<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="fa78b2c4ba732d90be891c20923a016c2ca06a59" translate="yes" xml:space="preserve">
          <source>If you don't care about leap seconds, use &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;NominalDiffTime&lt;/code&gt; for your clock calculations, and you'll be fine.</source>
          <target state="translated">Если вас не волнуют дополнительные секунды, используйте &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;NominalDiffTime&lt;/code&gt; для расчета часов, и все будет в порядке.</target>
        </trans-unit>
        <trans-unit id="91fa5b3759632ec86596531c30715d1630f054a4" translate="yes" xml:space="preserve">
          <source>If you don't care about ordering, consider use &lt;code&gt;Data.HashMap.Strict&lt;/code&gt; from the &lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;unordered-containers&lt;/a&gt; package instead.</source>
          <target state="translated">Если вас не волнует порядок, рассмотрите возможность использования &lt;code&gt;Data.HashMap.Strict&lt;/code&gt; из пакета &lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;неупорядоченных контейнеров&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="919994a6ad24d536810a2f90a16851626c53afe9" translate="yes" xml:space="preserve">
          <source>If you don't care about ordering, consider using &lt;code&gt;Data.HashMap.Lazy&lt;/code&gt; from the &lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;unordered-containers&lt;/a&gt; package instead.</source>
          <target state="translated">Если вас не волнует порядок, рассмотрите возможность использования &lt;code&gt;Data.HashMap.Lazy&lt;/code&gt; из пакета &lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;unordered-container&lt;/a&gt; вместо этого.</target>
        </trans-unit>
        <trans-unit id="fbad3655a306b0eed532c2a8565759cd003f86c6" translate="yes" xml:space="preserve">
          <source>If you don't use the &lt;code&gt;-threaded&lt;/code&gt; option, then the runtime does not make use of multiple OS threads. Foreign calls will block all other running Haskell threads until the call returns. The &lt;a href=&quot;system-io&quot;&gt;System.IO&lt;/a&gt; library still does multiplexing, so there can be multiple threads doing I/O, and this is handled internally by the runtime using &lt;code&gt;select&lt;/code&gt;.</source>
          <target state="translated">Если вы не используете параметр &lt;code&gt;-threaded&lt;/code&gt; , среда выполнения не использует несколько потоков ОС. Внешние вызовы будут блокировать все другие запущенные потоки Haskell, пока вызов не вернется. Библиотека &lt;a href=&quot;system-io&quot;&gt;System.IO по-&lt;/a&gt; прежнему выполняет мультиплексирование, поэтому может быть несколько потоков, выполняющих ввод-вывод, и это обрабатывается внутри среды выполнения с помощью &lt;code&gt;select&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="798faf56167bc1eadc054491085974ccd1b8e71f" translate="yes" xml:space="preserve">
          <source>If you fail to test the flag and use it although it is undefined, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; will throw an error.</source>
          <target state="translated">Если вы не сможете протестировать флаг и использовать его, хотя он не определен, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; выдаст ошибку.</target>
        </trans-unit>
        <trans-unit id="88f18162bea62ea91e089db538307585a73e927f" translate="yes" xml:space="preserve">
          <source>If you fail to test the flag and use it although it is undefined, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; will throw an error.</source>
          <target state="translated">Если вы не сможете протестировать флаг и использовать его, хотя он не определен, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; выдаст ошибку.</target>
        </trans-unit>
        <trans-unit id="181e16d814261217260a59c6eebf52bfe99f472f" translate="yes" xml:space="preserve">
          <source>If you fail to test the flag and use it although it is undefined, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; will throw an error.</source>
          <target state="translated">Если вы не сможете протестировать флаг и использовать его, хотя он не определен, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; выдаст ошибку.</target>
        </trans-unit>
        <trans-unit id="ead50587e0a0cdc543693c999e66d196c802d0fa" translate="yes" xml:space="preserve">
          <source>If you feel strongly that any of these restrictions are too onerous, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/MailingListsAndIRC&quot;&gt;please give the GHC team a shout&lt;/a&gt;.</source>
          <target state="translated">Если вы уверены, что какое-либо из этих ограничений слишком обременительно, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/MailingListsAndIRC&quot;&gt;пожалуйста&lt;/a&gt; , сообщите команде GHC .</target>
        </trans-unit>
        <trans-unit id="57825a77683045fd11cf61c7e2280d83f489c5c5" translate="yes" xml:space="preserve">
          <source>If you feel strongly that any of these restrictions are too onerous, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/mailing-lists-and-irc&quot;&gt;please give the GHC team a shout&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e72fd7c3e56cd41e50c2977a39a79818e565356" translate="yes" xml:space="preserve">
          <source>If you feel your code warrants modifying these settings please consult the source code for default values and documentation. But I strongly advise against this.</source>
          <target state="translated">Если вы считаете,что ваш код гарантирует изменение этих настроек,обратитесь к исходному коду для получения значений по умолчанию и документации.Но я настоятельно рекомендую не делать этого.</target>
        </trans-unit>
        <trans-unit id="12b8dd6cc517c8e6f32241fd0c8da26f585dc4a7" translate="yes" xml:space="preserve">
          <source>If you find cases of significant performance regressions, which can be traced back to obviously bad code layout please open a ticket.</source>
          <target state="translated">Если вы обнаружили случаи значительных регрессий производительности,которые могут быть прослежены до очевидно плохой компоновки кода,пожалуйста,откройте билет.</target>
        </trans-unit>
        <trans-unit id="eddd7a1b6ed2ec9f8ddbaa4b9719044314989fa0" translate="yes" xml:space="preserve">
          <source>If you forget the &lt;code&gt;-watch&lt;/code&gt; flag you can still select &amp;ldquo;Watch file&amp;rdquo; from the &amp;ldquo;State&amp;rdquo; menu. Now each time you generate a new profile &lt;code&gt;FOO.ps&lt;/code&gt; the view will update automatically.</source>
          <target state="translated">Если вы забыли флаг &lt;code&gt;-watch&lt;/code&gt; , вы все равно можете выбрать &amp;laquo;Смотреть файл&amp;raquo; в меню &amp;laquo;Состояние&amp;raquo;. Теперь каждый раз, когда вы создаете новый профиль &lt;code&gt;FOO.ps&lt;/code&gt; , вид будет обновляться автоматически.</target>
        </trans-unit>
        <trans-unit id="3b468bbdec19642d76f696af7811d40687e4a9c8" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;#unboxed-tuples&quot;&gt;unboxed tuples&lt;/a&gt; enabled, tuple sections will also be available for them, like so</source>
          <target state="translated">Если у вас включены &lt;a href=&quot;#unboxed-tuples&quot;&gt;распакованные кортежи&lt;/a&gt; , для них также будут доступны разделы кортежей , например</target>
        </trans-unit>
        <trans-unit id="f4a2a18f9fd122d9f155cead5fb45d6a3af3ea4b" translate="yes" xml:space="preserve">
          <source>If you have specific requirements about the encoding format, you can use the encoding and decoding primitives directly, see the modules &lt;a href=&quot;data-binary-get&quot;&gt;Data.Binary.Get&lt;/a&gt; and &lt;a href=&quot;data-binary-put&quot;&gt;Data.Binary.Put&lt;/a&gt;.</source>
          <target state="translated">Если у вас есть особые требования к формату кодирования, вы можете напрямую использовать примитивы кодирования и декодирования, см. Модули &lt;a href=&quot;data-binary-get&quot;&gt;Data.Binary.Get&lt;/a&gt; и &lt;a href=&quot;data-binary-put&quot;&gt;Data.Binary.Put&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fedbc3661026d144c58745e2aaa481b83a3bdcbc" translate="yes" xml:space="preserve">
          <source>If you have to use absolute paths (beware of the innocent-looking &lt;code&gt;ROOT=$(pwd)&lt;/code&gt; in makefile hierarchies or configure scripts), Cygwin provides a tool called &lt;code&gt;cygpath&lt;/code&gt; that can convert Cygwin&amp;rsquo;s Unix-style paths to their actual Windows-style counterparts. Many Cygwin tools actually accept absolute Windows-style paths (remember, though, that you either need to escape &lt;code&gt;\\&lt;/code&gt; or convert &lt;code&gt;\\&lt;/code&gt; to &lt;code&gt;/&lt;/code&gt;), so you should be fine just using those everywhere. If you need to use tools that do some kind of path-mangling that depends on unix-style paths (one fun example is trying to interpret &lt;code&gt;:&lt;/code&gt; as a separator in path lists), you can still try to convert paths using &lt;code&gt;cygpath&lt;/code&gt; just before they are passed to GHC and friends.</source>
          <target state="translated">Если вам нужно использовать абсолютные пути (остерегайтесь невинно выглядящего &lt;code&gt;ROOT=$(pwd)&lt;/code&gt; в иерархиях make-файлов или сценариев конфигурации), Cygwin предоставляет инструмент под названием &lt;code&gt;cygpath&lt;/code&gt; , который может преобразовывать пути Cygwin в стиле Unix в их фактические аналоги в стиле Windows. Многие инструменты Cygwin на самом деле принимают абсолютные пути в стиле Windows (однако помните, что вам нужно либо экранировать &lt;code&gt;\\&lt;/code&gt; , либо преобразовать &lt;code&gt;\\&lt;/code&gt; в &lt;code&gt;/&lt;/code&gt; ), поэтому вы должны быть в порядке, просто используя их везде. Если вам нужно использовать инструменты, которые выполняют какое-то изменение пути, которое зависит от путей в стиле unix (один забавный пример пытается интерпретировать &lt;code&gt;:&lt;/code&gt; как разделитель в списках путей), вы все равно можете попытаться преобразовать пути с помощью &lt;code&gt;cygpath&lt;/code&gt; непосредственно перед тем, как они будут переданы GHC и друзьям.</target>
        </trans-unit>
        <trans-unit id="4762767c31f000dd608b9d320e6a27ecd6749f85" translate="yes" xml:space="preserve">
          <source>If you have trouble because of running out of space in &lt;code&gt;/tmp&lt;/code&gt; (or wherever your installation thinks temporary files should go), you may use the &lt;a href=&quot;#ghc-flag--tmpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-tmpdir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; option option to specify an alternate directory. For example, &lt;code&gt;-tmpdir .&lt;/code&gt; says to put temporary files in the current working directory.</source>
          <target state="translated">Если у вас возникли проблемы из-за нехватки места в &lt;code&gt;/tmp&lt;/code&gt; (или там, где, по вашему мнению, должны располагаться временные файлы), вы можете использовать &lt;a href=&quot;#ghc-flag--tmpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-tmpdir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; option, чтобы указать альтернативный каталог. Например, &lt;code&gt;-tmpdir .&lt;/code&gt; говорит, что нужно поместить временные файлы в текущий рабочий каталог.</target>
        </trans-unit>
        <trans-unit id="a0263efca84aff634e475d876d93d1d53987bcc2" translate="yes" xml:space="preserve">
          <source>If you know in advance that you will be working with data that has a specific encoding (e.g. UTF-8), and your application is highly performance sensitive, you may find that it is faster to perform I/O with bytestrings and to encode and decode yourself than to use the functions in this module.</source>
          <target state="translated">Если вы заранее знаете,что будете работать с данными,которые имеют определенную кодировку (например,UTF-8),и ваше приложение очень чувствительно к производительности,вы можете обнаружить,что быстрее выполнять ввод/вывод с помощью байтстрингов,а также кодировать и декодировать самостоятельно,чем использовать функции в этом модуле.</target>
        </trans-unit>
        <trans-unit id="9980c81f41f8848255c9b3c4f5b6f35d26a2660e" translate="yes" xml:space="preserve">
          <source>If you locally define a signature which specifies &lt;code&gt;type Elem = Char&lt;/code&gt;, you can now use &lt;code&gt;head&lt;/code&gt; from the inherited signature as if it returned a &lt;code&gt;Char&lt;/code&gt;.</source>
          <target state="translated">Если вы локально определяете подпись, которая определяет &lt;code&gt;type Elem = Char&lt;/code&gt; , теперь вы можете использовать &lt;code&gt;head&lt;/code&gt; из унаследованной подписи, как если бы она вернула &lt;code&gt;Char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99a2b1931884bf135bea0a3fa27795d553e75cd2" translate="yes" xml:space="preserve">
          <source>If you make some changes to the source code and want GHCi to recompile the program, give the &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; command. The program will be recompiled as necessary, with GHCi doing its best to avoid actually recompiling modules if their external dependencies haven&amp;rsquo;t changed. This is the same mechanism we use to avoid re-compiling modules in the batch compilation setting (see &lt;a href=&quot;separate_compilation#recomp&quot;&gt;The recompilation checker&lt;/a&gt;).</source>
          <target state="translated">Если вы вносите некоторые изменения в исходный код и хотите, чтобы GHCi перекомпилировал программу, введите команду &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; . При необходимости программа будет перекомпилирована, при этом GHCi сделает все возможное, чтобы избежать фактической перекомпиляции модулей, если их внешние зависимости не изменились. Это тот же самый механизм, который мы используем, чтобы избежать повторной компиляции модулей в настройке пакетной компиляции (см &lt;a href=&quot;separate_compilation#recomp&quot;&gt;. Проверка перекомпиляции&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8d9454e1d6cb0edc697a136b26feb4f14fca0245" translate="yes" xml:space="preserve">
          <source>If you must use a non-UTF-8 locale on an older version of GHC, you will have to perform the transcoding yourself, e.g. as follows:</source>
          <target state="translated">Если вы должны использовать неUTF-8 локаль на более старой версии GHC,вам придется выполнить транскодирование самостоятельно,например,следующим образом:</target>
        </trans-unit>
        <trans-unit id="c0177890eaf8c9853290382c679f931e99463619" translate="yes" xml:space="preserve">
          <source>If you need to break a string by a substring repeatedly (e.g. you want to break on every instance of a substring), use &lt;code&gt;&lt;a href=&quot;data-text#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; instead, as it has lower startup overhead.</source>
          <target state="translated">Если вам нужно многократно разбивать строку на подстроку (например, вы хотите разбивать каждый экземпляр подстроки), используйте вместо этого &lt;code&gt;&lt;a href=&quot;data-text#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; , так как это снижает накладные расходы на запуск.</target>
        </trans-unit>
        <trans-unit id="ba1d6d4a81148f3b4501f77ab4535df2eb1411a3" translate="yes" xml:space="preserve">
          <source>If you need to break a string by a substring repeatedly (e.g. you want to break on every instance of a substring), use &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; instead, as it has lower startup overhead.</source>
          <target state="translated">Если вам нужно многократно разбивать строку на подстроку (например, вы хотите разбивать каждый экземпляр подстроки), используйте вместо этого &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; , так как это снижает накладные расходы на запуск.</target>
        </trans-unit>
        <trans-unit id="60305b59f145cbe3c8640c6266d72f000c109cde" translate="yes" xml:space="preserve">
          <source>If you need to unmask asynchronous exceptions again in the exception handler, &lt;code&gt;restore&lt;/code&gt; can be used there too.</source>
          <target state="translated">Если вам нужно снова демаскировать асинхронные исключения в обработчике исключений, &lt;code&gt;restore&lt;/code&gt; можно использовать и там.</target>
        </trans-unit>
        <trans-unit id="4591e0c74e5d8610c0f46b0b70574c886adac838" translate="yes" xml:space="preserve">
          <source>If you need to write your own builder primitives, then be aware that you are writing code with &lt;em&gt;all saftey belts off&lt;/em&gt;; i.e., *this is the code that might make your application vulnerable to buffer-overflow attacks!* The &lt;a href=&quot;data-bytestring-builder-prim-tests&quot;&gt;Data.ByteString.Builder.Prim.Tests&lt;/a&gt; module provides you with utilities for testing your encodings thoroughly.</source>
          <target state="translated">Если вам нужно написать свои собственные примитивы построителя, то имейте в &lt;em&gt;виду,&lt;/em&gt; что вы пишете код со &lt;em&gt;снятыми поясами безопасности&lt;/em&gt; ; т.е. * это код, который может сделать ваше приложение уязвимым для атак с переполнением буфера! * Модуль &lt;a href=&quot;data-bytestring-builder-prim-tests&quot;&gt;Data.ByteString.Builder.Prim.Tests&lt;/a&gt; предоставляет вам утилиты для тщательного тестирования ваших кодировок.</target>
        </trans-unit>
        <trans-unit id="85034b2140ed46e219a17c0fb6a82d6555ea6a0b" translate="yes" xml:space="preserve">
          <source>If you redirect the interface file somewhere that GHC can&amp;rsquo;t find it, then the recompilation checker may get confused (at the least, you won&amp;rsquo;t get any recompilation avoidance). We recommend using a combination of &lt;code&gt;-hidir&lt;/code&gt; and &lt;code&gt;-hisuf&lt;/code&gt; options instead, if possible.</source>
          <target state="translated">Если вы перенаправляете интерфейсный файл куда-то, что GHC не может его найти, тогда программа проверки перекомпиляции может запутаться (по крайней мере, вы не получите никакого предотвращения перекомпиляции). Мы рекомендуем вместо этого использовать комбинацию параметров &lt;code&gt;-hidir&lt;/code&gt; и &lt;code&gt;-hisuf&lt;/code&gt; , если это возможно.</target>
        </trans-unit>
        <trans-unit id="7c56d9c704da4ef4488b84c4ca979cb6f42ee172" translate="yes" xml:space="preserve">
          <source>If you run GHCi in a Cygwin or MSYS shell, then the Control-C behaviour is adversely affected. In one of these environments you should use the &lt;code&gt;ghcii.sh&lt;/code&gt; script to start GHCi, otherwise when you hit Control-C you&amp;rsquo;ll be returned to the shell prompt but the GHCi process will still be running. However, even using the &lt;code&gt;ghcii.sh&lt;/code&gt; script, if you hit Control-C then the GHCi process will be killed immediately, rather than letting you interrupt a running program inside GHCi as it should. This problem is caused by the fact that the Cygwin and MSYS shell environments don&amp;rsquo;t pass Control-C events to non-Cygwin child processes, because in order to do that there needs to be a Windows console.</source>
          <target state="translated">Если вы запускаете GHCi в оболочке Cygwin или MSYS, это отрицательно влияет на поведение Control-C. В одной из этих сред вы должны использовать сценарий &lt;code&gt;ghcii.sh&lt;/code&gt; для запуска GHCi, в противном случае, когда вы нажмете Control-C, вы вернетесь в приглашение оболочки, но процесс GHCi все равно будет работать. Однако даже при использовании сценария &lt;code&gt;ghcii.sh&lt;/code&gt; , если вы нажмете Control-C, процесс GHCi будет немедленно остановлен , вместо того, чтобы позволить вам прервать выполняющуюся программу внутри GHCi, как следует. Эта проблема вызвана тем, что среды оболочки Cygwin и MSYS не передают события Control-C дочерним процессам, не относящимся к Cygwin, потому что для этого должна быть консоль Windows.</target>
        </trans-unit>
        <trans-unit id="baf4b7d8b90c0aee801d209afdb87b81f931a2c9" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; flag appropriately when linking (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), you can give RTS options on the command line when running your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="499bbb66890db92d2aef64ba55e59fe5e3a4a579" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; flag appropriately when linking (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), you can give RTS options on the command line when running your program.</source>
          <target state="translated">Если вы &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; установите флаг -rtsopts [= ⟨none | some | all⟩] при связывании (см. &lt;a href=&quot;phases#options-linker&quot;&gt;Параметры, влияющие на связывание&lt;/a&gt; ), вы можете указать параметры RTS в командной строке при запуске вашей программы.</target>
        </trans-unit>
        <trans-unit id="779ae353821cb3c36339c8fffc8e4e1da51bc948" translate="yes" xml:space="preserve">
          <source>If you specify the optional &amp;ldquo;&lt;code&gt;!&lt;/code&gt;&amp;rdquo;, GHC will in addition normalise the type by expanding out type synonyms and evaluating type-function applications, and display the normalised result.</source>
          <target state="translated">Если вы укажете необязательный &amp;laquo; &lt;code&gt;!&lt;/code&gt; &amp;rdquo;, GHC дополнительно нормализует тип, расширяя синонимы типов и оценивая приложения типа-функции, и отображает нормализованный результат.</target>
        </trans-unit>
        <trans-unit id="17573b39128b09ddb274fe402c07a3712fa0b038" translate="yes" xml:space="preserve">
          <source>If you started up GHCi from the command line then GHCi&amp;rsquo;s current directory is the same as the current directory of the shell from which it was started. If you started GHCi from the &amp;ldquo;Start&amp;rdquo; menu in Windows, then the current directory is probably something like &lt;code&gt;C:\Documents and Settings\user name&lt;/code&gt;.</source>
          <target state="translated">Если вы запустили GHCi из командной строки, то текущий каталог GHCi совпадает с текущим каталогом оболочки, из которой он был запущен. Если вы запустили GHCi из меню &amp;laquo;Пуск&amp;raquo; в Windows, то текущий каталог, вероятно, будет чем-то вроде &lt;code&gt;C:\Documents and Settings\user name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba902f4235b03731027db2ba203807d60051b0f0" translate="yes" xml:space="preserve">
          <source>If you still have a problem after consulting this section, then you may have found a &lt;em&gt;bug&lt;/em&gt;&amp;mdash;please report it! See &lt;a href=&quot;intro#bug-reporting&quot;&gt;Reporting bugs in GHC&lt;/a&gt; for details on how to report a bug and a list of things we&amp;rsquo;d like to know about your bug. If in doubt, send a report &amp;mdash; we love mail from irate users :-!</source>
          <target state="translated">Если после просмотра этого раздела у вас все еще есть проблема, возможно, вы нашли &lt;em&gt;ошибку -&lt;/em&gt; сообщите об этом! См. &amp;laquo; &lt;a href=&quot;intro#bug-reporting&quot;&gt;Сообщение об ошибках в GHC&amp;raquo;&lt;/a&gt; для получения подробной информации о том, как сообщить об ошибке, и список того, что мы хотели бы знать о вашей ошибке. Если сомневаетесь, отправьте отчет - мы любим письма от разгневанных пользователей: -!</target>
        </trans-unit>
        <trans-unit id="bb6e307b2815d284d219246f3cc396f72341fb96" translate="yes" xml:space="preserve">
          <source>If you supply &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt;, you should ensure that:</source>
          <target state="translated">Если вы поставляете &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; , вы должны убедиться, что:</target>
        </trans-unit>
        <trans-unit id="f9036a091eb31d7e1d179225efb47ed576aaf8c2" translate="yes" xml:space="preserve">
          <source>If you supply &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:second&quot;&gt;second&lt;/a&gt;&lt;/code&gt;, ensure:</source>
          <target state="translated">Если вы поставляете &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:second&quot;&gt;second&lt;/a&gt;&lt;/code&gt; , убедитесь:</target>
        </trans-unit>
        <trans-unit id="43deefe8a45aff4b957628597a98f2d9c624d164" translate="yes" xml:space="preserve">
          <source>If you supply both, you should also ensure:</source>
          <target state="translated">Если вы поставляете и то,и другое,вы также должны убедиться:</target>
        </trans-unit>
        <trans-unit id="e7ad27dbd268005c25e921cdbe065308694238cd" translate="yes" xml:space="preserve">
          <source>If you think of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value as an array of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values (which it is not), you run the risk of writing inefficient code.</source>
          <target state="translated">Если вы думаете о &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; значении как о массиве значений &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; (а это не так), вы рискуете написать неэффективный код.</target>
        </trans-unit>
        <trans-unit id="3de2aa2ed3ef394e6e0d1016569003785b8ad818" translate="yes" xml:space="preserve">
          <source>If you think that GHC could have produced a better error message, please report it as a bug.</source>
          <target state="translated">Если вы думаете,что GHC мог выдать сообщение об ошибке получше,пожалуйста,сообщите об этом как об ошибке.</target>
        </trans-unit>
        <trans-unit id="c7f6f86d2972b585d04fe43fdaef1e7b40cc4531" translate="yes" xml:space="preserve">
          <source>If you turn on the &lt;code&gt;+t&lt;/code&gt; option, GHCi will show the type of each variable bound by a statement. For example:</source>
          <target state="translated">Если вы включите опцию &lt;code&gt;+t&lt;/code&gt; , GHCi покажет тип каждой переменной, связанной с оператором. Например:</target>
        </trans-unit>
        <trans-unit id="5833a6633f41ece1646113439cfc7147d21b2d27" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;ghc --make&lt;/code&gt; and you don&amp;rsquo;t use the &lt;code&gt;-o&lt;/code&gt;, the name GHC will choose for the executable will be based on the name of the file containing the module &lt;code&gt;Main&lt;/code&gt;. Note that with GHC the &lt;code&gt;Main&lt;/code&gt; module doesn&amp;rsquo;t have to be put in file &lt;code&gt;Main.hs&lt;/code&gt;. Thus both</source>
          <target state="translated">Если вы используете &lt;code&gt;ghc --make&lt;/code&gt; и не используете &lt;code&gt;-o&lt;/code&gt; , имя, которое GHC выберет для исполняемого файла, будет основано на имени файла, содержащего модуль &lt;code&gt;Main&lt;/code&gt; . Обратите внимание , что с GHC &lt;code&gt;Main&lt;/code&gt; модуль не должен быть помещен в файл &lt;code&gt;Main.hs&lt;/code&gt; . Таким образом, оба</target>
        </trans-unit>
        <trans-unit id="b8fe07ab672e6ec151ea93a6073a6731a1a39a86" translate="yes" xml:space="preserve">
          <source>If you use the &lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt;&lt;code&gt;-Wmissing-local-signatures&lt;/code&gt;&lt;/a&gt; flag GHC will warn you about any polymorphic local bindings. As part of the warning GHC also reports the inferred type. The option is off by default.</source>
          <target state="translated">Если вы используете &lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt; &lt;code&gt;-Wmissing-local-signatures&lt;/code&gt; &lt;/a&gt; GHC предупредит вас о любых полиморфных локальных привязках. В рамках предупреждения GHC также сообщает предполагаемый тип. По умолчанию опция выключена.</target>
        </trans-unit>
        <trans-unit id="d28c5895543f69e7126cf50a6926f46b942709ca" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-T&lt;/code&gt; flag then, you should access the statistics using &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-stats&quot;&gt;GHC.Stats&lt;/a&gt;.</source>
          <target state="translated">Если вы используете флаг &lt;code&gt;-T&lt;/code&gt; , вы должны получить доступ к статистике с помощью &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-stats&quot;&gt;GHC.Stats&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b229e3d5ff9a118b7d23643c61f72dbd7947f474" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-T&lt;/code&gt; flag then, you should access the statistics using &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-stats&quot;&gt;GHC.Stats&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5a15f9c3c8b55e5de03f7f69c8dd111c9672ec" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-s&lt;/code&gt; flag then, when your program finishes, you will see something like this (the exact details will vary depending on what sort of RTS you have, e.g. you will only see profiling data if your RTS is compiled for profiling):</source>
          <target state="translated">Если вы используете флаг &lt;code&gt;-s&lt;/code&gt; , то, когда ваша программа завершится, вы увидите что-то вроде этого (точные детали будут зависеть от того, какой у вас RTS, например, вы увидите данные профилирования, только если ваш RTS скомпилирован для профилирования) :</target>
        </trans-unit>
        <trans-unit id="b228a004af7cc3ea3defaec36492a49b21092145" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-t&lt;/code&gt; flag then, when your program finishes, you will see something like this:</source>
          <target state="translated">Если вы используете флаг &lt;code&gt;-t&lt;/code&gt; , то по завершении вашей программы вы увидите что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="42843f480d669d0dd71c1f456d85a83006a59f62" translate="yes" xml:space="preserve">
          <source>If you use the flag &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Worphans&lt;/code&gt;&lt;/a&gt;, GHC will warn you if you are creating an orphan module. Like any warning, you can switch the warning off with &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Wno-orphans&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; will make the compilation fail if the warning is issued.</source>
          <target state="translated">Если вы используете флаг &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt; &lt;code&gt;-Worphans&lt;/code&gt; &lt;/a&gt; , GHC предупредит вас, если вы создаете сиротский модуль. Как и любое &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt; &lt;code&gt;-Wno-orphans&lt;/code&gt; &lt;/a&gt; предупреждение, вы можете отключить предупреждение с помощью -Wno-orphans , и &lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt; приведет к сбою компиляции, если предупреждение будет выдано.</target>
        </trans-unit>
        <trans-unit id="5c0d6aaecc809c7a412ba9777573bc108e4291b9" translate="yes" xml:space="preserve">
          <source>If you use the flag &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Worphans&lt;/code&gt;&lt;/a&gt;, GHC will warn you if you are creating an orphan module. Like any warning, you can switch the warning off with &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Wno-orphans&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;using-warnings#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; will make the compilation fail if the warning is issued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3539d052ca8f3d12bdfa6a2cf6c42e142aedfd6e" translate="yes" xml:space="preserve">
          <source>If you want a RULE that truly applies to the overloaded class method, the only way to do it is like this:</source>
          <target state="translated">Если вам нужно ПРАВИЛО,которое действительно применимо к перегруженному методу класса,то единственный способ сделать это-это сделать так:</target>
        </trans-unit>
        <trans-unit id="cc687a75092e5bd8f51f4c5f01b8880c77b9787b" translate="yes" xml:space="preserve">
          <source>If you want impredicative polymorphism, the main workaround is to use a newtype wrapper. The &lt;code&gt;id runST&lt;/code&gt; example can be written using this workaround like this:</source>
          <target state="translated">Если вам нужен непредсказуемый полиморфизм, основной обходной путь - использовать оболочку newtype. &lt;code&gt;id runST&lt;/code&gt; пример можно записать с помощью этого метода обхода , как это:</target>
        </trans-unit>
        <trans-unit id="51a0b4a5af5e77d81a82bb08f150b3da8ce734c3" translate="yes" xml:space="preserve">
          <source>If you want line-buffered behaviour, as in GHC, you can start your program thus:</source>
          <target state="translated">Если вы хотите,чтобы линейное буферизованное поведение,как в GHC,вы можете запустить свою программу таким образом:</target>
        </trans-unit>
        <trans-unit id="8ca971e710dc0dea81074a50ffdb031c934cf7b8" translate="yes" xml:space="preserve">
          <source>If you want the latter type, you can write your &lt;code&gt;forall&lt;/code&gt;s explicitly. Indeed, doing so is strongly advised for rank-2 types.</source>
          <target state="translated">Если вам нужен последний тип, вы можете явно написать свой &lt;code&gt;forall&lt;/code&gt; . Действительно, это настоятельно рекомендуется для типов ранга 2.</target>
        </trans-unit>
        <trans-unit id="549a9b63d55271a3b9df4de32eb523229040185b" translate="yes" xml:space="preserve">
          <source>If you want the program to wait for child threads to finish before exiting, you need to program this yourself. A simple mechanism is to have each child thread write to an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; when it completes, and have the main thread wait on all the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s before exiting:</source>
          <target state="translated">Если вы хотите, чтобы программа ожидала завершения дочерних потоков перед завершением, вам нужно запрограммировать это самостоятельно. Простой механизм состоит в том, чтобы каждый дочерний поток записывал в &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; по завершении, а основной поток &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; всех MVar перед выходом:</target>
        </trans-unit>
        <trans-unit id="0f9571a9dcbff8738c6a55f4c7676d668b8f5fc0" translate="yes" xml:space="preserve">
          <source>If you want to also pass some data back from the C callback to Haskell, this is best done by first allocating some memory in Haskell to receive the data, and passing the address to C, as we did in the above example.</source>
          <target state="translated">Если вы хотите также передать некоторые данные обратно из C callback в Haskell,это лучше всего сделать,сначала выделив некоторое количество памяти в Haskell для получения данных,и передав адрес на C,как мы делали это в вышеприведенном примере.</target>
        </trans-unit>
        <trans-unit id="f34429256ffca9baa1e5bbc692ae867402400276" translate="yes" xml:space="preserve">
          <source>If you want to create hard link by Windows way, use &lt;code&gt;&lt;a href=&quot;system-win32-hardlink#v:createHardLink-39-&quot;&gt;createHardLink'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Если вы хотите создать жесткую ссылку с помощью Windows, используйте вместо этого &lt;code&gt;&lt;a href=&quot;system-win32-hardlink#v:createHardLink-39-&quot;&gt;createHardLink'&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="791c272c3172b5ca90ccf11219abe251062c8501" translate="yes" xml:space="preserve">
          <source>If you want to create symbolic link by Windows way, use &lt;code&gt;&lt;a href=&quot;system-win32-symboliclink#v:createSymbolicLink-39-&quot;&gt;createSymbolicLink'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Если вы хотите создать символическую ссылку способом Windows, используйте вместо этого &lt;code&gt;&lt;a href=&quot;system-win32-symboliclink#v:createSymbolicLink-39-&quot;&gt;createSymbolicLink'&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3df7bf8a33fccc5739143bc2735696e4c097cb3" translate="yes" xml:space="preserve">
          <source>If you want to do some cleanup in the event that an exception is raised, use &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите выполнить некоторую очистку в случае возникновения исключения, используйте &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c4838ba039983c15a539bfb6ca822e21c42138c" translate="yes" xml:space="preserve">
          <source>If you want to do the steps manually or are writing your own build system then there are certain conventions that must be followed. Building a shared library that exports Haskell code, to be used by other Haskell code is a bit more complicated than it is for one that exports a C API and will be used by C code. If you get it wrong you will usually end up with linker errors.</source>
          <target state="translated">Если вы хотите выполнить эти шаги вручную или пишите свою собственную систему сборки,то существуют определённые соглашения,которым необходимо следовать.Сборка общей библиотеки,экспортирующей код Haskell,для использования другим кодом Haskell немного сложнее,чем для экспортирующего C API и используемого C-кодом.Если вы ошибетесь,то,как правило,это приведет к ошибкам компоновщика.</target>
        </trans-unit>
        <trans-unit id="f0fb26a20e253d10479d39da2a4fcad468dce057" translate="yes" xml:space="preserve">
          <source>If you want to give a cost centre different name than the function name, you can pass a string to the annotation</source>
          <target state="translated">Если вы хотите дать центру затрат имя,отличное от имени функции,вы можете передать строку в аннотацию</target>
        </trans-unit>
        <trans-unit id="7c4f1ffc646261bf14798c8c4f8089e635cc58af" translate="yes" xml:space="preserve">
          <source>If you want to make use of assertions in your standard Haskell code, you could define a function like the following:</source>
          <target state="translated">Если вы хотите использовать утверждения в вашем стандартном коде Haskell,вы можете определить функцию,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="6f423384a233b13b91f89809f16b0b043668524f" translate="yes" xml:space="preserve">
          <source>If you want to mention any of the primitive data types or operations in your program, you must first import &lt;code&gt;GHC.Prim&lt;/code&gt; to bring them into scope. Many of them have names ending in &lt;code&gt;#&lt;/code&gt;, and to mention such names you need the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">Если вы хотите упомянуть какой-либо из примитивных типов данных или операций в вашей программе, вы должны сначала импортировать &lt;code&gt;GHC.Prim&lt;/code&gt; , чтобы ввести их в область видимости. Многие из них имеют имена, оканчивающиеся на &lt;code&gt;#&lt;/code&gt; , и чтобы упомянуть такие имена, вам понадобится расширение &lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61014e31e4e9b046a9ef2fe3074becc72ef93381" translate="yes" xml:space="preserve">
          <source>If you want to opt out of all preprocessing just expliticly use namespaces in your paths. Due to this change, if you need to open raw devices (e.g. COM ports) you need to use the device namespace explicitly. (e.g. &lt;code&gt;\\.\COM1&lt;/code&gt;). GHC and Haskell programs in general no longer support opening devices in the legacy format.</source>
          <target state="translated">Если вы хотите отказаться от предварительной обработки, просто явно используйте пространства имен в своих путях. Из-за этого изменения, если вам нужно открыть необработанные устройства (например, COM-порты), вам нужно явно использовать пространство имен устройства. (например, &lt;code&gt;\\.\COM1&lt;/code&gt; ). Программы GHC и Haskell в целом больше не поддерживают открытие устройств в устаревшем формате.</target>
        </trans-unit>
        <trans-unit id="6ebcdc956ed871c44f4c6bca024bf09987c0e4ea" translate="yes" xml:space="preserve">
          <source>If you want to reexport an entity from a signature, you must also include a &lt;code&gt;module SigName&lt;/code&gt; export, so that all of the entities defined in the signature are exported. For example, the following module exports both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; from &lt;code&gt;Prelude&lt;/code&gt;:</source>
          <target state="translated">Если вы хотите повторно экспортировать объект из подписи, вы должны также включить &lt;code&gt;module SigName&lt;/code&gt; экспорта SigName , чтобы все объекты, определенные в подписи, были экспортированы. Например, следующий модуль экспортирует как &lt;code&gt;f&lt;/code&gt; ,так и &lt;code&gt;Int&lt;/code&gt; из &lt;code&gt;Prelude&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0a5bd52fcd4928ca0545145bd2a955f15998cd35" translate="yes" xml:space="preserve">
          <source>If you want to use it afterwards, ensure that you &lt;code&gt;&lt;a href=&quot;data-array-storable#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; after the last use of the pointer, so the array is not freed too early.</source>
          <target state="translated">Если вы хотите использовать его позже, убедитесь, что вы &lt;code&gt;&lt;a href=&quot;data-array-storable#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; после последнего использования указателя, чтобы массив не был освобожден слишком рано.</target>
        </trans-unit>
        <trans-unit id="2bf3e986051a32ecf5c1ec7e4a43659b77ba4029" translate="yes" xml:space="preserve">
          <source>If you want to use it afterwards, ensure that you &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; after the last use of the pointer, so the array is not freed too early.</source>
          <target state="translated">Если вы хотите использовать его позже, убедитесь, что вы &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; после последнего использования указателя, чтобы массив не был освобожден слишком рано.</target>
        </trans-unit>
        <trans-unit id="f60cbafbc7fa66b6dc79d12e60e2984d79a1c2f8" translate="yes" xml:space="preserve">
          <source>If you want to write your own good consumers or producers, look at the Prelude definitions of the above functions to see how to do so.</source>
          <target state="translated">Если вы хотите написать свои собственные хорошие потребители или производители,посмотрите на определения Прелюдии вышеперечисленных функций,чтобы понять,как это сделать.</target>
        </trans-unit>
        <trans-unit id="cc3353ab3b67d47aa44c20e1d16cbe4a8241b654" translate="yes" xml:space="preserve">
          <source>If you would like GHC to check that every exported top-level function/value has a type signature, but not check unexported values, use the &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt;&lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt;&lt;/a&gt; option. This option takes precedence over &lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt;&lt;code&gt;-Wmissing-signatures&lt;/code&gt;&lt;/a&gt;. As part of the warning GHC also reports the inferred type. The option is off by default.</source>
          <target state="translated">Если вы хотите, чтобы GHC проверял, что каждая экспортируемая функция / значение верхнего уровня имеет сигнатуру типа, но не проверял неэкспортированные значения, используйте параметр &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt; &lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt; &lt;/a&gt; . Эта опция имеет приоритет над &lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt; &lt;code&gt;-Wmissing-signatures&lt;/code&gt; &lt;/a&gt; . В рамках предупреждения GHC также сообщает предполагаемый тип. По умолчанию опция выключена.</target>
        </trans-unit>
        <trans-unit id="fb30d07648b8cbbd10ad61170b84d1c688b54b88" translate="yes" xml:space="preserve">
          <source>If you would like GHC to check that every pattern synonym has a type signature, use the &lt;a href=&quot;#ghc-flag--Wmissing-pattern-synonym-signatures&quot;&gt;&lt;code&gt;-Wmissing-pattern-synonym-signatures&lt;/code&gt;&lt;/a&gt; option. If this option is used in conjunction with &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt;&lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt;&lt;/a&gt; then only exported pattern synonyms must have a type signature. GHC also reports the inferred type. This option is off by default.</source>
          <target state="translated">Если вы хотите, чтобы GHC проверял, что каждый синоним шаблона имеет сигнатуру типа, используйте параметр &lt;a href=&quot;#ghc-flag--Wmissing-pattern-synonym-signatures&quot;&gt; &lt;code&gt;-Wmissing-pattern-synonym-signatures&lt;/code&gt; &lt;/a&gt; . Если эта опция используется вместе с &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt; &lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt; ,&lt;/a&gt; тогда только экспортированные синонимы шаблона должны иметь сигнатуру типа. GHC также сообщает о предполагаемом типе. По умолчанию этот параметр отключен.</target>
        </trans-unit>
        <trans-unit id="640d34ea6f4536c99e1408cd399b64374ccf19de" translate="yes" xml:space="preserve">
          <source>If you would like GHC to check that every top-level function/value has a type signature, use the &lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt;&lt;code&gt;-Wmissing-signatures&lt;/code&gt;&lt;/a&gt; option. As part of the warning GHC also reports the inferred type. The option is off by default.</source>
          <target state="translated">Если вы хотите, чтобы GHC проверял, что каждая функция / значение верхнего уровня имеет сигнатуру типа, используйте параметр &lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt; &lt;code&gt;-Wmissing-signatures&lt;/code&gt; &lt;/a&gt; . В рамках предупреждения GHC также сообщает предполагаемый тип. По умолчанию опция выключена.</target>
        </trans-unit>
        <trans-unit id="922fe94f618cace70dccf3e7c465abb01606e0ff" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re feeling really paranoid, the &lt;a href=&quot;debugging#ghc-flag--dcore-lint&quot;&gt;&lt;code&gt;-dcore-lint&lt;/code&gt;&lt;/a&gt; option is a good choice. It turns on heavyweight intra-pass sanity-checking within GHC. (It checks GHC&amp;rsquo;s sanity, not yours.)</source>
          <target state="translated">Если вы чувствуете себя действительно параноиком, вариант &lt;a href=&quot;debugging#ghc-flag--dcore-lint&quot;&gt; &lt;code&gt;-dcore-lint&lt;/code&gt; &lt;/a&gt; - хороший выбор. Он включает тяжелую внутрипроходную проверку работоспособности в GHC. (Он проверяет вменяемость GHC, а не вашего.)</target>
        </trans-unit>
        <trans-unit id="2a661b6665d9019ecdcc937c98f6c881af1386b5" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;code&gt;Complex&lt;/code&gt;, definitely use &lt;code&gt;Complex Double&lt;/code&gt; rather than &lt;code&gt;Complex Float&lt;/code&gt; (the former is specialised heavily, but the latter isn&amp;rsquo;t).</source>
          <target state="translated">Если вы используете &lt;code&gt;Complex&lt;/code&gt; , определенно используйте &lt;code&gt;Complex Double&lt;/code&gt; , а не &lt;code&gt;Complex Float&lt;/code&gt; (первый сильно специализирован, а второй - нет).</target>
        </trans-unit>
        <trans-unit id="6ea05e3cdd60f132f915750383a0d35497a9912f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Cabal, then the exposed or hidden status of a package is irrelevant: the available packages are instead determined by the dependencies listed in your &lt;code&gt;.cabal&lt;/code&gt; specification. The exposed/hidden status of packages is only relevant when using &lt;code&gt;ghc&lt;/code&gt; or &lt;code&gt;ghci&lt;/code&gt; directly.</source>
          <target state="translated">Если вы используете Cabal, то открытый или скрытый статус пакета не имеет значения: доступные пакеты вместо этого определяются зависимостями, перечисленными в вашей спецификации &lt;code&gt;.cabal&lt;/code&gt; . Открытый / скрытый статус пакетов актуален только при &lt;code&gt;ghci&lt;/code&gt; использовании &lt;code&gt;ghc&lt;/code&gt; или ghci .</target>
        </trans-unit>
        <trans-unit id="d0881127c805c94fe0b7925eea21f4274da0ef78" translate="yes" xml:space="preserve">
          <source>If you'd like to be able to set environment variables to blank strings, use &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите иметь возможность устанавливать переменные среды в пустые строки, используйте &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99dd4325947ff2bc013e316ae08d0a505ef5df45" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;GHC.Generics&lt;/code&gt;, you should consider using the &lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;http://hackage.haskell.org/package/generic-deriving&lt;/a&gt; package, which contains many useful generic functions.</source>
          <target state="translated">Если вы используете &lt;code&gt;GHC.Generics&lt;/code&gt; , вам следует рассмотреть возможность использования пакета &lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;http://hackage.haskell.org/package/generic-deriving&lt;/a&gt; , который содержит множество полезных общих функций.</target>
        </trans-unit>
        <trans-unit id="cf81c24bf66e4ccd3de419acbb16c71960559688" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; is also &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;, a popular definition is</source>
          <target state="translated">Если ваша &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; также является &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; , популярным определением будет</target>
        </trans-unit>
        <trans-unit id="9b9d738102f8d206b5388e75296045ea1b95c56d" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; is also &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;, a popular definition is</source>
          <target state="translated">Если ваша &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; также является &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; , популярным определением будет</target>
        </trans-unit>
        <trans-unit id="94332bc18cf68bdf173c4385ef20100acbd02982" translate="yes" xml:space="preserve">
          <source>If your datatype has a single constructor with a single field, use a &lt;code&gt;newtype&lt;/code&gt; declaration instead of a &lt;code&gt;data&lt;/code&gt; declaration. The &lt;code&gt;newtype&lt;/code&gt; will be optimised away in most cases.</source>
          <target state="translated">Если ваш тип данных имеет единственный конструктор с одним полем, используйте объявление &lt;code&gt;newtype&lt;/code&gt; вместо объявления &lt;code&gt;data&lt;/code&gt; . В большинстве случаев &lt;code&gt;newtype&lt;/code&gt; будет оптимизирован.</target>
        </trans-unit>
        <trans-unit id="1c1b5c441eca4c4d33097e3b6efbf4299541fa8b" translate="yes" xml:space="preserve">
          <source>If your program contains multiple modules, then you only need to tell GHC the name of the source file containing the &lt;code&gt;Main&lt;/code&gt; module, and GHC will examine the &lt;code&gt;import&lt;/code&gt; declarations to find the other modules that make up the program and find their source files. This means that, with the exception of the &lt;code&gt;Main&lt;/code&gt; module, every source file should be named after the module name that it contains (with dots replaced by directory separators). For example, the module &lt;code&gt;Data.Person&lt;/code&gt; would be in the file &lt;code&gt;Data/Person.hs&lt;/code&gt; on Unix/Linux/Mac, or &lt;code&gt;Data\Person.hs&lt;/code&gt; on Windows.</source>
          <target state="translated">Если ваша программа содержит несколько модулей, вам нужно только сообщить GHC имя исходного файла, содержащего &lt;code&gt;Main&lt;/code&gt; модуль, и GHC проверит объявления &lt;code&gt;import&lt;/code&gt; чтобы найти другие модули, составляющие программу, и найти их исходные файлы. Это означает, что, за исключением &lt;code&gt;Main&lt;/code&gt; модуля, каждый исходный файл должен быть назван в честь имени модуля, который он содержит (с точками, замененными разделителями каталогов). Например, модуль &lt;code&gt;Data.Person&lt;/code&gt; будет в файле &lt;code&gt;Data/Person.hs&lt;/code&gt; в Unix / Linux / Mac или &lt;code&gt;Data\Person.hs&lt;/code&gt; в Windows.</target>
        </trans-unit>
        <trans-unit id="12c51f85806fd47c9dd60cc6181af38ca30de15c" translate="yes" xml:space="preserve">
          <source>If your program has no foreign calls in it, and no calls to known-unsafe functions (such as &lt;code&gt;unsafePerformIO&lt;/code&gt;) then a crash is always a BUG in the GHC system, except in one case: If your program is made of several modules, each module must have been compiled after any modules on which it depends (unless you use &lt;code&gt;.hi-boot&lt;/code&gt; files, in which case these &lt;em&gt;must&lt;/em&gt; be correct with respect to the module source).</source>
          <target state="translated">Если в вашей программе нет внешних вызовов и вызовов &lt;code&gt;unsafePerformIO&lt;/code&gt; небезопасных функций (таких как unsafePerformIO ), тогда сбой всегда является ОШИБКОЙ в системе GHC, за исключением одного случая: если ваша программа состоит из нескольких модулей, каждый модуль должен быть скомпилирован после любых модулей, от которых он зависит (если вы не используете &lt;code&gt;.hi-boot&lt;/code&gt; , и в этом случае они &lt;em&gt;должны&lt;/em&gt; быть правильными по отношению к источнику модуля).</target>
        </trans-unit>
        <trans-unit id="6d6ef9a1cfc5c74eeeabcdcb897c3ce978bdc728" translate="yes" xml:space="preserve">
          <source>If your program&amp;rsquo;s GC stats (&lt;code&gt;-S [⟨file⟩]&lt;/code&gt; RTS option) indicate that it&amp;rsquo;s doing lots of garbage-collection (say, more than 20% of execution time), more memory might help &amp;mdash; with the &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; or &lt;code&gt;-A ⟨size⟩&lt;/code&gt; RTS options (see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;). As a rule of thumb, try setting &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; to the amount of memory you&amp;rsquo;re willing to let your process consume, or perhaps try passing &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; without any argument to let GHC calculate a value based on the amount of live data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24caa1726f2cf05e2f221b7c2e73786d79f53d8" translate="yes" xml:space="preserve">
          <source>If your program&amp;rsquo;s GC stats (&lt;code&gt;-S [⟨file⟩]&lt;/code&gt; RTS option) indicate that it&amp;rsquo;s doing lots of garbage-collection (say, more than 20% of execution time), more memory might help &amp;mdash; with the &lt;code&gt;-H⟨size⟩&lt;/code&gt; or &lt;code&gt;-A⟨size⟩&lt;/code&gt; RTS options (see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;). As a rule of thumb, try setting &lt;code&gt;-H ⟨size⟩&lt;/code&gt; to the amount of memory you&amp;rsquo;re willing to let your process consume, or perhaps try passing &lt;code&gt;-H ⟨size⟩&lt;/code&gt; without any argument to let GHC calculate a value based on the amount of live data.</source>
          <target state="translated">Если статистика сборки мусора вашей программы (параметр &lt;code&gt;-S [⟨file⟩]&lt;/code&gt; RTS) указывает, что она выполняет много сборок мусора (скажем, более 20% времени выполнения), может помочь больше памяти - с параметром &lt;code&gt;-H⟨size⟩&lt;/code&gt; или &lt;code&gt;-A⟨size⟩&lt;/code&gt; параметры RTS (см. Параметры RTS &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;для управления сборщиком мусора&lt;/a&gt; ). Как правило, попробуйте установить &lt;code&gt;-H ⟨size⟩&lt;/code&gt; равным объему памяти, который вы хотите использовать для своего процесса, или, возможно, попробуйте передать &lt;code&gt;-H ⟨size⟩&lt;/code&gt; без каких-либо аргументов, чтобы позволить GHC вычислить значение на основе количества живых данных.</target>
        </trans-unit>
        <trans-unit id="5d51b512922ef864f145abd749faf72a2827c750" translate="yes" xml:space="preserve">
          <source>If your shared library exports a Haskell API then you cannot directly link it into another Haskell program and use that Haskell API. You will get linker errors. You must instead make it into a package as described in the section above.</source>
          <target state="translated">Если ваша разделяемая библиотека экспортирует Haskell API,то вы не можете напрямую связать ее с другой программой Haskell и использовать этот Haskell API.Вы получите ошибки компоновщика.Вместо этого вы должны сделать из нее пакет,как описано в разделе выше.</target>
        </trans-unit>
        <trans-unit id="d789f4ed9268a1d21783901d260313592caf0cd5" translate="yes" xml:space="preserve">
          <source>If ⟨n⟩ is omitted, level 2 is assumed.</source>
          <target state="translated">Если опустить ⟨n⟩,то предполагается уровень 2.</target>
        </trans-unit>
        <trans-unit id="02e8f60e1dacd712159be5f50380ce32b92d474d" translate="yes" xml:space="preserve">
          <source>If ⟨prompt⟩ starts with &lt;code&gt;&quot;&lt;/code&gt; then it is parsed as a Haskell String; otherwise it is treated as a literal string.</source>
          <target state="translated">Если &amp;laquo;подсказка&amp;raquo; начинается с &lt;code&gt;&quot;&lt;/code&gt; то она анализируется как строка Haskell; в противном случае она рассматривается как буквальная строка.</target>
        </trans-unit>
        <trans-unit id="f40887e4a14555fe188999a20b1ed14821cfa667" translate="yes" xml:space="preserve">
          <source>If ⟨size⟩ is omitted, then the garbage collector will take the size of the heap at the previous GC as the ⟨size⟩. This has the effect of allowing for a larger &lt;code&gt;-A&lt;/code&gt; value but without increasing the overall memory requirements of the program. It can be useful when the default small &lt;code&gt;-A&lt;/code&gt; value is suboptimal, as it can be in programs that create large amounts of long-lived data.</source>
          <target state="translated">Если &amp;laquo;размер&amp;raquo; опущен, то сборщик мусора примет размер кучи на предыдущем сборщике мусора как &amp;laquo;размер&amp;raquo;. Это позволяет использовать большее значение &lt;code&gt;-A&lt;/code&gt; , но без увеличения общих требований к памяти программы. Это может быть полезно, когда маленькое значение &lt;code&gt;-A&lt;/code&gt; по умолчанию является субоптимальным, как это может быть в программах, которые создают большие объемы долгоживущих данных.</target>
        </trans-unit>
        <trans-unit id="c3cbf12867cec0a1cfdbab9049d695f31f35ad31" translate="yes" xml:space="preserve">
          <source>If, as a library author of a type constructor like &lt;code&gt;Set a&lt;/code&gt;, you want to prevent a user of your module to write &lt;code&gt;coerce :: Set T -&amp;gt; Set NT&lt;/code&gt;, you need to set the role of &lt;code&gt;Set&lt;/code&gt;'s type parameter to &lt;code&gt;nominal&lt;/code&gt;, by writing</source>
          <target state="translated">Если в библиотеке автора типа конструктора , как &lt;code&gt;Set a&lt;/code&gt; , вы хотите запретить пользователю вашего модуля для записи &lt;code&gt;coerce :: Set T -&amp;gt; Set NT&lt;/code&gt; , необходимо установить роль &lt;code&gt;Set&lt;/code&gt; параметра типа &amp;laquo;s к &lt;code&gt;nominal&lt;/code&gt; , написав</target>
        </trans-unit>
        <trans-unit id="2ae8e5b9dd31d643002083a67d731779f470355f" translate="yes" xml:space="preserve">
          <source>If, however, you enable the extension &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt; when compiling the module that contains (D), GHC will instead pick (C), without complaining about the problem of subsequent instantiations.</source>
          <target state="translated">Однако, если вы включите расширение &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt; &lt;code&gt;IncoherentInstances&lt;/code&gt; &lt;/a&gt; при компиляции модуля, содержащего (D), GHC вместо этого выберет (C), не жалуясь на проблемы последующих экземпляров.</target>
        </trans-unit>
        <trans-unit id="6b618f909fc1ba5b25f3ecf49daabdeb00466da8" translate="yes" xml:space="preserve">
          <source>If, in any dimension, the lower bound is greater than the upper bound, then the array is legal, but empty. Indexing an empty array always gives an array-bounds error, but &lt;code&gt;&lt;a href=&quot;data-array#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; still yields the bounds with which the array was constructed.</source>
          <target state="translated">Если в любом измерении нижняя граница больше верхней границы, то массив допустим, но пуст. Индексирование пустого массива всегда дает ошибку границ массива, но &lt;code&gt;&lt;a href=&quot;data-array#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; прежнему дают границы, с которыми был построен массив.</target>
        </trans-unit>
        <trans-unit id="581c6edcefcd8eed3b3ae0f7ff0449e91b4a1964" translate="yes" xml:space="preserve">
          <source>If, in any dimension, the lower bound is greater than the upper bound, then the array is legal, but empty. Indexing an empty array always gives an array-bounds error, but &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; still yields the bounds with which the array was constructed.</source>
          <target state="translated">Если в любом измерении нижняя граница больше верхней границы, то массив допустим, но пуст. Индексирование пустого массива всегда дает ошибку границ массива, но &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; прежнему дают границы, с которыми был построен массив.</target>
        </trans-unit>
        <trans-unit id="f0312c7db6cdd96c1e4afe75b973aea9e68784cd" translate="yes" xml:space="preserve">
          <source>If, in any dimension, the lower bound is greater than the upper bound, then the array is legal, but empty. Indexing an empty array always gives an array-bounds error, but &lt;code&gt;&lt;a href=&quot;ghc-arr#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; still yields the bounds with which the array was constructed.</source>
          <target state="translated">Если в любом измерении нижняя граница больше верхней границы, то массив допустим, но пуст. Индексирование пустого массива всегда дает ошибку границ массива, но &lt;code&gt;&lt;a href=&quot;ghc-arr#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; прежнему дают границы, с которыми был построен массив.</target>
        </trans-unit>
        <trans-unit id="7f3727d8d991f15f746dc285dd2ca3bc1e889211" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">Если бы вместо этого был использован &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; будет оцениваться при каждом сравнении, давая оценки \ (O (n \ log n) \), а не \ (O (n) \).</target>
        </trans-unit>
        <trans-unit id="2bb6b96d1379082a5862430606e077e4951c8b2d" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a437f0ed534e2c46aa15fd000c2c49a678255cee" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">Если бы вместо этого был использован &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; будет оцениваться при каждом сравнении, давая оценки \ (O (n \ log n) \), а не \ (O (n) \).</target>
        </trans-unit>
        <trans-unit id="a830bfeca5ac45c0e56970fbc2cc9313f12b8526" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f1c19a944153820e63548e8f204d611cc0ec11" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">Если бы вместо этого был использован &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; будет оцениваться при каждом сравнении, давая оценки \ (O (n \ log n) \), а не \ (O (n) \).</target>
        </trans-unit>
        <trans-unit id="b49b973971f72b90b88232bbeeb66a8215462172" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ddcd1aa495c4907a6fe0bad7ff4515b81505d0" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">Если бы вместо этого был использован &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; будет оцениваться при каждом сравнении, давая оценки \ (O (n \ log n) \), а не \ (O (n) \).</target>
        </trans-unit>
        <trans-unit id="98de0ed556230c1fbd1808a2934adcaaa69ac02e" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98f55db57c8ed898dbaabddea8af88630b3b7caf" translate="yes" xml:space="preserve">
          <source>Ignore</source>
          <target state="translated">Ignore</target>
        </trans-unit>
        <trans-unit id="6ced7795214ecfa08f172052b124c985d4dc2867" translate="yes" xml:space="preserve">
          <source>Ignore an invalid input, substituting nothing in the output.</source>
          <target state="translated">Игнорируйте неправильный ввод,ничего не заменяя в выводе.</target>
        </trans-unit>
        <trans-unit id="8de491836ac03baa0a19777da9dff92193700b2f" translate="yes" xml:space="preserve">
          <source>Ignore assertions in the source. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Игнорируйте утверждения в источнике. Подразумевается &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="796ae3faa0a04e8aa497303246f1859cfbe98a2a" translate="yes" xml:space="preserve">
          <source>Ignore cfg weights for code layout.</source>
          <target state="translated">Игнорируйте веса cfg для компоновки кода.</target>
        </trans-unit>
        <trans-unit id="282a96dffe5fa4b96c3595d453205018d521d4f8" translate="yes" xml:space="preserve">
          <source>Ignore marks.</source>
          <target state="translated">Не обращайте внимания на следы.</target>
        </trans-unit>
        <trans-unit id="619d7d17ba8aa59dc524ffcd3b64d16b188b1a3c" translate="yes" xml:space="preserve">
          <source>Ignore package ⟨pkg⟩</source>
          <target state="translated">Игнорировать пакет ⟨pkg⟩</target>
        </trans-unit>
        <trans-unit id="591f0c15c8a037cd490c5cb494c2d82d49da6604" translate="yes" xml:space="preserve">
          <source>Ignore pragmas in interface files. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O0&quot;&gt;&lt;code&gt;-O0&lt;/code&gt;&lt;/a&gt; only.</source>
          <target state="translated">Игнорировать прагмы в файлах интерфейса. Подразумевается только &lt;a href=&quot;using-optimisation#ghc-flag--O0&quot;&gt; &lt;code&gt;-O0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf4ec85769b7a4182ac16f4a75bfe188c6947b6d" translate="yes" xml:space="preserve">
          <source>Ignore pragmas in interface files. Implied by &lt;code&gt;-O0&lt;/code&gt; only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58001447e7c0f2060ba0e27ea5f58c03c12170c4" translate="yes" xml:space="preserve">
          <source>Ignore the exposed flag on installed packages, and hide them all by default. If you use this flag, then any packages you require (including &lt;code&gt;base&lt;/code&gt;) need to be explicitly exposed using &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">Игнорируйте выставленный флаг на установленных пакетах и ​​по умолчанию скрывайте их все. Если вы используете этот флаг, то все необходимые вам пакеты (включая &lt;code&gt;base&lt;/code&gt; ) должны быть явно представлены с использованием параметров &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f1acc423ed92fdcade39f871d86c0a091be2b4d" translate="yes" xml:space="preserve">
          <source>Ignore the trusted flag on installed packages, and distrust them by default. If you use this flag and Safe Haskell then any packages you require to be trusted (including &lt;code&gt;base&lt;/code&gt;) need to be explicitly trusted using &lt;code&gt;-trust ⟨pkg⟩&lt;/code&gt; options. This option does not change the exposed/hidden status of a package, so it isn&amp;rsquo;t equivalent to applying &lt;code&gt;-distrust ⟨pkg⟩&lt;/code&gt; to all packages on the system. (see &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;).</source>
          <target state="translated">Игнорируйте флаг доверенных установленных пакетов и не доверяйте им по умолчанию. Если вы используете этот флаг и Safe Haskell, то любые пакеты, которым вы должны доверять (включая &lt;code&gt;base&lt;/code&gt; ), должны быть явно доверенными с использованием параметров &lt;code&gt;-trust ⟨pkg⟩&lt;/code&gt; . Этот параметр не изменяет открытый / скрытый статус пакета, поэтому он не эквивалентен применению &lt;code&gt;-distrust ⟨pkg⟩&lt;/code&gt; ко всем пакетам в системе. (см. &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d1a80c4097f230ea51440815b595a3404f62d484" translate="yes" xml:space="preserve">
          <source>IgnoreBreak</source>
          <target state="translated">IgnoreBreak</target>
        </trans-unit>
        <trans-unit id="4bc3560f87c85dba51d0aa8d52c5b4fea219fa0e" translate="yes" xml:space="preserve">
          <source>IgnoreCR</source>
          <target state="translated">IgnoreCR</target>
        </trans-unit>
        <trans-unit id="5cc74aacba3116f5c95cef183a2a38286abfa5de" translate="yes" xml:space="preserve">
          <source>IgnoreCodingFailure</source>
          <target state="translated">IgnoreCodingFailure</target>
        </trans-unit>
        <trans-unit id="fe3f599d5da3fc2eaa2412ebe7eba8e9f6ce8049" translate="yes" xml:space="preserve">
          <source>IgnoreParityErrors</source>
          <target state="translated">IgnoreParityErrors</target>
        </trans-unit>
        <trans-unit id="7045891c278655482762e70dd83a0b56759287f9" translate="yes" xml:space="preserve">
          <source>Ignoring breakpoints for a specified number of iterations is also possible using similar techniques.</source>
          <target state="translated">Игнорирование точек останова для заданного количества итераций также возможно при использовании аналогичных методик.</target>
        </trans-unit>
        <trans-unit id="2575568b1dcfc64c91f1f0fba9eba34462ba8283" translate="yes" xml:space="preserve">
          <source>IllegalOperation</source>
          <target state="translated">IllegalOperation</target>
        </trans-unit>
        <trans-unit id="21b60a9549daf6edf60beed5d20bc1d15c3b1b25" translate="yes" xml:space="preserve">
          <source>Immediately</source>
          <target state="translated">Immediately</target>
        </trans-unit>
        <trans-unit id="06ecb0ede3eff0f856805c208c7b6f7685988a9a" translate="yes" xml:space="preserve">
          <source>Immutable array type.</source>
          <target state="translated">Неизменяемый тип массива.</target>
        </trans-unit>
        <trans-unit id="f741bf79c240632317d4b768abc8b5c1a34b775c" translate="yes" xml:space="preserve">
          <source>Immutable arrays, with an overloaded interface. For array types which can be used with this interface, see the &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; type exported by this module and the &lt;a href=&quot;data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt; module. Other packages, such as diffarray, also provide arrays using this interface.</source>
          <target state="translated">Неизменяемые массивы с перегруженным интерфейсом. Для типов массивов, которые могут использоваться с этим интерфейсом, см. Тип &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; экспортируемый этим модулем, и модуль &lt;a href=&quot;data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt; . Другие пакеты, такие как diffarray, также предоставляют массивы с использованием этого интерфейса.</target>
        </trans-unit>
        <trans-unit id="2439111ed8a6dd1e9e35ac3526ebfdf6f8659f07" translate="yes" xml:space="preserve">
          <source>Immutable non-strict (boxed) arrays</source>
          <target state="translated">Непрерывные неограниченные (коробчатые)массивы</target>
        </trans-unit>
        <trans-unit id="f0150626bdfa29e3185274acde3b82736d872c8f" translate="yes" xml:space="preserve">
          <source>Immutable non-strict arrays</source>
          <target state="translated">Непрерывные неограниченные массивы</target>
        </trans-unit>
        <trans-unit id="ad6434427f6f7e2bf4d2041f12cd8285fbd475e3" translate="yes" xml:space="preserve">
          <source>ImplBidir</source>
          <target state="translated">ImplBidir</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="3c9c8e530dca9330d05d5aa3109b2b8286699aca" translate="yes" xml:space="preserve">
          <source>Implementation Internals</source>
          <target state="translated">Внедрение Внутренние отделы</target>
        </trans-unit>
        <trans-unit id="f225c7ab898261af0638456301826901232d3d11" translate="yes" xml:space="preserve">
          <source>Implementation details aside, the function names in the stack should hopefully give you enough clues to track down the bug.</source>
          <target state="translated">Если отложить в сторону детали реализации,то имена функций в стеке,надеюсь,дадут вам достаточно подсказок,чтобы отследить ошибку.</target>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="translated">Инструкции по внедрению</target>
        </trans-unit>
        <trans-unit id="04f0e36fb0e54bb9f6609b935523e843d65a2659" translate="yes" xml:space="preserve">
          <source>Implementations for the character predicates (isLower, isUpper, etc.) and the conversions (toUpper, toLower). The implementation uses libunicode on Unix systems if that is available.</source>
          <target state="translated">Введение символов предикатов (isLower,isUpper и т.д.)и преобразование (toUpper,toLower).Реализация использует либуникод на Unix-системах,если он доступен.</target>
        </trans-unit>
        <trans-unit id="4803faa28409cecc36571d8ab8726f7adec639ce" translate="yes" xml:space="preserve">
          <source>Implementations should enforce as far as possible, at least locally to the Haskell process, multiple-reader single-writer locking on files. That is, &lt;em&gt;there may either be many handles on the same file which manage input, or just one handle on the file which manages output&lt;/em&gt;. If any open or semi-closed handle is managing a file for output, no new handle can be allocated for that file. If any open or semi-closed handle is managing a file for input, new handles can only be allocated if they do not manage output. Whether two files are the same is implementation-dependent, but they should normally be the same if they have the same absolute path name and neither has been renamed, for example.</source>
          <target state="translated">Реализации должны обеспечивать, насколько это возможно, по крайней мере локально для процесса Haskell, блокировку файлов с несколькими читателями и одной записью. То есть &lt;em&gt;в одном файле может быть много дескрипторов, управляющих вводом, или только один дескриптор файла, который управляет выводом&lt;/em&gt; . Если какой-либо открытый или полузакрытый дескриптор управляет файлом для вывода, новый дескриптор не может быть выделен для этого файла. Если какой-либо открытый или полузакрытый дескриптор управляет файлом для ввода, новые дескрипторы могут быть выделены, только если они не управляют выходом. Являются ли два файла одинаковыми, зависит от реализации, но обычно они должны быть одинаковыми, если, например, у них одинаковый абсолютный путь и ни один из них не был переименован.</target>
        </trans-unit>
        <trans-unit id="95b15fdd44b258375ec9508491e65e9614ff63d6" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Реализовано с помощью &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee9605b9875596b2f9957b69963d14d19dbd98a4" translate="yes" xml:space="preserve">
          <source>Implemented using an algorithm adapted from /Breadth-First Numbering: Lessons from a Small Exercise in Algorithm Design&lt;em&gt;, by Chris Okasaki, &lt;/em&gt;ICFP'00/.</source>
          <target state="translated">Реализовано с использованием алгоритма, адаптированного из / Breadth-First Numbering: Lessons from a Small Exercise in Algorithm Design &lt;em&gt;, Chris&lt;/em&gt; Okasaki &lt;em&gt;,&lt;/em&gt; ICFP'00 /.</target>
        </trans-unit>
        <trans-unit id="ce44457603020d3e393a5770d9319edff0c59393" translate="yes" xml:space="preserve">
          <source>Implicit call stacks</source>
          <target state="translated">Неявные стеки вызовов</target>
        </trans-unit>
        <trans-unit id="e4767a7af64b718f0f087f2f77c45daac0f221c4" translate="yes" xml:space="preserve">
          <source>Implicit parameter binding declaration. Can only be used in let and where clauses which consist entirely of implicit bindings.</source>
          <target state="translated">Неявное объявление связывания параметров.Может использоваться только в случаях,когда клаузулы полностью состоят из неявных привязок.</target>
        </trans-unit>
        <trans-unit id="8e5e6bdeb8195ae9a56250fa5a11abb1b4c4ca76" translate="yes" xml:space="preserve">
          <source>Implicit parameters (see &lt;a href=&quot;glasgow_exts#implicit-parameters&quot;&gt;Implicit parameters&lt;/a&gt;) are only available at the scope of a breakpoint if there is an explicit type signature.</source>
          <target state="translated">Неявные параметры (см. &lt;a href=&quot;glasgow_exts#implicit-parameters&quot;&gt;Неявные параметры&lt;/a&gt; ) доступны только в области точки останова при наличии явной сигнатуры типа.</target>
        </trans-unit>
        <trans-unit id="96344ea55749ca67fb2833fb9d1ea7587feab87a" translate="yes" xml:space="preserve">
          <source>Implicit parameters are implemented as described in &lt;a href=&quot;#lewis2000&quot; id=&quot;id60&quot;&gt;[Lewis2000]&lt;/a&gt; and enabled with the option &lt;a href=&quot;#extension-ImplicitParams&quot;&gt;&lt;code&gt;ImplicitParams&lt;/code&gt;&lt;/a&gt;. (Most of the following, still rather incomplete, documentation is due to Jeff Lewis.)</source>
          <target state="translated">Неявные параметры реализованы, как описано в &lt;a href=&quot;#lewis2000&quot; id=&quot;id60&quot;&gt;[Lewis2000],&lt;/a&gt; и включены с помощью опции &lt;a href=&quot;#extension-ImplicitParams&quot;&gt; &lt;code&gt;ImplicitParams&lt;/code&gt; &lt;/a&gt; . (Большая часть нижеследующей, все еще довольно неполной документации принадлежит Джеффу Льюису.)</target>
        </trans-unit>
        <trans-unit id="f3e48b33a4890da92cd70584a377ecd462ba1a72" translate="yes" xml:space="preserve">
          <source>Implicit parameters are implemented as described in &lt;a href=&quot;#lewis2000&quot; id=&quot;id62&quot;&gt;[Lewis2000]&lt;/a&gt; and enabled with the option &lt;a href=&quot;#extension-ImplicitParams&quot;&gt;&lt;code&gt;ImplicitParams&lt;/code&gt;&lt;/a&gt;. (Most of the following, still rather incomplete, documentation is due to Jeff Lewis.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d896817ab0c9fc745a6846e04e6e0b797e133fb2" translate="yes" xml:space="preserve">
          <source>Implicit-parameter constraints do not cause ambiguity. For example, consider:</source>
          <target state="translated">Неявные ограничения параметров не вызывают двусмысленности.Например,рассмотрим:</target>
        </trans-unit>
        <trans-unit id="e96fdb8318fd32f2e2e39a2a6d18b9f85a8f84b4" translate="yes" xml:space="preserve">
          <source>ImplicitParams</source>
          <target state="translated">ImplicitParams</target>
        </trans-unit>
        <trans-unit id="2b2233be7646337ec9333a40a93e6817457da678" translate="yes" xml:space="preserve">
          <source>ImplicitPrelude</source>
          <target state="translated">ImplicitPrelude</target>
        </trans-unit>
        <trans-unit id="218aafacdf8f46f838b7332039de5c3dbbc7cc14" translate="yes" xml:space="preserve">
          <source>Implied by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91e7074a90e49338f31c7b8d7563d1849b2d089" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--O%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-O0&lt;/code&gt;&lt;/a&gt;, otherwise off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9084c82dfec5377f9fc397a036577c18a18be8e1" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--O0&quot;&gt;&lt;code&gt;-O0&lt;/code&gt;&lt;/a&gt;, otherwise off.</source>
          <target state="translated">Подразумевается &lt;a href=&quot;#ghc-flag--O0&quot;&gt; &lt;code&gt;-O0&lt;/code&gt; &lt;/a&gt; , в противном случае отключено.</target>
        </trans-unit>
        <trans-unit id="b621c4b935c566b23caad050661b44248a2aea06" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt;&lt;code&gt;-Wdeferred-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Подразумевается &lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt; . См. Также &lt;a href=&quot;#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt; &lt;code&gt;-Wdeferred-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f431cb19e87fba9b86d9726b255a020698520002" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;#ghc-flag--Wtyped-holes&quot;&gt;&lt;code&gt;-Wtyped-holes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Подразумевается &lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt; . См. Также &lt;a href=&quot;#ghc-flag--Wtyped-holes&quot;&gt; &lt;code&gt;-Wtyped-holes&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3cb21b29dd0fa6b86f91cfc36f481aa089a2398e" translate="yes" xml:space="preserve">
          <source>Implied by:</source>
          <target state="translated">Подразумевается:</target>
        </trans-unit>
        <trans-unit id="696ba2ae8759bcaca0a74feee3fb3d26911b302c" translate="yes" xml:space="preserve">
          <source>Implies</source>
          <target state="translated">Implies</target>
        </trans-unit>
        <trans-unit id="6242df79ef25a40efdb6b02069e963ee6c75ae36" translate="yes" xml:space="preserve">
          <source>Implies:</source>
          <target state="translated">Implies:</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="1de625c46836a8d690ceb58d45293b81c48c397e" translate="yes" xml:space="preserve">
          <source>Import a module by &lt;code&gt;hs-boot&lt;/code&gt; file to break a module loop.</source>
          <target state="translated">Импортируйте модуль с помощью файла &lt;code&gt;hs-boot&lt;/code&gt; , чтобы разорвать цикл модуля.</target>
        </trans-unit>
        <trans-unit id="15a02ed60dd913a32866007cb8b0f286d068920a" translate="yes" xml:space="preserve">
          <source>Import statements and scoping rules are exactly as in Haskell. To mention a non-Prelude type or class, you must import it.</source>
          <target state="translated">Импортные отчёты и правила определения сферы действия точно такие же,как и в Хаскелле.Чтобы упомянуть тип или класс,не являющийся прелюдией,вы должны импортировать его.</target>
        </trans-unit>
        <trans-unit id="ccaf39f584206e7c3969db9d359129399c8be167" translate="yes" xml:space="preserve">
          <source>Import the patterns:</source>
          <target state="translated">Импортируйте шаблоны:</target>
        </trans-unit>
        <trans-unit id="0ace903aa74341e5d1ccb710b3fdc2bed74b4565" translate="yes" xml:space="preserve">
          <source>Import/export functions</source>
          <target state="translated">Функции импорта/экспорта</target>
        </trans-unit>
        <trans-unit id="5df41abfd75ae06055cd5c44bb9065e3454ceee7" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">Важное примечание: поведение &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; отличается от описанного в статье &amp;laquo;Асинхронные исключения в Haskell&amp;raquo; ( &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt; ). В статье &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; не является блокирующим; но реализация библиотеки использует более синхронный дизайн, в котором &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; не возвращается, пока исключение не будет получено целевым потоком. Компромисс обсуждается в разделе 9 статьи. &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; как и любая блокирующая операция, throwTo можно прервать (см. Раздел 5.3 статьи). В отличии от других прерываемых операций, однако, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; это &lt;em&gt;всегда&lt;/em&gt; прерываемый, даже если он на самом деле не блокировать.</target>
        </trans-unit>
        <trans-unit id="179fcf640a3d899c14d346ac25778d5710538175" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">Важное примечание: поведение &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; отличается от описанного в статье &amp;laquo;Асинхронные исключения в Haskell&amp;raquo; ( &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt; ). В статье &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; не является блокирующим; но реализация библиотеки использует более синхронный дизайн, в котором &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; не возвращается, пока исключение не будет получено целевым потоком. Компромисс обсуждается в разделе 9 статьи. &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; как и любая блокирующая операция, throwTo можно прервать (см. Раздел 5.3 статьи). В отличии от других прерываемых операций, однако, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; это &lt;em&gt;всегда&lt;/em&gt; прерываемый, даже если он на самом деле не блокировать.</target>
        </trans-unit>
        <trans-unit id="95c64cf2f235ca7554567f7534fe0b43d5677eea" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">Важное примечание: поведение &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; отличается от описанного в статье &amp;laquo;Асинхронные исключения в Haskell&amp;raquo; ( &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt; ). В статье &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; не является блокирующим; но реализация библиотеки использует более синхронный дизайн, в котором &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; не возвращается, пока исключение не будет получено целевым потоком. Компромисс обсуждается в разделе 9 статьи. &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; как и любая блокирующая операция, throwTo можно прервать (см. Раздел 5.3 статьи). В отличии от других прерываемых операций, однако, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; это &lt;em&gt;всегда&lt;/em&gt; прерываемый, даже если он на самом деле не блокировать.</target>
        </trans-unit>
        <trans-unit id="4589bf4e9a6ce37b31d36f0a6e150b4292fb9be8" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">Важное примечание: поведение &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; отличается от описанного в статье &amp;laquo;Асинхронные исключения в Haskell&amp;raquo; ( &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt; ). В статье &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; не является блокирующим; но реализация библиотеки использует более синхронный дизайн, в котором &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; не возвращается, пока исключение не будет получено целевым потоком. Компромисс обсуждается в разделе 9 статьи. &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; как и любая блокирующая операция, throwTo можно прервать (см. Раздел 5.3 статьи). В отличии от других прерываемых операций, однако, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; это &lt;em&gt;всегда&lt;/em&gt; прерываемый, даже если он на самом деле не блокировать.</target>
        </trans-unit>
        <trans-unit id="c537cf521e62d230fcbda7200d4c65bb85bb9950" translate="yes" xml:space="preserve">
          <source>Importantly, GHC will &lt;strong&gt;never&lt;/strong&gt; infer a &lt;code&gt;HasCallStack&lt;/code&gt; constraint, you must request it explicitly.</source>
          <target state="translated">Важно отметить, что GHC не будет &lt;strong&gt;никогда&lt;/strong&gt; логически вывести &lt;code&gt;HasCallStack&lt;/code&gt; ограничения, вы должны запросить его в явном виде.</target>
        </trans-unit>
        <trans-unit id="209a185dcdc64df7c89fd6b4a06c378dd59a523b" translate="yes" xml:space="preserve">
          <source>Imports can be &lt;em&gt;removed&lt;/em&gt; from the context, using the syntax &lt;code&gt;:module -M&lt;/code&gt;. The &lt;code&gt;import&lt;/code&gt; syntax is cumulative (as in a Haskell module), so this is the only way to subtract from the scope.</source>
          <target state="translated">Импорт можно &lt;em&gt;удалить&lt;/em&gt; из контекста, используя синтаксис &lt;code&gt;:module -M&lt;/code&gt; . &lt;code&gt;import&lt;/code&gt; синтаксис является кумулятивным (как в модуле Haskell), так что это единственный способ , чтобы вычесть из объема.</target>
        </trans-unit>
        <trans-unit id="04d8d8c71e07fcca11b70e8d6722717ba5c7bbd1" translate="yes" xml:space="preserve">
          <source>ImpredicativeTypes</source>
          <target state="translated">ImpredicativeTypes</target>
        </trans-unit>
        <trans-unit id="ada1b47a54b4c0472b230f71a39fa22ace4b62eb" translate="yes" xml:space="preserve">
          <source>In (unlikely) bad cases, this algorithm's complexity degrades towards O(n*m).</source>
          <target state="translated">В (маловероятных)плохих случаях сложность этого алгоритма снижается в сторону O(n*m).</target>
        </trans-unit>
        <trans-unit id="c9b4f236af14825a1f87646152c7ae5ae54d6f1b" translate="yes" xml:space="preserve">
          <source>In (unlikely) bad cases, this function's time complexity degrades towards O(n*m).</source>
          <target state="translated">В (маловероятных)плохих случаях временная сложность этой функции уменьшается в сторону O(n*m).</target>
        </trans-unit>
        <trans-unit id="10cba8ae40b482d6815c0aed2cb5cad28971bc60" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode and &lt;a href=&quot;using#ghc-flag---interactive&quot;&gt;&lt;code&gt;--interactive&lt;/code&gt;&lt;/a&gt; mode (see &lt;a href=&quot;using#modes&quot;&gt;Modes of operation&lt;/a&gt;), the compiler normally determines which packages are required by the current Haskell modules, and links only those. In batch mode however, the dependency information isn&amp;rsquo;t available, and explicit &lt;code&gt;-package&lt;/code&gt; options must be given when linking. The one other time you might need to use &lt;code&gt;-package&lt;/code&gt; to force linking a package is when the package does not contain any Haskell modules (it might contain a C library only, for example). In that case, GHC will never discover a dependency on it, so it has to be mentioned explicitly.</source>
          <target state="translated">В &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;using#ghc-flag---interactive&quot;&gt; &lt;code&gt;--interactive&lt;/code&gt; &lt;/a&gt; (см. &lt;a href=&quot;using#modes&quot;&gt;Режимы работы&lt;/a&gt; ) компилятор обычно определяет, какие пакеты требуются текущим модулям Haskell, и связывает только те. Однако в пакетном режиме информация о зависимостях недоступна, и при компоновке необходимо &lt;code&gt;-package&lt;/code&gt; явные параметры -package . Еще один раз, когда вам может потребоваться использовать &lt;code&gt;-package&lt;/code&gt; для принудительной компоновки пакета, это когда пакет не содержит никаких модулей Haskell (например, он может содержать только библиотеку C). В этом случае GHC никогда не обнаружит зависимости от него, поэтому о нем нужно упомянуть явно.</target>
        </trans-unit>
        <trans-unit id="0e9c1cc6f5410615b774e4fbc397355fcbc8c4fd" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&quot;wrong1&quot;&lt;/code&gt;, the LHS is not an application; in &lt;code&gt;&quot;wrong2&quot;&lt;/code&gt;, the LHS has a pattern variable in the head. In &lt;code&gt;&quot;wrong3&quot;&lt;/code&gt;, the LHS consists of a &lt;em&gt;constructor&lt;/em&gt;, rather than a &lt;em&gt;variable&lt;/em&gt;, applied to an argument.</source>
          <target state="translated">В случае &lt;code&gt;&quot;wrong1&quot;&lt;/code&gt; LHS не является приложением; в &lt;code&gt;&quot;wrong2&quot;&lt;/code&gt; LHS имеет переменную шаблона в голове. В &lt;code&gt;&quot;wrong3&quot;&lt;/code&gt; LHS состоит из &lt;em&gt;конструктора&lt;/em&gt; , а не из &lt;em&gt;переменной&lt;/em&gt; , применяемой к аргументу.</target>
        </trans-unit>
        <trans-unit id="2cba9c2c873dc3a1842eba8795586b3cad1e7927" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;('[] :: [Maybe a])&lt;/code&gt;, the kind variable &lt;code&gt;a&lt;/code&gt; is implicitly bound by the kind signature of the LHS type pattern &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;('[] :: [Maybe a])&lt;/code&gt; переменная вида &lt;code&gt;a&lt;/code&gt; неявно связана сигнатурой типа шаблона типа LHS &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd722d9619f7131d53a6e0696cd49a366c57cba6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;...rhs...&lt;/code&gt; there is, in effect a local instance for &lt;code&gt;Eq (f a)&lt;/code&gt; for any &lt;code&gt;a&lt;/code&gt;. But at a call site for &lt;code&gt;f&lt;/code&gt; the compiler itself produces evidence to pass to &lt;code&gt;f&lt;/code&gt;. For example, if we called &lt;code&gt;f Nothing&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;Maybe&lt;/code&gt; and the compiler must prove (at the call site) that &lt;code&gt;forall a. Eq a =&amp;gt; Eq (Maybe a)&lt;/code&gt; holds. It can do this easily, by appealing to the existing instance declaration for &lt;code&gt;Eq (Maybe a)&lt;/code&gt;.</source>
          <target state="translated">In &lt;code&gt;...rhs...&lt;/code&gt; фактически существует локальный экземпляр для &lt;code&gt;Eq (f a)&lt;/code&gt; для любого &lt;code&gt;a&lt;/code&gt; . Но на сайте вызова для &lt;code&gt;f&lt;/code&gt; компилятор сам предоставляет доказательства для перехода к &lt;code&gt;f&lt;/code&gt; . Например, если мы вызвали &lt;code&gt;f Nothing&lt;/code&gt; , тогда &lt;code&gt;f&lt;/code&gt; равно &lt;code&gt;Maybe&lt;/code&gt; , и компилятор должен доказать (на месте вызова), что для &lt;code&gt;forall a. Eq a =&amp;gt; Eq (Maybe a)&lt;/code&gt; выполняется. Это можно легко сделать, обратившись к существующему объявлению экземпляра &lt;code&gt;Eq (Maybe a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68a829120c1a8cf6dc40005b5743e07320e4e76d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances of the form</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; случаях вида</target>
        </trans-unit>
        <trans-unit id="948361792703e617253f8a40efc29e2464a33346" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt;, the parameter &lt;code&gt;p&lt;/code&gt; is used for the first time, whereas &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; simply wraps an application of &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; параметр &lt;code&gt;p&lt;/code&gt; используется впервые, тогда как &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; просто оборачивает приложение &lt;code&gt;f&lt;/code&gt; к &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a4440f56e4e4c2cfc9de276b7ac8c2dd211dcc7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt;, name of the parent class or type</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt; - имя родительского класса или типа.</target>
        </trans-unit>
        <trans-unit id="845d36fb6d42c5c12db137868f32d7eab65dd2b2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, arity of the type constructor</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; арность конструктора типа</target>
        </trans-unit>
        <trans-unit id="b6d9284ef85a16cb7684b74958aee144b991c17a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, is the type constructor unlifted?</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; не поднят ли конструктор типа?</target>
        </trans-unit>
        <trans-unit id="c8e7141714d539cd7c869ec1a2a44cb47eefb8e1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the number associated with a particular data constructor. &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s are one-indexed and should never exceed the value of its corresponding &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; - число, связанное с конкретным конструктором данных. &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; являются одноиндексированными и никогда не должны превышать значение соответствующего &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="8baeebee8820ef8d8750b87cc615ff6f0298f331" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the total number of &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s. For example, &lt;code&gt;(#|#)&lt;/code&gt; has a &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; of 2.</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; - общее количество &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; s. Например, &lt;code&gt;(#|#)&lt;/code&gt; имеет &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; равное 2.</target>
        </trans-unit>
        <trans-unit id="d196e0b1f2acfe7fd37b1d4013ccf57a2a366c38" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt;, name of the parent class or type</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt; - имя родительского класса или типа.</target>
        </trans-unit>
        <trans-unit id="b499ce2ba87784f2de26193d6919b4f01a32b507" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, arity of the type constructor</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; арность конструктора типа</target>
        </trans-unit>
        <trans-unit id="1d657fa5f332487c2a8bc2384b505cdd8da898c0" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, is the type constructor unlifted?</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; не поднят ли конструктор типа?</target>
        </trans-unit>
        <trans-unit id="267623324428073bc541eebd4aad8f68ba67c469" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the number associated with a particular data constructor. &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s are one-indexed and should never exceed the value of its corresponding &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; - число, связанное с конкретным конструктором данных. &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; являются одноиндексированными и никогда не должны превышать значение соответствующего &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="8ef1f15923838f9b858d723d5c8a4bfd38ff8b06" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the total number of &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s. For example, &lt;code&gt;(#|#)&lt;/code&gt; has a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; of 2.</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; - общее количество &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; s. Например, &lt;code&gt;(#|#)&lt;/code&gt; имеет &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; равное 2.</target>
        </trans-unit>
        <trans-unit id="9e5468a181d7acdf72891e57c5df9af13b9a16ef" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MetaCons n f s&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; is the constructor's name, &lt;code&gt;f&lt;/code&gt; is its fixity, and &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;'True&lt;/code&gt; if the constructor contains record selectors.</source>
          <target state="translated">В &lt;code&gt;MetaCons n f s&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; это имя конструктора, &lt;code&gt;f&lt;/code&gt; является его неподвижность, и &lt;code&gt;s&lt;/code&gt; является &lt;code&gt;'True&lt;/code&gt; , если конструктор содержит записи селекторов.</target>
        </trans-unit>
        <trans-unit id="bdcb03ae6fc4038ed5d8f740a99f5a3faec1e49a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MetaData n m p nt&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; is the datatype's name, &lt;code&gt;m&lt;/code&gt; is the module in which the datatype is defined, &lt;code&gt;p&lt;/code&gt; is the package in which the datatype is defined, and &lt;code&gt;nt&lt;/code&gt; is &lt;code&gt;'True&lt;/code&gt; if the datatype is a &lt;code&gt;newtype&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;MetaData n m p nt&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; - это имя типа данных, &lt;code&gt;m&lt;/code&gt; - это модуль, в котором определен тип данных, &lt;code&gt;p&lt;/code&gt; - это пакет, в котором определен тип данных, и &lt;code&gt;nt&lt;/code&gt; - &lt;code&gt;'True&lt;/code&gt; если тип данных является &lt;code&gt;newtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e83eee84186dc4d831c882f80bd99d4e5968d965" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MetaSel mn su ss ds&lt;/code&gt;, if the field uses record syntax, then &lt;code&gt;mn&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the record name. Otherwise, &lt;code&gt;mn&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;su&lt;/code&gt; and &lt;code&gt;ss&lt;/code&gt; are the field's unpackedness and strictness annotations, and &lt;code&gt;ds&lt;/code&gt; is the strictness that GHC infers for the field.</source>
          <target state="translated">В &lt;code&gt;MetaSel mn su ss ds&lt;/code&gt; , если поле использует синтаксис записи, то &lt;code&gt;mn&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; имя записи. В противном случае &lt;code&gt;mn&lt;/code&gt; равно &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;su&lt;/code&gt; и &lt;code&gt;ss&lt;/code&gt; - это аннотации неупакованности и строгости поля, а &lt;code&gt;ds&lt;/code&gt; - строгость, которую GHC определяет для поля.</target>
        </trans-unit>
        <trans-unit id="d34a93041bfae2648000d66b86976acbec2d0642" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkBar&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;MkBar&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; будет количественно &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , и &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ced4e254bc1eb559ceb481fab3bee8103d304a01" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkBar&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;MkBar&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; будет количественно &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , и &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87dae09b658c1498dee148900bef2b9dd60aee21" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkFoo&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;b&lt;/code&gt;, but not &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;MkFoo&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; будет количественно &lt;code&gt;b&lt;/code&gt; , но не . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fe62b913f985335a3ba832edccdcf6977c0bf16" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkFoo&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;b&lt;/code&gt;, but not &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;MkFoo&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; будет количественно &lt;code&gt;b&lt;/code&gt; , но не . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7cc75f8d8c4b35c1f3e3a3913bb479147b81cb55" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Monad&lt;/code&gt; instances declarations warn if any of the following conditions does not hold:</source>
          <target state="translated">В экземплярах &lt;code&gt;Monad&lt;/code&gt; объявления предупреждают, если любое из следующих условий не выполняется:</target>
        </trans-unit>
        <trans-unit id="ce6899c2e8dfb1d03397333b9eb9a07339697044" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Monoid&lt;/code&gt; instances declarations warn if any of the following conditions does not hold:</source>
          <target state="translated">В экземплярах &lt;code&gt;Monoid&lt;/code&gt; объявления предупреждают, если какое-либо из следующих условий не выполняется:</target>
        </trans-unit>
        <trans-unit id="e39ca16be80f52a77708c1a747b96b2360e52634" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;, the type variable &lt;code&gt;b&lt;/code&gt; is not quantified by the outermost &lt;code&gt;forall&lt;/code&gt;, so it is not in scope over the bodies of the functions. Neither is &lt;code&gt;b&lt;/code&gt; in scope over the body of &lt;code&gt;f3&lt;/code&gt;, as the &lt;code&gt;forall&lt;/code&gt; is tucked underneath the &lt;code&gt;Foo&lt;/code&gt; type synonym.</source>
          <target state="translated">В &lt;code&gt;f1&lt;/code&gt; и &lt;code&gt;f2&lt;/code&gt; переменная типа &lt;code&gt;b&lt;/code&gt; не определяется количественно самым внешним &lt;code&gt;forall&lt;/code&gt; , поэтому она не входит в область видимости тел функций. Ни &lt;code&gt;b&lt;/code&gt; , ни b не попадают в область действия &lt;code&gt;f3&lt;/code&gt; , так как &lt;code&gt;forall&lt;/code&gt; скрывается под синонимом типа &lt;code&gt;Foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a77988f2a2ed6a0e43f6b8c5f856f98a253efb90" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s definition, we&amp;rsquo;ll instantiate to &lt;code&gt;(C alpha)&lt;/code&gt; and try to deduce &lt;code&gt;(C alpha)&lt;/code&gt; from &lt;code&gt;(C a)&lt;/code&gt;, and fail.</source>
          <target state="translated">В определении &lt;code&gt;g&lt;/code&gt; мы создадим экземпляр &lt;code&gt;(C alpha)&lt;/code&gt; и попытаемся вывести &lt;code&gt;(C alpha)&lt;/code&gt; из &lt;code&gt;(C a)&lt;/code&gt; , и потерпим неудачу.</target>
        </trans-unit>
        <trans-unit id="3a689d248410c565d4fb51360a8de99b622f55fe" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s definition, we&amp;rsquo;ll instantiate to &lt;code&gt;(C alpha)&lt;/code&gt; and try to deduce &lt;code&gt;(C alpha)&lt;/code&gt; from &lt;code&gt;(C a)&lt;/code&gt;, and fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc4c70c143662f5383482b6d67de0f92f7a365d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;kindOf&lt;/code&gt;, the &lt;code&gt;k&lt;/code&gt; variable is used both in a kind position and a type position. Currently, &lt;code&gt;kindOf&lt;/code&gt; happens to be accepted as well.</source>
          <target state="translated">В &lt;code&gt;kindOf&lt;/code&gt; , то &lt;code&gt;k&lt;/code&gt; переменному используются как в своем роде положение и положение типа. В настоящее время также &lt;code&gt;kindOf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b35e40411bc58348de1c2765fb1a4292327ba91" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;libraries/base/GHC/Base.hs&lt;/code&gt; look at the rules for &lt;code&gt;map&lt;/code&gt; to see how to write rules that will do fusion and yet give an efficient program even if fusion doesn&amp;rsquo;t happen. More rules in &lt;code&gt;GHC/List.hs&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;libraries/base/GHC/Base.hs&lt;/code&gt; просмотрите правила для &lt;code&gt;map&lt;/code&gt; чтобы узнать, как писать правила, которые будут выполнять слияние, но при этом дают эффективную программу, даже если слияние не происходит. Другие правила в &lt;code&gt;GHC/List.hs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06a114c54d904ac4a8b931a8b996071d7f5db6f6" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;batch mode&lt;/em&gt;, GHC will compile one or more source files given on the command line.</source>
          <target state="translated">В &lt;em&gt;пакетном режиме&lt;/em&gt; GHC скомпилирует один или несколько исходных файлов, указанных в командной строке.</target>
        </trans-unit>
        <trans-unit id="58d94fdb74e22b1e4ed6c0f3d1765a358e401fba" translate="yes" xml:space="preserve">
          <source>In GHC 6.12.3 and earlier, the default was to process all RTS options. However, since RTS options can be used to write logging data to arbitrary files under the security context of the running program, there is a potential security problem. For this reason, GHC 7.0.1 and later default to &lt;code&gt;-rtsopts=some&lt;/code&gt;.</source>
          <target state="translated">В GHC 6.12.3 и ранее по умолчанию обрабатывались все параметры RTS. Однако, поскольку параметры RTS могут использоваться для записи данных журнала в произвольные файлы в контексте безопасности работающей программы, существует потенциальная проблема безопасности. По этой причине для GHC 7.0.1 и более поздних &lt;code&gt;-rtsopts=some&lt;/code&gt; по умолчанию используется -rtsopts = some .</target>
        </trans-unit>
        <trans-unit id="d1bf7ad7520a92b283b23d11132eda5dbd26c8a6" translate="yes" xml:space="preserve">
          <source>In GHC 8.4 and higher, the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; has been corrected to lift a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance instead of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance. Consequently, this type is no longer useful. It will be marked deprecated in GHC 8.8 and removed in GHC 8.10.</source>
          <target state="translated">В GHC 8.4 и более &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; экземпляр Monoid для &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; был исправлен, чтобы поднять экземпляр &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; вместо экземпляра &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; . Следовательно, этот тип больше бесполезен. Он будет помечен как устаревший в GHC 8.8 и удален в GHC 8.10.</target>
        </trans-unit>
        <trans-unit id="acf62f569044864c4ed60a6a7bb15cef4826949f" translate="yes" xml:space="preserve">
          <source>In GHC the &lt;code&gt;Int&lt;/code&gt; type follows the size of an address on the host architecture; in other words it holds 32 bits on a 32-bit machine, and 64-bits on a 64-bit machine.</source>
          <target state="translated">В GHC тип &lt;code&gt;Int&lt;/code&gt; соответствует размеру адреса в архитектуре хоста; другими словами, он содержит 32 бита на 32-битной машине и 64 бита на 64-битной машине.</target>
        </trans-unit>
        <trans-unit id="9843e6ca6c6b645c8f794b9b1a427c411f140a1a" translate="yes" xml:space="preserve">
          <source>In GHC version 6.12 building shared libraries is supported for Linux (on x86 and x86-64 architectures). GHC version 7.0 adds support on Windows (see &lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Building and using Win32 DLLs&lt;/a&gt;), FreeBSD and OpenBSD (x86 and x86-64), Solaris (x86) and Mac OS X (x86 and PowerPC).</source>
          <target state="translated">В GHC версии 6.12 поддерживается сборка разделяемых библиотек для Linux (на архитектурах x86 и x86-64). В GHC версии 7.0 добавлена ​​поддержка Windows (см. &lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Создание и использование библиотек DLL Win32&lt;/a&gt; ), FreeBSD и OpenBSD (x86 и x86-64), Solaris (x86) и Mac OS X (x86 и PowerPC).</target>
        </trans-unit>
        <trans-unit id="1daba1b4560bdfc70e09fd592e0d65dc1e9c37b9" translate="yes" xml:space="preserve">
          <source>In GHC, &lt;code&gt;alloca&lt;/code&gt; is implemented using &lt;code&gt;MutableByteArray#&lt;/code&gt;, so allocation and deallocation are fast: much faster than C&amp;rsquo;s &lt;code&gt;malloc/free&lt;/code&gt;, but not quite as fast as stack allocation in C. Use &lt;code&gt;alloca&lt;/code&gt; whenever you can.</source>
          <target state="translated">В GHC &lt;code&gt;alloca&lt;/code&gt; реализована с использованием &lt;code&gt;MutableByteArray#&lt;/code&gt; , поэтому выделение и освобождение выполняется быстро: намного быстрее, чем &lt;code&gt;malloc/free&lt;/code&gt; в C , но не так быстро, как выделение стека в C. Используйте &lt;code&gt;alloca&lt;/code&gt; всякий раз, когда можете.</target>
        </trans-unit>
        <trans-unit id="eaea8bf5bbec3eca1845287a1a36bf3f40ff1211" translate="yes" xml:space="preserve">
          <source>In GHC, &lt;code&gt;mallocForeignPtr&lt;/code&gt; is also implemented using &lt;code&gt;MutableByteArray#&lt;/code&gt;. Although the memory is pointed to by a &lt;code&gt;ForeignPtr&lt;/code&gt;, there are no actual finalizers involved (unless you add one with &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt;), and the deallocation is done using GC, so &lt;code&gt;mallocForeignPtr&lt;/code&gt; is normally very cheap.</source>
          <target state="translated">В GHC &lt;code&gt;mallocForeignPtr&lt;/code&gt; также реализован с использованием &lt;code&gt;MutableByteArray#&lt;/code&gt; . Хотя память указана с помощью &lt;code&gt;ForeignPtr&lt;/code&gt; , фактических финализаторов не задействовано (если вы не добавили один с помощью &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt; ), а освобождение &lt;code&gt;mallocForeignPtr&lt;/code&gt; выполняется с помощью GC, поэтому mallocForeignPtr обычно очень дешевый.</target>
        </trans-unit>
        <trans-unit id="39daf99f45a84ba8de844fc76ad7b4153033baaa" translate="yes" xml:space="preserve">
          <source>In GHC, a fixity declaration may accompany a local binding:</source>
          <target state="translated">В GHC заявление о фиксировании может сопровождаться местным обязательством:</target>
        </trans-unit>
        <trans-unit id="0d4c63d000de5dba60a416622dd3245150848f85" translate="yes" xml:space="preserve">
          <source>In GHC, the stdout handle is line-buffered by default. However, in GHCi we turn off the buffering on stdout, because this is normally what you want in an interpreter: output appears as it is generated.</source>
          <target state="translated">В GHC ручка stdout по умолчанию линейно буферизируется.Однако,в GHCi мы отключаем буферизацию на stdout,потому что обычно это то,что вам нужно в интерпретаторе:вывод появляется в том виде,в котором он генерируется.</target>
        </trans-unit>
        <trans-unit id="8852f0e928d58c915cd8b9e1a00743a1e68d9fa3" translate="yes" xml:space="preserve">
          <source>In GHC, this is 1 (a tab is just a character)</source>
          <target state="translated">В GHC это 1 (табуляция-это просто символ).</target>
        </trans-unit>
        <trans-unit id="d19c28d54f7c0de858c1b5974a88ffcb3bf56049" translate="yes" xml:space="preserve">
          <source>In GHC, threads created by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; are lightweight threads, and are managed entirely by the GHC runtime. Typically Haskell threads are an order of magnitude or two more efficient (in terms of both time and space) than operating system threads.</source>
          <target state="translated">В GHC потоки, созданные &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; , являются легкими потоками и полностью управляются средой выполнения GHC. Обычно потоки Haskell на порядок или два более эффективны (с точки зрения времени и пространства), чем потоки операционной системы.</target>
        </trans-unit>
        <trans-unit id="1805c71d435523bc362fb0a41eec670b0de8eef4" translate="yes" xml:space="preserve">
          <source>In Haskell 2010, certain kinds of expressions can be used without parentheses as an argument to an operator, but not as an argument to a function. They include &lt;code&gt;do&lt;/code&gt;, lambda, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, and &lt;code&gt;let&lt;/code&gt; expressions. Some GHC extensions also define language constructs of this type: &lt;code&gt;mdo&lt;/code&gt; (&lt;a href=&quot;#recursive-do-notation&quot;&gt;The recursive do-notation&lt;/a&gt;), &lt;code&gt;\case&lt;/code&gt; (&lt;a href=&quot;#lambda-case&quot;&gt;Lambda-case&lt;/a&gt;), and &lt;code&gt;proc&lt;/code&gt; (&lt;a href=&quot;#arrow-notation&quot;&gt;Arrow notation&lt;/a&gt;).</source>
          <target state="translated">В Haskell 2010 некоторые виды выражений можно использовать без скобок в качестве аргумента оператора, но не в качестве аргумента функции. Они включают выражения &lt;code&gt;do&lt;/code&gt; , lambda, &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;case&lt;/code&gt; и &lt;code&gt;let&lt;/code&gt; . Некоторые расширения GHC также определяют языковые конструкции этого типа: &lt;code&gt;mdo&lt;/code&gt; ( &lt;a href=&quot;#recursive-do-notation&quot;&gt;рекурсивная do-нотация&lt;/a&gt; ), &lt;code&gt;\case&lt;/code&gt; ( &lt;a href=&quot;#lambda-case&quot;&gt;лямбда-регистр&lt;/a&gt; ) и &lt;code&gt;proc&lt;/code&gt; ( &lt;a href=&quot;#arrow-notation&quot;&gt;обозначение стрелок&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="958b65070f6cab89550e593513742b0ca3a25efb" translate="yes" xml:space="preserve">
          <source>In Haskell 2010, this is an opaque type.</source>
          <target state="translated">В Хаскелле 2010 года это непрозрачный тип.</target>
        </trans-unit>
        <trans-unit id="141c5fc516d90c0307fae2cd69b966988b2f5738" translate="yes" xml:space="preserve">
          <source>In Haskell 98 mode and by default (but not in Haskell 2010 mode), GHC is a little less strict about the layout rule when used in &lt;code&gt;do&lt;/code&gt; expressions. Specifically, the restriction that &amp;ldquo;a nested context must be indented further to the right than the enclosing context&amp;rdquo; is relaxed to allow the nested context to be at the same level as the enclosing context, if the enclosing context is a &lt;code&gt;do&lt;/code&gt; expression.</source>
          <target state="translated">В режиме Haskell 98 и по умолчанию (но не в режиме Haskell 2010) GHC немного менее строг в отношении правила компоновки при использовании в выражениях &lt;code&gt;do&lt;/code&gt; . В частности, ограничение, заключающееся в том, что &amp;laquo;вложенный контекст должен иметь отступ вправо, чем включающий контекст&amp;raquo;, ослабляется, чтобы позволить вложенному контексту находиться на том же уровне, что и включающий контекст, если включающий контекст является выражением &lt;code&gt;do&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="599e88170bd7d883f77ba5d44a7ddebdba1a790b" translate="yes" xml:space="preserve">
          <source>In Haskell 98 the context of a class declaration (which introduces superclasses) must be simple; that is, each predicate must consist of a class applied to type variables. The extension &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;) lifts this restriction, so that the only restriction on the context in a class declaration is that the class hierarchy must be acyclic. So these class declarations are OK:</source>
          <target state="translated">В Haskell 98 контекст объявления класса (который вводит суперклассы) должен быть простым; то есть каждый предикат должен состоять из класса, применяемого к переменным типа. Расширение &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;#flexible-contexts&quot;&gt;контекст сигнатуры типа&lt;/a&gt; ) снимает это ограничение, так что единственное ограничение контекста в объявлении класса состоит в том, что иерархия классов должна быть ациклической. Итак, эти объявления классов в порядке:</target>
        </trans-unit>
        <trans-unit id="b4c8da415db612e5f1ea4bd84f8b71735ea83ad2" translate="yes" xml:space="preserve">
          <source>In Haskell 98 the head of an instance declaration must be of the form &lt;code&gt;C (T a1 ... an)&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; is the class, &lt;code&gt;T&lt;/code&gt; is a data type constructor, and the &lt;code&gt;a1 ... an&lt;/code&gt; are distinct type variables. In the case of multi-parameter type classes, this rule applies to each parameter of the instance head (Arguably it should be okay if just one has this form and the others are type variables, but that&amp;rsquo;s the rules at the moment).</source>
          <target state="translated">В Haskell 98 заголовок объявления экземпляра должен иметь форму &lt;code&gt;C (T a1 ... an)&lt;/code&gt; , где &lt;code&gt;C&lt;/code&gt; - это класс, &lt;code&gt;T&lt;/code&gt; - конструктор типа данных, а &lt;code&gt;a1 ... an&lt;/code&gt; - переменные разных типов. В случае многопараметрических классов типов это правило применяется к каждому параметру заголовка экземпляра (возможно, это должно быть нормально, если только один имеет эту форму, а остальные являются типовыми переменными, но это правила на данный момент).</target>
        </trans-unit>
        <trans-unit id="ea4ec2e25de3b576b30de329ce5f6bd4501065f2" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the class constraints in the context of the instance declaration must be of the form &lt;code&gt;C a&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is a type variable that occurs in the head.</source>
          <target state="translated">В Haskell 98 ограничения класса в контексте объявления экземпляра должны иметь форму &lt;code&gt;C a&lt;/code&gt; , где &lt;code&gt;a&lt;/code&gt; - это переменная типа, которая встречается в заголовке.</target>
        </trans-unit>
        <trans-unit id="fc46eaaf6d9e1c84e4c85176656529491f0cd53f" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the inferred kind for &lt;code&gt;App&lt;/code&gt; is &lt;code&gt;(Type -&amp;gt; Type) -&amp;gt; Type -&amp;gt;
Type&lt;/code&gt;. But this is overly specific, because another suitable Haskell 98 kind for &lt;code&gt;App&lt;/code&gt; is &lt;code&gt;((Type -&amp;gt; Type) -&amp;gt; Type) -&amp;gt; (Type -&amp;gt; Type) -&amp;gt; Type&lt;/code&gt;, where the kind assigned to &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. Indeed, without kind signatures (&lt;a href=&quot;#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;), it is necessary to use a dummy constructor to get a Haskell compiler to infer the second kind. With kind polymorphism (&lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;), GHC infers the kind &lt;code&gt;forall k. (k -&amp;gt; Type) -&amp;gt; k -&amp;gt;
Type&lt;/code&gt; for &lt;code&gt;App&lt;/code&gt;, which is its most general kind.</source>
          <target state="translated">В Haskell 98 предполагаемый тип &lt;code&gt;App&lt;/code&gt; - &lt;code&gt;(Type -&amp;gt; Type) -&amp;gt; Type -&amp;gt; Type&lt;/code&gt; . Но это слишком конкретно, потому что другой подходящий тип Haskell 98 для &lt;code&gt;App&lt;/code&gt; - это &lt;code&gt;((Type -&amp;gt; Type) -&amp;gt; Type) -&amp;gt; (Type -&amp;gt; Type) -&amp;gt; Type&lt;/code&gt; , где тип, присвоенный &lt;code&gt;a&lt;/code&gt; , - это &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; . Действительно, без добрых подписей ( &lt;a href=&quot;#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; &lt;/a&gt; ) необходимо использовать фиктивный конструктор, чтобы компилятор Haskell мог вывести второй тип. С помощью полиморфизма вида ( &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; ) GHC выводит вид для &lt;code&gt;forall k. (k -&amp;gt; Type) -&amp;gt; k -&amp;gt; Type&lt;/code&gt; for &lt;code&gt;App&lt;/code&gt; , что является его наиболее общим видом.</target>
        </trans-unit>
        <trans-unit id="aac9bc239948204f2a8d4ed156b20d8d29b1b9f6" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the only derivable classes are &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt;. &lt;a href=&quot;#deriving-extra&quot;&gt;Various language extensions&lt;/a&gt; extend this list.</source>
          <target state="translated">В Haskell 98 единственными производными классами являются &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Enum&lt;/code&gt; , &lt;code&gt;Ix&lt;/code&gt; , &lt;code&gt;Bounded&lt;/code&gt; , &lt;code&gt;Read&lt;/code&gt; и &lt;code&gt;Show&lt;/code&gt; . Этот список расширяют &lt;a href=&quot;#deriving-extra&quot;&gt;различные языковые расширения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2150415688076448290962ad6fd2b0c86ad5929a" translate="yes" xml:space="preserve">
          <source>In Haskell 98, we can define a parsing monad by</source>
          <target state="translated">В Хаскелле 98,мы можем определить синтаксическую монаду по</target>
        </trans-unit>
        <trans-unit id="4c90bfb63f72d089b5eed20faef5057d4b7a83ec" translate="yes" xml:space="preserve">
          <source>In Haskell, a &lt;code&gt;let&lt;/code&gt; expression is followed by &lt;code&gt;in&lt;/code&gt;. However, in GHCi, since the expression can also be interpreted in the &lt;code&gt;IO&lt;/code&gt; monad, a &lt;code&gt;let&lt;/code&gt; binding with no accompanying &lt;code&gt;in&lt;/code&gt; statement can be signalled by an empty line, as in the above example.</source>
          <target state="translated">В Haskell за выражением &lt;code&gt;let&lt;/code&gt; следует &lt;code&gt;in&lt;/code&gt; . Однако в GHCi, поскольку выражение также можно интерпретировать в монаде &lt;code&gt;IO&lt;/code&gt; , связывание &lt;code&gt;let&lt;/code&gt; без сопровождающего оператора &lt;code&gt;in&lt;/code&gt; может сигнализироваться пустой строкой, как в приведенном выше примере.</target>
        </trans-unit>
        <trans-unit id="9068501a015364519d15db889c0608523757cd88" translate="yes" xml:space="preserve">
          <source>In Haskell, a newline is always represented by the character &lt;code&gt;'\n'&lt;/code&gt;. However, in files and external character streams, a newline may be represented by another character sequence, such as &lt;code&gt;'\r\n'&lt;/code&gt;.</source>
          <target state="translated">В Haskell новая строка всегда представлена ​​символом &lt;code&gt;'\n'&lt;/code&gt; . Однако в файлах и внешних потоках символов новая строка может быть представлена ​​другой последовательностью символов, например &lt;code&gt;'\r\n'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf7c74c15737415db5c329d8398aaad16be0f6da" translate="yes" xml:space="preserve">
          <source>In Haskell, a programmer-written type signature is implicitly quantified over its free type variables (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.1.2&quot;&gt;Section 4.1.2&lt;/a&gt; of the Haskell Report). Lexically scoped type variables affect this implicit quantification rules as follows: any type variable that is in scope is &lt;em&gt;not&lt;/em&gt; universally quantified. For example, if type variable &lt;code&gt;a&lt;/code&gt; is in scope, then</source>
          <target state="translated">В Haskell сигнатура типа, написанная программистом, неявно определяется количественно по ее свободным переменным типа ( &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.1.2&quot;&gt;раздел 4.1.2&lt;/a&gt; отчета Haskell). Переменные типа с лексической областью видимости влияют на эти правила неявной количественной оценки следующим образом: любая переменная типа, которая находится в области видимости, &lt;em&gt;не&lt;/em&gt; подлежит универсальной количественной оценке. Например, если переменная типа &lt;code&gt;a&lt;/code&gt; находится в области видимости, то</target>
        </trans-unit>
        <trans-unit id="8a045d12bdfe38097b59295fbb7e2d5b85ec1646" translate="yes" xml:space="preserve">
          <source>In Haskell, floating-point operations have pure types, and the evaluation order is unspecified. So strictly speaking, since the &lt;code&gt;fenv.h&lt;/code&gt; functions let you change the results of, or observe the effects of floating point operations, use of &lt;code&gt;fenv.h&lt;/code&gt; renders the behaviour of floating-point operations anywhere in the program undefined.</source>
          <target state="translated">В Haskell у операций с плавающей запятой есть чистые типы, и порядок вычисления не определен. Строго говоря, поскольку функции &lt;code&gt;fenv.h&lt;/code&gt; позволяют вам изменять результаты или наблюдать за эффектами операций с плавающей запятой, использование &lt;code&gt;fenv.h&lt;/code&gt; отображает поведение операций с плавающей запятой в любом месте программы undefined.</target>
        </trans-unit>
        <trans-unit id="0d8a1e12648617b7ab29a94bd933ecabcb8fcfe6" translate="yes" xml:space="preserve">
          <source>In Haskell, you can&amp;rsquo;t write a type signature in an instance declaration, but it is sometimes convenient to do so, and the language extension &lt;a href=&quot;#extension-InstanceSigs&quot;&gt;&lt;code&gt;InstanceSigs&lt;/code&gt;&lt;/a&gt; allows you to do so. For example:</source>
          <target state="translated">В Haskell вы не можете написать сигнатуру типа в объявлении экземпляра, но иногда это удобно, и расширение языка &lt;a href=&quot;#extension-InstanceSigs&quot;&gt; &lt;code&gt;InstanceSigs&lt;/code&gt; &lt;/a&gt; позволяет вам это сделать. Например:</target>
        </trans-unit>
        <trans-unit id="8427a76c9ee7a864a646e420064761a09284fce9" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;closed type family&lt;/em&gt; all equations are ordered and in one place. Equations are also checked pair-wise but this time an equation has to be paired with all the preceeding equations. Of course a single-equation closed type family is trivially injective (unless (1), (2) or (3) above holds).</source>
          <target state="translated">В &lt;em&gt;семействе закрытого типа&lt;/em&gt; все уравнения упорядочены и собраны в одном месте. Уравнения также проверяются попарно, но на этот раз уравнение должно быть связано со всеми предыдущими уравнениями. Конечно, семейство замкнутого типа с одним уравнением тривиально инъективно (если не выполняется (1), (2) или (3) выше).</target>
        </trans-unit>
        <trans-unit id="450e95ea754d91229aeb1e695390ebec4e7895e5" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;source&lt;/em&gt; program this would declare TA to have no constructors (a GHC extension: see &lt;a href=&quot;glasgow_exts#nullary-types&quot;&gt;Data types with no constructors&lt;/a&gt;), but in an hi-boot file it means &amp;ldquo;I don&amp;rsquo;t know or care what the constructors are&amp;rdquo;. This is the most common form of data type declaration, because it&amp;rsquo;s easy to get right. You &lt;em&gt;can&lt;/em&gt; also write out the constructors but, if you do so, you must write it out precisely as in its real definition.</source>
          <target state="translated">В &lt;em&gt;исходной&lt;/em&gt; программе это объявило бы, что TA не имеет конструкторов (расширение GHC: см. &lt;a href=&quot;glasgow_exts#nullary-types&quot;&gt;Типы данных без конструкторов&lt;/a&gt; ), но в файле с высокой загрузкой это означает: &amp;laquo;Я не знаю и не интересуюсь конструкторами&amp;raquo;. Это наиболее распространенная форма объявления типа данных, потому что ее легко понять. Вы также &lt;em&gt;можете&lt;/em&gt; выписать конструкторы, но, если вы это сделаете, вы должны записать их точно так же, как в их реальном определении.</target>
        </trans-unit>
        <trans-unit id="64d45f71dec31ef9b1d51fa3c3cf25f39fcadcc0" translate="yes" xml:space="preserve">
          <source>In a GADT-style data type declaration there is no obvious way to specify that a data constructor should be infix, which makes a difference if you derive &lt;code&gt;Show&lt;/code&gt; for the type. (Data constructors declared infix are displayed infix by the derived &lt;code&gt;show&lt;/code&gt;.) So GHC implements the following design: a data constructor declared in a GADT-style data type declaration is displayed infix by &lt;code&gt;Show&lt;/code&gt; iff (a) it is an operator symbol, (b) it has two arguments, (c) it has a programmer-supplied fixity declaration. For example</source>
          <target state="translated">В объявлении типа данных в стиле GADT нет очевидного способа указать, что конструктор данных должен быть инфиксным, что имеет значение, если вы производите &lt;code&gt;Show&lt;/code&gt; для типа. (Конструкторы данных, объявленные инфиксными, отображаются в инфиксе производным &lt;code&gt;show&lt;/code&gt; .) Таким образом, GHC реализует следующий дизайн: конструктор данных, объявленный в объявлении типа данных в стиле GADT, отображается инфиксным с помощью &lt;code&gt;Show&lt;/code&gt; iff (a) это символ оператора, (b ) у него есть два аргумента, (c) у него есть объявление исправления, предоставленное программистом. Например</target>
        </trans-unit>
        <trans-unit id="07a23e9f4a3adccc2a7677063668d39db095dd14" translate="yes" xml:space="preserve">
          <source>In a class declaration, all of the class type variables must be reachable (in the sense mentioned in &lt;a href=&quot;#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;) from the free variables of each method type. For example:</source>
          <target state="translated">В объявлении класса все переменные типа класса должны быть достижимы (в смысле, упомянутом в &lt;a href=&quot;#flexible-contexts&quot;&gt;контексте сигнатуры типа&lt;/a&gt; ) из свободных переменных каждого типа метода. Например:</target>
        </trans-unit>
        <trans-unit id="8c6ea776cade0a00536fe0dd1e2c07174843e962" translate="yes" xml:space="preserve">
          <source>In a concurrent program, &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; operations may appear out-of-order to another thread, depending on the memory model of the underlying processor architecture. For example, on x86, loads can move ahead of stores, so in the following example:</source>
          <target state="translated">В параллельной программе операции &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; могут казаться неупорядоченными для другого потока, в зависимости от модели памяти базовой архитектуры процессора. Например, на x86 загрузка может идти впереди магазина, поэтому в следующем примере:</target>
        </trans-unit>
        <trans-unit id="8414a11b42213e9da0ee87ae53530ee3ce8a4f45" translate="yes" xml:space="preserve">
          <source>In a few cases, even equality constraints cannot be deferred. Specifically:</source>
          <target state="translated">В некоторых случаях даже ограничения в отношении равенства не могут быть отложены.В частности:</target>
        </trans-unit>
        <trans-unit id="b3f8a7d6c3b7eb5e07bab83a298a4d4322657fec" translate="yes" xml:space="preserve">
          <source>In a form that checks the invariant lazily.</source>
          <target state="translated">В форме,которая лениво проверяет инварианта.</target>
        </trans-unit>
        <trans-unit id="0e001e5b19bb7f459d52b88fa8993534911ab892" translate="yes" xml:space="preserve">
          <source>In a future release of GHC, both &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;kindOf&lt;/code&gt; will be rejected per the &amp;ldquo;forall-or-nothing&amp;rdquo; rule. This warning, being part of the &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, allows to detect this before the actual breaking change takes place.</source>
          <target state="translated">В будущих версиях GHC и &lt;code&gt;n&lt;/code&gt; , и &lt;code&gt;kindOf&lt;/code&gt; будут отклонены по правилу &amp;laquo;все или ничего&amp;raquo;. Это предупреждение, являющееся частью группы &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt; , позволяет обнаружить это до того, как произойдет фактическое критическое изменение.</target>
        </trans-unit>
        <trans-unit id="a786f90842cfbc1183ff12a32670a5ffa98f0bc7" translate="yes" xml:space="preserve">
          <source>In a multithreaded program, the current working directory is a global state shared among all threads of the process. Therefore, when performing filesystem operations from multiple threads, it is highly recommended to use absolute rather than relative paths (see: &lt;code&gt;&lt;a href=&quot;system-directory#v:makeAbsolute&quot;&gt;makeAbsolute&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">В многопоточной программе текущий рабочий каталог является глобальным состоянием, совместно используемым всеми потоками процесса. Поэтому при выполнении операций с файловой системой из нескольких потоков настоятельно рекомендуется использовать абсолютные, а не относительные пути (см. &lt;code&gt;&lt;a href=&quot;system-directory#v:makeAbsolute&quot;&gt;makeAbsolute&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="61315f4b8bb71a0b1c939d36bc50aba8647c5d4e" translate="yes" xml:space="preserve">
          <source>In a pattern context</source>
          <target state="translated">В закономерном контексте</target>
        </trans-unit>
        <trans-unit id="9010ad7519addcc90a448173aedba3758c2fa46a" translate="yes" xml:space="preserve">
          <source>In a pattern context with field puns</source>
          <target state="translated">В контексте шаблона с каламбурами</target>
        </trans-unit>
        <trans-unit id="71bde6dc1de743e6a58a0db5f14b26f355407ecb" translate="yes" xml:space="preserve">
          <source>In a pattern context with record syntax</source>
          <target state="translated">В контексте шаблона с синтаксисом записи</target>
        </trans-unit>
        <trans-unit id="f7c8cccfc50e043aecf8ac5ce9ee8531c541f745" translate="yes" xml:space="preserve">
          <source>In a pattern type signature (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;)</source>
          <target state="translated">В сигнатуре типа шаблона (см. &lt;a href=&quot;#scoped-type-variables&quot;&gt;Переменные типа с лексической областью видимости&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="6844f7a79c5dfe3ec9aa5a919c116ac89f9053b7" translate="yes" xml:space="preserve">
          <source>In a record update</source>
          <target state="translated">В обновлении записи</target>
        </trans-unit>
        <trans-unit id="fa8401c566cf94c06de714273e8a2c803bf6fdb3" translate="yes" xml:space="preserve">
          <source>In a record update such as &lt;code&gt;e { x = 1 }&lt;/code&gt;, if there are multiple &lt;code&gt;x&lt;/code&gt; fields in scope, then the type of the context must fix which record datatype is intended, or a type annotation must be supplied. Consider the following definitions:</source>
          <target state="translated">При обновлении записи, таком как &lt;code&gt;e { x = 1 }&lt;/code&gt; , если в области действия несколько полей &lt;code&gt;x&lt;/code&gt; , то тип контекста должен указывать, какой тип данных записи предназначен, или должна быть предоставлена ​​аннотация типа. Рассмотрим следующие определения:</target>
        </trans-unit>
        <trans-unit id="0bd9f17a624418d16516d174a2fcb42b7bab910d" translate="yes" xml:space="preserve">
          <source>In a similar way, the earlier definition of &lt;code&gt;g&lt;/code&gt; will now be flagged as a type error.</source>
          <target state="translated">Аналогичным образом, более раннее определение &lt;code&gt;g&lt;/code&gt; теперь будет помечено как ошибка типа.</target>
        </trans-unit>
        <trans-unit id="3ce7f512726e8d285ac156a0f35f6359e45bcb80" translate="yes" xml:space="preserve">
          <source>In a single pattern, variables bound by patterns to the left of a view pattern expression are in scope. For example:</source>
          <target state="translated">В одном шаблоне в области видимости находятся переменные,ограниченные шаблонами слева от выражения шаблона видимости.Например:</target>
        </trans-unit>
        <trans-unit id="85b6b61563103c5b7dfd5b620fb5437b770cc196" translate="yes" xml:space="preserve">
          <source>In a standalone GHC program, only the main thread is required to terminate in order for the process to terminate. Thus all other forked threads will simply terminate at the same time as the main thread (the terminology for this kind of behaviour is &quot;daemonic threads&quot;).</source>
          <target state="translated">В автономной программе GHC для завершения процесса требуется только основной поток.Таким образом,все остальные вилочные потоки будут просто завершаться одновременно с главным потоком (терминология такого поведения-&quot;демонические потоки&quot;).</target>
        </trans-unit>
        <trans-unit id="0aa908ae420e77e1f4bb85ee334ad239c1ccb262" translate="yes" xml:space="preserve">
          <source>In a strict monad you know when each action is executed, but the monad is not necessarily strict in the return value, or in other components of the monad, such as a state. However you can use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; to create an action that is strict in the component you want evaluated.</source>
          <target state="translated">В строгой монаде вы знаете, когда выполняется каждое действие, но монада не обязательно является строгой в отношении возвращаемого значения или других компонентов монады, таких как состояние. Однако вы можете использовать &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; для создания строгого действия в компоненте, который вы хотите оценить.</target>
        </trans-unit>
        <trans-unit id="7880166b35b3a24c62f866c80bb1e9fca6aab314" translate="yes" xml:space="preserve">
          <source>In a strict monad you know when each action is executed, but the monad is not necessarily strict in the return value, or in other components of the monad, such as a state. However you can use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; to create an action that is strict in the component you want evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43015c398315c351d899f4cc070e29bfc23b64c4" translate="yes" xml:space="preserve">
          <source>In absence of an inline kind annotation, the inferred arity includes all explicitly bound parameters and all immediately following invisible parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4597cb1599aee82731cada610232980bbc2d3431" translate="yes" xml:space="preserve">
          <source>In addition &lt;code&gt;#{stuff}&lt;/code&gt; is equivalent to &lt;code&gt;#stuff&lt;/code&gt; except that it&amp;rsquo;s self-delimited and thus needs not to be placed at the end of line or in some brackets.</source>
          <target state="translated">Кроме того, &lt;code&gt;#{stuff}&lt;/code&gt; эквивалентно &lt;code&gt;#stuff&lt;/code&gt; , за исключением того, что он саморазграничивается, и поэтому его не нужно помещать в конец строки или в скобки.</target>
        </trans-unit>
        <trans-unit id="eb314fe5b2039048608ae504bca0f576e50cf0b7" translate="yes" xml:space="preserve">
          <source>In addition to Core plugins, GHC has experimental support for typechecker plugins, which allow the behaviour of the constraint solver to be modified. For example, they make it possible to interface the compiler to an SMT solver, in order to support a richer theory of type-level arithmetic expressions than the theory built into GHC (see &lt;a href=&quot;glasgow_exts#typelit-tyfuns&quot;&gt;Computing With Type-Level Naturals&lt;/a&gt;).</source>
          <target state="translated">В дополнение к модулям Core GHC имеет экспериментальную поддержку подключаемых модулей проверки типов, которые позволяют изменять поведение решателя ограничений. Например, они позволяют связать компилятор с решателем SMT, чтобы поддерживать более обширную теорию арифметических выражений на уровне типов, чем теория, встроенная в GHC (см. &lt;a href=&quot;glasgow_exts#typelit-tyfuns&quot;&gt;Вычисления с&lt;/a&gt; естественными выражениями на уровне типов ).</target>
        </trans-unit>
        <trans-unit id="a4828c748a125eae444ad80c1e864e71abc3d059" translate="yes" xml:space="preserve">
          <source>In addition to being equivalent in the structural sense, the two also have &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instances that behave the same. This type will be marked deprecated in GHC 8.8, and removed in GHC 8.10. Users are advised to use the variant from &lt;a href=&quot;data-semigroup&quot;&gt;Data.Semigroup&lt;/a&gt; and wrap it in &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Помимо эквивалентности в структурном смысле, эти два экземпляра также имеют экземпляры &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; , которые ведут себя одинаково. Этот тип будет помечен как устаревший в GHC 8.8 и удален в GHC 8.10. Пользователям рекомендуется использовать вариант из &lt;a href=&quot;data-semigroup&quot;&gt;Data.Semigroup&lt;/a&gt; и обернуть его в &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8311e5504e292a63b6e04f775b8d4c2184db072" translate="yes" xml:space="preserve">
          <source>In addition to core and type checker plugins, you can install plugins that can access different representations of the source code. The main purpose of these plugins is to make it easier to implement development tools.</source>
          <target state="translated">В дополнение к плагинам проверки ядра и типа,вы можете установить плагины,которые могут иметь доступ к различным представлениям исходного кода.Основное назначение этих плагинов-облегчить реализацию средств разработки.</target>
        </trans-unit>
        <trans-unit id="babc3f5d8badd87263ede33fef263b59d78b2950" translate="yes" xml:space="preserve">
          <source>In addition to creating a DLL, the &lt;code&gt;-shared&lt;/code&gt; option also creates an import library. The import library name is derived from the name of the DLL, as follows:</source>
          <target state="translated">Помимо создания DLL, параметр &lt;code&gt;-shared&lt;/code&gt; также создает библиотеку импорта. Имя библиотеки импорта происходит от имени библиотеки DLL, как показано ниже:</target>
        </trans-unit>
        <trans-unit id="249a7c61164a88062524e2aa24c887b8f5661159" translate="yes" xml:space="preserve">
          <source>In addition to exceptions thrown by &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, exceptions may be thrown by pure code (imprecise exceptions) or by external events (asynchronous exceptions), but may only be caught in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. For more details, see:</source>
          <target state="translated">В дополнение к исключениям, создаваемым операциями &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; , исключения могут создаваться чистым кодом (неточные исключения) или внешними событиями (асинхронные исключения), но могут быть пойманы только в монаде &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; . Подробнее см .:</target>
        </trans-unit>
        <trans-unit id="8ee7bbb76ed60016773cd70eeacaa30823fc8982" translate="yes" xml:space="preserve">
          <source>In addition to profiling the time and allocation behaviour of your program, you can also generate a graph of its memory usage over time. This is useful for detecting the causes of space leaks, when your program holds on to more memory at run-time that it needs to. Space leaks lead to slower execution due to heavy garbage collector activity, and may even cause the program to run out of memory altogether.</source>
          <target state="translated">Помимо профилирования времени и поведения распределения вашей программы,вы также можете сгенерировать график использования ее памяти с течением времени.Это полезно для выявления причин утечки памяти,когда Ваша программа удерживает во время выполнения больше памяти,чем ей необходимо.Утечка места приводит к замедлению выполнения из-за сильной активности сборщика мусора и может даже привести к полному исчерпанию памяти программы.</target>
        </trans-unit>
        <trans-unit id="6a5fe76494632cc57e366196cfdfa66ddce021ab" translate="yes" xml:space="preserve">
          <source>In addition to the data that has just been written into your buffer by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action, it gives you a pre-existing chunk of data as a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It also gives you the following &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action. It is safe to run this following action using a buffer with as much free space as was left by the previous run action.</source>
          <target state="translated">В дополнение к данным, которые только что были записаны в ваш буфер действием &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; , он предоставляет вам уже существующий фрагмент данных в виде &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . Он также дает вам следующее действие &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; . Это следующее действие безопасно запускать, используя буфер со свободным пространством, оставшимся после предыдущего действия.</target>
        </trans-unit>
        <trans-unit id="68a3d1c2998b358fa67a87a4eae02294a3a1f06e" translate="yes" xml:space="preserve">
          <source>In addition to the usual DIEs specified by the DWARF specification, GHC produces a variety of others using the vendor-extensibility regions of the tag and attribute space.</source>
          <target state="translated">В дополнение к обычным DIE,указанным в спецификации DWARF,GHC производит множество других,используя регионы расширяемости тегов и пространство атрибутов производителя.</target>
        </trans-unit>
        <trans-unit id="367b4aa700725245db9b4214f26896949ea4e52a" translate="yes" xml:space="preserve">
          <source>In addition you can use the &lt;a href=&quot;#rts-flag--P&quot;&gt;&lt;code&gt;-P&lt;/code&gt;&lt;/a&gt; RTS option to get the following additional information:</source>
          <target state="translated">Кроме того, вы можете использовать параметр &lt;a href=&quot;#rts-flag--P&quot;&gt; &lt;code&gt;-P&lt;/code&gt; &lt;/a&gt; RTS, чтобы получить следующую дополнительную информацию:</target>
        </trans-unit>
        <trans-unit id="34a0aaebb5d7ddb8779614a440c8d24ce42c1bca" translate="yes" xml:space="preserve">
          <source>In addition, in &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt;&lt;/code&gt; mode, &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; will throw a &lt;code&gt;UserInterrupt&lt;/code&gt; exception if the process terminated with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt; (-SIGINT)&lt;/code&gt;. Typically you will not want to catch this exception, but let it propagate, giving a normal orderly shutdown. One detail to be aware of is that the &lt;code&gt;UserInterrupt&lt;/code&gt; exception is thrown &lt;em&gt;synchronously&lt;/em&gt; in the thread that calls &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;, whereas normally &lt;code&gt;SIGINT&lt;/code&gt; causes the exception to be thrown &lt;em&gt;asynchronously&lt;/em&gt; to the main thread.</source>
          <target state="translated">Кроме того, в &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt;&lt;/code&gt; режиме, &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; будет бросать &lt;code&gt;UserInterrupt&lt;/code&gt; исключение , если процесс завершается с &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt; (-SIGINT)&lt;/code&gt; . Обычно вы не хотите перехватывать это исключение, но позволяете ему распространяться, обеспечивая нормальное упорядоченное завершение работы. Следует иметь в &lt;code&gt;UserInterrupt&lt;/code&gt; исключение UserInterrupt генерируется &lt;em&gt;синхронно&lt;/em&gt; в потоке, который вызывает &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; , тогда как обычно &lt;code&gt;SIGINT&lt;/code&gt; вызывает &lt;em&gt;асинхронное &lt;/em&gt;генерирование исключения в основном потоке.</target>
        </trans-unit>
        <trans-unit id="90bb874cbfbf13e44d04cff0d054e6082425071b" translate="yes" xml:space="preserve">
          <source>In addition, the datatype that is meant may be given as a type signature on the argument to the selector:</source>
          <target state="translated">Кроме того,подразумеваемый тип данных может быть задан в качестве сигнатуры типа на аргументе к селектору:</target>
        </trans-unit>
        <trans-unit id="4126bb6eb85667a0ba0f06971d33a3e7b8c05e03" translate="yes" xml:space="preserve">
          <source>In addition, the profile can be restricted to heap data which satisfies certain criteria - for example, you might want to display a profile by type but only for data produced by a certain module, or a profile by retainer for a certain type of data. Restrictions are specified as follows:</source>
          <target state="translated">Кроме того,профиль может быть ограничен кучами данных,которые соответствуют определенным критериям-например,вы можете захотеть отобразить профиль по типу,но только для данных,произведенных определенным модулем,или профиль по фиксатору для определенного типа данных.Ограничения указываются следующим образом:</target>
        </trans-unit>
        <trans-unit id="99e228e4f1543c3dc7a9d1ed29f66747995deb83" translate="yes" xml:space="preserve">
          <source>In addition, there are some fields with special syntax (e.g. package names, version, dependencies).</source>
          <target state="translated">Кроме того,есть некоторые поля со специальным синтаксисом (например,имена пакетов,версии,зависимости).</target>
        </trans-unit>
        <trans-unit id="d6e619bf7b233d387015ddc79828be55161d099a" translate="yes" xml:space="preserve">
          <source>In addition, with &lt;a href=&quot;#extension-PatternSynonyms&quot;&gt;&lt;code&gt;PatternSynonyms&lt;/code&gt;&lt;/a&gt; you can prefix the name of a data constructor in an import or export list with the keyword &lt;code&gt;pattern&lt;/code&gt;, to allow the import or export of a data constructor without its parent type constructor (see &lt;a href=&quot;#patsyn-impexp&quot;&gt;Import and export of pattern synonyms&lt;/a&gt;).</source>
          <target state="translated">Кроме того, с помощью &lt;a href=&quot;#extension-PatternSynonyms&quot;&gt; &lt;code&gt;PatternSynonyms&lt;/code&gt; &lt;/a&gt; вы можете префикс имени конструктора данных в списке импорта или экспорта с помощью &lt;code&gt;pattern&lt;/code&gt; ключевого слова , чтобы разрешить импорт или экспорт конструктора данных без его конструктора родительского типа (см. &lt;a href=&quot;#patsyn-impexp&quot;&gt;Импорт и экспорт синонимов шаблона&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3132ea808ceba667f793dbacd623742dade438fc" translate="yes" xml:space="preserve">
          <source>In all cases (apart from arrow notation), the static semantics should be that of the desugared form, even if that is a little unexpected. For example, the static semantics of the literal &lt;code&gt;368&lt;/code&gt; is exactly that of &lt;code&gt;fromInteger (368::Integer)&lt;/code&gt;; it&amp;rsquo;s fine for &lt;code&gt;fromInteger&lt;/code&gt; to have any of the types:</source>
          <target state="translated">Во всех случаях (кроме обозначений стрелок) статическая семантика должна соответствовать обессахаренной форме, даже если это немного неожиданно. Например, статическая семантика литерала &lt;code&gt;368&lt;/code&gt; в точности такая же, как у &lt;code&gt;fromInteger (368::Integer)&lt;/code&gt; ; Для &lt;code&gt;fromInteger&lt;/code&gt; нормально иметь любой из типов:</target>
        </trans-unit>
        <trans-unit id="5f38c78f8727c5dd6daeb670eabd5e48e13730ce" translate="yes" xml:space="preserve">
          <source>In all other contexts, type wildcards are disallowed, and a named wildcard is treated as an ordinary type variable. For example:</source>
          <target state="translated">Во всех других контекстах подстановочные знаки типа запрещены,а именованный подстановочный знак рассматривается как обычная переменная типа.Например:</target>
        </trans-unit>
        <trans-unit id="e57867e96afea7ee28118e42687442828dc1fec7" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;instance&lt;/code&gt; declaration for the class, if no explicit &lt;code&gt;type instance&lt;/code&gt; declaration is given for the associated type, the default declaration is used instead, just as with default class methods.</source>
          <target state="translated">В объявлении &lt;code&gt;instance&lt;/code&gt; для класса, если для связанного типа не указано явное объявление &lt;code&gt;type instance&lt;/code&gt; типа, вместо него используется объявление по умолчанию, как и в случае с методами класса по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e2a6cf8b0ee18b4eb7df425b8e1b8603664a8706" translate="yes" xml:space="preserve">
          <source>In an import or export list, such as</source>
          <target state="translated">В списке импортируемых или экспортируемых товаров,например</target>
        </trans-unit>
        <trans-unit id="cc915ffb21811be1dad23381dc586229e4878e9d" translate="yes" xml:space="preserve">
          <source>In associated types, we order the type variables as if the type family was a top-level declaration, ignoring the visibilities of the class&amp;rsquo;s type variable binders. Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55a4f9d1aac9b09d0ad21c5b54130b49a8ea4a4" translate="yes" xml:space="preserve">
          <source>In base we can't use wordToNatural# as built-in rules transform some of them into Natural literals. Use this function instead.</source>
          <target state="translated">В базе мы не можем использовать словоToNatural#,так как встроенные правила превращают некоторые из них в естественные литералы.Вместо этого используйте эту функцию.</target>
        </trans-unit>
        <trans-unit id="734a9d6aacdebfcf8e099a4ac67e6c63811f6437" translate="yes" xml:space="preserve">
          <source>In batch compilation mode, the name of the object file can also be overridden using the &lt;a href=&quot;#ghc-flag--o%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-o ⟨file⟩&lt;/code&gt;&lt;/a&gt; option, and the name of the interface file can be specified directly using the &lt;a href=&quot;#ghc-flag--ohi%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-ohi ⟨file⟩&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="translated">В режиме пакетной компиляции имя объектного файла также можно переопределить с помощью параметра &lt;a href=&quot;#ghc-flag--o%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-o ⟨file⟩&lt;/code&gt; &lt;/a&gt; , а имя файла интерфейса можно указать напрямую с помощью параметра &lt;a href=&quot;#ghc-flag--ohi%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-ohi ⟨file⟩&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dabb8697131df61b0e2fe80e2efe74db486060e0" translate="yes" xml:space="preserve">
          <source>In binary format to a file for later analysis by a variety of tools. One such tool is &lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt;, which interprets the event log to produce a visual parallel execution profile of the program.</source>
          <target state="translated">В двоичном формате в файл для последующего анализа различными инструментами. Одним из таких инструментов является &lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt; , который интерпретирует журнал событий для создания визуального профиля параллельного выполнения программы.</target>
        </trans-unit>
        <trans-unit id="03034364819bbabad90c6e7c5e8b8d93809898f3" translate="yes" xml:space="preserve">
          <source>In binary format to customized event log writer. This enables live analysis of the events while the program is running.</source>
          <target state="translated">В двоичном формате к настраиваемому регистратору событий.Это позволяет в реальном времени анализировать события во время работы программы.</target>
        </trans-unit>
        <trans-unit id="31be45f64d4525c6c8cb6e9758d8d1527903b2fe" translate="yes" xml:space="preserve">
          <source>In binding positions, we have similar parsing rules. Consider the following example</source>
          <target state="translated">В связующих позициях мы имеем аналогичные правила разбора.Рассмотрим следующий пример</target>
        </trans-unit>
        <trans-unit id="0ed50f5a5fcb2b11667475d2e83b41c38eee4ebd" translate="yes" xml:space="preserve">
          <source>In both cases &lt;code&gt;e&lt;/code&gt; is evaluated before starting to evaluate &lt;code&gt;body&lt;/code&gt;.</source>
          <target state="translated">В обоих случаях &lt;code&gt;e&lt;/code&gt; оценивается до начала оценки &lt;code&gt;body&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bacc600884c7ef880d3490fde1eab0149e179ff1" translate="yes" xml:space="preserve">
          <source>In both cases, &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; are available both throughout the &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;rec&lt;/code&gt; block, and in the statements that follow it. The difference is that &lt;code&gt;let&lt;/code&gt; is non-monadic, while &lt;code&gt;rec&lt;/code&gt; is monadic. (In Haskell &lt;code&gt;let&lt;/code&gt; is really &lt;code&gt;letrec&lt;/code&gt;, of course.)</source>
          <target state="translated">В обоих случаях &lt;code&gt;r1&lt;/code&gt; и &lt;code&gt;r2&lt;/code&gt; доступны как в блоке &lt;code&gt;let&lt;/code&gt; или &lt;code&gt;rec&lt;/code&gt; , так и в следующих за ним операторах. Разница в том, что &lt;code&gt;let&lt;/code&gt; немонадическая, а &lt;code&gt;rec&lt;/code&gt; монадическая. (В Haskell &lt;code&gt;let&lt;/code&gt; действительно &lt;code&gt;letrec&lt;/code&gt; , конечно.)</target>
        </trans-unit>
        <trans-unit id="be81ef5fcc497dfbbeafbf556c2438a6c9895ee9" translate="yes" xml:space="preserve">
          <source>In case you try to derive some class on a newtype, and &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; is also on, &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; takes precedence.</source>
          <target state="translated">В случае, если вы пытаетесь наследовать какой-либо класс от нового типа, а &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt; также &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; , DeriveAnyClass имеет приоритет.</target>
        </trans-unit>
        <trans-unit id="a51760f56c296114327d0a572e7ed7fabe636444" translate="yes" xml:space="preserve">
          <source>In cases where several instances of &lt;code&gt;needle&lt;/code&gt; overlap, only the first one will be replaced:</source>
          <target state="translated">В случаях, когда несколько случаев перекрытия &lt;code&gt;needle&lt;/code&gt; , будет заменена только первая:</target>
        </trans-unit>
        <trans-unit id="0f9ef87c7934b0a5953335739ae5904bf71e50d1" translate="yes" xml:space="preserve">
          <source>In concert with &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;, GHC supports higher-rank kinds. Here is an example:</source>
          <target state="translated">&lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt; с RankNTypes GHC поддерживает типы более высокого ранга. Вот пример:</target>
        </trans-unit>
        <trans-unit id="ecd1bab6934e5b406a45cc9d86aaae1eda35aa2c" translate="yes" xml:space="preserve">
          <source>In conjunction with the &lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt;&lt;code&gt;EmptyDataDeriving&lt;/code&gt;&lt;/a&gt; extension, empty data declarations can also derive instances of standard type classes (see &lt;a href=&quot;#empty-data-deriving&quot;&gt;Deriving instances for empty data types&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0160dd1b8a2fb226728d5dc6a312d10bda3db9e4" translate="yes" xml:space="preserve">
          <source>In conjunction with the &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt;&lt;code&gt;-XEmptyDataDeriving&lt;/code&gt;&lt;/a&gt; extension, empty data declarations can also derive instances of standard type classes (see &lt;a href=&quot;#empty-data-deriving&quot;&gt;Deriving instances for empty data types&lt;/a&gt;).</source>
          <target state="translated">В сочетании с расширением &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt; &lt;code&gt;-XEmptyDataDeriving&lt;/code&gt; &lt;/a&gt; объявления пустых данных могут также создавать экземпляры классов стандартных типов (см. &lt;a href=&quot;#empty-data-deriving&quot;&gt;Получение экземпляров для пустых типов данных&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b20440f6fb3e228846c05d91a5f12ecb0390cdea" translate="yes" xml:space="preserve">
          <source>In contrast, there is no reliable way to do this for &lt;code&gt;g&lt;/code&gt;; we will not know whether &lt;code&gt;Eq a&lt;/code&gt; or &lt;code&gt;Eq b&lt;/code&gt; will be listed first in the constraint in &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s type. In order to have visible type application be robust between releases of GHC, we thus forbid its use with &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">Напротив, нет надежного способа сделать это для &lt;code&gt;g&lt;/code&gt; ; мы не будем знать, будет ли &lt;code&gt;Eq a&lt;/code&gt; или &lt;code&gt;Eq b&lt;/code&gt; указано первым в ограничении в типе &lt;code&gt;g&lt;/code&gt; . Чтобы приложение видимого типа было устойчивым между выпусками GHC, мы запрещаем его использование с &lt;code&gt;g&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22f781a5702b84d96719b279819ee7bee564bebe" translate="yes" xml:space="preserve">
          <source>In contrast, there is no reliable way to do this for &lt;code&gt;g&lt;/code&gt;; we will not know whether &lt;code&gt;Eq a&lt;/code&gt; or &lt;code&gt;Eq b&lt;/code&gt; will be listed first in the constraint in &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s type. In order to have visible type application be robust between releases of GHC, we thus forbid its use with &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3824b67115f2edecbe27bdcb0540496f21f8bbe" translate="yes" xml:space="preserve">
          <source>In dumps, suppress everything (except for uniques) that is suppressible.</source>
          <target state="translated">На свалках подавляйте все (за исключением уникальных),что является допустимым.</target>
        </trans-unit>
        <trans-unit id="827cb020739fbf9c40831c2ab9e7d2857ae60ae1" translate="yes" xml:space="preserve">
          <source>In each case the appropriate class must be in scope before it can be mentioned in the &lt;code&gt;deriving&lt;/code&gt; clause.</source>
          <target state="translated">В каждом случае соответствующий класс должен быть в области видимости, прежде чем он может быть упомянут в &lt;code&gt;deriving&lt;/code&gt; предложении.</target>
        </trans-unit>
        <trans-unit id="ea2baf294e27435a713527ed1fabd3f79a5937ec" translate="yes" xml:space="preserve">
          <source>In earlier versions of GHC, it was possible to omit the &lt;code&gt;forall&lt;/code&gt; in the type of the constructor if there was an explicit context. For example:</source>
          <target state="translated">В более ранних версиях GHC можно было опустить &lt;code&gt;forall&lt;/code&gt; в типе конструктора, если был явный контекст. Например:</target>
        </trans-unit>
        <trans-unit id="1fa31c0c659980e252d481c558bed906f0492165" translate="yes" xml:space="preserve">
          <source>In either case, C is the only authority on package trust. It is up to the client to decide which &lt;a href=&quot;#safe-package-trust&quot;&gt;packages they trust&lt;/a&gt;.</source>
          <target state="translated">В любом случае C является единственным органом по доверию пакетов. Клиент должен решить, каким &lt;a href=&quot;#safe-package-trust&quot;&gt;пакетам он доверяет&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e577bd1cf962e0880951f56bb28b5bcc144b9dbd" translate="yes" xml:space="preserve">
          <source>In error messages, expressions are printed to a certain &amp;ldquo;depth&amp;rdquo;, with subexpressions beyond the depth replaced by ellipses. This flag sets the depth. Its default value is 5.</source>
          <target state="translated">В сообщениях об ошибках выражения печатаются с определенной &amp;laquo;глубиной&amp;raquo;, а подвыражения за пределами глубины заменяются эллипсами. Этот флаг устанавливает глубину. Его значение по умолчанию - 5.</target>
        </trans-unit>
        <trans-unit id="4aea9c2bc91c202848f5c9b6db19bf9964c3bd1d" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;#pragma-UNPACK&quot;&gt;&lt;code&gt;UNPACK&lt;/code&gt;&lt;/a&gt; has no effect without &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, for technical reasons (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5252&quot;&gt;#5252&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3785b1fb09bd9bd3050ae561da76ff7c2ea38ed" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;#pragma-UNPACK&quot;&gt;&lt;code&gt;UNPACK&lt;/code&gt;&lt;/a&gt; has no effect without &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, for technical reasons (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5252&quot;&gt;Issue #5252&lt;/a&gt;).</source>
          <target state="translated">Фактически, &lt;a href=&quot;#pragma-UNPACK&quot;&gt; &lt;code&gt;UNPACK&lt;/code&gt; не&lt;/a&gt; работает без &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; по техническим причинам (см. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5252&quot;&gt;Issue # 5252&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3bbd3972ad6aafb5b6e87ed35007593f460b926a" translate="yes" xml:space="preserve">
          <source>In fact, GHC enters make mode automatically if there are any Haskell source files on the command line and no other mode is specified, so in this case we could just type</source>
          <target state="translated">На самом деле,GHC автоматически переходит в режим make,если в командной строке есть исходные файлы Haskell,а другой режим не указан,поэтому в данном случае мы можем просто напечатать</target>
        </trans-unit>
        <trans-unit id="99ccc14a1c3446055aa550c00e0053392d4a3107" translate="yes" xml:space="preserve">
          <source>In fact, GHCi provides a way to run a command when a breakpoint is hit, so we can make it automatically do &lt;a href=&quot;#ghci-cmd-:list&quot;&gt;&lt;code&gt;:list&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Фактически, GHCi предоставляет способ запуска команды при достижении точки останова, поэтому мы можем сделать так, чтобы это выполнялось автоматически &lt;a href=&quot;#ghci-cmd-:list&quot;&gt; &lt;code&gt;:list&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4c63df3de91a091a7b7f15134cec823a993cb116" translate="yes" xml:space="preserve">
          <source>In function &lt;code&gt;showHelp&lt;/code&gt; GHC sees no overlapping instances, and so uses the &lt;code&gt;MyShow [a]&lt;/code&gt; instance without complaint. In the call to &lt;code&gt;myshow&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt;, GHC resolves the &lt;code&gt;MyShow [T]&lt;/code&gt; constraint using the overlapping instance declaration in module &lt;code&gt;Main&lt;/code&gt;. As a result, the program prints</source>
          <target state="translated">В функции &lt;code&gt;showHelp&lt;/code&gt; GHC не видит перекрывающихся экземпляров и поэтому использует &lt;code&gt;MyShow [a]&lt;/code&gt; без жалоб. При вызове &lt;code&gt;myshow&lt;/code&gt; в &lt;code&gt;main&lt;/code&gt; GHC разрешает &lt;code&gt;MyShow [T]&lt;/code&gt; используя объявление перекрывающегося экземпляра в модуле &lt;code&gt;Main&lt;/code&gt; . В результате программа печатает</target>
        </trans-unit>
        <trans-unit id="2ec6fbf6ec53f51208aead68b9f4175c5c65a628" translate="yes" xml:space="preserve">
          <source>In general a lazy pattern binding &lt;code&gt;p = e&lt;/code&gt; is a no-op if &lt;code&gt;p&lt;/code&gt; does not bind any variables. The motivation for allowing lone wild-card patterns is they are not very different from &lt;code&gt;_v = rhs3&lt;/code&gt;, which elicits no warning; and they can be useful to add a type constraint, e.g. &lt;code&gt;_ = x::Int&lt;/code&gt;. A banged pattern (see &lt;a href=&quot;glasgow_exts#bang-patterns&quot;&gt;Bang patterns and Strict Haskell&lt;/a&gt;) is &lt;em&gt;not&lt;/em&gt; a no-op, because it forces evaluation, and is useful as an alternative to &lt;code&gt;seq&lt;/code&gt;.</source>
          <target state="translated">В общем случае ленивая привязка шаблона &lt;code&gt;p = e&lt;/code&gt; не работает, если &lt;code&gt;p&lt;/code&gt; не связывает никакие переменные. Мотивация к разрешению одиночных шаблонов &lt;code&gt;_v = rhs3&lt;/code&gt; , что они не сильно отличаются от _v = rhs3 , который не вызывает предупреждения; и они могут быть полезны для добавления ограничения типа, например &lt;code&gt;_ = x::Int&lt;/code&gt; . Шаблон с ударами (см. &lt;a href=&quot;glasgow_exts#bang-patterns&quot;&gt;Шаблоны взрыва и Strict Haskell&lt;/a&gt; ) &lt;em&gt;не&lt;/em&gt; является запретной операцией, потому что он требует вычисления и полезен в качестве альтернативы &lt;code&gt;seq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51f41108f0c2bbe0749431bd7963794d7183a3a6" translate="yes" xml:space="preserve">
          <source>In general terms, a weak pointer is a reference to an object that is not followed by the garbage collector - that is, the existence of a weak pointer to an object has no effect on the lifetime of that object. A weak pointer can be de-referenced to find out whether the object it refers to is still alive or not, and if so to return the object itself.</source>
          <target state="translated">В общем,слабый указатель-это ссылка на объект,за которым не следует мусорщик,то есть существование слабого указателя на объект не влияет на время жизни этого объекта.Слабый указатель может быть снят с привязки,чтобы выяснить,жив ли еще объект,на который он ссылается,и если да,то вернуть сам объект.</target>
        </trans-unit>
        <trans-unit id="481359b39a7a3a188516a1c2c13bacad1c4ff5db" translate="yes" xml:space="preserve">
          <source>In general there are three kinds of pattern synonyms. Unidirectional, bidirectional and explicitly bidirectional. The examples given so far are examples of bidirectional pattern synonyms. A bidirectional synonym behaves the same as an ordinary data constructor. We can use it in a pattern context to deconstruct values and in an expression context to construct values. For example, we can construct the value &lt;code&gt;intEndo&lt;/code&gt; using the pattern synonyms &lt;code&gt;Arrow&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; as defined previously.</source>
          <target state="translated">Обычно существует три вида синонимов шаблонов. Однонаправленный, двунаправленный и явно двунаправленный. Приведенные до сих пор примеры являются примерами синонимов двунаправленного шаблона. Двунаправленный синоним ведет себя так же, как обычный конструктор данных. Мы можем использовать его в контексте шаблона для деконструкции значений и в контексте выражения для создания значений. Например, мы можем построить значение &lt;code&gt;intEndo&lt;/code&gt; , используя синонимы шаблона &lt;code&gt;Arrow&lt;/code&gt; и &lt;code&gt;Int&lt;/code&gt; , как определено ранее.</target>
        </trans-unit>
        <trans-unit id="2b27522334b948b2f46f2564190ed9a7b062b44c" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;ghc -M Foo&lt;/code&gt; does the following. For each module &lt;code&gt;M&lt;/code&gt; in the set &lt;code&gt;Foo&lt;/code&gt; plus all its imports (transitively), it adds to the Makefile:</source>
          <target state="translated">В общем, &lt;code&gt;ghc -M Foo&lt;/code&gt; делает следующее. Для каждого модуля &lt;code&gt;M&lt;/code&gt; в наборе &lt;code&gt;Foo&lt;/code&gt; плюс весь его импорт (транзитивно) он добавляет в Makefile:</target>
        </trans-unit>
        <trans-unit id="7f7c6f26fd4493c528d23d0ae55697bac0eab934" translate="yes" xml:space="preserve">
          <source>In general, GHC only inlines the function if there is some reason (no matter how slight) to suppose that it is useful to do so.</source>
          <target state="translated">В общем,GHC встраивает функцию только в том случае,если есть какая-либо причина (неважно,насколько незначительная)предположить,что это полезно.</target>
        </trans-unit>
        <trans-unit id="60a1f55e5825a2ce9deec4865aae9e5195367f7d" translate="yes" xml:space="preserve">
          <source>In general, GHC will only instantiate a polymorphic function at a monomorphic type (one with no foralls). For example,</source>
          <target state="translated">В целом,GHC будет инстанцировать полиморфную функцию только при мономорфном типе (без форалов).Например,</target>
        </trans-unit>
        <trans-unit id="225fcb89e38b97f2054653e3553fa5805a7ccac0" translate="yes" xml:space="preserve">
          <source>In general, after a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command, an automatic import is added to the scope for the most recently loaded &amp;ldquo;target&amp;rdquo; module, in a &lt;code&gt;*&lt;/code&gt;-form if possible. For example, if you say &lt;code&gt;:load foo.hs bar.hs&lt;/code&gt; and &lt;code&gt;bar.hs&lt;/code&gt; contains module &lt;code&gt;Bar&lt;/code&gt;, then the scope will be set to &lt;code&gt;*Bar&lt;/code&gt; if &lt;code&gt;Bar&lt;/code&gt; is interpreted, or if &lt;code&gt;Bar&lt;/code&gt; is compiled it will be set to &lt;code&gt;Prelude Bar&lt;/code&gt; (GHCi automatically adds &lt;code&gt;Prelude&lt;/code&gt; if it isn&amp;rsquo;t present and there aren&amp;rsquo;t any &lt;code&gt;*&lt;/code&gt;-form modules). These automatically-added imports can be seen with &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Как правило, после команды &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; к области действия последнего загруженного &amp;laquo;целевого&amp;raquo; модуля добавляется автоматический импорт в &lt;code&gt;*&lt;/code&gt; -форме, если это возможно. Например, если вы скажете &lt;code&gt;:load foo.hs bar.hs&lt;/code&gt; и &lt;code&gt;bar.hs&lt;/code&gt; содержит модуль &lt;code&gt;Bar&lt;/code&gt; , тогда для области будет установлено значение &lt;code&gt;*Bar&lt;/code&gt; , если &lt;code&gt;Bar&lt;/code&gt; интерпретируется, или если &lt;code&gt;Bar&lt;/code&gt; скомпилирован, он будет установлен на &lt;code&gt;Prelude Bar&lt;/code&gt; (GHCi автоматически добавляет &lt;code&gt;Prelude&lt;/code&gt; , если его нет и нет модулей &lt;code&gt;*&lt;/code&gt; -form). Этот автоматически добавленный импорт можно увидеть с помощью &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f31992d81c36250762b8a1fe8122ed580d721498" translate="yes" xml:space="preserve">
          <source>In general, as discussed in &lt;a href=&quot;#instance-resolution&quot;&gt;Instance resolution&lt;/a&gt;, &lt;em&gt;GHC requires that it be unambiguous which instance declaration should be used to resolve a type-class constraint&lt;/em&gt;. GHC also provides a way to loosen the instance resolution, by allowing more than one instance to match, &lt;em&gt;provided there is a most specific one&lt;/em&gt;. Moreover, it can be loosened further, by allowing more than one instance to match irrespective of whether there is a most specific one. This section gives the details.</source>
          <target state="translated">В общем, как обсуждалось в &lt;a href=&quot;#instance-resolution&quot;&gt;разделе &amp;laquo;Разрешение экземпляра&amp;raquo;&lt;/a&gt; , &lt;em&gt;GHC требует, чтобы было однозначно определено, какое объявление экземпляра следует использовать для разрешения ограничения типа-класс&lt;/em&gt; . GHC также предоставляет способ ослабить разрешение экземпляра, позволяя сопоставить более одного экземпляра, &lt;em&gt;при условии, что есть наиболее конкретный&lt;/em&gt; . Более того, его можно еще больше ослабить, допустив сопоставление более чем одного экземпляра, независимо от того, есть ли наиболее конкретный. В этом разделе приведены подробности.</target>
        </trans-unit>
        <trans-unit id="a24a52ff5732e7457a6c0f10b8d48e80b50c3fe8" translate="yes" xml:space="preserve">
          <source>In general, if GHC sees an expression within Oxford brackets (e.g., &lt;code&gt;[|
foo bar |]&lt;/code&gt;, then GHC looks up each name within the brackets. If a name is global (e.g., suppose &lt;code&gt;foo&lt;/code&gt; comes from an import or a top-level declaration), then the fully qualified name is used directly in the quotation. If the name is local (e.g., suppose &lt;code&gt;bar&lt;/code&gt; is bound locally in the function definition &lt;code&gt;mkFoo bar = [| foo bar |]&lt;/code&gt;), then GHC uses &lt;code&gt;lift&lt;/code&gt; on it (so GHC pretends &lt;code&gt;[| foo bar |]&lt;/code&gt; actually contains &lt;code&gt;[|
foo $(lift bar) |]&lt;/code&gt;). Local names, which are not in scope at splice locations, are actually evaluated when the quotation is processed.</source>
          <target state="translated">В общем, если GHC видит выражение в оксфордских скобках (например, &lt;code&gt;[| foo bar |]&lt;/code&gt; , то GHC ищет каждое имя в скобках. Если имя глобальное (например, предположим, что &lt;code&gt;foo&lt;/code&gt; получено из импорта или верхнего уровня декларации), то полное имя используется непосредственно в &lt;code&gt;mkFoo bar = [| foo bar |]&lt;/code&gt; имя является локальным (например, предположим, что &lt;code&gt;bar&lt;/code&gt; привязан локально в определении функции mkFoo bar = [| foo bar |] ), то GHC использует на нем значение &lt;code&gt;lift&lt;/code&gt; ( поэтому GHC притворяется, что &lt;code&gt;[| foo bar |]&lt;/code&gt; на самом деле содержит &lt;code&gt;[| foo $(lift bar) |]&lt;/code&gt; ). Локальные имена, которые не входят в область действия в местах соединения, фактически оцениваются при обработке предложения.</target>
        </trans-unit>
        <trans-unit id="c64b81fdef25b826556b46bc221a058713ff56df" translate="yes" xml:space="preserve">
          <source>In general, it is not recommended to use finalizers on separate objects with ordering constraints between them. To express the ordering robustly requires explicit synchronisation using &lt;code&gt;MVar&lt;/code&gt;s between the finalizers, but even then the runtime sometimes runs multiple finalizers sequentially in a single thread (for performance reasons), so synchronisation between finalizers could result in artificial deadlock. Another alternative is to use explicit reference counting.</source>
          <target state="translated">В общем, не рекомендуется использовать финализаторы для отдельных объектов с ограничениями упорядочения между ними. Для &lt;code&gt;MVar&lt;/code&gt; выражения порядка требуется явная синхронизация с использованием MVar между финализаторами, но даже тогда среда выполнения иногда запускает несколько финализаторов последовательно в одном потоке (по соображениям производительности), поэтому синхронизация между финализаторами может привести к искусственной тупиковой ситуации. Другой альтернативой является использование явного подсчета ссылок.</target>
        </trans-unit>
        <trans-unit id="2a479e2f380ec3084c0c0b21decb15ffdb8b192d" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;pluginRecompile&lt;/code&gt; field has the following type:</source>
          <target state="translated">Как правило, поле &lt;code&gt;pluginRecompile&lt;/code&gt; имеет следующий тип:</target>
        </trans-unit>
        <trans-unit id="c8f3128b6b16c5e45ef1a5d99515ed3873e858da" translate="yes" xml:space="preserve">
          <source>In general, the rule for when a &lt;code&gt;do&lt;/code&gt; statement incurs a &lt;code&gt;Monad&lt;/code&gt; constraint is as follows. If the do-expression has the following form:</source>
          <target state="translated">В общем, правило , когда &lt;code&gt;do&lt;/code&gt; выписки берет на &lt;code&gt;Monad&lt;/code&gt; ограничение заключается в следующем. Если do-выражение имеет следующий вид:</target>
        </trans-unit>
        <trans-unit id="16433cfc779e293649e5b61b5f49a9b6e34ab87f" translate="yes" xml:space="preserve">
          <source>In general, these options act on a &lt;code&gt;.tix&lt;/code&gt; file after an instrumented binary has generated it.</source>
          <target state="translated">Как правило, эти параметры действуют для файла &lt;code&gt;.tix&lt;/code&gt; после того, как инструментальный двоичный файл сгенерировал его.</target>
        </trans-unit>
        <trans-unit id="16864de7adb994a5d73b4457714719a11060892c" translate="yes" xml:space="preserve">
          <source>In general, type inference for arbitrary-rank types is undecidable. GHC uses an algorithm proposed by Odersky and Laufer (&amp;ldquo;Putting type annotations to work&amp;rdquo;, POPL&amp;lsquo;96) to get a decidable algorithm by requiring some help from the programmer. We do not yet have a formal specification of &amp;ldquo;some help&amp;rdquo; but the rule is this:</source>
          <target state="translated">В общем, вывод типов для типов произвольного ранга неразрешим. GHC использует алгоритм, предложенный Одерским и Лауфером (&amp;laquo;Работа с аннотациями типов&amp;raquo;, POPL'96), чтобы получить разрешимый алгоритм, требуя некоторой помощи от программиста. У нас еще нет формального описания &amp;laquo;некоторой помощи&amp;raquo;, но правило таково:</target>
        </trans-unit>
        <trans-unit id="31dba12d8f480c4aabbd58985394adff8da0a17b" translate="yes" xml:space="preserve">
          <source>In general, type inference for arbitrary-rank types is undecidable. GHC uses an algorithm proposed by Odersky and Laufer (&amp;ldquo;Putting type annotations to work&amp;rdquo;, POPL&amp;rsquo;96) to get a decidable algorithm by requiring some help from the programmer. We do not yet have a formal specification of &amp;ldquo;some help&amp;rdquo; but the rule is this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2024a464eb534dfbe74fefedd702f7a3e2250030" translate="yes" xml:space="preserve">
          <source>In general, you can only pattern-match on an existentially-quantified constructor in a &lt;code&gt;case&lt;/code&gt; expression or in the patterns of a function definition. The reason for this restriction is really an implementation one. Type-checking binding groups is already a nightmare without existentials complicating the picture. Also an existential pattern binding at the top level of a module doesn&amp;rsquo;t make sense, because it&amp;rsquo;s not clear how to prevent the existentially-quantified type &amp;ldquo;escaping&amp;rdquo;. So for now, there&amp;rsquo;s a simple-to-state restriction. We&amp;rsquo;ll see how annoying it is.</source>
          <target state="translated">В общем, сопоставление с образцом возможно только для конструктора с количественной оценкой существования в выражении &lt;code&gt;case&lt;/code&gt; или в образцах определения функции. Причина этого ограничения действительно связана с реализацией. Группы привязки с проверкой типов - это уже кошмар, без усложняющих картину экзистенциальных элементов. Кроме того, привязка экзистенциального шаблона на верхнем уровне модуля не имеет смысла, потому что неясно, как предотвратить &amp;laquo;экранирование&amp;raquo; экзистенциально-количественно определенного типа. Так что пока есть простое ограничение. Посмотрим, как это раздражает.</target>
        </trans-unit>
        <trans-unit id="98c6d67c9ce44b8e6eac2d0b4075c81dabba5106" translate="yes" xml:space="preserve">
          <source>In high-performance Haskell code (e.g. numeric code) eliminating thunks from an inner loop can be a huge win. GHC supports three extensions to allow the programmer to specify use of strict (call-by-value) evaluation rather than lazy (call-by-need) evaluation.</source>
          <target state="translated">В высокопроизводительном коде Хаскелла (например,в числовом коде)исключение из внутреннего цикла может быть огромной победой.GHC поддерживает три расширения,позволяющие программисту указывать использование строгой (call-by-value)оценки,а не ленивой (call-by-need).</target>
        </trans-unit>
        <trans-unit id="c3bb19915354a80256cd126fd6a60161eb482c2d" translate="yes" xml:space="preserve">
          <source>In its default mode, GHC does not accept datatype contexts, as it has been decided to remove them from the next version of the language standard. This behaviour can be controlled with the &lt;code&gt;DatatypeContexts&lt;/code&gt; extension. See &lt;a href=&quot;glasgow_exts#datatype-contexts&quot;&gt;Data type contexts&lt;/a&gt;.</source>
          <target state="translated">В своем режиме по умолчанию GHC не принимает контексты типов данных, так как было решено удалить их из следующей версии языкового стандарта. Этим поведением можно управлять с помощью расширения &lt;code&gt;DatatypeContexts&lt;/code&gt; . См. &lt;a href=&quot;glasgow_exts#datatype-contexts&quot;&gt;Контексты типов данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="275629b87d7294aa0eaa9588d8a9a706ba895f13" translate="yes" xml:space="preserve">
          <source>In its default mode, GHC makes some programs slightly more defined than they should be. For example, consider</source>
          <target state="translated">В своем режиме по умолчанию GHC делает некоторые программы немного более определенными,чем они должны быть.Например,рассмотрим</target>
        </trans-unit>
        <trans-unit id="e94f4b216d151b4a30a7c1bd717bfe451b1cb48d" translate="yes" xml:space="preserve">
          <source>In keeping with the way that class methods list their class variables first, associated types also list class variables before others. This means that the inferred variables from the class come before the specified variables from the class, which come before other implicitly bound variables. Here is an example:</source>
          <target state="translated">В соответствии с тем,как методы класса сначала перечисляют свои переменные класса,ассоциированные типы также перечисляют переменные класса раньше других.Это означает,что выведенные переменные класса идут раньше указанных переменных класса,которые идут раньше других неявно связанных переменных.Приведем пример:</target>
        </trans-unit>
        <trans-unit id="af1a88fdd917297213df61b4944e92d2f20600ce" translate="yes" xml:space="preserve">
          <source>In many situations, the &lt;code&gt;&lt;a href=&quot;control-monad#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; operations can be replaced by uses of &lt;code&gt;&lt;a href=&quot;control-monad#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt;, which promotes function application.</source>
          <target state="translated">Во многих ситуациях операции &lt;code&gt;&lt;a href=&quot;control-monad#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; можно заменить использованием &lt;code&gt;&lt;a href=&quot;control-monad#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt; , что способствует применению функции.</target>
        </trans-unit>
        <trans-unit id="86e41b1490a2b7bfe151acff33ef58b56ab399e1" translate="yes" xml:space="preserve">
          <source>In many situations, the &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; operations can be replaced by uses of &lt;code&gt;&lt;a href=&quot;ghc-base#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt;, which promotes function application.</source>
          <target state="translated">Во многих ситуациях операции &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; можно заменить использованием &lt;code&gt;&lt;a href=&quot;ghc-base#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt; , что способствует применению функции.</target>
        </trans-unit>
        <trans-unit id="3b2d8e96b23e6bc78c49594a14c36c62bbb7071e" translate="yes" xml:space="preserve">
          <source>In more complicated examples, you may wish to define a whole hierarchy of exceptions:</source>
          <target state="translated">В более сложных примерах вы можете захотеть определить целую иерархию исключений:</target>
        </trans-unit>
        <trans-unit id="4c4936db3ddc3e67725b71767b1d5c5e41743bb8" translate="yes" xml:space="preserve">
          <source>In most cases, the parameters used by &lt;code&gt;toLazyByteString&lt;/code&gt; give good performance. A sub-performing case of &lt;code&gt;toLazyByteString&lt;/code&gt; is executing short (&amp;lt;128 bytes) &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. In this case, the allocation overhead for the first 4kb buffer and the trimming cost dominate the cost of executing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. You can avoid this problem using</source>
          <target state="translated">В большинстве случаев параметры, используемые &lt;code&gt;toLazyByteString&lt;/code&gt; , дают хорошую производительность. &lt;code&gt;toLazyByteString&lt;/code&gt; случай toLazyByteString - это выполнение коротких (&amp;lt;128 байт) &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; s. В этом случае накладные расходы на выделение для первого буфера размером 4 КБ и стоимость обрезки преобладают над затратами на выполнение &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; . Вы можете избежать этой проблемы, используя</target>
        </trans-unit>
        <trans-unit id="3027d30c8f8fb2c3a4b6e7dd0e32412aa9179811" translate="yes" xml:space="preserve">
          <source>In most cases, the parameters used by &lt;code&gt;toLazyByteString&lt;/code&gt; give good performance. A sub-performing case of &lt;code&gt;toLazyByteString&lt;/code&gt; is executing short (&amp;lt;128 bytes) &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. In this case, the allocation overhead for the first 4kb buffer and the trimming cost dominate the cost of executing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. You can avoid this problem using</source>
          <target state="translated">В большинстве случаев параметры, используемые &lt;code&gt;toLazyByteString&lt;/code&gt; , дают хорошую производительность. &lt;code&gt;toLazyByteString&lt;/code&gt; случай toLazyByteString - это выполнение коротких (&amp;lt;128 байт) &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; s. В этом случае накладные расходы на выделение для первого буфера размером 4 КБ и стоимость обрезки преобладают над затратами на выполнение &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; . Вы можете избежать этой проблемы, используя</target>
        </trans-unit>
        <trans-unit id="76b1ffe4dff1aba8ccdccdaa16d342830f1d4227" translate="yes" xml:space="preserve">
          <source>In most cases, you must supply an explicit context (in the example the context is &lt;code&gt;(Eq a)&lt;/code&gt;), exactly as you would in an ordinary instance declaration. (In contrast, in a &lt;code&gt;deriving&lt;/code&gt; clause attached to a data type declaration, the context is inferred.)</source>
          <target state="translated">В большинстве случаев вы должны предоставить явный контекст (в примере контекст &lt;code&gt;(Eq a)&lt;/code&gt; ), точно так же, как и в обычном объявлении экземпляра. (Напротив, в &lt;code&gt;deriving&lt;/code&gt; предложении, прикрепленном к объявлению типа данных, подразумевается контекст.)</target>
        </trans-unit>
        <trans-unit id="19e317a4f2744059301e6b1045661a71d5655709" translate="yes" xml:space="preserve">
          <source>In most scenarios, every &lt;code&gt;deriving&lt;/code&gt; statement generates a typeclass instance in an unambiguous fashion. There is a corner case, however, where simultaneously enabling both the &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; extensions can make deriving become ambiguous. Consider the following example</source>
          <target state="translated">В большинстве сценариев каждое &lt;code&gt;deriving&lt;/code&gt; выражение однозначно генерирует экземпляр класса типов. Однако есть угловой случай, когда одновременное включение расширений &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; может сделать наследование неоднозначным. Рассмотрим следующий пример</target>
        </trans-unit>
        <trans-unit id="1b692dc9121229cacd00afc8cf58d7662492e8b8" translate="yes" xml:space="preserve">
          <source>In mutually recursive bindings, such as &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;where&lt;/code&gt;, or the top level, view patterns in one declaration may not mention variables bound by other declarations. That is, each declaration must be self-contained. For example, the following program is not allowed:</source>
          <target state="translated">Во взаимно рекурсивных привязках, таких как &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;where&lt;/code&gt; или верхний уровень, шаблоны представления в одном объявлении могут не упоминать переменные, связанные другими объявлениями. То есть каждое объявление должно быть самодостаточным. Например, следующая программа не разрешена:</target>
        </trans-unit>
        <trans-unit id="becdc0c8077f7104b4c28a91add0067b223f02f7" translate="yes" xml:space="preserve">
          <source>In order to allow full flexibility in how kinds are used, it is necessary to use the kind system to differentiate between boxed, lifted types (normal, everyday types like &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;[Bool]&lt;/code&gt;) and unboxed, primitive types (&lt;a href=&quot;#primitives&quot;&gt;Unboxed types and primitive operations&lt;/a&gt;) like &lt;code&gt;Int#&lt;/code&gt;. We thus have so-called levity polymorphism.</source>
          <target state="translated">Чтобы обеспечить полную гибкость в использовании видов, необходимо использовать систему типов, чтобы различать упакованные, расширенные типы (обычные, повседневные типы, такие как &lt;code&gt;Int&lt;/code&gt; и &lt;code&gt;[Bool]&lt;/code&gt; ) и неупакованные, примитивные типы ( &lt;a href=&quot;#primitives&quot;&gt;неупакованные типы и примитивные операции.&lt;/a&gt; ) как &lt;code&gt;Int#&lt;/code&gt; . Таким образом, мы имеем так называемый полиморфизм левитации.</target>
        </trans-unit>
        <trans-unit id="e6cd748eca92cb9876cb47ec0d324628b6e60b35" translate="yes" xml:space="preserve">
          <source>In order to avoid conflicting with the built-in constraint solving, the following user-defined &lt;code&gt;HasField&lt;/code&gt; instances are prohibited (in addition to the usual rules, such as the prohibition on type families appearing in instance heads):</source>
          <target state="translated">Во избежание конфликта со встроенным решением ограничений запрещены следующие определяемые &lt;code&gt;HasField&lt;/code&gt; экземпляры HasField (в дополнение к обычным правилам, таким как запрет на появление семейств типов в заголовках экземпляров):</target>
        </trans-unit>
        <trans-unit id="93af4d623943d3f8bd7b71270963bbcbfaf23873" translate="yes" xml:space="preserve">
          <source>In order to be able to do this, we need to know the actual definitions of these types:</source>
          <target state="translated">Для того,чтобы это сделать,нам необходимо знать фактические определения этих типов:</target>
        </trans-unit>
        <trans-unit id="aec123491a69a064a575a51206895c88f02274ac" translate="yes" xml:space="preserve">
          <source>In order to guarantee that type inference in the presence of type families decidable, we need to place a number of additional restrictions on the formation of type instance declarations (c.f., Definition 5 (Relaxed Conditions) of &amp;ldquo;&lt;a href=&quot;http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html&quot;&gt;Type Checking with Open Type Functions&lt;/a&gt;&amp;rdquo;). Instance declarations have the general form</source>
          <target state="translated">Чтобы гарантировать такой вывод типов при наличии разрешимых семейств типов, нам необходимо установить ряд дополнительных ограничений на формирование объявлений экземпляров типа (см. Определение 5 (Ослабленные условия) &amp;laquo; &lt;a href=&quot;http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html&quot;&gt;Проверка типов с помощью функций открытого типа&lt;/a&gt; &amp;raquo;) , Объявления экземпляров имеют общий вид</target>
        </trans-unit>
        <trans-unit id="5a5e110d7e22d8c1fbc33d3a5b3e328299c301bb" translate="yes" xml:space="preserve">
          <source>In order to make graphs more readable, &lt;code&gt;hp2ps&lt;/code&gt; sorts the shaded bands for each identifier. The default sort ordering is for the bands with the largest area to be stacked on top of the smaller ones. The &lt;code&gt;-d&lt;/code&gt; option causes rougher bands (those representing series of values with the largest standard deviations) to be stacked on top of smoother ones.</source>
          <target state="translated">Чтобы графики были более удобочитаемыми, &lt;code&gt;hp2ps&lt;/code&gt; сортирует закрашенные полосы для каждого идентификатора. Порядок сортировки по умолчанию - полосы с наибольшей площадью укладываются поверх более мелких. Параметр &lt;code&gt;-d&lt;/code&gt; заставляет более грубые полосы (те, которые представляют серии значений с наибольшими стандартными отклонениями) накладываться поверх более гладких.</target>
        </trans-unit>
        <trans-unit id="05de27ae60fa5ff58255cf77bb61e0034b072231" translate="yes" xml:space="preserve">
          <source>In order to make use of multiple CPUs, your program must be linked with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;). Additionally, the following compiler options affect parallelism:</source>
          <target state="translated">Чтобы использовать несколько процессоров, ваша программа должна быть связана с параметром &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; (см. &lt;a href=&quot;phases#options-linker&quot;&gt;Параметры, влияющие на связывание&lt;/a&gt; ). Кроме того, на параллелизм влияют следующие параметры компилятора:</target>
        </trans-unit>
        <trans-unit id="a539e64a6ae327e4d4847a3da0692c246af57900" translate="yes" xml:space="preserve">
          <source>In order to stop the value &lt;code&gt;it&lt;/code&gt; being bound on each command, the flag &lt;a href=&quot;#ghc-flag--fno-it&quot;&gt;&lt;code&gt;-fno-it&lt;/code&gt;&lt;/a&gt; can be set. The &lt;code&gt;it&lt;/code&gt; variable can be the source of space leaks due to how shadowed declarations are handled by GHCi (see &lt;a href=&quot;#ghci-decls&quot;&gt;Type, class and other declarations&lt;/a&gt;).</source>
          <target state="translated">Чтобы значение &lt;code&gt;it&lt;/code&gt; было привязано к каждой команде, можно установить флаг &lt;a href=&quot;#ghc-flag--fno-it&quot;&gt; &lt;code&gt;-fno-it&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;it&lt;/code&gt; переменная может быть источником космических утечек из - за того , как слежка заявления обрабатываются GHCi (см &lt;a href=&quot;#ghci-decls&quot;&gt;Тип, класс и другие заявления&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b5ff7b86e25253644ff1722e9fde733a07775459" translate="yes" xml:space="preserve">
          <source>In order to tell GHC the C type that a Haskell type corresponds to when it is used with the CAPI, a &lt;code&gt;CTYPE&lt;/code&gt; pragma can be used on the type definition. The header which defines the type can optionally also be specified. The syntax looks like:</source>
          <target state="translated">Чтобы сообщить GHC тип C, которому соответствует тип Haskell, когда он используется с CAPI, в определении &lt;code&gt;CTYPE&lt;/code&gt; можно использовать прагму CTYPE . При желании также может быть указан заголовок, определяющий тип. Синтаксис выглядит так:</target>
        </trans-unit>
        <trans-unit id="47421418538d24c7ed6361fd82a54bf7f6224d2c" translate="yes" xml:space="preserve">
          <source>In order to use the FFI in a multi-threaded setting, you must use the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;).</source>
          <target state="translated">Чтобы использовать FFI в многопоточном режиме, вы должны использовать параметр &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; (см. &lt;a href=&quot;phases#options-linker&quot;&gt;Параметры, влияющие на связывание&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b3462ac0bc32460cb66fe5ad73156484f635fcbf" translate="yes" xml:space="preserve">
          <source>In order, &lt;code&gt;ghc&lt;/code&gt; will look for the package environment in the following locations:</source>
          <target state="translated">По порядку &lt;code&gt;ghc&lt;/code&gt; будет искать среду пакета в следующих местах:</target>
        </trans-unit>
        <trans-unit id="6e148f1a9d40b361ea9368ff7b0c22490d6f5818" translate="yes" xml:space="preserve">
          <source>In ordinary Haskell, &lt;code&gt;f&lt;/code&gt; is lazy in its argument and hence in &lt;code&gt;x&lt;/code&gt;; and &lt;code&gt;g&lt;/code&gt; is strict in its argument and hence also strict in &lt;code&gt;x&lt;/code&gt;. With &lt;code&gt;Strict&lt;/code&gt;, both become strict because &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s argument gets an implicit bang.</source>
          <target state="translated">В обычном Haskell &lt;code&gt;f&lt;/code&gt; ленив в своих аргументах и, следовательно, в &lt;code&gt;x&lt;/code&gt; ; и &lt;code&gt;g&lt;/code&gt; строг по своим аргументам, а значит, и по &lt;code&gt;x&lt;/code&gt; . С &lt;code&gt;Strict&lt;/code&gt; оба становятся строгими, потому что аргумент &lt;code&gt;f&lt;/code&gt; вызывает неявный удар.</target>
        </trans-unit>
        <trans-unit id="f0c005424bafd0442e357105c93d1f9cfe1f688c" translate="yes" xml:space="preserve">
          <source>In ordinary Haskell, &lt;code&gt;f&lt;/code&gt; is lazy in its argument and hence in &lt;code&gt;x&lt;/code&gt;; and &lt;code&gt;g&lt;/code&gt; is strict in its argument and hence also strict in &lt;code&gt;x&lt;/code&gt;. With &lt;code&gt;Strict&lt;/code&gt;, both become strict because &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s argument gets an implicit bang.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1405421d283da798715928c97732511b19ea5e87" translate="yes" xml:space="preserve">
          <source>In other situations, the C function may need knowledge of the RTS closure types. The following example sums the first element of each &lt;code&gt;ByteArray#&lt;/code&gt; (interpreting the bytes as an array of &lt;code&gt;CInt&lt;/code&gt;) element of an &lt;code&gt;ArrayArray##&lt;/code&gt;&lt;a href=&quot;#id7&quot; id=&quot;id3&quot;&gt;3&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e11a6dcf1454bf3942eab61b919beed891ed2da" translate="yes" xml:space="preserve">
          <source>In other ways, however, a standalone deriving obeys the same rules as ordinary deriving:</source>
          <target state="translated">В других отношениях,однако,автономное получение подчиняется тем же правилам,что и обычное получение:</target>
        </trans-unit>
        <trans-unit id="0f9811e2dd3d2cfe0a2fc61f31ef2b584425e79b" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;check b = unless b retry&lt;/code&gt;.</source>
          <target state="translated">Другими словами, &lt;code&gt;check b = unless b retry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09118f7c3443c63e9289f6a2ade854e33281ae45" translate="yes" xml:space="preserve">
          <source>In our situation, module &lt;code&gt;TCB_Runner&lt;/code&gt; compiles fine without importing module &lt;code&gt;Dangerous&lt;/code&gt;. So when deciding which instance to use for the call to &lt;code&gt;op&lt;/code&gt;, if we determine the instance &lt;code&gt;TC [Int]&lt;/code&gt; from module Dangerous is the most specific, this is unsafe. This prevents code written by third-parties we don&amp;rsquo;t trust (which is compiled using &lt;code&gt;-XSafe&lt;/code&gt; in Safe Haskell) from changing the behaviour of our existing code.</source>
          <target state="translated">В нашей ситуации модуль &lt;code&gt;TCB_Runner&lt;/code&gt; компилируется нормально без импорта модуля &lt;code&gt;Dangerous&lt;/code&gt; . Поэтому, когда мы решаем, какой экземпляр использовать для вызова &lt;code&gt;op&lt;/code&gt; , если мы определим, что экземпляр &lt;code&gt;TC [Int]&lt;/code&gt; из модуля Dangerous является наиболее конкретным, это небезопасно. Это не позволяет коду, написанному сторонними разработчиками, которому мы не доверяем (который скомпилирован с использованием &lt;code&gt;-XSafe&lt;/code&gt; в Safe Haskell), изменить поведение нашего существующего кода.</target>
        </trans-unit>
        <trans-unit id="43b674e690d27f945dd913940cb2232c8d90f70b" translate="yes" xml:space="preserve">
          <source>In parallel GC, the amount of balanced data copied by all threads</source>
          <target state="translated">В параллельных GC,количество сбалансированных данных,скопированных всеми потоками</target>
        </trans-unit>
        <trans-unit id="a61170ee3ee14c29ceaa4174895c06c76c4573d5" translate="yes" xml:space="preserve">
          <source>In parallel GC, the max amount of data copied by any one thread. Deprecated.</source>
          <target state="translated">В параллельных GC-максимальный объем данных,скопированный любым из потоков.Исключено.</target>
        </trans-unit>
        <trans-unit id="bf8ef4c6fe3834e5d04cec18ee87b3394e6f88d0" translate="yes" xml:space="preserve">
          <source>In particular GHC produces the following DWARF sections,</source>
          <target state="translated">В частности,GHC выпускает следующие разделы DWARF,</target>
        </trans-unit>
        <trans-unit id="ccd52b4b1f1e992bf8f459eea8eeca8d965ef594" translate="yes" xml:space="preserve">
          <source>In particular Haskell shared libraries &lt;em&gt;must&lt;/em&gt; be made into packages. You cannot freely assign which modules go in which shared libraries. The Haskell shared libraries must match the package boundaries. The reason for this is that GHC handles references to symbols &lt;em&gt;within&lt;/em&gt; the same shared library (or main executable binary) differently from references to symbols &lt;em&gt;between&lt;/em&gt; different shared libraries. GHC needs to know for each imported module if that module lives locally in the same shared lib or in a separate shared lib. The way it does this is by using packages. When using &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;, a module from a separate package is assumed to come from a separate shared lib, while modules from the same package (or the default &amp;ldquo;main&amp;rdquo; package) are assumed to be within the same shared lib (or main executable binary).</source>
          <target state="translated">В частности, разделяемые библиотеки Haskell &lt;em&gt;должны&lt;/em&gt; быть превращены в пакеты. Вы не можете свободно назначать, какие модули входят в общие библиотеки. Общие библиотеки Haskell должны соответствовать границам пакета. Причина в том, что GHC обрабатывает ссылки на символы &lt;em&gt;в&lt;/em&gt; одной и той же разделяемой библиотеке (или основном исполняемом двоичном файле) иначе, чем ссылки на символы &lt;em&gt;между&lt;/em&gt; разными разделяемыми библиотеками. GHC необходимо знать для каждого импортированного модуля, находится ли этот модуль локально в той же общей библиотеке или в отдельной общей библиотеке. Это делается с помощью пакетов. При использовании &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;предполагается, что модуль из отдельного пакета поступает из отдельной совместно используемой библиотеки, в то время как модули из того же пакета (или &amp;laquo;основного&amp;raquo; пакета по умолчанию) считаются находящимися в одной общей библиотеке (или основном исполняемом двоичном файле).</target>
        </trans-unit>
        <trans-unit id="684eca7730ca7b2ff8a385904d2e0b0bdd7e41b3" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;inits _|_ = [] : _|_&lt;/code&gt;</source>
          <target state="translated">В частности, &lt;code&gt;inits _|_ = [] : _|_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59e1ce5ee87d506ce95263e7f934380331fec187" translate="yes" xml:space="preserve">
          <source>In particular, after inlining this will expose &lt;code&gt;f&lt;/code&gt; to the loop body directly, allowing heavy specialisation over the recursive cases.</source>
          <target state="translated">В частности, после встраивания это приведет к непосредственному отображению &lt;code&gt;f&lt;/code&gt; в теле цикла, что обеспечит серьезную специализацию по рекурсивным случаям.</target>
        </trans-unit>
        <trans-unit id="5b268bd7dbdcc411a15b5953757d10b21ca32c1a" translate="yes" xml:space="preserve">
          <source>In particular, constructors are &lt;em&gt;not&lt;/em&gt; retainers.</source>
          <target state="translated">В частности, конструкторы &lt;em&gt;не&lt;/em&gt; слуги.</target>
        </trans-unit>
        <trans-unit id="078a7a8154ddbe01c2111502e8ae65f0e2be01b1" translate="yes" xml:space="preserve">
          <source>In particular, if an instance declaration is in the same module as the definition of any type or class mentioned in the &lt;em&gt;head&lt;/em&gt; of the instance declaration (the part after the &amp;ldquo;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;rdquo;; see &lt;a href=&quot;glasgow_exts#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;), then GHC has to visit that interface file anyway. Example:</source>
          <target state="translated">В частности, если объявление экземпляра находится в том же модуле, что и определение любого типа или класса , указанном в &lt;em&gt;голове&lt;/em&gt; декларации экземпляра (часть после &amp;laquo; &lt;code&gt;=&amp;gt;&lt;/code&gt; &amp;raquo;; см &lt;a href=&quot;glasgow_exts#instance-rules&quot;&gt;Relaxed правила, например , контекстов&lt;/a&gt; ), то GHC должен все равно посетите этот интерфейсный файл. Пример:</target>
        </trans-unit>
        <trans-unit id="5b3a1af7fc684a7365e0b7b609a3039be3699240" translate="yes" xml:space="preserve">
          <source>In particular, in &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;newtype&lt;/code&gt; declarations the constructor arguments may be polymorphic types of any rank; see examples in &lt;a href=&quot;#univ&quot;&gt;Examples&lt;/a&gt;. Note that the declared types are nevertheless always monomorphic. This is important because by default GHC will not instantiate type variables to a polymorphic type (&lt;a href=&quot;#impredicative-polymorphism&quot;&gt;Impredicative polymorphism&lt;/a&gt;).</source>
          <target state="translated">В частности, в объявлениях &lt;code&gt;data&lt;/code&gt; и &lt;code&gt;newtype&lt;/code&gt; аргументы конструктора могут быть полиморфными типами любого ранга; см. примеры в &lt;a href=&quot;#univ&quot;&gt;примерах&lt;/a&gt; . Обратите внимание, что объявленные типы, тем не менее, всегда мономорфны. Это важно, поскольку по умолчанию GHC не создает экземпляры переменных типа для полиморфного типа ( &lt;a href=&quot;#impredicative-polymorphism&quot;&gt;импредикативный полиморфизм&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d5e004af97f91f3b14786a737ee2ee1e783b46be" translate="yes" xml:space="preserve">
          <source>In particular, the &quot;bigger&quot; functions in this module (&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:swapMVar&quot;&gt;swapMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt;) are simply the composition of a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; followed by a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; with exception safety. These only have atomicity guarantees if all other threads perform a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; before a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; as well; otherwise, they may block.</source>
          <target state="translated">В частности, &amp;laquo;более крупные&amp;raquo; функции в этом модуле ( &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:swapMVar&quot;&gt;swapMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt; ) представляют собой просто композицию &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; , за которой следует &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; с безопасностью исключений. Они имеют гарантии атомарности только в том случае, если все другие потоки также выполняют &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; перед &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; ; в противном случае они могут заблокироваться.</target>
        </trans-unit>
        <trans-unit id="15d279defc6ca20240f2cd4bd6ca078465058a78" translate="yes" xml:space="preserve">
          <source>In particular, the functions in this module obey the following law:</source>
          <target state="translated">В частности,функции в этом модуле подчиняются следующему закону:</target>
        </trans-unit>
        <trans-unit id="9d41d9ff0d0d0895ae2e1959850587fbcb656b74" translate="yes" xml:space="preserve">
          <source>In particular, the occurrence &lt;code&gt;VarE nm1&lt;/code&gt; refers to the binding &lt;code&gt;VarP nm1&lt;/code&gt;, and is not captured by the binding &lt;code&gt;VarP nm2&lt;/code&gt;.</source>
          <target state="translated">В частности, появление &lt;code&gt;VarE nm1&lt;/code&gt; относится к связыванию &lt;code&gt;VarP nm1&lt;/code&gt; и не захватывается связыванием &lt;code&gt;VarP nm2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e3faed30034bb62c86f00fd56d131c7714b3f69" translate="yes" xml:space="preserve">
          <source>In practice, the FFI should not be used for a task as simple as reading bytes from a &lt;code&gt;MutableByteArray#&lt;/code&gt;. Users should prefer &lt;code&gt;GHC.Exts.readWord8Array#&lt;/code&gt; for this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d02df75e8eea52729bdf6cd2eb9e25ca0f13738" translate="yes" xml:space="preserve">
          <source>In previous releases, GHC would take advantage of the freedom afforded by the Chapter by performing &lt;code&gt;safe&lt;/code&gt; foreign calls in place of &lt;code&gt;unsafe&lt;/code&gt; calls in the bytecode interpreter. This meant that some packages which worked when compiled would fail under GHCi (e.g. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13730&quot;&gt;#13730&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="391b2886cb4e0d3786c17223969b938c2fef5e88" translate="yes" xml:space="preserve">
          <source>In previous releases, GHC would take advantage of the freedom afforded by the Chapter by performing &lt;code&gt;safe&lt;/code&gt; foreign calls in place of &lt;code&gt;unsafe&lt;/code&gt; calls in the bytecode interpreter. This meant that some packages which worked when compiled would fail under GHCi (e.g. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13730&quot;&gt;Issue #13730&lt;/a&gt;).</source>
          <target state="translated">В предыдущих выпусках GHC мог воспользоваться свободой, предоставляемой Chapter, выполняя &lt;code&gt;safe&lt;/code&gt; внешние вызовы вместо &lt;code&gt;unsafe&lt;/code&gt; вызовов в интерпретаторе байт-кода. Это означало, что некоторые пакеты, которые работали при компиляции, не работали в GHCi (например, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13730&quot;&gt;Проблема # 13730&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3ff8d012302e9131b060a6becba0fe4885a49e66" translate="yes" xml:space="preserve">
          <source>In principle you can use &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; without &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; in the link step. That means to statically link the runtime system and all of the base libraries into your new shared library. This would make a very big, but standalone shared library. On most platforms however that would require all the static libraries to have been built with &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; so that the code is suitable to include into a shared library and we do not do that at the moment.</source>
          <target state="translated">В принципе, вы можете использовать &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt; без &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; на этапе ссылки. Это означает статическую привязку системы времени выполнения и всех базовых библиотек к вашей новой общей библиотеке. Это сделало бы очень большую, но отдельную общую библиотеку. Однако на большинстве платформ это потребовало бы, чтобы все статические библиотеки были построены с помощью &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; ,&lt;/a&gt; чтобы код можно было включить в общую библиотеку, а мы этого не делаем в настоящее время.</target>
        </trans-unit>
        <trans-unit id="fd263cf5ce99e2b91836dc4e35a2d6bb18f488af" translate="yes" xml:space="preserve">
          <source>In principle, with a suitable class declaration with a functional dependency, it&amp;rsquo;s possible that this type is not ambiguous; but GHC nevertheless rejects it. The type variables mentioned in the context of the data type declaration must be among the type parameters of the data type.</source>
          <target state="translated">В принципе, при подходящем объявлении класса с функциональной зависимостью этот тип может быть неоднозначным; но GHC, тем не менее, отвергает это. Переменные типа, упомянутые в контексте объявления типа данных, должны быть среди параметров типа данного типа данных.</target>
        </trans-unit>
        <trans-unit id="18e2f91b13004cb3ee73758eb6c0f3436fbf8f70" translate="yes" xml:space="preserve">
          <source>In record construction and record pattern matching it is entirely unambiguous which field is referred to, even if there are two different data types in scope with a common field name. For example:</source>
          <target state="translated">В построении записи и совпадении шаблона записи совершенно однозначно,к какому полю относится данное поле,даже если в области видимости есть два разных типа данных с общим именем поля.Например:</target>
        </trans-unit>
        <trans-unit id="026f7b4f745c03773b13fa4d11e7929e66eb04db" translate="yes" xml:space="preserve">
          <source>In short, all &quot;catching&quot; mechanisms in this library will be unable to catch exceptions thrown by functions in the &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; module, and vice-versa.</source>
          <target state="translated">Короче говоря, все механизмы &quot;перехвата&quot; в этой библиотеке не смогут перехватывать исключения, создаваемые функциями в модуле &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; , и наоборот.</target>
        </trans-unit>
        <trans-unit id="c7c0b572397dc91bfdb2bb7d885052532168e385" translate="yes" xml:space="preserve">
          <source>In short, all &quot;catching&quot; mechanisms in this library will be unable to catch exceptions thrown by functions in the &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; module, and vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="934808fb13fd2c8c5cce75253dd4e268d2a4d578" translate="yes" xml:space="preserve">
          <source>In short, if you compile a module and its interface changes, then all the modules that import that interface &lt;em&gt;must&lt;/em&gt; be re-compiled.</source>
          <target state="translated">Короче говоря, если вы компилируете модуль и его интерфейс изменяется, все модули, которые импортируют этот интерфейс, &lt;em&gt;должны&lt;/em&gt; быть перекомпилированы.</target>
        </trans-unit>
        <trans-unit id="f81140bb54ceba3a8d0fad4549fca0af74b151f4" translate="yes" xml:space="preserve">
          <source>In short, if you want GADT-like behaviour for pattern synonyms, then (unlike concrete data constructors like &lt;code&gt;S1&lt;/code&gt;) you must write its type with explicit provided equalities. For a concrete data constructor like &lt;code&gt;S1&lt;/code&gt; you can write its type signature as either &lt;code&gt;S1 :: Bool -&amp;gt; S Bool&lt;/code&gt; or &lt;code&gt;S1 :: (b~Bool) =&amp;gt; Bool -&amp;gt; S b&lt;/code&gt;; the two are equivalent. Not so for pattern synonyms: the two forms are different, in order to distinguish the two cases above. (See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/9953&quot;&gt;#9953&lt;/a&gt; for discussion of this choice.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c8b3bf997296fa73e6193137e7fe4e16c83b1a" translate="yes" xml:space="preserve">
          <source>In short, if you want GADT-like behaviour for pattern synonyms, then (unlike concrete data constructors like &lt;code&gt;S1&lt;/code&gt;) you must write its type with explicit provided equalities. For a concrete data constructor like &lt;code&gt;S1&lt;/code&gt; you can write its type signature as either &lt;code&gt;S1 :: Bool -&amp;gt; S Bool&lt;/code&gt; or &lt;code&gt;S1 :: (b~Bool) =&amp;gt; Bool -&amp;gt; S b&lt;/code&gt;; the two are equivalent. Not so for pattern synonyms: the two forms are different, in order to distinguish the two cases above. (See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/9953&quot;&gt;Issue #9953&lt;/a&gt; for discussion of this choice.)</source>
          <target state="translated">Короче говоря, если вам нужно GADT-подобное поведение для синонимов шаблонов, тогда (в отличие от конкретных конструкторов данных, таких как &lt;code&gt;S1&lt;/code&gt; ) вы должны написать его тип с явными предоставленными равенствами. Для конкретного конструктора данных, такого как &lt;code&gt;S1&lt;/code&gt; , вы можете написать сигнатуру его типа либо как &lt;code&gt;S1 :: Bool -&amp;gt; S Bool&lt;/code&gt; либо как &lt;code&gt;S1 :: (b~Bool) =&amp;gt; Bool -&amp;gt; S b&lt;/code&gt; ; эти два эквивалентны. Иначе обстоит дело с синонимами шаблонов: эти две формы различны, чтобы различать два вышеуказанных случая. (См. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/9953&quot;&gt;Вопрос № 9953&lt;/a&gt; для обсуждения этого выбора.)</target>
        </trans-unit>
        <trans-unit id="c2cfc1f8c0043394ab94a925d7089c33080293c8" translate="yes" xml:space="preserve">
          <source>In short, quantifed constraints do not introduce incoherence.</source>
          <target state="translated">Короче говоря,количественные ограничения не приводят к несогласованности.</target>
        </trans-unit>
        <trans-unit id="eedb3f453802c917804d8787ef3886b3897a16d7" translate="yes" xml:space="preserve">
          <source>In short: GHC does &lt;em&gt;not&lt;/em&gt; propagate kind information from the members of a class instance declaration into the instance declaration head.</source>
          <target state="translated">Вкратце: GHC &lt;em&gt;не&lt;/em&gt; передает информацию о типе от членов объявления экземпляра класса в заголовок объявления экземпляра.</target>
        </trans-unit>
        <trans-unit id="65fcdd4e01ef4cdb5c7448159811829c535afe34" translate="yes" xml:space="preserve">
          <source>In some cases, &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; can undo a &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; operation:</source>
          <target state="translated">В некоторых случаях, &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; может отменить &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; операцию:</target>
        </trans-unit>
        <trans-unit id="b6129fb34e144fcdfe206a301e6dfcb025a1c2ff" translate="yes" xml:space="preserve">
          <source>In some cases, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; can undo a &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; operation:</source>
          <target state="translated">В некоторых случаях, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; может отменить &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; операцию:</target>
        </trans-unit>
        <trans-unit id="7dca494ed5d22b408ce97c79a38cce42379ecc3f" translate="yes" xml:space="preserve">
          <source>In some monads, using the applicative operators is more efficient than monadic bind. For example, it may enable more parallelism.</source>
          <target state="translated">В некоторых монадах использование прикладных операторов более эффективно,чем монадское связывание.Например,это может обеспечить большую параллельность.</target>
        </trans-unit>
        <trans-unit id="7dc076e52a11bd5ce04c056123ea9f1e10b44f69" translate="yes" xml:space="preserve">
          <source>In summary, Safe Haskell consists of the following three language flags:</source>
          <target state="translated">Таким образом,Safe Haskell состоит из следующих трех языковых флагов:</target>
        </trans-unit>
        <trans-unit id="c0610e4e2f239ff00ac0559246fa585a0148acde" translate="yes" xml:space="preserve">
          <source>In summary, given an &lt;code&gt;mdo&lt;/code&gt; expression, GHC first performs segmentation, introducing &lt;code&gt;rec&lt;/code&gt; blocks to wrap over minimal recursive groups. Then, each resulting &lt;code&gt;rec&lt;/code&gt; is desugared, using a call to &lt;code&gt;Control.Monad.Fix.mfix&lt;/code&gt; as described in the previous section. The original &lt;code&gt;mdo&lt;/code&gt;-expression typechecks exactly when the desugared version would do so.</source>
          <target state="translated">Таким образом, учитывая выражение &lt;code&gt;mdo&lt;/code&gt; , GHC сначала выполняет сегментацию, вводя блоки &lt;code&gt;rec&lt;/code&gt; для переноса минимальных рекурсивных групп. Затем каждый полученный &lt;code&gt;rec&lt;/code&gt; будет обессахаренный, используя вызов &lt;code&gt;Control.Monad.Fix.mfix&lt;/code&gt; , как описано в предыдущем разделе. Оригинальное &lt;code&gt;mdo&lt;/code&gt; -expression typechecks точно , когда обессахаренная версия будет делать это.</target>
        </trans-unit>
        <trans-unit id="a10dd2ac36a1ae45ee7e6746793e9b0203b43531" translate="yes" xml:space="preserve">
          <source>In terms of expressivity, the function &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:fixedPrim&quot;&gt;fixedPrim&lt;/a&gt;&lt;/code&gt; would be sufficient for constructing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;s. The fused variants of this function are provided because they allow for more efficient implementations. Our compilers are just not smart enough yet; and for some of the employed optimizations (see the code of &lt;code&gt;encodeByteStringWithF&lt;/code&gt;) they will very likely never be.</source>
          <target state="translated">С точки зрения выразительности, функции &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:fixedPrim&quot;&gt;fixedPrim&lt;/a&gt;&lt;/code&gt; будет достаточно для построения &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; s из &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; . Предлагаются объединенные варианты этой функции, поскольку они обеспечивают более эффективную реализацию. Наши компиляторы еще недостаточно умны; а для некоторых используемых оптимизаций (см. код &lt;code&gt;encodeByteStringWithF&lt;/code&gt; ) они, скорее всего, никогда не будут.</target>
        </trans-unit>
        <trans-unit id="16093d6461ecbdcf12ae1c671e142ce8282ad0b5" translate="yes" xml:space="preserve">
          <source>In terms of performance, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; (aka bound) threads are much more expensive than &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; (aka unbound) threads, because a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; thread is tied to a particular OS thread, whereas a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; thread can be run by any OS thread. Context-switching between a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; thread and a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; thread is many times more expensive than between two &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; threads.</source>
          <target state="translated">С точки зрения производительности, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; (также известные как связанные) намного дороже, чем &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; (также известные как несвязанные), потому что поток &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; привязан к конкретному потоку ОС, тогда как поток &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; может выполняться любым потоком ОС. Переключение контекста между потоком &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; и потоком &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; во много раз дороже, чем между двумя потоками &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bce56fe3f42df3f84c1b74ed1a9d8786ce76ea2b" translate="yes" xml:space="preserve">
          <source>In terms of the underlying bit encoding, each hexadecimal digit corresponds to 4 bits, and you may think of the exponent as &amp;ldquo;moving&amp;rdquo; the floating point by one bit left (negative) or right (positive). Here are some examples:</source>
          <target state="translated">Что касается базового битового кодирования, каждая шестнадцатеричная цифра соответствует 4 битам, и вы можете думать об экспоненте как о &amp;laquo;перемещении&amp;raquo; плавающей точки на один бит влево (отрицательное значение) или вправо (положительное значение). Вот некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="4c29bd546b673357d6a340429155e16543ce1ef1" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with a constant applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; например, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; должно быть эквивалентно обход с постоянным аппликативном функтором ( &lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="26bd18f823787461b100c3022f6a3b7c840dc2a6" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with the identity applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">В экземпляре &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; должен быть эквивалентен обходу с помощью аппликативного функтора идентификации ( &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="96a50628ee823a13660f1210d45eabd5be493de8" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with a constant applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; например, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; должно быть эквивалентно обход с постоянным аппликативном функтором ( &lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2b0439badce801cd06d5468b87c04f9c720d7a99" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with the identity applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">В экземпляре &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; должен быть эквивалентен обходу с помощью аппликативного функтора идентификации ( &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ca7aaa131ade1d4a8a95415db546c6e55e36ffda" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ModIface&lt;/code&gt; datatype you can find lots of useful information, including the exported definitions and type class instances.</source>
          <target state="translated">В &lt;code&gt;ModIface&lt;/code&gt; данных ModIface вы можете найти много полезной информации, включая экспортированные определения и экземпляры классов типов.</target>
        </trans-unit>
        <trans-unit id="c9e4b692ce0d40c03d30c364c1d3096a5795a987" translate="yes" xml:space="preserve">
          <source>In the above desugarings, the functions &lt;code&gt;toList&lt;/code&gt;, &lt;code&gt;fromList&lt;/code&gt; and &lt;code&gt;fromListN&lt;/code&gt; are all methods of the &lt;code&gt;IsList&lt;/code&gt; class, which is itself exported from the &lt;code&gt;GHC.Exts&lt;/code&gt; module. The type class is defined as follows:</source>
          <target state="translated">В приведенных выше сообщениях об &lt;code&gt;toList&lt;/code&gt; &lt;code&gt;fromList&lt;/code&gt; функции toList , fromList и &lt;code&gt;fromListN&lt;/code&gt; являются методами класса &lt;code&gt;IsList&lt;/code&gt; , который сам экспортируется из модуля &lt;code&gt;GHC.Exts&lt;/code&gt; . Класс типа определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="4825ce73481d56bef5ff3baeddca3bd6b9d29055" translate="yes" xml:space="preserve">
          <source>In the call &lt;code&gt;&lt;a href=&quot;numeric#v:showEFloat&quot;&gt;showEFloat&lt;/a&gt; digs val&lt;/code&gt;, if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the value is shown to full precision; if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt;, then at most &lt;code&gt;d&lt;/code&gt; digits after the decimal point are shown.</source>
          <target state="translated">В вызове &lt;code&gt;&lt;a href=&quot;numeric#v:showEFloat&quot;&gt;showEFloat&lt;/a&gt; digs val&lt;/code&gt; , если &lt;code&gt;digs&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , значение отображается с полной точностью; если &lt;code&gt;digs&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt; , то отображается не более &lt;code&gt;d&lt;/code&gt; цифр после десятичной точки.</target>
        </trans-unit>
        <trans-unit id="a51c3b2c73eac013b9c52be99faf3b0167ac1d7a" translate="yes" xml:space="preserve">
          <source>In the call &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt; digs val&lt;/code&gt;, if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the value is shown to full precision; if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt;, then at most &lt;code&gt;d&lt;/code&gt; digits after the decimal point are shown.</source>
          <target state="translated">В вызове &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt; digs val&lt;/code&gt; , если &lt;code&gt;digs&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , значение отображается с полной точностью; если &lt;code&gt;digs&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt; , то отображается не более &lt;code&gt;d&lt;/code&gt; цифр после десятичной точки.</target>
        </trans-unit>
        <trans-unit id="20f3428ed1923f90f0f3d4207a60933c2d70d92e" translate="yes" xml:space="preserve">
          <source>In the call &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloat&quot;&gt;showGFloat&lt;/a&gt; digs val&lt;/code&gt;, if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the value is shown to full precision; if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt;, then at most &lt;code&gt;d&lt;/code&gt; digits after the decimal point are shown.</source>
          <target state="translated">В вызове &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloat&quot;&gt;showGFloat&lt;/a&gt; digs val&lt;/code&gt; , если &lt;code&gt;digs&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , значение отображается с полной точностью; если &lt;code&gt;digs&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt; , то отображается не более &lt;code&gt;d&lt;/code&gt; цифр после десятичной точки.</target>
        </trans-unit>
        <trans-unit id="faf271f3b7e45777b426c7cffb5c33694e0dd460" translate="yes" xml:space="preserve">
          <source>In the caret diagnostics, there is currently no inheritance at all between &lt;code&gt;margin&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, and &lt;code&gt;fatal&lt;/code&gt;.</source>
          <target state="translated">В диагностике каретки в настоящее время нет наследования между &lt;code&gt;margin&lt;/code&gt; , &lt;code&gt;warning&lt;/code&gt; , &lt;code&gt;error&lt;/code&gt; и &lt;code&gt;fatal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df6b03ed8eec1645f1ec33aca8ebc6b982b543ce" translate="yes" xml:space="preserve">
          <source>In the case for &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt;, we append the encodings of the two subcomponents:</source>
          <target state="translated">В случае &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; мы добавляем кодировки двух подкомпонентов:</target>
        </trans-unit>
        <trans-unit id="a978f8a308124dfc5a94e8b84169bed1e73065cf" translate="yes" xml:space="preserve">
          <source>In the case for &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt;, we produce &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; depending on whether the constructor of the value provided is located on the left or on the right:</source>
          <target state="translated">В случае &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; мы создаем &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; в зависимости от того, находится ли конструктор предоставленного значения слева или справа:</target>
        </trans-unit>
        <trans-unit id="ce418c4b3f9c3b015c79b89b8c9bc6967c098d2d" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right:</source>
          <target state="translated">В случае списков, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; , когда применяется к бинарному оператору, начальному значению (обычно это левый идентификатор оператора) и списку, уменьшает список с помощью бинарного оператора слева направо:</target>
        </trans-unit>
        <trans-unit id="402a6cba8bb6099d8590be06c5b33a8b61bcddf5" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:</source>
          <target state="translated">В случае списков, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; , когда применяется к бинарному оператору, начальному значению (обычно это правый идентификатор оператора) и списку, уменьшает список с помощью бинарного оператора справа налево:</target>
        </trans-unit>
        <trans-unit id="685a71a3a3feec5434325876c2b1603c04dc1092" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right:</source>
          <target state="translated">В случае списков, &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; , когда применяется к бинарному оператору, начальному значению (обычно это левый идентификатор оператора) и списку, уменьшает список с помощью бинарного оператора слева направо:</target>
        </trans-unit>
        <trans-unit id="736cf45d430966ca499dea036acc85e2fd726f3c" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:</source>
          <target state="translated">В случае списков, &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; , когда применяется к бинарному оператору, начальному значению (обычно это правый идентификатор оператора) и списку, уменьшает список с помощью бинарного оператора справа налево:</target>
        </trans-unit>
        <trans-unit id="d2c4ff0ca5914473682d3bb850acf33cf8e28c10" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right:</source>
          <target state="translated">В случае списков, &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; , когда применяется к бинарному оператору, начальному значению (обычно это левый идентификатор оператора) и списку, уменьшает список с помощью бинарного оператора слева направо:</target>
        </trans-unit>
        <trans-unit id="814e67cd70bc9b16fbc05fe331eda86206bb01d8" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:</source>
          <target state="translated">В случае списков, &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; , когда применяется к бинарному оператору, начальному значению (обычно это правый идентификатор оператора) и списку, уменьшает список с помощью бинарного оператора справа налево:</target>
        </trans-unit>
        <trans-unit id="9d49a0dc9233f8cd0bbb34abc56b57be8989f4d7" translate="yes" xml:space="preserve">
          <source>In the case of transform comprehensions, notice that the groups are parameterised over some arbitrary type &lt;code&gt;n&lt;/code&gt; (provided it has an &lt;code&gt;fmap&lt;/code&gt;, as well as the comprehension being over an arbitrary monad.</source>
          <target state="translated">В случае преобразований, обратите внимание, что группы параметризованы по некоторому произвольному типу &lt;code&gt;n&lt;/code&gt; (при условии, что у него есть &lt;code&gt;fmap&lt;/code&gt; , а также понимание по произвольной монаде.</target>
        </trans-unit>
        <trans-unit id="3a3ec5fd8ab5dd582ca482ba430b56b04ee9d354" translate="yes" xml:space="preserve">
          <source>In the case where a module is compiled without one of &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt; being used, GHC will try to figure out itself if the module can be considered safe. This safety inference will never mark a module as trustworthy, only as either unsafe or as safe. GHC uses a simple method to determine this for a module M: If M would compile without error under the &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag, then M is marked as safe. Otherwise, it is marked as unsafe.</source>
          <target state="translated">В случае, если модуль скомпилирован без использования одного из параметров &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; &lt;/a&gt; , GHC попытается самостоятельно выяснить, можно ли считать модуль безопасным. Этот вывод безопасности никогда не пометит модуль как заслуживающий доверия, только как небезопасный или как безопасный. GHC использует простой метод для определения этого для модуля M: если M будет компилироваться без ошибок под флагом &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; , то M помечен как безопасный. В противном случае он помечается как небезопасный.</target>
        </trans-unit>
        <trans-unit id="bef7088bfdbcf4a4161af79eaa7b29eb8e585121" translate="yes" xml:space="preserve">
          <source>In the case where all the type variables in the pattern type signature are already in scope (i.e. bound by the enclosing context), matters are simple: the signature simply constrains the type of the pattern in the obvious way.</source>
          <target state="translated">В случае,когда все переменные типа в сигнатуре типа шаблона уже находятся в области видимости (т.е.связаны с окружающим контекстом),дело обстоит просто:сигнатура просто ограничивает тип шаблона очевидным образом.</target>
        </trans-unit>
        <trans-unit id="dd7dd4c533ac4dfdb79170f8873e9bdd1a07434d" translate="yes" xml:space="preserve">
          <source>In the class declaration, nothing constrains the kind of the type &lt;code&gt;a&lt;/code&gt;, so it becomes a poly-kinded type variable &lt;code&gt;(a :: k)&lt;/code&gt;. Yet, in the instance declaration, the right-hand side of the associated type instance &lt;code&gt;b -&amp;gt; b&lt;/code&gt; says that &lt;code&gt;b&lt;/code&gt; must be of kind &lt;code&gt;Type&lt;/code&gt;. GHC could theoretically propagate this information back into the instance head, and make that instance declaration apply only to type of kind &lt;code&gt;Type&lt;/code&gt;, as opposed to types of any kind. However, GHC does &lt;em&gt;not&lt;/em&gt; do this.</source>
          <target state="translated">В объявлении класса ничего не ограничивает тип типа &lt;code&gt;a&lt;/code&gt; , поэтому он становится переменной поликиндируемого типа &lt;code&gt;(a :: k)&lt;/code&gt; . Тем не менее, в объявлении экземпляра правая часть связанного экземпляра типа &lt;code&gt;b -&amp;gt; b&lt;/code&gt; говорит, что &lt;code&gt;b&lt;/code&gt; должен быть типа &lt;code&gt;Type&lt;/code&gt; . GHC теоретически мог бы распространить эту информацию обратно в заголовок экземпляра и применить объявление этого экземпляра только к типу типа &lt;code&gt;Type&lt;/code&gt; , а не к типам любого типа. Однако GHC этого &lt;em&gt;не&lt;/em&gt; делает.</target>
        </trans-unit>
        <trans-unit id="1ea0fe630422f6fbaa324604dd0d23443b8c3800" translate="yes" xml:space="preserve">
          <source>In the common case where &lt;code&gt;CProv&lt;/code&gt; is empty, (i.e., &lt;code&gt;()&lt;/code&gt;), it can be omitted altogether in the above pattern type signature for &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="translated">В общем случае , когда &lt;code&gt;CProv&lt;/code&gt; пусто, (т.е. &lt;code&gt;()&lt;/code&gt; ), он может быть опущен в целом выше типа рисунка подписи для &lt;code&gt;P&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="738595723a083effce19571c75a1705b54ce2cd0" translate="yes" xml:space="preserve">
          <source>In the current GHC implementation, the call stack is only available if the program was compiled with &lt;code&gt;-prof&lt;/code&gt;; otherwise &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceStack&quot;&gt;traceStack&lt;/a&gt;&lt;/code&gt; behaves exactly like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt;. Entries in the call stack correspond to &lt;code&gt;SCC&lt;/code&gt; annotations, so it is a good idea to use &lt;code&gt;-fprof-auto&lt;/code&gt; or &lt;code&gt;-fprof-auto-calls&lt;/code&gt; to add SCC annotations automatically.</source>
          <target state="translated">В текущей реализации GHC стек вызовов доступен только в том случае, если программа была скомпилирована с &lt;code&gt;-prof&lt;/code&gt; ; в противном случае &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceStack&quot;&gt;traceStack&lt;/a&gt;&lt;/code&gt; ведет себя точно так же, как &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; . Записи в стеке вызовов соответствуют аннотациям &lt;code&gt;SCC&lt;/code&gt; , поэтому для &lt;code&gt;-fprof-auto-calls&lt;/code&gt; добавления аннотаций SCC &lt;code&gt;-fprof-auto&lt;/code&gt; использовать -fprof-auto или -fprof-auto-calls .</target>
        </trans-unit>
        <trans-unit id="acbdce2c4062331f2c3f39e4ae942c4efb63986d" translate="yes" xml:space="preserve">
          <source>In the definition for &lt;code&gt;F&lt;/code&gt;, the two equations are incompatible &amp;ndash; their patterns are not apart, and yet their right-hand sides do not coincide. Thus, before GHC selects the second equation, it must be sure that the first can never apply. So, the type &lt;code&gt;F a&lt;/code&gt; does not simplify; only a type such as &lt;code&gt;F Double&lt;/code&gt; will simplify to &lt;code&gt;Char&lt;/code&gt;. In &lt;code&gt;G&lt;/code&gt;, on the other hand, the two equations are compatible. Thus, GHC can ignore the first equation when looking at the second. So, &lt;code&gt;G a&lt;/code&gt; will simplify to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">В определении для &lt;code&gt;F&lt;/code&gt; два уравнения несовместимы - их образцы не расходятся, но их правые части не совпадают. Таким образом, прежде чем GHC выберет второе уравнение, необходимо убедиться, что первое не применимо. Итак, тип &lt;code&gt;F a&lt;/code&gt; не упрощает; только такой тип, как &lt;code&gt;F Double&lt;/code&gt; , упростится до &lt;code&gt;Char&lt;/code&gt; . В &lt;code&gt;G&lt;/code&gt; , с другой стороны, два уравнения совместимы. Таким образом, GHC может игнорировать первое уравнение, глядя на второе. Итак, &lt;code&gt;G a&lt;/code&gt; упростится до &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="846c20df94f9314fa1fe586ab3d9172b13b606cb" translate="yes" xml:space="preserve">
          <source>In the definition of &lt;code&gt;gmapQ&lt;/code&gt;&lt;em&gt;x&lt;/em&gt; combinators, we use phantom type constructors for the &lt;code&gt;c&lt;/code&gt; in the type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; because the result type of a query does not involve the (polymorphic) type of the term argument. In the definition of &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQl&quot;&gt;gmapQl&lt;/a&gt;&lt;/code&gt; we simply use the plain constant type constructor because &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is left-associative anyway and so it is readily suited to fold a left-associative binary operation over the immediate subterms. In the definition of gmapQr, extra effort is needed. We use a higher-order accumulation trick to mediate between left-associative constructor application vs. right-associative binary operation (e.g., &lt;code&gt;(:)&lt;/code&gt;). When the query is meant to compute a value of type &lt;code&gt;r&lt;/code&gt;, then the result type withing generic folding is &lt;code&gt;r -&amp;gt; r&lt;/code&gt;. So the result of folding is a function to which we finally pass the right unit.</source>
          <target state="translated">В определении &lt;code&gt;gmapQ&lt;/code&gt; &lt;em&gt;x&lt;/em&gt; мы используем конструкторы фантомных типов для &lt;code&gt;c&lt;/code&gt; в типе &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; , потому что тип результата запроса не включает (полиморфный) тип аргумента термина. В определении &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQl&quot;&gt;gmapQl&lt;/a&gt;&lt;/code&gt; мы просто используем простой конструктор постоянного типа, потому что &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; в любом случае является левоассоциативным и поэтому легко подходит для свертывания левоассоциативной бинарной операции над непосредственными подтерминами. При определении gmapQr требуются дополнительные усилия. Мы используем трюк с накоплением более высокого порядка, чтобы быть посредником между приложением левоассоциативного конструктора и правоассоциативной бинарной операцией (например, &lt;code&gt;(:)&lt;/code&gt; ). Когда запрос предназначен для вычисления значения типа &lt;code&gt;r&lt;/code&gt; , тогда тип результата с универсальным сворачиванием будет &lt;code&gt;r -&amp;gt; r&lt;/code&gt; . Таким образом, результат сворачивания - это функция, которой мы наконец передаем нужный блок.</target>
        </trans-unit>
        <trans-unit id="172ded5aaf2bf60400ff8b3fbe797e04c36dee1c" translate="yes" xml:space="preserve">
          <source>In the degenerate case where all the alternatives have zero width, such as the &lt;code&gt;Bool&lt;/code&gt;-like &lt;code&gt;(# (# #) | (# #) #)&lt;/code&gt;, the unboxed sum layout only has an &lt;code&gt;Int32&lt;/code&gt; tag field (i.e., the whole thing is represented by an integer).</source>
          <target state="translated">В вырожденном случае, когда все альтернативы имеют нулевую ширину, например, &lt;code&gt;Bool&lt;/code&gt; - like &lt;code&gt;(# (# #) | (# #) #)&lt;/code&gt; , макет неупакованной суммы имеет только поле тега &lt;code&gt;Int32&lt;/code&gt; (т. Е. Все это представлено целым числом).</target>
        </trans-unit>
        <trans-unit id="eae7ddef52aa6d501f88a9704bbcc99c4b28932e" translate="yes" xml:space="preserve">
          <source>In the documentation, \(n\) is the number of elements in the list while \(d\) is the number of distinct elements in the list. \(W\) is the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В документации \ (n \) - количество элементов в списке, а \ (d \) - количество отдельных элементов в списке. \ (W \) - количество бит в &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0778e8d7eb2efc83b2b32dc144b880b32c199c0" translate="yes" xml:space="preserve">
          <source>In the documentation, \(n\) is the number of elements in the list while \(d\) is the number of distinct elements in the list. \(W\) is the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8410efb81dbdeacb0d6540b0e647a317447ad44" translate="yes" xml:space="preserve">
          <source>In the event you want to include ghc-compiled code as part of another (non-Haskell) program, the RTS will not be supplying its definition of &lt;code&gt;main()&lt;/code&gt; at link-time, you will have to. To signal that to the compiler when linking, use &lt;code&gt;-no-hs-main&lt;/code&gt;. See also &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите включить код, скомпилированный с помощью ghc, как часть другой программы (не Haskell), RTS не будет предоставлять свое определение &lt;code&gt;main()&lt;/code&gt; во время компоновки, вам придется это сделать. Чтобы сообщить об этом компилятору при компоновке, используйте &lt;code&gt;-no-hs-main&lt;/code&gt; . См. Также &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Использование собственного main ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d261a91a10cc118ec325a4c82debf0de9dec298f" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;Danger&lt;/code&gt; can import module &lt;code&gt;RIO&lt;/code&gt; because &lt;code&gt;RIO&lt;/code&gt; is compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;. Thus, &lt;code&gt;Danger&lt;/code&gt; can make use of the &lt;code&gt;rioReadFile&lt;/code&gt; and &lt;code&gt;rioWriteFile&lt;/code&gt; functions to access permitted file names. The main application then imports both &lt;code&gt;RIO&lt;/code&gt; and &lt;code&gt;Danger&lt;/code&gt;. To run the plugin, it calls &lt;code&gt;RIO.runRIO Danger.runMe&lt;/code&gt; within the &lt;code&gt;IO&lt;/code&gt; monad. The application is safe in the knowledge that the only &lt;code&gt;IO&lt;/code&gt; to ensue will be to files whose paths were approved by the &lt;code&gt;pathOK&lt;/code&gt; test.</source>
          <target state="translated">В этом примере &lt;code&gt;Danger&lt;/code&gt; может импортировать модуль &lt;code&gt;RIO&lt;/code&gt; , потому что &lt;code&gt;RIO&lt;/code&gt; скомпилирован с &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; . Таким образом, &lt;code&gt;Danger&lt;/code&gt; может использовать функции &lt;code&gt;rioReadFile&lt;/code&gt; и &lt;code&gt;rioWriteFile&lt;/code&gt; для доступа к разрешенным именам файлов. Затем основное приложение импортирует как &lt;code&gt;RIO&lt;/code&gt; ,так и &lt;code&gt;Danger&lt;/code&gt; . Чтобы запустить плагин, он вызывает &lt;code&gt;RIO.runRIO Danger.runMe&lt;/code&gt; в монаде &lt;code&gt;IO&lt;/code&gt; . Приложение безопасно, зная, что единственным &lt;code&gt;pathOK&lt;/code&gt; &lt;code&gt;IO&lt;/code&gt; будут файлы, пути которых были утверждены тестом pathOK .</target>
        </trans-unit>
        <trans-unit id="04e6cf746c3b3e5d963876bd4cd89448b3120476" translate="yes" xml:space="preserve">
          <source>In the examples above, all promoted constructors are prefixed with a single quote mark &lt;code&gt;'&lt;/code&gt;. This mark tells GHC to look in the data constructor namespace for a name, not the type (constructor) namespace. Consider</source>
          <target state="translated">В приведенных выше примерах все продвинутые конструкторы имеют префикс в виде одинарной кавычки &lt;code&gt;'&lt;/code&gt; . Этот знак указывает GHC искать имя в пространстве имен конструктора данных, а не в пространстве имен типа (конструктора). Рассматривать</target>
        </trans-unit>
        <trans-unit id="40ee1ceda8e59fc5b01c325869581e1e58fcdd95" translate="yes" xml:space="preserve">
          <source>In the first application of &lt;code&gt;f&lt;/code&gt;, we had to do some more type reconstruction in order to recover the result type of &lt;code&gt;f&lt;/code&gt;. But after that, we are free to use &lt;code&gt;f&lt;/code&gt; normally.</source>
          <target state="translated">В первом применении &lt;code&gt;f&lt;/code&gt; нам пришлось сделать еще несколько реконструкций типов, чтобы восстановить тип результата &lt;code&gt;f&lt;/code&gt; . Но после этого мы можем использовать &lt;code&gt;f&lt;/code&gt; как обычно.</target>
        </trans-unit>
        <trans-unit id="149193862750cd07d67aa98378a43e7fa5bcd8bc" translate="yes" xml:space="preserve">
          <source>In the first example above, &lt;code&gt;_x&lt;/code&gt; is generalised over (and is effectively replaced by a fresh type variable &lt;code&gt;a&lt;/code&gt;). In the second example, &lt;code&gt;_x&lt;/code&gt; is unified with the &lt;code&gt;Bool&lt;/code&gt; type, and as &lt;code&gt;Bool&lt;/code&gt; implements the &lt;code&gt;Show&lt;/code&gt; type class, the constraint &lt;code&gt;Show Bool&lt;/code&gt; can be simplified away.</source>
          <target state="translated">В первом примере выше &lt;code&gt;_x&lt;/code&gt; обобщается (и фактически заменяется новой переменной типа &lt;code&gt;a&lt;/code&gt; ). Во втором примере &lt;code&gt;_x&lt;/code&gt; объединяется с типом &lt;code&gt;Bool&lt;/code&gt; , и поскольку &lt;code&gt;Bool&lt;/code&gt; реализует класс типа &lt;code&gt;Show&lt;/code&gt; , ограничение &lt;code&gt;Show Bool&lt;/code&gt; можно упростить.</target>
        </trans-unit>
        <trans-unit id="5c6ea9d39cdb3d6f149abc95c32c55d1e377bfe4" translate="yes" xml:space="preserve">
          <source>In the first example, the kind variable &lt;code&gt;k&lt;/code&gt; is an &lt;em&gt;invisible&lt;/em&gt; argument to &lt;code&gt;ProxyKInvis&lt;/code&gt;. In other words, a user does not need to instantiate &lt;code&gt;k&lt;/code&gt; explicitly, as kind inference automatically determines what &lt;code&gt;k&lt;/code&gt; should be. For instance, in &lt;code&gt;ProxyKInvis True&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt; is inferred to be &lt;code&gt;Bool&lt;/code&gt;. This is reflected in the kind of &lt;code&gt;ProxyKInvis&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4e49151ec338f81e6976a10a88331d5852242bf" translate="yes" xml:space="preserve">
          <source>In the following, &amp;ldquo;Haskell file&amp;rdquo; is the main output (usually a &lt;code&gt;.hs&lt;/code&gt; file), &amp;ldquo;compiled Haskell file&amp;rdquo; is the Haskell file after &lt;code&gt;ghc&lt;/code&gt; has compiled it to C (i.e. a &lt;code&gt;.hc&lt;/code&gt; file), &amp;ldquo;C program&amp;rdquo; is the program that outputs the Haskell file, &amp;ldquo;C file&amp;rdquo; is the optionally generated C file, and &amp;ldquo;C header&amp;rdquo; is its header file.</source>
          <target state="translated">Далее &amp;laquo;файл Haskell&amp;raquo; - это основной вывод (обычно файл &lt;code&gt;.hs&lt;/code&gt; ), &amp;laquo;скомпилированный файл Haskell&amp;raquo; - это файл Haskell после того, как &lt;code&gt;ghc&lt;/code&gt; скомпилировал его в C (то есть файл &lt;code&gt;.hc&lt;/code&gt; ), &amp;laquo;C-программа&amp;raquo; - это программа, которая выводит файл Haskell, &amp;laquo;файл C&amp;raquo; - это необязательно сгенерированный файл C, а &amp;laquo;заголовок C&amp;raquo; - его файл заголовка.</target>
        </trans-unit>
        <trans-unit id="dc1456dc1bb5376e50df9356963ec4ad4e2b367b" translate="yes" xml:space="preserve">
          <source>In the function &lt;code&gt;h&lt;/code&gt; we use the record selectors &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;bind&lt;/code&gt; to extract the polymorphic bind and return functions from the &lt;code&gt;MonadT&lt;/code&gt; data structure, rather than using pattern matching.</source>
          <target state="translated">В функции &lt;code&gt;h&lt;/code&gt; мы используем селекторы записей &lt;code&gt;return&lt;/code&gt; и &lt;code&gt;bind&lt;/code&gt; для извлечения полиморфных функций связывания и возврата из &lt;code&gt;MonadT&lt;/code&gt; данных MonadT , вместо использования сопоставления с образцом.</target>
        </trans-unit>
        <trans-unit id="3c2ee3eafdcad4b683c78d591fee52c85b813144" translate="yes" xml:space="preserve">
          <source>In the future, GHC might use the manifest file for more things, such as supplying the location of dependent DLLs.</source>
          <target state="translated">В будущем GHC может использовать файл манифеста для других целей,например,для предоставления местоположения зависимых DLL.</target>
        </trans-unit>
        <trans-unit id="8c26d49122d64dd0270b09c279fadaf85a7e889c" translate="yes" xml:space="preserve">
          <source>In the last line, we use the promoted constructor &lt;code&gt;'MkCompose&lt;/code&gt;, which has kind</source>
          <target state="translated">В последней строке мы используем продвинутый конструктор &lt;code&gt;'MkCompose&lt;/code&gt; , который имеет вид</target>
        </trans-unit>
        <trans-unit id="6ea81a9e9ab238a60258241f86c06e46f72fec13" translate="yes" xml:space="preserve">
          <source>In the last section we saw that besides a name, a &lt;code&gt;CoreDoPluginPass&lt;/code&gt; takes a pass of type &lt;code&gt;PluginPass&lt;/code&gt;. A &lt;code&gt;PluginPass&lt;/code&gt; is a synonym for &lt;code&gt;(ModGuts -&amp;gt; CoreM ModGuts)&lt;/code&gt;. &lt;code&gt;ModGuts&lt;/code&gt; is a type that represents the one module being compiled by GHC at any given time.</source>
          <target state="translated">В последнем разделе мы видели, что помимо имени &lt;code&gt;CoreDoPluginPass&lt;/code&gt; принимает проход типа &lt;code&gt;PluginPass&lt;/code&gt; . &lt;code&gt;PluginPass&lt;/code&gt; является синонимом &lt;code&gt;(ModGuts -&amp;gt; CoreM ModGuts)&lt;/code&gt; . &lt;code&gt;ModGuts&lt;/code&gt; - это тип, который представляет один модуль, компилируемый GHC в любой момент времени.</target>
        </trans-unit>
        <trans-unit id="e7151264545101799acf59e7b7e571c55db95bd2" translate="yes" xml:space="preserve">
          <source>In the light of the overlap decision, instance lookup works like this when trying to solve a class constraint &lt;code&gt;C t&lt;/code&gt;</source>
          <target state="translated">В свете решения о перекрытии поиск экземпляра работает следующим образом при попытке решить ограничение класса &lt;code&gt;C t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53eb63bc56e230d6466f7d38014cd8cc4cf52862" translate="yes" xml:space="preserve">
          <source>In the messages from the compiler, we see that there is no line for &lt;code&gt;D&lt;/code&gt;. This is because it isn&amp;rsquo;t necessary to compile &lt;code&gt;D&lt;/code&gt;, because the source and everything it depends on is unchanged since the last compilation.</source>
          <target state="translated">В сообщениях от компилятора мы видим, что для &lt;code&gt;D&lt;/code&gt; нет строчки . Это потому, что нет необходимости компилировать &lt;code&gt;D&lt;/code&gt; , потому что источник и все, от чего он зависит, не изменилось с момента последней компиляции.</target>
        </trans-unit>
        <trans-unit id="ddeb2139081c601845dbe769a075fe10d73419d8" translate="yes" xml:space="preserve">
          <source>In the olden days, GHC compared the newly-generated &lt;code&gt;.hi&lt;/code&gt; file with the previous version; if they were identical, it left the old one alone and didn&amp;rsquo;t change its modification date. In consequence, importers of a module with an unchanged output &lt;code&gt;.hi&lt;/code&gt; file were not recompiled.</source>
          <target state="translated">&lt;code&gt;.hi&lt;/code&gt; GHC сравнивал вновь созданный файл .hi с предыдущей версией; если они были идентичны, он оставлял старую в покое и не менял дату его модификации. Как следствие, импортеры модуля с неизмененным выходным файлом &lt;code&gt;.hi&lt;/code&gt; не были перекомпилированы.</target>
        </trans-unit>
        <trans-unit id="374581211f11803a65e2cf204f4183e85b4fceb6" translate="yes" xml:space="preserve">
          <source>In the output above, observe that &lt;code&gt;T&lt;/code&gt; has two kind variables (&lt;code&gt;k&lt;/code&gt; and &lt;code&gt;l&lt;/code&gt;) and two type variables (&lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;). Note that &lt;code&gt;k&lt;/code&gt; is an &lt;em&gt;inferred&lt;/em&gt; variable and &lt;code&gt;l&lt;/code&gt; is a &lt;em&gt;specified&lt;/em&gt; variable (see &lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;), so as a result, they are displayed using slightly different syntax in the type &lt;code&gt;T @{k} @l a b&lt;/code&gt;. The application of &lt;code&gt;l&lt;/code&gt; (with &lt;code&gt;@l&lt;/code&gt;) is the standard syntax for visible type application (see &lt;a href=&quot;glasgow_exts#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;). The application of &lt;code&gt;k&lt;/code&gt; (with &lt;code&gt;@{k}&lt;/code&gt;), however, uses a hypothetical syntax for visible type application of inferred type variables. This syntax is not currently exposed to the programmer, but it is nevertheless displayed when &lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">В выходных данных выше обратите внимание, что &lt;code&gt;T&lt;/code&gt; имеет переменные двух типов ( &lt;code&gt;k&lt;/code&gt; и &lt;code&gt;l&lt;/code&gt; ) и переменные двух типов ( &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; ). Обратите внимание, что &lt;code&gt;k&lt;/code&gt; - это &lt;em&gt;предполагаемая&lt;/em&gt; переменная, а &lt;code&gt;l&lt;/code&gt; - &lt;em&gt;указанная&lt;/em&gt; переменная (см. &lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;Предполагаемые и указанные переменные типа&lt;/a&gt; ), поэтому в результате они отображаются с использованием немного другого синтаксиса в типе &lt;code&gt;T @{k} @l a b&lt;/code&gt; . Применение &lt;code&gt;l&lt;/code&gt; (с &lt;code&gt;@l&lt;/code&gt; ) является стандартным синтаксисом для приложения видимого типа (см. &lt;a href=&quot;glasgow_exts#visible-type-application&quot;&gt;Приложение видимого типа&lt;/a&gt; ). Применение &lt;code&gt;k&lt;/code&gt; (с &lt;code&gt;@{k}&lt;/code&gt; ), однако, использует гипотетический синтаксис для применения видимого типа переменных выведенного типа. Этот синтаксис в настоящее время не доступен программисту, но, тем не менее, отображается, когда включен &lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt; types.</target>
        </trans-unit>
        <trans-unit id="0a5a27aca496c351b26fd16433d9f2aacedebfda" translate="yes" xml:space="preserve">
          <source>In the paper and the previous implementation, values on the stack were paired to the right of the environment in a single argument, but now the environment and stack are separate arguments.</source>
          <target state="translated">В статье и в предыдущей реализации значения на стеке были сопряжены справа от окружения в одном аргументе,но теперь окружение и стек являются отдельными аргументами.</target>
        </trans-unit>
        <trans-unit id="e4a4ad8ff9e2ea2640cf5cde3b222326c4f733bc" translate="yes" xml:space="preserve">
          <source>In the previous example, we used a conditional expression to construct the input for an arrow. Sometimes we want to conditionally execute different commands, as in</source>
          <target state="translated">В предыдущем примере мы использовали условное выражение для построения входа для стрелки.Иногда нам хочется условно выполнять различные команды,как в случае с</target>
        </trans-unit>
        <trans-unit id="53458cc6655e7a520b6f10bf393f2ad481ee4cd4" translate="yes" xml:space="preserve">
          <source>In the second declaration, GHC cannot immediately tell that &lt;code&gt;k&lt;/code&gt; should be a dependent variable, and so the declaration is rejected.</source>
          <target state="translated">Во втором объявлении GHC не может сразу сказать, что &lt;code&gt;k&lt;/code&gt; должна быть зависимой переменной, и поэтому объявление отклоняется.</target>
        </trans-unit>
        <trans-unit id="e04af78973d3e47e134276ff85a7f3c652f7d13c" translate="yes" xml:space="preserve">
          <source>In the second example, &lt;code&gt;k&lt;/code&gt; is a &lt;em&gt;visible&lt;/em&gt; argument to &lt;code&gt;ProxyKVis&lt;/code&gt;. That is to say, &lt;code&gt;k&lt;/code&gt; is an argument that users must provide explicitly when applying &lt;code&gt;ProxyKVis&lt;/code&gt;. For example, &lt;code&gt;ProxyKVis Bool True&lt;/code&gt; is a well formed type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55addee8e051e63bec155782732ce1d09c9a2858" translate="yes" xml:space="preserve">
          <source>In the simple case of the previous section, we can say that specified variables appear in left-to-right order. However, not all cases are so simple. Here are the rules in the subtler cases:</source>
          <target state="translated">В простом случае предыдущего раздела можно сказать,что указанные переменные появляются в порядке слева направо.Однако не все случаи настолько просты.Вот правила в более тонких случаях:</target>
        </trans-unit>
        <trans-unit id="97b005cab59c28efe19b8404620d4586fb6285f7" translate="yes" xml:space="preserve">
          <source>In the threaded and SMP versions of the RTS (see &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), a major GC is automatically performed if the runtime has been idle (no Haskell computation has been running) for a period of time. The amount of idle time which must pass before a GC is performed is set by the &lt;code&gt;-I ⟨seconds⟩&lt;/code&gt; option. Specifying &lt;code&gt;-I0&lt;/code&gt; disables the idle GC.</source>
          <target state="translated">В &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; и SMP-версиях RTS (см. -Threaded , &lt;a href=&quot;phases#options-linker&quot;&gt;Параметры, влияющие на связывание&lt;/a&gt; ), основной сборщик мусора автоматически выполняется, если среда выполнения простаивает (не выполнялись вычисления Haskell) в течение определенного периода времени. Время простоя, которое должно пройти до выполнения GC, устанавливается параметром &lt;code&gt;-I ⟨seconds⟩&lt;/code&gt; . Указание &lt;code&gt;-I0&lt;/code&gt; отключает бездействующий сборщик мусора .</target>
        </trans-unit>
        <trans-unit id="1694137a8ab9fbad9a236c803a20b15d21740e1f" translate="yes" xml:space="preserve">
          <source>In the unification check in the final bullet, GHC also uses the &amp;ldquo;in-scope given constraints&amp;rdquo;. Consider for example</source>
          <target state="translated">При проверке унификации в последнем пункте GHC также использует &amp;laquo;заданные в рамках области ограничения&amp;raquo;. Рассмотрим, например,</target>
        </trans-unit>
        <trans-unit id="588a44eae37ca5b1dac65821d0d9f7a7a8542d81" translate="yes" xml:space="preserve">
          <source>In the unlikely case that modifier characters of some kind are desirable for a user-provided type, a &lt;code&gt;&lt;a href=&quot;text-printf#t:ModifierParser&quot;&gt;ModifierParser&lt;/a&gt;&lt;/code&gt; can be provided to process these characters. The resulting modifiers will appear in the &lt;code&gt;&lt;a href=&quot;text-printf#t:FieldFormat&quot;&gt;FieldFormat&lt;/a&gt;&lt;/code&gt; for use by the type-specific formatter.</source>
          <target state="translated">В том маловероятном случае, когда какие-либо символы-модификаторы желательны для типа, предоставленного пользователем, для обработки этих символов может быть предоставлен &lt;code&gt;&lt;a href=&quot;text-printf#t:ModifierParser&quot;&gt;ModifierParser&lt;/a&gt;&lt;/code&gt; . Результирующие модификаторы появятся в &lt;code&gt;&lt;a href=&quot;text-printf#t:FieldFormat&quot;&gt;FieldFormat&lt;/a&gt;&lt;/code&gt; для использования программой форматирования для конкретного типа.</target>
        </trans-unit>
        <trans-unit id="2ad711240568f9303ca209fe831d40e7c3af2733" translate="yes" xml:space="preserve">
          <source>In theory, this mechanism allows arbitrary data to be roundtripped via a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; with no loss of data. In practice, there are two limitations to be aware of:</source>
          <target state="translated">Теоретически этот механизм позволяет передавать произвольные данные через &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; без потери данных. На практике следует помнить о двух ограничениях:</target>
        </trans-unit>
        <trans-unit id="23cb01df08dfcb7824b863fc014f5bf29ea5fc79" translate="yes" xml:space="preserve">
          <source>In this case the derived instance declaration is of the form</source>
          <target state="translated">В этом случае производное заявление в качестве примера имеет форму</target>
        </trans-unit>
        <trans-unit id="71a288fd8d8656887893d68ab53108d408b426c0" translate="yes" xml:space="preserve">
          <source>In this case the kind parameter &lt;code&gt;k&lt;/code&gt; is actually an implicit parameter of the type family.</source>
          <target state="translated">В этом случае параметр вида &lt;code&gt;k&lt;/code&gt; фактически является неявным параметром семейства типов.</target>
        </trans-unit>
        <trans-unit id="1458f3d45d7cf8add3f964f47bf5c04fad0f65f0" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Head&lt;/code&gt; ⟨x⟩ cannot be used in expressions, only patterns, since it wouldn&amp;rsquo;t specify a value for the ⟨xs⟩ on the right-hand side. However, we can define an explicitly bidirectional pattern synonym by separately specifying how to construct and deconstruct a type. The syntax for doing this is as follows:</source>
          <target state="translated">В этом случае &lt;code&gt;Head&lt;/code&gt; ⟨x⟩ не может использоваться в выражениях, только в шаблонах, поскольку он не будет указывать значение для ⟨xs⟩ с правой стороны. Однако мы можем определить явно двунаправленный синоним шаблона, отдельно указав, как построить и деконструировать тип. Синтаксис для этого следующий:</target>
        </trans-unit>
        <trans-unit id="a0936edcab6b0c6b0eac6247ce8f47c52daa2c9a" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;g&lt;/code&gt; is desugared to</source>
          <target state="translated">В этом случае &lt;code&gt;g&lt;/code&gt; уменьшается до</target>
        </trans-unit>
        <trans-unit id="46b676aa5c3c6fb868cf3f9cd7c077e91b44b610" translate="yes" xml:space="preserve">
          <source>In this case, the child thread will receive a &lt;code&gt;NonTermination&lt;/code&gt; exception instead of waiting for the value of &lt;code&gt;r&lt;/code&gt; to be computed.</source>
          <target state="translated">В этом случае дочерний поток получит исключение &lt;code&gt;NonTermination&lt;/code&gt; вместо того, чтобы ждать вычисления значения &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cd24087d75374f112a445bc71400a6456c492b4" translate="yes" xml:space="preserve">
          <source>In this case, we could not simply bind &lt;code&gt;k&lt;/code&gt; on the left-hand side, as &lt;code&gt;k&lt;/code&gt; would become a &lt;em&gt;visible&lt;/em&gt; parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22cc674153a787afcfa95c57ed93cc3673880fbe" translate="yes" xml:space="preserve">
          <source>In this case, we were able to do this with &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;, but operations with more complex types require special lifting functions, which are provided by monad transformers for which they can be implemented. If you use the monad classes of the &lt;code&gt;mtl&lt;/code&gt; package or similar, this lifting is handled automatically by the instances of the classes, and you need only use the generalized methods &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt;.</source>
          <target state="translated">В этом случае мы смогли сделать это с помощью &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; , но для операций с более сложными типами требуются специальные функции подъема, которые предоставляются преобразователями монад, для которых они могут быть реализованы. Если вы используете классы монад из пакета &lt;code&gt;mtl&lt;/code&gt; или аналогичного, этот подъем выполняется автоматически экземплярами классов, и вам нужно использовать только обобщенные методы &lt;code&gt;get&lt;/code&gt; и &lt;code&gt;put&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bb4a09f269488c7395d0751f14e5beb2db506fc" translate="yes" xml:space="preserve">
          <source>In this chapter you&amp;rsquo;ll find a complete reference to the GHC command-line syntax, including all 400+ flags. It&amp;rsquo;s a large and complex system, and there are lots of details, so it can be quite hard to figure out how to get started. With that in mind, this introductory section provides a quick introduction to the basic usage of GHC for compiling a Haskell program, before the following sections dive into the full syntax.</source>
          <target state="translated">В этой главе вы найдете полную ссылку на синтаксис командной строки GHC, включая все 400+ флагов. Это большая и сложная система, в которой много деталей, поэтому может быть довольно сложно понять, с чего начать. Имея это в виду, этот вводный раздел представляет собой краткое введение в базовое использование GHC для компиляции программы на Haskell, прежде чем в следующих разделах будет рассмотрен полный синтаксис.</target>
        </trans-unit>
        <trans-unit id="a4cb88a5dbcf9e66af97ada60f7fc8018cc84f7c" translate="yes" xml:space="preserve">
          <source>In this code, once we pass the initial check for an empty list we know that in the recursive case this pattern match is redundant. As such &lt;code&gt;-fspec-constr&lt;/code&gt; will transform the above code to:</source>
          <target state="translated">В этом коде после прохождения начальной проверки пустого списка мы знаем, что в рекурсивном случае это совпадение с шаблоном является избыточным. Таким образом, &lt;code&gt;-fspec-constr&lt;/code&gt; преобразует приведенный выше код в:</target>
        </trans-unit>
        <trans-unit id="b4c5c94cfab7bea6a279520afd17cf54b4f5145f" translate="yes" xml:space="preserve">
          <source>In this example the &lt;code&gt;Reader&lt;/code&gt; monad provides access to variable bindings. Bindings are a &lt;code&gt;Map&lt;/code&gt; of integer variables. The variable &lt;code&gt;count&lt;/code&gt; contains number of variables in the bindings. You can see how to run a Reader monad and retrieve data from it with &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:runReader&quot;&gt;runReader&lt;/a&gt;&lt;/code&gt;, how to access the Reader data with &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:asks&quot;&gt;asks&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В этом примере монада &lt;code&gt;Reader&lt;/code&gt; обеспечивает доступ к привязкам переменных. Привязки - это &lt;code&gt;Map&lt;/code&gt; целочисленных переменных. &lt;code&gt;count&lt;/code&gt; переменных содержит количество переменных в привязках. Вы можете увидеть, как запустить монаду Reader и получить из нее данные с помощью &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:runReader&quot;&gt;runReader&lt;/a&gt;&lt;/code&gt; , как получить доступ к данным Reader с помощью &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:asks&quot;&gt;asks&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b2208e92b48546b397d55cc261960cb8033549a" translate="yes" xml:space="preserve">
          <source>In this example we use the operations &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt; from &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt;, which are defined only for monads that are applications of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt;. Alternatively one could use monad classes from the &lt;code&gt;mtl&lt;/code&gt; package or similar, which contain methods &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt; with types generalized over all suitable monads.</source>
          <target state="translated">В этом примере мы используем операции &lt;code&gt;get&lt;/code&gt; и &lt;code&gt;put&lt;/code&gt; из &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; , которые определены только для монад, которые являются приложениями &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; . В качестве альтернативы можно использовать классы монад из пакета &lt;code&gt;mtl&lt;/code&gt; или аналогичного, которые содержат методы &lt;code&gt;get&lt;/code&gt; и &lt;code&gt;put&lt;/code&gt; с типами, обобщенными для всех подходящих монад.</target>
        </trans-unit>
        <trans-unit id="22ae5ddc301afbf76db451d6ae86206a63cdb84b" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;, and &lt;code&gt;b&lt;/code&gt; depends on &lt;code&gt;a&lt;/code&gt;. Even though &lt;code&gt;a&lt;/code&gt; appears lexically before &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are quantified first, because &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;. Note further that &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are not reordered with respect to each other, even though doing so would not violate dependency conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ac2fd6e175d918e681db807d09bc0d9cfd7a0f" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;op&lt;/code&gt; is not an ordinary top-level function; it is a class method. GHC rapidly rewrites any occurrences of &lt;code&gt;op&lt;/code&gt;-used-at-type-Bool to a specialised function, say &lt;code&gt;opBool&lt;/code&gt;, where</source>
          <target state="translated">В этом примере &lt;code&gt;op&lt;/code&gt; - не обычная функция верхнего уровня; это метод класса. GHC быстро переписывает любые вхождения &lt;code&gt;op&lt;/code&gt; -used-at-type-Bool в специализированную функцию, скажем, &lt;code&gt;opBool&lt;/code&gt; , где</target>
        </trans-unit>
        <trans-unit id="a54c35f64a11f9102b446b75a06ab15997039209" translate="yes" xml:space="preserve">
          <source>In this example, a &lt;code&gt;reify&lt;/code&gt; inside&amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="144a6001279409b5fe23e336fea6b41236a7436a" translate="yes" xml:space="preserve">
          <source>In this example, a &lt;code&gt;reify&lt;/code&gt; inside...</source>
          <target state="translated">В этом примере &lt;code&gt;reify&lt;/code&gt; внутри ...</target>
        </trans-unit>
        <trans-unit id="d1ca7b6071a21a43da3a7e5ebc0b51fe9aa62cd1" translate="yes" xml:space="preserve">
          <source>In this example, all of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, and &lt;code&gt;k&lt;/code&gt; are considered kind variables and will always be placed before &lt;code&gt;b&lt;/code&gt;, a lowly type variable. (Note that &lt;code&gt;a&lt;/code&gt; is used in &lt;code&gt;b&lt;/code&gt;&amp;lsquo;s kind.) Yet, even though &lt;code&gt;a&lt;/code&gt; appears lexically before &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are quantified first, because &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;. Note further that &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are not reordered with respect to each other, even though doing so would not violate dependency conditions.</source>
          <target state="translated">В этом примере все &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; и &lt;code&gt;k&lt;/code&gt; считаются переменными типа и всегда будут помещаться перед &lt;code&gt;b&lt;/code&gt; , переменной низкого типа. (Обратите внимание, что &lt;code&gt;a&lt;/code&gt; используется в виде &lt;code&gt;b&lt;/code&gt; .) Тем не менее, даже если &lt;code&gt;a&lt;/code&gt; лексически появляется перед &lt;code&gt;j&lt;/code&gt; и &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; и &lt;code&gt;k&lt;/code&gt; количественно оцениваются первыми, потому что &lt;code&gt;a&lt;/code&gt; зависит от &lt;code&gt;j&lt;/code&gt; и &lt;code&gt;k&lt;/code&gt; . Обратите внимание, что &lt;code&gt;j&lt;/code&gt; и &lt;code&gt;k&lt;/code&gt; не переупорядочиваются относительно друг друга, даже если это не нарушит условия зависимости.</target>
        </trans-unit>
        <trans-unit id="ea70ba4f788151f3c14bd89916938adefd9dddbc" translate="yes" xml:space="preserve">
          <source>In this example, the declaration has only one variant. In general, it can be any number.</source>
          <target state="translated">В данном примере у декларации есть только один вариант.В общем,это может быть любое число.</target>
        </trans-unit>
        <trans-unit id="c73dc37636c8cb640cf041df73293ff0e50794dc" translate="yes" xml:space="preserve">
          <source>In this example, the list &lt;code&gt;output&lt;/code&gt; would take on the value:</source>
          <target state="translated">В этом примере &lt;code&gt;output&lt;/code&gt; списка примет значение:</target>
        </trans-unit>
        <trans-unit id="0477cc1de77b96d2dcbf9d8cc1e8fbeac11cb261" translate="yes" xml:space="preserve">
          <source>In this example, we inspect all available details of the compiled source code. We don&amp;rsquo;t change any of the representation, but write out the details to the standard output. The pretty printed representation of the parsed, renamed and type checked syntax tree will be in the output as well as the evaluated splices and quasi quotes. The name of the interfaces that are loaded will also be displayed.</source>
          <target state="translated">В этом примере мы проверяем все доступные детали скомпилированного исходного кода. Мы не меняем никаких представлений, но выводим детали на стандартный вывод. Красивое напечатанное представление синтаксического дерева проанализированного, переименованного и проверенного типа будет на выходе, а также оцененные соединения и квази-кавычки. Также будет отображаться имя загруженных интерфейсов.</target>
        </trans-unit>
        <trans-unit id="ce7a808f73475173c84b4a7d49aa6676ec3a0955" translate="yes" xml:space="preserve">
          <source>In this example, you cannot say &lt;code&gt;... deriving( Show )&lt;/code&gt; on the data type declaration for &lt;code&gt;T&lt;/code&gt;, because &lt;code&gt;T&lt;/code&gt; is a GADT, but you &lt;em&gt;can&lt;/em&gt; generate the instance declaration using stand-alone deriving.</source>
          <target state="translated">В этом примере вы не можете сказать &lt;code&gt;... deriving( Show )&lt;/code&gt; в объявлении типа данных для &lt;code&gt;T&lt;/code&gt; , потому что &lt;code&gt;T&lt;/code&gt; - это GADT, но вы &lt;em&gt;можете&lt;/em&gt; сгенерировать объявление экземпляра, используя автономное получение.</target>
        </trans-unit>
        <trans-unit id="af62a3290de70aad01a1a52e1391134fd1bf6e1e" translate="yes" xml:space="preserve">
          <source>In this mode, GHC will build a multi-module Haskell program automatically, figuring out dependencies for itself. If you have a straightforward Haskell program, this is likely to be much easier, and faster, than using &lt;strong&gt;make&lt;/strong&gt;. Make mode is described in &lt;a href=&quot;#make-mode&quot;&gt;Using ghc &amp;ndash;make&lt;/a&gt;.</source>
          <target state="translated">В этом режиме GHC автоматически построит многомодульную программу на Haskell, выясняя для себя зависимости. Если у вас есть простая программа на Haskell, это, вероятно, будет намного проще и быстрее, чем использование &lt;strong&gt;make&lt;/strong&gt; . Режим make описан в &lt;a href=&quot;#make-mode&quot;&gt;разделе Использование ghc &amp;ndash;make&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05b4a3b6689dfdb162bbf16479c4e6487fd716f8" translate="yes" xml:space="preserve">
          <source>In this mode, GHC will build a multi-module Haskell program automatically, figuring out dependencies for itself. If you have a straightforward Haskell program, this is likely to be much easier, and faster, than using &lt;strong&gt;make&lt;/strong&gt;. Make mode is described in &lt;a href=&quot;#make-mode&quot;&gt;Using ghc --make&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b5fc6a536a1554868646b6ca60e10360d30c4b" translate="yes" xml:space="preserve">
          <source>In this mode, GHC will build a multi-module Haskell program by following dependencies from one or more root modules (usually just &lt;code&gt;Main&lt;/code&gt;). For example, if your &lt;code&gt;Main&lt;/code&gt; module is in a file called &lt;code&gt;Main.hs&lt;/code&gt;, you could compile and link the program like this:</source>
          <target state="translated">В этом режиме GHC создаст многомодульную программу на Haskell, следуя зависимостям от одного или нескольких корневых модулей (обычно только &lt;code&gt;Main&lt;/code&gt; ). Например, если ваш &lt;code&gt;Main&lt;/code&gt; модуль находится в файле с именем &lt;code&gt;Main.hs&lt;/code&gt; , вы можете скомпилировать и связать программу следующим образом:</target>
        </trans-unit>
        <trans-unit id="28db988427b635ef091ce5edd09284a3efe60154" translate="yes" xml:space="preserve">
          <source>In this notation floating point numbers are written using hexadecimal digits, and so the digits are interpreted using base 16, rather then the usual 10. This means that digits left of the decimal point correspond to positive powers of 16, while the ones to the right correspond to negative ones.</source>
          <target state="translated">В этой нотации числа с плавающей точкой записываются с использованием шестнадцатеричных цифр,поэтому цифры интерпретируются с использованием базы 16,а не обычных 10.Это означает,что цифры слева от десятичной точки соответствуют положительной силе 16,а цифры справа-отрицательной.</target>
        </trans-unit>
        <trans-unit id="1625565ac67aff08f4fe4a675ec370d8a1444409" translate="yes" xml:space="preserve">
          <source>In this redefinition, we give an explicit kind for &lt;code&gt;(:~~:)&lt;/code&gt;, deferring the choice of &lt;code&gt;k2&lt;/code&gt; until after the first argument (&lt;code&gt;a&lt;/code&gt;) has been given. With this declaration for &lt;code&gt;(:~~:)&lt;/code&gt;, the instance for &lt;code&gt;HTestEquality&lt;/code&gt; is accepted.</source>
          <target state="translated">В этом переопределении мы даем явный вид для &lt;code&gt;(:~~:)&lt;/code&gt; , откладывая выбор &lt;code&gt;k2&lt;/code&gt; до тех пор, пока не будет указан первый аргумент ( &lt;code&gt;a&lt;/code&gt; ). С этим объявлением для &lt;code&gt;(:~~:)&lt;/code&gt; экземпляр для &lt;code&gt;HTestEquality&lt;/code&gt; принимается.</target>
        </trans-unit>
        <trans-unit id="241d07916ab9a1a491c806d2158cdc7962a6343f" translate="yes" xml:space="preserve">
          <source>In this version, sequencing of computations is lazy, so that for example the following produces a usable result:</source>
          <target state="translated">В этой версии последовательность вычислений ленива,так что,например,следующее дает полезный результат:</target>
        </trans-unit>
        <trans-unit id="c84b399cd2cbed2ef45d9909f32f6700a23e3816" translate="yes" xml:space="preserve">
          <source>In this version, sequencing of computations is strict (but computations are not strict in the state unless you force it with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; or the like). For a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-state-lazy&quot;&gt;Control.Monad.Trans.State.Lazy&lt;/a&gt;.</source>
          <target state="translated">В этой версии последовательность вычислений является строгой (но вычисления не являются строгими в состоянии, если вы не используете ее с помощью &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; и т.п.). Для ленивой версии с тем же интерфейсом см. &lt;a href=&quot;control-monad-trans-state-lazy&quot;&gt;Control.Monad.Trans.State.Lazy&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="733a7b8597e3bea6d79329500059b7357f9f04c9" translate="yes" xml:space="preserve">
          <source>In this version, sequencing of computations is strict (but computations are not strict in the state unless you force it with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; or the like). For a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-state-lazy&quot;&gt;Control.Monad.Trans.State.Lazy&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6a029dcaf77ff2149eaa82e23825caa41a60b1" translate="yes" xml:space="preserve">
          <source>In type errors, also print type-synonym-expanded types.</source>
          <target state="translated">В ошибках типа,а также в печати типа-синоним расширенных типов.</target>
        </trans-unit>
        <trans-unit id="9cdca6bb9120edae790472f128bdcd1be571c545" translate="yes" xml:space="preserve">
          <source>In types, an operator symbol like &lt;code&gt;(+)&lt;/code&gt; is normally treated as a type &lt;em&gt;variable&lt;/em&gt;, just like &lt;code&gt;a&lt;/code&gt;. Thus in Haskell 98 you can say</source>
          <target state="translated">В типах символ оператора, например &lt;code&gt;(+)&lt;/code&gt; , обычно рассматривается как &lt;em&gt;переменная&lt;/em&gt; типа , как &lt;code&gt;a&lt;/code&gt; . Таким образом, в Haskell 98 вы можете сказать</target>
        </trans-unit>
        <trans-unit id="65afe3f89d89dfa50d619b7bc79e59801641ec08" translate="yes" xml:space="preserve">
          <source>In typical use cases it can be imported alongside &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;, e.g.</source>
          <target state="translated">В типичных случаях его можно импортировать вместе с &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt; , например</target>
        </trans-unit>
        <trans-unit id="d1e5195c56fb5f6cf6fae4475985c40c8b88fe88" translate="yes" xml:space="preserve">
          <source>In your program, you import a module &lt;code&gt;Foo&lt;/code&gt; by saying &lt;code&gt;import Foo&lt;/code&gt;. In &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode or GHCi, GHC will look for a source file for &lt;code&gt;Foo&lt;/code&gt; and arrange to compile it first. Without &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt;, GHC will look for the interface file for &lt;code&gt;Foo&lt;/code&gt;, which should have been created by an earlier compilation of &lt;code&gt;Foo&lt;/code&gt;. GHC uses the same strategy in each of these cases for finding the appropriate file.</source>
          <target state="translated">В своей программе вы импортируете модуль &lt;code&gt;Foo&lt;/code&gt; , говоря &lt;code&gt;import Foo&lt;/code&gt; . В режиме &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; или GHCi GHC будет искать исходный файл для &lt;code&gt;Foo&lt;/code&gt; и сначала скомпилировать его. Без &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; GHC будет искать файл интерфейса для &lt;code&gt;Foo&lt;/code&gt; , который должен был быть создан при более ранней компиляции &lt;code&gt;Foo&lt;/code&gt; . GHC использует одну и ту же стратегию в каждом из этих случаев для поиска подходящего файла.</target>
        </trans-unit>
        <trans-unit id="e6fb0b72e73092b08131513da6dffeda9e5d2c1b" translate="yes" xml:space="preserve">
          <source>In-situ lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version uses the current output history on entering the continuation. It does not satisfy the uniformity property (see &lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signatures&lt;/a&gt;).</source>
          <target state="translated">В месте лифтинг &lt;code&gt;callCC&lt;/code&gt; операции к новой монаде. Эта версия использует текущую историю вывода при входе в продолжение. Он не удовлетворяет свойству однородности (см. &lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signatures&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ed82252f8ef32e515385822c367b97c16dae701f" translate="yes" xml:space="preserve">
          <source>In-situ lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version uses the current state on entering the continuation.</source>
          <target state="translated">В месте лифтинг &lt;code&gt;callCC&lt;/code&gt; операции к новой монаде. Эта версия использует текущее состояние при входе в продолжение.</target>
        </trans-unit>
        <trans-unit id="6a76bfe845d96c79100211ad66d5be912f9bcb9e" translate="yes" xml:space="preserve">
          <source>In-situ lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version uses the current state on entering the continuation. It does not satisfy the uniformity property (see &lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signatures&lt;/a&gt;).</source>
          <target state="translated">В месте лифтинг &lt;code&gt;callCC&lt;/code&gt; операции к новой монаде. Эта версия использует текущее состояние при входе в продолжение. Он не удовлетворяет свойству однородности (см. &lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signatures&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0bc346f91d9ddc5a0ccbe414514a097c0e2ae594" translate="yes" xml:space="preserve">
          <source>InappropriateType</source>
          <target state="translated">InappropriateType</target>
        </trans-unit>
        <trans-unit id="491a2c5d60825a9925b3d9a2ec49e95b47e7f9c8" translate="yes" xml:space="preserve">
          <source>Incidentally, the previous point, that &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; is incompatible with GHCi, is because the bytecode compiler can&amp;rsquo;t deal with unboxed tuples or sums.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5a86ec622c5d2ce4a51514213ff5193a71f6e8" translate="yes" xml:space="preserve">
          <source>Incidentally, the previous point, that &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; is incompatible with GHCi, is because the bytecode compiler can&amp;rsquo;t deal with unboxed tuples.</source>
          <target state="translated">Кстати, предыдущий момент, что &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; несовместим с GHCi, связан с тем, что компилятор байт-кода не может работать с распакованными кортежами.</target>
        </trans-unit>
        <trans-unit id="04035088cec19a7e2a3af045cabd4c24b2d47171" translate="yes" xml:space="preserve">
          <source>Include preprocessor dependencies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7ecb7c530843411667d62a790e5a78d07bb31e" translate="yes" xml:space="preserve">
          <source>Include the memory occupied by threads in a heap profile. Each thread takes up a small area for its thread state in addition to the space allocated for its stack (stacks normally start small and then grow as necessary).</source>
          <target state="translated">Включить в профиль кучи память,занятую потоками.Каждый поток занимает небольшую площадь для своего состояния в дополнение к площади,отведенной для его стека (стеки обычно начинают с малого и затем растут по мере необходимости).</target>
        </trans-unit>
        <trans-unit id="bf6b5e91451bcaf207fe546e25dfb945b2ef9008" translate="yes" xml:space="preserve">
          <source>Incoherent</source>
          <target state="translated">Incoherent</target>
        </trans-unit>
        <trans-unit id="b38b4aae2bf24bfd05e072f52c00b63da2993ab0" translate="yes" xml:space="preserve">
          <source>IncoherentInstances</source>
          <target state="translated">IncoherentInstances</target>
        </trans-unit>
        <trans-unit id="c456a08558be1da87f0db1872fa8594cdebf4bc0" translate="yes" xml:space="preserve">
          <source>Incompatibilities between closed type family equations can be displayed in &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; when &lt;a href=&quot;using#ghc-flag--fprint-axiom-incomps&quot;&gt;&lt;code&gt;-fprint-axiom-incomps&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835b6be9a8a369d9816b32613c73aac90a0d27dc" translate="yes" xml:space="preserve">
          <source>Increases the precedence context by one.</source>
          <target state="translated">Увеличивает прецедентный контекст на один.</target>
        </trans-unit>
        <trans-unit id="9fce6bc4b7e5c5a1ab1bd960ce68b81905da42d1" translate="yes" xml:space="preserve">
          <source>Increasing the allocation area size may or may not give better performance (a bigger allocation area means worse cache behaviour but fewer garbage collections and less promotion).</source>
          <target state="translated">Увеличение размера области распределения может дать или не дать лучшую производительность (большая область распределения означает худшее поведение кэша,но меньше мусора и меньше рекламы).</target>
        </trans-unit>
        <trans-unit id="90bbbaecf2c42b5555ebc1a33319be6fd0d0626c" translate="yes" xml:space="preserve">
          <source>Increasing this figure is more likely to result in longer compile times than faster code. The &lt;a href=&quot;#ghc-flag--funfolding-use-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-funfolding-use-threshold=⟨n⟩&lt;/code&gt;&lt;/a&gt; is more useful.</source>
          <target state="translated">Увеличение этого числа с большей вероятностью приведет к увеличению времени компиляции, чем более быстрый код. &lt;a href=&quot;#ghc-flag--funfolding-use-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-funfolding-use-threshold=⟨n⟩&lt;/code&gt; &lt;/a&gt; является более полезным.</target>
        </trans-unit>
        <trans-unit id="4f85c1ee822e61bcfb4fe66d19d113d5f463b45b" translate="yes" xml:space="preserve">
          <source>Incremental array updates</source>
          <target state="translated">Инкрементные обновления массивов</target>
        </trans-unit>
        <trans-unit id="df1b72108d080551ba84e7f0b92fa55056537617" translate="yes" xml:space="preserve">
          <source>Increments the column number of a source position.</source>
          <target state="translated">Увеличивает номер столбца исходного положения.</target>
        </trans-unit>
        <trans-unit id="e41e0acce642a9a1ccc70291606c4bb9e436f67f" translate="yes" xml:space="preserve">
          <source>Increments the line number of a source position.</source>
          <target state="translated">Увеличивает номер строки исходного положения.</target>
        </trans-unit>
        <trans-unit id="3b6b076780f1d62948deeee6a296d893d53b3592" translate="yes" xml:space="preserve">
          <source>Indeed, the bindings can even be recursive.</source>
          <target state="translated">Действительно,крепления могут быть даже рекурсивными.</target>
        </trans-unit>
        <trans-unit id="96dc8cbd171c88cf2266f42fcde1d0fd90902e1c" translate="yes" xml:space="preserve">
          <source>Indeed, we can even set breakpoints,</source>
          <target state="translated">Действительно,мы даже можем установить точки останова,</target>
        </trans-unit>
        <trans-unit id="ec8be4828bc680f1764ecad7e8b3a8f6a6c5c173" translate="yes" xml:space="preserve">
          <source>Indexed</source>
          <target state="translated">Indexed</target>
        </trans-unit>
        <trans-unit id="06793fabc8f42b418a1cb6b931583c1a10698618" translate="yes" xml:space="preserve">
          <source>Indexed data families are introduced by a signature, such as</source>
          <target state="translated">Семейства индексированных данных вводятся с помощью подписи,например</target>
        </trans-unit>
        <trans-unit id="35f58c1b9b260f98cfc78bcd3803628ca7e2f859" translate="yes" xml:space="preserve">
          <source>Indexed type families come in three flavours: data families, open type synonym families, and closed type synonym families. They are the indexed family variants of algebraic data types and type synonyms, respectively. The instances of data families can be data types and newtypes.</source>
          <target state="translated">Семейства индексированных типов имеют три вкуса:семейства данных,семейства синонимов открытого типа и семейства синонимов закрытого типа.Они являются индексированными вариантами семейств алгебраических типов данных и синонимов типов соответственно.Примерами семейств данных могут быть типы данных и новинки.</target>
        </trans-unit>
        <trans-unit id="d12b44f71b7203449d4ead8607709958c3027d75" translate="yes" xml:space="preserve">
          <source>Indexed type families form an extension to facilitate type-level programming. Type families are a generalisation of associated data types &lt;a href=&quot;#assocdatatypes2005&quot; id=&quot;id38&quot;&gt;[AssocDataTypes2005]&lt;/a&gt; and associated type synonyms &lt;a href=&quot;#assoctypesyn2005&quot; id=&quot;id39&quot;&gt;[AssocTypeSyn2005]&lt;/a&gt; Type families themselves are described in Schrijvers 2008 &lt;a href=&quot;#typefamilies2008&quot; id=&quot;id40&quot;&gt;[TypeFamilies2008]&lt;/a&gt;. Type families essentially provide type-indexed data types and named functions on types, which are useful for generic programming and highly parameterised library interfaces as well as interfaces with enhanced static information, much like dependent types. They might also be regarded as an alternative to functional dependencies, but provide a more functional style of type-level programming than the relational style of functional dependencies.</source>
          <target state="translated">Семейства индексированных типов образуют расширение для облегчения программирования на уровне типов. &lt;a href=&quot;#assocdatatypes2005&quot; id=&quot;id38&quot;&gt;Семейства&lt;/a&gt; типов являются обобщением связанных типов данных [AssocDataTypes2005] и связанных синонимов типов &lt;a href=&quot;#assoctypesyn2005&quot; id=&quot;id39&quot;&gt;[AssocTypeSyn2005]&lt;/a&gt; Сами семейства типов описаны в Schrijvers 2008 &lt;a href=&quot;#typefamilies2008&quot; id=&quot;id40&quot;&gt;[TypeFamilies2008]&lt;/a&gt; . Семейства типов по существу предоставляют типы данных с индексированными типами и именованные функции для типов, которые полезны для универсального программирования и интерфейсов библиотек с высокой степенью параметризации, а также интерфейсов с расширенной статической информацией, как и зависимые типы. Их также можно рассматривать как альтернативу функциональным зависимостям, но они обеспечивают более функциональный стиль программирования на уровне типов, чем реляционный стиль функциональных зависимостей.</target>
        </trans-unit>
        <trans-unit id="c623b2752a83108ab46f6eab2be4ef5e8f114c82" translate="yes" xml:space="preserve">
          <source>Indexed type families form an extension to facilitate type-level programming. Type families are a generalisation of associated data types &lt;a href=&quot;#assocdatatypes2005&quot; id=&quot;id39&quot;&gt;[AssocDataTypes2005]&lt;/a&gt; and associated type synonyms &lt;a href=&quot;#assoctypesyn2005&quot; id=&quot;id40&quot;&gt;[AssocTypeSyn2005]&lt;/a&gt; Type families themselves are described in Schrijvers 2008 &lt;a href=&quot;#typefamilies2008&quot; id=&quot;id41&quot;&gt;[TypeFamilies2008]&lt;/a&gt;. Type families essentially provide type-indexed data types and named functions on types, which are useful for generic programming and highly parameterised library interfaces as well as interfaces with enhanced static information, much like dependent types. They might also be regarded as an alternative to functional dependencies, but provide a more functional style of type-level programming than the relational style of functional dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7316d5d3f19bb830a24f91422d22cdab9dd77e21" translate="yes" xml:space="preserve">
          <source>Indexed type families, or type families for short, are type constructors that represent sets of types. Set members are denoted by supplying the type family constructor with type parameters, which are called type indices. The difference between vanilla parametrised type constructors and family constructors is much like between parametrically polymorphic functions and (ad-hoc polymorphic) methods of type classes. Parametric polymorphic functions behave the same at all type instances, whereas class methods can change their behaviour in dependence on the class type parameters. Similarly, vanilla type constructors imply the same data representation for all type instances, but family constructors can have varying representation types for varying type indices.</source>
          <target state="translated">Индексированные семейства типов,или семейства типов для краткости,являются конструкторами типов,которые представляют собой наборы типов.Члены множества обозначаются путем предоставления конструктору семейства типов параметров типов,которые называются индексами типов.Разница между ванильными параметризованными конструкторами типов и конструкторами семейства во многом похожа на разницу между параметрически полиморфными функциями и (ad-hoc полиморфными)методами классов типов.Параметрические полиморфные функции ведут себя одинаково на всех экземплярах типов,в то время как методы классов могут изменять свое поведение в зависимости от параметров типа класса.Аналогично,конструкторы ванильных типов подразумевают одинаковое представление данных для всех экземпляров типов,однако конструкторы семейства могут иметь различные типы представления для различных индексов типов.</target>
        </trans-unit>
        <trans-unit id="b949d0cdd6e23a0ad23263d4ec380e2896eb8d8b" translate="yes" xml:space="preserve">
          <source>IndexedQueue</source>
          <target state="translated">IndexedQueue</target>
        </trans-unit>
        <trans-unit id="8fa14decb45552b922c2f1e05a96dc53620208d3" translate="yes" xml:space="preserve">
          <source>IndexedTaggedQueue</source>
          <target state="translated">IndexedTaggedQueue</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="e8487b7ebf53e6a4c89fb11a42e40edb17475681" translate="yes" xml:space="preserve">
          <source>Indexing ByteStrings</source>
          <target state="translated">БайтСтринг индексирования</target>
        </trans-unit>
        <trans-unit id="a877b32121d14e603604359d2ca06dd6d1231f86" translate="yes" xml:space="preserve">
          <source>Indexing lists</source>
          <target state="translated">Списки индексирования</target>
        </trans-unit>
        <trans-unit id="10dea83b6d35fb66236376830ee8aaca1d2aa47d" translate="yes" xml:space="preserve">
          <source>Indexing streams</source>
          <target state="translated">Потоки индексирования</target>
        </trans-unit>
        <trans-unit id="9d4cf9835a874b031aa2556ce944d3dfd7d3212c" translate="yes" xml:space="preserve">
          <source>Indexing with predicates</source>
          <target state="translated">Индексирование с предикатами</target>
        </trans-unit>
        <trans-unit id="7bb8fb7fdc165fa4b18dff47b53df0d3155ddd63" translate="yes" xml:space="preserve">
          <source>Indicates a mode in which a file should be locked.</source>
          <target state="translated">Указывает режим,в котором файл должен быть заблокирован.</target>
        </trans-unit>
        <trans-unit id="3355b10b90f7375e78f86318065481808ee2eee6" translate="yes" xml:space="preserve">
          <source>Indicates an &quot;alternate format&quot;. See &lt;code&gt;printf(3)&lt;/code&gt; for the details, which vary by argument spec.</source>
          <target state="translated">Указывает на &amp;laquo;альтернативный формат&amp;raquo;. Подробности смотрите в &lt;code&gt;printf(3)&lt;/code&gt; , которые зависят от аргумента.</target>
        </trans-unit>
        <trans-unit id="ee701376e3689ff56e8540e626710f8190183f54" translate="yes" xml:space="preserve">
          <source>Indicates that this RunTH is finished, and the next message will be the result of RunTH (a QResult).</source>
          <target state="translated">Указывает на то,что данный RunTH завершен,и следующее сообщение будет результатом RunTH (QResult).</target>
        </trans-unit>
        <trans-unit id="ffebd8440073e88e499e1336894f2e16eae1751e" translate="yes" xml:space="preserve">
          <source>Indirections include the two special directories &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt;, as well as any symbolic links (and junction points on Windows). The input path need not point to an existing file or directory. Canonicalization is performed on the longest prefix of the path that points to an existing file or directory. The remaining portion of the path that does not point to an existing file or directory will still be normalized, but case canonicalization and indirection removal are skipped as they are impossible to do on a nonexistent path.</source>
          <target state="translated">Косвенные ссылки включают два специальных каталога &lt;code&gt;.&lt;/code&gt; и &lt;code&gt;..&lt;/code&gt; , а также любые символические ссылки (и точки соединения в Windows). Путь ввода не обязательно должен указывать на существующий файл или каталог. Канонизация выполняется для самого длинного префикса пути, указывающего на существующий файл или каталог. Оставшаяся часть пути, которая не указывает на существующий файл или каталог, все равно будет нормализована, но канонизация регистра и косвенное удаление пропускаются, поскольку это невозможно сделать на несуществующем пути.</target>
        </trans-unit>
        <trans-unit id="66db8a5a7f44af7446c06e6455194d161c7318dd" translate="yes" xml:space="preserve">
          <source>Individual fields of constructors: &lt;code&gt;K1&lt;/code&gt;</source>
          <target state="translated">Индивидуальные поля конструкторов: &lt;code&gt;K1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="004823746d749da477fecffe53c215cee2dcb8f7" translate="yes" xml:space="preserve">
          <source>Infer less polymorphic types for local bindings by default.</source>
          <target state="translated">По умолчанию,для локальных переплетов можно использовать менее полиморфные типы.</target>
        </trans-unit>
        <trans-unit id="a49aa56d23bf8a67723b80736f57bcc1ae0f7ed4" translate="yes" xml:space="preserve">
          <source>InferR</source>
          <target state="translated">InferR</target>
        </trans-unit>
        <trans-unit id="b62fa7fe203f750a1b3935b720b00e4d542210bf" translate="yes" xml:space="preserve">
          <source>Inferring equality from other types</source>
          <target state="translated">При условии равенства с другими типами</target>
        </trans-unit>
        <trans-unit id="3744a97e602ea3666eb2a1e01050a64e4445a1a1" translate="yes" xml:space="preserve">
          <source>Infers and prints the kind of ⟨type⟩. The latter can be an arbitrary type expression, including a partial application of a type constructor, such as &lt;code&gt;Either Int&lt;/code&gt;. In fact, &lt;a href=&quot;#ghci-cmd-:kind&quot;&gt;&lt;code&gt;:kind&lt;/code&gt;&lt;/a&gt; even allows you to write a partial application of a type synonym (usually disallowed), so that this works:</source>
          <target state="translated">Выводит и печатает вид &amp;laquo;типа&amp;raquo;. Последний может быть выражением произвольного типа, включая частичное применение конструктора типа, например &lt;code&gt;Either Int&lt;/code&gt; . Фактически &lt;a href=&quot;#ghci-cmd-:kind&quot;&gt; &lt;code&gt;:kind&lt;/code&gt; &lt;/a&gt; даже позволяет вам написать частичное применение синонима типа (обычно запрещенного), так что это работает:</target>
        </trans-unit>
        <trans-unit id="3177c8b6010228311525b74fd82e8bb7622e8e6c" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, but without fiddling with type variables or class constraints. This is useful when you are using &lt;a href=&quot;glasgow_exts#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; and care about the distinction between specified type variables (available for type application) and inferred type variables (not available). This mode sometimes prints constraints (such as &lt;code&gt;Show Int&lt;/code&gt;) that could readily be solved, but solving these constraints may affect the type variables, so GHC refrains.</source>
          <target state="translated">Выводит и печатает тип &amp;laquo;выражения&amp;raquo;, но без возни с переменными типа или ограничениями класса. Это полезно, когда вы используете &lt;a href=&quot;glasgow_exts#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt; и заботитесь о различии между переменными указанного типа (доступными для приложения типа) и переменными предполагаемого типа (недоступными). Этот режим иногда печатает ограничения (например, &lt;code&gt;Show Int&lt;/code&gt; ), которые можно легко решить, но решение этих ограничений может повлиять на переменные типа, поэтому GHC воздерживается.</target>
        </trans-unit>
        <trans-unit id="8a06b410b4c6d06c8f15b06ce8d7dbe7ce974ec5" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, defaulting type variables if possible. In this mode, if the inferred type is constrained by any interactive class (&lt;code&gt;Num&lt;/code&gt;, &lt;code&gt;Show&lt;/code&gt;, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Foldable&lt;/code&gt;, or &lt;code&gt;Traversable&lt;/code&gt;), the constrained type variable(s) are defaulted according to the rules described under &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt;&lt;code&gt;ExtendedDefaultRules&lt;/code&gt;&lt;/a&gt;. This mode is quite useful when the inferred type is quite general (such as for &lt;code&gt;foldr&lt;/code&gt;) and it may be helpful to see a more concrete instantiation.</source>
          <target state="translated">Выводит и печатает тип &amp;laquo;выражения&amp;raquo;, если возможно, переменные типа по умолчанию. В этом режиме, если предполагаемый тип ограничен каким-либо интерактивным классом ( &lt;code&gt;Num&lt;/code&gt; , &lt;code&gt;Show&lt;/code&gt; , &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Foldable&lt;/code&gt; или &lt;code&gt;Traversable&lt;/code&gt; ), переменные ограниченного типа устанавливаются по умолчанию в соответствии с правилами, описанными в &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt; &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; &lt;/a&gt; . Этот режим очень полезен, когда предполагаемый тип является довольно общим (например, для &lt;code&gt;foldr&lt;/code&gt; ), и может быть полезно увидеть более конкретный экземпляр.</target>
        </trans-unit>
        <trans-unit id="9b49ea1e8603da8d3ed4f7b29043ab1b859d18a2" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, including explicit forall quantifiers for polymorphic types. The type reported is the type that would be inferred for a variable assigned to the expression, but without the monomorphism restriction applied.</source>
          <target state="translated">Информирует и печатает тип ⟨expression⟩,в том числе и явные forall квантификаторы для полиморфных типов.Сообщаемый тип является типом,который будет выведен для переменной,приписываемой выражению,но без ограничения мономорфизма.</target>
        </trans-unit>
        <trans-unit id="89ab60251bc6707c53f48175ddc8665e44956e1a" translate="yes" xml:space="preserve">
          <source>Infinite ByteStrings</source>
          <target state="translated">Бесконечные байтСтринги</target>
        </trans-unit>
        <trans-unit id="f1a0caa9cda260897b3d3a8a3366456b3f12604b" translate="yes" xml:space="preserve">
          <source>Infinite lists</source>
          <target state="translated">Бесконечные списки</target>
        </trans-unit>
        <trans-unit id="fe77bd8489f76d5d9e8b67c97bcc2fb77aac9380" translate="yes" xml:space="preserve">
          <source>Infix</source>
          <target state="translated">Infix</target>
        </trans-unit>
        <trans-unit id="dc17702bd4456d8936d032b3557ed49fb5376c40" translate="yes" xml:space="preserve">
          <source>InfixL</source>
          <target state="translated">InfixL</target>
        </trans-unit>
        <trans-unit id="20413b58a0ca7cb9b7575983b614a1c19ab4ff77" translate="yes" xml:space="preserve">
          <source>InfixN</source>
          <target state="translated">InfixN</target>
        </trans-unit>
        <trans-unit id="028e6ce7a43f27e4616aed257c32e084ad147516" translate="yes" xml:space="preserve">
          <source>InfixR</source>
          <target state="translated">InfixR</target>
        </trans-unit>
        <trans-unit id="4b631f69842530d659306c8f06dbad594a6b1807" translate="yes" xml:space="preserve">
          <source>Info</source>
          <target state="translated">Info</target>
        </trans-unit>
        <trans-unit id="83ca07e3694e10dbb5ccf3a65b2e15a2aa71adaa" translate="yes" xml:space="preserve">
          <source>InfoQ</source>
          <target state="translated">InfoQ</target>
        </trans-unit>
        <trans-unit id="ce6a0a5b544415ee768925ccfd3225f374bbf9b6" translate="yes" xml:space="preserve">
          <source>Informally the &lt;code&gt;Strict&lt;/code&gt; language extension switches functions, data types, and bindings to be strict by default, allowing optional laziness by adding &lt;code&gt;~&lt;/code&gt; in front of a variable. This essentially reverses the present situation where laziness is default and strictness can be optionally had by adding &lt;code&gt;!&lt;/code&gt; in front of a variable.</source>
          <target state="translated">Неформально расширение языка &lt;code&gt;Strict&lt;/code&gt; переключает функции, типы данных и привязки на строгие по умолчанию, допуская необязательную лень, добавляя &lt;code&gt;~&lt;/code&gt; перед переменной. Это существенно меняет нынешнюю ситуацию, когда по умолчанию используется лень, а строгость можно опционально добавить, добавив &lt;code&gt;!&lt;/code&gt; перед переменной.</target>
        </trans-unit>
        <trans-unit id="b7a8fe8965d2d84c47cc81ac096afe56b49210c8" translate="yes" xml:space="preserve">
          <source>Informally the &lt;code&gt;StrictData&lt;/code&gt; language extension switches data type declarations to be strict by default allowing fields to be lazy by adding a &lt;code&gt;~&lt;/code&gt; in front of the field.</source>
          <target state="translated">Неформально &lt;code&gt;StrictData&lt;/code&gt; языка StrictData по умолчанию переключает объявления типов данных на строгие, позволяя использовать ленивые поля, добавляя &lt;code&gt;~&lt;/code&gt; перед полем.</target>
        </trans-unit>
        <trans-unit id="c1d79469162855a43f3eaf9e3321d8cf50684dcb" translate="yes" xml:space="preserve">
          <source>Informally, if we have a closed expression</source>
          <target state="translated">Неформально,если у нас есть закрытое выражение.</target>
        </trans-unit>
        <trans-unit id="bc65f2d3fbd1ee9f583dec831481e53abb70fa26" translate="yes" xml:space="preserve">
          <source>Information Preservation</source>
          <target state="translated">Сохранение информации</target>
        </trans-unit>
        <trans-unit id="ccf896e081192f981240670d0e7869acc682d16d" translate="yes" xml:space="preserve">
          <source>Information about a received signal (derived from &lt;code&gt;siginfo_t&lt;/code&gt;).</source>
          <target state="translated">Информация о полученном сигнале (полученная из &lt;code&gt;siginfo_t&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e730d579902dace90d61c30931b7c39b9b5c188a" translate="yes" xml:space="preserve">
          <source>Information about the characteristics of the host system lucky enough to run your program.</source>
          <target state="translated">Информация о характеристиках хост-системы,которой посчастливилось запустить вашу программу.</target>
        </trans-unit>
        <trans-unit id="97818649517ae55c8ef983801726362db33a72b7" translate="yes" xml:space="preserve">
          <source>Information about your computer.</source>
          <target state="translated">Информация о вашем компьютере.</target>
        </trans-unit>
        <trans-unit id="7590d8f956e48cf87c1411168c5822d362a8880b" translate="yes" xml:space="preserve">
          <source>Information specific to a particular type of signal (derived from &lt;code&gt;siginfo_t&lt;/code&gt;).</source>
          <target state="translated">Информация, &lt;code&gt;siginfo_t&lt;/code&gt; к определенному типу сигнала (полученная из siginfo_t ).</target>
        </trans-unit>
        <trans-unit id="18f99833bb423f35b13b6374e87a08306b82f669" translate="yes" xml:space="preserve">
          <source>Inherit</source>
          <target state="translated">Inherit</target>
        </trans-unit>
        <trans-unit id="10a7ab6418304c704b776a62f13dc7b3f3d8190a" translate="yes" xml:space="preserve">
          <source>Inherit Handle from parent</source>
          <target state="translated">Наследственная ручка от родителя</target>
        </trans-unit>
        <trans-unit id="131da1e4b635c2e4aa073e59724b377201ce6033" translate="yes" xml:space="preserve">
          <source>InitialQuote</source>
          <target state="translated">InitialQuote</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="468840c91f4e11363baba6fad080b835e2d90e74" translate="yes" xml:space="preserve">
          <source>Initialize a session of line-oriented user interaction.</source>
          <target state="translated">Инициализируйте сеанс линейно-ориентированного пользовательского взаимодействия.</target>
        </trans-unit>
        <trans-unit id="79a1bd4a448da27813a2c98ec5cbdca961401161" translate="yes" xml:space="preserve">
          <source>Initialize the terminfo library to the given terminal entry.</source>
          <target state="translated">Инициализируйте библиотеку терминалов к данной терминальной записи.</target>
        </trans-unit>
        <trans-unit id="f311d39fb45ca161e338979b5589e040c6185db3" translate="yes" xml:space="preserve">
          <source>Initialize the terminfo library, using the &lt;code&gt;TERM&lt;/code&gt; environmental variable. If &lt;code&gt;TERM&lt;/code&gt; is not set, we use the generic, minimal entry &lt;code&gt;dumb&lt;/code&gt;.</source>
          <target state="translated">Инициализируйте библиотеку terminfo, используя переменную окружения &lt;code&gt;TERM&lt;/code&gt; . Если &lt;code&gt;TERM&lt;/code&gt; не установлен, мы используем общий минимальный ввод &lt;code&gt;dumb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="939c8fcbb3a241e55009e926ba9e9f9f130c11fc" translate="yes" xml:space="preserve">
          <source>Initializes your &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;. This is optional.</source>
          <target state="translated">Инициализирует ваш &lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt; . Это необязательно.</target>
        </trans-unit>
        <trans-unit id="c79f3175dc50a18ee0d2393eff10c5aa2297aaaf" translate="yes" xml:space="preserve">
          <source>Inject a value into the monadic type.</source>
          <target state="translated">Введите значение в монадский тип.</target>
        </trans-unit>
        <trans-unit id="7de60f53f52e7d4a1d23489236b528a745ebb923" translate="yes" xml:space="preserve">
          <source>Injective type families are enabled with &lt;code&gt;-XTypeFamilyDependencies&lt;/code&gt; language extension. This extension implies &lt;code&gt;-XTypeFamilies&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-XTypeFamilyDependencies&lt;/code&gt; типов включены с расширением языка -XTypeFamilyDependencies . Это расширение подразумевает &lt;code&gt;-XTypeFamilies&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3800191eed005fd216c850a6af16770c6198afc5" translate="yes" xml:space="preserve">
          <source>Injectivity annotation</source>
          <target state="translated">аннотация по инъективности</target>
        </trans-unit>
        <trans-unit id="20740ccc0ccfa9620154536bb90e4481418a8cde" translate="yes" xml:space="preserve">
          <source>Injectivity annotation is added after type family head and consists of two parts:</source>
          <target state="translated">Аннотация по инъективности добавляется после головы семейства типа и состоит из двух частей:</target>
        </trans-unit>
        <trans-unit id="5ce4a424681e8e8d4af68879e4d178e19578aaeb" translate="yes" xml:space="preserve">
          <source>InjectivityAnn</source>
          <target state="translated">InjectivityAnn</target>
        </trans-unit>
        <trans-unit id="70da87d6559d7f1134da3bb10fd8c978c0bbd8a1" translate="yes" xml:space="preserve">
          <source>Inlinable</source>
          <target state="translated">Inlinable</target>
        </trans-unit>
        <trans-unit id="2e347f4ceb23a6d8637cc8028fda9ad8c7b7c47f" translate="yes" xml:space="preserve">
          <source>Inline</source>
          <target state="translated">Inline</target>
        </trans-unit>
        <trans-unit id="2cf1a81193ffc568b768198d38637e294820f553" translate="yes" xml:space="preserve">
          <source>Inline &lt;code&gt;memcpy&lt;/code&gt; calls if they would generate no more than ⟨n⟩ pseudo-instructions.</source>
          <target state="translated">Встроенные вызовы &lt;code&gt;memcpy&lt;/code&gt; , если они генерируют не более псевдо-инструкций ⟨n⟩.</target>
        </trans-unit>
        <trans-unit id="5455a4bec4fb43a62132e2ac05940c352abd92c6" translate="yes" xml:space="preserve">
          <source>Inline &lt;code&gt;memset&lt;/code&gt; calls if they would generate no more than n pseudo instructions.</source>
          <target state="translated">Встроенные вызовы &lt;code&gt;memset&lt;/code&gt; , если они генерируют не более n псевдо-инструкций.</target>
        </trans-unit>
        <trans-unit id="f455d62d020e6eddcc787a8c9c55ba1f78236d68" translate="yes" xml:space="preserve">
          <source>Input / Output</source>
          <target state="translated">Вход/выход</target>
        </trans-unit>
        <trans-unit id="d395c711b92fc61b74f8c3ff68d9004aa7cb8404" translate="yes" xml:space="preserve">
          <source>Input functions</source>
          <target state="translated">Входные функции</target>
        </trans-unit>
        <trans-unit id="5d1b609b532bb8aa117614c8340893874e0d56cc" translate="yes" xml:space="preserve">
          <source>Input string.</source>
          <target state="translated">Входная строка.</target>
        </trans-unit>
        <trans-unit id="746797b58353ee493a111e047d8432803b2bf4f0" translate="yes" xml:space="preserve">
          <source>Input text.</source>
          <target state="translated">Введите текст.</target>
        </trans-unit>
        <trans-unit id="59f2d1955d5cf0a2b8bee3b6d9a4ed1809c129a3" translate="yes" xml:space="preserve">
          <source>InputLineLimit</source>
          <target state="translated">InputLineLimit</target>
        </trans-unit>
        <trans-unit id="a1aa2989284777e5694122e01199982258b92b20" translate="yes" xml:space="preserve">
          <source>InputQueue</source>
          <target state="translated">InputQueue</target>
        </trans-unit>
        <trans-unit id="642ac7e20b3f8a8dd831942dd30d6fb267ed8a73" translate="yes" xml:space="preserve">
          <source>InputQueueLimit</source>
          <target state="translated">InputQueueLimit</target>
        </trans-unit>
        <trans-unit id="6b355e50341a905ef45c8beb3f4a624b29b98e2e" translate="yes" xml:space="preserve">
          <source>InputState</source>
          <target state="translated">InputState</target>
        </trans-unit>
        <trans-unit id="49141e9c95b68ea8d21c96c95e556fd4e3c8b9a0" translate="yes" xml:space="preserve">
          <source>InputT</source>
          <target state="translated">InputT</target>
        </trans-unit>
        <trans-unit id="e75f30b22d5bec33bb907d8901f7fb77cde5c043" translate="yes" xml:space="preserve">
          <source>InputUnderflow</source>
          <target state="translated">InputUnderflow</target>
        </trans-unit>
        <trans-unit id="d42b1cf617b7ff4fdd4f096b44e1d83b5423c29e" translate="yes" xml:space="preserve">
          <source>Insert &lt;code&gt;error&lt;/code&gt; expressions after bottoming expressions; useful when debugging the compiler.</source>
          <target state="translated">Вставьте выражения &lt;code&gt;error&lt;/code&gt; после выражений дна; полезно при отладке компилятора.</target>
        </trans-unit>
        <trans-unit id="76aa707dc17cbfd229d5de411f19e42614784006" translate="yes" xml:space="preserve">
          <source>Insert a scalar at the given position in a vector.</source>
          <target state="translated">Вставьте скаляр в заданную позицию в векторе.</target>
        </trans-unit>
        <trans-unit id="6ffaeff164e1d6773f39ae8fe9bbe6e6ef734c6a" translate="yes" xml:space="preserve">
          <source>Insertion</source>
          <target state="translated">Insertion</target>
        </trans-unit>
        <trans-unit id="0fb526c25f533482f1770bd05055cb689b6470bc" translate="yes" xml:space="preserve">
          <source>Insertion/removal</source>
          <target state="translated">Insertion/removal</target>
        </trans-unit>
        <trans-unit id="33b33d75acd9bccbdc63b02e3a1b9e48f6928c65" translate="yes" xml:space="preserve">
          <source>Inside a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; &amp;ldquo;&lt;code&gt;forall&lt;/code&gt;&amp;rdquo; is treated as a keyword, regardless of any other flag settings. Furthermore, inside a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt;, the language extension &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; is automatically enabled; see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de0c91236421ce4d302848e923cf815031f7fda" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;RULE&lt;/code&gt; &amp;ldquo;&lt;code&gt;forall&lt;/code&gt;&amp;rdquo; is treated as a keyword, regardless of any other flag settings. Furthermore, inside a RULE, the language extension &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; is automatically enabled; see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;.</source>
          <target state="translated">Внутри &lt;code&gt;RULE&lt;/code&gt; &amp;laquo; &lt;code&gt;forall&lt;/code&gt; &amp;raquo; рассматривается как ключевое слово, независимо от любых других настроек флага. Кроме того, внутри ПРАВИЛА автоматически включается языковое расширение &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt; ; см. &lt;a href=&quot;#scoped-type-variables&quot;&gt;Переменные типа с лексической областью видимости&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8052685f0cc727e7c2ebcd111bc548b4add6a4b8" translate="yes" xml:space="preserve">
          <source>Inside a splice you can only call functions defined in imported modules, not functions defined elsewhere in the same module. Note that declaration splices are not allowed anywhere except at top level (outside any other declarations).</source>
          <target state="translated">Внутри сплайса можно вызывать только функции,определенные в импортируемых модулях,а не функции,определенные в другом месте того же модуля.Обратите внимание,что декларирование сращиваний запрещено нигде,кроме как на верхнем уровне (вне любых других деклараций).</target>
        </trans-unit>
        <trans-unit id="545835b49fc011bc077a5db3657fd4e34d03642a" translate="yes" xml:space="preserve">
          <source>Inspecting</source>
          <target state="translated">Inspecting</target>
        </trans-unit>
        <trans-unit id="2409022af23815ff0491ac232cbdc6c5b9d6cd9e" translate="yes" xml:space="preserve">
          <source>Inspired by the paper &lt;em&gt;Functional Programming with Overloading and Higher-Order Polymorphism&lt;/em&gt;, Mark P Jones (&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt;) Advanced School of Functional Programming, 1995.</source>
          <target state="translated">Вдохновленный статьей &amp;laquo; &lt;em&gt;Функциональное программирование с перегрузкой и полиморфизмом высшего порядка&amp;raquo;&lt;/em&gt; , Марк П. Джонс ( &lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt; ) &lt;em&gt;Высшая&lt;/em&gt; школа функционального программирования, 1995 г.</target>
        </trans-unit>
        <trans-unit id="70c309e18c61bc57ee637952f14b1c7107d7947a" translate="yes" xml:space="preserve">
          <source>Inspired by the paper &lt;em&gt;Functional Programming with Overloading and Higher-Order Polymorphism&lt;/em&gt;, Mark P Jones (&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&quot;&gt;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&lt;/a&gt;) Advanced School of Functional Programming, 1995.</source>
          <target state="translated">Вдохновленный статьей &amp;laquo; &lt;em&gt;Функциональное программирование с перегрузкой и полиморфизмом высшего порядка&amp;raquo;&lt;/em&gt; , Марк П. Джонс ( &lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&quot;&gt;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&lt;/a&gt; ) Advanced School of Functional Programming, 1995.</target>
        </trans-unit>
        <trans-unit id="c0aacbdde24ca156566b7d32f70c5cccf57ab9e3" translate="yes" xml:space="preserve">
          <source>Install standard signal handlers for catching ^C, which just throw an exception in the target thread. The current target thread is the thread at the head of the list in the MVar passed to installSignalHandlers.</source>
          <target state="translated">Установите стандартные обработчики сигналов для перехвата ^C,которые просто бросают исключение в целевой поток.Текущим целевым потоком является поток во главе списка в MVar,переданный installSignalHandlers.</target>
        </trans-unit>
        <trans-unit id="4a69978d36d4f8c81b1e10d8995051dff3da9a47" translate="yes" xml:space="preserve">
          <source>Installer detection can be also turned off globally for the system using the security control panel, but GHC by default generates binaries that don&amp;rsquo;t depend on the user having disabled installer detection.</source>
          <target state="translated">Обнаружение установщика также можно отключить глобально для системы с помощью панели управления безопасностью, но GHC по умолчанию генерирует двоичные файлы, которые не зависят от того, отключил ли пользователь обнаружение установщика.</target>
        </trans-unit>
        <trans-unit id="7cc8d33f2d97d8e835a27045d7ac58f353fddcec" translate="yes" xml:space="preserve">
          <source>Instance declarations are only merged if their heads are exactly the same, so it is possible to get into a situation where GHC thinks that instances in a signature are overlapping, even if they are implemented in a non-overlapping way. If this is giving you problems give us a shout.</source>
          <target state="translated">Экземпляры деклараций объединяются только в том случае,если их головы точно совпадают,поэтому можно попасть в ситуацию,когда GHC считает,что экземпляры в подписи накладываются друг на друга,даже если они реализованы не накладываясь друг на друга.Если это дает вам проблемы,дайте нам крик.</target>
        </trans-unit>
        <trans-unit id="44d84e2252fdea394c95b5f2a46555b5e11e4e23" translate="yes" xml:space="preserve">
          <source>Instance declarations of data and newtype families are very similar to standard data and newtype declarations. The only two differences are that the keyword &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt; is followed by &lt;code&gt;instance&lt;/code&gt; and that some or all of the type arguments can be non-variable types, but may not contain forall types or type synonym families. However, data families are generally allowed in type parameters, and type synonyms are allowed as long as they are fully applied and expand to a type that is itself admissible - exactly as this is required for occurrences of type synonyms in class instance parameters. For example, the &lt;code&gt;Either&lt;/code&gt; instance for &lt;code&gt;GMap&lt;/code&gt; is</source>
          <target state="translated">Объявления экземпляров данных и семейств newtype очень похожи на объявления стандартных данных и newtype. Единственные два различия заключаются в том, что за ключевым словом &lt;code&gt;data&lt;/code&gt; или &lt;code&gt;newtype&lt;/code&gt; следует &lt;code&gt;instance&lt;/code&gt; и что некоторые или все аргументы типа могут быть неизменяемыми типами, но не могут содержать все типы или семейства синонимов типов. Однако семейства данных обычно разрешены в параметрах типа, а синонимы типов разрешены, если они полностью применяются и расширяются до допустимого типа - точно так же, как это требуется для вхождений синонимов типов в параметры экземпляра класса. Например, &lt;code&gt;Either&lt;/code&gt; экземпляр для &lt;code&gt;GMap&lt;/code&gt; является</target>
        </trans-unit>
        <trans-unit id="83bfa7778c9507fc8976cd01f0cb81fffebfd1e7" translate="yes" xml:space="preserve">
          <source>Instance declarations of type families are very similar to standard type synonym declarations. The only two differences are that the keyword &lt;code&gt;type&lt;/code&gt; is followed by &lt;code&gt;instance&lt;/code&gt; and that some or all of the type arguments can be non-variable types, but may not contain forall types or type synonym families. However, data families are generally allowed, and type synonyms are allowed as long as they are fully applied and expand to a type that is admissible - these are the exact same requirements as for data instances. For example, the &lt;code&gt;[e]&lt;/code&gt; instance for &lt;code&gt;Elem&lt;/code&gt; is</source>
          <target state="translated">Объявления экземпляров семейств типов очень похожи на объявления синонимов стандартных типов. Единственные два различия заключаются в том, что за &lt;code&gt;type&lt;/code&gt; ключевого слова следует &lt;code&gt;instance&lt;/code&gt; и что некоторые или все аргументы типа могут быть неизменяемыми типами, но не могут содержать все типы или семейства синонимов типов. Однако семейства данных обычно разрешены, а синонимы типов разрешены, если они полностью применяются и расширяются до допустимого типа - это те же требования, что и для экземпляров данных. Например, экземпляр &lt;code&gt;[e]&lt;/code&gt; для &lt;code&gt;Elem&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="aa54ccd8a5b1e6248e90321db5cede28dbc27c83" translate="yes" xml:space="preserve">
          <source>Instance details</source>
          <target state="translated">Конкретные детали</target>
        </trans-unit>
        <trans-unit id="7e9c3e59e4902eb11a9bc6ca6aecc9cd55844913" translate="yes" xml:space="preserve">
          <source>Instance lookup</source>
          <target state="translated">Искать в инстанциях</target>
        </trans-unit>
        <trans-unit id="4d286d9c6958cb859af4d3cc5f70112b22b5d71b" translate="yes" xml:space="preserve">
          <source>InstanceDec</source>
          <target state="translated">InstanceDec</target>
        </trans-unit>
        <trans-unit id="fd5054f4d8b7d330705d793f60720bb1539b82c2" translate="yes" xml:space="preserve">
          <source>InstanceSigs</source>
          <target state="translated">InstanceSigs</target>
        </trans-unit>
        <trans-unit id="86d67413e7f102d37a19a41e92518fd07b196a5a" translate="yes" xml:space="preserve">
          <source>Instances</source>
          <target state="translated">Instances</target>
        </trans-unit>
        <trans-unit id="87602c33058f0ebd121afb309504a6eb0e28e43e" translate="yes" xml:space="preserve">
          <source>Instances are similar to &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, e.g. given a data type</source>
          <target state="translated">Экземпляры похожи на &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , например, учитывая тип данных</target>
        </trans-unit>
        <trans-unit id="2b4574eaaa234d54582199f6b7f5240c28a0c1c8" translate="yes" xml:space="preserve">
          <source>Instances are similar to &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, e.g. given a data type</source>
          <target state="translated">Экземпляры похожи на &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , например, учитывая тип данных</target>
        </trans-unit>
        <trans-unit id="e4b471ed6e4af73beb38b8a58ed041752edf7705" translate="yes" xml:space="preserve">
          <source>Instances details</source>
          <target state="translated">Подробности</target>
        </trans-unit>
        <trans-unit id="d8a851e89f00abbc9380f8fe634c1825d148cc64" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">Экземпляры &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; должны удовлетворять следующему:</target>
        </trans-unit>
        <trans-unit id="f456cfda455d78aa8a5bb61b135052b5780b6a6d" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; should satisfy the following law: &lt;code&gt;fail s&lt;/code&gt; should be a left zero for &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">Экземпляры &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; должны удовлетворять следующему закону: &lt;code&gt;fail s&lt;/code&gt; должен быть нулевым слева для &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="af23596067e4762785ef1756f8ec64eb7e700ca3" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; should satisfy the following law: &lt;code&gt;fail s&lt;/code&gt; should be a left zero for &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">Экземпляры &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; должны удовлетворять следующему закону: &lt;code&gt;fail s&lt;/code&gt; должен быть нулевым слева для &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="d95157f0e1123c9e701efbf70b7e19778274e572" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">Экземпляры &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; должны удовлетворять следующему:</target>
        </trans-unit>
        <trans-unit id="c793ddfb9db8e74c5e0c06e1d28e546ad4cb0556" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; can be derived for any user-defined datatype whose constituent types are in &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. The declared order of the constructors in the data declaration determines the ordering in derived &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instances. The &lt;code&gt;&lt;a href=&quot;data-ord#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; datatype allows a single comparison to determine the precise ordering of two objects.</source>
          <target state="translated">Экземпляры &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; могут быть получены для любого определяемого пользователем типа данных, составляющие типы которого находятся в &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; . Объявленный порядок конструкторов в объявлении данных определяет порядок в производных экземплярах &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; . Тип данных &lt;code&gt;&lt;a href=&quot;data-ord#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; позволяет за одно сравнение определить точный порядок двух объектов.</target>
        </trans-unit>
        <trans-unit id="2b35050349db25cdc61794ff971eb58445ded210" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">Экземпляры &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; должны удовлетворять следующему:</target>
        </trans-unit>
        <trans-unit id="54c208a5a34a501f171c263767afb89fcd30fabe" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; may be derived for any enumeration type (types whose constructors have no fields). The nullary constructors are assumed to be numbered left-to-right by &lt;code&gt;&lt;a href=&quot;ghc-enum#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;n-1&lt;/code&gt;. See Chapter 10 of the &lt;em&gt;Haskell Report&lt;/em&gt; for more details.</source>
          <target state="translated">Экземпляры &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; могут быть производными для любого типа перечисления (типов, конструкторы которых не имеют полей). Предполагается, что нулевые конструкторы пронумерованы слева направо с помощью &lt;code&gt;&lt;a href=&quot;ghc-enum#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; от &lt;code&gt;0&lt;/code&gt; до &lt;code&gt;n-1&lt;/code&gt; . См. Главу 10 &lt;em&gt;отчета Haskell&lt;/em&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="993368854467462dff364596a665427fa9e766be" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; may be derived for any enumeration type (types whose constructors have no fields). The nullary constructors are assumed to be numbered left-to-right by &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;n-1&lt;/code&gt;. See Chapter 10 of the &lt;em&gt;Haskell Report&lt;/em&gt; for more details.</source>
          <target state="translated">Экземпляры &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; могут быть производными для любого типа перечисления (типов, конструкторы которых не имеют полей). Предполагается, что нулевые конструкторы пронумерованы слева направо с помощью &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; от &lt;code&gt;0&lt;/code&gt; до &lt;code&gt;n-1&lt;/code&gt; . См. Главу 10 &lt;em&gt;отчета Haskell&lt;/em&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="6abd05054200d033151c38fc2023bfb19af24a4f" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">Экземпляры &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; должны удовлетворять следующему:</target>
        </trans-unit>
        <trans-unit id="81df02f73af490aca4a8ceac4875eec434e49205" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; should satisfy the following law: &lt;code&gt;fail s&lt;/code&gt; should be a left zero for &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">Экземпляры &lt;code&gt;&lt;a href=&quot;prelude#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; должны удовлетворять следующему закону: &lt;code&gt;fail s&lt;/code&gt; должен быть нулевым слева для &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="8400c20b4cb48bf7adc682e14acc2013d85e7139" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; can be derived for any user-defined datatype whose constituent types are in &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. The declared order of the constructors in the data declaration determines the ordering in derived &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instances. The &lt;code&gt;&lt;a href=&quot;prelude#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; datatype allows a single comparison to determine the precise ordering of two objects.</source>
          <target state="translated">Экземпляры &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; могут быть получены для любого определяемого пользователем типа данных, составляющие типы которого находятся в &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; . Объявленный порядок конструкторов в объявлении данных определяет порядок в производных экземплярах &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; . Тип данных &lt;code&gt;&lt;a href=&quot;prelude#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; позволяет за одно сравнение определить точный порядок двух объектов.</target>
        </trans-unit>
        <trans-unit id="8498083049962c5ddf48a88c7ef6ff394e9c7be7" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Monoid&lt;/code&gt; should also be instances of &lt;code&gt;Semigroup&lt;/code&gt;</source>
          <target state="translated">Экземпляры &lt;code&gt;Monoid&lt;/code&gt; также должны быть экземплярами &lt;code&gt;Semigroup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b42499a12ab52b772685bdffe6cd77d34696c747" translate="yes" xml:space="preserve">
          <source>Instances of Binary should satisfy the following property:</source>
          <target state="translated">Примеры бинарного препарата должны удовлетворять следующему свойству:</target>
        </trans-unit>
        <trans-unit id="679c72c6bd3806fccb37008ccaad716ad6e46022" translate="yes" xml:space="preserve">
          <source>Instances of these classes can be derived by GHC with the &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt; extension, and are necessary to be able to define generic instances automatically.</source>
          <target state="translated">Экземпляры этих классов могут быть получены GHC с &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt; расширения DeriveGeneric и необходимы для возможности автоматического определения универсальных экземпляров.</target>
        </trans-unit>
        <trans-unit id="89fe09bb4f8ebf1e47ee60af8037d77fb33c5ffb" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the following laws, which state that &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; is a transformer of monads:</source>
          <target state="translated">Экземпляры должны удовлетворять следующим законам, которые &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; что liftIO является преобразователем монад:</target>
        </trans-unit>
        <trans-unit id="1abade2b53df1a1ba01e60f984a3a5290e836572" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the following laws:</source>
          <target state="translated">Примеры должны удовлетворять следующим законам:</target>
        </trans-unit>
        <trans-unit id="9d7bb7203c91aa0d38c7b980a4ce66dfed489cf2" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the following:</source>
          <target state="translated">Обстоятельства должны удовлетворять следующим требованиям:</target>
        </trans-unit>
        <trans-unit id="e86269f38cc2b59aa37a9312708da931d8afbda8" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the laws:</source>
          <target state="translated">Обстоятельства должны удовлетворять законам:</target>
        </trans-unit>
        <trans-unit id="b012f0abcde18071b0722ff582581b311bd03281" translate="yes" xml:space="preserve">
          <source>Instead of a single form of arrow application (arrow tail) with two translations, the implementation provides two forms &lt;code&gt;-&amp;lt;&lt;/code&gt; (first-order) and &lt;code&gt;-&amp;lt;&amp;lt;&lt;/code&gt; (higher-order).</source>
          <target state="translated">Вместо единой формы приложения стрелки (хвоста стрелки) с двумя переводами реализация предоставляет две формы &lt;code&gt;-&amp;lt;&lt;/code&gt; (первый порядок) и &lt;code&gt;-&amp;lt;&amp;lt;&lt;/code&gt; (более высокий порядок).</target>
        </trans-unit>
        <trans-unit id="886e0a6b103c70f084410d0784c49a059007efdd" translate="yes" xml:space="preserve">
          <source>Instead of creating an executable, GHC produces a shared object with this linker flag. Depending on the operating system target, this might be an ELF DSO, a Windows DLL, or a Mac OS dylib. GHC hides the operating system details beneath this uniform flag.</source>
          <target state="translated">Вместо того,чтобы создавать исполняемый файл,GHC создает разделяемый объект с этим флагом компоновщика.В зависимости от цели операционной системы это может быть ELF DSO,Windows DLL или Mac OS dylib.GHC скрывает информацию об операционной системе под этим однородным флагом.</target>
        </trans-unit>
        <trans-unit id="4bea18059726367b2d2fc3a93789ffe96f83da94" translate="yes" xml:space="preserve">
          <source>Instead of making a recursive call, we introduce a dummy parameter &lt;code&gt;rec&lt;/code&gt;; when used within &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;, this parameter then refers to &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; argument, hence the recursion is reintroduced.</source>
          <target state="translated">Вместо рекурсивного вызова мы вводим фиктивный параметр &lt;code&gt;rec&lt;/code&gt; ; при использовании в &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; этот параметр затем относится к аргументу &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; , поэтому рекурсия возвращается.</target>
        </trans-unit>
        <trans-unit id="43d6bd77abb0145c25600eed500e3ab34605d53a" translate="yes" xml:space="preserve">
          <source>Instead of making a recursive call, we introduce a dummy parameter &lt;code&gt;rec&lt;/code&gt;; when used within &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;, this parameter then refers to &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; argument, hence the recursion is reintroduced.</source>
          <target state="translated">Вместо рекурсивного вызова мы вводим фиктивный параметр &lt;code&gt;rec&lt;/code&gt; ; при использовании в &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; этот параметр затем относится к аргументу &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; , поэтому рекурсия возвращается.</target>
        </trans-unit>
        <trans-unit id="e766beefc2f70f81de8c559b30c93536dd165acf" translate="yes" xml:space="preserve">
          <source>Instead of reusing &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt;, a separate data family &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt;&lt;/code&gt; is used to mark occurrences of common unlifted types:</source>
          <target state="translated">Вместо повторного использования &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; используется отдельное семейство данных &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt;&lt;/code&gt; для маркировки вхождений распространенных неподтвержденных типов:</target>
        </trans-unit>
        <trans-unit id="28acba53025bd15fee205581c34d0d6b581a22f3" translate="yes" xml:space="preserve">
          <source>Instead, use a &lt;code&gt;case&lt;/code&gt; expression:</source>
          <target state="translated">Вместо этого используйте выражение &lt;code&gt;case&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="904bf5c0f9e80212c91a23a693a49eb67e501513" translate="yes" xml:space="preserve">
          <source>Instead, we can use the &lt;a href=&quot;#ghci-cmd-:main&quot;&gt;&lt;code&gt;:main&lt;/code&gt;&lt;/a&gt; command. This runs whatever &lt;code&gt;main&lt;/code&gt; is in scope, with any arguments being treated the same as command-line arguments, e.g.:</source>
          <target state="translated">Вместо этого мы можем использовать команду &lt;a href=&quot;#ghci-cmd-:main&quot;&gt; &lt;code&gt;:main&lt;/code&gt; &lt;/a&gt; . Это работает независимо от &lt;code&gt;main&lt;/code&gt; находится в области видимости, с любыми аргументами обращаются так же , как аргументы командной строки, например:</target>
        </trans-unit>
        <trans-unit id="ed612bf7d1e1bf9249388e996ba2c817a283fe3f" translate="yes" xml:space="preserve">
          <source>Instead, we provide a function &lt;code&gt;&lt;a href=&quot;control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt;, which would be used thus:</source>
          <target state="translated">Вместо этого мы предоставляем функцию &lt;code&gt;&lt;a href=&quot;control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt; , которая будет использоваться следующим образом:</target>
        </trans-unit>
        <trans-unit id="af0a510e3a346d26bd86b56dc0c175daeafd39a0" translate="yes" xml:space="preserve">
          <source>Instead, you should only catch exactly the exceptions that you really want. In this case, this would likely be more specific than even &quot;any IO exception&quot;; a permissions error would likely also want to be handled differently. Instead, you would probably want something like:</source>
          <target state="translated">Вместо этого,вы должны поймать только те исключения,которые вам действительно нужны.В этом случае,скорее всего,это будет более специфично,чем даже &quot;любое исключение из ввода-вывода&quot;;ошибка в разрешениях,скорее всего,также захочет быть обработана по-другому.Вместо этого вы,вероятно,захотите что-то вроде:</target>
        </trans-unit>
        <trans-unit id="ad2288edd1fb8d5afcaabf253b85250d058d0294" translate="yes" xml:space="preserve">
          <source>Instead, you would have to write &lt;code&gt;foo&lt;/code&gt; as a class operation, thus:</source>
          <target state="translated">Вместо этого вам придется написать &lt;code&gt;foo&lt;/code&gt; как операцию класса, таким образом:</target>
        </trans-unit>
        <trans-unit id="dbd230bbda194ea68580a1f846c3ea6c3d1dcbb0" translate="yes" xml:space="preserve">
          <source>Instruct &lt;a href=&quot;ghci#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; to use &lt;code&gt;Show&lt;/code&gt; instances where possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8b938452c4d4e801965219c0e20127da862913e" translate="yes" xml:space="preserve">
          <source>Instruct the linker to produce a position-independent executable.</source>
          <target state="translated">Поручите компоновщику создать позиционно-независимый исполняемый файл.</target>
        </trans-unit>
        <trans-unit id="395f6e3c69e858b418512c3a6a34e4c05014b51b" translate="yes" xml:space="preserve">
          <source>Instructs GHC to consider a value to be especially cheap to inline.</source>
          <target state="translated">Инструктирует GHC считать стоимость особенно дешевой для встраивания.</target>
        </trans-unit>
        <trans-unit id="bccb53bdffc16a668b6a787212ca241e78854706" translate="yes" xml:space="preserve">
          <source>Instructs GHC to use the platform&amp;rsquo;s native vector registers to pass vector arguments during function calls. As with all vector support, this requires &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Указывает GHC использовать собственные векторные регистры платформы для передачи векторных аргументов во время вызовов функций. Как и для любой &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt; поддержки векторов, для этого требуется -fllvm .</target>
        </trans-unit>
        <trans-unit id="8fc26ab3c56e988207cb5b87c0a8f1b8c3e39ed8" translate="yes" xml:space="preserve">
          <source>Instructs the GHC driver not to delete any of its temporary files, which it normally keeps in &lt;code&gt;/tmp&lt;/code&gt; (or possibly elsewhere; see &lt;a href=&quot;#temp-files&quot;&gt;Redirecting temporary files&lt;/a&gt;). Running GHC with &lt;code&gt;-v&lt;/code&gt; will show you what temporary files were generated along the way.</source>
          <target state="translated">Указывает драйверу GHC не удалять какие-либо временные файлы, которые он обычно хранит в &lt;code&gt;/tmp&lt;/code&gt; (или, возможно, в другом месте; см. &lt;a href=&quot;#temp-files&quot;&gt;Перенаправление временных файлов&lt;/a&gt; ). Запуск GHC с &lt;code&gt;-v&lt;/code&gt; покажет вам, какие временные файлы были созданы в процессе.</target>
        </trans-unit>
        <trans-unit id="eeeb93766512243c6a86ffca2e17fc90c9bf7fbd" translate="yes" xml:space="preserve">
          <source>Instructs the LLVM code generator to fill dead STG registers with garbage instead of &lt;code&gt;undef&lt;/code&gt; in calls. This makes it easier to catch subtle code generator and runtime system bugs (e.g. see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;#11487&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2154c477da950e933ffd834aafe87aa85025a4f4" translate="yes" xml:space="preserve">
          <source>Instructs the LLVM code generator to fill dead STG registers with garbage instead of &lt;code&gt;undef&lt;/code&gt; in calls. This makes it easier to catch subtle code generator and runtime system bugs (e.g. see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;Issue #11487&lt;/a&gt;).</source>
          <target state="translated">Указывает генератору кода LLVM заполнять мертвые регистры STG мусором вместо &lt;code&gt;undef&lt;/code&gt; в вызовах. Это упрощает выявление скрытых ошибок генератора кода и системы времени выполнения (например, см. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;Issue # 11487&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bfa150c9679995565d99e25e8bfa01f17da6a7ba" translate="yes" xml:space="preserve">
          <source>Instructs the compiler not to inline a value.</source>
          <target state="translated">Инструктирует компилятор не встраивать значение.</target>
        </trans-unit>
        <trans-unit id="675da7443910dccefb93ff214351f3b254eb9326" translate="yes" xml:space="preserve">
          <source>Instructs the compiler not to unpack a constructor field.</source>
          <target state="translated">Инструктирует компилятор не распаковывать поле конструктора.</target>
        </trans-unit>
        <trans-unit id="91e67ac1bd85402d088ab03ef989ae5c792d157d" translate="yes" xml:space="preserve">
          <source>Instructs the compiler to unpack the contents of a constructor field into the constructor itself.</source>
          <target state="translated">Инструктирует компилятор распаковать содержимое поля конструктора в сам конструктор.</target>
        </trans-unit>
        <trans-unit id="365865761dffc2759227bec5082fd7cd2a7643d4" translate="yes" xml:space="preserve">
          <source>Instructs the simplifier to emit &lt;code&gt;error&lt;/code&gt; expressions in the continuation of empty case analyses (which should bottom and consequently not return). This is helpful when debugging demand analysis bugs which can sometimes manifest as segmentation faults.</source>
          <target state="translated">Дает указание устройству упрощения выдавать выражения &lt;code&gt;error&lt;/code&gt; в продолжении анализа пустых наблюдений (которые должны завершиться и, следовательно, не возвращаться). Это полезно при отладке ошибок анализа спроса, которые иногда могут проявляться как ошибки сегментации.</target>
        </trans-unit>
        <trans-unit id="40743f84300c6c1b0918774a56963484d75164e4" translate="yes" xml:space="preserve">
          <source>Insufficient resources are available to perform the operation.</source>
          <target state="translated">Недостаточно ресурсов для выполнения операции.</target>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="b0b14c298354a19d3dea6a61e98e487fa2e51bfb" translate="yes" xml:space="preserve">
          <source>Int results</source>
          <target state="translated">В результаты</target>
        </trans-unit>
        <trans-unit id="474e49b09d35d1abae6313b6259476068b2d3bdb" translate="yes" xml:space="preserve">
          <source>Int#</source>
          <target state="translated">Int#</target>
        </trans-unit>
        <trans-unit id="7982e8c08d84551a97dde8c3cc98e03fc2d6082c" translate="yes" xml:space="preserve">
          <source>Int16</source>
          <target state="translated">Int16</target>
        </trans-unit>
        <trans-unit id="89aeb74564c1a3c6fca4d47bfe34fd7d47efe931" translate="yes" xml:space="preserve">
          <source>Int16#</source>
          <target state="translated">Int16#</target>
        </trans-unit>
        <trans-unit id="ea2b1a89854df33ae5484ba3a6d447aba6945b77" translate="yes" xml:space="preserve">
          <source>Int16ElemRep</source>
          <target state="translated">Int16ElemRep</target>
        </trans-unit>
        <trans-unit id="169183d72c87a00c62c1bb70bbe1dfca6290ac59" translate="yes" xml:space="preserve">
          <source>Int16Rep</source>
          <target state="translated">Int16Rep</target>
        </trans-unit>
        <trans-unit id="e2fdc71a811dda1a2d0bb96b4d4e22861e2e4166" translate="yes" xml:space="preserve">
          <source>Int16X16#</source>
          <target state="translated">Int16X16#</target>
        </trans-unit>
        <trans-unit id="89b499eed6d98b58571c4a678cbf7b8a491c01ed" translate="yes" xml:space="preserve">
          <source>Int16X32#</source>
          <target state="translated">Int16X32#</target>
        </trans-unit>
        <trans-unit id="126ed280a67ec0e5c6c0869188f83c20171f65d3" translate="yes" xml:space="preserve">
          <source>Int16X8#</source>
          <target state="translated">Int16X8#</target>
        </trans-unit>
        <trans-unit id="f4753a4dee54ee10a75b28c6d04eb9ea0d19acce" translate="yes" xml:space="preserve">
          <source>Int32</source>
          <target state="translated">Int32</target>
        </trans-unit>
        <trans-unit id="6f45983428b6cb7b5a6012b9615122a8dcae1e85" translate="yes" xml:space="preserve">
          <source>Int32#</source>
          <target state="translated">Int32#</target>
        </trans-unit>
        <trans-unit id="03ba764facc01a43ae3957c999e280d34c99b823" translate="yes" xml:space="preserve">
          <source>Int32ElemRep</source>
          <target state="translated">Int32ElemRep</target>
        </trans-unit>
        <trans-unit id="1dfbf78305bea63530a44158509f80087a73c868" translate="yes" xml:space="preserve">
          <source>Int32X16#</source>
          <target state="translated">Int32X16#</target>
        </trans-unit>
        <trans-unit id="6e53f2f4f4529ad29ba52b5509f536c32a89ecff" translate="yes" xml:space="preserve">
          <source>Int32X4#</source>
          <target state="translated">Int32X4#</target>
        </trans-unit>
        <trans-unit id="882e5d71bbe1adc471c1dd253deaed0ba0cf0f2c" translate="yes" xml:space="preserve">
          <source>Int32X8#</source>
          <target state="translated">Int32X8#</target>
        </trans-unit>
        <trans-unit id="180fcbe698d0f2c44101a06215c472930bbd0a01" translate="yes" xml:space="preserve">
          <source>Int64</source>
          <target state="translated">Int64</target>
        </trans-unit>
        <trans-unit id="2e9b900740b9471923d1ee1ad9a28f09fca651d7" translate="yes" xml:space="preserve">
          <source>Int64#</source>
          <target state="translated">Int64#</target>
        </trans-unit>
        <trans-unit id="280ff825353cf945ad0e0cb68c2f00e2c3be2f18" translate="yes" xml:space="preserve">
          <source>Int64ElemRep</source>
          <target state="translated">Int64ElemRep</target>
        </trans-unit>
        <trans-unit id="35a21477cc0dcffc75ded41cca3b2d1f63f3bc54" translate="yes" xml:space="preserve">
          <source>Int64Rep</source>
          <target state="translated">Int64Rep</target>
        </trans-unit>
        <trans-unit id="7dc1816fbc9a76921593b78d139c0aefaa5ed5d4" translate="yes" xml:space="preserve">
          <source>Int64X2#</source>
          <target state="translated">Int64X2#</target>
        </trans-unit>
        <trans-unit id="b5d12f27a2badb0da71c1c025c40a353791c7df3" translate="yes" xml:space="preserve">
          <source>Int64X4#</source>
          <target state="translated">Int64X4#</target>
        </trans-unit>
        <trans-unit id="0126c222589438679d7129f37eaa49a40ef647ad" translate="yes" xml:space="preserve">
          <source>Int64X8#</source>
          <target state="translated">Int64X8#</target>
        </trans-unit>
        <trans-unit id="a96d87d7c8b3dcfbd0b1d669a1f16d6b32c2a364" translate="yes" xml:space="preserve">
          <source>Int8</source>
          <target state="translated">Int8</target>
        </trans-unit>
        <trans-unit id="f23dd6eb83dd2c6d4c26d67bd205664514ef3334" translate="yes" xml:space="preserve">
          <source>Int8#</source>
          <target state="translated">Int8#</target>
        </trans-unit>
        <trans-unit id="6432a5292cbe710c394997d2e832158d7d933219" translate="yes" xml:space="preserve">
          <source>Int8ElemRep</source>
          <target state="translated">Int8ElemRep</target>
        </trans-unit>
        <trans-unit id="eeefd58bf82829401c0268ef8251bdf8b3f24966" translate="yes" xml:space="preserve">
          <source>Int8Rep</source>
          <target state="translated">Int8Rep</target>
        </trans-unit>
        <trans-unit id="bca4f782d0f853ef5278cf2783e82bd4ca0e6793" translate="yes" xml:space="preserve">
          <source>Int8X16#</source>
          <target state="translated">Int8X16#</target>
        </trans-unit>
        <trans-unit id="273d50cf360a4f6d087c88837ee0b4808a7557d2" translate="yes" xml:space="preserve">
          <source>Int8X32#</source>
          <target state="translated">Int8X32#</target>
        </trans-unit>
        <trans-unit id="5ec83732ef2a77c6bd76ba72fb9dccf0fdb8ff21" translate="yes" xml:space="preserve">
          <source>Int8X64#</source>
          <target state="translated">Int8X64#</target>
        </trans-unit>
        <trans-unit id="e09cb14a20b097264eac071df65d1afd98163fbc" translate="yes" xml:space="preserve">
          <source>IntMap</source>
          <target state="translated">IntMap</target>
        </trans-unit>
        <trans-unit id="e63b5240ec2d5f7585915f4d28ddb5efc058620c" translate="yes" xml:space="preserve">
          <source>IntPtr</source>
          <target state="translated">IntPtr</target>
        </trans-unit>
        <trans-unit id="2901d3f7a1db5d58eeaffb4b887831e2d949eb75" translate="yes" xml:space="preserve">
          <source>IntRep</source>
          <target state="translated">IntRep</target>
        </trans-unit>
        <trans-unit id="9e69d47445a71be667d23e5d0ef7d5321b56a177" translate="yes" xml:space="preserve">
          <source>IntSet</source>
          <target state="translated">IntSet</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="320552ac98d7f56a8b5c90eb071442ff5ade6253" translate="yes" xml:space="preserve">
          <source>Integer results</source>
          <target state="translated">Целочисленные результаты</target>
        </trans-unit>
        <trans-unit id="e3b59c9f1c26e320e172cac39695e68589e740a0" translate="yes" xml:space="preserve">
          <source>Integral</source>
          <target state="translated">Integral</target>
        </trans-unit>
        <trans-unit id="c4c03c5bf82bd9916b53979e703ce58d3667b527" translate="yes" xml:space="preserve">
          <source>Integral numbers, supporting integer division.</source>
          <target state="translated">Целочисленные числа,поддерживающие целочисленное деление.</target>
        </trans-unit>
        <trans-unit id="234d47467506fc9f47ee7950fcdb7bb2ae54365b" translate="yes" xml:space="preserve">
          <source>Integral types</source>
          <target state="translated">Интегральные типы</target>
        </trans-unit>
        <trans-unit id="df30aeff3c9f2ae9693e9f1c28c3699de6eac4ed" translate="yes" xml:space="preserve">
          <source>Integral types with lossless conversion to and from pointers</source>
          <target state="translated">Интегральные типы с безубыточным преобразованием в указатели и из них</target>
        </trans-unit>
        <trans-unit id="e27829052d0d9df18b05cefeb88ad5a94afbc61c" translate="yes" xml:space="preserve">
          <source>Intended for use with pinned arrays; otherwise very unsafe!</source>
          <target state="translated">Предназначен для использования со шарнирными массивами;в противном случае очень небезопасен!</target>
        </trans-unit>
        <trans-unit id="007b2ebed9a4c28b982956fb6038e4230fef94c2" translate="yes" xml:space="preserve">
          <source>Interactive mode - normally used by just running &lt;code&gt;ghci&lt;/code&gt;; see &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt; for details.</source>
          <target state="translated">Интерактивный режим - обычно используется просто при запуске &lt;code&gt;ghci&lt;/code&gt; ; подробнее см. &lt;a href=&quot;ghci#ghci&quot;&gt;Использование GHCi&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1a5c0c3d73751b79478f13c6aba7659e97bd850" translate="yes" xml:space="preserve">
          <source>Interactive mode, which is also available as &lt;strong&gt;ghci&lt;/strong&gt;. Interactive mode is described in more detail in &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt;.</source>
          <target state="translated">Интерактивный режим, который также доступен как &lt;strong&gt;ghci&lt;/strong&gt; . Интерактивный режим более подробно описан в &lt;a href=&quot;ghci#ghci&quot;&gt;разделе Использование GHCi&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="200ddf5e689f542251354b2292ff7f306c830bcd" translate="yes" xml:space="preserve">
          <source>Interactive sessions</source>
          <target state="translated">Интерактивные сессии</target>
        </trans-unit>
        <trans-unit id="9b175511971a5226d37c0acfed7f54181e087e72" translate="yes" xml:space="preserve">
          <source>Interchange</source>
          <target state="translated">Interchange</target>
        </trans-unit>
        <trans-unit id="0889e1352d0093dd2c1bd60ccefdbe1787dedf12" translate="yes" xml:space="preserve">
          <source>Intermediate C file produced by the Haskell compiler.</source>
          <target state="translated">Промежуточный C-файл,созданный компилятором Haskell.</target>
        </trans-unit>
        <trans-unit id="0e87fa48ab9403bcfb3ef1be0554d0a70b493987" translate="yes" xml:space="preserve">
          <source>Intermediate result in a processing pipeline.</source>
          <target state="translated">Промежуточный результат-перерабатывающий трубопровод.</target>
        </trans-unit>
        <trans-unit id="fc9225a1693f44637be7aea70d7fcc2c5840704d" translate="yes" xml:space="preserve">
          <source>Internal</source>
          <target state="translated">Internal</target>
        </trans-unit>
        <trans-unit id="82a32977b22d691e4bebb6181d666886678637a3" translate="yes" xml:space="preserve">
          <source>Internal encoding of argv</source>
          <target state="translated">Внутреннее кодирование аргумента</target>
        </trans-unit>
        <trans-unit id="25a43e5e4971ff9be08a18b36db8ee9809321bf3" translate="yes" xml:space="preserve">
          <source>Internal function used by the RTS to run sparks.</source>
          <target state="translated">Внутренняя функция,используемая RTS для запуска искр.</target>
        </trans-unit>
        <trans-unit id="811920182b71e4d6c39f62829f0533afa24b5bfb" translate="yes" xml:space="preserve">
          <source>Internal functions</source>
          <target state="translated">Внутренние функции</target>
        </trans-unit>
        <trans-unit id="f9ce090f6b4e6812a2a33054e170fe0befa25fea" translate="yes" xml:space="preserve">
          <source>Internal implementation</source>
          <target state="translated">Внутренняя реализация</target>
        </trans-unit>
        <trans-unit id="335c261c9e3240dffccc5e11b7feb9b035c0ffee" translate="yes" xml:space="preserve">
          <source>Internal modules are always subject to change from version to version.</source>
          <target state="translated">Внутренние модули всегда могут изменяться от версии к версии.</target>
        </trans-unit>
        <trans-unit id="4cd52ec76491f663a1c43928caec2f316b4ca018" translate="yes" xml:space="preserve">
          <source>Internal modules are always subject to change from version to version. The contents of this module are also platform-dependent, hence what is shown in the Hackage documentation may differ from what is actually available on your system.</source>
          <target state="translated">Внутренние модули всегда могут изменяться от версии к версии.Содержимое этого модуля также зависит от платформы,поэтому то,что отображается в документации Hackage,может отличаться от того,что на самом деле доступно в вашей системе.</target>
        </trans-unit>
        <trans-unit id="0fcdcb0ba8bba814068eb6100072ef47243548c0" translate="yes" xml:space="preserve">
          <source>Internal representation of ShortByteString</source>
          <target state="translated">Внутреннее представление ShortByteString</target>
        </trans-unit>
        <trans-unit id="6f8442c92f2a07632791660fdbe8ed261d183750" translate="yes" xml:space="preserve">
          <source>Internal stuff: support for ByteString FilePaths</source>
          <target state="translated">Внутренний материал:поддержка ByteString FilePaths</target>
        </trans-unit>
        <trans-unit id="c06d3b6c05aaeb5431e0abe73a9ea613ced45014" translate="yes" xml:space="preserve">
          <source>Internal to GHC is yet a third equality relation &lt;code&gt;(~#)&lt;/code&gt;. It is heterogeneous (like &lt;code&gt;~~&lt;/code&gt;) and is used only internally. It may appear in error messages and other output only when &lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">Внутри GHC есть еще третье отношение равенства &lt;code&gt;(~#)&lt;/code&gt; . Он неоднороден (как &lt;code&gt;~~&lt;/code&gt; ) и используется только для внутреннего использования. Он может появляться в сообщениях об ошибках и других выводах, только если включен &lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2bd330af85b0e5f22d5c9a7160723d4849210dfe" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are buffer-filling functions. They are executed by a &lt;em&gt;driver&lt;/em&gt; that provides them with an actual buffer to fill. Once called with a buffer, a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; fills it and returns a signal to the driver telling it that it is either done, has filled the current buffer, or wants to directly insert a reference to a chunk of memory. In the last two cases, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; also returns a continutation &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; that the driver can call to fill the next buffer. Here, we provide the two drivers that satisfy almost all use cases. See &lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra&lt;/a&gt;, for information about fine-tuning them.</source>
          <target state="translated">Внутренне &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; - это функции заполнения буфера. Они выполняются &lt;em&gt;драйвером,&lt;/em&gt; который предоставляет им фактический буфер для заполнения. После вызова с буфером &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; заполняет его и возвращает сигнал драйверу, сообщая ему, что он либо готов, либо заполнил текущий буфер, либо хочет напрямую вставить ссылку на кусок памяти. В двух последних случаях &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; также возвращает continutation &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; , что водитель может позвонить , чтобы заполнить следующий буфер. Здесь мы предоставляем два драйвера, которые удовлетворяют практически всем вариантам использования. См. &lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra&lt;/a&gt; для получения информации об их тонкой настройке.</target>
        </trans-unit>
        <trans-unit id="d88cff51e0a932119461c68d8546032600672fb6" translate="yes" xml:space="preserve">
          <source>Internally, a builder constructs a lazy &lt;code&gt;Text&lt;/code&gt; by filling arrays piece by piece. As each buffer is filled, it is 'popped' off, to become a new chunk of the resulting lazy &lt;code&gt;Text&lt;/code&gt;. All this is hidden from the user of the &lt;code&gt;Builder&lt;/code&gt;.</source>
          <target state="translated">Внутренне построитель создает ленивый &lt;code&gt;Text&lt;/code&gt; , заполняя массивы по частям. По мере заполнения каждого буфера он &amp;laquo;выталкивается&amp;raquo;, чтобы стать новым фрагментом результирующего ленивого &lt;code&gt;Text&lt;/code&gt; . Все это скрыто от пользователя &lt;code&gt;Builder&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12bba6c28355d7983d21c1e6090494085220dbb9" translate="yes" xml:space="preserve">
          <source>Internally, the &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is represented as an array of &lt;code&gt;Word16&lt;/code&gt; UTF-16 code units. The offset and length fields in the constructor are in these units, &lt;em&gt;not&lt;/em&gt; units of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Внутри &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; тип представлен как массив кодовых единиц &lt;code&gt;Word16&lt;/code&gt; UTF-16. Поля смещения и длины в конструкторе указаны в этих единицах, а &lt;em&gt;не в&lt;/em&gt; единицах &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0b999b33863c1153156a264b1868a08a53695d3" translate="yes" xml:space="preserve">
          <source>Internally, this function reads a chunk at a time from the lower-level buffering abstraction, and concatenates the chunks into a single string once the entire file has been read.</source>
          <target state="translated">Внутренне эта функция читает фрагмент за раз из низкоуровневой буферной абстракции,и объединяет фрагменты в единую строку после чтения всего файла.</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="a897c5f4e03ea395f7767d7d272cb62520bcf994" translate="yes" xml:space="preserve">
          <source>Internals of the &lt;code&gt;&lt;a href=&quot;ghc#v:ExecutionStack&quot;&gt;ExecutionStack&lt;/a&gt;&lt;/code&gt; module</source>
          <target state="translated">Внутреннее устройство модуля &lt;code&gt;&lt;a href=&quot;ghc#v:ExecutionStack&quot;&gt;ExecutionStack&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8603050a19ff41766967b86a389c3d31e6830c45" translate="yes" xml:space="preserve">
          <source>Interoperability with native code</source>
          <target state="translated">Интероперабельность с родным кодом</target>
        </trans-unit>
        <trans-unit id="c0f7a30128320b71a384a07bf1ad2a57bf643c91" translate="yes" xml:space="preserve">
          <source>Interpret &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; as 1-bit bit-field</source>
          <target state="translated">Интерпретировать &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; как 1-битовое поле</target>
        </trans-unit>
        <trans-unit id="2344763cc3af5c5ff8f14dc7427762225e47cc74" translate="yes" xml:space="preserve">
          <source>Interpret &lt;code&gt;&lt;a href=&quot;prelude#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; as 1-bit bit-field</source>
          <target state="translated">Интерпретировать &lt;code&gt;&lt;a href=&quot;prelude#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; как 1-битовое поле</target>
        </trans-unit>
        <trans-unit id="8180b611e957caccb58a76268ebb6645c0d090ca" translate="yes" xml:space="preserve">
          <source>Interpreter monad</source>
          <target state="translated">Монада переводчиков</target>
        </trans-unit>
        <trans-unit id="bc1f6afb0744a5bbe6fbb6b0551f3c09aa2d8e3d" translate="yes" xml:space="preserve">
          <source>Interpreting flags as concrete values</source>
          <target state="translated">Интерпретация флагов как конкретных значений</target>
        </trans-unit>
        <trans-unit id="b3238b1b65299f84d2a4787b06c096df0bde1630" translate="yes" xml:space="preserve">
          <source>Interpreting flags as transformations of an options record</source>
          <target state="translated">Интерпретация флагов как преобразование записи опционов</target>
        </trans-unit>
        <trans-unit id="5ca1eff01a671dfb25491109dc859fa21b0790a2" translate="yes" xml:space="preserve">
          <source>Interprocess communication</source>
          <target state="translated">Межпроцессное взаимодействие</target>
        </trans-unit>
        <trans-unit id="d5db45498426a18d87491bdc35ea0b2b61778847" translate="yes" xml:space="preserve">
          <source>Interrupt</source>
          <target state="translated">Interrupt</target>
        </trans-unit>
        <trans-unit id="fd306da47657f9f268642aa78227bfb906aca053" translate="yes" xml:space="preserve">
          <source>InterruptOnBreak</source>
          <target state="translated">InterruptOnBreak</target>
        </trans-unit>
        <trans-unit id="50be3afcff74fd9eea61c4dfdd7da275a216bfb6" translate="yes" xml:space="preserve">
          <source>Interrupted</source>
          <target state="translated">Interrupted</target>
        </trans-unit>
        <trans-unit id="36df567b3b522f136606322b1937e0e7e48c4f5c" translate="yes" xml:space="preserve">
          <source>Interruptible</source>
          <target state="translated">Interruptible</target>
        </trans-unit>
        <trans-unit id="d8390d6de28cf8b96b830c119a47584ce55061df" translate="yes" xml:space="preserve">
          <source>Interruptible operations</source>
          <target state="translated">Прерывание работы</target>
        </trans-unit>
        <trans-unit id="68c9e301e1801956050651ad57b360275600a452" translate="yes" xml:space="preserve">
          <source>InterruptibleFFI</source>
          <target state="translated">InterruptibleFFI</target>
        </trans-unit>
        <trans-unit id="d0f596ba112a353008597117b57b10b067fc620b" translate="yes" xml:space="preserve">
          <source>Intersection</source>
          <target state="translated">Intersection</target>
        </trans-unit>
        <trans-unit id="8ee8437c2a66962c8f0907ee26289d77e36aba20" translate="yes" xml:space="preserve">
          <source>Introducing and eliminating &lt;code&gt;ByteString&lt;/code&gt;s</source>
          <target state="translated">Введение и устранение &lt;code&gt;ByteString&lt;/code&gt; s</target>
        </trans-unit>
        <trans-unit id="f2ed6db5ae3728afff2fec4a361e39f9464f0d95" translate="yes" xml:space="preserve">
          <source>Introducing quantified constraints offers two main benefits:</source>
          <target state="translated">Введение количественных ограничений дает два основных преимущества:</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="e9b6edb900949eb2a114c5641991b055536e376d" translate="yes" xml:space="preserve">
          <source>Intruct LLVM to fill dead STG registers with garbage</source>
          <target state="translated">Интрукт LLVM для заполнения мусорными баками мертвых регистров STG</target>
        </trans-unit>
        <trans-unit id="f13f1e646d5fc57caced649f7e0af90a6d1873ef" translate="yes" xml:space="preserve">
          <source>Intuitively it is a bifunctor where both the first and second arguments are covariant.</source>
          <target state="translated">Интуитивно это бифунктор,где и первый,и второй аргументы являются ковариантными.</target>
        </trans-unit>
        <trans-unit id="f11b308cf805ee45457dc6ec7628b5e4afe5bda0" translate="yes" xml:space="preserve">
          <source>Intuitively, a covariant type is &lt;em&gt;produced&lt;/em&gt;, and a contravariant type is &lt;em&gt;consumed&lt;/em&gt;. Most types in Haskell are covariant, but the function type is special in that the lefthand side of a function arrow reverses variance. If a function type &lt;code&gt;a -&amp;gt; b&lt;/code&gt; appears in a covariant position (e.g., &lt;code&gt;CovFun1&lt;/code&gt; above), then &lt;code&gt;a&lt;/code&gt; is in a contravariant position and &lt;code&gt;b&lt;/code&gt; is in a covariant position. Similarly, if &lt;code&gt;a -&amp;gt; b&lt;/code&gt; appears in a contravariant position (e.g., &lt;code&gt;CovFun2&lt;/code&gt; above), then &lt;code&gt;a&lt;/code&gt; is in &lt;code&gt;a&lt;/code&gt; covariant position and &lt;code&gt;b&lt;/code&gt; is in a contravariant position.</source>
          <target state="translated">Интуитивно, ковариантный тип &lt;em&gt;производства&lt;/em&gt; , а контравариантным тип &lt;em&gt;потребляется&lt;/em&gt; . Большинство типов в Haskell ковариантны, но тип функции является особенным в том смысле, что левая сторона стрелки функции меняет дисперсию на противоположную. Если функция типа &lt;code&gt;a -&amp;gt; b&lt;/code&gt; появляется в ковариантной позиции (например, &lt;code&gt;CovFun1&lt;/code&gt; выше), тогда &lt;code&gt;a&lt;/code&gt; находится в контравариантной позиции, а &lt;code&gt;b&lt;/code&gt; находится в ковариантной позиции. Аналогичным образом , если &lt;code&gt;a -&amp;gt; b&lt;/code&gt; появляется в контравариантном положении (например, &lt;code&gt;CovFun2&lt;/code&gt; выше), то в &lt;code&gt;a&lt;/code&gt; ковариантной положении и &lt;code&gt;b&lt;/code&gt; находится в контравариантном положении. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="721bd28235527f71feda3a70976332e724e9adeb" translate="yes" xml:space="preserve">
          <source>InvalidArgument</source>
          <target state="translated">InvalidArgument</target>
        </trans-unit>
        <trans-unit id="c34e89295bf2cea238c801b77ea83ba0fd5c3764" translate="yes" xml:space="preserve">
          <source>InvalidSequence</source>
          <target state="translated">InvalidSequence</target>
        </trans-unit>
        <trans-unit id="6e547a33d95e99ec46c6344b0c23479734bb0e2a" translate="yes" xml:space="preserve">
          <source>Invariant: &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; are used iff value doesn't fit in &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Инвариант: &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; используются, если значение не соответствует &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf37e1cc70f0e61b9e34e40498126af8ea1a4ccd" translate="yes" xml:space="preserve">
          <source>Invariant: &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; are used iff value doesn't fit in &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Инвариант: &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; используются, если значение не соответствует &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4bfccb2baadf6166a2829f9676f95fd9d7a60ac3" translate="yes" xml:space="preserve">
          <source>Invariants that all functions must maintain:</source>
          <target state="translated">Инварианты,которые должны поддерживаться всеми функциями:</target>
        </trans-unit>
        <trans-unit id="11b6b45efb71efd3b50f12592ee43024fb8e5262" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;Tricky Nom Age&lt;/code&gt; representationally equal to &lt;code&gt;Tricky Nom Int&lt;/code&gt;? No! The former stores a &lt;code&gt;Char&lt;/code&gt; and the latter stores a &lt;code&gt;Bool&lt;/code&gt;. The solution to this is to require all parameters to type variables to have role nominal. Thus, GHC would infer role representational for &lt;code&gt;a&lt;/code&gt; but role nominal for &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Является ли &lt;code&gt;Tricky Nom Age&lt;/code&gt; репрезентативно равным &lt;code&gt;Tricky Nom Int&lt;/code&gt; ? Нет! Первый хранит &lt;code&gt;Char&lt;/code&gt; , а второй - &lt;code&gt;Bool&lt;/code&gt; . Чтобы решить эту проблему, нужно потребовать, чтобы все параметры для типа переменных имели номинальную роль. Таким образом, GHC сделает вывод о ролевой репрезентативности для &lt;code&gt;a&lt;/code&gt; , но номинальной роли для &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a766705ed66afa23d41d644b867c8c1d8246d785" translate="yes" xml:space="preserve">
          <source>Is a FilePath valid, i.e. could you create a file like it? This function checks for invalid names, and invalid characters, but does not check if length limits are exceeded, as these are typically filesystem dependent.</source>
          <target state="translated">Действителен ли FilePath,т.е.можно ли создать такой же файл? Эта функция проверяет недопустимые имена и недопустимые символы,но не проверяет,превышены ли ограничения по длине,так как они,как правило,зависят от файловой системы.</target>
        </trans-unit>
        <trans-unit id="2d4afcc43e797a70db779c9a0014ea77683183f9" translate="yes" xml:space="preserve">
          <source>Is a path relative, or is it fixed to the root?</source>
          <target state="translated">Является ли путь относительным,или он прикреплен к корню?</target>
        </trans-unit>
        <trans-unit id="43af79dad26580cb65546e44c841b83ea361dfc6" translate="yes" xml:space="preserve">
          <source>Is an element a drive</source>
          <target state="translated">Элемент привода</target>
        </trans-unit>
        <trans-unit id="ad55afc8d42967efa9b30f062839411d7d64cecd" translate="yes" xml:space="preserve">
          <source>Is an item either a directory or the last character a path separator?</source>
          <target state="translated">Является ли элемент каталога или последний символ разделителем путей?</target>
        </trans-unit>
        <trans-unit id="dea849a91828d7c22d9e225f465ea37622f0abe6" translate="yes" xml:space="preserve">
          <source>Is event tracing enabled?</source>
          <target state="translated">Включена ли функция отслеживания событий?</target>
        </trans-unit>
        <trans-unit id="4a3d4ce5bba4710d2b59407e172ef6004d960b58" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">Параметризован типом информации об ошибке и конструктором типа монады. Обычно &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; используется в качестве конструктора типа монады для монады ошибок, в которой описания ошибок принимают форму строк. В этом случае и во многих других распространенных случаях результирующая монада уже определена как экземпляр класса &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; . Вы также можете определить свой собственный тип ошибки и / или использовать конструктор типа монады, отличный от &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; . В этих случаях вам нужно будет явно определить экземпляры класса &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; . (Если вы используете устаревшие &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; или &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, вам также может потребоваться определить экземпляр &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="3d87698463b1e6a36b367f2bd25afa09087482c6" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">Параметризован типом информации об ошибке и конструктором типа монады. Обычно &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; используется в качестве конструктора типа монады для монады ошибок, в которой описания ошибок принимают форму строк. В этом случае и во многих других распространенных случаях результирующая монада уже определена как экземпляр класса &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; . Вы также можете определить свой собственный тип ошибки и / или использовать конструктор типа монады, отличный от &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; . В этих случаях вам нужно будет явно определить экземпляры класса &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; . (Если вы используете устаревшие &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; или &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, вам также может потребоваться определить экземпляр &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="3bfeac45184637e42717c5ef3d8450bbfdd4d45a" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">Параметризован типом информации об ошибке и конструктором типа монады. Обычно &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; используется в качестве конструктора типа монады для монады ошибок, в которой описания ошибок принимают форму строк. В этом случае и во многих других распространенных случаях результирующая монада уже определена как экземпляр класса &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; . Вы также можете определить свой собственный тип ошибки и / или использовать конструктор типа монады, отличный от &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; . В этих случаях вам нужно будет явно определить экземпляры класса &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; . (Если вы используете устаревшие &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; или &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, вам также может потребоваться определить экземпляр &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="371baf4cf811b522632264fa7d84bdafaf787645" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1fd83de1504db40a2c6a9fab6c7f5a6ffe0a914" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca9ee65f747219137fd7d52ad82e317c19d9c76e" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fa333bbf2afea384536b00960809179ff42dd9d" translate="yes" xml:space="preserve">
          <source>Is the character a file separator?</source>
          <target state="translated">Символ-это разделитель файлов?</target>
        </trans-unit>
        <trans-unit id="5f43305893105d5144cecca878b219714e75b65a" translate="yes" xml:space="preserve">
          <source>Is the character an extension character?</source>
          <target state="translated">Является ли персонаж дополнением к персонажу?</target>
        </trans-unit>
        <trans-unit id="badcfb21de3bbbdff6edcea7831f4297f75e8e47" translate="yes" xml:space="preserve">
          <source>Is the handle connected to a terminal?</source>
          <target state="translated">Ручка подключена к клемме?</target>
        </trans-unit>
        <trans-unit id="db53055cb5536987019e96f49887b6f3ccf9ab28" translate="yes" xml:space="preserve">
          <source>Is the list of instances returned by &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; nonempty?</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; ли список экземпляров, возвращаемых reifyInstances ?</target>
        </trans-unit>
        <trans-unit id="0276f66684c522748357fa6f520335cef096d53c" translate="yes" xml:space="preserve">
          <source>Is the list of instances returned by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; nonempty?</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; ли список экземпляров, возвращаемых reifyInstances ?</target>
        </trans-unit>
        <trans-unit id="ff726b2a6e4e23e49531e7725f31b4ca2f33315a" translate="yes" xml:space="preserve">
          <source>Is this a definition of the infix function &amp;ldquo;&lt;code&gt;(!)&lt;/code&gt;&amp;rdquo;, or of the &amp;ldquo;&lt;code&gt;f&lt;/code&gt;&amp;rdquo; with a bang pattern? GHC resolves this ambiguity in favour of the latter. If you want to define &lt;code&gt;(!)&lt;/code&gt; with bang-patterns enabled, you have to do so using prefix notation:</source>
          <target state="translated">Это определение инфиксной функции &amp;laquo; &lt;code&gt;(!)&lt;/code&gt; &amp;raquo; Или &amp;laquo; &lt;code&gt;f&lt;/code&gt; &amp;raquo; с рисунком взрыва? GHC решает эту двусмысленность в пользу последнего. Если вы хотите определить &lt;code&gt;(!)&lt;/code&gt; С включенными шаблонами взрыва, вы должны сделать это, используя префиксную нотацию:</target>
        </trans-unit>
        <trans-unit id="727d9897dcf734181d527a496f77a4e981c855b3" translate="yes" xml:space="preserve">
          <source>Is this an orphan module? Apparently not, because &lt;code&gt;T&lt;/code&gt; is declared in the same module. But suppose class &lt;code&gt;E&lt;/code&gt; had a functional dependency:</source>
          <target state="translated">Это сиротский модуль? По-видимому, нет, потому что &lt;code&gt;T&lt;/code&gt; объявлен в том же модуле. Но предположим, что у класса &lt;code&gt;E&lt;/code&gt; есть функциональная зависимость:</target>
        </trans-unit>
        <trans-unit id="015d37bd7153776002ea5dd2e0e58e04be60d1e9" translate="yes" xml:space="preserve">
          <source>Is this program linked against the GHC RTS? (always &amp;ldquo;YES&amp;rdquo;).</source>
          <target state="translated">Связана ли эта программа с GHC RTS? (всегда &amp;laquo;ДА&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="4ab93a61d74047e9e250aa0b4d353a580e7f3de6" translate="yes" xml:space="preserve">
          <source>Is this time zone just persisting for the summer?</source>
          <target state="translated">Этот часовой пояс сохраняется только на лето?</target>
        </trans-unit>
        <trans-unit id="5bdaa14aeb3a57c8d59aa15adeeaf4ca36f447a6" translate="yes" xml:space="preserve">
          <source>Is this year a leap year according to the proleptic Gregorian calendar?</source>
          <target state="translated">Является ли этот год високосным по пролептическому григорианскому календарю?</target>
        </trans-unit>
        <trans-unit id="722098dfb78f933cddee4ba4c9a0bba9c43dafcf" translate="yes" xml:space="preserve">
          <source>Is this year a leap year according to the proleptic Julian calendar?</source>
          <target state="translated">Является ли этот год високосным по пролептическому юлианскому календарю?</target>
        </trans-unit>
        <trans-unit id="ad4ea982b3c058e21b49b8f110e994dd2768d032" translate="yes" xml:space="preserve">
          <source>Is transformed to,</source>
          <target state="translated">трансформируется в</target>
        </trans-unit>
        <trans-unit id="ad0876366a1c77a7a9a0da1b2963828591f6ce29" translate="yes" xml:space="preserve">
          <source>Is used within a monadic computation to begin exception processing.</source>
          <target state="translated">Используется в рамках монадских вычислений,чтобы начать обработку исключений.</target>
        </trans-unit>
        <trans-unit id="5534ee618fbad70f11c2e1cb6e9405c6eaa359eb" translate="yes" xml:space="preserve">
          <source>IsChar</source>
          <target state="translated">IsChar</target>
        </trans-unit>
        <trans-unit id="1aa675efc7a7eeb0b92b8ba7fa53d00d3161a009" translate="yes" xml:space="preserve">
          <source>IsList</source>
          <target state="translated">IsList</target>
        </trans-unit>
        <trans-unit id="98e4309bebb71a041dd60cba19bc3de15703f3bf" translate="yes" xml:space="preserve">
          <source>IsStatic</source>
          <target state="translated">IsStatic</target>
        </trans-unit>
        <trans-unit id="d9570a11de28b7264d6886af3296a0aa64b763e0" translate="yes" xml:space="preserve">
          <source>IsString</source>
          <target state="translated">IsString</target>
        </trans-unit>
        <trans-unit id="3676b65080f47af23667593fa2dbe56b53899761" translate="yes" xml:space="preserve">
          <source>Isolate a decoder to operate with a fixed number of bytes, and fail if fewer bytes were consumed, or more bytes were attempted to be consumed. If the given decoder fails, &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt; will also fail. Offset from &lt;code&gt;&lt;a href=&quot;data-binary-get#v:bytesRead&quot;&gt;bytesRead&lt;/a&gt;&lt;/code&gt; will be relative to the start of &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt;, not the absolute of the input.</source>
          <target state="translated">Изолируйте декодер, чтобы он работал с фиксированным количеством байтов, и выйдет из строя, если было использовано меньше байтов или было предпринято попытки использовать больше байтов. Если данный декодер не работает, &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt; также не удастся. Смещение от &lt;code&gt;&lt;a href=&quot;data-binary-get#v:bytesRead&quot;&gt;bytesRead&lt;/a&gt;&lt;/code&gt; будет относиться к началу &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt; , а не абсолютному значению ввода.</target>
        </trans-unit>
        <trans-unit id="a4ce542505148e05bcc65af7af6636a88b0f16dd" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is marked as -XTrustworthy but it could instead be marked as -XSafe , a more informative bound. Can be used to detect once a Safe Haskell bound can be improved as dependencies are updated.</source>
          <target state="translated">Выдавать предупреждение,если скомпилируемый модуль помечен как -XTrustworthy,но вместо этого может быть помечен как -XSafe,более информативная привязка.Может быть использовано для обнаружения после того,как безопасная привязка Haskell может быть улучшена по мере обновления зависимостей.</target>
        </trans-unit>
        <trans-unit id="06aa14b53286f8584e57c40fad1e3a81a67ba0f1" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is regarded to be safe. Should be used to check the safety type of modules when using safe inference.</source>
          <target state="translated">Выдавать предупреждение,если компилируемый модуль считается безопасным.Следует использовать для проверки типа безопасности модулей при использовании безопасного вывода.</target>
        </trans-unit>
        <trans-unit id="b6ed530fa6a142afa10ab96b574f393e658ba7bb" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is regarded to be safe. Should be used to check the safety type of modules when using safe inference. If the module is explicitly marked as safe then no warning will be issued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60682df2a77a2bc855bbc66ec9bbdabac2ee26b2" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is regarded to be unsafe. Should be used to check the safety type of modules when using safe inference.</source>
          <target state="translated">Выдавать предупреждение,если скомпилируемый модуль считается опасным.Должен использоваться для проверки типа безопасности модулей при использовании безопасного вывода.</target>
        </trans-unit>
        <trans-unit id="7bf53c375a4a624f22b2da10f2c07ed17f8bb47d" translate="yes" xml:space="preserve">
          <source>It appears in the right hand side of a binding that binds at least one used variable that is used</source>
          <target state="translated">Она появляется в правой части переплета,который связывает по крайней мере одну использованную переменную,которая используется</target>
        </trans-unit>
        <trans-unit id="223c43fdc56fe609487e6e247ea7cd3e66ebb0fa" translate="yes" xml:space="preserve">
          <source>It can also be placed on the right-hand side of a type-level function to provide an error for an invalid case,</source>
          <target state="translated">Она также может быть размещена справа от функции уровня типа,чтобы обеспечить ошибку в случае недействительного случая,</target>
        </trans-unit>
        <trans-unit id="2ac87d14aeacaa952c867a2404b8511d2d18797a" translate="yes" xml:space="preserve">
          <source>It can also help in a third way: when used with &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;), a strict field can be unpacked or unboxed in the constructor, and one or more levels of indirection may be removed. Unpacking only happens for single-constructor datatypes (&lt;code&gt;Int&lt;/code&gt; is a good candidate, for example).</source>
          <target state="translated">Это также может помочь третьим способом: при использовании с &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt; (см. &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-F *: платформенно-независимые флаги&lt;/a&gt; ) строгое поле может быть распаковано или распаковано в конструкторе, и может быть использован один или несколько уровней косвенного обращения. удалить. Распаковка происходит только для типов данных с одним конструктором (например, &lt;code&gt;Int&lt;/code&gt; - хороший кандидат).</target>
        </trans-unit>
        <trans-unit id="294eac74bb8a1b732eb019ba498538e7dd7de972" translate="yes" xml:space="preserve">
          <source>It can be implemented in any way, with any set of superclasses and methods; however, modules depending on an abstract class are not permitted to define instances (as of GHC 8.2, this restriction is not checked, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;#13086&lt;/a&gt;.) These declarations can be implemented by type synonyms of kind &lt;code&gt;Constraint&lt;/code&gt;; this can be useful if you want to parametrize over a constraint in functions. For example, with the &lt;code&gt;ConstraintKinds&lt;/code&gt; extension, this type synonym is a valid implementation of the signature above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477b37878c8cab374119d560c1fadebca482f149" translate="yes" xml:space="preserve">
          <source>It can be implemented in any way, with any set of superclasses and methods; however, modules depending on an abstract class are not permitted to define instances (as of GHC 8.2, this restriction is not checked, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;Issue #13086&lt;/a&gt;.) These declarations can be implemented by type synonyms of kind &lt;code&gt;Constraint&lt;/code&gt;; this can be useful if you want to parametrize over a constraint in functions. For example, with the &lt;code&gt;ConstraintKinds&lt;/code&gt; extension, this type synonym is a valid implementation of the signature above:</source>
          <target state="translated">Его можно реализовать любым способом, с любым набором суперклассов и методов; однако модулям, зависящим от абстрактного класса, не разрешается определять экземпляры ( &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;начиная&lt;/a&gt; с GHC 8.2 это ограничение не проверяется, см. проблему №13086 ). Эти объявления могут быть реализованы с помощью синонимов типа типа &lt;code&gt;Constraint&lt;/code&gt; ; это может быть полезно, если вы хотите параметризовать ограничение в функциях. Например, с расширением &lt;code&gt;ConstraintKinds&lt;/code&gt; этот синоним типа является допустимой реализацией указанной выше подписи:</target>
        </trans-unit>
        <trans-unit id="7dc3d61a5c9f85d876d3d8830ea9d78107b392ca" translate="yes" xml:space="preserve">
          <source>It can be used as a base monad to which a series of monad transformers may be applied to construct a composite monad. Most monad transformer modules include the special case of applying the transformer to &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;. For example, &lt;code&gt;State s&lt;/code&gt; is an abbreviation for &lt;code&gt;StateT s &lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Его можно использовать в качестве базовой монады, к которой можно применить серию преобразователей монад для создания составной монады. Большинство модулей преобразователя монад включают специальный случай применения преобразователя к &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; . Например, &lt;code&gt;State s&lt;/code&gt; - это аббревиатура от &lt;code&gt;StateT s &lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9852af2f468eb5552aeda23d235265408470558" translate="yes" xml:space="preserve">
          <source>It can be used with functions parameterized by functor or monad classes.</source>
          <target state="translated">Может использоваться с функциями,параметризованными классами functor или monad.</target>
        </trans-unit>
        <trans-unit id="9d9e1dcae3fe4aa8145c9784bf5a266157b5617e" translate="yes" xml:space="preserve">
          <source>It can sometime be the case that the name and type of a valid hole fit is not enough to realize what the fit stands for. This flag adds the documentation of the fit to the message, if the documentation is available (and the module from which the function comes was compiled with the &lt;code&gt;-haddock&lt;/code&gt; flag).</source>
          <target state="translated">Иногда может случиться так, что названия и типа допустимой посадки отверстия недостаточно, чтобы понять, что означает посадка. Этот флаг добавляет к сообщению документацию о соответствии, если документация доступна (и модуль, из которого поступает функция, был скомпилирован с флагом &lt;code&gt;-haddock&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="131c8043e25d68f30a2ae760ed59ea45ec37b93c" translate="yes" xml:space="preserve">
          <source>It does seem odd that the existentially-bound type variable &lt;em&gt;must not&lt;/em&gt; be already in scope. Contrast that usually name-bindings merely shadow (make a &amp;lsquo;hole&amp;rsquo;) in a same-named outer variable&amp;rsquo;s scope. But we must have &lt;em&gt;some&lt;/em&gt; way to bring such type variables into scope, else we could not name existentially-bound type variables in subsequent type signatures.</source>
          <target state="translated">Кажется странным, что переменная экзистенциально связанного типа &lt;em&gt;не должна&lt;/em&gt; быть уже в области видимости. В отличие от этого, обычно привязки имен просто затеняют (делают &amp;laquo;дыру&amp;raquo;) в области видимости одноименной внешней переменной. Но у нас должен быть &lt;em&gt;какой-то&lt;/em&gt; способ перенести такие переменные типа в область видимости, иначе мы не могли бы назвать экзистенциально связанные переменные типа в последующих сигнатурах типа.</target>
        </trans-unit>
        <trans-unit id="054d4cae547999a330f8c63a5c615eee34554065" translate="yes" xml:space="preserve">
          <source>It enables the &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; to be used, which allows threads to run in parallelism on a multi-processor or multi-core machine. See &lt;a href=&quot;#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">Он позволяет использовать &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt; , что позволяет потокам работать параллельно на многопроцессорной или многоядерной машине. См. &lt;a href=&quot;#using-smp&quot;&gt;Использование параллелизма SMP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f4b4b81f61547fa1245445f1f306f991f4d6a69" translate="yes" xml:space="preserve">
          <source>It enables the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS option to be used, which allows threads to run in parallel on a multiprocessor or multicore machine. See &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">Он позволяет использовать параметр &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS, который позволяет потокам работать параллельно на многопроцессорной или многоядерной машине. См. &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;Использование параллелизма SMP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb0ce11093eeb1e05f584fe528a07b4ef4451608" translate="yes" xml:space="preserve">
          <source>It ensures that the result of each application of force to weak head normal form before proceeding.</source>
          <target state="translated">Она гарантирует,что результат каждого применения силы к слабой голове будет в нормальной форме,прежде чем двигаться дальше.</target>
        </trans-unit>
        <trans-unit id="46308fd5d44db11f7f98b515fc84088603b61098" translate="yes" xml:space="preserve">
          <source>It has a lower memory overhead than a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and and does not contribute to heap fragmentation. It can be converted to or from a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; (at the cost of copying the string data). It supports very few other operations.</source>
          <target state="translated">У него меньшие накладные расходы на память, чем у &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; , и он не способствует фрагментации кучи. Его можно преобразовать в &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; или из него (за счет копирования строковых данных). Он поддерживает очень мало других операций.</target>
        </trans-unit>
        <trans-unit id="5740ea7db69553e93f1f0294393cd715c08f5eba" translate="yes" xml:space="preserve">
          <source>It has been copied into a compact region. The documentation for &lt;code&gt;ghc-compact&lt;/code&gt; and &lt;code&gt;compact&lt;/code&gt; describes this process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a707e49b0a7765ed34649085bd077081e96884" translate="yes" xml:space="preserve">
          <source>It ignores leap-seconds, so it's not necessarily a fixed amount of clock time. For instance, 23:00 UTC + 2 hours of NominalDiffTime = 01:00 UTC (+ 1 day), regardless of whether a leap-second intervened.</source>
          <target state="translated">Он игнорирует прыжковые секунды,так что это не обязательно фиксированное время.Например,23:00 UTC+2 часа NominalDiffTime=01:00 UTC (+1 день),независимо от того,вмешалась ли високосная секунда.</target>
        </trans-unit>
        <trans-unit id="df69e6b9bd468ac0cfd863a00e4fc497cbf20b12" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;Your Responsibility&lt;/em&gt; to make sure that &lt;code&gt;intLookup&lt;/code&gt; really behaves as a specialised version of &lt;code&gt;genericLookup&lt;/code&gt;!!!</source>
          <target state="translated">Это &lt;em&gt;Ваша ответственность&lt;/em&gt; , чтобы убедиться , что &lt;code&gt;intLookup&lt;/code&gt; действительно ведет себя как специализированная версия &lt;code&gt;genericLookup&lt;/code&gt; !!!</target>
        </trans-unit>
        <trans-unit id="03f782cb2cf883c8957d19560fdc08a6367864fa" translate="yes" xml:space="preserve">
          <source>It is a member of the &lt;em&gt;root set&lt;/em&gt;.</source>
          <target state="translated">Это член &lt;em&gt;корневого набора&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="069be4f33a15425dcbdb6739fc39df2c50d79737" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-bytestring#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test. It is about 40% faster than &lt;em&gt;groupBy (==)&lt;/em&gt;</source>
          <target state="translated">Это частный случай &lt;code&gt;&lt;a href=&quot;data-bytestring#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; , который позволяет программисту предоставить свой собственный тест на равенство. Это примерно на 40% быстрее, чем &lt;em&gt;groupBy (==)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="239e0df1f67690a4356b9b61134d42a036c1b5b3" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">Это частный случай &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; , который позволяет программисту предоставить свой собственный тест на равенство.</target>
        </trans-unit>
        <trans-unit id="bd809bd965bb0b89781400d6bdebc57c3ad18a2c" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">Это частный случай &lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; , который позволяет программисту предоставить свой собственный тест на равенство.</target>
        </trans-unit>
        <trans-unit id="fa42b4f7bbfb75dac932dd4da50a6822c257bf8f" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">Это частный случай &lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; , который позволяет программисту предоставить свой собственный тест на равенство.</target>
        </trans-unit>
        <trans-unit id="f8fd3a20ff645eb541fd385527d7dc74a8034274" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">Это частный случай &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; , который позволяет программисту предоставить свой собственный тест на равенство.</target>
        </trans-unit>
        <trans-unit id="cb8c3ea4f4fa2bd6894db3bc15c4f14fe3736921" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test. If the element is found in both the first and the second list, the element from the first list will be used.</source>
          <target state="translated">Это частный случай &lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; , который позволяет программисту предоставить свой собственный тест на равенство. Если элемент найден как в первом, так и во втором списке, будет использован элемент из первого списка.</target>
        </trans-unit>
        <trans-unit id="8ca3310f8d4a5261d5f6d4a55bd30a7adbbbfad1" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">Это частный случай &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; , который позволяет программисту предоставить свой собственный тест на равенство.</target>
        </trans-unit>
        <trans-unit id="c645a3e28d8356b799e0c5997e6e6fa8ae48c19e" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">Это частный случай &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; , который позволяет программисту предоставить свой собственный тест на равенство.</target>
        </trans-unit>
        <trans-unit id="cbc3e58e1417baac797e30cd4b1fce7f11aee8c6" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">Это частный случай &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; , который позволяет программисту предоставить свой собственный тест на равенство.</target>
        </trans-unit>
        <trans-unit id="eab5f4c0e60e1bf6ad7feb752ee004afd76acf82" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">Это частный случай &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; , который позволяет программисту предоставить свой собственный тест на равенство.</target>
        </trans-unit>
        <trans-unit id="9f4770e82cc2d4aa8245aef5038e07d136f80baa" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test. If the element is found in both the first and the second list, the element from the first list will be used.</source>
          <target state="translated">Это частный случай &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; , который позволяет программисту предоставить свой собственный тест на равенство. Если элемент найден как в первом, так и во втором списке, будет использован элемент из первого списка.</target>
        </trans-unit>
        <trans-unit id="b1552e1c07901d09d36b63e9e1d341f53802ec30" translate="yes" xml:space="preserve">
          <source>It is a weak pointer object whose key is reachable.</source>
          <target state="translated">Это объект со слабым указателем,ключ которого доступен.</target>
        </trans-unit>
        <trans-unit id="0cca6e72767e4d015953dd197d29471c4aebb413" translate="yes" xml:space="preserve">
          <source>It is also possible for library writers to instruct GHC to perform call-pattern specialisation extremely aggressively. This is necessary for some highly optimized libraries, where we may want to specialize regardless of the number of specialisations, or the size of the code. As an example, consider a simplified use-case from the &lt;code&gt;vector&lt;/code&gt; library:</source>
          <target state="translated">Разработчики библиотек также могут указать GHC чрезвычайно агрессивно выполнять специализацию шаблонов вызовов. Это необходимо для некоторых высокооптимизированных библиотек, где мы можем захотеть специализироваться независимо от количества специализаций или размера кода. В качестве примера рассмотрим упрощенный вариант использования из &lt;code&gt;vector&lt;/code&gt; библиотеки:</target>
        </trans-unit>
        <trans-unit id="4757c18b6a5b619791dbad2b33b1d97df1650f39" translate="yes" xml:space="preserve">
          <source>It is also possible to break down the heap in one or more of these states by a different criteria, by restricting a profile by biography. For example, to show the portion of the heap in the drag or void state by producer:</source>
          <target state="translated">Также возможно разбить кучу в одном или нескольких из этих состояний по разным критериям,ограничив профиль по биографии.Например,показать часть кучи в состоянии перетаскивания или пустоты по производителю:</target>
        </trans-unit>
        <trans-unit id="22401f25d2546092811a16d0a0193b09e8047866" translate="yes" xml:space="preserve">
          <source>It is also possible to convert a run-time integer or string value to the corresponding type-level literal. Of course, the resulting type literal will be unknown at compile-time, so it is hidden in an existential type. The conversion may be performed using &lt;code&gt;someNatVal&lt;/code&gt; for integers and &lt;code&gt;someSymbolVal&lt;/code&gt; for strings:</source>
          <target state="translated">Также возможно преобразовать целочисленное или строковое значение времени выполнения в соответствующий литерал уровня типа. Конечно, результирующий литерал типа будет неизвестен во время компиляции, поэтому он скрыт в экзистенциальном типе. Преобразование может быть выполнено с использованием &lt;code&gt;someNatVal&lt;/code&gt; для целых чисел и &lt;code&gt;someSymbolVal&lt;/code&gt; для строк:</target>
        </trans-unit>
        <trans-unit id="c3907b0597bf6218c2db4b87b9bbdc3553feab8b" translate="yes" xml:space="preserve">
          <source>It is also possible to define pattern synonyms which behave just like record constructors. The syntax for doing this is as follows:</source>
          <target state="translated">Также можно определить синонимы паттернов,которые ведут себя как конструкторы записи.Синтаксис для этого следующий:</target>
        </trans-unit>
        <trans-unit id="8a1490fcee5f36e805c28234c40d20c616d4e3dd" translate="yes" xml:space="preserve">
          <source>It is also possible to use the special token &lt;code&gt;..&lt;/code&gt; in an export list to mean all currently bundled constructors. For example, we could write:</source>
          <target state="translated">Также можно использовать специальный токен &lt;code&gt;..&lt;/code&gt; в списке экспорта для обозначения всех связанных в настоящее время конструкторов. Например, мы могли бы написать:</target>
        </trans-unit>
        <trans-unit id="de2873d8935eeb0018b07c42899bc06b831c7270" translate="yes" xml:space="preserve">
          <source>It is also useful in higher-order situations, such as &lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt;.</source>
          <target state="translated">Это также полезно в ситуациях более высокого порядка, таких как &lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c12a49d05c28a1a98429762042c0b4412957c895" translate="yes" xml:space="preserve">
          <source>It is also useful in higher-order situations, such as &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt;.</source>
          <target state="translated">Это также полезно в ситуациях более высокого порядка, таких как &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9f8f6803d1f1e2615e394efe93e5fe24a089463" translate="yes" xml:space="preserve">
          <source>It is also useful in higher-order situations, such as &lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt;.</source>
          <target state="translated">Это также полезно в ситуациях более высокого порядка, таких как &lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="088801e51db959873ed393905491b4b94a913978" translate="yes" xml:space="preserve">
          <source>It is an error if &lt;code&gt;qualified&lt;/code&gt; appears in both pre and postpositive positions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c19c4298b2ba4d7e7e82d4c54f964b68bea6b25f" translate="yes" xml:space="preserve">
          <source>It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">Это экземпляр более общего &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; , в котором &lt;code&gt;n&lt;/code&gt; может быть любого целочисленного типа.</target>
        </trans-unit>
        <trans-unit id="8d61ccfca667f2076e6f4edcc5438cf1d81d7dfc" translate="yes" xml:space="preserve">
          <source>It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">Это экземпляр более общего &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; , в котором &lt;code&gt;n&lt;/code&gt; может быть любого целочисленного типа.</target>
        </trans-unit>
        <trans-unit id="4520db00eca14b103654198af329d717c9454f03" translate="yes" xml:space="preserve">
          <source>It is conceivable that this restriction will be relaxed in the future, but it is (at the time of writing) unclear if the difficulties around this scenario are theoretical (inferring this dependency would mean our type system does not have principal types) or merely practical (inferring this dependency is hard, given GHC&amp;rsquo;s implementation). So, GHC takes the easy way out and requires a little help from the user.</source>
          <target state="translated">Вполне возможно, что это ограничение будет ослаблено в будущем, но (на момент написания) неясно, являются ли трудности вокруг этого сценария теоретическими (вывод этой зависимости означал бы, что наша система типов не имеет основных типов) или просто практическими. (вывести эту зависимость сложно, учитывая реализацию GHC). Итак, GHC выбирает простой выход и требует небольшой помощи со стороны пользователя.</target>
        </trans-unit>
        <trans-unit id="132f9840bd91416c5132ad1603ef8603660ce360" translate="yes" xml:space="preserve">
          <source>It is currently implemented as &lt;code&gt;Array ix (TVar e)&lt;/code&gt;, but it may be replaced by a more efficient implementation in the future (the interface will remain the same, however).</source>
          <target state="translated">В настоящее время он реализован как &lt;code&gt;Array ix (TVar e)&lt;/code&gt; , но в будущем он может быть заменен более эффективной реализацией (однако интерфейс останется прежним).</target>
        </trans-unit>
        <trans-unit id="abf70f5f9fd5128dce09b9caedea975ee8e442ea" translate="yes" xml:space="preserve">
          <source>It is directly pointed to by a reachable object, other than a weak pointer object.</source>
          <target state="translated">На него прямо указывает достижимый объект,кроме слабого указателя.</target>
        </trans-unit>
        <trans-unit id="261c2e926d54062731e9f0110ad18886ba23e42b" translate="yes" xml:space="preserve">
          <source>It is enabled with the extension &lt;a href=&quot;#extension-RecursiveDo&quot;&gt;&lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/a&gt;, or the &lt;code&gt;LANGUAGE RecursiveDo&lt;/code&gt; pragma. (The same extension enables both &lt;code&gt;mdo&lt;/code&gt;-notation, and the use of &lt;code&gt;rec&lt;/code&gt; blocks inside &lt;code&gt;do&lt;/code&gt; expressions.)</source>
          <target state="translated">Он включается с помощью расширения &lt;a href=&quot;#extension-RecursiveDo&quot;&gt; &lt;code&gt;RecursiveDo&lt;/code&gt; &lt;/a&gt; или &lt;code&gt;LANGUAGE RecursiveDo&lt;/code&gt; . (То же самое расширение позволяет как &lt;code&gt;mdo&lt;/code&gt; -notation и использование &lt;code&gt;rec&lt;/code&gt; блоков внутри &lt;code&gt;do&lt;/code&gt; выражение.)</target>
        </trans-unit>
        <trans-unit id="8bea23b077b757046e91df01a7b24e7e8a098f4b" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">Это эквивалентно &lt;code&gt;(&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; когда &lt;code&gt;n&lt;/code&gt; не равно &lt;code&gt;_|_&lt;/code&gt; ( &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; является экземпляром более общего &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; , в котором &lt;code&gt;n&lt;/code&gt; может быть любого целочисленного типа.</target>
        </trans-unit>
        <trans-unit id="ab7ccf86caf74eb72038f169e079e1f3cf957dea" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;ghc-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;ghc-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">Это эквивалентно &lt;code&gt;(&lt;a href=&quot;ghc-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; когда &lt;code&gt;n&lt;/code&gt; не равно &lt;code&gt;_|_&lt;/code&gt; ( &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;ghc-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; является экземпляром более общего &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; , в котором &lt;code&gt;n&lt;/code&gt; может быть любого целочисленного типа.</target>
        </trans-unit>
        <trans-unit id="dd5e739fd9707031c252768bfd31d106af48cdf7" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">Это эквивалентно &lt;code&gt;(&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; когда &lt;code&gt;n&lt;/code&gt; не равно &lt;code&gt;_|_&lt;/code&gt; ( &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; является экземпляром более общего &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; , в котором &lt;code&gt;n&lt;/code&gt; может быть любого целочисленного типа.</target>
        </trans-unit>
        <trans-unit id="012b2268f894fbcad616c233a5e6e2ed1c0e90d2" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;prelude#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;prelude#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;prelude#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">Это эквивалентно &lt;code&gt;(&lt;a href=&quot;prelude#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;prelude#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; когда &lt;code&gt;n&lt;/code&gt; не равно &lt;code&gt;_|_&lt;/code&gt; ( &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;prelude#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; является экземпляром более общего &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; , в котором &lt;code&gt;n&lt;/code&gt; может быть любого целочисленного типа.</target>
        </trans-unit>
        <trans-unit id="9043eb63209967eef7cab64b2197f94ad029bacc" translate="yes" xml:space="preserve">
          <source>It is essential that this operator be polymorphic in &lt;code&gt;e&lt;/code&gt; (representing the environment input to the command and thence to its subcommands) and satisfy the corresponding naturality property</source>
          <target state="translated">Существенно, чтобы этот оператор был полиморфен в &lt;code&gt;e&lt;/code&gt; (представляя вход среды для команды и, следовательно, для ее подкоманд) и удовлетворял соответствующему свойству естественности</target>
        </trans-unit>
        <trans-unit id="51c5c05402feec4369eaf30cf0ebc2b274ccd329" translate="yes" xml:space="preserve">
          <source>It is expected that this operation will be replaced in a future revision of Haskell.</source>
          <target state="translated">Ожидается,что эта операция будет заменена в будущей ревизии Haskell.</target>
        </trans-unit>
        <trans-unit id="6893a464868ba3a09460037bfdb1c410934d2838" translate="yes" xml:space="preserve">
          <source>It is exported, or</source>
          <target state="translated">Она экспортируется,или</target>
        </trans-unit>
        <trans-unit id="6817f51eb52aa0729cda4c69d73c2002e9dd073d" translate="yes" xml:space="preserve">
          <source>It is fine for there to be a &lt;em&gt;potential&lt;/em&gt; of overlap (by including both declarations (A) and (B), say); an error is only reported if a particular constraint matches more than one.</source>
          <target state="translated">Это нормально, если существует &lt;em&gt;возможность&lt;/em&gt; перекрытия (например, путем включения обоих объявлений (A) и (B)); об ошибке сообщается только в том случае, если конкретное ограничение соответствует более чем одному.</target>
        </trans-unit>
        <trans-unit id="b7b71de1d9414a5e4eec5ca37b04a89216d93297" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;code&gt;-O*&lt;/code&gt; flags are roughly equivalent to combinations of &lt;code&gt;-f*&lt;/code&gt; flags. For this reason, the effect of the &lt;code&gt;-O*&lt;/code&gt; and &lt;code&gt;-f*&lt;/code&gt; flags is dependent upon the order in which they occur on the command line.</source>
          <target state="translated">Важно отметить, что флаги &lt;code&gt;-O*&lt;/code&gt; примерно эквивалентны комбинациям флагов &lt;code&gt;-f*&lt;/code&gt; . По этой причине действие флагов &lt;code&gt;-O*&lt;/code&gt; и &lt;code&gt;-f*&lt;/code&gt; зависит от порядка, в котором они появляются в командной строке.</target>
        </trans-unit>
        <trans-unit id="51fa236e42b180f8cc9073b0f8f9aa89b051ee47" translate="yes" xml:space="preserve">
          <source>It is large. Currently, GHC defines large object to be one that is at least as large as 80% of a 4KB block (i.e. at least 3277 bytes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a3f52225442e2fb709c4dba2b7ecf38df183fa" translate="yes" xml:space="preserve">
          <source>It is less well known that &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is not type safe. For example:</source>
          <target state="translated">Менее известно, что &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; небезопасен по типу. Например:</target>
        </trans-unit>
        <trans-unit id="c74a81a688854157f5042c8facebe05cd92fb4c3" translate="yes" xml:space="preserve">
          <source>It is less well known that &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is not type safe. For example:</source>
          <target state="translated">Менее известно, что &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; небезопасен по типу. Например:</target>
        </trans-unit>
        <trans-unit id="9df03deec4ca738a7771974c1c29751abc74608f" translate="yes" xml:space="preserve">
          <source>It is less well known that &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is not type safe. For example:</source>
          <target state="translated">Менее известно, что &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; небезопасен по типу. Например:</target>
        </trans-unit>
        <trans-unit id="f4ac0712f3f7039b35bf7281360a3c3a76733fb1" translate="yes" xml:space="preserve">
          <source>It is necessary to iterate the case, rather than using an equational function definition. And the situation is even worse when the matching against &lt;code&gt;t&lt;/code&gt; is buried deep inside another pattern.</source>
          <target state="translated">Необходимо повторить случай, а не использовать определение эквациональной функции. И ситуация еще хуже, когда сопоставление с &lt;code&gt;t&lt;/code&gt; скрыто глубоко внутри другого шаблона.</target>
        </trans-unit>
        <trans-unit id="e8c666bcec97da91a1f2bdb19c53fb008bad01e9" translate="yes" xml:space="preserve">
          <source>It is no faster than using &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Это не быстрее, чем использование &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7993dac004679b298df229876946bdc7ec3a34f8" translate="yes" xml:space="preserve">
          <source>It is no faster than using &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это не быстрее, чем использование &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c92a675066e21869f55b433afde1a20b5c0c7ab" translate="yes" xml:space="preserve">
          <source>It is not always required to provide instances for all the generic representation types, but omitting instances restricts the set of datatypes the functions will work for:</source>
          <target state="translated">Не всегда требуется предоставлять экземпляры для всех типов общего представления,но опускание экземпляров ограничивает набор типов данных,для которых будут работать функции:</target>
        </trans-unit>
        <trans-unit id="b38df5c45ca172adcd27d8afb5aa470712828fe4" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a finalizer will eventually run, and no attempt is made to run outstanding finalizers when the program exits. Therefore finalizers should not be relied on to clean up resources - other methods (eg. exception handlers) should be employed, possibly in addition to finalizers.</source>
          <target state="translated">Не гарантируется,что в конечном итоге будет запущен финализатор,и не предпринимается никаких попыток запустить выдающиеся финализаторы при выходе программы.Поэтому при очистке ресурсов не следует полагаться на финализаторы-следует использовать другие методы (например,обработчики исключений),возможно,в дополнение к финализаторам.</target>
        </trans-unit>
        <trans-unit id="4bbc26cf551bb9424447020a8aa82fbb576e6ad5" translate="yes" xml:space="preserve">
          <source>It is not recommended to move all the contents of your Makefiles into your source files, but in some circumstances, the &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma is the Right Thing. (If you use &lt;a href=&quot;separate_compilation#ghc-flag--keep-hc-file&quot;&gt;&lt;code&gt;-keep-hc-file&lt;/code&gt;&lt;/a&gt; and have &lt;code&gt;OPTION&lt;/code&gt; flags in your module, the &lt;code&gt;OPTIONS_GHC&lt;/code&gt; will get put into the generated &lt;code&gt;.hc&lt;/code&gt; file).</source>
          <target state="translated">Не рекомендуется перемещать все содержимое ваших Make-файлов в ваши исходные файлы, но в некоторых случаях прагма &lt;code&gt;OPTIONS_GHC&lt;/code&gt; является правильной. (Если вы используете &lt;a href=&quot;separate_compilation#ghc-flag--keep-hc-file&quot;&gt; &lt;code&gt;-keep-hc-file&lt;/code&gt; &lt;/a&gt; и в вашем модуле есть флаги &lt;code&gt;OPTION&lt;/code&gt; , &lt;code&gt;OPTIONS_GHC&lt;/code&gt; будет помещен в сгенерированный файл &lt;code&gt;.hc&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1ff8d11ee1db2c3d0f7f66202dd22454f1e83d2b" translate="yes" xml:space="preserve">
          <source>It is often convenient to use these functions together with &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt;, for instance &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt;
&lt;a href=&quot;data-function#v:on&quot;&gt;`on`&lt;/a&gt; &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">Часто бывает удобно использовать эти функции вместе с &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt; , например &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;data-function#v:on&quot;&gt;`on`&lt;/a&gt; &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f82e0aec46550ca7cd3c7a17a29d279383519fb8" translate="yes" xml:space="preserve">
          <source>It is often convenient to use these functions together with &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt;, for instance &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;
 `on` &lt;a href=&quot;data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">Часто бывает удобно использовать эти функции вместе с &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt; , например &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de502421480842aa548e8ea6ed82138595929709" translate="yes" xml:space="preserve">
          <source>It is often useful to change the interactive options, without having that option apply to loaded modules too. For example</source>
          <target state="translated">Часто бывает полезно изменить интерактивные опции,не применяя эту опцию и к загруженным модулям.Например</target>
        </trans-unit>
        <trans-unit id="eb7c1cce1ac012520a592bb5beee1e418b094930" translate="yes" xml:space="preserve">
          <source>It is perfectly fine to declare new instances of &lt;code&gt;IsList&lt;/code&gt;, so that list notation becomes useful for completely new data types. Here are several example instances:</source>
          <target state="translated">Совершенно нормально объявлять новые экземпляры &lt;code&gt;IsList&lt;/code&gt; , так что нотация списков становится полезной для совершенно новых типов данных. Вот несколько примеров:</target>
        </trans-unit>
        <trans-unit id="be592f31214a85aaa56dc9374e547bf23d2889f8" translate="yes" xml:space="preserve">
          <source>It is permitted to declare an ordinary algebraic data type using GADT-style syntax. What makes a GADT into a GADT is not the syntax, but rather the presence of data constructors whose result type is not just &lt;code&gt;T a b&lt;/code&gt;.</source>
          <target state="translated">Разрешено объявлять обычный алгебраический тип данных с использованием синтаксиса в стиле GADT. Что превращает GADT в GADT, так это не синтаксис, а наличие конструкторов данных, тип результата которых не просто &lt;code&gt;T a b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bbad91689683e0416e9939388b48991ae76e32a" translate="yes" xml:space="preserve">
          <source>It is possible for a splice to expand to an expression that contain names which are not in scope at the site of the splice. As an example, consider the following code:</source>
          <target state="translated">Возможно расширение сплайса до выражения,содержащего имена,которые не входят в область видимости в месте сращивания.В качестве примера рассмотрим следующий код:</target>
        </trans-unit>
        <trans-unit id="bd581700f02bf98080ced3eb7d39eabe45397ae7" translate="yes" xml:space="preserve">
          <source>It is possible for the class defining the associated type to specify a default for associated type instances. So for example, this is OK:</source>
          <target state="translated">Класс,определяющий ассоциированный тип,может указать тип по умолчанию для ассоциированных экземпляров.Так что,например,это нормально:</target>
        </trans-unit>
        <trans-unit id="d7b7fcebbf4b65341979036fb2aefa0d104f093c" translate="yes" xml:space="preserve">
          <source>It is possible that by using packages you might end up with a program that contains two modules with the same name: perhaps you used a package &lt;code&gt;P&lt;/code&gt; that has a &lt;em&gt;hidden&lt;/em&gt; module &lt;code&gt;M&lt;/code&gt;, and there is also a module &lt;code&gt;M&lt;/code&gt; in your program. Or perhaps the dependencies of packages that you used contain some overlapping modules. Perhaps the program even contains multiple versions of a certain package, due to dependencies from other packages.</source>
          <target state="translated">Возможно, что, используя пакеты, вы можете получить программу, содержащую два модуля с одинаковым именем: возможно, вы использовали пакет &lt;code&gt;P&lt;/code&gt; со &lt;em&gt;скрытым&lt;/em&gt; модулем &lt;code&gt;M&lt;/code&gt; , и в вашей программе также есть модуль &lt;code&gt;M&lt;/code&gt; .Или, возможно, зависимости пакетов, которые вы использовали, содержат некоторые перекрывающиеся модули. Возможно, программа даже содержит несколько версий одного пакета из-за зависимостей от других пакетов.</target>
        </trans-unit>
        <trans-unit id="e864f624e39a6372353b24e0e6a96c7344cbf60c" translate="yes" xml:space="preserve">
          <source>It is possible to ask the RTS to give some information about itself. To do this, use the &lt;a href=&quot;#rts-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt; flag, e.g.</source>
          <target state="translated">Можно попросить РТС предоставить информацию о себе. Для этого используйте флаг &lt;a href=&quot;#rts-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt; , например</target>
        </trans-unit>
        <trans-unit id="1a5239595846ebef3ee721fce01d7bb0a22f2eef" translate="yes" xml:space="preserve">
          <source>It is possible to catch all exceptions, by using the type &lt;code&gt;&lt;a href=&quot;control-exception#t:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Можно перехватить все исключения, используя тип &lt;code&gt;&lt;a href=&quot;control-exception#t:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8190060f870795d42df681cc02e5db01b634f194" translate="yes" xml:space="preserve">
          <source>It is possible to chain &lt;code&gt;&lt;a href=&quot;control-monad-cont#t:Cont&quot;&gt;Cont&lt;/a&gt;&lt;/code&gt; blocks with &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">Блоки &lt;code&gt;&lt;a href=&quot;control-monad-cont#t:Cont&quot;&gt;Cont&lt;/a&gt;&lt;/code&gt; можно объединить в цепочку с помощью &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb0b7b074cc3fe7c2ea69389e576baaaad67d773" translate="yes" xml:space="preserve">
          <source>It is possible to get intricate dependencies among the type variables introduced in a type or class declaration. Here is an example:</source>
          <target state="translated">Можно получить замысловатые зависимости между переменными типа,введенными в объявление типа или класса.Приведем пример:</target>
        </trans-unit>
        <trans-unit id="e9a188cc02db22c8ef5ca5e67b12a46a7c5847e2" translate="yes" xml:space="preserve">
          <source>It is possible to glean a little information about how well &lt;code&gt;par&lt;/code&gt; is working from the runtime statistics; see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;.</source>
          <target state="translated">Небольшую информацию о том, насколько хорошо &lt;code&gt;par&lt;/code&gt; работает, можно почерпнуть из статистики выполнения; см. &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;параметры RTS для управления сборщиком мусора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7f5b4a244218bab17d22682a2382ef6e25e7da7" translate="yes" xml:space="preserve">
          <source>It is possible to load shared libraries generated by GHC in other programs not written in Haskell, so they are suitable for using as plugins. Of course to construct a plugin you will have to use the FFI to export C functions and follow the rules about initialising the RTS. See &lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;Making a Haskell library that can be called from foreign code&lt;/a&gt;. In particular you will probably want to export a C function from your shared library to initialise the plugin before any Haskell functions are called.</source>
          <target state="translated">Можно загружать совместно используемые библиотеки, созданные GHC, в другие программы, написанные не на Haskell, поэтому они подходят для использования в качестве плагинов. Конечно, чтобы создать плагин, вам нужно будет использовать FFI для экспорта функций C и следовать правилам инициализации RTS. См. &lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;Создание библиотеки Haskell, которая может быть вызвана из внешнего кода&lt;/a&gt; . В частности, вы, вероятно, захотите экспортировать функцию C из вашей общей библиотеки для инициализации плагина перед вызовом каких-либо функций Haskell.</target>
        </trans-unit>
        <trans-unit id="98b901240fe3edf96da3bc8e1456eab7dfeb139d" translate="yes" xml:space="preserve">
          <source>It is possible to see the actual translation by using &lt;a href=&quot;debugging#ghc-flag--ddump-ds&quot;&gt;&lt;code&gt;-ddump-ds&lt;/code&gt;&lt;/a&gt;, but be warned, the output is quite verbose.</source>
          <target state="translated">Фактический перевод можно увидеть, используя &lt;a href=&quot;debugging#ghc-flag--ddump-ds&quot;&gt; &lt;code&gt;-ddump-ds&lt;/code&gt; &lt;/a&gt; , но имейте в виду , что вывод довольно подробный.</target>
        </trans-unit>
        <trans-unit id="97c0a8caadf3b66e62c0079cf1c23a1634b80cf9" translate="yes" xml:space="preserve">
          <source>It is possible to use the debugger to examine function values. When we are at a breakpoint and a function is in scope, the debugger cannot show you the source code for it; however, it is possible to get some information by applying it to some arguments and observing the result.</source>
          <target state="translated">Для изучения значений функций можно использовать отладчик.Когда мы находимся в точке останова и функция находится в области видимости,отладчик не может показать исходный код для нее,однако можно получить некоторую информацию,применив ее к некоторым аргументам и наблюдая за результатом.</target>
        </trans-unit>
        <trans-unit id="3cffc26f001e98a5eb62d64eab151b2a804d4ff6" translate="yes" xml:space="preserve">
          <source>It is possible to write a datatype that syntactically has a CUSK (according to the rules above) but actually requires some inference. As a very contrived example, consider</source>
          <target state="translated">Можно написать тип данных,который синтаксически имеет CUSK (в соответствии с правилами,приведенными выше),но на самом деле требует некоторого умозаключения.В качестве очень надуманного примера рассмотрим</target>
        </trans-unit>
        <trans-unit id="e70bf594eb18f38591c15ebb15e4986a31f41ffd" translate="yes" xml:space="preserve">
          <source>It is reasonably straightforward to set up a &lt;code&gt;Makefile&lt;/code&gt; to use with GHC, assuming you name your source files the same as your modules. Thus:</source>
          <target state="translated">Достаточно просто настроить &lt;code&gt;Makefile&lt;/code&gt; для использования с GHC, если вы называете свои исходные файлы так же, как и ваши модули. Таким образом:</target>
        </trans-unit>
        <trans-unit id="9b1330a63d6eae27b2d3c5c63940929507d87108" translate="yes" xml:space="preserve">
          <source>It is recommended that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is set to binary and &lt;code&gt;BlockBuffering&lt;/code&gt; mode. See &lt;code&gt;hSetBinaryMode&lt;/code&gt; and &lt;code&gt;hSetBuffering&lt;/code&gt;.</source>
          <target state="translated">Рекомендуется, чтобы &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; устанавливается в двоичную и &lt;code&gt;BlockBuffering&lt;/code&gt; режиме. Смотрите &lt;code&gt;hSetBinaryMode&lt;/code&gt; и &lt;code&gt;hSetBuffering&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fec177bf1098e5f20ba1d64f4c20e2f4b753abf5" translate="yes" xml:space="preserve">
          <source>It is recommended that the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is set to binary and &lt;code&gt;BlockBuffering&lt;/code&gt; mode. See &lt;code&gt;hSetBinaryMode&lt;/code&gt; and &lt;code&gt;hSetBuffering&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7149585b59024bf632f3eb0345377f4daf71cd2" translate="yes" xml:space="preserve">
          <source>It is safe to coerce each of the methods of &lt;code&gt;C&lt;/code&gt;. That is, the missing last argument to &lt;code&gt;C&lt;/code&gt; is not used at a nominal role in any of the &lt;code&gt;C&lt;/code&gt;&amp;lsquo;s methods. (See &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="translated">Принуждение к каждому из методов &lt;code&gt;C&lt;/code&gt; .безопасно . То есть, пропущенный последний аргумент &lt;code&gt;C&lt;/code&gt; не используется в номинальной роли ни в одном из методов &lt;code&gt;C&lt;/code&gt; .(См. &lt;a href=&quot;#roles&quot;&gt;Роли&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="56ac92f5a75c017852235f851030bbab0ac262ac" translate="yes" xml:space="preserve">
          <source>It is safe to coerce each of the methods of &lt;code&gt;C&lt;/code&gt;. That is, the missing last argument to &lt;code&gt;C&lt;/code&gt; is not used at a nominal role in any of the &lt;code&gt;C&lt;/code&gt;&amp;rsquo;s methods. (See &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6dfdd6aaac4046a07ffe9ab81b043a38fb69661" translate="yes" xml:space="preserve">
          <source>It is safe to modify the floating-point unit state temporarily during a foreign call, because foreign calls are never pre-empted by GHC.</source>
          <target state="translated">Временно изменять состояние блока с плавающей точкой во время иностранного вызова безопасно,так как иностранные вызовы никогда не упреждаются GHC.</target>
        </trans-unit>
        <trans-unit id="96385c6227a3ac0109a62a1c3c011cd583d5d18e" translate="yes" xml:space="preserve">
          <source>It is similar to &lt;code&gt;&lt;a href=&quot;data-array-io#v:IOUArray&quot;&gt;IOUArray&lt;/a&gt;&lt;/code&gt; but slower. Its advantage is that it's compatible with C.</source>
          <target state="translated">Он похож на &lt;code&gt;&lt;a href=&quot;data-array-io#v:IOUArray&quot;&gt;IOUArray&lt;/a&gt;&lt;/code&gt; , но работает медленнее. Его преимущество в том, что он совместим с C.</target>
        </trans-unit>
        <trans-unit id="5091abc2477144e1329f7f3c467074952c1a5362" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary to enable additional language extensions when deriving instances via &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;. For instance, consider a simple class and instance using &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; syntax:</source>
          <target state="translated">Иногда необходимо включить дополнительные языковые расширения при создании экземпляров через &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt; . Например, рассмотрим простой класс и экземпляр с использованием синтаксиса &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5897d1d4639badd735a78c211392c1d9c37495e6" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to construct the argument name using &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; to ensure that we are reifying from the right namespace. For instance, in this context:</source>
          <target state="translated">Иногда бывает полезно &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; имя аргумента с помощью lookupTypeName или &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; , чтобы убедиться, что мы осуществляем определение из правильного пространства имен. Например, в этом контексте:</target>
        </trans-unit>
        <trans-unit id="000457152f4555357926c0b8afb516222a4f1c89" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to construct the argument name using &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; to ensure that we are reifying from the right namespace. For instance, in this context:</source>
          <target state="translated">Иногда бывает полезно &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; имя аргумента с помощью lookupTypeName или &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; , чтобы убедиться, что мы осуществляем определение из правильного пространства имен. Например, в этом контексте:</target>
        </trans-unit>
        <trans-unit id="c301fee90cdf2b960b35ddd17fe3eb6c2529a715" translate="yes" xml:space="preserve">
          <source>It is strongly recommended to use the safer, monadic API of &lt;a href=&quot;system-console-haskeline&quot;&gt;System.Console.Haskeline&lt;/a&gt;, if possible, rather than the explicit state management functions of this module.</source>
          <target state="translated">Настоятельно рекомендуется использовать более безопасный монадический API &lt;a href=&quot;system-console-haskeline&quot;&gt;System.Console.Haskeline&lt;/a&gt; , если это возможно, а не явные функции управления состоянием этого модуля.</target>
        </trans-unit>
        <trans-unit id="cc6c22c421bb7df31e233c1d7015be119c4e51ad" translate="yes" xml:space="preserve">
          <source>It is suitable for use as an internal representation for code that needs to keep many short strings in memory, but it &lt;em&gt;should not&lt;/em&gt; be used as an interchange type. That is, it should not generally be used in public APIs. The &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; type is usually more suitable for use in interfaces; it is more flexible and it supports a wide range of operations.</source>
          <target state="translated">Он подходит для использования в качестве внутреннего представления кода, который должен хранить в памяти много коротких строк, но его &lt;em&gt;не&lt;/em&gt; следует использовать в качестве типа обмена. То есть его обычно не следует использовать в общедоступных API. Тип &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; обычно больше подходит для использования в интерфейсах; он более гибкий и поддерживает широкий спектр операций.</target>
        </trans-unit>
        <trans-unit id="c44526ff00c2ea8f2f54194c36d403aa696761a1" translate="yes" xml:space="preserve">
          <source>It is suitable for use in pure code. In an IO context use &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Он подходит для использования в чистом коде. В контексте ввода- &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; вместо этого используйте traceEventIO .</target>
        </trans-unit>
        <trans-unit id="dc72eb1fbfce672989fe724db9126c46b5b0adc1" translate="yes" xml:space="preserve">
          <source>It is the value or finalizer of a weak pointer object whose key is reachable.</source>
          <target state="translated">Это значение или финализатор объекта со слабым указателем,ключ которого доступен.</target>
        </trans-unit>
        <trans-unit id="746eec2fe2a404a8fabc9e6abdf7648c07f8bc2b" translate="yes" xml:space="preserve">
          <source>It is undefined which thread receives this exception. GHC currently throws this to the same thread that receives &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt;, but this may change in the future.</source>
          <target state="translated">Неизвестно, какой поток получит это исключение. В настоящее время GHC &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; это тому же потоку, который получает UserInterrupt , но это может измениться в будущем.</target>
        </trans-unit>
        <trans-unit id="d492c88d310512060b035b6ec8aa0a90e3614dfd" translate="yes" xml:space="preserve">
          <source>It is undefined which thread receives this exception. GHC currently throws this to the same thread that receives &lt;code&gt;&lt;a href=&quot;ghc-io-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt;, but this may change in the future.</source>
          <target state="translated">Неизвестно, какой поток получит это исключение. В настоящее время GHC &lt;code&gt;&lt;a href=&quot;ghc-io-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; это тому же потоку, который получает UserInterrupt , но это может измениться в будущем.</target>
        </trans-unit>
        <trans-unit id="f6bfd659d3eb587c25350fe75cdd1cec239a674b" translate="yes" xml:space="preserve">
          <source>It is useful for GHC to optimise the definition of an INLINE function &lt;code&gt;f&lt;/code&gt; just like any other non-&lt;code&gt;INLINE&lt;/code&gt; function, in case the non-inlined version of &lt;code&gt;f&lt;/code&gt; is ultimately called. But we don&amp;rsquo;t want to inline the &lt;em&gt;optimised&lt;/em&gt; version of &lt;code&gt;f&lt;/code&gt;; a major reason for &lt;code&gt;INLINE&lt;/code&gt; pragmas is to expose functions in &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s RHS that have rewrite rules, and it&amp;rsquo;s no good if those functions have been optimised away.</source>
          <target state="translated">Для GHC полезно оптимизировать определение INLINE-функции &lt;code&gt;f&lt;/code&gt; , как и любой другой не- &lt;code&gt;INLINE&lt;/code&gt; - функции, в случае, если в конечном итоге вызывается не-встроенная версия &lt;code&gt;f&lt;/code&gt; . Но мы не хотим встраивать &lt;em&gt;оптимизированную&lt;/em&gt; версию &lt;code&gt;f&lt;/code&gt; ; основной причиной использования &lt;code&gt;INLINE&lt;/code&gt; является предоставление функций в RHS &lt;code&gt;f&lt;/code&gt; , которые имеют правила перезаписи, и нет ничего хорошего, если эти функции были оптимизированы.</target>
        </trans-unit>
        <trans-unit id="257ce5275a4cb48ad40d9428d4ab5e66cc348fde" translate="yes" xml:space="preserve">
          <source>It is useful for GHC to optimise the definition of an INLINE function &lt;code&gt;f&lt;/code&gt; just like any other non-&lt;code&gt;INLINE&lt;/code&gt; function, in case the non-inlined version of &lt;code&gt;f&lt;/code&gt; is ultimately called. But we don&amp;rsquo;t want to inline the &lt;em&gt;optimised&lt;/em&gt; version of &lt;code&gt;f&lt;/code&gt;; a major reason for &lt;code&gt;INLINE&lt;/code&gt; pragmas is to expose functions in &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s RHS that have rewrite rules, and it&amp;rsquo;s no good if those functions have been optimised away.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf84a0b4bca232dcfe172af6a8fe10d863549539" translate="yes" xml:space="preserve">
          <source>It is useful to think of &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; not as a way to completely prevent asynchronous exceptions, but as a way to switch from asynchronous mode to polling mode. The main difficulty with asynchronous exceptions is that they normally can occur anywhere, but within a &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; an asynchronous exception is only raised by operations that are interruptible (or call other interruptible operations). In many cases these operations may themselves raise exceptions, such as I/O errors, so the caller will usually be prepared to handle exceptions arising from the operation anyway. To perform an explicit poll for asynchronous exceptions inside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;control-exception#v:allowInterrupt&quot;&gt;allowInterrupt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Полезно думать о &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; не как о способе полного предотвращения асинхронных исключений, а как о способе переключения из асинхронного режима в режим опроса. Основная трудность с асинхронными исключениями заключается в том, что они обычно могут возникать где угодно, но внутри &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; асинхронное исключение вызывается только операциями, которые можно прервать (или вызвать другие прерываемые операции). Во многих случаях эти операции сами по себе могут вызывать исключения, такие как ошибки ввода-вывода, поэтому вызывающая сторона обычно будет готова обрабатывать исключения, возникающие в результате операции. Чтобы выполнить явный опрос асинхронных исключений внутри &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; , используйте &lt;code&gt;&lt;a href=&quot;control-exception#v:allowInterrupt&quot;&gt;allowInterrupt&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="def905b28141bd2cd23fb72f07484744ecd15628" translate="yes" xml:space="preserve">
          <source>It is worth noting that &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not&lt;/em&gt; required to give the data families themselves return kinds involving &lt;code&gt;TYPE&lt;/code&gt;, such as the &lt;code&gt;FooKey&lt;/code&gt; and &lt;code&gt;BarType&lt;/code&gt; examples above. The extension is only required for &lt;code&gt;newtype instance&lt;/code&gt; declarations, such as &lt;code&gt;FooKeyBoolC&lt;/code&gt; and &lt;code&gt;BarTypeWorkRepC&lt;/code&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c498521723f8812e03fd4118ff670333ce430a6f" translate="yes" xml:space="preserve">
          <source>It is worth noting with shared objects, when each package is built as a single shared object file, since a reference to a shared object costs an extra indirection, intra-package references are cheaper than inter-package references. Of course, this applies to the &lt;code&gt;main&lt;/code&gt; package as well.</source>
          <target state="translated">Стоит отметить, что с общими объектами, когда каждый пакет строится как единый общий объектный файл, поскольку ссылка на разделяемый объект требует дополнительной косвенности, внутрипакетные ссылки дешевле, чем межпакетные ссылки. Конечно, это касается и &lt;code&gt;main&lt;/code&gt; пакета.</target>
        </trans-unit>
        <trans-unit id="92ef842f60f53412417acbb9c342eaa7f4e2205c" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t always possible to terminate a Haskell thread forcibly: for example, the thread might be currently executing a foreign call, and we have no way to force the foreign call to complete. What&amp;rsquo;s more, the runtime must assume that in the worst case the Haskell code and runtime are about to be removed from memory (e.g. if this is a &lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Windows DLL&lt;/a&gt;, &lt;code&gt;hs_exit()&lt;/code&gt; is normally called before unloading the DLL). So &lt;code&gt;hs_exit()&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; wait until all outstanding foreign calls return before it can return itself.</source>
          <target state="translated">Не всегда возможно завершить поток Haskell принудительно: например, поток может в настоящее время выполнять внешний вызов, и у нас нет возможности принудительно завершить внешний вызов. Более того, среда выполнения должна предполагать, что в худшем случае код и среда выполнения Haskell будут удалены из памяти (например, если это &lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Windows DLL&lt;/a&gt; , &lt;code&gt;hs_exit()&lt;/code&gt; обычно вызывается перед выгрузкой DLL). Таким образом, &lt;code&gt;hs_exit()&lt;/code&gt; &lt;em&gt;должна&lt;/em&gt; дождаться возврата всех невыполненных внешних вызовов, прежде чем она сможет вернуть себя.</target>
        </trans-unit>
        <trans-unit id="3e1f8368ea03e61951e96f7203ef6dd1ba202cc6" translate="yes" xml:space="preserve">
          <source>It may also output a C file which contains additional C functions to be linked into the program, together with a C header that gets included into the C code to which the Haskell module will be compiled (when compiled via C) and into the C file. These two files are created when the &lt;code&gt;#def&lt;/code&gt; construct is used (see below).</source>
          <target state="translated">Он также может выводить файл C, который содержит дополнительные функции C, которые должны быть связаны с программой, вместе с заголовком C, который включается в код C, в который будет скомпилирован модуль Haskell (при компиляции через C), и в файл C. , Эти два файла создаются при &lt;code&gt;#def&lt;/code&gt; конструкции #def (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="d09779bd37727473434368e2def3ed2ba44679a3" translate="yes" xml:space="preserve">
          <source>It may appear tempting to use &lt;code&gt;DllMain&lt;/code&gt; to call &lt;code&gt;hs_init&lt;/code&gt;/&lt;code&gt;hs_exit&lt;/code&gt;, but this won&amp;rsquo;t work (particularly if you compile with &lt;code&gt;-threaded&lt;/code&gt;). There are severe restrictions on which actions can be performed during &lt;code&gt;DllMain&lt;/code&gt;, and &lt;code&gt;hs_init&lt;/code&gt; violates these restrictions, which can lead to your DLL freezing during startup (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;#3605&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8136f6e215348988c49d3102c5c3052b920fc9de" translate="yes" xml:space="preserve">
          <source>It may appear tempting to use &lt;code&gt;DllMain&lt;/code&gt; to call &lt;code&gt;hs_init&lt;/code&gt;/&lt;code&gt;hs_exit&lt;/code&gt;, but this won&amp;rsquo;t work (particularly if you compile with &lt;code&gt;-threaded&lt;/code&gt;). There are severe restrictions on which actions can be performed during &lt;code&gt;DllMain&lt;/code&gt;, and &lt;code&gt;hs_init&lt;/code&gt; violates these restrictions, which can lead to your DLL freezing during startup (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;Issue #3605&lt;/a&gt;).</source>
          <target state="translated">Может показаться заманчивым использовать &lt;code&gt;DllMain&lt;/code&gt; для вызова &lt;code&gt;hs_init&lt;/code&gt; / &lt;code&gt;hs_exit&lt;/code&gt; , но это не сработает (особенно, если вы компилируете с &lt;code&gt;-threaded&lt;/code&gt; ). Существуют жесткие ограничения , на которых можно выполнять действия во время &lt;code&gt;DllMain&lt;/code&gt; , и &lt;code&gt;hs_init&lt;/code&gt; нарушает эти ограничения, которые могут привести к вашему DLL замораживания во время запуска (см &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;Issue # 3605&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="863ecc94447ccc2697e7cef0c45280ea8b50466a" translate="yes" xml:space="preserve">
          <source>It may be useful to note that supposing</source>
          <target state="translated">Может быть полезно отметить,что предположение</target>
        </trans-unit>
        <trans-unit id="32c8a688305684e8a6eed99f28e0bf7debe34172" translate="yes" xml:space="preserve">
          <source>It might seem that &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;import&lt;/code&gt; and &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; do similar things: you can use both to bring a module into scope. However, there is a very important difference. GHCi is concerned with two sets of modules:</source>
          <target state="translated">Может показаться, что &lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; / &lt;code&gt;import&lt;/code&gt; и &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; делают похожие вещи: вы можете использовать оба, чтобы добавить модуль в область видимости. Однако есть очень важное отличие. GHCi имеет дело с двумя наборами модулей:</target>
        </trans-unit>
        <trans-unit id="8e2a509fc1a6cc8bacc29eac66f8d2b04611ec55" translate="yes" xml:space="preserve">
          <source>It must be that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same kind. Note also that &lt;code&gt;b&lt;/code&gt; is implicitly declared in &lt;code&gt;c&lt;/code&gt;&amp;lsquo;s kind. Thus, according to our general principle, &lt;code&gt;b&lt;/code&gt; must come &lt;em&gt;before&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. However, &lt;code&gt;b&lt;/code&gt;&lt;em&gt;depends on&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. We thus reject &lt;code&gt;T2&lt;/code&gt; with a suitable error message.</source>
          <target state="translated">Должно быть, что &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; имеют одинаковый вид. Также обратите внимание, что &lt;code&gt;b&lt;/code&gt; неявно объявлен в типе &lt;code&gt;c&lt;/code&gt; . Таким образом, согласно нашему общему принципу, &lt;code&gt;b&lt;/code&gt; должно стоять &lt;em&gt;перед &lt;/em&gt; &lt;code&gt;k&lt;/code&gt; . Однако &lt;code&gt;b&lt;/code&gt; &lt;em&gt;зависит от &lt;/em&gt; &lt;code&gt;k&lt;/code&gt; . Таким образом, мы отклоняем &lt;code&gt;T2&lt;/code&gt; с подходящим сообщением об ошибке.</target>
        </trans-unit>
        <trans-unit id="d71a3e4924a3c6c7be2ff4e99d0b3ace79cfc698" translate="yes" xml:space="preserve">
          <source>It must be that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same kind. Note also that &lt;code&gt;b&lt;/code&gt; is implicitly declared in &lt;code&gt;c&lt;/code&gt;&amp;rsquo;s kind. Thus, according to our general principle, &lt;code&gt;b&lt;/code&gt; must come &lt;em&gt;before&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. However, &lt;code&gt;b&lt;/code&gt;&lt;em&gt;depends on&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. We thus reject &lt;code&gt;T2&lt;/code&gt; with a suitable error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6086959b33661c7e9581d7038f036b9687ffb684" translate="yes" xml:space="preserve">
          <source>It returns the number of bytes actually read. This may be zero if EOF was reached before any data was read (or if &lt;code&gt;count&lt;/code&gt; is zero).</source>
          <target state="translated">Он возвращает количество фактически прочитанных байтов. Это может быть ноль, если EOF был достигнут до того, как были прочитаны какие-либо данные (или если &lt;code&gt;count&lt;/code&gt; равен нулю).</target>
        </trans-unit>
        <trans-unit id="ad092a31e7b069ad5452e1dfd822db5e1ae8fc9d" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Он служит для сохранения внутренних состояний различных вызовов &lt;code&gt;&lt;a href=&quot;control-monad-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; отдельно друг от друга и от вызовов &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="211c65f9fdb230b192954d5e3e492b544e937b6c" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Он служит для сохранения внутренних состояний различных вызовов &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; отдельно друг от друга и от вызовов &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5294a2ca52cc071e8a324a9f8f6ff0a8cae15e2b" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Он служит для сохранения внутренних состояний различных вызовов &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; отдельно друг от друга и от вызовов &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2289a3219a1ed755ecc57cda3383343eb8709ef1" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Он служит для сохранения внутренних состояний различных вызовов &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; отдельно друг от друга и от вызовов &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b435c38ec10dc76b668c9ec854526a598ebffc36" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;ghc-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Он служит для сохранения внутренних состояний различных вызовов &lt;code&gt;&lt;a href=&quot;ghc-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; отдельно друг от друга и от вызовов &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29550fa0ca4c9e4aac212d854a9fc9caacdfa683" translate="yes" xml:space="preserve">
          <source>It turns out that such recursive bindings do indeed make sense for a variety of monads, but not all. In particular, recursion in this sense requires a fixed-point operator for the underlying monad, captured by the &lt;code&gt;mfix&lt;/code&gt; method of the &lt;code&gt;MonadFix&lt;/code&gt; class, defined in &lt;code&gt;Control.Monad.Fix&lt;/code&gt; as follows:</source>
          <target state="translated">Оказывается, такие рекурсивные привязки действительно имеют смысл для множества монад, но не для всех. В частности, рекурсии в этом смысле требует оператора с фиксированной точкой для базовога монады, захваченного в &lt;code&gt;mfix&lt;/code&gt; способом &lt;code&gt;MonadFix&lt;/code&gt; класса, определенном в &lt;code&gt;Control.Monad.Fix&lt;/code&gt; следующим образом :</target>
        </trans-unit>
        <trans-unit id="dc2967b7223e4a80cc2b7ede4a86ad6f728237bf" translate="yes" xml:space="preserve">
          <source>It was allocated by &lt;code&gt;newPinnedByteArray#&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5052bd2b0b2688526179e347a8f93097a86fbaf" translate="yes" xml:space="preserve">
          <source>It will create &lt;code&gt;.ghci-history&lt;/code&gt; in current folder where GHCi is launched.</source>
          <target state="translated">Он создаст &lt;code&gt;.ghci-history&lt;/code&gt; в текущей папке, в которой запущен GHCi .</target>
        </trans-unit>
        <trans-unit id="e89d7af8e2aa6670470982a682725f5658cf083d" translate="yes" xml:space="preserve">
          <source>It will then pass the individual entries and pairs of entries to &lt;code&gt;g1&lt;/code&gt;, &lt;code&gt;g2&lt;/code&gt;, or &lt;code&gt;f&lt;/code&gt; as appropriate:</source>
          <target state="translated">Затем он передаст отдельные записи и пары записей в &lt;code&gt;g1&lt;/code&gt; , &lt;code&gt;g2&lt;/code&gt; или &lt;code&gt;f&lt;/code&gt; в зависимости от ситуации:</target>
        </trans-unit>
        <trans-unit id="1540cae372d4d44e85661059bc790134f5ab7b8e" translate="yes" xml:space="preserve">
          <source>It would be better for GHCi to record what the default settings in each module are, and use those of the &amp;lsquo;current&amp;rsquo; module (whatever that is).</source>
          <target state="translated">Для GHCi было бы лучше записывать, какие настройки по умолчанию в каждом модуле, и использовать те из &amp;laquo;текущего&amp;raquo; модуля (что бы это ни было).</target>
        </trans-unit>
        <trans-unit id="7f8111ac56899714c85e5abca35105627760e1bf" translate="yes" xml:space="preserve">
          <source>It would be quite sensible to &lt;em&gt;compile&lt;/em&gt; on a fast machine using remotely-mounted disks; then &lt;em&gt;link&lt;/em&gt; on a slow machine that had your disks directly mounted.</source>
          <target state="translated">Было бы разумно &lt;em&gt;скомпилировать&lt;/em&gt; на быстрой машине с удаленно смонтированными дисками; затем &lt;em&gt;подключитесь&lt;/em&gt; к медленной машине, к которой были подключены ваши диски напрямую.</target>
        </trans-unit>
        <trans-unit id="763a82435cb1c586af5397dec827eab8a6fea09e" translate="yes" xml:space="preserve">
          <source>It would be undesirable if &lt;a href=&quot;glasgow_exts#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; were to apply to loaded modules too: that might cause a compilation error, but more commonly it will cause extra recompilation, because GHC will think that it needs to recompile the module because the flags have changed.</source>
          <target state="translated">Было бы нежелательно, если бы &lt;a href=&quot;glasgow_exts#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt; применялся и к загруженным модулям: это может вызвать ошибку компиляции, но чаще всего это вызовет дополнительную перекомпиляцию, потому что GHC будет думать, что ему нужно перекомпилировать модуль, потому что флаги изменились.</target>
        </trans-unit>
        <trans-unit id="738c3efaf58c34fc713cd68ed8f30d5430283ea5" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s all the better if a function is strict in a single-constructor type (a type with only one data-constructor; for example, tuples are single-constructor types).</source>
          <target state="translated">Тем лучше, если функция является строгой в типе с одним конструктором (тип только с одним конструктором данных; например, кортежи являются типами с одним конструктором).</target>
        </trans-unit>
        <trans-unit id="7aca502a5780a7008e4ab06793361208292555d4" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible to have mutually recursive bindings, using the new &lt;code&gt;rec&lt;/code&gt; keyword, as in the following example:</source>
          <target state="translated">Также возможно иметь взаимно рекурсивные привязки, используя ключевое слово new &lt;code&gt;rec&lt;/code&gt; , как в следующем примере:</target>
        </trans-unit>
        <trans-unit id="923f83a378500c5bf707083388bd8a5d2d3dc878" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s ok to say &lt;code&gt;a==b&lt;/code&gt; or &lt;code&gt;p==q&lt;/code&gt;, but &lt;code&gt;a==q&lt;/code&gt; is wrong because it equates the two distinct types arising from the two &lt;code&gt;Baz1&lt;/code&gt; constructors.</source>
          <target state="translated">Можно сказать &lt;code&gt;a==b&lt;/code&gt; или &lt;code&gt;p==q&lt;/code&gt; , но &lt;code&gt;a==q&lt;/code&gt; неверно, потому что оно уравнивает два различных типа, возникающих из двух конструкторов &lt;code&gt;Baz1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7c6fdc0025c696839bbcb4d3a4afbd97412dcd6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s ugly and slow.</source>
          <target state="translated">Это уродливо и медленно.</target>
        </trans-unit>
        <trans-unit id="514128120e37ddc76a0f201865baee5082dd51ad" translate="yes" xml:space="preserve">
          <source>It's recommended to avoid calling &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; for small integers as this function would currently convert those to big integers in msbf to call &lt;code&gt;mpz_export()&lt;/code&gt;.</source>
          <target state="translated">Рекомендуется избегать вызова &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; для небольших целых чисел, поскольку эта функция в настоящее время преобразует их в большие целые числа в msbf для вызова &lt;code&gt;mpz_export()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cee3c6301483587eda64e5ab687af2ed85576f1" translate="yes" xml:space="preserve">
          <source>It's worth noting that the size of the result may be smaller if, for some &lt;code&gt;(x,y)&lt;/code&gt;, &lt;code&gt;x /= y &amp;amp;&amp;amp; f x == f y&lt;/code&gt;</source>
          <target state="translated">Стоит отметить , что размер результата может быть меньше , если для некоторых &lt;code&gt;(x,y)&lt;/code&gt; , &lt;code&gt;x /= y &amp;amp;&amp;amp; f x == f y&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee6ff3dfa9bf63053b4c7f482ac4fa5228abd4d4" translate="yes" xml:space="preserve">
          <source>Item (IsList)</source>
          <target state="translated">Пункт (IsList)</target>
        </trans-unit>
        <trans-unit id="091b8d78ec3176b66348479ab0a7eba113756aa7" translate="yes" xml:space="preserve">
          <source>Iter</source>
          <target state="translated">Iter</target>
        </trans-unit>
        <trans-unit id="912a927d3c272044f83f97a4a9348c2b0b737b5e" translate="yes" xml:space="preserve">
          <source>Iterative construction</source>
          <target state="translated">итеративная конструкция</target>
        </trans-unit>
        <trans-unit id="15efe73a427c5593245c3e378d2d1f213eb9ce90" translate="yes" xml:space="preserve">
          <source>Ix</source>
          <target state="translated">Ix</target>
        </trans-unit>
        <trans-unit id="c00d287ecb04edccb5fea26b5b72064393528f73" translate="yes" xml:space="preserve">
          <source>J. Nievergelt and E.M. Reingold, &quot;&lt;em&gt;Binary search trees of bounded balance&lt;/em&gt;&quot;, SIAM journal of computing 2(1), March 1973.</source>
          <target state="translated">Дж. Нивергельт и Е. М. Рейнгольд, &quot; &lt;em&gt;Деревья двоичного поиска ограниченного баланса&lt;/em&gt; &quot;, журнал SIAM по вычислениям 2 (1), март 1973.</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="13f21e57d0b030c88aa84181b98abab96e4c801a" translate="yes" xml:space="preserve">
          <source>JavaScriptFFI</source>
          <target state="translated">JavaScriptFFI</target>
        </trans-unit>
        <trans-unit id="35f6feec54354858f697f87aaa0e0984f56e1720" translate="yes" xml:space="preserve">
          <source>Johan Tibell &amp;lt;johan.tibell@gmail.com&amp;gt;</source>
          <target state="translated">Йохан Тибелл &amp;lt;johan.tibell@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="136e9e756d575af36e49778c9cc45e9f8a0f90f2" translate="yes" xml:space="preserve">
          <source>Join a drive and the rest of the path.</source>
          <target state="translated">Соедините диск и остальную часть пути.</target>
        </trans-unit>
        <trans-unit id="81e4e655a28bbcb077ce4558a222bf0f0a8cba3c" translate="yes" xml:space="preserve">
          <source>Join path elements back together.</source>
          <target state="translated">Соедините элементы пути обратно.</target>
        </trans-unit>
        <trans-unit id="382ff1702ad460b913c77bbc040227d10fae8bb9" translate="yes" xml:space="preserve">
          <source>Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring, and Andres Loeh. &lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;A generic deriving mechanism for Haskell&lt;/a&gt;. Proceedings of the third ACM Haskell symposium on Haskell (Haskell&amp;lsquo;2010), pp. 37-48, ACM, 2010.</source>
          <target state="translated">Хосе Педро Магальяэс, Аце Дейкстра, Йохан Джеуринг и Андрес Лоэ. &lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;Общий механизм вывода для Haskell&lt;/a&gt; . Материалы третьего симпозиума ACM Haskell по Haskell (Haskell'2010), стр. 37-48, ACM, 2010.</target>
        </trans-unit>
        <trans-unit id="8cce6d3a7b7f612b30abbeb5c7bc5be263acd7cb" translate="yes" xml:space="preserve">
          <source>Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring, and Andres Loeh. &lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;A generic deriving mechanism for Haskell&lt;/a&gt;. Proceedings of the third ACM Haskell symposium on Haskell (Haskell&amp;rsquo;2010), pp. 37-48, ACM, 2010.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9361b1c736dd39f64c18be1fbaf85ce313be120e" translate="yes" xml:space="preserve">
          <source>Jules Hedges. &quot;Monad transformers for backtracking search&quot;. In &lt;em&gt;Proceedings of MSFP 2014&lt;/em&gt;. &lt;a href=&quot;https://arxiv.org/abs/1406.2058&quot;&gt;https://arxiv.org/abs/1406.2058&lt;/a&gt;</source>
          <target state="translated">Жюль Хеджес. &quot;Преобразователи монад для поиска с возвратом&quot;. В &lt;em&gt;материалах MSFP 2014&lt;/em&gt; . &lt;a href=&quot;https://arxiv.org/abs/1406.2058&quot;&gt;https://arxiv.org/abs/1406.2058&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e1532d85b8e7a783cd0eeb4f032f73947230558" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt;, but don't add the trailing slashes to each element.</source>
          <target state="translated">Так же, как &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt; , но не добавляйте завершающие слэши к каждому элементу.</target>
        </trans-unit>
        <trans-unit id="e1b8cd9be8a4a56d3e279168c48e322c5a8f7d5f" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt;, but don't add the trailing slashes to each element.</source>
          <target state="translated">Так же, как &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt; , но не добавляйте завершающие слэши к каждому элементу.</target>
        </trans-unit>
        <trans-unit id="bf4d570e4ce8e1639edd6b13c9e338ab1cfd25c6" translate="yes" xml:space="preserve">
          <source>Just as compiling &lt;code&gt;A.hs&lt;/code&gt; produces an interface file &lt;code&gt;A.hi&lt;/code&gt;, and an object file &lt;code&gt;A.o&lt;/code&gt;, so compiling &lt;code&gt;A.hs-boot&lt;/code&gt; produces an interface file &lt;code&gt;A.hi-boot&lt;/code&gt;, and a pseudo-object file &lt;code&gt;A.o-boot&lt;/code&gt;:</source>
          <target state="translated">Подобно тому, как компиляция &lt;code&gt;A.hs&lt;/code&gt; создает интерфейсный файл &lt;code&gt;A.hi&lt;/code&gt; и объектный файл &lt;code&gt;A.o&lt;/code&gt; , компиляция &lt;code&gt;A.hs-boot&lt;/code&gt; создает интерфейсный файл &lt;code&gt;A.hi-boot&lt;/code&gt; и псевдообъектный файл &lt;code&gt;A.o-boot&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a7ab736e2bc63d2763e588e9ee6e30408ceb5d71" translate="yes" xml:space="preserve">
          <source>Just as in the case of Template Haskell (&lt;a href=&quot;#th-syntax&quot;&gt;Syntax&lt;/a&gt;), GHC gets confused if you put a quote mark before a data constructor whose second character is a quote mark. In this case, just put a space between the promotion quote and the data constructor:</source>
          <target state="translated">Как и в случае с Template Haskell ( &lt;a href=&quot;#th-syntax&quot;&gt;синтаксис&lt;/a&gt; ), GHC запутается, если вы поставите кавычки перед конструктором данных, второй символ которого является кавычкой. В этом случае просто поставьте пробел между цитатой рекламного предложения и конструктором данных:</target>
        </trans-unit>
        <trans-unit id="5b2209ab2f057867c4513a2da5e88701a39853ef" translate="yes" xml:space="preserve">
          <source>Just as in type inference, kind inference for recursive types can only use &lt;em&gt;monomorphic&lt;/em&gt; recursion. Consider this (contrived) example:</source>
          <target state="translated">Как и в случае вывода типа, вывод типа для рекурсивных типов может использовать только &lt;em&gt;мономорфную&lt;/em&gt; рекурсию. Рассмотрим этот (надуманный) пример:</target>
        </trans-unit>
        <trans-unit id="960a74070ce7ace8facd72bd4167a0b45f8388db" translate="yes" xml:space="preserve">
          <source>Just as you wouldn&amp;rsquo;t define a &lt;code&gt;Monad&lt;/code&gt; instance using the do-notation, you shouldn&amp;rsquo;t define &lt;code&gt;Functor&lt;/code&gt; or &lt;code&gt;Applicative&lt;/code&gt; instance using do-notation (when using &lt;code&gt;ApplicativeDo&lt;/code&gt;) either. The correct way to define these instances in terms of &lt;code&gt;Monad&lt;/code&gt; is to use the &lt;code&gt;Monad&lt;/code&gt; operations directly, e.g.</source>
          <target state="translated">Точно так же, как вы не определяете экземпляр &lt;code&gt;Monad&lt;/code&gt; с помощью do-notation, вы также не должны определять &lt;code&gt;Functor&lt;/code&gt; или &lt;code&gt;Applicative&lt;/code&gt; с помощью do-notation (при использовании &lt;code&gt;ApplicativeDo&lt;/code&gt; ). Правильный способ определить эти экземпляры в терминах &lt;code&gt;Monad&lt;/code&gt; - напрямую использовать операции &lt;code&gt;Monad&lt;/code&gt; , например</target>
        </trans-unit>
        <trans-unit id="4b041bcf3276487951d5811d4b81addad99a067a" translate="yes" xml:space="preserve">
          <source>Just like signatures on value-level bindings, pattern synonym signatures can apply to more than one pattern. For instance,</source>
          <target state="translated">Подобно подписям на привязках на уровне значений,подписи синонимов шаблонов могут применяться к более чем одному шаблону.Например,</target>
        </trans-unit>
        <trans-unit id="7774d2f3942adcf9419122bc33bb2393a5f13dbf" translate="yes" xml:space="preserve">
          <source>Just like the other types of plugins, you can write &lt;code&gt;DynFlags&lt;/code&gt; plugins that can take and make use of some options that you can then specify using the &lt;code&gt;-fplugin-opt&lt;/code&gt; flag. In the &lt;code&gt;DynFlagsPlugin&lt;/code&gt; code from above, the said options would be available in the &lt;code&gt;opts&lt;/code&gt; argument of &lt;code&gt;hooksP&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985acf2ff25e349dcabef121160378e3f752037f" translate="yes" xml:space="preserve">
          <source>Just like unsafePerformIO, but we inline it. Big performance gains as it exposes lots of things to further inlining. &lt;em&gt;Very unsafe&lt;/em&gt;. In particular, you should do no memory allocation inside an &lt;code&gt;&lt;a href=&quot;data-text-internal-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; block. On Hugs this is just &lt;code&gt;unsafePerformIO&lt;/code&gt;.</source>
          <target state="translated">Как и unsafePerformIO, но мы его встроили. Значительный прирост производительности, поскольку он открывает множество возможностей для дальнейшего встраивания. &lt;em&gt;Очень небезопасно&lt;/em&gt; . В частности, вы не должны выделять память внутри блока &lt;code&gt;&lt;a href=&quot;data-text-internal-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; . На Hugs это просто &lt;code&gt;unsafePerformIO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fe74271062cab89acca9c50f817b98e381da7a1" translate="yes" xml:space="preserve">
          <source>Just like unsafePerformIO, but we inline it. Big performance gains as it exposes lots of things to further inlining. &lt;em&gt;Very unsafe&lt;/em&gt;. In particular, you should do no memory allocation inside an &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; block. On Hugs this is just &lt;code&gt;unsafePerformIO&lt;/code&gt;.</source>
          <target state="translated">Как и unsafePerformIO, но мы его встроили. Значительный прирост производительности, поскольку он открывает множество возможностей для дальнейшего встраивания. &lt;em&gt;Очень небезопасно&lt;/em&gt; . В частности, вы не должны выделять память внутри блока &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; . На Hugs это просто &lt;code&gt;unsafePerformIO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a6159003781d783ae2d3e51421957681ceabbb1" translate="yes" xml:space="preserve">
          <source>Just x =&amp;gt; creates the file with the given modes, Nothing =&amp;gt; the file must exist.</source>
          <target state="translated">Просто x =&amp;gt; создает файл с заданными режимами, Nothing =&amp;gt; файл должен существовать.</target>
        </trans-unit>
        <trans-unit id="7d2a7bff0abb0d0de4946434ea191a1498465dec" translate="yes" xml:space="preserve">
          <source>Justification</source>
          <target state="translated">Justification</target>
        </trans-unit>
        <trans-unit id="f0cab9d2f956f8044d800c15b8fc3a101bddd6b9" translate="yes" xml:space="preserve">
          <source>K1</source>
          <target state="translated">K1</target>
        </trans-unit>
        <trans-unit id="8db55d0eb9679e9399434774b00bd1464da87b23" translate="yes" xml:space="preserve">
          <source>KProxy</source>
          <target state="translated">KProxy</target>
        </trans-unit>
        <trans-unit id="39150f84927b15fbfb438bdbe30c28313b7dab8c" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.hc&lt;/code&gt; files when doing &lt;code&gt;.hs&lt;/code&gt;-to-&lt;code&gt;.o&lt;/code&gt; compilations via &lt;a href=&quot;codegens#c-code-gen&quot;&gt;C&lt;/a&gt; (Note: &lt;code&gt;.hc&lt;/code&gt; files are only generated by &lt;a href=&quot;codegens#unreg&quot;&gt;unregisterised&lt;/a&gt; compilers).</source>
          <target state="translated">Сохраняйте промежуточные файлы &lt;code&gt;.hc&lt;/code&gt; при компиляции &lt;code&gt;.hs&lt;/code&gt; -to- &lt;code&gt;.o&lt;/code&gt; через &lt;a href=&quot;codegens#c-code-gen&quot;&gt;C&lt;/a&gt; (Примечание: файлы &lt;code&gt;.hc&lt;/code&gt; генерируются только &lt;a href=&quot;codegens#unreg&quot;&gt;незарегистрированными&lt;/a&gt; компиляторами).</target>
        </trans-unit>
        <trans-unit id="0e96ed700c728faa5ce093e2ef58af4b206c758f" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.hi&lt;/code&gt; files. This is the default. You may use &lt;code&gt;-no-keep-hi-files&lt;/code&gt; if you are not interested in the &lt;code&gt;.hi&lt;/code&gt; files.</source>
          <target state="translated">Храните промежуточные файлы &lt;code&gt;.hi&lt;/code&gt; . Это значение по умолчанию. Вы можете использовать &lt;code&gt;-no-keep-hi-files&lt;/code&gt; , если вас не интересуют файлы &lt;code&gt;.hi&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65a6fabb3b1fdedf128544cf6e03be19810249f5" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.ll&lt;/code&gt; files when doing &lt;code&gt;.hs&lt;/code&gt;-to-&lt;code&gt;.o&lt;/code&gt; compilations via &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM&lt;/a&gt; (Note: &lt;code&gt;.ll&lt;/code&gt; files aren&amp;rsquo;t generated when using the native code generator, you may need to use &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt; to force them to be produced).</source>
          <target state="translated">Сохраняйте промежуточные файлы &lt;code&gt;.ll&lt;/code&gt; при выполнении &lt;code&gt;.hs&lt;/code&gt; -to- &lt;code&gt;.o&lt;/code&gt; через &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM&lt;/a&gt; (Примечание: файлы &lt;code&gt;.ll&lt;/code&gt; не генерируются при использовании генератора &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt; кода, вам может потребоваться использовать -fllvm для их создания ).</target>
        </trans-unit>
        <trans-unit id="bb4eaab08ea50b174cad4a0dcbfee09ebe256732" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.o&lt;/code&gt; files. This is the default. You may use &lt;code&gt;-no-keep-o-files&lt;/code&gt; if you are not interested in the &lt;code&gt;.o&lt;/code&gt; files.</source>
          <target state="translated">Храните промежуточные файлы &lt;code&gt;.o&lt;/code&gt; . Это значение по умолчанию. Вы можете использовать &lt;code&gt;-no-keep-o-files&lt;/code&gt; , если вас не интересуют файлы &lt;code&gt;.o&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8891247972e540d00a82a48db690001e72e39435" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.s&lt;/code&gt; files.</source>
          <target state="translated">Храните промежуточные файлы &lt;code&gt;.s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="618d7b66d0a5da454a76c61a106bbc8b386980c1" translate="yes" xml:space="preserve">
          <source>Keep only the groups in which at least one of the classes is an &lt;strong&gt;interactive class&lt;/strong&gt; (defined below).</source>
          <target state="translated">Оставьте только те группы, в которых хотя бы один из классов является &lt;strong&gt;интерактивным классом&lt;/strong&gt; (определенным ниже).</target>
        </trans-unit>
        <trans-unit id="db48f9adf54739f6c307652ccc128abe44ee55b6" translate="yes" xml:space="preserve">
          <source>Keep the output of the &lt;code&gt;CPP&lt;/code&gt; pre-processor phase as &lt;code&gt;.hscpp&lt;/code&gt; files. A &lt;code&gt;.hscpp&lt;/code&gt; file is only created, if a module gets compiled and uses the C pre-processor.</source>
          <target state="translated">Сохраните вывод фазы &lt;code&gt;.hscpp&lt;/code&gt; &lt;code&gt;CPP&lt;/code&gt; в виде файлов .hscpp . &lt;code&gt;.hscpp&lt;/code&gt; файл создается только, если модуль компилируется и использует C препроцессор.</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="45185a850411c05190d8644455ed7e28be79f32f" translate="yes" xml:space="preserve">
          <source>Key arguments are evaluated to WHNF</source>
          <target state="translated">Ключевые аргументы оцениваются для WHNF</target>
        </trans-unit>
        <trans-unit id="108b398a8a710d3b21b74c853623729fec5c66a8" translate="yes" xml:space="preserve">
          <source>KeyboardInterrupts</source>
          <target state="translated">KeyboardInterrupts</target>
        </trans-unit>
        <trans-unit id="7b932e7704c56ac279074adf9cbeed98bb90a289" translate="yes" xml:space="preserve">
          <source>Kill</source>
          <target state="translated">Kill</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="f6f11ccdb22e9dbd420ca8b73fb865e1a73beb02" translate="yes" xml:space="preserve">
          <source>Kind heterogeneous propositional equality. Like &lt;code&gt;&lt;a href=&quot;data-type-equality#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;a :~~: b&lt;/code&gt; is inhabited by a terminating value if and only if &lt;code&gt;a&lt;/code&gt; is the same type as &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Доброе разнородное пропозициональное равенство. Как &lt;code&gt;&lt;a href=&quot;data-type-equality#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;a :~~: b&lt;/code&gt; населен значением оконечного тогда и только тогда , когда имеет тот же тип , как &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9add9e559da1de515054945468cae650868cb37" translate="yes" xml:space="preserve">
          <source>Kind heterogeneous propositional equality. Like &lt;code&gt;&lt;a href=&quot;data-typeable#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;a :~~: b&lt;/code&gt; is inhabited by a terminating value if and only if &lt;code&gt;a&lt;/code&gt; is the same type as &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Доброе разнородное пропозициональное равенство. Как &lt;code&gt;&lt;a href=&quot;data-typeable#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;a :~~: b&lt;/code&gt; населен значением оконечного тогда и только тогда , когда имеет тот же тип , как &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b9fefce453a09c064d0416bf50a8fdee9b8f03a" translate="yes" xml:space="preserve">
          <source>Kind heterogeneous propositional equality. Like &lt;code&gt;&lt;a href=&quot;type-reflection#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;a :~~: b&lt;/code&gt; is inhabited by a terminating value if and only if &lt;code&gt;a&lt;/code&gt; is the same type as &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Доброе разнородное пропозициональное равенство. Как &lt;code&gt;&lt;a href=&quot;type-reflection#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;a :~~: b&lt;/code&gt; населен значением оконечного тогда и только тогда , когда имеет тот же тип , как &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e2202b3014628a192e63059a442e7689aab808a" translate="yes" xml:space="preserve">
          <source>Kind of filling or padding to be done.</source>
          <target state="translated">Вроде как заполнение или набивка.</target>
        </trans-unit>
        <trans-unit id="15d871de56a82992077494c7e2360de27a218760" translate="yes" xml:space="preserve">
          <source>Kind representations</source>
          <target state="translated">Добрые представления</target>
        </trans-unit>
        <trans-unit id="cc4cf8a32a2bc0862e7d482199843cd1ee70873c" translate="yes" xml:space="preserve">
          <source>Kind variables can also be quantified in &lt;em&gt;visible&lt;/em&gt; positions. Consider the following two examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0a4407d441254c502eba426c88d24ec2721a6ab" translate="yes" xml:space="preserve">
          <source>Kind-equalities cannot be deferred, e.g.</source>
          <target state="translated">Добропорядочность не может быть отложена,например.</target>
        </trans-unit>
        <trans-unit id="db7f1b7b324213bc7b9a60bf048eeec0dafa8a82" translate="yes" xml:space="preserve">
          <source>KindQ</source>
          <target state="translated">KindQ</target>
        </trans-unit>
        <trans-unit id="a0e1adf2caacb11f0a7f30552166686185a261b9" translate="yes" xml:space="preserve">
          <source>KindRep</source>
          <target state="translated">KindRep</target>
        </trans-unit>
        <trans-unit id="c53c4c21817ef2a1d4f60e2cceae1eb6be52eda4" translate="yes" xml:space="preserve">
          <source>KindSignatures</source>
          <target state="translated">KindSignatures</target>
        </trans-unit>
        <trans-unit id="1f207bb143ebf53a96f07da496ea625fd1ed3952" translate="yes" xml:space="preserve">
          <source>Kinds</source>
          <target state="translated">Kinds</target>
        </trans-unit>
        <trans-unit id="a4c865932a7f3d9b055f979bca5ede567a926edc" translate="yes" xml:space="preserve">
          <source>Kleisli</source>
          <target state="translated">Kleisli</target>
        </trans-unit>
        <trans-unit id="e841df54a07c5f2cc9b5f9af566dd4e754d4d096" translate="yes" xml:space="preserve">
          <source>Kleisli arrows of a monad.</source>
          <target state="translated">Клейсли стрелы монады.</target>
        </trans-unit>
        <trans-unit id="a5a5fafee83492d8b176cbbdd5bb0860a6fdbf28" translate="yes" xml:space="preserve">
          <source>Known limitations:</source>
          <target state="translated">Известные ограничения:</target>
        </trans-unit>
        <trans-unit id="5d7d25439595bfc8d329c71ca182a7c6823088b5" translate="yes" xml:space="preserve">
          <source>KnownNat</source>
          <target state="translated">KnownNat</target>
        </trans-unit>
        <trans-unit id="c37bbcaa811caf4684344786df42286e08100459" translate="yes" xml:space="preserve">
          <source>KnownSymbol</source>
          <target state="translated">KnownSymbol</target>
        </trans-unit>
        <trans-unit id="1bafcba98aca5f350dc05c967f514185665ef856" translate="yes" xml:space="preserve">
          <source>LANGID</source>
          <target state="translated">LANGID</target>
        </trans-unit>
        <trans-unit id="84f34581093e5397ee10c973d3f1265b05c1f6db" translate="yes" xml:space="preserve">
          <source>LARGE_INTEGER</source>
          <target state="translated">LARGE_INTEGER</target>
        </trans-unit>
        <trans-unit id="bf87bea3a535f56ac91a5de66d6b55f69d98184f" translate="yes" xml:space="preserve">
          <source>LCID</source>
          <target state="translated">LCID</target>
        </trans-unit>
        <trans-unit id="0beee13d31c1e3c6098692c8568c5506cfa9174d" translate="yes" xml:space="preserve">
          <source>LCMapFlags</source>
          <target state="translated">LCMapFlags</target>
        </trans-unit>
        <trans-unit id="336b811f9fed9547f7ebf0e4f1880cbb455180ca" translate="yes" xml:space="preserve">
          <source>LCTYPE</source>
          <target state="translated">LCTYPE</target>
        </trans-unit>
        <trans-unit id="52c2e43c2456d90f37c50642076b0af5566ae13a" translate="yes" xml:space="preserve">
          <source>LEFTWARDS ARROW</source>
          <target state="translated">СТРЕЛКА ВЛЕВО</target>
        </trans-unit>
        <trans-unit id="cecc3c11891d7815b56633d3559be2f6608334e9" translate="yes" xml:space="preserve">
          <source>LEFTWARDS ARROW-TAIL</source>
          <target state="translated">ЛЕВЫЙ ХВОСТ</target>
        </trans-unit>
        <trans-unit id="16577c79334aa225051280c5bb84f84cce0e4ae6" translate="yes" xml:space="preserve">
          <source>LEFTWARDS DOUBLE ARROW-TAIL</source>
          <target state="translated">ЛЕВЫЙ ДВОЙНОЙ СТРЕЛОВИДНЫЙ ХВОСТ</target>
        </trans-unit>
        <trans-unit id="91a07087a57580c557f3a426586f0c2f60ef2af4" translate="yes" xml:space="preserve">
          <source>LF</source>
          <target state="translated">LF</target>
        </trans-unit>
        <trans-unit id="7526c6cf5f75ab344e0a9b50d84724f46ba01601" translate="yes" xml:space="preserve">
          <source>LHANDLE</source>
          <target state="translated">LHANDLE</target>
        </trans-unit>
        <trans-unit id="a85510722a0e3f63597435d302fceae090486b57" translate="yes" xml:space="preserve">
          <source>LLVM code from the &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM code generator&lt;/a&gt;</source>
          <target state="translated">Код LLVM из &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;генератора кода LLVM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e71dc1792dc3123b5a369dd038b6e7cc64277908" translate="yes" xml:space="preserve">
          <source>LLVM code generator</source>
          <target state="translated">генератор LLVM-кодов</target>
        </trans-unit>
        <trans-unit id="a4ab30ac59152c7cdac425098a0e91bddb57dee0" translate="yes" xml:space="preserve">
          <source>LONG</source>
          <target state="translated">LONG</target>
        </trans-unit>
        <trans-unit id="ec5d37add4b689af044ac3c5bffa9caeddd4928a" translate="yes" xml:space="preserve">
          <source>LONG32</source>
          <target state="translated">LONG32</target>
        </trans-unit>
        <trans-unit id="4d839d00f90159ea1c7a2cce620daacfba69bfe0" translate="yes" xml:space="preserve">
          <source>LONG64</source>
          <target state="translated">LONG64</target>
        </trans-unit>
        <trans-unit id="30573aefe36d3bba7516573e936a54b9886f4531" translate="yes" xml:space="preserve">
          <source>LONG_PTR</source>
          <target state="translated">LONG_PTR</target>
        </trans-unit>
        <trans-unit id="6799d635b5e2816633a1eee1011aa42c6900072f" translate="yes" xml:space="preserve">
          <source>LPARAM</source>
          <target state="translated">LPARAM</target>
        </trans-unit>
        <trans-unit id="e191267d6636b8d8dd17922a36f5d83423ca186f" translate="yes" xml:space="preserve">
          <source>LPBOOL</source>
          <target state="translated">LPBOOL</target>
        </trans-unit>
        <trans-unit id="b0179249b725b53a04310f204589b18a9f487e9a" translate="yes" xml:space="preserve">
          <source>LPBYTE</source>
          <target state="translated">LPBYTE</target>
        </trans-unit>
        <trans-unit id="1aa1c9f4c10c1f10229a085be9fe5e8d772815c4" translate="yes" xml:space="preserve">
          <source>LPCSTR</source>
          <target state="translated">LPCSTR</target>
        </trans-unit>
        <trans-unit id="e741ece1418d5a115d62b99230ca71d3efe4070d" translate="yes" xml:space="preserve">
          <source>LPCTSTR</source>
          <target state="translated">LPCTSTR</target>
        </trans-unit>
        <trans-unit id="172c9c6bdd05170cc78b4016e92a18b0ce371012" translate="yes" xml:space="preserve">
          <source>LPCTSTR_</source>
          <target state="translated">LPCTSTR_</target>
        </trans-unit>
        <trans-unit id="77d43834b2e69f339ace63bdd9b49fba118491ec" translate="yes" xml:space="preserve">
          <source>LPCWSTR</source>
          <target state="translated">LPCWSTR</target>
        </trans-unit>
        <trans-unit id="eacdfe1b863de52295f8ed9111840c8b69de1d8a" translate="yes" xml:space="preserve">
          <source>LPDWORD</source>
          <target state="translated">LPDWORD</target>
        </trans-unit>
        <trans-unit id="f5d63f9a27fa44191677aa464c55c7503eba938c" translate="yes" xml:space="preserve">
          <source>LPINPUT</source>
          <target state="translated">LPINPUT</target>
        </trans-unit>
        <trans-unit id="d255c79116e40dec5d46ebe0b88ddcd312799e9a" translate="yes" xml:space="preserve">
          <source>LPMSG</source>
          <target state="translated">LPMSG</target>
        </trans-unit>
        <trans-unit id="4ade22c4abe03e351c322f7d46f37b350a895c69" translate="yes" xml:space="preserve">
          <source>LPOSVERSIONINFOEX</source>
          <target state="translated">LPOSVERSIONINFOEX</target>
        </trans-unit>
        <trans-unit id="59d6e50d1a4f36a9203f0cbba59c865419b38b5b" translate="yes" xml:space="preserve">
          <source>LPOVERLAPPED</source>
          <target state="translated">LPOVERLAPPED</target>
        </trans-unit>
        <trans-unit id="be649aa6e2e33d351a5bab4d706cca9fa800ea52" translate="yes" xml:space="preserve">
          <source>LPPAINTSTRUCT</source>
          <target state="translated">LPPAINTSTRUCT</target>
        </trans-unit>
        <trans-unit id="67257cfd99d80a2df705d6b562a4f33f6da4eef6" translate="yes" xml:space="preserve">
          <source>LPSECURITY_ATTRIBUTES</source>
          <target state="translated">LPSECURITY_ATTRIBUTES</target>
        </trans-unit>
        <trans-unit id="89625841cf8382a8b7cbfb91a1aa9825d588e589" translate="yes" xml:space="preserve">
          <source>LPSTR</source>
          <target state="translated">LPSTR</target>
        </trans-unit>
        <trans-unit id="4bf9ddc5d3aca695589c5b07f3bbfd2293289ee7" translate="yes" xml:space="preserve">
          <source>LPTSTR</source>
          <target state="translated">LPTSTR</target>
        </trans-unit>
        <trans-unit id="f34c393d2b1c91567364523f1ab42c92643afd25" translate="yes" xml:space="preserve">
          <source>LPVOID</source>
          <target state="translated">LPVOID</target>
        </trans-unit>
        <trans-unit id="df97686e2eaf116cd4616939d89f5db838713001" translate="yes" xml:space="preserve">
          <source>LPWSTR</source>
          <target state="translated">LPWSTR</target>
        </trans-unit>
        <trans-unit id="c9907d8861344b17d44c4f103abf75a9157959d9" translate="yes" xml:space="preserve">
          <source>LRESULT</source>
          <target state="translated">LRESULT</target>
        </trans-unit>
        <trans-unit id="6c62fb7313eb9d28efbca3e61ff13801b5b45a0a" translate="yes" xml:space="preserve">
          <source>LT</source>
          <target state="translated">LT</target>
        </trans-unit>
        <trans-unit id="e069a75ab11debd5703606dcab59ec2fb4d96109" translate="yes" xml:space="preserve">
          <source>Label a decoder. If the decoder fails, the label will be appended on a new line to the error message string.</source>
          <target state="translated">Пометь декодер.Если декодер выйдет из строя,метка будет добавлена в новой строке к строке сообщения об ошибке.</target>
        </trans-unit>
        <trans-unit id="600b10a6ff2b2b4798fef332e1c46bd3ff40864f" translate="yes" xml:space="preserve">
          <source>Labelling trees</source>
          <target state="translated">Маркировка деревьев</target>
        </trans-unit>
        <trans-unit id="bd0e2f60f3cab26b9d1a005d3e6df03ee775b43b" translate="yes" xml:space="preserve">
          <source>LambdaCase</source>
          <target state="translated">LambdaCase</target>
        </trans-unit>
        <trans-unit id="f8ba7082b851540c52b04047ac4c6d27074d828b" translate="yes" xml:space="preserve">
          <source>LangAsm</source>
          <target state="translated">LangAsm</target>
        </trans-unit>
        <trans-unit id="e29d0e2e40cfc7d4080b46c4ed09bd1426b13ae6" translate="yes" xml:space="preserve">
          <source>LangC</source>
          <target state="translated">LangC</target>
        </trans-unit>
        <trans-unit id="6f9fe5d064c62dd571d1cd25ae70836c15d42666" translate="yes" xml:space="preserve">
          <source>LangCxx</source>
          <target state="translated">LangCxx</target>
        </trans-unit>
        <trans-unit id="b36e168343c5d8ff6e8b16848d95a785e3e4e206" translate="yes" xml:space="preserve">
          <source>LangObjc</source>
          <target state="translated">LangObjc</target>
        </trans-unit>
        <trans-unit id="8f6e55899c5e99e242135ff6cf8c727ef909dd4c" translate="yes" xml:space="preserve">
          <source>LangObjcxx</source>
          <target state="translated">LangObjcxx</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="e3818c797711a3ca9b496a8bf021d70184059791" translate="yes" xml:space="preserve">
          <source>Language extension lookup</source>
          <target state="translated">Поиск языковых расширений</target>
        </trans-unit>
        <trans-unit id="819f46032d151fbc83b888fce06e8becbc1ba90d" translate="yes" xml:space="preserve">
          <source>Language extensions</source>
          <target state="translated">Расширения языка</target>
        </trans-unit>
        <trans-unit id="05b5ef0d2efbebac38a6a109039519a6c3f95008" translate="yes" xml:space="preserve">
          <source>Language extensions known to GHC</source>
          <target state="translated">Языковые расширения,известные GHC</target>
        </trans-unit>
        <trans-unit id="b132eded8d0dc30dbe1263774537feb48884f8fb" translate="yes" xml:space="preserve">
          <source>Language options can be controlled in two ways:</source>
          <target state="translated">Языковыми параметрами можно управлять двумя способами:</target>
        </trans-unit>
        <trans-unit id="6bd1a5ed914255da4f2e3d146728cb1407c73dac" translate="yes" xml:space="preserve">
          <source>Language options can be enabled either by a command-line option &lt;code&gt;-Xblah&lt;/code&gt;, or by a &lt;code&gt;{-# LANGUAGE blah #-}&lt;/code&gt; pragma in the file itself. See &lt;a href=&quot;glasgow_exts#options-language&quot;&gt;Language options&lt;/a&gt;.</source>
          <target state="translated">Языковые параметры можно включить либо параметром командной строки &lt;code&gt;-Xblah&lt;/code&gt; , либо прагмой &lt;code&gt;{-# LANGUAGE blah #-}&lt;/code&gt; в самом файле. См. &lt;a href=&quot;glasgow_exts#options-language&quot;&gt;Параметры языка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb129676df1e2ca9487a872968ddcafe0d9dd6a9" translate="yes" xml:space="preserve">
          <source>Language options recognised by Cabal can also be enabled using the &lt;code&gt;LANGUAGE&lt;/code&gt; pragma, thus &lt;code&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/code&gt; (see &lt;a href=&quot;#language-pragma&quot;&gt;LANGUAGE pragma&lt;/a&gt;).</source>
          <target state="translated">Параметры языка, распознаваемые Cabal, также можно включить с помощью прагмы &lt;code&gt;LANGUAGE&lt;/code&gt; , таким образом, &lt;code&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/code&gt; (см. &lt;a href=&quot;#language-pragma&quot;&gt;Прагму LANGUAGE&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4303cd5d535fbb5d0b9f4d30dd7adce7e5ce6778" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH</source>
          <target state="translated">Language.Haskell.TH</target>
        </trans-unit>
        <trans-unit id="de2ab3d572f18c64ff1f3f745dbafb85fc36b86d" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.LanguageExtensions</source>
          <target state="translated">Language.Haskell.TH.LanguageExtensions</target>
        </trans-unit>
        <trans-unit id="a536fc0da9feb311a1888ebea07a6df0b1199739" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Lib.Internal</source>
          <target state="translated">Language.Haskell.TH.Lib.Internal</target>
        </trans-unit>
        <trans-unit id="625f2edd5986bf5aa6e47f4476741a674b3ee730" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Lib.Internal exposes some additional functionality that is used internally in GHC's integration with Template Haskell. This is not a part of the public API, and as such, there are no API guarantees for this module from version to version.</source>
          <target state="translated">Language.Haskell.TH.Lib.Internal раскрывает некоторые дополнительные функциональные возможности,которые используются внутри GHC при интеграции с Template Haskell.Это не является частью публичного API,и поэтому нет никаких гарантий API для этого модуля от версии к версии.</target>
        </trans-unit>
        <trans-unit id="1c03c9aef7745ac205e3905894725dfd28c07640" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Ppr</source>
          <target state="translated">Language.Haskell.TH.Ppr</target>
        </trans-unit>
        <trans-unit id="d5b1913241bcbf67ca726f074016aeb992ec6064" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.PprLib</source>
          <target state="translated">Language.Haskell.TH.PprLib</target>
        </trans-unit>
        <trans-unit id="beacda45774b21626492b1c3c45cdfb6c502fea0" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Quote</source>
          <target state="translated">Language.Haskell.TH.Quote</target>
        </trans-unit>
        <trans-unit id="2af0f0aebf13fc8e5f915b22fc1832e251d01c0b" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Syntax</source>
          <target state="translated">Language.Haskell.TH.Syntax</target>
        </trans-unit>
        <trans-unit id="2c4c7d3c26eea5a437b10f135bd656f51fe7182c" translate="yes" xml:space="preserve">
          <source>LanguageDef</source>
          <target state="translated">LanguageDef</target>
        </trans-unit>
        <trans-unit id="8d5e1a74eb773e87b48d793c077afcf2cd4b9d8a" translate="yes" xml:space="preserve">
          <source>Large objects are not allocated from the normal allocation area set by the &lt;code&gt;-A&lt;/code&gt; flag, which is why there is a separate limit for these. Large objects tend to be much rarer than small objects, so most programs hit the &lt;code&gt;-A&lt;/code&gt; limit before the &lt;code&gt;-AL&lt;/code&gt; limit. However, the &lt;code&gt;-A&lt;/code&gt; limit is per-capability, whereas the &lt;code&gt;-AL&lt;/code&gt; limit is global, so as &lt;code&gt;-N&lt;/code&gt; gets larger it becomes more likely that we hit the &lt;code&gt;-AL&lt;/code&gt; limit first. To counteract this, it might be necessary to use a larger &lt;code&gt;-AL&lt;/code&gt; limit when using a large &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">Большие объекты не выделяются из обычной области выделения, установленной флагом &lt;code&gt;-A&lt;/code&gt; , поэтому для них существует отдельный предел. Большие объекты, как правило, встречаются намного реже, чем маленькие, поэтому большинство программ &lt;code&gt;-AL&lt;/code&gt; предела &lt;code&gt;-A&lt;/code&gt; до предела -AL . Однако ограничение &lt;code&gt;-A&lt;/code&gt; является ограничением для каждой возможности, тогда как ограничение &lt;code&gt;-AL&lt;/code&gt; является глобальным, поэтому, когда &lt;code&gt;-N&lt;/code&gt; становится больше, становится более вероятным, что мы &lt;code&gt;-AL&lt;/code&gt; ограничения -AL . Чтобы противодействовать этому, может потребоваться использовать больший предел &lt;code&gt;-AL&lt;/code&gt; при использовании большого &lt;code&gt;-N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1c69a859a9638b242f2dabf8acf1c0b1450ce6b" translate="yes" xml:space="preserve">
          <source>Last</source>
          <target state="translated">Last</target>
        </trans-unit>
        <trans-unit id="036fd8195c1bacf1837b14eef6243e90d12eeff8" translate="yes" xml:space="preserve">
          <source>Lastly come the normal type variables of a declaration.</source>
          <target state="translated">Наконец,приходят переменные нормального типа декларации.</target>
        </trans-unit>
        <trans-unit id="96565d42beb23b9f18b0c44cb990adddfa8c6c5e" translate="yes" xml:space="preserve">
          <source>Lastly, all of this applies only for classes other than &lt;code&gt;Read&lt;/code&gt;, &lt;code&gt;Show&lt;/code&gt;, &lt;code&gt;Typeable&lt;/code&gt;, and &lt;code&gt;Data&lt;/code&gt;, for which the stock derivation applies (section 4.3.3. of the Haskell Report). (For the standard classes &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, and &lt;code&gt;Bounded&lt;/code&gt; it is immaterial whether the stock method is used or the one described here.)</source>
          <target state="translated">Наконец, все это применимо только к классам, отличным от &lt;code&gt;Read&lt;/code&gt; , &lt;code&gt;Show&lt;/code&gt; , &lt;code&gt;Typeable&lt;/code&gt; и &lt;code&gt;Data&lt;/code&gt; , для которых применяется производная от акций (раздел 4.3.3. Отчета Haskell). (Для стандартных классов &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Ix&lt;/code&gt; и &lt;code&gt;Bounded&lt;/code&gt; не имеет значения, используется ли метод акций или метод, описанный здесь.)</target>
        </trans-unit>
        <trans-unit id="7a81fbeb8d54ada80dba09a4fc21a3129bfb1430" translate="yes" xml:space="preserve">
          <source>Laws:</source>
          <target state="translated">Laws:</target>
        </trans-unit>
        <trans-unit id="0f509e179cc1a0fe8f803e98982287db8fe059d4" translate="yes" xml:space="preserve">
          <source>Layout fields are then overlapped so that the final layout will be as compact as possible. For example, suppose we have the unboxed sum:</source>
          <target state="translated">Затем поля макета накладываются друг на друга,чтобы окончательная компоновка была как можно более компактной.Например,предположим,что у нас есть сумма без коробки:</target>
        </trans-unit>
        <trans-unit id="cb90f09d6abe9a4f5536f00172206430dfc1fd65" translate="yes" xml:space="preserve">
          <source>Layout with multi-way if works in the same way as other layout contexts, except that the semi-colons between guards in a multi-way if are optional. So it is not necessary to line up all the guards at the same column; this is consistent with the way guards work in function definitions and case expressions.</source>
          <target state="translated">Макет с многопутевой раскладкой,если работает так же,как и в других контекстах раскладки,за исключением того,что полуколонки между охранниками в многопутевой раскладке,если они являются необязательными.Таким образом,не обязательно выстраивать всех охранников в один столбец;это согласуется с тем,как охранники работают в определениях функций и выражениях регистра.</target>
        </trans-unit>
        <trans-unit id="cb0824cf9ff62297df30a510f886637077aac5e0" translate="yes" xml:space="preserve">
          <source>Lazily read all user input on &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; as a single string.</source>
          <target state="translated">Лениво читайте весь пользовательский ввод на &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; как одну строку.</target>
        </trans-unit>
        <trans-unit id="740345f4fc26eb7795ac98f172dc650babd2bee4" translate="yes" xml:space="preserve">
          <source>Lazily read the remaining contents of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; will be closed after the read completes, or on error.</source>
          <target state="translated">Лениво прочитать оставшееся содержимое &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; будет закрыта после Завершает чтения, или по ошибке.</target>
        </trans-unit>
        <trans-unit id="9133c4ce416a587d4206249b3ec0be18933d85ff" translate="yes" xml:space="preserve">
          <source>Lazily serialise a value to a file.</source>
          <target state="translated">Лениво сериализовать значение в файл.</target>
        </trans-unit>
        <trans-unit id="8e4c4b8d6f447284862f49f3045c8dc03eb992a3" translate="yes" xml:space="preserve">
          <source>Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to use as the tail of the generated lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; для использования в качестве хвоста сгенерированной lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2200f814b893336b40ddd029ac88811c89cd6469" translate="yes" xml:space="preserve">
          <source>Lazy I/O throws an exception if an error is encountered, in contrast to the Haskell 98 spec which requires that errors are discarded (see Section 21.2.2 of the Haskell 98 report). The exception thrown is the usual IO exception that would be thrown if the failing IO operation was performed in the IO monad, and can be caught by &lt;code&gt;System.IO.Error.catch&lt;/code&gt; or &lt;code&gt;Control.Exception.catch&lt;/code&gt;.</source>
          <target state="translated">Ленивый ввод-вывод генерирует исключение, если обнаруживается ошибка, в отличие от спецификации Haskell 98, которая требует, чтобы ошибки отбрасывались (см. Раздел 21.2.2 отчета Haskell 98). Вызываемое исключение - это обычное исключение ввода-вывода, которое будет выдано, если неудачная операция ввода-вывода была выполнена в монаде ввода-вывода, и может быть &lt;code&gt;System.IO.Error.catch&lt;/code&gt; или &lt;code&gt;Control.Exception.catch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0dc8a7617416cac1adb37dc18ef37fe1492d919f" translate="yes" xml:space="preserve">
          <source>Lazy RWS monad.</source>
          <target state="translated">Ленивая RWS монада.</target>
        </trans-unit>
        <trans-unit id="4e7f54740d38945be5cd4b244d5c2c47d033b6be" translate="yes" xml:space="preserve">
          <source>Lazy Reader-writer-state monads</source>
          <target state="translated">Ленивые Монады Читатель-Писатель-Государство</target>
        </trans-unit>
        <trans-unit id="eb43f112ea276b50bd6b9f699aa36231d04bac2f" translate="yes" xml:space="preserve">
          <source>Lazy state monads, passing an updatable state through a computation. See below for examples.</source>
          <target state="translated">Ленивые монады состояния,переходящие в обновляемое состояние через вычисления.См.примеры ниже.</target>
        </trans-unit>
        <trans-unit id="556c668dfd9b10659aee0887aa651ecc4197ef61" translate="yes" xml:space="preserve">
          <source>Lazy state monads.</source>
          <target state="translated">Ленивые государственные монады.</target>
        </trans-unit>
        <trans-unit id="d6e57ca0c7140fb8eaf2002ba63c8930d28ffe8d" translate="yes" xml:space="preserve">
          <source>Lazy writer monads.</source>
          <target state="translated">Ленивые писательские монады.</target>
        </trans-unit>
        <trans-unit id="0f8c868597dc0fe23d3aa967985ce4e3dd234ee3" translate="yes" xml:space="preserve">
          <source>LeapSecondMap</source>
          <target state="translated">LeapSecondMap</target>
        </trans-unit>
        <trans-unit id="6d9694ab87c1509816fc3f073364a45eed8143dd" translate="yes" xml:space="preserve">
          <source>Left associative monadic bifold over a structure.</source>
          <target state="translated">Левая ассоциативная монадальная бифолда над структурой.</target>
        </trans-unit>
        <trans-unit id="9113429feae9435bc9a22b91fdadcab770bb70b5" translate="yes" xml:space="preserve">
          <source>Left identity</source>
          <target state="translated">Левая личность</target>
        </trans-unit>
        <trans-unit id="888262dff4e29ba66957e08ae5e7c00c8ddb1ac9" translate="yes" xml:space="preserve">
          <source>Left shrinking (or Tightening)</source>
          <target state="translated">Сжатие влево (или затягивание)</target>
        </trans-unit>
        <trans-unit id="43b09cf749eb5491b74e53f1bc09fa04659674f0" translate="yes" xml:space="preserve">
          <source>Left-associative fold of a structure but with strict application of the operator.</source>
          <target state="translated">Лево-ассоциативная складка структуры,но со строгим применением оператора.</target>
        </trans-unit>
        <trans-unit id="2e864825085ba6b285b3deb3c0b79e4d521a8979" translate="yes" xml:space="preserve">
          <source>Left-associative fold of a structure.</source>
          <target state="translated">Лево-ассоциативная складка структуры.</target>
        </trans-unit>
        <trans-unit id="3c1c012fb20a62b44c7c2d747a91757337b12110" translate="yes" xml:space="preserve">
          <source>Left-associative fold operation for constructor applications.</source>
          <target state="translated">Управление лево-ассоциативной складкой для применения в конструкторах.</target>
        </trans-unit>
        <trans-unit id="771b2d8147f59a5691eb79cad7d5c64627dab857" translate="yes" xml:space="preserve">
          <source>Left-to-right composition</source>
          <target state="translated">лево-правая композиция</target>
        </trans-unit>
        <trans-unit id="c2371e24467463447fab51b81ef30f6f1fa7acf3" translate="yes" xml:space="preserve">
          <source>Left-to-right composition of Kleisli arrows.</source>
          <target state="translated">Лево-правая композиция из стрел Клейсли.</target>
        </trans-unit>
        <trans-unit id="b396eca23f1092998983c79f8de12421ce4d07d7" translate="yes" xml:space="preserve">
          <source>LeftAdjust</source>
          <target state="translated">LeftAdjust</target>
        </trans-unit>
        <trans-unit id="6f12db94ca14c410ee6aea9aaf9f37f142111790" translate="yes" xml:space="preserve">
          <source>LeftAssociative</source>
          <target state="translated">LeftAssociative</target>
        </trans-unit>
        <trans-unit id="0b5d32fdd51149a3a9a8927f5a4932ddaa322146" translate="yes" xml:space="preserve">
          <source>LeftMode</source>
          <target state="translated">LeftMode</target>
        </trans-unit>
        <trans-unit id="17af1ff09188bf46cc1670386af27eac4b42d3c1" translate="yes" xml:space="preserve">
          <source>Legacy folds</source>
          <target state="translated">Наследственные складки</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="b35cc825e3ceae3035f623e062f495f46e1b0bf1" translate="yes" xml:space="preserve">
          <source>Length of a SIMD vector type</source>
          <target state="translated">Длина SIMD векторного типа</target>
        </trans-unit>
        <trans-unit id="1da751ae056c25dec1bf146025343c7d7baa5ec4" translate="yes" xml:space="preserve">
          <source>Lennart Kolmodin</source>
          <target state="translated">Леннарт Колмодин</target>
        </trans-unit>
        <trans-unit id="4c902ed308255eedb5791755b57d87de654a6e37" translate="yes" xml:space="preserve">
          <source>Lennart Kolmodin &amp;lt;kolmodin@gmail.com&amp;gt;</source>
          <target state="translated">Леннарт Колмодин &amp;lt;kolmodin@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c65eb9120ed9793a089cab8d78b2b3e2762a66f1" translate="yes" xml:space="preserve">
          <source>Lennart Kolmodin Ross Paterson</source>
          <target state="translated">Леннарт Колмодин Росс Патерсон</target>
        </trans-unit>
        <trans-unit id="785175efbad60848e99dc0e384b6197a7399034b" translate="yes" xml:space="preserve">
          <source>Let us illustrate these improvements on the CSV-table rendering example from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;. Its &quot;hot code&quot; is the rendering of a table's cells, which we implement as follows using only the functions from the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; API.</source>
          <target state="translated">Проиллюстрируем эти улучшения на примере отрисовки CSV-таблицы из &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt; . Его &amp;laquo;горячий код&amp;raquo; - это отрисовка ячеек таблицы, которую мы реализуем следующим образом, используя только функции из &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; API.</target>
        </trans-unit>
        <trans-unit id="8f4eb684c9a2dfb229ddec06c0f99f449d161a5a" translate="yes" xml:space="preserve">
          <source>Let us look at an example first:</source>
          <target state="translated">Давайте сначала рассмотрим пример:</target>
        </trans-unit>
        <trans-unit id="a5c3e5bbf9a5e76197700fa3298be080332fba3f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider a simple example,</source>
          <target state="translated">Рассмотрим простой пример,</target>
        </trans-unit>
        <trans-unit id="a592951b101ac13a4cc74ab595c10c997b2adfa4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a Hello World program, and compile and run it. First, create a file &lt;code&gt;hello.hs&lt;/code&gt; containing the Haskell code:</source>
          <target state="translated">Давайте создадим программу Hello World, скомпилируем и запустим ее. Сначала создайте файл &lt;code&gt;hello.hs&lt;/code&gt; , содержащий код Haskell:</target>
        </trans-unit>
        <trans-unit id="dd8ebc96ea1bed3112a906d9d91800a76be4b101" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s first see how execution flows through this program. We start by telling GHC that we want debug information,</source>
          <target state="translated">Давайте сначала посмотрим, как выполняется эта программа. Мы начинаем с того, что говорим GHC, что нам нужна отладочная информация,</target>
        </trans-unit>
        <trans-unit id="bf4f9d515969a695864d800b64fe827628e6fe9a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with an example GHCi session. You can fire up GHCi with the command &lt;code&gt;ghci&lt;/code&gt;:</source>
          <target state="translated">Начнем с примера сеанса GHCi. Вы можете запустить GHCi с помощью команды &lt;code&gt;ghci&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3484d66cbe4a02744097aac7ef40e2f056cef65a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at an example:</source>
          <target state="translated">Давайте посмотрим на пример:</target>
        </trans-unit>
        <trans-unit id="594c7197a66aa41cb3dd72c23871e7b9c600e29e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the example from above, and invoke it from a standalone C program. Here&amp;rsquo;s the C code:</source>
          <target state="translated">Давайте возьмем приведенный выше пример и вызовем его из отдельной программы на C. Вот код C:</target>
        </trans-unit>
        <trans-unit id="c8a1d1f3d4842f4a6ca73f207182495c844d5cac" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s use quicksort as a running example. Here&amp;rsquo;s the code:</source>
          <target state="translated">Давайте использовать быструю сортировку в качестве рабочего примера. Вот код:</target>
        </trans-unit>
        <trans-unit id="acb86e263cb9634893bee6f20e365bbfa9867198" translate="yes" xml:space="preserve">
          <source>Let's decode binary data representing illustrated here. In this example the values are in little endian.</source>
          <target state="translated">Давайте декодируем бинарные данные,изображенные здесь.В данном примере значения находятся на маленьком эндиане.</target>
        </trans-unit>
        <trans-unit id="789a59a775f3c2900a64ef818bc09e8989fd5353" translate="yes" xml:space="preserve">
          <source>Let's first define a function that decodes many &lt;code&gt;Trade&lt;/code&gt;s.</source>
          <target state="translated">Давайте сначала определим функцию, которая декодирует многие &lt;code&gt;Trade&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e7e5ce190e9c80ce4a8c228bca3542e7865655a" translate="yes" xml:space="preserve">
          <source>LetterNumber</source>
          <target state="translated">LetterNumber</target>
        </trans-unit>
        <trans-unit id="87f5f38833b121fccd9e5087f3c99d3bb46af917" translate="yes" xml:space="preserve">
          <source>Level of detail in the pretty printed output. Level 0 is the least detail.</source>
          <target state="translated">Уровень детализации в симпатичной печатной продукции.Уровень 0-наименьшая детализация.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
