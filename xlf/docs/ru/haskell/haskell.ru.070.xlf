<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="03411ce0e13fe57751c2f82253b492cc9d47c8f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: &lt;code&gt;&lt;a href=&quot;prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; is a superclass of &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; since &lt;em&gt;base-4.11.0.0&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ&lt;/strong&gt; : &lt;code&gt;&lt;a href=&quot;prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; является суперклассом &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; начиная с &lt;em&gt;base-4.11.0.0&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="166aed14653edc6f46dcff3c1dae86631ba0a891" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Currently, &lt;code&gt;&lt;a href=&quot;text-parsec#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; exhibits surprising behaviour when applied to a parser &lt;code&gt;p&lt;/code&gt; that doesn't consume any input; specifically</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ&lt;/strong&gt; . В настоящее время &lt;code&gt;&lt;a href=&quot;text-parsec#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; демонстрирует удивительное поведение при применении к синтаксическому анализатору &lt;code&gt;p&lt;/code&gt; , который не потребляет никаких входных данных; конкретно</target>
        </trans-unit>
        <trans-unit id="ec9986bf04287187f171a448a6e427d2d4d16d6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Currently, &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; exhibits surprising behaviour when applied to a parser &lt;code&gt;p&lt;/code&gt; that doesn't consume any input; specifically</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ&lt;/strong&gt; . В настоящее время &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; демонстрирует удивительное поведение при применении к синтаксическому анализатору &lt;code&gt;p&lt;/code&gt; , который не потребляет никаких входных данных; конкретно</target>
        </trans-unit>
        <trans-unit id="5d16f3693057b662396f898cac3b01fe76debdb2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Currently, &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; exhibits surprising behaviour when applied to a parser &lt;code&gt;p&lt;/code&gt; that doesn't consume any input; specifically</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ&lt;/strong&gt; . В настоящее время &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; демонстрирует удивительное поведение при применении к синтаксическому анализатору &lt;code&gt;p&lt;/code&gt; , который не потребляет никаких входных данных; конкретно</target>
        </trans-unit>
        <trans-unit id="6818107750bfc6c118df69013440ac82805bba52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Only strict in the reference and not the referenced value.</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ&lt;/strong&gt; : строго в ссылке, а не в указанном значении.</target>
        </trans-unit>
        <trans-unit id="dc20d237e47fdcc6a1702edaefb72cd73590b46d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Prior to &lt;code&gt;deepseq-1.4.4.0&lt;/code&gt; this instance was only defined for &lt;code&gt;base-4.8.0.0&lt;/code&gt; and later.</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ&lt;/strong&gt; . До &lt;code&gt;deepseq-1.4.4.0&lt;/code&gt; этот экземпляр был определен только для &lt;code&gt;base-4.8.0.0&lt;/code&gt; и новее.</target>
        </trans-unit>
        <trans-unit id="7a7733fa013d8d35cc1c5581dc3eef96e5dfd0cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: The functions in &lt;code&gt;base-4.12&lt;/code&gt; changed the serialisation in case of a &lt;code&gt;Just 0&lt;/code&gt; precision; this version of &lt;code&gt;text&lt;/code&gt; still provides the serialisation as implemented in &lt;code&gt;base-4.11&lt;/code&gt;. The next major version of &lt;code&gt;text&lt;/code&gt; will switch to the more correct &lt;code&gt;base-4.12&lt;/code&gt; serialisation.</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ&lt;/strong&gt; . Функции в &lt;code&gt;base-4.12&lt;/code&gt; изменили сериализацию в случае точности &lt;code&gt;Just 0&lt;/code&gt; ; эта версия &lt;code&gt;text&lt;/code&gt; прежнему обеспечивает сериализацию, реализованную в &lt;code&gt;base-4.11&lt;/code&gt; . Следующая основная версия &lt;code&gt;text&lt;/code&gt; переключится на более правильную сериализацию &lt;code&gt;base-4.12&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77693d6f146c132591a587e160c8af245f51c0df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: The intrepid user may notice that &lt;code&gt;HasCallStack&lt;/code&gt; is just an alias for an implicit parameter &lt;code&gt;?callStack :: CallStack&lt;/code&gt;. This is an implementation detail and &lt;strong&gt;should not&lt;/strong&gt; be considered part of the &lt;code&gt;CallStack&lt;/code&gt; API, we may decide to change the implementation in the future.</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ&lt;/strong&gt; . Неустрашимый пользователь может заметить, что &lt;code&gt;HasCallStack&lt;/code&gt; - это просто псевдоним для неявного параметра &lt;code&gt;?callStack :: CallStack&lt;/code&gt; . Это деталь реализации, и &lt;strong&gt;ее не&lt;/strong&gt; следует рассматривать как часть API &lt;code&gt;CallStack&lt;/code&gt; , мы можем решить изменить реализацию в будущем.</target>
        </trans-unit>
        <trans-unit id="2533d0f8b23d21f162cecf82e012550c323eb127" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: The replacement character returned by &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnDecodeError&quot;&gt;OnDecodeError&lt;/a&gt;&lt;/code&gt; MUST be within the BMP plane; surrogate code points will automatically be remapped to the replacement char &lt;code&gt;U+FFFD&lt;/code&gt; (&lt;em&gt;since 0.11.3.0&lt;/em&gt;), whereas code points beyond the BMP will throw an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; (&lt;em&gt;since 1.2.3.1&lt;/em&gt;); For earlier versions of &lt;code&gt;text&lt;/code&gt; using those unsupported code points would result in undefined behavior.</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ&lt;/strong&gt; : замещающий символ, возвращаемый &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnDecodeError&quot;&gt;OnDecodeError&lt;/a&gt;&lt;/code&gt; , ДОЛЖЕН находиться в плоскости BMP; суррогатные кодовые точки будут автоматически переназначены на заменяющий char &lt;code&gt;U+FFFD&lt;/code&gt; ( &lt;em&gt;начиная с 0.11.3.0&lt;/em&gt; ), тогда как кодовые точки за пределами BMP &lt;em&gt;вызовут &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; ( &lt;em&gt;начиная с 1.2.3.1&lt;/em&gt; ); Для более ранних версий &lt;code&gt;text&lt;/code&gt; использование этих неподдерживаемых кодовых точек привело бы к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="6af85fbdeb1c1548ecdc703b5c39806483adbef4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This instance is only defined for &lt;code&gt;base &amp;gt;= 4.9.0&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ&lt;/strong&gt; . Этот экземпляр определен только для &lt;code&gt;base &amp;gt;= 4.9.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d4e26172ba9fac2189c2280c424438f132a68b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This is not needed anymore since &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; became a superclass of &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; in &lt;em&gt;base-4.11&lt;/em&gt; and this newtype be deprecated at some point in the future.</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ&lt;/strong&gt; . В этом больше нет необходимости, так как &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; стал суперклассом &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; в &lt;em&gt;base-4.11,&lt;/em&gt; и этот новый тип будет объявлен устаревшим в какой-то момент в будущем.</target>
        </trans-unit>
        <trans-unit id="09bbdeeb23f25384d247711b42a27b30cfbb93e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This method is redundant and has the default implementation &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; since &lt;em&gt;base-4.11.0.0&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ&lt;/strong&gt; . Этот метод является избыточным и имеет реализацию по умолчанию &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; начиная с &lt;em&gt;base-4.11.0.0&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2b7bee89a50523b2b7f4298406f2f560b7f97e3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This method is redundant and has the default implementation &lt;code&gt;&lt;a href=&quot;ghc-base#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;ghc-base#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; since &lt;em&gt;base-4.11.0.0&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ&lt;/strong&gt; . Этот метод является избыточным и имеет реализацию по умолчанию &lt;code&gt;&lt;a href=&quot;ghc-base#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;ghc-base#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; начиная с &lt;em&gt;base-4.11.0.0&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="53250bceefb8edf3079bcff5effdeb91a06684e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This method is redundant and has the default implementation &lt;code&gt;&lt;a href=&quot;prelude#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;prelude#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; since &lt;em&gt;base-4.11.0.0&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ&lt;/strong&gt; . Этот метод является избыточным и имеет реализацию по умолчанию &lt;code&gt;&lt;a href=&quot;prelude#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;prelude#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; начиная с &lt;em&gt;base-4.11.0.0&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4e5e33ea116bb722425b17e443f5a6fd673821d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This method is redundant and has the default implementation &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; since &lt;em&gt;base-4.11.0.0&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ&lt;/strong&gt; . Этот метод является избыточным и имеет реализацию по умолчанию &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; начиная с &lt;em&gt;base-4.11.0.0&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4b182cab3c093432cfb21fa9dafb0c11115dbd3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This method is redundant and has the default implementation &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; since &lt;em&gt;base-4.11.0.0&lt;/em&gt;. Should it be implemented manually, since &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; is a synonym for (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;), it is expected that the two functions are defined the same way. In a future GHC release &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; will be removed from &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b87531c422bb43abf588cd19cfb145b4b1af212" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Negation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Negation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="35fdc70491666deaadbc15762d73d32a5836699b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nested patterns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Вложенные шаблоны&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39c28848aeb5cab86ac6b199bccbac9933f1e95b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Newtypes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Newtypes&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0d40e5bd81d1d6957246a1ec75c38216c4704c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No ``-O*``-type option specified:&lt;/strong&gt; This is taken to mean &amp;ldquo;Please compile quickly; I&amp;rsquo;m not over-bothered about compiled-code quality.&amp;rdquo; So, for example, &lt;code&gt;ghc -c Foo.hs&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;Не указана опция типа &amp;laquo;-O *&amp;raquo;:&lt;/strong&gt; это означает &amp;laquo;Пожалуйста, скомпилируйте быстро; Меня не беспокоит качество скомпилированного кода &amp;raquo;. Так, например, &lt;code&gt;ghc -c Foo.hs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15fc39334b9319bc0d7d967925cee84740f69bc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This module exports internal implementation details that may change anytime. If you want a more stable API, use &lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Этот модуль экспортирует детали внутренней реализации, которые могут измениться в любое время. Если вам нужен более стабильный API, используйте вместо этого &lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2350c93205902e1c98253ef2f7d2621dcc8098cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The example above should rather be written in terms of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; to ensure releasing file-descriptors in a timely matter (see the description of &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; for an example).</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Приведенный выше пример лучше записывать в &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; чтобы обеспечить своевременное освобождение файловых дескрипторов (см. Описание &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; для примера).</target>
        </trans-unit>
        <trans-unit id="47f5cf616517b6eba6447338e761bc574ca481fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The example above should rather be written in terms of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; to ensure releasing file-descriptors in a timely matter (see the description of &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; for an example).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41c2eafe5091226c38a0690d82eb9525b65f556" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This function is a very big hammer. If you only need an absolute path, &lt;code&gt;&lt;a href=&quot;system-directory#v:makeAbsolute&quot;&gt;makeAbsolute&lt;/a&gt;&lt;/code&gt; is sufficient for removing dependence on the current working directory.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : эта функция представляет собой очень большой молоток. Если вам нужен только абсолютный путь, &lt;code&gt;&lt;a href=&quot;system-directory#v:makeAbsolute&quot;&gt;makeAbsolute&lt;/a&gt;&lt;/code&gt; достаточно для устранения зависимости от текущего рабочего каталога.</target>
        </trans-unit>
        <trans-unit id="615eff90afa4cc9668282159ebd5fba86b0a2aa6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is an internal GHC module with an API subject to change. It's recommended use the &lt;a href=&quot;numeric-natural&quot;&gt;Numeric.Natural&lt;/a&gt; module to import the &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Это внутренний модуль GHC, API которого может изменяться. Для импорта типа &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; рекомендуется использовать модуль &lt;a href=&quot;numeric-natural&quot;&gt;Numeric.Natural&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60f2ee22884b6646412af01b670fedfd33ce75d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Unlike for the unary &lt;code&gt;&lt;a href=&quot;control-deepseq#v:liftRnf&quot;&gt;liftRnf&lt;/a&gt;&lt;/code&gt;, there is currently no support for generically deriving &lt;code&gt;&lt;a href=&quot;control-deepseq#v:liftRnf2&quot;&gt;liftRnf2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . В отличие от унарного &lt;code&gt;&lt;a href=&quot;control-deepseq#v:liftRnf&quot;&gt;liftRnf&lt;/a&gt;&lt;/code&gt; , в настоящее время нет поддержки для обобщенного получения &lt;code&gt;&lt;a href=&quot;control-deepseq#v:liftRnf2&quot;&gt;liftRnf2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f5608392e60fb88bd92846a796785eb6d245173" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pattern matching in case expressions, lambdas, do-notation, etc&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Сопоставление с образцом в case-выражениях, лямбдах, do-notation и т. Д.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba63c80e3e98efdf17dda0cdece96c022afb21de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pick first&lt;/strong&gt;. We can simply select the &lt;strong&gt;first matching axiom&lt;/strong&gt; we encounter. In the above example, this would be &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt;. We&amp;rsquo;d then need to entail &lt;code&gt;A a&lt;/code&gt;, for which we have no matching axioms available, causing the above program to be rejected.</source>
          <target state="translated">&lt;strong&gt;Выбери первым&lt;/strong&gt; . Мы можем просто выбрать &lt;strong&gt;первую подходящую аксиому, с которой&lt;/strong&gt; столкнемся. В приведенном выше примере это будет &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; . Затем нам нужно будет вывести &lt;code&gt;A a&lt;/code&gt; , для которого у нас нет подходящих аксиом, что приведет к отклонению вышеуказанной программы.</target>
        </trans-unit>
        <trans-unit id="a9db9b2d82045af0ef687f46fd582968b70dfaa2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reflexivity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reflexivity&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b82302cd8a8e37a6d42b327c237c78b4a98d4a8b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reject if in doubt&lt;/strong&gt;. An alternative approach would be to check for overlapping axioms, when solving a constraint. When multiple matching axioms are discovered, we &lt;strong&gt;reject the program&lt;/strong&gt;. This approach is a bit conservative, in that it may reject working programs. But it seem much more transparent towards the developer, who can be presented with a clear message, explaining why the program is rejected.</source>
          <target state="translated">&lt;strong&gt;Отклоните, если сомневаетесь&lt;/strong&gt; . Альтернативный подход заключался бы в проверке перекрывающихся аксиом при решении ограничения. Когда обнаруживается несколько аксиом соответствия, мы &lt;strong&gt;отклоняем программу&lt;/strong&gt; . Этот подход немного консервативен, так как он может отклонять рабочие программы. Но это кажется гораздо более прозрачным для разработчика, которому можно представить четкое сообщение, объясняющее, почему программа отклонена.</target>
        </trans-unit>
        <trans-unit id="f0f25f822df506cef863bb9a00c96e4fcc1e4bad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Substitutivity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Substitutivity&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e45f773e26962ea2903c38d6204599890b0de4a9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Symmetry&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Symmetry&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="174acfc98226e3aa5c79a549f805f6cffd2f76aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Top level bindings&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Привязки верхнего уровня&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="75903953dc91115d2e5cd9a4146a4781631d6cb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Transitivity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Transitivity&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dbc186f13791531aa2d22dbaf862de224a352ddf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: It's advised to avoid calling this primitive with negative exponents unless it is guaranteed the inverse exists, as failure to do so will likely cause program abortion due to a divide-by-zero fault. See also &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : рекомендуется избегать вызова этого примитива с отрицательными показателями степени, если нет гарантии, что существует обратное, так как невыполнение этого может привести к прерыванию программы из-за ошибки деления на ноль. См. Также &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="992f7e50f9c1364f8bae8fe4988cebb6afeb5ae8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The internal implementation of &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; (i.e. which constructors are available) depends on the &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; backend used!</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : внутренняя реализация &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; (то есть доступные конструкторы) зависит от используемого бэкэнда &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="083d34b27586c0efd3bb96a02d93d956f6452f30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: result may become negative if (at least) one argument is &lt;code&gt;minBound&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : результат может стать отрицательным, если (хотя бы) один аргумент - &lt;code&gt;minBound&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58416cb35befd57e074b001d9d43848b0e5f2ef5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;hp2ps&lt;/strong&gt; is distributed in &lt;code&gt;ghc/utils/hp2ps&lt;/code&gt; in a GHC source distribution. It was originally developed by Dave Wakeling as part of the HBC/LML heap profiler.</source>
          <target state="translated">&lt;strong&gt;hp2ps&lt;/strong&gt; распространяется в &lt;strong&gt;каталоге &lt;/strong&gt; &lt;code&gt;ghc/utils/hp2ps&lt;/code&gt; в составе исходного кода GHC. Первоначально он был разработан Дэйвом Уэйкелингом как часть профилировщика кучи HBC / LML.</target>
        </trans-unit>
        <trans-unit id="a2a10c48ea0cdf0ca5edaab63d2e386e55d8c83d" translate="yes" xml:space="preserve">
          <source>= (&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;, &lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;)</source>
          <target state="translated">= ( &lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Инт&lt;/a&gt; ; &lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Инт&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="4b9374aa68561e358ba9277ebf67e9a0b2cac65c" translate="yes" xml:space="preserve">
          <source>= [&lt;a href=&quot;language-haskell-th#t:Pred&quot;&gt;Pred&lt;/a&gt;]</source>
          <target state="translated">= [ &lt;a href=&quot;language-haskell-th#t:Pred&quot;&gt;Пред.&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="6a4a112b1856c707441c9370242edae658a769d2" translate="yes" xml:space="preserve">
          <source>= [&lt;a href=&quot;language-haskell-th-syntax#t:Pred&quot;&gt;Pred&lt;/a&gt;]</source>
          <target state="translated">= [ &lt;a href=&quot;language-haskell-th-syntax#t:Pred&quot;&gt;Пред.&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="f3e53936f3c79bf9c4206c8b91a0a0c917161364" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt; -&amp;gt; b)</source>
          <target state="translated">=&amp;gt; ( &lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;HTML&lt;/a&gt; -&amp;gt; б)</target>
        </trans-unit>
        <trans-unit id="22500a4bcb96fc197f5175e32ffc6ecdc6564339" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt; -&amp;gt; b)</source>
          <target state="translated">=&amp;gt; ( &lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;HTML&lt;/a&gt; -&amp;gt; б)</target>
        </trans-unit>
        <trans-unit id="98254af121448be337d889b7151e3095f29dfd2e" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt; -&amp;gt; b)</source>
          <target state="translated">=&amp;gt; ( &lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;HTML&lt;/a&gt; -&amp;gt; б)</target>
        </trans-unit>
        <trans-unit id="87b9b2b6b45827b7ebbf823fd4e6fa2e656b9896" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (a -&amp;gt; &lt;a href=&quot;text-show#t:ShowS&quot;&gt;ShowS&lt;/a&gt;)</source>
          <target state="translated">=&amp;gt; (а -&amp;gt; &lt;a href=&quot;text-show#t:ShowS&quot;&gt;ShowS&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="7e543fa87f892cd0310b1be2e1183e668e09b4b6" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (ann -&amp;gt; m r)</source>
          <target state="translated">=&amp;gt; (Энн -&amp;gt; г-н)</target>
        </trans-unit>
        <trans-unit id="3f837c598bd2a2ea0c21ac7ef916a3ba8c291114" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (e -&amp;gt; &lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; b)</source>
          <target state="translated">=&amp;gt; (e -&amp;gt; &lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Может быть,&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="146ec650c89d3406783a47923e5bcd00b024cf1a" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (e -&amp;gt; a -&amp;gt; e)</source>
          <target state="translated">=&amp;gt; (е -&amp;gt; а -&amp;gt; е)</target>
        </trans-unit>
        <trans-unit id="28b8a020a4a70d67b201ecca5ebfe9b3decfac94" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (e -&amp;gt; e' -&amp;gt; e)</source>
          <target state="translated">=&amp;gt; (е -&amp;gt; е '-&amp;gt; е)</target>
        </trans-unit>
        <trans-unit id="d1cff79143a6b98192e6f5c93021392b3bb26523" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (i, i)</source>
          <target state="translated">=&amp;gt; (я, я)</target>
        </trans-unit>
        <trans-unit id="273c01aab4f2aada746f406147099fc43c561169" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (r -&amp;gt; a)</source>
          <target state="translated">=&amp;gt; (г -&amp;gt; а)</target>
        </trans-unit>
        <trans-unit id="98cb27f97fefd7391598e198b2314a4052bd3f10" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (s -&amp;gt; (a, s))</source>
          <target state="translated">=&amp;gt; (s -&amp;gt; (a, s))</target>
        </trans-unit>
        <trans-unit id="40a084ccf2eb50cdea0902780e3641bbeeb218a0" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (t -&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;)</source>
          <target state="translated">=&amp;gt; (t -&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;Строка&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a913d2dfb1e9cb8a3706aeccb247062382be5958" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (t -&amp;gt; &lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f7f76239cb27ca373456dbde8bc8bedbe3e3f1" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="631db25a13c5bd3f3a27fb66e2b126a624973fe7" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Может быть, &lt;/a&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Чар&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e3b4666c0db847e1f4ef59969ccc1e08d98e0fb5" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;Строка&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="83f228b1575a69db7fa34e7e1f31ba1fcc909002" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt; a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt; a</target>
        </trans-unit>
        <trans-unit id="9b29c2ad51aea488dc493c38480ca6f86fb32ef5" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.14.1.0/data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eea19132ccdb3f07c5c85871217ec3b42357147" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a090ffafec70ef99fa90de5566cfbed70873913" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt; a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4c85809d4a3a2bbe15915426aa3ae9d49b837b4" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-rws-lazy#t:RWST&quot;&gt;RWST&lt;/a&gt; r w s m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-rws-lazy#t:RWST&quot;&gt;RWST&lt;/a&gt; rwsma</target>
        </trans-unit>
        <trans-unit id="881da90599e1b286facbeb80f0b5665a56f022f1" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-rws-strict#t:RWST&quot;&gt;RWST&lt;/a&gt; r w s m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-rws-strict#t:RWST&quot;&gt;RWST&lt;/a&gt; rwsma</target>
        </trans-unit>
        <trans-unit id="c0ed1cf1dee5f53006a4c0bd4c39fd64413da332" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-trans-error#t:ErrorT&quot;&gt;ErrorT&lt;/a&gt; e m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-trans-error#t:ErrorT&quot;&gt;ErrorT&lt;/a&gt; ema</target>
        </trans-unit>
        <trans-unit id="43faa2c3584d57723d2b7894cdd8de390f7d6ff3" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-trans-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt; e m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-trans-except#t:ExceptT&quot;&gt;Кроме&lt;/a&gt; ema</target>
        </trans-unit>
        <trans-unit id="ed1c848733ee83ef5cfd6f49ba6a222cc681fb5b" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-cps#t:RWS&quot;&gt;RWS&lt;/a&gt; r w s a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-cps#t:RWS&quot;&gt;RWS&lt;/a&gt; rwsa</target>
        </trans-unit>
        <trans-unit id="0d59b61a3690bc45a5667c7d9d686fd7aae890a6" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-cps#t:RWST&quot;&gt;RWST&lt;/a&gt; r w s m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-cps#t:RWST&quot;&gt;RWST&lt;/a&gt; rwsma</target>
        </trans-unit>
        <trans-unit id="e04a43f264efe742e62b7c872cf3243a4e74e724" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-lazy#t:RWST&quot;&gt;RWST&lt;/a&gt; r w s m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-lazy#t:RWST&quot;&gt;RWST&lt;/a&gt; rwsma</target>
        </trans-unit>
        <trans-unit id="46a15491d5a54f8e9623cc81bd3b40c08cc35bc5" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-strict#t:RWST&quot;&gt;RWST&lt;/a&gt; r w s m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-strict#t:RWST&quot;&gt;RWST&lt;/a&gt; rwsma</target>
        </trans-unit>
        <trans-unit id="1decabf293013a44ad8fb38d770351c0b3d3eff0" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Динамический&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2c49f72d1d47fd85210f06fe46bd2fbdba18a7f1" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f a c</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;Когда отсутствует&lt;/a&gt; фак</target>
        </trans-unit>
        <trans-unit id="c6dd57371651023369288a8ddebf01f317b257ab" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f a c</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;Когда отсутствует&lt;/a&gt; фак</target>
        </trans-unit>
        <trans-unit id="01807040766915893b46814bd7bc992c2c731d87" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-map-merge-lazy#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt; k a c</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-map-merge-lazy#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt; kac</target>
        </trans-unit>
        <trans-unit id="f3e23cdc0abf474625d6acfcfc952ed151e46c12" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k a c</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;Когда не&lt;/a&gt; хватает fkac</target>
        </trans-unit>
        <trans-unit id="e4ec523b9e7b9c9afd657cd3f09a05fbaa7be373" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-map-merge-strict#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt; k a c</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-map-merge-strict#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt; kac</target>
        </trans-unit>
        <trans-unit id="5b3d889a0b4ee8e84ff7b2d421af97fb78b317dd" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k a c</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;Когда не&lt;/a&gt; хватает fkac</target>
        </trans-unit>
        <trans-unit id="998942da66b438367a1103e796eb6fe2d1d3b071" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-text-lazy-builder-realfloat#t:FPFormat&quot;&gt;FPFormat&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-text-lazy-builder-realfloat#t:FPFormat&quot;&gt;FPFormat&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d97087128e0e8d5868c008414eb04d89f5c495f9" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-time-format#t:TimeLocale&quot;&gt;TimeLocale&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-time-format#t:TimeLocale&quot;&gt;TimeLocale&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="16402fa4cd4c09cc613611f7301a7d80b85c6647" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt; a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt; a</target>
        </trans-unit>
        <trans-unit id="64674fd23e15a8758e1e185aedc3564f71140d67" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a</target>
        </trans-unit>
        <trans-unit id="7cc439ff40c5b4dedd82f1f56048dc9dea26eb6f" translate="yes" xml:space="preserve">
          <source>=&amp;gt; [(node, key, [key])]</source>
          <target state="translated">=&amp;gt; [(узел, ключ, [ключ])]</target>
        </trans-unit>
        <trans-unit id="43c78599b734a8beb8eaf6cf4e3c3a77e20137fe" translate="yes" xml:space="preserve">
          <source>=&amp;gt; a</source>
          <target state="translated">=&amp;gt; а</target>
        </trans-unit>
        <trans-unit id="9ed6660105e653b094e0abb01e8f35fac4855dca" translate="yes" xml:space="preserve">
          <source>=&amp;gt; dev</source>
          <target state="translated">=&amp;gt; разработчик</target>
        </trans-unit>
        <trans-unit id="6947818ac409551f11fbaa78f0ea6391960aa5b8" translate="yes" xml:space="preserve">
          <source>==</source>
          <target state="translated">==</target>
        </trans-unit>
        <trans-unit id="6bb984861a61b745289ffc16ea1e0057086b9c13" translate="yes" xml:space="preserve">
          <source>@&lt;code&gt;&lt;a href=&quot;data-binary-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;data-binary-builder#v:fromShortByteString&quot;&gt;fromShortByteString&lt;/a&gt;&lt;/code&gt; bs) = &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#v:fromChunks&quot;&gt;fromChunks&lt;/a&gt;&lt;/code&gt; [&lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#v:fromShort&quot;&gt;fromShort&lt;/a&gt;&lt;/code&gt; bs]</source>
          <target state="translated">@ &lt;code&gt;&lt;a href=&quot;data-binary-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;data-binary-builder#v:fromShortByteString&quot;&gt;fromShortByteString&lt;/a&gt;&lt;/code&gt; bs) = &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#v:fromChunks&quot;&gt;fromChunks&lt;/a&gt;&lt;/code&gt; [ &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#v:fromShort&quot;&gt;fromShort&lt;/a&gt;&lt;/code&gt; bs]</target>
        </trans-unit>
        <trans-unit id="a3f4dc36787602cc5de507d13c594861d488c7eb" translate="yes" xml:space="preserve">
          <source>A &quot;-&amp;gt;&quot; string</source>
          <target state="translated">Строка &quot;-&amp;gt;&quot;</target>
        </trans-unit>
        <trans-unit id="3dbf51df963b10779a311937a8f60e762c73a212" translate="yes" xml:space="preserve">
          <source>A &quot;::&quot; string</source>
          <target state="translated">Строка &quot;::&quot;</target>
        </trans-unit>
        <trans-unit id="300f220bfe895126a57222e655e8c3d3cabdf03a" translate="yes" xml:space="preserve">
          <source>A &quot;plain&quot; type constructor. &quot;Fancier&quot; type constructors are returned using &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:FamilyI&quot;&gt;FamilyI&lt;/a&gt;&lt;/code&gt; as appropriate. At present, this reified declaration will never have derived instances attached to it (if you wish to check for an instance, see &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Конструктор &quot;простого&quot; типа. Конструкторы типа &quot;Fancier&quot; возвращаются с использованием &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:FamilyI&quot;&gt;FamilyI&lt;/a&gt;&lt;/code&gt; в зависимости от ситуации. В настоящее время это обобщенное объявление никогда не будет иметь прикрепленных к нему производных экземпляров (если вы хотите проверить экземпляр, см. &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="10a841c387fe820bc69427b7c8889b542a6b0766" translate="yes" xml:space="preserve">
          <source>A &quot;plain&quot; type constructor. &quot;Fancier&quot; type constructors are returned using &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:FamilyI&quot;&gt;FamilyI&lt;/a&gt;&lt;/code&gt; as appropriate. At present, this reified declaration will never have derived instances attached to it (if you wish to check for an instance, see &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Конструктор &quot;простого&quot; типа. Конструкторы типа &quot;Fancier&quot; возвращаются с использованием &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:FamilyI&quot;&gt;FamilyI&lt;/a&gt;&lt;/code&gt; в зависимости от ситуации. В настоящее время это обобщенное объявление никогда не будет иметь прикрепленных к нему производных экземпляров (если вы хотите проверить экземпляр, см. &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="32c1213ff43ed2016bf02de4b047ebc7b374b44b" translate="yes" xml:space="preserve">
          <source>A &quot;primitive&quot; type constructor, which can't be expressed with a &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Dec&quot;&gt;Dec&lt;/a&gt;&lt;/code&gt;. Examples: &lt;code&gt;(-&amp;gt;)&lt;/code&gt;, &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">А &amp;laquo;примитивный&amp;raquo; конструктор типа, который не может быть выражено с &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Dec&quot;&gt;Dec&lt;/a&gt;&lt;/code&gt; . Примеры: &lt;code&gt;(-&amp;gt;)&lt;/code&gt; , &lt;code&gt;Int#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8cadfacc5513088f5ce5adc653861e33911e323" translate="yes" xml:space="preserve">
          <source>A &quot;primitive&quot; type constructor, which can't be expressed with a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Dec&quot;&gt;Dec&lt;/a&gt;&lt;/code&gt;. Examples: &lt;code&gt;(-&amp;gt;)&lt;/code&gt;, &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">А &amp;laquo;примитивный&amp;raquo; конструктор типа, который не может быть выражено с &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Dec&quot;&gt;Dec&lt;/a&gt;&lt;/code&gt; . Примеры: &lt;code&gt;(-&amp;gt;)&lt;/code&gt; , &lt;code&gt;Int#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b95014d55a1a5c44f3c7bc23c6504bed812af75" translate="yes" xml:space="preserve">
          <source>A &quot;raw&quot; (disk) device which supports block binary read and write operations and may be seekable only to positions of certain granularity (block- aligned).</source>
          <target state="translated">Устройство &quot;raw&quot; (дисковое),которое поддерживает блочные двоичные операции чтения и записи и может быть обращено только к позициям с определенной степенью детализации (блочно-выровненным).</target>
        </trans-unit>
        <trans-unit id="40dadc0fe1ae92b18009dce1f8fd8927976b9479" translate="yes" xml:space="preserve">
          <source>A &quot;standard&quot; derived instance</source>
          <target state="translated">&quot;стандартный&quot; производный экземпляр</target>
        </trans-unit>
        <trans-unit id="a9c3609906f2647fca409f7da980e584e3ef11e0" translate="yes" xml:space="preserve">
          <source>A &quot;value&quot; variable (as opposed to a type variable, see &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:TyVarI&quot;&gt;TyVarI&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Переменная &amp;laquo;значение&amp;raquo; (в отличие от переменной типа, см. &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:TyVarI&quot;&gt;TyVarI&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d2fa3eeda719de99d1617880e4ee077e0acc83a6" translate="yes" xml:space="preserve">
          <source>A &quot;value&quot; variable (as opposed to a type variable, see &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:TyVarI&quot;&gt;TyVarI&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Переменная &amp;laquo;значение&amp;raquo; (в отличие от переменной типа, см. &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:TyVarI&quot;&gt;TyVarI&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d099ba358135489de4b98f8bef8e1700327509fb" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;&lt;code&gt;Found hole&lt;/code&gt;&amp;rdquo; error usually terminates compilation, like any other type error. After all, you have omitted some code from your program. Nevertheless, you can run and test a piece of code containing holes, by using the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; flag. This flag defers errors produced by typed holes until runtime, and converts them into compile-time warnings. These warnings can in turn be suppressed entirely by &lt;a href=&quot;using-warnings#ghc-flag--Wtyped-holes&quot;&gt;&lt;code&gt;-Wno-typed-holes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ошибка &amp;laquo; &lt;code&gt;Found hole&lt;/code&gt; &amp;raquo; обычно прерывает компиляцию, как и ошибка любого другого типа. В конце концов, вы пропустили какой-то код из своей программы. Тем не менее, вы можете запустить и протестировать фрагмент кода, содержащий дыры, используя &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt; . Этот флаг откладывает ошибки, вызванные типизированными дырами, до времени выполнения и преобразует их в предупреждения времени компиляции. Эти предупреждения, в свою очередь, могут быть полностью подавлены &lt;a href=&quot;using-warnings#ghc-flag--Wtyped-holes&quot;&gt; &lt;code&gt;-Wno-typed-holes&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03ff9cc92a1ea810e41d8095971be93bdf74f086" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;literate Haskell&amp;rdquo; module.</source>
          <target state="translated">Модуль &amp;laquo;грамотный Haskell&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="8fe0e5fa44b3983941075b4a786a25d59bed2413" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;stable topological sort&amp;rdquo; here, we mean that we perform this algorithm (which we call &lt;em&gt;ScopedSort&lt;/em&gt;):</source>
          <target state="translated">&amp;laquo;Стабильная топологическая сортировка&amp;raquo; здесь означает, что мы выполняем этот алгоритм (который мы называем &lt;em&gt;ScopedSort&lt;/em&gt; ):</target>
        </trans-unit>
        <trans-unit id="65e8bde33d0926b669005135d74a4a27a9f4e93e" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;strict pattern match&amp;rdquo; is any pattern match that can fail. For example, &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;(x:xs)&lt;/code&gt;, &lt;code&gt;!z&lt;/code&gt;, and &lt;code&gt;C x&lt;/code&gt; are strict patterns, but &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;~(1,2)&lt;/code&gt; are not. For the purposes of &lt;code&gt;ApplicativeDo&lt;/code&gt;, a pattern match against a &lt;code&gt;newtype&lt;/code&gt; constructor is considered strict.</source>
          <target state="translated">&amp;laquo;Строгое сопоставление с образцом&amp;raquo; - это любое сопоставление с образцом, которое может потерпеть неудачу. Например, &lt;code&gt;()&lt;/code&gt; , &lt;code&gt;(x:xs)&lt;/code&gt; , &lt;code&gt;!z&lt;/code&gt; и &lt;code&gt;C x&lt;/code&gt; строгие узоры, но &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;~(1,2)&lt;/code&gt; не являются. Для целей &lt;code&gt;ApplicativeDo&lt;/code&gt; соответствие шаблона конструктору &lt;code&gt;newtype&lt;/code&gt; считается строгим.</target>
        </trans-unit>
        <trans-unit id="f547f0739b0d3ec8b58b70d55fe4382a3dcaab7d" translate="yes" xml:space="preserve">
          <source>A '(' character</source>
          <target state="translated">Символ '(')</target>
        </trans-unit>
        <trans-unit id="70d5a19191116accb71ec443cd4b4fc4796865be" translate="yes" xml:space="preserve">
          <source>A ')' character</source>
          <target state="translated">')' персонаж</target>
        </trans-unit>
        <trans-unit id="5c59fc97f8f16f9e84989be6184e3be3c12f4c4d" translate="yes" xml:space="preserve">
          <source>A ',' character</source>
          <target state="translated">'',' персонаж</target>
        </trans-unit>
        <trans-unit id="8cea7bc9d7fd5c53754fe5fa302c98ab7ebba9d0" translate="yes" xml:space="preserve">
          <source>A ';' character</source>
          <target state="translated">A ';' персонаж</target>
        </trans-unit>
        <trans-unit id="24a06b0596e6f9b715b619a7c1e59cb58205d143" translate="yes" xml:space="preserve">
          <source>A '=' character</source>
          <target state="translated">Символ &quot;=</target>
        </trans-unit>
        <trans-unit id="f781f6726d451e5c82ca330b01816e92ba6ee9b1" translate="yes" xml:space="preserve">
          <source>A '[' character</source>
          <target state="translated">Символ '['</target>
        </trans-unit>
        <trans-unit id="f989a4679028d9554fb0771f1f50eeed8579ba0d" translate="yes" xml:space="preserve">
          <source>A ']' character</source>
          <target state="translated">Персонаж &quot;А</target>
        </trans-unit>
        <trans-unit id="fa5fc1c81727f1321da12121ae03096bcaacada5" translate="yes" xml:space="preserve">
          <source>A '{' character</source>
          <target state="translated">Персонаж '{'</target>
        </trans-unit>
        <trans-unit id="f0864bd7f5f8f23f2a725f53240aa607578e2ea5" translate="yes" xml:space="preserve">
          <source>A '}' character</source>
          <target state="translated">Персонаж &quot;}</target>
        </trans-unit>
        <trans-unit id="0d686b1feab210fa1d571b1cf64d0dc555ea4552" translate="yes" xml:space="preserve">
          <source>A (partial) type signature has the following form: &lt;code&gt;forall a b .. . (C1, C2, ..) =&amp;gt; tau&lt;/code&gt;. It consists of three parts:</source>
          <target state="translated">Сигнатура (частичного) типа имеет следующий вид: &lt;code&gt;forall a b .. . (C1, C2, ..) =&amp;gt; tau&lt;/code&gt; . Он состоит из трех частей:</target>
        </trans-unit>
        <trans-unit id="f80c2a8ab20b3b616d4d4b2f353d1a0756e8af37" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#safe-language&quot;&gt;safe language&lt;/a&gt; dialect of Haskell that provides stricter guarantees about the code. It allows types and module boundaries to be trusted.</source>
          <target state="translated">&lt;a href=&quot;#safe-language&quot;&gt;Безопасный язык&lt;/a&gt; диалект Haskell , что обеспечивает более строгие гарантии о коде. Это позволяет доверять типам и границам модулей.</target>
        </trans-unit>
        <trans-unit id="240604f168c64bbbbd9cc3f79b1c96c50e4da4c9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#&lt;/code&gt; is followed by optional spaces and tabs, an alphanumeric keyword that describes the kind of processing, and its arguments. Arguments look like C expressions separated by commas (they are not written inside parens). They extend up to the nearest unmatched &lt;code&gt;)&lt;/code&gt;, &lt;code&gt;]&lt;/code&gt; or &lt;code&gt;}&lt;/code&gt;, or to the end of line if it occurs outside any &lt;code&gt;() [] {} '' &quot;&quot; /**/&lt;/code&gt; and is not preceded by a backslash. Backslash-newline pairs are stripped.</source>
          <target state="translated">За &lt;code&gt;#&lt;/code&gt; следуют необязательные пробелы и табуляторы, буквенно-цифровое ключевое слово, описывающее вид обработки и ее аргументы. Аргументы выглядят как выражения C, разделенные запятыми (они не записываются внутри скобок). Они простираются до ближайшего несоответствующего &lt;code&gt;)&lt;/code&gt; , &lt;code&gt;]&lt;/code&gt; или &lt;code&gt;}&lt;/code&gt; или до конца строки, если оно встречается за пределами any &lt;code&gt;() [] {} '' &quot;&quot; /**/&lt;/code&gt; и ему не предшествует обратная косая черта. Пары обратной косой черты и новой строки удаляются.</target>
        </trans-unit>
        <trans-unit id="ec7d45efe24e17a78b3531b77507cc5b414969c3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;:&lt;/code&gt; character</source>
          <target state="translated">A &lt;code&gt;:&lt;/code&gt; персонаж</target>
        </trans-unit>
        <trans-unit id="4d77aa84dcc8476d8b0a59a06fc9910da40d4c94" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;-like function, specialized to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; monoid, which takes advantage of the internal structure of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; to avoid wrapping in &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; at certain points.</source>
          <target state="translated">Функция, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; , специализированная для моноида &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; , которая использует преимущества внутренней структуры &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; , чтобы избежать оборачивания в &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; в определенных точках.</target>
        </trans-unit>
        <trans-unit id="79c191e27824000624b968ce755ce2407b5fc3a4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; that describes the error.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , описывающая ошибку.</target>
        </trans-unit>
        <trans-unit id="c8af9e26c7ea200796fafc8da4bdbcb725df4cd0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;-like function, specialized to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; monoid, which takes advantage of the internal structure of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; to avoid wrapping in &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; at certain points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f58fb0b6ff8af11490e6db18e3159b3eb14567f8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; is an abstract type representing a handle to a thread. &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, where the &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance implements an arbitrary total ordering over &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;s. The &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance lets you convert an arbitrary-valued &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; to string form; showing a &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; value is occasionally useful when debugging or diagnosing the behaviour of a concurrent program.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; является абстрактным типом , представляющий дескриптор потока. &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; - это экземпляр &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; , где экземпляр &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; реализует произвольное общее упорядочение по &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; s. &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; Экземпляр позволяет преобразовать произвольные многозначные &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; в виде строки; отображение значения &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; иногда полезно при отладке или диагностике поведения параллельной программы.</target>
        </trans-unit>
        <trans-unit id="ce7ce3c377d39b823d763d8b4302a42e6c97ffce" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is a synchronising variable, used for communication between concurrent threads. It can be thought of as a box, which may be empty or full.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; является переменной синхронизации, используемый для связи между параллельными потоками. Его можно представить как коробку, которая может быть пустой или полной.</target>
        </trans-unit>
        <trans-unit id="af4f02e01c3ad2f55652fc8918f170a9b5f03f08" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt; is like a &lt;code&gt;TChan&lt;/code&gt;, with two important differences:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt; подобен &lt;code&gt;TChan&lt;/code&gt; , с двумя важными отличиями:</target>
        </trans-unit>
        <trans-unit id="db398cefd7bed902dc3f0468dccbf2a712235464" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; without a &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; instance may only be used in conjunction with pattern that always match, such as newtypes, tuples, data types with only a single data constructor, and irrefutable patterns (&lt;code&gt;~pat&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; без &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; , например , может быть использована только в сочетании с рисунком , который всегда совпадает, такие , как ньютайпы, кортежи, типы данных только с одним конструктором данных и неопровержимыми образцы ( &lt;code&gt;~pat&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d52facfcc17560b0b9fcad065ab617e3ee01a7a6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; without a &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; instance may only be used in conjunction with pattern that always match, such as newtypes, tuples, data types with only a single data constructor, and irrefutable patterns (&lt;code&gt;~pat&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; без &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; , например , может быть использована только в сочетании с рисунком , который всегда совпадает, такие , как ньютайпы, кортежи, типы данных только с одним конструктором данных и неопровержимыми образцы ( &lt;code&gt;~pat&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c2ad78e77b876113c12279bae00129914cb00534" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; will generally be more efficient (in terms of both time and space) than the equivalent &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; with the same element type. However, &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; is strict in its elements - so don't use &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; if you require the non-strictness that &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; provides.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; как правило , будет более эффективным (с точки зрения времени и в пространстве) , чем эквивалентный &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; с тем же типом элемента. Однако &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; строг в своих элементах - поэтому не используйте &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; , если вам требуется нестрогость, которую обеспечивает &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1d5b0a46bf9ac13012695d647011268c6839438" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; contains 8-bit bytes, or by using the operations from &lt;a href=&quot;data-bytestring-char8&quot;&gt;Data.ByteString.Char8&lt;/a&gt; it can be interpreted as containing 8-bit characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; содержит 8-битовый байт, или с помощью операции из &lt;a href=&quot;data-bytestring-char8&quot;&gt;Data.ByteString.Char8&lt;/a&gt; он может быть истолкованы как содержащие 8-битные символы.</target>
        </trans-unit>
        <trans-unit id="f0361d0a51c1f43d10a9cb740bc7c3263eaf2423" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; represents the result of running a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. It unfolds as a sequence of chunks of data. These chunks come in two forms:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; представляет собой результат запуска &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; . Он разворачивается как последовательность порций данных. Эти фрагменты бывают двух видов:</target>
        </trans-unit>
        <trans-unit id="a2a67d6507558e86947578e9d9e53ccc77b5315b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Buffer&quot;&gt;Buffer&lt;/a&gt;&lt;/code&gt; together with the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; of free bytes. The filled space starts at offset 0 and ends at the first free byte.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Buffer&quot;&gt;Buffer&lt;/a&gt;&lt;/code&gt; вместе с &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; свободных байтов. Заполненное пространство начинается со смещения 0 и заканчивается первым свободным байтом.</target>
        </trans-unit>
        <trans-unit id="811beb8fb95b58583e6d93fef1cf1359e8bd2557" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; action denotes a computation of a value that writes a stream of bytes as a side-effect. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are strict in their side-effect; i.e., the stream of bytes will always be written before the computed value is returned.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; действие означает вычисление значения , которое записывает поток байт в качестве побочного эффекта. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; s строги в своих побочных эффектах; т.е. поток байтов всегда будет записан до того, как будет возвращено вычисленное значение.</target>
        </trans-unit>
        <trans-unit id="77ba64f4eea7ca7040ede60a91c0479a0256585a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; contains 8-bit bytes, or by using the operations from &lt;a href=&quot;data-bytestring-char8&quot;&gt;Data.ByteString.Char8&lt;/a&gt; it can be interpreted as containing 8-bit characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; содержит 8-битовый байт, или с помощью операции из &lt;a href=&quot;data-bytestring-char8&quot;&gt;Data.ByteString.Char8&lt;/a&gt; он может быть истолкованы как содержащие 8-битные символы.</target>
        </trans-unit>
        <trans-unit id="3742f257dac22eaeb1f72c5a59a402dd9caed9a3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; contains 8-bit bytes, or by using the operations from &lt;a href=&quot;data-bytestring-char8&quot;&gt;Data.ByteString.Char8&lt;/a&gt; it can be interpreted as containing 8-bit characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; содержит 8-битовый байт, или с помощью операции из &lt;a href=&quot;data-bytestring-char8&quot;&gt;Data.ByteString.Char8&lt;/a&gt; он может быть истолкованы как содержащие 8-битные символы.</target>
        </trans-unit>
        <trans-unit id="87acc03140b6a38efd5eb569210acf530d577e77" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; may only represent a monomorphic value; an attempt to create a value of type &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; from a polymorphically-typed expression will result in an ambiguity error (see &lt;code&gt;&lt;a href=&quot;data-dynamic#v:toDyn&quot;&gt;toDyn&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; может представлять только мономорфное значение; попытка создать значение типа &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; из выражения с полиморфным типом приведет к ошибке неоднозначности (см. &lt;code&gt;&lt;a href=&quot;data-dynamic#v:toDyn&quot;&gt;toDyn&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7559ec7e510228d1d09527f56d2e4f26a8324238" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Comparison&quot;&gt;Comparison&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; can apply its function argument to each input of the comparison function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Comparison&quot;&gt;Comparison&lt;/a&gt;&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , потому что &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; можно применить свой аргумент функции для каждого входа функции сравнения.</target>
        </trans-unit>
        <trans-unit id="dfe92df845c7b9c6045ec318c8250ac09ae3d416" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Predicate&quot;&gt;Predicate&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; can apply its function argument to the input of the predicate.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Predicate&quot;&gt;Predicate&lt;/a&gt;&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , потому что &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; может применить свой аргумент функции на вход предиката.</target>
        </trans-unit>
        <trans-unit id="89f60209ccece04c7a022e1e1c35644383139a1b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-list-nonempty#t:NonEmpty&quot;&gt;NonEmpty&lt;/a&gt;&lt;/code&gt; list is one which always has at least one element, but is otherwise identical to the traditional list type in complexity and in terms of API. You will almost certainly want to import this module &lt;code&gt;qualified&lt;/code&gt;.</source>
          <target state="translated">Список &lt;code&gt;&lt;a href=&quot;data-list-nonempty#t:NonEmpty&quot;&gt;NonEmpty&lt;/a&gt;&lt;/code&gt; -это список, который всегда имеет хотя бы один элемент, но в остальном идентичен традиционному типу списка по сложности и с точки зрения API. Вы почти наверняка захотите импортировать этот &lt;code&gt;qualified&lt;/code&gt; модуль .</target>
        </trans-unit>
        <trans-unit id="344c6ff8d7a2bcd44da8bfd8dc8df57dba6e7404" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; with the added requirement of a neutral element. Thus any &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt;, but not the other way around.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; с дополнительным требованием нейтрального элемента. Таким образом, любой &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; , но не наоборот.</target>
        </trans-unit>
        <trans-unit id="e35d89b46351c9630145c0b8bbf882d79457fee2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; is a generalization of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;. Yet unlike the &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; requires the presence of a neutral element (&lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;) in addition to the associative operator. The requirement for a neutral element prevents many types from being a full Monoid, like &lt;a href=&quot;data-list-nonempty-nonempty&quot;&gt;Data.List.NonEmpty.NonEmpty&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; является обобщением &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; . Тем не менее, в отличие от &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; требует наличия нейтрального элемента ( &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; ) в дополнение к ассоциативному оператору. Требование нейтрального элемента предотвращает &lt;a href=&quot;data-list-nonempty-nonempty&quot;&gt;превращение&lt;/a&gt; многих типов в полноценный моноид, например Data.List.NonEmpty.NonEmpty .</target>
        </trans-unit>
        <trans-unit id="276d119a24c0525aa19868a36000fbee697e666e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt;-like function, specialized to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; monoid, which takes advantage of the internal structure of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; to avoid wrapping in &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; at certain points.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt; , специализированная для моноида &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; , которая использует внутреннюю структуру &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; , чтобы избежать переноса в &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; в определенные моменты.</target>
        </trans-unit>
        <trans-unit id="8fd75af820d1f54d527c5ea90ed335e09bb6599b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt;-like function, specialized to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; monoid, which takes advantage of the internal structure of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; to avoid wrapping in &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; at certain points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031626d15f769e94dae06fe92bad6c13a12414d5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is a list of characters. String constants in Haskell are values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; представляет собой список символов. Строковые константы в Haskell - это значения типа &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d557b82ce614c78066224f253d24d1e9e55d7e4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value is a sequence of Unicode scalar values, as defined in &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=35&quot;&gt;&amp;sect;3.9, definition D76 of the Unicode 5.2 standard&lt;/a&gt;. As such, a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; cannot contain values in the range U+D800 to U+DFFF inclusive. Haskell implementations admit all Unicode code points (&lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=13&quot;&gt;&amp;sect;3.4, definition D10&lt;/a&gt;) as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values, including code points from this invalid range. This means that there are some &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values, and the functions in this module must handle those cases.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; значение представляет собой последовательность значений скалярных Unicode, как это определено в &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=35&quot;&gt;&amp;sect;3.9, определение D76 стандарта Unicode 5.2&lt;/a&gt; . Таким образом, &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; не может содержать значения в диапазоне от U + D800 до U + DFFF включительно. Реализации Haskell допускают все кодовые точки Unicode ( &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=13&quot;&gt;&amp;sect;3.4, определение D10&lt;/a&gt; ) как значения &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , включая кодовые точки из этого недопустимого диапазона. Это означает, что есть некоторые значения &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , которые не являются допустимыми скалярными значениями Unicode, и функции в этом модуле должны обрабатывать эти случаи.</target>
        </trans-unit>
        <trans-unit id="493151274c14fd9063bbd993eabc297404d04a97" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value is a sequence of Unicode scalar values, as defined in &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=35&quot;&gt;&amp;sect;3.9, definition D76 of the Unicode 5.2 standard&lt;/a&gt;. As such, a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; cannot contain values in the range U+D800 to U+DFFF inclusive. Haskell implementations admit all Unicode code points (&lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=13&quot;&gt;&amp;sect;3.4, definition D10&lt;/a&gt;) as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values, including code points from this invalid range. This means that there are some &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values, and the functions in this module must handle those cases.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; значение представляет собой последовательность значений скалярных Unicode, как это определено в &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=35&quot;&gt;&amp;sect;3.9, определение D76 стандарта Unicode 5.2&lt;/a&gt; . Таким образом, &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; не может содержать значения в диапазоне от U + D800 до U + DFFF включительно. Реализации Haskell допускают все кодовые точки Unicode ( &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=13&quot;&gt;&amp;sect;3.4, определение D10&lt;/a&gt; ) как значения &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , включая кодовые точки из этого недопустимого диапазона. Это означает, что есть некоторые значения &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , которые не являются допустимыми скалярными значениями Unicode, и функции в этом модуле должны обрабатывать эти случаи.</target>
        </trans-unit>
        <trans-unit id="a2ab4f0a1420ff27eb07a2afba8acbdae44df567" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-version#t:Version&quot;&gt;Version&lt;/a&gt;&lt;/code&gt; represents the version of a software entity.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-version#t:Version&quot;&gt;Version&lt;/a&gt;&lt;/code&gt; представляет собой версию программного объекта.</target>
        </trans-unit>
        <trans-unit id="5972d36864fed9ff33b5afd14a95cb4b9c27b6e1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; is an unsigned integral type, with the same size as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; является беззнаковым интегральным типом, с таким же размером , как &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3aa7b36dc316c60d893b5f124b1ba5988ceb7f6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is a list of characters. String constants in Haskell are values of type &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; представляет собой список символов. Строковые константы в Haskell - это значения типа &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39546383234ce70932952659423f3ad369b9dc5e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; is an abstract type representing a handle to a thread. &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, where the &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance implements an arbitrary total ordering over &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;s. The &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance lets you convert an arbitrary-valued &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; to string form; showing a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; value is occasionally useful when debugging or diagnosing the behaviour of a concurrent program.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; является абстрактным типом , представляющий дескриптор потока. &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; - это экземпляр &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; , где экземпляр &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; реализует произвольное общее упорядочение по &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; s. &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; Экземпляр позволяет преобразовать произвольные многозначные &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; в виде строки; отображение значения &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; иногда полезно при отладке или диагностике поведения параллельной программы.</target>
        </trans-unit>
        <trans-unit id="6daf9cc92f22cab1cda41ec56fc33fa5bcb5c1b5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; is an abstract type representing a handle to a thread. &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, where the &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance implements an arbitrary total ordering over &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;s. The &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance lets you convert an arbitrary-valued &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; to string form; showing a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; value is occasionally useful when debugging or diagnosing the behaviour of a concurrent program.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; является абстрактным типом , представляющий дескриптор потока. &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; - это экземпляр &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; , где экземпляр &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; реализует произвольное общее упорядочение по &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; s. &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; Экземпляр позволяет преобразовать произвольные многозначные &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; в виде строки; отображение значения &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; иногда полезно при отладке или диагностике поведения параллельной программы.</target>
        </trans-unit>
        <trans-unit id="c433ed52817c69814ef408474d7e7f0f19916c6d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;[(String, SrcLoc)]&lt;/code&gt;. The &lt;code&gt;String&lt;/code&gt; is the name of function that was called, the &lt;code&gt;&lt;a href=&quot;ghc-exception#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; is the call-site. The list is ordered with the most recently called function at the head.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; является &lt;code&gt;[(String, SrcLoc)]&lt;/code&gt; . &lt;code&gt;String&lt;/code&gt; это имя функции , которая была вызвана, &lt;code&gt;&lt;a href=&quot;ghc-exception#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; это вызов-сайт. Список упорядочен так, что во главе его стоит функция, вызываемая последней.</target>
        </trans-unit>
        <trans-unit id="e99764c1391b456842912477a01318962af2d4bc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; is an unsigned integral type, with the same size as &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; является беззнаковым интегральным типом, с таким же размером , как &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c448caa1f3bf73a5f3c86998ff8b234d23f5d613" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt; instance must satisfy the following laws:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt; экземпляр должен удовлетворять следующим условиям:</target>
        </trans-unit>
        <trans-unit id="f058fc8709c912eeb2b787983729f79e927817fe" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; instance must satisfy the following laws:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; экземпляр должен удовлетворять следующим условиям:</target>
        </trans-unit>
        <trans-unit id="37bca98687b6539690c105875b7d36949eaf0920" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is a specification of a conversion scheme between sequences of bytes and sequences of Unicode characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; это спецификация схемы преобразования между последовательностями байтов и последовательности символов Unicode.</target>
        </trans-unit>
        <trans-unit id="9ccfc506522947e455012faccd5c0641a69d1d0d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;[(String, SrcLoc)]&lt;/code&gt;. The &lt;code&gt;String&lt;/code&gt; is the name of function that was called, the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; is the call-site. The list is ordered with the most recently called function at the head.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; является &lt;code&gt;[(String, SrcLoc)]&lt;/code&gt; . &lt;code&gt;String&lt;/code&gt; это имя функции , которая была вызвана, &lt;code&gt;&lt;a href=&quot;ghc-stack#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; это вызов-сайт. Список упорядочен так, что во главе его стоит функция, вызываемая последней.</target>
        </trans-unit>
        <trans-unit id="95958acad6af1408745c1c860b5d733b2d323753" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;[(String, SrcLoc)]&lt;/code&gt;. The &lt;code&gt;String&lt;/code&gt; is the name of function that was called, the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; is the call-site. The list is ordered with the most recently called function at the head.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; является &lt;code&gt;[(String, SrcLoc)]&lt;/code&gt; . &lt;code&gt;String&lt;/code&gt; это имя функции , которая была вызвана, &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; это вызов-сайт. Список упорядочен так, что во главе его стоит функция, вызываемая последней.</target>
        </trans-unit>
        <trans-unit id="8456cabb368794e2df99a2d1a5a798a5a772942a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; is an unsigned integral type, with the same size as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; является беззнаковым интегральным типом, с таким же размером , как &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e97ac17514823d55db637532fc8cca228a55594" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghci-resolvedbco#t:ResolvedBCO&quot;&gt;ResolvedBCO&lt;/a&gt;&lt;/code&gt; is one in which all the &lt;code&gt;Name&lt;/code&gt; references have been resolved to actual addresses or &lt;code&gt;RemoteHValues&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-resolvedbco#t:ResolvedBCO&quot;&gt;ResolvedBCO&lt;/a&gt;&lt;/code&gt; является один , в котором все &lt;code&gt;Name&lt;/code&gt; ссылка была решена с реальными адресами или &lt;code&gt;RemoteHValues&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e9ca692d8226adf018ac8ce128aabc55c560244" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;-style resource handler for &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; обработчик -стиль ресурс для &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e20537f017b881ed432aeb6d8c3c69764ad12389" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Lift&quot;&gt;Lift&lt;/a&gt;&lt;/code&gt; instance can have any of its values turned into a Template Haskell expression. This is needed when a value used within a Template Haskell quotation is bound outside the Oxford brackets (&lt;code&gt;[| ... |]&lt;/code&gt;) but not at the top level. As an example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Lift&quot;&gt;Lift&lt;/a&gt;&lt;/code&gt; экземпляр может иметь какой - либо из его значений превратились в выражение шаблона Haskell. Это необходимо, когда значение, используемое в цитате Template Haskell, ограничено за пределами оксфордских скобок ( &lt;code&gt;[| ... |]&lt;/code&gt; ), но не на верхнем уровне. Например:</target>
        </trans-unit>
        <trans-unit id="8baf8997f83651b56856d51ed22119ab60baf8c6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Lift&quot;&gt;Lift&lt;/a&gt;&lt;/code&gt; instance must satisfy &lt;code&gt;$(lift x) &amp;equiv; x&lt;/code&gt; for all &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;$(...)&lt;/code&gt; is a Template Haskell splice.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Lift&quot;&gt;Lift&lt;/a&gt;&lt;/code&gt; экземпляр должен удовлетворять &lt;code&gt;$(lift x) &amp;equiv; x&lt;/code&gt; для всех &lt;code&gt;x&lt;/code&gt; , где &lt;code&gt;$(...)&lt;/code&gt; является сращивание Template Haskell.</target>
        </trans-unit>
        <trans-unit id="dc2e529d77216b7e230e75736a12096341b81566" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; without a &lt;code&gt;&lt;a href=&quot;prelude#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; instance may only be used in conjunction with pattern that always match, such as newtypes, tuples, data types with only a single data constructor, and irrefutable patterns (&lt;code&gt;~pat&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; без &lt;code&gt;&lt;a href=&quot;prelude#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; , например , может быть использована только в сочетании с рисунком , который всегда совпадает, такие , как ньютайпы, кортежи, типы данных только с одним конструктором данных и неопровержимыми образцы ( &lt;code&gt;~pat&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="01cb4e7f2872a463ecfc84cecc5fd37176ad2686" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is a list of characters. String constants in Haskell are values of type &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; представляет собой список символов. Строковые константы в Haskell - это значения типа &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16c73c4644db1dd430eecd595b2935abcbd70f5e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;prelude#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; is an unsigned integral type, with the same size as &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; является беззнаковым интегральным типом, с таким же размером , как &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5384336a86ebc421cc3fe658790659229a2e63f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Behavior&quot;&gt;Behavior&lt;/a&gt;&lt;/code&gt; is a method for deciding at run-time which type of interaction to use.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Behavior&quot;&gt;Behavior&lt;/a&gt;&lt;/code&gt; является способом принятия решения во время выполнения какого типа взаимодействия для использования.</target>
        </trans-unit>
        <trans-unit id="45d218cdb4af63fb065f7347943499e7d49ef9be" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#t:RunIO&quot;&gt;RunIO&lt;/a&gt;&lt;/code&gt; function takes a monadic action &lt;code&gt;m&lt;/code&gt; as input, and outputs an IO action which performs the underlying impure part of &lt;code&gt;m&lt;/code&gt; and returns the '&lt;code&gt;pure'&lt;/code&gt; part of &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#t:RunIO&quot;&gt;RunIO&lt;/a&gt;&lt;/code&gt; принимает на вход монадическое действие &lt;code&gt;m&lt;/code&gt; и выводит действие ввода-вывода, которое выполняет нижележащую нечистую часть &lt;code&gt;m&lt;/code&gt; и возвращает &amp;laquo; &lt;code&gt;pure'&lt;/code&gt; часть &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3139966130ea6dafab5ae56d42fa83f1c983bce8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is a specification of a conversion scheme between sequences of bytes and sequences of Unicode characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; это спецификация схемы преобразования между последовательностями байтов и последовательности символов Unicode.</target>
        </trans-unit>
        <trans-unit id="1a15ba8c0101a0b559f5881de53f7fa0649c9e6b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; combinator. The argument is some general parser message.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; сообщение генерируется &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; комбинатора. Аргументом является какое-то общее сообщение парсера.</target>
        </trans-unit>
        <trans-unit id="d7c33b518e905e06246fdc3442ce5bfca419239f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; combinator. The argument is some general parser message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ef7fe44084ddf44d2e8bb742356ef4d58d6b59" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsec-error#v:Expect&quot;&gt;Expect&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; combinator. The argument describes the expected item.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsec-error#v:Expect&quot;&gt;Expect&lt;/a&gt;&lt;/code&gt; сообщение генерируется &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; Комбинатора. Аргумент описывает ожидаемый элемент.</target>
        </trans-unit>
        <trans-unit id="2f54fff1c216809b3a5e0dbc637601d50f8c6c28" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsec-error#v:SysUnExpect&quot;&gt;SysUnExpect&lt;/a&gt;&lt;/code&gt; message is automatically generated by the &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; combinator. The argument is the unexpected input.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsec-error#v:SysUnExpect&quot;&gt;SysUnExpect&lt;/a&gt;&lt;/code&gt; сообщение автоматически генерируется &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; комбинатора. Аргумент - неожиданный ввод.</target>
        </trans-unit>
        <trans-unit id="cd574240b0c567cd017058a316ed035f46f6524e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsec-error#v:UnExpect&quot;&gt;UnExpect&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:unexpected&quot;&gt;unexpected&lt;/a&gt;&lt;/code&gt; combinator. The argument describes the unexpected item.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsec-error#v:UnExpect&quot;&gt;UnExpect&lt;/a&gt;&lt;/code&gt; сообщение генерируется &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:unexpected&quot;&gt;unexpected&lt;/a&gt;&lt;/code&gt; комбинатора. Аргумент описывает неожиданный предмет.</target>
        </trans-unit>
        <trans-unit id="c19aa3725eed1ff35ec390fbcd0c985fd5b931ed" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; combinator. The argument is some general parser message.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; сообщение генерируется &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; комбинатора. Аргументом является какое-то общее сообщение парсера.</target>
        </trans-unit>
        <trans-unit id="c65c2017bc5e0477e9c2b63e9054f9b8989ca0a8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; combinator. The argument is some general parser message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbea807bde10982fba750640fdd252b73cdd256c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#v:Expect&quot;&gt;Expect&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; combinator. The argument describes the expected item.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#v:Expect&quot;&gt;Expect&lt;/a&gt;&lt;/code&gt; сообщение генерируется &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; Комбинатора. Аргумент описывает ожидаемый элемент.</target>
        </trans-unit>
        <trans-unit id="a0592092bb04d822c205343ec720a927bd033f59" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#v:SysUnExpect&quot;&gt;SysUnExpect&lt;/a&gt;&lt;/code&gt; message is automatically generated by the &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; combinator. The argument is the unexpected input.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#v:SysUnExpect&quot;&gt;SysUnExpect&lt;/a&gt;&lt;/code&gt; сообщение автоматически генерируется &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; комбинатора. Аргумент - неожиданный ввод.</target>
        </trans-unit>
        <trans-unit id="043b63a3a919975f6460c5dd3c3a8b5b0fcacbb9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#v:UnExpect&quot;&gt;UnExpect&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:unexpected&quot;&gt;unexpected&lt;/a&gt;&lt;/code&gt; combinator. The argument describes the unexpected item.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#v:UnExpect&quot;&gt;UnExpect&lt;/a&gt;&lt;/code&gt; сообщение генерируется &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:unexpected&quot;&gt;unexpected&lt;/a&gt;&lt;/code&gt; комбинатора. Аргумент описывает неожиданный предмет.</target>
        </trans-unit>
        <trans-unit id="97982bdf22f3c28d9d65ec6b0247f3758c15fa0c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Builder&lt;/code&gt; is an efficient way to build lazy &lt;code&gt;Text&lt;/code&gt; values. There are several functions for constructing builders, but only one to inspect them: to extract any data, you have to turn them into lazy &lt;code&gt;Text&lt;/code&gt; values using &lt;code&gt;toLazyText&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Builder&lt;/code&gt; является эффективным способом построения ленивого &lt;code&gt;Text&lt;/code&gt; значения. Есть несколько функций для создания построителей, но только одна для их проверки: чтобы извлечь какие-либо данные, вы должны превратить их в ленивые &lt;code&gt;Text&lt;/code&gt; значения с помощью &lt;code&gt;toLazyText&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="994c45c3efba13b92d41911d6419360be708120c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DEPRECATED&lt;/code&gt; pragma lets you specify that a particular function, class, or type is deprecated.</source>
          <target state="translated">&lt;code&gt;DEPRECATED&lt;/code&gt; Прагма позволяет определить , что конкретная функция, класс или тип осуждается.</target>
        </trans-unit>
        <trans-unit id="202df593255e09bcdac86158dc3e1eaaeacee3f8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HasField x r a&lt;/code&gt; constraint represents the fact that &lt;code&gt;x&lt;/code&gt; is a field of type &lt;code&gt;a&lt;/code&gt; belonging to a record type &lt;code&gt;r&lt;/code&gt;. The &lt;code&gt;getField&lt;/code&gt; method gives the record selector function.</source>
          <target state="translated">&lt;code&gt;HasField x r a&lt;/code&gt; ограничение представляет тот факт , что &lt;code&gt;x&lt;/code&gt; представляет собой поле типа , принадлежащий к записи типа &lt;code&gt;r&lt;/code&gt; . Метод &lt;code&gt;getField&lt;/code&gt; предоставляет функцию выбора записи. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48ba20858c6e487ee442bbf0e918d296f38bac12" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Message a&lt;/code&gt; is a message that returns a value of type &lt;code&gt;a&lt;/code&gt;. These are requests sent from GHC to the server.</source>
          <target state="translated">&lt;code&gt;Message a&lt;/code&gt; это сообщение , которое возвращает значение типа &lt;code&gt;a&lt;/code&gt; . Это запросы, отправленные GHC на сервер.</target>
        </trans-unit>
        <trans-unit id="4cb20e68d9cba85e4c2de51bcc3a4286e1b2b4ed" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ModGuts&lt;/code&gt; holds all of the module&amp;rsquo;s top level bindings which we can examine. These bindings are of type &lt;code&gt;CoreBind&lt;/code&gt; and effectively represent the binding of a name to body of code. Top-level module bindings are part of a &lt;code&gt;ModGuts&lt;/code&gt; in the field &lt;code&gt;mg_binds&lt;/code&gt;. Implementing a pass that manipulates the top level bindings merely needs to iterate over this field, and return a new &lt;code&gt;ModGuts&lt;/code&gt; with an updated &lt;code&gt;mg_binds&lt;/code&gt; field. Because this is such a common case, there is a function provided named &lt;code&gt;bindsOnlyPass&lt;/code&gt; which lifts a function of type &lt;code&gt;([CoreBind] -&amp;gt; CoreM [CoreBind])&lt;/code&gt; to type &lt;code&gt;(ModGuts -&amp;gt; CoreM ModGuts)&lt;/code&gt;.</source>
          <target state="translated">А &lt;code&gt;ModGuts&lt;/code&gt; содержит все привязки верхнего уровня модуля, который мы можем исследовать. Эти привязки относятся к типу &lt;code&gt;CoreBind&lt;/code&gt; и эффективно представляют привязку имени к основной части кода. Привязки модулей верхнего уровня являются частью &lt;code&gt;ModGuts&lt;/code&gt; в поле &lt;code&gt;mg_binds&lt;/code&gt; . Для реализации прохода, который манипулирует привязками верхнего уровня, необходимо просто перебрать это поле и вернуть новый &lt;code&gt;ModGuts&lt;/code&gt; с обновленным полем &lt;code&gt;mg_binds&lt;/code&gt; . Поскольку это очень распространенный случай, существует функция с именем &lt;code&gt;bindsOnlyPass&lt;/code&gt; , которая переводит функцию типа &lt;code&gt;([CoreBind] -&amp;gt; CoreM [CoreBind])&lt;/code&gt; в тип &lt;code&gt;(ModGuts -&amp;gt; CoreM ModGuts)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a70f83cdade171d92c14ec57aaab7b2cf6914937" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MutVar#&lt;/code&gt; behaves like a single-element mutable array.</source>
          <target state="translated">&lt;code&gt;MutVar#&lt;/code&gt; ведет себя как изменяемый массив с одним элементом.</target>
        </trans-unit>
        <trans-unit id="c6337414644ea4c6c26609fea40acca352b7ea57" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Plugin&lt;/code&gt; effectively holds a function which installs a compilation pass into the compiler pipeline. By default there is the empty plugin which does nothing, &lt;code&gt;GhcPlugins.defaultPlugin&lt;/code&gt;, which you should override with record syntax to specify your installation function. Since the exact fields of the &lt;code&gt;Plugin&lt;/code&gt; type are open to change, this is the best way to ensure your plugins will continue to work in the future with minimal interface impact.</source>
          <target state="translated">&lt;code&gt;Plugin&lt;/code&gt; эффективно удерживает функцию , которая устанавливает компиляцию прохода в трубопровод компилятора. По умолчанию есть пустой плагин, который ничего не делает, &lt;code&gt;GhcPlugins.defaultPlugin&lt;/code&gt; , который вы должны переопределить синтаксисом записи, чтобы указать вашу функцию установки. Поскольку точные поля типа &lt;code&gt;Plugin&lt;/code&gt; открыты для изменения, это лучший способ гарантировать, что ваши плагины будут продолжать работать в будущем с минимальным влиянием на интерфейс.</target>
        </trans-unit>
        <trans-unit id="c79966287c7a0289106cbf652df27cd92d1d3c79" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Reader&lt;/code&gt; to run.</source>
          <target state="translated">&lt;code&gt;Reader&lt;/code&gt; для запуска.</target>
        </trans-unit>
        <trans-unit id="42d146b8c1428a840a06c263b2ea3c6508ddd7d5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SPECIALIZE&lt;/code&gt; has the effect of generating (a) a specialised version of the function and (b) a rewrite rule (see &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;) that rewrites a call to the un-specialised function into a call to the specialised one. Moreover, given a &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma for a function &lt;code&gt;f&lt;/code&gt;, GHC will automatically create specialisations for any type-class-overloaded functions called by &lt;code&gt;f&lt;/code&gt;, if they are in the same module as the &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma, or if they are &lt;code&gt;INLINABLE&lt;/code&gt;; and so on, transitively.</source>
          <target state="translated">&lt;code&gt;SPECIALIZE&lt;/code&gt; имеет эффект генерации (а) специализированная версия функции и (б) правила перезаписи (см &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite правила&lt;/a&gt; ) , которые переписывают вызов функции ипа-специализировано в вызов специализированной один. Более того, учитывая прагму &lt;code&gt;SPECIALIZE&lt;/code&gt; для функции &lt;code&gt;f&lt;/code&gt; , GHC автоматически создает специализации для любых функций, перегруженных типом-классом, вызываемых &lt;code&gt;f&lt;/code&gt; , если они находятся в том же модуле, что и прагма &lt;code&gt;SPECIALIZE&lt;/code&gt; , или если они являются &lt;code&gt;INLINABLE&lt;/code&gt; ; и так далее, транзитивно.</target>
        </trans-unit>
        <trans-unit id="8b980d520829db47b0e6b9e92a84de862c7cc8a1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma can optionally be followed with a &lt;code&gt;INLINE&lt;/code&gt; or &lt;code&gt;NOINLINE&lt;/code&gt; pragma, optionally followed by a phase, as described in &lt;a href=&quot;#inline-noinline-pragma&quot;&gt;INLINE and NOINLINE pragmas&lt;/a&gt;. The &lt;code&gt;INLINE&lt;/code&gt; pragma affects the specialised version of the function (only), and applies even if the function is recursive. The motivating example is this:</source>
          <target state="translated">За &lt;code&gt;SPECIALIZE&lt;/code&gt; необязательно может следовать прагма &lt;code&gt;INLINE&lt;/code&gt; или &lt;code&gt;NOINLINE&lt;/code&gt; , за которой может следовать этап, как описано в &lt;a href=&quot;#inline-noinline-pragma&quot;&gt;прагмах INLINE и NOINLINE&lt;/a&gt; . &lt;code&gt;INLINE&lt;/code&gt; Прагма влияет на специализированную версию функции (только), и применяется , даже если функция является рекурсивной. Вот мотивирующий пример:</target>
        </trans-unit>
        <trans-unit id="7b82be1262e45e02f43857ca0ff6515f9db20126" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma for a function can be put anywhere its type signature could be put. Moreover, you can also &lt;code&gt;SPECIALIZE&lt;/code&gt; an &lt;em&gt;imported&lt;/em&gt; function provided it was given an &lt;code&gt;INLINABLE&lt;/code&gt; pragma at its definition site (&lt;a href=&quot;#inlinable-pragma&quot;&gt;INLINABLE pragma&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;SPECIALIZE&lt;/code&gt; Прагма для функции можно разместить в любом месте его тип подписи может поставить. Кроме того, вы можете также &lt;code&gt;SPECIALIZE&lt;/code&gt; &lt;em&gt;импортирована&lt;/em&gt; функция при условии , что было дано &lt;code&gt;INLINABLE&lt;/code&gt; прагму на его определение сайта ( &lt;a href=&quot;#inlinable-pragma&quot;&gt;INLINABLE прагма&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a25c001444e85ab6f7b0766980538a555f7440b7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Span&lt;/code&gt; represents the result of an annotation after a &lt;code&gt;Doc&lt;/code&gt; has been rendered, capturing where the annotation now starts and ends in the rendered output.</source>
          <target state="translated">&lt;code&gt;Span&lt;/code&gt; представляет собой результат аннотацию после того, как &lt;code&gt;Doc&lt;/code&gt; был оказанной, захватив где аннотаций теперь начинается и заканчивается в воспроизведенной выходной.</target>
        </trans-unit>
        <trans-unit id="9ed158fbad702e89568f4c1dbb871930a8429284" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Stream&lt;/code&gt; instance is responsible for maintaining the &quot;position within the stream&quot; in the stream state &lt;code&gt;s&lt;/code&gt;. This is trivial unless you are using the monad in a non-trivial way.</source>
          <target state="translated">&lt;code&gt;Stream&lt;/code&gt; экземпляр несет ответственность за сохранение &amp;laquo;позиции в потоке&amp;raquo; в государственном потоке &lt;code&gt;s&lt;/code&gt; . Это тривиально, если только вы не используете монаду нетривиальным образом.</target>
        </trans-unit>
        <trans-unit id="6768d45124fc6209d1d55206e3becea75d2017a7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;data instance&lt;/code&gt; can use GADT syntax for the data constructors, and indeed can define a GADT. For example:</source>
          <target state="translated">&lt;code&gt;data instance&lt;/code&gt; можно использовать синтаксис GADT для конструкторов данных, и в самом деле можно определить GADT. Например:</target>
        </trans-unit>
        <trans-unit id="daba80bb3a6be48bbea57e35e9db17367b1d0d13" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;deriving instance&lt;/code&gt; declaration must obey the same rules concerning form and termination as ordinary instance declarations, controlled by the same flags; see &lt;a href=&quot;#instance-decls&quot;&gt;Instance declarations&lt;/a&gt;.</source>
          <target state="translated">Объявление &lt;code&gt;deriving instance&lt;/code&gt; должно подчиняться тем же правилам относительно формы и завершения, что и обычные объявления экземпляра, управляемые теми же флагами; см. &lt;a href=&quot;#instance-decls&quot;&gt;Объявления экземпляров&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="59db072390d4948ccdd767966bcedd58bf2bcf38" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;hs-boot&lt;/code&gt; file is compiled by GHC, just like a &lt;code&gt;hs&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;hs-boot&lt;/code&gt; файл компилируется GHC, так же , как &lt;code&gt;hs&lt;/code&gt; файл:</target>
        </trans-unit>
        <trans-unit id="0ee8809aa12d51318c13f6f45ee2d8d36268a40a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;rec&lt;/code&gt;-block tells the compiler where precisely the recursive knot should be tied. It turns out that the placement of the recursive knots can be rather delicate: in particular, we would like the knots to be wrapped around as minimal groups as possible. This process is known as &lt;em&gt;segmentation&lt;/em&gt;, and is described in detail in Section 3.2 of &lt;a href=&quot;http://leventerkok.github.io/papers/recdo.pdf&quot;&gt;A recursive do for Haskell&lt;/a&gt;. Segmentation improves polymorphism and reduces the size of the recursive knot. Most importantly, it avoids unnecessary interference caused by a fundamental issue with the so-called &lt;em&gt;right-shrinking&lt;/em&gt; axiom for monadic recursion. In brief, most monads of interest (IO, strict state, etc.) do &lt;em&gt;not&lt;/em&gt; have recursion operators that satisfy this axiom, and thus not performing segmentation can cause unnecessary interference, changing the termination behavior of the resulting translation. (Details can be found in Sections 3.1 and 7.2.2 of &lt;a href=&quot;http://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;Value Recursion in Monadic Computations&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;rec&lt;/code&gt; -блок сообщает компилятор , где именно рекурсивный узел должен быть привязан. Оказывается, размещение рекурсивных узлов может быть довольно деликатным: в частности, мы хотели бы, чтобы узлы были обернуты вокруг как можно меньшего количества групп. Этот процесс известен как &lt;em&gt;сегментация&lt;/em&gt; и подробно описан в разделе 3.2 &lt;a href=&quot;http://leventerkok.github.io/papers/recdo.pdf&quot;&gt;Рекурсивной операции для Haskell&lt;/a&gt; . Сегментация улучшает полиморфизм и уменьшает размер рекурсивного узла. Что наиболее важно, он позволяет избежать ненужного вмешательства, вызванного фундаментальной проблемой с так называемой аксиомой &lt;em&gt;сжатия вправо&lt;/em&gt; для монадической рекурсии. Короче говоря, большинство представляющих интерес монад (IO, строгое состояние и т. Д.) &lt;em&gt;Не&lt;/em&gt;имеют операторы рекурсии, которые удовлетворяют этой аксиоме, и, таким образом, невыполнение сегментации может вызвать ненужные помехи, изменяя поведение завершения результирующего перевода. (Подробности можно найти в разделах 3.1 и 7.2.2 Рекурсии &lt;a href=&quot;http://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;значений в монадических вычислениях&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="0bdbd6d30e59c1faa209edf1aa68a5deb84cd963" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;lexically scoped type variable&lt;/em&gt; can be bound by:</source>
          <target state="translated">&lt;em&gt;Лексическую область видимости тип переменной&lt;/em&gt; может быть связано:</target>
        </trans-unit>
        <trans-unit id="109054251366535f7af799fd6243e0d372229344" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;package environment file&lt;/em&gt; is a file that tells &lt;code&gt;ghc&lt;/code&gt; precisely which packages should be visible. It can be used to create environments for &lt;code&gt;ghc&lt;/code&gt; or &lt;code&gt;ghci&lt;/code&gt; that are local to a shell session or to some file system location. They are intended to be managed by build/package tools, to enable &lt;code&gt;ghc&lt;/code&gt; and &lt;code&gt;ghci&lt;/code&gt; to automatically use an environment created by the tool.</source>
          <target state="translated">&lt;em&gt;Файл пакет среды&lt;/em&gt; представляет собой файл , который говорит &lt;code&gt;ghc&lt;/code&gt; точно , какие пакеты должны быть видны. Его можно использовать для создания окружений для &lt;code&gt;ghc&lt;/code&gt; или &lt;code&gt;ghci&lt;/code&gt; , которые являются локальными для сеанса оболочки или для некоторого местоположения файловой системы. Они предназначены для управления с помощью инструментов сборки / упаковки, чтобы позволить &lt;code&gt;ghc&lt;/code&gt; и &lt;code&gt;ghci&lt;/code&gt; автоматически использовать среду, созданную этим инструментом.</target>
        </trans-unit>
        <trans-unit id="c8382233c25160218d5faa2b0244da9d3072c08a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;safe import&lt;/em&gt; extension that specifies that the module being imported must be trusted.</source>
          <target state="translated">Расширение &lt;em&gt;безопасного импорта,&lt;/em&gt; которое указывает, что импортируемый модуль должен быть доверенным.</target>
        </trans-unit>
        <trans-unit id="a2030af640ee35ae911effa3c859071e394be43d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;segment&lt;/em&gt; of a given &lt;code&gt;mdo&lt;/code&gt;-expression is a minimal sequence of generators such that no generator of the sequence depends on an outside generator. As a special case, although it is not a generator, the final expression in an &lt;code&gt;mdo&lt;/code&gt;-expression is considered to form a segment by itself.</source>
          <target state="translated">&lt;em&gt;Сегмент&lt;/em&gt; данного &lt;code&gt;mdo&lt;/code&gt; -expression является минимальной последовательностью образующих таким образом, что нет генератора последовательности не зависит от внешнего генератора. В качестве особого случая считается, что последнее выражение в &lt;code&gt;mdo&lt;/code&gt; -выражении само по себе формирует сегмент , хотя оно и не является генератором .</target>
        </trans-unit>
        <trans-unit id="19ca4e3b6cf814de306149f6c08ac93ed06475ee" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;stable pointer&lt;/em&gt; is a reference to a Haskell expression that is guaranteed not to be affected by garbage collection, i.e., it will neither be deallocated nor will the value of the stable pointer itself change during garbage collection (ordinary references may be relocated during garbage collection). Consequently, stable pointers can be passed to foreign code, which can treat it as an opaque reference to a Haskell value.</source>
          <target state="translated">&lt;em&gt;Указатель стабильным&lt;/em&gt; является ссылкой на выражение Haskell , который гарантированно не могут быть затронуты в процессе сборки мусора, то есть, это ни будет освобождаться не будет значение указателя стабильной само изменение во время сборки мусора (обычные ссылки могут быть переселены во время сбора мусора ). Следовательно, стабильные указатели могут быть переданы внешнему коду, который может рассматривать его как непрозрачную ссылку на значение Haskell.</target>
        </trans-unit>
        <trans-unit id="9598916c07779e260b1bef0d4810f6ea9d7267b5" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;typed&lt;/em&gt; expression quotation is written as &lt;code&gt;[|| ... ||]&lt;/code&gt;, or &lt;code&gt;[e|| ... ||]&lt;/code&gt;, where the &amp;ldquo;&amp;hellip;&amp;rdquo; is an expression; if the &amp;ldquo;&amp;hellip;&amp;rdquo; expression has type &lt;code&gt;a&lt;/code&gt;, then the quotation has type &lt;code&gt;Q (TExp a)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03966a369ab9f12abf8e596ab2fa4aeb07d6727e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;typed&lt;/em&gt; expression quotation is written as &lt;code&gt;[|| ... ||]&lt;/code&gt;, or &lt;code&gt;[e|| ... ||]&lt;/code&gt;, where the &amp;rdquo;...&amp;rdquo; is an expression; if the &amp;rdquo;...&amp;rdquo; expression has type &lt;code&gt;a&lt;/code&gt;, then the quotation has type &lt;code&gt;Q (TExp a)&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Типизированное&lt;/em&gt; выражение котировка записываются в виде &lt;code&gt;[|| ... ||]&lt;/code&gt; или &lt;code&gt;[e|| ... ||]&lt;/code&gt; , где &amp;laquo;...&amp;raquo; - выражение; если выражение &amp;laquo;...&amp;raquo; имеет тип &lt;code&gt;a&lt;/code&gt; , то цитата имеет тип &lt;code&gt;Q (TExp a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bd2d6413fa23bbe46409864d68196768ad43eda" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;typed&lt;/em&gt; expression splice is written &lt;code&gt;$$x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is an identifier, or &lt;code&gt;$$(...)&lt;/code&gt;, where the &amp;ldquo;&amp;hellip;&amp;rdquo; is an arbitrary expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04024bbf6ad0e93c59da416e846a98466aa2e965" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;typed&lt;/em&gt; expression splice is written &lt;code&gt;$$x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is an identifier, or &lt;code&gt;$$(...)&lt;/code&gt;, where the &amp;rdquo;...&amp;rdquo; is an arbitrary expression.</source>
          <target state="translated">Соединение &lt;em&gt;типизированного&lt;/em&gt; выражения записывается как &lt;code&gt;$$x&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; - это идентификатор, или &lt;code&gt;$$(...)&lt;/code&gt; , где &amp;laquo;...&amp;raquo; - произвольное выражение.</target>
        </trans-unit>
        <trans-unit id="e77214962b033f462a16c20eb7078d49bb12efbd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;wrapper&lt;/em&gt; that for any datatype that is in &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt;, performs the conversion between the original value and its &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt;-based representation and then invokes the generic instances.</source>
          <target state="translated">&lt;em&gt;Обертка&lt;/em&gt; , что для любого типа данных , который находится в &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt; , выполняет преобразование между исходным значением и его &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; основанного представлением , а затем вызывает общие экземпляры.</target>
        </trans-unit>
        <trans-unit id="b326e9656587b1adc32b0826a631549e0850098e" translate="yes" xml:space="preserve">
          <source>A C &lt;code&gt;printf(3)&lt;/code&gt;-like formatter. This version has been extended by Bart Massey as per the recommendations of John Meacham and Simon Marlow &lt;a href=&quot;http://comments.gmane.org/gmane.comp.lang.haskell.libraries/4726&quot;&gt;http://comments.gmane.org/gmane.comp.lang.haskell.libraries/4726&lt;/a&gt; to support extensible formatting for new datatypes. It has also been extended to support almost all C &lt;code&gt;printf(3)&lt;/code&gt; syntax.</source>
          <target state="translated">Программа форматирования, подобная AC &lt;code&gt;printf(3)&lt;/code&gt; . Эта версия была расширена Барт Мэсси в соответствии с рекомендациями Джона Мичема и Саймона Марлоу &lt;a href=&quot;http://comments.gmane.org/gmane.comp.lang.haskell.libraries/4726&quot;&gt;http://comments.gmane.org/gmane.comp.lang.haskell.libraries/4726&lt;/a&gt; для поддержки расширяемого форматирования для новых типов данных. Он также был расширен для поддержки почти всего синтаксиса C &lt;code&gt;printf(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e0f8ee9d576152373e38d95b4048e53733a3d06" translate="yes" xml:space="preserve">
          <source>A C file not produced by the Haskell compiler.</source>
          <target state="translated">Файл на Си,не созданный компилятором Haskell.</target>
        </trans-unit>
        <trans-unit id="0aad97c64c03d205c1227f534babfb0125731f8e" translate="yes" xml:space="preserve">
          <source>A C string is a reference to an array of C characters terminated by NUL.</source>
          <target state="translated">Строка на языке C-это ссылка на массив символов на языке C,заканчивающийся на NUL.</target>
        </trans-unit>
        <trans-unit id="73ba7d14948cc5309d53b24f871c08ff3a2fc5ec" translate="yes" xml:space="preserve">
          <source>A C template should define a macro or function with name prefixed by &lt;code&gt;hsc_&lt;/code&gt; that handles the construct by emitting the expansion to stdout. See &lt;code&gt;template-hsc.h&lt;/code&gt; for examples.</source>
          <target state="translated">Шаблон AC должен определять макрос или функцию с именем с префиксом &lt;code&gt;hsc_&lt;/code&gt; , которая обрабатывает конструкцию, передавая расширение в stdout. Примеры см. В &lt;code&gt;template-hsc.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6886031497104d24437d52b2978fb1d3195d1677" translate="yes" xml:space="preserve">
          <source>A C wide string is a reference to an array of C wide characters terminated by NUL.</source>
          <target state="translated">Строка на языке C-это ссылка на массив символов на языке C,заканчивающийся на NUL.</target>
        </trans-unit>
        <trans-unit id="fff4ba731434913625d1042847648e899bcdc46f" translate="yes" xml:space="preserve">
          <source>A DynFlags plugin allows you to modify the &lt;code&gt;DynFlags&lt;/code&gt; that GHC is going to use when processing a given (set of) file(s). &lt;code&gt;DynFlags&lt;/code&gt; is a record containing all sorts of configuration and command line data, from verbosity level to the integer library to use, including compiler hooks, plugins and pretty-printing options. DynFlags plugins allow plugin authors to update any of those values before GHC starts doing any actual work, effectively meaning that the updates specified by the plugin will be taken into account and influence GHC&amp;rsquo;s behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e325f82925ec97e39b08ddc2fdbd0f77145b84c" translate="yes" xml:space="preserve">
          <source>A GADT can only be declared using GADT-style syntax (&lt;a href=&quot;#gadt-style&quot;&gt;Declaring data types with explicit constructor signatures&lt;/a&gt;); the old Haskell 98 syntax for data declarations always declares an ordinary data type. The result type of each constructor must begin with the type constructor being defined, but for a GADT the arguments to the type constructor can be arbitrary monotypes. For example, in the &lt;code&gt;Term&lt;/code&gt; data type above, the type of each constructor must end with &lt;code&gt;Term ty&lt;/code&gt;, but the &lt;code&gt;ty&lt;/code&gt; need not be a type variable (e.g. the &lt;code&gt;Lit&lt;/code&gt; constructor).</source>
          <target state="translated">GADT может быть объявлен только с использованием синтаксиса в стиле GADT (объявление &lt;a href=&quot;#gadt-style&quot;&gt;типов данных с явными сигнатурами конструктора&lt;/a&gt; ); старый синтаксис Haskell 98 для объявлений данных всегда объявляет обычный тип данных. Тип результата каждого конструктора должен начинаться с определяемого конструктора типа, но для GADT аргументы конструктора типа могут быть произвольными монотипами. Например, в приведенном выше типе данных &lt;code&gt;Term&lt;/code&gt; тип каждого конструктора должен заканчиваться &lt;code&gt;Term ty&lt;/code&gt; , но &lt;code&gt;ty&lt;/code&gt; не обязательно должен быть переменной типа (например, конструктор &lt;code&gt;Lit&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b1c115ed6390536f96008338c3a76d6dc97d17be" translate="yes" xml:space="preserve">
          <source>A Haskell equivalent of the C numeric type will be output. It will be one of &lt;code&gt;{Int,Word}{8,16,32,64}&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;LDouble&lt;/code&gt;.</source>
          <target state="translated">Будет выведен Haskell-эквивалент числового типа C. Это будет одно из &lt;code&gt;{Int,Word}{8,16,32,64}&lt;/code&gt; , &lt;code&gt;Float&lt;/code&gt; , &lt;code&gt;Double&lt;/code&gt; , &lt;code&gt;LDouble&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="411cbf3d599620cacbd5cc015731fcfe3b92f459" translate="yes" xml:space="preserve">
          <source>A Haskell interface file, probably compiler-generated.</source>
          <target state="translated">Файл интерфейса Хаскелла,вероятно,сгенерированный компилятором.</target>
        </trans-unit>
        <trans-unit id="bea884a4fa9bc97a6459261f9e280deaec7399ff" translate="yes" xml:space="preserve">
          <source>A Haskell module.</source>
          <target state="translated">Модуль Хаскелла.</target>
        </trans-unit>
        <trans-unit id="e5aff74609ec235803608003865846be7a8bd1bc" translate="yes" xml:space="preserve">
          <source>A Map from keys &lt;code&gt;k&lt;/code&gt; to values &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Карта от ключей &lt;code&gt;k&lt;/code&gt; до значений &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cea3593e9e6a31d8bb148597b7e5fd17de4ea82d" translate="yes" xml:space="preserve">
          <source>A TextDetails represents a fragment of text that will be output at some point in a &lt;code&gt;Doc&lt;/code&gt;.</source>
          <target state="translated">TextDetails представляет собой фрагмент текста, который будет выводиться в какой-то момент в &lt;code&gt;Doc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc9ca598a7522d4ced721535fa37974946883f88" translate="yes" xml:space="preserve">
          <source>A TimeZone is a whole number of minutes offset from UTC, together with a name and a &quot;just for summer&quot; flag.</source>
          <target state="translated">TimeZone-это смещение по UTC на целое количество минут,вместе с названием и флагом &quot;только на лето&quot;.</target>
        </trans-unit>
        <trans-unit id="c5ce154a6a02d4026db50fe3f1a5c49edc516fc7" translate="yes" xml:space="preserve">
          <source>A bang only really has an effect if it precedes a variable or wild-card pattern:</source>
          <target state="translated">Взрыв действительно имеет эффект,только если он предшествует переменной или шаблону wild-card:</target>
        </trans-unit>
        <trans-unit id="bdd93c38550cc32cf4aa813352ba8371915da4f4" translate="yes" xml:space="preserve">
          <source>A bang pattern is allowed in a let or where clause, and makes the binding strict. For example:</source>
          <target state="translated">Шаблон взрыва разрешен в пункте &quot;let&quot; или &quot;где&quot;,и делает обязательную к исполнению строгую.Например:</target>
        </trans-unit>
        <trans-unit id="dbe85709a7348f901616c420f38c5dde9ca96cf4" translate="yes" xml:space="preserve">
          <source>A bare kind variable (with &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; enabled). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8b165584d313eb61a9a907807491cb2de49845" translate="yes" xml:space="preserve">
          <source>A better method is to keep a global list of all child threads which we should wait for at the end of the program:</source>
          <target state="translated">Лучшим методом является ведение глобального списка всех дочерних потоков,который мы должны ждать в конце программы:</target>
        </trans-unit>
        <trans-unit id="6005fc493cfa098670cf6142c7e4205f8cdf474b" translate="yes" xml:space="preserve">
          <source>A better monoid for Maybe</source>
          <target state="translated">Лучший моноид для &quot;Может быть</target>
        </trans-unit>
        <trans-unit id="d6fedf65a2cdf1eec5e505a6812db33c8b5b82ec" translate="yes" xml:space="preserve">
          <source>A bidirectional pattern synonym matching an empty sequence.</source>
          <target state="translated">Двунаправленный синоним шаблона,совпадающий с пустой последовательностью.</target>
        </trans-unit>
        <trans-unit id="4177af688c85d2078a0a8ce62a0441115616a0c4" translate="yes" xml:space="preserve">
          <source>A bidirectional pattern synonym viewing the front of a non-empty sequence.</source>
          <target state="translated">Двунаправленный синоним шаблона,отображающий переднюю часть непустой последовательности.</target>
        </trans-unit>
        <trans-unit id="81df1a482fca8b73fcc642c85849297fd446593b" translate="yes" xml:space="preserve">
          <source>A bidirectional pattern synonym viewing the rear of a non-empty sequence.</source>
          <target state="translated">Синоним двунаправленного рисунка,отображающий заднюю часть непустой последовательности.</target>
        </trans-unit>
        <trans-unit id="9d4dd551ba4445c410acc2d23a963ba185817d09" translate="yes" xml:space="preserve">
          <source>A bifunctor is a type constructor that takes two type arguments and is a functor in &lt;em&gt;both&lt;/em&gt; arguments. That is, unlike with &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, a type constructor such as &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; does not need to be partially applied for a &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; instance, and the methods in this class permit mapping functions over the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; value or the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; value, or both at the same time.</source>
          <target state="translated">Бифунктор - это конструктор типа, который принимает два аргумента типа и является функтором в &lt;em&gt;обоих&lt;/em&gt; аргументах. То есть, в отличие от &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , конструктор типа, такой как &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; , не нужно частично применять для экземпляра &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; , а методы в этом классе разрешают функции сопоставления по &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; значению или &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; значению, или обоим одновременно.</target>
        </trans-unit>
        <trans-unit id="de0591af67d2bf9b3b0301e6aff8ce08884f0195" translate="yes" xml:space="preserve">
          <source>A big difference with higher-rank kinds as compared with higher-rank types is that &lt;code&gt;forall&lt;/code&gt;s in kinds &lt;em&gt;cannot&lt;/em&gt; be moved. This is best illustrated by example. Suppose we want to have an instance of &lt;code&gt;HTestEquality&lt;/code&gt; for &lt;code&gt;(:~~:)&lt;/code&gt;.</source>
          <target state="translated">Большая разница с более высоким рангом видами по сравнению с типами высокого ранга, что &lt;code&gt;forall&lt;/code&gt; s в видах &lt;em&gt;не может&lt;/em&gt; быть перемещена. Лучше всего это проиллюстрировать на примере. Предположим, мы хотим иметь экземпляр &lt;code&gt;HTestEquality&lt;/code&gt; для &lt;code&gt;(:~~:)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="018f1834f8f4ba2f827cc9e9d66782e066f8b4db" translate="yes" xml:space="preserve">
          <source>A big part of what makes the heaps fast is that they're non empty, so the merge function can avoid an extra case match. To take advantage of this, though, we need specialized versions of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt;, which can alternate between calling the faster semigroup-like merge when folding over non empty structures (like &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Node&quot;&gt;Node&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Digit&quot;&gt;Digit&lt;/a&gt;&lt;/code&gt;), and the &lt;code&gt;&lt;a href=&quot;data-semirgroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt;-like mappend, when folding over structures which can be empty (like &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:FingerTree&quot;&gt;FingerTree&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Большая часть того, что делает кучи быстрыми, заключается в том, что они не пусты, поэтому функция слияния может избежать дополнительного совпадения регистра. Однако, чтобы воспользоваться этим, нам нужны специализированные версии &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt; , которые могут чередоваться между вызовом более быстрого слияния, подобного полугруппе, при сворачивании непустых структур (таких как &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Node&quot;&gt;Node&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Digit&quot;&gt;Digit&lt;/a&gt;&lt;/code&gt; ) и &lt;code&gt;&lt;a href=&quot;data-semirgroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; - подобного mappend при сворачивании над структурами, которые могут быть пустыми (например, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:FingerTree&quot;&gt;FingerTree&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="47779d8a6c1ed5651ad2278a9f8963fba26cb6a4" translate="yes" xml:space="preserve">
          <source>A big part of what makes the heaps fast is that they're non empty, so the merge function can avoid an extra case match. To take advantage of this, though, we need specialized versions of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt;, which can alternate between calling the faster semigroup-like merge when folding over non empty structures (like &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Node&quot;&gt;Node&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Digit&quot;&gt;Digit&lt;/a&gt;&lt;/code&gt;), and the &lt;code&gt;&lt;a href=&quot;data-semirgroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt;-like mappend, when folding over structures which can be empty (like &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:FingerTree&quot;&gt;FingerTree&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59eaf213264b07a33c9b86cc594f16cfebf034b" translate="yes" xml:space="preserve">
          <source>A binding group is &lt;em&gt;fully generalised&lt;/em&gt; if and only if</source>
          <target state="translated">Связывающая группа является &lt;em&gt;полностью обобщенной&lt;/em&gt; тогда и только тогда, когда</target>
        </trans-unit>
        <trans-unit id="f0ac98b71fc651c5cb7838fb8ecc4183a85e5c4f" translate="yes" xml:space="preserve">
          <source>A biographical heap profile displays the portion of the live heap in each of the four states listed above. Usually the most interesting states are the void and drag states: live heap in these states is more likely to be wasted space than heap in the lag or use states.</source>
          <target state="translated">Биографический профиль кучи отображает часть живой кучи в каждом из четырех вышеперечисленных штатов.Обычно наиболее интересными состояниями являются состояния пустоты и перетаскивания:живая куча в этих состояниях с большей вероятностью останется пустым местом,чем куча в состояниях запаздывания или использования.</target>
        </trans-unit>
        <trans-unit id="798384519287140522d002a35024512e2c520012" translate="yes" xml:space="preserve">
          <source>A bound thread is a haskell thread that is &lt;em&gt;bound&lt;/em&gt; to an operating system thread. While the bound thread is still scheduled by the Haskell run-time system, the operating system thread takes care of all the foreign calls made by the bound thread.</source>
          <target state="translated">Связанный поток - это поток haskell, который &lt;em&gt;привязан&lt;/em&gt; к потоку операционной системы. Хотя связанный поток по-прежнему запланирован системой времени выполнения Haskell, поток операционной системы берет на себя все внешние вызовы, сделанные связанным потоком.</target>
        </trans-unit>
        <trans-unit id="3f4f07c153a23dab6881d6b97859240ea5495b6b" translate="yes" xml:space="preserve">
          <source>A buffer allocation strategy for executing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">Стратегия выделения буфера для выполнения &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="3acbb589dc6847927b75f04416af1f081adc5cfc" translate="yes" xml:space="preserve">
          <source>A buffer allocation strategy for executing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">Стратегия выделения буфера для выполнения &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="b00aec03f8bf511485eb07886b22c54f4f193a13" translate="yes" xml:space="preserve">
          <source>A builder primitive that always results in a sequence of bytes of a pre-determined, fixed size.</source>
          <target state="translated">Примитив конструктора,который всегда приводит к последовательности байт заранее заданного,фиксированного размера.</target>
        </trans-unit>
        <trans-unit id="218c8868a68984ef2191051e647e5ad44495f1c2" translate="yes" xml:space="preserve">
          <source>A builder primitive that always results in sequence of bytes that is no longer than a pre-determined bound.</source>
          <target state="translated">Строительный примитив,который всегда приводит к последовательности байтов,не превышающей заданную границу.</target>
        </trans-unit>
        <trans-unit id="cee5a68b267e0b9eedc95f3e5e46dbbcbd9d7c7d" translate="yes" xml:space="preserve">
          <source>A canonical proxy type</source>
          <target state="translated">Канонический тип прокси</target>
        </trans-unit>
        <trans-unit id="f9785a9266197868d744526bac75698ed903dbc4" translate="yes" xml:space="preserve">
          <source>A capability has been deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e42267c559ef0543a396aeedf38ba2368048b9" translate="yes" xml:space="preserve">
          <source>A capability has been disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86896e42132938a37e212fd5cef10f4151fc9477" translate="yes" xml:space="preserve">
          <source>A capability has been enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c58d21d44a4d30e0c00f0ffb699c3dbb7518536" translate="yes" xml:space="preserve">
          <source>A capability has been started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="646cfd44f97fd578432c1d7e4ee9f594332ba27b" translate="yes" xml:space="preserve">
          <source>A careful reading of the Haskell 98 Report reveals that fixity declarations (&lt;code&gt;infix&lt;/code&gt;, &lt;code&gt;infixl&lt;/code&gt;, and &lt;code&gt;infixr&lt;/code&gt;) are permitted to appear inside local bindings such those introduced by &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;where&lt;/code&gt;. However, the Haskell Report does not specify the semantics of such bindings very precisely.</source>
          <target state="translated">Внимательное чтение отчета Haskell 98 показывает, что объявлениям &lt;code&gt;infixl&lt;/code&gt; ( &lt;code&gt;infix&lt;/code&gt; , infixl и &lt;code&gt;infixr&lt;/code&gt; ) разрешено появляться внутри локальных привязок, таких как введенные &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;where&lt;/code&gt; . Однако отчет Haskell не очень точно определяет семантику таких привязок.</target>
        </trans-unit>
        <trans-unit id="6cad22f831909a841240c57158600100ecb21412" translate="yes" xml:space="preserve">
          <source>A caveat: this encoding strategy may not be reliable across different versions of GHC. When deriving a &lt;code&gt;Generic&lt;/code&gt; instance is free to choose any nesting of &lt;code&gt;:+:&lt;/code&gt; and &lt;code&gt;:*:&lt;/code&gt; it chooses, so if GHC chooses &lt;code&gt;(a :+: b) :+: c&lt;/code&gt;, then the encoding for &lt;code&gt;a&lt;/code&gt; would be &lt;code&gt;[O, O]&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; would be &lt;code&gt;[O, I]&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; would be &lt;code&gt;[I]&lt;/code&gt;. However, if GHC chooses &lt;code&gt;a :+: (b :+: c)&lt;/code&gt;, then the encoding for &lt;code&gt;a&lt;/code&gt; would be &lt;code&gt;[O]&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; would be &lt;code&gt;[I, O]&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; would be &lt;code&gt;[I, I]&lt;/code&gt;. (In practice, the current implementation tries to produce a more-or-less balanced nesting of &lt;code&gt;:+:&lt;/code&gt; and &lt;code&gt;:*:&lt;/code&gt; so that the traversal of the structure of the datatype from the root to a particular component can be performed in logarithmic rather than linear time.)</source>
          <target state="translated">Предостережение: эта стратегия кодирования может быть ненадежной в разных версиях GHC. При создании экземпляра &lt;code&gt;Generic&lt;/code&gt; можно выбрать любое вложение &lt;code&gt;:+:&lt;/code&gt; и &lt;code&gt;:*:&lt;/code&gt; по своему усмотрению, поэтому, если GHC выбирает &lt;code&gt;(a :+: b) :+: c&lt;/code&gt; , то кодировка для &lt;code&gt;a&lt;/code&gt; будет &lt;code&gt;[O, O]&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; будет &lt;code&gt;[O, I]&lt;/code&gt; , а &lt;code&gt;c&lt;/code&gt; будет &lt;code&gt;[I]&lt;/code&gt; . Однако, если GHC выбирает &lt;code&gt;a :+: (b :+: c)&lt;/code&gt; , тогда кодировка для &lt;code&gt;a&lt;/code&gt; будет &lt;code&gt;[O]&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; будет &lt;code&gt;[I, O]&lt;/code&gt; , а &lt;code&gt;c&lt;/code&gt; будет &lt;code&gt;[I, I]&lt;/code&gt; , (На практике текущая реализация пытается произвести более или менее сбалансированное вложение &lt;code&gt;:+:&lt;/code&gt; и &lt;code&gt;:*:&lt;/code&gt; так, чтобы переход структуры типа данных от корня к конкретному компоненту мог выполняться в логарифмическом, а не линейное время.)</target>
        </trans-unit>
        <trans-unit id="22d4b5245916ddee4003e31bf87953ef290e9b20" translate="yes" xml:space="preserve">
          <source>A class cannot generally have itself as a superclass. So this is illegal</source>
          <target state="translated">Класс,как правило,не может иметь себя в качестве суперкласса.Так что это незаконно</target>
        </trans-unit>
        <trans-unit id="f056b7a04761436a087354198406063da33c9730" translate="yes" xml:space="preserve">
          <source>A class declarations can either be abstract or concrete. An abstract class is one with no superclasses or class methods:</source>
          <target state="translated">Классовые декларации могут быть как абстрактными,так и конкретными.Абстрактный класс-это класс,в котором нет ни суперклассов,ни методов класса:</target>
        </trans-unit>
        <trans-unit id="1b36f377a6bd2fac28e2b563337bb9c2dc25741e" translate="yes" xml:space="preserve">
          <source>A class for categories. Instances should satisfy the laws</source>
          <target state="translated">Класс для категорий.Случаи должны соответствовать законам</target>
        </trans-unit>
        <trans-unit id="6fec2d7334def5a7f37888bee18c8bb561acd718" translate="yes" xml:space="preserve">
          <source>A class for things buildable from static pointers.</source>
          <target state="translated">Класс для вещей,построенных из статических указателей.</target>
        </trans-unit>
        <trans-unit id="16f65e9b0b64e45d51e0bcdd76ca8407c6f3cc52" translate="yes" xml:space="preserve">
          <source>A class method</source>
          <target state="translated">метод класса</target>
        </trans-unit>
        <trans-unit id="6f3ca3b97f5cb6f003ec47445c70a8cb5a13ebc9" translate="yes" xml:space="preserve">
          <source>A class method without a definition (neither a default definition, nor a definition in the appropriate instance) was called. The &lt;code&gt;String&lt;/code&gt; gives information about which method it was.</source>
          <target state="translated">Был вызван метод класса без определения (ни определения по умолчанию, ни определения в соответствующем экземпляре). &lt;code&gt;String&lt;/code&gt; дает информацию о том, какой метод он был.</target>
        </trans-unit>
        <trans-unit id="820008a62ac203372438ae344a8da118e60912d3" translate="yes" xml:space="preserve">
          <source>A class of bifunctors that can be fully evaluated.</source>
          <target state="translated">Класс бифункторов,который может быть полностью оценен.</target>
        </trans-unit>
        <trans-unit id="5f62d094b52f200eb67c73fe054a072916deee3f" translate="yes" xml:space="preserve">
          <source>A class of functors that can be fully evaluated.</source>
          <target state="translated">Класс functors,который может быть полностью оценен.</target>
        </trans-unit>
        <trans-unit id="03b36f13be1922d1c74d9e6e0b4b212a81502e1b" translate="yes" xml:space="preserve">
          <source>A class of types that can be fully evaluated.</source>
          <target state="translated">Класс типов,которые могут быть полностью оценены.</target>
        </trans-unit>
        <trans-unit id="18974c638151613690d5d785bcc282ea54126e16" translate="yes" xml:space="preserve">
          <source>A class, with a list of its visible instances</source>
          <target state="translated">Класс,со списком его видимых экземпляров.</target>
        </trans-unit>
        <trans-unit id="cf9b4ce512562f9b4a68069022cc221d559c7dde" translate="yes" xml:space="preserve">
          <source>A closed type family has a complete signature when all of its type variables are annotated and a return kind (with a top-level &lt;code&gt;::&lt;/code&gt;) is supplied.</source>
          <target state="translated">Семейство закрытых типов имеет полную сигнатуру, когда все его переменные типа аннотированы и предоставляется возвращаемый вид (с верхним уровнем &lt;code&gt;::&lt;/code&gt; :).</target>
        </trans-unit>
        <trans-unit id="5dfadf25c80308dd41216413c27a3be8dce8cf23" translate="yes" xml:space="preserve">
          <source>A closed type family may be declared with no equations. Such closed type families are opaque type-level definitions that will never reduce, are not necessarily injective (unlike empty data types), and cannot be given any instances. This is different from omitting the equations of a closed type family in a &lt;code&gt;hs-boot&lt;/code&gt; file, which uses the syntax &lt;code&gt;where ..&lt;/code&gt;, as in that case there may or may not be equations given in the &lt;code&gt;hs&lt;/code&gt; file.</source>
          <target state="translated">Семейство закрытых типов можно объявлять без уравнений. Такие закрытые семейства типов являются непрозрачными определениями на уровне типов, которые никогда не уменьшаются, не обязательно являются инъективными (в отличие от пустых типов данных) и не могут иметь никаких экземпляров. Это отличается от исключения уравнений семейства закрытых типов в файле &lt;code&gt;hs-boot&lt;/code&gt; , который использует синтаксис &lt;code&gt;where ..&lt;/code&gt; , поскольку в этом случае в файле &lt;code&gt;hs&lt;/code&gt; могут быть или не быть уравнения .</target>
        </trans-unit>
        <trans-unit id="5bc12f9a6f357ec15b737234f9f657aacb094303" translate="yes" xml:space="preserve">
          <source>A closed type family may optionally omit its equations, as in the following example:</source>
          <target state="translated">Семейство закрытого типа может по желанию опускать свои уравнения,как в следующем примере:</target>
        </trans-unit>
        <trans-unit id="560667c66049aeef765aec3cd394fe9074dbfde4" translate="yes" xml:space="preserve">
          <source>A closed type family&amp;rsquo;s equations are tried in order, from top to bottom, when simplifying a type family application. In this example, we declare an instance for &lt;code&gt;F&lt;/code&gt; such that &lt;code&gt;F Int&lt;/code&gt; simplifies to &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;F Bool&lt;/code&gt; simplifies to &lt;code&gt;Char&lt;/code&gt;, and for any other type &lt;code&gt;a&lt;/code&gt; that is known not to be &lt;code&gt;Int&lt;/code&gt; or &lt;code&gt;Bool&lt;/code&gt;, &lt;code&gt;F a&lt;/code&gt; simplifies to &lt;code&gt;String&lt;/code&gt;. Note that GHC must be sure that &lt;code&gt;a&lt;/code&gt; cannot unify with &lt;code&gt;Int&lt;/code&gt; or &lt;code&gt;Bool&lt;/code&gt; in that last case; if a programmer specifies just &lt;code&gt;F a&lt;/code&gt; in their code, GHC will not be able to simplify the type. After all, &lt;code&gt;a&lt;/code&gt; might later be instantiated with &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">Уравнения замкнутого семейства типов проверяются по порядку, сверху вниз, при упрощении приложения семейства типов. В этом примере мы объявляем экземпляр для &lt;code&gt;F&lt;/code&gt; так , что &lt;code&gt;F Int&lt;/code&gt; упрощается до &lt;code&gt;Double&lt;/code&gt; , &lt;code&gt;F Bool&lt;/code&gt; упрощается до &lt;code&gt;Char&lt;/code&gt; , а для любого другого типа &lt;code&gt;a&lt;/code&gt; , который, как известно, не является &lt;code&gt;Int&lt;/code&gt; или &lt;code&gt;Bool&lt;/code&gt; , &lt;code&gt;F a&lt;/code&gt; упрощается до &lt;code&gt;String&lt;/code&gt; . Обратите внимание, что GHC должен быть уверен, что &lt;code&gt;a&lt;/code&gt; не может объединиться с &lt;code&gt;Int&lt;/code&gt; или &lt;code&gt;Bool&lt;/code&gt; в последнем случае; если программист указывает только &lt;code&gt;F a&lt;/code&gt; в своем коде GHC не сможет упростить тип. В конце концов, позже может быть &lt;code&gt;a&lt;/code&gt; экземпляр с &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8038c2136e5194f458ce16e855b310af6be8edf" translate="yes" xml:space="preserve">
          <source>A closed type family&amp;rsquo;s equations have the same restrictions and extensions as the equations for open type family instances. For instance, when &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type or kind variables used on the left hand side of an equation can be explicitly bound, such as in:</source>
          <target state="translated">Уравнения семейства закрытого типа имеют те же ограничения и расширения, что и уравнения для экземпляров семейства открытого типа. Например, когда включен &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; , переменные типа или типа, используемые в левой части уравнения, могут быть явно связаны, например в:</target>
        </trans-unit>
        <trans-unit id="55db83fdd426c323b8ba055ddebf0f4927065c0d" translate="yes" xml:space="preserve">
          <source>A collection of FFI declarations for interfacing with Win32 Console API</source>
          <target state="translated">Коллекция FFI-деклараций для взаимодействия с Win32 Console API</target>
        </trans-unit>
        <trans-unit id="97dfd9521aba56f50c67376cea085b8e6e134f90" translate="yes" xml:space="preserve">
          <source>A collection of FFI declarations for interfacing with Win32 mapped files.</source>
          <target state="translated">Коллекция FFI-деклараций для взаимодействия с картографическими файлами Win32.</target>
        </trans-unit>
        <trans-unit id="0e9e3c664eeffb3c7374565940d3d04f59d623a4" translate="yes" xml:space="preserve">
          <source>A collection of FFI declarations for interfacing with Win32.</source>
          <target state="translated">Коллекция FFI-деклараций для взаимодействия с Win32.</target>
        </trans-unit>
        <trans-unit id="15a4c2ec78aa243e78e786440542fa86a3f898c2" translate="yes" xml:space="preserve">
          <source>A combination is &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Pure&quot;&gt;Pure&lt;/a&gt;&lt;/code&gt; only either part is.</source>
          <target state="translated">Комбинация &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Pure&quot;&gt;Pure&lt;/a&gt;&lt;/code&gt; только обе части.</target>
        </trans-unit>
        <trans-unit id="0e6111313c9398a428339ebfc1488b4234c0e6df" translate="yes" xml:space="preserve">
          <source>A combination is &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Pure&quot;&gt;Pure&lt;/a&gt;&lt;/code&gt; only if both parts are.</source>
          <target state="translated">Комбинация &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Pure&quot;&gt;Pure&lt;/a&gt;&lt;/code&gt; только если обе части чистые .</target>
        </trans-unit>
        <trans-unit id="1cf4024f647ac4b5f1014ad62fdb4551663a3cfd" translate="yes" xml:space="preserve">
          <source>A command line to execute using the shell</source>
          <target state="translated">Командная строка для выполнения с помощью оболочки</target>
        </trans-unit>
        <trans-unit id="2b42afbfaea58252904aedc72c342409dc5217ec" translate="yes" xml:space="preserve">
          <source>A common example is opening a file:</source>
          <target state="translated">Обычный пример-открытие файла:</target>
        </trans-unit>
        <trans-unit id="e611ccbbca22d800c83d8e50686983d00ac930b7" translate="yes" xml:space="preserve">
          <source>A common interface to a collection of useful concurrency abstractions.</source>
          <target state="translated">Общий интерфейс к коллекции полезных параллельных абстракций.</target>
        </trans-unit>
        <trans-unit id="158d48aa333ea6c2ec16fe37bdb3bd252bd76bb9" translate="yes" xml:space="preserve">
          <source>A common use of &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; is to process input from network sockets, &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s, and channels (e.g. &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Обычное использование &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; является вход процесса от сетевых розеток, &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; с, и каналов (например , &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="de5703326cbd6c93faef0a72782d20b8fe31e5ee" translate="yes" xml:space="preserve">
          <source>A common use of &lt;code&gt;&lt;a href=&quot;control-monad#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; is to run an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation returned from an &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; transaction, since &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; transactions can't perform &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; directly. Recall that</source>
          <target state="translated">Обычно &lt;code&gt;&lt;a href=&quot;control-monad#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; используется для выполнения вычисления &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; вывода, возвращаемого из транзакции &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; , поскольку транзакции &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; не могут выполнять &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; напрямую. Напомним, что</target>
        </trans-unit>
        <trans-unit id="d6b9bff21670bd6e1dbddd535cfab7c10fd33d82" translate="yes" xml:space="preserve">
          <source>A common use of &lt;code&gt;&lt;a href=&quot;ghc-base#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; is to run an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation returned from an &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; transaction, since &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; transactions can't perform &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; directly. Recall that</source>
          <target state="translated">Обычно &lt;code&gt;&lt;a href=&quot;ghc-base#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; используется для выполнения вычисления &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; вывода, возвращаемого из транзакции &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; , поскольку транзакции &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; не могут выполнять &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; напрямую. Напомним, что</target>
        </trans-unit>
        <trans-unit id="923f01eefd2602576139719f5c7af323619c5a66" translate="yes" xml:space="preserve">
          <source>A compact representation of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; vector.</source>
          <target state="translated">Компактное представление вектора &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5b6f1851ba64e7fbc006018f91e89cc899a277e" translate="yes" xml:space="preserve">
          <source>A compact representation of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; vector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc43ee46b5b21f3e78943bd2860ac98eafb0926" translate="yes" xml:space="preserve">
          <source>A compact representation suitable for storing short byte strings in memory.</source>
          <target state="translated">Компактное представление,подходящее для хранения коротких строк байтов в памяти.</target>
        </trans-unit>
        <trans-unit id="4dee1b6583088672899330bd95413844639d24f0" translate="yes" xml:space="preserve">
          <source>A concrete class specifies its superclasses, methods, default method signatures (but not their implementations) and a &lt;code&gt;MINIMAL&lt;/code&gt; pragma. Unlike regular Haskell classes, you don&amp;rsquo;t have to explicitly declare a default for a method to make it optional vis-a-vis the &lt;code&gt;MINIMAL&lt;/code&gt; pragma.</source>
          <target state="translated">Конкретный класс определяет свои Суперклассов, методы, сигнатуры метода по умолчанию (но не их реализация) и &lt;code&gt;MINIMAL&lt;/code&gt; Прагме. В отличие от обычных классов Haskell, вам не нужно явно объявлять значение по умолчанию для метода, чтобы сделать его необязательным по отношению к &lt;code&gt;MINIMAL&lt;/code&gt; MINIMAL.</target>
        </trans-unit>
        <trans-unit id="48e06f28fdc9e894b60b4a1b8a5f1e5767f7a49e" translate="yes" xml:space="preserve">
          <source>A concrete representation of &lt;code&gt;Version&lt;/code&gt;</source>
          <target state="translated">Конкретное представление &lt;code&gt;Version&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cb20f59e5f2e9ba3dec010b3eb3028f911a9a31" translate="yes" xml:space="preserve">
          <source>A concrete representation of a (monomorphic) type. &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; supports reasonably efficient equality.</source>
          <target state="translated">Конкретное представление (мономорфного) типа. &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; поддерживает достаточно эффективное равенство.</target>
        </trans-unit>
        <trans-unit id="11422484bfa14bcef95a9aa3860b69ba994b65fb" translate="yes" xml:space="preserve">
          <source>A concrete representation of a (monomorphic) type. &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; supports reasonably efficient equality.</source>
          <target state="translated">Конкретное представление (мономорфного) типа. &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; поддерживает достаточно эффективное равенство.</target>
        </trans-unit>
        <trans-unit id="0e1fa2e1fdd32663fb32988ae8b548b810674d4a" translate="yes" xml:space="preserve">
          <source>A concrete type constructor applied to some types.</source>
          <target state="translated">Конструктор бетонного типа применяется к некоторым типам.</target>
        </trans-unit>
        <trans-unit id="8bad079c8885ff9572beaf6828f7450891b38608" translate="yes" xml:space="preserve">
          <source>A concrete type literal.:</source>
          <target state="translated">Бетонный тип буквально..:</target>
        </trans-unit>
        <trans-unit id="5d4c61340ac65e2aef91e6fee099cfe89ce3d06e" translate="yes" xml:space="preserve">
          <source>A concrete, promotable proxy type, for use at the kind level. There are no instances for this because it is intended at the kind level only</source>
          <target state="translated">Конкретный,стимулирующий тип прокси,для использования на уровне вида.Случаев для этого нет,так как он предназначен только на уровне вида.</target>
        </trans-unit>
        <trans-unit id="63ae3dab5a2e143c3ea2383adfe2778d5d710d0b" translate="yes" xml:space="preserve">
          <source>A constraint in the type signature is not used in the code it covers:</source>
          <target state="translated">Ограничение в подписи типа не используется в коде,который она охватывает:</target>
        </trans-unit>
        <trans-unit id="84193f4f755d1c0b1057183b2a0adc6bf73de7fb" translate="yes" xml:space="preserve">
          <source>A constructor signature may mention type class constraints, which can differ for different constructors. For example, this is fine:</source>
          <target state="translated">В сигнатуре конструктора могут быть указаны ограничения типов классов,которые могут отличаться для разных конструкторов.Например,это нормально:</target>
        </trans-unit>
        <trans-unit id="1fe5ae7286a52f71d84c6187f3fe447df9c9228a" translate="yes" xml:space="preserve">
          <source>A contrived addition example. Works only with positive numbers:</source>
          <target state="translated">Искусственный пример добавления.Работает только с положительными числами:</target>
        </trans-unit>
        <trans-unit id="0df890da0fb3e9db7fe956f05674d4d8aa062f47" translate="yes" xml:space="preserve">
          <source>A conversion specification begins with the character &lt;code&gt;%&lt;/code&gt;, followed by zero or more of the following flags:</source>
          <target state="translated">Спецификация преобразования начинается с символа &lt;code&gt;%&lt;/code&gt; , за которым следует ноль или более следующих флагов:</target>
        </trans-unit>
        <trans-unit id="dd84caa4cb664b8bd50303514ba4d2b0f6763dd8" translate="yes" xml:space="preserve">
          <source>A corresponding Haskell value looks like this:</source>
          <target state="translated">Соответствующее значение Хаскелла выглядит так:</target>
        </trans-unit>
        <trans-unit id="2f782e63a1f3f05e6a16c8d7b64076664f462677" translate="yes" xml:space="preserve">
          <source>A cost-centre from GHC's cost-center profiler.</source>
          <target state="translated">Стоимость в профилировщике GHC.</target>
        </trans-unit>
        <trans-unit id="ba083c36a70a7120687138d63b14bdaf702d8dac" translate="yes" xml:space="preserve">
          <source>A cost-centre stack from GHC's cost-center profiler.</source>
          <target state="translated">Стоимость стека из профилировщика стоимости GHC.</target>
        </trans-unit>
        <trans-unit id="50ea9d5bdb5ec17d018609e47a9ec22b64ecd54e" translate="yes" xml:space="preserve">
          <source>A couple of things to notice:</source>
          <target state="translated">Пара вещей,на которые стоит обратить внимание:</target>
        </trans-unit>
        <trans-unit id="3dc945323c54ee396119be0717674ee79090c303" translate="yes" xml:space="preserve">
          <source>A custom &lt;code&gt;&lt;a href=&quot;system-console-haskeline-completion#t:CompletionFunc&quot;&gt;CompletionFunc&lt;/a&gt;&lt;/code&gt; which completes the word immediately to the left of the cursor, and takes into account the line contents to the left of the word.</source>
          <target state="translated">Пользовательский &lt;code&gt;&lt;a href=&quot;system-console-haskeline-completion#t:CompletionFunc&quot;&gt;CompletionFunc&lt;/a&gt;&lt;/code&gt; , который завершает слово сразу слева от курсора и учитывает содержимое строки слева от слова.</target>
        </trans-unit>
        <trans-unit id="8c0d52f3762ec276383b7f73f082f54d2df5f0bc" translate="yes" xml:space="preserve">
          <source>A custom &lt;code&gt;&lt;a href=&quot;system-console-haskeline-completion#t:CompletionFunc&quot;&gt;CompletionFunc&lt;/a&gt;&lt;/code&gt; which completes the word immediately to the left of the cursor.</source>
          <target state="translated">Пользовательский &lt;code&gt;&lt;a href=&quot;system-console-haskeline-completion#t:CompletionFunc&quot;&gt;CompletionFunc&lt;/a&gt;&lt;/code&gt; , который завершает слово сразу слева от курсора.</target>
        </trans-unit>
        <trans-unit id="5862453396404797aa7de7142dce28109cb9b288" translate="yes" xml:space="preserve">
          <source>A custom pre-processor is run over your Haskell source file only if the &lt;code&gt;-F&lt;/code&gt; option is given.</source>
          <target state="translated">Пользовательский препроцессор запускается в исходном файле Haskell только в том случае, если задана опция &lt;code&gt;-F&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1599a4a0a331f022d3d429faece9bf7cf541b2b9" translate="yes" xml:space="preserve">
          <source>A custom pretty printing function can be used, for example, to format tree-like and nested structures in a more readable way.</source>
          <target state="translated">Пользовательская красивая функция печати может быть использована,например,для более читабельного форматирования древовидных и вложенных структур.</target>
        </trans-unit>
        <trans-unit id="f8eb6d3c983aaf3cde12f740cd4904b0498bd294" translate="yes" xml:space="preserve">
          <source>A data constructor</source>
          <target state="translated">Конструктор данных</target>
        </trans-unit>
        <trans-unit id="b5d4cb00190598ddeec4823830bc239b1485a236" translate="yes" xml:space="preserve">
          <source>A data family instance declaration can use the full expressiveness of ordinary &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt; declarations:</source>
          <target state="translated">Объявление экземпляра семейства данных может использовать полную выразительность обычных &lt;code&gt;data&lt;/code&gt; или объявлений &lt;code&gt;newtype&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f190b4f01195b249d3555778e7d04af0949a28aa" translate="yes" xml:space="preserve">
          <source>A data or type synonym family can be declared as part of a type class, thus:</source>
          <target state="translated">Таким образом,данные или семейство синонимов типов могут быть объявлены как часть класса типов:</target>
        </trans-unit>
        <trans-unit id="4fab55b5200474635e47e3680a86e7055016af5b" translate="yes" xml:space="preserve">
          <source>A data type declaration can either be given in full, exactly as in Haskell, or it can be given abstractly, by omitting the &amp;lsquo;=&amp;rsquo; sign and everything that follows. For example:</source>
          <target state="translated">Объявление типа данных может быть дано полностью, как в Haskell, или может быть дано абстрактно, опуская знак '=' и все, что следует за ним. Например:</target>
        </trans-unit>
        <trans-unit id="3df736aafe2d3db3e69d9a2a8f83fab7d3cd7998" translate="yes" xml:space="preserve">
          <source>A data type has no type parameters (e.g., &lt;code&gt;data Nothing = Nothing&lt;/code&gt;).</source>
          <target state="translated">Тип данных не имеет параметров типа (например, &lt;code&gt;data Nothing = Nothing&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="586827d4266b3d644377c42c18624801ae4ad40a" translate="yes" xml:space="preserve">
          <source>A data type&amp;rsquo;s last type variable is used in a &lt;a href=&quot;#extension-DatatypeContexts&quot;&gt;&lt;code&gt;DatatypeContexts&lt;/code&gt;&lt;/a&gt; constraint (e.g., &lt;code&gt;data Ord a =&amp;gt; O a = O a&lt;/code&gt;).</source>
          <target state="translated">Переменная последнего типа типа данных используется в ограничении &lt;a href=&quot;#extension-DatatypeContexts&quot;&gt; &lt;code&gt;DatatypeContexts&lt;/code&gt; &lt;/a&gt; (например, &lt;code&gt;data Ord a =&amp;gt; O a = O a&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="541952865f0bce99dfba54b59c18bf4d90b79e63" translate="yes" xml:space="preserve">
          <source>A data type&amp;rsquo;s last type variable is used in an &lt;a href=&quot;#extension-ExistentialQuantification&quot;&gt;&lt;code&gt;ExistentialQuantification&lt;/code&gt;&lt;/a&gt; constraint, or is refined in a GADT. For example,</source>
          <target state="translated">Переменная последнего типа типа данных используется в ограничении &lt;a href=&quot;#extension-ExistentialQuantification&quot;&gt; &lt;code&gt;ExistentialQuantification&lt;/code&gt; &lt;/a&gt; или уточняется в GADT. Например,</target>
        </trans-unit>
        <trans-unit id="21d82223d3ac86e9e0f5a1e86033ba159dc2adca" translate="yes" xml:space="preserve">
          <source>A datatype-generic function comprises two parts:</source>
          <target state="translated">Функция генерирования данных состоит из двух частей:</target>
        </trans-unit>
        <trans-unit id="6264b318464960e93f9c184b690473f5a5728225" translate="yes" xml:space="preserve">
          <source>A declaration type signature (&lt;a href=&quot;#decl-type-sigs&quot;&gt;Declaration type signatures&lt;/a&gt;)</source>
          <target state="translated">Подпись типа объявления ( &lt;a href=&quot;#decl-type-sigs&quot;&gt;подписи типа объявления&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="ee69366de998246ce67952ee9a1a1b3b6c96d4af" translate="yes" xml:space="preserve">
          <source>A declaration type signature that has &lt;em&gt;explicit&lt;/em&gt; quantification (using &lt;code&gt;forall&lt;/code&gt;) brings into scope the explicitly-quantified type variables, in the definition of the named function. For example:</source>
          <target state="translated">Сигнатура типа объявления, которая имеет &lt;em&gt;явную&lt;/em&gt; количественную оценку (с использованием &lt;code&gt;forall&lt;/code&gt; ), вводит в область видимости явно определенные количественные переменные типа в определении названной функции. Например:</target>
        </trans-unit>
        <trans-unit id="7a000f3b48bd252b4ec5f85b4c427ccb663838bd" translate="yes" xml:space="preserve">
          <source>A decoder procuced by running a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">Декодер, получаемый при запуске монады &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d17b00ef4a90f5cabfdbf829a677b6db008e640" translate="yes" xml:space="preserve">
          <source>A default declaration is not permitted for an associated &lt;em&gt;data&lt;/em&gt; type.</source>
          <target state="translated">Объявление по умолчанию не разрешено для связанного типа &lt;em&gt;данных&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="13508033e2c27b5de3214a6e0b6e522b009a007b" translate="yes" xml:space="preserve">
          <source>A default definition of &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldMap&quot;&gt;bifoldMap&lt;/a&gt;&lt;/code&gt; in terms of the &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">Определение &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldMap&quot;&gt;bifoldMap&lt;/a&gt;&lt;/code&gt; по умолчанию с точки &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; операций Bitraversable .</target>
        </trans-unit>
        <trans-unit id="a5b5443d78a52a0405c2f0d6239820bf3007f82e" translate="yes" xml:space="preserve">
          <source>A default definition of &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; in terms of the &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">Определение &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; по умолчанию с точки &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; операций Bitraversable .</target>
        </trans-unit>
        <trans-unit id="8979aa9d1894c898d3c726fca41fdca65c4a33d5" translate="yes" xml:space="preserve">
          <source>A default element</source>
          <target state="translated">Элемент по умолчанию</target>
        </trans-unit>
        <trans-unit id="6b0ba2dc21c07d694dd7ceb37775a8c3eee889d5" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt; must satisfy the following laws:</source>
          <target state="translated">Определение &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt; должно удовлетворять следующим законам:</target>
        </trans-unit>
        <trans-unit id="a180dbe254c504564dcc326aee311c425f63e9ec" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; must satisfy the following laws:</source>
          <target state="translated">Определение &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; A должно удовлетворять следующим законам:</target>
        </trans-unit>
        <trans-unit id="16de260f1c6cac6529ed6b018b65c836efe37f81" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; must satisfy the following laws:</source>
          <target state="translated">Определение &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; должно удовлетворять следующим законам:</target>
        </trans-unit>
        <trans-unit id="47d9196fc9df3f1fb6cf5bd564f834d9d06f81f1" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;&lt;a href=&quot;prelude#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; must satisfy the following laws:</source>
          <target state="translated">Определение &lt;code&gt;&lt;a href=&quot;prelude#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; A должно удовлетворять следующим законам:</target>
        </trans-unit>
        <trans-unit id="dc3862240a73ca7ad48aba38069f60afa153c34d" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;&lt;a href=&quot;prelude#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; must satisfy the following laws:</source>
          <target state="translated">Определение &lt;code&gt;&lt;a href=&quot;prelude#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; должно удовлетворять следующим законам:</target>
        </trans-unit>
        <trans-unit id="06c816889d8c0a0e486735490b0238ade51de818" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;safeDiv&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;control-monad#v:guard&quot;&gt;guard&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;&lt;code&gt;do&lt;/code&gt;-notation:</source>
          <target state="translated">Определение &lt;code&gt;safeDiv&lt;/code&gt; с использованием нотации &lt;code&gt;&lt;a href=&quot;control-monad#v:guard&quot;&gt;guard&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; &lt;code&gt;do&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c1670eef1322c0d7b707d0ae468ed9e809e67e91" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;safeDiv&lt;/code&gt; using guards, but not &lt;code&gt;&lt;a href=&quot;control-monad#v:guard&quot;&gt;guard&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Определение &lt;code&gt;safeDiv&lt;/code&gt; с использованием охранников, но не &lt;code&gt;&lt;a href=&quot;control-monad#v:guard&quot;&gt;guard&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="006a6845e3a856bbfba4df0255e3848a4a860831" translate="yes" xml:space="preserve">
          <source>A definition of &lt;em&gt;trust&lt;/em&gt; (or safety) and how it operates, along with ways of defining and changing the trust of modules and packages.</source>
          <target state="translated">Определение &lt;em&gt;доверия&lt;/em&gt; (или безопасности) и то, как оно работает, а также способы определения и изменения доверия модулей и пакетов.</target>
        </trans-unit>
        <trans-unit id="1fb7cf11f58e4e4a3003926053464a1496f9bd2f" translate="yes" xml:space="preserve">
          <source>A deprecated alias of &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt; псевдоним RankNTypes .</target>
        </trans-unit>
        <trans-unit id="c13f98be7b9473c582b30f2dd1c5005c007bdc07" translate="yes" xml:space="preserve">
          <source>A derived instance is derived only for declarations of these forms (after expansion of any type synonyms)</source>
          <target state="translated">Производный экземпляр выводится только для деклараций этих форм (после расширения синонимов любого типа).</target>
        </trans-unit>
        <trans-unit id="fd8f6757bd0323a7730e959138361a06c176f799" translate="yes" xml:space="preserve">
          <source>A description of a custom type error.</source>
          <target state="translated">Описание ошибки пользовательского типа.</target>
        </trans-unit>
        <trans-unit id="97496eb0e26835b32d2dfe1ae69ecf8a627e29cb" translate="yes" xml:space="preserve">
          <source>A descriptive string roughly identifying the cost-centre.</source>
          <target state="translated">Описательная строка,грубо определяющая центр затрат.</target>
        </trans-unit>
        <trans-unit id="1814a528e490de53f22aa61afcafb8d5feeb8d24" translate="yes" xml:space="preserve">
          <source>A different approach is to group the option values in a record of type &lt;code&gt;Options&lt;/code&gt;, and have each flag yield a function of type &lt;code&gt;Options -&amp;gt; Options&lt;/code&gt; transforming this record.</source>
          <target state="translated">Другой подход состоит в том, чтобы сгруппировать значения параметров в записи типа &lt;code&gt;Options&lt;/code&gt; , и каждый флаг должен давать функцию типа &lt;code&gt;Options -&amp;gt; Options&lt;/code&gt; преобразующую эту запись.</target>
        </trans-unit>
        <trans-unit id="bbb68a110439919741a19755964df2e6fa3244b4" translate="yes" xml:space="preserve">
          <source>A directory contains a series of entries, each of which is a named reference to a file system object (file, directory etc.). Some entries may be hidden, inaccessible, or have some administrative function (e.g. &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt; under &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399&quot;&gt;POSIX&lt;/a&gt;), but in this standard all such entries are considered to form part of the directory contents. Entries in sub-directories are not, however, considered to form part of the directory contents.</source>
          <target state="translated">Каталог содержит серию записей, каждая из которых является именованной ссылкой на объект файловой системы (файл, каталог и т. Д.). Некоторые записи могут быть скрыты, недоступны, или иметь некоторую административную функцию (например &lt;code&gt;.&lt;/code&gt; Или &lt;code&gt;..&lt;/code&gt; под &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399&quot;&gt;POSIX&lt;/a&gt; ), но в этом стандарте все такие записи считаются составляют часть содержимого каталога. Однако записи в подкаталогах не считаются частью содержимого каталога.</target>
        </trans-unit>
        <trans-unit id="7cea28c5c17737eb22d5290576e72180db68e967" translate="yes" xml:space="preserve">
          <source>A document of height 1 containing a literal string. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt;&lt;/code&gt; satisfies the following laws:</source>
          <target state="translated">Документ высотой 1, содержащий буквальную строку. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt;&lt;/code&gt; удовлетворяет следующим законам:</target>
        </trans-unit>
        <trans-unit id="a7c0af88c561dd3e381e4c0c9eb468d9f9adda7d" translate="yes" xml:space="preserve">
          <source>A document of height 1 containing a literal string. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt;&lt;/code&gt; satisfies the following laws:</source>
          <target state="translated">Документ высотой 1, содержащий буквальную строку. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt;&lt;/code&gt; удовлетворяет следующим законам:</target>
        </trans-unit>
        <trans-unit id="b60445ccdc10943dbfcb65b6302d60eef3c3dd3b" translate="yes" xml:space="preserve">
          <source>A document of height 1 containing a literal string. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt;&lt;/code&gt; satisfies the following laws:</source>
          <target state="translated">Документ высотой 1, содержащий буквальную строку. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt;&lt;/code&gt; удовлетворяет следующим законам:</target>
        </trans-unit>
        <trans-unit id="688bfb4bbd29b21c2ae8d691c138d77983de8115" translate="yes" xml:space="preserve">
          <source>A document of height and width 1, containing a literal character.</source>
          <target state="translated">Документ высотой и шириной 1,содержащий буквальный символ.</target>
        </trans-unit>
        <trans-unit id="6b6ebd185f2a3b55592691251680ab65322061fe" translate="yes" xml:space="preserve">
          <source>A duplex communications channel (results in creation of a duplex &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;). The standard libraries use this device type when creating &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s for open sockets.</source>
          <target state="translated">Дуплексный канал связи (приводит к созданию дуплексного &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; ). Стандартные библиотеки используют этот тип устройства при создании &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; для открытых сокетов.</target>
        </trans-unit>
        <trans-unit id="86a3012ad906142a305a738b9de653227862c657" translate="yes" xml:space="preserve">
          <source>A expression quotation is written in Oxford brackets, thus:</source>
          <target state="translated">Таким образом,цитата из выражения записывается в оксфордские скобки:</target>
        </trans-unit>
        <trans-unit id="5e47ffa147be43069d678d8783f87f9374b92f8d" translate="yes" xml:space="preserve">
          <source>A feature or operation which a &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Terminal&quot;&gt;Terminal&lt;/a&gt;&lt;/code&gt; may define.</source>
          <target state="translated">Функция или операция, которую может определять &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Terminal&quot;&gt;Terminal&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14e098e337088120cd46a6eee334387a102be1a6" translate="yes" xml:space="preserve">
          <source>A few caveats apply here. First, it is illegal to export an entity which refers to a locally defined type which itself is not exported (GHC will report an error in this case). Second, signatures which come from dependencies which expose modules cannot be thinned in this way (after all, the dependency itself may need the entity); these requirements are unconditionally exported. Finally, any module reexports must refer to modules imported by the local signature (even if an inherited signature exported the module).</source>
          <target state="translated">Здесь есть несколько предостережений.Во-первых,запрещен экспорт сущности,которая относится к локально определённому типу,но которая сама по себе не экспортируется (GHC в этом случае сообщит об ошибке).Во-вторых,сигнатуры,которые приходят от зависимостей,которые обнажают модули,не могут быть прорезаны таким образом (в конце концов,зависимость сама по себе может нуждаться в сущности);эти требования экспортируются безоговорочно.Наконец,любой реэкспорт модуля должен относиться к модулям,импортируемым локальной подписью (даже если экспортируется унаследованная подпись модуля).</target>
        </trans-unit>
        <trans-unit id="ebd630669cc76942437803b1fb8107b3e2063e84" translate="yes" xml:space="preserve">
          <source>A few functors support an implementation of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; that is more efficient than the default one.</source>
          <target state="translated">Некоторые функторы поддерживают реализацию &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , которая более эффективна, чем стандартная.</target>
        </trans-unit>
        <trans-unit id="4e9bb325d8e94370ab23120a7426d9ee7ea2c654" translate="yes" xml:space="preserve">
          <source>A few functors support an implementation of &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; that is more efficient than the default one.</source>
          <target state="translated">Некоторые функторы поддерживают реализацию &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , которая более эффективна, чем стандартная.</target>
        </trans-unit>
        <trans-unit id="feddbc495dd6f9bc1a1874e911421fb2030f4453" translate="yes" xml:space="preserve">
          <source>A few functors support an implementation of &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; that is more efficient than the default one.</source>
          <target state="translated">Некоторые функторы поддерживают реализацию &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , которая более эффективна, чем стандартная.</target>
        </trans-unit>
        <trans-unit id="412108fee011dff2957aa26fc118a779db7cb3e1" translate="yes" xml:space="preserve">
          <source>A field must be in scope for the corresponding &lt;code&gt;HasField&lt;/code&gt; constraint to be solved. This retains the existing representation hiding mechanism, whereby a module may choose not to export a field, preventing client modules from accessing or updating it directly.</source>
          <target state="translated">Поле должно быть в области действия, чтобы соответствующее ограничение &lt;code&gt;HasField&lt;/code&gt; было разрешено. При этом сохраняется существующий механизм сокрытия представления, посредством которого модуль может решить не экспортировать поле, не позволяя клиентским модулям напрямую обращаться к нему или обновлять его.</target>
        </trans-unit>
        <trans-unit id="647667c77d993eaf0e249337caf2de0283b2f13c" translate="yes" xml:space="preserve">
          <source>A file created by the preprocessor.</source>
          <target state="translated">Файл,созданный препроцессором.</target>
        </trans-unit>
        <trans-unit id="10a6f21acebb16166b923fe8816f24879cac7dc7" translate="yes" xml:space="preserve">
          <source>A file descriptor registration cookie.</source>
          <target state="translated">Куки-файл регистрации дескрипторов файлов.</target>
        </trans-unit>
        <trans-unit id="b7ff63f15803ad313bc70e86c0b9af3bd034d57c" translate="yes" xml:space="preserve">
          <source>A file that may be read or written, and also may be seekable.</source>
          <target state="translated">Файл,который может быть прочитан или написан,а также может быть доступен для поиска.</target>
        </trans-unit>
        <trans-unit id="3fc8729fc9cba21c227493e06ca57c42259f5fbc" translate="yes" xml:space="preserve">
          <source>A file-header pragma must precede the &lt;code&gt;module&lt;/code&gt; keyword in the file.</source>
          <target state="translated">Прагма заголовка файла должна предшествовать ключевому слову &lt;code&gt;module&lt;/code&gt; в файле.</target>
        </trans-unit>
        <trans-unit id="ee69f3557f209a70b6dbd3e30733ef3266ad45c4" translate="yes" xml:space="preserve">
          <source>A finalizer is not always called after its weak pointer's object becomes unreachable. There are two situations that can cause this:</source>
          <target state="translated">Финишилизатор не всегда вызывается после того,как объект его слабого указателя становится недоступным.Есть две ситуации,которые могут вызвать это:</target>
        </trans-unit>
        <trans-unit id="c83751e185497b34efc04696de873a6948bad996" translate="yes" xml:space="preserve">
          <source>A finalizer is represented as a pointer to a foreign function that, at finalisation time, gets as an argument a plain pointer variant of the foreign pointer that the finalizer is associated with.</source>
          <target state="translated">Финализатор представляется как указатель на инородную функцию,которая во время завершения работы получает в качестве аргумента вариант простого указателя на инородный указатель,с которым связан финализатор.</target>
        </trans-unit>
        <trans-unit id="1df6acc2d101561b7dc4207a365d517cbb075848" translate="yes" xml:space="preserve">
          <source>A fixed-precision integer type with at least the range &lt;code&gt;[-2^29 .. 2^29-1]&lt;/code&gt;. The exact range for a given implementation can be determined by using &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">Целочисленный тип фиксированной точности с диапазоном не менее &lt;code&gt;[-2^29 .. 2^29-1]&lt;/code&gt; . Точный диапазон для данной реализации можно определить с помощью &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; из класса &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5c0b209d881b38e76f482af23564dfb8494b98b" translate="yes" xml:space="preserve">
          <source>A flag to disable Safe Haskell checks:</source>
          <target state="translated">Флаг,чтобы отключить проверки Безопасного Хаскелла:</target>
        </trans-unit>
        <trans-unit id="5e83789a4d462ba5ff17578c25dbd53a56499d15" translate="yes" xml:space="preserve">
          <source>A flexible variation parameterised in a type constructor</source>
          <target state="translated">Гибкий вариант,параметризованный в конструкторе типа.</target>
        </trans-unit>
        <trans-unit id="ae7acb61d64b5e1b08a76042f669d06cf246bf79" translate="yes" xml:space="preserve">
          <source>A fmap-like operator for builder primitives, both bounded and fixed size.</source>
          <target state="translated">fmap-подобный оператор для примитивов конструктора,как ограниченного,так и фиксированного размера.</target>
        </trans-unit>
        <trans-unit id="3156de946a16b219e4da74bb691b1f317bcde8a4" translate="yes" xml:space="preserve">
          <source>A frontend plugin allows you to add new major modes to GHC. You may prefer this over a traditional program which calls the GHC API, as GHC manages a lot of parsing flags and administrative nonsense which can be difficult to manage manually. To load a frontend plugin exported by &lt;code&gt;Foo.FrontendPlugin&lt;/code&gt;, we just invoke GHC with the &lt;code&gt;--frontend ⟨module⟩&lt;/code&gt; flag as follows:</source>
          <target state="translated">Плагин внешнего интерфейса позволяет добавлять новые основные режимы в GHC. Вы можете предпочесть это традиционной программе, которая вызывает GHC API, поскольку GHC управляет множеством флагов синтаксического анализа и административной ерундой, которой может быть трудно управлять вручную. Чтобы загрузить плагин &lt;code&gt;Foo.FrontendPlugin&lt;/code&gt; интерфейса, экспортированный Foo.FrontendPlugin , мы просто вызываем GHC с флагом &lt;code&gt;--frontend ⟨module⟩&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="a6ca1012af98c96815c71a4e1c588fc523445abe" translate="yes" xml:space="preserve">
          <source>A function can request its call-site with the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint. For example, we can define</source>
          <target state="translated">Функция может запросить свой сайт вызова с ограничением &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; . Например, мы можем определить</target>
        </trans-unit>
        <trans-unit id="85ce5ed93025fc855be629c4ba88fa8a1670bc1d" translate="yes" xml:space="preserve">
          <source>A function can request its call-site with the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint. For example, we can define</source>
          <target state="translated">Функция может запросить свой сайт вызова с ограничением &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; . Например, мы можем определить</target>
        </trans-unit>
        <trans-unit id="b827823da9db0cd7f4da87d2bab81acb959e4419" translate="yes" xml:space="preserve">
          <source>A function can request its call-site with the &lt;code&gt;HasCallStack&lt;/code&gt; constraint and access it as a Haskell value by using &lt;code&gt;callStack&lt;/code&gt;.</source>
          <target state="translated">Функция может запросить свой сайт вызова с ограничением &lt;code&gt;HasCallStack&lt;/code&gt; и получить к нему доступ как к значению Haskell с помощью &lt;code&gt;callStack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="959c41ee1afd55fc73fec6ad553ce55c337100e6" translate="yes" xml:space="preserve">
          <source>A function that accepts another &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. That string will be assumed to directly follow the string that was passed as input to the original function, and it will in turn be decoded.</source>
          <target state="translated">Функция, которая принимает другую &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . Предполагается, что эта строка следует непосредственно за строкой, переданной в качестве входных данных исходной функции, и она, в свою очередь, будет декодирована.</target>
        </trans-unit>
        <trans-unit id="146f819aeac6eebc6c002e437bb527a05441309a" translate="yes" xml:space="preserve">
          <source>A function that fills a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;, calls the continuation with the updated &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; and its computed value once its done, and signals its caller how to proceed using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; signals.</source>
          <target state="translated">Функция, которая заполняет &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; , вызывает продолжение с обновленным &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; и его вычисленным значением после его завершения и сигнализирует вызывающей &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt; , как продолжить, используя сигналы &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; , bufferFull или &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9fe9550377f39c1dda07402c3e5dd3c52deb055" translate="yes" xml:space="preserve">
          <source>A function that fills a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;, calls the continuation with the updated &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; once its done, and signals its caller how to proceed using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция, которая заполняет &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; , после завершения вызывает продолжение с обновленным &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; и сигнализирует вызывающей &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt; , как действовать дальше, используя &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; , bufferFull или &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a1cfa6ac431e810bfaf7276b3ed3786ed71fd59" translate="yes" xml:space="preserve">
          <source>A function that peeks a field of a C struct will be output. It will have the type &lt;code&gt;Storable b =&amp;gt; Ptr a -&amp;gt; IO b&lt;/code&gt;. The intention is that &lt;code&gt;#peek&lt;/code&gt; and &lt;code&gt;#poke&lt;/code&gt; can be used for implementing the operations of class &lt;code&gt;Storable&lt;/code&gt; for a given C struct (see the &lt;code&gt;Foreign.Storable&lt;/code&gt; module in the library documentation).</source>
          <target state="translated">Будет выведена функция, которая просматривает поле структуры C. Он будет иметь тип &lt;code&gt;Storable b =&amp;gt; Ptr a -&amp;gt; IO b&lt;/code&gt; . Предполагается, что &lt;code&gt;#peek&lt;/code&gt; и &lt;code&gt;#poke&lt;/code&gt; можно использовать для реализации операций класса &lt;code&gt;Storable&lt;/code&gt; для данной структуры C (см. Модуль &lt;code&gt;Foreign.Storable&lt;/code&gt; в документации библиотеки).</target>
        </trans-unit>
        <trans-unit id="d2ef8a015f90280c78a9e52d4eaee96c355e724d" translate="yes" xml:space="preserve">
          <source>A function to check if the current terminal uses MinTTY. Much of this code was originally authored by Phil Ruffwind and the git-for-windows project.</source>
          <target state="translated">Функция проверки,использует ли текущий терминал MinTTY.Большая часть этого кода была изначально написана Филом Раффвиндом (Phil Ruffwind)и проектом git-for-windows.</target>
        </trans-unit>
        <trans-unit id="31ba468a5f0c3b9552cf7091416e0dd2026254a0" translate="yes" xml:space="preserve">
          <source>A function to increment a counter. Taken from the paper &quot;Generalising Monads to Arrows&quot;, John Hughes (&lt;a href=&quot;http://www.cse.chalmers.se/~rjmh/&quot;&gt;http://www.cse.chalmers.se/~rjmh/&lt;/a&gt;), November 1998:</source>
          <target state="translated">Функция увеличения счетчика. Взято из статьи Джона Хьюза &amp;laquo;Обобщение монад на стрелы&amp;raquo; ( &lt;a href=&quot;http://www.cse.chalmers.se/~rjmh/&quot;&gt;http://www.cse.chalmers.se/~rjmh/&lt;/a&gt; ), ноябрь 1998 г .:</target>
        </trans-unit>
        <trans-unit id="05dac60b6df39a2cc430ba2715bb82eb9d50346b" translate="yes" xml:space="preserve">
          <source>A function to increment a counter. Taken from the paper &lt;em&gt;Generalising Monads to Arrows&lt;/em&gt;, John Hughes (&lt;a href=&quot;http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf&quot;&gt;http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf&lt;/a&gt;), November 1998:</source>
          <target state="translated">Функция увеличения счетчика. Взято из статьи Джона Хьюза &amp;laquo; &lt;em&gt;Обобщение монад до стрел&amp;raquo;&lt;/em&gt; ( &lt;a href=&quot;http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf&quot;&gt;http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf&lt;/a&gt; ), ноябрь 1998 г .:</target>
        </trans-unit>
        <trans-unit id="cba486e1fb914bff3d0a304947268224d9af2b9a" translate="yes" xml:space="preserve">
          <source>A function to increment a counter. Taken from the paper &lt;em&gt;Generalising Monads to Arrows&lt;/em&gt;, John Hughes (&lt;a href=&quot;http://www.math.chalmers.se/~rjmh/&quot;&gt;http://www.math.chalmers.se/~rjmh/&lt;/a&gt;), November 1998:</source>
          <target state="translated">Функция увеличения счетчика. Взято из статьи Джона Хьюза &amp;laquo; &lt;em&gt;Обобщение монад на стрелы&amp;raquo;&lt;/em&gt; ( &lt;a href=&quot;http://www.math.chalmers.se/~rjmh/&quot;&gt;http://www.math.chalmers.se/~rjmh/&lt;/a&gt; ), ноябрь 1998 г .:</target>
        </trans-unit>
        <trans-unit id="407bdfca3acdcf3e83644e05bb20353353df0c81" translate="yes" xml:space="preserve">
          <source>A functor with application, providing operations to</source>
          <target state="translated">Функтор с приложением,обеспечивающим работу с</target>
        </trans-unit>
        <trans-unit id="672c26b34e9f1b6a9e0ef2bedd270f00f9598669" translate="yes" xml:space="preserve">
          <source>A garbage collection pass has been finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74eb92ae3094b3fdb42750a32df490044fa7fa7c" translate="yes" xml:space="preserve">
          <source>A garbage collection pass has been started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b56072e77298e15569c00276b7c0299340640ae" translate="yes" xml:space="preserve">
          <source>A general library for representation and manipulation of versions.</source>
          <target state="translated">Общая библиотека для представления и манипулирования версиями.</target>
        </trans-unit>
        <trans-unit id="3bc20610754970931bb56e207d89ee27df2c440a" translate="yes" xml:space="preserve">
          <source>A generalization of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt; takes a mapping function that also depends on the element's index, and applies it to every element in the sequence.</source>
          <target state="translated">Обобщая &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt; принимает функцию сопоставления, которая также зависит от индекса элемента, и применяет ее к каждому элементу в последовательности.</target>
        </trans-unit>
        <trans-unit id="4ed89134d2ae1ba346467054c2cbd0888a87f736" translate="yes" xml:space="preserve">
          <source>A generalization of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt; takes a mapping function that also depends on the element's index, and applies it to every element in the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b0bb9b6108641f8e5517af378b5cb49562a948" translate="yes" xml:space="preserve">
          <source>A generalization of &lt;code&gt;&lt;a href=&quot;data-list#v:cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt; to an arbitrary &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt;. May fail to terminate for some values in some semigroups.</source>
          <target state="translated">Обобщение &lt;code&gt;&lt;a href=&quot;data-list#v:cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt; на произвольную &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; . Может не завершиться для некоторых значений в некоторых полугруппах.</target>
        </trans-unit>
        <trans-unit id="26ff4b7505fb166fcbe7f642bd27c36a8063bf48" translate="yes" xml:space="preserve">
          <source>A generator with side-effects.</source>
          <target state="translated">Генератор с побочными эффектами.</target>
        </trans-unit>
        <trans-unit id="862450f7f65fc829d17b888581dcf9423b4a7480" translate="yes" xml:space="preserve">
          <source>A generator ⟨g⟩ &lt;em&gt;depends&lt;/em&gt; on a textually following generator ⟨g&amp;rsquo;⟩, if</source>
          <target state="translated">Генератор g⟩ &lt;em&gt;зависит&lt;/em&gt; от текстуально следующего генератора g'⟩, если</target>
        </trans-unit>
        <trans-unit id="62ae38d3598e1153af86caff741ce7f45b481a95" translate="yes" xml:space="preserve">
          <source>A generic function is defined by creating a class and giving instances for each of the representation types of &lt;code&gt;GHC.Generics&lt;/code&gt;. As an example we show generic serialization:</source>
          <target state="translated">Универсальная функция определяется путем создания класса и предоставления экземпляров для каждого из типов представления &lt;code&gt;GHC.Generics&lt;/code&gt; . В качестве примера мы показываем универсальную сериализацию:</target>
        </trans-unit>
        <trans-unit id="1c195a4fb48a9a5e0bec2f551debfe0bebac3b3f" translate="yes" xml:space="preserve">
          <source>A generic monadic transformation that maps over the immediate subterms</source>
          <target state="translated">Общее монадское преобразование,которое отображает ближайшие субботы.</target>
        </trans-unit>
        <trans-unit id="2371a81d45c2bb3b8a13c0d110026806d7062e4b" translate="yes" xml:space="preserve">
          <source>A generic query that processes one child by index (zero-based)</source>
          <target state="translated">Общий запрос,который обрабатывает один дочерний элемент по индексу (на основе нуля).</target>
        </trans-unit>
        <trans-unit id="b30dda47587e5c218c84c8765cbfb57d7c32ee07" translate="yes" xml:space="preserve">
          <source>A generic query that processes the immediate subterms and returns a list of results. The list is given in the same order as originally specified in the declaration of the data constructors.</source>
          <target state="translated">Общий запрос,который обрабатывает немедленные подзапросы и возвращает список результатов.Список дается в том же порядке,который был изначально указан в декларации конструкторов данных.</target>
        </trans-unit>
        <trans-unit id="51d2a5deead9d5e63a49652af5db4d773df15f2a" translate="yes" xml:space="preserve">
          <source>A generic query with a left-associative binary operator</source>
          <target state="translated">Общий запрос с лево-ассоциативным двоичным оператором</target>
        </trans-unit>
        <trans-unit id="f172406f53434c2c85e3e88b3b734c76fe4cbf1f" translate="yes" xml:space="preserve">
          <source>A generic query with a right-associative binary operator</source>
          <target state="translated">Общий запрос с право-ассоциативным двоичным оператором</target>
        </trans-unit>
        <trans-unit id="aa8f907ef342f61225b3aaaca537bb6131e08eed" translate="yes" xml:space="preserve">
          <source>A generic transformation that maps over the immediate subterms</source>
          <target state="translated">Общее преобразование,которое отображает немедленные подзаголовки.</target>
        </trans-unit>
        <trans-unit id="263bda9728b8670fff6c73f321e0c1114a53a098" translate="yes" xml:space="preserve">
          <source>A graph where the out-list references unspecified nodes (&lt;code&gt;'c'&lt;/code&gt;), these are ignored.</source>
          <target state="translated">Граф, в котором исходящий список ссылается на неуказанные узлы ( &lt;code&gt;'c'&lt;/code&gt; ), они игнорируются.</target>
        </trans-unit>
        <trans-unit id="547e608af651f4f8ae6ad4968c6a78fb1a5f9911" translate="yes" xml:space="preserve">
          <source>A graph with 3 vertices: (&quot;a&quot;) -&amp;gt; (&quot;b&quot;) -&amp;gt; (&quot;c&quot;)</source>
          <target state="translated">Граф с 3 вершинами: (&quot;a&quot;) -&amp;gt; (&quot;b&quot;) -&amp;gt; (&quot;c&quot;)</target>
        </trans-unit>
        <trans-unit id="12b3806c7a4a6d3f01bcf0d2c455af966755af91" translate="yes" xml:space="preserve">
          <source>A group of implicit-parameter bindings may occur anywhere a normal group of Haskell bindings can occur, except at top level. That is, they can occur in a &lt;code&gt;let&lt;/code&gt; (including in a list comprehension, or do-notation, or pattern guards), or a &lt;code&gt;where&lt;/code&gt; clause. Note the following points:</source>
          <target state="translated">Группа привязок неявных параметров может встречаться везде, где возможна обычная группа привязок Haskell, за исключением верхнего уровня. То есть они могут встречаться в &lt;code&gt;let&lt;/code&gt; (в том числе в понимании списка, или в нотации do, или в защите шаблонов) или в предложении &lt;code&gt;where&lt;/code&gt; . Обратите внимание на следующие моменты:</target>
        </trans-unit>
        <trans-unit id="65051f92e572963e4acdb9bb33b4d2b90e5a8b97" translate="yes" xml:space="preserve">
          <source>A handle managing input from the Haskell program's standard input channel.</source>
          <target state="translated">Ручка,управляющая входом со стандартного входного канала программы Хаскелла.</target>
        </trans-unit>
        <trans-unit id="e751926f8fa8be7abe2938c68d0bde4c6028d510" translate="yes" xml:space="preserve">
          <source>A handle managing output to the Haskell program's standard error channel.</source>
          <target state="translated">Ручка,управляющая выводом в стандартный канал ошибок программы Хаскелла.</target>
        </trans-unit>
        <trans-unit id="2d2d9310b94785cb31fe1e4c863bde58a3090d7e" translate="yes" xml:space="preserve">
          <source>A handle managing output to the Haskell program's standard output channel.</source>
          <target state="translated">Ручка,управляющая выводом на стандартный выходной канал программы Хаскелла.</target>
        </trans-unit>
        <trans-unit id="d7a3e5b5484f784fade78cfdf6ff6413b1996492" translate="yes" xml:space="preserve">
          <source>A handle to a process, which can be used to wait for termination of the process using &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; процесса, который можно использовать для ожидания завершения процесса с помощью waitForProcess .</target>
        </trans-unit>
        <trans-unit id="703580b3dc907bb3f23c64f76055da6a35b3d742" translate="yes" xml:space="preserve">
          <source>A handler for a decoding error.</source>
          <target state="translated">Обработчик ошибки декодирования.</target>
        </trans-unit>
        <trans-unit id="e5858ba1a84179526a85d088788e5ed04cd3ca67" translate="yes" xml:space="preserve">
          <source>A handler for an encoding error.</source>
          <target state="translated">Обработчик ошибки кодирования.</target>
        </trans-unit>
        <trans-unit id="a61fb6766aecc9004ee1afd5c6ce82d376d98ad4" translate="yes" xml:space="preserve">
          <source>A handler function to handle previous errors and return to normal execution. A common idiom is:</source>
          <target state="translated">Функция обработчика для обработки предыдущих ошибок и возврата к нормальному выполнению.Общая идиома:</target>
        </trans-unit>
        <trans-unit id="be659a8b5b88eca4628da85b8cd673c423ac389e" translate="yes" xml:space="preserve">
          <source>A heap object is &lt;em&gt;reachable&lt;/em&gt; if:</source>
          <target state="translated">Объект кучи &lt;em&gt;доступен,&lt;/em&gt; если:</target>
        </trans-unit>
        <trans-unit id="ea694877df8a08ed123b92ef6005435d0a5c6bc8" translate="yes" xml:space="preserve">
          <source>A heap residency census will follow. Since events may only be up to 2^16^ bytes in length a single sample may need to be split among multiple &lt;code&gt;EVENT_HEAP_PROF_SAMPLE&lt;/code&gt; events. The precise format of the census entries is determined by the break-down type.</source>
          <target state="translated">Будет проведена перепись населения кучи. Поскольку длина событий может составлять не более 2 ^ 16 ^ байтов, может потребоваться разделение одной выборки на несколько событий &lt;code&gt;EVENT_HEAP_PROF_SAMPLE&lt;/code&gt; . Точный формат записей переписи определяется типом разбивки.</target>
        </trans-unit>
        <trans-unit id="f721eb8b4b3c875c9b3039562674d9428b85321c" translate="yes" xml:space="preserve">
          <source>A helper module that defines some language definitions that can be used to instantiate a token parser (see &lt;a href=&quot;text-parsec-token&quot;&gt;Text.Parsec.Token&lt;/a&gt;).</source>
          <target state="translated">Вспомогательный модуль, который определяет некоторые определения языка, которые можно использовать для создания экземпляра анализатора токенов (см. &lt;a href=&quot;text-parsec-token&quot;&gt;Text.Parsec.Token&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="020709edaa36d2287275fd9547b133a13203df95" translate="yes" xml:space="preserve">
          <source>A helper module to parse &quot;expressions&quot;. Builds a parser given a table of operators and associativities.</source>
          <target state="translated">Вспомогательный модуль для разбора &quot;выражений&quot;.Сборка синтаксического анализатора с учетом таблицы операторов и ассоциативностей.</target>
        </trans-unit>
        <trans-unit id="150ba12f35ac6072514bd31b5f915a96dc42b4c6" translate="yes" xml:space="preserve">
          <source>A helper module to parse lexical elements (tokens). See &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; for a description of how to use it.</source>
          <target state="translated">Вспомогательный модуль для разбора лексических элементов (токенов). См. &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; для описания того, как его использовать.</target>
        </trans-unit>
        <trans-unit id="0383b225a4de83038268fe176e36b5324f8b57bd" translate="yes" xml:space="preserve">
          <source>A hs-boot file is written in a subset of Haskell:</source>
          <target state="translated">Файл hs-boot записан в подмножестве Haskell:</target>
        </trans-unit>
        <trans-unit id="beb39b13efdd6752b158de82a3a13e416589e21f" translate="yes" xml:space="preserve">
          <source>A hs-boot file need only contain the bare minimum of information needed to get the bootstrapping process started. For example, it doesn&amp;rsquo;t need to contain declarations for &lt;em&gt;everything&lt;/em&gt; that module &lt;code&gt;A&lt;/code&gt; exports, only the things required by the module(s) that import &lt;code&gt;A&lt;/code&gt; recursively.</source>
          <target state="translated">Файл hs-boot должен содержать только самый минимум информации, необходимой для запуска процесса начальной загрузки. Например, он не должен содержать объявления для &lt;em&gt;всего,&lt;/em&gt; что экспортирует модуль &lt;code&gt;A&lt;/code&gt; , только то, что требуется модулям, рекурсивно импортирующим &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c6d3cf5164d3e0790c51b498cf4792069b594e1" translate="yes" xml:space="preserve">
          <source>A key feature of lazy ByteStrings is the means to manipulate large or unbounded streams of data without requiring the entire sequence to be resident in memory. To take advantage of this you have to write your functions in a lazy streaming style, e.g. classic pipeline composition. The default I/O chunk size is 32k, which should be good in most circumstances.</source>
          <target state="translated">Ключевой особенностью ленивого ByteStrings является возможность манипулировать большими или неограниченными потоками данных,не требуя,чтобы вся последовательность была резидентной в памяти.Чтобы воспользоваться этим,вы должны написать свои функции в ленивом потоковом стиле,например,классическую трубопроводную композицию.По умолчанию размер фрагмента ввода/вывода составляет 32k,что должно быть хорошо в большинстве случаев.</target>
        </trans-unit>
        <trans-unit id="325a2bf823d17d06d93a99292962d2fd916a91fe" translate="yes" xml:space="preserve">
          <source>A key for &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt;s that can be serialized and used with &lt;code&gt;&lt;a href=&quot;ghc-staticptr#v:unsafeLookupStaticPtr&quot;&gt;unsafeLookupStaticPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Ключ для &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; , который можно сериализовать и использовать с &lt;code&gt;&lt;a href=&quot;ghc-staticptr#v:unsafeLookupStaticPtr&quot;&gt;unsafeLookupStaticPtr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="036affe5e2067ef8e5a7e25cb46bbfbf0c7d82cb" translate="yes" xml:space="preserve">
          <source>A kind signature is considered to be outermost regardless of redundant parentheses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b381dc7ee35453cc6200cb73ab6f7a29da015f" translate="yes" xml:space="preserve">
          <source>A kind variable can also be bound implicitly in a LHS type pattern, as in this example:</source>
          <target state="translated">Переменная вида также может быть неявно связана в шаблоне типа LHS,как в данном примере:</target>
        </trans-unit>
        <trans-unit id="fed1bf023551f5e183a777d4ad8f17c745a4596e" translate="yes" xml:space="preserve">
          <source>A lazier version of Data.List.intersperse. The other version causes space leaks!</source>
          <target state="translated">Более ленивая версия Data.List.intersperse.Другая версия вызывает утечку места!</target>
        </trans-unit>
        <trans-unit id="54d1e3a19df5bd11488b091ae905ebe5fef9f311" translate="yes" xml:space="preserve">
          <source>A lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; contains 8-bit bytes, or by using the operations from &lt;a href=&quot;data-bytestring-lazy-char8&quot;&gt;Data.ByteString.Lazy.Char8&lt;/a&gt; it can be interpreted as containing 8-bit characters.</source>
          <target state="translated">Ленивая &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; содержит 8-битные байты или с помощью операций из &lt;a href=&quot;data-bytestring-lazy-char8&quot;&gt;Data.ByteString.Lazy.Char8&lt;/a&gt; может быть интерпретирована как содержащая 8-битные символы.</target>
        </trans-unit>
        <trans-unit id="5a2fd64b80af2ff85d7158cad974f3b8d6d3fa1e" translate="yes" xml:space="preserve">
          <source>A lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; contains 8-bit bytes, or by using the operations from &lt;a href=&quot;data-bytestring-lazy-char8&quot;&gt;Data.ByteString.Lazy.Char8&lt;/a&gt; it can be interpreted as containing 8-bit characters.</source>
          <target state="translated">Ленивая &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; содержит 8-битные байты или с помощью операций из &lt;a href=&quot;data-bytestring-lazy-char8&quot;&gt;Data.ByteString.Lazy.Char8&lt;/a&gt; может быть интерпретирована как содержащая 8-битные символы.</target>
        </trans-unit>
        <trans-unit id="4f64b98de52b0b6fa53b16083b06816797fde862" translate="yes" xml:space="preserve">
          <source>A lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; contains 8-bit bytes, or by using the operations from &lt;a href=&quot;data-bytestring-lazy-char8&quot;&gt;Data.ByteString.Lazy.Char8&lt;/a&gt; it can be interpreted as containing 8-bit characters.</source>
          <target state="translated">Ленивая &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; содержит 8-битные байты или с помощью операций из &lt;a href=&quot;data-bytestring-lazy-char8&quot;&gt;Data.ByteString.Lazy.Char8&lt;/a&gt; может быть интерпретирована как содержащая 8-битные символы.</target>
        </trans-unit>
        <trans-unit id="15d0c3d1a9e330b475d899c85089d3a45d5191af" translate="yes" xml:space="preserve">
          <source>A leading (or &quot;high&quot;) surrogate code unit (0xD800&amp;ndash;0xDBFF) must always be followed by a trailing (or &quot;low&quot;) surrogate code unit (0xDC00-0xDFFF). A trailing surrogate code unit must always be preceded by a leading surrogate code unit.</source>
          <target state="translated">За ведущей (или &amp;laquo;высокой&amp;raquo;) единицей суррогатного кода (0xD800&amp;ndash;0xDBFF) всегда должна следовать завершающая (или &amp;laquo;младшая&amp;raquo;) единица суррогатного кода (0xDC00-0xDFFF). Завершающей единице суррогатного кода всегда должна предшествовать ведущая единица суррогатного кода.</target>
        </trans-unit>
        <trans-unit id="49f7c0bc99a71677d388689dcc2d6ba4d8f6ecf2" translate="yes" xml:space="preserve">
          <source>A left fold over the elements</source>
          <target state="translated">Левый склад над элементами</target>
        </trans-unit>
        <trans-unit id="875903e7616532ab0681456be555fa6ab6806498" translate="yes" xml:space="preserve">
          <source>A left fold over the elements with no starting value</source>
          <target state="translated">Левый сгиб над элементами без стартового значения.</target>
        </trans-unit>
        <trans-unit id="13379849e3da0988f874c759315290aea7600c73" translate="yes" xml:space="preserve">
          <source>A less contrived example shows the use of &lt;code&gt;cases&lt;/code&gt; instead of &lt;code&gt;lets&lt;/code&gt; to get stricter code (a good thing):</source>
          <target state="translated">Менее надуманный пример показывает использование &lt;code&gt;cases&lt;/code&gt; вместо &lt;code&gt;lets&lt;/code&gt; получить более строгий код (хорошая вещь):</target>
        </trans-unit>
        <trans-unit id="fd8adda1f5cdce432835cce105d7c84fdbd2dac1" translate="yes" xml:space="preserve">
          <source>A lexer for the haskell language.</source>
          <target state="translated">Лексер для языка хаскеллов.</target>
        </trans-unit>
        <trans-unit id="6b7e5a3a0abc0bd6645cddccc0976a9582cc8903" translate="yes" xml:space="preserve">
          <source>A lexer for the mondrian language.</source>
          <target state="translated">Лексер для языка мондрий.</target>
        </trans-unit>
        <trans-unit id="1726ba2f885b524251e70e59cf6b4178dcd2f11f" translate="yes" xml:space="preserve">
          <source>A library for &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; manipulations, using Posix style paths on all platforms. Importing &lt;a href=&quot;system-filepath&quot;&gt;System.FilePath&lt;/a&gt; is usually better.</source>
          <target state="translated">Библиотека для &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; манипуляций, используя пути стиля Posix на всех платформах. Обычно лучше импортировать &lt;a href=&quot;system-filepath&quot;&gt;System.FilePath&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d22f4e61fa94ecb3258b9cf1c0bad6a5edb3b1fc" translate="yes" xml:space="preserve">
          <source>A library for &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; manipulations, using Windows style paths on all platforms. Importing &lt;a href=&quot;system-filepath&quot;&gt;System.FilePath&lt;/a&gt; is usually better.</source>
          <target state="translated">Библиотека для манипуляций с &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; , использующая пути в стиле Windows на всех платформах. Обычно лучше импортировать &lt;a href=&quot;system-filepath&quot;&gt;System.FilePath&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b736f738e6fcd73b3f446e3ef506bfbfaf5591f3" translate="yes" xml:space="preserve">
          <source>A line recording the dependence of the object file on the source file.</source>
          <target state="translated">Строка,записывающая зависимость объектного файла от исходного файла.</target>
        </trans-unit>
        <trans-unit id="dc910a705047942aa6596ecdf81615bb378b5bf0" translate="yes" xml:space="preserve">
          <source>A list containing child cost-centre stacks.</source>
          <target state="translated">Список,содержащий детские стеки.</target>
        </trans-unit>
        <trans-unit id="a5dad55926d22c2d61986b7de9e0d931acff5efa" translate="yes" xml:space="preserve">
          <source>A list of all known keys.</source>
          <target state="translated">Список всех известных ключей.</target>
        </trans-unit>
        <trans-unit id="a068c69873917f77c92591cc3eed569ea30b4268" translate="yes" xml:space="preserve">
          <source>A list of all supported language extensions can be obtained by invoking &lt;code&gt;ghc --supported-extensions&lt;/code&gt; (see &lt;a href=&quot;using#ghc-flag---supported-extensions&quot;&gt;&lt;code&gt;--supported-extensions&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Список всех поддерживаемых языковых расширений можно получить, вызвав &lt;code&gt;ghc --supported-extensions&lt;/code&gt; (см. &lt;a href=&quot;using#ghc-flag---supported-extensions&quot;&gt; &lt;code&gt;--supported-extensions&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9020f71c1c4e09df1fb37e8eb8a85e9c837975c2" translate="yes" xml:space="preserve">
          <source>A list of separate command line arguments to the program</source>
          <target state="translated">Список отдельных аргументов командной строки к программе</target>
        </trans-unit>
        <trans-unit id="5f31632c64a2a83d396013e71426f91b56565679" translate="yes" xml:space="preserve">
          <source>A list of the program&amp;rsquo;s cost centres</source>
          <target state="translated">Список центров затрат программы</target>
        </trans-unit>
        <trans-unit id="73940efd2676f199ed1ac86bfd84a3386d46652a" translate="yes" xml:space="preserve">
          <source>A list of zero or more usernames that are members (gr_mem)</source>
          <target state="translated">Список нулевых и более имен пользователей,которые являются членами (gr_mem).</target>
        </trans-unit>
        <trans-unit id="bb14c26279814204dd8eba9acbc9f2cc037cda91" translate="yes" xml:space="preserve">
          <source>A list producer that can be fused with &lt;code&gt;&lt;a href=&quot;ghc-base#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. This function is merely</source>
          <target state="translated">Производитель списков, который можно объединить с &lt;code&gt;&lt;a href=&quot;ghc-base#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; . Эта функция просто</target>
        </trans-unit>
        <trans-unit id="7609384306d65c392d73d1f946dd577e1543b1ed" translate="yes" xml:space="preserve">
          <source>A list producer that can be fused with &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. This function is merely</source>
          <target state="translated">Производитель списков, который можно объединить с &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; . Эта функция просто</target>
        </trans-unit>
        <trans-unit id="3157123a0be7934993229fbac35bb2de4bfc150e" translate="yes" xml:space="preserve">
          <source>A literal POSIX file path</source>
          <target state="translated">Буквальный путь к POSIX-файлу</target>
        </trans-unit>
        <trans-unit id="616e39ecf2bde53027e5f642d48b139e07322230" translate="yes" xml:space="preserve">
          <source>A local time together with a time zone.</source>
          <target state="translated">Местное время вместе с часовым поясом.</target>
        </trans-unit>
        <trans-unit id="edcfe1b56e989ad66407f462968b76cf02bda336" translate="yes" xml:space="preserve">
          <source>A location in the original program source.</source>
          <target state="translated">Местоположение в оригинальном источнике программы.</target>
        </trans-unit>
        <trans-unit id="8d5a785c724a8eba79d22f8cfdbe656e03ea3ef1" translate="yes" xml:space="preserve">
          <source>A log message from the runtime system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb40e6b7e0ea76eae404b014920691442447d08" translate="yes" xml:space="preserve">
          <source>A logically uninhabited data type, used to indicate that a given term should not exist.</source>
          <target state="translated">Логически необитаемый тип данных,используемый для обозначения того,что данный термин не должен существовать.</target>
        </trans-unit>
        <trans-unit id="4fae0237e62dbac5cce6d600545ee02ceb780eef" translate="yes" xml:space="preserve">
          <source>A long GC sync can be caused by a mutator thread that is inside an &lt;code&gt;unsafe&lt;/code&gt; FFI call, or running in a loop that doesn&amp;rsquo;t allocate memory and so doesn&amp;rsquo;t yield. To fix the former, make the call &lt;code&gt;safe&lt;/code&gt;, and to fix the latter, either avoid calling the code in question or compile it with &lt;a href=&quot;using-optimisation#ghc-flag--fomit-yields&quot;&gt;&lt;code&gt;-fomit-yields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Долгая синхронизация GC может быть вызвана потоком мутатора, который находится внутри &lt;code&gt;unsafe&lt;/code&gt; вызова FFI или работает в цикле, который не выделяет память и поэтому не дает результатов. Чтобы исправить первое, сделайте вызов &lt;code&gt;safe&lt;/code&gt; , а для исправления последнего либо избегайте вызова рассматриваемого кода, либо скомпилируйте его с помощью &lt;a href=&quot;using-optimisation#ghc-flag--fomit-yields&quot;&gt; &lt;code&gt;-fomit-yields&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05cad06e7cb8bda737ea7d67ec36667703119c82" translate="yes" xml:space="preserve">
          <source>A low-level I/O provider where the data is bytes in memory.</source>
          <target state="translated">Провайдер низкоуровневых входов/выходов,где данные находятся в байтах в памяти.</target>
        </trans-unit>
        <trans-unit id="2c87eeefae8a2c24218a0a414358507070126796" translate="yes" xml:space="preserve">
          <source>A low-tech way: grep (search) your interface files for overloaded type signatures. You can view interface files using the &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; option (see &lt;a href=&quot;separate_compilation#hi-options&quot;&gt;Other options related to interface files&lt;/a&gt;).</source>
          <target state="translated">Нетехнологичный способ: grep (поиск) файлов интерфейса на предмет подписей перегруженного типа. Вы можете просматривать файлы интерфейса, используя параметр &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; (см. &lt;a href=&quot;separate_compilation#hi-options&quot;&gt;Другие параметры, относящиеся к файлам интерфейса&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f6dadb395de3d2b9d69bc143f67ef70d410699b4" translate="yes" xml:space="preserve">
          <source>A lower-case identifier &lt;code&gt;foo&lt;/code&gt;. GHC assumes that the main function is &lt;code&gt;Main.foo&lt;/code&gt;.</source>
          <target state="translated">Идентификатор в нижнем регистре &lt;code&gt;foo&lt;/code&gt; . GHC предполагает, что основная функция - &lt;code&gt;Main.foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68062c83cacf82d9a90ab7e0cc7ea387cf2a996a" translate="yes" xml:space="preserve">
          <source>A map of integers to values &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Карта целых чисел со значениями &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65d761f61d1d8b61018c0927736bc1f2164bec10" translate="yes" xml:space="preserve">
          <source>A masking character; e.g., &lt;code&gt;Just '*'&lt;/code&gt;</source>
          <target state="translated">Маскирующий персонаж; например, &lt;code&gt;Just '*'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec043ff4717214a6d38bc8fbb175d1fdb2e2c0b5" translate="yes" xml:space="preserve">
          <source>A maximal set of mutually reachable vertices.</source>
          <target state="translated">Максимальный набор взаимно достижимых вершин.</target>
        </trans-unit>
        <trans-unit id="11966b51fe1d27560b215138baa79271c17219dd" translate="yes" xml:space="preserve">
          <source>A memory pool.</source>
          <target state="translated">Бассейн памяти.</target>
        </trans-unit>
        <trans-unit id="068781bc49acfb4cc274e15ab83d09598ea7b38a" translate="yes" xml:space="preserve">
          <source>A minimal &lt;code&gt;&lt;a href=&quot;data-bifoldable#t:Bifoldable&quot;&gt;Bifoldable&lt;/a&gt;&lt;/code&gt; definition consists of either &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldMap&quot;&gt;bifoldMap&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt;. When defining more than this minimal set, one should ensure that the following identities hold:</source>
          <target state="translated">Минимальное &lt;code&gt;&lt;a href=&quot;data-bifoldable#t:Bifoldable&quot;&gt;Bifoldable&lt;/a&gt;&lt;/code&gt; определение состоит либо из &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldMap&quot;&gt;bifoldMap&lt;/a&gt;&lt;/code&gt; , либо из &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt; . При определении большего, чем этот минимальный набор, следует убедиться, что выполняются следующие тождества:</target>
        </trans-unit>
        <trans-unit id="3ca5616e71a7726aa5bd2663b7f524e751a256d8" translate="yes" xml:space="preserve">
          <source>A minimal complete definition must include implementations of &lt;code&gt;&lt;a href=&quot;control-applicative#v:pure&quot;&gt;pure&lt;/a&gt;&lt;/code&gt; and of either &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt;&lt;/code&gt;. If it defines both, then they must behave the same as their default definitions:</source>
          <target state="translated">Минимальное полное определение должно включать в себя реализации &lt;code&gt;&lt;a href=&quot;control-applicative#v:pure&quot;&gt;pure&lt;/a&gt;&lt;/code&gt; и либо &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , либо &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt;&lt;/code&gt; . Если он определяет оба, тогда они должны вести себя так же, как их определения по умолчанию:</target>
        </trans-unit>
        <trans-unit id="c69118482cffeb2b76367b869803b6611f4079d3" translate="yes" xml:space="preserve">
          <source>A minimal complete definition must include implementations of &lt;code&gt;&lt;a href=&quot;ghc-base#v:pure&quot;&gt;pure&lt;/a&gt;&lt;/code&gt; and of either &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA2&quot;&gt;liftA2&lt;/a&gt;&lt;/code&gt;. If it defines both, then they must behave the same as their default definitions:</source>
          <target state="translated">Минимальное полное определение должно включать в себя реализации &lt;code&gt;&lt;a href=&quot;ghc-base#v:pure&quot;&gt;pure&lt;/a&gt;&lt;/code&gt; и либо &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , либо &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA2&quot;&gt;liftA2&lt;/a&gt;&lt;/code&gt; . Если он определяет оба, тогда они должны вести себя так же, как их определения по умолчанию:</target>
        </trans-unit>
        <trans-unit id="a11f1b1fc9f85e87f7328e93a0fe87efd1a62782" translate="yes" xml:space="preserve">
          <source>A minimal complete definition must include implementations of &lt;code&gt;&lt;a href=&quot;prelude#v:pure&quot;&gt;pure&lt;/a&gt;&lt;/code&gt; and of either &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt;&lt;/code&gt;. If it defines both, then they must behave the same as their default definitions:</source>
          <target state="translated">Минимальное полное определение должно включать в себя реализации &lt;code&gt;&lt;a href=&quot;prelude#v:pure&quot;&gt;pure&lt;/a&gt;&lt;/code&gt; и либо &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , либо &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt;&lt;/code&gt; . Если он определяет оба, тогда они должны вести себя так же, как их определения по умолчанию:</target>
        </trans-unit>
        <trans-unit id="b8c72a19154aaf8d59b6b3ec9d5c79b6d054c147" translate="yes" xml:space="preserve">
          <source>A mirror image of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-arrow#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Зеркальное отображение &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-arrow#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9728f4924a2cece6cd9f3bd1f1fb2a3d7d63e51" translate="yes" xml:space="preserve">
          <source>A mirror image of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-arrow#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2014f989a9d241989c62fe055f679a0c74c7b1b5" translate="yes" xml:space="preserve">
          <source>A mirror image of &lt;code&gt;&lt;a href=&quot;control-arrow#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Зеркальное отображение &lt;code&gt;&lt;a href=&quot;control-arrow#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11fd433555f19114cd7accfaf208363211897740" translate="yes" xml:space="preserve">
          <source>A mirror image of &lt;code&gt;&lt;a href=&quot;control-arrow#v:left&quot;&gt;left&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Зеркальное отображение &lt;code&gt;&lt;a href=&quot;control-arrow#v:left&quot;&gt;left&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b38d2272521d203ef9738b678b691090ceb2c2a7" translate="yes" xml:space="preserve">
          <source>A mode that determines the effect of &lt;code&gt;&lt;a href=&quot;system-io#v:hSeek&quot;&gt;hSeek&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl mode i&lt;/code&gt;.</source>
          <target state="translated">Режим, определяющий эффект &lt;code&gt;&lt;a href=&quot;system-io#v:hSeek&quot;&gt;hSeek&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl mode i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f6374097118c76813d909ba13b814c9cd41e81e" translate="yes" xml:space="preserve">
          <source>A module &lt;code&gt;M&lt;/code&gt; in a package &lt;code&gt;P&lt;/code&gt; is trusted by a client C if and only if:</source>
          <target state="translated">Модуль &lt;code&gt;M&lt;/code&gt; в пакете &lt;code&gt;P&lt;/code&gt; пользуется доверием со стороны клиента C тогда и только тогда, когда:</target>
        </trans-unit>
        <trans-unit id="79f16cbaafdc9bfd2ba1ca22d71d2c674b761102" translate="yes" xml:space="preserve">
          <source>A module &lt;code&gt;M&lt;/code&gt; that is &lt;code&gt;{-# SOURCE #-}&lt;/code&gt;-imported in a program will usually also be ordinarily imported elsewhere. If not, &lt;code&gt;ghc --make&lt;/code&gt; automatically adds &lt;code&gt;M&lt;/code&gt; to the set of modules it tries to compile and link, to ensure that &lt;code&gt;M&lt;/code&gt;&amp;lsquo;s implementation is included in the final program.</source>
          <target state="translated">Модуль &lt;code&gt;M&lt;/code&gt; , который &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; -импортирован в программу, обычно также обычно импортируется в другое место. Если нет, &lt;code&gt;ghc --make&lt;/code&gt; автоматически добавляет &lt;code&gt;M&lt;/code&gt; к набору модулей, которые он пытается скомпилировать и связать, чтобы гарантировать, что реализация &lt;code&gt;M&lt;/code&gt; включена в окончательную программу.</target>
        </trans-unit>
        <trans-unit id="987f7b14a3141b967b7850d7f7657d68e62459f9" translate="yes" xml:space="preserve">
          <source>A module &lt;code&gt;M&lt;/code&gt; that is &lt;code&gt;{-# SOURCE #-}&lt;/code&gt;-imported in a program will usually also be ordinarily imported elsewhere. If not, &lt;code&gt;ghc --make&lt;/code&gt; automatically adds &lt;code&gt;M&lt;/code&gt; to the set of modules it tries to compile and link, to ensure that &lt;code&gt;M&lt;/code&gt;&amp;rsquo;s implementation is included in the final program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="519fe32d3643ce1e03ac2bab30bb1bdcc52d189b" translate="yes" xml:space="preserve">
          <source>A module containing &lt;em&gt;unsafe&lt;/em&gt; operations, for &lt;em&gt;very very careful&lt;/em&gt; use in &lt;em&gt;heavily tested&lt;/em&gt; code.</source>
          <target state="translated">Модуль, содержащий &lt;em&gt;небезопасные&lt;/em&gt; операции, для &lt;em&gt;очень осторожного&lt;/em&gt; использования в &lt;em&gt;тщательно протестированном&lt;/em&gt; коде.</target>
        </trans-unit>
        <trans-unit id="461ba4ff0cf5d9d0e690d1653b0296554ff09c30" translate="yes" xml:space="preserve">
          <source>A module containing private &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; internals. This exposes the &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; representation and low level construction functions. Modules which extend the &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; system may need to use this module.</source>
          <target state="translated">Модуль, содержащий внутреннее частное &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; содержимое. Это предоставляет функции &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; представления и построения нижнего уровня. Модули, расширяющие &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; систему, могут нуждаться в использовании этого модуля.</target>
        </trans-unit>
        <trans-unit id="9355e89a95e098cf87e4b9b4d4b0c731bdb2c1ad" translate="yes" xml:space="preserve">
          <source>A module containing private &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; internals. This exposes the &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; representation and low level construction functions. Modules which extend the &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; system may need to use this module.</source>
          <target state="translated">Модуль, содержащий внутреннее частное &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; содержимое. Это предоставляет функции &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; представления и построения нижнего уровня. Модули, расширяющие &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; систему, могут нуждаться в использовании этого модуля.</target>
        </trans-unit>
        <trans-unit id="d6002f28ce7de42f2068e2f04b1e0c26f91c712e" translate="yes" xml:space="preserve">
          <source>A module containing semi-public &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; internals. This exposes the &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; representation and low level construction functions. As such all the functions in this module are unsafe. The API is also not stable.</source>
          <target state="translated">Модуль, содержащий &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; внутренние компоненты ByteString . Это предоставляет представление &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; и функции построения нижнего уровня. Таким образом, все функции в этом модуле небезопасны. API тоже нестабилен.</target>
        </trans-unit>
        <trans-unit id="1bd1a012965931778304a7fe9b5fbe73d7d293aa" translate="yes" xml:space="preserve">
          <source>A module containing semi-public &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; internals. This exposes the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; representation and low level construction functions. Modules which extend the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; system will need to use this module while ideally most users will be able to make do with the public interface modules.</source>
          <target state="translated">Модуль, содержащий &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; внутренние компоненты ByteString . Это предоставляет представление &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; и функции построения нижнего уровня. Модули, расширяющие систему &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; , должны будут использовать этот модуль, в то время как в идеале большинство пользователей смогут обходиться модулями общедоступного интерфейса.</target>
        </trans-unit>
        <trans-unit id="23bf84d5c3edc452896e02cf0360a0e8d1e320af" translate="yes" xml:space="preserve">
          <source>A module containing unsafe &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">Модуль, содержащий небезопасные операции &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d9f0c8a370cea074b5aff281e49729218f6c1e7" translate="yes" xml:space="preserve">
          <source>A module containing unsafe &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; operations, for very very careful use in heavily tested code.</source>
          <target state="translated">Модуль, содержащий небезопасные &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; операции, для очень осторожного использования в тщательно протестированном коде.</target>
        </trans-unit>
        <trans-unit id="af7a45c55bc3dff94ebe92e041da9cd2e519eb81" translate="yes" xml:space="preserve">
          <source>A module implementing &lt;code&gt;A&lt;/code&gt; would have to export the function &lt;code&gt;double&lt;/code&gt; with a type definitionally equal to the signature. Note that this means you can&amp;rsquo;t implement &lt;code&gt;double&lt;/code&gt; using a polymorphic function &lt;code&gt;double :: Num a =&amp;gt; a -&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">Модуль, реализующий &lt;code&gt;A&lt;/code&gt; , должен будет экспортировать функцию &lt;code&gt;double&lt;/code&gt; с типом, определенно равным сигнатуре. Обратите внимание, что это означает, что вы не можете реализовать &lt;code&gt;double&lt;/code&gt; с помощью полиморфной функции &lt;code&gt;double :: Num a =&amp;gt; a -&amp;gt; a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab6705ee3245e4112a8338653bc894373bc0218c" translate="yes" xml:space="preserve">
          <source>A module name &lt;code&gt;A&lt;/code&gt;. GHC assumes that the main function is &lt;code&gt;A.main&lt;/code&gt;.</source>
          <target state="translated">Имя модуля . GHC предполагает, что основной функцией является &lt;code&gt;A.main&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ffa8da0aa9a3feddea78d0a337a370d07af5012b" translate="yes" xml:space="preserve">
          <source>A module which imports &lt;code&gt;MyNum(..)&lt;/code&gt; from &lt;code&gt;Example&lt;/code&gt; and then re-exports &lt;code&gt;MyNum(..)&lt;/code&gt; will also export any pattern synonyms bundled with &lt;code&gt;MyNum&lt;/code&gt; in &lt;code&gt;Example&lt;/code&gt;. A more complete specification can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/PatternSynonyms/AssociatingSynonyms&quot;&gt;wiki.&lt;/a&gt;</source>
          <target state="translated">Модуль, который импортирует &lt;code&gt;MyNum(..)&lt;/code&gt; из &lt;code&gt;Example&lt;/code&gt; а затем повторно экспортирует &lt;code&gt;MyNum(..)&lt;/code&gt; , также будет экспортировать любые синонимы шаблона, связанные с &lt;code&gt;MyNum&lt;/code&gt; в &lt;code&gt;Example&lt;/code&gt; . Более полную спецификацию можно найти в &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/PatternSynonyms/AssociatingSynonyms&quot;&gt;вики.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46205c3964ea4b2def4e3d5de0a91193b170cf06" translate="yes" xml:space="preserve">
          <source>A module which imports &lt;code&gt;MyNum(..)&lt;/code&gt; from &lt;code&gt;Example&lt;/code&gt; and then re-exports &lt;code&gt;MyNum(..)&lt;/code&gt; will also export any pattern synonyms bundled with &lt;code&gt;MyNum&lt;/code&gt; in &lt;code&gt;Example&lt;/code&gt;. A more complete specification can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/pattern-synonyms/associating-synonyms&quot;&gt;wiki.&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11caca4dfe7a2e6647b187af096af9ce16cdb9c3" translate="yes" xml:space="preserve">
          <source>A monad containing an environment of type &lt;code&gt;r&lt;/code&gt;, output of type &lt;code&gt;w&lt;/code&gt; and an updatable state of type &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Монада, содержащая среду типа &lt;code&gt;r&lt;/code&gt; , вывод типа &lt;code&gt;w&lt;/code&gt; и обновляемое состояние типа &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44b463ce5ac795e0357256636d6bb8abafd3b888" translate="yes" xml:space="preserve">
          <source>A monad is said to be &lt;em&gt;strict&lt;/em&gt; if its &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; operation is strict in its first argument. The base monads &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; are strict:</source>
          <target state="translated">Монада называется &lt;em&gt;строгой,&lt;/em&gt; если ее операция &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; строго по первому аргументу. Базовые монады &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; строгие:</target>
        </trans-unit>
        <trans-unit id="880b41c9b53dfefef049250c9c1a2e53c78a0d3b" translate="yes" xml:space="preserve">
          <source>A monad is said to be &lt;em&gt;strict&lt;/em&gt; if its &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; operation is strict in its first argument. The base monads &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; are strict:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77a2e0dd83579c01e51b5cfcae453a98e588af94" translate="yes" xml:space="preserve">
          <source>A monad supporting atomic memory transactions.</source>
          <target state="translated">Монада,поддерживающая атомные операции с памятью.</target>
        </trans-unit>
        <trans-unit id="84ed5327cac92c7ef6e8588da5238de45965557c" translate="yes" xml:space="preserve">
          <source>A monad that can execute GHCi statements by lifting them out of m into the IO monad. (e.g state monads)</source>
          <target state="translated">Монада,которая может выполнять заявления о GHCi,поднимая их из меня в IO monad.(например,государственные монады)</target>
        </trans-unit>
        <trans-unit id="2d83f98faa29021325e93148f624ac116d49fdd7" translate="yes" xml:space="preserve">
          <source>A monad that doesn't allow any IO.</source>
          <target state="translated">Монада,которая не разрешает никакого ввода.</target>
        </trans-unit>
        <trans-unit id="475de8d1c4ced9051885211b80d0128a644d0a1b" translate="yes" xml:space="preserve">
          <source>A monad transformer adding reading an environment of type &lt;code&gt;r&lt;/code&gt;, collecting an output of type &lt;code&gt;w&lt;/code&gt; and updating a state of type &lt;code&gt;s&lt;/code&gt; to an inner monad &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">Преобразователь монады, добавляющий чтение среды типа &lt;code&gt;r&lt;/code&gt; , сбор выходных данных типа &lt;code&gt;w&lt;/code&gt; и обновление состояния типа &lt;code&gt;s&lt;/code&gt; до внутренней монады &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec0442bcbea355903251a46fae40d37d907ac64e" translate="yes" xml:space="preserve">
          <source>A monad transformer embedding lazy &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; parameter indicates that the internal state used by the &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation is a special one supplied by the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad, and thus distinct from those used by invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Преобразователь монад, встраивающий ленивый &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; в монаду &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; . Параметр &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; указывает, что внутреннее состояние, используемое вычислением &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; , является особым состоянием, предоставляемым монадой &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; , и поэтому отличается от состояния, используемого при &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21a5486c71e41350dc1ca87d78fb4f0bce729afa" translate="yes" xml:space="preserve">
          <source>A monad transformer embedding lazy &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; parameter indicates that the internal state used by the &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation is a special one supplied by the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad, and thus distinct from those used by invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Преобразователь монад, встраивающий ленивый &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; в монаду &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; . Параметр &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; указывает, что внутреннее состояние, используемое вычислением &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; , является особым состоянием, предоставляемым монадой &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; , и поэтому отличается от состояния, используемого при &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="601b40dc8531d619de3d6e429600341c4287841e" translate="yes" xml:space="preserve">
          <source>A monad transformer makes a new monad out of an existing monad, such that computations of the old monad may be embedded in the new one. To construct a monad with a desired set of features, one typically starts with a base monad, such as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;, and applies a sequence of monad transformers.</source>
          <target state="translated">Преобразователь монад создает новую монаду из существующей монады, так что вычисления старой монады могут быть встроены в новую. Чтобы построить монаду с желаемым набором функций, обычно начинают с базовой монады, такой как &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; , и применяют последовательность преобразователей монад.</target>
        </trans-unit>
        <trans-unit id="b365f46b9cfdefb11fdd9add50d3c78cbda728a5" translate="yes" xml:space="preserve">
          <source>A monad transformer makes a new monad out of an existing monad, such that computations of the old monad may be embedded in the new one. To construct a monad with a desired set of features, one typically starts with a base monad, such as &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;, and applies a sequence of monad transformers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f7cb8e57886d5e86aabfd267501ad0211c3d9f3" translate="yes" xml:space="preserve">
          <source>A monad transformer that adds exceptions to other monads.</source>
          <target state="translated">Монада-трансформатор,который добавляет исключения к другим монадам.</target>
        </trans-unit>
        <trans-unit id="6426c40e7452ced39d0234fd45fc21a33bd3cc41" translate="yes" xml:space="preserve">
          <source>A monad transformer that combines &lt;code&gt;ReaderT&lt;/code&gt;, &lt;code&gt;WriterT&lt;/code&gt; and &lt;code&gt;StateT&lt;/code&gt;. This version is lazy; for a constant-space version with almost the same interface, see &lt;a href=&quot;control-monad-trans-rws-cps&quot;&gt;Control.Monad.Trans.RWS.CPS&lt;/a&gt;.</source>
          <target state="translated">Преобразователь монад, объединяющий &lt;code&gt;ReaderT&lt;/code&gt; , &lt;code&gt;WriterT&lt;/code&gt; и &lt;code&gt;StateT&lt;/code&gt; . Эта версия ленивая; для версии с постоянным пространством с почти таким же интерфейсом см. &lt;a href=&quot;control-monad-trans-rws-cps&quot;&gt;Control.Monad.Trans.RWS.CPS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2547fe70b78fa47777714df77c0add427abe3628" translate="yes" xml:space="preserve">
          <source>A monad transformer that combines &lt;code&gt;ReaderT&lt;/code&gt;, &lt;code&gt;WriterT&lt;/code&gt; and &lt;code&gt;StateT&lt;/code&gt;. This version is strict; for a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-rws-lazy&quot;&gt;Control.Monad.Trans.RWS.Lazy&lt;/a&gt;. Although the output is built strictly, it is not possible to achieve constant space behaviour with this transformer: for that, use &lt;a href=&quot;control-monad-trans-rws-cps&quot;&gt;Control.Monad.Trans.RWS.CPS&lt;/a&gt; instead.</source>
          <target state="translated">Преобразователь монад, объединяющий &lt;code&gt;ReaderT&lt;/code&gt; , &lt;code&gt;WriterT&lt;/code&gt; и &lt;code&gt;StateT&lt;/code&gt; . Эта версия строгая; для ленивой версии с тем же интерфейсом см. &lt;a href=&quot;control-monad-trans-rws-lazy&quot;&gt;Control.Monad.Trans.RWS.Lazy&lt;/a&gt; . Хотя вывод построен строго, с помощью этого преобразователя невозможно добиться постоянного пространственного поведения: для этого используйте вместо него &lt;a href=&quot;control-monad-trans-rws-cps&quot;&gt;Control.Monad.Trans.RWS.CPS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e9a2ee9baf8f5856a19298f4db328fc74a1d39bd" translate="yes" xml:space="preserve">
          <source>A monad transformer that combines &lt;code&gt;ReaderT&lt;/code&gt;, &lt;code&gt;WriterT&lt;/code&gt; and &lt;code&gt;StateT&lt;/code&gt;. This version uses continuation-passing-style for the writer part to achieve constant space usage. For a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-rws-lazy&quot;&gt;Control.Monad.Trans.RWS.Lazy&lt;/a&gt;.</source>
          <target state="translated">Преобразователь монад, объединяющий &lt;code&gt;ReaderT&lt;/code&gt; , &lt;code&gt;WriterT&lt;/code&gt; и &lt;code&gt;StateT&lt;/code&gt; . Эта версия использует стиль передачи продолжения для части записи для достижения постоянного использования пространства. Для ленивой версии с тем же интерфейсом см. &lt;a href=&quot;control-monad-trans-rws-lazy&quot;&gt;Control.Monad.Trans.RWS.Lazy&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="500a320bcd121d2c8283ae8852b2515080dcee31" translate="yes" xml:space="preserve">
          <source>A monad transformer which carries all of the state and settings relevant to a line-reading application.</source>
          <target state="translated">Монадный трансформатор,который несет в себе все состояния и настройки,относящиеся к приложению линейного считывания.</target>
        </trans-unit>
        <trans-unit id="f7f92818234c049ae409685d4444b37152111dc8" translate="yes" xml:space="preserve">
          <source>A monoid on applicative functors.</source>
          <target state="translated">Моноид на аппликативных фанкторах.</target>
        </trans-unit>
        <trans-unit id="fe60158aa8a2b3958c4da9fb0fee916548d774b6" translate="yes" xml:space="preserve">
          <source>A monoid on arrows.</source>
          <target state="translated">Моноид на стрелках.</target>
        </trans-unit>
        <trans-unit id="5845b618bce8288ed7fd6ae679531f4a7a5b077f" translate="yes" xml:space="preserve">
          <source>A more precise specification is as follows. The willingness to be overlapped or incoherent is a property of the &lt;em&gt;instance declaration&lt;/em&gt; itself, controlled as follows:</source>
          <target state="translated">Более точное описание выглядит следующим образом. Готовность к перекрытию или несогласованности - это свойство самого &lt;em&gt;объявления экземпляра&lt;/em&gt; , управляемое следующим образом:</target>
        </trans-unit>
        <trans-unit id="f0e63911e5dfc97bc3c592219078a690d8ed2ff3" translate="yes" xml:space="preserve">
          <source>A mutable array of bytes that can be passed to foreign functions.</source>
          <target state="translated">Мутируемый массив байт,который может быть передан в сторонние функции.</target>
        </trans-unit>
        <trans-unit id="aaaa00796670cca26a60ac72f4e07d8b337ab183" translate="yes" xml:space="preserve">
          <source>A mutable array with unboxed elements, that can be manipulated in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">Изменяемый массив с распакованными элементами, которыми можно управлять в монаде &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; . Аргументы типа следующие:</target>
        </trans-unit>
        <trans-unit id="3387c300ae3f8914517cc0cd6aa9b1be1561eb1a" translate="yes" xml:space="preserve">
          <source>A mutable array with unboxed elements, that can be manipulated in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6994baa9908c386c8aa2378b6690cc491d3b838a" translate="yes" xml:space="preserve">
          <source>A mutable variable in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad</source>
          <target state="translated">Изменяемая переменная в монаде &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="86d8cb4c41428c71956a58b3affc3d3a67e5a624" translate="yes" xml:space="preserve">
          <source>A mutable variable in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985e8387b10ebbbd6e5ab332eab6588b350aa36d" translate="yes" xml:space="preserve">
          <source>A mutable variable in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad</source>
          <target state="translated">Изменяемая переменная в монаде &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a954d6c35420d409169ad1a91fbdf2cc6fa8fd09" translate="yes" xml:space="preserve">
          <source>A name can be quoted with either one or two prefix single quotes:</source>
          <target state="translated">Имя может быть процитировано как с одной,так и с двумя префиксными одиночными кавычками:</target>
        </trans-unit>
        <trans-unit id="6eac8d924312d7747867fd052a0984825adb6ab0" translate="yes" xml:space="preserve">
          <source>A name whose second character is a single quote (sadly) cannot be quoted in this way, because it will be parsed instead as a quoted character. For example, if the function is called &lt;code&gt;f'7&lt;/code&gt; (which is a legal Haskell identifier), an attempt to quote it as &lt;code&gt;'f'7&lt;/code&gt; would be parsed as the character literal &lt;code&gt;'f'&lt;/code&gt; followed by the numeric literal &lt;code&gt;7&lt;/code&gt;. There is no current escape mechanism in this (unusual) situation.</source>
          <target state="translated">Имя, вторым символом которого является одинарная кавычка (к сожалению), нельзя заключать в кавычки таким образом, потому что вместо этого оно будет проанализировано как заключенный в кавычки символ. Например, если функция называется &lt;code&gt;f'7&lt;/code&gt; (который является допустимым идентификатором Haskell), попытка процитировать ее как &lt;code&gt;'f'7&lt;/code&gt; будет анализироваться как символьный литерал &lt;code&gt;'f'&lt;/code&gt; за которым следует числовой литерал &lt;code&gt;7&lt;/code&gt; . В этой (необычной) ситуации нет действующего механизма выхода.</target>
        </trans-unit>
        <trans-unit id="7f16e7f677a6d8e62b9e97a39d3de36debfc79cc" translate="yes" xml:space="preserve">
          <source>A name's package, if it exists.</source>
          <target state="translated">Пакет с именем,если он существует.</target>
        </trans-unit>
        <trans-unit id="7598a3dc426907ef37ba1a8eb3a99bc5a30b0e87" translate="yes" xml:space="preserve">
          <source>A new chunk of heap has been allocated by the indicated capability set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6919dce57a8f508bed2b02c9c8ad2d961f4e47dd" translate="yes" xml:space="preserve">
          <source>A non-blocking version of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryPutMVar&quot;&gt;tryPutMVar&lt;/a&gt;&lt;/code&gt; function attempts to put the value &lt;code&gt;a&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, returning &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if it was successful, or &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">Неблокирующая версия &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; . Функция &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryPutMVar&quot;&gt;tryPutMVar&lt;/a&gt;&lt;/code&gt; пытается поместить значение &lt;code&gt;a&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; , возвращая &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; в случае успеха или &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="1adb02601e1d9275c9a9312a596d444889d03e7a" translate="yes" xml:space="preserve">
          <source>A non-blocking version of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryReadMVar&quot;&gt;tryReadMVar&lt;/a&gt;&lt;/code&gt; function returns immediately, with &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Неблокирующая версия &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; . Функция &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryReadMVar&quot;&gt;tryReadMVar&lt;/a&gt;&lt;/code&gt; немедленно возвращает значение &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; был пуст, или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; , если &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; был заполнен содержимым &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ccd9ca2458eb3a684692c3f8141733d7490bf75" translate="yes" xml:space="preserve">
          <source>A non-blocking version of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; function returns immediately, with &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;. After &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="translated">Неблокирующая версия &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; . Функция &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; немедленно возвращает значение &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; был пуст, или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; , если &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; был заполнен содержимым &lt;code&gt;a&lt;/code&gt; . После &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; , то &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; остается пустым.</target>
        </trans-unit>
        <trans-unit id="e55cff29c2c9733e10c5a0b338cfcec2b5ad75a2" translate="yes" xml:space="preserve">
          <source>A non-blocking version of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryPutMVar&quot;&gt;tryPutMVar&lt;/a&gt;&lt;/code&gt; function attempts to put the value &lt;code&gt;a&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, returning &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if it was successful, or &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">Неблокирующая версия &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; . Функция &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryPutMVar&quot;&gt;tryPutMVar&lt;/a&gt;&lt;/code&gt; пытается поместить значение &lt;code&gt;a&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; , возвращая &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; в случае успеха или &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="206f440a2076bebff809698fc93d8fc54da5d7ab" translate="yes" xml:space="preserve">
          <source>A non-blocking version of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryReadMVar&quot;&gt;tryReadMVar&lt;/a&gt;&lt;/code&gt; function returns immediately, with &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Неблокирующая версия &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; . Функция &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryReadMVar&quot;&gt;tryReadMVar&lt;/a&gt;&lt;/code&gt; немедленно возвращает значение &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; был пуст, или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; , если &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; был заполнен содержимым &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c36e2f146526d2510dab34b468a2981631693ee" translate="yes" xml:space="preserve">
          <source>A non-blocking version of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; function returns immediately, with &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;. After &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="translated">Неблокирующая версия &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; . Функция &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; немедленно возвращает значение &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; был пуст, или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; , если &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; был заполнен содержимым &lt;code&gt;a&lt;/code&gt; . После &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; , то &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; остается пустым.</target>
        </trans-unit>
        <trans-unit id="2569960f87e4b3b548288102fd577f9229d2fab8" translate="yes" xml:space="preserve">
          <source>A non-indexed type representation.</source>
          <target state="translated">Неиндексированное представление типа.</target>
        </trans-unit>
        <trans-unit id="e9d1290f4bd898d7ad62e94e9d30ceb6655bd011" translate="yes" xml:space="preserve">
          <source>A non-inlined version of &lt;code&gt;&lt;a href=&quot;data-text-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Версия без встроенного файла &lt;code&gt;&lt;a href=&quot;data-text-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f03b8899bb7d9e29bd30f804a030dd4fd076a1a" translate="yes" xml:space="preserve">
          <source>A note on evaluation order: the expression &lt;code&gt;seq a b&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; guarantee that &lt;code&gt;a&lt;/code&gt; will be evaluated before &lt;code&gt;b&lt;/code&gt;. The only guarantee given by &lt;code&gt;seq&lt;/code&gt; is that the both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; will be evaluated before &lt;code&gt;seq&lt;/code&gt; returns a value. In particular, this means that &lt;code&gt;b&lt;/code&gt; may be evaluated before &lt;code&gt;a&lt;/code&gt;. If you need to guarantee a specific order of evaluation, you must use the function &lt;code&gt;pseq&lt;/code&gt; from the &quot;parallel&quot; package.</source>
          <target state="translated">Замечание о порядке оценки: выражение &lt;code&gt;seq a b&lt;/code&gt; вовсе &lt;em&gt;не&lt;/em&gt; гарантирует , что будет оцениваться , прежде чем &lt;code&gt;b&lt;/code&gt; . Единственная гарантия, предоставляемая &lt;code&gt;seq&lt;/code&gt; , заключается в том, что и &lt;code&gt;a&lt;/code&gt; , и &lt;code&gt;b&lt;/code&gt; будут вычислены до того, как &lt;code&gt;seq&lt;/code&gt; вернет значение. В частности, это означает, что &lt;code&gt;b&lt;/code&gt; можно вычислить до &lt;code&gt;a&lt;/code&gt; . Если вам нужно гарантировать определенный порядок оценки, вы должны использовать функцию &lt;code&gt;pseq&lt;/code&gt; из пакета &amp;laquo;parallel&amp;raquo;. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c16b58b80137c1a8cc002192b71e052aeb6a9ce" translate="yes" xml:space="preserve">
          <source>A number of restrictions apply to use of annotations:</source>
          <target state="translated">На использование аннотаций распространяется ряд ограничений:</target>
        </trans-unit>
        <trans-unit id="711bb74ca36d3d4c1868e4f33ea8af8c9700a708" translate="yes" xml:space="preserve">
          <source>A package database is where the details about installed packages are stored. It is a directory, usually called &lt;code&gt;package.conf.d&lt;/code&gt;, that contains a file for each package, together with a binary cache of the package data in the file &lt;code&gt;package.cache&lt;/code&gt;. Normally you won&amp;rsquo;t need to look at or modify the contents of a package database directly; all management of package databases can be done through the &lt;strong&gt;ghc-pkg&lt;/strong&gt; tool (see &lt;a href=&quot;#package-management&quot;&gt;Package management (the ghc-pkg command)&lt;/a&gt;).</source>
          <target state="translated">База данных пакетов - это место, где хранятся сведения об установленных пакетах. Это каталог, обычно называемый &lt;code&gt;package.conf.d&lt;/code&gt; , который содержит файл для каждого пакета вместе с двоичным кешем данных пакета в файле &lt;code&gt;package.cache&lt;/code&gt; . Обычно вам не нужно напрямую просматривать или изменять содержимое базы данных пакетов; все управление базами данных пакетов можно выполнить с помощью инструмента &lt;strong&gt;ghc-pkg&lt;/strong&gt; (см. Управление пакетами &lt;a href=&quot;#package-management&quot;&gt;(команда ghc-pkg)&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e6482c111ff88fbc29ede2ddeea4102525681832" translate="yes" xml:space="preserve">
          <source>A package description consists of a number of field/value pairs. A field starts with the field name in the left-hand column followed by a &amp;ldquo;&lt;code&gt;:&lt;/code&gt;&amp;rdquo;, and the value continues until the next line that begins in the left-hand column, or the end of file.</source>
          <target state="translated">Описание пакета состоит из ряда пар поле / значение. Поле начинается с имени поля в левом столбце, за которым следует &amp;laquo; &lt;code&gt;:&lt;/code&gt; &amp;raquo;, и значение продолжается до следующей строки, которая начинается в левом столбце, или до конца файла.</target>
        </trans-unit>
        <trans-unit id="f0d41efbca1f6d8a23338adade26a83c1583e8be" translate="yes" xml:space="preserve">
          <source>A package is a library of Haskell modules known to the compiler. GHC comes with several packages: see the accompanying &lt;a href=&quot;../libraries/index&quot;&gt;library documentation&lt;/a&gt;. More packages to install can be obtained from &lt;a href=&quot;http://hackage.haskell.org/packages/hackage.html&quot;&gt;HackageDB&lt;/a&gt;.</source>
          <target state="translated">Пакет - это библиотека модулей Haskell, известная компилятору. GHC поставляется с несколькими пакетами: см. Сопроводительную &lt;a href=&quot;../libraries/index&quot;&gt;документацию библиотеки&lt;/a&gt; . Дополнительные пакеты для установки можно получить на &lt;a href=&quot;http://hackage.haskell.org/packages/hackage.html&quot;&gt;HackageDB&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3dbde045ae446b9fd85968f7cfc7dbefc9f7710" translate="yes" xml:space="preserve">
          <source>A package specification is a Haskell record; in particular, it is the record &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/Cabal-3.2.0.0/Distribution-InstalledPackageInfo.html#t:InstalledPackageInfo&quot;&gt;Distribution.InstalledPackageInfo.InstalledPackageInfo&lt;/a&gt; in the module Distribution.InstalledPackageInfo, which is part of the Cabal package distributed with GHC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c877a3844ef3dc7d9601200a6497a731da7b2b16" translate="yes" xml:space="preserve">
          <source>A package specification is a Haskell record; in particular, it is the record &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Distribution-InstalledPackageInfo.html#t:InstalledPackageInfo&quot;&gt;Distribution.InstalledPackageInfo.InstalledPackageInfo&lt;/a&gt; in the module Distribution.InstalledPackageInfo, which is part of the Cabal package distributed with GHC.</source>
          <target state="translated">Спецификация пакета - это запись Haskell; в частности, это запись &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Distribution-InstalledPackageInfo.html#t:InstalledPackageInfo&quot;&gt;Distribution.InstalledPackageInfo.InstalledPackageInfo&lt;/a&gt; в модуле Distribution.InstalledPackageInfo, который является частью пакета Cabal, распространяемого с GHC.</target>
        </trans-unit>
        <trans-unit id="8d7ab63973f7143650edb4489cbabd9755f0dae2" translate="yes" xml:space="preserve">
          <source>A pair of an open type family equations is checked by attempting to unify their RHSs. If the RHSs don&amp;rsquo;t unify this pair does not violate injectivity annotation. If unification succeeds with a substitution then LHSs of unified equations must be identical under that substitution. If they are not identical then GHC reports that the type family is not injective.</source>
          <target state="translated">Пара уравнений семейства открытого типа проверяется попыткой унифицировать их правые части. Если RHS не объединяются, эта пара не нарушает аннотацию приемистости. Если объединение успешно с заменой, то LHS унифицированных уравнений должны быть идентичны при этой замене. Если они не идентичны, то GHC сообщает, что семейство типов не является инъективным.</target>
        </trans-unit>
        <trans-unit id="84d2773400375ccf44e88b72599837fd03633672" translate="yes" xml:space="preserve">
          <source>A pairing heap tagged with both a key and the original position of its elements, for use in &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Куча сопряжения, помеченная как ключом, так и исходной позицией ее элементов, для использования в &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2dd62e14bc9431464958571d2b435d03d28b2f82" translate="yes" xml:space="preserve">
          <source>A pairing heap tagged with some key for sorting elements, for use in &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Куча сопряжения, помеченная некоторым ключом для сортировки элементов, для использования в &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08959b3dc19b34612dd713a20c89a35536c5c8b1" translate="yes" xml:space="preserve">
          <source>A pairing heap tagged with the original position of elements, to allow for stable sorting.</source>
          <target state="translated">Сопряженная куча,помеченная исходным положением элементов,для обеспечения стабильной сортировки.</target>
        </trans-unit>
        <trans-unit id="179683aea0f779b8d62f71ce768d02e25c23258e" translate="yes" xml:space="preserve">
          <source>A pairing/concatenation operator for builder primitives, both bounded and fixed size.</source>
          <target state="translated">Оператор сопряжения/конскатенации для примитивов конструктора,как ограниченного,так и фиксированного размера.</target>
        </trans-unit>
        <trans-unit id="a9abb3b7589ecd20d1d2b93e90cc7db6542915ba" translate="yes" xml:space="preserve">
          <source>A parallel garbage collection has been requested by a capability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b720794f2dd0a7c18f79f3dbbf604879cd4d39c" translate="yes" xml:space="preserve">
          <source>A parallel list comprehension has multiple independent branches of qualifier lists, each separated by a &lt;code&gt;|&lt;/code&gt; symbol. For example, the following zips together two lists:</source>
          <target state="translated">Понимание параллельного списка имеет несколько независимых ветвей списков квалификаторов, каждая из которых разделена знаком &lt;code&gt;|&lt;/code&gt; условное обозначение. Например, следующий код объединяет два списка:</target>
        </trans-unit>
        <trans-unit id="3fb86b841f661b45cc569b86782f61f203ff3263" translate="yes" xml:space="preserve">
          <source>A parameter to specify the number of lines affected. Some capabilities (e.g., &lt;code&gt;clear&lt;/code&gt; and &lt;code&gt;dch1&lt;/code&gt;) use this parameter on some terminals to compute variable-length padding.</source>
          <target state="translated">Параметр для указания количества затронутых строк. Некоторые возможности (например, &lt;code&gt;clear&lt;/code&gt; и &lt;code&gt;dch1&lt;/code&gt; ) используют этот параметр на некоторых терминалах для вычисления заполнения переменной длины.</target>
        </trans-unit>
        <trans-unit id="3c7816b5381405514fd134ab41157f7a1b19dbb1" translate="yes" xml:space="preserve">
          <source>A parser for a type &lt;code&gt;a&lt;/code&gt;, represented as a function that takes a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and returns a list of possible parses as &lt;code&gt;(a,&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;)&lt;/code&gt; pairs.</source>
          <target state="translated">Синтаксический анализатор для типа &lt;code&gt;a&lt;/code&gt; , представленный как функция, которая принимает &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; и возвращает список возможных синтаксических анализов в &lt;code&gt;(a,&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;)&lt;/code&gt; пар (a, String ) .</target>
        </trans-unit>
        <trans-unit id="8ef40a705741b0fa0c05e60da025feb810b08af8" translate="yes" xml:space="preserve">
          <source>A parser for a type &lt;code&gt;a&lt;/code&gt;, represented as a function that takes a &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and returns a list of possible parses as &lt;code&gt;(a,&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;)&lt;/code&gt; pairs.</source>
          <target state="translated">Синтаксический анализатор для типа &lt;code&gt;a&lt;/code&gt; , представленный как функция, которая принимает &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; и возвращает список возможных синтаксических анализов в &lt;code&gt;(a,&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;)&lt;/code&gt; пар (a, String ) .</target>
        </trans-unit>
        <trans-unit id="77e31a3f5862591f06987b3fcab3d8cc7ae35a42" translate="yes" xml:space="preserve">
          <source>A parser for versions in the format produced by &lt;code&gt;&lt;a href=&quot;data-version#v:showVersion&quot;&gt;showVersion&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Парсер для версий в формате, созданном &lt;code&gt;&lt;a href=&quot;data-version#v:showVersion&quot;&gt;showVersion&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00189f74465df92aa0eb7c3be6fb9e5d018cbddf" translate="yes" xml:space="preserve">
          <source>A partial type signature is a type signature containing special placeholders called &lt;em&gt;wildcards&lt;/em&gt;. A wildcard is written as an underscore (e.g. &amp;ldquo;&lt;code&gt;_&lt;/code&gt;&amp;rdquo;) or, if &lt;a href=&quot;#extension-NamedWildCards&quot;&gt;&lt;code&gt;NamedWildCards&lt;/code&gt;&lt;/a&gt; is enabled, any identifier with a leading underscore (e.g. &amp;ldquo;&lt;code&gt;_foo&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_bar&lt;/code&gt;&amp;rdquo;). Partial type signatures are to type signatures what &lt;a href=&quot;#typed-holes&quot;&gt;Typed Holes&lt;/a&gt; are to expressions. During compilation these wildcards or holes will generate an error message that describes which type was inferred at the hole&amp;rsquo;s location, and information about the origin of any free type variables. GHC reports such error messages by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d8d03f9fe4fb54a82d09df64d310f7a60062a82" translate="yes" xml:space="preserve">
          <source>A partial type signature is a type signature containing special placeholders written with a leading underscore (e.g., &amp;ldquo;&lt;code&gt;_&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_foo&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_bar&lt;/code&gt;&amp;rdquo;) called &lt;em&gt;wildcards&lt;/em&gt;. Partial type signatures are to type signatures what &lt;a href=&quot;#typed-holes&quot;&gt;Typed Holes&lt;/a&gt; are to expressions. During compilation these wildcards or holes will generate an error message that describes which type was inferred at the hole&amp;rsquo;s location, and information about the origin of any free type variables. GHC reports such error messages by default.</source>
          <target state="translated">Сигнатура частичного типа - это сигнатура типа, содержащая специальные заполнители, записанные с &lt;code&gt;_foo&lt;/code&gt; подчеркиванием (например, &amp;laquo; &lt;code&gt;_&lt;/code&gt; &amp;raquo;, &amp;laquo; _foo &amp;raquo;, &amp;laquo; &lt;code&gt;_bar&lt;/code&gt; &amp;raquo;), называемые &lt;em&gt;подстановочными знаками&lt;/em&gt; . Сигнатуры частичного типа предназначены для &lt;a href=&quot;#typed-holes&quot;&gt;типизированных&lt;/a&gt; сигнатур, что и типизированные отверстия для выражений. Во время компиляции эти подстановочные знаки или дыры будут генерировать сообщение об ошибке, описывающее, какой тип был выведен в местоположении дыры, и информацию о происхождении любых переменных свободного типа. GHC выдает такие сообщения об ошибках по умолчанию.</target>
        </trans-unit>
        <trans-unit id="0ce90625442120850b40e55bce20778556220c5e" translate="yes" xml:space="preserve">
          <source>A pattern</source>
          <target state="translated">Образец</target>
        </trans-unit>
        <trans-unit id="433fae1ea61aa93f2a83f57ff1684a275dd099f0" translate="yes" xml:space="preserve">
          <source>A pattern match failed. The &lt;code&gt;String&lt;/code&gt; gives information about the source location of the pattern.</source>
          <target state="translated">Не удалось сопоставить шаблон. &lt;code&gt;String&lt;/code&gt; дает информацию об исходном местоположении шаблона.</target>
        </trans-unit>
        <trans-unit id="252b18a2db7ed609ee5f049df36aa764455492be" translate="yes" xml:space="preserve">
          <source>A pattern quasiquoter &lt;em&gt;may&lt;/em&gt; generate binders that scope over the right-hand side of a definition because these binders are in scope lexically. For example, given a quasiquoter &lt;code&gt;haskell&lt;/code&gt; that parses Haskell, in the following code, the &lt;code&gt;y&lt;/code&gt; in the right-hand side of &lt;code&gt;f&lt;/code&gt; refers to the &lt;code&gt;y&lt;/code&gt; bound by the &lt;code&gt;haskell&lt;/code&gt; pattern quasiquoter, &lt;em&gt;not&lt;/em&gt; the top-level &lt;code&gt;y = 7&lt;/code&gt;.</source>
          <target state="translated">Квазиквотер шаблона &lt;em&gt;может&lt;/em&gt; генерировать связующие, которые охватывают правую часть определения, потому что эти связующие находятся в области лексической области. Например, для данного квазиквотера &lt;code&gt;haskell&lt;/code&gt; , который анализирует Haskell, в следующем коде &lt;code&gt;y&lt;/code&gt; в правой части &lt;code&gt;f&lt;/code&gt; относится к &lt;code&gt;y&lt;/code&gt; , ограниченному квазиквотером шаблона &lt;code&gt;haskell&lt;/code&gt; , а &lt;em&gt;не&lt;/em&gt; к верхнему уровню &lt;code&gt;y = 7&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ac55497c2a5f3f9d1f6ff0844f5381d5d90653d" translate="yes" xml:space="preserve">
          <source>A pattern synonym</source>
          <target state="translated">Синоним шаблона</target>
        </trans-unit>
        <trans-unit id="b17af7c644158ae7e89b62cef1f1583e8c015c62" translate="yes" xml:space="preserve">
          <source>A pattern synonym declaration can be either unidirectional, bidirectional or explicitly bidirectional. The syntax for unidirectional pattern synonyms is:</source>
          <target state="translated">Объявление синонима шаблона может быть однонаправленным,двунаправленным или явно двунаправленным.Синтаксисом однонаправленных синонимов шаблона является:</target>
        </trans-unit>
        <trans-unit id="55cb5ca64df4e9f9ca70699a5130d9563eece58c" translate="yes" xml:space="preserve">
          <source>A pattern synonym occurrence in a pattern is evaluated by first matching against the pattern synonym itself, and then on the argument patterns.</source>
          <target state="translated">Вхождение синонима шаблона в шаблон оценивается сначала по совпадению с синонимом самого шаблона,а затем по шаблонам аргументов.</target>
        </trans-unit>
        <trans-unit id="6a294e72d5a00c5790ab20aeadfe0fb6770ada67" translate="yes" xml:space="preserve">
          <source>A pattern synonym's argument type.</source>
          <target state="translated">Тип аргумента синонима шаблона.</target>
        </trans-unit>
        <trans-unit id="cc5e6ef416da30039d54dd764052a16e266e5fba" translate="yes" xml:space="preserve">
          <source>A pattern synonym's directionality.</source>
          <target state="translated">Направленность синонима шаблона.</target>
        </trans-unit>
        <trans-unit id="dbbd0987654018a69ab48de461e219d56cbd0973" translate="yes" xml:space="preserve">
          <source>A pattern synonym's type signature.</source>
          <target state="translated">Подпись типа синонима шаблона.</target>
        </trans-unit>
        <trans-unit id="57cf5046220efabc22f8328901a49323d7f92001" translate="yes" xml:space="preserve">
          <source>A pattern synonym's type. Note that a pattern synonym's &lt;em&gt;fully&lt;/em&gt; specified type has a peculiar shape coming with two forall quantifiers and two constraint contexts. For example, consider the pattern synonym</source>
          <target state="translated">Тип синонима шаблона. Обратите внимание, что &lt;em&gt;полностью&lt;/em&gt; определенный тип синонима шаблона имеет своеобразную форму с двумя квантификаторами для всех и двумя контекстами ограничений. Например, рассмотрим синоним шаблона</target>
        </trans-unit>
        <trans-unit id="eb6f155dcdcf6384b306398b26156bf38f28d6e1" translate="yes" xml:space="preserve">
          <source>A pattern type signature (&lt;a href=&quot;#pattern-type-sigs&quot;&gt;Pattern type signatures&lt;/a&gt;)</source>
          <target state="translated">Подпись типа шаблона ( &lt;a href=&quot;#pattern-type-sigs&quot;&gt;подписи типа шаблона&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a7c69d52227bddae63e60e9734e227c6257070e0" translate="yes" xml:space="preserve">
          <source>A pattern variable may optionally have a type signature. If the type of the pattern variable is polymorphic, it &lt;em&gt;must&lt;/em&gt; have a type signature. For example, here is the &lt;code&gt;foldr/build&lt;/code&gt; rule:</source>
          <target state="translated">Переменная шаблона может дополнительно иметь подпись типа. Если тип переменной шаблона является полиморфным, она &lt;em&gt;должна&lt;/em&gt; иметь сигнатуру типа. Например, вот правило &lt;code&gt;foldr/build&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0a9bf5dd0f5b938cd3b48a5e6e85a85c3767d1a0" translate="yes" xml:space="preserve">
          <source>A pattern with a bang at the outermost level is not allowed at the top level of a module.</source>
          <target state="translated">На верхнем уровне модуля не допускается использование шаблона со взбалтыванием на крайнем уровне.</target>
        </trans-unit>
        <trans-unit id="a45544682b3f8a207a4592a867670905952dce9d" translate="yes" xml:space="preserve">
          <source>A periodic reporting of various statistics of spark evaluation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9808c24500197f32f662437a4166807e09da1b17" translate="yes" xml:space="preserve">
          <source>A permutation phrase is a sequence of elements (possibly of different types) in which each element occurs exactly once and the order is irrelevant. Some of the permutable elements may be optional.</source>
          <target state="translated">Фраза перестановки-это последовательность элементов (возможно,разных типов),в которой каждый элемент встречается ровно один раз и порядок не имеет значения.Некоторые из перестановочных элементов могут быть необязательными.</target>
        </trans-unit>
        <trans-unit id="5dbcb4942ca58cf7831c96fb91a0838412cc4bba" translate="yes" xml:space="preserve">
          <source>A pinned byte array is one that the garbage collector is not allowed to move. Consequently, it has a stable address that can be safely requested with &lt;code&gt;byteArrayContents#&lt;/code&gt;. There are a handful of primitive functions in GHC.Prim &amp;lt;GHC-Prim.html&amp;gt; used to enforce or check for pinnedness: &lt;code&gt;isByteArrayPinned#&lt;/code&gt;, &lt;code&gt;isMutableByteArrayPinned#&lt;/code&gt;, and &lt;code&gt;newPinnedByteArray#&lt;/code&gt;. A byte array can be pinned as a result of three possible causes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43d2f58da1fb581a9ce7c0820def592bde3a97f6" translate="yes" xml:space="preserve">
          <source>A plugin which declares itself impure using &lt;code&gt;ForceRecompile&lt;/code&gt; will always trigger a recompilation of the current module. &lt;code&gt;NoForceRecompile&lt;/code&gt; is used for &amp;ldquo;pure&amp;rdquo; plugins which don&amp;rsquo;t need to be rerun unless a module would ordinarily be recompiled. &lt;code&gt;MaybeRecompile&lt;/code&gt; computes a &lt;code&gt;Fingerprint&lt;/code&gt; and if this &lt;code&gt;Fingerprint&lt;/code&gt; is different to a previously computed &lt;code&gt;Fingerprint&lt;/code&gt; for the plugin, then we recompile the module.</source>
          <target state="translated">Плагин, который объявляет себя нечистым с помощью &lt;code&gt;ForceRecompile&lt;/code&gt; , всегда запускает перекомпиляцию текущего модуля. &lt;code&gt;NoForceRecompile&lt;/code&gt; используется для &amp;laquo;чистых&amp;raquo; плагинов, которые не нужно запускать повторно, если модуль не будет обычно перекомпилирован. &lt;code&gt;MaybeRecompile&lt;/code&gt; вычисляет &lt;code&gt;Fingerprint&lt;/code&gt; , и если этот &lt;code&gt;Fingerprint&lt;/code&gt; отличается от ранее вычисленного &lt;code&gt;Fingerprint&lt;/code&gt; для плагина, мы перекомпилируем модуль.</target>
        </trans-unit>
        <trans-unit id="a3bc90dc2dc45d7f4fd4afcd9ae1bd1af634697a" translate="yes" xml:space="preserve">
          <source>A plugin&amp;rsquo;s installation function (&lt;code&gt;install&lt;/code&gt; in the above example) takes a list of &lt;code&gt;CoreToDo&lt;/code&gt;s and returns a list of &lt;code&gt;CoreToDo&lt;/code&gt;. Before GHC begins compiling modules, it enumerates all the needed plugins you tell it to load, and runs all of their installation functions, initially on a list of passes that GHC specifies itself. After doing this for every plugin, the final list of passes is given to the optimizer, and are run by simply going over the list in order.</source>
          <target state="translated">Функция установки плагина ( &lt;code&gt;install&lt;/code&gt; в приведенном выше примере) принимает список &lt;code&gt;CoreToDo&lt;/code&gt; и возвращает список &lt;code&gt;CoreToDo&lt;/code&gt; . Прежде чем GHC начнет компилировать модули, он перечисляет все необходимые плагины, которые вы указываете для загрузки, и запускает все их функции установки, первоначально в списке проходов, который GHC определяет сам. После выполнения этого для каждого плагина окончательный список проходов передается оптимизатору и запускается простым просмотром списка по порядку.</target>
        </trans-unit>
        <trans-unit id="c3c0c15abdc47e8b410d77eeddeb4ff60204efc9" translate="yes" xml:space="preserve">
          <source>A pointer to a foreign function equivalent to &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt;, which may be used as a finalizer (cf &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;) for storage allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Указатель на внешнюю функцию, эквивалентную &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; , которая может использоваться в качестве финализатора (см. &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; ) для памяти, выделенной с помощью &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed62f36de9a3053add8b5f383c46d4ea22035d53" translate="yes" xml:space="preserve">
          <source>A pointer, but &lt;em&gt;not&lt;/em&gt; to a Haskell value</source>
          <target state="translated">Указатель, но &lt;em&gt;не&lt;/em&gt; на значение Haskell</target>
        </trans-unit>
        <trans-unit id="12c3c6eef2eab225b82c10e7756d7d1120735999" translate="yes" xml:space="preserve">
          <source>A positive initial counter value denotes availability of units &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:waitTSem&quot;&gt;waitTSem&lt;/a&gt;&lt;/code&gt; can acquire.</source>
          <target state="translated">Положительное начальное значение счетчика означает наличие единиц, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:waitTSem&quot;&gt;waitTSem&lt;/a&gt;&lt;/code&gt; может получить waitTSem .</target>
        </trans-unit>
        <trans-unit id="4607e3c8d43d975a9d5043b9fe5325adef419139" translate="yes" xml:space="preserve">
          <source>A possible reason for this is that &lt;code&gt;readLitChar&lt;/code&gt; accepts hex and octal escapes, so it seems inconsistent not to do so for integers too.</source>
          <target state="translated">Возможная причина этого в том, что &lt;code&gt;readLitChar&lt;/code&gt; принимает шестнадцатеричные и восьмеричные escape-последовательности , поэтому не делать этого и для целых чисел тоже непоследовательно.</target>
        </trans-unit>
        <trans-unit id="ee0df3315cf15090b8170db19c00adae9d086669" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList&quot;&gt;liftReadList&lt;/a&gt;&lt;/code&gt; method. This is only needed for &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; instances where &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; isn't defined as &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrecDefault&quot;&gt;liftReadListPrecDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Определение возможной замены для метода &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList&quot;&gt;liftReadList&lt;/a&gt;&lt;/code&gt; . Это необходимо только для &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; случаев , когда &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; не определяется как &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrecDefault&quot;&gt;liftReadListPrecDefault&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d38c3479f89f023338692e638f45fe5ac188bd2d" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList2&quot;&gt;liftReadList2&lt;/a&gt;&lt;/code&gt; method. This is only needed for &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read2&quot;&gt;Read2&lt;/a&gt;&lt;/code&gt; instances where &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; isn't defined as &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2Default&quot;&gt;liftReadListPrec2Default&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Определение возможной замены для метода &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList2&quot;&gt;liftReadList2&lt;/a&gt;&lt;/code&gt; . Это необходимо только для &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read2&quot;&gt;Read2&lt;/a&gt;&lt;/code&gt; случаев , когда &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; не определяется как &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2Default&quot;&gt;liftReadListPrec2Default&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1d027bf72f3911128c132d8c54e0a8ef6c5c888" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; method, defined using &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Определение возможной замены для метода &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; , определенного с помощью &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d373fa8bb2d277c322dacc2f2dcc3f3d824b4e2" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; method, defined using &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Определение возможной замены для метода &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; , определенного с помощью &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29364a8e8891d9c56243d372544806d4d546619b" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; method (GHC only). This is only needed for GHC, and even then only for &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances where &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; isn't defined as &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Определение возможной замены для метода &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; (только GHC). Это необходимо только для GHC, и даже тогда только для экземпляров &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; , где &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; не определен как &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68ae1239307d70eba9e18971c894baa48ad11cf4" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; method, defined using &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; (GHC only).</source>
          <target state="translated">Определение возможной замены для метода &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; , определенного с помощью &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; (только GHC).</target>
        </trans-unit>
        <trans-unit id="f80e2bb9e234ed027f7e8ba6d593f983b80c8933" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; method (GHC only). This is only needed for GHC, and even then only for &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances where &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; isn't defined as &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Определение возможной замены для метода &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; (только GHC). Это необходимо только для GHC, и даже тогда только для экземпляров &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; , где &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; не определен как &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f98f636cd56d17e711ba559f0f71c4bdebdffa1" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; method, defined using &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; (GHC only).</source>
          <target state="translated">Определение возможной замены для метода &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; , определенного с помощью &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; (только GHC).</target>
        </trans-unit>
        <trans-unit id="b157127674bef09a54a1bf4952fda41dd1808377" translate="yes" xml:space="preserve">
          <source>A postfix '&lt;code&gt;M&lt;/code&gt;' always stands for a function in the Kleisli category: The monad type constructor &lt;code&gt;m&lt;/code&gt; is added to function results (modulo currying) and nowhere else. So, for example,</source>
          <target state="translated">Постфикс &amp;laquo; &lt;code&gt;M&lt;/code&gt; &amp;raquo; всегда означает функцию из категории Клейсли: конструктор монадного типа &lt;code&gt;m&lt;/code&gt; добавляется к результатам функции (по модулю каррирования) и больше нигде. Так, например,</target>
        </trans-unit>
        <trans-unit id="4f57aca0d9a4c899e484cd901e67bacaa13d70b9" translate="yes" xml:space="preserve">
          <source>A postfix '&lt;code&gt;_&lt;/code&gt;' changes the result type from &lt;code&gt;(m a)&lt;/code&gt; to &lt;code&gt;(m ())&lt;/code&gt;. Thus, for example:</source>
          <target state="translated">Постфикс ' &lt;code&gt;_&lt;/code&gt; ' изменяет тип результата с &lt;code&gt;(m a)&lt;/code&gt; на &lt;code&gt;(m ())&lt;/code&gt; . Так, например:</target>
        </trans-unit>
        <trans-unit id="46921428c3bbaa58265d19bfda0ee3268636763a" translate="yes" xml:space="preserve">
          <source>A precise semantics</source>
          <target state="translated">Точная семантика</target>
        </trans-unit>
        <trans-unit id="47f994aa80408a0bd45b4587fcafe17e6fd888ec" translate="yes" xml:space="preserve">
          <source>A predicate &lt;code&gt;trim used allocated&lt;/code&gt; returning &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, if the buffer should be trimmed before it is returned.</source>
          <target state="translated">Используется &lt;code&gt;trim used allocated&lt;/code&gt; предиката, возвращающая значение &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если буфер должен быть обрезан перед возвратом .</target>
        </trans-unit>
        <trans-unit id="d580afd63f73de0a796d71c734098f93fa407b93" translate="yes" xml:space="preserve">
          <source>A predicate &lt;code&gt;trim used allocated&lt;/code&gt; returning &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, if the buffer should be trimmed before it is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7be90e7ccc0906e803e54dbfc057396ec04901" translate="yes" xml:space="preserve">
          <source>A prefix '&lt;code&gt;m&lt;/code&gt;' generalizes an existing function to a monadic form. Thus, for example:</source>
          <target state="translated">Префикс &amp;laquo; &lt;code&gt;m&lt;/code&gt; &amp;raquo; обобщает существующую функцию до монадической формы. Так, например:</target>
        </trans-unit>
        <trans-unit id="89ba2753b7a938dad018da0fd6997dc0b76bb953" translate="yes" xml:space="preserve">
          <source>A primitive C-style string, type Addr#</source>
          <target state="translated">Примитивная строка в стиле C,введите Addr#.</target>
        </trans-unit>
        <trans-unit id="47d0a23e976121bc1cfab9f6f18718ab2b9d2383" translate="yes" xml:space="preserve">
          <source>A process in the process group</source>
          <target state="translated">Процесс в группе процессов</target>
        </trans-unit>
        <trans-unit id="e2978f6c6d0c2493478216f46bf15eb08160b4e7" translate="yes" xml:space="preserve">
          <source>A program that fails in any other way is treated as if it had called &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt;. A program that terminates successfully without calling &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; explicitly is treated as if it had called &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Программа, которая терпит неудачу каким-либо другим образом, рассматривается как если бы она вызвала &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; . Программа, которая успешно завершается без явного вызова &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; , обрабатывается так, как если бы она вызвала &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="106e5d7fb17753020184a4433ee767b6d5411226" translate="yes" xml:space="preserve">
          <source>A programmer may use &lt;code&gt;forall&lt;/code&gt; in a type to introduce new quantified type variables. These variables may depend on each other, even in the same &lt;code&gt;forall&lt;/code&gt;. However, GHC requires that the dependency be inferrable from the body of the &lt;code&gt;forall&lt;/code&gt;. Here are some examples:</source>
          <target state="translated">Программист может использовать &lt;code&gt;forall&lt;/code&gt; в типе, чтобы ввести новые количественные переменные типа. Эти переменные могут зависеть друг от друга, даже в том же &lt;code&gt;forall&lt;/code&gt; . Тем не менее, GHC требует, чтобы зависимость быть inferrable от тела &lt;code&gt;forall&lt;/code&gt; . Вот некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="71ba773b3259e537cc66acd4ec6d24f2384a5425" translate="yes" xml:space="preserve">
          <source>A programmer-defined error value constructed using &lt;code&gt;&lt;a href=&quot;system-io-error#v:userError&quot;&gt;userError&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Значение ошибки, определяемое программистом, &lt;code&gt;&lt;a href=&quot;system-io-error#v:userError&quot;&gt;userError&lt;/a&gt;&lt;/code&gt; с помощью userError .</target>
        </trans-unit>
        <trans-unit id="7217616c7698f7547fd2c1e5c701e62f18577563" translate="yes" xml:space="preserve">
          <source>A pun on a qualified field name is expanded by stripping off the module qualifier. For example:</source>
          <target state="translated">Каламбур на квалифицированном названии поля расширяется путем удаления классификатора модуля.Например:</target>
        </trans-unit>
        <trans-unit id="c36208f7850763edf61643d27d80bde39732dac8" translate="yes" xml:space="preserve">
          <source>A qualified name &lt;code&gt;A.foo&lt;/code&gt;. GHC assumes that the main function is &lt;code&gt;A.foo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A.foo&lt;/code&gt; имя A.foo . GHC предполагает, что основная функция - &lt;code&gt;A.foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1f854f70933a723bf95a735c3aa4de5afabd5c6" translate="yes" xml:space="preserve">
          <source>A qualified name; dynamically bound</source>
          <target state="translated">Квалифицированное имя;динамически связанное</target>
        </trans-unit>
        <trans-unit id="a8f9eb9db19a1818e7c75d1fe1ee9a6205220c54" translate="yes" xml:space="preserve">
          <source>A quantified type representation.</source>
          <target state="translated">Количественное представление типа.</target>
        </trans-unit>
        <trans-unit id="e82bbf975220aa7ab5228dfdba9164c275fc91d4" translate="yes" xml:space="preserve">
          <source>A quasi-quotation can appear in a pattern, type, expression, or declaration context and is also written in Oxford brackets:</source>
          <target state="translated">Квази-цитата может появиться в шаблоне,типе,выражении или контексте декларации,а также написана в Оксфордских скобках:</target>
        </trans-unit>
        <trans-unit id="9598087296773252828f5341b4828654c30bd8a1" translate="yes" xml:space="preserve">
          <source>A quasi-quote has the form &lt;code&gt;[quoter| string |]&lt;/code&gt;.</source>
          <target state="translated">Квази-цитата имеет вид &lt;code&gt;[quoter| string |]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1cb587055071e4fb0d1b0454a870959e6f9fa49" translate="yes" xml:space="preserve">
          <source>A quasi-quote is expanded by applying the appropriate parser to the string enclosed by the Oxford brackets. The context of the quasi-quote (expression, pattern, type, declaration) determines which of the parsers is called.</source>
          <target state="translated">Квази-цитата расширяется путем применения соответствующего парсера к строке,заключенной в Оксфордские скобки.Контекст квазицитаты (выражение,шаблон,тип,объявление)определяет,какой из парсеров вызывается.</target>
        </trans-unit>
        <trans-unit id="cdcde5d2df86936b559e312ff74aff26f8e4d03f" translate="yes" xml:space="preserve">
          <source>A quasiquote may appear in place of</source>
          <target state="translated">Квазиквота может появиться вместо</target>
        </trans-unit>
        <trans-unit id="a001d4fd181336f68b683e872533d57d619d5b7e" translate="yes" xml:space="preserve">
          <source>A question that we often want to ask when debugging a program is &amp;ldquo;how did I get here?&amp;rdquo;. Traditional imperative debuggers usually provide some kind of stack-tracing feature that lets you see the stack of active function calls (sometimes called the &amp;ldquo;lexical call stack&amp;rdquo;), describing a path through the code to the current location. Unfortunately this is hard to provide in Haskell, because execution proceeds on a demand-driven basis, rather than a depth-first basis as in strict languages. The &amp;ldquo;stack&amp;ldquo; in GHC&amp;rsquo;s execution engine bears little resemblance to the lexical call stack. Ideally GHCi would maintain a separate lexical call stack in addition to the dynamic call stack, and in fact this is exactly what our profiling system does (&lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;), and what some other Haskell debuggers do. For the time being, however, GHCi doesn&amp;rsquo;t maintain a lexical call stack (there are some technical challenges to be overcome). Instead, we provide a way to backtrack from a breakpoint to previous evaluation steps: essentially this is like single-stepping backwards, and should in many cases provide enough information to answer the &amp;ldquo;how did I get here?&amp;rdquo; question.</source>
          <target state="translated">При отладке программы мы часто задаем вопрос: &amp;laquo;Как я сюда попал?&amp;raquo;. Традиционные императивные отладчики обычно предоставляют некую функцию трассировки стека, которая позволяет вам видеть стек вызовов активных функций (иногда называемый &amp;laquo;стеком лексических вызовов&amp;raquo;), описывающий путь через код к текущему местоположению. К сожалению, это сложно обеспечить в Haskell, потому что выполнение происходит по запросу, а не по глубине, как в строгих языках. &amp;laquo;Стек&amp;raquo; в механизме выполнения GHC мало похож на лексический стек вызовов. В идеале GHCi должен поддерживать отдельный стек лексических вызовов в дополнение к стеку динамических вызовов, и фактически это именно то, что делает наша система профилирования ( &lt;a href=&quot;profiling#profiling&quot;&gt;Профилирование&lt;/a&gt;) и что делают некоторые другие отладчики Haskell. Однако в настоящее время GHCi не поддерживает лексический стек вызовов (есть некоторые технические проблемы, которые необходимо преодолеть). Вместо этого мы предоставляем способ вернуться от точки останова к предыдущим этапам оценки: по сути, это похоже на одиночный шаг назад, и во многих случаях он должен предоставлять достаточно информации, чтобы ответить на вопрос &amp;laquo;как я сюда попал?&amp;raquo; вопрос.</target>
        </trans-unit>
        <trans-unit id="ad0242b7d03d75d9ad4b17787a60e3e615d37d16" translate="yes" xml:space="preserve">
          <source>A quoter is a value of type &lt;code&gt;Language.Haskell.TH.Quote.QuasiQuoter&lt;/code&gt;, which is defined thus:</source>
          <target state="translated">Кавычки - это значение типа &lt;code&gt;Language.Haskell.TH.Quote.QuasiQuoter&lt;/code&gt; , которое определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="a48ce4817f3e54a0532248a31d1f099d88b1351f" translate="yes" xml:space="preserve">
          <source>A range of bytes in a buffer represented by the pointer to the first byte of the range and the pointer to the first byte &lt;em&gt;after&lt;/em&gt; the range.</source>
          <target state="translated">Диапазон байтов в буфере, представленный указателем на первый байт диапазона и указателем на первый байт &lt;em&gt;после&lt;/em&gt; диапазона.</target>
        </trans-unit>
        <trans-unit id="b28c56da049e38013f1fcf4d02dcb6b1f0080a5c" translate="yes" xml:space="preserve">
          <source>A record GADT may have a restricted type for a selector function, which may lead to additional unification when solving &lt;code&gt;HasField&lt;/code&gt; constraints. For example,</source>
          <target state="translated">Запись GADT может иметь ограниченный тип для функции выбора, что может привести к дополнительной унификации при решении ограничений &lt;code&gt;HasField&lt;/code&gt; . Например,</target>
        </trans-unit>
        <trans-unit id="b338877827c7ed29adfee9e9d6b0b8e5a63641d8" translate="yes" xml:space="preserve">
          <source>A record selector was applied to a constructor without the appropriate field. This can only happen with a datatype with multiple constructors, where some fields are in one constructor but not another. The &lt;code&gt;String&lt;/code&gt; gives information about the source location of the record selector.</source>
          <target state="translated">Селектор записи был применен к конструктору без соответствующего поля. Это может произойти только с типом данных с несколькими конструкторами, где некоторые поля находятся в одном конструкторе, но не в другом. &lt;code&gt;String&lt;/code&gt; содержит информацию о местоположении источника селектора записи.</target>
        </trans-unit>
        <trans-unit id="c21fec8a784a0df6d796742b5beccbbdfb0d37ed" translate="yes" xml:space="preserve">
          <source>A record update was performed on a constructor without the appropriate field. This can only happen with a datatype with multiple constructors, where some fields are in one constructor but not another. The &lt;code&gt;String&lt;/code&gt; gives information about the source location of the record update.</source>
          <target state="translated">Обновление записи было выполнено для конструктора без соответствующего поля. Это может произойти только с типом данных с несколькими конструкторами, где некоторые поля находятся в одном конструкторе, но не в другом. &lt;code&gt;String&lt;/code&gt; дает информацию об исходном местоположении обновления записи.</target>
        </trans-unit>
        <trans-unit id="92fb5684ae95209348bfee7f9aea2ce376b9a4d4" translate="yes" xml:space="preserve">
          <source>A redundant constraint within the type signature itself:</source>
          <target state="translated">Резервное ограничение внутри самой подписи типа:</target>
        </trans-unit>
        <trans-unit id="54a410c09496ec54abde3e9710dcb3fcce5da06f" translate="yes" xml:space="preserve">
          <source>A reference to a remote value. These are allocated and freed explicitly.</source>
          <target state="translated">Ссылка на удаленное значение.Они выделяются и освобождаются явно.</target>
        </trans-unit>
        <trans-unit id="fb2a2acd6cd218a5be6c4d95fa1ad4daf16624a7" translate="yes" xml:space="preserve">
          <source>A reference to a value of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Ссылка на значение типа &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0361e89442d5407a746896c1f1424c0385608b9b" translate="yes" xml:space="preserve">
          <source>A rendering style. Allows us to specify constraints to choose among the many different rendering options.</source>
          <target state="translated">Стиль рендеринга.Позволяет указать ограничения для выбора из множества различных опций рендеринга.</target>
        </trans-unit>
        <trans-unit id="9a7715c19cf7faa5dc45883c88b4e480b883a9aa" translate="yes" xml:space="preserve">
          <source>A retainer is either the system stack, an unevaluated closure (thunk), or an explicitly mutable object.</source>
          <target state="translated">Фиксатором является либо системный стек,либо неоцененное закрытие (thunk),либо явно мутируемый объект.</target>
        </trans-unit>
        <trans-unit id="c17ab32a3bf231aeb0c4cd50ac9f91c26d98d0f8" translate="yes" xml:space="preserve">
          <source>A rewrite rule in a module &lt;code&gt;M&lt;/code&gt; is an &lt;em&gt;orphan rule&lt;/em&gt; orphan rule if none of the variables, type constructors, or classes that are free in the left hand side of the rule are declared in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">Правило перезаписи в модуле &lt;code&gt;M&lt;/code&gt; является &lt;em&gt;правило сиротого&lt;/em&gt; правила сиротой , если ни одна из переменных, конструкторов типов или классов, которые свободны в левой части правил не объявлено в &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7576507e849494c245f578b7b08c722c72b9e4b" translate="yes" xml:space="preserve">
          <source>A rich user interface for line input in command-line programs. Haskeline is Unicode-aware and runs both on POSIX-compatible systems and on Windows.</source>
          <target state="translated">Богатый пользовательский интерфейс для ввода строки в программы командной строки.Haskeline ориентирован на юникод и работает как на POSIX-совместимых системах,так и на Windows.</target>
        </trans-unit>
        <trans-unit id="5fe62b863adf6df34977b49f0095efaac4aba5e7" translate="yes" xml:space="preserve">
          <source>A right fold over the elements</source>
          <target state="translated">Правый склад над элементами</target>
        </trans-unit>
        <trans-unit id="468cdfbdf06effe43a3aa0fc4e881403e078094b" translate="yes" xml:space="preserve">
          <source>A right fold over the elements with no starting value</source>
          <target state="translated">Правую складку над элементами без стартового значения</target>
        </trans-unit>
        <trans-unit id="1bd8cdef3742749b47082f965a23008abf9bc15b" translate="yes" xml:space="preserve">
          <source>A rule does not need to be in the same module as (any of) the variables it mentions, though of course they need to be in scope.</source>
          <target state="translated">Правило не обязательно должно находиться в том же модуле,что и (любая из)переменных,которые оно упоминает,хотя,конечно,они должны быть в области действия.</target>
        </trans-unit>
        <trans-unit id="4dda8ffe8bacae7a3d13b78da8fc37161b54e971" translate="yes" xml:space="preserve">
          <source>A rule may optionally have a phase-control number (see &lt;a href=&quot;#phase-control&quot;&gt;Phase control&lt;/a&gt;), immediately after the name of the rule. Thus:</source>
          <target state="translated">Правило может дополнительно иметь номер контроля фазы (см. &lt;a href=&quot;#phase-control&quot;&gt;Контроль фазы&lt;/a&gt; ) сразу после имени правила. Таким образом:</target>
        </trans-unit>
        <trans-unit id="ba8873804ea20a68777a6a79acc2a5e0d1a22d48" translate="yes" xml:space="preserve">
          <source>A safe way to create and work with a mutable array before returning an immutable array for later perusal. This function avoids copying the array before returning it - it uses &lt;code&gt;unsafeFreeze&lt;/code&gt; internally, but this wrapper is a safe interface to that function.</source>
          <target state="translated">Безопасный способ создания изменяемого массива и работы с ним перед возвратом неизменяемого массива для дальнейшего изучения. Эта функция избегает копирования массива перед его возвратом - она ​​использует &lt;code&gt;unsafeFreeze&lt;/code&gt; внутри, но эта оболочка является безопасным интерфейсом для этой функции.</target>
        </trans-unit>
        <trans-unit id="8ed6207609d767c14b5aa06f9aa68c12587a18b1" translate="yes" xml:space="preserve">
          <source>A safe way to create and work with an unboxed mutable array before returning an immutable array for later perusal. This function avoids copying the array before returning it - it uses &lt;code&gt;unsafeFreeze&lt;/code&gt; internally, but this wrapper is a safe interface to that function.</source>
          <target state="translated">Безопасный способ создания распакованного изменяемого массива и работы с ним перед возвратом неизменяемого массива для дальнейшего изучения. Эта функция избегает копирования массива перед его возвратом - она ​​использует &lt;code&gt;unsafeFreeze&lt;/code&gt; внутри, но эта оболочка является безопасным интерфейсом для этой функции.</target>
        </trans-unit>
        <trans-unit id="b9df3dc079f00f9a8e0de830c01848206acb9ca5" translate="yes" xml:space="preserve">
          <source>A sample (consisting of a list of break-down classes, e.g. cost centres, and heap residency sizes), is to be encoded in the body of one or more events.</source>
          <target state="translated">Образец (состоящий из списка разбитых классов,например,центров стоимости и размеров кучи резиденций)должен быть закодирован в теле одного или нескольких событий.</target>
        </trans-unit>
        <trans-unit id="75c24f2265f3d8c4ccd393f15ae237ff3f6f2a33" translate="yes" xml:space="preserve">
          <source>A scoped type variable stands for a type &lt;em&gt;variable&lt;/em&gt;, and not for a &lt;em&gt;type&lt;/em&gt;. (This is a change from GHC&amp;rsquo;s earlier design.)</source>
          <target state="translated">Область видимости переменной типа обозначает тип &lt;em&gt;переменной&lt;/em&gt; , а не для &lt;em&gt;типа&lt;/em&gt; . (Это изменение от более раннего дизайна GHC.)</target>
        </trans-unit>
        <trans-unit id="f9e8504d9f7ca56788ad83a6712e3deabb56b1fb" translate="yes" xml:space="preserve">
          <source>A sequence of actions produces a value only if all the actions in the sequence do. If one exits, the rest of the sequence is skipped and the composite action exits.</source>
          <target state="translated">Последовательность действий дает значение только в том случае,если все действия в последовательности выполняются.При выходе одного из них остальная часть последовательности пропускается,а составное действие выходит.</target>
        </trans-unit>
        <trans-unit id="627ab33bc11dc284fde08d4bb2c60e4ca6633e05" translate="yes" xml:space="preserve">
          <source>A sequence of actions succeeds, producing a value, only if all the actions in the sequence are successful. If one fails with an error, the rest of the sequence is skipped and the composite action fails with that error.</source>
          <target state="translated">Последовательность действий является успешной,создавая значение,только если все действия в последовательности успешны.Если одно из действий завершилось неудачей с ошибкой,остальная часть последовательности пропускается,и составное действие с этой ошибкой завершается неудачей.</target>
        </trans-unit>
        <trans-unit id="2df1f1dd397310b516738a6b735261200af88e24" translate="yes" xml:space="preserve">
          <source>A sequence of actions terminates normally, producing a value, only if none of the actions in the sequence throws an exception. If one throws an exception, the rest of the sequence is skipped and the composite action exits with that exception.</source>
          <target state="translated">Последовательность действий завершается нормально,создавая значение,только если ни одно из действий в последовательности не бросает исключение.Если бросить исключение,остальная часть последовательности пропускается,и составное действие выходит с этим исключением.</target>
        </trans-unit>
        <trans-unit id="86877c5118e45e245e3a082f5d36380aaa868a97" translate="yes" xml:space="preserve">
          <source>A sequence of non-space characters, or a sequence of arbitrary characters surrounded by quotes &lt;code&gt;&quot;....&quot;&lt;/code&gt;.</source>
          <target state="translated">Последовательность непробельных символов или последовательность произвольных символов, заключенных в кавычки &lt;code&gt;&quot;....&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76595a701ee44ea1c9f930a9c60dd85fa6bdaa4c" translate="yes" xml:space="preserve">
          <source>A sequence of strings, separated by commas. The sequence may be empty.</source>
          <target state="translated">Последовательность строк,разделенных запятыми.Последовательность может быть пустой.</target>
        </trans-unit>
        <trans-unit id="94dd7b6a2c0e4fe592c072a99a09ce1205c850da" translate="yes" xml:space="preserve">
          <source>A sequential garbage collection has been requested by a capability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9195a974dd24c0ef39d75bed4d1efb9a1d3015e" translate="yes" xml:space="preserve">
          <source>A set of integers.</source>
          <target state="translated">Набор целых чисел.</target>
        </trans-unit>
        <trans-unit id="bb204bd8db13fe7816a94a82e9d47e0712050306" translate="yes" xml:space="preserve">
          <source>A set of signals reserved for use by the implementation. In GHC, this will normally include either &lt;code&gt;&lt;a href=&quot;system-posix-signals#v:sigVTALRM&quot;&gt;sigVTALRM&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-posix-signals#v:sigALRM&quot;&gt;sigALRM&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Набор сигналов, зарезервированных для использования реализацией. В GHC это обычно включает либо &lt;code&gt;&lt;a href=&quot;system-posix-signals#v:sigVTALRM&quot;&gt;sigVTALRM&lt;/a&gt;&lt;/code&gt; , либо &lt;code&gt;&lt;a href=&quot;system-posix-signals#v:sigALRM&quot;&gt;sigALRM&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a966b0c2cbc724a4e1636286c1f35ede7a08d8c" translate="yes" xml:space="preserve">
          <source>A set of values &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Набор значений &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a84ea57aa89435041641005d90f97cd8afe4994e" translate="yes" xml:space="preserve">
          <source>A setEnv implementation that allows blank environment variables. Mimics the &lt;code&gt;&lt;a href=&quot;system-posix#v:Env&quot;&gt;Env&lt;/a&gt;&lt;/code&gt; module from the &lt;code&gt;unix&lt;/code&gt; package, but with support for Windows too.</source>
          <target state="translated">Реализация setEnv, которая допускает пустые переменные среды. Имитирует модуль &lt;code&gt;&lt;a href=&quot;system-posix#v:Env&quot;&gt;Env&lt;/a&gt;&lt;/code&gt; из пакета &lt;code&gt;unix&lt;/code&gt; , но также с поддержкой Windows.</target>
        </trans-unit>
        <trans-unit id="f4ca239f09f9ab5cacd4dc55290c45509ce3c667" translate="yes" xml:space="preserve">
          <source>A shared mutable variable (&lt;em&gt;not&lt;/em&gt; the same as a &lt;code&gt;MutVar#&lt;/code&gt;!). (Note: in a non-concurrent implementation, &lt;code&gt;(MVar# a)&lt;/code&gt; can be represented by &lt;code&gt;(MutVar# (Maybe a))&lt;/code&gt;.)</source>
          <target state="translated">Общая изменяемая переменная ( &lt;em&gt;не&lt;/em&gt; то же самое, что &lt;code&gt;MutVar#&lt;/code&gt; !). (Примечание: в &lt;code&gt;(MVar# a)&lt;/code&gt; реализации (MVar # a) может быть представлено как &lt;code&gt;(MutVar# (Maybe a))&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="a82158df9a5688ce51d763088d1b6426e23f9a62" translate="yes" xml:space="preserve">
          <source>A shortcut for multiple definitions which use &lt;code&gt;#const&lt;/code&gt;. Each &lt;code&gt;value&lt;/code&gt; is a name of a C integer constant, e.g. enumeration value. The name will be translated to Haskell by making each letter following an underscore uppercase, making all the rest lowercase, and removing underscores. You can supply a different translation by writing &lt;code&gt;hs_name = c_value&lt;/code&gt; instead of a &lt;code&gt;value&lt;/code&gt;, in which case &lt;code&gt;c_value&lt;/code&gt; may be an arbitrary expression. The &lt;code&gt;hs_name&lt;/code&gt; will be defined as having the specified &lt;code&gt;type&lt;/code&gt;. Its definition is the specified &lt;code&gt;constructor&lt;/code&gt; (which in fact may be an expression or be empty) applied to the appropriate integer value. You can have multiple &lt;code&gt;#enum&lt;/code&gt; definitions with the same &lt;code&gt;type&lt;/code&gt;; this construct does not emit the type definition itself.</source>
          <target state="translated">Ярлык для нескольких определений, использующих &lt;code&gt;#const&lt;/code&gt; . Каждое &lt;code&gt;value&lt;/code&gt; - это имя целочисленной константы C, например значение перечисления. Имя будет переведено на Haskell, каждая буква после подчеркивания будет заглавной, все остальные будут строчными, а символы подчеркивания будут удалены. Вы можете предоставить другой перевод, написав &lt;code&gt;hs_name = c_value&lt;/code&gt; вместо &lt;code&gt;value&lt;/code&gt; , и в этом случае &lt;code&gt;c_value&lt;/code&gt; может быть произвольным выражением. &lt;code&gt;hs_name&lt;/code&gt; будет определен как имеющий заданный &lt;code&gt;type&lt;/code&gt; . Его определение - это указанный &lt;code&gt;constructor&lt;/code&gt; (который на самом деле может быть выражением или быть пустым), применяемый к соответствующему целочисленному значению. Вы можете иметь несколько &lt;code&gt;#enum&lt;/code&gt; определения одного &lt;code&gt;type&lt;/code&gt; ; эта конструкция не генерирует само определение типа.</target>
        </trans-unit>
        <trans-unit id="00e25301890375feab76786821b7d4508efb82ce" translate="yes" xml:space="preserve">
          <source>A signature file is denoted by an &lt;code&gt;hsig&lt;/code&gt; file; every required signature must have an &lt;code&gt;hsig&lt;/code&gt; file (even if it is an empty one), including required signatures inherited from dependencies. Signatures can be imported using an ordinary &lt;code&gt;import Sig&lt;/code&gt; declaration.</source>
          <target state="translated">Файл подписи обозначается файлом &lt;code&gt;hsig&lt;/code&gt; ; каждая необходимая подпись должна иметь файл &lt;code&gt;hsig&lt;/code&gt; (даже если он пустой), включая обязательные подписи, унаследованные от зависимостей. Подписи можно импортировать с помощью обычного объявления &lt;code&gt;import Sig&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92355b0e296eb8f9e53318fcbdb4d680dbc31d1d" translate="yes" xml:space="preserve">
          <source>A signed integral type that can be losslessly converted to and from &lt;code&gt;Ptr&lt;/code&gt;. This type is also compatible with the C99 type &lt;code&gt;intptr_t&lt;/code&gt;, and can be marshalled to and from that type safely.</source>
          <target state="translated">Целочисленный тип со &lt;code&gt;Ptr&lt;/code&gt; который можно без потерь преобразовать в Ptr . Этот тип также совместим с типом &lt;code&gt;intptr_t&lt;/code&gt; C99 и может быть безопасно ранжирован в этот тип и из него.</target>
        </trans-unit>
        <trans-unit id="948520b277e60dcee21361dd65adb915f2606d36" translate="yes" xml:space="preserve">
          <source>A similar transformation of array values may be achieved using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">Аналогичное преобразование значений массива может быть достигнуто с помощью &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; из экземпляра &lt;code&gt;&lt;a href=&quot;data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; класса &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99bde5053270918eb2f3d7c1e964f644e4ce138b" translate="yes" xml:space="preserve">
          <source>A similar transformation of array values may be achieved using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbbe5e3287fe101eaac49bce2bfcb028d8f2b308" translate="yes" xml:space="preserve">
          <source>A similar transformation of array values may be achieved using &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;ghc-arr#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">Аналогичное преобразование значений массива может быть достигнуто с помощью &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; из экземпляра &lt;code&gt;&lt;a href=&quot;ghc-arr#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; класса &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6c85786bd39c1497a36a8cbe06706b97c38a416" translate="yes" xml:space="preserve">
          <source>A simple choice for the type associated with flags is to define a type &lt;code&gt;Flag&lt;/code&gt; as an algebraic type representing the possible flags and their arguments:</source>
          <target state="translated">Простой выбор для типа, связанного с флагами, - определить тип &lt;code&gt;Flag&lt;/code&gt; как алгебраический тип, представляющий возможные флаги и их аргументы:</target>
        </trans-unit>
        <trans-unit id="385ee26bb3c563691e99d165abb3ca38a355c178" translate="yes" xml:space="preserve">
          <source>A simple day and time aggregate, where the day is of the specified parameter, and the time is a TimeOfDay. Conversion of this (as local civil time) to UTC depends on the time zone. Conversion of this (as local mean time) to UT1 depends on the longitude.</source>
          <target state="translated">Простой агрегат дня и времени,где день имеет заданный параметр,а время-TimeOfDay.Преобразование этого (как местного гражданского времени)в UTC зависит от часового пояса.Преобразование этого (как местного среднего времени)в UT1 зависит от долготы.</target>
        </trans-unit>
        <trans-unit id="5071edc607af851a249c97dfb4d0c57e03432a4d" translate="yes" xml:space="preserve">
          <source>A simple example of the new notation is the expression</source>
          <target state="translated">Простой пример новой нотации-выражение</target>
        </trans-unit>
        <trans-unit id="32cefd4bea4e7110a3dca7239bc47887ca83ce67" translate="yes" xml:space="preserve">
          <source>A simple pairing heap.</source>
          <target state="translated">Простая парная куча.</target>
        </trans-unit>
        <trans-unit id="8ad0b83378258a314fc0adf90a8e10c9bc3f1588" translate="yes" xml:space="preserve">
          <source>A simple use of unfoldr:</source>
          <target state="translated">Простое использование разворачивания:</target>
        </trans-unit>
        <trans-unit id="a1f654f7060b7d2d650700b6c757eab119833574" translate="yes" xml:space="preserve">
          <source>A simpler version of this function is:</source>
          <target state="translated">Более простая версия этой функции:</target>
        </trans-unit>
        <trans-unit id="109ec8484c225e4b238b8dbafe102ddb90cbe663" translate="yes" xml:space="preserve">
          <source>A single &lt;code&gt;deriving&lt;/code&gt; clause at the end of a datatype.</source>
          <target state="translated">Один &lt;code&gt;deriving&lt;/code&gt; положение в конце типом данные.</target>
        </trans-unit>
        <trans-unit id="07552ccc8f83d8da8c2ff1373fe5871fc375aea0" translate="yes" xml:space="preserve">
          <source>A single Char fragment</source>
          <target state="translated">Один фрагмент Шар</target>
        </trans-unit>
        <trans-unit id="c8a470d3f21b5f8bd88b72ca5e212009e6a9ba92" translate="yes" xml:space="preserve">
          <source>A single data constructor.</source>
          <target state="translated">Один конструктор данных.</target>
        </trans-unit>
        <trans-unit id="8b90ffe9d4585beccabc5b42a63afc7e90a28d58" translate="yes" xml:space="preserve">
          <source>A single fixed-width event emitted during program start-up describing the samples that follow.</source>
          <target state="translated">При запуске программы генерируется одно событие фиксированной ширины,описывающее следующие образцы.</target>
        </trans-unit>
        <trans-unit id="dce34a123f3c9357183ae1491a545fbaf2ea2561" translate="yes" xml:space="preserve">
          <source>A single location in the source code.</source>
          <target state="translated">Одно место в исходном коде.</target>
        </trans-unit>
        <trans-unit id="50f411ba135dec27d6a3801b72dc1838706dca5a" translate="yes" xml:space="preserve">
          <source>A single vertex that is not in any cycle.</source>
          <target state="translated">Одна вершина,которая не находится ни в одном цикле.</target>
        </trans-unit>
        <trans-unit id="97bd9aab1d447685b69723475ad0a956cc38e08e" translate="yes" xml:space="preserve">
          <source>A sink of event-log data.</source>
          <target state="translated">Раковина данных журнала событий.</target>
        </trans-unit>
        <trans-unit id="80976804b592e9e2e94c0bbcedb3e158f3a504b2" translate="yes" xml:space="preserve">
          <source>A size in UTF-16 code units.</source>
          <target state="translated">Размер в кодовых единицах UTF-16.</target>
        </trans-unit>
        <trans-unit id="909e2a440c7053acbcd40d2af23d2760c9d12442" translate="yes" xml:space="preserve">
          <source>A skip channel is a pair of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s. The first &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; contains the current value, and a list of semaphores that need to be notified when it changes. The second &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is a semaphore for this particular reader: it is full if there is a value in the channel that this reader has not read yet, and empty otherwise.</source>
          <target state="translated">Пропускаемый канал - это пара &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; s. Первый &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; содержит текущее значение и список семафоров, которые необходимо уведомлять при его изменении. Второй &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; является семафором для этого конкретного считывателя: он заполнен, если в канале есть значение, которое этот считыватель еще не прочитал, и пусто в противном случае.</target>
        </trans-unit>
        <trans-unit id="75b2421aa3377ed4749c4916a0cb0dcfc04c0013" translate="yes" xml:space="preserve">
          <source>A slight variation on &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; that allows a value to be returned (&lt;code&gt;b&lt;/code&gt;) in addition to the modified value of the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Небольшая вариация в &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; , позволяющая возвращать значение ( &lt;code&gt;b&lt;/code&gt; ) в дополнение к измененному значению &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f69c10ed60508f59cb5a529f1b359642cbe6b858" translate="yes" xml:space="preserve">
          <source>A slightly faster version of &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; that may not be safe to use with multiple threads. The unsafety arises when used like this:</source>
          <target state="translated">Немного более быстрая версия &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; , которую небезопасно использовать с несколькими потоками. Небезопасность возникает при таком использовании:</target>
        </trans-unit>
        <trans-unit id="1a46cd68f2f2846ae726246b12281b2435629226" translate="yes" xml:space="preserve">
          <source>A small example:</source>
          <target state="translated">Небольшой пример:</target>
        </trans-unit>
        <trans-unit id="f3fa3447a8afd4949b9c12f9f8e9147cd390aae9" translate="yes" xml:space="preserve">
          <source>A small word of warning: &lt;a href=&quot;#ghc-flag--cpp&quot;&gt;&lt;code&gt;-cpp&lt;/code&gt;&lt;/a&gt; is not friendly to &amp;ldquo;string gaps&amp;rdquo;. In other words, strings such as the following:</source>
          <target state="translated">Небольшое предупреждение: &lt;a href=&quot;#ghc-flag--cpp&quot;&gt; &lt;code&gt;-cpp&lt;/code&gt; &lt;/a&gt; не подходит для &amp;laquo;пробелов в строках &amp;raquo;. Другими словами, такие строки, как:</target>
        </trans-unit>
        <trans-unit id="b896df9db0191f80e6db640a0983ae75b9330707" translate="yes" xml:space="preserve">
          <source>A space character</source>
          <target state="translated">знак пробела</target>
        </trans-unit>
        <trans-unit id="2cf7bf5a17da5fc043fc8f14a663aecfa5439dbc" translate="yes" xml:space="preserve">
          <source>A space efficient, packed, unboxed Unicode text type.</source>
          <target state="translated">Компактный,упакованный,неупакованный тип текста Юникод.</target>
        </trans-unit>
        <trans-unit id="b320aab997efd2d7ca1e00ac225c124b5d920ec5" translate="yes" xml:space="preserve">
          <source>A space-efficient representation of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; vector, supporting many efficient operations.</source>
          <target state="translated">Пространство-эффективное представление &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; вектора, поддерживая множество эффективных операций.</target>
        </trans-unit>
        <trans-unit id="edd5ed41a7ad61d8ccb7e1f320dd68310fe46295" translate="yes" xml:space="preserve">
          <source>A space-efficient representation of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; vector, supporting many efficient operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34c30bb293046f1353d1b4c1fb7e4c15767c64f" translate="yes" xml:space="preserve">
          <source>A spanning forest of the graph, obtained from a depth-first search of the graph starting from each vertex in an unspecified order.</source>
          <target state="translated">Охватывающий лес графика,полученный в результате первого глубинного поиска графика,начинающегося с каждой вершины в неуказанном порядке.</target>
        </trans-unit>
        <trans-unit id="4794ea6b46c0b3e368866c3f6657148757943020" translate="yes" xml:space="preserve">
          <source>A spanning forest of the part of the graph reachable from the listed vertices, obtained from a depth-first search of the graph starting at each of the listed vertices in order.</source>
          <target state="translated">Охватывающий лес части графика,достижимой из перечисленных вершин,полученный в результате углубленного поиска графика,начинающегося в каждой из перечисленных вершин по порядку.</target>
        </trans-unit>
        <trans-unit id="17409cdf1a726a6b210a04d4446854b3d6bf4233" translate="yes" xml:space="preserve">
          <source>A spark has been GC&amp;rsquo;d before being evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7a9f3b3b4de7ca05232bf75a6a63a5d4979fe6" translate="yes" xml:space="preserve">
          <source>A spark has been added to the spark pool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ef42be18896ca33cf39edd26afbfce8fc5c5ae" translate="yes" xml:space="preserve">
          <source>A spark has been stolen from another capability for evaluation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="000576d9dd7d866ebbbaf02ec2da581917b4c07a" translate="yes" xml:space="preserve">
          <source>A special case of &lt;code&gt;&lt;a href=&quot;ghc-err#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;. It is expected that compilers will recognize this and insert error messages which are more appropriate to the context in which &lt;code&gt;&lt;a href=&quot;ghc-err#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; appears.</source>
          <target state="translated">Особый случай &lt;code&gt;&lt;a href=&quot;ghc-err#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; . Ожидается, что компиляторы распознают это и вставят сообщения об ошибках, которые больше подходят для контекста, в котором появляется &lt;code&gt;&lt;a href=&quot;ghc-err#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73c8066b78af5a513799e5e6e43841a928951845" translate="yes" xml:space="preserve">
          <source>A special case of &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;. It is expected that compilers will recognize this and insert error messages which are more appropriate to the context in which &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; appears.</source>
          <target state="translated">Особый случай &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; . Ожидается, что компиляторы распознают это и вставят сообщения об ошибках, которые больше подходят для контекста, в котором появляется &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b61fe333d2ebb606e68ef9534fb8ee51a3dcbe6f" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; with just a computation to run afterward.</source>
          <target state="translated">Специализированный вариант &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; с последующим запуском вычислений.</target>
        </trans-unit>
        <trans-unit id="d381bfcecd222a40938da33628701d9caa7e0fc9" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, using precedence context zero, and returning an ordinary &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Специализированный вариант &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; , использующий нулевой контекст приоритета и возвращающий обычную &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3551127e07d1074127cf665da3dc3de8f74d78ac" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, using precedence context zero, and returning an ordinary &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Специализированный вариант &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; , использующий нулевой контекст приоритета и возвращающий обычную &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f3343104c8933573bbaff2361f546628d45e8d8" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; with just a computation to run afterward.</source>
          <target state="translated">Специализированный вариант &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; с последующим запуском вычислений.</target>
        </trans-unit>
        <trans-unit id="addf8bf904a9b53d42ba0004dc6e0c96e5f166b4" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, using precedence context zero, and returning an ordinary &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Специализированный вариант &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; , использующий нулевой контекст приоритета и возвращающий обычную &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a0c5e6176b1b7f34e452cb42488bc078090478d" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeak&quot;&gt;mkWeak&lt;/a&gt;&lt;/code&gt; where the value is actually a pair of the key and value passed to &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeakPair&quot;&gt;mkWeakPair&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Специализированная версия &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeak&quot;&gt;mkWeak&lt;/a&gt;&lt;/code&gt; ,в которой значение фактически представляет собой пару ключа и значения, переданную в &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeakPair&quot;&gt;mkWeakPair&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ed256b1475f3db11a1e053e7393f2e62ac0741a5" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeak&quot;&gt;mkWeak&lt;/a&gt;&lt;/code&gt;, where the key and the value are the same object:</source>
          <target state="translated">Специализированная версия &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeak&quot;&gt;mkWeak&lt;/a&gt;&lt;/code&gt; , где ключ и значение являются одним и тем же объектом:</target>
        </trans-unit>
        <trans-unit id="88cbeb4d1e4332278f7efaec95990a7cd06ab5a6" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeakPtr&quot;&gt;mkWeakPtr&lt;/a&gt;&lt;/code&gt;, where the &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; object returned is simply thrown away (however the finalizer will be remembered by the garbage collector, and will still be run when the key becomes unreachable).</source>
          <target state="translated">Специализированная версия &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeakPtr&quot;&gt;mkWeakPtr&lt;/a&gt;&lt;/code&gt; , в которой возвращенный объект &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; просто выбрасывается (однако финализатор запоминается сборщиком мусора и все равно будет запущен, когда ключ станет недоступным).</target>
        </trans-unit>
        <trans-unit id="c000f76b0d515b8c303304c303dc38592d07556a" translate="yes" xml:space="preserve">
          <source>A splice can occur in place of</source>
          <target state="translated">Соединение может произойти вместо</target>
        </trans-unit>
        <trans-unit id="cd4cb3a4aa37b46f04784c0f6f0060998bc7f64a" translate="yes" xml:space="preserve">
          <source>A splice is written &lt;code&gt;$x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is an identifier, or &lt;code&gt;$(...)&lt;/code&gt;, where the &amp;ldquo;&amp;hellip;&amp;rdquo; is an arbitrary expression. There must be no space between the &amp;ldquo;$&amp;rdquo; and the identifier or parenthesis. This use of &amp;ldquo;$&amp;rdquo; overrides its meaning as an infix operator, just as &amp;ldquo;M.x&amp;rdquo; overrides the meaning of &amp;ldquo;.&amp;rdquo; as an infix operator. If you want the infix operator, put spaces around it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc7d08e30e7130abc877e7e166eb7f0bb2f0e91" translate="yes" xml:space="preserve">
          <source>A splice is written &lt;code&gt;$x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is an identifier, or &lt;code&gt;$(...)&lt;/code&gt;, where the &amp;rdquo;...&amp;rdquo; is an arbitrary expression. There must be no space between the &amp;ldquo;$&amp;rdquo; and the identifier or parenthesis. This use of &amp;ldquo;$&amp;rdquo; overrides its meaning as an infix operator, just as &amp;ldquo;M.x&amp;rdquo; overrides the meaning of &amp;rdquo;.&amp;rdquo; as an infix operator. If you want the infix operator, put spaces around it.</source>
          <target state="translated">Соединение записывается как &lt;code&gt;$x&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; - идентификатор, или &lt;code&gt;$(...)&lt;/code&gt; , где &amp;laquo;...&amp;raquo; - произвольное выражение. Между символом &amp;laquo;$&amp;raquo; и идентификатором или круглой скобкой не должно быть пробелов. Такое использование &amp;laquo;$&amp;raquo; отменяет его значение как инфиксного оператора, так же как &amp;laquo;Mx&amp;raquo; отменяет значение &amp;laquo;.&amp;raquo; как инфиксный оператор. Если вам нужен инфиксный оператор, заключите его в пробелы.</target>
        </trans-unit>
        <trans-unit id="029020ae6b32756dd16466eb423a1a26ab4457d6" translate="yes" xml:space="preserve">
          <source>A state monad parameterized by the type &lt;code&gt;s&lt;/code&gt; of the state to carry.</source>
          <target state="translated">Состояние Монады параметризовано типа &lt;code&gt;s&lt;/code&gt; государством носить с собой.</target>
        </trans-unit>
        <trans-unit id="dc96818c8486fd2f0989d60f3799e6dcb782b7f0" translate="yes" xml:space="preserve">
          <source>A state transformer monad parameterized by:</source>
          <target state="translated">Монада государственного трансформатора,параметризованная:</target>
        </trans-unit>
        <trans-unit id="584d223e5ba9554539274f317131b078dc9f657c" translate="yes" xml:space="preserve">
          <source>A static form determines a value of type &lt;code&gt;StaticPtr t&lt;/code&gt;, but just like &lt;code&gt;OverloadedLists&lt;/code&gt; and &lt;code&gt;OverloadedStrings&lt;/code&gt;, this literal expression is overloaded to allow lifting a &lt;code&gt;StaticPtr&lt;/code&gt; into another type implicitly, via the &lt;code&gt;IsStatic&lt;/code&gt; class:</source>
          <target state="translated">Статическая форма определяет значение типа &lt;code&gt;StaticPtr t&lt;/code&gt; , но так же, как &lt;code&gt;OverloadedLists&lt;/code&gt; и &lt;code&gt;OverloadedStrings&lt;/code&gt; , это литеральное выражение перегружено, чтобы позволить &lt;code&gt;StaticPtr&lt;/code&gt; преобразовать StaticPtr в другой тип через класс &lt;code&gt;IsStatic&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="29153c897e531a67acff58cc6b01500af3000f33" translate="yes" xml:space="preserve">
          <source>A storable array is an IO-mutable array which stores its contents in a contiguous memory block living in the C heap. Elements are stored according to the class &lt;code&gt;Storable&lt;/code&gt;. You can obtain the pointer to the array contents to manipulate elements from languages like C.</source>
          <target state="translated">Сохраняемый массив - это изменяемый ввод-вывод массив, который хранит свое содержимое в непрерывном блоке памяти, находящемся в куче C. Элементы хранятся в соответствии с классом &lt;code&gt;Storable&lt;/code&gt; . Вы можете получить указатель на содержимое массива для управления элементами из таких языков, как C.</target>
        </trans-unit>
        <trans-unit id="4f5037287f3893bff45330861345a86eebed76c2" translate="yes" xml:space="preserve">
          <source>A stream of chunks that are constructed in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">Поток фрагментов, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; монаде ввода-вывода .</target>
        </trans-unit>
        <trans-unit id="43919f0b621bd7f60ea00562492dbc3adfa8a6aa" translate="yes" xml:space="preserve">
          <source>A stream of chunks that are constructed in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b113394401941b6890516fb8e3af8a462d1fd40" translate="yes" xml:space="preserve">
          <source>A stream oriented decoding result.</source>
          <target state="translated">Результат декодирования,ориентированный на поток.</target>
        </trans-unit>
        <trans-unit id="d911f61b4fa0d9284a8e1a6f69a0f61b1e73b5e6" translate="yes" xml:space="preserve">
          <source>A strict left fold over the elements</source>
          <target state="translated">Строгая левая складка над элементами</target>
        </trans-unit>
        <trans-unit id="98cd4454f56f48afeffc70d90f58b5920ca58301" translate="yes" xml:space="preserve">
          <source>A strict pair</source>
          <target state="translated">Строгая пара</target>
        </trans-unit>
        <trans-unit id="6eccc911da51c833236284b3d32b3123513710ad" translate="yes" xml:space="preserve">
          <source>A strict pattern match in a bind statement prevents &lt;code&gt;ApplicativeDo&lt;/code&gt; from transforming that statement to use &lt;code&gt;Applicative&lt;/code&gt;. This is because the transformation would change the semantics by making the expression lazier.</source>
          <target state="translated">Строгое соответствие шаблону в операторе связывания не позволяет &lt;code&gt;ApplicativeDo&lt;/code&gt; преобразовать этот оператор для использования &lt;code&gt;Applicative&lt;/code&gt; . Это связано с тем, что преобразование изменит семантику, сделав выражение более ленивым.</target>
        </trans-unit>
        <trans-unit id="0814095da0f374f363b2744acbf7641a2610efcb" translate="yes" xml:space="preserve">
          <source>A strict right fold over the elements</source>
          <target state="translated">Строгий правый склад над элементами</target>
        </trans-unit>
        <trans-unit id="0ec086694cd0bcf9cc7eaaf131dce1a8c3f470d3" translate="yes" xml:space="preserve">
          <source>A strict variant of foldr1</source>
          <target state="translated">Строгий вариант сгиба1</target>
        </trans-unit>
        <trans-unit id="37c2878fde673453465a3e32200c82b9e97c2b4d" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Строгий вариант &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00787a530c1e072ddb6f8e17b643611bd5348b98" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Строгий вариант &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00a8b3473a1ebcbcb0938b14d80dd5227345445f" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Строгий вариант &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5320390dc6f10cc24227a72c79ba582ebcc655a1" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Строгий вариант &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="493154631c22520a575e67380475a32d6bd2b085" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Строгий вариант &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb8a26929f2fded3b180d5708141aba0e7729a4d" translate="yes" xml:space="preserve">
          <source>A strict version of foldl.</source>
          <target state="translated">Строгая версия складки.</target>
        </trans-unit>
        <trans-unit id="38c487e511f9d1d69315932a619005a1ef13ecae" translate="yes" xml:space="preserve">
          <source>A strict version of foldl1.</source>
          <target state="translated">Строгая версия фолделя1.</target>
        </trans-unit>
        <trans-unit id="3a7a0698bbaa3cecd2768e6bf682a107a5760347" translate="yes" xml:space="preserve">
          <source>A string &lt;code&gt;x&lt;/code&gt; is a caseless match for a string &lt;code&gt;y&lt;/code&gt; if and only if:</source>
          <target state="translated">Строка &lt;code&gt;x&lt;/code&gt; является совпадением без регистра для строки &lt;code&gt;y&lt;/code&gt; тогда и только тогда, когда:</target>
        </trans-unit>
        <trans-unit id="0a89823ddb2e0acf1e32d6f1968848a1d41921ad" translate="yes" xml:space="preserve">
          <source>A string can be thrown as an error.</source>
          <target state="translated">Строка может быть брошена как ошибка.</target>
        </trans-unit>
        <trans-unit id="a6ae9c82c7d68fe5d1dffcf904a8de12b9166247" translate="yes" xml:space="preserve">
          <source>A string describing the source span enclosing the cost-centre.</source>
          <target state="translated">Строка,описывающая исходный диапазон,окружающий цену.</target>
        </trans-unit>
        <trans-unit id="1236c4b5dbb424adbd898df93abf13e38ab1cf45" translate="yes" xml:space="preserve">
          <source>A string to pass on standard input to the forked process.</source>
          <target state="translated">Строка для передачи стандартного входного сигнала в вилочный процесс.</target>
        </trans-unit>
        <trans-unit id="624066030a645e943a5b155270eb593c7b3b17d0" translate="yes" xml:space="preserve">
          <source>A string with explicit length information in bytes instead of a terminating NUL (allowing NUL characters in the middle of the string).</source>
          <target state="translated">Строка с явной информацией о длине в байтах вместо завершающего NUL символа (допускающего NUL символы в середине строки).</target>
        </trans-unit>
        <trans-unit id="2356ccf00398e74e586e317a2fe01305d7bf8c72" translate="yes" xml:space="preserve">
          <source>A superclass context for a class &lt;code&gt;C&lt;/code&gt; is allowed if, after expanding type synonyms to their right-hand-sides, and uses of classes (other than &lt;code&gt;C&lt;/code&gt;) to their superclasses, &lt;code&gt;C&lt;/code&gt; does not occur syntactically in the context.</source>
          <target state="translated">Контекст суперкласса для класса &lt;code&gt;C&lt;/code&gt; разрешен, если после расширения синонимов типов до их правых частей и использования классов (кроме &lt;code&gt;C&lt;/code&gt; ) в их суперклассах &lt;code&gt;C&lt;/code&gt; не встречается синтаксически в контексте.</target>
        </trans-unit>
        <trans-unit id="a8df258a3806dcb111bd7b1772adfed8e5b1b40a" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;, but as a function instead of an operator.</source>
          <target state="translated">Синоним для &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; , Но как функция вместо оператора.</target>
        </trans-unit>
        <trans-unit id="b99600f4f94d4a88ef68809095d330e12de5939a" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;code&gt;hPut&lt;/code&gt;, for compatibility</source>
          <target state="translated">Синоним &lt;code&gt;hPut&lt;/code&gt; для совместимости</target>
        </trans-unit>
        <trans-unit id="f7bdd4682beedebc0801ab80535b56959469b2ec" translate="yes" xml:space="preserve">
          <source>A system-dependent mode. This is also the default mode. On Unix ELF systems this embeds &lt;code id=&quot;index-1&quot;&gt;RPATH&lt;/code&gt;/&lt;code id=&quot;index-2&quot;&gt;RUNPATH&lt;/code&gt; entries into the shared library or executable. In particular it uses absolute paths to where the shared libraries for the rts and each package can be found. This means the program can immediately be run and it will be able to find the libraries it needs. However it may not be suitable for deployment if the libraries are installed in a different location on another machine.</source>
          <target state="translated">Системно-зависимый режим. Это также режим по умолчанию. В системах Unix ELF это встраивает записи &lt;code id=&quot;index-1&quot;&gt;RPATH&lt;/code&gt; / &lt;code id=&quot;index-2&quot;&gt;RUNPATH&lt;/code&gt; в общую библиотеку или исполняемый файл. В частности, он использует абсолютные пути к тому, где можно найти общие библиотеки для rts и каждого пакета. Это означает, что программу можно сразу запустить, и она сможет найти нужные библиотеки. Однако он может не подходить для развертывания, если библиотеки установлены в другом месте на другом компьютере.</target>
        </trans-unit>
        <trans-unit id="e155fb42dd454dac03073c4506c36df94ce050b3" translate="yes" xml:space="preserve">
          <source>A table of the count of edges from each node.</source>
          <target state="translated">Таблица подсчета рёбер от каждого узла.</target>
        </trans-unit>
        <trans-unit id="e0214aac47583666947c6b02d5dbd5d0f74c69cb" translate="yes" xml:space="preserve">
          <source>A table of the count of edges into each node.</source>
          <target state="translated">Таблица подсчета рёбер в каждом узле.</target>
        </trans-unit>
        <trans-unit id="9e56547706c1d22e7563bc02015e6d5ea9059fce" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тактика работы с ключами, присутствующими на обеих картах в &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5b40ab4ad40ca71821f774d179180ff9dbb3299" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тактика работы с ключами, присутствующими на обеих картах при &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68563c20275c3937fe80971256761864f36ba257" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тактика работы с ключами, присутствующими на обеих картах в &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d861ca0e3d900bc21406b6b1807bc2b2cf18dc29" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тактика работы с ключами, присутствующими на обеих картах при &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ae51b27a95cdff285456cfd64fc7198ed349ffd" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тактика работы с ключами, присутствующими на обеих картах в &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f49a606d06085ba26fc41ac70ef7f11a81b40cb" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тактика работы с ключами, присутствующими на обеих картах при &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f35d2589fef4b7d60b15566c52bfd61bb4b033fd" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тактика работы с ключами, присутствующими на обеих картах в &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35605a33cfca77541ce0f7a28d4adaaa7f211e60" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тактика работы с ключами, присутствующими на обеих картах при &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22ba35b272e3222b9000490c23cd7a38c265aa2c" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тактика работы с ключами, присутствующими на одной карте, но не с другой в &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="724f196ee83cb8f7d04ef2bfd02c2a5fc6e8942c" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тактика работы с ключами, присутствующими на одной карте, но не с другой при &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68f6f41d93467c8eca9791eed5e9e6b94541a4bf" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тактика работы с ключами, присутствующими на одной карте, но не с другой в &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3768165dc6a607a11a4e4e49c5b342c117fa0f2f" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тактика работы с ключами, присутствующими на одной карте, но не с другой при &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c0f20d68941a262026f0633a3098ddef91196da" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тактика работы с ключами, присутствующими на одной карте, но не с другой в &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e901e7cd9f4ef00918e6cc4628a80d9109d39ab6" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тактика работы с ключами, присутствующими на одной карте, но не с другой при &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d93c5772a7eda6b6b5cb9d8ee695cda722b263bd" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тактика работы с ключами, присутствующими на одной карте, но не с другой в &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e438d5b20c4d0ae49dae9e96e6eb2bd92c80240d" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тактика работы с ключами, присутствующими на одной карте, но не с другой при &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c03aaf5092b4ace221cdda40d0db350523640c20" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt; SimpleWhenMatched k x y z &lt;/code&gt; is an abstract representation of a function of type &lt;code&gt; k -&amp;gt; x -&amp;gt; y -&amp;gt; Maybe z &lt;/code&gt;.</source>
          <target state="translated">Тактика типа &lt;code&gt; SimpleWhenMatched k x y z &lt;/code&gt; является абстрактным представлением функции типа &lt;code&gt; k -&amp;gt; x -&amp;gt; y -&amp;gt; Maybe z &lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a13beca0501a32224295f634b47d23e06f1ddb66" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt; SimpleWhenMissing k x z &lt;/code&gt; is an abstract representation of a function of type &lt;code&gt; k -&amp;gt; x -&amp;gt; Maybe z &lt;/code&gt;.</source>
          <target state="translated">Тактика типа &lt;code&gt; SimpleWhenMissing k x z &lt;/code&gt; - это абстрактное представление функции типа &lt;code&gt; k -&amp;gt; x -&amp;gt; Maybe z &lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ba8a10e8973c7adb58835a435c234b5058a0a41" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt; WhenMatched f k x y z &lt;/code&gt; is an abstract representation of a function of type &lt;code&gt; k -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z) &lt;/code&gt;.</source>
          <target state="translated">Тактика типа &lt;code&gt; WhenMatched f k x y z &lt;/code&gt; - это абстрактное представление функции типа &lt;code&gt; k -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z) &lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2a9c18a71365b1b648cf16681fd8c36a0f1c2b1" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt; WhenMissing f k x z &lt;/code&gt; is an abstract representation of a function of type &lt;code&gt; k -&amp;gt; x -&amp;gt; f (Maybe z) &lt;/code&gt;.</source>
          <target state="translated">Тактика типа &lt;code&gt; WhenMissing f k x z &lt;/code&gt; является абстрактным представлением функции типа &lt;code&gt; k -&amp;gt; x -&amp;gt; f (Maybe z) &lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa71c38b94fc6a846cbe5d938f6e3e23141ac8bc" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt;SimpleWhenMatched x y z&lt;/code&gt; is an abstract representation of a function of type &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; Maybe z&lt;/code&gt;.</source>
          <target state="translated">Тактика типа &lt;code&gt;SimpleWhenMatched x y z&lt;/code&gt; является абстрактным представлением функции типа &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; Maybe z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e05a0a550e141ac884df50db0a9d4c7b208813b" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt;SimpleWhenMissing x z&lt;/code&gt; is an abstract representation of a function of type &lt;code&gt;Key -&amp;gt; x -&amp;gt; Maybe z&lt;/code&gt;.</source>
          <target state="translated">Тактика типа &lt;code&gt;SimpleWhenMissing x z&lt;/code&gt; является абстрактным представлением функции типа &lt;code&gt;Key -&amp;gt; x -&amp;gt; Maybe z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="788c7aaeca2fa9237bef6f30f44eda24345655ff" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt;WhenMatched f x y z&lt;/code&gt; is an abstract representation of a function of type &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt;.</source>
          <target state="translated">Тактика типа &lt;code&gt;WhenMatched f x y z&lt;/code&gt; - это абстрактное представление функции типа &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d8ff0b141b2eb58a8bb144bfb707f725b7e036c" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt;WhenMissing f k x z&lt;/code&gt; is an abstract representation of a function of type &lt;code&gt;Key -&amp;gt; x -&amp;gt; f (Maybe z)&lt;/code&gt;.</source>
          <target state="translated">Тактика типа &lt;code&gt;WhenMissing f k x z&lt;/code&gt; является абстрактным представлением функции типа &lt;code&gt;Key -&amp;gt; x -&amp;gt; f (Maybe z)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac94aa09dce6e03f7dc40cf67060871ccd2030ef" translate="yes" xml:space="preserve">
          <source>A text format for a type</source>
          <target state="translated">Текстовый формат для типа</target>
        </trans-unit>
        <trans-unit id="5d64a70b084ed3d99633afca034baca94024378e" translate="yes" xml:space="preserve">
          <source>A text-mode &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; has an associated &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; that specifies how to transate newline characters. The &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; specifies the input and output translation separately, so that for instance you can translate &lt;code&gt;'\r\n'&lt;/code&gt; to &lt;code&gt;'\n'&lt;/code&gt; on input, but leave newlines as &lt;code&gt;'\n'&lt;/code&gt; on output.</source>
          <target state="translated">Текстовый режим &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; имеет ассоциированное &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; , что определяет , как transate символы новой строки. &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; определяет входной и выходной перевод отдельно, так что, например , вы можете перевести &lt;code&gt;'\r\n'&lt;/code&gt; к &lt;code&gt;'\n'&lt;/code&gt; на входе, но оставить как символ новой строки &lt;code&gt;'\n'&lt;/code&gt; на выходе.</target>
        </trans-unit>
        <trans-unit id="e920ef23a8f0e5c9a461f6e5c3a3ecaedd1aa8f0" translate="yes" xml:space="preserve">
          <source>A text-mode &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; has an associated &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt;, which is used to decode bytes into Unicode characters when reading, and encode Unicode characters into bytes when writing.</source>
          <target state="translated">Текстовый режим &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; имеет связанный с ним &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; , который используется для декодирования байтов в символы Unicode при чтении, и кодировать символы Unicode в байты при записи.</target>
        </trans-unit>
        <trans-unit id="afd27d79af07b06b6dd2c8c51dd15b84360a87c3" translate="yes" xml:space="preserve">
          <source>A thread has been created to perform spark evaluation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513f9205785871fd0e6a34a5a8b00e27eaabc144" translate="yes" xml:space="preserve">
          <source>A time and space-efficient implementation of Unicode text using lists of packed arrays.</source>
          <target state="translated">Эффективное с точки зрения затрат времени и пространства внедрение текста Юникода с использованием списков упакованных массивов.</target>
        </trans-unit>
        <trans-unit id="871d33c09316ac87a1774045ce6be43e65d6fbbd" translate="yes" xml:space="preserve">
          <source>A time and space-efficient implementation of Unicode text. Suitable for performance critical use, both in terms of large data quantities and high speed.</source>
          <target state="translated">Эффективное с точки зрения затрат времени и пространства внедрение текста Юникода.Подходит для критически важного использования с точки зрения производительности,как с точки зрения больших объемов данных,так и с точки зрения высокой скорости.</target>
        </trans-unit>
        <trans-unit id="cb913ed9248b4b73bbb05825979d544eb2127ebb" translate="yes" xml:space="preserve">
          <source>A time and space-efficient implementation of lazy byte vectors using lists of packed &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; arrays, suitable for high performance use, both in terms of large data quantities, or high speed requirements. Lazy ByteStrings are encoded as lazy lists of strict chunks of bytes.</source>
          <target state="translated">Эффективная по времени и пространству реализация ленивых байтовых векторов с использованием списков упакованных массивов &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; , подходящая для высокопроизводительного использования как с точки зрения больших объемов данных, так и требований к высокой скорости. Ленивые байтовые строки кодируются как отложенные списки строгих блоков байтов.</target>
        </trans-unit>
        <trans-unit id="87548884e6950ce7611c58d0e6aa6d111ae018da" translate="yes" xml:space="preserve">
          <source>A time and space-efficient implementation of lazy byte vectors using lists of packed &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; arrays, suitable for high performance use, both in terms of large data quantities, or high speed requirements. Lazy ByteStrings are encoded as lazy lists of strict chunks of bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51040e6bbff0d1db2681967125dbcf0660a785a" translate="yes" xml:space="preserve">
          <source>A time- and space-efficient implementation of byte vectors using packed Word8 arrays, suitable for high performance use, both in terms of large data quantities and high speed requirements. Byte vectors are encoded as strict &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; arrays of bytes, held in a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, and can be passed between C and Haskell with little effort.</source>
          <target state="translated">Эффективная по времени и пространству реализация байтовых векторов с использованием упакованных массивов Word8, подходящая для высокопроизводительного использования как с точки зрения больших объемов данных, так и требований к высокой скорости. Byte векторы кодируются как строгие &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; массивы байтов, проведенных в &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; , и может передаваться между C и Haskell с небольшим усилием.</target>
        </trans-unit>
        <trans-unit id="bd5048b9a802cb3ce698b367ba1957e1c7c15edd" translate="yes" xml:space="preserve">
          <source>A time- and space-efficient implementation of byte vectors using packed Word8 arrays, suitable for high performance use, both in terms of large data quantities and high speed requirements. Byte vectors are encoded as strict &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; arrays of bytes, held in a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, and can be passed between C and Haskell with little effort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe6c6fa0b66fdbc97157d1012689fd665f63f77" translate="yes" xml:space="preserve">
          <source>A timeout registration cookie.</source>
          <target state="translated">Куки-файл регистрации на тайм-аут.</target>
        </trans-unit>
        <trans-unit id="9e5d778e506d2310054d3157a8637a07f1af1107" translate="yes" xml:space="preserve">
          <source>A top-level declaration</source>
          <target state="translated">декларация высшего уровня</target>
        </trans-unit>
        <trans-unit id="c16187723ff5e241fc07ce9bf83e42940dac6da5" translate="yes" xml:space="preserve">
          <source>A topological sort of the graph. The order is partially specified by the condition that a vertex &lt;em&gt;i&lt;/em&gt; precedes &lt;em&gt;j&lt;/em&gt; whenever &lt;em&gt;j&lt;/em&gt; is reachable from &lt;em&gt;i&lt;/em&gt; but not vice versa.</source>
          <target state="translated">Топологическая разновидность графа. Порядок частично определяется условием, что вершина &lt;em&gt;i&lt;/em&gt; предшествует &lt;em&gt;j,&lt;/em&gt; если &lt;em&gt;j&lt;/em&gt; достижима из &lt;em&gt;i,&lt;/em&gt; но не наоборот.</target>
        </trans-unit>
        <trans-unit id="4693f1c5c0fbb57b8d5c4df19d87586bf13001db" translate="yes" xml:space="preserve">
          <source>A tricky implementation detail is the question of how to abort an &lt;code&gt;IO&lt;/code&gt; computation. This combinator relies on asynchronous exceptions internally (namely throwing the computation the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-timeout#t:Timeout&quot;&gt;Timeout&lt;/a&gt;&lt;/code&gt; exception). The technique works very well for computations executing inside of the Haskell runtime system, but it doesn't work at all for non-Haskell code. Foreign function calls, for example, cannot be timed out with this combinator simply because an arbitrary C function cannot receive asynchronous exceptions. When &lt;code&gt;timeout&lt;/code&gt; is used to wrap an FFI call that blocks, no timeout event can be delivered until the FFI call returns, which pretty much negates the purpose of the combinator. In practice, however, this limitation is less severe than it may sound. Standard I/O functions like &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt;, Network.Socket.accept, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; appear to be blocking, but they really don't because the runtime system uses scheduling mechanisms like &lt;code&gt;select(2)&lt;/code&gt; to perform asynchronous I/O, so it is possible to interrupt standard socket I/O or file I/O using this combinator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6efe802c821d7daf17899a761feb1bf7a82692b9" translate="yes" xml:space="preserve">
          <source>A tricky implementation detail is the question of how to abort an &lt;code&gt;IO&lt;/code&gt; computation. This combinator relies on asynchronous exceptions internally. The technique works very well for computations executing inside of the Haskell runtime system, but it doesn't work at all for non-Haskell code. Foreign function calls, for example, cannot be timed out with this combinator simply because an arbitrary C function cannot receive asynchronous exceptions. When &lt;code&gt;timeout&lt;/code&gt; is used to wrap an FFI call that blocks, no timeout event can be delivered until the FFI call returns, which pretty much negates the purpose of the combinator. In practice, however, this limitation is less severe than it may sound. Standard I/O functions like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt;, Network.Socket.accept, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; appear to be blocking, but they really don't because the runtime system uses scheduling mechanisms like &lt;code&gt;select(2)&lt;/code&gt; to perform asynchronous I/O, so it is possible to interrupt standard socket I/O or file I/O using this combinator.</source>
          <target state="translated">Сложная деталь реализации - это вопрос о том, как прервать вычисление &lt;code&gt;IO&lt;/code&gt; вывода. Этот комбинатор внутренне полагается на асинхронные исключения. Этот метод очень хорошо работает для вычислений, выполняемых внутри системы времени выполнения Haskell, но он совсем не работает для кода, отличного от Haskell. Например, этот комбинатор не может использовать тайм-аут для вызовов сторонних функций просто потому, что произвольная функция C не может принимать асинхронные исключения. Когда &lt;code&gt;timeout&lt;/code&gt; используется для обертывания блокирующего вызова FFI, событие тайм-аута не может быть доставлено до тех пор, пока вызов FFI не вернется, что в значительной степени сводит на нет цель комбинатора. Однако на практике это ограничение менее сурово, чем может показаться. Стандартные функции ввода-вывода, такие как &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt; , Network.Socket.accept или &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; кажутся блокирующими, но на самом деле это не так, потому что система времени выполнения использует механизмы планирования, такие как &lt;code&gt;select(2)&lt;/code&gt; для выполнения асинхронного ввода-вывода, поэтому можно прервать стандартный ввод-вывод сокета. или файловый ввод-вывод с помощью этого комбинатора.</target>
        </trans-unit>
        <trans-unit id="41f5a544b2c86e8b88cd4fa644eb1707b05f6a06" translate="yes" xml:space="preserve">
          <source>A tricky implementation detail is the question of how to abort an &lt;code&gt;IO&lt;/code&gt; computation. This combinator relies on asynchronous exceptions internally. The technique works very well for computations executing inside of the Haskell runtime system, but it doesn't work at all for non-Haskell code. Foreign function calls, for example, cannot be timed out with this combinator simply because an arbitrary C function cannot receive asynchronous exceptions. When &lt;code&gt;timeout&lt;/code&gt; is used to wrap an FFI call that blocks, no timeout event can be delivered until the FFI call returns, which pretty much negates the purpose of the combinator. In practice, however, this limitation is less severe than it may sound. Standard I/O functions like &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt;, Network.Socket.accept, or &lt;code&gt;&lt;a href=&quot;system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; appear to be blocking, but they really don't because the runtime system uses scheduling mechanisms like &lt;code&gt;select(2)&lt;/code&gt; to perform asynchronous I/O, so it is possible to interrupt standard socket I/O or file I/O using this combinator.</source>
          <target state="translated">Сложная деталь реализации - это вопрос о том, как прервать вычисление &lt;code&gt;IO&lt;/code&gt; вывода. Этот комбинатор внутренне полагается на асинхронные исключения. Этот метод очень хорошо работает для вычислений, выполняемых внутри системы времени выполнения Haskell, но он совсем не работает для кода, отличного от Haskell. Например, этот комбинатор не может использовать тайм-аут для вызовов сторонних функций просто потому, что произвольная функция C не может принимать асинхронные исключения. Когда &lt;code&gt;timeout&lt;/code&gt; используется для обертывания блокирующего вызова FFI, событие тайм-аута не может быть доставлено до тех пор, пока вызов FFI не вернется, что в значительной степени сводит на нет цель комбинатора. Однако на практике это ограничение менее сурово, чем может показаться. Стандартные функции ввода-вывода, такие как &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt; , Network.Socket.accept или &lt;code&gt;&lt;a href=&quot;system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; кажутся блокирующими, но на самом деле это не так, потому что система времени выполнения использует механизмы планирования, такие как &lt;code&gt;select(2)&lt;/code&gt; для выполнения асинхронного ввода-вывода, поэтому можно прервать стандартный ввод-вывод сокета. или файловый ввод-вывод с помощью этого комбинатора.</target>
        </trans-unit>
        <trans-unit id="966e03642cf0118fe092db70abdc7d1b27e6b71d" translate="yes" xml:space="preserve">
          <source>A type</source>
          <target state="translated">Тип А</target>
        </trans-unit>
        <trans-unit id="b12eefa8f8a22f3c9c1c70d44c19389c8c5386e5" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; if it provides an associative function (&lt;code&gt;&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;) that lets you combine any two values of type &lt;code&gt;a&lt;/code&gt; into one, and a neutral element (&lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;) such that</source>
          <target state="translated">Тип &lt;code&gt;a&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; если он предоставляет ассоциативную функцию ( &lt;code&gt;&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; ), которая позволяет объединить любые два значения типа &lt;code&gt;a&lt;/code&gt; в одно и нейтральный элемент ( &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; ), так что</target>
        </trans-unit>
        <trans-unit id="900bea671831ed1ce8158cdebd74c597c210974a" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; if it provides an associative function (&lt;code&gt;&lt;a href=&quot;data-semigroup#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;) that lets you combine any two values of type &lt;code&gt;a&lt;/code&gt; into one. Where being associative means that the following must always hold:</source>
          <target state="translated">Тип &lt;code&gt;a&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; если он предоставляет ассоциативную функцию ( &lt;code&gt;&lt;a href=&quot;data-semigroup#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; ), которая позволяет объединить любые два значения типа &lt;code&gt;a&lt;/code&gt; в одно. Если ассоциативность означает, что всегда должно выполняться следующее:</target>
        </trans-unit>
        <trans-unit id="5c36da43acccbf65c4959f463c0fb381ab69f5fb" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;f&lt;/code&gt; is a Functor if it provides a function &lt;code&gt;fmap&lt;/code&gt; which, given any types &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; lets you apply any function from &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; to turn an &lt;code&gt;f a&lt;/code&gt; into an &lt;code&gt;f b&lt;/code&gt;, preserving the structure of &lt;code&gt;f&lt;/code&gt;. Furthermore &lt;code&gt;f&lt;/code&gt; needs to adhere to the following:</source>
          <target state="translated">Тип &lt;code&gt;f&lt;/code&gt; является функтором, если он предоставляет функцию &lt;code&gt;fmap&lt;/code&gt; , которая, учитывая любые типы &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , позволяет вам применять любую функцию из &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; чтобы превратить &lt;code&gt;f a&lt;/code&gt; в &lt;code&gt;f b&lt;/code&gt; , сохраняя структуру &lt;code&gt;f&lt;/code&gt; . Кроме того, &lt;code&gt;f&lt;/code&gt; необходимо соблюдать следующее:</target>
        </trans-unit>
        <trans-unit id="e8dc677defa7be455d6125e7b6e0f1fcd1c4b205" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;f&lt;/code&gt; is a Functor if it provides a function &lt;code&gt;fmap&lt;/code&gt; which, given any types &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, lets you apply any function of type &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; to turn an &lt;code&gt;f a&lt;/code&gt; into an &lt;code&gt;f b&lt;/code&gt;, preserving the structure of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;f&lt;/code&gt; является функтором, если он предоставляет функцию &lt;code&gt;fmap&lt;/code&gt; , которая, учитывая любые типы &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , позволяет вам применять любую функцию типа &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; для превращения &lt;code&gt;f a&lt;/code&gt; в &lt;code&gt;f b&lt;/code&gt; , сохраняя структуру &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5b73b56591ee75fd4320cdb138584a6631c70e7" translate="yes" xml:space="preserve">
          <source>A type application.</source>
          <target state="translated">Тип приложения.</target>
        </trans-unit>
        <trans-unit id="4843d11f8e6edd0b1d5c045f927fdb0d7d055f98" translate="yes" xml:space="preserve">
          <source>A type constructor or class can be any non-reserved operator. Symbols used in types are always like capitalized identifiers; they are never variables. Note that this is different from the lexical syntax of data constructors, which are required to begin with a &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">Конструктор типа или класс может быть любым незарезервированным оператором. Символы, используемые в типах, всегда похожи на идентификаторы с заглавной буквы; они никогда не бывают переменными. Обратите внимание , что это отличается от лексического синтаксиса конструкторов данных, которые необходимы , чтобы начать с &lt;code&gt;:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2957975b2e2a0d72a85cca6ba60d8dc7b412130f" translate="yes" xml:space="preserve">
          <source>A type context can include equality constraints of the form &lt;code&gt;t1 ~ t2&lt;/code&gt;, which denote that the types &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; need to be the same. In the presence of type families, whether two types are equal cannot generally be decided locally. Hence, the contexts of function signatures may include equality constraints, as in the following example:</source>
          <target state="translated">Контекст типа может включать в себя ограничения равенства вида &lt;code&gt;t1 ~ t2&lt;/code&gt; , которые означают, что типы &lt;code&gt;t1&lt;/code&gt; и &lt;code&gt;t2&lt;/code&gt; должны быть одинаковыми. При наличии семейств типов нельзя решить, равны ли два типа на местном уровне. Следовательно, контексты сигнатур функций могут включать в себя ограничения равенства, как в следующем примере:</target>
        </trans-unit>
        <trans-unit id="dbb43eef001aa96d23cb8f2b1045baf5a1fc027f" translate="yes" xml:space="preserve">
          <source>A type family can also be declared with a &lt;code&gt;where&lt;/code&gt; clause, defining the full set of equations for that family. For example:</source>
          <target state="translated">Семейство типов также можно объявить с помощью предложения &lt;code&gt;where&lt;/code&gt; , определяющего полный набор уравнений для этого семейства. Например:</target>
        </trans-unit>
        <trans-unit id="3ca042aa66fa2759abc533fbf4e600be254b35ae" translate="yes" xml:space="preserve">
          <source>A type family to compute Boolean equality.</source>
          <target state="translated">Семейство типов для вычисления булевского равенства.</target>
        </trans-unit>
        <trans-unit id="8eff1fa8083a3c76f23688ec0faf2770e8f9b619" translate="yes" xml:space="preserve">
          <source>A type is &amp;ldquo;rigid&amp;rdquo; if it is completely known to the compiler at its binding site. The easiest way to ensure that a variable a rigid type is to give it a type signature. For more precise details see &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/papers/gadt/&quot;&gt;Simple unification-based type inference for GADTs&lt;/a&gt;. The criteria implemented by GHC are given in the Appendix.</source>
          <target state="translated">Тип считается &amp;laquo;жестким&amp;raquo;, если он полностью известен компилятору в месте его привязки. Самый простой способ гарантировать, что переменная является жестким типом, - это присвоить ей сигнатуру типа. Для более точных деталей см. &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/papers/gadt/&quot;&gt;Простой вывод типа на основе унификации для GADT&lt;/a&gt; . Критерии, применяемые GHC, приведены в Приложении.</target>
        </trans-unit>
        <trans-unit id="6b6dc84a99a51911e396803e6f137d1ec9e7ecb5" translate="yes" xml:space="preserve">
          <source>A type or data family, with a list of its visible instances. A closed type family is returned with 0 instances.</source>
          <target state="translated">Тип или семейство данных,со списком его видимых экземпляров.Семейство закрытого типа возвращается с 0 экземплярами.</target>
        </trans-unit>
        <trans-unit id="0a858ee617d52cf82c99429cf69589bf7daf3b44" translate="yes" xml:space="preserve">
          <source>A type or kind variable explicitly bound using &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; but not used on the left hand side will generate an error, not a warning.</source>
          <target state="translated">Переменная типа или вида, явно связанная с использованием &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; ,&lt;/a&gt; но не используемая в левой части, вызовет ошибку, а не предупреждение.</target>
        </trans-unit>
        <trans-unit id="13dc503b524051e73bf1854416495a7c476690ef" translate="yes" xml:space="preserve">
          <source>A type representing a number of UTF-16 code units.</source>
          <target state="translated">Тип,представляющий ряд единиц кода UTF-16.</target>
        </trans-unit>
        <trans-unit id="fac7b1b31387a5dce83f6207988f33acc423d8c4" translate="yes" xml:space="preserve">
          <source>A type signature may occur in any pattern; this is a &lt;em&gt;pattern type signature&lt;/em&gt;. For example:</source>
          <target state="translated">Подпись типа может встречаться в любом шаблоне; это &lt;em&gt;сигнатура типа шаблона&lt;/em&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="8682a8a15f37e1952f2bed70e4a76505ad01ea0d" translate="yes" xml:space="preserve">
          <source>A type variable applied to some types:</source>
          <target state="translated">Переменная типа,применяемая к некоторым типам:</target>
        </trans-unit>
        <trans-unit id="9bfcbaf65cc2630df1737c174af7d766948febae" translate="yes" xml:space="preserve">
          <source>A type variable beginning with an underscore is not treated specially in a type or data instance declaration. For example:</source>
          <target state="translated">Переменная типа,начинающаяся со знака подчеркивания,не обрабатывается специально в объявлении типа или экземпляра данных.Например:</target>
        </trans-unit>
        <trans-unit id="6ca958f1089d3d1582d1c30aba329c8223832dd9" translate="yes" xml:space="preserve">
          <source>A type variable.</source>
          <target state="translated">Переменная типа.</target>
        </trans-unit>
        <trans-unit id="297b034e775e243ef7a125f9be96bd9336678f08" translate="yes" xml:space="preserve">
          <source>A typed expression splice can occur in place of an expression; the spliced expression must have type &lt;code&gt;Q (TExp a)&lt;/code&gt;</source>
          <target state="translated">Склейка типизированного выражения может происходить вместо выражения; склеенное выражение должно иметь тип &lt;code&gt;Q (TExp a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fff5bdf005b35f179294ba275419d126af32c8a0" translate="yes" xml:space="preserve">
          <source>A typical heap object may be in one of the following four states at each point in its lifetime:</source>
          <target state="translated">Типичный объект кучи может находиться в одном из следующих четырех состояний в каждой точке своей жизни:</target>
        </trans-unit>
        <trans-unit id="6e00c4c8e7f8a62193a99b6e6434c24bc66d1ce8" translate="yes" xml:space="preserve">
          <source>A typical use is to prevent resource leaks in lazy IO programs, by forcing all characters from a file to be read. For example:</source>
          <target state="translated">Типичное применение-предотвращение утечки ресурсов в ленивых программах ввода-вывода,заставляя читать все символы из файла.Например:</target>
        </trans-unit>
        <trans-unit id="fb52c77586fd9d5d1d5e06c0781fa29b45252709" translate="yes" xml:space="preserve">
          <source>A typical use of &lt;code&gt;&lt;a href=&quot;control-exception#v:tryJust&quot;&gt;tryJust&lt;/a&gt;&lt;/code&gt; for recovery looks like this:</source>
          <target state="translated">Типичное использование &lt;code&gt;&lt;a href=&quot;control-exception#v:tryJust&quot;&gt;tryJust&lt;/a&gt;&lt;/code&gt; для восстановления выглядит так:</target>
        </trans-unit>
        <trans-unit id="f5fa8bc47ca59ba407ee77bfa4f457f11af6f63d" translate="yes" xml:space="preserve">
          <source>A unique &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; object Used when the strings are dynamically allocated, eg from binary deserialisation</source>
          <target state="translated">Уникальный объект &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; Используется, когда строки выделяются динамически, например, из двоичной десериализации</target>
        </trans-unit>
        <trans-unit id="6e0b23e86250bf5ded8e24685820d0cba5c52892" translate="yes" xml:space="preserve">
          <source>A unique identifier used to refer to the cost-centre</source>
          <target state="translated">Уникальный идентификатор,используемый для обозначения центра затрат.</target>
        </trans-unit>
        <trans-unit id="e2b058205e0073a16e899cb4a51295d96e6d2af1" translate="yes" xml:space="preserve">
          <source>A unique local name</source>
          <target state="translated">Уникальное местное название</target>
        </trans-unit>
        <trans-unit id="1f67274a4c72a292a8769f67401cc21d34e5f22d" translate="yes" xml:space="preserve">
          <source>A use of &lt;code&gt;MkSet&lt;/code&gt; as a constructor (e.g. in the definition of &lt;code&gt;makeSet&lt;/code&gt;) gives rise to a &lt;code&gt;(Eq a)&lt;/code&gt; constraint, as you would expect. The new feature is that pattern-matching on &lt;code&gt;MkSet&lt;/code&gt; (as in the definition of &lt;code&gt;insert&lt;/code&gt;) makes &lt;em&gt;available&lt;/em&gt; an &lt;code&gt;(Eq a)&lt;/code&gt; context. In implementation terms, the &lt;code&gt;MkSet&lt;/code&gt; constructor has a hidden field that stores the &lt;code&gt;(Eq a)&lt;/code&gt; dictionary that is passed to &lt;code&gt;MkSet&lt;/code&gt;; so when pattern-matching that dictionary becomes available for the right-hand side of the match. In the example, the equality dictionary is used to satisfy the equality constraint generated by the call to &lt;code&gt;elem&lt;/code&gt;, so that the type of &lt;code&gt;insert&lt;/code&gt; itself has no &lt;code&gt;Eq&lt;/code&gt; constraint.</source>
          <target state="translated">Использование &lt;code&gt;MkSet&lt;/code&gt; в качестве конструктора (например, в определении &lt;code&gt;makeSet&lt;/code&gt; ) приводит к ограничению &lt;code&gt;(Eq a)&lt;/code&gt; , как и следовало ожидать. Новая функция является то , что сопоставления с образцом на &lt;code&gt;MkSet&lt;/code&gt; (как в определении &lt;code&gt;insert&lt;/code&gt; ) делает &lt;em&gt;доступна&lt;/em&gt; в &lt;code&gt;(Eq a)&lt;/code&gt; контекст. С точки зрения реализации, конструктор &lt;code&gt;MkSet&lt;/code&gt; имеет скрытое поле, в котором хранится словарь &lt;code&gt;(Eq a)&lt;/code&gt; , который передается в &lt;code&gt;MkSet&lt;/code&gt; ; поэтому при сопоставлении с образцом этот словарь становится доступным для правой стороны сопоставления. В этом примере словарь равенства используется для удовлетворения ограничения равенства, созданного вызовом &lt;code&gt;elem&lt;/code&gt; , так что сам тип &lt;code&gt;insert&lt;/code&gt; не имеет ограничений &lt;code&gt;Eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1353efcd4777e1aa99c83066c3c4fd8238bee7d" translate="yes" xml:space="preserve">
          <source>A useful &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt;-like function for debugging purposes.</source>
          <target state="translated">Полезная функция &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; - like для отладки.</target>
        </trans-unit>
        <trans-unit id="86295d409cfd9cf7cbef34ae7b547dcc96dc0f25" translate="yes" xml:space="preserve">
          <source>A useful default. In particular:</source>
          <target state="translated">Полезное значение по умолчанию.В частности:</target>
        </trans-unit>
        <trans-unit id="f8c74a72bfde3e2ebcf4f91dbf953debbfc38d10" translate="yes" xml:space="preserve">
          <source>A useful idiom permitted by the above rules is as follows. If one allows overlapping instance declarations then it&amp;rsquo;s quite convenient to have a &amp;ldquo;default instance&amp;rdquo; declaration that applies if something more specific does not:</source>
          <target state="translated">Полезная идиома, разрешенная приведенными выше правилами, следующая. Если разрешено перекрытие деклараций экземпляров, то довольно удобно иметь декларацию &amp;laquo;экземпляра по умолчанию&amp;raquo;, которая применяется, если чего-то более конкретного нет:</target>
        </trans-unit>
        <trans-unit id="a0a8e93d7731f26de07f8a99cabb013a2ca2c78f" translate="yes" xml:space="preserve">
          <source>A useful option to alert you when interfaces change is &lt;code&gt;-ddump-hi-diffs&lt;/code&gt; option. It will run &lt;code&gt;diff&lt;/code&gt; on the changed interface file, before and after, when applicable.</source>
          <target state="translated">Полезная опция для предупреждения вас об изменении интерфейсов - &lt;code&gt;-ddump-hi-diffs&lt;/code&gt; . Он будет запускать &lt;code&gt;diff&lt;/code&gt; для измененного файла интерфейса до и после, если применимо.</target>
        </trans-unit>
        <trans-unit id="48bece416cc59f93fda6101dbf5899713474b8a5" translate="yes" xml:space="preserve">
          <source>A user could provide, for example, a &lt;code&gt;GSerialize UInt&lt;/code&gt; instance so that a &lt;code&gt;Serialize IntHash&lt;/code&gt; instance could be easily defined in terms of &lt;code&gt;GSerialize&lt;/code&gt;.</source>
          <target state="translated">Пользователь может предоставить, например, экземпляр &lt;code&gt;GSerialize UInt&lt;/code&gt; , чтобы экземпляр &lt;code&gt;Serialize IntHash&lt;/code&gt; можно было легко определить в терминах &lt;code&gt;GSerialize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5dd220d0ff116d56be2881c3c2eda319a7be24bc" translate="yes" xml:space="preserve">
          <source>A user log message (from, e.g., &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:traceEvent&quot;&gt;Control.Concurrent.traceEvent&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab5483fab05ffacd5a3f560ae7afd7921c21d6c2" translate="yes" xml:space="preserve">
          <source>A user marker (from &lt;a href=&quot;../libraries/base-4.14.1.0/debug-trace#v:traceMarker&quot;&gt;Debug.Trace.traceMarker&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bf4989d597f060b1f221f4d9b40f8cbdd26cf10" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; is an object encapsulated together with its type.</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; - это объект, инкапсулированный вместе с его типом.</target>
        </trans-unit>
        <trans-unit id="5e578226b20de3d07741dafad66454d118f3458d" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; is a pointer to a function callable from foreign code. The type &lt;code&gt;a&lt;/code&gt; will normally be a &lt;em&gt;foreign type&lt;/em&gt;, a function type with zero or more arguments where</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; - указатель на функцию, вызываемую из внешнего кода. Тип &lt;code&gt;a&lt;/code&gt; обычно будет &lt;em&gt;внешним типом&lt;/em&gt; , типом функции с нулем или более аргументов, где</target>
        </trans-unit>
        <trans-unit id="5e81410f386c89f452d754e65a825472786597c7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; may be a pointer to a foreign function, either returned by another foreign function or imported with a a static address import like</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; может быть указателем на внешнюю функцию, либо возвращенным другой внешней функцией, либо импортированным с помощью импорта статического адреса, например</target>
        </trans-unit>
        <trans-unit id="7f136bc98f2d8137b486a143123edbe9b3241275" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; представляет собой указатель на объект или массив объектов, которые могут быть упорядочены в значения типа &lt;code&gt;a&lt;/code&gt; Haskell или из них .</target>
        </trans-unit>
        <trans-unit id="3cd6a3283ff99f274500f801cf1370f639df9d9c" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; is a pointer to a function callable from foreign code. The type &lt;code&gt;a&lt;/code&gt; will normally be a &lt;em&gt;foreign type&lt;/em&gt;, a function type with zero or more arguments where</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; - указатель на функцию, вызываемую из внешнего кода. Тип &lt;code&gt;a&lt;/code&gt; обычно будет &lt;em&gt;внешним типом&lt;/em&gt; , типом функции с нулем или более аргументов, где</target>
        </trans-unit>
        <trans-unit id="afb41f27d10d971b0c644adebd15549eb369a006" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; may be a pointer to a foreign function, either returned by another foreign function or imported with a a static address import like</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; может быть указателем на внешнюю функцию, либо возвращенным другой внешней функцией, либо импортированным с помощью импорта статического адреса, например</target>
        </trans-unit>
        <trans-unit id="239d8e1787a28722de24cac0f475ff48393d312a" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; представляет собой указатель на объект или массив объектов, которые могут быть упорядочены в значения типа &lt;code&gt;a&lt;/code&gt; Haskell или из них .</target>
        </trans-unit>
        <trans-unit id="65cdd07d411abaf19b949230fd787b91d7248467" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; is a computation which, when performed, does some I/O before returning a value of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; - это вычисление, которое при выполнении выполняет некоторый ввод-вывод перед возвратом значения типа &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a20081f01fcf352f0cfcb6c5a5c6d192ad5b3810" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; is a pointer to a function callable from foreign code. The type &lt;code&gt;a&lt;/code&gt; will normally be a &lt;em&gt;foreign type&lt;/em&gt;, a function type with zero or more arguments where</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; - указатель на функцию, вызываемую из внешнего кода. Тип &lt;code&gt;a&lt;/code&gt; обычно будет &lt;em&gt;внешним типом&lt;/em&gt; , типом функции с нулем или более аргументов, где</target>
        </trans-unit>
        <trans-unit id="6305ddbae16f3512160787cb992d3e58bee68afe" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; may be a pointer to a foreign function, either returned by another foreign function or imported with a a static address import like</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; может быть указателем на внешнюю функцию, либо возвращенным другой внешней функцией, либо импортированным с помощью импорта статического адреса, например</target>
        </trans-unit>
        <trans-unit id="9be954ea62342aa30dc2f597f01c234102f416fd" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; представляет собой указатель на объект или массив объектов, которые могут быть упорядочены в значения типа &lt;code&gt;a&lt;/code&gt; Haskell или из них .</target>
        </trans-unit>
        <trans-unit id="90894fbb07b5d90eacb70ed7f8519e1d7af5b5d4" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; is a computation which, when performed, does some I/O before returning a value of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; - это вычисление, которое при выполнении выполняет некоторый ввод-вывод перед возвратом значения типа &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f741bc04d3ebabbc8052c3e8ced2a6bbb1b0a05" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; представляет собой указатель на объект или массив объектов, которые могут быть упорядочены в значения типа &lt;code&gt;a&lt;/code&gt; Haskell или из них .</target>
        </trans-unit>
        <trans-unit id="9e06d2b58f261c19e13fe9c8981e6d1218570c7c" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; is a computation which, when performed, does some I/O before returning a value of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; - это вычисление, которое при выполнении выполняет некоторый ввод-вывод перед возвратом значения типа &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65e2250aafb04e86e024b91238925a6bb2963b39" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;StablePtr a&lt;/code&gt; is a stable pointer to a Haskell expression of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Значение типа &lt;code&gt;StablePtr a&lt;/code&gt; является стабильным указателем на выражение Haskell типа &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="013a61726b4b56a72c4ddab274465f1e28f21c9f" translate="yes" xml:space="preserve">
          <source>A variable is &lt;em&gt;closed&lt;/em&gt; if and only if</source>
          <target state="translated">Переменная &lt;em&gt;закрыта&lt;/em&gt; тогда и только тогда, когда</target>
        </trans-unit>
        <trans-unit id="6d0624bb33a678b07c2a300b904ae61401b2b3e3" translate="yes" xml:space="preserve">
          <source>A variable is called &lt;em&gt;dynamically bound&lt;/em&gt; when it is bound by the calling context of a function and &lt;em&gt;statically bound&lt;/em&gt; when bound by the callee&amp;rsquo;s context. In Haskell, all variables are statically bound. Dynamic binding of variables is a notion that goes back to Lisp, but was later discarded in more modern incarnations, such as Scheme. Dynamic binding can be very confusing in an untyped language, and unfortunately, typed languages, in particular Hindley-Milner typed languages like Haskell, only support static scoping of variables.</source>
          <target state="translated">Переменная вызывается &lt;em&gt;динамически связанной,&lt;/em&gt; когда она привязана вызывающим контекстом функции, и &lt;em&gt;статически связанной,&lt;/em&gt; когда привязана контекстом вызываемого. В Haskell все переменные статически связаны. Динамическое связывание переменных - это понятие, восходящее к Лиспу, но позже оно было отброшено в более современных воплощениях, таких как Scheme. Динамическое связывание может сильно сбивать с толку на нетипизированном языке, и, к сожалению, типизированные языки, в частности типизированные языки Хиндли-Милнера, такие как Haskell, поддерживают только статическое определение области видимости переменных.</target>
        </trans-unit>
        <trans-unit id="e557c6a254bde2fa9fce694bac49fbabbe6203a2" translate="yes" xml:space="preserve">
          <source>A variable is regarded as &amp;ldquo;used&amp;rdquo; if</source>
          <target state="translated">Переменная считается &amp;laquo;использованной&amp;raquo;, если</target>
        </trans-unit>
        <trans-unit id="ef00f1720266eda76457e7e8274afd0d351d58ec" translate="yes" xml:space="preserve">
          <source>A variable-length event encoding a heap sample broken down by,</source>
          <target state="translated">Событие переменной длины,кодирующее образец кучи,разбитый на части,</target>
        </trans-unit>
        <trans-unit id="b96521844e19dff99bc29450ed4b5c3e48d9657d" translate="yes" xml:space="preserve">
          <source>A variable-length packet encoding a heap profile sample broken down by,</source>
          <target state="translated">Пакет переменной длины,кодирующий образец профиля кучи,разбитый на части,</target>
        </trans-unit>
        <trans-unit id="d2629ff819bfa2b3bc89a988e7b72caf2ad22ebf" translate="yes" xml:space="preserve">
          <source>A variable-length packet encoding a profile sample.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661a750d420cf956ff31ac1cd27a77853ed3578e" translate="yes" xml:space="preserve">
          <source>A variable-length packet produced once for each cost centre,</source>
          <target state="translated">Пакет переменной длины,производимый один раз для каждого центра затрат,</target>
        </trans-unit>
        <trans-unit id="5d1f67f8c131ae27aed80d2e73f0a9a08edfca88" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; with the arguments reversed.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; с обратными аргументами.</target>
        </trans-unit>
        <trans-unit id="bdb2d179c96dfc9014b723ecd18ad20eb9df0287" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; where the return value from the first computation is not required.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; котором возвращаемое значение из первого вычисления не требуется.</target>
        </trans-unit>
        <trans-unit id="f484ec182618f59bc6a03fa556e1dfe4602922b2" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , который можно использовать только в монаде &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a806f7ef066f93f4459cf71c970f146b042ce14" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; that takes an exception predicate to select which exceptions are caught (c.f. &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt;). If the exception does not match the predicate, it is re-thrown.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; ,в котором используется предикат исключения для выбора &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; исключений (cf catchJust ). Если исключение не соответствует предикату, оно генерируется повторно.</target>
        </trans-unit>
        <trans-unit id="980dc5b1188b883f4b0698253298fdcc03f22555" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-state-class#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;control-monad-state-class#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; при котором вычисление является строгим в новом состоянии.</target>
        </trans-unit>
        <trans-unit id="4ec6ceddfeaaf45a25f723cacb495b1ccc3c2250" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-state-lazy#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;control-monad-state-lazy#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; при котором вычисление является строгим в новом состоянии.</target>
        </trans-unit>
        <trans-unit id="d552c9d4da515c75912002c65ae5ebd55983c353" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-state-strict#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;control-monad-state-strict#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; при котором вычисление является строгим в новом состоянии.</target>
        </trans-unit>
        <trans-unit id="2be03be1f4f972f3e16388053b30f3f14523b03b" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; при котором вычисление является строгим в новом состоянии.</target>
        </trans-unit>
        <trans-unit id="3d7eba7d8d00a5efd27077394673889a22d85d24" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; при котором вычисление является строгим в новом состоянии.</target>
        </trans-unit>
        <trans-unit id="f8879cc31acc8932b5c49885c6d29e918117f2f5" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; , не имеющий базового случая, и поэтому может применяться только к непустым структурам.</target>
        </trans-unit>
        <trans-unit id="d3d4bfbfcd281f231983e2d29e27a74b95a66a32" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt; , не имеющий базового случая, и поэтому может применяться только к непустым структурам.</target>
        </trans-unit>
        <trans-unit id="50c2bc37d962248156836e2639fc6b4dadc3fba3" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; that is strict in the accumulator.</source>
          <target state="translated">Строгий по аккумулятору вариант &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18749169ab66a243e5d3ff1e282a5a0fa0dd77c7" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; , который не имеет базового случая и, следовательно, может применяться только к непустым структурам.</target>
        </trans-unit>
        <trans-unit id="c779c916890acc8970f5fe31251b940c218fccc0" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; , который не имеет базового случая и, следовательно, может применяться только к непустым структурам.</target>
        </trans-unit>
        <trans-unit id="8ddfd37c7061963e7b77b06bdb4fbd084e4a8097" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; , который не имеет базового случая и, следовательно, может применяться только к непустым структурам.</target>
        </trans-unit>
        <trans-unit id="7defbd1e72da7e4dd78ff7b670071a5b458cf24a" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; , который не имеет базового случая и, следовательно, может применяться только к непустым структурам.</target>
        </trans-unit>
        <trans-unit id="e9ee1d48660b932b3bb180c1aaef20eee11c73c0" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; with the arguments reversed.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; с обратными аргументами.</target>
        </trans-unit>
        <trans-unit id="d32ebdebb4f9a3837e2e7d4648c8bd7eceb6c9f2" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;ghc-err#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; that does not produce a stack trace.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;ghc-err#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; , при которой трассировка стека не производится.</target>
        </trans-unit>
        <trans-unit id="f23407f9c31b9d9550363e44222113e312af065d" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228eb2d34fa954a72d817265f3ac30a2c4d0f77c" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0680130bb0f4b8f4cbc7c8b028930fd44a3af9ce" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , который можно использовать только в монаде &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ec4492419779cfaef51be94d2b8f28e80c4545f" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , который можно использовать только в монаде &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="491efa58eb1f11c0cb3815ae8f348ca0c034ce84" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , который можно использовать только в монаде &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47d036c06686a27eae150f0188962179aa6b3b53" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , который можно использовать только в монаде &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da53c6399c31d81bfdb2f650d84ca62634038b07" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , который можно использовать только в монаде &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73f171fdb5237d901b1c481374b6861edf14fa56" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; that does not produce a stack trace.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; , при которой трассировка стека не производится.</target>
        </trans-unit>
        <trans-unit id="47f3f2679bc0ad75bdf30646c6761ef6c4b68243" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; , который не имеет базового случая и, следовательно, может применяться только к непустым структурам.</target>
        </trans-unit>
        <trans-unit id="477f918f68cdb05044cf99fdb58a555808faeff3" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; , который не имеет базового случая и, следовательно, может применяться только к непустым структурам.</target>
        </trans-unit>
        <trans-unit id="6911589d252df6b0d320b35e4685df9e30028055" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; where the return value from the first computation is not required.</source>
          <target state="translated">Вариант &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; котором возвращаемое значение из первого вычисления не требуется.</target>
        </trans-unit>
        <trans-unit id="add459265a4128073f2963ebb449fbb05ec6cb08" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">Разновидность &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; ,в которой не проверяются &lt;code&gt;n&lt;/code&gt; , поэтому программист обязан предоставить доказательство того, что &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="022677c1577a85e404387475e8f412822a05da7e" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; omits the check for the empty case, so there is an obligation on the programmer to provide a proof that the ByteString is non-empty.</source>
          <target state="translated">Разнообразие &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; для непустых байтовых строк. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; не проверяет пустой регистр, поэтому программист обязан предоставить доказательство того, что ByteString непусто.</target>
        </trans-unit>
        <trans-unit id="8b4ffb4fe31d0195b8acddfad454298b4604216b" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeInit&quot;&gt;unsafeInit&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">Разнообразие &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; для непустых байтовых строк. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeInit&quot;&gt;unsafeInit&lt;/a&gt;&lt;/code&gt; не проверяет пустой регистр. Как и в случае с &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; , программист должен предоставить отдельное доказательство того, что ByteString не пуста.</target>
        </trans-unit>
        <trans-unit id="1d777dc5f4859f53e852d78b2a883751d3a5e477" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeLast&quot;&gt;unsafeLast&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">Разнообразие &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; для непустых байтовых строк. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeLast&quot;&gt;unsafeLast&lt;/a&gt;&lt;/code&gt; не проверяет пустой регистр. Как и в случае с &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; , программист должен предоставить отдельное доказательство того, что ByteString не пуста.</target>
        </trans-unit>
        <trans-unit id="d0e791ecae2adcb55aa4c85c7e30c588765957cb" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">Разнообразие &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; для непустых байтовых строк. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; не проверяет пустой регистр. Как и в случае с &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; , программист должен предоставить отдельное доказательство того, что ByteString не пуста.</target>
        </trans-unit>
        <trans-unit id="cd0eca831b19e2193bae89b92f0b4e215f8baf4c" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">Разнообразие &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; , который пропускает проверку на &lt;code&gt;n&lt;/code&gt; так есть обязанность программиста предоставить доказательства того, что &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d61fdfe5cc2564d603aac91be2fa83ba8aa2a7c" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06fb91e894a0b25610b75a5af5b9808209630d25" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; omits the check for the empty case, so there is an obligation on the programmer to provide a proof that the ByteString is non-empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdce50acace32ba6eb0fe5af8f10f59503ea5260" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeInit&quot;&gt;unsafeInit&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416bf67712d94a4092fa1366ed0a1243511ca321" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeLast&quot;&gt;unsafeLast&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73173fcba7dc4f1755bea5939f3721c98a85b2cb" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91ba6eac709468119bb502dc4a786ac25beaa443" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="011da0f3d1d6c75639ffb6db3b663d10df8596d2" translate="yes" xml:space="preserve">
          <source>A version can be tagged with an arbitrary list of strings. The interpretation of the list of tags is entirely dependent on the entity that this version applies to.</source>
          <target state="translated">Версия может быть помечена произвольным списком строк.Интерпретация списка тегов полностью зависит от сущности,к которой относится данная версия.</target>
        </trans-unit>
        <trans-unit id="ecaf2ca21f3f2373e5185cd515851b6e67ee803a" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:peekTBQueue&quot;&gt;peekTBQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">Версия &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:peekTBQueue&quot;&gt;peekTBQueue&lt;/a&gt;&lt;/code&gt; , которая не повторяет попытку. Вместо этого он возвращает &lt;code&gt;Nothing&lt;/code&gt; , если значение недоступно.</target>
        </trans-unit>
        <trans-unit id="60ffeb4910a01e5cd6d72fcebc814ef710471656" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:readTBQueue&quot;&gt;readTBQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">Версия &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:readTBQueue&quot;&gt;readTBQueue&lt;/a&gt;&lt;/code&gt; , которая не повторяет попытку. Вместо этого он возвращает &lt;code&gt;Nothing&lt;/code&gt; , если значение недоступно.</target>
        </trans-unit>
        <trans-unit id="0b08df2ea8c4c791467734758ae49b0aa839c743" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:peekTChan&quot;&gt;peekTChan&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">Версия &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:peekTChan&quot;&gt;peekTChan&lt;/a&gt;&lt;/code&gt; , которая не повторяет попытку. Вместо этого он возвращает &lt;code&gt;Nothing&lt;/code&gt; , если значение недоступно.</target>
        </trans-unit>
        <trans-unit id="ef5e78e2ce5a1352cca108846156255775dd7108" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:readTChan&quot;&gt;readTChan&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">Версия &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:readTChan&quot;&gt;readTChan&lt;/a&gt;&lt;/code&gt; , которая не повторяет попытку. Вместо этого он возвращает &lt;code&gt;Nothing&lt;/code&gt; , если значение недоступно.</target>
        </trans-unit>
        <trans-unit id="ff76e55acfcccd02a15d736db81fe96146722925" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryPutTMVar&quot;&gt;tryPutTMVar&lt;/a&gt;&lt;/code&gt; function attempts to put the value &lt;code&gt;a&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, returning &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if it was successful, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">Версия &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; , которая не повторяет &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; . Функция &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryPutTMVar&quot;&gt;tryPutTMVar&lt;/a&gt;&lt;/code&gt; пытается поместить значение &lt;code&gt;a&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; , возвращая &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; в случае успеха или &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="28577cb8a660e56c217a279acfd2976c3b7454ed" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryPutTMVar&quot;&gt;tryPutTMVar&lt;/a&gt;&lt;/code&gt; function attempts to put the value &lt;code&gt;a&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, returning &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if it was successful, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01dc8f0973fefa88de9a13d12ee694150980b61d" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:readTMVar&quot;&gt;readTMVar&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">Версия &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:readTMVar&quot;&gt;readTMVar&lt;/a&gt;&lt;/code&gt; , которая не повторяет попытку. Вместо этого он возвращает &lt;code&gt;Nothing&lt;/code&gt; , если значение недоступно.</target>
        </trans-unit>
        <trans-unit id="ed2b50c296f40c959a6e33c87f8de3078552d7bb" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;. After &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="translated">Версия &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; , которая не повторяет &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; . Функция &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; была пуста, или &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; , если &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; была заполнена содержимым &lt;code&gt;a&lt;/code&gt; . После &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; , то &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; остается пустым.</target>
        </trans-unit>
        <trans-unit id="5433d7bb6120760452598bf6c542c3024a31c810" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;. After &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30f3fd19a32279f9ca43fcf5051a4b725b4afb0" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:peekTQueue&quot;&gt;peekTQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">Версия &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:peekTQueue&quot;&gt;peekTQueue&lt;/a&gt;&lt;/code&gt; , которая не повторяет попытку. Вместо этого он возвращает &lt;code&gt;Nothing&lt;/code&gt; , если значение недоступно.</target>
        </trans-unit>
        <trans-unit id="2433a0ad5e90f34ad9f4bf45621e0ceb170fdea6" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:readTQueue&quot;&gt;readTQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">Версия &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:readTQueue&quot;&gt;readTQueue&lt;/a&gt;&lt;/code&gt; , которая не повторяет попытку. Вместо этого он возвращает &lt;code&gt;Nothing&lt;/code&gt; , если значение недоступно.</target>
        </trans-unit>
        <trans-unit id="4fc561502aa5288942ce875d139d9631abcf512c" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; with the arguments swapped around; useful in situations where the code for the handler is shorter. For example:</source>
          <target state="translated">Версия &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; с переставленными аргументами; полезно в ситуациях, когда код обработчика короче. Например:</target>
        </trans-unit>
        <trans-unit id="1c3e44a662ef33517cd5d56bc8e42cf32ad0c3d0" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; with the arguments swapped around (see &lt;code&gt;&lt;a href=&quot;control-exception#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Версия &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; с аргументами обмениваемых вокруг (см &lt;code&gt;&lt;a href=&quot;control-exception#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e66efe0c3f15c8fafbf44d9ce27299363bc807ef" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; that forces the (pair) result of the function.</source>
          <target state="translated">Версия &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; , которая форсирует (парный) результат функции.</target>
        </trans-unit>
        <trans-unit id="bef2aa5115f3db1a79e2efec0dfffeeae204b525" translate="yes" xml:space="preserve">
          <source>A vertical bar denotes disjunction, i.e. one of the two sides is required. A comma denotes conjunction, i.e. both sides are required. Conjunction binds stronger than disjunction.</source>
          <target state="translated">Вертикальный столбец обозначает дизъюнкцию,т.е.требуется одна из двух сторон.Запятая обозначает соединение,т.е.нужны обе стороны.Соединение связывает сильнее,чем разъединение.</target>
        </trans-unit>
        <trans-unit id="edf34a57d05a3c5d4ea50057dd0ce34f6a6b36fa" translate="yes" xml:space="preserve">
          <source>A very experimental flag that makes dictionary-valued expressions seem cheap to the optimiser.</source>
          <target state="translated">Очень экспериментальный флаг,который делает словарно-значимые выражения дешевыми для оптимизатора.</target>
        </trans-unit>
        <trans-unit id="7c65e4b2cb887d618e9c4063061a15033cdc0051" translate="yes" xml:space="preserve">
          <source>A violation of the &amp;ldquo;forall-or-nothing&amp;rdquo; rule looks like this:</source>
          <target state="translated">Нарушение правила &amp;laquo;все или ничего&amp;raquo; выглядит так:</target>
        </trans-unit>
        <trans-unit id="a5feb9baead6354d4dfbb9ad7fa5678327d72c84" translate="yes" xml:space="preserve">
          <source>A visible type application is preceded with an &lt;code&gt;@&lt;/code&gt; sign. (To disambiguate the syntax, the &lt;code&gt;@&lt;/code&gt; must be preceded with a non-identifier letter, usually a space. For example, &lt;code&gt;read@Int 5&lt;/code&gt; would not parse.) It can be used whenever the full polymorphic type of the function is known. If the function is an identifier (the common case), its type is considered known only when the identifier has been given a type signature. If the identifier does not have a type signature, visible type application cannot be used.</source>
          <target state="translated">Перед приложением видимого типа стоит знак &lt;code&gt;@&lt;/code&gt; . (Чтобы устранить неоднозначность синтаксиса, перед &lt;code&gt;@&lt;/code&gt; должна стоять буква, не являющаяся идентификатором, обычно пробел. Например, &lt;code&gt;read@Int 5&lt;/code&gt; не будет анализироваться.) Его можно использовать всякий раз, когда известен полный полиморфный тип функции. Если функция является идентификатором (общий случай), ее тип считается известным только в том случае, если идентификатору присвоена сигнатура типа. Если идентификатор не имеет сигнатуры типа, приложение видимого типа использовать нельзя.</target>
        </trans-unit>
        <trans-unit id="f7aecd3b32383a90db727ba6bc951dd96bb7555b" translate="yes" xml:space="preserve">
          <source>A way of creating ByteStrings outside the IO monad. The &lt;code&gt;Int&lt;/code&gt; argument gives the final size of the ByteString.</source>
          <target state="translated">Способ создания ByteStrings вне монады ввода-вывода. &lt;code&gt;Int&lt;/code&gt; аргумент дает окончательный размер байтовой строки.</target>
        </trans-unit>
        <trans-unit id="ae700162fd083eb51a2e5484581b63431c6cf961" translate="yes" xml:space="preserve">
          <source>A weak pointer expresses a relationship between two objects, the &lt;em&gt;key&lt;/em&gt; and the &lt;em&gt;value&lt;/em&gt;: if the key is considered to be alive by the garbage collector, then the value is also alive. A reference from the value to the key does &lt;em&gt;not&lt;/em&gt; keep the key alive.</source>
          <target state="translated">Слабый указатель выражает связь между двумя объектами, &lt;em&gt;ключом&lt;/em&gt; и &lt;em&gt;значением&lt;/em&gt; : если сборщик мусора считает ключ живым, то значение также живое. Ссылка значения на ключ &lt;em&gt;не&lt;/em&gt; сохраняет ключ в действии.</target>
        </trans-unit>
        <trans-unit id="4c0a7ed1da2479162371079b8163cabf26c83c98" translate="yes" xml:space="preserve">
          <source>A weak pointer may also have a finalizer of type &lt;code&gt;IO ()&lt;/code&gt;; if it does, then the finalizer will be run at most once, at a time after the key has become unreachable by the program (&quot;dead&quot;). The storage manager attempts to run the finalizer(s) for an object soon after the object dies, but promptness is not guaranteed.</source>
          <target state="translated">Слабый указатель может также иметь финализатор типа &lt;code&gt;IO ()&lt;/code&gt; ; если это так, то финализатор будет запущен не более одного раза, после того, как ключ стал недоступен для программы (&amp;laquo;мертв&amp;raquo;). Диспетчер хранилища пытается запустить финализатор (ы) для объекта вскоре после смерти объекта, но оперативность не гарантируется.</target>
        </trans-unit>
        <trans-unit id="a955a161a9eee216cd6b80d8d47df1c807c9be34" translate="yes" xml:space="preserve">
          <source>A weak pointer object with a key and a value. The value has type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Объект слабого указателя с ключом и значением. Значение имеет тип &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b5c16f462f6b8ca64b6aee48fd180f321af7cba" translate="yes" xml:space="preserve">
          <source>A whole String fragment</source>
          <target state="translated">Целый фрагмент Струны</target>
        </trans-unit>
        <trans-unit id="1306d902863c6c0a77b6f4d1230a385868937f62" translate="yes" xml:space="preserve">
          <source>A wide character string with explicit length information in &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CWchar&quot;&gt;CWchar&lt;/a&gt;&lt;/code&gt;s instead of a terminating NUL (allowing NUL characters in the middle of the string).</source>
          <target state="translated">Строка широких символов с явной информацией о длине в &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CWchar&quot;&gt;CWchar&lt;/a&gt;&lt;/code&gt; s вместо завершающего NUL (разрешая символы NUL в середине строки).</target>
        </trans-unit>
        <trans-unit id="987253a26575543a06fc7e055fbc0251b63eb205" translate="yes" xml:space="preserve">
          <source>A word begins either at the start of the line or after an unescaped whitespace character.</source>
          <target state="translated">Слово начинается либо в начале строки,либо после свободного пробела.</target>
        </trans-unit>
        <trans-unit id="98bca88a2b006e940b1f7f785915d961c11c9f72" translate="yes" xml:space="preserve">
          <source>A writer monad parameterized by the type &lt;code&gt;w&lt;/code&gt; of output to accumulate.</source>
          <target state="translated">Монада записи, параметризованная типом вывода &lt;code&gt;w&lt;/code&gt; для накопления.</target>
        </trans-unit>
        <trans-unit id="07ef82639a79658d53d1fcd5bfce5876d5b9adb5" translate="yes" xml:space="preserve">
          <source>A writer monad parameterized by:</source>
          <target state="translated">Монада записи,параметризованная:</target>
        </trans-unit>
        <trans-unit id="3f08cc0b30779a95143aa2ad65f0531b4ad12960" translate="yes" xml:space="preserve">
          <source>ACL</source>
          <target state="translated">ACL</target>
        </trans-unit>
        <trans-unit id="882edca3292f207f02c04f0e4d828075132b5c5b" translate="yes" xml:space="preserve">
          <source>ADDATTRS</source>
          <target state="translated">ADDATTRS</target>
        </trans-unit>
        <trans-unit id="d37db076be2c745cf98c9bb60cf88dbf2626e6b7" translate="yes" xml:space="preserve">
          <source>AM/PM symbols</source>
          <target state="translated">символы AM/PM</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="e95867ec94d8c275a2d1d9afac6a1d2ffb7fd390" translate="yes" xml:space="preserve">
          <source>ASCII (Char7)</source>
          <target state="translated">ASCII (Char7)</target>
        </trans-unit>
        <trans-unit id="2f934a30b8b57fba10b2b745dc320b339724b1b7" translate="yes" xml:space="preserve">
          <source>ASCII &lt;code&gt;'0'&lt;/code&gt; through &lt;code&gt;'9'&lt;/code&gt; are all numbers:</source>
          <target state="translated">От &lt;code&gt;'0'&lt;/code&gt; до &lt;code&gt;'9'&lt;/code&gt; кодировке ASCII все числа:</target>
        </trans-unit>
        <trans-unit id="cae061a530cef71c477f974034de1fd1d9b43ecb" translate="yes" xml:space="preserve">
          <source>ATOM</source>
          <target state="translated">ATOM</target>
        </trans-unit>
        <trans-unit id="09116156619580f2fa8233d5bca8cf8644f9c359" translate="yes" xml:space="preserve">
          <source>Abandon evaluation of a statement after a breakpoint</source>
          <target state="translated">Отказаться от оценки заявления после точки перерыва.</target>
        </trans-unit>
        <trans-unit id="c38c6ea6c11538ed82fd288d53c904871944106f" translate="yes" xml:space="preserve">
          <source>Abandons the current evaluation (only available when stopped at a breakpoint).</source>
          <target state="translated">Бросает текущий анализ (доступен только при остановке в точке останова).</target>
        </trans-unit>
        <trans-unit id="f07c8230701366b843cd68845fafa5d65a1de2d9" translate="yes" xml:space="preserve">
          <source>About validity:</source>
          <target state="translated">Об обоснованности:</target>
        </trans-unit>
        <trans-unit id="05edf0d68cd3c84475eb832e7d283639e6bdeca9" translate="yes" xml:space="preserve">
          <source>Above, except that if the last line of the first argument stops at least one position before the first line of the second begins, these two lines are overlapped. For example:</source>
          <target state="translated">Выше,за исключением того,что если последняя строка первого аргумента останавливается хотя бы на одну позицию до начала первой строки второго,эти две строки накладываются друг на друга.Например:</target>
        </trans-unit>
        <trans-unit id="ef82336eb495d4e5324f732f879ad3b7c7dd9b61" translate="yes" xml:space="preserve">
          <source>Above, with no overlapping. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вверху, без нахлеста. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; ассоциативен с &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; тождественностью .</target>
        </trans-unit>
        <trans-unit id="8a7dc34cb7ea60a4e1ddaf0a591cdafbc0e403cf" translate="yes" xml:space="preserve">
          <source>Above, with no overlapping. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вверху, без нахлеста. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; ассоциативен с &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; тождественностью .</target>
        </trans-unit>
        <trans-unit id="d2d972269377ed5359cdd2dcc108f0e3936d78b1" translate="yes" xml:space="preserve">
          <source>Above, with no overlapping. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вверху, без нахлеста. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; ассоциативен с &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; тождественностью .</target>
        </trans-unit>
        <trans-unit id="88874691ade84811a148df43dee3e898c7993db4" translate="yes" xml:space="preserve">
          <source>Above, without dovetailing.</source>
          <target state="translated">Выше,без голубиных хвостов.</target>
        </trans-unit>
        <trans-unit id="ffc84c11cb600f5730c837f24132ad44932f0e4a" translate="yes" xml:space="preserve">
          <source>Above; if there is no overlap it &quot;dovetails&quot; the two</source>
          <target state="translated">Выше;если нет перекрытия,он &quot;ласточкин хвост&quot;.</target>
        </trans-unit>
        <trans-unit id="2c7fe8b95b08b1e64796580d91044372f5603e8d" translate="yes" xml:space="preserve">
          <source>Absolute cursor movements</source>
          <target state="translated">Абсолютные движения курсора</target>
        </trans-unit>
        <trans-unit id="44530d6a736fdaae47537dfbad7f8dda6f90c1ca" translate="yes" xml:space="preserve">
          <source>Absolute intervals</source>
          <target state="translated">Абсолютные интервалы</target>
        </trans-unit>
        <trans-unit id="05675a8df55f00a801d7267f15ceae258c856842" translate="yes" xml:space="preserve">
          <source>Absolute value.</source>
          <target state="translated">Абсолютная ценность.</target>
        </trans-unit>
        <trans-unit id="be11481292069bbf4e5d32f6f22e3e0ba35a6c06" translate="yes" xml:space="preserve">
          <source>AbsoluteSeek</source>
          <target state="translated">AbsoluteSeek</target>
        </trans-unit>
        <trans-unit id="d18ae99534459c5602deda227d35dbfc2f1e9957" translate="yes" xml:space="preserve">
          <source>AbsoluteTime</source>
          <target state="translated">AbsoluteTime</target>
        </trans-unit>
        <trans-unit id="434cecc208a8b4bb275114bca8d90f1c47541833" translate="yes" xml:space="preserve">
          <source>AbsoluteTime is TAI, time as measured by a clock.</source>
          <target state="translated">Абсолютное время-TAI,время,измеряемое часами.</target>
        </trans-unit>
        <trans-unit id="667a8cf10407b19099b8b8a8c853533598abd554" translate="yes" xml:space="preserve">
          <source>Abstract data types can be implemented not only with data declarations, but also newtypes and type synonyms (with the restriction that a type synonym must be fully eta-reduced, e.g., &lt;code&gt;type T = ...&lt;/code&gt; to be accepted.) For example, the following are all valid implementations of the T above:</source>
          <target state="translated">Абстрактные типы данных могут быть реализованы не только с объявлениями данных, но также с новыми типами и синонимами типов (с ограничением, что синоним типа должен быть полностью сокращен по эталону, например, чтобы &lt;code&gt;type T = ...&lt;/code&gt; был принят). Например, Ниже приведены все допустимые реализации T выше:</target>
        </trans-unit>
        <trans-unit id="beb8fcf15e248371df65aec656beac0bfea7c0b8" translate="yes" xml:space="preserve">
          <source>Abstract representation of vertices.</source>
          <target state="translated">Абстрактное представление вершин.</target>
        </trans-unit>
        <trans-unit id="f326ddf7104d3df6fa13479c593c244c4623b73c" translate="yes" xml:space="preserve">
          <source>Abstract syntax definitions for Template Haskell.</source>
          <target state="translated">Абстрактные определения синтаксиса для Шаблона Хаскелла.</target>
        </trans-unit>
        <trans-unit id="71b7aef56068b7e751389cca7071da4abd7a1c80" translate="yes" xml:space="preserve">
          <source>Accept leading and trailing whitespace?</source>
          <target state="translated">Принимать лидирующие и отстающие пробелы?</target>
        </trans-unit>
        <trans-unit id="95d34f3b555d7e27b1e17d75f2e37485b204658e" translate="yes" xml:space="preserve">
          <source>Accept leading whitespace?</source>
          <target state="translated">Согласен лидировать на белых пробелах?</target>
        </trans-unit>
        <trans-unit id="bc52205c7ec889cf4cba765533bcd4e5d13957bc" translate="yes" xml:space="preserve">
          <source>Acceptable data</source>
          <target state="translated">Приемлемые данные</target>
        </trans-unit>
        <trans-unit id="3a8a3f0706793232d22f7100e8ea68a2faa1f5f0" translate="yes" xml:space="preserve">
          <source>Access to GHC's call-stack simulation</source>
          <target state="translated">Доступ к симуляции стека вызовов GHC</target>
        </trans-unit>
        <trans-unit id="4756089d5cd10709a1d37fad3e346fb021462dee" translate="yes" xml:space="preserve">
          <source>AccessMode</source>
          <target state="translated">AccessMode</target>
        </trans-unit>
        <trans-unit id="f9fce24b3c49b79586973841924c190bcf8769f7" translate="yes" xml:space="preserve">
          <source>Accessing arrays</source>
          <target state="translated">Массивы доступа</target>
        </trans-unit>
        <trans-unit id="aff0bc5a5aaa0b373eac340c6aadb774a3a23049" translate="yes" xml:space="preserve">
          <source>Accessing the pointer to the array contents</source>
          <target state="translated">Доступ к указателю на содержимое массива</target>
        </trans-unit>
        <trans-unit id="3efd139cf44f823a7b553a058c94da8090307f52" translate="yes" xml:space="preserve">
          <source>Accessors to GHC RTS flags. Descriptions of flags can be seen in &lt;a href=&quot;https://www.haskell.org/ghc/docs/latest/html/users_guide/runtime_control.html&quot;&gt;GHC User's Guide&lt;/a&gt;, or by running RTS help message using &lt;code&gt;+RTS --help&lt;/code&gt;.</source>
          <target state="translated">Аксессоры к флагам GHC RTS. Описания флагов можно увидеть в &lt;a href=&quot;https://www.haskell.org/ghc/docs/latest/html/users_guide/runtime_control.html&quot;&gt;Руководстве пользователя GHC&lt;/a&gt; или запустив справочное сообщение RTS с помощью &lt;code&gt;+RTS --help&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7edca54ae2bf350d49cd477266ad9dd7d55aedcd" translate="yes" xml:space="preserve">
          <source>According to [1]:</source>
          <target state="translated">Согласно [1]:</target>
        </trans-unit>
        <trans-unit id="2d6dfb6165d33d7dc1b66480f6a0d421d69dd337" translate="yes" xml:space="preserve">
          <source>According to the GMP documentation, the underlying function &lt;code&gt;mpz_nextprime()&lt;/code&gt; &quot;uses a probabilistic algorithm to identify primes. For practical purposes it's adequate, the chance of a composite passing will be extremely small.&quot;</source>
          <target state="translated">Согласно документации GMP, основная функция &lt;code&gt;mpz_nextprime()&lt;/code&gt; &amp;laquo;использует вероятностный алгоритм для определения простых чисел. Для практических целей этого достаточно, вероятность составного прохождения будет чрезвычайно мала&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a91ad95de89488856c8210673c103c15b4491b35" translate="yes" xml:space="preserve">
          <source>According to the rules above &lt;code&gt;X&lt;/code&gt; has a CUSK. Yet, the kind of &lt;code&gt;k&lt;/code&gt; is undetermined. It is thus quantified over, giving &lt;code&gt;X&lt;/code&gt; the kind &lt;code&gt;forall k1 (k :: k1). Proxy k -&amp;gt; Type&lt;/code&gt;.</source>
          <target state="translated">Согласно правилам, приведенным выше, &lt;code&gt;X&lt;/code&gt; имеет КУСК. Тем не менее, вид &lt;code&gt;k&lt;/code&gt; не определен. Таким образом, он определяется количественно, давая &lt;code&gt;X&lt;/code&gt; вид для &lt;code&gt;forall k1 (k :: k1). Proxy k -&amp;gt; Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d5e0f0e68219f2793950ff4f739b0707416bc38" translate="yes" xml:space="preserve">
          <source>Accordingly, the rule for kind quantification in higher-rank contexts has changed slightly. In GHC 7, if a kind variable was mentioned for the first time in the kind of a variable bound in a non-top-level &lt;code&gt;forall&lt;/code&gt;, the kind variable was bound there, too. That is, in &lt;code&gt;f :: (forall (a :: k). ...) -&amp;gt; ...&lt;/code&gt;, the &lt;code&gt;k&lt;/code&gt; was bound by the same &lt;code&gt;forall&lt;/code&gt; as the &lt;code&gt;a&lt;/code&gt;. In GHC 8, however, all kind variables mentioned in a type are bound at the outermost level. If you want one bound in a higher-rank &lt;code&gt;forall&lt;/code&gt;, include it explicitly.</source>
          <target state="translated">Соответственно, правила количественной оценки вида в контекстах более высокого ранга немного изменились. В GHC 7, если вид переменный было упомянуто впервые в виде переменного , связанных в не-верхнем уровне &lt;code&gt;forall&lt;/code&gt; , вид переменный была связанно там, тоже. То есть, в &lt;code&gt;f :: (forall (a :: k). ...) -&amp;gt; ...&lt;/code&gt; , то &lt;code&gt;k&lt;/code&gt; был связан тем же &lt;code&gt;forall&lt;/code&gt; , как &lt;code&gt;a&lt;/code&gt; . Однако в GHC 8 все переменные типа, упомянутые в типе, связаны на самом внешнем уровне. Если вы хотите, чтобы один был связан с более высоким рангом для &lt;code&gt;forall&lt;/code&gt; , включите его явно.</target>
        </trans-unit>
        <trans-unit id="1bb0023c7c1fa4cd60dd0df32c9589498220f1d0" translate="yes" xml:space="preserve">
          <source>Accordingly, the type environment seen by &lt;code&gt;reify&lt;/code&gt; includes all the top-level declarations up to the end of the immediately preceding declaration group, but no more.</source>
          <target state="translated">Соответственно, среда типов, которую видит &lt;code&gt;reify&lt;/code&gt; , включает все объявления верхнего уровня до конца непосредственно предшествующей группы объявлений, но не более того.</target>
        </trans-unit>
        <trans-unit id="82bedfe88009972d90237d52b7f414b23e6d5eb6" translate="yes" xml:space="preserve">
          <source>Accum</source>
          <target state="translated">Accum</target>
        </trans-unit>
        <trans-unit id="50b4f3d88aa3c9059e12c063f7c950d2f9b4b778" translate="yes" xml:space="preserve">
          <source>Accum operations</source>
          <target state="translated">Аккумулятивные операции</target>
        </trans-unit>
        <trans-unit id="cd4bf7ea6fd4060189e1e1baaa24ebb42d7660ad" translate="yes" xml:space="preserve">
          <source>AccumT</source>
          <target state="translated">AccumT</target>
        </trans-unit>
        <trans-unit id="50412c7500ef5d04ef8c2e37d60a2b1db38c9207" translate="yes" xml:space="preserve">
          <source>Accumulating maps</source>
          <target state="translated">Накопительные карты</target>
        </trans-unit>
        <trans-unit id="97c89a4d6630adeb18fa12ba9976a31413fe293e" translate="yes" xml:space="preserve">
          <source>Action</source>
          <target state="translated">Action</target>
        </trans-unit>
        <trans-unit id="6347206826a895475f5f91774a889e897ffc7d63" translate="yes" xml:space="preserve">
          <source>Action &lt;code&gt;askString&lt;/code&gt; requests user to enter a string, and passes it to the continuation. &lt;code&gt;askString&lt;/code&gt; takes as a parameter a continuation taking a string parameter, and returning &lt;code&gt;IO ()&lt;/code&gt;. Compare its signature to &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:runContT&quot;&gt;runContT&lt;/a&gt;&lt;/code&gt; definition.</source>
          <target state="translated">Действие &lt;code&gt;askString&lt;/code&gt; просит пользователя ввести строку и передает ее продолжению. &lt;code&gt;askString&lt;/code&gt; принимает в качестве параметра продолжение, принимающее строковый параметр и возвращающее &lt;code&gt;IO ()&lt;/code&gt; . Сравните его подпись с определением &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:runContT&quot;&gt;runContT&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2f1b38e49644d95f7b46650e509c991d77060f8" translate="yes" xml:space="preserve">
          <source>Action to be executed</source>
          <target state="translated">Действие,которое должно быть выполнено</target>
        </trans-unit>
        <trans-unit id="f5278c8649d913f335c11a62f866017db4429c6b" translate="yes" xml:space="preserve">
          <source>Actions on directories</source>
          <target state="translated">Действия по каталогам</target>
        </trans-unit>
        <trans-unit id="696ed90b8efd0baea13c573b2e7c286d011d6b3c" translate="yes" xml:space="preserve">
          <source>Actions on files</source>
          <target state="translated">Действия с файлами</target>
        </trans-unit>
        <trans-unit id="7083b72c48cfaf651eebc9aa10754311beefc8de" translate="yes" xml:space="preserve">
          <source>Activate cross-compilation mode (see &lt;a href=&quot;#hsc2hs-cross&quot;&gt;Cross-compilation&lt;/a&gt;).</source>
          <target state="translated">Активируйте режим кросс-компиляции (см. &lt;a href=&quot;#hsc2hs-cross&quot;&gt;Кросс-компиляция&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="583d9a705b86bbdfe3e1d9047b3ea1485ccadeeb" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; except when the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; refers to a symbolic link. In that case the &lt;code&gt;FileStatus&lt;/code&gt; information of the symbolic link itself is returned instead of that of the file it points to.</source>
          <target state="translated">Действует как &lt;code&gt;&lt;a href=&quot;system-posix-files#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; , за исключением случаев, когда &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; ссылается на символическую ссылку. В этом случае &lt;code&gt;FileStatus&lt;/code&gt; информация FileStatus самой символической ссылки вместо файла, на который она указывает.</target>
        </trans-unit>
        <trans-unit id="7d65523818024ea88107f6287927f036ddf6afd4" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; except when the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; refers to a symbolic link. In that case the &lt;code&gt;FileStatus&lt;/code&gt; information of the symbolic link itself is returned instead of that of the file it points to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb8dd245b9cb57f179bf3b4b88042343c063795" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; but does not follow symlinks (and thus changes permissions on the link itself).</source>
          <target state="translated">Действует как &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; , но не следует символическим ссылкам (и, таким образом, изменяет права доступа к самой ссылке).</target>
        </trans-unit>
        <trans-unit id="00b98c6571c6f97fdd25d5e837fe03213c325e22" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; except when the &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; refers to a symbolic link. In that case the &lt;code&gt;FileStatus&lt;/code&gt; information of the symbolic link itself is returned instead of that of the file it points to.</source>
          <target state="translated">Действует как &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; , за исключением случаев, когда &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; ссылается на символическую ссылку. В этом случае &lt;code&gt;FileStatus&lt;/code&gt; информация FileStatus самой символической ссылки вместо файла, на который она указывает.</target>
        </trans-unit>
        <trans-unit id="cbcea92f66c4289d12fcd3463f6bb4e3fab3bda6" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; but does not follow symlinks (and thus changes permissions on the link itself).</source>
          <target state="translated">Действует как &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; , но не следует символическим ссылкам (и, таким образом, изменяет права доступа к самой ссылке).</target>
        </trans-unit>
        <trans-unit id="6a6c3ff29419f1c7034849f1db0a070b794f9ad2" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setFileSize&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Действует как &lt;code&gt;setFileSize&lt;/code&gt; , но использует дескриптор файла вместо &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49be567080d7b410e84b47729961520e4de920c4" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setFileSize&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4b7078adb2d96736d050720e01d8ae82392b27c" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setOwnerAndGroup&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Действует как &lt;code&gt;setOwnerAndGroup&lt;/code&gt; , но использует дескриптор файла вместо &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f40c80358e12a1e2aaf02b1148d6c20fcfd4ba45" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setOwnerAndGroup&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce17679436ea260fadec4591a677de22164d0f8" translate="yes" xml:space="preserve">
          <source>Actually &lt;code&gt;hsc2hs&lt;/code&gt; does not output the Haskell file directly. It creates a C program that includes the headers, gets automatically compiled and run. That program outputs the Haskell code.</source>
          <target state="translated">На самом деле &lt;code&gt;hsc2hs&lt;/code&gt; не выводит файл Haskell напрямую. Он создает программу на C, которая включает заголовки, автоматически компилируется и запускается. Эта программа выводит код Haskell.</target>
        </trans-unit>
        <trans-unit id="eb4c8a6633849d6709d07c9f3e63104f63a51077" translate="yes" xml:space="preserve">
          <source>Add a finalizer that will run in the Q monad after the current module has been type checked. This only makes sense when run within a top-level splice.</source>
          <target state="translated">Добавьте финализатор,который будет работать в Q-монаде после того,как текущий модуль будет проверен на тип.Это имеет смысл только в том случае,если запуск осуществляется в рамках сращивания верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="de0de177dcddf4173fd744c404b8ba61f96637ed" translate="yes" xml:space="preserve">
          <source>Add a finalizer to an &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; (GHC only). See &lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt; and &lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt; for more about finalizers.</source>
          <target state="translated">Добавьте финализатор в &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; (только GHC). См. &lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt; и &lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt; для получения дополнительной информации о финализаторах.</target>
        </trans-unit>
        <trans-unit id="87eb63d6dca38f792891dceb6d3068ba951d4549" translate="yes" xml:space="preserve">
          <source>Add a line to the history unless it matches the previously recorded line.</source>
          <target state="translated">Добавьте строку в историю,если она не совпадает с ранее записанной строкой.</target>
        </trans-unit>
        <trans-unit id="aaca03fa0d32c5a3d402a6fb5fcc0ded2bb915ec" translate="yes" xml:space="preserve">
          <source>Add a line to the history, and remove all previous entries which are the same as it.</source>
          <target state="translated">Добавьте строку в историю и удалите все предыдущие записи.</target>
        </trans-unit>
        <trans-unit id="1d7fd5dfa46b0f645d5db42f20504f6c3caf7358" translate="yes" xml:space="preserve">
          <source>Add a trailing file path separator if one is not already present.</source>
          <target state="translated">Добавьте разделитель путей к файлу,если его еще нет.</target>
        </trans-unit>
        <trans-unit id="c5f1a8ca3a641a6b0ef6dbe461171ca7f604eb5a" translate="yes" xml:space="preserve">
          <source>Add additional top-level declarations. The added declarations will be type checked along with the current declaration group.</source>
          <target state="translated">Добавьте дополнительные декларации высшего уровня.Добавленные декларации будут проверяться на тип вместе с текущей группой деклараций.</target>
        </trans-unit>
        <trans-unit id="cecd1aea8fe88c39fcc8f71681a3e087791c984b" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Добавьте расширение, эквивалентное &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt; , Даже если оно уже есть .</target>
        </trans-unit>
        <trans-unit id="34878ebb3f1e96601aafa913d00d7bd263cdc36c" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Добавьте расширение, даже если оно уже есть, эквивалентное &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89357b09335d29d387cf17547863b974b8decc59" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Добавьте расширение, эквивалентное &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt; , Даже если оно уже есть .</target>
        </trans-unit>
        <trans-unit id="12e0f266814b31f57d2a4d4f2e065ebded03e6c4" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Добавьте расширение, даже если оно уже есть, эквивалентное &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88bd486d89c4fede722e2d2391a03c0fd1f29c23" translate="yes" xml:space="preserve">
          <source>Add entries to the Static Pointer Table</source>
          <target state="translated">Добавить записи в таблицу статических указателей</target>
        </trans-unit>
        <trans-unit id="573b000c455e2582361374a0f2d5ce932b4443a5" translate="yes" xml:space="preserve">
          <source>Add months (clipped to last day), then add days</source>
          <target state="translated">Добавьте месяцы (вырезанные на последний день),затем добавьте дни.</target>
        </trans-unit>
        <trans-unit id="11f2dacfd6ba9147a205050f051361aedae62583" translate="yes" xml:space="preserve">
          <source>Add months (rolling over to next month), then add days</source>
          <target state="translated">Добавьте месяцы (переход на следующий месяц),затем добавьте дни.</target>
        </trans-unit>
        <trans-unit id="b015364a9bf90321fb61c3a98f1cdc612fdf7a8d" translate="yes" xml:space="preserve">
          <source>Add months, with days past the last day of the month clipped to the last day. For instance, 2005-01-30 + 1 month = 2005-02-28.</source>
          <target state="translated">Добавьте месяцы,при этом дни,прошедшие после последнего дня месяца,вырезаются до последнего дня.Например,2005-01-30+1 месяц=2005-02-28.</target>
        </trans-unit>
        <trans-unit id="1ce9d4dd3c00c35abdeda445f12f814c42604388" translate="yes" xml:space="preserve">
          <source>Add months, with days past the last day of the month rolling over to the next month. For instance, 2005-01-30 + 1 month = 2005-03-02.</source>
          <target state="translated">Добавьте месяцы,при этом дни,прошедшие после последнего дня месяца,переносятся на следующий месяц.Например,2005-01-30+1 месяц=2005-03-02.</target>
        </trans-unit>
        <trans-unit id="45aa2700c673ebfa0acebc5efea925be3a17cb6f" translate="yes" xml:space="preserve">
          <source>Add one to the given number using the state monad:</source>
          <target state="translated">Добавьте один к данному номеру с помощью государственного монада:</target>
        </trans-unit>
        <trans-unit id="ad0277793f67d2e393175d08b52db34131c5ef10" translate="yes" xml:space="preserve">
          <source>Add signed integers reporting overflow. First member of result is the sum truncated to an &lt;code&gt;Int#&lt;/code&gt;; second member is zero if the true sum fits in an &lt;code&gt;Int#&lt;/code&gt;, nonzero if overflow occurred (the sum is either too large or too small to fit in an &lt;code&gt;Int#&lt;/code&gt;).</source>
          <target state="translated">Добавить целые числа со знаком, сообщающие о переполнении. Первый член результата - это сумма, усеченная до &lt;code&gt;Int#&lt;/code&gt; ; второй член равен нулю, если истинная сумма умещается в &lt;code&gt;Int#&lt;/code&gt; , ненулевой, если произошло переполнение (сумма слишком велика или слишком мала, чтобы поместиться в &lt;code&gt;Int#&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b0fcd5e56314036018a9f0cac00e78ef55a1787b" translate="yes" xml:space="preserve">
          <source>Add some helper code that starts up and shuts down the Haskell RTS:</source>
          <target state="translated">Добавьте вспомогательный код,который запускает и отключает Haskell RTS:</target>
        </trans-unit>
        <trans-unit id="985586c7f3031f00d6269e644d3adc10e6ea07bc" translate="yes" xml:space="preserve">
          <source>Add the &lt;code&gt;-s [⟨file⟩]&lt;/code&gt; RTS option when running the program to see timing stats, which will help to tell you whether your program got faster by using more CPUs or not. If the user time is greater than the elapsed time, then the program used more than one CPU. You should also run the program without &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; for comparison.</source>
          <target state="translated">Добавьте параметр &lt;code&gt;-s [⟨file⟩]&lt;/code&gt; RTS при запуске программы, чтобы увидеть статистику времени, которая поможет вам узнать, стала ли ваша программа быстрее за счет использования большего количества процессоров или нет. Если пользовательское время больше прошедшего времени, значит, программа использовала более одного процессора. Вы также должны запустить программу без &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt; для сравнения.</target>
        </trans-unit>
        <trans-unit id="343b1a229f6a10110d459f27e6591278cc0810b3" translate="yes" xml:space="preserve">
          <source>Add the global package database on top of the current stack. This option can be used after &lt;a href=&quot;#ghc-flag--no-global-package-db&quot;&gt;&lt;code&gt;-no-global-package-db&lt;/code&gt;&lt;/a&gt; to specify the position in the stack where the global package database should be loaded.</source>
          <target state="translated">Добавьте глобальную базу данных пакетов поверх текущего стека. Этот параметр можно использовать после &lt;a href=&quot;#ghc-flag--no-global-package-db&quot;&gt; &lt;code&gt;-no-global-package-db&lt;/code&gt; ,&lt;/a&gt; чтобы указать позицию в стеке, куда должна быть загружена глобальная база данных пакетов.</target>
        </trans-unit>
        <trans-unit id="24dc1f25cbb780084188d4ff897a81d5104622f0" translate="yes" xml:space="preserve">
          <source>Add the global package db to the stack.</source>
          <target state="translated">Добавить глобальный пакет db в стек.</target>
        </trans-unit>
        <trans-unit id="fe975763255492732af82ca06ecb5eda5e5fa904" translate="yes" xml:space="preserve">
          <source>Add the package database ⟨file⟩ on top of the current stack.</source>
          <target state="translated">Добавить базу данных пакетов ⟨file⟩ поверх текущего стека.</target>
        </trans-unit>
        <trans-unit id="6134bf2d1b2295efc8fa6b7e828ec4d22ba2e38e" translate="yes" xml:space="preserve">
          <source>Add the user&amp;rsquo;s package database on top of the current stack. This option can be used after &lt;a href=&quot;#ghc-flag--no-user-package-db&quot;&gt;&lt;code&gt;-no-user-package-db&lt;/code&gt;&lt;/a&gt; to specify the position in the stack where the user&amp;rsquo;s package database should be loaded.</source>
          <target state="translated">Добавьте базу данных пакетов пользователя поверх текущего стека. Этот параметр можно использовать после &lt;a href=&quot;#ghc-flag--no-user-package-db&quot;&gt; &lt;code&gt;-no-user-package-db&lt;/code&gt; ,&lt;/a&gt; чтобы указать позицию в стеке, куда должна быть загружена база данных пакетов пользователя.</target>
        </trans-unit>
        <trans-unit id="30d336c4a71c8e660819935f8d9b591c05d3839d" translate="yes" xml:space="preserve">
          <source>Add the user&amp;rsquo;s package db to the stack.</source>
          <target state="translated">Добавить пакет пользователя db в стек.</target>
        </trans-unit>
        <trans-unit id="f0c714c0819e829fa65b99edbce416f762fa1cd5" translate="yes" xml:space="preserve">
          <source>Add the user's package db to the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e83704b0c13e474a873f78d2503ff9d5058a2e" translate="yes" xml:space="preserve">
          <source>Add two &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">Добавить два &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; s</target>
        </trans-unit>
        <trans-unit id="42140a41e27de0c19e086f86091f816243e8209e" translate="yes" xml:space="preserve">
          <source>Add two non-negative numbers. Errors out on overflow.</source>
          <target state="translated">Добавьте два неотрицательных числа.Ошибки при переполнении.</target>
        </trans-unit>
        <trans-unit id="e2856c1714aa39e0ac4378840b55f10a1492a342" translate="yes" xml:space="preserve">
          <source>Add two vectors element-wise.</source>
          <target state="translated">Добавьте два вектора по элементам.</target>
        </trans-unit>
        <trans-unit id="d21ffb0b2e887326fe4eaccd172c45b78c0f6321" translate="yes" xml:space="preserve">
          <source>Add unsigned integers reporting overflow. The first element of the pair is the result. The second element is the carry flag, which is nonzero on overflow. See also &lt;code&gt;plusWord2#&lt;/code&gt;.</source>
          <target state="translated">Добавьте целые числа без знака, сообщающие о переполнении. Первый элемент пары - результат. Второй элемент - это флаг переноса, который не равен нулю при переполнении. См. Также &lt;code&gt;plusWord2#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4224f11c255c4982dd554902608b0a229771245f" translate="yes" xml:space="preserve">
          <source>Add unsigned integers, with the high part (carry) in the first component of the returned pair and the low part in the second component of the pair. See also &lt;code&gt;addWordC#&lt;/code&gt;.</source>
          <target state="translated">Добавьте беззнаковые целые числа, причем старшая часть (перенос) находится в первом компоненте возвращаемой пары, а младшая часть - во втором компоненте пары. См. Также &lt;code&gt;addWordC#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7bc6acbb336def5a2fed21adc84cf2eba8c8695" translate="yes" xml:space="preserve">
          <source>Add years, matching month and day, with Feb 29th clipped to Feb 28th if necessary. For instance, 2004-02-29 + 2 years = 2006-02-28.</source>
          <target state="translated">Добавьте годы,соответствующий месяц и день,с 29 февраля клипом до 28 февраля,если это необходимо.Например,2004-02-29+2 года=2006-02-28.</target>
        </trans-unit>
        <trans-unit id="00a5a0f630ddf36709167f1d67babdf5ba438d3b" translate="yes" xml:space="preserve">
          <source>Add years, matching month and day, with Feb 29th rolled over to Mar 1st if necessary. For instance, 2004-02-29 + 2 years = 2006-03-01.</source>
          <target state="translated">Добавьте годы,соответствующий месяц и день,с 29 февраля переверните на 1 марта,если это необходимо.Например,2004-02-29+2 года=2006-03-01.</target>
        </trans-unit>
        <trans-unit id="b78eacb0dc09583fbc5860e25537c0fbd17b2217" translate="yes" xml:space="preserve">
          <source>Add ⟨dir⟩ to the directory search list for &lt;code&gt;#include&lt;/code&gt; files</source>
          <target state="translated">Добавить dir⟩ в список поиска каталогов для файлов &lt;code&gt;#include&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3af3cf99d9bd473db5a8f166f611704c815a0e2a" translate="yes" xml:space="preserve">
          <source>Add ⟨dir⟩ to the list of directories searched for libraries</source>
          <target state="translated">Добавить ⟨dir⟩ в список каталогов,в которых ведется поиск библиотек.</target>
        </trans-unit>
        <trans-unit id="22a6f927fd045f27916f2841389ceb5619f2f520" translate="yes" xml:space="preserve">
          <source>Add ⟨file⟩ to the package db stack.</source>
          <target state="translated">Добавить ⟨file⟩ в стек пакетов db.</target>
        </trans-unit>
        <trans-unit id="fd862d70f0a0e1b3f98b9cfd9a82f7a12719414c" translate="yes" xml:space="preserve">
          <source>Add ⟨module⟩(s) to the current target set, and perform a reload. Normally pre-compiled code for the module will be loaded if available, or otherwise the module will be compiled to byte-code. Using the &lt;code&gt;*&lt;/code&gt; prefix forces the module to be loaded as byte-code.</source>
          <target state="translated">Добавьте &amp;laquo;модули&amp;raquo; к текущему целевому набору и выполните перезагрузку. Обычно предварительно скомпилированный код для модуля будет загружен, если он доступен, в противном случае модуль будет скомпилирован в байт-код. Использование префикса &lt;code&gt;*&lt;/code&gt; заставляет модуль загружаться как байт-код.</target>
        </trans-unit>
        <trans-unit id="d5c0d264184b29e5240b822c85a976bae183083b" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;~&lt;/code&gt; in front of &lt;code&gt;x&lt;/code&gt; gives the regular lazy behavior.</source>
          <target state="translated">Добавление &lt;code&gt;~&lt;/code&gt; перед &lt;code&gt;x&lt;/code&gt; дает обычное ленивое поведение.</target>
        </trans-unit>
        <trans-unit id="320069f40befc715427528e74af5fccc8e33c273" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;~&lt;/code&gt; in front of &lt;code&gt;x&lt;/code&gt; gives the regular lazy behavior. The general rule is that we add an implicit bang on the outermost pattern, unless disabled with &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">Добавление &lt;code&gt;~&lt;/code&gt; перед &lt;code&gt;x&lt;/code&gt; дает обычное ленивое поведение. Общее правило состоит в том, что мы добавляем неявный удар по внешнему шаблону, если он не отключен с помощью &lt;code&gt;~&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d83058e490d2d8e416a97aa6b2da12e694c423cc" translate="yes" xml:space="preserve">
          <source>Adding a new kind of pure computation to an applicative functor.</source>
          <target state="translated">Добавление нового вида чистых вычислений в прикладные функции.</target>
        </trans-unit>
        <trans-unit id="3e22ec51f6417f07ed5484e9c1f31e458834a41e" translate="yes" xml:space="preserve">
          <source>Adding a type signature dramatically changes the result! This is a rather counter-intuitive phenomenon, worth watching out for.</source>
          <target state="translated">Добавление типовой подписи кардинально меняет результат! Это довольно интуитивное явление,на которое стоит обратить внимание.</target>
        </trans-unit>
        <trans-unit id="99385bb5ea9d50b509bba76a80c6d5cf02fdad9b" translate="yes" xml:space="preserve">
          <source>Adding the optional &amp;ldquo;&lt;code&gt;!&lt;/code&gt;&amp;rdquo; turns type errors into warnings while loading. This allows to use the portions of the module that are correct, even if there are type errors in some definitions. Effectively, the &amp;ldquo;-fdefer-type-errors&amp;rdquo; flag is set before loading and unset after loading if the flag has not already been set before. See &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt; for further motivation and details.</source>
          <target state="translated">Добавление необязательного &amp;laquo; &lt;code&gt;!&lt;/code&gt; &amp;raquo;Превращает ошибки типа в предупреждения при загрузке. Это позволяет использовать правильные части модуля, даже если в некоторых определениях есть ошибки типа. Фактически, флаг &amp;laquo;-fdefer-type-errors&amp;raquo; устанавливается перед загрузкой и сбрасывается после загрузки, если этот флаг еще не был установлен ранее. Дополнительные сведения и мотивацию см. В разделе &amp;laquo; &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;Откладывание ошибок типа на время выполнения&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00f220c3a56210a9843d04890d61a40e6f8811dd" translate="yes" xml:space="preserve">
          <source>Addition of type-level naturals.</source>
          <target state="translated">Добавление натуральных веществ на уровне типа.</target>
        </trans-unit>
        <trans-unit id="1d55c4561961d726b476a4d113ce4ac1271e1f3d" translate="yes" xml:space="preserve">
          <source>Additional &lt;code&gt;Integer&lt;/code&gt; operations</source>
          <target state="translated">Дополнительные &lt;code&gt;Integer&lt;/code&gt; операции</target>
        </trans-unit>
        <trans-unit id="452f31724597f25fbb7b21a77fe4b6fccc9c9f11" translate="yes" xml:space="preserve">
          <source>Additional arguments to the pre-processor can be passed in using the &lt;a href=&quot;#ghc-flag--optF%20%E2%9F%A8option%E2%9F%A9&quot;&gt;&lt;code&gt;-optF ⟨option⟩&lt;/code&gt;&lt;/a&gt; option. These are fed to ⟨cmd⟩ on the command line after the three standard input and output arguments.</source>
          <target state="translated">Дополнительные аргументы препроцессору можно передать с помощью параметра &lt;a href=&quot;#ghc-flag--optF%20%E2%9F%A8option%E2%9F%A9&quot;&gt; &lt;code&gt;-optF ⟨option⟩&lt;/code&gt; &lt;/a&gt; . Они передаются в &amp;laquo;cmd&amp;raquo; в командной строке после трех стандартных аргументов ввода и вывода.</target>
        </trans-unit>
        <trans-unit id="ba84f116cccb8aaddf33910d85c19273f9b5c33d" translate="yes" xml:space="preserve">
          <source>Additional conversion operations to &lt;code&gt;Integer&lt;/code&gt;</source>
          <target state="translated">Дополнительные операции преобразования в &lt;code&gt;Integer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05dd2fde350699cecd8602584538e2a5301a7997" translate="yes" xml:space="preserve">
          <source>Additional functions for deconstructing sequences are available via the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Дополнительные функции для деконструируя последовательностей доступны через &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; экземпляр &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cf2915563496656545c5e0888c8da42599eb5f8" translate="yes" xml:space="preserve">
          <source>Additional functions for deconstructing sequences are available via the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33810ea2f256277dbeeee354b4b9748e64cd54e7" translate="yes" xml:space="preserve">
          <source>Additional generic representation type constructors</source>
          <target state="translated">Дополнительные конструкторы типа общего представления</target>
        </trans-unit>
        <trans-unit id="fefa8177b546e09c697ef3ccda7dfb9a8468dadd" translate="yes" xml:space="preserve">
          <source>Additional submodules</source>
          <target state="translated">Дополнительные субмодули</target>
        </trans-unit>
        <trans-unit id="d5fc75cb6b2328204ad6e4f5c7b8aa1503974318" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;ghc-pkg list&lt;/code&gt; reminds you that there are broken packages and suggests &lt;code&gt;ghc-pkg check&lt;/code&gt;, which displays more information about the nature of the failure:</source>
          <target state="translated">Кроме того, &lt;code&gt;ghc-pkg list&lt;/code&gt; напоминает вам, что есть сломанные пакеты, и предлагает &lt;code&gt;ghc-pkg check&lt;/code&gt; , которая отображает дополнительную информацию о характере сбоя:</target>
        </trans-unit>
        <trans-unit id="4dc57812bc7acb080b8b1b3c9a8dc29f687921a8" translate="yes" xml:space="preserve">
          <source>Additionally, any files specified with &lt;a href=&quot;#ghc-flag--ghci-script&quot;&gt;&lt;code&gt;-ghci-script&lt;/code&gt;&lt;/a&gt; flags will be read after the standard files, allowing the use of custom .ghci files.</source>
          <target state="translated">Кроме того, любые файлы, указанные с &lt;a href=&quot;#ghc-flag--ghci-script&quot;&gt; &lt;code&gt;-ghci-script&lt;/code&gt; &lt;/a&gt; флагов -ghci-script, будут считываться после стандартных файлов, что позволяет использовать пользовательские файлы .ghci.</target>
        </trans-unit>
        <trans-unit id="8273902569bf382d8f68303982acb32861c6cbb8" translate="yes" xml:space="preserve">
          <source>Additionally, in function definitions, variables bound by matching earlier curried arguments may be used in view pattern expressions in later arguments:</source>
          <target state="translated">Кроме того,в определениях функций можно использовать переменные,ограниченные сопоставлением ранее выведенных аргументов,в выражениях шаблонов в более поздних аргументах:</target>
        </trans-unit>
        <trans-unit id="f89673843f1be6757860a64501f5bc027e357960" translate="yes" xml:space="preserve">
          <source>Additionally, the following flags are accepted by &lt;code&gt;ghc-pkg&lt;/code&gt;:</source>
          <target state="translated">Кроме того, &lt;code&gt;ghc-pkg&lt;/code&gt; принимает следующие флаги :</target>
        </trans-unit>
        <trans-unit id="6098dd57b05f9b5adb478e7eb1c70e1499221dae" translate="yes" xml:space="preserve">
          <source>Additionally, the use of &lt;a href=&quot;extending_ghc#annotation-pragmas&quot;&gt;annotations&lt;/a&gt; is forbidden, as that would allow bypassing Safe Haskell restrictions. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10826&quot;&gt;#10826&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea07a4f598cd1862ca91a8d811d4455a836c0db0" translate="yes" xml:space="preserve">
          <source>Additionally, the use of &lt;a href=&quot;extending_ghc#annotation-pragmas&quot;&gt;annotations&lt;/a&gt; is forbidden, as that would allow bypassing Safe Haskell restrictions. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10826&quot;&gt;Issue #10826&lt;/a&gt; for details.</source>
          <target state="translated">Кроме того, использование &lt;a href=&quot;extending_ghc#annotation-pragmas&quot;&gt;аннотаций&lt;/a&gt; запрещено, так как это позволит обойти ограничения Safe Haskell. Подробности см. В &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10826&quot;&gt;выпуске № 10826&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba7d071e5cf6b03c15819e3ffdf6a64a0ef17bfa" translate="yes" xml:space="preserve">
          <source>Additionally, this implementation places bitmaps in the leaves of the tree. Their size is the natural size of a machine word (32 or 64 bits) and greatly reduce memory footprint and execution times for dense sets, e.g. sets where it is likely that many values lie close to each other. The asymptotics are not affected by this optimization.</source>
          <target state="translated">Кроме того,эта реализация размещает растровые карты на листьях дерева.Их размер является естественным размером машинного слова (32 или 64 бита)и значительно сокращает объем памяти и время выполнения для плотных множеств,например,множеств,где,вероятно,многие значения лежат близко друг к другу.Асимптотика при такой оптимизации не затрагивается.</target>
        </trans-unit>
        <trans-unit id="9433cfd346f8c54358a2f7edce3cb77efb148924" translate="yes" xml:space="preserve">
          <source>Additionally, this implementation places bitmaps in the leaves of the tree. Their size is the natural size of a machine word (32 or 64 bits) and greatly reduces the memory footprint and execution times for dense sets, e.g. sets where it is likely that many values lie close to each other. The asymptotics are not affected by this optimization.</source>
          <target state="translated">Кроме того,эта реализация размещает растровые карты на листьях дерева.Их размер является естественным размером машинного слова (32 или 64 бита)и значительно сокращает объем памяти и время выполнения для плотных множеств,например,множеств,где,скорее всего,многие значения лежат близко друг к другу.Асимптотика при такой оптимизации не затрагивается.</target>
        </trans-unit>
        <trans-unit id="1bf2d76785594ad916dd8c2e5e99f51e13db7893" translate="yes" xml:space="preserve">
          <source>Additionally, unless &lt;code&gt;-hide-all-packages&lt;/code&gt; is specified &lt;code&gt;ghc&lt;/code&gt; will also look for the package environment in the following locations:</source>
          <target state="translated">Кроме того, если &lt;code&gt;-hide-all-packages&lt;/code&gt; не указан &lt;code&gt;ghc&lt;/code&gt; также будет выглядеть для окружающей среды упаковки в следующих местах:</target>
        </trans-unit>
        <trans-unit id="2aa983ad06fdb2dac09d7b6232814da70747e9ee" translate="yes" xml:space="preserve">
          <source>Additive</source>
          <target state="translated">Additive</target>
        </trans-unit>
        <trans-unit id="0d42cec26dbc762aafe43e05a50f969d0b7505d7" translate="yes" xml:space="preserve">
          <source>Addr</source>
          <target state="translated">Addr</target>
        </trans-unit>
        <trans-unit id="e78f3509a8a9919b87bca8268eb67a1992a398dd" translate="yes" xml:space="preserve">
          <source>Addr#</source>
          <target state="translated">Addr#</target>
        </trans-unit>
        <trans-unit id="9693f97edb3f213e60bf04638a2964d95c0a8e70" translate="yes" xml:space="preserve">
          <source>AddrRep</source>
          <target state="translated">AddrRep</target>
        </trans-unit>
        <trans-unit id="e1bcdaba63c737122befb027c96355aebd956e8a" translate="yes" xml:space="preserve">
          <source>Address range information necessary for efficient lookup in debug information.</source>
          <target state="translated">Адресная информация,необходимая для эффективного поиска в отладочной информации.</target>
        </trans-unit>
        <trans-unit id="2bea019ec2ca9ce8cba25638cef6e4ebf912a40d" translate="yes" xml:space="preserve">
          <source>Adds a core plugin to the compilation pipeline.</source>
          <target state="translated">Добавляет основной плагин к трубопроводу компиляции.</target>
        </trans-unit>
        <trans-unit id="f141d838836915fbdfd335ae66e883d10b2bee58" translate="yes" xml:space="preserve">
          <source>Adds a location description and maybe a file path and file handle to an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;. If any of the file handle or file path is not given the corresponding value in the &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; remains unaltered.</source>
          <target state="translated">Добавляет описание местоположения и, возможно, путь к файлу и дескриптор файла в &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; . Если какой-либо дескриптор файла или путь к файлу не заданы, соответствующее значение в &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; остается неизменным.</target>
        </trans-unit>
        <trans-unit id="14518bca79b10a8d6a6afac2dc2d74ba60c9789a" translate="yes" xml:space="preserve">
          <source>Adds an automatic &lt;code&gt;SCC&lt;/code&gt; annotation to all &lt;em&gt;call sites&lt;/em&gt;. This is particularly useful when using profiling for the purposes of generating stack traces; see the function &lt;a href=&quot;../libraries/base-4.13.0.0/debug-trace#v:traceShow&quot;&gt;Debug.Trace.traceShow&lt;/a&gt;, or the &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt;&lt;code&gt;-xc&lt;/code&gt;&lt;/a&gt; RTS flag (&lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;RTS options for hackers, debuggers, and over-interested souls&lt;/a&gt;) for more details.</source>
          <target state="translated">Добавляет автоматические аннотации &lt;code&gt;SCC&lt;/code&gt; ко всем &lt;em&gt;сайтам вызовов&lt;/em&gt; . Это особенно полезно при использовании профилирования для создания трассировки стека; см. функцию &lt;a href=&quot;../libraries/base-4.13.0.0/debug-trace#v:traceShow&quot;&gt;Debug.Trace.traceShow&lt;/a&gt; или флаг &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt; &lt;code&gt;-xc&lt;/code&gt; &lt;/a&gt; RTS ( &lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;параметры RTS для хакеров, отладчиков и чрезмерно заинтересованных душ&lt;/a&gt; ) для получения дополнительных сведений.</target>
        </trans-unit>
        <trans-unit id="4dd58b10c5df43531b5419e150eab3428f317659" translate="yes" xml:space="preserve">
          <source>Adds an automatic &lt;code&gt;SCC&lt;/code&gt; annotation to all &lt;em&gt;call sites&lt;/em&gt;. This is particularly useful when using profiling for the purposes of generating stack traces; see the function &lt;a href=&quot;../libraries/base-4.14.1.0/debug-trace#v:traceShow&quot;&gt;Debug.Trace.traceShow&lt;/a&gt;, or the &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt;&lt;code&gt;-xc&lt;/code&gt;&lt;/a&gt; RTS flag (&lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;RTS options for hackers, debuggers, and over-interested souls&lt;/a&gt;) for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4fd2a08806dfb482db344074817b7f6e5c01441" translate="yes" xml:space="preserve">
          <source>Adds ⟨file⟩ to the stack of package databases. Additionally, ⟨file⟩ will also be the database modified by a &lt;code&gt;register&lt;/code&gt;, &lt;code&gt;unregister&lt;/code&gt;, &lt;code&gt;expose&lt;/code&gt; or &lt;code&gt;hide&lt;/code&gt; command, unless it is overridden by a later &lt;code&gt;--package-db&lt;/code&gt;, &lt;code&gt;--user&lt;/code&gt; or &lt;code&gt;--global&lt;/code&gt; option.</source>
          <target state="translated">Добавляет &amp;laquo;файл&amp;raquo; в стек пакетов баз данных. Кроме того, ⟨file⟩ будет также база данных модифицируется в &lt;code&gt;register&lt;/code&gt; , &lt;code&gt;unregister&lt;/code&gt; , &lt;code&gt;expose&lt;/code&gt; или &lt;code&gt;hide&lt;/code&gt; команду, если оно не отменено позже &lt;code&gt;--package-db&lt;/code&gt; , &lt;code&gt;--user&lt;/code&gt; или &lt;code&gt;--global&lt;/code&gt; вариант.</target>
        </trans-unit>
        <trans-unit id="6b704187610182fd9bd374b8590aaa1ef187a2e9" translate="yes" xml:space="preserve">
          <source>Adjacency list representation of a graph, mapping each vertex to its list of successors.</source>
          <target state="translated">Представление списка адъюнктуры графика,сопоставляющего каждую вершину со своим списком преемников.</target>
        </trans-unit>
        <trans-unit id="b54a06cdf203c292a9600afc8f4877852335267a" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array</source>
          <target state="translated">Настройка размера массива</target>
        </trans-unit>
        <trans-unit id="90ae8e7c61f1d870875dbba75294d0ee30d78240" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array in the given pool.</source>
          <target state="translated">Настройте размер массива в данном пуле.</target>
        </trans-unit>
        <trans-unit id="0f13658ace97bdbb476bffd14472478597823d14" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array including an extra position for the end marker.</source>
          <target state="translated">Отрегулируйте размер массива,включая дополнительную позицию для конечного маркера.</target>
        </trans-unit>
        <trans-unit id="8f64f3b151b220c78b035080db416951b86c9133" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array with an end marker in the given pool.</source>
          <target state="translated">Настройте размер массива с конечным маркером в данном пуле.</target>
        </trans-unit>
        <trans-unit id="22c056b1203c0d0dbe4975dcb12541b083750969" translate="yes" xml:space="preserve">
          <source>Adjust the storage area for an element in the pool to the given size of the required type.</source>
          <target state="translated">Отрегулируйте место для хранения элемента в бассейне в соответствии с заданным размером требуемого типа.</target>
        </trans-unit>
        <trans-unit id="7b78d30e021c76a4d2cd9b8d7c83d0401635e998" translate="yes" xml:space="preserve">
          <source>Adjust the storage area for an element in the pool to the given size.</source>
          <target state="translated">Отрегулируйте место для хранения элемента в бассейне в соответствии с заданным размером.</target>
        </trans-unit>
        <trans-unit id="483b6c748f94c6096a813d4e1202da0abec1197a" translate="yes" xml:space="preserve">
          <source>Administration: errors, locations and IO</source>
          <target state="translated">Администрация:ошибки,местоположение и IO</target>
        </trans-unit>
        <trans-unit id="e796c7c730ff7dabd900a81e118126dd63495d56" translate="yes" xml:space="preserve">
          <source>Advance a pointer into an array by the given number of elements</source>
          <target state="translated">Продвинуть указатель в массив на заданное количество элементов.</target>
        </trans-unit>
        <trans-unit id="260fc09cb1bd463d426655ad971e67b80c27f04d" translate="yes" xml:space="preserve">
          <source>Advances the given address by the given offset in bytes.</source>
          <target state="translated">Аванс заданного адреса на заданное смещение в байтах.</target>
        </trans-unit>
        <trans-unit id="8295b736050208f7764a760aab4c1497c80f65b8" translate="yes" xml:space="preserve">
          <source>Advice</source>
          <target state="translated">Advice</target>
        </trans-unit>
        <trans-unit id="1f3b7ab3442ed00e15ed0541b2686cab5245f648" translate="yes" xml:space="preserve">
          <source>Advice parameter for &lt;code&gt;&lt;a href=&quot;system-posix-fcntl#v:fileAdvise&quot;&gt;fileAdvise&lt;/a&gt;&lt;/code&gt; operation.</source>
          <target state="translated">Параметр рекомендации для операции &lt;code&gt;&lt;a href=&quot;system-posix-fcntl#v:fileAdvise&quot;&gt;fileAdvise&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="641791da837ed200728e9e50c3a7a04bddd511ba" translate="yes" xml:space="preserve">
          <source>AdviceDontNeed</source>
          <target state="translated">AdviceDontNeed</target>
        </trans-unit>
        <trans-unit id="ea4292d4f711440375ee49d21953e80b5e52f970" translate="yes" xml:space="preserve">
          <source>AdviceNoReuse</source>
          <target state="translated">AdviceNoReuse</target>
        </trans-unit>
        <trans-unit id="74d7e2511ff18bffd6e754606fb5eef4017e56ae" translate="yes" xml:space="preserve">
          <source>AdviceNormal</source>
          <target state="translated">AdviceNormal</target>
        </trans-unit>
        <trans-unit id="81df8c0f743f838767314197c10a01806cad2ee1" translate="yes" xml:space="preserve">
          <source>AdviceRandom</source>
          <target state="translated">AdviceRandom</target>
        </trans-unit>
        <trans-unit id="ccfd39209774bc0bd28a1949494a57c9a708ab38" translate="yes" xml:space="preserve">
          <source>AdviceSequential</source>
          <target state="translated">AdviceSequential</target>
        </trans-unit>
        <trans-unit id="42c90330aa2e9c8f79a56b93334f2cee6565ec83" translate="yes" xml:space="preserve">
          <source>AdviceWillNeed</source>
          <target state="translated">AdviceWillNeed</target>
        </trans-unit>
        <trans-unit id="ed7d231de2d15caa7608638f366b36b040083e12" translate="yes" xml:space="preserve">
          <source>After &amp;ldquo;for each class constraint &lt;code&gt;(C t1 ... tn)&lt;/code&gt;&amp;rdquo;, add &amp;ldquo;or each quantified constraint &lt;code&gt;(forall as. context =&amp;gt; C t1 .. tn)&lt;/code&gt;&amp;ldquo;</source>
          <target state="translated">После &amp;laquo;для каждого ограничения класса &lt;code&gt;(C t1 ... tn)&lt;/code&gt; &amp;raquo; добавьте &amp;laquo;или каждого количественно определенного ограничения &lt;code&gt;(forall as. context =&amp;gt; C t1 .. tn)&lt;/code&gt; &amp;raquo;</target>
        </trans-unit>
        <trans-unit id="962b02c7a62413f64f2ece2fa9269c59c618e145" translate="yes" xml:space="preserve">
          <source>After &amp;ldquo;for each class constraint &lt;code&gt;(C t1 ... tn)&lt;/code&gt;&amp;rdquo;, add &amp;ldquo;or each quantified constraint &lt;code&gt;(forall as. context =&amp;gt; C t1 .. tn)&lt;/code&gt;&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b0f8ce28395257ee72603489cfcfd39f2ac90c3" translate="yes" xml:space="preserve">
          <source>After a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command, the current context is set to:</source>
          <target state="translated">После команды &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; текущий контекст устанавливается на:</target>
        </trans-unit>
        <trans-unit id="07383eb16f1578a01af993380c0758317c77da4a" translate="yes" xml:space="preserve">
          <source>After analysing this declaration, GHC will discover that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; can be kind-polymorphic, with &lt;code&gt;a :: k2 -&amp;gt; Type&lt;/code&gt; and &lt;code&gt;c :: k2&lt;/code&gt;. We thus infer the following kind:</source>
          <target state="translated">Проанализировав это объявление, GHC обнаружит, что &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; могут быть полиморфными по &lt;code&gt;a :: k2 -&amp;gt; Type&lt;/code&gt; с a :: k2 -&amp;gt; Type и &lt;code&gt;c :: k2&lt;/code&gt; . Таким образом, мы получаем следующий вид:</target>
        </trans-unit>
        <trans-unit id="43eb39a82773f2a643009be434c6a85d6547dd46" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCString&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">После вызова этой функции &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; разделяет базовый байтовый буфер с исходной &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . Таким образом, изменение &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; , либо на C, либо с помощью poke, вызовет изменение содержимого &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; , нарушив ссылочную прозрачность. Другие &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; , созданные путем совместного использования (например, созданные с помощью &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; ), также будут отражать эти изменения. Изменение &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; нарушит ссылочную прозрачность. Чтобы этого избежать, используйте &lt;code&gt;useAsCString&lt;/code&gt; , которая делает копию исходной &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f34b11d2d5cf5b9fa61ceda45199281dda85ee6f" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCStringLen&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">После вызова этой функции &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; разделяет нижележащий байтовый буфер с исходной &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . Таким образом, изменение &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; либо на C, либо с помощью &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; к изменению содержимого ByteString , нарушив ссылочную прозрачность. Другие &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; , созданные путем совместного использования (например, созданные с помощью &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; ), также будут отражать эти изменения. Изменение &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; нарушит ссылочную прозрачность. Чтобы этого избежать, используйте &lt;code&gt;useAsCStringLen&lt;/code&gt; , которая делает копию исходной &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82a058ea48e1049a3153e84c6e2e32200ba90877" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCString&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb3d574900104a74408c8731d7eda427531f654" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCStringLen&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6923804e768f3da3c4e34a50b537baa1cecaa53f" translate="yes" xml:space="preserve">
          <source>After expanding the synonym, &lt;code&gt;f&lt;/code&gt; has the legal (in GHC) type:</source>
          <target state="translated">После раскрытия синонима &lt;code&gt;f&lt;/code&gt; имеет допустимый (в GHC) тип:</target>
        </trans-unit>
        <trans-unit id="e94a959addb55b4d2ce5f3c538f5e0b4451a9198" translate="yes" xml:space="preserve">
          <source>After expanding the synonym, &lt;code&gt;foo&lt;/code&gt; has the legal (in GHC) type:</source>
          <target state="translated">После раскрытия синонима &lt;code&gt;foo&lt;/code&gt; имеет допустимый (в GHC) тип:</target>
        </trans-unit>
        <trans-unit id="06d0d43c4a9a4534a91da534db4a4831101176f7" translate="yes" xml:space="preserve">
          <source>After expanding type synonyms, GHC does validity checking on types, looking for the following malformedness which isn&amp;rsquo;t detected simply by kind checking:</source>
          <target state="translated">После расширения синонимов типов GHC выполняет проверку достоверности типов, ища следующие искажения, которые не обнаруживаются простой проверкой типа:</target>
        </trans-unit>
        <trans-unit id="0449647915398655b7a878613d9a9af3cfaf3fda" translate="yes" xml:space="preserve">
          <source>After running a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action there are three possibilities for what comes next:</source>
          <target state="translated">После выполнения действия &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; есть три возможности для дальнейших действий:</target>
        </trans-unit>
        <trans-unit id="f4bbb708c55cef458c6b0bed0fa5801c96a405ff" translate="yes" xml:space="preserve">
          <source>After starting &lt;code&gt;remote-iserv ⟨tmp_dir⟩ ⟨port⟩&lt;/code&gt; on the target and providing it with a temporary folder (where it will copy the necessary libraries to load to) and port it will listen for the proxy to connect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f8861d66315ce749c004b7e24b472e22e1345c7" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve finished invoking our Haskell functions, we can call &lt;code&gt;hs_exit()&lt;/code&gt;, which terminates the RTS.</source>
          <target state="translated">После того, как мы закончили вызывать наши функции Haskell, мы можем вызвать &lt;code&gt;hs_exit()&lt;/code&gt; , что завершит RTS.</target>
        </trans-unit>
        <trans-unit id="2fa08ab3cb629ae0630f4dccf9a63999f34ccc01" translate="yes" xml:space="preserve">
          <source>Again, if &lt;code&gt;C&lt;/code&gt; contains no class methods, the instance context will be redundant, so GHC will instead generate &lt;code&gt;instance C c_1 c_2 ... c_(m-1) (N n_1 n_2 ... n_q)&lt;/code&gt;.</source>
          <target state="translated">Опять же, если &lt;code&gt;C&lt;/code&gt; не содержит методов класса, контекст экземпляра будет избыточным, поэтому GHC вместо этого сгенерирует &lt;code&gt;instance C c_1 c_2 ... c_(m-1) (N n_1 n_2 ... n_q)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80611142c1da75771c803bc1306de5dd47e954cb" translate="yes" xml:space="preserve">
          <source>Alexander Berntsen 2014</source>
          <target state="translated">Александр Бернцен 2014</target>
        </trans-unit>
        <trans-unit id="0f9d329fecfee776bcba1d14e6bca4840fae8ece" translate="yes" xml:space="preserve">
          <source>Algebraic data types specified in a signature cannot be implemented using pattern synonyms. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12717&quot;&gt;#12717&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70df90ba28c32aa3934681405622b497740ae050" translate="yes" xml:space="preserve">
          <source>Algebraic data types specified in a signature cannot be implemented using pattern synonyms. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12717&quot;&gt;Issue #12717&lt;/a&gt;</source>
          <target state="translated">Алгебраические типы данных, указанные в подписи, не могут быть реализованы с использованием синонимов шаблонов. См. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12717&quot;&gt;Выпуск № 12717.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a995fe628ebfb0ac7cc0c0b98a66a1d60308575a" translate="yes" xml:space="preserve">
          <source>Algebraic properties:</source>
          <target state="translated">Алгебраические свойства:</target>
        </trans-unit>
        <trans-unit id="00fe36cee0a001e71e45449595c2a673824d1b79" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biasum&quot;&gt;biasum&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Псевдоним &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biasum&quot;&gt;biasum&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="308d7f644aaa00a5665368fb713217dcb84b51ce" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifor_&quot;&gt;bifor_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Псевдоним для &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifor_&quot;&gt;bifor_&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cdf35744dcefb67854cfd9303dbe37b27518062" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bisequence_&quot;&gt;bisequence_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Псевдоним для &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bisequence_&quot;&gt;bisequence_&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="107c8c77b99ddea22e0d4483b070454ccd2a71ae" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Псевдоним для &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23f78602884a7b538f91b984806e37d22c871f3b" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Псевдоним для &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c1b2d82c320084f6a2ecaa9b2bb2ee948dec368" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bisequence&quot;&gt;bisequence&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Псевдоним для &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bisequence&quot;&gt;bisequence&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60cc1b8e67da53fd1ea040fa3bfb7016cc924b7f" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Псевдоним для &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc75b7adfd72cadf1d0c28de54a66b5886fa0528" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;ghc-exts#v:tagToEnum-35-&quot;&gt;tagToEnum#&lt;/a&gt;&lt;/code&gt;. Returns True if its parameter is 1# and False if it is 0#.</source>
          <target state="translated">Псевдоним для &lt;code&gt;&lt;a href=&quot;ghc-exts#v:tagToEnum-35-&quot;&gt;tagToEnum#&lt;/a&gt;&lt;/code&gt; . Возвращает True, если его параметр равен 1 #, и False, если он равен 0 #.</target>
        </trans-unit>
        <trans-unit id="b5417a2480ca72a7d0a8e8c2b271f31533da5d02" translate="yes" xml:space="preserve">
          <source>Align functions at given boundary.</source>
          <target state="translated">Функции выравнивания на заданной границе.</target>
        </trans-unit>
        <trans-unit id="309cb56d1cbd5360ce8e4fa89688161c57474b68" translate="yes" xml:space="preserve">
          <source>Align functions to multiples of the given value. Only valid values are powers of two.</source>
          <target state="translated">Выравнивание функций по кратным числам заданного значения.Только действительные значения имеют силу двойки.</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="be7cbc9171e2709ef932f92879b2fa92b735095e" translate="yes" xml:space="preserve">
          <source>All are based directly on their similarly-named &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt; counterparts.</source>
          <target state="translated">Все они основаны непосредственно на своих аналогах &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt; с аналогичным названием .</target>
        </trans-unit>
        <trans-unit id="a6cd8f76353135f8eca4c08f035ed3722d4ad99a" translate="yes" xml:space="preserve">
          <source>All arithmetic is performed modulo 2^n, where &lt;code&gt;n&lt;/code&gt; is the number of bits in the type.</source>
          <target state="translated">Вся арифметика выполняется по модулю 2 ^ n, где &lt;code&gt;n&lt;/code&gt; - количество бит в типе.</target>
        </trans-unit>
        <trans-unit id="5c996c3cc62dedfc6f0f7accd3202c5cbe66b76c" translate="yes" xml:space="preserve">
          <source>All arithmetic is performed modulo 2^n, where n is the number of bits in the type. One non-obvious consequence of this is that &lt;code&gt;&lt;a href=&quot;prelude#v:negate&quot;&gt;negate&lt;/a&gt;&lt;/code&gt; should &lt;em&gt;not&lt;/em&gt; raise an error on negative arguments.</source>
          <target state="translated">Вся арифметика выполняется по модулю 2 ^ n, где n - количество бит в типе. Одно неочевидное следствие этого состоит в том, что &lt;code&gt;&lt;a href=&quot;prelude#v:negate&quot;&gt;negate&lt;/a&gt;&lt;/code&gt; &lt;em&gt; не&lt;/em&gt; должно вызывать ошибку для отрицательных аргументов.</target>
        </trans-unit>
        <trans-unit id="0cb70b7dc62c8932f9a5fdafd462f49e1a9ac846" translate="yes" xml:space="preserve">
          <source>All data that is read will be decoded as UTF-8.</source>
          <target state="translated">Все прочитанные данные будут декодированы как UTF-8.</target>
        </trans-unit>
        <trans-unit id="63944b6a06201ae38dfb9a4d0c8e79dcd222ae47" translate="yes" xml:space="preserve">
          <source>All formats</source>
          <target state="translated">Все форматы</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
