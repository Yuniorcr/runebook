<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="bc89363b3d736091da072542a570e3138b391d30" translate="yes" xml:space="preserve">
          <source>The following uses of &lt;code&gt;unsafeCoerce#&lt;/code&gt; are supposed to work (i.e. not lead to spurious compile-time or run-time crashes):</source>
          <target state="translated">Следующие способы использования &lt;code&gt;unsafeCoerce#&lt;/code&gt; должны работать (т.е. не приводить к ложным сбоям во время компиляции или выполнения):</target>
        </trans-unit>
        <trans-unit id="1c72fa99c47cb70fcbd686ee80df427b2899a75e" translate="yes" xml:space="preserve">
          <source>The following will fail with an &amp;ldquo;Illegal unboxed tuple&amp;rdquo; error, since the derived instance produced by the compiler makes use of unboxed tuple syntax,</source>
          <target state="translated">Следующее приведет к ошибке &amp;laquo;Недопустимый распакованный кортеж&amp;raquo;, поскольку производный экземпляр, созданный компилятором, использует синтаксис распакованного кортежа:</target>
        </trans-unit>
        <trans-unit id="bbe044a46ef1c2c19252cc897f6025061c027f6f" translate="yes" xml:space="preserve">
          <source>The followup discussion that changed the behavior of &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is archived here: &lt;a href=&quot;http://markmail.org/message/trovdc6zkphyi3cr#query:+page:1+mid:a46der3iacwjcf6n+state:results&quot;&gt;Proposal: Allow gunfold for Data.Map, ...&lt;/a&gt;</source>
          <target state="translated">Последующее обсуждение, которое изменило поведение &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; , заархивировано здесь: &lt;a href=&quot;http://markmail.org/message/trovdc6zkphyi3cr#query:+page:1+mid:a46der3iacwjcf6n+state:results&quot;&gt;Предложение: Разрешить стрельбу для Data.Map, ...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cee1c36106928daf538418e53cc5b65ec5381bc2" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;C(..)&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; is a class, names the class &lt;code&gt;C&lt;/code&gt; and all its methods &lt;em&gt;and associated types&lt;/em&gt;.</source>
          <target state="translated">Форма &lt;code&gt;C(..)&lt;/code&gt; , где &lt;code&gt;C&lt;/code&gt; - класс, называет класс &lt;code&gt;C&lt;/code&gt; и все его методы &lt;em&gt;и связанные типы&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="16df0b26ad83c27523378eaf1216ddacafe4cfa5" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;C(.., mi, .., type Tj, ..)&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; is a class, names the class &lt;code&gt;C&lt;/code&gt;, and the specified methods &lt;code&gt;mi&lt;/code&gt; and associated types &lt;code&gt;Tj&lt;/code&gt;. The types need a keyword &amp;ldquo;&lt;code&gt;type&lt;/code&gt;&amp;rdquo; to distinguish them from data constructors.</source>
          <target state="translated">Форма &lt;code&gt;C(.., mi, .., type Tj, ..)&lt;/code&gt; , где &lt;code&gt;C&lt;/code&gt; - класс, называет класс &lt;code&gt;C&lt;/code&gt; , а также указанные методы &lt;code&gt;mi&lt;/code&gt; и связанные типы &lt;code&gt;Tj&lt;/code&gt; . Типам необходимо ключевое слово &amp;laquo; &lt;code&gt;type&lt;/code&gt; &amp;raquo;, чтобы отличать их от конструкторов данных.</target>
        </trans-unit>
        <trans-unit id="54deed429c05521fb5fa3d0bb8ceb609130a547f" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;T(..)&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a data family, names the family &lt;code&gt;T&lt;/code&gt; and all the in-scope constructors (whether in scope qualified or unqualified) that are data instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Форма &lt;code&gt;T(..)&lt;/code&gt; , где &lt;code&gt;T&lt;/code&gt; представляет собой семейство данных, имена семьи &lt;code&gt;T&lt;/code&gt; и все конструктор в области видимости (будь то в рамках квалифицированный или неквалифицированный) , которые являются экземплярами данных из &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="784438eaf0aa44838a323a050c855ee268899421" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;T(.., ci, .., fj, ..)&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a data family, names &lt;code&gt;T&lt;/code&gt; and the specified constructors &lt;code&gt;ci&lt;/code&gt; and fields &lt;code&gt;fj&lt;/code&gt; as usual. The constructors and field names must belong to some data instance of &lt;code&gt;T&lt;/code&gt;, but are not required to belong to the &lt;em&gt;same&lt;/em&gt; instance.</source>
          <target state="translated">Форма &lt;code&gt;T(.., ci, .., fj, ..)&lt;/code&gt; , где &lt;code&gt;T&lt;/code&gt; - семейство данных, называет &lt;code&gt;T&lt;/code&gt; и указанные конструкторы &lt;code&gt;ci&lt;/code&gt; и поля &lt;code&gt;fj&lt;/code&gt; как обычно. Имена конструкторов и полей должны принадлежать какому-либо экземпляру данных &lt;code&gt;T&lt;/code&gt; , но не обязаны принадлежать одному и тому &lt;em&gt;же&lt;/em&gt; экземпляру.</target>
        </trans-unit>
        <trans-unit id="e19f785765e870b264c7a6f5303ec2d2e122f27d" translate="yes" xml:space="preserve">
          <source>The form is called a &amp;ldquo;GADT-style declaration&amp;rdquo; because Generalised Algebraic Data Types, described in &lt;a href=&quot;#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt;, can only be declared using this form.</source>
          <target state="translated">Форма называется &amp;laquo;декларацией в стиле GADT&amp;raquo;, поскольку обобщенные алгебраические типы данных, описанные в &lt;a href=&quot;#gadt&quot;&gt;разделе &amp;laquo;Обобщенные алгебраические типы данных&amp;raquo; (GADT)&lt;/a&gt; , могут быть объявлены только с помощью этой формы.</target>
        </trans-unit>
        <trans-unit id="ccb8198ff02595b7c5252294cca08712b727694b" translate="yes" xml:space="preserve">
          <source>The form with a type variable at the head allows this:</source>
          <target state="translated">Форма с переменной типа во главе позволяет это:</target>
        </trans-unit>
        <trans-unit id="33fa9d40a30aa7e6dce906a9649768430ce7ca3a" translate="yes" xml:space="preserve">
          <source>The format character &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; was invoked with. &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; should fail unless this character matches the type. It is normal to handle many different format characters for a single type.</source>
          <target state="translated">Символ формата &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; был вызван с помощью. &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; должен завершиться ошибкой, если этот символ не соответствует типу. Для одного типа нормально обрабатывать много символов разных форматов.</target>
        </trans-unit>
        <trans-unit id="2d9a19d4aec50fa6639cb12bdd8357cf823eed22" translate="yes" xml:space="preserve">
          <source>The format in which GHC currently stores its typechecked AST, makes it costly to collect the types for some expressions nodes. For the sake of performance, GHC currently chooses to skip over these, so not all expression nodes should be expected to have type information on them. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/16233&quot;&gt;Issue #16233&lt;/a&gt; for more.</source>
          <target state="translated">Формат, в котором GHC в настоящее время хранит свой AST с проверкой типов, делает сбор типов для некоторых узлов выражений дорогостоящим. Ради производительности GHC в настоящее время предпочитает пропускать их, поэтому не следует ожидать, что все узлы выражений будут иметь информацию о типах. Подробнее см. В &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/16233&quot;&gt;выпуске № 16233&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d12d8f748fe76f6f798cf8384f400dd6e25b26a" translate="yes" xml:space="preserve">
          <source>The format of the log file is described by the header &lt;code&gt;EventLogFormat.h&lt;/code&gt; that comes with GHC, and it can be parsed in Haskell using the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; library. To dump the contents of a &lt;code&gt;.eventlog&lt;/code&gt; file as text, use the tool &lt;code&gt;ghc-events show&lt;/code&gt; that comes with the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; package.</source>
          <target state="translated">Формат файла журнала описывается заголовком &lt;code&gt;EventLogFormat.h&lt;/code&gt; , который поставляется с GHC, и его можно проанализировать в Haskell с помощью библиотеки &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; . Чтобы &lt;code&gt;.eventlog&lt;/code&gt; файла .eventlog в виде текста, используйте инструмент &lt;code&gt;ghc-events show&lt;/code&gt; , который поставляется с пакетом &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be4698f989f63506bf7e347d2e60a53dbb0e6400" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary characters and &lt;em&gt;conversion specifications&lt;/em&gt;, which specify how to format one of the arguments to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; in the output string. A format specification is introduced by the &lt;code&gt;%&lt;/code&gt; character; this character can be self-escaped into the format string using &lt;code&gt;%%&lt;/code&gt;. A format specification ends with a &lt;em&gt;format character&lt;/em&gt; that provides the primary information about how to format the value. The rest of the conversion specification is optional. In order, one may have flag characters, a width specifier, a precision specifier, and type-specific modifier characters.</source>
          <target state="translated">Строка формата состоит из обычных символов и &lt;em&gt;спецификаций преобразования&lt;/em&gt; , которые указывают, как отформатировать один из аргументов &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; в выходной строке. Спецификация формата вводится символом &lt;code&gt;%&lt;/code&gt; ; этот символ может быть экранирован в строку формата с помощью &lt;code&gt;%%&lt;/code&gt; . Спецификация формата заканчивается &lt;em&gt;символом формата,&lt;/em&gt; который предоставляет основную информацию о том, как отформатировать значение. Остальная часть спецификации преобразования необязательна. По порядку могут быть символы флага, спецификатор ширины, спецификатор точности и символы-модификаторы для конкретного типа.</target>
        </trans-unit>
        <trans-unit id="25e09c7cb4393ecfca8f299ffa2b0d2ecb753a77" translate="yes" xml:space="preserve">
          <source>The former will result in far better code.</source>
          <target state="translated">В первом случае код будет намного лучше.</target>
        </trans-unit>
        <trans-unit id="64194ba26d3825d046086abae5391759fabeb498" translate="yes" xml:space="preserve">
          <source>The full Haskell import syntax is supported, including &lt;code&gt;hiding&lt;/code&gt; and &lt;code&gt;as&lt;/code&gt; clauses. The prompt shows the modules that are currently imported, but it omits details about &lt;code&gt;hiding&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, and so on. To see the full story, use &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Поддерживается полный синтаксис импорта Haskell, включая предложения &lt;code&gt;hiding&lt;/code&gt; и &lt;code&gt;as&lt;/code&gt; . В приглашении показаны модули, которые в настоящее время импортированы, но не указаны сведения о &lt;code&gt;hiding&lt;/code&gt; , &lt;code&gt;as&lt;/code&gt; и т. Д. Чтобы увидеть полную историю, используйте &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="6d2ba0a02591100122d7720b515c37aa08242448" translate="yes" xml:space="preserve">
          <source>The full set of warning options is described below. To turn off any warning, simply give the corresponding &lt;code&gt;-Wno-...&lt;/code&gt; option on the command line. For backwards compatibility with GHC versions prior to 8.0, all these warnings can still be controlled with &lt;code&gt;-f(no-)warn-*&lt;/code&gt; instead of &lt;code&gt;-W(no-)*&lt;/code&gt;.</source>
          <target state="translated">Полный набор параметров предупреждений описан ниже. Чтобы отключить любое предупреждение, просто &lt;code&gt;-Wno-...&lt;/code&gt; соответствующую опцию -Wno -... в командной строке. Для обратной совместимости с версиями GHC до 8.0 все эти предупреждения можно контролировать с помощью &lt;code&gt;-f(no-)warn-*&lt;/code&gt; вместо &lt;code&gt;-W(no-)*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc028589c7596178a298d55a5adc62737995f4c1" translate="yes" xml:space="preserve">
          <source>The fully-qualified name of the module where the type is declared</source>
          <target state="translated">Полноценное имя модуля,в котором объявлен тип</target>
        </trans-unit>
        <trans-unit id="a1840c040d0f137dff3d86a1c41a473b6f4799b8" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; is like &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;, but it takes an extra argument which is an &lt;em&gt;exception predicate&lt;/em&gt;, a function which selects which type of exceptions we're interested in.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; похожа на &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; , но она принимает дополнительный аргумент, который является &lt;em&gt;предикатом исключения&lt;/em&gt; , функцией, которая выбирает, какой тип исключений нас интересует.</target>
        </trans-unit>
        <trans-unit id="6c24fa3787eba0e6f28035b825969cadbe339326" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;data-complex#v:polar&quot;&gt;polar&lt;/a&gt;&lt;/code&gt; takes a complex number and returns a (magnitude, phase) pair in canonical form: the magnitude is nonnegative, and the phase in the range &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt;; if the magnitude is zero, then so is the phase.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-complex#v:polar&quot;&gt;polar&lt;/a&gt;&lt;/code&gt; принимает комплексное число и возвращает пару (величина, фаза) в канонической форме: величина неотрицательна, а фаза в диапазоне &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt; ; если величина равна нулю, то фаза тоже.</target>
        </trans-unit>
        <trans-unit id="d424b407dc86bdf0a0767c07efa10515030815a2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; applied to a real floating-point number returns the significand expressed as an &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; and an appropriately scaled exponent (an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;). If &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; yields &lt;code&gt;(m,n)&lt;/code&gt;, then &lt;code&gt;x&lt;/code&gt; is equal in value to &lt;code&gt;m*b^^n&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix, and furthermore, either &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are both zero or else &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; is the value of &lt;code&gt;&lt;a href=&quot;ghc-float#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt;. In particular, &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt;. If the type contains a negative zero, also &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt;. &lt;em&gt;The result of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is unspecified if either of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-float#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;or&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-float#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; , примененная к действительному числу с плавающей запятой, возвращает мантиссу, выраженную как &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; и соответствующим образом масштабированный показатель степени ( &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ). Если &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; дает &lt;code&gt;(m,n)&lt;/code&gt; , то &lt;code&gt;x&lt;/code&gt; равно по значению &lt;code&gt;m*b^^n&lt;/code&gt; , где &lt;code&gt;b&lt;/code&gt; - основание системы счисления с плавающей запятой, и, кроме того, либо &lt;code&gt;m&lt;/code&gt; и &lt;code&gt;n&lt;/code&gt; оба равны нулю, либо &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt; , где &lt;code&gt;d&lt;/code&gt; - значение &lt;code&gt;&lt;a href=&quot;ghc-float#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt; . В частности, &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt; , Если тип содержит отрицательный ноль, также &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt; . &lt;em&gt;Результат &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; &lt;em&gt;не &lt;/em&gt;указан,&lt;em&gt; если &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;ghc-float#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt; &lt;em&gt;или &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;ghc-float#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt; &lt;em&gt;имеет значение &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe262135e4b1d91cb57eb1b81744970db71313a5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; takes a real fractional number &lt;code&gt;x&lt;/code&gt; and returns a pair &lt;code&gt;(n,f)&lt;/code&gt; such that &lt;code&gt;x = n+f&lt;/code&gt;, and:</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; принимает действительное дробное число &lt;code&gt;x&lt;/code&gt; и возвращает пару &lt;code&gt;(n,f)&lt;/code&gt; такую, что &lt;code&gt;x = n+f&lt;/code&gt; , и:</target>
        </trans-unit>
        <trans-unit id="afbc2bb6bd9e243f694f4d3b3dece0b75ced87dd" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; applied to a real floating-point number returns the significand expressed as an &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; and an appropriately scaled exponent (an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;). If &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; yields &lt;code&gt;(m,n)&lt;/code&gt;, then &lt;code&gt;x&lt;/code&gt; is equal in value to &lt;code&gt;m*b^^n&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix, and furthermore, either &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are both zero or else &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; is the value of &lt;code&gt;&lt;a href=&quot;prelude#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt;. In particular, &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt;. If the type contains a negative zero, also &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt;. &lt;em&gt;The result of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is unspecified if either of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;or&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; , примененная к действительному числу с плавающей запятой, возвращает мантиссу, выраженную как &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; и соответствующим образом масштабированный показатель степени ( &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ). Если &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; дает &lt;code&gt;(m,n)&lt;/code&gt; , то &lt;code&gt;x&lt;/code&gt; равно по значению &lt;code&gt;m*b^^n&lt;/code&gt; , где &lt;code&gt;b&lt;/code&gt; - основание системы счисления с плавающей запятой, и, кроме того, либо &lt;code&gt;m&lt;/code&gt; и &lt;code&gt;n&lt;/code&gt; оба равны нулю, либо &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt; , где &lt;code&gt;d&lt;/code&gt; - значение &lt;code&gt;&lt;a href=&quot;prelude#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt; . В частности, &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt; , Если тип содержит отрицательный ноль, также &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt; . &lt;em&gt;Результат &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; &lt;em&gt;не &lt;/em&gt;указан,&lt;em&gt; если &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt; &lt;em&gt;или &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt; &lt;em&gt;имеет значение &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="079629951658e63a1aceb4ed5c824cc91a0b5d86" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; takes a real fractional number &lt;code&gt;x&lt;/code&gt; and returns a pair &lt;code&gt;(n,f)&lt;/code&gt; such that &lt;code&gt;x = n+f&lt;/code&gt;, and:</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; принимает действительное дробное число &lt;code&gt;x&lt;/code&gt; и возвращает пару &lt;code&gt;(n,f)&lt;/code&gt; такую, что &lt;code&gt;x = n+f&lt;/code&gt; , и:</target>
        </trans-unit>
        <trans-unit id="88f909330278d9f82a3312e25ef59ec6d2186b36" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;coerce&lt;/code&gt; allows you to safely convert between values of types that have the same representation with no run-time overhead. In the simplest case you can use it instead of a newtype constructor, to go from the newtype's concrete type to the abstract type. But it also works in more complicated settings, e.g. converting a list of newtypes to a list of concrete types.</source>
          <target state="translated">Функция &lt;code&gt;coerce&lt;/code&gt; позволяет безопасно преобразовывать значения типов, которые имеют одинаковое представление, без дополнительных затрат времени выполнения. В простейшем случае вы можете использовать его вместо конструктора newtype, чтобы перейти от конкретного типа newtype к абстрактному типу. Но он также работает в более сложных настройках, например, при преобразовании списка новых типов в список конкретных типов.</target>
        </trans-unit>
        <trans-unit id="a9426870a71de06c1f556cf879bcdaf0553394f4" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f3&lt;/code&gt; has a rank-3 type; it has rank-2 types on the left of a function arrow.</source>
          <target state="translated">Функция &lt;code&gt;f3&lt;/code&gt; имеет тип ранга 3; у него есть типы ранга 2 слева от стрелки функции.</target>
        </trans-unit>
        <trans-unit id="4bebe5f1a75a0eddf8839f635c3decbffc5557dc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f&lt;/code&gt; below will fail when applied to &lt;code&gt;Bar&lt;/code&gt;, so the compiler will emit a warning about this when &lt;a href=&quot;#ghc-flag--Wincomplete-record-updates&quot;&gt;&lt;code&gt;-Wincomplete-record-updates&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">Приведенная ниже функция &lt;code&gt;f&lt;/code&gt; завершится ошибкой при применении к &lt;code&gt;Bar&lt;/code&gt; , поэтому компилятор выдаст предупреждение об этом, когда &lt;a href=&quot;#ghc-flag--Wincomplete-record-updates&quot;&gt; &lt;code&gt;-Wincomplete-record-updates&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="782d3d59f72773f7952ce1ebae2822b75b04a8b7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f&lt;/code&gt; from the previous section has a more accurate type:</source>
          <target state="translated">Функция &lt;code&gt;f&lt;/code&gt; из предыдущего раздела имеет более точный тип:</target>
        </trans-unit>
        <trans-unit id="7ec7041ec2658984f17f499a66ced25885c4a3a1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fromList&lt;/code&gt; constructs the structure &lt;code&gt;l&lt;/code&gt; from the given list of &lt;code&gt;Item l&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;fromList&lt;/code&gt; строит структуру &lt;code&gt;l&lt;/code&gt; из заданного списка &lt;code&gt;Item l&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53dd445850b902910cfbc7105e43df3c60dfa18d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fromListN&lt;/code&gt; takes the input list&amp;rsquo;s length as a hint. Its behaviour should be equivalent to &lt;code&gt;fromList&lt;/code&gt;. The hint can be used for more efficient construction of the structure &lt;code&gt;l&lt;/code&gt; compared to &lt;code&gt;fromList&lt;/code&gt;. If the given hint is not equal to the input list&amp;rsquo;s length the behaviour of &lt;code&gt;fromListN&lt;/code&gt; is not specified.</source>
          <target state="translated">Функция &lt;code&gt;fromListN&lt;/code&gt; принимает длину входного списка в качестве подсказки. Его поведение должно быть эквивалентно &lt;code&gt;fromList&lt;/code&gt; . Подсказка может использоваться для более эффективного построения структуры &lt;code&gt;l&lt;/code&gt; по сравнению с &lt;code&gt;fromList&lt;/code&gt; . Если указанная подсказка не равна длине входного списка, поведение &lt;code&gt;fromListN&lt;/code&gt; не указывается.</target>
        </trans-unit>
        <trans-unit id="b2c51e1ae6a25019f5b8dcb68c7e1cc6360380a0" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;g&lt;/code&gt; from the previous section is now rejected with a type error as we would hope because the type of &lt;code&gt;f&lt;/code&gt; does not allow the two arguments to have different types. This, then, is an example of a multiple parameter class that does actually work quite well in practice, without ambiguity problems. There is, however, a catch. This version of the &lt;code&gt;Collects&lt;/code&gt; class is nowhere near as general as the original class seemed to be: only one of the four instances for &lt;code&gt;Collects&lt;/code&gt; given above can be used with this version of Collects because only one of them&amp;mdash;the instance for lists&amp;mdash;has a collection type that can be written in the form &lt;code&gt;c
e&lt;/code&gt;, for some type constructor &lt;code&gt;c&lt;/code&gt;, and element type &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;g&lt;/code&gt; из предыдущего раздела теперь отклоняется с ошибкой типа, как мы надеемся, потому что тип &lt;code&gt;f&lt;/code&gt; не позволяет двум аргументам иметь разные типы. Таким образом, это пример класса с несколькими параметрами, который действительно хорошо работает на практике без проблем с неоднозначностью. Однако есть одна загвоздка. Эта версия класса &lt;code&gt;Collects&lt;/code&gt; далеко не так универсальна, как представлялся исходный класс: только один из четырех экземпляров для &lt;code&gt;Collects&lt;/code&gt; , указанных выше, может использоваться с этой версией Collects, потому что только один из них - экземпляр для списков - имеет тип коллекции, который может быть записан в форме &lt;code&gt;c e&lt;/code&gt; , для конструктора некоторого типа &lt;code&gt;c&lt;/code&gt; и типа элемента &lt;code&gt;e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e1caf69d4b138be614d3615769e3ef6ea6617e4" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;toList&lt;/code&gt; should be the inverse of &lt;code&gt;fromList&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;toList&lt;/code&gt; должна быть обратной по отношению к &lt;code&gt;fromList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3f8ca21e6067d938666eb5fad69ffc6307e5c9d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;unsafeCoerce#&lt;/code&gt; allows you to side-step the typechecker entirely. That is, it allows you to coerce any type into any other type. If you use this function, you had better get it right, otherwise segmentation faults await. It is generally used when you want to write a program that you know is well-typed, but where Haskell's type system is not expressive enough to prove that it is well typed.</source>
          <target state="translated">Функция &lt;code&gt;unsafeCoerce#&lt;/code&gt; позволяет полностью обойти проверку типов. То есть он позволяет преобразовать любой тип в любой другой. Если вы используете эту функцию, вам лучше сделать это правильно, иначе ждут ошибки сегментации. Обычно он используется, когда вы хотите написать программу, которая, как вы знаете, хорошо типизирована, но когда система типов Haskell недостаточно выразительна, чтобы доказать, что она хорошо типизирована.</target>
        </trans-unit>
        <trans-unit id="4078d840830c2b32e85bca92ef57e0c6f82bd822" translate="yes" xml:space="preserve">
          <source>The function also returns two new handles: * an I/O Completion Port handle on which events will be signaled. * a Job handle which can be used to kill all running processes.</source>
          <target state="translated">Функция также возвращает две новые ручки:*дескриптор порта завершения ввода/вывода,на котором будут подаваться сигналы о событиях.*хэндл задания,который может быть использован для уничтожения всех запущенных процессов.</target>
        </trans-unit>
        <trans-unit id="f6e72213f9f513b34bc27c803b9c687fb47fd6c8" translate="yes" xml:space="preserve">
          <source>The function arrow &lt;code&gt;-&amp;gt;&lt;/code&gt; is &lt;code&gt;infixr&lt;/code&gt; with fixity -1.</source>
          <target state="translated">Функция стрелка &lt;code&gt;-&amp;gt;&lt;/code&gt; это &lt;code&gt;infixr&lt;/code&gt; с неподвижностью -1.</target>
        </trans-unit>
        <trans-unit id="54424bef429db403f4735db658be9ddb164137b0" translate="yes" xml:space="preserve">
          <source>The function creates a temporary file in ReadWrite mode. The created file isn't deleted automatically, so you need to delete it manually.</source>
          <target state="translated">Функция создает временный файл в режиме ReadWrite.Созданный файл не удаляется автоматически,поэтому его нужно удалить вручную.</target>
        </trans-unit>
        <trans-unit id="4d31db636076141a2d374629e18c022c852ebef1" translate="yes" xml:space="preserve">
          <source>The function doesn't verify whether the path exists.</source>
          <target state="translated">Функция не проверяет,существует ли путь.</target>
        </trans-unit>
        <trans-unit id="add6d8a8d14a017a7abdc22d6a499ce254500df6" translate="yes" xml:space="preserve">
          <source>The function is assumed to define a total ordering.</source>
          <target state="translated">Предполагается,что эта функция определяет общий заказ.</target>
        </trans-unit>
        <trans-unit id="8c87908085624472ff4238bfb948223b787875d2" translate="yes" xml:space="preserve">
          <source>The function that applies a parser must now unwrap each of the monad transformers in turn:</source>
          <target state="translated">Теперь функция,которая применяет синтаксический анализатор,должна поочередно разворачивать каждый из трансформаторов monad:</target>
        </trans-unit>
        <trans-unit id="83dbb4039dba1fe07aa4bcd8c6ba58bf457a2ec1" translate="yes" xml:space="preserve">
          <source>The function to modify the environment.</source>
          <target state="translated">Функция изменения окружающей среды.</target>
        </trans-unit>
        <trans-unit id="1ccbf33c88dc57758ba1b802fb4f53d665b9edec" translate="yes" xml:space="preserve">
          <source>The function type constructor.</source>
          <target state="translated">Конструктор типа функции.</target>
        </trans-unit>
        <trans-unit id="f0f44ae6963080cf76e0ebf83f004dc8df761919" translate="yes" xml:space="preserve">
          <source>The function will return the corresponding value as &lt;code&gt;(&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the key isn't in the map.</source>
          <target state="translated">Функция вернет соответствующее значение как &lt;code&gt;(&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если ключа нет на карте.</target>
        </trans-unit>
        <trans-unit id="ce3cf6b1fb41916c15598ef7c7a2316d0affe736" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to a comparison function, but the more general type ensures that the implementation uses it to compare elements of the first container with elements of the second.</source>
          <target state="translated">Функция обычно применяется к функции сравнения,но более общий тип гарантирует,что в реализации она используется для сравнения элементов первого контейнера с элементами второго.</target>
        </trans-unit>
        <trans-unit id="57722a7fa81914229dcd7f438a467425fc2444d4" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to an equality function, but the more general type ensures that the implementation uses it to compare elements of the first container with elements of the second.</source>
          <target state="translated">Функция обычно применяется к функции равенства,но более общий тип гарантирует,что реализация использует ее для сравнения элементов первого контейнера с элементами второго.</target>
        </trans-unit>
        <trans-unit id="a2f33e33f25cc5b116bd53d1e8871c737f431f0f" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to comparison functions, but the more general type ensures that the implementation uses them to compare elements of the first container with elements of the second.</source>
          <target state="translated">Функция обычно применяется к функциям сравнения,но более общий тип гарантирует,что в реализации они используются для сравнения элементов первого контейнера с элементами второго.</target>
        </trans-unit>
        <trans-unit id="4fea0a18b8df51f28201953f3c7f75703eb47939" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to equality functions, but the more general type ensures that the implementation uses them to compare elements of the first container with elements of the second.</source>
          <target state="translated">Функция обычно применяется к функциям равенства,но более общий тип гарантирует,что в реализации они используются для сравнения элементов первого контейнера с элементами второго.</target>
        </trans-unit>
        <trans-unit id="6b6bc4aeee7f2323c64ee51bd60f90b62c365dcb" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;f2&lt;/code&gt; and &lt;code&gt;g2&lt;/code&gt; have rank-2 types; the &lt;code&gt;forall&lt;/code&gt; is on the left of a function arrow. As &lt;code&gt;g2&lt;/code&gt; shows, the polymorphic type on the left of the function arrow can be overloaded.</source>
          <target state="translated">Функции &lt;code&gt;f2&lt;/code&gt; и &lt;code&gt;g2&lt;/code&gt; имеют тип ранга 2; &lt;code&gt;forall&lt;/code&gt; находится слева от функции стрелка. Как показывает &lt;code&gt;g2&lt;/code&gt; , полиморфный тип слева от стрелки функции может быть перегружен.</target>
        </trans-unit>
        <trans-unit id="436e2ff4e3f10ce06692935420d28156ccb98ad6" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; have the same body, but only &lt;code&gt;f&lt;/code&gt; is given a type signature. When GHC is figuring out how to process a visible type application, it must know what variable to instantiate. It thus must be able to provide an ordering to the type variables in a function&amp;rsquo;s type.</source>
          <target state="translated">Функции &lt;code&gt;f&lt;/code&gt; и &lt;code&gt;g&lt;/code&gt; имеют одно и то же тело, но только &lt;code&gt;f&lt;/code&gt; имеет сигнатуру типа. Когда GHC выясняет, как обрабатывать приложение видимого типа, он должен знать, какую переменную создать. Таким образом, он должен иметь возможность упорядочивать переменные типа в типе функции.</target>
        </trans-unit>
        <trans-unit id="709a35f15e3b44bedbeb0d4b4dddb4664dc2f475" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;g5&lt;/code&gt; and &lt;code&gt;g6&lt;/code&gt; mean exactly the same thing. But &lt;code&gt;g7&lt;/code&gt; evaluates &lt;code&gt;(f x)&lt;/code&gt;, binds &lt;code&gt;y&lt;/code&gt; to the result, and then evaluates &lt;code&gt;body&lt;/code&gt;.</source>
          <target state="translated">Функции &lt;code&gt;g5&lt;/code&gt; и &lt;code&gt;g6&lt;/code&gt; означают одно и то же. Но &lt;code&gt;g7&lt;/code&gt; оценивает &lt;code&gt;(f x)&lt;/code&gt; , связывает &lt;code&gt;y&lt;/code&gt; с результатом, а затем оценивает &lt;code&gt;body&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b19b31f5cbfb6277d7255768c1a9509164d5a55" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt; are careful to force values before installing them in an &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;. This is usually more efficient in cases where laziness is not essential. The functions in this module do not do so.</source>
          <target state="translated">Функции в &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict стараются&lt;/a&gt; принудительно устанавливать значения перед их установкой в &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; . Обычно это более эффективно в случаях, когда лень не нужна. Функции этого модуля этого не делают.</target>
        </trans-unit>
        <trans-unit id="670d1298e5cb7a4e8403b208919c4f9aa9e19f28" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict&lt;/a&gt; are careful to force values before installing them in a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;. This is usually more efficient in cases where laziness is not essential. The functions in this module do not do so.</source>
          <target state="translated">Функции в &lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict стараются&lt;/a&gt; принудительно устанавливать значения перед их установкой в &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; . Обычно это более эффективно в случаях, когда лень не нужна. Функции этого модуля этого не делают.</target>
        </trans-unit>
        <trans-unit id="d7ac968071ec3d6db992b2e9189f08e304a943fb" translate="yes" xml:space="preserve">
          <source>The functions in this library use the following naming conventions:</source>
          <target state="translated">Функции в этой библиотеке используют следующие соглашения по наименованию:</target>
        </trans-unit>
        <trans-unit id="4d771bd73e07b4943d9ccd53e1231da21d4a47f0" translate="yes" xml:space="preserve">
          <source>The functions in this module obey the runtime system's locale, character set encoding, and line ending conversion settings.</source>
          <target state="translated">Функции в этом модуле подчиняются настройкам локали системы исполнения,кодировки наборов символов и преобразования в конце строки.</target>
        </trans-unit>
        <trans-unit id="d0245bbfde5cb4645880f74fa8998ab54478221f" translate="yes" xml:space="preserve">
          <source>The general form is &lt;code&gt;%&amp;lt;modifier&amp;gt;&amp;lt;width&amp;gt;&amp;lt;alternate&amp;gt;&amp;lt;specifier&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;modifier&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;alternate&amp;gt;&lt;/code&gt; are optional.</source>
          <target state="translated">Общая форма - &lt;code&gt;%&amp;lt;modifier&amp;gt;&amp;lt;width&amp;gt;&amp;lt;alternate&amp;gt;&amp;lt;specifier&amp;gt;&lt;/code&gt; , где &lt;code&gt;&amp;lt;modifier&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;alternate&amp;gt;&lt;/code&gt; являются необязательными.</target>
        </trans-unit>
        <trans-unit id="d87f5dd37c519e3511a8db8b010d4f7ff96c2337" translate="yes" xml:space="preserve">
          <source>The general interface</source>
          <target state="translated">Общий интерфейс</target>
        </trans-unit>
        <trans-unit id="ec767503aee97b2532b6ed4020896fc0a3c857b5" translate="yes" xml:space="preserve">
          <source>The general principle is this:</source>
          <target state="translated">Общий принцип таков:</target>
        </trans-unit>
        <trans-unit id="63fa8f01398fe9d9b6a5c91481c5c9f9c693d55d" translate="yes" xml:space="preserve">
          <source>The general rendering interface, supporting annotations. Please refer to the &lt;code&gt;Style&lt;/code&gt; and &lt;code&gt;Mode&lt;/code&gt; types for a description of rendering mode, line length and ribbons.</source>
          <target state="translated">Общий интерфейс рендеринга с поддержкой аннотаций. Пожалуйста, обратитесь к типам &lt;code&gt;Style&lt;/code&gt; и &lt;code&gt;Mode&lt;/code&gt; для описания режима рендеринга, длины линии и лент.</target>
        </trans-unit>
        <trans-unit id="443a3115347a69de80f7eab2e438bb5e78262ac7" translate="yes" xml:space="preserve">
          <source>The general rendering interface. Please refer to the &lt;code&gt;Style&lt;/code&gt; and &lt;code&gt;Mode&lt;/code&gt; types for a description of rendering mode, line length and ribbons.</source>
          <target state="translated">Общий интерфейс рендеринга. Пожалуйста, обратитесь к типам &lt;code&gt;Style&lt;/code&gt; и &lt;code&gt;Mode&lt;/code&gt; для описания режима рендеринга, длины линии и лент.</target>
        </trans-unit>
        <trans-unit id="2c8107939525836136417ba263c01627df220ab0" translate="yes" xml:space="preserve">
          <source>The generated code for the &lt;code&gt;Functor Wrong&lt;/code&gt; instance would look exactly the same, except with &lt;code&gt;Wrong&lt;/code&gt; replacing every occurrence of &lt;code&gt;Right&lt;/code&gt;. The problem is now that &lt;code&gt;fmap&lt;/code&gt; is being applied recursively to a value of type &lt;code&gt;Either a Int&lt;/code&gt;. This cannot possibly produce a value of type &lt;code&gt;Either b Int&lt;/code&gt;, as &lt;code&gt;fmap&lt;/code&gt; can only change the last type parameter! This causes the generated code to be ill-typed.</source>
          <target state="translated">Сгенерированный код для экземпляра &lt;code&gt;Functor Wrong&lt;/code&gt; будет выглядеть точно так же, за исключением того, что &lt;code&gt;Wrong&lt;/code&gt; заменяет каждое вхождение &lt;code&gt;Right&lt;/code&gt; . Проблема в том, что теперь &lt;code&gt;fmap&lt;/code&gt; рекурсивно применяется к значению типа &lt;code&gt;Either a Int&lt;/code&gt; . Это не может создать значение типа &lt;code&gt;Either b Int&lt;/code&gt; , поскольку &lt;code&gt;fmap&lt;/code&gt; может изменять только последний параметр типа! Это приводит к неправильной типизации сгенерированного кода.</target>
        </trans-unit>
        <trans-unit id="32903708d002dac9c0ac078342e2e27cabf0d2dd" translate="yes" xml:space="preserve">
          <source>The generation number of this GC</source>
          <target state="translated">Количество поколений этого ГК</target>
        </trans-unit>
        <trans-unit id="878b032694848adb77a2b859c02bd1b95a7bae5c" translate="yes" xml:space="preserve">
          <source>The goal here is to &lt;code&gt;lift&lt;/code&gt; from monad &lt;code&gt;m&lt;/code&gt; to &lt;code&gt;t2 m&lt;/code&gt; and then &lt;code&gt;lift&lt;/code&gt; this again into &lt;code&gt;t1 (t2 m)&lt;/code&gt;. However, this second &lt;code&gt;lift&lt;/code&gt; can only be accepted when &lt;code&gt;(t2 m)&lt;/code&gt; is a monad and there is no way of establishing that this fact universally holds.</source>
          <target state="translated">Цель здесь - &lt;code&gt;lift&lt;/code&gt; монаду &lt;code&gt;m&lt;/code&gt; до &lt;code&gt;t2 m&lt;/code&gt; , а затем снова &lt;code&gt;lift&lt;/code&gt; ее до &lt;code&gt;t1 (t2 m)&lt;/code&gt; . Однако этот второй &lt;code&gt;lift&lt;/code&gt; может быть принят только тогда, когда &lt;code&gt;(t2 m)&lt;/code&gt; - монада, и невозможно установить, что этот факт универсален.</target>
        </trans-unit>
        <trans-unit id="cbfa1f88a3966514e5f590037e0742d3e33e28f3" translate="yes" xml:space="preserve">
          <source>The goal is to preserve the meaning of paths better than &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:normalise&quot;&gt;normalise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Цель состоит в том, чтобы лучше сохранить смысл путей, чем &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:normalise&quot;&gt;normalise&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e6155b86f48a01b347dfb545d9546dfe24b006f" translate="yes" xml:space="preserve">
          <source>The goal of the roles system is to track when two types have the same underlying representation. In the example above, &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; have the same representation. But, the corresponding instances of &lt;code&gt;BadIdea&lt;/code&gt; would &lt;em&gt;not&lt;/em&gt; have the same representation, because the types of the implementations of &lt;code&gt;bad&lt;/code&gt; would be different.</source>
          <target state="translated">Цель системы ролей - отслеживать, когда два типа имеют одинаковое базовое представление. В приведенном выше примере &lt;code&gt;Age&lt;/code&gt; и &lt;code&gt;Int&lt;/code&gt; имеют одинаковое представление. Но соответствующие экземпляры &lt;code&gt;BadIdea&lt;/code&gt; &lt;em&gt;не&lt;/em&gt; будут иметь одинаковое представление, потому что типы реализаций &lt;code&gt;bad&lt;/code&gt; будут разными.</target>
        </trans-unit>
        <trans-unit id="ae5a7fa8ebdfcbe0b2302748233617b3ca55c26a" translate="yes" xml:space="preserve">
          <source>The goal of typed holes is to help with writing Haskell code rather than to change the type system. Typed holes can be used to obtain extra information from the type checker, which might otherwise be hard to get. Normally, using GHCi, users can inspect the (inferred) type signatures of all top-level bindings. However, this method is less convenient with terms that are not defined on top-level or inside complex expressions. Holes allow the user to check the type of the term they are about to write.</source>
          <target state="translated">Целью типовых дыр является помощь в написании кода Haskell,а не изменение системы типов.Типизированные дыры могут быть использованы для получения дополнительной информации от программы проверки типов,которую в противном случае будет сложно получить.Обычно,используя GHCi,пользователи могут проверять (предполагаемые)сигнатуры типов всех привязок верхнего уровня.Однако этот метод менее удобен при использовании терминов,которые не определены на верхнем уровне или внутри сложных выражений.Отверстия позволяют пользователю проверить тип термина,который он собирается написать.</target>
        </trans-unit>
        <trans-unit id="0cbbcd933189820e27a73038da6c88d11c5e0b90" translate="yes" xml:space="preserve">
          <source>The gory details:</source>
          <target state="translated">Кровавые детали:</target>
        </trans-unit>
        <trans-unit id="19256158b7bc99497456b028690add2697259def" translate="yes" xml:space="preserve">
          <source>The grammar is ambiguous regarding the extent of lambda abstractions, let expressions, and conditionals. The ambiguity is resolved by the meta-rule that each of these constructs extends as far to the right as possible.</source>
          <target state="translated">Грамматика неоднозначна в отношении степени лямбда-абстракций,пусть даже выражений и условий.Двусмысленность разрешается мета-правилом,что каждая из этих конструкций простирается как можно дальше вправо.</target>
        </trans-unit>
        <trans-unit id="13bcdca0f47d6db8faa9273bbcc3a3514eb3a812" translate="yes" xml:space="preserve">
          <source>The graph obtained by reversing all edges.</source>
          <target state="translated">График,полученный путем перевертывания всех ребер.</target>
        </trans-unit>
        <trans-unit id="84d579939cacc525ddd770c640be60c5f760cbb9" translate="yes" xml:space="preserve">
          <source>The graph: a list of nodes uniquely identified by keys, with a list of keys of nodes this node has edges to. The out-list may contain keys that don't correspond to nodes of the graph; such edges are ignored.</source>
          <target state="translated">График:список узлов,однозначно идентифицированных по клавишам,со списком ключей узлов,к которым этот узел имеет края.Аут-лист может содержать ключи,не соответствующие вершинам графа,такие рёбра игнорируются.</target>
        </trans-unit>
        <trans-unit id="19a77ba5e8a6424783c2bacf9d044768e5056e5e" translate="yes" xml:space="preserve">
          <source>The group database</source>
          <target state="translated">База данных группы</target>
        </trans-unit>
        <trans-unit id="f37dce2ec9ac848392eba760bfa9b2a8e001c3e2" translate="yes" xml:space="preserve">
          <source>The hash sign does not change semantics at all. We tend to use variable names ending in &amp;ldquo;#&amp;rdquo; for unboxed values or types (e.g. &lt;code&gt;Int#&lt;/code&gt;), but there is no requirement to do so; they are just plain ordinary variables. Nor does the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension bring anything into scope. For example, to bring &lt;code&gt;Int#&lt;/code&gt; into scope you must import &lt;code&gt;GHC.Prim&lt;/code&gt; (see &lt;a href=&quot;#primitives&quot;&gt;Unboxed types and primitive operations&lt;/a&gt;); the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension then allows you to &lt;em&gt;refer&lt;/em&gt; to the &lt;code&gt;Int#&lt;/code&gt; that is now in scope. Note that with this option, the meaning of &lt;code&gt;x#y = 0&lt;/code&gt; is changed: it defines a function &lt;code&gt;x#&lt;/code&gt; taking a single argument &lt;code&gt;y&lt;/code&gt;; to define the operator &lt;code&gt;#&lt;/code&gt;, put a space: &lt;code&gt;x # y = 0&lt;/code&gt;.</source>
          <target state="translated">Знак решетки совершенно не меняет семантику. Мы склонны использовать имена переменных, оканчивающиеся на &amp;laquo;#&amp;raquo; для распакованных значений или типов (например, &lt;code&gt;Int#&lt;/code&gt; ), но это не обязательно; это просто обычные переменные. Расширение &lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt; также ничего не дает . Например, чтобы ввести &lt;code&gt;Int#&lt;/code&gt; в область видимости, вы должны импортировать &lt;code&gt;GHC.Prim&lt;/code&gt; (см. &lt;a href=&quot;#primitives&quot;&gt;Распакованные типы и примитивные операции&lt;/a&gt; ); &lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt; расширение затем позволяет &lt;em&gt;обратиться&lt;/em&gt; к &lt;code&gt;Int#&lt;/code&gt; , который сейчас находится в области видимости. Обратите внимание, что с помощью этой опции значение &lt;code&gt;x#y = 0&lt;/code&gt; изменяется: он определяет функцию &lt;code&gt;x#&lt;/code&gt; принимающую единственный аргумент &lt;code&gt;y&lt;/code&gt; ; для определения оператора &lt;code&gt;#&lt;/code&gt; поставьте пробел: &lt;code&gt;x # y = 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2210882c0ad0919709f59e7db6b4f28dc98cefd9" translate="yes" xml:space="preserve">
          <source>The header line is followed by ⟨l⟩ lines each containing one completion candidate encoded as (quoted) string literal. Here are some example invocations showing the various cases:</source>
          <target state="translated">За строкой заголовка следуют строки ⟨l⟩,каждая из которых содержит по одному кандидату на заполнение,закодированному как (цитируемый)строковый литерал.Приведем несколько примеров обращений,показывающих различные случаи:</target>
        </trans-unit>
        <trans-unit id="de913877c8fa30a91fa438399fb16f39f34a7e00" translate="yes" xml:space="preserve">
          <source>The header of a signature is &lt;code&gt;signature A where ...&lt;/code&gt; (instead of the usual &lt;code&gt;module A where ...&lt;/code&gt;).</source>
          <target state="translated">Заголовок подписи - это &lt;code&gt;signature A where ...&lt;/code&gt; (вместо обычного &lt;code&gt;module A where ...&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="78e62bbf377912fb128bb2f1870fb9fa408d92d9" translate="yes" xml:space="preserve">
          <source>The heap profiler can produce output to GHC&amp;rsquo;s event log, allowing samples to be correlated with other event log events over the program&amp;rsquo;s lifecycle.</source>
          <target state="translated">Профилировщик кучи может создавать выходные данные в журнале событий GHC, позволяя сопоставить образцы с другими событиями журнала событий в течение жизненного цикла программы.</target>
        </trans-unit>
        <trans-unit id="5cd522d72de3dbc3a1ac632468d70b83c0446184" translate="yes" xml:space="preserve">
          <source>The heap-overflow message.</source>
          <target state="translated">Сообщение о переполненной куче.</target>
        </trans-unit>
        <trans-unit id="baec639ab942341375f18c11aa4da668c27baef2" translate="yes" xml:space="preserve">
          <source>The hexadecimal notation for floating point literals is useful when you need to specify floating point constants precisely, as the literal notation corresponds closely to the underlying bit-encoding of the number.</source>
          <target state="translated">Шестнадцатеричная нотация для литералов с плавающей точкой полезна,когда необходимо точно указать константы с плавающей точкой,так как буквенная нотация близко соответствует битовой кодировке,лежащей в основе числа.</target>
        </trans-unit>
        <trans-unit id="0542015ab0e10f3b338b694e109bbc36d0e1ca73" translate="yes" xml:space="preserve">
          <source>The history is only available when using &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;; the reason for this is we found that logging each breakpoint in the history cuts performance by a factor of 2 or more.</source>
          <target state="translated">История доступна только при использовании &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt; ; Причина этого в том, что мы обнаружили, что регистрация каждой точки останова в истории снижает производительность в 2 или более раз.</target>
        </trans-unit>
        <trans-unit id="8e8742e7091ac952b2100b44f6fcab38011c36c7" translate="yes" xml:space="preserve">
          <source>The hpc command has several sub-commands:</source>
          <target state="translated">У команды hpc есть несколько подкоманд:</target>
        </trans-unit>
        <trans-unit id="cd85d2b986388d0386fde70a80e9bce5adc09ca4" translate="yes" xml:space="preserve">
          <source>The hpc tool assumes you are in the top-level directory of the location where you built your application, and the &lt;code&gt;.tix&lt;/code&gt; file is in the same top-level directory. You can use the flag &lt;code&gt;--srcdir&lt;/code&gt; to use &lt;code&gt;hpc&lt;/code&gt; for any other directory, and use &lt;code&gt;--srcdir&lt;/code&gt; multiple times to analyse programs compiled from difference locations, as is typical for packages.</source>
          <target state="translated">Инструмент hpc предполагает, что вы находитесь в каталоге верхнего уровня того места, где вы создали свое приложение, а файл &lt;code&gt;.tix&lt;/code&gt; находится в том же каталоге верхнего уровня. Вы можете использовать флаг &lt;code&gt;--srcdir&lt;/code&gt; , чтобы использовать &lt;code&gt;hpc&lt;/code&gt; для любого другого каталога, и использовать &lt;code&gt;--srcdir&lt;/code&gt; несколько раз для анализа программ, скомпилированных из разных мест, что типично для пакетов.</target>
        </trans-unit>
        <trans-unit id="ae95e293d652aa6b2e442077a87caf492f54c808" translate="yes" xml:space="preserve">
          <source>The idea is that &lt;code&gt;a&lt;/code&gt; should really be a representational parameter, but role inference assigns it to phantom. This makes some level of sense: a pointer to an &lt;code&gt;Int&lt;/code&gt; really is representationally the same as a pointer to a &lt;code&gt;Bool&lt;/code&gt;. But, that&amp;rsquo;s not at all how we want to use &lt;code&gt;Ptr&lt;/code&gt;s! So, we want to be able to say</source>
          <target state="translated">Идея состоит в том, что &lt;code&gt;a&lt;/code&gt; действительно должен быть репрезентативным параметром, но вывод ролей назначает его фантому. В этом есть определенный смысл: указатель на &lt;code&gt;Int&lt;/code&gt; действительно репрезентативно такой же, как указатель на &lt;code&gt;Bool&lt;/code&gt; . Но это совсем не то, как мы хотим использовать &lt;code&gt;Ptr&lt;/code&gt; s! Итак, мы хотим иметь возможность сказать</target>
        </trans-unit>
        <trans-unit id="e9b8ad3e3c7027edac335bae313b7046d76ae478" translate="yes" xml:space="preserve">
          <source>The idea is that we can then use &lt;code&gt;Point&lt;/code&gt; just as if we had defined a new datatype &lt;code&gt;MyPoint&lt;/code&gt; with two fields &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Идея состоит в том, что затем мы можем использовать &lt;code&gt;Point&lt;/code&gt; так же, как если бы мы определили новый тип данных &lt;code&gt;MyPoint&lt;/code&gt; с двумя полями &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5577da026d4ae923963655859a7950c0d959c92" translate="yes" xml:space="preserve">
          <source>The idea is that we have a new fundamental type constant &lt;code&gt;TYPE&lt;/code&gt;, which is parameterised by a &lt;code&gt;RuntimeRep&lt;/code&gt;. We thus get &lt;code&gt;Int# :: TYPE 'IntRep&lt;/code&gt; and &lt;code&gt;Bool :: TYPE 'LiftedRep&lt;/code&gt;. Anything with a type of the form &lt;code&gt;TYPE x&lt;/code&gt; can appear to either side of a function arrow &lt;code&gt;-&amp;gt;&lt;/code&gt;. We can thus say that &lt;code&gt;-&amp;gt;&lt;/code&gt; has type &lt;code&gt;TYPE r1 -&amp;gt; TYPE r2 -&amp;gt; TYPE 'LiftedRep&lt;/code&gt;. The result is always lifted because all functions are lifted in GHC.</source>
          <target state="translated">Идея состоит в том, что у нас есть новая константа фундаментального типа &lt;code&gt;TYPE&lt;/code&gt; , которая параметризуется с помощью &lt;code&gt;RuntimeRep&lt;/code&gt; . Таким образом, мы получаем &lt;code&gt;Int# :: TYPE 'IntRep&lt;/code&gt; и &lt;code&gt;Bool :: TYPE 'LiftedRep&lt;/code&gt; . Все, что имеет тип формы &lt;code&gt;TYPE x&lt;/code&gt; , может появиться по обе стороны от стрелки функции &lt;code&gt;-&amp;gt;&lt;/code&gt; . Таким образом, мы можем сказать, что &lt;code&gt;-&amp;gt;&lt;/code&gt; имеет тип &lt;code&gt;TYPE r1 -&amp;gt; TYPE r2 -&amp;gt; TYPE 'LiftedRep&lt;/code&gt; . Результат всегда поднимается, потому что в GHC подняты все функции.</target>
        </trans-unit>
        <trans-unit id="fa2009e07206ad049abebf85b239bfe1d707aee1" translate="yes" xml:space="preserve">
          <source>The idea is there can be no legal calls to &lt;code&gt;f&lt;/code&gt; because every call will give rise to an ambiguous constraint. Indeed, the &lt;em&gt;only&lt;/em&gt; purpose of the ambiguity check is to report functions that cannot possibly be called. We could soundly omit the ambiguity check on type signatures entirely, at the expense of delaying ambiguity errors to call sites. Indeed, the language extension &lt;a href=&quot;#extension-AllowAmbiguousTypes&quot;&gt;&lt;code&gt;AllowAmbiguousTypes&lt;/code&gt;&lt;/a&gt; switches off the ambiguity check.</source>
          <target state="translated">Идея состоит в том, что не может быть никаких законных вызовов к &lt;code&gt;f&lt;/code&gt; , потому что каждый вызов вызывает неоднозначное ограничение. Действительно, &lt;em&gt;единственная&lt;/em&gt; цель проверки на двусмысленность - сообщить о функциях, которые невозможно вызвать. Мы могли бы полностью отказаться от проверки неоднозначности сигнатур типов за счет задержки ошибок неоднозначности для вызова сайтов. Действительно, языковое расширение &lt;a href=&quot;#extension-AllowAmbiguousTypes&quot;&gt; &lt;code&gt;AllowAmbiguousTypes&lt;/code&gt; &lt;/a&gt; отключает проверку на неоднозначность.</target>
        </trans-unit>
        <trans-unit id="9edc673edb982c2282b649a46c26961301e8081f" translate="yes" xml:space="preserve">
          <source>The idea of using existential quantification in data type declarations was suggested by Perry, and implemented in Hope+ (Nigel Perry, &lt;em&gt;The Implementation of Practical Functional Programming Languages&lt;/em&gt;, PhD Thesis, University of London, 1991). It was later formalised by Laufer and Odersky (&lt;em&gt;Polymorphic type inference and abstract data types&lt;/em&gt;, TOPLAS, 16(5), pp. 1411-1430, 1994). It&amp;rsquo;s been in Lennart Augustsson&amp;rsquo;s &lt;code&gt;hbc&lt;/code&gt; Haskell compiler for several years, and proved very useful. Here&amp;rsquo;s the idea. Consider the declaration:</source>
          <target state="translated">Идея использования экзистенциальной квантификации в объявлениях типов данных была предложена Перри и реализована в Hope + (Найджел Перри, &lt;em&gt;Реализация практических функциональных языков программирования&lt;/em&gt; , докторская диссертация, Лондонский университет, 1991). Позднее он был формализован Лауфером и Одерским ( &lt;em&gt;вывод полиморфных типов и абстрактные типы данных&lt;/em&gt; , TOPLAS, 16 (5), стр. 1411-1430, 1994). Он был &lt;code&gt;hbc&lt;/code&gt; компилятор hbc Haskell Леннарта Аугустссона несколько лет и оказался очень полезным. Вот идея. Рассмотрим декларацию:</target>
        </trans-unit>
        <trans-unit id="f61001cad70bbaad44a625a79404312846844b51" translate="yes" xml:space="preserve">
          <source>The identity arrow, which plays the role of &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in arrow notation.</source>
          <target state="translated">Стрелка идентичности, которая играет роль &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; в обозначении стрелки.</target>
        </trans-unit>
        <trans-unit id="d797741d4a3ad156d7b9784f618a05a1d311a057" translate="yes" xml:space="preserve">
          <source>The identity functor and monad.</source>
          <target state="translated">Фанктор личности и Монада.</target>
        </trans-unit>
        <trans-unit id="7c8b0e59b588b67f3edbe61854791ee47cfe12bb" translate="yes" xml:space="preserve">
          <source>The identity monad transformer</source>
          <target state="translated">Трансформатор идентичности &quot;Монад</target>
        </trans-unit>
        <trans-unit id="54f9712c13de60b181bae26ad1f4c1f7a1f328db" translate="yes" xml:space="preserve">
          <source>The identity monad transformer.</source>
          <target state="translated">Трансформатор Монада Личности.</target>
        </trans-unit>
        <trans-unit id="bf1cafdec594d8369ed303bb1c662b40aaf0daff" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Личность &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4ceda1c87510537b203d25ca80c04c39b54cdf6" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt;. It should also satisfy the equations</source>
          <target state="translated">Личность &lt;code&gt;&lt;a href=&quot;control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; . Он также должен удовлетворять уравнениям</target>
        </trans-unit>
        <trans-unit id="deee9983cee920e92095b678fac9a903e0f11845" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Личность &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="034960daf8bea9c51407ed94a1c25464ed2788bc" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;ghc-base#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt;. It should also satisfy the equations</source>
          <target state="translated">Личность &lt;code&gt;&lt;a href=&quot;ghc-base#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; . Он также должен удовлетворять уравнениям</target>
        </trans-unit>
        <trans-unit id="5dbaaef3597110434c54ae1a2138fb5629731bbb" translate="yes" xml:space="preserve">
          <source>The implementation does not support system calls.</source>
          <target state="translated">Реализация не поддерживает системные вызовы.</target>
        </trans-unit>
        <trans-unit id="7512c5f22af2e468e091d738afee317bd6f3ab0c" translate="yes" xml:space="preserve">
          <source>The implementation is based on</source>
          <target state="translated">Реализация основана на</target>
        </trans-unit>
        <trans-unit id="4406a52eaac6bbe886c15f95aa7c9a4f4887ba65" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. Additionally, benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">Реализация основана на &lt;em&gt;деревьях патриции с прямым порядком байтов&lt;/em&gt; . Эта структура данных особенно хорошо работает с бинарными операциями, такими как &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; . Кроме того, тесты показывают, что он также (намного) быстрее при вставке и удалении по сравнению с общей реализацией карты со сбалансированным размером (см. &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="42cee383ad635f6c8d6a1715e198b017fcd560b8" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. Additionally, benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">Реализация основана на &lt;em&gt;деревьях патриции с прямым порядком байтов&lt;/em&gt; . Эта структура данных особенно хорошо работает с бинарными операциями, такими как &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; . Кроме того, тесты показывают, что он также (намного) быстрее при вставке и удалении по сравнению с общей реализацией карты со сбалансированным размером (см. &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5899bda78d1b99406df43306b7f1534696819133" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. Additionally, benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">Реализация основана на &lt;em&gt;деревьях патриции с прямым порядком байтов&lt;/em&gt; . Эта структура данных особенно хорошо работает с бинарными операциями, такими как &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; . Кроме того, тесты показывают, что он также (намного) быстрее при вставке и удалении по сравнению с общей реализацией карты со сбалансированным размером (см. &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="78d8c8ee898c5c545e70528f4e14f986552f2ded" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">Реализация основана на &lt;em&gt;деревьях патриции с прямым порядком байтов&lt;/em&gt; . Эта структура данных особенно хорошо работает с бинарными операциями, такими как &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; . Однако мои тесты показывают, что он также (намного) быстрее при вставке и удалении по сравнению с общей реализацией карты со сбалансированным размером (см. &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="24c8616bf917dc1c69eac297bc08b786fe0c06a6" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intset#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intset#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced set implementation (see &lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;).</source>
          <target state="translated">Реализация основана на &lt;em&gt;деревьях патриции с прямым порядком байтов&lt;/em&gt; . Эта структура данных особенно хорошо работает с бинарными операциями, такими как &lt;code&gt;&lt;a href=&quot;data-intset#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-intset#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; . Однако мои тесты показывают, что он также (намного) быстрее при вставке и удалении по сравнению с общей реализацией набора со сбалансированным размером (см. &lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="55fccc3b15937a9358c0161b537d1afd44dfe908" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced set implementation (see &lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;).</source>
          <target state="translated">Реализация основана на &lt;em&gt;деревьях патриции с прямым порядком байтов&lt;/em&gt; . Эта структура данных особенно хорошо работает с бинарными операциями, такими как &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; . Однако мои тесты показывают, что он также (намного) быстрее при вставке и удалении по сравнению с общей реализацией набора со сбалансированным размером (см. &lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="178e58b7fb96bd95fd580401e99f441f886cc770" translate="yes" xml:space="preserve">
          <source>The implementation is based on the traditional purely-functional queue representation that uses two lists to obtain amortised O(1) enqueue and dequeue operations.</source>
          <target state="translated">Реализация основана на традиционном чисто функциональном представлении очереди,использующем два списка для получения амортизированных операций O(1)enqueue и dequeue.</target>
        </trans-unit>
        <trans-unit id="4463036bd69024477097c960a434a6af09c8061f" translate="yes" xml:space="preserve">
          <source>The implementation is required to ensure that reordering of memory operations cannot cause type-correct code to go wrong. In particular, when inspecting the value read from an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;, the memory writes that created that value must have occurred from the point of view of the current thread.</source>
          <target state="translated">Реализация требуется, чтобы гарантировать, что переупорядочение операций с памятью не может привести к неправильному выполнению кода с правильным типом. В частности, при проверке значения, считанного из &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; , записи в память, которые создали это значение, должны были произойти с точки зрения текущего потока.</target>
        </trans-unit>
        <trans-unit id="fb8ec445b14ea757e9282327414d673b0305ee28" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;. If the function passed to &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; inspects its argument, the resulting action will throw &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:FixIOException&quot;&gt;FixIOException&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Реализация &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; . Если функция, переданная &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; , проверяет свой аргумент, результирующее действие вызовет &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:FixIOException&quot;&gt;FixIOException&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10f5d1702e3170c14a64676532aebf2fd23b667a" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is based on &lt;em&gt;size balanced&lt;/em&gt; binary trees (or trees of &lt;em&gt;bounded balance&lt;/em&gt;) as described by:</source>
          <target state="translated">Реализация &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; основана на &lt;em&gt;сбалансированных&lt;/em&gt; по &lt;em&gt;размеру&lt;/em&gt; двоичных деревьях (или деревьях с &lt;em&gt;ограниченным балансом&lt;/em&gt; ), как описано:</target>
        </trans-unit>
        <trans-unit id="f3594b695ff2e4cfc4a3fffda3940bb5f4b15f6c" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is based on &lt;em&gt;size balanced&lt;/em&gt; binary trees (or trees of &lt;em&gt;bounded balance&lt;/em&gt;) as described by:</source>
          <target state="translated">Реализация &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; основана на &lt;em&gt;сбалансированных&lt;/em&gt; по &lt;em&gt;размеру&lt;/em&gt; двоичных деревьях (или деревьях с &lt;em&gt;ограниченным балансом&lt;/em&gt; ), как описано:</target>
        </trans-unit>
        <trans-unit id="f3ded865df489185e9f39c1a5890fb3ac2d0d16a" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; is based on &lt;em&gt;size balanced&lt;/em&gt; binary trees (or trees of &lt;em&gt;bounded balance&lt;/em&gt;) as described by:</source>
          <target state="translated">Реализация &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; основана на &lt;em&gt;сбалансированных&lt;/em&gt; по &lt;em&gt;размеру&lt;/em&gt; двоичных деревьях (или деревьях &lt;em&gt;ограниченного баланса&lt;/em&gt; ), как описано ниже:</target>
        </trans-unit>
        <trans-unit id="2eb1e65a073f89d353d1b82491d0d335135d9d69" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;code&gt;&lt;a href=&quot;ghci-message#v:RunTH&quot;&gt;RunTH&lt;/a&gt;&lt;/code&gt; message</source>
          <target state="translated">Реализация сообщения &lt;code&gt;&lt;a href=&quot;ghci-message#v:RunTH&quot;&gt;RunTH&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0444f9d8082237d5b98f84df587436a9614cf1ab" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;code&gt;&lt;a href=&quot;ghci-message#v:StartTH&quot;&gt;StartTH&lt;/a&gt;&lt;/code&gt; message: create a new IORef QState, and return a RemoteRef to it.</source>
          <target state="translated">Реализация сообщения &lt;code&gt;&lt;a href=&quot;ghci-message#v:StartTH&quot;&gt;StartTH&lt;/a&gt;&lt;/code&gt; : создайте новый QState IORef и верните ему RemoteRef.</target>
        </trans-unit>
        <trans-unit id="6bc3fa0b81755563203b0ca242878725420112c8" translate="yes" xml:space="preserve">
          <source>The implementation uses 2-3 finger trees annotated with sizes, as described in section 4.2 of</source>
          <target state="translated">В реализации используются 2-3 дерева пальцев,аннотированные размерами,как описано в разделе 4.2.</target>
        </trans-unit>
        <trans-unit id="a87c4ceafe0cd86c1c0f98a96d0e26cff7b08cc5" translate="yes" xml:space="preserve">
          <source>The implementation uses the call-stack simulation maintained by the profiler, so it only works if the program was compiled with &lt;code&gt;-prof&lt;/code&gt; and contains suitable SCC annotations (e.g. by using &lt;code&gt;-fprof-auto&lt;/code&gt;). Otherwise, the list returned is likely to be empty or uninformative.</source>
          <target state="translated">Реализация использует имитацию стека вызовов, поддерживаемую профилировщиком, поэтому она работает, только если программа была скомпилирована с &lt;code&gt;-prof&lt;/code&gt; и содержит подходящие аннотации SCC (например, с помощью &lt;code&gt;-fprof-auto&lt;/code&gt; ). В противном случае возвращенный список может быть пустым или неинформативным.</target>
        </trans-unit>
        <trans-unit id="b6788a58c1982f00220dd59a9ac7e8fe15617f19" translate="yes" xml:space="preserve">
          <source>The incoming &lt;code&gt;x&lt;/code&gt; is converted using &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from&quot;&gt;from&lt;/a&gt;&lt;/code&gt;, then we dispatch to the generic instances using &lt;code&gt;encode'&lt;/code&gt;. We use this as a default definition for &lt;code&gt;encode&lt;/code&gt;. We need the &lt;code&gt;default encode&lt;/code&gt; signature because ordinary Haskell default methods must not introduce additional class constraints, but our generic default does.</source>
          <target state="translated">Входящий &lt;code&gt;x&lt;/code&gt; преобразуется с помощью &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from&quot;&gt;from&lt;/a&gt;&lt;/code&gt; , а затем мы отправляем в общие экземпляры с помощью &lt;code&gt;encode'&lt;/code&gt; . Мы используем это как определение по умолчанию для &lt;code&gt;encode&lt;/code&gt; . Нам нужна подпись &lt;code&gt;default encode&lt;/code&gt; по умолчанию, потому что обычные методы по умолчанию Haskell не должны вводить дополнительные ограничения класса, но наше общее значение по умолчанию делает.</target>
        </trans-unit>
        <trans-unit id="2cdd8c06c5214198e849b6d05981aab3d32d8114" translate="yes" xml:space="preserve">
          <source>The incremental input interface</source>
          <target state="translated">Интерфейс инкрементного ввода</target>
        </trans-unit>
        <trans-unit id="982c0c54fd891b5bd49cff179145ac54d3aa5b07" translate="yes" xml:space="preserve">
          <source>The incremental interface consumes a strict &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; at a time, each being part of the total amount of input. If your decoder needs more input to finish it will return a &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Partial&quot;&gt;Partial&lt;/a&gt;&lt;/code&gt; with a continuation. If there is no more input, provide it &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Инкрементный интерфейс потребляет строгую &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; за раз, каждая из которых является частью общего объема ввода. Если вашему декодеру требуется больше входных данных для завершения, он вернет &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Partial&quot;&gt;Partial&lt;/a&gt;&lt;/code&gt; с продолжением. Если ввода больше нет, укажите &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3146e319b6642665d719ade7d912bb954ff2d63" translate="yes" xml:space="preserve">
          <source>The incremental interface gives you more control over how input is provided during parsing. This lets you e.g. interleave parsing and I/O.</source>
          <target state="translated">Инкрементальный интерфейс дает вам больше контроля над тем,как входные данные предоставляются во время разбора.Это позволяет,например,выполнять интерлейвный синтаксический анализ и ввод/вывод.</target>
        </trans-unit>
        <trans-unit id="c051b888dc5371d4c7a1728cceef03c9f9b40699" translate="yes" xml:space="preserve">
          <source>The information is formatted such that it can be read as a of type &lt;code&gt;[(String, String)]&lt;/code&gt;. Currently the following fields are present:</source>
          <target state="translated">Информация отформатирована так, чтобы ее можно было прочитать как тип &lt;code&gt;[(String, String)]&lt;/code&gt; . В настоящее время присутствуют следующие поля:</target>
        </trans-unit>
        <trans-unit id="5a76a6fe1392f713b6ebeea929ebb56029f377be" translate="yes" xml:space="preserve">
          <source>The initial counter value can be negative which denotes a resource &quot;debt&quot; that requires a respective amount of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:signalTSem&quot;&gt;signalTSem&lt;/a&gt;&lt;/code&gt; operations to counter-balance.</source>
          <target state="translated">Начальное значение счетчика может быть отрицательным, что означает &amp;laquo;долг&amp;raquo; ресурса, который требует соответствующего количества операций &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:signalTSem&quot;&gt;signalTSem&lt;/a&gt;&lt;/code&gt; для уравновешивания.</target>
        </trans-unit>
        <trans-unit id="2dec26d2e77fa146664e92628931f0bd402a7a5d" translate="yes" xml:space="preserve">
          <source>The initial value left and right of the cursor</source>
          <target state="translated">Начальное значение слева и справа от курсора</target>
        </trans-unit>
        <trans-unit id="c7b64e8e48e54908c3b727b4c3f0042b5289f865" translate="yes" xml:space="preserve">
          <source>The initialisation routine, &lt;code&gt;mylib_init&lt;/code&gt;, calls &lt;code&gt;hs_init()&lt;/code&gt; as normal to initialise the Haskell runtime, and the corresponding deinitialisation function &lt;code&gt;mylib_end()&lt;/code&gt; calls &lt;code&gt;hs_exit()&lt;/code&gt; to shut down the runtime.</source>
          <target state="translated">Подпрограмма инициализации &lt;code&gt;mylib_init&lt;/code&gt; вызывает &lt;code&gt;hs_init()&lt;/code&gt; как обычно для инициализации среды выполнения Haskell, а соответствующая функция деинициализации &lt;code&gt;mylib_end()&lt;/code&gt; вызывает &lt;code&gt;hs_exit()&lt;/code&gt; для завершения работы среды выполнения.</target>
        </trans-unit>
        <trans-unit id="74ecac49867880c39edcc9122f73fce73221a98f" translate="yes" xml:space="preserve">
          <source>The input file should end with .hsc (it should be plain Haskell source only; literate Haskell is not supported at the moment). Output files by default get names with the &lt;code&gt;.hsc&lt;/code&gt; suffix replaced:</source>
          <target state="translated">Входной файл должен заканчиваться на .hsc (это должен быть только простой исходный код Haskell; грамотный Haskell в настоящее время не поддерживается). Выходные файлы по умолчанию получают имена с &lt;code&gt;.hsc&lt;/code&gt; суффиксом .hsc :</target>
        </trans-unit>
        <trans-unit id="54a5800cd273f30522c8241f5237a75f5ea6ce1e" translate="yes" xml:space="preserve">
          <source>The input lines stored in the history (newest first)</source>
          <target state="translated">Строки ввода,сохраненные в истории (последняя первая)</target>
        </trans-unit>
        <trans-unit id="6c739498395288f23756ffacf049c5d728041bb8" translate="yes" xml:space="preserve">
          <source>The input prompt</source>
          <target state="translated">Оповещение о вводе</target>
        </trans-unit>
        <trans-unit id="57092b7ab7c2a987bc9c90336b0ad9cdf5249eb0" translate="yes" xml:space="preserve">
          <source>The input value that caused the error. If the error arose because the end of input was reached or could not be identified precisely, this value will be &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Входное значение, вызвавшее ошибку. Если ошибка возникла из-за того, что конец ввода был достигнут или не удалось точно определить, это значение будет &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38d4405c8eebc2938893eeda1606e7e5691e0dd1" translate="yes" xml:space="preserve">
          <source>The installer that installs GHC on Win32 also sets up the file-suffix associations for &amp;rdquo;.hs&amp;rdquo; and &amp;rdquo;.lhs&amp;rdquo; files so that double-clicking them starts &lt;code&gt;ghci&lt;/code&gt;.</source>
          <target state="translated">Программа установки, устанавливающая GHC на Win32, также устанавливает ассоциации файловых суффиксов для файлов &amp;laquo;.hs&amp;raquo; и &amp;laquo;.lhs&amp;raquo;, так что двойной щелчок по ним запускает &lt;code&gt;ghci&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aeaab7d9918fe1175bfdf3172a8ff60d6d574ffa" translate="yes" xml:space="preserve">
          <source>The instance axioms : &lt;code&gt;(B a, D a, E a) =&amp;gt; F a&lt;/code&gt;</source>
          <target state="translated">Аксиомы экземпляра: &lt;code&gt;(B a, D a, E a) =&amp;gt; F a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf7d82e643d691468293fcd6f5135cfe7a24d9a1" translate="yes" xml:space="preserve">
          <source>The instance context is determined by the type signatures of the derived class&amp;rsquo;s methods. For instance, if the class is:</source>
          <target state="translated">Контекст экземпляра определяется сигнатурами типов методов производного класса. Например, если класс:</target>
        </trans-unit>
        <trans-unit id="ead7524ad446883d4bbd99873e64016bb63c69da" translate="yes" xml:space="preserve">
          <source>The instance declaration is only relevant if the type &lt;code&gt;T&lt;/code&gt; is in use, and if so, GHC will have visited &lt;code&gt;A&lt;/code&gt;&amp;lsquo;s interface file to find &lt;code&gt;T&lt;/code&gt;&amp;lsquo;s definition.</source>
          <target state="translated">Объявление экземпляра имеет значение только если тип &lt;code&gt;T&lt;/code&gt; используется, и если да, то GHC будет Побывали &lt;code&gt;A&lt;/code&gt; &amp;laquo;s файл интерфейса , чтобы найти &lt;code&gt;T&lt;/code&gt; &amp;raquo; определение s.</target>
        </trans-unit>
        <trans-unit id="c7c21710f81c09d49133c941cdff45d1b58bd4f0" translate="yes" xml:space="preserve">
          <source>The instance declarations of a data family used in a single program may not overlap at all, independent of whether they are associated or not. In contrast to type class instances, this is not only a matter of consistency, but one of type safety.</source>
          <target state="translated">Объявления экземпляров семейства данных,используемые в одной программе,могут вообще не совпадать,независимо от того,связаны они или нет.В отличие от экземпляров классов типов,это вопрос не только согласованности,но и безопасности типов.</target>
        </trans-unit>
        <trans-unit id="8cc7dac373c8ecc1b365857145ddad40214eea96" translate="yes" xml:space="preserve">
          <source>The instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; is slightly awkward (but also rarely used):</source>
          <target state="translated">Пример для &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; немного неудобен (но также редко используется):</target>
        </trans-unit>
        <trans-unit id="289b8b3ebc33cd2f4157166d16a368f79f089f26" translate="yes" xml:space="preserve">
          <source>The instance for an associated type can be omitted in class instances. In that case, unless there is a default instance (see &lt;a href=&quot;#assoc-decl-defs&quot;&gt;Associated type synonym defaults&lt;/a&gt;), the corresponding instance type is not inhabited; i.e., only diverging expressions, such as &lt;code&gt;undefined&lt;/code&gt;, can assume the type.</source>
          <target state="translated">Экземпляр для связанного типа может быть опущен в экземплярах класса. В этом случае, если не существует экземпляра по умолчанию (см. &lt;a href=&quot;#assoc-decl-defs&quot;&gt;Значения по умолчанию для синонима связанного типа&lt;/a&gt; ), соответствующий тип экземпляра не используется; то есть только расходящиеся выражения, такие как &lt;code&gt;undefined&lt;/code&gt; , могут принимать тип.</target>
        </trans-unit>
        <trans-unit id="59904cb0ab2fe8f19f68bd984f2b517b8091cc17" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">Экземпляры &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; для списков, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; , определенные в &lt;a href=&quot;prelude&quot;&gt;Prelude,&lt;/a&gt; удовлетворяют этим законам.</target>
        </trans-unit>
        <trans-unit id="585199a1b65eac2628d79ac97b369b88ce05f950" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">Экземпляры &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; для списков, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; , определенные в &lt;a href=&quot;prelude&quot;&gt;Prelude,&lt;/a&gt; удовлетворяют этим законам.</target>
        </trans-unit>
        <trans-unit id="1581053810276ec21d30df3978e3008a7ff9fc55" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">Экземпляры &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; для списков, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; , определенные в &lt;a href=&quot;prelude&quot;&gt;Prelude,&lt;/a&gt; удовлетворяют этим законам.</target>
        </trans-unit>
        <trans-unit id="1a017b052435df19797d88fb110f1e8782d90594" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">Экземпляры &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; для списков, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; , определенные в &lt;a href=&quot;prelude&quot;&gt;Prelude,&lt;/a&gt; удовлетворяют этим законам.</target>
        </trans-unit>
        <trans-unit id="f9f0c8e6289e586cc5baeea5fcfbbbe115d5e7f6" translate="yes" xml:space="preserve">
          <source>The intention is for &lt;code&gt;IsLabel&lt;/code&gt; to be used to support overloaded record fields and perhaps anonymous records. Thus, it may be given instances for base datatypes (in particular &lt;code&gt;(-&amp;gt;)&lt;/code&gt;) in the future.</source>
          <target state="translated">Предполагается, что &lt;code&gt;IsLabel&lt;/code&gt; будет использоваться для поддержки полей перегруженных записей и, возможно, анонимных записей. Таким образом, в будущем ему могут быть предоставлены экземпляры для базовых типов данных (в частности &lt;code&gt;(-&amp;gt;)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="26b1329858bfddb7f19887db1797b6a20a449184" translate="yes" xml:space="preserve">
          <source>The interact function takes a function of type &lt;code&gt;ByteString -&amp;gt; ByteString&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">Функция взаимодействия принимает в качестве аргумента функцию типа &lt;code&gt;ByteString -&amp;gt; ByteString&lt;/code&gt; . Весь ввод от стандартного устройства ввода передается этой функции в качестве аргумента, а результирующая строка выводится на стандартное устройство вывода.</target>
        </trans-unit>
        <trans-unit id="28bb27e789e236bd63cc99925076154513d01eb7" translate="yes" xml:space="preserve">
          <source>The interactive classes (only relevant when &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt;&lt;code&gt;ExtendedDefaultRules&lt;/code&gt;&lt;/a&gt; is in effect) are: any numeric class, &lt;code&gt;Show&lt;/code&gt;, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Foldable&lt;/code&gt; or &lt;code&gt;Traversable&lt;/code&gt;.</source>
          <target state="translated">К интерактивным классам (актуальным только при использовании &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt; &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; &lt;/a&gt; ) относятся: любой числовой класс, &lt;code&gt;Show&lt;/code&gt; , &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Foldable&lt;/code&gt; или &lt;code&gt;Traversable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c15d5fb52d82aa70762f462a28f7dddcf408ca0" translate="yes" xml:space="preserve">
          <source>The interface file, which normally ends in a &lt;code&gt;.hi&lt;/code&gt; suffix, contains the information that GHC needs in order to compile further modules that depend on this module. It contains things like the types of exported functions, definitions of data types, and so on. It is stored in a binary format, so don&amp;rsquo;t try to read one; use the &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; option instead (see &lt;a href=&quot;#hi-options&quot;&gt;Other options related to interface files&lt;/a&gt;).</source>
          <target state="translated">Файл интерфейса, который обычно заканчивается суффиксом &lt;code&gt;.hi&lt;/code&gt; , содержит информацию, которая необходима GHC для компиляции дополнительных модулей, которые зависят от этого модуля. Он содержит такие вещи, как типы экспортируемых функций, определения типов данных и так далее. Он хранится в двоичном формате, поэтому не пытайтесь его прочитать; вместо этого используйте параметр &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; (см. &lt;a href=&quot;#hi-options&quot;&gt;Другие параметры, связанные с интерфейсными файлами&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="01f926777c79e4e6d52fb1a2cf6afecc0a8b7f65" translate="yes" xml:space="preserve">
          <source>The interface output may be directed to another file &lt;code&gt;bar2/Wurble.iface&lt;/code&gt; with the option &lt;code&gt;-ohi bar2/Wurble.iface&lt;/code&gt; (not recommended).</source>
          <target state="translated">Вывод интерфейса может быть направлен в другой файл &lt;code&gt;bar2/Wurble.iface&lt;/code&gt; с опцией &lt;code&gt;-ohi bar2/Wurble.iface&lt;/code&gt; (не рекомендуется).</target>
        </trans-unit>
        <trans-unit id="d422eff6b38b54b7b01cf3f23285761f3009b5be" translate="yes" xml:space="preserve">
          <source>The interface provides &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;, a type representation which can be safely decomposed and composed. See &lt;a href=&quot;data-dynamic&quot;&gt;Data.Dynamic&lt;/a&gt; for an example of this.</source>
          <target state="translated">Интерфейс предоставляет &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; , представление типа, которое можно безопасно разложить и составить. См. &lt;a href=&quot;data-dynamic&quot;&gt;Пример этого в Data.Dynamic&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7525fed411a95f2aba1be67c722e982ae098165e" translate="yes" xml:space="preserve">
          <source>The interpreter can&amp;rsquo;t load modules with foreign export declarations!</source>
          <target state="translated">Интерпретатор не может загружать модули с внешними экспортными декларациями!</target>
        </trans-unit>
        <trans-unit id="c6f1b29cc56478e029057e80fde7617996385c3a" translate="yes" xml:space="preserve">
          <source>The interpreter doesn&amp;rsquo;t support unboxed tuples, so GHCi will automatically compile these modules, and all modules they depend on, to object code instead of bytecode.</source>
          <target state="translated">Интерпретатор не поддерживает распакованные кортежи, поэтому GHCi автоматически компилирует эти модули и все модули, от которых они зависят, в объектный код вместо байт-кода.</target>
        </trans-unit>
        <trans-unit id="bcc96915fbf058774c86b1ad6764191d649fe219" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратное &lt;code&gt;&lt;a href=&quot;control-monad-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="960baabb94ec6d41e7f419f3f0516ce7cfa51827" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратное &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25e108698be586db7ffe3f616a94bfc73b7ee1a2" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:mondayStartWeek&quot;&gt;mondayStartWeek&lt;/a&gt;&lt;/code&gt;. Get a &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; given the year, the number of the Monday-starting week, and the day of the week. The first Monday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%W&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Обратный &lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:mondayStartWeek&quot;&gt;mondayStartWeek&lt;/a&gt;&lt;/code&gt; . Получите &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; учетом года, номера недели, начинающейся с понедельника, и дня недели. Первый понедельник - это первый день недели 1, любые более ранние дни в году - это неделя 0 (как &lt;code&gt;%W&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2617db8ad5e573ea343c5794cabc4dfe2b8d32ba" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:sundayStartWeek&quot;&gt;sundayStartWeek&lt;/a&gt;&lt;/code&gt;. Get a &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; given the year and the number of the day of a Sunday-starting week. The first Sunday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%U&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Обратное &lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:sundayStartWeek&quot;&gt;sundayStartWeek&lt;/a&gt;&lt;/code&gt; . Получите &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; учетом года и номера дня недели, начинающейся с воскресенья. Первое воскресенье - это первый день недели 1, любые более ранние дни в году - это неделя 0 (как &lt;code&gt;%U&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8e1d7169fde4f120c1aa4f3ece9ee57253f95f60" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt;, i.e., we have the identity</source>
          <target state="translated">Обратный к &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt; , т.е. у нас есть тождество</target>
        </trans-unit>
        <trans-unit id="085f4b1b3304279a7c72a59a48e1ceb8b934a83e" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;ghc-stable#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt;, i.e., we have the identity</source>
          <target state="translated">Обратный к &lt;code&gt;&lt;a href=&quot;ghc-stable#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt; , т.е. у нас есть тождество</target>
        </trans-unit>
        <trans-unit id="bdd2cce8158f1320bcd058983fb015f9d2fa4781" translate="yes" xml:space="preserve">
          <source>The key component of a typechecker plugin is a function of type &lt;code&gt;TcPluginSolver&lt;/code&gt;, like this:</source>
          <target state="translated">Ключевым компонентом подключаемого модуля проверки типов является функция типа &lt;code&gt;TcPluginSolver&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="50146b4ed40e4fdb3a0f98772092c373b41b7b82" translate="yes" xml:space="preserve">
          <source>The key difference here is that we abstract over the type constructor &lt;code&gt;c&lt;/code&gt; that is used to form the collection type &lt;code&gt;c e&lt;/code&gt;, and not over that collection type itself, represented by &lt;code&gt;ce&lt;/code&gt; in the original class declaration. This avoids the immediate problems that we mentioned above: empty has type &lt;code&gt;Collects e c =&amp;gt; c e&lt;/code&gt;, which is not ambiguous.</source>
          <target state="translated">Ключевое отличие здесь состоит в том, что мы абстрагируемся над конструктором типа &lt;code&gt;c&lt;/code&gt; , который используется для формирования типа коллекции &lt;code&gt;c e&lt;/code&gt; , а не над самим типом коллекции, представленным &lt;code&gt;ce&lt;/code&gt; в исходном объявлении класса. Это позволяет избежать непосредственных проблем, о которых мы упоминали выше: empty имеет тип &lt;code&gt;Collects e c =&amp;gt; c e&lt;/code&gt; , что не является неоднозначным.</target>
        </trans-unit>
        <trans-unit id="d931654af7b546e8d6ff7d64be51ee7d51eed95b" translate="yes" xml:space="preserve">
          <source>The key point about GADTs is that &lt;em&gt;pattern matching causes type refinement&lt;/em&gt;. For example, in the right hand side of the equation</source>
          <target state="translated">Ключевым моментом в GADT является то, что &lt;em&gt;сопоставление с образцом вызывает уточнение типа&lt;/em&gt; . Например, в правой части уравнения</target>
        </trans-unit>
        <trans-unit id="1c6ccf2ae2f2b690d9a1832c4814300edcd715a9" translate="yes" xml:space="preserve">
          <source>The key to defining your own datatype-generic functions is to understand how to represent datatypes using the given set of type constructors.</source>
          <target state="translated">Ключом к определению собственных генерических функций типа данных является понимание того,как представлять типы данных с помощью заданного набора конструкторов типов.</target>
        </trans-unit>
        <trans-unit id="101f96a1728772ac592ac70565bf2d4fd3554ddc" translate="yes" xml:space="preserve">
          <source>The key tool to use in making your Haskell program run faster are GHC&amp;rsquo;s profiling facilities, described separately in &lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;. There is &lt;em&gt;no substitute&lt;/em&gt; for finding where your program&amp;rsquo;s time/space is &lt;em&gt;really&lt;/em&gt; going, as opposed to where you imagine it is going.</source>
          <target state="translated">Ключевым инструментом для ускорения работы вашей программы на Haskell являются средства профилирования GHC, описанные отдельно в &lt;a href=&quot;profiling#profiling&quot;&gt;разделе Профилирование&lt;/a&gt; . Ничто &lt;em&gt;не заменит&lt;/em&gt; поиск того, куда на &lt;em&gt;самом деле&lt;/em&gt; движется время / пространство вашей программы , в отличие от того, куда вы его представляете.</target>
        </trans-unit>
        <trans-unit id="52cd9e5fb65950d32847b984e9879cffe2f00ec9" translate="yes" xml:space="preserve">
          <source>The keypad</source>
          <target state="translated">Клавиатура</target>
        </trans-unit>
        <trans-unit id="89852fc3a3f80fb4cacd31fc13b712715ce5683a" translate="yes" xml:space="preserve">
          <source>The kind &lt;code&gt;Type&lt;/code&gt; (imported from &lt;code&gt;Data.Kind&lt;/code&gt;) classifies ordinary types. With &lt;a href=&quot;#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; (currently enabled by default), &lt;code&gt;*&lt;/code&gt; is desugared to &lt;code&gt;Type&lt;/code&gt;, but using this legacy syntax is not recommended due to conflicts with &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt;. This also applies to &lt;code&gt;★&lt;/code&gt;, the Unicode variant of &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">Вид &lt;code&gt;Type&lt;/code&gt; (импортирован из &lt;code&gt;Data.Kind&lt;/code&gt; ) классифицирует обычные типы. С &lt;a href=&quot;#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt; (в настоящее время включен по умолчанию) &lt;code&gt;*&lt;/code&gt; заменяется на &lt;code&gt;Type&lt;/code&gt; , но использование этого устаревшего синтаксиса не рекомендуется из-за конфликтов с &lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt; . Это также относится к &lt;code&gt;★&lt;/code&gt; , варианту Unicode &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cd808c3a0aa47774f7ee55994f44b345c1912bc" translate="yes" xml:space="preserve">
          <source>The kind of &lt;code&gt;Foo&lt;/code&gt;&amp;lsquo;s parameter is &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt;, but the kind of &lt;code&gt;Proxy&lt;/code&gt; is &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt;, where &lt;code&gt;{k}&lt;/code&gt; denotes that the kind variable &lt;code&gt;k&lt;/code&gt; is to be inferred, not specified by the user. (See &lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt; for more discussion on the inferred-specified distinction). GHC does not consider &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; and &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; to be equal at the kind level, and thus rejects &lt;code&gt;Foo Proxy&lt;/code&gt; as ill-kinded.</source>
          <target state="translated">Тип параметра &lt;code&gt;Foo&lt;/code&gt; - для &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; , но вид &lt;code&gt;Proxy&lt;/code&gt; является &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; , где &lt;code&gt;{k}&lt;/code&gt; означает, что должна быть выведена переменная вида &lt;code&gt;k&lt;/code&gt; , а не указана пользователем. (См. &lt;a href=&quot;#visible-type-application&quot;&gt;Приложение с видимым типом&lt;/a&gt; для более подробного обсуждения предполагаемого различия). GHC не рассматривает все &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; и все &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; должен быть равным на уровне доброты, и, таким образом, отклоняет &lt;code&gt;Foo Proxy&lt;/code&gt; как недоброжелательный.</target>
        </trans-unit>
        <trans-unit id="d650258dfa554e9a0a612c8d7a0289cda5964e46" translate="yes" xml:space="preserve">
          <source>The kind of &lt;code&gt;Vec&lt;/code&gt; is &lt;code&gt;Type -&amp;gt; Type -&amp;gt; Type&lt;/code&gt;. This means that, e.g., &lt;code&gt;Vec Int Char&lt;/code&gt; is a well-kinded type, even though this is not what we intend when defining length-indexed vectors.</source>
          <target state="translated">Тип &lt;code&gt;Vec&lt;/code&gt; - это &lt;code&gt;Type -&amp;gt; Type -&amp;gt; Type&lt;/code&gt; . Это означает, что, например, &lt;code&gt;Vec Int Char&lt;/code&gt; является хорошо подобранным типом, хотя это не то, что мы имели в виду при определении векторов с индексом длины.</target>
        </trans-unit>
        <trans-unit id="6bdcf0025de5c2355bf036fb20350561d0e1ffc4" translate="yes" xml:space="preserve">
          <source>The kind of constraints, like &lt;code&gt;Show a&lt;/code&gt;</source>
          <target state="translated">Такие ограничения, как &lt;code&gt;Show a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3970d2a390e8339e6194fae0a800fd7ee383f1f3" translate="yes" xml:space="preserve">
          <source>The kind of types with values. For example &lt;code&gt;Int :: Type&lt;/code&gt;.</source>
          <target state="translated">Вид типов со значениями. Например &lt;code&gt;Int :: Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a2ff1eafaf2cf50aa099b7bed39cd8ce178efc2" translate="yes" xml:space="preserve">
          <source>The kind-polymorphism from the class declaration makes &lt;code&gt;D1&lt;/code&gt; kind-polymorphic, but not so &lt;code&gt;D2&lt;/code&gt;; and similarly &lt;code&gt;F1&lt;/code&gt;, &lt;code&gt;F1&lt;/code&gt;.</source>
          <target state="translated">Тип-полиморфизм из объявления класса делает вид-полиморфизм &lt;code&gt;D1&lt;/code&gt; , но не &lt;code&gt;D2&lt;/code&gt; ; и аналогично &lt;code&gt;F1&lt;/code&gt; , &lt;code&gt;F1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="142a287b02ca78aabf16196f308cd74692a41234" translate="yes" xml:space="preserve">
          <source>The kinds of the literals and all other low-level operations for this feature are defined in module &lt;code&gt;GHC.TypeLits&lt;/code&gt;. Note that the module defines some type-level operators that clash with their value-level counterparts (e.g. &lt;code&gt;(+)&lt;/code&gt;). Import and export declarations referring to these operators require an explicit namespace annotation (see &lt;a href=&quot;#explicit-namespaces&quot;&gt;Explicit namespaces in import/export&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;GHC.TypeLits&lt;/code&gt; литералов и все другие низкоуровневые операции для этой функции определены в модуле GHC.TypeLits . Обратите внимание, что модуль определяет некоторые операторы уровня типа, которые конфликтуют со своими аналогами на уровне значений (например, &lt;code&gt;(+)&lt;/code&gt; ). Объявления импорта и экспорта, относящиеся к этим операторам, требуют явной аннотации пространства имен (см. &lt;a href=&quot;#explicit-namespaces&quot;&gt;Явные пространства имен в импорте / экспорте&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f14aa2c065169defb0f47595c9265ce4ba5857e8" translate="yes" xml:space="preserve">
          <source>The lag stage, which is the time between creation and the first use of the object,</source>
          <target state="translated">Этап запаздывания-время между созданием и первым использованием объекта,</target>
        </trans-unit>
        <trans-unit id="67f729cc5793b907e6283b32042b3a6379b975b3" translate="yes" xml:space="preserve">
          <source>The language &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; changes this behaviour:</source>
          <target state="translated">Язык &lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt; меняет это поведение:</target>
        </trans-unit>
        <trans-unit id="96eef94888750b6bf04df904c79af345e5cf88c6" translate="yes" xml:space="preserve">
          <source>The language definition for the Haskell language.</source>
          <target state="translated">Определение языка для языка Хаскелла.</target>
        </trans-unit>
        <trans-unit id="f35e66eca43d1117d42cef793c6da9da1b53ea98" translate="yes" xml:space="preserve">
          <source>The language definition for the language Mondrian.</source>
          <target state="translated">Определение языка для языка Мондриана.</target>
        </trans-unit>
        <trans-unit id="c6db1b982530559c016310cc1374654d4e113cec" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-BinaryLiterals&quot;&gt;&lt;code&gt;BinaryLiterals&lt;/code&gt;&lt;/a&gt; adds support for expressing integer literals in binary notation with the prefix &lt;code&gt;0b&lt;/code&gt; or &lt;code&gt;0B&lt;/code&gt;. For instance, the binary integer literal &lt;code&gt;0b11001001&lt;/code&gt; will be desugared into &lt;code&gt;fromInteger 201&lt;/code&gt; when &lt;a href=&quot;#extension-BinaryLiterals&quot;&gt;&lt;code&gt;BinaryLiterals&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">Расширение языка &lt;a href=&quot;#extension-BinaryLiterals&quot;&gt; &lt;code&gt;BinaryLiterals&lt;/code&gt; &lt;/a&gt; добавляет поддержку для выражения целочисленных литералов в двоичной записи с префиксом &lt;code&gt;0b&lt;/code&gt; или &lt;code&gt;0B&lt;/code&gt; . Например, двоичный целочисленный литерал &lt;code&gt;0b11001001&lt;/code&gt; будет преобразован в &lt;code&gt;fromInteger 201&lt;/code&gt; , когда &lt;a href=&quot;#extension-BinaryLiterals&quot;&gt; &lt;code&gt;BinaryLiterals&lt;/code&gt; &lt;/a&gt; включен.</target>
        </trans-unit>
        <trans-unit id="2aa01e6792de69a814fc51631fa469117dc53520" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; allows &lt;code&gt;#&lt;/code&gt; as a postfix modifier to identifiers. Thus, &lt;code&gt;x#&lt;/code&gt; is a valid variable, and &lt;code&gt;T#&lt;/code&gt; is a valid type constructor or data constructor.</source>
          <target state="translated">Расширение языка &lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt; позволяет использовать &lt;code&gt;#&lt;/code&gt; в качестве модификатора постфикса для идентификаторов. Таким образом, &lt;code&gt;x#&lt;/code&gt; - допустимая переменная, а &lt;code&gt;T#&lt;/code&gt; - допустимый конструктор типа или конструктор данных.</target>
        </trans-unit>
        <trans-unit id="482fac3caa33dc4889f02993b124d842b7fc23c8" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-NumDecimals&quot;&gt;&lt;code&gt;NumDecimals&lt;/code&gt;&lt;/a&gt; allows you to also use the floating literal syntax for instances of &lt;code&gt;Integral&lt;/code&gt;, and have values like &lt;code&gt;(1.2e6 :: Num a =&amp;gt; a)&lt;/code&gt;</source>
          <target state="translated">Расширение языка &lt;a href=&quot;#extension-NumDecimals&quot;&gt; &lt;code&gt;NumDecimals&lt;/code&gt; &lt;/a&gt; позволяет также использовать синтаксис плавающего литерала для экземпляров &lt;code&gt;Integral&lt;/code&gt; и иметь такие значения, как &lt;code&gt;(1.2e6 :: Num a =&amp;gt; a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7301f20dd6642c45e1a8ac269b635e38af928e05" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; adds support for expressing underscores in numeric literals. For instance, the numeric literal &lt;code&gt;1_000_000&lt;/code&gt; will be parsed into &lt;code&gt;1000000&lt;/code&gt; when &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; is enabled. That is, underscores in numeric literals are ignored when &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; is enabled. See also &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14473&quot;&gt;Issue #14473&lt;/a&gt;.</source>
          <target state="translated">Расширение языка &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt; добавляет поддержку выражения подчеркивания в числовых литералах. Например, числовой литерал &lt;code&gt;1_000_000&lt;/code&gt; будет преобразован в &lt;code&gt;1000000&lt;/code&gt; , если включен &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt; . То есть подчеркивания в числовых литералах игнорируются, если включен &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt; . См. Также &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14473&quot;&gt;выпуск № 14473&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1df0d3ed5fc3e05e0b2f091352293e402f435759" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-StaticPointers&quot;&gt;&lt;code&gt;StaticPointers&lt;/code&gt;&lt;/a&gt; adds a new syntactic form &lt;code&gt;static e&lt;/code&gt;, which stands for a reference to the closed expression ⟨e⟩. This reference is stable and portable, in the sense that it remains valid across different processes on possibly different machines. Thus, a process can create a reference and send it to another process that can resolve it to ⟨e⟩.</source>
          <target state="translated">Расширение языка &lt;a href=&quot;#extension-StaticPointers&quot;&gt; &lt;code&gt;StaticPointers&lt;/code&gt; &lt;/a&gt; добавляет новую синтаксическую форму &lt;code&gt;static e&lt;/code&gt; , которая обозначает ссылку на закрытое выражение ⟨e⟩. Эта ссылка является стабильной и переносимой в том смысле, что она остается действительной для разных процессов на, возможно, разных машинах. Таким образом, процесс может создать ссылку и отправить ее другому процессу, который может разрешить ее в ⟨e⟩.</target>
        </trans-unit>
        <trans-unit id="1164d109e3a8912c2bd8dbd337b1bd95e59931eb" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt;&lt;code&gt;UndecidableSuperClasses&lt;/code&gt;&lt;/a&gt; allows much more flexible constraints in superclasses.</source>
          <target state="translated">Расширение языка &lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt; &lt;code&gt;UndecidableSuperClasses&lt;/code&gt; &lt;/a&gt; допускает гораздо более гибкие ограничения в суперклассах.</target>
        </trans-unit>
        <trans-unit id="a23afb63a5225acfa62366c99fa9002b8bd272d4" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt; enables Unicode characters to be used to stand for certain ASCII character sequences. The following alternatives are provided:</source>
          <target state="translated">Расширение языка &lt;a href=&quot;#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; &lt;/a&gt; позволяет использовать символы Unicode для обозначения определенных последовательностей символов ASCII. Предлагаются следующие альтернативы:</target>
        </trans-unit>
        <trans-unit id="0f020db4c2779c8a84447ac375908f8cf1851cd7" translate="yes" xml:space="preserve">
          <source>The language extensions control what variation of the language are permitted.</source>
          <target state="translated">Расширения языка управляют тем,какие варианты языка допустимы.</target>
        </trans-unit>
        <trans-unit id="1e3e7e5b927ef3a07b1708c8234ccb8fab69c087" translate="yes" xml:space="preserve">
          <source>The language extensions known to GHC.</source>
          <target state="translated">Языковые расширения,известные GHC.</target>
        </trans-unit>
        <trans-unit id="47f8be94c2ca864c563003d6cd62e96954c9f6b8" translate="yes" xml:space="preserve">
          <source>The language option &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt; enables an alternative translation for the do-notation, which uses the operators &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;, along with &lt;code&gt;join&lt;/code&gt; as far as possible. There are two main reasons for wanting to do this:</source>
          <target state="translated">Параметр языка &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; &lt;/a&gt; включает альтернативный перевод для нотации до, который использует операторы &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; вместе с &lt;code&gt;join&lt;/code&gt; насколько это возможно. У этого есть две основные причины:</target>
        </trans-unit>
        <trans-unit id="6758c18bb77d5105f15261fc6f768c32b1ac1a54" translate="yes" xml:space="preserve">
          <source>The language option &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; (which implies &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt;) enables higher-rank types. That is, you can nest &lt;code&gt;forall&lt;/code&gt;s arbitrarily deep in function arrows. For example, a forall-type (also called a &amp;ldquo;type scheme&amp;rdquo;), including a type-class context, is legal:</source>
          <target state="translated">Параметр языка &lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt; (который подразумевает &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; ) включает типы более высокого ранга. То есть вы можете вкладывать все &lt;code&gt;forall&lt;/code&gt; произвольно глубоко в стрелки функций. Например, допустима forall-type (также называемая &amp;laquo;схемой типов&amp;raquo;), включая контекст типа-class:</target>
        </trans-unit>
        <trans-unit id="e43581d03051421db388e53bc00c80ed362d21f6" translate="yes" xml:space="preserve">
          <source>The largest element of a non-empty structure with respect to the given comparison function.</source>
          <target state="translated">Самый большой элемент непустой структуры по отношению к данной функции сравнения.</target>
        </trans-unit>
        <trans-unit id="a09e69c04a0fae36b18bfad0cec44eb5b7dac599" translate="yes" xml:space="preserve">
          <source>The largest element of a non-empty structure.</source>
          <target state="translated">Самый большой элемент непустой структуры.</target>
        </trans-unit>
        <trans-unit id="1c3c62ef7c501b737425bd024e6b97dd8602a4d0" translate="yes" xml:space="preserve">
          <source>The last of these examples will generate a RULE with a somewhat-complex left-hand side (try it yourself), so it might not fire very well. If you use this kind of specialisation, let us know how well it works.</source>
          <target state="translated">Последний из этих примеров сгенерирует ПРАВИЛО со сложной левой стороны (попробуйте сами),так что он может стрелять не очень хорошо.Если вы используете такую специализацию,дайте нам знать,насколько хорошо она работает.</target>
        </trans-unit>
        <trans-unit id="c09c37300640da9fa5a1e825531f7baf46e4a4a9" translate="yes" xml:space="preserve">
          <source>The last point means that, for example, this program:</source>
          <target state="translated">Последний пункт означает,что,например,эта программа:</target>
        </trans-unit>
        <trans-unit id="c7b0fe0f98d69788b12fc3fe8961316784922da5" translate="yes" xml:space="preserve">
          <source>The last string parameter is useful for when the span is out of date, i.e. the file changed and the code has moved. In which case &lt;a href=&quot;#ghci-cmd-:type-at&quot;&gt;&lt;code&gt;:type-at&lt;/code&gt;&lt;/a&gt; falls back to a general &lt;a href=&quot;#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; like lookup.</source>
          <target state="translated">Последний строковый параметр полезен, когда диапазон устарел, т. Е. Файл изменился, а код переместился. В этом случае &lt;a href=&quot;#ghci-cmd-:type-at&quot;&gt; &lt;code&gt;:type-at&lt;/code&gt; &lt;/a&gt; возвращается к общему &lt;a href=&quot;#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt; как поиск.</target>
        </trans-unit>
        <trans-unit id="74662c9c171e1f11f6d4c17936e04e8cfc73a0a4" translate="yes" xml:space="preserve">
          <source>The last time we looked, this bug still wasn&amp;rsquo;t fixed in the BFD codebase, and there wasn&amp;rsquo;t any noticeable interest in fixing it when we reported the bug back in 2001 or so.</source>
          <target state="translated">В прошлый раз, когда мы посмотрели, эта ошибка все еще не была исправлена ​​в кодовой базе BFD, и не было заметного интереса к ее исправлению, когда мы сообщили об ошибке еще в 2001 году или около того.</target>
        </trans-unit>
        <trans-unit id="cc178347052a701ca8893682ca3efb8b74c8a5b7" translate="yes" xml:space="preserve">
          <source>The latter two extensions are simply a way to avoid littering high-performance code with bang patterns, making it harder to read.</source>
          <target state="translated">Последние два расширения-это просто способ избежать засорения высокопроизводительного кода шаблонами взрыва,делая его более трудным для чтения.</target>
        </trans-unit>
        <trans-unit id="83ef67ff9e0acbd2b46b885ad1e2b9746fa12727" translate="yes" xml:space="preserve">
          <source>The layout rule applies in a pragma. Currently no new indentation level is set, so if you put several rules in single &lt;code&gt;RULES&lt;/code&gt; pragma and wish to use layout to separate them, you must lay out the starting in the same column as the enclosing definitions.</source>
          <target state="translated">Правило макета применяется в прагме. В настоящее время новый уровень отступа не установлен, поэтому, если вы помещаете несколько правил в одну прагму &lt;code&gt;RULES&lt;/code&gt; и хотите использовать макет для их разделения, вы должны расположить начало в том же столбце, что и включающие определения.</target>
        </trans-unit>
        <trans-unit id="d2d17886ee9122e995c736b68557cda7950811bf" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt; monad.
 The ST monad allows for destructive updates, but is escapable (unlike IO).
 A computation of type &lt;/code&gt;&lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; s a&lt;code&gt; returns a value of type &lt;/code&gt;a&lt;code&gt;, and
 execute in &quot;thread&quot; &lt;/code&gt;s&lt;code&gt;. The &lt;/code&gt;s@ parameter is either</source>
          <target state="translated">Ленивая &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt; monad. The ST monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;/code&gt; &lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt; . Монада ST допускает деструктивные обновления, но ее можно избежать (в отличие от ввода-вывода). Вычисление типа &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; sa &lt;code&gt; returns a value of type &lt;/code&gt; a &lt;code&gt;, and execute in &quot;thread&quot; &lt;/code&gt; s &lt;code&gt;. The &lt;/code&gt; s @ либо</target>
        </trans-unit>
        <trans-unit id="cb5e3600ef521edc02534f8316cf1842086384c6" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt; monad.
 The ST monad allows for destructive updates, but is escapable (unlike IO).
 A computation of type &lt;/code&gt;&lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; s a&lt;code&gt; returns a value of type &lt;/code&gt;a&lt;code&gt;, and
 execute in &quot;thread&quot; &lt;/code&gt;s&lt;code&gt;. The &lt;/code&gt;s@ parameter is either</source>
          <target state="translated">Ленивая &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt; monad. The ST monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;/code&gt; &lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt; . Монада ST допускает деструктивные обновления, но ее можно избежать (в отличие от ввода-вывода). Вычисление типа &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; sa &lt;code&gt; returns a value of type &lt;/code&gt; a &lt;code&gt;, and execute in &quot;thread&quot; &lt;/code&gt; s &lt;code&gt;. The &lt;/code&gt; s @ либо</target>
        </trans-unit>
        <trans-unit id="40d868f620139062b248b76538a36b443a676fd8" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#t:AccumT&quot;&gt;AccumT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds accumulation capabilities (such as declarations or document patches) to a given monad.</source>
          <target state="translated">Ленивый &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#t:AccumT&quot;&gt;AccumT&lt;/a&gt;&lt;/code&gt; монад AccumT , который добавляет к данной монаде возможности накопления (например, объявления или исправления документов).</target>
        </trans-unit>
        <trans-unit id="0148fab25056e7d25108af73020e1e1fd6b568bc" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">Ленивый &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; монад WriterT , который добавляет коллекцию выходных данных (например, счетчик или строку) к данной монаде.</target>
        </trans-unit>
        <trans-unit id="460dbda305fa0fdf243ff4aaca3b36cbface9176" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;ByteString&lt;/code&gt; type and representation</source>
          <target state="translated">Ленивый тип и представление &lt;code&gt;ByteString&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd66658dbdbc20cd277316b5f47a31d85a5a657d" translate="yes" xml:space="preserve">
          <source>The lazy ByteString that results from &lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; can be written to disk, and read from disk using Data.ByteString.Lazy IO functions, such as hPutStr or writeFile:</source>
          <target state="translated">Ленивая ByteString, полученная в результате &lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; может быть записана на диск и прочитана с диска с помощью функций Data.ByteString.Lazy IO, таких как hPutStr или writeFile:</target>
        </trans-unit>
        <trans-unit id="81b4ea9d6659ffec90b8a98fd916cb7519cdd284" translate="yes" xml:space="preserve">
          <source>The lazy input interface</source>
          <target state="translated">Ленивый интерфейс ввода</target>
        </trans-unit>
        <trans-unit id="18194b6ea93e37e29c30dcb32e97e5e2850d4eab" translate="yes" xml:space="preserve">
          <source>The lazy interface consumes a single lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It's the easiest interface to get started with, but it doesn't support interleaving I/O and parsing, unless lazy I/O is used.</source>
          <target state="translated">Ленивый интерфейс потребляет одну ленивую &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . Это самый простой интерфейс для начала, но он не поддерживает чередование ввода-вывода и синтаксического анализа, если не используется ленивый ввод-вывод.</target>
        </trans-unit>
        <trans-unit id="d0f94810b2d4d1d107dde9a11881d98fcdccae35" translate="yes" xml:space="preserve">
          <source>The least element of a non-empty structure with respect to the given comparison function.</source>
          <target state="translated">Наименьший элемент непустой структуры относительно данной функции сравнения.</target>
        </trans-unit>
        <trans-unit id="07d9943e6fdf33ee01fbdf7cd0db14fb536c6243" translate="yes" xml:space="preserve">
          <source>The least element of a non-empty structure.</source>
          <target state="translated">Наименьший элемент непустой конструкции.</target>
        </trans-unit>
        <trans-unit id="0e70192fc1725fb44e6261baa525bb34fe0d8271" translate="yes" xml:space="preserve">
          <source>The left hand side of a rule must consist of a top-level variable applied to arbitrary expressions. For example, this is &lt;em&gt;not&lt;/em&gt; OK:</source>
          <target state="translated">Левая часть правила должна состоять из переменной верхнего уровня, применяемой к произвольным выражениям. Например, это &lt;em&gt;не&lt;/em&gt; нормально:</target>
        </trans-unit>
        <trans-unit id="9bbc16e1c3670ac6be9b561d2b10f00b7e4c905c" translate="yes" xml:space="preserve">
          <source>The length of a given month in the Gregorian or Julian calendars. First arg is leap year flag.</source>
          <target state="translated">Продолжительность данного месяца в григорианском или юлианском календарях.Первый аргумент-флаг високосного года.</target>
        </trans-unit>
        <trans-unit id="02862fec4929a80083ca47de3fabc777823d03ea" translate="yes" xml:space="preserve">
          <source>The lexeme parser &lt;code&gt;reserved name&lt;/code&gt; parses &lt;code&gt;symbol
 name&lt;/code&gt;, but it also checks that the &lt;code&gt;name&lt;/code&gt; is not a prefix of a valid identifier. A &lt;code&gt;reserved&lt;/code&gt; word is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;reserved name&lt;/code&gt; парсера лексемы анализирует имя &lt;code&gt;symbol name&lt;/code&gt; , но также проверяет, не является ли &lt;code&gt;name&lt;/code&gt; префиксом допустимого идентификатора. &lt;code&gt;reserved&lt;/code&gt; слово трактуется как один маркер , используя &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12483176ac2649de2ec04abe4c197ebb522e5167" translate="yes" xml:space="preserve">
          <source>The lexeme parser &lt;code&gt;reservedOp name&lt;/code&gt; parses &lt;code&gt;symbol
 name&lt;/code&gt;, but it also checks that the &lt;code&gt;name&lt;/code&gt; is not a prefix of a valid operator. A &lt;code&gt;reservedOp&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Анализатор лексемы &lt;code&gt;reservedOp name&lt;/code&gt; анализирует имя &lt;code&gt;symbol name&lt;/code&gt; , но также проверяет, не является ли &lt;code&gt;name&lt;/code&gt; префиксом допустимого оператора. &lt;code&gt;reservedOp&lt;/code&gt; рассматривается как один маркер , используя &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fe325967df8e680315725cbc04cfb4a0cda946a" translate="yes" xml:space="preserve">
          <source>The libraries listed in &lt;code&gt;extra-libraries&lt;/code&gt; may be any libraries supported by your system&amp;rsquo;s linker, including dynamic libraries (&lt;code&gt;.so&lt;/code&gt; on Unix, &lt;code&gt;.DLL&lt;/code&gt; on Windows).</source>
          <target state="translated">Библиотеки, перечисленные в &lt;code&gt;extra-libraries&lt;/code&gt; могут быть любыми библиотеками, поддерживаемыми компоновщиком вашей системы, включая динамические библиотеки ( &lt;code&gt;.so&lt;/code&gt; в Unix, &lt;code&gt;.DLL&lt;/code&gt; в Windows).</target>
        </trans-unit>
        <trans-unit id="177074a86a1a2bfb7162db93da0c7658d94219a2" translate="yes" xml:space="preserve">
          <source>The lifetime of an event registration.</source>
          <target state="translated">Срок действия регистрации события.</target>
        </trans-unit>
        <trans-unit id="abc2a96639fca06ac1cbe729983e770d28dcf330" translate="yes" xml:space="preserve">
          <source>The limitations here are listed in Haskell Report order (roughly).</source>
          <target state="translated">Ограничения здесь перечислены в заказе Haskell Report (примерно).</target>
        </trans-unit>
        <trans-unit id="d2f24eb430e5f7113d1bb42457d3209f32c4782e" translate="yes" xml:space="preserve">
          <source>The linker standard library search can also be overriden on some systems using the &lt;code id=&quot;index-20&quot;&gt;LIBRARY_PATH&lt;/code&gt; environment variable. Because of some implementation detail on Windows, setting &lt;code&gt;LIBRARY_PATH&lt;/code&gt; will also extend the system loader path for any library it finds. So often setting &lt;code id=&quot;index-21&quot;&gt;LIBRARY_PATH&lt;/code&gt; is enough.</source>
          <target state="translated">Поиск в стандартной библиотеке компоновщика также может быть переопределен в некоторых системах с помощью переменной среды &lt;code id=&quot;index-20&quot;&gt;LIBRARY_PATH&lt;/code&gt; . Из-за некоторых деталей реализации в Windows установка &lt;code&gt;LIBRARY_PATH&lt;/code&gt; также расширит путь системного загрузчика для любой найденной библиотеки. Поэтому часто достаточно установки &lt;code id=&quot;index-21&quot;&gt;LIBRARY_PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35439bfe005709a8b0e917ffb02271e76a64cd30" translate="yes" xml:space="preserve">
          <source>The linker to use (default: &lt;code&gt;gcc&lt;/code&gt;).</source>
          <target state="translated">Используемый компоновщик (по умолчанию: &lt;code&gt;gcc&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="eeafbb95d04ce25f7a78da969fb894e2ec069b3e" translate="yes" xml:space="preserve">
          <source>The list is ordered by most recent call.</source>
          <target state="translated">Список упорядочен по последнему звонку.</target>
        </trans-unit>
        <trans-unit id="1f523c49a9fa8705bc3372a7af5bd59d5259f47e" translate="yes" xml:space="preserve">
          <source>The list must be finite.</source>
          <target state="translated">Список должен быть конечным.</target>
        </trans-unit>
        <trans-unit id="95bb9fda3d0750b05641de34c2d4bc742e5f26cc" translate="yes" xml:space="preserve">
          <source>The list of all possible separators.</source>
          <target state="translated">Список всех возможных разделителей.</target>
        </trans-unit>
        <trans-unit id="140110a0fe6147ee6523b90cc08f34ea3d3d7870" translate="yes" xml:space="preserve">
          <source>The list of associations of an array in index order.</source>
          <target state="translated">Список ассоциаций массива в порядке индекса.</target>
        </trans-unit>
        <trans-unit id="4db5b3fb0ce028bd2eb08c3da0fe9c3bade145e2" translate="yes" xml:space="preserve">
          <source>The list of breakpoints currently enabled can be displayed using &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt;&lt;code&gt;:show breaks&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Список включенных в данный момент точек останова можно отобразить с помощью &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt; &lt;code&gt;:show breaks&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="6840298fc1ff7b758a2385cba92227fe7cb9d802" translate="yes" xml:space="preserve">
          <source>The list of elements of an array in index order.</source>
          <target state="translated">Список элементов массива в порядке индекса.</target>
        </trans-unit>
        <trans-unit id="920d0464cfa124351a5c124482bb76f7bb005ea6" translate="yes" xml:space="preserve">
          <source>The list of indices of an array in ascending order.</source>
          <target state="translated">Список индексов массива в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="c272635afded4d839339a1be1f84abe89e36c500" translate="yes" xml:space="preserve">
          <source>The list of paths is split using &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath#v:searchPathSeparator&quot;&gt;searchPathSeparator&lt;/a&gt;&lt;/code&gt;, which on Windows is a semicolon.</source>
          <target state="translated">Список путей разделяется с помощью &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath#v:searchPathSeparator&quot;&gt;searchPathSeparator&lt;/a&gt;&lt;/code&gt; , который в Windows представляет собой точку с запятой.</target>
        </trans-unit>
        <trans-unit id="dc809c8f4a7b8427301c5f620413f00381ab3112" translate="yes" xml:space="preserve">
          <source>The list of possible &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt;s in the API documentation is not exhaustive. The full list may vary by platform and/or evolve over time.</source>
          <target state="translated">Список возможных &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; в документации API не является исчерпывающим. Полный список может варьироваться в зависимости от платформы и / или со временем развиваться.</target>
        </trans-unit>
        <trans-unit id="c6f1b33fdad02db727e19018a482ecf607406289" translate="yes" xml:space="preserve">
          <source>The list of reserved identifiers.</source>
          <target state="translated">Список зарезервированных идентификаторов.</target>
        </trans-unit>
        <trans-unit id="91edba8a3a46eed84d044f0b039fdf7160f70fd8" translate="yes" xml:space="preserve">
          <source>The list of reserved operators.</source>
          <target state="translated">Список зарезервированных операторов.</target>
        </trans-unit>
        <trans-unit id="c39f3749d7b0f0a59a29e12553ad09d0740f4541" translate="yes" xml:space="preserve">
          <source>The list of valid hole fits is found by checking which bindings in scope would fit into the hole. As an example, compiling the following module with GHC:</source>
          <target state="translated">Список подходящих отверстий можно найти,проверив,какие крепления в области видимости поместятся в отверстие.В качестве примера можно привести компиляцию следующего модуля с GHC:</target>
        </trans-unit>
        <trans-unit id="a1d5e76811a70379851fd0870f7be2601a8c80c1" translate="yes" xml:space="preserve">
          <source>The list of valid hole fits is limited by displaying up to 6 hole fits per hole. The number of hole fits shown can be set by this flag. Turning the limit off with &lt;code&gt;-fno-max-valid-hole-fits&lt;/code&gt; displays all found hole fits.</source>
          <target state="translated">Список допустимых посадок отверстий ограничен отображением до 6 посадок на одно отверстие. Количество отображаемых отверстий может быть установлено этим флагом. Отключение предела с помощью &lt;code&gt;-fno-max-valid-hole-fits&lt;/code&gt; отображает все найденные отверстия.</target>
        </trans-unit>
        <trans-unit id="d8490f70aa9b2cb5e8e7f8af8e97ea93b083ee94" translate="yes" xml:space="preserve">
          <source>The list of valid refinement hole fits is generated by considering hole fits with a varying amount of additional holes. The amount of holes in a refinement can be set by this flag. If the flag is set to 0 or not set at all, no valid refinement hole fits will be suggested.</source>
          <target state="translated">Список действующих посадочных мест для рафинированных отверстий формируется с учетом посадочных мест с различным количеством дополнительных отверстий.Количество отверстий в рафинировке может быть установлено этим флагом.Если флаг установлен в 0 или не установлен вообще,то не будет предложено ни одного подходящего утончённого отверстия.</target>
        </trans-unit>
        <trans-unit id="0e9c3cb541a9f4b1ef3a2b89a4f5da3c5f2f0b80" translate="yes" xml:space="preserve">
          <source>The list of valid refinement hole fits is limited by displaying up to 6 hole fits per hole. The number of hole fits shown can be set by this flag. Turning the limit off with &lt;code&gt;-fno-max-refinement-hole-fits&lt;/code&gt; displays all found hole fits.</source>
          <target state="translated">Список допустимых посадок отверстий для уточнения ограничен отображением до 6 посадок на отверстие. Количество отображаемых отверстий может быть установлено этим флагом. Отключение предела с помощью &lt;code&gt;-fno-max-refinement-hole-fits&lt;/code&gt; отображает все найденные отверстия.</target>
        </trans-unit>
        <trans-unit id="b86a88a2e8b5e2bcc9593f30db6f5ffae5340c3d" translate="yes" xml:space="preserve">
          <source>The list of values in the subrange defined by a bounding pair.</source>
          <target state="translated">Список значений в поддиапазоне,определяемый ограниченной парой.</target>
        </trans-unit>
        <trans-unit id="c06dff0a9cb5a38686c70f9512cbd43e5942e7dc" translate="yes" xml:space="preserve">
          <source>The literal &lt;code&gt;-123&lt;/code&gt; is, according to Haskell98 and Haskell 2010, desugared as &lt;code&gt;negate (fromInteger 123)&lt;/code&gt;. The language extension &lt;a href=&quot;#extension-NegativeLiterals&quot;&gt;&lt;code&gt;NegativeLiterals&lt;/code&gt;&lt;/a&gt; means that it is instead desugared as &lt;code&gt;fromInteger (-123)&lt;/code&gt;.</source>
          <target state="translated">Литерал &lt;code&gt;-123&lt;/code&gt; , согласно Haskell98 и Haskell 2010, обессахаривается как &lt;code&gt;negate (fromInteger 123)&lt;/code&gt; . Расширение языка &lt;a href=&quot;#extension-NegativeLiterals&quot;&gt; &lt;code&gt;NegativeLiterals&lt;/code&gt; &lt;/a&gt; означает, что вместо него используется &lt;code&gt;fromInteger (-123)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e4c18eaf2be8a9b015eed5cef929f88b0717761" translate="yes" xml:space="preserve">
          <source>The local axioms from the instance context : &lt;code&gt;B a&lt;/code&gt;, &lt;code&gt;D a&lt;/code&gt; and &lt;code&gt;E a&lt;/code&gt;</source>
          <target state="translated">Локальные аксиомы из контекста экземпляра: &lt;code&gt;B a&lt;/code&gt; , &lt;code&gt;D a&lt;/code&gt; и &lt;code&gt;E a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47ffc1a6bb0aa38dfc306316588a7559300ef95b" translate="yes" xml:space="preserve">
          <source>The location at which this computation is spliced.</source>
          <target state="translated">Место,в котором происходит сращивание этих вычислений.</target>
        </trans-unit>
        <trans-unit id="eeb6dd18dd0c7cd9fc57a8f2ff6c2bb37bc4af79" translate="yes" xml:space="preserve">
          <source>The lowercase versions (&lt;em&gt;syntax operators&lt;/em&gt;) of these constructors are preferred to these constructors, since they compose better with quotations (&lt;code&gt;[| |]&lt;/code&gt;) and splices (&lt;code&gt;$( ... )&lt;/code&gt;)</source>
          <target state="translated">Строчные версии ( &lt;em&gt;синтаксические операторы&lt;/em&gt; ) этих конструкторов предпочтительнее этих конструкторов, поскольку они лучше сочетаются с цитатами ( &lt;code&gt;[| |]&lt;/code&gt; ) и склейками ( &lt;code&gt;$( ... )&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="abe92315667ac8537af92643ee70ab06a908884e" translate="yes" xml:space="preserve">
          <source>The machine architecture on which the program is running.</source>
          <target state="translated">Архитектура машины,на которой выполняется программа.</target>
        </trans-unit>
        <trans-unit id="32815c54d6aac2d0c3f3ab1768e3826958371ab4" translate="yes" xml:space="preserve">
          <source>The main advantages to using &lt;code&gt;ghc --make&lt;/code&gt; over traditional &lt;code&gt;Makefile&lt;/code&gt;s are:</source>
          <target state="translated">Основные преимущества использования &lt;code&gt;ghc --make&lt;/code&gt; по сравнению с традиционными &lt;code&gt;Makefile&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8f8b11338657365b7972c69ff46bf6811e5d4123" translate="yes" xml:space="preserve">
          <source>The main idea is to add a single new production to the syntax of patterns:</source>
          <target state="translated">Основная идея заключается в добавлении одной новой продукции к синтаксису шаблонов:</target>
        </trans-unit>
        <trans-unit id="fb265d0d99b20462c3bedd36be578770dd2b3955" translate="yes" xml:space="preserve">
          <source>The main library you need to use is the &lt;a href=&quot;http://hackage.haskell.org/package/stm&quot;&gt;stm library&lt;/a&gt;. The main features supported are these:</source>
          <target state="translated">Основная библиотека, которую вам нужно использовать, - это &lt;a href=&quot;http://hackage.haskell.org/package/stm&quot;&gt;библиотека stm&lt;/a&gt; . Основные поддерживаемые функции:</target>
        </trans-unit>
        <trans-unit id="5e1d49c28d217785350db1f824835b79bff3fc25" translate="yes" xml:space="preserve">
          <source>The main reason for using phase control on specialisations is so that you can write optimisation RULES that fire early in the compilation pipeline, and only &lt;em&gt;then&lt;/em&gt; specialise the calls to the function. If specialisation is done too early, the optimisation rules might fail to fire.</source>
          <target state="translated">Основная причина использования фазового управления для специализаций заключается в том, что вы можете написать ПРАВИЛА оптимизации, которые срабатывают на ранней стадии конвейера компиляции, и только &lt;em&gt;после этого&lt;/em&gt; специализировать вызовы функции. Если специализация выполняется слишком рано, правила оптимизации могут не сработать.</target>
        </trans-unit>
        <trans-unit id="bd99fbab8c2a96e5d1994f5a584841ebedd4fc5c" translate="yes" xml:space="preserve">
          <source>The main requirement here is that the runtime needs to be initialized before any Haskell code can be called, so your library should provide initialisation and deinitialisation entry points, implemented in C or C++. For example:</source>
          <target state="translated">Основным требованием здесь является то,что время выполнения должно быть инициализировано перед вызовом любого кода Haskell,поэтому ваша библиотека должна предоставлять точки входа для инициализации и деинициализации,реализованные на C или C++.Например:</target>
        </trans-unit>
        <trans-unit id="a36b3b528156f09407c2aa49bd251573cb91ec76" translate="yes" xml:space="preserve">
          <source>The main thread principle also applies to calls to Haskell from outside, using &lt;code&gt;foreign export&lt;/code&gt;. When the &lt;code&gt;foreign export&lt;/code&gt;ed function is invoked, it starts a new main thread, and it returns when this main thread terminates. If the call causes new threads to be forked, they may remain in the system after the &lt;code&gt;foreign export&lt;/code&gt;ed function has returned.</source>
          <target state="translated">Принцип основного потока также применяется к вызовам Haskell извне с использованием &lt;code&gt;foreign export&lt;/code&gt; . Когда вызывается &lt;code&gt;foreign export&lt;/code&gt; функция экспорта ed, она запускает новый основной поток и возвращается, когда этот основной поток завершается. Если вызов вызывает разветвление новых потоков, они могут остаться в системе после возврата &lt;code&gt;foreign export&lt;/code&gt; функции ed.</target>
        </trans-unit>
        <trans-unit id="a8aa707c2a5513daf094974e7984d291b1194cb2" translate="yes" xml:space="preserve">
          <source>The maintainers are glad to accept patches for further standard encodings of standard Haskell values.</source>
          <target state="translated">Мейнтейнеры рады принять патчи для дальнейших стандартных кодировок стандартных значений Haskell.</target>
        </trans-unit>
        <trans-unit id="744ef2d7aabc6bab260fc29bb9d92f2367435b58" translate="yes" xml:space="preserve">
          <source>The major effect of an &lt;code&gt;INLINE&lt;/code&gt; pragma is to declare a function&amp;rsquo;s &amp;ldquo;cost&amp;rdquo; to be very low. The normal unfolding machinery will then be very keen to inline it. However, an &lt;code&gt;INLINE&lt;/code&gt; pragma for a function &amp;ldquo;&lt;code&gt;f&lt;/code&gt;&amp;rdquo; has a number of other effects:</source>
          <target state="translated">Главный эффект &lt;code&gt;INLINE&lt;/code&gt; - объявить &amp;laquo;стоимость&amp;raquo; функции очень низкой. Тогда обычное разворачивающее оборудование будет очень стараться его встроить. Однако прагма &lt;code&gt;INLINE&lt;/code&gt; для функции &amp;laquo; &lt;code&gt;f&lt;/code&gt; &amp;raquo; имеет ряд других эффектов:</target>
        </trans-unit>
        <trans-unit id="1159d0b17e1c60d7b892bb9301ccde55977e5feb" translate="yes" xml:space="preserve">
          <source>The manifest file that GHC generates when linking a binary on Windows is also embedded in the executable itself, by default. This means that the binary can be distributed without having to supply the manifest file too. The embedding is done by running &lt;strong&gt;windres&lt;/strong&gt;; to see exactly what GHC does to embed the manifest, use the &lt;a href=&quot;using#ghc-flag--v&quot;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/a&gt; flag. A GHC installation comes with its own copy of &lt;code&gt;windres&lt;/code&gt; for this reason.</source>
          <target state="translated">Файл манифеста, который GHC генерирует при компоновке двоичного файла в Windows, также по умолчанию встроен в сам исполняемый файл. Это означает, что двоичный файл можно распространять без необходимости предоставления файла манифеста. Встраивание выполняется беговыми &lt;strong&gt;винтами&lt;/strong&gt; ; чтобы увидеть, что именно GHC делает для встраивания манифеста, используйте флаг &lt;a href=&quot;using#ghc-flag--v&quot;&gt; &lt;code&gt;-v&lt;/code&gt; &lt;/a&gt; . По этой причине установка GHC поставляется со своей собственной копией &lt;code&gt;windres&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3378e6fba41b187d6615b43817c87aba7dfb73d6" translate="yes" xml:space="preserve">
          <source>The marshalling converts each Haskell character, representing a Unicode code point, to one or more bytes in a manner that, by default, is determined by the current locale. As a consequence, no guarantees can be made about the relative length of a Haskell string and its corresponding C string, and therefore all the marshalling routines include memory allocation. The translation between Unicode and the encoding of the current locale may be lossy.</source>
          <target state="translated">Маршрутизация преобразует каждый символ Хаскелла,представляющий точку кода Юникода,в один или несколько байтов таким образом,что по умолчанию определяется текущей локалью.Как следствие,нельзя гарантировать относительную длину Haskell-строки и соответствующей ей C-строки,и поэтому все процедуры сортировки включают в себя выделение памяти.Трансляция между Юникодом и кодировкой текущей локали может быть с потерями.</target>
        </trans-unit>
        <trans-unit id="ce3ddf92b0204346524d60c5ce7d32e072cd0d54" translate="yes" xml:space="preserve">
          <source>The matching behaviour is also influenced by two module-level language extension flags: &lt;a href=&quot;#extension-OverlappingInstances&quot;&gt;&lt;code&gt;OverlappingInstances&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt;. These extensions are now deprecated (since GHC 7.10) in favour of the fine-grained per-instance pragmas.</source>
          <target state="translated">На поведение сопоставления также влияют два флага расширения языка на уровне модуля: &lt;a href=&quot;#extension-OverlappingInstances&quot;&gt; &lt;code&gt;OverlappingInstances&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt; &lt;code&gt;IncoherentInstances&lt;/code&gt; &lt;/a&gt; . Эти расширения теперь устарели (начиная с GHC 7.10) в пользу детализированных прагм для каждого экземпляра.</target>
        </trans-unit>
        <trans-unit id="e2ff7a2e018dbc48e22ad18efcef13edd8c486f6" translate="yes" xml:space="preserve">
          <source>The matrix of platforms that:</source>
          <target state="translated">Матрица платформ,которая:</target>
        </trans-unit>
        <trans-unit id="07015c741417849721502853df57df8b2fae7145" translate="yes" xml:space="preserve">
          <source>The maximal prefix of &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; that could be decoded from the given input.</source>
          <target state="translated">Максимальный префикс &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; который может быть декодирован из заданного ввода.</target>
        </trans-unit>
        <trans-unit id="aa2a714293d353e1ff3212bd761cfba481644c07" translate="yes" xml:space="preserve">
          <source>The maximal size of a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that is copied. &lt;code&gt;2 * &lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt; to guarantee that on average a chunk is of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Максимальный размер &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;2 * &lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt; чтобы гарантировать, что в среднем чанк имеет &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d1640b5c03c6ca6aaac14f9e05c39afaa8e1c64" translate="yes" xml:space="preserve">
          <source>The maximum heap size also affects other garbage collection parameters: when the amount of live data in the heap exceeds a certain fraction of the maximum heap size, compacting collection will be automatically enabled for the oldest generation, and the &lt;code&gt;-F&lt;/code&gt; parameter will be reduced in order to avoid exceeding the maximum heap size.</source>
          <target state="translated">Максимальный размер кучи также влияет на другие параметры сборки мусора: когда объем живых данных в куче превышает определенную долю от максимального размера кучи, для самого старого поколения автоматически включается сборка сжатия, а параметр &lt;code&gt;-F&lt;/code&gt; будет уменьшен в чтобы избежать превышения максимального размера кучи.</target>
        </trans-unit>
        <trans-unit id="7deac0bbef1cce9de070bc6eff250887dc27e012" translate="yes" xml:space="preserve">
          <source>The maximum number of lines stored in the history. If &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the history storage is unlimited.</source>
          <target state="translated">Максимальное количество строк, хранящихся в истории. Если &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , хранилище истории неограничено.</target>
        </trans-unit>
        <trans-unit id="d734e50598efc9c9203e0509468ba84ba10e6429" translate="yes" xml:space="preserve">
          <source>The maximum number of of colors on the screen.</source>
          <target state="translated">Максимальное количество цветов на экране.</target>
        </trans-unit>
        <trans-unit id="b7d459650a2ba9b1231e79e180aceb1bd015d81c" translate="yes" xml:space="preserve">
          <source>The maximum space actually used by your program is the &amp;ldquo;bytes maximum residency&amp;rdquo; figure. This is only checked during major garbage collections, so it is only an approximation; the number of samples tells you how many times it is checked.</source>
          <target state="translated">Максимальное пространство, фактически используемое вашей программой, - это показатель &amp;laquo;максимальное количество байтов&amp;raquo;. Это проверяется только во время крупных сборок мусора, так что это только приблизительное значение; количество образцов говорит вам, сколько раз он проверялся.</target>
        </trans-unit>
        <trans-unit id="8b43db138dc3a233b97e08a96f2e5508bd7bc2ca" translate="yes" xml:space="preserve">
          <source>The maximum tuple size</source>
          <target state="translated">Максимальный размер кортежа</target>
        </trans-unit>
        <trans-unit id="3c1ae6c029d2317f8ba5fb3110e02abfdbf30bfa" translate="yes" xml:space="preserve">
          <source>The meaning of the shortened &lt;a href=&quot;#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt; is dependent on whether your program was compiled for profiling. (See &lt;a href=&quot;profiling#rts-options-heap-prof&quot;&gt;RTS options for heap profiling&lt;/a&gt; for details.)</source>
          <target state="translated">Значение сокращенного &lt;a href=&quot;#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt; зависит от того, была ли ваша программа скомпилирована для профилирования. (Подробнее см. &lt;a href=&quot;profiling#rts-options-heap-prof&quot;&gt;Параметры RTS для профилирования кучи&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="d87c8b0eb65b8cb788e02129482e2e2b711668c6" translate="yes" xml:space="preserve">
          <source>The meaning of the shortened &lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt; is dependent on whether your program was compiled for profiling. When compiled for profiling, &lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt; is equivalent to &lt;a href=&quot;#rts-flag--hc&quot;&gt;&lt;code&gt;-hc&lt;/code&gt;&lt;/a&gt;, but otherwise is equivalent to &lt;a href=&quot;runtime_control#rts-flag--hT&quot;&gt;&lt;code&gt;-hT&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;runtime_control#rts-profiling&quot;&gt;RTS options for profiling&lt;/a&gt;).</source>
          <target state="translated">Значение сокращенного &lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt; зависит от того, была ли ваша программа скомпилирована для профилирования. При компиляции для профилирования &lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt; эквивалентно &lt;a href=&quot;#rts-flag--hc&quot;&gt; &lt;code&gt;-hc&lt;/code&gt; &lt;/a&gt; , но в остальном эквивалентно &lt;a href=&quot;runtime_control#rts-flag--hT&quot;&gt; &lt;code&gt;-hT&lt;/code&gt; &lt;/a&gt; (см. Параметры&lt;a href=&quot;runtime_control#rts-profiling&quot;&gt; RTS для профилирования&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2c90c10f5a199858ea71a07e1f9c65a1b0281964" translate="yes" xml:space="preserve">
          <source>The mechanism is simple: whenever the program evaluates an expression with an SCC annotation, &lt;code&gt;{-# SCC c -#} E&lt;/code&gt;, the cost centre &lt;code&gt;c&lt;/code&gt; is pushed on the current stack, and the entry count for this stack is incremented by one. The stack also sometimes has to be saved and restored; in particular when the program creates a thunk (a lazy suspension), the current cost-centre stack is stored in the thunk, and restored when the thunk is evaluated. In this way, the cost-centre stack is independent of the actual evaluation order used by GHC at runtime.</source>
          <target state="translated">Механизм прост: всякий раз, когда программа оценивает выражение с аннотацией SCC, &lt;code&gt;{-# SCC c -#} E&lt;/code&gt; , центр затрат &lt;code&gt;c&lt;/code&gt; помещается в текущий стек, и счетчик записей для этого стека увеличивается на единицу. Стек также иногда нужно сохранять и восстанавливать; в частности, когда программа создает преобразователь (ленивая приостановка), текущий стек центра затрат сохраняется в преобразователе и восстанавливается при его оценке. Таким образом, стек МВЗ не зависит от фактического порядка оценки, используемого GHC во время выполнения.</target>
        </trans-unit>
        <trans-unit id="f7c0a3feb5345a104be8d4a49924286ed63663fa" translate="yes" xml:space="preserve">
          <source>The member functions of this class facilitate writing values of primitive types to raw memory (which may have been allocated with the above mentioned routines) and reading values from blocks of raw memory. The class, furthermore, includes support for computing the storage requirements and alignment restrictions of storable types.</source>
          <target state="translated">Функции-члены данного класса облегчают запись значений примитивных типов в сырую память (которые могли быть выделены вышеуказанными подпрограммами)и чтение значений из блоков сырой памяти.Кроме того,в классе реализована поддержка вычисления требований к памяти и ограничений по выравниванию хранимых типов.</target>
        </trans-unit>
        <trans-unit id="cba31954fa26087a15e99fd14a2e8df87f705a4d" translate="yes" xml:space="preserve">
          <source>The members &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-storable#v:poke&quot;&gt;poke&lt;/a&gt;&lt;/code&gt; of the &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; class map all values of &lt;code&gt;CT&lt;/code&gt; to the corresponding value of &lt;code&gt;t&lt;/code&gt; and vice versa.</source>
          <target state="translated">Члены &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;foreign-storable#v:poke&quot;&gt;poke&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; класса отобразить все значения &lt;code&gt;CT&lt;/code&gt; для соответствующего значения &lt;code&gt;t&lt;/code&gt; , и наоборот.</target>
        </trans-unit>
        <trans-unit id="723dfa6d14019cdcb7ea8b493daa172324f5d5cf" translate="yes" xml:space="preserve">
          <source>The memory is freed when &lt;code&gt;f&lt;/code&gt; terminates (either normally or via an exception), so the pointer passed to &lt;code&gt;f&lt;/code&gt; must &lt;em&gt;not&lt;/em&gt; be used after this.</source>
          <target state="translated">Память освобождается , когда &lt;code&gt;f&lt;/code&gt; заканчивается (либо , как правило , либо через исключение), поэтому указатель передается &lt;code&gt;f&lt;/code&gt; должен &lt;em&gt;не&lt;/em&gt; использоваться после этого.</target>
        </trans-unit>
        <trans-unit id="30cdd2b8067e97ef326db4b7a7649ae2a1d70b50" translate="yes" xml:space="preserve">
          <source>The memory management overhead. Currently this is tuned for GHC only.</source>
          <target state="translated">Накладные расходы на управление памятью.В настоящее время это настроено только для GHC.</target>
        </trans-unit>
        <trans-unit id="296145d71ce1908abeb930aa215c007de95d6dac" translate="yes" xml:space="preserve">
          <source>The memory may be deallocated using &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:finalizerFree&quot;&gt;finalizerFree&lt;/a&gt;&lt;/code&gt; when no longer required.</source>
          <target state="translated">Память может быть освобождена с помощью &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:finalizerFree&quot;&gt;finalizerFree&lt;/a&gt;&lt;/code&gt; , когда больше не требуется.</target>
        </trans-unit>
        <trans-unit id="b7786c976f2ff7540d0a6e4b59833c22c599315f" translate="yes" xml:space="preserve">
          <source>The memory may freed at any point after the subcomputation terminates, so the pointer to the storage must *not* be used after this.</source>
          <target state="translated">Память может освободиться в любой момент после завершения подвычислений,поэтому указатель на хранилище должен *not*использоваться после этого.</target>
        </trans-unit>
        <trans-unit id="51295ee3cd81001e8a30ec8543497b0e8c877217" translate="yes" xml:space="preserve">
          <source>The merit of this is that you can derive instances for GADTs and other exotic data types, providing only that the boilerplate code does indeed typecheck. For example:</source>
          <target state="translated">Достоинство этого заключается в том,что вы можете получить экземпляры для GADT и других экзотических типов данных,при условии,что только код шаблона действительно выполняет проверку.Например:</target>
        </trans-unit>
        <trans-unit id="09ce093d9b8936752c951269f1ca598cad553080" translate="yes" xml:space="preserve">
          <source>The message printed if &lt;code&gt;malloc&lt;/code&gt; fails.</source>
          <target state="translated">Сообщение печатается в случае сбоя &lt;code&gt;malloc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c55c4a564eeb697e2553fd6d32d12eec12c5af2" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of parsing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be are expected to use double quotes, rather than square brackets.</source>
          <target state="translated">Предоставляется метод &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; , позволяющий программисту предоставить специализированный способ анализа списков значений. Например, это используется предопределенным экземпляром &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , где для значений типа &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; должны использоваться двойные кавычки, а не квадратные скобки.</target>
        </trans-unit>
        <trans-unit id="2bb9dae247f1417713fe2e3ff89e568a58dd2064" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;ghc-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of showing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be shown in double quotes, rather than between square brackets.</source>
          <target state="translated">Предоставляется метод &lt;code&gt;&lt;a href=&quot;ghc-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; , позволяющий программисту предоставить специальный способ отображения списков значений. Например, это используется предопределенным экземпляром &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , где значения типа &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; должны быть показаны в двойных кавычках, а не в квадратных скобках.</target>
        </trans-unit>
        <trans-unit id="9b206e34c8564a26770cfb63266e92dafdef2f00" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of parsing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be are expected to use double quotes, rather than square brackets.</source>
          <target state="translated">Предоставляется метод &lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; , позволяющий программисту предоставить специализированный способ анализа списков значений. Например, это используется предопределенным экземпляром &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , где для значений типа &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; должны использоваться двойные кавычки, а не квадратные скобки.</target>
        </trans-unit>
        <trans-unit id="0b9ba8a954c2ae61c20aa36e469332d7313c7d48" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;prelude#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of showing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be shown in double quotes, rather than between square brackets.</source>
          <target state="translated">Предоставляется метод &lt;code&gt;&lt;a href=&quot;prelude#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; , позволяющий программисту предоставить специальный способ отображения списков значений. Например, это используется предопределенным экземпляром &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , где значения типа &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; должны быть показаны в двойных кавычках, а не в квадратных скобках.</target>
        </trans-unit>
        <trans-unit id="332ed4acf796a389b61681f06e5d3b89101d146a" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of parsing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be are expected to use double quotes, rather than square brackets.</source>
          <target state="translated">Предоставляется метод &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; , позволяющий программисту предоставить специализированный способ анализа списков значений. Например, это используется предопределенным экземпляром &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , где для значений типа &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; должны использоваться двойные кавычки, а не квадратные скобки.</target>
        </trans-unit>
        <trans-unit id="1e8a0b574789d1de5cf8d746837c55989fd9ec8f" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;text-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of showing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be shown in double quotes, rather than between square brackets.</source>
          <target state="translated">Предоставляется метод &lt;code&gt;&lt;a href=&quot;text-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; , позволяющий программисту предоставить специальный способ отображения списков значений. Например, это используется предопределенным экземпляром &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , где значения типа &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; должны быть показаны в двойных кавычках, а не в квадратных скобках.</target>
        </trans-unit>
        <trans-unit id="a55e07264dbb157af3468bbfef9f673d9ed1c760" translate="yes" xml:space="preserve">
          <source>The method names refer to the monoid of lists under concatenation, but there are many other instances.</source>
          <target state="translated">Имена методов относятся к моноиду списков под конкатендацией,но есть много других случаев.</target>
        </trans-unit>
        <trans-unit id="14f5aff046cf43c34ac7e373b3ac53e710239001" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-records&quot;&gt;GHC.Records&lt;/a&gt; defines the following:</source>
          <target state="translated">Модуль &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-records&quot;&gt;GHC.Records&lt;/a&gt; определяет следующее:</target>
        </trans-unit>
        <trans-unit id="6fe9f2287d708875ff918672eee840079c919130" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-marshal-alloc&quot;&gt;Foreign.Marshal.Alloc&lt;/a&gt; provides operations to allocate and deallocate blocks of raw memory (i.e., unstructured chunks of memory outside of the area maintained by the Haskell storage manager). These memory blocks are commonly used to pass compound data structures to foreign functions or to provide space in which compound result values are obtained from foreign functions.</source>
          <target state="translated">Модуль &lt;a href=&quot;foreign-marshal-alloc&quot;&gt;Foreign.Marshal.Alloc&lt;/a&gt; предоставляет операции по распределению и освобождению блоков необработанной памяти (т. Е. Неструктурированных блоков памяти за пределами области, поддерживаемой менеджером хранилища Haskell). Эти блоки памяти обычно используются для передачи составных структур данных сторонним функциям или для обеспечения пространства, в котором значения составных результатов получаются из внешних функций.</target>
        </trans-unit>
        <trans-unit id="0aaac35805022709131420c56844a405405859b9" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe&lt;/a&gt; re-exports the other modules in the &lt;code&gt;Foreign.Marshal&lt;/code&gt; hierarchy (except for &lt;code&gt;Foreign.Marshal.Unsafe&lt;/code&gt;):</source>
          <target state="translated">Модуль &lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe&lt;/a&gt; реэкспортирует другие модули в иерархии &lt;code&gt;Foreign.Marshal&lt;/code&gt; (кроме &lt;code&gt;Foreign.Marshal.Unsafe&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="b1df10bb69bf2b89bf3830cfbd382b7d65aa4ba2" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe&lt;/a&gt; re-exports the other modules in the &lt;code&gt;Foreign.Marshal&lt;/code&gt; hierarchy:</source>
          <target state="translated">Модуль &lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe&lt;/a&gt; реэкспортирует другие модули в иерархии &lt;code&gt;Foreign.Marshal&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="28a8a8e9077c7af6ee0166e9bad843be62034b8c" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-storable&quot;&gt;Foreign.Storable&lt;/a&gt; provides most elementary support for marshalling and is part of the language-independent portion of the Foreign Function Interface (FFI), and will normally be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">Модуль &lt;a href=&quot;foreign-storable&quot;&gt;Foreign.Storable&lt;/a&gt; обеспечивает наиболее элементарную поддержку маршалинга и является частью независимой от языка части интерфейса внешних функций (FFI) и обычно импортируется через модуль &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b7c64247943d5ed0c07fe913e3a4cc1b0d102fc" translate="yes" xml:space="preserve">
          <source>The module header (including the export list), and import statements, are exactly as in Haskell, and so are the scoping rules. Hence, to mention a non-Prelude type or class, you must import it.</source>
          <target state="translated">Заголовок модуля (включая список экспорта)и операторы импорта точно такие же,как и в Haskell,а также правила поиска.Следовательно,чтобы упомянуть тип или класс,не являющийся прелюдией,вы должны импортировать его.</target>
        </trans-unit>
        <trans-unit id="4ce45cb81b574e7a52ecde45d4ee5f41764d49db" translate="yes" xml:space="preserve">
          <source>The module must import &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;.</source>
          <target state="translated">Модуль должен импортировать &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="271abdd5800add2d2a429d3960db113d446e207f" translate="yes" xml:space="preserve">
          <source>The module was compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Модуль был скомпилирован с помощью &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="61f9fc1e39c23939a82e428406225578b440fb61" translate="yes" xml:space="preserve">
          <source>The module was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Модуль был скомпилирован с помощью &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8638db98256357d4532755afc9c9f9aac9ff4038" translate="yes" xml:space="preserve">
          <source>The monad and its operations</source>
          <target state="translated">Монада и ее операции</target>
        </trans-unit>
        <trans-unit id="da5e8905606683d3d0ad467ab40cd56a8717786c" translate="yes" xml:space="preserve">
          <source>The monoid of endomorphisms under composition.</source>
          <target state="translated">Моноид эндоморфизмов по составу.</target>
        </trans-unit>
        <trans-unit id="e9ccf96ea16ca69c701719763f3afb8aa9f150cf" translate="yes" xml:space="preserve">
          <source>The most common usage of &lt;code&gt;COMPLETE&lt;/code&gt; pragmas is with &lt;a href=&quot;#pattern-synonyms&quot;&gt;Pattern synonyms&lt;/a&gt;. On its own, the checker is very naive and assumes that any match involving a pattern synonym will fail. As a result, any pattern match on a pattern synonym is regarded as incomplete unless the user adds a catch-all case.</source>
          <target state="translated">Чаще всего прагмы &lt;code&gt;COMPLETE&lt;/code&gt; используются с &lt;a href=&quot;#pattern-synonyms&quot;&gt;синонимами Pattern&lt;/a&gt; . Сама по себе программа проверки очень наивна и предполагает, что любое совпадение с синонимом шаблона не удастся. В результате любое совпадение с шаблоном синонима с шаблоном считается неполным, если пользователь не добавляет универсальный регистр.</target>
        </trans-unit>
        <trans-unit id="063a9618d36844f08d6ef94989127397ea9b9b40" translate="yes" xml:space="preserve">
          <source>The most common way this can happen is when you&amp;rsquo;re evaluating a CAF (e.g. main), stop at a breakpoint, and ask for the value of the CAF at the prompt again.</source>
          <target state="translated">Чаще всего это может произойти, когда вы оцениваете CAF (например, основной), останавливаетесь на точке останова и снова запрашиваете значение CAF в приглашении.</target>
        </trans-unit>
        <trans-unit id="75340b8409f86aba60aed6656112aab745923bcd" translate="yes" xml:space="preserve">
          <source>The most commonly used ISO 8601 format for this type.</source>
          <target state="translated">Наиболее часто используемый формат ISO 8601 для этого типа.</target>
        </trans-unit>
        <trans-unit id="bfe39e2ecd43cfd563f91e4eca3de1502694fa6f" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser over the Identity monad. &lt;code&gt;runParser p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns either a &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Самый общий способ запустить синтаксический анализатор над монадой Identity. &lt;code&gt;runParser p state filePath input&lt;/code&gt; работает синтаксический анализатор &lt;code&gt;p&lt;/code&gt; в списке входных лексем &lt;code&gt;input&lt;/code&gt; , полученный от источника &lt;code&gt;filePath&lt;/code&gt; с начальным состоянием пользователя &lt;code&gt;st&lt;/code&gt; . &lt;code&gt;filePath&lt;/code&gt; используется только в сообщениях об ошибках и может быть пустой строкой. Возвращает либо &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ), либо значение типа &lt;code&gt;a&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aeb3d7e2ffb679903cf3a78fe1e8a43f4f5df8ed" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser over the Identity monad. &lt;code&gt;runParser p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns either a &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Самый общий способ запустить синтаксический анализатор над монадой Identity. &lt;code&gt;runParser p state filePath input&lt;/code&gt; работает синтаксический анализатор &lt;code&gt;p&lt;/code&gt; в списке входных лексем &lt;code&gt;input&lt;/code&gt; , полученный от источника &lt;code&gt;filePath&lt;/code&gt; с начальным состоянием пользователя &lt;code&gt;st&lt;/code&gt; . &lt;code&gt;filePath&lt;/code&gt; используется только в сообщениях об ошибках и может быть пустой строкой. Возвращает либо &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ), либо значение типа &lt;code&gt;a&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2c5053914782286bf569d388ab06bfb0dd58462e" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser. &lt;code&gt;runParserT p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns a computation in the underlying monad &lt;code&gt;m&lt;/code&gt; that return either a &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Самый общий способ запустить парсер. &lt;code&gt;runParserT p state filePath input&lt;/code&gt; работает синтаксический анализатор &lt;code&gt;p&lt;/code&gt; в списке входных лексем &lt;code&gt;input&lt;/code&gt; , полученный от источника &lt;code&gt;filePath&lt;/code&gt; с начальным состоянием пользователя &lt;code&gt;st&lt;/code&gt; . &lt;code&gt;filePath&lt;/code&gt; используется только в сообщениях об ошибках и может быть пустой строкой. Возвращает вычисление в базовой монаде &lt;code&gt;m&lt;/code&gt; , возвращающее либо &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ), либо значение типа &lt;code&gt;a&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0c6a5560b83d86896cc9662f87720adba5507322" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser. &lt;code&gt;runParserT p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns a computation in the underlying monad &lt;code&gt;m&lt;/code&gt; that return either a &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Самый общий способ запустить парсер. &lt;code&gt;runParserT p state filePath input&lt;/code&gt; работает синтаксический анализатор &lt;code&gt;p&lt;/code&gt; в списке входных лексем &lt;code&gt;input&lt;/code&gt; , полученный от источника &lt;code&gt;filePath&lt;/code&gt; с начальным состоянием пользователя &lt;code&gt;st&lt;/code&gt; . &lt;code&gt;filePath&lt;/code&gt; используется только в сообщениях об ошибках и может быть пустой строкой. Возвращает вычисление в базовой монаде &lt;code&gt;m&lt;/code&gt; , возвращающее либо &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ), либо значение типа &lt;code&gt;a&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b5be00a95c813a0dae9db110b897e76b924717d2" translate="yes" xml:space="preserve">
          <source>The motivation for the change is that it means &lt;code&gt;IO a&lt;/code&gt; actions default to &lt;code&gt;IO ()&lt;/code&gt;, which in turn means that ghci won&amp;rsquo;t try to print a result when running them. This is particularly important for &lt;code&gt;printf&lt;/code&gt;, which has an instance that returns &lt;code&gt;IO a&lt;/code&gt;. However, it is only able to return &lt;code&gt;undefined&lt;/code&gt; (the reason for the instance having this type is so that printf doesn&amp;rsquo;t require extensions to the class system), so if the type defaults to &lt;code&gt;Integer&lt;/code&gt; then ghci gives an error when running a printf.</source>
          <target state="translated">Мотивация для изменения заключается в том, что это означает, что &lt;code&gt;IO a&lt;/code&gt; действия по умолчанию для &lt;code&gt;IO ()&lt;/code&gt; , что, в свою очередь, означает, что ghci не будет пытаться распечатать результат при их запуске. Это особенно важно для &lt;code&gt;printf&lt;/code&gt; , у которого есть экземпляр, возвращающий &lt;code&gt;IO a&lt;/code&gt; . Однако он может возвращать только &lt;code&gt;undefined&lt;/code&gt; (причина, по которой экземпляр имеет этот тип, заключается в том, что printf не требует расширений для системы классов), поэтому, если по умолчанию используется тип &lt;code&gt;Integer&lt;/code&gt; , тогда ghci выдает ошибку при запуске printf.</target>
        </trans-unit>
        <trans-unit id="c736836da3c61a5b28a8e40cd26c58ac3671ca42" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; is used to illustrate the relationship to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt;: where &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; is shallow in the sense that it only evaluates the top level of its argument, &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; traverses the entire data structure evaluating it completely.</source>
          <target state="translated">Имя &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; используется для иллюстрации отношения к &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; : где &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; является неглубоким в том смысле, что он оценивает только верхний уровень своего аргумента, &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; просматривает всю структуру данных, оценивая его полностью.</target>
        </trans-unit>
        <trans-unit id="ecfeb2264bf3f2219dcf11640cc5f23d975957a1" translate="yes" xml:space="preserve">
          <source>The name of an executable with a list of arguments</source>
          <target state="translated">Имя исполняемого файла со списком аргументов</target>
        </trans-unit>
        <trans-unit id="e05e238891a0e5d7a1ad5addb5acbfa1d828b57f" translate="yes" xml:space="preserve">
          <source>The name of the constructor</source>
          <target state="translated">Имя конструктора</target>
        </trans-unit>
        <trans-unit id="2372d4365121c955cf759525401a9a51abda2da3" translate="yes" xml:space="preserve">
          <source>The name of the datatype (unqualified)</source>
          <target state="translated">Имя типа данных (неквалифицированный).</target>
        </trans-unit>
        <trans-unit id="4ad137cef439e5cbd9d31d951cbeeb39fa772cfe" translate="yes" xml:space="preserve">
          <source>The name of the dynamic library on Windows systems (optional).</source>
          <target state="translated">Название динамической библиотеки на системах Windows (необязательно).</target>
        </trans-unit>
        <trans-unit id="a75d937e0b98713b032f66a0d3ddc12a66577a2c" translate="yes" xml:space="preserve">
          <source>The name of the interface file is derived using the same rules, except that the suffix is ⟨hisuf⟩ (&lt;code&gt;.hi&lt;/code&gt; by default) instead of ⟨osuf⟩, and the relevant options are &lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--hisuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt;&lt;code&gt;-hisuf ⟨suffix⟩&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-odir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--osuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt;&lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt;&lt;/a&gt; respectively.</source>
          <target state="translated">Имя файла интерфейса происходит по тем же правилам, за исключением того, что суффикс ⟨hisuf⟩ ( &lt;code&gt;.hi&lt;/code&gt; по умолчанию) вместо ⟨osuf⟩, и соответствующие варианты &lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#ghc-flag--hisuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt; &lt;code&gt;-hisuf ⟨suffix⟩&lt;/code&gt; &lt;/a&gt; вместо of &lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-odir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#ghc-flag--osuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt; &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; &lt;/a&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="6453686e83ae95972b7e17f3b926e084c57ab74f" translate="yes" xml:space="preserve">
          <source>The name of the library on Unix and Windows (mingw) systems. Note that we don&amp;rsquo;t support building dynamic libraries of Haskell code on Unix systems.</source>
          <target state="translated">Имя библиотеки в системах Unix и Windows (mingw). Обратите внимание, что мы не поддерживаем создание динамических библиотек кода Haskell в системах Unix.</target>
        </trans-unit>
        <trans-unit id="d0f5dc8321c09ce84049b074ac570bfbec19828a" translate="yes" xml:space="preserve">
          <source>The name of the object file generated by GHC is derived according to the following rules, where ⟨osuf⟩ is the object-file suffix (this can be changed with the &lt;code&gt;-osuf&lt;/code&gt; option).</source>
          <target state="translated">Имя объектного файла, созданного GHC, получается в соответствии со следующими правилами, где ⟨osuf⟩ - суффикс объектного файла (его можно изменить с &lt;code&gt;-osuf&lt;/code&gt; параметра -osuf ).</target>
        </trans-unit>
        <trans-unit id="6861c4770b27354d7d4cfab408a9a6ca379e4807" translate="yes" xml:space="preserve">
          <source>The name of the pattern synonym is in the same namespace as proper data constructors. Like normal data constructors, pattern synonyms can be imported and exported through association with a type constructor or independently.</source>
          <target state="translated">Имя синонима шаблона находится в том же пространстве имён,что и соответствующие конструкторы данных.Как и обычные конструкторы данных,синонимы шаблонов могут быть импортированы и экспортированы через ассоциацию с конструктором типа или независимо друг от друга.</target>
        </trans-unit>
        <trans-unit id="1be799bf296167235ebb2ca091eee552b142616f" translate="yes" xml:space="preserve">
          <source>The name of the program</source>
          <target state="translated">Название программы</target>
        </trans-unit>
        <trans-unit id="39a42659e6043aff3532b0014c5b4fae37244931" translate="yes" xml:space="preserve">
          <source>The name of the selector</source>
          <target state="translated">Имя селектора</target>
        </trans-unit>
        <trans-unit id="7c51ecee2db2e110dbf3d1d2d9420bc2a5044c61" translate="yes" xml:space="preserve">
          <source>The name of the zone, typically a three- or four-letter acronym.</source>
          <target state="translated">Название зоны,как правило,трех-или четырехбуквенное аббревиатурное сокращение.</target>
        </trans-unit>
        <trans-unit id="4e49908da6a172e68a423a7eb23e95b552938d75" translate="yes" xml:space="preserve">
          <source>The name of this group (gr_name)</source>
          <target state="translated">Имя этой группы (gr_name)</target>
        </trans-unit>
        <trans-unit id="fae25b47526c2bd90bbb6d0b312e7136e668661b" translate="yes" xml:space="preserve">
          <source>The name of this operator is an allusion to &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt;. Note the similarities between their types:</source>
          <target state="translated">Название этого оператора является намеком на &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; . Обратите внимание на сходство между их типами:</target>
        </trans-unit>
        <trans-unit id="3bffd90620f4f0f826e5aaf337b1fe1334e782e4" translate="yes" xml:space="preserve">
          <source>The name without its module prefix.</source>
          <target state="translated">Имя без префикса модуля.</target>
        </trans-unit>
        <trans-unit id="646f96f37bb735ef8278fbc57b542fce8c940d51" translate="yes" xml:space="preserve">
          <source>The named wildcard forces the argument and result types to be the same. Lacking a signature, GHC would have inferred &lt;code&gt;forall a b. (Char, a) -&amp;gt; (Char, b)&lt;/code&gt;. A named wildcard can be mentioned in constraints, provided it also occurs in the monotype part of the type signature to make sure that it unifies with something:</source>
          <target state="translated">Именованный подстановочный знак заставляет типы аргумента и результата быть одинаковыми. Не имея подписи, GHC сделал бы вывод для &lt;code&gt;forall a b. (Char, a) -&amp;gt; (Char, b)&lt;/code&gt; . Именованный подстановочный знак может быть упомянут в ограничениях, при условии, что он также встречается в монотипной части сигнатуры типа, чтобы убедиться, что он с чем-то объединяется:</target>
        </trans-unit>
        <trans-unit id="1eb6c48a77c3ff916d6d31d64741779306bc02b7" translate="yes" xml:space="preserve">
          <source>The names in this module resemble those in the &lt;code&gt;&lt;a href=&quot;data#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; family of modules, but are shorter due to the assumption of qualified naming.</source>
          <target state="translated">Имена в этом модуле похожи на имена в семействе модулей &lt;code&gt;&lt;a href=&quot;data#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; , но короче из-за допущения квалифицированного именования.</target>
        </trans-unit>
        <trans-unit id="2a298a889af18ee73428f1b23010db1d461094d5" translate="yes" xml:space="preserve">
          <source>The namespaces are:</source>
          <target state="translated">Пространства имен:</target>
        </trans-unit>
        <trans-unit id="c41bfe70547efc280b4b232c6db8795351037886" translate="yes" xml:space="preserve">
          <source>The naming scheme may look a bit weird, but it has the purpose of allowing the co-existence of import libraries with ordinary static libraries (e.g., &lt;code&gt;libHSfoo.a&lt;/code&gt; and &lt;code&gt;libHSfoo.dll.a&lt;/code&gt;. Additionally, when the compiler driver is linking in non-static mode, it will rewrite occurrence of &lt;code&gt;-lHSfoo&lt;/code&gt; on the command line to &lt;code&gt;-lHSfoo.dll&lt;/code&gt;. By doing this for you, switching from non-static to static linking is simply a question of adding &lt;code&gt;-static&lt;/code&gt; to your command line.</source>
          <target state="translated">Схема именования может выглядеть немного странно, но ее цель - обеспечить сосуществование библиотек импорта с обычными статическими библиотеками (например, &lt;code&gt;libHSfoo.a&lt;/code&gt; и &lt;code&gt;libHSfoo.dll.a&lt;/code&gt; . Кроме того, когда драйвер компилятора подключается в non -статический режим, он перепишет вхождение &lt;code&gt;-lHSfoo&lt;/code&gt; в командной строке в &lt;code&gt;-lHSfoo.dll&lt;/code&gt; . Сделав это для вас, переключение с нестатической на статическую компоновку - это просто вопрос добавления &lt;code&gt;-static&lt;/code&gt; в вашу командную строку.</target>
        </trans-unit>
        <trans-unit id="a0044db577b12199ca68313af424ef55cbf96d30" translate="yes" xml:space="preserve">
          <source>The native newline representation for the current platform: &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; on Unix systems, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; on Windows.</source>
          <target state="translated">Собственное представление новой строки для текущей платформы: &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; в системах Unix, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; в Windows.</target>
        </trans-unit>
        <trans-unit id="17286b53488467d11ce996bb67e9ac72d58ccc97" translate="yes" xml:space="preserve">
          <source>The native newline representation for the current platform: &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; on Unix systems, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; on Windows.</source>
          <target state="translated">Собственное представление новой строки для текущей платформы: &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; в системах Unix, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; в Windows.</target>
        </trans-unit>
        <trans-unit id="78f21582e0027e530ef578f9b561481600ae0181" translate="yes" xml:space="preserve">
          <source>The native newline representation for the current platform: &lt;code&gt;&lt;a href=&quot;system-io#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; on Unix systems, &lt;code&gt;&lt;a href=&quot;system-io#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; on Windows.</source>
          <target state="translated">Собственное представление новой строки для текущей платформы: &lt;code&gt;&lt;a href=&quot;system-io#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; в системах Unix, &lt;code&gt;&lt;a href=&quot;system-io#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; в Windows.</target>
        </trans-unit>
        <trans-unit id="f38af79343aeda66e3c105c4d632b98dde240785" translate="yes" xml:space="preserve">
          <source>The natural generated &lt;code&gt;Eq&lt;/code&gt; code would result in these instance declarations:</source>
          <target state="translated">Естественно сгенерированный код &lt;code&gt;Eq&lt;/code&gt; приведет к следующим объявлениям экземпляров:</target>
        </trans-unit>
        <trans-unit id="2aa75ff914d05468b9b141013cb484ac0d26b5d2" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; shares the finalizer of the original, equivalent from a finalization standpoint to just creating another reference to the original. That is, the finalizer will not be called before the new &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is unreachable, nor will it be called an additional time due to this call, and the finalizer will be called with the same address that it would have had this call not happened, *not* the new address.</source>
          <target state="translated">Новый &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; использует финализатор оригинала, что эквивалентно с точки зрения завершения просто созданию еще одной ссылки на оригинал. То есть финализатор не будет вызываться до того, как новый &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; станет недоступен, и не будет вызываться дополнительное время из-за этого вызова, и финализатор будет вызываться с тем же адресом, по которому этот вызов не произошел бы, * не * новый адрес.</target>
        </trans-unit>
        <trans-unit id="d537ecc2a0a7273339bdcd281e6203980acce3cf" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; shares the finalizer of the original, equivalent from a finalization standpoint to just creating another reference to the original. That is, the finalizer will not be called before the new &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is unreachable, nor will it be called an additional time due to this call, and the finalizer will be called with the same address that it would have had this call not happened, *not* the new address.</source>
          <target state="translated">Новый &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; использует финализатор оригинала, что эквивалентно с точки зрения завершения просто созданию еще одной ссылки на оригинал. То есть финализатор не будет вызываться до того, как новый &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; станет недоступен, и не будет вызываться дополнительное время из-за этого вызова, и финализатор будет вызываться с тем же адресом, по которому этот вызов не произошел бы, * не * новый адрес.</target>
        </trans-unit>
        <trans-unit id="9565bf7af2fc32661af4296e391a5a4f73420f53" translate="yes" xml:space="preserve">
          <source>The new algorithm considers all outgoing edges of a basic blocks for code layout instead of only the last jump instruction. It also builds a control flow graph for functions, tries to find hot code paths and place them sequentially leading to better cache utilization and performance.</source>
          <target state="translated">Новый алгоритм учитывает все исходящие края базовых блоков для компоновки кода,а не только последнюю инструкцию по прыжку.Он также строит граф потока управления для функций,пытается найти горячие пути кода и разместить их последовательно,что приводит к лучшему использованию кэша и производительности.</target>
        </trans-unit>
        <trans-unit id="0e6b6e161e08547e4c2e84b69fc3ce69fd7fe2bd" translate="yes" xml:space="preserve">
          <source>The new prompt is &lt;code&gt;*Main&lt;/code&gt;, which indicates that we are typing expressions in the context of the top-level of the &lt;code&gt;Main&lt;/code&gt; module. Everything that is in scope at the top-level in the module &lt;code&gt;Main&lt;/code&gt; we just loaded is also in scope at the prompt (probably including &lt;code&gt;Prelude&lt;/code&gt;, as long as &lt;code&gt;Main&lt;/code&gt; doesn&amp;rsquo;t explicitly hide it).</source>
          <target state="translated">Новое приглашение - &lt;code&gt;*Main&lt;/code&gt; , что означает, что мы вводим выражения в контексте верхнего уровня модуля &lt;code&gt;Main&lt;/code&gt; . Все, что находится в области видимости на верхнем уровне в только что загруженном модуле &lt;code&gt;Main&lt;/code&gt; , также находится в области видимости в приглашении (возможно, включая &lt;code&gt;Prelude&lt;/code&gt; , если &lt;code&gt;Main&lt;/code&gt; явно не скрывает это).</target>
        </trans-unit>
        <trans-unit id="53f5b2e47a4b9ae427e19c9dbf1f618026a18fe1" translate="yes" xml:space="preserve">
          <source>The new thread inherits the &lt;em&gt;masked&lt;/em&gt; state of the parent (see &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Новый поток наследует &lt;em&gt;замаскированное&lt;/em&gt; состояние родителя (см. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8d318f738e712b9a7c49deddbf087cc0b4b1ac85" translate="yes" xml:space="preserve">
          <source>The new thread inherits the &lt;em&gt;masked&lt;/em&gt; state of the parent (see &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Новый поток наследует &lt;em&gt;замаскированное&lt;/em&gt; состояние родителя (см. &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f49ffa4a3cda912cfa43024b34a8d1f99a2d6f8d" translate="yes" xml:space="preserve">
          <source>The new thread will be a lightweight, &lt;em&gt;unbound&lt;/em&gt; thread. Foreign calls made by this thread are not guaranteed to be made by any particular OS thread; if you need foreign calls to be made by a particular OS thread, then use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Новый поток будет легким, &lt;em&gt;несвязанным&lt;/em&gt; потоком. Не гарантируется, что внешние вызовы, сделанные этим потоком, будут выполнены каким-либо конкретным потоком ОС; если вам нужно, чтобы определенные &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; ОС выполняли внешние вызовы, используйте вместо этого forkOS .</target>
        </trans-unit>
        <trans-unit id="d79262bf7af143e8fe77bde10bec763c9abf1332" translate="yes" xml:space="preserve">
          <source>The new thread will be a lightweight, &lt;em&gt;unbound&lt;/em&gt; thread. Foreign calls made by this thread are not guaranteed to be made by any particular OS thread; if you need foreign calls to be made by a particular OS thread, then use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Новый поток будет легким, &lt;em&gt;несвязанным&lt;/em&gt; потоком. Не гарантируется, что внешние вызовы, сделанные этим потоком, будут выполнены каким-либо конкретным потоком ОС; если вам нужно, чтобы определенные &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; ОС выполняли внешние вызовы, используйте вместо этого forkOS .</target>
        </trans-unit>
        <trans-unit id="bc43222cc5f22f48444dca9a33addd84a41162b9" translate="yes" xml:space="preserve">
          <source>The newly created thread has an exception handler that discards the exceptions &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt;, and passes all other exceptions to the uncaught exception handler.</source>
          <target state="translated">Вновь созданный поток имеет обработчик исключений, который отбрасывает исключения &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; и передает все остальные исключения обработчику неперехваченных исключений.</target>
        </trans-unit>
        <trans-unit id="06467093ec13b99be21e49f501d476baef2995e0" translate="yes" xml:space="preserve">
          <source>The next Sunday strictly after a given day.</source>
          <target state="translated">Следующее воскресенье строго после определенного дня.</target>
        </trans-unit>
        <trans-unit id="00554018ca7c76296e2e972dcf6e4032903f571e" translate="yes" xml:space="preserve">
          <source>The non-copying implementation is supported between certain pairs of array types only; one constraint is that the array types must have identical representations. In GHC, The following pairs of array types have a non-copying O(1) implementation of &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeFreeze&quot;&gt;unsafeFreeze&lt;/a&gt;&lt;/code&gt;. Because the optimised versions are enabled by specialisations, you will need to compile with optimisation (-O) to get them.</source>
          <target state="translated">Реализация без копирования поддерживается только между некоторыми парами типов массивов; одно ограничение состоит в том, что типы массивов должны иметь идентичные представления. В GHC следующие пары типов массивов имеют некопирующую O (1) реализацию &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeFreeze&quot;&gt;unsafeFreeze&lt;/a&gt;&lt;/code&gt; . Поскольку оптимизированные версии включены в специализации, вам нужно будет скомпилировать с оптимизацией (-O), чтобы получить их.</target>
        </trans-unit>
        <trans-unit id="a17dd35e1a788245fc2675b10d198269467558f5" translate="yes" xml:space="preserve">
          <source>The non-copying implementation is supported between certain pairs of array types only; one constraint is that the array types must have identical representations. In GHC, The following pairs of array types have a non-copying O(1) implementation of &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeThaw&quot;&gt;unsafeThaw&lt;/a&gt;&lt;/code&gt;. Because the optimised versions are enabled by specialisations, you will need to compile with optimisation (-O) to get them.</source>
          <target state="translated">Реализация без копирования поддерживается только между некоторыми парами типов массивов; одно ограничение состоит в том, что типы массивов должны иметь идентичные представления. В GHC следующие пары типов массивов имеют некопирующую реализацию O (1) &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeThaw&quot;&gt;unsafeThaw&lt;/a&gt;&lt;/code&gt; . Поскольку оптимизированные версии включены в специализации, вам нужно будет скомпилировать с оптимизацией (-O), чтобы получить их.</target>
        </trans-unit>
        <trans-unit id="4065cd5ff81b5cc613fc73a9059855b99c8be0cc" translate="yes" xml:space="preserve">
          <source>The non-termination is reported like this:</source>
          <target state="translated">Сообщается о том,что он не заканчивает срок действия:</target>
        </trans-unit>
        <trans-unit id="7d6d02244fcddd7ae83db06c2e068263589664bf" translate="yes" xml:space="preserve">
          <source>The nonnegative magnitude of a complex number.</source>
          <target state="translated">Отрицательная величина комплексного числа.</target>
        </trans-unit>
        <trans-unit id="2ff00bf6c0c197af17057ab64282dcdcec685b3e" translate="yes" xml:space="preserve">
          <source>The normal &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; function with right associativity instead of left.</source>
          <target state="translated">Функция normal &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; с правой ассоциативностью вместо левой.</target>
        </trans-unit>
        <trans-unit id="e8ea10bfd840fdd3f1f9ba01648e552adcfe5390" translate="yes" xml:space="preserve">
          <source>The normal rule in Haskell is that your program must supply a &lt;code&gt;main&lt;/code&gt; function in module &lt;code&gt;Main&lt;/code&gt;. When testing, it is often convenient to change which function is the &amp;ldquo;main&amp;rdquo; one, and the &lt;code&gt;-main-is&lt;/code&gt; flag allows you to do so. The ⟨thing⟩ can be one of:</source>
          <target state="translated">Обычное правило в Haskell - ваша программа должна предоставлять &lt;code&gt;main&lt;/code&gt; функцию в модуле &lt;code&gt;Main&lt;/code&gt; . При тестировании часто бывает удобно изменить, какая функция является &amp;laquo;основной&amp;raquo;, и флаг &lt;code&gt;-main-is&lt;/code&gt; позволяет это сделать. &amp;laquo;Что-то&amp;raquo; может быть одним из:</target>
        </trans-unit>
        <trans-unit id="8565c7cc336e9d2bc02ea4c1cab0de9e55beac01" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;a -&amp;gt; b&lt;/code&gt; used here between the &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;where&lt;/code&gt; symbols &amp;mdash; not to be confused with a function type &amp;mdash; indicates that the &lt;code&gt;a&lt;/code&gt; parameter uniquely determines the &lt;code&gt;b&lt;/code&gt; parameter, and might be read as &amp;ldquo;&lt;code&gt;a&lt;/code&gt; determines &lt;code&gt;b&lt;/code&gt;.&amp;rdquo; Thus &lt;code&gt;D&lt;/code&gt; is not just a relation, but actually a (partial) function. Similarly, from the two dependencies that are included in the definition of &lt;code&gt;E&lt;/code&gt;, we can see that &lt;code&gt;E&lt;/code&gt; represents a (partial) one-to-one mapping between types.</source>
          <target state="translated">Обозначение &lt;code&gt;a -&amp;gt; b&lt;/code&gt; используется здесь между &lt;code&gt;|&lt;/code&gt; и &lt;code&gt;where&lt;/code&gt; символы - не путать с типом функции - указывают, что параметр &lt;code&gt;a&lt;/code&gt; однозначно определяет параметр &lt;code&gt;b&lt;/code&gt; и может быть прочитан как &amp;laquo; &lt;code&gt;a&lt;/code&gt; определяет &lt;code&gt;b&lt;/code&gt; &amp;raquo;. Таким образом, &lt;code&gt;D&lt;/code&gt; - это не просто отношение, а фактически (частичная) функция. Точно так же из двух зависимостей, которые включены в определение &lt;code&gt;E&lt;/code&gt; , мы можем видеть, что &lt;code&gt;E&lt;/code&gt; представляет собой (частичное) взаимно-однозначное сопоставление между типами.</target>
        </trans-unit>
        <trans-unit id="65e0f3cb1cdca573b0a31816dea29f6e08943a92" translate="yes" xml:space="preserve">
          <source>The null address.</source>
          <target state="translated">Нулевой адрес.</target>
        </trans-unit>
        <trans-unit id="6f24da5886263ef92cea0da538817aecc2d6f529" translate="yes" xml:space="preserve">
          <source>The number of bytes that must be consumed</source>
          <target state="translated">Количество потребляемых байтов</target>
        </trans-unit>
        <trans-unit id="ca0f126d79cabf7e2c5e95757d200444f569118d" translate="yes" xml:space="preserve">
          <source>The number of days in a given month according to the proleptic Gregorian calendar. First argument is year, second is month.</source>
          <target state="translated">Количество дней в данном месяце по пролептическому григорианскому календарю.Первый аргумент-год,второй-месяц.</target>
        </trans-unit>
        <trans-unit id="9391d34aef57b18832247680a9bb961c2cb802e0" translate="yes" xml:space="preserve">
          <source>The number of days in a given month according to the proleptic Julian calendar. First argument is year, second is month.</source>
          <target state="translated">Количество дней в данном месяце по пролептическому юлианскому календарю.Первый аргумент-год,второй-месяц.</target>
        </trans-unit>
        <trans-unit id="0419481cf5884d86b99e61181cced8b51e95c26d" translate="yes" xml:space="preserve">
          <source>The number of elements in the array.</source>
          <target state="translated">Количество элементов в массиве.</target>
        </trans-unit>
        <trans-unit id="43d9d47c41193f72155e7e7c1d8d822460113e6b" translate="yes" xml:space="preserve">
          <source>The number of minutes offset from UTC. Positive means local time will be later in the day than UTC.</source>
          <target state="translated">Смещение количества минут по UTC.Положительно означает,что местное время будет позже,чем UTC.</target>
        </trans-unit>
        <trans-unit id="69b816c0ec0e62c60a64cad0412b6307fc8984cc" translate="yes" xml:space="preserve">
          <source>The number of times this particular point in the call tree was entered.</source>
          <target state="translated">Количество раз,которое эта конкретная точка была введена в дереве вызовов.</target>
        </trans-unit>
        <trans-unit id="d0ef27c2e92d99ce3709f3c8cd8149198afbb479" translate="yes" xml:space="preserve">
          <source>The numeric branch for this version. This reflects the fact that most software versions are tree-structured; there is a main trunk which is tagged with versions at various points (1,2,3...), and the first branch off the trunk after version 3 is 3.1, the second branch off the trunk after version 3 is 3.2, and so on. The tree can be branched arbitrarily, just by adding more digits.</source>
          <target state="translated">Числовая ветка для этой версии.Это отражает тот факт,что большинство версий программ имеют древовидную структуру;есть основной ствол,который помечен версиями в различных точках (1,2,3...),и первое ответвление из ствола после версии 3 равно 3.1,второе ответвление из ствола после версии 3 равно 3.2,и так далее.Дерево может разветвляться произвольно,просто добавляя дополнительные цифры.</target>
        </trans-unit>
        <trans-unit id="4f31d4347cd14b9ff9a95c759d4f40a65f6f736b" translate="yes" xml:space="preserve">
          <source>The object file, which normally ends in a &lt;code&gt;.o&lt;/code&gt; suffix, contains the compiled code for the module.</source>
          <target state="translated">Объектный файл, который обычно заканчивается суффиксом &lt;code&gt;.o&lt;/code&gt; , содержит скомпилированный код для модуля.</target>
        </trans-unit>
        <trans-unit id="805b61067737cd38cfcd7f8a184e0af8d81d4642" translate="yes" xml:space="preserve">
          <source>The object files, &lt;code&gt;Foo.o&lt;/code&gt;, &lt;code&gt;Bar.o&lt;/code&gt;, and &lt;code&gt;Bumble.o&lt;/code&gt; would be put into a subdirectory named after the architecture of the executing machine (&lt;code&gt;x86&lt;/code&gt;, &lt;code&gt;mips&lt;/code&gt;, etc).</source>
          <target state="translated">Объектные файлы &lt;code&gt;Foo.o&lt;/code&gt; , &lt;code&gt;Bar.o&lt;/code&gt; и &lt;code&gt;Bumble.o&lt;/code&gt; будут помещены в подкаталог, названный в соответствии с архитектурой исполняющей машины ( &lt;code&gt;x86&lt;/code&gt; , &lt;code&gt;mips&lt;/code&gt; и т. Д.).</target>
        </trans-unit>
        <trans-unit id="75f3688b610f29c49c2454cfe45bd0a8cb6e12b0" translate="yes" xml:space="preserve">
          <source>The object version of the library used by GHCi.</source>
          <target state="translated">Объектная версия библиотеки,используемой GHCi.</target>
        </trans-unit>
        <trans-unit id="838855ecfc9a22622038d43b1adcde548a91e7ce" translate="yes" xml:space="preserve">
          <source>The obsolete language options &lt;code&gt;PolymorphicComponents&lt;/code&gt; and &lt;a href=&quot;#extension-Rank2Types&quot;&gt;&lt;code&gt;Rank2Types&lt;/code&gt;&lt;/a&gt; are synonyms for &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;. They used to specify finer distinctions that GHC no longer makes. (They should really elicit a deprecation warning, but they don&amp;rsquo;t, purely to avoid the need to library authors to change their old flags specifications.)</source>
          <target state="translated">Устаревшие языковые параметры &lt;code&gt;PolymorphicComponents&lt;/code&gt; и &lt;a href=&quot;#extension-Rank2Types&quot;&gt; &lt;code&gt;Rank2Types&lt;/code&gt; &lt;/a&gt; являются синонимами для &lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt; . Раньше они определяли более тонкие различия, которые GHC больше не делает. (Они действительно должны вызывать предупреждение об устаревании, но они этого не делают, просто чтобы избежать необходимости для авторов библиотеки изменять свои старые спецификации флагов.)</target>
        </trans-unit>
        <trans-unit id="de0046d717353b2193c161124220232a1d8fd82e" translate="yes" xml:space="preserve">
          <source>The old, shadowed, version of &lt;code&gt;T&lt;/code&gt; is displayed as &lt;code&gt;main::Interactive.T&lt;/code&gt; by GHCi in an attempt to distinguish it from the new &lt;code&gt;T&lt;/code&gt;, which is displayed as simply &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Старая, слежка, версия &lt;code&gt;T&lt;/code&gt; отображается как &lt;code&gt;main::Interactive.T&lt;/code&gt; по GHCi в попытке отличить его от нового &lt;code&gt;T&lt;/code&gt; , который отображается как просто &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c88cd7b17fb54593c249863957ba4ed3bfbb9b4a" translate="yes" xml:space="preserve">
          <source>The one exception to this rule is &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, since deriving an instance via &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; simply generates an empty instance declaration, which does not require the use of any constructors. See the &lt;a href=&quot;#derive-any-class&quot;&gt;deriving any class&lt;/a&gt; section for more details.</source>
          <target state="translated">Единственным исключением из этого правила является &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; , поскольку при получении экземпляра через &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; просто создается пустое объявление экземпляра, которое не требует использования каких-либо конструкторов. Подробнее см. В разделе &amp;laquo; &lt;a href=&quot;#derive-any-class&quot;&gt;Создание любого класса&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="0268dcd59bf97b0cda9fb2201599f6e5dff9ca67" translate="yes" xml:space="preserve">
          <source>The only IO operations allowed in the IO action passed to &lt;code&gt;unsafeLocalState&lt;/code&gt; are (a) local allocation (&lt;code&gt;alloca&lt;/code&gt;, &lt;code&gt;allocaBytes&lt;/code&gt; and derived operations such as &lt;code&gt;withArray&lt;/code&gt; and &lt;code&gt;withCString&lt;/code&gt;), and (b) pointer operations (&lt;code&gt;Foreign.Storable&lt;/code&gt; and &lt;code&gt;Foreign.Ptr&lt;/code&gt;) on the pointers to local storage, and (c) foreign functions whose only observable effect is to read and/or write the locally allocated memory. Passing an IO operation that does not obey these rules results in undefined behaviour.</source>
          <target state="translated">Единственными операциями ввода-вывода, разрешенными в действии ввода-вывода, передаваемом в &lt;code&gt;unsafeLocalState&lt;/code&gt; , являются (а) локальное выделение ( &lt;code&gt;alloca&lt;/code&gt; , &lt;code&gt;allocaBytes&lt;/code&gt; и производные операции, такие как &lt;code&gt;withArray&lt;/code&gt; и &lt;code&gt;withCString&lt;/code&gt; ) и (б) операции с указателями ( &lt;code&gt;Foreign.Storable&lt;/code&gt; и &lt;code&gt;Foreign.Ptr&lt;/code&gt; ) для указателей. в локальное хранилище и (c) сторонние функции, единственный наблюдаемый эффект которых - чтение и / или запись в локально выделенную память. Передача операции ввода-вывода, которая не подчиняется этим правилам, приводит к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="e9a1db195c814668311158eb1709c1054c413cfc" translate="yes" xml:space="preserve">
          <source>The only difference between the two groups is that in the second group &lt;code&gt;len_acc&lt;/code&gt; is given a type signature. In the former case, &lt;code&gt;len_acc1&lt;/code&gt; is monomorphic in its own right-hand side, so the implicit parameter &lt;code&gt;?acc&lt;/code&gt; is not passed to the recursive call. In the latter case, because &lt;code&gt;len_acc2&lt;/code&gt; has a type signature, the recursive call is made to the &lt;em&gt;polymorphic&lt;/em&gt; version, which takes &lt;code&gt;?acc&lt;/code&gt; as an implicit parameter. So we get the following results in GHCi:</source>
          <target state="translated">Единственное различие между двумя группами состоит в том, что во второй группе &lt;code&gt;len_acc&lt;/code&gt; дается сигнатура типа. В первом случае &lt;code&gt;len_acc1&lt;/code&gt; является мономорфным в своей собственной правой части, поэтому неявный параметр &lt;code&gt;?acc&lt;/code&gt; не передается рекурсивному вызову. В последнем случае, поскольку &lt;code&gt;len_acc2&lt;/code&gt; имеет сигнатуру типа, рекурсивный вызов выполняется к &lt;em&gt;полиморфной&lt;/em&gt; версии, которая принимает &lt;code&gt;?acc&lt;/code&gt; в качестве неявного параметра. Итак, в GHCi мы получаем следующие результаты:</target>
        </trans-unit>
        <trans-unit id="ac6054b6f6b6ca4251de8b08424a09d5460a4c6c" translate="yes" xml:space="preserve">
          <source>The only permissible implementation of such a signature is a module which reexports precisely the same entity:</source>
          <target state="translated">Единственной допустимой реализацией такой подписи является модуль,который реэкспортирует точно такую же сущность:</target>
        </trans-unit>
        <trans-unit id="99f45ecbd145f7b28b73197352d367ab369881f7" translate="yes" xml:space="preserve">
          <source>The only point where the &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; parser should be called explicitly is the start of the main parser in order to skip any leading white space.</source>
          <target state="translated">Единственная точка, где синтаксический анализатор &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; должен вызываться явно, - это начало основного синтаксического анализатора, чтобы пропустить любые начальные пробелы.</target>
        </trans-unit>
        <trans-unit id="0d17721b8d0f0086bd5ec1ab600c24a5629c442f" translate="yes" xml:space="preserve">
          <source>The only point where the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; parser should be called explicitly is the start of the main parser in order to skip any leading white space.</source>
          <target state="translated">Единственная точка, где синтаксический анализатор &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; должен вызываться явно, - это начало основного синтаксического анализатора, чтобы пропустить любые начальные пробелы.</target>
        </trans-unit>
        <trans-unit id="bb632a82c8eebfabcb7f6f7ed3c1cccfca2ac4bd" translate="yes" xml:space="preserve">
          <source>The only predefined instance is the obvious one that does nothing:</source>
          <target state="translated">Единственный предопределенный экземпляр-это очевидный экземпляр,который ничего не делает:</target>
        </trans-unit>
        <trans-unit id="b74e3ab63478dc88412921dd78460cac468112a4" translate="yes" xml:space="preserve">
          <source>The only predefined instance is the obvious one to make strings work as usual:</source>
          <target state="translated">Единственный предопределенный экземпляр-это очевидный экземпляр,который заставляет строки работать как обычно:</target>
        </trans-unit>
        <trans-unit id="225b573fdeb899c7024573c1625d7b7bcfcbe5a0" translate="yes" xml:space="preserve">
          <source>The only problem comes when a module contains an instance declaration and GHC has no other reason for visiting the module. Example:</source>
          <target state="translated">Единственная проблема возникает,когда модуль содержит объявление экземпляра,а у GHC нет других причин для посещения модуля.Пример:</target>
        </trans-unit>
        <trans-unit id="a77af1dde4bfd3f080f8a163fea93aea7a444506" translate="yes" xml:space="preserve">
          <source>The only thing left to do now is to define a &amp;ldquo;front-end&amp;rdquo; class, which is exposed to the user:</source>
          <target state="translated">Единственное, что осталось сделать сейчас, это определить &amp;laquo;интерфейсный&amp;raquo; класс, который предоставляется пользователю:</target>
        </trans-unit>
        <trans-unit id="4957a1ff0c6373e596985963e968abbd42fa8755" translate="yes" xml:space="preserve">
          <source>The only use for the &lt;code&gt;Unused&lt;/code&gt; constructor was to force the correct kind for the type variable &lt;code&gt;cxt&lt;/code&gt;.</source>
          <target state="translated">Единственное использование конструктора &lt;code&gt;Unused&lt;/code&gt; - это принудительное использование правильного типа для переменной типа &lt;code&gt;cxt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69d170600f85b05b40716ccd35bcd4f06954e076" translate="yes" xml:space="preserve">
          <source>The operating system on which the program is running.</source>
          <target state="translated">Операционная система,на которой выполняется программа.</target>
        </trans-unit>
        <trans-unit id="34731bb0d80073cd13a1f4f0433438861e603be9" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is either a directory or a symbolic link to a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">Операция &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если файл аргументов существует и является каталогом или символической ссылкой на каталог, и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="abe2bcec36d3cfe98f8b3b771acf0e3cbe03a0c1" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is not a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">Операция &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если файл аргументов существует и не является каталогом, и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="c1014ad70a94098ad03145dbaaa5e10a46dcfeb3" translate="yes" xml:space="preserve">
          <source>The operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setCurrentDirectory&quot;&gt;setCurrentDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Операция может завершиться ошибкой с теми же исключениями, что и &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;system-directory#v:setCurrentDirectory&quot;&gt;setCurrentDirectory&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1a77a11f3e83e3fc7cb291c25444400219866a2" translate="yes" xml:space="preserve">
          <source>The operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Операция может завершиться ошибкой с теми же исключениями, что и &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec1e5f517351d98a1317840aae7a3f6d64c13a50" translate="yes" xml:space="preserve">
          <source>The operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:listDirectory&quot;&gt;listDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Операция может завершиться неудачно с теми же исключениями, что и &lt;code&gt;&lt;a href=&quot;system-directory#v:listDirectory&quot;&gt;listDirectory&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0c5c7f2e239edbf825df9ce2a38beea0ba143ba" translate="yes" xml:space="preserve">
          <source>The operation may fail with:</source>
          <target state="translated">Операция может выйти из строя:</target>
        </trans-unit>
        <trans-unit id="8c066a4952b72a09ccd45c4c56e69a302b836518" translate="yes" xml:space="preserve">
          <source>The operations on strings are similar.</source>
          <target state="translated">Операции со строками похожи.</target>
        </trans-unit>
        <trans-unit id="d278879460916dc24a386ba29fcbbca12720c53d" translate="yes" xml:space="preserve">
          <source>The operator section is treated like function application of an undefined function, while the lambda form is in WHNF that contains an application of an undefined function.</source>
          <target state="translated">Операторская часть рассматривается как применение функции неопределенной функции,в то время как лямбда-форма находится в WHNF,которая содержит применение неопределенной функции.</target>
        </trans-unit>
        <trans-unit id="90d2b833a3ae58e36d089e36990a3439898a2cf2" translate="yes" xml:space="preserve">
          <source>The optimisation also works for GADTs which bind dictionaries. If we statically know which class dictionary we need then we will solve it directly rather than indirectly using the one passed in at run time.</source>
          <target state="translated">Оптимизация также работает для GADT,которые связывают словари.Если мы статически знаем,в каком классе нам нужен словарь,то будем решать его прямо,а не косвенно,используя тот,который передается во время выполнения.</target>
        </trans-unit>
        <trans-unit id="560d5fd1f4bc4b620b6067d2806fe1c21df3d911" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--C&quot;&gt;&lt;code&gt;-C&lt;/code&gt;&lt;/a&gt; is only available when GHC is built in unregisterised mode. See &lt;a href=&quot;codegens#unreg&quot;&gt;Unregisterised compilation&lt;/a&gt; for more details.</source>
          <target state="translated">Параметр &lt;a href=&quot;#ghc-flag--C&quot;&gt; &lt;code&gt;-C&lt;/code&gt; &lt;/a&gt; доступен только в том случае, если GHC построен в незарегистрированном режиме. Подробнее см. &lt;a href=&quot;codegens#unreg&quot;&gt;Незарегистрированная компиляция&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00a060100430958f91df26ba43eebf619fa4ae0a" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--E&quot;&gt;&lt;code&gt;-E&lt;/code&gt;&lt;/a&gt; runs just the pre-processing passes of the compiler, dumping the result in a file.</source>
          <target state="translated">Параметр &lt;a href=&quot;#ghc-flag--E&quot;&gt; &lt;code&gt;-E&lt;/code&gt; &lt;/a&gt; запускает только этапы предварительной обработки компилятора, выгружая результат в файл.</target>
        </trans-unit>
        <trans-unit id="0964a10be81d642da333713be7237fbcfb02fa70" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; warns about places where a pattern-match might fail at runtime. The function &lt;code&gt;g&lt;/code&gt; below will fail when applied to non-empty lists, so the compiler will emit a warning about this when &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">Параметр &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt; предупреждает о местах, где сопоставление с шаблоном может завершиться ошибкой во время выполнения. Приведенная ниже функция &lt;code&gt;g&lt;/code&gt; завершится ошибкой при применении к непустым спискам, поэтому компилятор выдаст предупреждение об этом при &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ccd337cf3edfdd4e01711e8e069283d6a4d19280" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt;&lt;code&gt;-Wpartial-fields&lt;/code&gt;&lt;/a&gt; warns about record fields that could fail when accessed via a lacking constructor. The function &lt;code&gt;f&lt;/code&gt; below will fail when applied to &lt;code&gt;Bar&lt;/code&gt;, so the compiler will emit a warning at its definition when &lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt;&lt;code&gt;-Wpartial-fields&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">Параметр &lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt; &lt;code&gt;-Wpartial-fields&lt;/code&gt; &lt;/a&gt; предупреждает о полях записи, которые могут выйти из строя при доступе через отсутствующий конструктор. Приведенная ниже функция &lt;code&gt;f&lt;/code&gt; завершится ошибкой при применении к &lt;code&gt;Bar&lt;/code&gt; , поэтому компилятор выдаст предупреждение при ее определении, когда &lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt; &lt;code&gt;-Wpartial-fields&lt;/code&gt; &lt;/a&gt; включено.</target>
        </trans-unit>
        <trans-unit id="f50424482bd3ed523aa1fb5ace8902d19e5c6938" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt;&lt;code&gt;-feager-blackholing&lt;/code&gt;&lt;/a&gt; causes each thunk to be blackholed as soon as evaluation begins. The default is &amp;ldquo;lazy blackholing&amp;rdquo;, whereby thunks are only marked as being under evaluation when a thread is paused for some reason. Lazy blackholing is typically more efficient (by 1-2% or so), because most thunks don&amp;rsquo;t need to be blackholed. However, eager blackholing can avoid more repeated computation in a parallel program, and this often turns out to be important for parallelism.</source>
          <target state="translated">Опция &lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt; &lt;code&gt;-feager-blackholing&lt;/code&gt; &lt;/a&gt; заставляет каждый преобразователь блокироваться, как только начинается оценка. По умолчанию используется &amp;laquo;ленивая черная дыра&amp;raquo;, при которой преобразователи помечаются как находящиеся на стадии оценки только тогда, когда поток по какой-либо причине приостановлен. Ленивая черная дыра обычно более эффективна (на 1-2% или около того), потому что большинство преобразователей не нуждаются в черной дыре. Тем не менее, нетерпеливое &amp;laquo;чёрное пятно&amp;raquo; может избежать повторения вычислений в параллельной программе, и это часто оказывается важным для параллелизма.</target>
        </trans-unit>
        <trans-unit id="dc3e0ec3b48b83ee97a18d535f56695193e4148b" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;-XExtendedDefaultRules&lt;/code&gt; is enabled, in order to apply special defaulting rules to expressions typed at the prompt (see &lt;a href=&quot;#extended-default-rules&quot;&gt;Type defaulting in GHCi&lt;/a&gt;).</source>
          <target state="translated">Параметр &lt;code&gt;-XExtendedDefaultRules&lt;/code&gt; включен для применения специальных правил по умолчанию к выражениям, набранным в приглашении (см. &lt;a href=&quot;#extended-default-rules&quot;&gt;Тип по умолчанию в GHCi&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a172fb76c6f9f556ecc7ed1e53e547b76840fe25" translate="yes" xml:space="preserve">
          <source>The option descriptions (see &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:OptDescr&quot;&gt;OptDescr&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">Описание опций (см. &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:OptDescr&quot;&gt;OptDescr&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="90c51e481e3ef85be23988058a9d8ffbfe523dad" translate="yes" xml:space="preserve">
          <source>The order requirements (see &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:ArgOrder&quot;&gt;ArgOrder&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">Требования к заказу (см. &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:ArgOrder&quot;&gt;ArgOrder&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a48428e93cda469aec76c5bbf3a45a3d1d4c0eca" translate="yes" xml:space="preserve">
          <source>The original discussion is archived here: &lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2010-January/072379.html&quot;&gt;could we get a Data instance for Data.Text.Text?&lt;/a&gt;</source>
          <target state="translated">Исходное обсуждение заархивировано здесь: &lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2010-January/072379.html&quot;&gt;можем ли мы получить экземпляр Data для Data.Text.Text?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3f3ab7a20ae1158bd257f4656d1c486a0bcb46f" translate="yes" xml:space="preserve">
          <source>The original program is just plain wrong. Here&amp;rsquo;s another sort of error</source>
          <target state="translated">Исходная программа просто неверна. Вот еще одна ошибка</target>
        </trans-unit>
        <trans-unit id="6a36573f2a76f839bf0ccfbddc9a2d1af4b0c55c" translate="yes" xml:space="preserve">
          <source>The original set of data constructors for &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">Исходный набор конструкторов данных для &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="026c8d8f9302a24eb8eb077091c8693319be6e8f" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; operation, &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;, has a suitable type for lifting using &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:mapStateT&quot;&gt;mapStateT&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Другой &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; операции, &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; , имеет подходящий тип для подъема с помощью &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:mapStateT&quot;&gt;mapStateT&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1421877ede54d6e7f4dbd61b5345c2c064b769f8" translate="yes" xml:space="preserve">
          <source>The other combinators have sensible default definitions, which may be overridden for efficiency.</source>
          <target state="translated">Другие комбинаторы имеют разумные определения по умолчанию,которые могут быть переопределены для эффективности.</target>
        </trans-unit>
        <trans-unit id="ab98415919b10ecc3cc9f0ce7f01d77f22a18942" translate="yes" xml:space="preserve">
          <source>The other methods have the following default definitions, which may be overridden with equivalent specialized implementations:</source>
          <target state="translated">Другие методы имеют следующие определения по умолчанию,которые могут быть переопределены эквивалентными специализированными реализациями:</target>
        </trans-unit>
        <trans-unit id="1ac58fe3cbf02ef4899da15f0408247b3325cf81" translate="yes" xml:space="preserve">
          <source>The other place where role annotations may be necessary are in &lt;code&gt;hs-boot&lt;/code&gt; files (&lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;), where the right-hand sides of definitions can be omitted. As usual, the types/classes declared in an &lt;code&gt;hs-boot&lt;/code&gt; file must match up with the definitions in the &lt;code&gt;hs&lt;/code&gt; file, including down to the roles. The default role for datatypes is representational in &lt;code&gt;hs-boot&lt;/code&gt; files, corresponding to the common use case.</source>
          <target state="translated">Другое место, где могут потребоваться аннотации ролей, - это файлы &lt;code&gt;hs-boot&lt;/code&gt; ( &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;Как компилировать взаимно рекурсивные модули&lt;/a&gt; ), где правые части определений могут быть опущены. Как обычно, типы / классы, объявленные в файле &lt;code&gt;hs-boot&lt;/code&gt; , должны совпадать с определениями в файле &lt;code&gt;hs&lt;/code&gt; , включая роли. Роль по умолчанию для типов данных является представительной в файлах &lt;code&gt;hs-boot&lt;/code&gt; , что соответствует общему варианту использования.</target>
        </trans-unit>
        <trans-unit id="ce2fa55812a38ce84cedcaac2cdc1ef31b6202dc" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">Другая тактика, приведенная ниже, - это оптимизация или упрощение &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; для особых случаев. Самое главное,</target>
        </trans-unit>
        <trans-unit id="3063f59fc82d5bcf9d848a0f374f0dfb94c93aae" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">Другая тактика, представленная ниже, - это оптимизация или упрощение &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; для особых случаев. Самое главное,</target>
        </trans-unit>
        <trans-unit id="ac62773ad5362997c71d7ab264fe5c75fd2faaf0" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">Другая тактика, приведенная ниже, - это оптимизация или упрощение &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; для особых случаев. Самое главное,</target>
        </trans-unit>
        <trans-unit id="b158418f40f40b703534feba48e0a39163932604" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">Другая тактика, представленная ниже, - это оптимизация или упрощение &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; для особых случаев. Самое главное,</target>
        </trans-unit>
        <trans-unit id="dd0ae12fb273623c47053fb946e9734ec1504f3d" translate="yes" xml:space="preserve">
          <source>The other time when &lt;code&gt;ghc-pkg recache&lt;/code&gt; is useful is for registering packages manually: it is possible to register a package by simply putting the appropriate file in the package database directory and invoking &lt;code&gt;ghc-pkg recache&lt;/code&gt; to update the cache. This method of registering packages may be more convenient for automated packaging systems.</source>
          <target state="translated">Другой случай, когда &lt;code&gt;ghc-pkg recache&lt;/code&gt; полезен, - это регистрация пакетов вручную: можно зарегистрировать пакет, просто поместив соответствующий файл в каталог базы данных пакетов и вызвав &lt;code&gt;ghc-pkg recache&lt;/code&gt; для обновления кеша. Этот метод регистрации пакетов может быть более удобным для автоматизированных систем упаковки.</target>
        </trans-unit>
        <trans-unit id="0861b9b6f0ebfe21a1fd22a4af5949eaf3c859aa" translate="yes" xml:space="preserve">
          <source>The outer type constructor of the type</source>
          <target state="translated">Конструктор наружного типа типа</target>
        </trans-unit>
        <trans-unit id="e52891e976f0923c9c450c24bf9a613b4e6090fe" translate="yes" xml:space="preserve">
          <source>The outermost pattern of all pattern matches gets an implicit bang, unless disabled with &lt;code&gt;~&lt;/code&gt;. This applies to case expressions, patterns in lambda, do-notation, list comprehension, and so on. For example</source>
          <target state="translated">Самый внешний шаблон из всех совпадений шаблонов получает неявный удар, если не отключен с помощью &lt;code&gt;~&lt;/code&gt; . Это относится к выражениям регистра, шаблонам в лямбда-выражениях, нотации до, пониманию списков и так далее. Например</target>
        </trans-unit>
        <trans-unit id="50fd86f2281248d9b015c6814bb25ce010f3a96e" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is the unused portion of the left half of the line, reversed.</source>
          <target state="translated">Выходная &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; - это неиспользуемая часть левой половины строки, перевернутая.</target>
        </trans-unit>
        <trans-unit id="cb7e26fd34291e2acd5790d7394332a842bf49bb" translate="yes" xml:space="preserve">
          <source>The output contains one report for each exception raised in the program (the program might raise and catch several exceptions during its execution), where each report looks something like this:</source>
          <target state="translated">Вывод содержит по одному отчету за каждое возникшее в программе исключение (программа может вызвать и поймать несколько исключений во время своего выполнения),где каждый отчет выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="05194572a5381678c8a688228784f26b016a976f" translate="yes" xml:space="preserve">
          <source>The output is buffered using the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s associated buffer. If this buffer is too small to execute one step of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; action, then it is replaced with a large enough buffer.</source>
          <target state="translated">Выход буферном с помощью &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; связанный с ним буфер сек. Если этот буфер слишком мал для выполнения одного шага действия &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; , он заменяется достаточно большим буфером.</target>
        </trans-unit>
        <trans-unit id="0c8e73b419eae441e273e393df1e5bc3d4c312e7" translate="yes" xml:space="preserve">
          <source>The output is placed in ⟨file⟩. If ⟨file⟩ is omitted, then the output is sent to &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">Вывод помещается в &amp;laquo;файл&amp;raquo;. Если file⟩ опущен, то вывод отправляется на &lt;code&gt;stderr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c175e78b8f75a38f3457e0b934e42a19295ad3d3" translate="yes" xml:space="preserve">
          <source>The output of &lt;a href=&quot;#ghci-cmd-:complete&quot;&gt;&lt;code&gt;:complete&lt;/code&gt;&lt;/a&gt; begins with a header line containing three space-delimited fields:</source>
          <target state="translated">Вывод &lt;a href=&quot;#ghci-cmd-:complete&quot;&gt; &lt;code&gt;:complete&lt;/code&gt; &lt;/a&gt; начинается со строки заголовка, содержащей три поля, разделенных пробелами:</target>
        </trans-unit>
        <trans-unit id="28802857a982ea85a85714f0425defb468c55946" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;+RTS -s&lt;/code&gt; tells you how many &amp;ldquo;sparks&amp;rdquo; were created and executed during the run of the program (see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;), which will give you an idea how well your &lt;code&gt;par&lt;/code&gt; annotations are working.</source>
          <target state="translated">Вывод команды &lt;code&gt;+RTS -s&lt;/code&gt; сообщает вам, сколько &amp;laquo;искр&amp;raquo; было создано и выполнено во время выполнения программы (см. &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;Параметры RTS для управления сборщиком мусора&lt;/a&gt; ), что даст вам представление о том, насколько хорошо работают ваши &lt;code&gt;par&lt;/code&gt; - аннотации.</target>
        </trans-unit>
        <trans-unit id="5ec2bae52b2cc3a473ad80eff58c4a7008471d7a" translate="yes" xml:space="preserve">
          <source>The output of this program:</source>
          <target state="translated">Вывод этой программы:</target>
        </trans-unit>
        <trans-unit id="2446a2868a9a29723ecfffcf757a87c6d61bb061" translate="yes" xml:space="preserve">
          <source>The overloaded immutable array interface</source>
          <target state="translated">Перегруженный непреложный интерфейс массива</target>
        </trans-unit>
        <trans-unit id="1e0e89b8710fb95ffae85a663ed5283ed9621513" translate="yes" xml:space="preserve">
          <source>The package name of the module where the type is declared</source>
          <target state="translated">Имя пакета модуля,в котором объявлен тип</target>
        </trans-unit>
        <trans-unit id="48d90d755f55a500041350382bef98a10e9d0ca5" translate="yes" xml:space="preserve">
          <source>The package specification must be a package that isn&amp;rsquo;t already installed.</source>
          <target state="translated">В спецификации пакета должен быть пакет, который еще не установлен.</target>
        </trans-unit>
        <trans-unit id="f92b41996d348be77128232f9506df91b9529223" translate="yes" xml:space="preserve">
          <source>The pair returned by &lt;code&gt;&lt;a href=&quot;data-either#v:partitionEithers&quot;&gt;partitionEithers&lt;/a&gt; x&lt;/code&gt; should be the same pair as &lt;code&gt;(&lt;a href=&quot;data-either#v:lefts&quot;&gt;lefts&lt;/a&gt; x, &lt;a href=&quot;data-either#v:rights&quot;&gt;rights&lt;/a&gt; x)&lt;/code&gt;:</source>
          <target state="translated">Пара, возвращаемая &lt;code&gt;&lt;a href=&quot;data-either#v:partitionEithers&quot;&gt;partitionEithers&lt;/a&gt; x&lt;/code&gt; , должна быть той же парой, что и &lt;code&gt;(&lt;a href=&quot;data-either#v:lefts&quot;&gt;lefts&lt;/a&gt; x, &lt;a href=&quot;data-either#v:rights&quot;&gt;rights&lt;/a&gt; x)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="87fe52a309c7ffdc572bfe5a6172b7ecd3b52888" translate="yes" xml:space="preserve">
          <source>The paper &lt;a href=&quot;http://i.cs.hku.hk/~bruno//papers/hs2017.pdf&quot;&gt;Quantified class constraints&lt;/a&gt; (by Bottu, Karachalias, Schrijvers, Oliveira, Wadler, Haskell Symposium 2017) describes this feature in technical detail, with examples, and so is a primary reference source for this proposal.</source>
          <target state="translated">В документе &lt;a href=&quot;http://i.cs.hku.hk/~bruno//papers/hs2017.pdf&quot;&gt;Quantified class constraints&lt;/a&gt; (Bottu, Karachalias, Schrijvers, Oliveira, Wadler, Haskell Symposium 2017) описывается эта функция в технических деталях с примерами, и поэтому она является основным справочным источником для этого предложения.</target>
        </trans-unit>
        <trans-unit id="dced94497d68754bb216a7cf6251afa8e9bde139" translate="yes" xml:space="preserve">
          <source>The parameterizable exception monad.</source>
          <target state="translated">Параметризируемый монад исключений.</target>
        </trans-unit>
        <trans-unit id="b8f1d6b1bf477c0c166957c6d1222206673e1984" translate="yes" xml:space="preserve">
          <source>The parameterizable maybe monad, obtained by composing an arbitrary monad with the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">Параметризуемая монада &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; , полученная путем соединения произвольной монады с монадой Maybe .</target>
        </trans-unit>
        <trans-unit id="74b1844d5fa42c50cd76f5db0bf9f59ef141a0c6" translate="yes" xml:space="preserve">
          <source>The parameterizable reader monad.</source>
          <target state="translated">Параметризируемый считыватель monad.</target>
        </trans-unit>
        <trans-unit id="6146efa10903bbbf156fa5c26b4d5e4f6606ce79" translate="yes" xml:space="preserve">
          <source>The parentheses are required.</source>
          <target state="translated">Скобки обязательны.</target>
        </trans-unit>
        <trans-unit id="397c15a9095569645dd284901afa170c9778710f" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;anyToken&lt;/code&gt; accepts any kind of token. It is for example used to implement &lt;code&gt;&lt;a href=&quot;text-parsec#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;. Returns the accepted token.</source>
          <target state="translated">Парсер &lt;code&gt;anyToken&lt;/code&gt; принимает любые токены. Например, он используется для реализации &lt;code&gt;&lt;a href=&quot;text-parsec#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; . Возвращает принятый токен.</target>
        </trans-unit>
        <trans-unit id="70b77746def41feea7c0cc0c441ef8e1338f1075" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;anyToken&lt;/code&gt; accepts any kind of token. It is for example used to implement &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;. Returns the accepted token.</source>
          <target state="translated">Парсер &lt;code&gt;anyToken&lt;/code&gt; принимает любые токены. Например, он используется для реализации &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; . Возвращает принятый токен.</target>
        </trans-unit>
        <trans-unit id="959f106f98eb9f3ad1febb52797880e72fcf614c" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;anyToken&lt;/code&gt; accepts any kind of token. It is for example used to implement &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;. Returns the accepted token.</source>
          <target state="translated">Парсер &lt;code&gt;anyToken&lt;/code&gt; принимает любые токены. Например, он используется для реализации &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; . Возвращает принятый токен.</target>
        </trans-unit>
        <trans-unit id="032f4f1c69665e22c5b13c0fd126547d28a038f1" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;p &amp;lt;?&amp;gt; msg&lt;/code&gt; behaves as parser &lt;code&gt;p&lt;/code&gt;, but whenever the parser &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, it replaces expect error messages with the expect error message &lt;code&gt;msg&lt;/code&gt;.</source>
          <target state="translated">Синтаксический анализатор &lt;code&gt;p &amp;lt;?&amp;gt; msg&lt;/code&gt; ведет себя как синтаксический анализатор &lt;code&gt;p&lt;/code&gt; , но всякий раз, когда синтаксический анализатор &lt;code&gt;p&lt;/code&gt; дает сбой, &lt;em&gt;не потребляя никаких входных данных&lt;/em&gt; , он заменяет ожидаемые сообщения об ошибках на ожидаемое сообщение об ошибке &lt;code&gt;msg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8f1cafb19ba2c6dd478998d4b66d545fc48222e" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;permute perm&lt;/code&gt; parses a permutation of parser described by &lt;code&gt;perm&lt;/code&gt;. For example, suppose we want to parse a permutation of: an optional string of &lt;code&gt;a&lt;/code&gt;'s, the character &lt;code&gt;b&lt;/code&gt; and an optional &lt;code&gt;c&lt;/code&gt;. This can be described by:</source>
          <target state="translated">Анализатор &lt;code&gt;permute perm&lt;/code&gt; анализирует перестановку синтаксического анализатора, описанную &lt;code&gt;perm&lt;/code&gt; . Например, предположим, что мы хотим проанализировать перестановку: необязательной строки &lt;code&gt;a&lt;/code&gt; , символа &lt;code&gt;b&lt;/code&gt; и необязательного &lt;code&gt;c&lt;/code&gt; . Это можно описать следующим образом:</target>
        </trans-unit>
        <trans-unit id="8e254f70fe9adf4383093f8ce0d95f1c2bcda2e8" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;satisfy f&lt;/code&gt; succeeds for any character for which the supplied function &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;. Returns the character that is actually parsed.</source>
          <target state="translated">Синтаксический анализатор &lt;code&gt;satisfy f&lt;/code&gt; успешно для любого символа, для которого предоставленная функция &lt;code&gt;f&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; . Возвращает фактически проанализированный символ.</target>
        </trans-unit>
        <trans-unit id="1bfb2b49655a713a162727e182fda358189b4c0f" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The source position of the &lt;code&gt;t&lt;/code&gt; should be returned by &lt;code&gt;posFromTok t&lt;/code&gt; and the token can be shown using &lt;code&gt;showTok t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; парсера showTok posFromTok testTok принимает токен &lt;code&gt;t&lt;/code&gt; с результатом &lt;code&gt;x&lt;/code&gt; , когда функция &lt;code&gt;testTok t&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; . &lt;code&gt;posFromTok t&lt;/code&gt; позиция &lt;code&gt;t&lt;/code&gt; должна быть возвращена posFromTok t, а токен может быть показан с помощью &lt;code&gt;showTok t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8a05309fd4e0b7bbf92681d8e8ae0f5ce9a9e73" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The token can be shown using &lt;code&gt;showTok t&lt;/code&gt;. The position of the &lt;em&gt;next&lt;/em&gt; token should be returned when &lt;code&gt;nextPos&lt;/code&gt; is called with the current source position &lt;code&gt;pos&lt;/code&gt;, the current token &lt;code&gt;t&lt;/code&gt; and the rest of the tokens &lt;code&gt;toks&lt;/code&gt;, &lt;code&gt;nextPos pos t toks&lt;/code&gt;.</source>
          <target state="translated">Анализатор &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; принимает токен &lt;code&gt;t&lt;/code&gt; с результатом &lt;code&gt;x&lt;/code&gt; , когда функция &lt;code&gt;testTok t&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; . Токен можно показать с помощью &lt;code&gt;showTok t&lt;/code&gt; . Положение &lt;em&gt;следующих&lt;/em&gt; маркеров должно быть возвращено , когда &lt;code&gt;nextPos&lt;/code&gt; вызываются с текущим положением источника &lt;code&gt;pos&lt;/code&gt; , текущими маркерами &lt;code&gt;t&lt;/code&gt; и остальная частью лексем &lt;code&gt;toks&lt;/code&gt; , &lt;code&gt;nextPos pos t toks&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="284e02f9430552d71dd41595aab5dc530d4b9da6" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;try p&lt;/code&gt; behaves like parser &lt;code&gt;p&lt;/code&gt;, except that it pretends that it hasn't consumed any input when an error occurs.</source>
          <target state="translated">Синтаксический анализатор &lt;code&gt;try p&lt;/code&gt; ведет себя как синтаксический анализатор &lt;code&gt;p&lt;/code&gt; , за исключением того, что он делает вид, что не использовал никаких входных данных при возникновении ошибки.</target>
        </trans-unit>
        <trans-unit id="d3107597af9e1ca4d6874447085190c38569263b" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;unexpected msg&lt;/code&gt; always fails with an unexpected error message &lt;code&gt;msg&lt;/code&gt; without consuming any input.</source>
          <target state="translated">Анализатор &lt;code&gt;unexpected msg&lt;/code&gt; всегда терпит неудачу с неожиданным сообщением об ошибке &lt;code&gt;msg&lt;/code&gt; , не потребляя никакого входа.</target>
        </trans-unit>
        <trans-unit id="248c447e9af3733e32f0c2f859f725b0237051c8" translate="yes" xml:space="preserve">
          <source>The parser is called &lt;em&gt;predictive&lt;/em&gt; since &lt;code&gt;q&lt;/code&gt; is only tried when parser &lt;code&gt;p&lt;/code&gt; didn't consume any input (i.e.. the look ahead is 1). This non-backtracking behaviour allows for both an efficient implementation of the parser combinators and the generation of good error messages.</source>
          <target state="translated">Синтаксический анализатор называется &lt;em&gt;прогнозирующим,&lt;/em&gt; поскольку &lt;code&gt;q&lt;/code&gt; выполняется только в том случае, если синтаксический анализатор &lt;code&gt;p&lt;/code&gt; не потреблял никаких входных данных (т.е. упреждающий просмотр равен 1). Такое поведение без возврата позволяет как эффективную реализацию комбинаторов синтаксического анализатора, так и создание хороших сообщений об ошибках.</target>
        </trans-unit>
        <trans-unit id="c654c33ff97b96ae7e18c028c030987b14161463" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Анализаторы &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; работают , ( &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) И &lt;code&gt;unexpected&lt;/code&gt; - три парсера, используемые для генерации сообщений об ошибках. Из них обычно используется только ( &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ). Пример использования &lt;code&gt;unexpected&lt;/code&gt; см. В определении &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5368ea498695499b712c681c0cc89fba27b8d208" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Анализаторы &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; работают , ( &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) И &lt;code&gt;unexpected&lt;/code&gt; - три парсера, используемые для генерации сообщений об ошибках. Из них обычно используется только ( &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ). Пример использования &lt;code&gt;unexpected&lt;/code&gt; см. В определении &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="128ec374e35c570797eef5701a7459bc72bdf064" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Анализаторы &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; работают , ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) И &lt;code&gt;unexpected&lt;/code&gt; - три парсера, используемые для генерации сообщений об ошибках. Из них обычно используется только ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ). Пример использования &lt;code&gt;unexpected&lt;/code&gt; см. В определении &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4818ed8827f047325509f05e7e58db632c0a9b1" translate="yes" xml:space="preserve">
          <source>The part before the &amp;ldquo;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;rdquo; is the &lt;em&gt;context&lt;/em&gt;, while the part after the &amp;ldquo;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;rdquo; is the &lt;em&gt;head&lt;/em&gt; of the instance declaration.</source>
          <target state="translated">Часть до &amp;laquo; &lt;code&gt;=&amp;gt;&lt;/code&gt; &amp;raquo; является &lt;em&gt;контекстом&lt;/em&gt; , в то время как часть после &amp;laquo; &lt;code&gt;=&amp;gt;&lt;/code&gt; &amp;raquo; является &lt;em&gt;главой&lt;/em&gt; декларации экземпляра.</target>
        </trans-unit>
        <trans-unit id="8c4af47c225f8bda2b21acfa7343627c8d8e9119" translate="yes" xml:space="preserve">
          <source>The partially filled last buffer together with the result.</source>
          <target state="translated">Частично заполненный последний буфер вместе с результатом.</target>
        </trans-unit>
        <trans-unit id="76555f01f592b0a2cdc627f47763c8dfacb0c6f2" translate="yes" xml:space="preserve">
          <source>The password for this group (gr_passwd)</source>
          <target state="translated">Пароль для этой группы (gr_passwd)</target>
        </trans-unit>
        <trans-unit id="2d3745d1a12b2bebf51e7faab541e80ec1f0a40f" translate="yes" xml:space="preserve">
          <source>The path returned by &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt; name&lt;/code&gt; corresponds to the program that would be executed by &lt;code&gt;&lt;a href=&quot;http://hackage.haskell.org/package/process/docs/System-Process.html#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; when passed the same string (as a &lt;code&gt;RawCommand&lt;/code&gt;, not a &lt;code&gt;ShellCommand&lt;/code&gt;), provided that &lt;code&gt;name&lt;/code&gt; is not a relative path with more than one segment.</source>
          <target state="translated">Путь, возвращаемый &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt; name&lt;/code&gt; , соответствует программе, которая будет выполняться &lt;code&gt;&lt;a href=&quot;http://hackage.haskell.org/package/process/docs/System-Process.html#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; при передаче той же строки (как &lt;code&gt;RawCommand&lt;/code&gt; , а не &lt;code&gt;ShellCommand&lt;/code&gt; ), при условии, что это &lt;code&gt;name&lt;/code&gt; не является относительным путем с более чем одним сегментом.</target>
        </trans-unit>
        <trans-unit id="9dcaa800bf3364bc2f0c84de7ea08da5a42f3563" translate="yes" xml:space="preserve">
          <source>The path to the directory you want to make</source>
          <target state="translated">Путь к каталогу,который вы хотите сделать</target>
        </trans-unit>
        <trans-unit id="1e9c6b10b0fdf62a37b5bb885fce58f3a72f52f0" translate="yes" xml:space="preserve">
          <source>The pattern</source>
          <target state="translated">Образец</target>
        </trans-unit>
        <trans-unit id="80e42327db0e35402f1cf71bace675478feffb85" translate="yes" xml:space="preserve">
          <source>The pattern syntax reflects the term syntax:</source>
          <target state="translated">Синтаксис шаблона отражает термин &quot;синтаксис&quot;:</target>
        </trans-unit>
        <trans-unit id="1c7f40f56c74434aacb6e8837492766e4ad8a9e2" translate="yes" xml:space="preserve">
          <source>The pattern type signature makes the type variable available on the right-hand side of the equation.</source>
          <target state="translated">Сигнатура типа шаблона делает переменную типа доступной с правой стороны уравнения.</target>
        </trans-unit>
        <trans-unit id="64cba4adeb973c40ed7ade97bdcc25e2ee42d42d" translate="yes" xml:space="preserve">
          <source>The peak memory the RTS has allocated from the OS.</source>
          <target state="translated">Пиковая память,выделенная RTS от операционной системы.</target>
        </trans-unit>
        <trans-unit id="22eefa908237bf9e53141f656837f953dc52cd51" translate="yes" xml:space="preserve">
          <source>The percentage of the total memory allocations (excluding profiling overheads) of the program made by this call and all of its sub-calls.</source>
          <target state="translated">Процент от общего объема выделенной памяти (без учета накладных расходов на профилирование)программы при данном вызове и всех ее подзапросах.</target>
        </trans-unit>
        <trans-unit id="65fb5b8744f0d8b0724f16ce7115e8c2ec9bf85b" translate="yes" xml:space="preserve">
          <source>The percentage of the total memory allocations (excluding profiling overheads) of the program made by this call.</source>
          <target state="translated">Процент от общего объема выделенной памяти (без учета накладных расходов на профилирование)программы,выполненной по данному вызову.</target>
        </trans-unit>
        <trans-unit id="068fb517248f218c1fba65bf915d364e543e8fec" translate="yes" xml:space="preserve">
          <source>The percentage of the total run time of the program spent at this point in the call tree.</source>
          <target state="translated">Процент от общего времени работы программы,потраченного на данный момент в дереве вызовов.</target>
        </trans-unit>
        <trans-unit id="7c2cbfcc5414f5b7bbe22870e814c3e36aa5a19a" translate="yes" xml:space="preserve">
          <source>The percentage of the total run time of the program spent below this point in the call tree.</source>
          <target state="translated">Процент от общего времени работы программы,потраченного ниже этой точки в дереве вызовов.</target>
        </trans-unit>
        <trans-unit id="6d1e32ad3dc0bf0fc541838e24bd7ba405c901ce" translate="yes" xml:space="preserve">
          <source>The phase of a complex number, in the range &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt;. If the magnitude is zero, then so is the phase.</source>
          <target state="translated">Фаза комплексного числа в диапазоне &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt; . Если величина равна нулю, то и фаза тоже.</target>
        </trans-unit>
        <trans-unit id="5ec5d9e6ba55f7a9e7cb0eba6a8d8b520103da78" translate="yes" xml:space="preserve">
          <source>The platform specific type for a process identifier.</source>
          <target state="translated">Специфический для платформы тип идентификатора процесса.</target>
        </trans-unit>
        <trans-unit id="05ce8c49af72e9c0812629a99bef4d7bdcd57f07" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Указатель на содержимое массива получается &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; . Идея аналогична &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (здесь используется для внутренних целей). Указатель следует использовать только во время выполнения действия &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; вывода, восстановленного функцией, переданной в качестве аргумента в &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f752177391a2368cd5aff90c60b692550ec7f6f2" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Указатель на содержимое массива получается &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; . Идея аналогична &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (здесь используется для внутренних целей). Указатель следует использовать только во время выполнения действия &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; вывода, восстановленного функцией, переданной в качестве аргумента в &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b20c9f030aa51113089e5842b41d705c082ffe5" translate="yes" xml:space="preserve">
          <source>The polymorphic kind of this type allows it to be used in several settings. For instance, it can be used as a constraint, e.g. to provide a better error message for a non-existent instance,</source>
          <target state="translated">Полиморфный тип этого типа позволяет использовать его в нескольких настройках.Например,его можно использовать в качестве ограничения,например,для получения лучшего сообщения об ошибке для несуществующего экземпляра,</target>
        </trans-unit>
        <trans-unit id="7dd3eeff891b51deab88c6a4902ae766c6f21033" translate="yes" xml:space="preserve">
          <source>The position of a subscript in the subrange.</source>
          <target state="translated">Положение абонента в поддиапазоне.</target>
        </trans-unit>
        <trans-unit id="559ede6970ff4191905ab3f6622d825b5bd8500d" translate="yes" xml:space="preserve">
          <source>The practical implication of this difference is that due to the &lt;em&gt;imprecise exceptions&lt;/em&gt; semantics,</source>
          <target state="translated">Практическое значение этого различия заключается в том, что из-за &lt;em&gt;неточной&lt;/em&gt; семантики &lt;em&gt;исключений&lt;/em&gt; ,</target>
        </trans-unit>
        <trans-unit id="8190358d9c4e04dbcfc369855323f1dc1ed11104" translate="yes" xml:space="preserve">
          <source>The pragma must occur inside the &lt;code&gt;where&lt;/code&gt; part of the instance declaration.</source>
          <target state="translated">Прагма должна находиться внутри части &lt;code&gt;where&lt;/code&gt; объявления экземпляра.</target>
        </trans-unit>
        <trans-unit id="031c8f6ef621f154509b2aed1694bc1a7e8c617f" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;code&gt;OVERLAPPING&lt;/code&gt;, &lt;code&gt;OVERLAPPABLE&lt;/code&gt;, &lt;code&gt;OVERLAPS&lt;/code&gt;, &lt;code&gt;INCOHERENT&lt;/code&gt; are used to specify the overlap behavior for individual instances, as described in Section &lt;a href=&quot;#instance-overlap&quot;&gt;Overlapping instances&lt;/a&gt;. The pragmas are written immediately after the &lt;code&gt;instance&lt;/code&gt; keyword, like this:</source>
          <target state="translated">Прагм &lt;code&gt;OVERLAPPING&lt;/code&gt; , &lt;code&gt;OVERLAPPABLE&lt;/code&gt; , &lt;code&gt;OVERLAPS&lt;/code&gt; , &lt;code&gt;INCOHERENT&lt;/code&gt; используется для определения поведения перекрытия для отдельных случаев, как описан в разделе &lt;a href=&quot;#instance-overlap&quot;&gt;экземпляров перекрывающихся&lt;/a&gt; . Прагмы пишутся сразу после ключевого слова &lt;code&gt;instance&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="80dd1dde937515d8dba7eb30a62ee2aee1dbce22" translate="yes" xml:space="preserve">
          <source>The pre-processor is run just before the Haskell compiler proper processes the Haskell input, but after the literate markup has been stripped away and (possibly) the C pre-processor has washed the Haskell input.</source>
          <target state="translated">Препроцессор запускается непосредственно перед тем,как компилятор Haskell надлежащим образом обработает входные данные Haskell,но после того,как грамотная разметка была удалена и (возможно)препроцессор C промыл входные данные Haskell.</target>
        </trans-unit>
        <trans-unit id="3b0af5d5c36b657cc7d9ed4c1b41c0833ec4e287" translate="yes" xml:space="preserve">
          <source>The precise color scheme is controlled by the environment variable &lt;code&gt;GHC_COLORS&lt;/code&gt; (or &lt;code&gt;GHC_COLOURS&lt;/code&gt;). This can be set to colon-separated list of &lt;code&gt;key=value&lt;/code&gt; pairs. These are the default settings:</source>
          <target state="translated">Точная цветовая схема контролируется переменной окружения &lt;code&gt;GHC_COLORS&lt;/code&gt; (или &lt;code&gt;GHC_COLOURS&lt;/code&gt; ). Это может быть список разделенных двоеточиями пар &lt;code&gt;key=value&lt;/code&gt; . Это настройки по умолчанию:</target>
        </trans-unit>
        <trans-unit id="2fc32854b4e2e98d1d21502bcb28d7b8e12f08ad" translate="yes" xml:space="preserve">
          <source>The precision for Integral types is accomplished by zero-padding. If both precision and zero-pad are given for an Integral field, the zero-pad is ignored.</source>
          <target state="translated">Точность для интегральных типов достигается за счет нулевой накладки.Если для поля Интеграл заданы и точность,и нулевой участок,то нулевой участок игнорируется.</target>
        </trans-unit>
        <trans-unit id="6427936fd3378899feeb71f267643f93c076799f" translate="yes" xml:space="preserve">
          <source>The predicate is assumed to define an equivalence.</source>
          <target state="translated">Предполагается,что предикат определяет эквивалентность.</target>
        </trans-unit>
        <trans-unit id="97c46e75defc42b19335cc4acd7f7b8d23b0ab48" translate="yes" xml:space="preserve">
          <source>The prefix `&lt;code&gt;generic&lt;/code&gt;' indicates an overloaded function that is a generalized version of a &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; function.</source>
          <target state="translated">Префикс &quot; &lt;code&gt;generic&lt;/code&gt; &quot; указывает на перегруженную функцию, которая является обобщенной версией функции &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e5998474098f5954e11b07869ce4b965aab5cd3" translate="yes" xml:space="preserve">
          <source>The preprocessor cannot cope with other Haskell extensions. These would have to go in separate modules.</source>
          <target state="translated">Препроцессор не может справиться с другими расширениями Haskell.Они должны быть в отдельных модулях.</target>
        </trans-unit>
        <trans-unit id="48cdcef6c8bba47873b2657cefbebf9a582e8376" translate="yes" xml:space="preserve">
          <source>The primary difficulty with managing shared libraries is arranging things such that programs can find the libraries they need at runtime. The details of how this works varies between platforms, in particular the three major systems: Unix ELF platforms, Windows and Mac OS X.</source>
          <target state="translated">Основная трудность в управлении разделяемыми библиотеками заключается в том,чтобы организовать так,чтобы программы могли находить нужные им библиотеки во время выполнения.Детали того,как это работает,различны для разных платформ,в частности для трех основных систем:Платформы Unix ELF,Windows и Mac OS X.</target>
        </trans-unit>
        <trans-unit id="1b94ab7b19971d0143cb6a1dc0aaaa9d62aab435" translate="yes" xml:space="preserve">
          <source>The primary source of asynchronous exceptions, however, is &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Однако основным источником асинхронных исключений является &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="db2ba14a4921403cf0313fa72d18649bbc679eef" translate="yes" xml:space="preserve">
          <source>The primitive parser combinators.</source>
          <target state="translated">Примитивные парсерные комбинаторы.</target>
        </trans-unit>
        <trans-unit id="f13d852fb55e7d4ce977dd12fee90d0bc1dc9fe0" translate="yes" xml:space="preserve">
          <source>The primops make extensive use of &lt;a href=&quot;#glasgow-unboxed&quot;&gt;unboxed types&lt;/a&gt; and &lt;a href=&quot;#unboxed-tuples&quot;&gt;unboxed tuples&lt;/a&gt;, which we briefly summarise here.</source>
          <target state="translated">Примопы широко используют &lt;a href=&quot;#glasgow-unboxed&quot;&gt;распакованные типы&lt;/a&gt; и &lt;a href=&quot;#unboxed-tuples&quot;&gt;распакованные кортежи&lt;/a&gt; , которые мы кратко резюмируем здесь.</target>
        </trans-unit>
        <trans-unit id="17617bbcaecd4caffa758995817fc1d0e3af127e" translate="yes" xml:space="preserve">
          <source>The problem here is that this instance would allow one particular choice of &lt;code&gt;[a]&lt;/code&gt; to be associated with more than one choice for &lt;code&gt;b&lt;/code&gt;, which contradicts the dependency specified in the definition of &lt;code&gt;D&lt;/code&gt;. More generally, this means that, in any instance of the form:</source>
          <target state="translated">Проблема здесь заключается в том , что этот случай позволил бы один конкретный выбор &lt;code&gt;[a]&lt;/code&gt; ассоциируется с более чем одним выбором для &lt;code&gt;b&lt;/code&gt; , что противоречит зависимости , указанный в определении &lt;code&gt;D&lt;/code&gt; . В более общем смысле это означает, что в любом экземпляре формы:</target>
        </trans-unit>
        <trans-unit id="e0f5743627f2c13906299b1a7e64c44a8ec050dd" translate="yes" xml:space="preserve">
          <source>The problem is that it is not possible in general to interrupt a foreign call safely. However, GHC does provide a way to interrupt blocking system calls which works for most system calls on both Unix and Windows. When the &lt;code&gt;InterruptibleFFI&lt;/code&gt; extension is enabled, a foreign call can be annotated with &lt;code&gt;interruptible&lt;/code&gt; instead of &lt;code&gt;safe&lt;/code&gt; or &lt;code&gt;unsafe&lt;/code&gt;:</source>
          <target state="translated">Проблема в том, что в целом невозможно безопасно прервать внешний вызов. Однако GHC предоставляет способ прерывания системных вызовов блокировки, который работает для большинства системных вызовов как в Unix, так и в Windows. Когда расширение &lt;code&gt;InterruptibleFFI&lt;/code&gt; включено, внешний вызов может быть аннотирован &lt;code&gt;interruptible&lt;/code&gt; вместо &lt;code&gt;safe&lt;/code&gt; или &lt;code&gt;unsafe&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3d34cc9fd2e90a4c7e190d8e316ee751917d80db" translate="yes" xml:space="preserve">
          <source>The problem with using &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChan&quot;&gt;newTChan&lt;/a&gt;&lt;/code&gt; to create the broadcast channel is that if it is only written to and never read, items will pile up in memory. By using &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChan&quot;&gt;newBroadcastTChan&lt;/a&gt;&lt;/code&gt; to create the broadcast channel, items can be garbage collected after clients have seen them.</source>
          <target state="translated">Проблема с использованием &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChan&quot;&gt;newTChan&lt;/a&gt;&lt;/code&gt; для создания широковещательного канала заключается в том, что если он только записывается и никогда не читается, элементы будут накапливаться в памяти. Используя &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChan&quot;&gt;newBroadcastTChan&lt;/a&gt;&lt;/code&gt; для создания широковещательного канала, элементы могут быть удалены сборщиком мусора после того, как клиенты их увидят.</target>
        </trans-unit>
        <trans-unit id="abc76e2f497ab466ec7ca65dcd335b801b282966" translate="yes" xml:space="preserve">
          <source>The procedure to check if a module is trusted or not depends on if the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is present. The check is similar in both cases with the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag enabling an extra requirement for trustworthy modules to be regarded as trusted.</source>
          <target state="translated">Процедура проверки того, является ли модуль доверенным или нет, зависит от &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; флага -fpackage-trust . Проверка аналогична в обоих случаях с &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; позволяющим дополнительно требовать, чтобы надежные модули считались надежными.</target>
        </trans-unit>
        <trans-unit id="ada084bff7147867e37d2b21221c961521d29596" translate="yes" xml:space="preserve">
          <source>The process has insufficient privileges to perform the operation.</source>
          <target state="translated">У процесса недостаточно привилегий для выполнения операции.</target>
        </trans-unit>
        <trans-unit id="58c80733d659717ab91216ecfc11c90f2165a6c0" translate="yes" xml:space="preserve">
          <source>The process is slightly complicated when the binding is polymorphic. We show the process by means of an example. To keep things simple, we will use the well known &lt;code&gt;map&lt;/code&gt; function:</source>
          <target state="translated">Процесс немного усложняется, если переплет полиморфный. Покажем процесс на примере. Для простоты мы будем использовать известную функцию &lt;code&gt;map&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="355fc82b6533b2538478ddb7b7f9868d90ea5c2a" translate="yes" xml:space="preserve">
          <source>The process signal mask</source>
          <target state="translated">Маска сигнала процесса</target>
        </trans-unit>
        <trans-unit id="505d4ae162b670335f91963acc1d97b4cead190f" translate="yes" xml:space="preserve">
          <source>The profile data itself is described by the &lt;code&gt;profile&lt;/code&gt; field, which contains a tree-like object (which we&amp;rsquo;ll call a &amp;ldquo;cost-centre stack&amp;rdquo; here) with the following properties,</source>
          <target state="translated">Сами данные профиля описываются полем &lt;code&gt;profile&lt;/code&gt; , которое содержит древовидный объект (который мы здесь назовем &amp;laquo;стеком центра затрат&amp;raquo;) со следующими свойствами:</target>
        </trans-unit>
        <trans-unit id="60512792acedb21616d84dd583523fdb5bfdbd7f" translate="yes" xml:space="preserve">
          <source>The profile tree itself</source>
          <target state="translated">Само дерево профилей</target>
        </trans-unit>
        <trans-unit id="73c7e4bcf702d08f9fbe508aab53b3b722fac243" translate="yes" xml:space="preserve">
          <source>The program &lt;strong&gt;hp2ps&lt;/strong&gt; program converts a &lt;code&gt;.hp&lt;/code&gt; file produced by the &lt;code&gt;-h&amp;lt;break-down&amp;gt;&lt;/code&gt; runtime option into a PostScript graph of the heap profile. By convention, the file to be processed by &lt;strong&gt;hp2ps&lt;/strong&gt; has a &lt;code&gt;.hp&lt;/code&gt; extension. The PostScript output is written to &lt;code&gt;&lt;em&gt;file&lt;/em&gt;@.ps&lt;/code&gt;. If &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; is omitted entirely, then the program behaves as a filter.</source>
          <target state="translated">Программа &lt;strong&gt;hp2ps&lt;/strong&gt; преобразует файл &lt;code&gt;.hp&lt;/code&gt; , созданный параметром времени выполнения &lt;code&gt;-h&amp;lt;break-down&amp;gt;&lt;/code&gt; в график PostScript профиля кучи. По соглашению файл, обрабатываемый &lt;strong&gt;hp2ps,&lt;/strong&gt; имеет расширение &lt;code&gt;.hp&lt;/code&gt; . Вывод PostScript записывается в &lt;code&gt;&lt;em&gt;file&lt;/em&gt;@.ps&lt;/code&gt; . Если &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; полностью опущен, программа ведет себя как фильтр.</target>
        </trans-unit>
        <trans-unit id="146c7ee2b2dbd1e6430b6a92386c207342ed1810" translate="yes" xml:space="preserve">
          <source>The program text itself, the C stack, any non-heap data (e.g. data allocated by foreign libraries, and data allocated by the RTS), and &lt;code&gt;mmap()&lt;/code&gt;&amp;lsquo;d memory are not counted in the heap profile.</source>
          <target state="translated">Сам текст программы, стек C, любые данные, не относящиеся к куче (например, данные, выделенные сторонними библиотеками, и данные, выделенные RTS), и память &lt;code&gt;mmap()&lt;/code&gt; 'd не учитываются в профиле кучи.</target>
        </trans-unit>
        <trans-unit id="608f29767e628bc3908a6f9a3b5c8447d29874fc" translate="yes" xml:space="preserve">
          <source>The program's heap is reaching its limit, and the program should take action to reduce the amount of live data it has. Notes:</source>
          <target state="translated">Куча данных программы достигает своего предела,и программа должна принять меры по сокращению объема имеющихся у нее данных в реальном времени.Примечания:</target>
        </trans-unit>
        <trans-unit id="42403ff8e7d02a582ef311693ed3c81d360f6281" translate="yes" xml:space="preserve">
          <source>The programmer can specify rewrite rules as part of the source program (in a pragma). Here is an example:</source>
          <target state="translated">Программист может задавать правила перезаписи как часть исходной программы (в прагме).Приведем пример:</target>
        </trans-unit>
        <trans-unit id="7913df84bb2ae3b02dcb56dbc5ad5cfcbd49b3ac" translate="yes" xml:space="preserve">
          <source>The pseudo-object file &lt;code&gt;A.o-boot&lt;/code&gt; is empty (don&amp;rsquo;t link it!), but it is very useful when using a Makefile, to record when the &lt;code&gt;A.hi-boot&lt;/code&gt; was last brought up to date (see &lt;a href=&quot;#using-make&quot;&gt;Using make&lt;/a&gt;).</source>
          <target state="translated">Файл псевдообъекта &lt;code&gt;A.o-boot&lt;/code&gt; пуст (не связывайте его!), Но он очень полезен при использовании Makefile, чтобы записывать, когда последний раз &lt;code&gt;A.hi-boot&lt;/code&gt; (см. &lt;a href=&quot;#using-make&quot;&gt;Использование make&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="db524ce2791037ca05d5828a71f6846facf22e65" translate="yes" xml:space="preserve">
          <source>The public face of Template Haskell</source>
          <target state="translated">Публичное лицо Шаблона Хаскелла...</target>
        </trans-unit>
        <trans-unit id="23463757868e42fe8367dadcedc764a10dfe3e71" translate="yes" xml:space="preserve">
          <source>The purpose of &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; is to provide a common interface for I/O devices that can read and write data through a buffer. Devices that implement &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; include ordinary files, memory-mapped files, and bytestrings. The underlying device implementing a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; must provide &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Цель &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; - предоставить общий интерфейс для устройств ввода-вывода, которые могут читать и записывать данные через буфер. Устройства, реализующие &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; , включают обычные файлы, файлы с отображением в память и строки байтов. Базовое устройство, реализующее &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; , должно предоставлять &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd5d324fb68ef0a9578edac19d7cc075670db732" translate="yes" xml:space="preserve">
          <source>The purpose of the installed package ID is to detect problems caused by re-installing a package without also recompiling the packages that depend on it. Recompiling dependencies is necessary, because the newly compiled package may have a different ABI (Application Binary Interface) than the previous version, even if both packages were built from the same source code using the same compiler. With installed package IDs, a recompiled package will have a different installed package ID from the previous version, so packages that depended on the previous version are now orphaned - one of their dependencies is not satisfied. Packages that are broken in this way are shown in the &lt;code&gt;ghc-pkg list&lt;/code&gt; output either in red (if possible) or otherwise surrounded by braces. In the following example, we have recompiled and reinstalled the &lt;code&gt;filepath&lt;/code&gt; package, and this has caused various dependencies including &lt;code&gt;Cabal&lt;/code&gt; to break:</source>
          <target state="translated">Идентификатор установленного пакета предназначен для обнаружения проблем, вызванных повторной установкой пакета, без повторной компиляции пакетов, которые от него зависят. Перекомпиляция зависимостей необходима, поскольку вновь скомпилированный пакет может иметь другой ABI (двоичный интерфейс приложения), чем предыдущая версия, даже если оба пакета были собраны из одного и того же исходного кода с использованием одного и того же компилятора. С установленными идентификаторами пакетов повторно скомпилированный пакет будет иметь идентификатор установленного пакета, отличный от идентификатора предыдущей версии, поэтому пакеты, которые зависели от предыдущей версии, теперь являются сиротами - одна из их зависимостей не выполняется. Пакеты, поврежденные таким образом, отображаются в &lt;code&gt;ghc-pkg list&lt;/code&gt; вывод либо красным (если возможно), либо в фигурных скобках. В следующем примере мы перекомпилировали и переустановили пакет &lt;code&gt;filepath&lt;/code&gt; , что привело к нарушению различных зависимостей, включая &lt;code&gt;Cabal&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="61845a19ad288b45ffb2fcd9525a2a7e4ba4eab7" translate="yes" xml:space="preserve">
          <source>The purpose of using builder primitives is to improve the performance of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. These improvements stem from making the two most common steps performed by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; more efficient. We explain these two steps in turn.</source>
          <target state="translated">Цель использования примитивов построителя - повысить производительность &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; s. Эти улучшения связаны с повышением эффективности двух наиболее распространенных шагов, выполняемых &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; . Мы объясним эти два шага по очереди.</target>
        </trans-unit>
        <trans-unit id="457568e28e80e66fe1efa03405736fd1dd831161" translate="yes" xml:space="preserve">
          <source>The quantification in &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s type signature is explicit. For example:</source>
          <target state="translated">Количественная оценка в сигнатуре типа &lt;code&gt;f&lt;/code&gt; является явной. Например:</target>
        </trans-unit>
        <trans-unit id="b2a0aea25ac8727b745c955a5b510d60c52345ef" translate="yes" xml:space="preserve">
          <source>The quoted ⟨string⟩ can be arbitrary, and may contain newlines.</source>
          <target state="translated">Цитируемый сайт ⟨string⟩ может быть произвольным и содержать новые строки.</target>
        </trans-unit>
        <trans-unit id="349650fae25bef4c0203cca3a1569d66bff63fe6" translate="yes" xml:space="preserve">
          <source>The quoted ⟨string⟩ finishes at the first occurrence of the two-character sequence &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. Absolutely no escaping is performed. If you want to embed that character sequence in the string, you must invent your own escape convention (such as, say, using the string &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; instead), and make your quoter function interpret &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; as &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. One way to implement this is to compose your quoter with a pre-processing pass to perform your escape conversion. See the discussion in &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;Issue #5348&lt;/a&gt; for details.</source>
          <target state="translated">&amp;laquo;Строка&amp;raquo; в кавычках заканчивается при первом появлении двухсимвольной последовательности &lt;code&gt;&quot;|]&quot;&lt;/code&gt; . Абсолютно никакого побега не происходит. Если вы хотите встроить эту последовательность символов в строку, вы должны изобрести собственное соглашение об экранировании (например, использовать вместо нее строку &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; ) и заставить вашу функцию кавычек интерпретировать &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; как &lt;code&gt;&quot;|]&quot;&lt;/code&gt; . Один из способов реализовать это - составить кавычку с проходом предварительной обработки для выполнения escape-преобразования. Подробнее см. Обсуждение в &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;выпуске №5348&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="767b19d5997c1561a35b16bb492c27dcece0b46f" translate="yes" xml:space="preserve">
          <source>The rationale for this more conservative strategy is given in &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;the papers&lt;/a&gt; &amp;ldquo;Let should not be generalised&amp;rdquo; and &amp;ldquo;Modular type inference with local assumptions&amp;rdquo;, and a related &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">Обоснование этой более консервативной стратегии дается в &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;статьях&lt;/a&gt; &amp;laquo;Пусть не следует обобщать&amp;raquo; и &amp;laquo;Вывод модульного типа с локальными допущениями&amp;raquo;, а также в соответствующем &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7&quot;&gt;сообщении в блоге&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="849e06109e6633ff65fca6836e32e867a5ee49f7" translate="yes" xml:space="preserve">
          <source>The raw number of time &amp;ldquo;ticks&amp;rdquo; which were attributed to this cost-centre; from this, we get the &lt;code&gt;%time&lt;/code&gt; figure mentioned above.</source>
          <target state="translated">Необработанное количество временных &amp;laquo;отметок&amp;raquo;, которые были отнесены к этому МВЗ; отсюда мы получаем указанное выше значение &lt;code&gt;%time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="075d071c18a7d6b84d43703f15e6485084ed0703" translate="yes" xml:space="preserve">
          <source>The reader monad transformer, which adds a read-only environment to the given monad.</source>
          <target state="translated">Трансформатор считывающего устройства monad,который добавляет к данной монаде среду,доступную только для чтения.</target>
        </trans-unit>
        <trans-unit id="ecd219a50b8d392987e91be61182f89babccea17" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;gdb&lt;/code&gt; doesn&amp;rsquo;t show this symbol name in the backtrace output is an infidelity in its interpretation of debug information, which assumes an invariant preserved in C but not Haskell programs. Unfortunately it is necessary to work around this manually until this behivior is fixed upstream.</source>
          <target state="translated">Причина, по которой &lt;code&gt;gdb&lt;/code&gt; не показывает это имя символа в выходных данных обратной трассировки, заключается в неверной интерпретации отладочной информации, которая предполагает, что инвариант сохраняется в программах на C, но не в программах на Haskell. К сожалению, это необходимо обойти вручную, пока это поведение не будет исправлено в апстриме.</target>
        </trans-unit>
        <trans-unit id="2b6817263ed46c0c59f4fb0e7df2a91e7de71d71" translate="yes" xml:space="preserve">
          <source>The reason for the latter restriction is that there is no way to check for instance matching. Consider</source>
          <target state="translated">Причина последнего ограничения заключается в том,что нет возможности проверить,например,соответствие.Рассмотрим сайт .</target>
        </trans-unit>
        <trans-unit id="3292261ccecbbe56c864dbca83a9f104595c5227" translate="yes" xml:space="preserve">
          <source>The reason the call to &lt;code&gt;mergeQs&lt;/code&gt; is lazy is that it will be bottom for the last element in the queue, preventing us from evaluating the fully sorted sequence.</source>
          <target state="translated">Причина, по которой вызов &lt;code&gt;mergeQs&lt;/code&gt; является ленивым, заключается в том, что он будет нижним для последнего элемента в очереди, что не позволяет нам оценить полностью отсортированную последовательность.</target>
        </trans-unit>
        <trans-unit id="edf4240fa18eff64428292cd48a993b1b77fd9cc" translate="yes" xml:space="preserve">
          <source>The reason there are two modes of checking trust is that the extra requirement enabled by &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; causes the design of Safe Haskell to be invasive. Packages using Safe Haskell when the flag is enabled may or may not compile depending on the state of trusted packages on a user&amp;rsquo;s machine. This is both fragile, and causes compilation failures for everyone, even if they aren&amp;rsquo;t trying to use any of the guarantees provided by Safe Haskell. Disabling &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; by default and turning it into a flag makes Safe Haskell an opt-in extension rather than an always on feature.</source>
          <target state="translated">Причина, по которой существует два режима проверки доверия, заключается в том, что дополнительное требование, включенное &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; ,&lt;/a&gt; делает дизайн Safe Haskell инвазивным. Пакеты, использующие Safe Haskell при включенном флаге, могут или не могут компилироваться в зависимости от состояния доверенных пакетов на машине пользователя. Это и хрупко, и вызывает сбои компиляции у всех, даже если они не пытаются использовать какие-либо гарантии, предоставляемые Safe Haskell. Отключение &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; по умолчанию и превращение его в флаг делает Safe Haskell дополнительным расширением, а не постоянно включенной функцией.</target>
        </trans-unit>
        <trans-unit id="159c99e34aff08a973c8421fe23cb3b0d5c07141" translate="yes" xml:space="preserve">
          <source>The rebindable operators must have the &amp;ldquo;Expected type&amp;rdquo; given in the table above. These types are surprisingly general. For example, you can use a bind operator with the type</source>
          <target state="translated">Операторы с возможностью повторной привязки должны иметь &amp;laquo;Ожидаемый тип&amp;raquo;, указанный в таблице выше. Эти типы на удивление универсальны. Например, вы можете использовать оператор привязки с типом</target>
        </trans-unit>
        <trans-unit id="109e20de090fa1c1b399a775d6b526e390949383" translate="yes" xml:space="preserve">
          <source>The recomended way to assemble ByteStrings from smaller parts is to use the builder monoid from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;.</source>
          <target state="translated">Рекомендуемый способ сборки ByteString из более мелких частей - использовать моноид построителя из &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b4b03fcea2b02b1be1981e46342fb710629897c" translate="yes" xml:space="preserve">
          <source>The recomended way to assemble lazy ByteStrings from smaller parts is to use the builder monoid from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;.</source>
          <target state="translated">Рекомендуемый способ собрать ленивые ByteString из более мелких частей - использовать моноид построителя из &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="971c0f87b4ec7b2e7c3c7a4e19d1ae863981807b" translate="yes" xml:space="preserve">
          <source>The recommended chunk size. Currently set to 4k, less the memory management overhead</source>
          <target state="translated">Рекомендуемый размер куска.В настоящее время установлен на 4k,за вычетом накладных расходов на управление памятью.</target>
        </trans-unit>
        <trans-unit id="16cfd92a1589e5e42d0809eabdbac78c22e8ab8a" translate="yes" xml:space="preserve">
          <source>The record field &lt;code&gt;f&lt;/code&gt; is in scope somehow (either qualified or unqualified).</source>
          <target state="translated">Поле записи &lt;code&gt;f&lt;/code&gt; каким-то образом попадает в область видимости (либо квалифицировано, либо неквалифицировано).</target>
        </trans-unit>
        <trans-unit id="9f86b5036b23f14de358102557f9b2feb9bc01db" translate="yes" xml:space="preserve">
          <source>The recursive use of &lt;code&gt;T&lt;/code&gt; forced the second argument to have kind &lt;code&gt;Type&lt;/code&gt;. However, just as in type inference, you can achieve polymorphic recursion by giving a &lt;em&gt;complete user-supplied kind signature&lt;/em&gt; (or CUSK) for &lt;code&gt;T&lt;/code&gt;. A CUSK is present when all argument kinds and the result kind are known, without any need for inference. For example:</source>
          <target state="translated">Рекурсивное использование &lt;code&gt;T&lt;/code&gt; заставило второй аргумент иметь вид &lt;code&gt;Type&lt;/code&gt; . Однако, как и при выводе типов, вы можете добиться полиморфной рекурсии, задав для &lt;code&gt;T&lt;/code&gt; &lt;em&gt;полную подпись типа&lt;/em&gt; (или CUSK), предоставленную пользователем . CUSK присутствует, когда известны все виды аргументов и вид результата, без необходимости вывода. Например:</target>
        </trans-unit>
        <trans-unit id="1d0b6b616ac33870a76db9dfeee72d989646c528" translate="yes" xml:space="preserve">
          <source>The references must be created on the caller process.</source>
          <target state="translated">Ссылки должны быть созданы на вызывающем процессе.</target>
        </trans-unit>
        <trans-unit id="cd1d9b57d9e1f2da5f01c8a0b23b6bcae81f914b" translate="yes" xml:space="preserve">
          <source>The related &lt;a href=&quot;http://en.wikipedia.org/wiki/Find_first_set&quot;&gt;find-first-set operation&lt;/a&gt; can be expressed in terms of &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; as follows</source>
          <target state="translated">Связанная &lt;a href=&quot;http://en.wikipedia.org/wiki/Find_first_set&quot;&gt;операция find-first-set&lt;/a&gt; может быть выражена в терминах &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; следующим образом</target>
        </trans-unit>
        <trans-unit id="564781d2dff109b716b0d2471e109284c4e81426" translate="yes" xml:space="preserve">
          <source>The rendering mode.</source>
          <target state="translated">Режим рендеринга.</target>
        </trans-unit>
        <trans-unit id="7132980ad9037a15d16a77f68d4d766cf683fbea" translate="yes" xml:space="preserve">
          <source>The representation &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; is ever so slightly different from &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt;. Let us look at &lt;code&gt;Tree&lt;/code&gt; as an example again:</source>
          <target state="translated">Представление &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; немного отличается от &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; . Давайте снова посмотрим на &lt;code&gt;Tree&lt;/code&gt; в качестве примера:</target>
        </trans-unit>
        <trans-unit id="80113248ad71c5d6cf6ea8aa34e9ecf1815e1b9b" translate="yes" xml:space="preserve">
          <source>The representation of Typ is held abstract, permitting implementations to use a fancy representation (e.g., hash-consing to manage sharing). Without view patterns, using this signature is a little inconvenient:</source>
          <target state="translated">Представление типа имеет абстрактный характер,позволяя реализациям использовать фантастическое представление (например,хэш-консалтинг для управления совместным использованием).Без шаблонов представления использование этой подписи немного неудобно:</target>
        </trans-unit>
        <trans-unit id="ce09571bea4175cf0b61d56e33f52dd06fcf9579" translate="yes" xml:space="preserve">
          <source>The representation of a newline in the external file or stream.</source>
          <target state="translated">Представление новой строки во внешнем файле или потоке.</target>
        </trans-unit>
        <trans-unit id="7b7630e352dcb7bfcd09fc6c495339d580d997c4" translate="yes" xml:space="preserve">
          <source>The representation produced by GHC for conjuring up the kind of a &lt;code&gt;&lt;a href=&quot;data-typeable#v:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Представление, созданное GHC для создания типа &lt;code&gt;&lt;a href=&quot;data-typeable#v:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa5cd6402de01324e41f0be34f809686f8aa3e73" translate="yes" xml:space="preserve">
          <source>The representation reuses &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; (and thereby &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;) as well as &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt;. (This reusability is the reason that we carry around the dummy type argument for kind-&lt;code&gt;*&lt;/code&gt;-types, but there are already enough different names involved without duplicating each of these.)</source>
          <target state="translated">В представлении повторно используются &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; (и, следовательно, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; ), а также &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; из &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; . (Эта возможность повторного использования является причиной того, что мы переносим аргумент фиктивного типа для kind- &lt;code&gt;*&lt;/code&gt; -типов , но уже задействовано достаточно разных имен без дублирования каждого из них.)</target>
        </trans-unit>
        <trans-unit id="6718f5e7eb98e2ba45cb31a79fe17fb174159077" translate="yes" xml:space="preserve">
          <source>The representation used by this module is suitable for high performance use and for streaming large quantities of data. It provides a means to manipulate a large body of text without requiring that the entire content be resident in memory.</source>
          <target state="translated">Представление,используемое этим модулем,подходит для высокопроизводительного использования и для потоковой передачи больших объемов данных.Он предоставляет возможность манипулировать большим объемом текста,не требуя,чтобы весь контент был заселен в памяти.</target>
        </trans-unit>
        <trans-unit id="26b7e0bcafa80352886c3f224d6fc81197b8c13d" translate="yes" xml:space="preserve">
          <source>The representations of the types &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;, and the function &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#v:mkTyCon&quot;&gt;mkTyCon&lt;/a&gt;&lt;/code&gt; which is used by derived instances of &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; to construct &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">Представления типов &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; , а также функции &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#v:mkTyCon&quot;&gt;mkTyCon&lt;/a&gt;&lt;/code&gt; , которая используется производными экземплярами &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; для создания &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="dfb69b0bd4ce1104852d70ba458a8bfd36b537ab" translate="yes" xml:space="preserve">
          <source>The rescheduling timer runs on a 20ms granularity by default, but this may be altered using the &lt;code&gt;-i&amp;lt;n&amp;gt;&lt;/code&gt; RTS option. After a rescheduling &quot;tick&quot; the running thread is pre-empted as soon as possible.</source>
          <target state="translated">По умолчанию таймер перепланирования работает с шагом 20 мс, но это можно изменить с помощью параметра &lt;code&gt;-i&amp;lt;n&amp;gt;&lt;/code&gt; RTS. После установки &amp;laquo;галочки&amp;raquo; перепланирования выполняющийся поток как можно скорее прерывается.</target>
        </trans-unit>
        <trans-unit id="5ccf3c631aa004c7a4328462d6c6f7c7c056c904" translate="yes" xml:space="preserve">
          <source>The resolution of &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;getCurrentTime&lt;/code&gt;, &lt;code&gt;getPOSIXTime&lt;/code&gt;</source>
          <target state="translated">Разрешение &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;getCurrentTime&lt;/code&gt; , &lt;code&gt;getPOSIXTime&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="25a55460c2a715b4f949aab992e6307c6595c7ef" translate="yes" xml:space="preserve">
          <source>The rest of this section gives further details about GADT-style data type declarations.</source>
          <target state="translated">Остальная часть этого раздела содержит более подробную информацию об объявлениях типов данных в стиле GADT.</target>
        </trans-unit>
        <trans-unit id="19d3d68095be8adb122dbb0abbee590b0795bdfa" translate="yes" xml:space="preserve">
          <source>The rest of this section outlines the extensions to GHC that support GADTs. The extension is enabled with &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt; extension also sets &lt;a href=&quot;#extension-GADTSyntax&quot;&gt;&lt;code&gt;GADTSyntax&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В остальной части этого раздела описаны расширения GHC, поддерживающие GADT. Расширение включено с помощью &lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt; расширение также устанавливает &lt;a href=&quot;#extension-GADTSyntax&quot;&gt; &lt;code&gt;GADTSyntax&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fc3cff348af6d0057b280081d4e52f199855d1b" translate="yes" xml:space="preserve">
          <source>The restrictions on functional dependencies (&lt;a href=&quot;#functional-dependencies&quot;&gt;Functional dependencies&lt;/a&gt;) are particularly troublesome. It is tempting to introduce type variables in the context that do not appear in the head, something that is excluded by the normal rules. For example:</source>
          <target state="translated">Ограничения на функциональные зависимости ( &lt;a href=&quot;#functional-dependencies&quot;&gt;функциональные зависимости&lt;/a&gt; ) вызывают особые хлопоты. Заманчиво ввести в контекст переменные типа, которые не появляются в голове, что исключается обычными правилами. Например:</target>
        </trans-unit>
        <trans-unit id="fe30b8393929aa46afe3ba1601056b94f8b1e95e" translate="yes" xml:space="preserve">
          <source>The result expression of the comprehension is the &lt;em&gt;last&lt;/em&gt; of the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt;s, and should be a &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Выражение результата понимания является &lt;em&gt;последним&lt;/em&gt; из &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt; и должно быть &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e162d7d3e549dfb287c4d837722595657b805b3e" translate="yes" xml:space="preserve">
          <source>The result expression of the comprehension is the &lt;em&gt;last&lt;/em&gt; of the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt;s, and should be a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Выражение результата понимания является &lt;em&gt;последним&lt;/em&gt; из &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt; и должно быть &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="710e76d5addaf1f899275d53172aecc9354da03d" translate="yes" xml:space="preserve">
          <source>The result is that a hole or a variable will behave like &lt;code&gt;undefined&lt;/code&gt;, but with the added benefits that it shows a warning at compile time, and will show the same message if it gets evaluated at runtime. This behaviour follows that of the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; option, which implies &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt;.</source>
          <target state="translated">В результате дыра или переменная будут вести себя как &lt;code&gt;undefined&lt;/code&gt; , но с дополнительными преимуществами, заключающимися в том, что они показывают предупреждение во время компиляции и то же самое сообщение, если оно оценивается во время выполнения. Это поведение соответствует параметру &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt; , который подразумевает &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; . См. Раздел &amp;laquo; &lt;a href=&quot;#defer-type-errors&quot;&gt;Отложить ошибки типа на время выполнения&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f91260437a64c0bf7ba3f383cbdaa028dbaaf14c" translate="yes" xml:space="preserve">
          <source>The result kind annotation is optional and defaults to &lt;code&gt;Type&lt;/code&gt; (like argument kinds) if omitted. Polykinded type families can be declared using a parameter in the kind annotation:</source>
          <target state="translated">Аннотация типа результата является необязательной и по умолчанию имеет значение &lt;code&gt;Type&lt;/code&gt; (как и типы аргументов), если не указано. Семейства многоязычных типов можно объявить с помощью параметра в аннотации вида:</target>
        </trans-unit>
        <trans-unit id="719264555b0951fe0a4d18be61f0d63372d62021" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">Результатом &lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; является синтаксически правильное выражение Haskell, содержащее только константы, с учетом деклараций fixity, действующих в точке, где объявлен тип. Он содержит только имена конструкторов, определенные в типе данных, круглых скобках и пробелах. При использовании помеченных полей конструктора также используются фигурные скобки, запятые, имена полей и знаки равенства.</target>
        </trans-unit>
        <trans-unit id="e395cc90b3823d714718102043b3b6ff7d03845d" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">Результатом &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; является синтаксически правильное выражение Haskell, содержащее только константы, с учетом деклараций fixity, действующих в точке, где объявлен тип. Он содержит только имена конструкторов, определенные в типе данных, круглых скобках и пробелах. При использовании помеченных полей конструктора также используются фигурные скобки, запятые, имена полей и знаки равенства.</target>
        </trans-unit>
        <trans-unit id="e710dfc2405f9e2c8e759d75351536fb10cbd249" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">Результатом &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; является синтаксически правильное выражение Haskell, содержащее только константы, с учетом деклараций fixity, действующих в точке, где объявлен тип. Он содержит только имена конструкторов, определенные в типе данных, круглых скобках и пробелах. При использовании помеченных полей конструктора также используются фигурные скобки, запятые, имена полей и знаки равенства.</target>
        </trans-unit>
        <trans-unit id="94b285ade7413e35c67b8f133c21227a5def2f92" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; as the final continuation.</source>
          <target state="translated">Результат выполнения вычисления CPS с &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; в качестве окончательного продолжения.</target>
        </trans-unit>
        <trans-unit id="2b871831fa284400865f590f83f36a493f64dd34" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with a given final continuation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">Результат выполнения вычисления CPS с заданным окончательным продолжением. (Обратное &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6d14e5fbfa50ec1c145f7227bc08876962cef6e2" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with a given final continuation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">Результат выполнения вычисления CPS с заданным окончательным продолжением. (Обратное &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="fc8678bffd077c0bbb42fb756db0c09316a348b9" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with the identity as the final continuation.</source>
          <target state="translated">Результат выполнения вычисления CPS с идентификатором в качестве конечного продолжения.</target>
        </trans-unit>
        <trans-unit id="7be0d32b03742647a7734d3d21c2b8a2fbadd5ac" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature &quot;ﬓ&quot; (men now, U+FB13) is case folded to the sequence &quot;մ&quot; (men, U+0574) followed by &quot;ն&quot; (now, U+0576), while the Greek &quot;&amp;micro;&quot; (micro sign, U+00B5) is case folded to &quot;&amp;mu;&quot; (small letter mu, U+03BC) instead of itself.</source>
          <target state="translated">Строка результата может быть длиннее, чем строка ввода, и может отличаться от применения &lt;code&gt;&lt;a href=&quot;data-text#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; к строке ввода. Например, армянская малая лигатура &amp;laquo;&amp;raquo; (сейчас мужчины, U + FB13) складывается в регистр в последовательность &amp;laquo;մ&amp;raquo; (мужчины, U + 0574), за которой следует &amp;laquo;ն&amp;raquo; (теперь U + 0576), а греческая &amp;laquo;&amp;micro;&amp;raquo; (микро-знак, U + 00B5) заменяется регистром на &amp;laquo;&amp;mu;&amp;raquo; (строчная буква &amp;laquo;мю&amp;raquo;, U + 03BC).</target>
        </trans-unit>
        <trans-unit id="f1f067d31c498d308c7527edc24e5abe084a8aef" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature men now (U+FB13) is case folded to the bigram men now (U+0574 U+0576), while the micro sign (U+00B5) is case folded to the Greek small letter letter mu (U+03BC) instead of itself.</source>
          <target state="translated">Строка результата может быть длиннее, чем строка ввода, и может отличаться от применения &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; к строке ввода. Например, армянские маленькие лигатуры человечков (U + FB13) теперь сложены в регистр до биграмм (U + 0574 U + 0576), а микрознак (U + 00B5) - это заглавные буквы в греческой строчной букве мю. (U + 03BC) вместо себя.</target>
        </trans-unit>
        <trans-unit id="b57c640dd113a5ef9f93ec6e9fa6c4901f3490dd" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature men now (U+FB13) is case folded to the bigram men now (U+0574 U+0576), while the micro sign (U+00B5) is case folded to the Greek small letter letter mu (U+03BC) instead of itself.</source>
          <target state="translated">Строка результата может быть длиннее, чем строка ввода, и может отличаться от применения &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; к строке ввода. Например, армянские маленькие лигатуры человечков (U + FB13) теперь сложены в регистр до биграмм (U + 0574 U + 0576), а микрознак (U + 00B5) - это заглавные буквы в греческой строчной букве мю. (U + 03BC) вместо себя.</target>
        </trans-unit>
        <trans-unit id="d7d1ee7a53d61c5066bf7c6b99507274cf414cc2" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For example, the Latin small ligature ﬂ (U+FB02) is converted to the sequence Latin capital letter F (U+0046) followed by Latin small letter l (U+006C).</source>
          <target state="translated">Строка результата может быть длиннее строки ввода.Например,маленькая латинская лигатура ﬂ (U+FB02)преобразуется в последовательность латинской прописной буквы F (U+0046),за которой следует маленькая латинская буква l (U+006C).</target>
        </trans-unit>
        <trans-unit id="cb6d1fe8a7f7ce6500d2e6aeea87ffd462ba9559" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, &quot;İ&quot; (Latin capital letter I with dot above, U+0130) maps to the sequence &quot;i&quot; (Latin small letter i, U+0069) followed by &quot; ̇&quot; (combining dot above, U+0307).</source>
          <target state="translated">Строка результата может быть длиннее строки ввода.Например,&quot;İ&quot; (латинская большая буква I с точкой выше,U+0130)карты с последовательностью &quot;i&quot; (латинская маленькая буква i,U+0069),за которой следует &quot; ̇&quot;.(комбинация точек выше,U+0307).</target>
        </trans-unit>
        <trans-unit id="59d5af9a9e862a6261e0531052f3b7332bd96132" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the German &quot;&amp;szlig;&quot; (eszett, U+00DF) maps to the two-letter sequence &quot;SS&quot;.</source>
          <target state="translated">Строка результата может быть длиннее, чем строка ввода. Например, немецкое &amp;laquo;&amp;szlig;&amp;raquo; (eszett, U + 00DF) соответствует двухбуквенной последовательности &amp;laquo;SS&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="187c0a7ad1ec133af85262cf2aefbee65363c294" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the German eszett (U+00DF) maps to the two-letter sequence SS.</source>
          <target state="translated">Строка результата может быть длиннее строки ввода.Например,немецкий eszett (U+00DF)сопоставляет двухбуквенную последовательность SS.</target>
        </trans-unit>
        <trans-unit id="3bcb0ada5949116a1ec956043ccada7f764943ad" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the Latin capital letter I with dot above (U+0130) maps to the sequence Latin small letter i (U+0069) followed by combining dot above (U+0307).</source>
          <target state="translated">Строка результата может быть длиннее строки ввода.Например,латинская заглавная буква I с точкой выше (U+0130)сопоставляет последовательность латинской строчной буквы i (U+0069)с последующим объединением точки выше (U+0307).</target>
        </trans-unit>
        <trans-unit id="267f91be8361e6b486bf16241ee4a2ca1c72d153" translate="yes" xml:space="preserve">
          <source>The result type is an instance of &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">Тип результата - это экземпляр &lt;code&gt;Show&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff72841077011df112090a92ab49b6f760730161" translate="yes" xml:space="preserve">
          <source>The result type is not &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">Тип результата - не &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bd69cf03243d72a4d327360fffc77c84f470ae1" translate="yes" xml:space="preserve">
          <source>The result type must also be unambiguous. Usually this can be inferred but when all the pattern synonyms in a group are polymorphic in the constructor the user must provide a type signature.</source>
          <target state="translated">Тип результата также должен быть однозначным.Обычно это можно вывести,но когда все синонимы шаблонов в группе полиморфны в конструкторе,пользователь должен предоставить сигнатуру типа.</target>
        </trans-unit>
        <trans-unit id="e51fdef8c98fee655b68c4b681ce174c3c7038dc" translate="yes" xml:space="preserve">
          <source>The result type of each data constructor must begin with the type constructor being defined. If the result type of all constructors has the form &lt;code&gt;T a1 ... an&lt;/code&gt;, where &lt;code&gt;a1 ... an&lt;/code&gt; are distinct type variables, then the data type is &lt;em&gt;ordinary&lt;/em&gt;; otherwise is a &lt;em&gt;generalised&lt;/em&gt; data type (&lt;a href=&quot;#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt;).</source>
          <target state="translated">Тип результата каждого конструктора данных должен начинаться с определяемого конструктора типа. Если тип результата всех конструкторов имеет вид &lt;code&gt;T a1 ... an&lt;/code&gt; , где &lt;code&gt;a1 ... an&lt;/code&gt; - переменные различных типов, то тип данных является &lt;em&gt;обычным&lt;/em&gt; ; в противном случае - это &lt;em&gt;обобщенный&lt;/em&gt; тип данных ( &lt;a href=&quot;#gadt&quot;&gt;обобщенные алгебраические типы данных (GADT)&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d7542961c89b6c461de16b24fa92766645c70980" translate="yes" xml:space="preserve">
          <source>The result will be a (possibly) recursive set of bindings, binding only simple variables on the left hand side. (One could go one step further, as in the Haskell Report and make the recursive bindings non-recursive using &lt;code&gt;fix&lt;/code&gt;, but we do not do so in Core, and it only obfuscates matters, so we do not do so here.)</source>
          <target state="translated">Результатом будет (возможно) рекурсивный набор привязок, связывающий только простые переменные с левой стороны. (Можно было бы пойти еще дальше, как в отчете Haskell, и сделать рекурсивные привязки нерекурсивными с помощью &lt;code&gt;fix&lt;/code&gt; , но мы этого не делаем в Core, и это только запутывает ситуацию, поэтому мы не делаем этого здесь.)</target>
        </trans-unit>
        <trans-unit id="87462ec88b42724161b7cc8f2f63b59ae8384ebd" translate="yes" xml:space="preserve">
          <source>The resulting block is not known to the GC until &lt;code&gt;compactFixupPointers#&lt;/code&gt; is called on it, and care must be taken so that the address does not escape or memory will be leaked.</source>
          <target state="translated">Результирующий блок не известен &lt;code&gt;compactFixupPointers#&lt;/code&gt; до тех пор, пока для него не будет вызван compactFixupPointers # , и необходимо позаботиться о том, чтобы адрес не ускользнул, иначе произойдет утечка памяти.</target>
        </trans-unit>
        <trans-unit id="44b0b01d6fc72a9ebc6e569ea7b7a4acf9c3f0f1" translate="yes" xml:space="preserve">
          <source>The return codes and possible failures are the same as for &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Коды возврата и возможные сбои такие же, как для &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d168a5662d111348c5652178bf35438b7d7e5d7d" translate="yes" xml:space="preserve">
          <source>The return codes and possible failures are the same as for &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Коды возврата и возможные сбои такие же, как для &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c84126d5da79081acd0696fd7bf7e6755dd26714" translate="yes" xml:space="preserve">
          <source>The return value is either &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a)&lt;/code&gt; (which should be &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; ())&lt;/code&gt;, but Haskell's type system makes this hard).</source>
          <target state="translated">Возвращаемое значение - либо &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , либо &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a)&lt;/code&gt; (которое должно быть &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; ())&lt;/code&gt; , но система типов Haskell усложняет эту задачу).</target>
        </trans-unit>
        <trans-unit id="0f6dd3e83915d6810f63269b6047123bac8e9627" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;ghc-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; depends on when the garbage collector runs, hence it is in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;&lt;a href=&quot;ghc-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; зависит от того, когда запускается сборщик мусора, следовательно, он находится в монаде &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de3f75faf8980c76bf0430052903fea92d219a50" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; depends on when the garbage collector runs, hence it is in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; зависит от того, когда запускается сборщик мусора, следовательно, он находится в монаде &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5bb2aac698e0ab4acfe10c33904a9c6ea7a4ffd" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; may return a different &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; after an object is evaluated.</source>
          <target state="translated">Обратное не всегда верно: если два стабильных имени не равны, то объекты, которые они называют, могут быть одинаковыми. Обратите внимание, в частности, что &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; может возвращать другое &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; после оценки объекта.</target>
        </trans-unit>
        <trans-unit id="5277d01d4cf93639a960e6c2b422210d104ab497" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; may return a different &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; after an object is evaluated.</source>
          <target state="translated">Обратное не всегда верно: если два стабильных имени не равны, то объекты, которые они называют, могут быть одинаковыми. Обратите внимание, в частности, что &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; может возвращать другое &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; после оценки объекта.</target>
        </trans-unit>
        <trans-unit id="9ee861d7191d03480270623b0c278f3e796515d5" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;code&gt;&lt;a href=&quot;control-monad#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Реверсе , &lt;code&gt;&lt;a href=&quot;control-monad#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="090562c4f4dc69d8f3d635e5732725c84ce56598" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Реверсе , &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de4201a99f5e0cf83a88c84b37a22d265b4759a2" translate="yes" xml:space="preserve">
          <source>The rewrite is only performed by the compiler when it spots applications of &lt;code&gt;Control.Exception.assert&lt;/code&gt;, so you can still define and use your own versions of &lt;code&gt;assert&lt;/code&gt;, should you so wish. If not, import &lt;code&gt;Control.Exception&lt;/code&gt; to make use &lt;code&gt;assert&lt;/code&gt; in your code.</source>
          <target state="translated">Перезапись выполняется только компилятором, когда он обнаруживает приложения &lt;code&gt;Control.Exception.assert&lt;/code&gt; , поэтому вы все равно можете определять и использовать свои собственные версии &lt;code&gt;assert&lt;/code&gt; , если хотите. Если нет, импортируйте &lt;code&gt;Control.Exception&lt;/code&gt; , чтобы использовать &lt;code&gt;assert&lt;/code&gt; в своем коде.</target>
        </trans-unit>
        <trans-unit id="a203db3467cf5555838881627c38d194d3093046" translate="yes" xml:space="preserve">
          <source>The rule for record update is this:</source>
          <target state="translated">Правило обновления записей таково:</target>
        </trans-unit>
        <trans-unit id="c2a3d9f840c6b0b6b05ca67275951ae59e8720e2" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; to force or handle exceptions in lazy values. If, on the other hand, you are forcing a lazy value for efficiency reasons only and do not care about exceptions, you may use &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;.</source>
          <target state="translated">Эмпирическое правило состоит в том, чтобы использовать &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; для принудительной обработки или обработки исключений в отложенных значениях. Если, с другой стороны, вы используете ленивое значение только из соображений эффективности и не заботитесь об исключениях, вы можете использовать &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d29e4936cf91ded40f7b191a687c4dd53e33e0f9" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; to force or handle exceptions in lazy values. If, on the other hand, you are forcing a lazy value for efficiency reasons only and do not care about exceptions, you may use &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;.</source>
          <target state="translated">Эмпирическое правило состоит в том, чтобы использовать &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; для принудительной обработки или обработки исключений в отложенных значениях. Если, с другой стороны, вы используете ленивое значение только из соображений эффективности и не заботитесь об исключениях, вы можете использовать &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c31b88d72206b36249f66b725cc9bbead67a01dc" translate="yes" xml:space="preserve">
          <source>The rules are these:</source>
          <target state="translated">Правила такие:</target>
        </trans-unit>
        <trans-unit id="cad458489bec4a53c044a1cc9e76951b0e492b13" translate="yes" xml:space="preserve">
          <source>The rules for export lists (Haskell Report &lt;a href=&quot;http://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;Section 5.2&lt;/a&gt;) needs adjustment for type families:</source>
          <target state="translated">Правила для списков экспорта (Отчет Haskell, &lt;a href=&quot;http://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;раздел 5.2&lt;/a&gt; ) нуждаются в корректировке для семейств типов:</target>
        </trans-unit>
        <trans-unit id="e971c3e68673f355040db3c25b4189ad831663fc" translate="yes" xml:space="preserve">
          <source>The rules for lexically-scoped type variables (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;) apply to pattern-synonym signatures. As those rules specify, only the type variables from an explicit, syntactically-visible outer &lt;code&gt;forall&lt;/code&gt; (the universals) scope over the definition of the pattern synonym; the existentials, bound by the inner forall, do not. For example</source>
          <target state="translated">Правила для переменных типа с лексической областью видимости (см. Переменные типа с &lt;a href=&quot;#scoped-type-variables&quot;&gt;лексической областью видимости&lt;/a&gt; ) применяются к сигнатурам синонимов шаблонов. Как указано в этих правилах, только переменные типа из явной, синтаксически видимой внешней области &lt;code&gt;forall&lt;/code&gt; (универсалий) над определением синонима шаблона; экзистенциальные личности, связанные внутренним миром, этого не делают. Например</target>
        </trans-unit>
        <trans-unit id="fdf820a27fadf4bd22b75f1d8f664efea7b721ca" translate="yes" xml:space="preserve">
          <source>The rules for solving `Typeable` constraints are as follows:</source>
          <target state="translated">Правила решения ограничений `Typeable` следующие:</target>
        </trans-unit>
        <trans-unit id="f36a018d059c7c4d04382dae985b5d3771e4cf06" translate="yes" xml:space="preserve">
          <source>The rules that hold for &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over a bounded type such as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (see the section of the Haskell report dealing with arithmetic sequences) also hold for the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over the various &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; types defined here.</source>
          <target state="translated">Правила, которые выполняются для экземпляров &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; для ограниченного типа, такого как &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (см. Раздел отчета Haskell, посвященный арифметическим последовательностям), также справедливы для экземпляров &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; для различных типов &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; , определенных здесь.</target>
        </trans-unit>
        <trans-unit id="6455d6be1aa6dc5e07209062c07959f5e933541f" translate="yes" xml:space="preserve">
          <source>The rules that hold for &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over a bounded type such as &lt;code&gt;&lt;a href=&quot;prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (see the section of the Haskell report dealing with arithmetic sequences) also hold for the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over the various &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; types defined here.</source>
          <target state="translated">Правила, которые выполняются для экземпляров &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; для ограниченного типа, такого как &lt;code&gt;&lt;a href=&quot;prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (см. Раздел отчета Haskell, посвященный арифметическим последовательностям), также применяются для экземпляров &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; для различных типов &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; , определенных здесь.</target>
        </trans-unit>
        <trans-unit id="287275684f46fad5e60ea4e63f2b3989a859dcc8" translate="yes" xml:space="preserve">
          <source>The runtime manages a set of virtual processors, which we call &lt;em&gt;capabilities&lt;/em&gt;, the number of which is determined by the &lt;code&gt;-N&lt;/code&gt; option. Each capability can run one Haskell thread at a time, so the number of capabilities is equal to the number of Haskell threads that can run physically in parallel. A capability is animated by one or more OS threads; the runtime manages a pool of OS threads for each capability, so that if a Haskell thread makes a foreign call (see &lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;Multi-threading and the FFI&lt;/a&gt;) another OS thread can take over that capability.</source>
          <target state="translated">Среда выполнения управляет набором виртуальных процессоров, которые мы называем &lt;em&gt;возможностями&lt;/em&gt; , количество которых определяется параметром &lt;code&gt;-N&lt;/code&gt; . Каждая возможность может запускать один поток Haskell за раз, поэтому количество возможностей равно количеству потоков Haskell, которые могут работать физически параллельно. Возможность анимируется одним или несколькими потоками ОС; среда выполнения управляет пулом потоков ОС для каждой возможности, так что если поток Haskell делает внешний вызов (см. &lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;Многопоточность и FFI&lt;/a&gt; ), другой поток ОС может взять на себя эту возможность.</target>
        </trans-unit>
        <trans-unit id="0bf54255cb34f158e27d2a0117da364ec1bb6e6e" translate="yes" xml:space="preserve">
          <source>The runtime will run a Haskell thread using any of the available worker OS threads. If you need control over which particular OS thread is used to run a given Haskell thread, perhaps because you need to call a foreign library that uses OS-thread-local state, then you need bound threads (see &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt;).</source>
          <target state="translated">Среда выполнения будет запускать поток Haskell, используя любой из доступных рабочих потоков ОС. Если вам нужен контроль над тем, какой конкретный поток ОС используется для запуска данного потока Haskell, возможно потому, что вам нужно вызвать внешнюю библиотеку, которая использует локальное состояние потока ОС, тогда вам нужны связанные потоки (см. &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d9bdd79c3248e72d8f8184d783c66c7199f4ffdb" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;-v2&lt;/code&gt;, except that in addition the full command line (if appropriate) for each compilation phase is also printed.</source>
          <target state="translated">То же, что и &lt;code&gt;-v2&lt;/code&gt; , за исключением того, что дополнительно печатается полная командная строка (при необходимости) для каждой фазы компиляции.</target>
        </trans-unit>
        <trans-unit id="7a04f812bf453bed7d5a0caca4f5add0ec2c5d47" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;-v3&lt;/code&gt; except that the intermediate program representation after each compilation phase is also printed (excluding preprocessed and C/assembly files).</source>
          <target state="translated">То же, что и &lt;code&gt;-v3&lt;/code&gt; , за исключением того, что промежуточное представление программы после каждой фазы компиляции также печатается (за исключением препроцессированных файлов и файлов C / сборки).</target>
        </trans-unit>
        <trans-unit id="a2f32cc087f14553948fee64bcdc2ba34e644d9e" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">То же, что и &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; , но добавляет символ новой строки.</target>
        </trans-unit>
        <trans-unit id="8625552121606097b2d5857951839ce9043083ac" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt;, but for non-IO computations. Used for wrapping &lt;code&gt;foreign export&lt;/code&gt; and &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; when these are used to export Haskell functions with non-IO types.</source>
          <target state="translated">То же, что и &lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; , но для вычислений без ввода-вывода. Используется для &amp;laquo;обертки&amp;raquo; &lt;code&gt;foreign export&lt;/code&gt; и &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; когда они используются для экспорта функций Haskell с типами, отличными от IO.</target>
        </trans-unit>
        <trans-unit id="0648b1616676c9114b65de58cfeaaf5383529541" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;prelude#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">То же, что и &lt;code&gt;&lt;a href=&quot;prelude#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; , но добавляет символ новой строки.</target>
        </trans-unit>
        <trans-unit id="9e5b130c850d3ae23a8be04b3fa2ce4fa7fa0fb8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">То же, что и &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; , но добавляет символ новой строки.</target>
        </trans-unit>
        <trans-unit id="aa026dba543148cd2b273f964a160b184bdfeb30" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">То же, что и &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; , но добавляет символ новой строки.</target>
        </trans-unit>
        <trans-unit id="b8d8ca41d6eb5a3c9f60bb5bd1f3f55e1d6d7bbc" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">То же, что и &lt;code&gt;&lt;a href=&quot;system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; , но добавляет символ новой строки.</target>
        </trans-unit>
        <trans-unit id="6843b9b5a417fec3fae3876bec15b17db894f832" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;register&lt;/code&gt;, except that if a package of the same name is already installed, it is replaced by the new one.</source>
          <target state="translated">То же, что и &lt;code&gt;register&lt;/code&gt; , за исключением того, что если пакет с таким же именем уже установлен, он заменяется новым.</target>
        </trans-unit>
        <trans-unit id="4eb269dc2a06d69045a2a36c859373422e12ad50" translate="yes" xml:space="preserve">
          <source>The same as a regular Haskell pair, but</source>
          <target state="translated">То же самое,что и обычная пара Хаскелла,но</target>
        </trans-unit>
        <trans-unit id="4f89735e4671a45444902a2195c78bc1da818092" translate="yes" xml:space="preserve">
          <source>The same behaviour for &amp;ldquo;&lt;code&gt;Variable out of scope&lt;/code&gt;&amp;rdquo; errors, it terminates compilation by default. You can defer such errors by using the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; flag. This flag defers errors produced by out of scope variables until runtime, and converts them into compile-time warnings. These warnings can in turn be suppressed entirely by &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt;&lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Такое же поведение для ошибок &amp;laquo; &lt;code&gt;Variable out of scope&lt;/code&gt; &amp;raquo;, по умолчанию завершается компиляция. Вы можете отложить такие ошибки, используя &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; . Этот флаг откладывает ошибки, вызванные переменными вне области видимости, до времени выполнения и преобразует их в предупреждения времени компиляции. Эти предупреждения, в свою очередь, могут быть полностью подавлены с помощью &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt; &lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8543dc86d96439208628a8b1d7af30e1ee08694f" translate="yes" xml:space="preserve">
          <source>The same flag is necessary even if we compiled the modules from source, because GHC still reckons it&amp;rsquo;s in batch mode:</source>
          <target state="translated">Тот же флаг необходим, даже если мы скомпилировали модули из исходников, потому что GHC все еще считает его в пакетном режиме:</target>
        </trans-unit>
        <trans-unit id="ba3027bbf0fcb7bae35aa9ca1f45ea5074c50762" translate="yes" xml:space="preserve">
          <source>The same functor, but with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances that process the elements in the reverse order.</source>
          <target state="translated">Тот же функтор, но с экземплярами &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; , которые обрабатывают элементы в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="1c1f71fccfe0e9e481708999ce54008fd68d4d10" translate="yes" xml:space="preserve">
          <source>The same functor, but with an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">Тот же функтор, но с экземпляром &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; , который выполняет действия в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="c9c5f788326fc36e1f3b48e98542218be99c253c" translate="yes" xml:space="preserve">
          <source>The same information is summarised here:</source>
          <target state="translated">Та же информация обобщена здесь:</target>
        </trans-unit>
        <trans-unit id="ce5a33c04c63ab14da95d7e82ff9a7fdffb21817" translate="yes" xml:space="preserve">
          <source>The same phase-numbering control is available for &lt;code&gt;RULE&lt;/code&gt;s (&lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;).</source>
          <target state="translated">Такой же контроль нумерации фаз доступен для &lt;code&gt;RULE&lt;/code&gt; ( &lt;a href=&quot;#rewrite-rules&quot;&gt;правил перезаписи&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9d09ef3d38a83d48d1f4c76f8672633a3afd70db" translate="yes" xml:space="preserve">
          <source>The same refined dependency analysis also allows the type signatures of mutually-recursive functions to have different contexts, something that is illegal in Haskell 98 (Section 4.5.2, last sentence). GHC only insists that the type signatures of a &lt;em&gt;refined&lt;/em&gt; group have identical type signatures; in practice this means that only variables bound by the same pattern binding must have the same context. For example, this is fine:</source>
          <target state="translated">Тот же усовершенствованный анализ зависимостей также позволяет сигнатурам типов взаимно рекурсивных функций иметь разные контексты, что недопустимо в Haskell 98 (раздел 4.5.2, последнее предложение). GHC настаивает только на том, чтобы сигнатуры типов &lt;em&gt;уточненной&lt;/em&gt; группы имели идентичные сигнатуры типов; на практике это означает, что только переменные, связанные одной привязкой шаблона, должны иметь один и тот же контекст. Например, это нормально:</target>
        </trans-unit>
        <trans-unit id="8a7f218302834b3d894808ca735f7557a9dbe8d2" translate="yes" xml:space="preserve">
          <source>The same restrictions apply to instances generated by &lt;code&gt;deriving&lt;/code&gt; clauses. Thus the following is accepted:</source>
          <target state="translated">Те же ограничения применяются к экземплярам, ​​созданным с помощью &lt;code&gt;deriving&lt;/code&gt; предложений. Таким образом, принято следующее:</target>
        </trans-unit>
        <trans-unit id="9c526491ec37b7cc0b42d99e653f9e9274cc77d9" translate="yes" xml:space="preserve">
          <source>The scenario here is much like in &lt;a href=&quot;#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;, except that the aim is not to link a complete program, but to make a library from Haskell code that can be deployed in the same way that you would deploy a library of C code.</source>
          <target state="translated">Сценарий здесь очень похож на &lt;a href=&quot;#using-own-main&quot;&gt;использование вашего собственного main ()&lt;/a&gt; , за исключением того, что цель состоит не в том, чтобы связать полную программу, а в создании библиотеки из кода Haskell, которую можно развернуть таким же образом, как вы развертываете библиотеку C код.</target>
        </trans-unit>
        <trans-unit id="a7be4622eea3de88ed1a96151065af1cf68b5eb8" translate="yes" xml:space="preserve">
          <source>The search path by default contains a single directory: &amp;ldquo;&lt;code&gt;.&lt;/code&gt;&amp;rdquo; (i.e. the current directory). The following options can be used to add to or change the contents of the search path:</source>
          <target state="translated">Путь поиска по умолчанию содержит один каталог: &amp;laquo; &lt;code&gt;.&lt;/code&gt; &amp;rdquo;(Т.е. текущий каталог). Следующие параметры можно использовать для добавления или изменения содержимого пути поиска:</target>
        </trans-unit>
        <trans-unit id="8249f40a7c74a660887a3e9aa4b80efa30b048ab" translate="yes" xml:space="preserve">
          <source>The search path for finding source files is specified with the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option on the GHCi command line, like so:</source>
          <target state="translated">Путь поиска для поиска исходных файлов указывается с помощью опции &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt; в командной строке GHCi, например:</target>
        </trans-unit>
        <trans-unit id="097279f54de9a88bc11286150e5f678f203fd020" translate="yes" xml:space="preserve">
          <source>The second argument is usually the name of the application. Since it will be integrated into the path, it must consist of valid path characters. Note: if the second argument is an absolute path, it will just return the second argument.</source>
          <target state="translated">Вторым аргументом обычно является имя приложения.Так как он будет интегрирован в путь,он должен состоять из допустимых символов пути.Замечание:если второй аргумент-абсолютный путь,то он просто вернет второй аргумент.</target>
        </trans-unit>
        <trans-unit id="c8c52aa6b540d63fbb2366f65727bf3d9dc7ec2c" translate="yes" xml:space="preserve">
          <source>The second clause is a little more interesting. It says that two overlapping type family instances are allowed if the right-hand sides coincide in the region of overlap. Some examples help here:</source>
          <target state="translated">Второй пункт немного интереснее.В нем говорится,что допускаются два перекрывающихся экземпляра семейства типов,если правая сторона совпадает в области перекрытия.Некоторые примеры помогают здесь:</target>
        </trans-unit>
        <trans-unit id="1b82bdc74d0800be180d02d7bcd708e9c96094a1" translate="yes" xml:space="preserve">
          <source>The second constructor consists of two fields. Each is a recursive field of type &lt;code&gt;Tree a&lt;/code&gt;, represented as &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; (Tree a)&lt;/code&gt;. Representations of individual fields are combined using the binary type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Второй конструктор состоит из двух полей. Каждое из них является рекурсивным полем типа &lt;code&gt;Tree a&lt;/code&gt; , представленным как &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; (Tree a)&lt;/code&gt; . Представления отдельных полей объединяются с помощью конструктора бинарного типа &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69067e45a2d5620e94c67c0a1174c1c5e40697f6" translate="yes" xml:space="preserve">
          <source>The second most common step performed by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is to fill a buffer using a bounded primitives, which works as follows. The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; checks whether there is enough space left to execute the bounded primitive. If there is, then the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; executes the bounded primitive and calls the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; with the updated buffer. Otherwise, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; signals its driver that it requires a new buffer. This buffer must be at least as large as the bound of the primitive. We can use bounded primitives to reduce the number of buffer-free checks by fusing the buffer-free checks of consecutive &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. We can also use bounded primitives to simplify the control flow for signalling that a buffer is full by ensuring that we check first that there is enough space left and only then decide on how to encode a given value.</source>
          <target state="translated">Второй наиболее распространенный шаг, выполняемый &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; - это заполнение буфера с помощью ограниченных примитивов, который работает следующим образом. В &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; проверяет , есть ли осталось выполнить ограниченный примитив достаточно места. Если есть, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; выполняет ограниченный примитив и вызывает следующий &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; с обновленным буфером. В противном случае &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; сигнализирует своему драйверу, что ему требуется новый буфер. Размер этого буфера должен быть не меньше размера примитива. Мы можем использовать ограниченные примитивы, чтобы уменьшить количество проверок отсутствия буфера, путем объединения проверок отсутствия буфера последовательного &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; s. Мы также можем использовать ограниченные примитивы, чтобы упростить поток управления для сигнализации о том, что буфер заполнен, гарантируя, что мы сначала проверяем, достаточно ли осталось места, и только затем решаем, как кодировать данное значение.</target>
        </trans-unit>
        <trans-unit id="e3adff620b84d87073094a0d1e40cfb431f3fc23" translate="yes" xml:space="preserve">
          <source>The second of those cases, in which a type is unequal to the type parameter but does contain the type parameter, can be surprisingly tricky. For example, the following example compiles:</source>
          <target state="translated">Второй из этих случаев,в котором тип не совпадает с типом параметра,но содержит тип параметра,может быть удивительно хитрым.Например,следующий пример компилируется:</target>
        </trans-unit>
        <trans-unit id="9eb91d87bd37f6664f6bb87879f2252a0136d8dd" translate="yes" xml:space="preserve">
          <source>The second option is to add the flag &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;), which runs the interpreter in a separate process, wherein it can load and run the profiled code directly. There&amp;rsquo;s no need to compile the code twice, just add &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; and it should just work. (this option is experimental in GHC 8.0.x, but it may become the default in future releases).</source>
          <target state="translated">Второй вариант - добавить флаг &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt; (см. &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Запуск интерпретатора в отдельном процессе&lt;/a&gt; ), который запускает интерпретатор в отдельном процессе, в котором он может загружать и запускать профилированный код напрямую. Нет необходимости дважды компилировать код, просто добавьте &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt; и он должен работать. (эта опция является экспериментальной в GHC 8.0.x, но в будущих выпусках она может стать настройкой по умолчанию).</target>
        </trans-unit>
        <trans-unit id="1fe592ef22fd84069dc46f6e28d2597f0796d538" translate="yes" xml:space="preserve">
          <source>The second part of the file is a break-down by cost centre of the most costly functions in the program. In this case, there was only one significant function in the program, namely &lt;code&gt;fib&lt;/code&gt;, and it was responsible for 100% of both the time and allocation costs of the program.</source>
          <target state="translated">Вторая часть файла представляет собой разбивку по МВЗ наиболее дорогостоящих функций программы. В этом случае в программе была только одна важная функция, а именно &lt;code&gt;fib&lt;/code&gt; , и она отвечала за 100% затрат времени и распределения программы.</target>
        </trans-unit>
        <trans-unit id="b8df1be0cd5e2537cf6f141763056fb7615154f3" translate="yes" xml:space="preserve">
          <source>The section in this manual on kind polymorphism describes how variables in type and class declarations are ordered (&lt;a href=&quot;#inferring-variable-order&quot;&gt;Inferring the order of variables in a type/class declaration&lt;/a&gt;).</source>
          <target state="translated">В разделе этого руководства, посвященном полиморфизму видов, описывается порядок расположения переменных в объявлениях типов и классов ( &lt;a href=&quot;#inferring-variable-order&quot;&gt;определение порядка переменных в объявлении типа / класса&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="688179792a83dd0d7ac02a615c37eb7cae624b2d" translate="yes" xml:space="preserve">
          <source>The selector function to apply to the environment.</source>
          <target state="translated">Функция селектора,применяемая к окружающей среде.</target>
        </trans-unit>
        <trans-unit id="ab7e699fcd26948a260d7ff833362f9c40e09439" translate="yes" xml:space="preserve">
          <source>The selector's strictness annotation (if any)</source>
          <target state="translated">Строгая аннотация селектора (если таковая имеется).</target>
        </trans-unit>
        <trans-unit id="bbaa3124e273f9bbeae5e4b775012fe09975055e" translate="yes" xml:space="preserve">
          <source>The selector's unpackedness annotation (if any)</source>
          <target state="translated">Аннотация о распаковке селектора (если таковая имеется)</target>
        </trans-unit>
        <trans-unit id="66f2ee62244d552545951793286b38aaf65937a4" translate="yes" xml:space="preserve">
          <source>The semantics in this case is that the set of required entities is defined exclusively by its exports; if an entity is not mentioned in the export list, it is not required. The motivation behind this feature is to allow a library author to provide an omnibus signature containing the type of every function someone might want to use, while a client thins down the exports to the ones they actually require. For example, supposing that you have inherited a signature for strings, you might write a local signature of this form, listing only the entities that you need:</source>
          <target state="translated">Семантикой в данном случае является то,что набор требуемых организаций определяется исключительно их экспортом;если организация не упомянута в списке экспортируемых организаций,то она не требуется.Мотивация,стоящая за этой функцией,состоит в том,чтобы позволить автору библиотеки предоставить всестороннюю подпись,содержащую тип каждой функции,которую кто-то может захотеть использовать,в то время как клиент сокращает экспорт до тех,которые ему действительно нужны.Например,предполагая,что вы унаследовали подпись для строк,вы можете написать локальную подпись этой формы,перечисляя только те сущности,которые вам нужны:</target>
        </trans-unit>
        <trans-unit id="56586055c1a973adf6bc976c7f0c5948635e349a" translate="yes" xml:space="preserve">
          <source>The semantics of &lt;code&gt;rec&lt;/code&gt; is fairly straightforward. Whenever GHC finds a &lt;code&gt;rec&lt;/code&gt; group, it will compute its set of bound variables, and will introduce an appropriate call to the underlying monadic value-recursion operator &lt;code&gt;mfix&lt;/code&gt;, belonging to the &lt;code&gt;MonadFix&lt;/code&gt; class. Here is an example:</source>
          <target state="translated">Семантика &lt;code&gt;rec&lt;/code&gt; довольно проста. Каждый раз, когда GHC находит группу &lt;code&gt;rec&lt;/code&gt; , он вычисляет ее набор связанных переменных и вводит соответствующий вызов базового монадического оператора рекурсии &lt;code&gt;mfix&lt;/code&gt; , принадлежащего классу &lt;code&gt;MonadFix&lt;/code&gt; . Вот пример:</target>
        </trans-unit>
        <trans-unit id="b6ee2b36fc137b76acfc45249fe3e6a495362536" translate="yes" xml:space="preserve">
          <source>The semantics of Haskell pattern matching is described in &lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;Section 3.17.2&lt;/a&gt; of the Haskell Report. To this description add one extra item 10, saying:</source>
          <target state="translated">Семантика сопоставления с образцом Haskell описана в &lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;разделе 3.17.2&lt;/a&gt; отчета Haskell. К этому описанию добавьте еще один пункт 10:</target>
        </trans-unit>
        <trans-unit id="6864c1eb13210b08463d051de2f706ed1978f9af" translate="yes" xml:space="preserve">
          <source>The semantics of a pattern &lt;code&gt;(&lt;/code&gt; ⟨exp⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt; are as follows:</source>
          <target state="translated">Семантика шаблона &lt;code&gt;(&lt;/code&gt; ⟨exp⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; pat⟩ &lt;code&gt;)&lt;/code&gt; следующая:</target>
        </trans-unit>
        <trans-unit id="a49b20375791de9003bfc8d14ce130dc3774a912" translate="yes" xml:space="preserve">
          <source>The server-side Template Haskell state. This is created by the StartTH message. A new one is created per module that GHC typechecks.</source>
          <target state="translated">Шаблон состояния Хаскелла на стороне сервера.Оно создается сообщением StartTH.Для каждого модуля,который печатает GHC,создается новый шаблон.</target>
        </trans-unit>
        <trans-unit id="880e48518d2af8b17f9fbbf6826532563177f0bb" translate="yes" xml:space="preserve">
          <source>The set of keys used for locating static pointers in the Static Pointer Table is not guaranteed to remain stable for different program binaries. Or in other words, only processes launched from the same program binary are guaranteed to use the same set of keys.</source>
          <target state="translated">Набор ключей,используемый для нахождения статических указателей в таблице статических указателей,не гарантированно останется стабильным для различных двоичных программ.Или,другими словами,только процессы,запущенные из одного и того же двоичного файла программы,гарантированно используют один и тот же набор ключей.</target>
        </trans-unit>
        <trans-unit id="dce2b77db6ba22442abb84bf3fa8f872ca37ee0c" translate="yes" xml:space="preserve">
          <source>The set of known encodings is system-dependent, but includes at least:</source>
          <target state="translated">Набор известных кодировок зависит от системы,но включает в себя,как минимум:</target>
        </trans-unit>
        <trans-unit id="ed757898094aff99841d9541019b43be5923bde9" translate="yes" xml:space="preserve">
          <source>The set of modules that are currently &lt;em&gt;in scope&lt;/em&gt; at the prompt. This set is modified by &lt;code&gt;import&lt;/code&gt; and &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt;, and it is also modified automatically after &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt;, as described above. The set of modules in scope can be shown with &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Набор модулей, которые в настоящее время находятся &lt;em&gt;в области видимости&lt;/em&gt; в командной строке. Этот набор модифицируется &lt;code&gt;import&lt;/code&gt; и &lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; , а также автоматически изменяется после того, как &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt; , и &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; , как описано выше. Набор модулей в области видимости может быть показан с помощью &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51b1bf1f03c7acf30bf735e70b82dfebbaab8737" translate="yes" xml:space="preserve">
          <source>The set of modules that are currently &lt;em&gt;loaded&lt;/em&gt;. This set is modified by &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt;, and can be shown with &lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt;&lt;code&gt;:show modules&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Набор модулей, которые &lt;em&gt;загружены в&lt;/em&gt; данный момент . Этот набор модифицируется &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; , и может быть показан с &lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt; &lt;code&gt;:show modules&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4532383c79df86a71369071f6d14da2f5e99ce9c" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">Боковое условие в последнем законе необходимо, потому что &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; имеет высоту 1, а &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; не имеет высоты.</target>
        </trans-unit>
        <trans-unit id="e35ac63dcda6789b67e6cd555f46f1f50139eee5" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">Боковое условие в последнем законе необходимо, потому что &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; имеет высоту 1, а &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; не имеет высоты.</target>
        </trans-unit>
        <trans-unit id="78c75f7b1cf88eb962a211ac91c885339428b11f" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">Боковое условие в последнем законе необходимо, потому что &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; имеет высоту 1, а &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; не имеет высоты.</target>
        </trans-unit>
        <trans-unit id="7a38da53d66a8da2924f4490445d6a8597e51f56" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Побочное условие в последнем законе необходимо, потому что &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; - это левая идентичность для &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b01edfa1c723af20aa00f5a449572814388533c" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Побочное условие в последнем законе необходимо, потому что &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; - это левая идентичность для &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2031546b63b6ae221df9dd4d7437db7bf7d7abf" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Побочное условие в последнем законе необходимо, потому что &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; - это левая идентичность для &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a539d9419888c0404d1209818ed699951d45c48" translate="yes" xml:space="preserve">
          <source>The signature gives a type for a function binding or a bare variable binding, not a pattern binding. For example:</source>
          <target state="translated">Сигнатура дает тип для привязки функции или &quot;голые&quot; переменные,а не шаблон.Например:</target>
        </trans-unit>
        <trans-unit id="ff30f1e0ca7431f3c51b29f5935841acd7e3621c" translate="yes" xml:space="preserve">
          <source>The simplest interface to run a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; decoder. If the decoder runs into an error, calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, or runs out of input, it will call &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Самый простой интерфейс для запуска декодера &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; . Если декодер столкнется с &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; вызовет &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; или закончится ввод, он вызовет ошибку .</target>
        </trans-unit>
        <trans-unit id="a4171317271f9701924c5612cace202985932b94" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">Размер &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; не должен превышать &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; . Нарушение этого условия не обнаруживается, и в случае превышения лимита размера его поведение не определено.</target>
        </trans-unit>
        <trans-unit id="60d63bdb6773052d3664fc612f9f7c5d02a759c0" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">Размер &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; не должен превышать &lt;code&gt;maxBound::Int&lt;/code&gt; . Нарушение этого условия не обнаруживается, и в случае превышения лимита размера его поведение не определено.</target>
        </trans-unit>
        <trans-unit id="3cdb54d22332866769de89f6af0995d2941f5088" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, the behaviour of the sequence is undefined. This is unlikely to occur in most applications, but some care may be required when using &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, particularly repeatedly and particularly in combination with &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Размер &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; не должен превышать &lt;code&gt;maxBound::Int&lt;/code&gt; . Нарушение этого условия не обнаруживается, и если предел размера превышен, поведение последовательности не определено. Это маловероятно в большинстве приложений, но может потребоваться некоторая осторожность при использовании &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; , особенно многократно и особенно в сочетании с &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68b39ad023d3f11bcc8409b018ab8336d3bbbfec" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the associated values will be combined using &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Размер результата может быть меньше, если &lt;code&gt;f&lt;/code&gt; сопоставляет два или более разных ключа одному и тому же новому ключу. В этом случае связанные значения будут объединены с помощью &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="639cfdba7720e86e3a5a012ef353f96a357f6789" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the associated values will be combined using &lt;code&gt;c&lt;/code&gt;. The value at the greater of the two original keys is used as the first argument to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Размер результата может быть меньше, если &lt;code&gt;f&lt;/code&gt; сопоставляет два или более разных ключа одному и тому же новому ключу. В этом случае связанные значения будут объединены с помощью &lt;code&gt;c&lt;/code&gt; . Значение большего из двух исходных ключей используется в качестве первого аргумента для &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="048cc6a4527ae04b4d309fa4f47c7a471d6d47b2" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the value at the greatest of the original keys is retained.</source>
          <target state="translated">Размер результата может быть меньше, если &lt;code&gt;f&lt;/code&gt; сопоставляет два или более разных ключа одному и тому же новому ключу. В этом случае сохраняется максимальное значение исходного ключа.</target>
        </trans-unit>
        <trans-unit id="60b72fd8bb3e5f4a06fde0ee0bf443bff7e4e932" translate="yes" xml:space="preserve">
          <source>The size of the sequences of bytes generated by this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Размер последовательностей байтов, сгенерированных этим &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea5ea3bbb55b918ed6ea55188cf64e0d86600e17" translate="yes" xml:space="preserve">
          <source>The size of the set must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">Размер набора не должен превышать &lt;code&gt;maxBound::Int&lt;/code&gt; . Нарушение этого условия не обнаруживается, и в случае превышения лимита размера его поведение не определено.</target>
        </trans-unit>
        <trans-unit id="fb09dc2a9c4d162d88ca14ed072d0aed53b01f64" translate="yes" xml:space="preserve">
          <source>The size of the subrange defined by a bounding pair.</source>
          <target state="translated">Размер поддиапазона,определяемый ограничивающей парой.</target>
        </trans-unit>
        <trans-unit id="d626e1e8a07f4e02db6c2c2e1323369febdb90fc" translate="yes" xml:space="preserve">
          <source>The sized integral datatypes, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; типы данных размера: Int8 , &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c34be630267a2f34532e3f61be86bde91aa72b2" translate="yes" xml:space="preserve">
          <source>The sledgehammer you can bring to bear is the &lt;code&gt;INLINE&lt;/code&gt; pragma, used thusly:</source>
          <target state="translated">Кувалда, которую вы можете использовать, - это прагма &lt;code&gt;INLINE&lt;/code&gt; , используемая следующим образом:</target>
        </trans-unit>
        <trans-unit id="0cda2a4753e71bf4b99293af09e40ba00c0db06e" translate="yes" xml:space="preserve">
          <source>The solution is to define the instance-specific function yourself, with a pragma to prevent it being inlined too early, and give a RULE for it:</source>
          <target state="translated">Решение заключается в том,чтобы определить специфическую для экземпляра функцию самостоятельно,с прагматикой,чтобы не допустить ее слишком раннего встраивания,и дать для нее ПРАВИЛЬНОЕ значение:</target>
        </trans-unit>
        <trans-unit id="a143118fd55bf0e45fde2c00d4308bb63967230b" translate="yes" xml:space="preserve">
          <source>The source files for the program don&amp;rsquo;t all need to be in the same directory; the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option can be used to add directories to the search path (see &lt;a href=&quot;separate_compilation#search-path&quot;&gt;The search path&lt;/a&gt;).</source>
          <target state="translated">Исходные файлы программы не обязательно должны находиться в одном каталоге; параметр &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt; можно использовать для добавления каталогов в путь поиска (см. &lt;a href=&quot;separate_compilation#search-path&quot;&gt;Путь поиска&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7242f5a8794ecd7a9adc72221dcd6d3bf9cd57f6" translate="yes" xml:space="preserve">
          <source>The source location</source>
          <target state="translated">Местоположение источника</target>
        </trans-unit>
        <trans-unit id="bff14f9be362d2c46b6dfec1a6f40516c9ee7a4d" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;family&lt;/code&gt; distinguishes family from standard data declarations. The result kind annotation is optional and, as usual, defaults to &lt;code&gt;Type&lt;/code&gt; if omitted. An example is</source>
          <target state="translated">Специальное &lt;code&gt;family&lt;/code&gt; отличает семейство от стандартных объявлений данных. Аннотация типа результата является необязательной и, как обычно, по умолчанию имеет значение &lt;code&gt;Type&lt;/code&gt; если не указано. Примером является</target>
        </trans-unit>
        <trans-unit id="3b7b5cbf731a1d6d5a127ef030fdc4cd00939e17" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;family&lt;/code&gt; distinguishes family from standard type declarations. The result kind annotation is optional and, as usual, defaults to &lt;code&gt;Type&lt;/code&gt; if omitted. An example is</source>
          <target state="translated">Специальное &lt;code&gt;family&lt;/code&gt; отличает семейство от стандартных объявлений типов. Аннотация типа результата является необязательной и, как обычно, по умолчанию имеет значение &lt;code&gt;Type&lt;/code&gt; если не указано. Примером является</target>
        </trans-unit>
        <trans-unit id="952b7f739ae18492bdd3551b26083ef12a4de0fd" translate="yes" xml:space="preserve">
          <source>The special package name &lt;code&gt;this&lt;/code&gt; can be used to refer to the current package being built.</source>
          <target state="translated">Специальное имя пакета &lt;code&gt;this&lt;/code&gt; может быть использовано для обозначения текущего пакета строится.</target>
        </trans-unit>
        <trans-unit id="f6fec8a577698b9ef729ece863f1fe5c0db5311e" translate="yes" xml:space="preserve">
          <source>The specification ends with a format character:</source>
          <target state="translated">Спецификация заканчивается символом формата:</target>
        </trans-unit>
        <trans-unit id="e0644f44c0a9f69e8ff30c1b7ba3cca8f1d8012c" translate="yes" xml:space="preserve">
          <source>The specified file gets included into the C program, the compiled Haskell file, and the C header. &lt;code&gt;&amp;lt;HsFFI.h&amp;gt;&lt;/code&gt; is included automatically.</source>
          <target state="translated">Указанный файл включается в программу C, скомпилированный файл Haskell и заголовок C. &lt;code&gt;&amp;lt;HsFFI.h&amp;gt;&lt;/code&gt; включается автоматически.</target>
        </trans-unit>
        <trans-unit id="761a2c36ed9e89b5d391f9fcda8b027fe4d8b2e1" translate="yes" xml:space="preserve">
          <source>The specifiers for &lt;code&gt;DiffTime&lt;/code&gt;, &lt;code&gt;NominalDiffTime&lt;/code&gt;, &lt;code&gt;CalendarDiffDays&lt;/code&gt;, and &lt;code&gt;CalendarDiffTime&lt;/code&gt; are semantically separate from the other types. Specifiers on negative time differences will generally be negative (think &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Спецификаторы для &lt;code&gt;DiffTime&lt;/code&gt; , &lt;code&gt;NominalDiffTime&lt;/code&gt; , &lt;code&gt;CalendarDiffDays&lt;/code&gt; и &lt;code&gt;CalendarDiffTime&lt;/code&gt; семантически отделены от других типов. Спецификаторы отрицательной разницы во времени обычно будут отрицательными (подумайте о &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; , а не о &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ea0203e7d159675d01a82f8d0629d8fedd3302a1" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(blah1)&lt;/code&gt; cannot refer to the function &lt;code&gt;w&lt;/code&gt; - &lt;code&gt;w&lt;/code&gt; is part of a later declaration group, and thus invisible, similarly, &lt;code&gt;$(blah1)&lt;/code&gt; cannot see the definition of &lt;code&gt;h&lt;/code&gt; (since it is part of the same declaration group as &lt;code&gt;$(blah1)&lt;/code&gt;. However, the splice &lt;code&gt;$(blah1)&lt;/code&gt; can see the definition of &lt;code&gt;f&lt;/code&gt; (since it is in the immediately preceding declaration group).</source>
          <target state="translated">Сплайсинга &lt;code&gt;$(blah1)&lt;/code&gt; не может относиться к функции &lt;code&gt;w&lt;/code&gt; - &lt;code&gt;w&lt;/code&gt; является частью более поздней декларации группы, и , следовательно , невидим, подобным образом , &lt;code&gt;$(blah1)&lt;/code&gt; не может видеть определение &lt;code&gt;h&lt;/code&gt; (так как она является частью одной и той же декларации группы как &lt;code&gt;$(blah1)&lt;/code&gt; Тем не менее, splice &lt;code&gt;$(blah1)&lt;/code&gt; может видеть определение &lt;code&gt;f&lt;/code&gt; (так как оно находится в непосредственно предшествующей группе объявлений).</target>
        </trans-unit>
        <trans-unit id="aff3f00779b326bffbfbc12657deeca9ca823bb1" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(blah2)&lt;/code&gt; would see the same definitions as the splice &lt;code&gt;$(th2 ...)&lt;/code&gt; (but &lt;em&gt;not&lt;/em&gt; any bindings it creates).</source>
          <target state="translated">Сращивание &lt;code&gt;$(blah2)&lt;/code&gt; будут видеть то же определение, что и сращивание &lt;code&gt;$(th2 ...)&lt;/code&gt; (но &lt;em&gt;не&lt;/em&gt; любые привязок он создает).</target>
        </trans-unit>
        <trans-unit id="23568e32cf98b6540af26102a798c92ac5cc17bb" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th1 ...)&lt;/code&gt; would see the definition of &lt;code&gt;f&lt;/code&gt; - the splice is top-level and thus all definitions in the previous declaration group are visible (that is, all definitions in the module up-to, but not including, the splice itself).</source>
          <target state="translated">Сращивание &lt;code&gt;$(th1 ...)&lt;/code&gt; увидит определение &lt;code&gt;f&lt;/code&gt; - Сращивание верхнего уровня и , таким образом , все определения в предыдущей декларации группы открыты (то есть, все определения в модуле вверх, но не в том числе, сам стык).</target>
        </trans-unit>
        <trans-unit id="66ae13b13f09d43d7d7022adb99559db22c69352" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th1 ...)&lt;/code&gt;&lt;em&gt;cannot&lt;/em&gt; refer to &lt;code&gt;D&lt;/code&gt; - it is in the same declaration group.</source>
          <target state="translated">Сращивание &lt;code&gt;$(th1 ...)&lt;/code&gt; &lt;em&gt;не может&lt;/em&gt; ссылаться на &lt;code&gt;D&lt;/code&gt; - это в той же декларации группы.</target>
        </trans-unit>
        <trans-unit id="cfd7f431c58d50783a5438978201e850185fd6f9" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th2 ...)&lt;/code&gt; would see the definition of &lt;code&gt;f&lt;/code&gt;, all the bindings created by &lt;code&gt;$(th1 ...)&lt;/code&gt;, the definition of &lt;code&gt;h&lt;/code&gt; and all bindings created by &lt;code&gt;[qq|blah|]&lt;/code&gt; (they are all in previous declaration groups).</source>
          <target state="translated">Соединение &lt;code&gt;$(th2 ...)&lt;/code&gt; увидит определение &lt;code&gt;f&lt;/code&gt; , все привязки, созданные &lt;code&gt;$(th1 ...)&lt;/code&gt; , определение &lt;code&gt;h&lt;/code&gt; и все привязки, созданные &lt;code&gt;[qq|blah|]&lt;/code&gt; (все они были в предыдущем группы объявлений).</target>
        </trans-unit>
        <trans-unit id="fd5a42cc6f0856988a6988150fdee908257d806e" translate="yes" xml:space="preserve">
          <source>The splice to run</source>
          <target state="translated">Соединить воедино</target>
        </trans-unit>
        <trans-unit id="47923b168fb732c024dc494400d461bd0f3e5688" translate="yes" xml:space="preserve">
          <source>The stack isn&amp;rsquo;t counted in the heap profile by default. See the RTS &lt;a href=&quot;#rts-flag--xt&quot;&gt;&lt;code&gt;-xt&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="translated">По умолчанию стек не учитывается в профиле кучи. См. &lt;a href=&quot;#rts-flag--xt&quot;&gt; &lt;code&gt;-xt&lt;/code&gt; &lt;/a&gt; RTS -xt .</target>
        </trans-unit>
        <trans-unit id="f8363fc1e95626b191f2da3fd7dd2880aae6eb17" translate="yes" xml:space="preserve">
          <source>The stack trace may often begin with something uninformative like &lt;code&gt;GHC.List.CAF&lt;/code&gt;; this is an artifact of GHC&amp;rsquo;s optimiser, which lifts out exceptions to the top-level where the profiling system assigns them to the cost centre &amp;ldquo;CAF&amp;rdquo;. However, &lt;code&gt;+RTS -xc&lt;/code&gt; doesn&amp;rsquo;t just print the current stack, it looks deeper and reports the stack at the time the CAF was evaluated, and it may report further stacks until a non-CAF stack is found. In the example above, the next stack (after &lt;code&gt;--&amp;gt; evaluated by&lt;/code&gt;) contains plenty of information about what the program was doing when it evaluated &lt;code&gt;head []&lt;/code&gt;.</source>
          <target state="translated">Трассировка стека часто может начинаться с чего-то неинформативного, например &lt;code&gt;GHC.List.CAF&lt;/code&gt; ; это артефакт оптимизатора GHC, который выводит исключения на верхний уровень, где система профилирования назначает их центру затрат &amp;laquo;CAF&amp;raquo;. Однако &lt;code&gt;+RTS -xc&lt;/code&gt; не просто печатает текущий стек, он смотрит глубже и сообщает стек на момент оценки CAF, и может сообщать о дальнейших стеках, пока не будет найден стек, отличный от CAF. В приведенном выше примере следующий стек (после &lt;code&gt;--&amp;gt; evaluated by&lt;/code&gt; ) содержит много информации о том, что программа делала, когда оценивала &lt;code&gt;head []&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f357097f00a6468c2d3427445e00b165cb07e564" translate="yes" xml:space="preserve">
          <source>The stack-overflow message.</source>
          <target state="translated">Сообщение о переполнении стека.</target>
        </trans-unit>
        <trans-unit id="e0a326a9e00b997f5fb0b784326a904a6e7b5eaa" translate="yes" xml:space="preserve">
          <source>The stand-alone syntax is generalised for newtypes in exactly the same way that ordinary &lt;code&gt;deriving&lt;/code&gt; clauses are generalised (&lt;a href=&quot;#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;). For example:</source>
          <target state="translated">Автономный синтаксис обобщается для новых типов точно так же, как обычные &lt;code&gt;deriving&lt;/code&gt; предложения ( &lt;a href=&quot;#newtype-deriving&quot;&gt;обобщенные производные экземпляры для новых типов&lt;/a&gt; ). Например:</target>
        </trans-unit>
        <trans-unit id="45542d7c9b7a614f41aca25452eef03382fd8b7e" translate="yes" xml:space="preserve">
          <source>The standalone deriving declaration does not need to be in the same module as the data type declaration. (But be aware of the dangers of orphan instances (&lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;Orphan modules and instance declarations&lt;/a&gt;).</source>
          <target state="translated">Объявление автономного производного объекта не обязательно должно находиться в том же модуле, что и объявление типа данных. (Но помните об опасностях сиротских экземпляров ( &lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;сиротских модулей и объявлений экземпляров&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9c93dc2af6ef75fd7905ebfe43102d59d1f187ca" translate="yes" xml:space="preserve">
          <source>The standard C99 &lt;code&gt;fenv.h&lt;/code&gt; header provides operations for inspecting and modifying the state of the floating point unit. In particular, the rounding mode used by floating point operations can be changed, and the exception flags can be tested.</source>
          <target state="translated">Стандартный заголовок C99 &lt;code&gt;fenv.h&lt;/code&gt; предоставляет операции для проверки и изменения состояния модуля с плавающей запятой. В частности, можно изменить режим округления, используемый операциями с плавающей запятой, и можно проверить флаги исключения.</target>
        </trans-unit>
        <trans-unit id="9da3d7146865193067ad8c49db6bf7867c4feacc" translate="yes" xml:space="preserve">
          <source>The standard CPUTime library.</source>
          <target state="translated">Стандартная библиотека CPUTime.</target>
        </trans-unit>
        <trans-unit id="c1534047809870fc776b9636db7a2f0d8217f803" translate="yes" xml:space="preserve">
          <source>The standard IO library.</source>
          <target state="translated">Стандартная библиотека ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="dada1f21d1ada812f4cdf347467d780f571ac73f" translate="yes" xml:space="preserve">
          <source>The standard assumption on Darwin/Mac OS X is that dynamic libraries will be stamped at build time with an &amp;ldquo;install name&amp;rdquo;, which is the full ultimate install path of the library file. Any libraries or executables that subsequently link against it (even if it hasn&amp;rsquo;t been installed yet) will pick up that path as their runtime search location for it. When compiling with ghc directly, the install name is set by default to the location where it is built. You can override this with the &lt;code&gt;-dylib-install-name ⟨path⟩&lt;/code&gt; option (which passes &lt;code&gt;-install_name&lt;/code&gt; to the Apple linker). Cabal does this for you. It automatically sets the install name for dynamic libraries to the absolute path of the ultimate install location.</source>
          <target state="translated">Стандартное предположение для Darwin / Mac OS X состоит в том, что динамические библиотеки будут отмечены во время сборки &amp;laquo;именем установки&amp;raquo;, которое является полным окончательным путем установки файла библиотеки. Любые библиотеки или исполняемые файлы, которые впоследствии связываются с ним (даже если он еще не был установлен), будут использовать этот путь в качестве места его поиска во время выполнения. При компиляции напрямую с помощью ghc в качестве имени установки по умолчанию используется место, где она была создана. Вы можете переопределить это с помощью &lt;code&gt;-dylib-install-name ⟨path⟩&lt;/code&gt; (которая передает &lt;code&gt;-install_name&lt;/code&gt; компоновщику Apple). Кабал сделает это за вас. Он автоматически устанавливает в качестве имени установки для динамических библиотек абсолютный путь к окончательному месту установки.</target>
        </trans-unit>
        <trans-unit id="a4171f107795c00f458d3b7816f1b704314edbe3" translate="yes" xml:space="preserve">
          <source>The standard defaulting rule is extended thus: defaulting applies when all the unresolved constraints involve standard classes &lt;em&gt;or&lt;/em&gt;&lt;code&gt;IsString&lt;/code&gt;; and at least one is a numeric class &lt;em&gt;or&lt;/em&gt;&lt;code&gt;IsString&lt;/code&gt;.</source>
          <target state="translated">Стандартное правило по &lt;code&gt;IsString&lt;/code&gt; расширяется таким образом: по умолчанию применяется, когда все неразрешенные ограничения включают стандартные классы &lt;em&gt;или &lt;/em&gt;IsString ; и по крайней мере один - это числовой класс &lt;em&gt;или &lt;/em&gt; &lt;code&gt;IsString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b90689216583cd41f330d5e5b4b7eba42ec2fd80" translate="yes" xml:space="preserve">
          <source>The standard function &lt;code&gt;hs_free_stable_ptr&lt;/code&gt; locks the stable pointer table, frees the given stable pointer, and then unlocks the stable pointer table again. When freeing many stable pointers at once, it is usually more efficient to lock and unlock the table only once.</source>
          <target state="translated">Стандартная функция &lt;code&gt;hs_free_stable_ptr&lt;/code&gt; блокирует таблицу стабильных указателей, освобождает данный стабильный указатель, а затем снова разблокирует таблицу стабильных указателей. При одновременном освобождении многих стабильных указателей обычно более эффективно заблокировать и разблокировать таблицу только один раз.</target>
        </trans-unit>
        <trans-unit id="668fc1031df30471faf0816d4347dfd7e6b9a3b7" translate="yes" xml:space="preserve">
          <source>The standard functions for encoding and decoding text are strict, which is to say that they throw exceptions on invalid input. This is often unhelpful on real world input, so alternative functions exist that accept custom handlers for dealing with invalid inputs. These &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnError&quot;&gt;OnError&lt;/a&gt;&lt;/code&gt; handlers are normal Haskell functions. You can use one of the presupplied functions in this module, or you can write a custom handler of your own.</source>
          <target state="translated">Стандартные функции для кодирования и декодирования текста являются строгими, то есть выдают исключения при недопустимом вводе. Это часто бесполезно при вводе в реальном мире, поэтому существуют альтернативные функции, которые принимают пользовательские обработчики для работы с недопустимыми вводами. Эти обработчики &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnError&quot;&gt;OnError&lt;/a&gt;&lt;/code&gt; являются обычными функциями Haskell. Вы можете использовать одну из предустановленных функций в этом модуле или написать собственный обработчик.</target>
        </trans-unit>
        <trans-unit id="fd1929edeb7d09363083e46bcd3c301839eb47a2" translate="yes" xml:space="preserve">
          <source>The standard idiom used with &lt;code&gt;callCC&lt;/code&gt; is to provide a lambda-expression to name the continuation. Then calling the named continuation anywhere within its scope will escape from the computation, even if it is many layers deep within nested computations.</source>
          <target state="translated">Стандартная идиома, используемая с &lt;code&gt;callCC&lt;/code&gt; , заключается в предоставлении лямбда-выражения для имени продолжения. Тогда вызов именованного продолжения в любом месте в пределах его области видимости ускользнет из вычислений, даже если он находится на многих уровнях вложенных вычислений.</target>
        </trans-unit>
        <trans-unit id="725c149b8ea2ab588b227befe8a0a38299e1f811" translate="yes" xml:space="preserve">
          <source>The standard libraries do not have direct support for this device type, but a user implementation is expected to provide a list of file names in the directory, in any order, separated by &lt;code&gt;'\0'&lt;/code&gt; characters, excluding the &lt;code&gt;&quot;.&quot;&lt;/code&gt; and &lt;code&gt;&quot;..&quot;&lt;/code&gt; names. See also &lt;code&gt;&lt;a href=&quot;system-directory#v:getDirectoryContents&quot;&gt;getDirectoryContents&lt;/a&gt;&lt;/code&gt;. Seek operations are not supported on directories (other than to the zero position).</source>
          <target state="translated">Стандартные библиотеки не имеют прямой поддержки для этого типа устройства, но ожидается, что реализация пользователя предоставит список имен файлов в каталоге в любом порядке, разделенных символами &lt;code&gt;'\0'&lt;/code&gt; , за исключением символа &lt;code&gt;&quot;.&quot;&lt;/code&gt; и &lt;code&gt;&quot;..&quot;&lt;/code&gt; имена. См. Также &lt;code&gt;&lt;a href=&quot;system-directory#v:getDirectoryContents&quot;&gt;getDirectoryContents&lt;/a&gt;&lt;/code&gt; . Операции поиска не поддерживаются в каталогах (кроме нулевой позиции).</target>
        </trans-unit>
        <trans-unit id="e8a916de96b5a1348d801040a8c4f1a1a8827fbc" translate="yes" xml:space="preserve">
          <source>The standard library search path for your system loader, which on some systems may be overridden by setting the &lt;code id=&quot;index-19&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">Стандартный путь поиска библиотеки для вашего системного загрузчика, который в некоторых системах может быть переопределен установкой &lt;code id=&quot;index-19&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; среды LD_LIBRARY_PATH .</target>
        </trans-unit>
        <trans-unit id="19505176a01ce854f810479f684294743406e341" translate="yes" xml:space="preserve">
          <source>The state of the execution stack</source>
          <target state="translated">Состояние исполнительного стека</target>
        </trans-unit>
        <trans-unit id="f7e67ea8aa9dfee2731a58a175262adf6a4d0499" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;x &amp;lt;- return 42&lt;/code&gt; means &amp;ldquo;execute &lt;code&gt;return 42&lt;/code&gt; in the &lt;code&gt;IO&lt;/code&gt; monad, and bind the result to &lt;code&gt;x&lt;/code&gt;&amp;rdquo;. We can then use &lt;code&gt;x&lt;/code&gt; in future statements, for example to print it as we did above.</source>
          <target state="translated">Оператор &lt;code&gt;x &amp;lt;- return 42&lt;/code&gt; означает &amp;laquo;выполнить &lt;code&gt;return 42&lt;/code&gt; в монаде &lt;code&gt;IO&lt;/code&gt; и привязать результат к &lt;code&gt;x&lt;/code&gt; &amp;raquo;. Затем мы можем использовать &lt;code&gt;x&lt;/code&gt; в будущих операторах, например, чтобы распечатать его, как мы делали выше.</target>
        </trans-unit>
        <trans-unit id="c88d72a338b6ab0349b2edbe2a444fed0466129c" translate="yes" xml:space="preserve">
          <source>The statement is not a binding, or it is a monadic binding (&lt;code&gt;p &amp;lt;- e&lt;/code&gt;) that binds exactly one variable.</source>
          <target state="translated">Оператор не является привязкой или представляет собой монадическую привязку ( &lt;code&gt;p &amp;lt;- e&lt;/code&gt; ), которая связывает ровно одну переменную.</target>
        </trans-unit>
        <trans-unit id="26713db50737151b3061c0a0f90970614125b4e0" translate="yes" xml:space="preserve">
          <source>The stored values don't represent large virtual data structures to be lazily computed.</source>
          <target state="translated">Хранимые значения не представляют собой больших виртуальных структур данных,которые можно лениво вычислить.</target>
        </trans-unit>
        <trans-unit id="5a195b06cb90447dc9776264506496aa92aefc45" translate="yes" xml:space="preserve">
          <source>The strategy of combining computations that can throw exceptions by bypassing bound functions from the point an exception is thrown to the point that it is handled.</source>
          <target state="translated">Стратегия объединения вычислений,которые могут бросать исключения,обходя связанные функции из точки,в которую бросается исключение,до точки,с которой оно обрабатывается.</target>
        </trans-unit>
        <trans-unit id="a281a63e6736007299339dba190a3fb504a19a81" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">Строгая монада &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; монада позволяет деструктивных обновлений, но возможность выхода ( в отличие от IO). Вычисление типа &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; возвращает значение типа &lt;code&gt;a&lt;/code&gt; и выполняется в &amp;laquo;потоке&amp;raquo; &lt;code&gt;s&lt;/code&gt; . Параметр &lt;code&gt;s&lt;/code&gt; либо</target>
        </trans-unit>
        <trans-unit id="7afb89a781054b4b6d53c66cdbade7065f50d3d8" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">Строгая монада &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; монада позволяет деструктивных обновлений, но возможность выхода ( в отличие от IO). Вычисление типа &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; возвращает значение типа &lt;code&gt;a&lt;/code&gt; и выполняется в &amp;laquo;потоке&amp;raquo; &lt;code&gt;s&lt;/code&gt; . Параметр &lt;code&gt;s&lt;/code&gt; либо</target>
        </trans-unit>
        <trans-unit id="2d98a56131e0f04de337d0882771e394acb9d5b6" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">Строгий &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; монад WriterT , который добавляет набор выходных данных (например, счетчик или строковый выход) к данной монаде.</target>
        </trans-unit>
        <trans-unit id="4dc8357833da3292394aae6b46a123bbe223bc0c" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">Строгий &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; монад WriterT , который добавляет набор выходных данных (например, счетчик или строковый выход) к данной монаде.</target>
        </trans-unit>
        <trans-unit id="7c186abcf6ac752f3c38badaf602dca2e58877f2" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type requires that an entire string fit into memory at once. The lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is capable of streaming strings that are larger than memory using a small memory footprint. In many cases, the overhead of chunked streaming makes the lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type slower than its strict counterpart, but this is not always the case. Sometimes, the time complexity of a function in one module may be different from the other, due to their differing internal structures.</source>
          <target state="translated">Тип strict &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; требует, чтобы в память помещалась сразу вся строка. Тип отложенного &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; может передавать строки, размер которых превышает размер памяти, с использованием небольшого объема памяти. Во многих случаях накладные расходы на потоковую передачу по фрагментам делают ленивый тип &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; медленнее, чем его строгий аналог, но это не всегда так. Иногда временная сложность функции в одном модуле может отличаться от другого из-за их различной внутренней структуры.</target>
        </trans-unit>
        <trans-unit id="65527fd492a2c24e97d357e54b9019d2cf4c0b6f" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">Строгая монада &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; монада позволяет деструктивных обновлений, но возможность выхода ( в отличие от IO). Вычисление типа &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; возвращает значение типа &lt;code&gt;a&lt;/code&gt; и выполняется в &amp;laquo;потоке&amp;raquo; &lt;code&gt;s&lt;/code&gt; . Параметр &lt;code&gt;s&lt;/code&gt; либо</target>
        </trans-unit>
        <trans-unit id="8767e7a8a38c16ab0bb2841059262444985ec93e" translate="yes" xml:space="preserve">
          <source>The strictness analyser figures out when arguments and variables in a function can be treated &amp;lsquo;strictly&amp;rsquo; (that is they are always evaluated in the function at some point). This allow GHC to apply certain optimisations such as unboxing that otherwise don&amp;rsquo;t apply as they change the semantics of the program when applied to lazy arguments.</source>
          <target state="translated">Анализатор строгости определяет, когда аргументы и переменные в функции можно обрабатывать &amp;laquo;строго&amp;raquo; (то есть они всегда вычисляются в функции в какой-то момент). Это позволяет GHC применять определенные оптимизации, такие как распаковка, которые в противном случае не применяются, поскольку они изменяют семантику программы при применении к ленивым аргументам.</target>
        </trans-unit>
        <trans-unit id="6e2011ddb103ca8a7d059229ae604d364befac79" translate="yes" xml:space="preserve">
          <source>The strictness of a field as the user wrote it in the source code. For example, in the following data type:</source>
          <target state="translated">Строгость поля,как пользователь написал его в исходном коде.Например,в следующем типе данных:</target>
        </trans-unit>
        <trans-unit id="452caeb84acbb77ee8c95de9c60b64d7a53f7406" translate="yes" xml:space="preserve">
          <source>The strictness that GHC infers for a field during compilation. Whereas there are nine different combinations of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt;, the strictness that GHC decides will ultimately be one of lazy, strict, or unpacked. What GHC decides is affected both by what the user writes in the source code and by GHC flags. As an example, consider this data type:</source>
          <target state="translated">Строгость, которую GHC определяет для поля во время компиляции. &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; на то, что существует девять различных комбинаций &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; и SourceStrictness , строгость, которую решает GHC, в конечном итоге будет ленивой, строгой или распакованной. Решение GHC зависит как от того, что пользователь пишет в исходном коде, так и от флагов GHC. В качестве примера рассмотрим этот тип данных:</target>
        </trans-unit>
        <trans-unit id="89a584f7d6318b24a421c9d75de2b615ce3c18f3" translate="yes" xml:space="preserve">
          <source>The strictness that the compiler inferred for the selector</source>
          <target state="translated">Строгость,которую компилятор вывел для селектора...</target>
        </trans-unit>
        <trans-unit id="874f9293737bf29e2db184d41d8db8a32987eb82" translate="yes" xml:space="preserve">
          <source>The string capabilities in this module are the character sequences corresponding to user input such as arrow keys and function keys.</source>
          <target state="translated">Строковыми возможностями в этом модуле являются символьные последовательности,соответствующие вводу пользователя,такие как клавиши со стрелками и функциональные клавиши.</target>
        </trans-unit>
        <trans-unit id="1f4ad8b7962c51a61e8c4bd613c54e8011e48fb7" translate="yes" xml:space="preserve">
          <source>The string in parentheses after the package name is the installed package ID: it normally begins with the package name and version, and ends in a hash string derived from the compiled package. Dependencies between packages are expressed in terms of installed package IDs, rather than just packages and versions. For example, take a look at the dependencies of the &lt;code&gt;haskell98&lt;/code&gt; package:</source>
          <target state="translated">Строка в скобках после имени пакета является идентификатором установленного пакета: обычно она начинается с имени и версии пакета и заканчивается строкой хэша, полученной из скомпилированного пакета. Зависимости между пакетами выражаются в виде идентификаторов установленных пакетов, а не только пакетов и версий. Например, взгляните на зависимости пакета &lt;code&gt;haskell98&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="800c652caf58afbb39f126fbcdbcf23d8117aa7a" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a directed graph, reverse topologically sorted.</source>
          <target state="translated">Сильно связанные компоненты направленного графика,обратно топологически отсортированные.</target>
        </trans-unit>
        <trans-unit id="ddf6268ee3b3ab45015db89ef43dec769f4bad14" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a directed graph, reverse topologically sorted. The function is the same as &lt;code&gt;&lt;a href=&quot;data-graph#v:stronglyConnComp&quot;&gt;stronglyConnComp&lt;/a&gt;&lt;/code&gt;, except that all the information about each node retained. This interface is used when you expect to apply &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; to (some of) the result of &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt;, so you don't want to lose the dependency information.</source>
          <target state="translated">Сильносвязные компоненты ориентированного графа, отсортированные обратно топологически. Функция такая же, как и &lt;code&gt;&lt;a href=&quot;data-graph#v:stronglyConnComp&quot;&gt;stronglyConnComp&lt;/a&gt;&lt;/code&gt; , за исключением того, что сохраняется вся информация о каждом узле. Этот интерфейс используется, когда вы планируете применить &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; к (некоторым) результатам &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; , поэтому вы не хотите терять информацию о зависимости.</target>
        </trans-unit>
        <trans-unit id="a57d36a00a23d146f6ef5c2dc372f9cf337806de" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a graph, in reverse topological order.</source>
          <target state="translated">Сильно связанные компоненты графика,в обратном топологическом порядке.</target>
        </trans-unit>
        <trans-unit id="43a19690de2f9d1d8be09c13cbb22de3789cc278" translate="yes" xml:space="preserve">
          <source>The subtraction operation, and the greater-than-or-equal test, in &lt;code&gt;n+k&lt;/code&gt; patterns use whatever &lt;code&gt;(-)&lt;/code&gt; and &lt;code&gt;(&amp;gt;=)&lt;/code&gt; are in scope.</source>
          <target state="translated">Операция вычитания и проверка &amp;laquo;больше или равно&amp;raquo; в &lt;code&gt;n+k&lt;/code&gt; шаблонах используют любые &lt;code&gt;(-)&lt;/code&gt; и &lt;code&gt;(&amp;gt;=)&lt;/code&gt; в области видимости.</target>
        </trans-unit>
        <trans-unit id="4012471429ca5c7ba04bc705b681a94410ab1849" translate="yes" xml:space="preserve">
          <source>The suffix of the &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that could not be decoded due to insufficient input.</source>
          <target state="translated">Суффикс &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; , который не удалось декодировать из-за недостаточного ввода.</target>
        </trans-unit>
        <trans-unit id="bc55708fbbcc2f6408e01cba514ffdea99d3c7fa" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biconcat&quot;&gt;biconcat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Сумма набора действий, обобщающая &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biconcat&quot;&gt;biconcat&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4ea1e538ad4b53fa66cdfd634dcb4ac8d35e514" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Сумма набора действий, обобщающего &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3b60db9348af6943b179b2e86b7211b8058b8a2" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;. As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Сумма набора действий, обобщающего &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; . Начиная с версии 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; , специализированным для &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3dbb19dea24b4fb38846d955f10c5e44271be4ab" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;. As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Сумма набора действий, обобщающего &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; . Начиная с версии 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; , специализированным для &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34ab21e6e1aaae1bca96ae7ec03ef891e22c67a2" translate="yes" xml:space="preserve">
          <source>The superclass instances should satisfy the following:</source>
          <target state="translated">Суперклассные экземпляры должны удовлетворять следующим требованиям:</target>
        </trans-unit>
        <trans-unit id="601c418a63c60900d136bd4720ff47c285ee0785" translate="yes" xml:space="preserve">
          <source>The symbols defined by GHC are listed below. To check which symbols are defined by your local GHC installation, the following trick is useful:</source>
          <target state="translated">Символы,определенные GHC,перечислены ниже.Чтобы проверить,какие символы определены вашей локальной установкой GHC,полезно воспользоваться следующим трюком:</target>
        </trans-unit>
        <trans-unit id="09212832b3e34d72dce2fff3badb2d4c72e1995b" translate="yes" xml:space="preserve">
          <source>The syntax accepted by this function is the same as for &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Синтаксис, принятый этой функцией, такой же, как для &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31649ab7ec4ff56487760fbbe409d363750ae3e3" translate="yes" xml:space="preserve">
          <source>The syntax accepted by this function is the same as for &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Синтаксис, принятый этой функцией, такой же, как для &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7ced7f7fed6d217b69c558540eb691be95e7fb5" translate="yes" xml:space="preserve">
          <source>The syntax and semantics of pattern synonyms are elaborated in the following subsections. There are also lots more details in the &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf&quot;&gt;paper&lt;/a&gt;.</source>
          <target state="translated">Синтаксис и семантика синонимов шаблонов подробно описаны в следующих подразделах. В &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf&quot;&gt;статье&lt;/a&gt; также есть много других подробностей .</target>
        </trans-unit>
        <trans-unit id="f1898dd084c771828aecaee9b8e697bb13e36ea3" translate="yes" xml:space="preserve">
          <source>The syntax for minimal complete definition is:</source>
          <target state="translated">Синтаксис для минимального полного определения:</target>
        </trans-unit>
        <trans-unit id="6d4d4090d2ca1b67d53de25f5ccbc8a40e760887" translate="yes" xml:space="preserve">
          <source>The syntax in the prompt &lt;code&gt;*module&lt;/code&gt; indicates that it is the full top-level scope of ⟨module⟩ that is contributing to the scope for expressions typed at the prompt. Without the &lt;code&gt;*&lt;/code&gt;, just the exports of the module are visible.</source>
          <target state="translated">Синтаксис в &lt;code&gt;*module&lt;/code&gt; приглашения * указывает, что это полная область верхнего уровня &amp;laquo;модуля&amp;raquo;, которая вносит вклад в область видимости выражений, вводимых в приглашении. Без &lt;code&gt;*&lt;/code&gt; видны только экспорты модуля.</target>
        </trans-unit>
        <trans-unit id="89df7dc6bb4bb7bfb64ddff710508f03cebad89a" translate="yes" xml:space="preserve">
          <source>The syntax is</source>
          <target state="translated">Синтаксис</target>
        </trans-unit>
        <trans-unit id="e90385697e013355d38615469e8cfd75a3c62ed9" translate="yes" xml:space="preserve">
          <source>The syntax is identical to that of an ordinary instance declaration apart from (a) the keyword &lt;code&gt;deriving&lt;/code&gt;, and (b) the absence of the &lt;code&gt;where&lt;/code&gt; part.</source>
          <target state="translated">Синтаксис идентичен обычный экземпляр декларации , кроме (а) с ключевыми словами , &lt;code&gt;deriving&lt;/code&gt; , и (б) отсутствием &lt;code&gt;where&lt;/code&gt; частью.</target>
        </trans-unit>
        <trans-unit id="c439f2f4a3a3244db28746190d4b4754f0a2dbfb" translate="yes" xml:space="preserve">
          <source>The syntax is the same as for &lt;code&gt;case&lt;/code&gt; expressions, except that the bodies of the alternatives are commands rather than expressions. The translation is similar to that of &lt;code&gt;if&lt;/code&gt; commands.</source>
          <target state="translated">Синтаксис такой же, как и для &lt;code&gt;case&lt;/code&gt; - выражений, за исключением того, что тела альтернатив - это команды, а не выражения. Перевод аналогичен переводу команд &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06b82b71139eb6105985a9ea822a6da5f567e6c2" translate="yes" xml:space="preserve">
          <source>The syntax of a cost centre annotation for expressions is</source>
          <target state="translated">Синтаксис аннотации к центру расходов для выражений</target>
        </trans-unit>
        <trans-unit id="39642abd7096bcb01814d7cae1861c218f39c272" translate="yes" xml:space="preserve">
          <source>The syntax of a statement accepted at the GHCi prompt is exactly the same as the syntax of a statement in a Haskell &lt;code&gt;do&lt;/code&gt; expression. However, there&amp;rsquo;s no monad overloading here: statements typed at the prompt must be in the &lt;code&gt;IO&lt;/code&gt; monad.</source>
          <target state="translated">Синтаксис оператора, принятого в приглашении GHCi, точно такой же, как синтаксис оператора в выражении Haskell &lt;code&gt;do&lt;/code&gt; . Однако здесь нет перегрузки монады: операторы, набранные в приглашении, должны быть в монаде &lt;code&gt;IO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57bd174f58802ef0f51feabdb13a1ea1a660c409" translate="yes" xml:space="preserve">
          <source>The syntax of the value depends on the field. The various field types are:</source>
          <target state="translated">Синтаксис значения зависит от поля.Различные типы полей:</target>
        </trans-unit>
        <trans-unit id="202a394073135e421a152f8ce9fd5cd3dfc192e0" translate="yes" xml:space="preserve">
          <source>The table below summarises where each kind of pattern synonym can be used.</source>
          <target state="translated">В таблице ниже приведена сводная информация о том,где можно использовать синонимы каждого типа шаблонов.</target>
        </trans-unit>
        <trans-unit id="63a6c28c376561a6f590d22eabde559eabb51ab0" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">Тактика, описанная для &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; работает и с &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; . Кроме того, доступны следующие варианты.</target>
        </trans-unit>
        <trans-unit id="a934fce6fdd2ffdb39bbed5c280b561fba32c363" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">Тактика, описанная для &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; работает и с &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; . Кроме того, доступны следующие варианты.</target>
        </trans-unit>
        <trans-unit id="c26d3376b4a836bb67a06339918f835307d1d509" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">Тактика, описанная для &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; работает и с &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; . Кроме того, доступны следующие варианты.</target>
        </trans-unit>
        <trans-unit id="ff8bb3eff7d145417d7bd237ecabdafc3547dcf3" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">Тактика, описанная для &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; работает и с &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; . Кроме того, доступны следующие варианты.</target>
        </trans-unit>
        <trans-unit id="d865c7a90982fb62dc4ae75514e4dcae088ee2b0" translate="yes" xml:space="preserve">
          <source>The template file (see below).</source>
          <target state="translated">Файл шаблона (см.ниже).</target>
        </trans-unit>
        <trans-unit id="0b4e99c29e9e1110faab1ac222008a4dc83498a8" translate="yes" xml:space="preserve">
          <source>The temporary storage is freed when the subcomputation terminates (either normally or via an exception), so the pointer to the temporary storage must &lt;em&gt;not&lt;/em&gt; be used after this function returns.</source>
          <target state="translated">Временное хранилище освобождается, когда подвычисление завершается (обычно или через исключение), поэтому указатель на временное хранилище &lt;em&gt;не&lt;/em&gt; должен использоваться после возврата из этой функции.</target>
        </trans-unit>
        <trans-unit id="5843b93328315843899ef67d9ac21737c6ec6f80" translate="yes" xml:space="preserve">
          <source>The term &amp;ldquo;unregisterised&amp;rdquo; really means &amp;ldquo;compile via vanilla C&amp;rdquo;, disabling some of the platform-specific tricks that GHC normally uses to make programs go faster. When compiling unregisterised, GHC simply generates a C file which is compiled via gcc.</source>
          <target state="translated">Термин &amp;laquo;незарегистрированный&amp;raquo; на самом деле означает &amp;laquo;компилировать с помощью ванильного языка C&amp;raquo;, отключая некоторые специфические для платформы уловки, которые GHC обычно использует для ускорения работы программ. При компиляции без регистрации GHC просто генерирует файл C, который компилируется через gcc.</target>
        </trans-unit>
        <trans-unit id="e2c5e0b321bb9e70feb67c2d09ee38018c4bf2af" translate="yes" xml:space="preserve">
          <source>The term level syntax is similar. Leading and preceding bars (&lt;code&gt;|&lt;/code&gt;) indicate which alternative it is. Here are two terms of the type shown above:</source>
          <target state="translated">Синтаксис уровня термина аналогичен. Передняя и предыдущая полоски ( &lt;code&gt;|&lt;/code&gt; ) указывают, какая это альтернатива. Вот два термина указанного выше типа:</target>
        </trans-unit>
        <trans-unit id="c6feeb4ddd15050ca18ee294869d49815d5f2066" translate="yes" xml:space="preserve">
          <source>The third and final section of the file gives a profile break-down by cost-centre stack. This is roughly a call-tree profile of the program. In the example above, it is clear that the costly call to &lt;code&gt;fib&lt;/code&gt; came from &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">Третий и последний раздел файла дает разбивку профиля по стеку центров затрат. Это примерно профиль дерева вызовов программы. В приведенном выше примере ясно, что дорогостоящий вызов &lt;code&gt;fib&lt;/code&gt; исходил из &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="006833f98130a8f76b519213e28557b98c68aabc" translate="yes" xml:space="preserve">
          <source>The third instance declaration does not obey the coverage condition; and indeed the (somewhat strange) definition:</source>
          <target state="translated">Заявление в третьей инстанции не подчиняется условию охвата;и действительно (несколько странное)определение:</target>
        </trans-unit>
        <trans-unit id="05cc827b35cf7b3c105e9a9c20e954f8071d852d" translate="yes" xml:space="preserve">
          <source>The third kind of instance exists for every &lt;code&gt;newtype NT = MkNT T&lt;/code&gt; and comes in two variants, namely</source>
          <target state="translated">Третий вид экземпляров существует для каждого &lt;code&gt;newtype NT = MkNT T&lt;/code&gt; и бывает двух вариантов, а именно</target>
        </trans-unit>
        <trans-unit id="3bd2c3ed5890f250e2002920ec679aa2cdafcf5e" translate="yes" xml:space="preserve">
          <source>The third kind of wildcard is the &lt;em&gt;extra-constraints wildcard&lt;/em&gt;. The presence of an extra-constraints wildcard indicates that an arbitrary number of extra constraints may be inferred during type checking and will be added to the type signature. In the example below, the extra-constraints wildcard is used to infer three extra constraints.</source>
          <target state="translated">Третий вид подстановочных знаков - это подстановочные знаки &lt;em&gt;дополнительных ограничений&lt;/em&gt; . Наличие подстановочного знака дополнительных ограничений указывает, что во время проверки типа может быть выведено произвольное количество дополнительных ограничений, которые будут добавлены к сигнатуре типа. В приведенном ниже примере подстановочный знак дополнительных ограничений используется для вывода трех дополнительных ограничений.</target>
        </trans-unit>
        <trans-unit id="e3f90c4625109b43c8084cce4940a68a10e8c40f" translate="yes" xml:space="preserve">
          <source>The thread is blocked on an &lt;code&gt;MVar&lt;/code&gt;, but there are no other references to the &lt;code&gt;MVar&lt;/code&gt; so it can't ever continue.</source>
          <target state="translated">Поток заблокирован на &lt;code&gt;MVar&lt;/code&gt; , но других ссылок на &lt;code&gt;MVar&lt;/code&gt; нет, поэтому он не может продолжаться.</target>
        </trans-unit>
        <trans-unit id="153d4dcc14c4b83f4dd90f15af80d80779678ce4" translate="yes" xml:space="preserve">
          <source>The thread is waiting to retry an STM transaction, but there are no other references to any &lt;code&gt;TVar&lt;/code&gt;s involved, so it can't ever continue.</source>
          <target state="translated">Поток ожидает повторной попытки транзакции STM, но нет других ссылок на какие-либо задействованные &lt;code&gt;TVar&lt;/code&gt; , поэтому он не может продолжаться.</target>
        </trans-unit>
        <trans-unit id="e47d3507c379ee5ecfefb0d652582554ff9592ce" translate="yes" xml:space="preserve">
          <source>The thread making the foreign call is sent a &lt;code&gt;SIGPIPE&lt;/code&gt; signal using &lt;code&gt;pthread_kill()&lt;/code&gt;. This is usually enough to cause a blocking system call to return with &lt;code&gt;EINTR&lt;/code&gt; (GHC by default installs an empty signal handler for &lt;code&gt;SIGPIPE&lt;/code&gt;, to override the default behaviour which is to terminate the process immediately).</source>
          <target state="translated">Поток, выполняющий внешний вызов, отправляет сигнал &lt;code&gt;SIGPIPE&lt;/code&gt; с помощью &lt;code&gt;pthread_kill()&lt;/code&gt; . Обычно этого достаточно, чтобы системный вызов блокировки возвращался с &lt;code&gt;EINTR&lt;/code&gt; (GHC по умолчанию устанавливает пустой обработчик сигнала для &lt;code&gt;SIGPIPE&lt;/code&gt; , чтобы переопределить поведение по умолчанию, которое заключается в немедленном завершении процесса).</target>
        </trans-unit>
        <trans-unit id="dc3f55c5bbf83854f6c0fbdab69d4f8ac8efc219" translate="yes" xml:space="preserve">
          <source>The threaded runtime system provides the following benefits:</source>
          <target state="translated">Потоковая исполнительная система обеспечивает следующие преимущества:</target>
        </trans-unit>
        <trans-unit id="0857013e6b098dcf4a2991653bd77bab36770599" translate="yes" xml:space="preserve">
          <source>The time and allocation incurred by a given part of the program is displayed in two ways: &amp;ldquo;individual&amp;rdquo;, which are the costs incurred by the code covered by this cost centre stack alone, and &amp;ldquo;inherited&amp;rdquo;, which includes the costs incurred by all the children of this node.</source>
          <target state="translated">Время и распределение, понесенные данной частью программы, отображаются двумя способами: &amp;laquo;индивидуальные&amp;raquo;, которые представляют собой затраты, понесенные кодом, охватываемым только этим стеком МВЗ, и &amp;laquo;унаследованные&amp;raquo;, которые включают затраты, понесенные всеми. дочерние элементы этого узла.</target>
        </trans-unit>
        <trans-unit id="ba821c7b2c68328012c9090eb3761d8e93f68a1c" translate="yes" xml:space="preserve">
          <source>The time elapsed during GC itself</source>
          <target state="translated">Время,прошедшее во время самого ГХ</target>
        </trans-unit>
        <trans-unit id="51d9a82a9f3d64e8432722f74df5f02d64a529e0" translate="yes" xml:space="preserve">
          <source>The time elapsed during synchronisation before GC</source>
          <target state="translated">Время,прошедшее во время синхронизации до GC</target>
        </trans-unit>
        <trans-unit id="7c0735b2391960bf71874071a3ad1522abfcdaab" translate="yes" xml:space="preserve">
          <source>The time locale.</source>
          <target state="translated">Местное время.</target>
        </trans-unit>
        <trans-unit id="635699c1de3bbf03eeb4589396236f0563a33d91" translate="yes" xml:space="preserve">
          <source>The time value, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the input could not be parsed using the given format.</source>
          <target state="translated">Значение времени или &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если вход не может быть проанализирован с использованием данного формата.</target>
        </trans-unit>
        <trans-unit id="b879d81d9e92215265250a4d9dbf254f8e1ceccb" translate="yes" xml:space="preserve">
          <source>The time value.</source>
          <target state="translated">Значение времени.</target>
        </trans-unit>
        <trans-unit id="d67a73e76fb4a63dbec3bae1d772d92896ac5e8e" translate="yes" xml:space="preserve">
          <source>The total number of bytes allocated by the program over the whole run.</source>
          <target state="translated">Общее количество байт,выделенных программой за весь запуск.</target>
        </trans-unit>
        <trans-unit id="659dcc49ad7db77aa436a59a26fe4ff143fda38c" translate="yes" xml:space="preserve">
          <source>The total number of garbage collections performed.</source>
          <target state="translated">Общее количество вывезенного мусора.</target>
        </trans-unit>
        <trans-unit id="c34c589e65c946035b07b2931096cc65473c816d" translate="yes" xml:space="preserve">
          <source>The total wall time of the program&amp;rsquo;s execution in seconds.</source>
          <target state="translated">Суммарное время выполнения программы в секундах.</target>
        </trans-unit>
        <trans-unit id="70c58cb0b1b679f8dbf2b38d7d0722b07c314a3c" translate="yes" xml:space="preserve">
          <source>The transaction may have seen an inconsistent view of memory when the IO runs. Invariants that you expect to be true throughout your program may not be true inside a transaction, due to the way transactions are implemented. Normally this wouldn't be visible to the programmer, but using &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; can expose it.</source>
          <target state="translated">При выполнении операции ввода-вывода транзакция могла видеть несогласованное представление памяти. Инварианты, которые, как вы ожидаете, будут истинными во всей программе, могут не выполняться внутри транзакции из-за способа реализации транзакций. Обычно это не видно программисту, но использование &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; может раскрыть его.</target>
        </trans-unit>
        <trans-unit id="8c79225ca289cd5ba4c8a1fb91fc94c1d3935a10" translate="yes" xml:space="preserve">
          <source>The transaction may have seen an inconsistent view of memory when the IO runs. Invariants that you expect to be true throughout your program may not be true inside a transaction, due to the way transactions are implemented. Normally this wouldn't be visible to the programmer, but using &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; can expose it.</source>
          <target state="translated">При выполнении операции ввода-вывода транзакция могла видеть несогласованное представление памяти. Инварианты, которые, как вы ожидаете, будут истинными во всей программе, могут не выполняться внутри транзакции из-за способа реализации транзакций. Обычно это не видно программисту, но использование &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; может раскрыть его.</target>
        </trans-unit>
        <trans-unit id="59680a93a71d010858520603ea1e8e61b91ff0e7" translate="yes" xml:space="preserve">
          <source>The translation is carefully crafted to make bang patterns meaningful for recursive and polymorphic bindings as well as straightforward non-recursive bindings.</source>
          <target state="translated">Перевод выполнен с особой тщательностью,с тем чтобы сделать взбалтывание значимым для рекурсивных и полиморфных переплетов,а также для простых не рекурсивных переплетов.</target>
        </trans-unit>
        <trans-unit id="ebea5cebfd88bea17758c13e86ea6a4d0e1d2c76" translate="yes" xml:space="preserve">
          <source>The translation of such forms uses the &lt;code&gt;loop&lt;/code&gt; combinator, so the arrow concerned must belong to the &lt;code&gt;ArrowLoop&lt;/code&gt; class.</source>
          <target state="translated">При переводе таких форм используется комбинатор &lt;code&gt;loop&lt;/code&gt; , поэтому &lt;code&gt;ArrowLoop&lt;/code&gt; стрелка должна принадлежать классу ArrowLoop .</target>
        </trans-unit>
        <trans-unit id="dfd95fc9633151cbaf9c86c13c1e83646b8ce5db" translate="yes" xml:space="preserve">
          <source>The trivial monad transformer, which maps a monad to an equivalent monad.</source>
          <target state="translated">Тривиальный трансформатор монады,который сопоставляет монаду с эквивалентной монадой.</target>
        </trans-unit>
        <trans-unit id="cf37054a4b01f1fddda009bf4a01c4e8cca69192" translate="yes" xml:space="preserve">
          <source>The trouble with orphans is that GHC must pro-actively read the interface files for all orphan modules, just in case their instances or rules play a role, whether or not the module&amp;rsquo;s interface would otherwise be of any use. See &lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;Orphan modules and instance declarations&lt;/a&gt; for details.</source>
          <target state="translated">Проблема с &amp;laquo;сиротами&amp;raquo; заключается в том, что GHC должен активно читать файлы интерфейса для всех &amp;laquo;сиротских&amp;raquo; модулей, на всякий случай, если их экземпляры или правила играют роль, независимо от того, был бы в противном случае полезен интерфейс модуля. См. Подробности в &lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;описании модулей-сирот и объявлений экземпляров&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd2fc9c6f6439ffd8e46493e079adf0e00b62d37" translate="yes" xml:space="preserve">
          <source>The two are treated identically, except that the latter may bring type variables into scope (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;).</source>
          <target state="translated">Оба обрабатываются идентично, за исключением того, что последний может вводить переменные типа в область видимости (см. &lt;a href=&quot;#scoped-type-variables&quot;&gt;Переменные типа с лексической областью видимости&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3e1a8fe74af6e6a8cdd2677c908de8ccfe0c2eeb" translate="yes" xml:space="preserve">
          <source>The two constructors have the types you&amp;rsquo;d expect:</source>
          <target state="translated">У двух конструкторов есть ожидаемые типы:</target>
        </trans-unit>
        <trans-unit id="bf5989a27408738db3d0883d648567d3eb763546" translate="yes" xml:space="preserve">
          <source>The two functions &lt;code&gt;comp1&lt;/code&gt; and &lt;code&gt;comp2&lt;/code&gt; have the same semantics, but &lt;code&gt;comp1&lt;/code&gt; will be inlined when applied to &lt;em&gt;two&lt;/em&gt; arguments, while &lt;code&gt;comp2&lt;/code&gt; requires &lt;em&gt;three&lt;/em&gt;. This might make a big difference if you say</source>
          <target state="translated">Две функции &lt;code&gt;comp1&lt;/code&gt; и &lt;code&gt;comp2&lt;/code&gt; имеют одинаковую семантику, но &lt;code&gt;comp1&lt;/code&gt; будет встроен при применении к &lt;em&gt;двум&lt;/em&gt; аргументам, а &lt;code&gt;comp2&lt;/code&gt; требует &lt;em&gt;трех&lt;/em&gt; . Это может иметь большое значение, если вы скажете</target>
        </trans-unit>
        <trans-unit id="fba374fd5b03a3d47d674283e790f74d219af40d" translate="yes" xml:space="preserve">
          <source>The two sets of options are initialised as follows. First, both sets of options are initialised as described in &lt;a href=&quot;#ghci-dot-files&quot;&gt;The .ghci and .haskeline files&lt;/a&gt;. Then the interactive options are modified as follows:</source>
          <target state="translated">Два набора параметров инициализируются следующим образом. Сначала инициализируются оба набора параметров, как описано в &lt;a href=&quot;#ghci-dot-files&quot;&gt;файлах .ghci и .haskeline&lt;/a&gt; . Затем интерактивные параметры изменяются следующим образом:</target>
        </trans-unit>
        <trans-unit id="4f082e0361fdf6edb4a33604e967da5739b7056c" translate="yes" xml:space="preserve">
          <source>The two sets of options can be inspected using the &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; commands respectively, with no arguments. For example, in a clean GHCi session we might see something like this:</source>
          <target state="translated">Два набора параметров можно проверить с помощью команд &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt; соответственно, без аргументов. Например, в чистой сессии GHCi мы можем увидеть что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="7caf43f8ce0ab145605d6b69de0c3897baa9da80" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is the type of values which can be either a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, and the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; - это тип значений, который может быть либо &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , либо &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; . Конструктор &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; можно использовать только для &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; s, а конструктор &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; можно использовать только для &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ed78adfe8300c790978c92161f3422d92e969883" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; представляет ссылки на объекты, которые поддерживаются на иностранном языке, т. Е. Не являются частью структур данных, обычно управляемых менеджером хранилища Haskell. Существенное различие между &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; s и обычными ссылками на память типа &lt;code&gt;Ptr a&lt;/code&gt; состоит в том, что первые могут быть связаны с &lt;em&gt;финализаторами&lt;/em&gt; . Финализатор - это процедура, которая вызывается, когда диспетчер хранилища Haskell обнаруживает, что в куче и стеке Haskell больше не осталось ссылок, указывающих на &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; . Обычно финализатор затем вызывает подпрограммы на иностранном языке, которые освобождают ресурсы, связанные с посторонним объектом.</target>
        </trans-unit>
        <trans-unit id="419ee8e65889bcd48fbc5fc15fe89139aefad4e4" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; представляет ссылки на объекты, которые поддерживаются на иностранном языке, т. Е. Не являются частью структур данных, обычно управляемых менеджером хранилища Haskell. Существенное различие между &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; s и обычными ссылками на память типа &lt;code&gt;Ptr a&lt;/code&gt; состоит в том, что первые могут быть связаны с &lt;em&gt;финализаторами&lt;/em&gt; . Финализатор - это процедура, которая вызывается, когда диспетчер хранилища Haskell обнаруживает, что в куче и стеке Haskell больше не осталось ссылок, указывающих на &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; . Обычно финализатор затем вызывает подпрограммы на иностранном языке, которые освобождают ресурсы, связанные с посторонним объектом.</target>
        </trans-unit>
        <trans-unit id="1f1f3e2498fc3dc454f35f0c13d62c79ebcfbca7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; представляет ссылки на объекты, которые поддерживаются на иностранном языке, т. Е. Не являются частью структур данных, обычно управляемых менеджером хранилища Haskell. Существенное различие между &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; s и обычными ссылками на память типа &lt;code&gt;Ptr a&lt;/code&gt; состоит в том, что первые могут быть связаны с &lt;em&gt;финализаторами&lt;/em&gt; . Финализатор - это процедура, которая вызывается, когда диспетчер хранилища Haskell обнаруживает, что в куче и стеке Haskell больше не осталось ссылок, указывающих на &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; . Обычно финализатор затем вызывает подпрограммы на иностранном языке, которые освобождают ресурсы, связанные с посторонним объектом.</target>
        </trans-unit>
        <trans-unit id="4d4f963e4969ef845301b6512e9387a803cf233d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is the type of values which can be either a &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, and the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; - это тип значений, который может быть либо &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , либо &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; . Конструктор &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; можно использовать только для &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; s, а конструктор &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; можно использовать только для &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="66ab93edaefb73f810fbe09019f9b02482d161f1" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Simple&lt;/code&gt; has its parameter at role representational, which is generally the most common case. &lt;code&gt;Simple Age&lt;/code&gt; would have the same representation as &lt;code&gt;Simple Int&lt;/code&gt;. The type &lt;code&gt;Complex&lt;/code&gt;, on the other hand, has its parameter at role nominal, because &lt;code&gt;Complex Age&lt;/code&gt; and &lt;code&gt;Complex Int&lt;/code&gt; are &lt;em&gt;not&lt;/em&gt; the same. Lastly, &lt;code&gt;Phant Age&lt;/code&gt; and &lt;code&gt;Phant Bool&lt;/code&gt; have the same representation, even though &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Bool&lt;/code&gt; are unrelated.</source>
          <target state="translated">Тип &lt;code&gt;Simple&lt;/code&gt; имеет свой параметр в ролевом представлении, что обычно является наиболее распространенным случаем. &lt;code&gt;Simple Age&lt;/code&gt; будет иметь то же представление, что и &lt;code&gt;Simple Int&lt;/code&gt; . Тип &lt;code&gt;Complex&lt;/code&gt; , с другой стороны, имеет свой параметр в роли номинального, так как &lt;code&gt;Complex Age&lt;/code&gt; и &lt;code&gt;Complex Int&lt;/code&gt; являются &lt;em&gt;не&lt;/em&gt; то же самое. Наконец, &lt;code&gt;Phant Age&lt;/code&gt; и &lt;code&gt;Phant Bool&lt;/code&gt; имеют одинаковое представление, хотя &lt;code&gt;Age&lt;/code&gt; и &lt;code&gt;Bool&lt;/code&gt; не связаны между собой.</target>
        </trans-unit>
        <trans-unit id="3c4014baea40eec814c3def2f55ce0d628bbaefa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;StreamPermParser s st a&lt;/code&gt; denotes a permutation parser that, when converted by the &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt; function, parses &lt;code&gt;s&lt;/code&gt; streams with user state &lt;code&gt;st&lt;/code&gt; and returns a value of type &lt;code&gt;a&lt;/code&gt; on success.</source>
          <target state="translated">Тип &lt;code&gt;StreamPermParser s st a&lt;/code&gt; обозначает синтаксический анализатор перестановки, который при преобразовании функцией &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt; анализирует потоки &lt;code&gt;s&lt;/code&gt; с пользовательским состоянием &lt;code&gt;st&lt;/code&gt; и возвращает значение типа &lt;code&gt;a&lt;/code&gt; в случае успеха.</target>
        </trans-unit>
        <trans-unit id="c22ce23b8a65ad0bce0abd3a477d13efd3e09be5" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;a&lt;/code&gt; часто будет экземпляром класса &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; , который обеспечивает операции маршалинга. Однако это не существенно, и вы можете предоставить свои собственные операции для доступа к указателю. Например , вы могли бы написать небольшие внешние функции , чтобы получить или установить поля в C &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="370b7cbf7eb99c94429a5901c2c830ab76f33e79" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;a&lt;/code&gt; часто будет экземпляром класса &lt;code&gt;&lt;a href=&quot;foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; , который обеспечивает операции маршалинга. Однако это не существенно, и вы можете предоставить свои собственные операции для доступа к указателю. Например , вы могли бы написать небольшие внешние функции , чтобы получить или установить поля в C &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c3e2e4b4159097f9e4b78db1290fd9ab1184135" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;t&lt;/code&gt; is an arbitrary type.</source>
          <target state="translated">Тип &lt;code&gt;t&lt;/code&gt; - произвольный тип.</target>
        </trans-unit>
        <trans-unit id="ff3ca6f1e2f18d7218da226b719c5d115f82e6ca" translate="yes" xml:space="preserve">
          <source>The type checker sometimes displays a fragment of the type environment in error messages, but only up to some maximum number, set by this flag. Turning it off with &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; gives an unlimited number. Syntactically top-level bindings are also usually excluded (since they may be numerous), but &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; includes them too.</source>
          <target state="translated">Средство проверки типов иногда отображает фрагмент окружения типов в сообщениях об ошибках, но только до некоторого максимального числа, установленного этим флагом. Отключение с помощью &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; дает неограниченное количество. Синтаксически привязки верхнего уровня также обычно исключаются (поскольку их может быть много), но &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; включает их.</target>
        </trans-unit>
        <trans-unit id="a1736df80e93e16ffd674b3951d956f327a670ca" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Any&quot;&gt;Any&lt;/a&gt;&lt;/code&gt; is type to which you can unsafely coerce any lifted type, and back. More concretely, for a lifted type &lt;code&gt;t&lt;/code&gt; and value &lt;code&gt;x :: t&lt;/code&gt;, -- &lt;code&gt;unsafeCoerce (unsafeCoerce x :: Any) :: t&lt;/code&gt; is equivalent to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Конструктор типа &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Any&quot;&gt;Any&lt;/a&gt;&lt;/code&gt; - это тип, к которому вы можете небезопасно привести любой поднятый тип и обратно. Более конкретно, для &lt;code&gt;unsafeCoerce (unsafeCoerce x :: Any) :: t&lt;/code&gt; типа &lt;code&gt;t&lt;/code&gt; и значения &lt;code&gt;x :: t&lt;/code&gt; - unsafeCoerce (unsafeCoerce x :: Any) :: t эквивалентен &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea123257a3ea77501373eb40af6b37206703f285" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Конструктор типа &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; является вариантом &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="55d3829bd0947962c7f37d5290cf7fb9ebbb1e05" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;Proxy#&lt;/code&gt; is used to bear witness to some type variable. It's used when you want to pass around proxy values for doing things like modelling type applications. A &lt;code&gt;Proxy#&lt;/code&gt; is not only unboxed, it also has a polymorphic kind, and has no runtime representation, being totally free.</source>
          <target state="translated">Конструктор типа &lt;code&gt;Proxy#&lt;/code&gt; используется, чтобы свидетельствовать о некоторой переменной типа. Он используется, когда вы хотите передать значения прокси для таких вещей, как приложения для моделирования. &lt;code&gt;Proxy#&lt;/code&gt; не только распакованный, он также имеет полиморфный вид, и не имеет никакого представления во время выполнения, будучи совершенно свободным.</target>
        </trans-unit>
        <trans-unit id="56d9865b671376bed7c725718b4b3598bbdc080b" translate="yes" xml:space="preserve">
          <source>The type constructors &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; are all variants of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Все конструкторы типов &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; являются вариантами &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="427f7d138a9c24f5fd34b3ac2e117fbf5b6e9472" translate="yes" xml:space="preserve">
          <source>The type function &lt;code&gt;Item&lt;/code&gt; returns the type of items of the structure &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">Функция типа &lt;code&gt;Item&lt;/code&gt; возвращает тип элементов структуры &lt;code&gt;l&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8367a0b18542e7e434fc0f6304e749d0f89ce162" translate="yes" xml:space="preserve">
          <source>The type in a &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma can be any type that is less polymorphic than the type of the original function. In concrete terms, if the original function is &lt;code&gt;f&lt;/code&gt; then the pragma</source>
          <target state="translated">Тип в прагме &lt;code&gt;SPECIALIZE&lt;/code&gt; может быть любым типом, который менее полиморфен, чем тип исходной функции. Конкретно, если исходной функцией является &lt;code&gt;f&lt;/code&gt; , то прагма</target>
        </trans-unit>
        <trans-unit id="6a5c083af5b39446fdb74fc301ec9287b848c4cb" translate="yes" xml:space="preserve">
          <source>The type may contain a class context too, of course:</source>
          <target state="translated">Конечно,тип может содержать и контекст класса:</target>
        </trans-unit>
        <trans-unit id="f38fe9f69c2a95d7c4f30f267130d69388ac39b4" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is a headache, but operationally it is a simple generalisation of a list fold.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; - головная боль, но с практической точки зрения это простое обобщение свернутого списка.</target>
        </trans-unit>
        <trans-unit id="67ce2acf5b412fb046750a70729d01c5751bba50" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;elem&lt;/code&gt; is illegal in Haskell 98, because it contains the constraint &lt;code&gt;Eq a&lt;/code&gt;, which constrains only the class type variable (in this case &lt;code&gt;a&lt;/code&gt;). this case &lt;code&gt;a&lt;/code&gt;). More precisely, a constraint in a class method signature is rejected if</source>
          <target state="translated">Тип &lt;code&gt;elem&lt;/code&gt; недопустим в Haskell 98, потому что он содержит ограничение &lt;code&gt;Eq a&lt;/code&gt; , которое ограничивает только переменную типа класса (в данном случае &lt;code&gt;a&lt;/code&gt; ). в этом случае &lt;code&gt;a&lt;/code&gt; ). Точнее, ограничение в сигнатуре метода класса отклоняется, если</target>
        </trans-unit>
        <trans-unit id="f45425f3fa8bef6aae90934b75c4fbd7b74b6954" translate="yes" xml:space="preserve">
          <source>The type of any free variable mentioned in any of the &lt;code&gt;case&lt;/code&gt; alternatives must be rigid.</source>
          <target state="translated">Тип любой свободной переменной, упомянутой в любом из вариантов &lt;code&gt;case&lt;/code&gt; должен быть жестким.</target>
        </trans-unit>
        <trans-unit id="745bb7ba75f0f40b920b56af8d91fc7035fd3d5d" translate="yes" xml:space="preserve">
          <source>The type of immutable non-strict (boxed) arrays with indices in &lt;code&gt;i&lt;/code&gt; and elements in &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">Тип неизменяемых нестрогих (упакованных) массивов с индексами в &lt;code&gt;i&lt;/code&gt; и элементами в &lt;code&gt;e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="635ffd579754d6af7e5c946097cca0d521883477" translate="yes" xml:space="preserve">
          <source>The type of non-empty streams</source>
          <target state="translated">Тип непустых потоков</target>
        </trans-unit>
        <trans-unit id="baf7178ecc15f8f15e23e50e1c918ba63de7aef2" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;enum&lt;/code&gt; method is &lt;code&gt;[a]&lt;/code&gt;, and this is also the type of the default method. You can lift this restriction and give another type to the default method using the extension &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;. For instance, if you have written a generic implementation of enumeration in a class &lt;code&gt;GEnum&lt;/code&gt; with method &lt;code&gt;genum&lt;/code&gt; in terms of &lt;code&gt;GHC.Generics&lt;/code&gt;, you can specify a default method that uses that generic implementation:</source>
          <target state="translated">Тип метода &lt;code&gt;enum&lt;/code&gt; - &lt;code&gt;[a]&lt;/code&gt; , и это также тип метода по умолчанию. Вы можете снять это ограничение и присвоить другой тип методу по умолчанию, используя расширение &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt; . Например, если вы написали универсальную реализацию перечисления в классе &lt;code&gt;GEnum&lt;/code&gt; с методом &lt;code&gt;genum&lt;/code&gt; в терминах &lt;code&gt;GHC.Generics&lt;/code&gt; , вы можете указать метод по умолчанию, который использует эту универсальную реализацию:</target>
        </trans-unit>
        <trans-unit id="5a6d2b6921b02fa113109fd505bf3ca7ae784ac9" translate="yes" xml:space="preserve">
          <source>The type of the argument can, as usual, be more general than the type required, as &lt;code&gt;(MkSwizzle reverse)&lt;/code&gt; shows. (&lt;code&gt;reverse&lt;/code&gt; does not need the &lt;code&gt;Ord&lt;/code&gt; constraint.)</source>
          <target state="translated">Тип аргумента, как обычно, может быть более общим, чем требуемый тип, как показывает &lt;code&gt;(MkSwizzle reverse)&lt;/code&gt; . ( &lt;code&gt;reverse&lt;/code&gt; не требует ограничения &lt;code&gt;Ord&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="a3cd0d91471726689bc984c8ebae6cee3ed30fb7" translate="yes" xml:space="preserve">
          <source>The type of the entire &lt;code&gt;case&lt;/code&gt; expression must be rigid.</source>
          <target state="translated">Тип всего &lt;code&gt;case&lt;/code&gt; - выражения должен быть жестким.</target>
        </trans-unit>
        <trans-unit id="2dd2e80c536cca089cdcb5a70cf104cd60ae01b1" translate="yes" xml:space="preserve">
          <source>The type of the expression being updated will not be inferred, and no constraint-solving will be performed, so the following will be rejected as ambiguous:</source>
          <target state="translated">Тип обновляемого выражения не будет выведен,и не будет выполняться решение ограничений,поэтому следующее будет отклонено как двусмысленное:</target>
        </trans-unit>
        <trans-unit id="3a2054583d66d61226f35d028b4a26f1b1f3dc5b" translate="yes" xml:space="preserve">
          <source>The type of the object must be an instance of &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, which ensures that only monomorphically-typed objects may be converted to &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt;. To convert a polymorphic object into &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt;, give it a monomorphic type signature. For example:</source>
          <target state="translated">Тип объекта должен быть экземпляром &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; , что гарантирует, что только мономорфно типизированные объекты могут быть преобразованы в &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; . Чтобы преобразовать полиморфный объект в &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; , присвойте ему сигнатуру мономорфного типа. Например:</target>
        </trans-unit>
        <trans-unit id="459ed51d92aa384f112f0d4508119aa781e99a11" translate="yes" xml:space="preserve">
          <source>The type of the record that holds lexical parsers that work on &lt;code&gt;s&lt;/code&gt; streams with state &lt;code&gt;u&lt;/code&gt; over a monad &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">Тип записи, содержащей лексические анализаторы, работающие с &lt;code&gt;s&lt;/code&gt; потоками с состоянием &lt;code&gt;u&lt;/code&gt; над монадой &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a771e46469f4ad150a88bc265d7240c0b42178a7" translate="yes" xml:space="preserve">
          <source>The type of the scrutinee must be rigid.</source>
          <target state="translated">Тип проверяемого должен быть жестким.</target>
        </trans-unit>
        <trans-unit id="979bbf6913a49836de61dced0e41ea9872ed2cf7" translate="yes" xml:space="preserve">
          <source>The type parameter &lt;code&gt;c_m&lt;/code&gt; occurs once in each of the type variables of &lt;code&gt;T1&lt;/code&gt; through &lt;code&gt;Tk&lt;/code&gt;. Imagine a class where this condition didn&amp;rsquo;t hold. For example:</source>
          <target state="translated">Параметр типа &lt;code&gt;c_m&lt;/code&gt; встречается один раз в каждой из переменных типа от &lt;code&gt;T1&lt;/code&gt; до &lt;code&gt;Tk&lt;/code&gt; . Представьте себе класс, в котором это условие не выполняется. Например:</target>
        </trans-unit>
        <trans-unit id="d8d7616108b7358a6ff7d651d02802bd3f54a508" translate="yes" xml:space="preserve">
          <source>The type parameter should be an instance of &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Параметр типа должен быть экземпляром &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72be687a9472d52b3ba6b265c8d95d06ffd98dec" translate="yes" xml:space="preserve">
          <source>The type parameters must all be type variables, of course, and some (but not necessarily all) of then can be the class parameters. Each class parameter may only be used at most once per associated type, but some may be omitted and they may be in an order other than in the class head. Hence, the following contrived example is admissible:</source>
          <target state="translated">Конечно,все параметры типа должны быть переменными типа,а некоторые (но не обязательно все)из них могут быть параметрами класса.Каждый параметр класса может быть использован не более одного раза для каждого ассоциированного типа,но некоторые из них могут быть опущены,и они могут быть в порядке,отличном от головы класса.Следовательно,допустимым является следующий надуманный пример:</target>
        </trans-unit>
        <trans-unit id="e48ed805d22716f6596791f0192736bc9bd803b6" translate="yes" xml:space="preserve">
          <source>The type patterns in this pair equal if &lt;code&gt;x&lt;/code&gt; is replaced by an infinite nesting of lists. Rejecting instances such as these is necessary for type soundness.</source>
          <target state="translated">Образцы типов в этой паре равны, если &lt;code&gt;x&lt;/code&gt; заменяется бесконечной вложенностью списков. Отклонение таких экземпляров необходимо для правильности типа.</target>
        </trans-unit>
        <trans-unit id="851ffb061ccd0ba4140a0e2aced43cb02b2b4642" translate="yes" xml:space="preserve">
          <source>The type signature for &lt;code&gt;f&lt;/code&gt; brings the type variable &lt;code&gt;a&lt;/code&gt; into scope, because of the explicit &lt;code&gt;forall&lt;/code&gt; (&lt;a href=&quot;#decl-type-sigs&quot;&gt;Declaration type signatures&lt;/a&gt;). The type variables bound by a &lt;code&gt;forall&lt;/code&gt; scope over the entire definition of the accompanying value declaration. In this example, the type variable &lt;code&gt;a&lt;/code&gt; scopes over the whole definition of &lt;code&gt;f&lt;/code&gt;, including over the type signature for &lt;code&gt;ys&lt;/code&gt;. In Haskell 98 it is not possible to declare a type for &lt;code&gt;ys&lt;/code&gt;; a major benefit of scoped type variables is that it becomes possible to do so.</source>
          <target state="translated">Сигнатура типа для &lt;code&gt;f&lt;/code&gt; переносит переменную типа &lt;code&gt;a&lt;/code&gt; в область видимости из-за явного &lt;code&gt;forall&lt;/code&gt; ( &lt;a href=&quot;#decl-type-sigs&quot;&gt;сигнатуры типа объявления&lt;/a&gt; ). Переменный типа связанного между собой &lt;code&gt;forall&lt;/code&gt; объемом по всему определению декларации сопровождающего значения. В этом примере переменная типа &lt;code&gt;a&lt;/code&gt; охватывает все определение &lt;code&gt;f&lt;/code&gt; , включая сигнатуру типа для &lt;code&gt;ys&lt;/code&gt; . В Haskell 98 невозможно объявить тип для &lt;code&gt;ys&lt;/code&gt; ; Основное преимущество переменных с ограниченным типом состоит в том, что это становится возможным.</target>
        </trans-unit>
        <trans-unit id="7656da70988a168a35816a1e6dfaeeb97ff1256b" translate="yes" xml:space="preserve">
          <source>The type signature for a default method of a type class must take on the same form as the corresponding main method&amp;rsquo;s type signature. Otherwise, the typechecker will reject that class&amp;rsquo;s definition. By &amp;ldquo;take on the same form&amp;rdquo;, we mean that the default type signature should differ from the main type signature only in their contexts. Therefore, if you have a method &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">Сигнатура типа для метода по умолчанию класса типа должна иметь ту же форму, что и сигнатура типа соответствующего основного метода. В противном случае проверка типов отклонит определение этого класса. Под &amp;laquo;принятием той же формы&amp;raquo; мы подразумеваем, что сигнатура типа по умолчанию должна отличаться от сигнатуры основного типа только в их контексте. Поэтому, если у вас есть &lt;code&gt;bar&lt;/code&gt; методов :</target>
        </trans-unit>
        <trans-unit id="71f24ac949ca33b38012525ec9dbb7d664ab057c" translate="yes" xml:space="preserve">
          <source>The type signature in the instance declaration must be more polymorphic than (or the same as) the one in the class declaration, instantiated with the instance type. For example, this is fine:</source>
          <target state="translated">Подпись типа в объявлении экземпляра должна быть более полиморфной,чем подпись в объявлении класса,инстанцированная на тип экземпляра.Например,это нормально:</target>
        </trans-unit>
        <trans-unit id="7f2cb1a90a9b0995252c7b308eee2ab22f083907" translate="yes" xml:space="preserve">
          <source>The type signature may have quantified type variables that do not appear in the result type:</source>
          <target state="translated">Подпись типа может иметь количественные переменные типа,которые не отображаются в типе результата:</target>
        </trans-unit>
        <trans-unit id="0066bd7c09b1311eefbd05fc74e2a7e0fdcf2cfb" translate="yes" xml:space="preserve">
          <source>The type signature of &lt;code&gt;isPrime&lt;/code&gt; informs users that its correctness depends on an unproven conjecture. If the function is used, the user has to acknowledge the dependence with:</source>
          <target state="translated">Сигнатура типа &lt;code&gt;isPrime&lt;/code&gt; сообщает пользователям, что ее правильность зависит от недоказанной гипотезы. Если функция используется, пользователь должен подтвердить зависимость с помощью:</target>
        </trans-unit>
        <trans-unit id="6889d9f64b4cea7008114f032c7565a988347b9d" translate="yes" xml:space="preserve">
          <source>The type signature of each constructor is independent, and is implicitly universally quantified as usual. In particular, the type variable(s) in the &amp;ldquo;&lt;code&gt;data T a where&lt;/code&gt;&amp;rdquo; header have no scope, and different constructors may have different universally-quantified type variables:</source>
          <target state="translated">Сигнатура типа каждого конструктора независима и, как обычно, неявно универсально определяется количественно. В частности, переменные типа в заголовке &amp;laquo; &lt;code&gt;data T a where&lt;/code&gt; &amp;raquo; не имеют области видимости, и разные конструкторы могут иметь разные переменные типа с универсальной количественной оценкой:</target>
        </trans-unit>
        <trans-unit id="534c19947f6b057574c6c2246010e8ba73a4eab7" translate="yes" xml:space="preserve">
          <source>The type used for sizes and sizeBounds of sizes.</source>
          <target state="translated">Тип,используемый для размеров и размеровГраницы размеров.</target>
        </trans-unit>
        <trans-unit id="43178326dfa4ad1ed29dea64db5e0736803b9188" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;a&lt;/code&gt; appears in no other constraints</source>
          <target state="translated">Переменная типа &lt;code&gt;a&lt;/code&gt; не фигурирует ни в каких других ограничениях.</target>
        </trans-unit>
        <trans-unit id="b4943498fbb77950d71e01bb410d131c2809b43c" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;e&lt;/code&gt; used here represents the element type, while &lt;code&gt;ce&lt;/code&gt; is the type of the container itself. Within this framework, we might want to define instances of this class for lists or characteristic functions (both of which can be used to represent collections of any equality type), bit sets (which can be used to represent collections of characters), or hash tables (which can be used to represent any collection whose elements have a hash function). Omitting standard implementation details, this would lead to the following declarations:</source>
          <target state="translated">Используемая здесь переменная типа &lt;code&gt;e&lt;/code&gt; представляет тип элемента, а &lt;code&gt;ce&lt;/code&gt; - тип самого контейнера. В рамках этой структуры мы можем захотеть определить экземпляры этого класса для списков или характеристических функций (обе из которых могут использоваться для представления коллекций любого типа равенства), наборов битов (которые могут использоваться для представления коллекций символов) или хеш-функции. таблицы (которые можно использовать для представления любой коллекции, элементы которой имеют хеш-функцию). Если опустить стандартные детали реализации, это приведет к следующим объявлениям:</target>
        </trans-unit>
        <trans-unit id="1c38092768f402e22883de13c0c16e8f30763372" translate="yes" xml:space="preserve">
          <source>The type variable is quantified by the single, syntactically visible, outermost &lt;code&gt;forall&lt;/code&gt; of the type signature. For example, GHC will reject all of the following examples:</source>
          <target state="translated">Типа переменный количественно с помощью одного, синтаксический видимой, внешней &lt;code&gt;forall&lt;/code&gt; от типа подписи. Например, GHC отклонит все следующие примеры:</target>
        </trans-unit>
        <trans-unit id="d1965a58b0782ba3ba393196ffb0b2c45422203a" translate="yes" xml:space="preserve">
          <source>The type variables (if given) may be explicitly kinded, so we could also write the header for &lt;code&gt;Foo&lt;/code&gt; like this:</source>
          <target state="translated">Переменные типа (если они указаны) могут быть явно видны, поэтому мы также можем написать заголовок для &lt;code&gt;Foo&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="635b4f657c280b661bdb956cc7379ca577a5dd9a" translate="yes" xml:space="preserve">
          <source>The type variables &lt;code&gt;vk+1...vn&lt;/code&gt; do not occur in the types &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;s1..sk&lt;/code&gt;, or &lt;code&gt;t1..tj&lt;/code&gt;.</source>
          <target state="translated">Переменные типа &lt;code&gt;vk+1...vn&lt;/code&gt; не встречаются в типах &lt;code&gt;t&lt;/code&gt; , &lt;code&gt;s1..sk&lt;/code&gt; или &lt;code&gt;t1..tj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0367b19eac21df607dd1a0c03766f0d72dc00eb4" translate="yes" xml:space="preserve">
          <source>The type variables in the head of a &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;instance&lt;/code&gt; declaration scope over the methods defined in the &lt;code&gt;where&lt;/code&gt; part. You do not even need an explicit &lt;code&gt;forall&lt;/code&gt; (although you are allowed an explicit &lt;code&gt;forall&lt;/code&gt; in an &lt;code&gt;instance&lt;/code&gt; declaration; see &lt;a href=&quot;#explicit-foralls&quot;&gt;Explicit universal quantification (forall)&lt;/a&gt;). For example:</source>
          <target state="translated">Переменные типа в заголовке области объявления &lt;code&gt;class&lt;/code&gt; или &lt;code&gt;instance&lt;/code&gt; над методами, определенными в части &lt;code&gt;where&lt;/code&gt; . Вам даже не требуется явный &lt;code&gt;forall&lt;/code&gt; (хотя вам разрешено явное &lt;code&gt;forall&lt;/code&gt; в объявлении &lt;code&gt;instance&lt;/code&gt; ; см. &lt;a href=&quot;#explicit-foralls&quot;&gt;Явное универсальное количественное определение (forall)&lt;/a&gt; ). Например:</target>
        </trans-unit>
        <trans-unit id="af20cee98cf274e2f035d875bbac735384b7ac2d" translate="yes" xml:space="preserve">
          <source>The type variables on the right hand side of the type family equation must, as usual, be explicitly bound by the left hand side. This restriction is relaxed for &lt;em&gt;kind&lt;/em&gt; variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound. For example, these are legitimate:</source>
          <target state="translated">Переменные типа в правой части уравнения семейства типов, как обычно, должны быть явно связаны с левой частью. Это ограничение смягчается для &lt;em&gt;рода&lt;/em&gt; переменных, однако, как правая рука разрешается упоминать рода переменные, которые неявно связанные. Например, это законные:</target>
        </trans-unit>
        <trans-unit id="84e64daabc652df729898a89399f171ba5fb963f" translate="yes" xml:space="preserve">
          <source>The type variables: &lt;code&gt;a b ..&lt;/code&gt;</source>
          <target state="translated">Переменные типа: &lt;code&gt;a b ..&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3336a5e221e837a924af361dde3fa8fafd4e883" translate="yes" xml:space="preserve">
          <source>The type-level equivalent of &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эквивалент &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; уровне типа .</target>
        </trans-unit>
        <trans-unit id="51833098f3f8dc039531765e941df75d867dbd6d" translate="yes" xml:space="preserve">
          <source>The type-safe cast operation</source>
          <target state="translated">Тип-безопасная литая операция</target>
        </trans-unit>
        <trans-unit id="587a72d06270d5ada9648f212a80e7c9f1025cdd" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;, the classes &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; and casting between Word32 and Float and Word64 and Double.</source>
          <target state="translated">Типы &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; , классы &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-float#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; и приведение типов между Word32 и Float и Word64 и Double.</target>
        </trans-unit>
        <trans-unit id="41579a31faecdff7eb564e18d1f5224721d9b9c2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S&quot;&gt;S&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C&quot;&gt;C&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D&quot;&gt;D&lt;/a&gt;&lt;/code&gt; are once again type-level proxies, just used to create several variants of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Типы &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S&quot;&gt;S&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C&quot;&gt;C&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D&quot;&gt;D&lt;/a&gt;&lt;/code&gt; снова являются прокси-серверами уровня типа, использованными для создания нескольких вариантов &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e810d6a26e49cbbb2492c272a8362cc5c02deb2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt;, and the classes &lt;code&gt;&lt;a href=&quot;ghc-real#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-real#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Типы &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-real#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; , а также классы &lt;code&gt;&lt;a href=&quot;ghc-real#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-real#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48ea1d3d0cd4b9a0ed9e5c243628ebffae4d7214" translate="yes" xml:space="preserve">
          <source>The types alone do not enforce these laws, so you'll have to check them yourself.</source>
          <target state="translated">Типы сами по себе не соблюдают эти законы,так что вам придется проверить их самому.</target>
        </trans-unit>
        <trans-unit id="a0cd438c82f2c05948aa7d6cb52d631f7b43ae69" translate="yes" xml:space="preserve">
          <source>The types of the additional holes in refinement hole fits are displayed in the output, e.g. &lt;code&gt;foldl1 (_ :: a -&amp;gt; a -&amp;gt; a)&lt;/code&gt; is a refinement for the hole &lt;code&gt;_ :: [a] -&amp;gt; a&lt;/code&gt;. If this flag is toggled off, the output will display only &lt;code&gt;foldl1 _&lt;/code&gt;, which can be used as a direct replacement for the hole, without requiring &lt;code&gt;-XScopedTypeVariables&lt;/code&gt;.</source>
          <target state="translated">Типы дополнительных отверстий в уточнении отверстий отображаются в выходных данных, например, &lt;code&gt;foldl1 (_ :: a -&amp;gt; a -&amp;gt; a)&lt;/code&gt; - это уточнение для отверстия &lt;code&gt;_ :: [a] -&amp;gt; a&lt;/code&gt; . Если этот флаг выключен, на выходе будет отображаться только &lt;code&gt;foldl1 _&lt;/code&gt; , которую можно использовать как прямую замену дыры, не требуя &lt;code&gt;-XScopedTypeVariables&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e436a3cd3a5f7288599b9dc44ff4a6cead76bb9b" translate="yes" xml:space="preserve">
          <source>The typical use of unboxed tuples is simply to return multiple values, binding those multiple results with a &lt;code&gt;case&lt;/code&gt; expression, thus:</source>
          <target state="translated">Типичное использование распакованных кортежей - просто возвращать несколько значений, связывая эти несколько результатов с помощью выражения &lt;code&gt;case&lt;/code&gt; , таким образом:</target>
        </trans-unit>
        <trans-unit id="83c5520bf61af07b81095eddaa98572a93badb2f" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation.</source>
          <target state="translated">Объединение списка карт,с комбинированной операцией.</target>
        </trans-unit>
        <trans-unit id="b23e039e05803f1d435b095a3be2c2ad316fc53b" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Объединение списка карт с помощью операции объединения: ( &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9719fd151f851952631d41cb987f9951e7aa35cd" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Объединение списка карт с помощью операции объединения: ( &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a6d65bd708163831054fd39465f70221e9e5ae24" translate="yes" xml:space="preserve">
          <source>The union of a list of maps.</source>
          <target state="translated">Объединение списка карт.</target>
        </trans-unit>
        <trans-unit id="0eef324f1a749e58701da2776b9ed04269a8f3da" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Объединение списка карт: ( &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f822cc3b31dd5e47c32c226b0091a2baecc772ee" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Объединение списка карт: ( &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="79b141fce6e886ba88eb4e367332c9cfb39cd808" translate="yes" xml:space="preserve">
          <source>The union of a list of sets.</source>
          <target state="translated">Объединение списков.</target>
        </trans-unit>
        <trans-unit id="a0436ce0333db453178d1bb27860d26164bc30d6" translate="yes" xml:space="preserve">
          <source>The union of the sets in a Foldable structure : (&lt;code&gt;&lt;a href=&quot;data-set#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-set#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Объединение множеств в складную структуру: ( &lt;code&gt;&lt;a href=&quot;data-set#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-set#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="84d32e19c18412fa13a69a4d3cce159a043b6669" translate="yes" xml:space="preserve">
          <source>The unique numeric ID for this group (gr_gid)</source>
          <target state="translated">Уникальный цифровой идентификатор для этой группы (gr_gid)</target>
        </trans-unit>
        <trans-unit id="212144f380f03e225a7d36c34f05e2ff45aba6e6" translate="yes" xml:space="preserve">
          <source>The unit type &lt;code&gt;()&lt;/code&gt; and the list type &lt;code&gt;[]&lt;/code&gt; are added to the start of the standard list of types which are tried when doing type defaulting.</source>
          <target state="translated">Тип единицы &lt;code&gt;()&lt;/code&gt; и тип списка &lt;code&gt;[]&lt;/code&gt; добавляются в начало стандартного списка типов, которые проверяются при выборе типа по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e05fd75092f26b39420e90105c4452458f344690" translate="yes" xml:space="preserve">
          <source>The unpackedness of a field as the user wrote it in the source code. For example, in the following data type:</source>
          <target state="translated">Распаковка поля,как пользователь написал его в исходном коде.Например,в следующем типе данных:</target>
        </trans-unit>
        <trans-unit id="bf60d2a5c5d09194c3ba4034c0529e6a606e32cc" translate="yes" xml:space="preserve">
          <source>The upshot of this is that if you have Haskell threads that are blocked in foreign calls, then &lt;code&gt;hs_exit()&lt;/code&gt; may hang (or possibly busy-wait) until the calls return. Therefore it&amp;rsquo;s a good idea to make sure you don&amp;rsquo;t have any such threads in the system when calling &lt;code&gt;hs_exit()&lt;/code&gt;. This includes any threads doing I/O, because I/O may (or may not, depending on the type of I/O and the platform) be implemented using blocking foreign calls.</source>
          <target state="translated">Результатом этого является то, что если у вас есть потоки Haskell, которые заблокированы во внешних вызовах, тогда &lt;code&gt;hs_exit()&lt;/code&gt; может зависнуть (или, возможно, занято-ждать), пока вызовы не вернутся. Поэтому при вызове &lt;code&gt;hs_exit()&lt;/code&gt; убедиться, что в системе нет таких потоков . Это включает в себя любые потоки, выполняющие ввод-вывод, потому что ввод-вывод может (или не может, в зависимости от типа ввода-вывода и платформы) быть реализован с использованием блокировки внешних вызовов.</target>
        </trans-unit>
        <trans-unit id="fd5ed5363995c4cea70a22ac737d595e21dc4544" translate="yes" xml:space="preserve">
          <source>The use of &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; to compile &lt;code&gt;Danger&lt;/code&gt; restricts the features of Haskell that can be used to a &lt;a href=&quot;#safe-language&quot;&gt;safe subset&lt;/a&gt;. This includes disallowing &lt;code&gt;unsafePerformIO&lt;/code&gt;, Template Haskell, pure FFI functions, RULES and restricting the operation of Overlapping Instances. The &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag also restricts the modules can be imported by &lt;code&gt;Danger&lt;/code&gt; to only those that are considered trusted. Trusted modules are those compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, where GHC provides a mechanical guarantee that the code is safe. Or those modules compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;, where the module author claims that the module is Safe.</source>
          <target state="translated">Использование &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; для компиляции &lt;code&gt;Danger&lt;/code&gt; ограничивает возможности Haskell, которые можно использовать, &lt;a href=&quot;#safe-language&quot;&gt;безопасным подмножеством&lt;/a&gt; . Это включает в себя &lt;code&gt;unsafePerformIO&lt;/code&gt; , Template Haskell, чистых функций FFI, ПРАВИЛ и ограничение работы перекрывающихся экземпляров. &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; флаг также ограничивает модули могут быть импортированы &lt;code&gt;Danger&lt;/code&gt; только те , которые считаются доверяли. Надежные модули - это модули, скомпилированные с помощью &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; , где GHC предоставляет механическую гарантию безопасности кода. Или те модули, которые скомпилированы с помощью &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; , где автор модуля утверждает, что модуль безопасен.</target>
        </trans-unit>
        <trans-unit id="76408d263ea83823caa29289a23caf377016849f" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;*&lt;/code&gt; to denote the kind of inhabited types relies on the &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; extension, which in a future release will be turned off by default and then possibly removed. The reasons for this and the deprecation schedule are described in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;GHC proposal #30&lt;/a&gt;.</source>
          <target state="translated">Использование &lt;code&gt;*&lt;/code&gt; для обозначения типов обитаемых типов зависит от расширения &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt; , которое в будущих выпусках будет отключено по умолчанию, а затем, возможно, удалено. Причины этого и график прекращения поддержки описаны в &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;предложении GHC № 30&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a443865b645e76d78a948d7d73f2496761df0274" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;?x&lt;/code&gt; in the binding for &lt;code&gt;?y&lt;/code&gt; does not &amp;ldquo;see&amp;rdquo; the binding for &lt;code&gt;?x&lt;/code&gt;, so the type of &lt;code&gt;f&lt;/code&gt; is</source>
          <target state="translated">Использование &lt;code&gt;?x&lt;/code&gt; в привязке для &lt;code&gt;?y&lt;/code&gt; не &amp;laquo;видит&amp;raquo; привязку для &lt;code&gt;?x&lt;/code&gt; , поэтому тип &lt;code&gt;f&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="6962747001f3e463de123d47ef1692d0e218a535" translate="yes" xml:space="preserve">
          <source>The use of this function is quite stylized - one imports the appropiate language definition and selects the lexical parsers that are needed from the resulting &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Использование этой функции довольно стилизовано - импортируется соответствующее определение языка и выбираются необходимые лексические анализаторы из результирующего &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2dbc79a4883471be7b0186b057046ae7dfdc1e0b" translate="yes" xml:space="preserve">
          <source>The use of this function is quite stylized - one imports the appropiate language definition and selects the lexical parsers that are needed from the resulting &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Использование этой функции довольно стилизовано - импортируется соответствующее определение языка и выбираются необходимые лексические анализаторы из результирующего &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26730cfbec649d68d217865bf13abfb7172eb1ff" translate="yes" xml:space="preserve">
          <source>The usefulness of cost-centre stacks is better demonstrated by modifying the example slightly:</source>
          <target state="translated">Полезность стоимостно-ориентированных стекол лучше продемонстрировать,слегка изменив пример:</target>
        </trans-unit>
        <trans-unit id="04516ad04a116cb6b3a9eecd21c1a49b5a9b220f" translate="yes" xml:space="preserve">
          <source>The user can optionally declare the desired &lt;a href=&quot;#deriving-stragies&quot;&gt;deriving strategy&lt;/a&gt;, especially if the compiler chooses the wrong one &lt;a href=&quot;#default-deriving-strategy&quot;&gt;by default&lt;/a&gt;.</source>
          <target state="translated">Пользователь может при желании объявить желаемую &lt;a href=&quot;#deriving-stragies&quot;&gt;стратегию вывода&lt;/a&gt; , особенно если компилятор &lt;a href=&quot;#default-deriving-strategy&quot;&gt;по умолчанию&lt;/a&gt; выбирает неправильную .</target>
        </trans-unit>
        <trans-unit id="2b6318421e47e29c50f821a4cb593213b3cf90b5" translate="yes" xml:space="preserve">
          <source>The user database</source>
          <target state="translated">База данных пользователей</target>
        </trans-unit>
        <trans-unit id="985a9c88151c387783de3c084f48215ba9fd8373" translate="yes" xml:space="preserve">
          <source>The usual output stream is &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;. For Windows GUI applications (that have no stderr) the output is directed to the Windows debug console. Some implementations of these functions may decorate the string that's output to indicate that you're tracing.</source>
          <target state="translated">Обычный выходной поток - &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; . Для приложений с графическим интерфейсом пользователя Windows (не имеющих stderr) вывод направляется в консоль отладки Windows. Некоторые реализации этих функций могут украшать выводимую строку, чтобы указать, что вы отслеживаете.</target>
        </trans-unit>
        <trans-unit id="5b635ec2e13718c809af8ad02bfe21b9ad380c51" translate="yes" xml:space="preserve">
          <source>The value at the given index in an array.</source>
          <target state="translated">Значение на данном индексе в массиве.</target>
        </trans-unit>
        <trans-unit id="46ea80b9df5d3660b22bccd45dcec6dcfc82dba3" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; (see &lt;a href=&quot;phases#c-pre-processor&quot;&gt;Options affecting the C pre-processor&lt;/a&gt;) for a major release &lt;code&gt;x.y.z&lt;/code&gt; is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example in version 6.8.2 of GHC we would have &lt;code&gt;__GLASGOW_HASKELL__==608&lt;/code&gt;).</source>
          <target state="translated">Значение &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; (см. &lt;a href=&quot;phases#c-pre-processor&quot;&gt;Параметры, влияющие на препроцессор C&lt;/a&gt; ) для основного выпуска &lt;code&gt;x.y.z&lt;/code&gt; - это целое число ⟨xyy⟩ (если y⟩ - однозначное число, то добавляется начальный ноль, так, например, в версии 6.8.2. GHC у нас будет &lt;code&gt;__GLASGOW_HASKELL__==608&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a9f2f912f328420400217d42f0703423875720dd" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; for a snapshot release is the integer ⟨xyy⟩. You should never write any conditional code which tests for this value, however: since interfaces change on a day-to-day basis, and we don&amp;rsquo;t have finer granularity in the values of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt;, you should only conditionally compile using predicates which test whether &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; is equal to, later than, or earlier than a given major release.</source>
          <target state="translated">Значение &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; для выпуска моментального снимка - целое число ⟨xyy⟩. Однако вам никогда не следует писать какой-либо условный код, который проверяет это значение: поскольку интерфейсы меняются ежедневно, и у нас нет более тонкой детализации в значениях &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; , вам следует только условно компилировать с использованием предикатов, которые проверяют является ли &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; равным, более поздним или более ранним, чем данный основной выпуск.</target>
        </trans-unit>
        <trans-unit id="88bc0b8a4e725cfca8629af95b9bfc3789cec929" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;seq a b&lt;/code&gt; is bottom if &lt;code&gt;a&lt;/code&gt; is bottom, and otherwise equal to &lt;code&gt;b&lt;/code&gt;. In other words, it evaluates the first argument &lt;code&gt;a&lt;/code&gt; to weak head normal form (WHNF). &lt;code&gt;seq&lt;/code&gt; is usually introduced to improve performance by avoiding unneeded laziness.</source>
          <target state="translated">Значение &lt;code&gt;seq a b&lt;/code&gt; равно bottom, если &lt;code&gt;a&lt;/code&gt; равно bottom, и в противном случае равно &lt;code&gt;b&lt;/code&gt; . Другими словами, он оценивает первый аргумент &lt;code&gt;a&lt;/code&gt; для слабой нормальной формы головы (WHNF). &lt;code&gt;seq&lt;/code&gt; обычно вводится для повышения производительности, избегая ненужной лени.</target>
        </trans-unit>
        <trans-unit id="b9ddf1473b8cefa80d18a48c0a819936c1f6abc1" translate="yes" xml:space="preserve">
          <source>The value of the GHC flag &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; at compile/link time.</source>
          <target state="translated">Значение флага GHC &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; во время компиляции / компоновки.</target>
        </trans-unit>
        <trans-unit id="16d740d7f1efaee618fc89b84be2bf2b95e0d2bb" translate="yes" xml:space="preserve">
          <source>The variable&amp;rsquo;s type is not polymorphic, is not &lt;code&gt;()&lt;/code&gt;, and is an instance of &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">Тип переменной не является полиморфным, не является &lt;code&gt;()&lt;/code&gt; и является экземпляром &lt;code&gt;Show&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0d33e4220ed576dc1b282f848ba5c762001d9e7" translate="yes" xml:space="preserve">
          <source>The variables in the left-hand side of the definition are bound by the pattern on the right-hand side. For bidirectional pattern synonyms, all the variables of the right-hand side must also occur on the left-hand side; also, wildcard patterns and view patterns are not allowed. For unidirectional and explicitly bidirectional pattern synonyms, there is no restriction on the right-hand side pattern.</source>
          <target state="translated">Переменные в левой части определения ограничены образцом с правой стороны.Для синонимов двунаправленных шаблонов все переменные в правой части также должны встречаться с левой стороны;кроме того,не допускается использование шаблонов подстановки и просмотр шаблонов.Для однонаправленных и явно двунаправленных синонимов нет никаких ограничений для правостороннего рисунка.</target>
        </trans-unit>
        <trans-unit id="44137130cdaca8e0c4502b29129e5daf2347a2a8" translate="yes" xml:space="preserve">
          <source>The variant (&amp;ldquo;way&amp;rdquo;) of the runtime. The most common values are &lt;code&gt;rts_v&lt;/code&gt; (vanilla), &lt;code&gt;rts_thr&lt;/code&gt; (threaded runtime, i.e. linked using the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option) and &lt;code&gt;rts_p&lt;/code&gt; (profiling runtime, i.e. linked using the &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option). Other variants include &lt;code&gt;debug&lt;/code&gt; (linked using &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt;&lt;code&gt;-debug&lt;/code&gt;&lt;/a&gt;), and &lt;code&gt;dyn&lt;/code&gt; (the RTS is linked in dynamically, i.e. a shared library, rather than statically linked into the executable itself). These can be combined, e.g. you might have &lt;code&gt;rts_thr_debug_p&lt;/code&gt;.</source>
          <target state="translated">Вариант (&amp;laquo;путь&amp;raquo;) исполнения. Наиболее распространенными значениями являются &lt;code&gt;rts_v&lt;/code&gt; (vanilla), &lt;code&gt;rts_thr&lt;/code&gt; (среда выполнения с &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; , т.е. связанная с использованием параметра -threaded ) и &lt;code&gt;rts_p&lt;/code&gt; (среда выполнения профилирования, т.е. связанная с использованием параметра &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; ). Другие варианты включают &lt;code&gt;debug&lt;/code&gt; (связана с использованием &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt; &lt;code&gt;-debug&lt;/code&gt; &lt;/a&gt; ) и &lt;code&gt;dyn&lt;/code&gt; (RTS подключается динамически, т. Е. Разделяемая библиотека, а не статически связана с самим исполняемым файлом). Их можно комбинировать, например, у вас может быть &lt;code&gt;rts_thr_debug_p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a8f2c46e457eee624cced1b694975c68f48a5a2" translate="yes" xml:space="preserve">
          <source>The various communicating processes need to aggree on the keys used to refer to the values in the Static Pointer Table, or lookups will fail. Only processes launched from the same program binary are guaranteed to use the same set of keys.</source>
          <target state="translated">Различные взаимодействующие процессы должны объединиться по клавишам,используемым для ссылки на значения в таблице статических указателей,иначе поиск завершится неудачей.Гарантируется,что только процессы,запущенные из одного и того же программного двоичного файла,будут использовать один и тот же набор ключей.</target>
        </trans-unit>
        <trans-unit id="5694e81946ac8e88f6e63d9e40df994b86b3e941" translate="yes" xml:space="preserve">
          <source>The version number of your copy of GHC can be found by invoking &lt;code&gt;ghc&lt;/code&gt; with the &lt;code&gt;--version&lt;/code&gt; flag (see &lt;a href=&quot;using#options-help&quot;&gt;Verbosity options&lt;/a&gt;).</source>
          <target state="translated">Номер версии вашей копии GHC можно узнать, вызвав &lt;code&gt;ghc&lt;/code&gt; с флагом &lt;code&gt;--version&lt;/code&gt; (см. &lt;a href=&quot;using#options-help&quot;&gt;Параметры подробности&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2e8aa9d1f5c524e0cde85db6f3babdf5d9554847" translate="yes" xml:space="preserve">
          <source>The version of &lt;code&gt;&lt;a href=&quot;system-info#v:compilerName&quot;&gt;compilerName&lt;/a&gt;&lt;/code&gt; with which the program was compiled or is being interpreted.</source>
          <target state="translated">Версия &lt;code&gt;&lt;a href=&quot;system-info#v:compilerName&quot;&gt;compilerName&lt;/a&gt;&lt;/code&gt; , с которой программа была скомпилирована или интерпретируется.</target>
        </trans-unit>
        <trans-unit id="bb35b8767806f1c86c957b959147f402a711b5a1" translate="yes" xml:space="preserve">
          <source>The version of GHC used to compile this program.</source>
          <target state="translated">Для компиляции этой программы использовалась версия GHC.</target>
        </trans-unit>
        <trans-unit id="93227c16b6d7c528eff0c93942527f094cd10bec" translate="yes" xml:space="preserve">
          <source>The vertices of a list of strongly connected components.</source>
          <target state="translated">Вершины списка сильно связанных компонентов.</target>
        </trans-unit>
        <trans-unit id="d6e05e606713f53ba7147a93b159172282b0b43c" translate="yes" xml:space="preserve">
          <source>The vertices of a strongly connected component.</source>
          <target state="translated">Вершины сильно связанного компонента.</target>
        </trans-unit>
        <trans-unit id="49a2297af6458fc2b5c07ab0b04fc8ce1dcc5198" translate="yes" xml:space="preserve">
          <source>The visibility of class parameters in the right-hand side of associated family instances depends &lt;em&gt;solely&lt;/em&gt; on the parameters of the family. As an example, consider the simple class declaration</source>
          <target state="translated">Видимость параметров класса в правой части связанных экземпляров семейства зависит &lt;em&gt;исключительно&lt;/em&gt; от параметров семейства. В качестве примера рассмотрим простое объявление класса</target>
        </trans-unit>
        <trans-unit id="7c87aaad206da2e888073ea427b97a0356ce2035" translate="yes" xml:space="preserve">
          <source>The warning &lt;a href=&quot;using-warnings#ghc-flag--Wdodgy-imports&quot;&gt;&lt;code&gt;-Wdodgy-imports&lt;/code&gt;&lt;/a&gt;, which is off by default but included with &lt;a href=&quot;using-warnings#ghc-flag--W&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt;, warns if you hide something that the imported module does not export.</source>
          <target state="translated">Предупреждение &lt;a href=&quot;using-warnings#ghc-flag--Wdodgy-imports&quot;&gt; &lt;code&gt;-Wdodgy-imports&lt;/code&gt; &lt;/a&gt; , которое по умолчанию отключено, но включено с &lt;a href=&quot;using-warnings#ghc-flag--W&quot;&gt; &lt;code&gt;-W&lt;/code&gt; &lt;/a&gt; , предупреждает, если вы скрываете что-то, что импортированный модуль не экспортирует.</target>
        </trans-unit>
        <trans-unit id="a03cd870af60a97e6c37efe987b7dd2cccef087d" translate="yes" xml:space="preserve">
          <source>The warning is suppressed for names beginning with an underscore. For example</source>
          <target state="translated">Предупреждение подавляется для имен,начинающихся с символа подчеркивания.Например</target>
        </trans-unit>
        <trans-unit id="aac2dafa10e3a823b7ded12b65eef4e083b63750" translate="yes" xml:space="preserve">
          <source>The warning is suppressed if the field name begins with an underscore.</source>
          <target state="translated">Предупреждение подавляется,если имя поля начинается с символа подчеркивания.</target>
        </trans-unit>
        <trans-unit id="09e93405f4f9b2ea4174a8ddd6b288e044b33e0d" translate="yes" xml:space="preserve">
          <source>The warning will indicate the duplicated &lt;code&gt;Eq a&lt;/code&gt; constraint.</source>
          <target state="translated">Предупреждение укажет на дублированный &lt;code&gt;Eq a&lt;/code&gt; ограничение.</target>
        </trans-unit>
        <trans-unit id="885ab10c1f8ab02131a671457c0e4e4f86d4a471" translate="yes" xml:space="preserve">
          <source>The warning will indicate the redundant &lt;code&gt;Eq a&lt;/code&gt; constraint: : it is not used by the definition of &lt;code&gt;f&lt;/code&gt;.)</source>
          <target state="translated">Предупреждение будет указывать на избыточное &lt;code&gt;Eq a&lt;/code&gt; ограничение:: оно не используется в определении &lt;code&gt;f&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="2c9ca978562d45408d7bbf41edbc42ac363df90f" translate="yes" xml:space="preserve">
          <source>The warning will indicate the redundant &lt;code&gt;Eq a&lt;/code&gt; constraint: it is subsumed by the &lt;code&gt;Ord a&lt;/code&gt; constraint.</source>
          <target state="translated">Предупреждение укажет на избыточное &lt;code&gt;Eq a&lt;/code&gt; ограничение: оно входит в &lt;code&gt;Ord a&lt;/code&gt; ограничение.</target>
        </trans-unit>
        <trans-unit id="cd02bc31ae80ea7b5041549bb5587f8dbaec0da6" translate="yes" xml:space="preserve">
          <source>The way to get predictable behaviour is to use a &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma, or an INLINE[⟨phase⟩] pragma, on &lt;code&gt;f&lt;/code&gt;, to ensure that it is not inlined until its RULEs have had a chance to fire. The warning flag &lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt;&lt;code&gt;-Winline-rule-shadowing&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;) warns about this situation.</source>
          <target state="translated">Способ получить предсказуемое поведение - это использовать прагму &lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt; или прагму INLINE [⟨phase⟩] для &lt;code&gt;f&lt;/code&gt; , чтобы гарантировать, что она не встроена, пока ее правила не сработают. Флаг предупреждения &lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt; &lt;code&gt;-Winline-rule-shadowing&lt;/code&gt; &lt;/a&gt; (см. &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Предупреждения и проверка &lt;/a&gt;работоспособности ) предупреждает об этой ситуации.</target>
        </trans-unit>
        <trans-unit id="5013e4baa488d5d314aebcbb6b7fda1ed4bf2dad" translate="yes" xml:space="preserve">
          <source>The way to identify such situations is to have &lt;em&gt;roles&lt;/em&gt; assigned to type variables of datatypes, classes, and type synonyms.</source>
          <target state="translated">Способ идентифицировать такие ситуации состоит в том, чтобы назначить &lt;em&gt;роли&lt;/em&gt; для переменных типа типов данных, классов и синонимов типов.</target>
        </trans-unit>
        <trans-unit id="dbc05c21c4ca12a5bb342be8ff05e5cc7b28ffad" translate="yes" xml:space="preserve">
          <source>The weak pointers in this library support another approach, called &lt;em&gt;finalization&lt;/em&gt;. When the key referred to by a weak pointer dies, the storage manager arranges to run a programmer-specified finalizer. In the case of memo tables, for example, the finalizer could remove the key/value pair from the memo table.</source>
          <target state="translated">Слабые указатели в этой библиотеке поддерживают другой подход, называемый &lt;em&gt;финализацией&lt;/em&gt; . Когда ключ, на который ссылается слабый указатель, умирает, диспетчер памяти запускает указанный программистом финализатор. В случае таблиц памяток, например, финализатор может удалить пару ключ / значение из таблицы памяток.</target>
        </trans-unit>
        <trans-unit id="16b1e41cdb78be221f6e82549ccc55a1f8ad8616" translate="yes" xml:space="preserve">
          <source>The workaround is to split up the .o files that make up your package into two or more .o&amp;rsquo;s, along the lines of how the &lt;code&gt;base&lt;/code&gt; package does it.</source>
          <target state="translated">Обходной путь состоит в том, чтобы разделить файлы .o, составляющие ваш пакет, на два или более .o в соответствии с тем, как это делает &lt;code&gt;base&lt;/code&gt; пакет.</target>
        </trans-unit>
        <trans-unit id="35b72d62819dbbd936ae83f6354b7de7a85577e3" translate="yes" xml:space="preserve">
          <source>The working dirctory</source>
          <target state="translated">Рабочий диркторий</target>
        </trans-unit>
        <trans-unit id="535995757af62c46c74a8d0a30d4df43208ca8cc" translate="yes" xml:space="preserve">
          <source>The wrapper and generic default</source>
          <target state="translated">Обёртка и общее значение по умолчанию</target>
        </trans-unit>
        <trans-unit id="2e4a6cdea1d1f000843aed4753e1ee986034058e" translate="yes" xml:space="preserve">
          <source>The zips: &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; молнии: zipWith , &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="0b5f326239415a00dcecafffd81728af7e4f1c01" translate="yes" xml:space="preserve">
          <source>The ⟨quoter⟩ cannot be &amp;ldquo;&lt;code&gt;e&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;t&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;d&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;p&lt;/code&gt;&amp;rdquo;, since those overlap with Template Haskell quotations.</source>
          <target state="translated">&amp;laquo;Цитата&amp;raquo; не может быть &amp;laquo; &lt;code&gt;e&lt;/code&gt; &amp;raquo;, &amp;laquo; &lt;code&gt;t&lt;/code&gt; &amp;raquo;, &amp;laquo; &lt;code&gt;d&lt;/code&gt; &amp;raquo; или &amp;laquo; &lt;code&gt;p&lt;/code&gt; &amp;raquo;, поскольку они перекрываются с цитатами Template Haskell.</target>
        </trans-unit>
        <trans-unit id="24a847f4ac69458f27486855ba65ce23bfdba7ee" translate="yes" xml:space="preserve">
          <source>The ⟨quoter⟩ must be the name of an imported quoter, either qualified or unqualified; it cannot be an arbitrary expression.</source>
          <target state="translated">⟨quoter⟩ должно быть именем импортируемого котировщика,как квалифицированного,так и неквалифицированного;это не может быть произвольным выражением.</target>
        </trans-unit>
        <trans-unit id="f3c92987d54a0ea72d8e1dc17f976a0a34f40d8f" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;Foo_stub.h&lt;/code&gt; will contain something like this:</source>
          <target state="translated">Тогда &lt;code&gt;Foo_stub.h&lt;/code&gt; будет содержать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="287d60a50242eedc6d56387d9c6ce35ff6a4229d" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;Parser&lt;/code&gt; is an instance of &lt;code&gt;MonadPlus&lt;/code&gt;: monadic sequencing implements concatenation of parsers, while &lt;code&gt;mplus&lt;/code&gt; provides choice. To use parsers, we need a primitive to run a constructed parser on an input string:</source>
          <target state="translated">Тогда &lt;code&gt;Parser&lt;/code&gt; является экземпляром &lt;code&gt;MonadPlus&lt;/code&gt; : монадическая последовательность реализует конкатенацию синтаксических анализаторов, а &lt;code&gt;mplus&lt;/code&gt; предоставляет выбор. Чтобы использовать парсеры, нам нужен примитив для запуска сконструированного парсера для входной строки:</target>
        </trans-unit>
        <trans-unit id="24214124afc9b467f1e56cb920ef654013822fb3" translate="yes" xml:space="preserve">
          <source>Then a default method for &lt;code&gt;bar&lt;/code&gt; must take on the form:</source>
          <target state="translated">Тогда метод по умолчанию для &lt;code&gt;bar&lt;/code&gt; должен иметь форму:</target>
        </trans-unit>
        <trans-unit id="aabc9095f750cdfdaf214cd60e3076a836e78de7" translate="yes" xml:space="preserve">
          <source>Then although you can use &lt;code&gt;stdout2&lt;/code&gt; to write to standard output, it is not the case that &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt; == stdout2&lt;/code&gt;.</source>
          <target state="translated">Тогда, хотя вы можете использовать &lt;code&gt;stdout2&lt;/code&gt; для записи в стандартный вывод, это не тот случай, когда &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt; == stdout2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bb2935faafd4776cf7e351d968573f0d1e31e63" translate="yes" xml:space="preserve">
          <source>Then applicative desugaring will turn it into</source>
          <target state="translated">Тогда аппликативное обессахаливание превратит его в</target>
        </trans-unit>
        <trans-unit id="0e055a4cc73e0184385ff381492db1ab945dd588" translate="yes" xml:space="preserve">
          <source>Then come variables the user has written, implicitly brought into scope in a type variable&amp;rsquo;s kind.</source>
          <target state="translated">Затем идут переменные, написанные пользователем, неявно введенные в область видимости типа переменной типа.</target>
        </trans-unit>
        <trans-unit id="9d1a05c562a8777c9badd7fde0dbd017553d2ffa" translate="yes" xml:space="preserve">
          <source>Then compile it again with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;, and additionally use &lt;code&gt;-osuf
p_o&lt;/code&gt; to name the object files differently (you can choose any suffix that isn&amp;rsquo;t the normal object suffix here). GHC will automatically load the object files built in the first step when executing splice expressions. If you omit the &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; flag when building with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; and Template Haskell is used, GHC will emit an error message.</source>
          <target state="translated">Затем скомпилируйте его снова с помощью &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; и дополнительно используйте &lt;code&gt;-osuf p_o&lt;/code&gt; чтобы по- другому называть объектные файлы (вы можете выбрать любой суффикс, который здесь не является обычным суффиксом объекта). GHC автоматически загрузит объектные файлы, созданные на первом этапе, при выполнении выражений склейки. Если вы опустите флаг &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; при сборке с &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; и используется Template Haskell, GHC выдаст сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="267961b11ee1a950806257a4cbf10ba471301448" translate="yes" xml:space="preserve">
          <source>Then in some importing module &lt;code&gt;M&lt;/code&gt;, the constraint &lt;code&gt;(E a Int)&lt;/code&gt; should be &amp;ldquo;improved&amp;rdquo; by setting &lt;code&gt;a = T&lt;/code&gt;, &lt;em&gt;even though there is no explicit mention&lt;/em&gt; of &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">Тогда в некотором импортере модуль &lt;code&gt;M&lt;/code&gt; , то ограничение &lt;code&gt;(E a Int)&lt;/code&gt; должно быть &amp;laquo;улучшение&amp;raquo;, установив &lt;code&gt;a = T&lt;/code&gt; , &lt;em&gt;несмотря на то, что нет явного упоминания&lt;/em&gt; о &lt;code&gt;T&lt;/code&gt; в &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="235e255d86c977344be94069c97c451ade72cb56" translate="yes" xml:space="preserve">
          <source>Then it becomes possible to derive a &lt;code&gt;HigherEq Option&lt;/code&gt; instance. Note that the only difference is that now the non-default type signature for &lt;code&gt;(==#)&lt;/code&gt; brings in an &lt;code&gt;Eq a&lt;/code&gt; constraint. Constraints from non-default type signatures never appear in the derived instance context itself, but they can be used to discharge obligations that are demanded by the default type signatures. In the example above, the default type signature demanded an &lt;code&gt;Eq a&lt;/code&gt; instance, and the non-default signature was able to satisfy that request, so the derived instance is simply:</source>
          <target state="translated">Затем становится возможным получить экземпляр &lt;code&gt;HigherEq Option&lt;/code&gt; . Обратите внимание, что единственное отличие состоит в том, что теперь сигнатура типа, отличная от используемой по умолчанию, для &lt;code&gt;(==#)&lt;/code&gt; вводит в &lt;code&gt;Eq a&lt;/code&gt; ограничение. Ограничения из сигнатур нестандартных типов никогда не появляются в самом контексте производного экземпляра, но их можно использовать для выполнения обязательств, которые требуются сигнатурами типов по умолчанию. В приведенном выше примере сигнатура типа по умолчанию требовала экземпляра &lt;code&gt;Eq a&lt;/code&gt; , а сигнатура, отличная от стандартной, могла удовлетворить этот запрос, поэтому производный экземпляр просто:</target>
        </trans-unit>
        <trans-unit id="99798bf68e94e178e7a793054f2701180898cefe" translate="yes" xml:space="preserve">
          <source>Then it will fail with an error to the effect of:</source>
          <target state="translated">Тогда он потерпит неудачу с ошибкой:</target>
        </trans-unit>
        <trans-unit id="c8519f9fb12a86b7dec5b48f34503c863da894e0" translate="yes" xml:space="preserve">
          <source>Then the derived &lt;code&gt;Foo&lt;/code&gt; instance will be:</source>
          <target state="translated">Тогда производный экземпляр &lt;code&gt;Foo&lt;/code&gt; будет:</target>
        </trans-unit>
        <trans-unit id="2b6a24fbb16a1dd169092c2ab47c619d87caf81a" translate="yes" xml:space="preserve">
          <source>Then the derived instance declaration is of the form</source>
          <target state="translated">Тогда декларация производного экземпляра имеет форму</target>
        </trans-unit>
        <trans-unit id="eeb84bcf4430c9ca69c9cb2ed1cfcc1c124a8d55" translate="yes" xml:space="preserve">
          <source>Then the parser will keep track of how many &lt;code&gt;tick&lt;/code&gt;s it executes.</source>
          <target state="translated">Затем парсер будет отслеживать, сколько &lt;code&gt;tick&lt;/code&gt; он выполняет.</target>
        </trans-unit>
        <trans-unit id="e5a62b711aedfbcb9ffe97913b28dd5b6da0bf6d" translate="yes" xml:space="preserve">
          <source>Then the rest of the program will use the constructed list of flags to determine it's behaviour.</source>
          <target state="translated">Затем остальная часть программы будет использовать построенный список флагов для определения своего поведения.</target>
        </trans-unit>
        <trans-unit id="56cf715d11100588d8255f66af58098ca12ef540" translate="yes" xml:space="preserve">
          <source>Then the result of invoking &lt;code&gt;foo&lt;/code&gt; with &lt;code&gt;args.txt&lt;/code&gt; is:</source>
          <target state="translated">Тогда результат вызова &lt;code&gt;foo&lt;/code&gt; с &lt;code&gt;args.txt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ae14f36ef7ad89be09b154c46ee11ccd94f3dbb9" translate="yes" xml:space="preserve">
          <source>Then we can run the program like this:</source>
          <target state="translated">Тогда мы сможем запустить программу вот так:</target>
        </trans-unit>
        <trans-unit id="3e41f47121700ac5c2df677839acdf049e3f9e48" translate="yes" xml:space="preserve">
          <source>Then you can implement your own version of &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; on top of the &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; primitive.</source>
          <target state="translated">Затем вы можете реализовать свою собственную версию &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; поверх примитива &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a5eeee560256a85b705cade438380ca2718e1e0" translate="yes" xml:space="preserve">
          <source>There are &lt;em&gt;many&lt;/em&gt; options that affect the quality of code produced by GHC. Most people only have a general goal, something like &amp;ldquo;Compile quickly&amp;rdquo; or &amp;ldquo;Make my program run like greased lightning.&amp;rdquo; The following &amp;ldquo;packages&amp;rdquo; of optimisations (or lack thereof) should suffice.</source>
          <target state="translated">Есть &lt;em&gt;много&lt;/em&gt; параметров, которые влияют на качество кода, создаваемого GHC. У большинства людей есть только общая цель, что-то вроде &amp;laquo;скомпилировать быстро&amp;raquo; или &amp;laquo;заставить мою программу работать как смазанная молния&amp;raquo;. Следующих &amp;laquo;пакетов&amp;raquo; оптимизаций (или их отсутствия) должно хватить.</target>
        </trans-unit>
        <trans-unit id="a77fd5209f37754aca85e51e88e8331502ef09cb" translate="yes" xml:space="preserve">
          <source>There are a couple of caveats that will hopefully be removed in the future: this option is currently not implemented on Windows (it is a no-op), and the external interpreter does not support the GHCi debugger, so breakpoints and single-stepping don&amp;rsquo;t work with &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Есть несколько предостережений, которые, надеюсь, будут устранены в будущем: эта опция в настоящее время не реализована в Windows (она не работает), а внешний интерпретатор не поддерживает отладчик GHCi, поэтому точки останова и пошаговое выполнение не используются. не работает с &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="238a2c3809b79499c01f2138d09c2d1d9feaad16" translate="yes" xml:space="preserve">
          <source>There are a few flags for controlling the amount of context information shown for typed holes:</source>
          <target state="translated">Есть несколько флагов для контроля количества контекстной информации,отображаемой для типизированных отверстий:</target>
        </trans-unit>
        <trans-unit id="05f73d7b9e81f28e5b08f63baac61b1c0e9fd698" translate="yes" xml:space="preserve">
          <source>There are a few other profiling-related compilation options. Use them &lt;em&gt;in addition to&lt;/em&gt;&lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;. These do not have to be used consistently for all modules in a program.</source>
          <target state="translated">Есть еще несколько вариантов компиляции, связанных с профилированием. Используйте их &lt;em&gt;в дополнение к &lt;/em&gt;&lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; . Их необязательно использовать последовательно для всех модулей в программе.</target>
        </trans-unit>
        <trans-unit id="bfaa1403a2ac25e9e81e0a2422e4318fed05546d" translate="yes" xml:space="preserve">
          <source>There are a few things to note here.</source>
          <target state="translated">Здесь есть на что обратить внимание.</target>
        </trans-unit>
        <trans-unit id="65c24a4a0fbb8909b2a9afa60ebb6820a2bea67a" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;case&lt;/code&gt; commands, like</source>
          <target state="translated">Также есть команды &lt;code&gt;case&lt;/code&gt; , например</target>
        </trans-unit>
        <trans-unit id="771e1589e9fa56b87ca43cc9ff1e2b15e3622f3f" translate="yes" xml:space="preserve">
          <source>There are currently two ways to sort valid hole fits. Sorting can be toggled with &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt;</source>
          <target state="translated">В настоящее время есть два способа отсортировать допустимые отверстия. Сортировку можно переключать с помощью &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9dbf7fd538b1582c001293e373fa1358ed1160bc" translate="yes" xml:space="preserve">
          <source>There are disadvantages to compiling to object-code: you can&amp;rsquo;t set breakpoints in object-code modules, for example. Only the exports of an object-code module will be visible in GHCi, rather than all top-level bindings as in interpreted modules.</source>
          <target state="translated">Компиляция в объектный код имеет недостатки: например, вы не можете устанавливать точки останова в модулях объектного кода. В GHCi будет виден только экспорт модуля объектного кода, а не все привязки верхнего уровня, как в интерпретируемых модулях.</target>
        </trans-unit>
        <trans-unit id="99abc70961c6ddd5c63e8fff24e698349bbae073" translate="yes" xml:space="preserve">
          <source>There are five new forms of comprehension qualifier, all introduced by the (existing) keyword &lt;code&gt;then&lt;/code&gt;:</source>
          <target state="translated">Есть пять новых форм понимания классификатором, все вносимые (существующий) ключевое слово &lt;code&gt;then&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b5730f07b618c090c0cbf82d3d38f729cdc48001" translate="yes" xml:space="preserve">
          <source>There are four ways to set RTS options:</source>
          <target state="translated">Есть четыре способа установить опции RTS:</target>
        </trans-unit>
        <trans-unit id="b2ec965da649e8c81ce5901a31769ddc2d0814b9" translate="yes" xml:space="preserve">
          <source>There are many datatype-generic functions that do not distinguish between positions that are parameters or positions that are recursive calls. There are also many datatype-generic functions that do not care about the names of datatypes and constructors at all. To keep the number of cases to consider in generic functions in such a situation to a minimum, it turns out that many of the type constructors introduced above are actually synonyms, defining them to be variants of a smaller set of constructors.</source>
          <target state="translated">Существует множество генерических функций типа данных,которые не различают позиции,являющиеся параметрами,или позиции,являющиеся рекурсивными вызовами.Существует также много генерических функций типа данных,которые вообще не заботятся об именах типов данных и конструкторов.Чтобы свести к минимуму количество случаев для рассмотрения в генерических функциях в такой ситуации,оказывается,что многие из конструкторов типов,введённых выше,на самом деле являются синонимами,определяя их как варианты меньшего набора конструкторов.</target>
        </trans-unit>
        <trans-unit id="1a9399599d5316c913ed2356bf5f34b740745168" translate="yes" xml:space="preserve">
          <source>There are many different kinds of profile that can be generated, selected by different RTS options. We will be describing the various kinds of profile throughout the rest of this chapter. Some profiles require further processing using additional tools after running the program.</source>
          <target state="translated">Существует много различных типов профилей,которые могут быть сгенерированы,выбраны различными опциями RTS.Мы будем описывать различные виды профилей на протяжении всей оставшейся части этой главы.Некоторые профили требуют дальнейшей обработки с использованием дополнительных инструментов после запуска программы.</target>
        </trans-unit>
        <trans-unit id="cde574e7b85226578f80e50c9f896820c6ba2e16" translate="yes" xml:space="preserve">
          <source>There are no predefined instances of this class. It is not in scope by default, but can be brought into scope by importing &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt;. Unlike &lt;code&gt;IsString&lt;/code&gt;, there are no special defaulting rules for &lt;code&gt;IsLabel&lt;/code&gt;.</source>
          <target state="translated">Предопределенных экземпляров этого класса нет. По умолчанию он не входит в область видимости, но может быть добавлен в область видимости путем импорта &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt; . В отличие от &lt;code&gt;IsString&lt;/code&gt; , для &lt;code&gt;IsLabel&lt;/code&gt; нет специальных правил по умолчанию .</target>
        </trans-unit>
        <trans-unit id="269b2e3e0b62fd25b64a351c5f6a350824ce3dd4" translate="yes" xml:space="preserve">
          <source>There are no runnable threads, so the program is deadlocked. The &lt;code&gt;Deadlock&lt;/code&gt; exception is raised in the main thread only.</source>
          <target state="translated">Нет исполняемых потоков, поэтому программа зашла в тупик. &lt;code&gt;Deadlock&lt;/code&gt; возбуждается исключение только в главном потоке.</target>
        </trans-unit>
        <trans-unit id="beb33239136056ec4e0f1d010703bb7704f0b5d8" translate="yes" xml:space="preserve">
          <source>There are no syntactic changes with &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt;. The only way it shows up at the source level is that you can have a &lt;code&gt;do&lt;/code&gt; expression that doesn&amp;rsquo;t require a &lt;code&gt;Monad&lt;/code&gt; constraint. For example, in GHCi:</source>
          <target state="translated">В &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; &lt;/a&gt; нет синтаксических изменений . Единственный способ его появления на уровне исходного кода - это то, что у вас может быть выражение &lt;code&gt;do&lt;/code&gt; , которое не требует ограничения &lt;code&gt;Monad&lt;/code&gt; . Например, в GHCi:</target>
        </trans-unit>
        <trans-unit id="fac55f918da621ac3417ac0d5e66c22c7958b174" translate="yes" xml:space="preserve">
          <source>There are no values of type &lt;code&gt;V1 p&lt;/code&gt; to pass (except undefined), so this is actually impossible. One can ask why it is useful to define an instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; at all in this case? Well, an empty type can be used as an argument to a non-empty type, and you might still want to encode the resulting type. As a somewhat contrived example, consider &lt;code&gt;[Empty]&lt;/code&gt;, which is not an empty type, but contains just the empty list. The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; instance ensures that we can call the generic function on such types.</source>
          <target state="translated">Нет значений типа &lt;code&gt;V1 p&lt;/code&gt; для передачи (кроме undefined), поэтому это фактически невозможно. Возникает вопрос, почему в этом случае вообще полезно определять экземпляр для &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; ? Ну, пустой тип можно использовать в качестве аргумента для непустого типа, и вы все равно можете захотеть закодировать результирующий тип. В качестве несколько надуманного примера рассмотрим &lt;code&gt;[Empty]&lt;/code&gt; , который не является пустым типом, а содержит только пустой список. В &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; экземпляре гарантирует , что мы можем назвать обобщенную функцию на таких типах.</target>
        </trans-unit>
        <trans-unit id="dda49e2845b7918f36228a92c75280c5c35090c6" translate="yes" xml:space="preserve">
          <source>There are occasions when you really do need to catch any sort of exception. However, in most cases this is just so you can do some cleaning up; you aren't actually interested in the exception itself. For example, if you open a file then you want to close it again, whether processing the file executes normally or throws an exception. However, in these cases you can use functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt;, which never actually pass you the exception, but just call the cleanup functions at the appropriate points.</source>
          <target state="translated">Бывают случаи, когда вам действительно нужно перехватить какое-либо исключение. Однако в большинстве случаев это просто для того, чтобы вы могли немного очистить; на самом деле вас не интересует само исключение. Например, если вы открываете файл, вы хотите снова закрыть его, независимо от того, выполняется ли обработка файла нормально или возникает исключение. Однако в этих случаях вы можете использовать такие функции, как &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; , которые на самом деле никогда не передают вам исключение, а просто вызывают функции очистки в соответствующих точках.</target>
        </trans-unit>
        <trans-unit id="639f40c3a09baf81a098f96274a0d1a94feb6f6d" translate="yes" xml:space="preserve">
          <source>There are several different access points that you can use for defining plugins that access the representations. All these fields receive the list of &lt;code&gt;CommandLineOption&lt;/code&gt; strings that are passed to the compiler using the &lt;code&gt;-fplugin-opt&lt;/code&gt; flags.</source>
          <target state="translated">Есть несколько различных точек доступа, которые вы можете использовать для определения плагинов, которые обращаются к представлениям. Все эти поля получают список строк &lt;code&gt;CommandLineOption&lt;/code&gt; , которые передаются компилятору с помощью флагов &lt;code&gt;-fplugin-opt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5c2fccb39860e74a196437dc4b29b1d5931960f" translate="yes" xml:space="preserve">
          <source>There are several different kinds of heap profile that can be generated. All the different profile types yield a graph of live heap against time, but they differ in how the live heap is broken down into bands. The following RTS options select which break-down to use:</source>
          <target state="translated">Существует несколько различных типов профилей кучи,которые могут быть сгенерированы.Все разные типы профилей дают график живой кучи со временем,но они отличаются тем,как живая куча разбивается на группы.Следующие опции RTS выбирают,какую разбивку использовать:</target>
        </trans-unit>
        <trans-unit id="59dc5a84493de5e0b4fa021edc7dec2cdb87c983" translate="yes" xml:space="preserve">
          <source>There are several functions for catching and examining exceptions; all of them may only be used from within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">Есть несколько функций для перехвата и изучения исключений; все они могут использоваться только внутри монады &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="337f85cb08a97f0edab39052ebaa84e5942811b2" translate="yes" xml:space="preserve">
          <source>There are several options to give you precise control over garbage collection. Hopefully, you won&amp;rsquo;t need any of these in normal operation, but there are several things that can be tweaked for maximum performance.</source>
          <target state="translated">Есть несколько вариантов, позволяющих точно контролировать сборку мусора. Надеюсь, вам не понадобится ничего из этого при нормальной работе, но есть несколько вещей, которые можно настроить для максимальной производительности.</target>
        </trans-unit>
        <trans-unit id="01c5afb51e2571a4a55001c10a6176945f0a6177" translate="yes" xml:space="preserve">
          <source>There are several other Haskell and GHC-related mailing lists served by &lt;code&gt;www.haskell.org&lt;/code&gt;. Go to &lt;a href=&quot;http://www.haskell.org/mailman/listinfo/&quot;&gt;http://www.haskell.org/mailman/listinfo/&lt;/a&gt; for the full list.</source>
          <target state="translated">Есть несколько других списков рассылки, связанных с Haskell и GHC, которые обслуживаются &lt;code&gt;www.haskell.org&lt;/code&gt; . Перейдите на &lt;a href=&quot;http://www.haskell.org/mailman/listinfo/&quot;&gt;http://www.haskell.org/mailman/listinfo/,&lt;/a&gt; чтобы просмотреть полный список.</target>
        </trans-unit>
        <trans-unit id="5ad7bd779fbd5beae4e736df98cf99e5f6fe7e9c" translate="yes" xml:space="preserve">
          <source>There are several points to note here:</source>
          <target state="translated">Здесь есть несколько моментов,которые следует отметить:</target>
        </trans-unit>
        <trans-unit id="784aa0353059aa8ea4162b074576148c1af282a0" translate="yes" xml:space="preserve">
          <source>There are several restrictions on the ways in which existentially-quantified constructors can be used.</source>
          <target state="translated">Существует несколько ограничений на способы использования экзистенциально количественных конструкторов.</target>
        </trans-unit>
        <trans-unit id="bd4c52cde7bbf81cc7e9bbd55c1d798440501cfc" translate="yes" xml:space="preserve">
          <source>There are some other differences regarding what data types can have derived &lt;code&gt;Foldable&lt;/code&gt; instances:</source>
          <target state="translated">Существуют и другие различия относительно того, какие типы данных могут иметь производные экземпляры &lt;code&gt;Foldable&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="037468f11530bf3546d6d6b4b426b492e5fe132b" translate="yes" xml:space="preserve">
          <source>There are some other scenarios in which a derived &lt;code&gt;Functor&lt;/code&gt; instance will fail to compile:</source>
          <target state="translated">Существуют и другие сценарии, в которых производный экземпляр &lt;code&gt;Functor&lt;/code&gt; не может быть скомпилирован:</target>
        </trans-unit>
        <trans-unit id="322b63636f583080da1a2074c03c06a60190898f" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of primitive types:</source>
          <target state="translated">Существуют некоторые ограничения на использование примитивных типов:</target>
        </trans-unit>
        <trans-unit id="6714ecb3bd613a0859b0e085d69581a99ba78991" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of unboxed tuples:</source>
          <target state="translated">Существуют некоторые ограничения на использование кортежей без коробки:</target>
        </trans-unit>
        <trans-unit id="f2c8a53e7498d7f11900cb2cae3b497c5f15ea0f" translate="yes" xml:space="preserve">
          <source>There are three more options which relate to heap profiling:</source>
          <target state="translated">Есть еще три варианта,которые связаны с профилированием кучи:</target>
        </trans-unit>
        <trans-unit id="d3c78fa44479aea5bb07f36a79f3018825c1a8bf" translate="yes" xml:space="preserve">
          <source>There are three new keywords: &lt;code&gt;group&lt;/code&gt;, &lt;code&gt;by&lt;/code&gt;, and &lt;code&gt;using&lt;/code&gt;. (The functions &lt;code&gt;sortWith&lt;/code&gt; and &lt;code&gt;groupWith&lt;/code&gt; are not keywords; they are ordinary functions that are exported by &lt;code&gt;GHC.Exts&lt;/code&gt;.)</source>
          <target state="translated">Есть три новых ключевых слова: &lt;code&gt;group&lt;/code&gt; , &lt;code&gt;by&lt;/code&gt; и &lt;code&gt;using&lt;/code&gt; . (Функции &lt;code&gt;sortWith&lt;/code&gt; и &lt;code&gt;groupWith&lt;/code&gt; не являются ключевыми словами; это обычные функции, экспортируемые &lt;code&gt;GHC.Exts&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="12e1f881320b3ea52d40fd0c1f40b27e82ba9b3c" translate="yes" xml:space="preserve">
          <source>There are three ways to get access to the current call stack.</source>
          <target state="translated">Есть три способа получить доступ к текущему стеку вызовов.</target>
        </trans-unit>
        <trans-unit id="de26986dee76170f6ec07baa5f2f57d4f2f3bd27" translate="yes" xml:space="preserve">
          <source>There are two classes of special syntax:</source>
          <target state="translated">Существует два класса специального синтаксиса:</target>
        </trans-unit>
        <trans-unit id="ec969b2442b8eecc56a5e56e4a38606a9d6c4714" translate="yes" xml:space="preserve">
          <source>There are two distinct ways in which DLLs can be used:</source>
          <target state="translated">Существует два различных способа использования DLL:</target>
        </trans-unit>
        <trans-unit id="69520fd35811ca565d4a03687080e48476082679" translate="yes" xml:space="preserve">
          <source>There are two exceptions to this rule:</source>
          <target state="translated">Из этого правила есть два исключения:</target>
        </trans-unit>
        <trans-unit id="6daa1632cd3b54f8ed467624d2b1ea21fe282ac2" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Есть еще два важных свойства &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3c01c12b532e489f2e09eda20a43541fbb8e2c20" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Есть еще два важных свойства &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4f041a590258ae158bc19338ee5f5bd08e96e3ac" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Есть еще два важных свойства &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="608b986739cc6bfe64513cdb88f373b5188a6cbd" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Есть еще два важных свойства &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7692866ec9e3ed0746b6d2a44bba6c0047fee10a" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Есть еще два важных свойства &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6e9eb556d85a345c9f86d9bb55e006140b1fb7fb" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Есть еще два важных свойства &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fba4531a8b11c8291da983f4d43d0fb17f51f7ee" translate="yes" xml:space="preserve">
          <source>There are two kinds of ways to execute this decoder, the lazy input method and the incremental input method. Here we will use the lazy input method.</source>
          <target state="translated">Существует два вида способов выполнения этого декодера-метод ленивого ввода и метод инкрементального ввода.Здесь мы будем использовать метод ленивого ввода.</target>
        </trans-unit>
        <trans-unit id="6e774e84479488317f2efb9ffb8c2bacf8c0269f" translate="yes" xml:space="preserve">
          <source>There are two major differences between sequences and lists:</source>
          <target state="translated">Существует два основных различия между последовательностями и списками:</target>
        </trans-unit>
        <trans-unit id="dc6af36ef821dae775e5ef867b3bd7dcc5981254" translate="yes" xml:space="preserve">
          <source>There are two things that you can do with this counter:</source>
          <target state="translated">Есть две вещи,которые ты можешь сделать с этим прилавком:</target>
        </trans-unit>
        <trans-unit id="1ea5fcd10d6a59a0b100463bc4e292062bdcd770" translate="yes" xml:space="preserve">
          <source>There are two variants of the browse command:</source>
          <target state="translated">Существует два варианта команды просмотра:</target>
        </trans-unit>
        <trans-unit id="de327a3762d47ae125858b0ff7b1122a826b2325" translate="yes" xml:space="preserve">
          <source>There are two ways of using these pragmas.</source>
          <target state="translated">Есть два способа использовать эти прагмы.</target>
        </trans-unit>
        <trans-unit id="8e1b9f93dd0dc44d439a143716f8059fe53f2cd0" translate="yes" xml:space="preserve">
          <source>There are two ways to run a program on multiple processors: call &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; from your program, or use the RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">Есть два способа запустить программу на нескольких процессорах: вызвать &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; из вашей программы или использовать параметры RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2f6a5706b25587b231e13caab60243ec8dfb7a0" translate="yes" xml:space="preserve">
          <source>There can be as many file-header pragmas as you please, and they can be preceded or followed by comments.</source>
          <target state="translated">В этом случае может быть столько заголовочных файловых прагм,сколько вам угодно,и они могут быть предваряющими или сопровождаться комментариями.</target>
        </trans-unit>
        <trans-unit id="04a5ab37848c92aef36743d412ae5b5c117d1518" translate="yes" xml:space="preserve">
          <source>There can be at most one default declaration for an associated type synonym.</source>
          <target state="translated">Для синонима ассоциированного типа может быть максимально одно объявление по умолчанию.</target>
        </trans-unit>
        <trans-unit id="dffa4d1ea036ae67d9e2bc55fafeaa6f75d96500" translate="yes" xml:space="preserve">
          <source>There can be multiple calls to &lt;code&gt;hs_init()&lt;/code&gt;, but each one should be matched by one (and only one) call to &lt;code&gt;hs_exit()&lt;/code&gt;. The outermost &lt;code&gt;hs_exit()&lt;/code&gt; will actually de-initialise the system. Note that currently GHC&amp;rsquo;s runtime cannot reliably re-initialise after this has happened; see &lt;a href=&quot;bugs#infelicities-ffi&quot;&gt;The Foreign Function Interface&lt;/a&gt;.</source>
          <target state="translated">Может быть несколько вызовов &lt;code&gt;hs_init()&lt;/code&gt; , но каждому из них должен соответствовать один (и только один) вызов &lt;code&gt;hs_exit()&lt;/code&gt; . Самый внешний &lt;code&gt;hs_exit()&lt;/code&gt; фактически деинициализирует систему. Обратите внимание, что в настоящее время среда выполнения GHC не может надежно повторно инициализироваться после того, как это произошло; см. &lt;a href=&quot;bugs#infelicities-ffi&quot;&gt;Интерфейс внешних функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8238a9e8534ce08f318f309173b6e1d9f39f30cc" translate="yes" xml:space="preserve">
          <source>There can only be one &amp;ldquo;break-down&amp;rdquo; option (eg. &lt;a href=&quot;#rts-flag--hr&quot;&gt;&lt;code&gt;-hr&lt;/code&gt;&lt;/a&gt; in the example above), but there is no limit on the number of further restrictions that may be applied. All the options may be combined, with one exception: GHC doesn&amp;rsquo;t currently support mixing the &lt;a href=&quot;#rts-flag--hr&quot;&gt;&lt;code&gt;-hr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#rts-flag--hb&quot;&gt;&lt;code&gt;-hb&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">Может быть только одна опция &amp;laquo;разбивки&amp;raquo; (например, &lt;a href=&quot;#rts-flag--hr&quot;&gt; &lt;code&gt;-hr&lt;/code&gt; &lt;/a&gt; в приведенном выше примере), но нет ограничений на количество дополнительных ограничений, которые могут применяться. Все параметры можно комбинировать, за одним исключением: GHC в настоящее время не поддерживает смешивание параметров &lt;a href=&quot;#rts-flag--hr&quot;&gt; &lt;code&gt;-hr&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#rts-flag--hb&quot;&gt; &lt;code&gt;-hb&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c485dde3423005740634757de5268432c646f0a8" translate="yes" xml:space="preserve">
          <source>There is a default value &lt;code&gt;defaultRtsConfig&lt;/code&gt; that should be used to initialise variables of type &lt;code&gt;RtsConfig&lt;/code&gt;. More fields will undoubtedly be added to &lt;code&gt;RtsConfig&lt;/code&gt; in the future, so in order to keep your code forwards-compatible it is best to initialise with &lt;code&gt;defaultRtsConfig&lt;/code&gt; and then modify the required fields, as in the code sample above.</source>
          <target state="translated">Существует значение по умолчанию &lt;code&gt;defaultRtsConfig&lt;/code&gt; , которое следует использовать для инициализации переменных типа &lt;code&gt;RtsConfig&lt;/code&gt; . Несомненно, в &lt;code&gt;RtsConfig&lt;/code&gt; в RtsConfig будет добавлено больше полей , поэтому для обеспечения прямой совместимости вашего кода лучше всего инициализировать с помощью &lt;code&gt;defaultRtsConfig&lt;/code&gt; , а затем изменить необходимые поля, как в примере кода выше.</target>
        </trans-unit>
        <trans-unit id="5b2325f0000268be99bab7c0c4bf9b7b70a365cb" translate="yes" xml:space="preserve">
          <source>There is a more detailed discussion of the issues involved in compilation safety and some potential solutions on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/SafeHaskell/SafeCompilation&quot;&gt;GHC Wiki&lt;/a&gt;.</source>
          <target state="translated">На &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/SafeHaskell/SafeCompilation&quot;&gt;GHC Wiki&lt;/a&gt; есть более подробное обсуждение вопросов, связанных с безопасностью компиляции, и некоторых потенциальных решений .</target>
        </trans-unit>
        <trans-unit id="fce04b326aff61ebe2df9a60af9c38cb1dce575b" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">Есть небольшая разница между &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; , аналогично разнице между &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; . Если ленивое значение &lt;code&gt;x&lt;/code&gt; вызывает исключение, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; не сможет вернуть действие &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; и вместо этого вызовет исключение. &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; другой стороны, оценка x всегда производит действие &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ; это действие вызовет исключение при &lt;em&gt;выполнении,&lt;/em&gt; если &lt;code&gt;x&lt;/code&gt; генерирует исключение при &lt;em&gt;оценке&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="eb1e4212250bc026f307434003db90efbde2bd64" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">Есть небольшая разница между &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; , аналогично разнице между &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; . Если ленивое значение &lt;code&gt;x&lt;/code&gt; вызывает исключение, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; не сможет вернуть действие &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; и вместо этого вызовет исключение. &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; другой стороны, оценка x всегда производит действие &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ; это действие вызовет исключение при &lt;em&gt;выполнении,&lt;/em&gt; если &lt;code&gt;x&lt;/code&gt; генерирует исключение при &lt;em&gt;оценке&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2563e2a704bbfcc49ec757ba40163da4dd1fc632" translate="yes" xml:space="preserve">
          <source>There is a subtle interaction between deadlock detection and finalizers (as created by &lt;code&gt;&lt;a href=&quot;foreign-concurrent#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; or the functions in &lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt;): if a thread is blocked waiting for a finalizer to run, then the thread will be considered deadlocked and sent an exception. So preferably don't do this, but if you have no alternative then it is possible to prevent the thread from being considered deadlocked by making a &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; pointing to it. Don't forget to release the &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; later with &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Между обнаружением взаимоблокировок и финализаторами существует тонкое взаимодействие (созданное &lt;code&gt;&lt;a href=&quot;foreign-concurrent#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; или функциями в &lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt; ): если поток заблокирован в ожидании запуска финализатора, то поток будет считаться заблокированным и отправит исключение. Поэтому желательно не делать этого, но если у вас нет альтернативы, можно предотвратить блокировку &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; указав на него StablePtr . Не забудьте выпустить &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; позже с помощью &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a138de3ec39dbf7ca00320675627b0016f828fa6" translate="yes" xml:space="preserve">
          <source>There is additional notation (borrowed from GNU iconv) for specifying how illegal characters are handled:</source>
          <target state="translated">Есть дополнительная запись (заимствованная из GNU iconv)для указания того,как обрабатываются незаконные символы:</target>
        </trans-unit>
        <trans-unit id="e9d61711326fa0b013bb306b7ecd3dfd1ba853da" translate="yes" xml:space="preserve">
          <source>There is an extensive Haskell folk art of &lt;a href=&quot;https://wiki.haskell.org/Smart_constructor&quot;&gt;smart constructors&lt;/a&gt;, essentially functions that wrap validation around a constructor, and avoid exposing its representation. The downside is that the underlying constructor can&amp;rsquo;t be used as a matcher. Pattern synonyms can be used as genuinely smart constructors, for both validation and matching.</source>
          <target state="translated">Существует обширное народное искусство Haskell в области &lt;a href=&quot;https://wiki.haskell.org/Smart_constructor&quot;&gt;умных конструкторов&lt;/a&gt; , по сути, функций, которые обертывают валидацию вокруг конструктора и избегают раскрытия его представления. Обратной стороной является то, что базовый конструктор не может использоваться в качестве сопоставителя. Синонимы шаблонов могут использоваться как действительно умные конструкторы как для проверки, так и для сопоставления.</target>
        </trans-unit>
        <trans-unit id="3c1c1857aceea948e7d21232acb00e3e546f38d8" translate="yes" xml:space="preserve">
          <source>There is an overhead of profiling itself, which is subtracted from the residency figures by the profiler. This overhead goes away when compiling without profiling support, of course. The space overhead is currently 2 extra words per heap object, which probably results in about a 30% overhead.</source>
          <target state="translated">Существует накладная часть самого профилирования,которая вычитается профилировщиком из числа резидентов.Разумеется,эти накладные расходы проходят при составлении профилей без поддержки профилирования.Пространственные накладные расходы в настоящее время составляют 2 лишних слова на кучу объектов,что,вероятно,приводит к накладным расходам около 30%.</target>
        </trans-unit>
        <trans-unit id="d8de98d63557bb552149bc7c1b7c9441d6a8dd4f" translate="yes" xml:space="preserve">
          <source>There is currently no support for obtaining a &amp;ldquo;stack trace&amp;rdquo;, but the tracing and history features provide a useful second-best, which will often be enough to establish the context of an error. For instance, it is possible to break automatically when an exception is thrown, even if it is thrown from within compiled code (see &lt;a href=&quot;#ghci-debugger-exceptions&quot;&gt;Debugging exceptions&lt;/a&gt;).</source>
          <target state="translated">В настоящее время нет поддержки для получения &amp;laquo;трассировки стека&amp;raquo;, но функции трассировки и истории предоставляют второстепенные полезные функции, которых часто бывает достаточно, чтобы установить контекст ошибки. Например, возможно автоматическое прерывание при возникновении исключения, даже если оно было выброшено из скомпилированного кода (см. &lt;a href=&quot;#ghci-debugger-exceptions&quot;&gt;Отладка исключений&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="05298a3a39fbf634a0e6edb9d64da77de83036ef" translate="yes" xml:space="preserve">
          <source>There is exactly one value of type &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt;, so encoding it requires no knowledge, and we can use zero bits:</source>
          <target state="translated">Существует ровно одно значение типа &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; , поэтому для его кодирования не требуется знаний, и мы можем использовать нулевые биты:</target>
        </trans-unit>
        <trans-unit id="a0d17e4c841b3c2b20a6d55cc49a93844fdda33f" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;ZonedTime&lt;/code&gt;. If you want to compare local times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt;. If you want to compare absolute times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Там нет &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; экземпляра для &lt;code&gt;ZonedTime&lt;/code&gt; . Если вы хотите сравнить местное время, используйте &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt; . Если вы хотите сравнить абсолютное время, используйте &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4d935f491ea262d75f4027e96a025772c84736d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;deRefStableName&lt;/code&gt; operation. You can't get back from a stable name to the original Haskell object. The reason for this is that the existence of a stable name for an object does not guarantee the existence of the object itself; it can still be garbage collected.</source>
          <target state="translated">Операция &lt;code&gt;deRefStableName&lt;/code&gt; отсутствует . Вы не можете вернуться от стабильного имени к исходному объекту Haskell. Причина этого в том, что наличие стабильного имени для объекта не гарантирует существования самого объекта; его все еще можно собирать мусором.</target>
        </trans-unit>
        <trans-unit id="dcb0e28b510aab00d8eb90f67a01a5ce984b4fe5" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;freeStableName&lt;/code&gt; operation, unlike &lt;a href=&quot;foreign-stableptr&quot;&gt;Foreign.StablePtr&lt;/a&gt;s. Stable names are reclaimed by the runtime system when they are no longer needed.</source>
          <target state="translated">Там нет &lt;code&gt;freeStableName&lt;/code&gt; операции, в отличие от &lt;a href=&quot;foreign-stableptr&quot;&gt;Foreign.StablePtr&lt;/a&gt; s. Стабильные имена возвращаются системой времени выполнения, когда они больше не нужны.</target>
        </trans-unit>
        <trans-unit id="efff9d8f51d60ed15b8f7397e759321e79cf6a90" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;{-# UNPACK #-}&lt;/code&gt; or &lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt; annotation in the source, so it is tagged with &lt;code&gt;'NoSourceUnpackedness&lt;/code&gt;.</source>
          <target state="translated">В источнике нет &lt;code&gt;{-# UNPACK #-}&lt;/code&gt; или &lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt; , поэтому он помечен тегом &lt;code&gt;'NoSourceUnpackedness&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a45e4999f85d7fe32a999bebf9535c3d4c0ff576" translate="yes" xml:space="preserve">
          <source>There is no corresponding operation for read buffers, because before reading the client will always call &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#v:fillReadBuffer&quot;&gt;fillReadBuffer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для буферов чтения нет соответствующей операции, потому что перед чтением клиент всегда вызывает &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#v:fillReadBuffer&quot;&gt;fillReadBuffer&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34dd8b71967c29b174452c1a3603b96013167aa4" translate="yes" xml:space="preserve">
          <source>There is no effect on newtypes, which simply rename existing types. For example:</source>
          <target state="translated">Нет никакого эффекта на новинки,которые просто переименовывают существующие типы.Например:</target>
        </trans-unit>
        <trans-unit id="e61dd8454d5cd40d618f2a4b76daa69735c08b4e" translate="yes" xml:space="preserve">
          <source>There is no guarantee about the ordering of evaluation. The implementation may evaluate the components of the structure in any order or in parallel. To impose an actual order on evaluation, use &lt;code&gt;pseq&lt;/code&gt; from &lt;a href=&quot;control-parallel&quot;&gt;Control.Parallel&lt;/a&gt; in the &lt;code&gt;parallel&lt;/code&gt; package.</source>
          <target state="translated">Нет никаких гарантий относительно заказа оценки. Реализация может оценивать компоненты структуры в любом порядке или параллельно. Чтобы наложить реальный порядок оценки, используйте &lt;code&gt;pseq&lt;/code&gt; из &lt;a href=&quot;control-parallel&quot;&gt;Control.Parallel&lt;/a&gt; в пакете &lt;code&gt;parallel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="174d05733afd5ac16dc7445d7fb3277cc5bdc2d2" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Нет никакой гарантии, что исключение будет доставлено в кратчайшие сроки, хотя среда выполнения приложит все усилия, чтобы не допустить произвольных задержек. В GHC исключение может быть вызвано только тогда, когда поток достигает &lt;em&gt;безопасной точки&lt;/em&gt; , где безопасная точка - это место, где происходит выделение памяти. Некоторые циклы не &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; память внутри цикла и поэтому не могут быть прерваны методом throwTo .</target>
        </trans-unit>
        <trans-unit id="17ab87d8b15509feea83bfa466783ea6dbfde5ca" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Нет никакой гарантии, что исключение будет доставлено в кратчайшие сроки, хотя среда выполнения приложит все усилия, чтобы не допустить произвольных задержек. В GHC исключение может быть вызвано только тогда, когда поток достигает &lt;em&gt;безопасной точки&lt;/em&gt; , где безопасная точка - это место, где происходит выделение памяти. Некоторые циклы не &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; память внутри цикла и поэтому не могут быть прерваны методом throwTo .</target>
        </trans-unit>
        <trans-unit id="12996aa618fab21e63df138a73f65dd2c12773a5" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Нет никакой гарантии, что исключение будет доставлено в кратчайшие сроки, хотя среда выполнения приложит все усилия, чтобы не допустить произвольных задержек. В GHC исключение может быть вызвано только тогда, когда поток достигает &lt;em&gt;безопасной точки&lt;/em&gt; , где безопасная точка - это место, где происходит выделение памяти. Некоторые циклы не &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; память внутри цикла и поэтому не могут быть прерваны методом throwTo .</target>
        </trans-unit>
        <trans-unit id="1a69783f3d3b8ddc10a9ccc302c3a5316e76d653" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Нет никакой гарантии, что исключение будет доставлено в кратчайшие сроки, хотя среда выполнения приложит все усилия, чтобы не допустить произвольных задержек. В GHC исключение может быть вызвано только тогда, когда поток достигает &lt;em&gt;безопасной точки&lt;/em&gt; , где безопасная точка - это место, где происходит выделение памяти. Некоторые циклы не &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; память внутри цикла и поэтому не могут быть прерваны методом throwTo .</target>
        </trans-unit>
        <trans-unit id="d130cc9fa616d4b612107014858ea9434d5a0e51" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the thread will be rescheduled promptly when the delay has expired, but the thread will never continue to run &lt;em&gt;earlier&lt;/em&gt; than specified.</source>
          <target state="translated">Нет гарантии, что поток будет немедленно перепланирован по истечении задержки, но поток никогда не продолжит выполнение &lt;em&gt;раньше&lt;/em&gt; указанного.</target>
        </trans-unit>
        <trans-unit id="840213e7969b17914dbe8b15a7755e40f1d9a57c" translate="yes" xml:space="preserve">
          <source>There is no need to list all of the source files as arguments to the &lt;code&gt;ghc -M&lt;/code&gt; command; &lt;code&gt;ghc&lt;/code&gt; traces the dependencies, just like &lt;code&gt;ghc --make&lt;/code&gt; (a new feature in GHC 6.4).</source>
          <target state="translated">Нет необходимости перечислять все исходные файлы в качестве аргументов команды &lt;code&gt;ghc -M&lt;/code&gt; ; &lt;code&gt;ghc&lt;/code&gt; отслеживает зависимости, как и &lt;code&gt;ghc --make&lt;/code&gt; (новая функция в GHC 6.4).</target>
        </trans-unit>
        <trans-unit id="41c9157200b76970f9cebe37b324916f47f53c9e" translate="yes" xml:space="preserve">
          <source>There is no strictness (&lt;code&gt;!&lt;/code&gt;) or laziness (&lt;code&gt;~&lt;/code&gt;) annotation in the source, so it is tagged with &lt;code&gt;'NoSourceStrictness&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;'NoSourceStrictness&lt;/code&gt; аннотаций строгости ( &lt;code&gt;!&lt;/code&gt; ) Или лени ( &lt;code&gt;~&lt;/code&gt; ), поэтому они помечены тегом 'NoSourceStrictness .</target>
        </trans-unit>
        <trans-unit id="8f5d3d572ae2ac9987e9d1633cf25db9cd582d12" translate="yes" xml:space="preserve">
          <source>There is no way to place restrictions on the modules that &lt;code&gt;Danger&lt;/code&gt; can import. This gives the author of &lt;code&gt;Danger&lt;/code&gt; a very large attack surface, essentially any package currently installed on the system. Should any of these packages have a vulnerability, then the &lt;code&gt;Danger&lt;/code&gt; module can exploit it.</source>
          <target state="translated">Невозможно установить ограничения на модули, которые &lt;code&gt;Danger&lt;/code&gt; может импортировать. Это дает автору &lt;code&gt;Danger&lt;/code&gt; очень большую поверхность для атаки, по сути, любой пакет, установленный в системе в настоящее время. Если в каком-либо из этих пакетов есть уязвимость, модуль &lt;code&gt;Danger&lt;/code&gt; может ее использовать.</target>
        </trans-unit>
        <trans-unit id="c7097b975bff4ec34afcba2f720e5f54ab84dec8" translate="yes" xml:space="preserve">
          <source>There is no way to provide more input other than the initial data. To be able to incrementally give more data, see the incremental input interface.</source>
          <target state="translated">Нет способа предоставить больше ввода,чем исходные данные.Чтобы иметь возможность вводить больше данных инкрементально,см.интерфейс инкрементального ввода.</target>
        </trans-unit>
        <trans-unit id="154e0cf4b003872e3bd7a794778721cb530a308b" translate="yes" xml:space="preserve">
          <source>There is now some potential ambiguity in import and export lists; for example if you write &lt;code&gt;import M( (+) )&lt;/code&gt; do you mean the &lt;em&gt;function&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt; or the &lt;em&gt;type constructor&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt;? The default is the former, but with &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; (which is implied by &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt;) GHC allows you to specify the latter by preceding it with the keyword &lt;code&gt;type&lt;/code&gt;, thus:</source>
          <target state="translated">Теперь есть некоторая потенциальная двусмысленность в списках импорта и экспорта; например, если вы пишете &lt;code&gt;import M( (+) )&lt;/code&gt; , вы имеете в виду &lt;em&gt;функцию &lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; или &lt;em&gt;конструктор типа &lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; ? По умолчанию используется первое, но с &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt; &lt;code&gt;ExplicitNamespaces&lt;/code&gt; &lt;/a&gt; (что подразумевается &lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt; ) GHC позволяет вам указать последнее, поставив перед ним ключевое слово &lt;code&gt;type&lt;/code&gt; , таким образом:</target>
        </trans-unit>
        <trans-unit id="7c604d18d01de136afc7c368a4880b16051b91f7" translate="yes" xml:space="preserve">
          <source>There is one edge case: &lt;code&gt;reifyInstances ''Typeable tys&lt;/code&gt; currently always produces an empty list (no matter what &lt;code&gt;tys&lt;/code&gt; are given).</source>
          <target state="translated">Есть один &lt;code&gt;reifyInstances ''Typeable tys&lt;/code&gt; случай: reifyInstances '' Typeable tys в настоящее время всегда создает пустой список (независимо от того, какие &lt;code&gt;tys&lt;/code&gt; заданы).</target>
        </trans-unit>
        <trans-unit id="bfdf7e43230c9da3e741c2b02c054c33cbab26e7" translate="yes" xml:space="preserve">
          <source>There is one exception to this general rule: when you load a program with &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, or specify it when you invoke &lt;code&gt;ghci&lt;/code&gt;, you can give a filename rather than a module name. This filename is loaded if it exists, and it may contain any module you like. This is particularly convenient if you have several &lt;code&gt;Main&lt;/code&gt; modules in the same directory and you can&amp;rsquo;t call them all &lt;code&gt;Main.hs&lt;/code&gt;.</source>
          <target state="translated">Есть одно исключение из этого общего правила: когда вы загружаете программу с помощью &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; или указываете ее при вызове &lt;code&gt;ghci&lt;/code&gt; , вы можете указать имя файла, а не имя модуля. Это имя файла загружается, если оно существует, и может содержать любой понравившийся вам модуль. Это особенно удобно , если у вас есть несколько &lt;code&gt;Main&lt;/code&gt; модули в том же каталоге , и вы не можете назвать их все &lt;code&gt;Main.hs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a05b5aa7181827ccaae8d49cbc7cd70b222b777" translate="yes" xml:space="preserve">
          <source>There is one particularly tricky case that should be explained:</source>
          <target state="translated">Есть одно особенно сложное дело,которое следует объяснить:</target>
        </trans-unit>
        <trans-unit id="2c99c4cb4443d9b5c20eb143da1040b414ad6caa" translate="yes" xml:space="preserve">
          <source>There is one problem with syntactic ambiguity. Consider:</source>
          <target state="translated">Есть одна проблема с синтаксической неоднозначностью.Рассмотрим:</target>
        </trans-unit>
        <trans-unit id="ddd63182fb2553244a804aed12a58a139a850d50" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">На самом деле есть только один способ &amp;laquo;выполнить&amp;raquo; действие ввода-вывода: привязать его к &lt;code&gt;Main.main&lt;/code&gt; в вашей программе. Когда ваша программа запущена, будет выполняться ввод-вывод. Невозможно выполнить ввод-вывод из произвольной функции, если эта функция сама не находится в монаде &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; и вызывается в какой-то момент прямо или косвенно из &lt;code&gt;Main.main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f08ac2b068afd4addda982c60a0e8364828c216" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">На самом деле есть только один способ &amp;laquo;выполнить&amp;raquo; действие ввода-вывода: привязать его к &lt;code&gt;Main.main&lt;/code&gt; в вашей программе. Когда ваша программа запущена, будет выполняться ввод-вывод. Невозможно выполнить ввод-вывод из произвольной функции, если эта функция сама не находится в монаде &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; и вызывается в какой-то момент прямо или косвенно из &lt;code&gt;Main.main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6918723127704307a50ace1e32e77a7f8c5d3be" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">На самом деле есть только один способ &amp;laquo;выполнить&amp;raquo; действие ввода-вывода: привязать его к &lt;code&gt;Main.main&lt;/code&gt; в вашей программе. Когда ваша программа запущена, будет выполняться ввод-вывод. Невозможно выполнить ввод-вывод из произвольной функции, если эта функция сама не находится в монаде &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; и вызывается в какой-то момент прямо или косвенно из &lt;code&gt;Main.main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="626791f34e752bd7930c265d6230de29022cc4e4" translate="yes" xml:space="preserve">
          <source>There may be a short pause while GHCi loads the prelude and standard libraries, after which the prompt is shown. As the banner says, you can type &lt;a href=&quot;#ghci-cmd-:?&quot;&gt;&lt;code&gt;:?&lt;/code&gt;&lt;/a&gt; to see the list of commands available, and a half line description of each of them. We&amp;rsquo;ll explain most of these commands as we go along, and there is complete documentation for all the commands in &lt;a href=&quot;#ghci-commands&quot;&gt;GHCi commands&lt;/a&gt;.</source>
          <target state="translated">Может быть небольшая пауза, пока GHCi загружает прелюдию и стандартные библиотеки, после чего отображается приглашение. Как сказано в баннере, вы можете ввести &lt;a href=&quot;#ghci-cmd-:?&quot;&gt; &lt;code&gt;:?&lt;/code&gt; &lt;/a&gt;чтобы увидеть список доступных команд и полстрочное описание каждой из них. Мы объясним большинство этих команд по мере продвижения, и есть полная документация по всем командам в &lt;a href=&quot;#ghci-commands&quot;&gt;командах GHCi&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9713a5adae5fb837e7a87a5d86c5d3b524809755" translate="yes" xml:space="preserve">
          <source>There may be multiple weak pointers with the same key. In this case, the finalizers for each of these weak pointers will all be run in some arbitrary order, or perhaps concurrently, when the key dies. If the programmer specifies a finalizer that assumes it has the only reference to an object (for example, a file that it wishes to close), then the programmer must ensure that there is only one such finalizer.</source>
          <target state="translated">При использовании одного и того же ключа может быть несколько слабых мест.В этом случае все финализаторы для каждого из этих слабых мест будут запущены в произвольном порядке,или,возможно,одновременно,когда ключ умрет.Если программист указывает финализатор,который предполагает,что у него есть единственная ссылка на объект (например,файл,который он хочет закрыть),то он должен убедиться,что есть только один такой финализатор.</target>
        </trans-unit>
        <trans-unit id="baba37366d9f9a52b2ae50c41c0fcd79cb92d44f" translate="yes" xml:space="preserve">
          <source>There may be zero or more rules in a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; pragma, separated by semicolons (which may be generated by the layout rule).</source>
          <target state="translated">В прагме &lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; может быть ноль или более правил , разделенных точкой с запятой (которые могут быть сгенерированы правилом макета).</target>
        </trans-unit>
        <trans-unit id="80bec96acf35e3263bf84072cb37215ccbdcc675" translate="yes" xml:space="preserve">
          <source>There must be no spaces in the token &lt;code&gt;[quoter|&lt;/code&gt;.</source>
          <target state="translated">В лексеме &lt;code&gt;[quoter|&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="9a36b38bedcf9582a8dcc97581917a08cf4b8e95" translate="yes" xml:space="preserve">
          <source>There must be no value declarations, but there can be type signatures for values. For example, we might define the signature:</source>
          <target state="translated">Деклараций значений не должно быть,но для значений могут быть сигнатуры типов.Например,можно определить подпись:</target>
        </trans-unit>
        <trans-unit id="c81a592e40538f53e4039fb29ed298bfb5184ce7" translate="yes" xml:space="preserve">
          <source>There must be no value declarations, but there can be type signatures for values. For example:</source>
          <target state="translated">Деклараций значений не должно быть,но для значений могут быть сигнатуры типов.Например:</target>
        </trans-unit>
        <trans-unit id="d28bf64bbbaabed23b3240c076575673b0ed4a5c" translate="yes" xml:space="preserve">
          <source>There must be some restrictions on the equations of type families, lest we define an ambiguous rewrite system. So, equations of open type families are restricted to be compatible. Two type patterns are compatible if</source>
          <target state="translated">Должны быть некоторые ограничения на уравнения семейств типов,чтобы не определить неоднозначную систему переписывания.Таким образом,уравнения семейств открытого типа ограничены для совместимости.Два шаблона типа совместимы,если</target>
        </trans-unit>
        <trans-unit id="9d9581281214ffc3f58141d4c64d4cc52bc8ee9a" translate="yes" xml:space="preserve">
          <source>There used to be another variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; (namely &lt;code&gt;Par0&lt;/code&gt;), but it has since been deprecated.</source>
          <target state="translated">Раньше был другой вариант &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; (а именно &lt;code&gt;Par0&lt;/code&gt; ), но с тех пор он устарел.</target>
        </trans-unit>
        <trans-unit id="b7acc6a8e49bdd94e38648f0e9b48c1b6c527d3b" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a fine distinction between &lt;em&gt;concurrency&lt;/em&gt; and &lt;em&gt;parallelism&lt;/em&gt;: parallelism is all about making your program run &lt;em&gt;faster&lt;/em&gt; by making use of multiple processors simultaneously. Concurrency, on the other hand, is a means of abstraction: it is a convenient way to structure a program that must respond to multiple asynchronous events.</source>
          <target state="translated">Между &lt;em&gt;параллелизмом&lt;/em&gt; и &lt;em&gt;параллелизмом&lt;/em&gt; существует тонкое различие : параллелизм - это то, что ваша программа работает &lt;em&gt;быстрее за&lt;/em&gt; счет одновременного использования нескольких процессоров. С другой стороны, параллелизм - это средство абстракции: это удобный способ структурировать программу, которая должна реагировать на несколько асинхронных событий.</target>
        </trans-unit>
        <trans-unit id="510ad80f56b9b3197c81b4ce6586316af939e48c" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a special function to create the &lt;code&gt;StablePtr&lt;/code&gt;: &lt;code&gt;newStablePtrPrimMVar&lt;/code&gt;, because the RTS needs a &lt;code&gt;StablePtr&lt;/code&gt; to the primitive &lt;code&gt;MVar#&lt;/code&gt; object, and we can&amp;rsquo;t create that directly. Do &lt;em&gt;not&lt;/em&gt; just use &lt;code&gt;newStablePtr&lt;/code&gt; on the &lt;code&gt;MVar&lt;/code&gt;: your program will crash.</source>
          <target state="translated">Существует специальная функция для создания &lt;code&gt;StablePtr&lt;/code&gt; : &lt;code&gt;newStablePtrPrimMVar&lt;/code&gt; , потому что RTS требуется &lt;code&gt;StablePtr&lt;/code&gt; для примитивного объекта &lt;code&gt;MVar#&lt;/code&gt; , и мы не можем создать его напрямую. Вы &lt;em&gt;не&lt;/em&gt; просто использовать &lt;code&gt;newStablePtr&lt;/code&gt; на &lt;code&gt;MVar&lt;/code&gt; : программа зависнет.</target>
        </trans-unit>
        <trans-unit id="c6de6fee468bcddecbdfc815d3488f25d03ac030" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s an exception: you can use a Cygwin shell if the &lt;code&gt;CYGWIN&lt;/code&gt; environment variable does &lt;em&gt;not&lt;/em&gt; contain &lt;code&gt;tty&lt;/code&gt;. In this mode, the Cygwin shell behaves like a Windows console shell and console events are propagated to child processes. Note that the &lt;code&gt;CYGWIN&lt;/code&gt; environment variable must be set &lt;em&gt;before&lt;/em&gt; starting the Cygwin shell; changing it afterwards has no effect on the shell.</source>
          <target state="translated">Есть исключение: вы можете использовать оболочку Cygwin, если переменная среды &lt;code&gt;CYGWIN&lt;/code&gt; &lt;em&gt;не&lt;/em&gt; содержит &lt;code&gt;tty&lt;/code&gt; . В этом режиме оболочка Cygwin ведет себя как оболочка консоли Windows, а события консоли распространяются на дочерние процессы. Обратите внимание, что переменная среды &lt;code&gt;CYGWIN&lt;/code&gt; должна быть установлена &lt;em&gt;перед&lt;/em&gt; запуском оболочки Cygwin; его последующее изменение не влияет на оболочку.</target>
        </trans-unit>
        <trans-unit id="58c919b54688060e3273eb452f86f71d39670a13" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one other gotcha to bear in mind when using external libraries: if the library contains a &lt;code&gt;main()&lt;/code&gt; function, then this will be a link conflict with GHC&amp;rsquo;s own &lt;code&gt;main()&lt;/code&gt; function (eg. &lt;code&gt;libf2c&lt;/code&gt; and &lt;code&gt;libl&lt;/code&gt; have their own &lt;code&gt;main()&lt;/code&gt;s).</source>
          <target state="translated">При использовании внешних библиотек следует иметь в виду еще одну хитрость: если библиотека содержит функцию &lt;code&gt;main()&lt;/code&gt; , то это будет конфликт ссылок с собственной функцией &lt;code&gt;main()&lt;/code&gt; GHC (например, &lt;code&gt;libf2c&lt;/code&gt; и &lt;code&gt;libl&lt;/code&gt; имеют свои собственные &lt;code&gt;main()&lt;/code&gt; s ).</target>
        </trans-unit>
        <trans-unit id="164798370452dfaed74b9a96d15febf241d138cc" translate="yes" xml:space="preserve">
          <source>There's an implied &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; around every exception handler in a call to one of the &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; family of functions. This is because that is what you want most of the time - it eliminates a common race condition in starting an exception handler, because there may be no exception handler on the stack to handle another exception if one arrives immediately. If asynchronous exceptions are masked on entering the handler, though, we have time to install a new exception handler before being interrupted. If this weren't the default, one would have to write something like</source>
          <target state="translated">Вокруг каждого обработчика исключений при вызове одной из функций семейства &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; имеется подразумеваемая &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; . Это потому, что это то, что вы хотите большую часть времени - это устраняет обычное состояние гонки при запуске обработчика исключений, потому что в стеке может не быть обработчика исключений для обработки другого исключения, если оно возникает немедленно. Однако если асинхронные исключения маскируются при входе в обработчик, у нас есть время установить новый обработчик исключений, прежде чем они будут прерваны. Если бы это не было по умолчанию, пришлось бы написать что-то вроде</target>
        </trans-unit>
        <trans-unit id="609b73a306420ab86396c82ac4d964ed91191e2a" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;Names&lt;/code&gt; can be used to construct Template Haskell expressions, patterns, declarations etc. They may also be given as an argument to the &lt;code&gt;reify&lt;/code&gt; function.</source>
          <target state="translated">Эти &lt;code&gt;Names&lt;/code&gt; можно использовать для построения выражений, шаблонов, объявлений Template Haskell и т. Д. Они также могут быть переданы в качестве аргумента функции &lt;code&gt;reify&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bfa2b8abe1cf06d188efba9def47c2abdf571c7" translate="yes" xml:space="preserve">
          <source>These RTS options might be used (a) to avoid a GHC bug, (b) to see &amp;ldquo;what&amp;rsquo;s really happening&amp;rdquo;, or (c) because you feel like it. Not recommended for everyday use!</source>
          <target state="translated">Эти параметры RTS можно использовать (а), чтобы избежать ошибки GHC, (б), чтобы увидеть, &amp;laquo;что на самом деле происходит&amp;raquo;, или (в) потому что вам это нравится. Не рекомендуется для повседневного использования!</target>
        </trans-unit>
        <trans-unit id="91dc626b2d992ca1c73233bc91d37d37c8eaf57b" translate="yes" xml:space="preserve">
          <source>These and many other examples are given in papers by Hongwei Xi, and Tim Sheard. There is a longer introduction &lt;a href=&quot;http://www.haskell.org/haskellwiki/GADT&quot;&gt;on the wiki&lt;/a&gt;, and Ralf Hinze&amp;rsquo;s &lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;Fun with phantom types&lt;/a&gt; also has a number of examples. Note that papers may use different notation to that implemented in GHC.</source>
          <target state="translated">Эти и многие другие примеры приведены в статьях Хунвэя Си и Тима Шеарда. В &lt;a href=&quot;http://www.haskell.org/haskellwiki/GADT&quot;&gt;вики&lt;/a&gt; есть более подробное введение , и в книге Ральфа Хинце &amp;laquo; &lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;Веселье с фантомными типами&amp;raquo;&lt;/a&gt; также есть несколько примеров. Обратите внимание, что в документах могут использоваться обозначения, отличные от реализованных в GHC.</target>
        </trans-unit>
        <trans-unit id="1628b6a8ce1bd48c62947ef018bda935aa9c7989" translate="yes" xml:space="preserve">
          <source>These are available as &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapDefault&quot;&gt;bimapDefault&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifoldMapDefault&quot;&gt;bifoldMapDefault&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">Они доступны как &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapDefault&quot;&gt;bimapDefault&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifoldMapDefault&quot;&gt;bifoldMapDefault&lt;/a&gt;&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="5ccfc02746ae8237d14a062ea086c63733700661" translate="yes" xml:space="preserve">
          <source>These are available from the &lt;em&gt;Trustworthy&lt;/em&gt; module &lt;a href=&quot;data-coerce&quot;&gt;Data.Coerce&lt;/a&gt; as well</source>
          <target state="translated">Они доступны из &lt;em&gt;Благонадежного&lt;/em&gt; модуля &lt;a href=&quot;data-coerce&quot;&gt;Data.Coerce&lt;/a&gt; а</target>
        </trans-unit>
        <trans-unit id="74d061aa46ef3dc30721ffc21924ea94edea88fa" translate="yes" xml:space="preserve">
          <source>These are examples of &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;newtype&lt;/code&gt; declarations whose data constructors have polymorphic argument types:</source>
          <target state="translated">Это примеры объявлений &lt;code&gt;data&lt;/code&gt; и &lt;code&gt;newtype&lt;/code&gt; , конструкторы данных которых имеют полиморфные типы аргументов:</target>
        </trans-unit>
        <trans-unit id="4003d97f9fbee1ee32a83c010d7f3dad0e1ce9da" translate="yes" xml:space="preserve">
          <source>These are the platform the program is compiled to run on.</source>
          <target state="translated">Это платформа,на которой компилируется программа.</target>
        </trans-unit>
        <trans-unit id="bdf71604f8a74c2998b767206df5ca5f1622a6ed" translate="yes" xml:space="preserve">
          <source>These are the platform where GHC itself was compiled. Again, this would normally be identical to the build and target platforms.</source>
          <target state="translated">Это платформа,на которой был скомпилирован сам GHC.Опять же,это обычно идентично сборке и целевым платформам.</target>
        </trans-unit>
        <trans-unit id="250e57ac0724bf8197c79a6b2642a8db1471d94b" translate="yes" xml:space="preserve">
          <source>These are the platform where the program was built on. (That is, the target platform of GHC itself.) Ordinarily this is identical to the target platform. (It could potentially be different if cross-compiling.)</source>
          <target state="translated">Это платформа,на которой была построена программа.(То есть,целевая платформа самого GHC.)Обычно она идентична целевой платформе.(Потенциально она может отличаться при кросс-компиляции.)</target>
        </trans-unit>
        <trans-unit id="e196ab1e01bdb7196eee4d4b84c75e053f033500" translate="yes" xml:space="preserve">
          <source>These attributes have all properties turned off.</source>
          <target state="translated">Эти атрибуты имеют все свойства,отключенные.</target>
        </trans-unit>
        <trans-unit id="ffe393cc3b69c6a3b0293f6f3fcd06f44da059fe" translate="yes" xml:space="preserve">
          <source>These can be useful for investigating bugs or performance problems. They should &lt;em&gt;not&lt;/em&gt; be used in production code.</source>
          <target state="translated">Это может быть полезно для исследования ошибок или проблем с производительностью. Их &lt;em&gt;не&lt;/em&gt; следует использовать в производственном коде.</target>
        </trans-unit>
        <trans-unit id="aed0329f308d729cc20188cdcc6a8a99aaffdf45" translate="yes" xml:space="preserve">
          <source>These capabilities correspond directly to &lt;code&gt;cub&lt;/code&gt;, &lt;code&gt;cud&lt;/code&gt;, &lt;code&gt;cub1&lt;/code&gt;, &lt;code&gt;cud1&lt;/code&gt;, etc.</source>
          <target state="translated">Эти возможности соответствуют непосредственно &lt;code&gt;cub&lt;/code&gt; , &lt;code&gt;cud&lt;/code&gt; , &lt;code&gt;cub1&lt;/code&gt; , &lt;code&gt;cud1&lt;/code&gt; и т.д.</target>
        </trans-unit>
        <trans-unit id="bd3c163c0be4700d712f2f68f8583051146d63a1" translate="yes" xml:space="preserve">
          <source>These characters are: any whitespace, single quote, double quote, and the backslash character. The backslash character always escapes (i.e., passes through without further consideration) the character which follows. Characters can also be escaped in blocks by quoting (i.e., surrounding the blocks with matching pairs of either single- or double-quotes which are not themselves escaped).</source>
          <target state="translated">Этими символами являются:любой пробел,одиночная кавычка,двойная кавычка и символ обратного слеша.Символ обратной косой черты всегда проходит (т.е.проходит без дальнейшего рассмотрения)через символ,который следует за ним.Символы могут также экранироваться в блоках путем кавычек (т.е.окружать блоки соответствующими парами одинарных или двойных кавычек,которые сами по себе не экранируются).</target>
        </trans-unit>
        <trans-unit id="88446671dea618410eaf4183b1120fcd11d3045f" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Letter&quot;.</source>
          <target state="translated">Эти классы определены в базе &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;данных символов Unicode, являющейся&lt;/a&gt; частью стандарта Unicode. В том же документе определяется, что является и не является &amp;laquo;письмом&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="c1807a959c36ca6fd9beb8a2794aa09400e74ccf" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Mark&quot;.</source>
          <target state="translated">Эти классы определены в базе &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;данных символов Unicode, являющейся&lt;/a&gt; частью стандарта Unicode. В том же документе определяется, что является, а что не является &amp;laquo;Маркой&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="36ce8c81a08d5662b80e9c04ed3b305777ff4865" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Number&quot;.</source>
          <target state="translated">Эти классы определены в базе &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;данных символов Unicode, являющейся&lt;/a&gt; частью стандарта Unicode. В том же документе определяется, что является &amp;laquo;числом&amp;raquo;, а что нет.</target>
        </trans-unit>
        <trans-unit id="1ca887acc4c9422f8d94d31048ed94d01f03a1df" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Punctuation&quot;.</source>
          <target state="translated">Эти классы определены в базе &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;данных символов Unicode, являющейся&lt;/a&gt; частью стандарта Unicode. В том же документе определяется, что является, а что не является &amp;laquo;пунктуацией&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="97aa5ae0e404885ccbb1f0839fcfc76fda78a6a0" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Separator&quot;.</source>
          <target state="translated">Эти классы определены в базе &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;данных символов Unicode, являющейся&lt;/a&gt; частью стандарта Unicode. В том же документе определяется, что является, а что не является &amp;laquo;разделителем&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="0085c67836b35ed181dc391234356151ff198a63" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Symbol&quot;.</source>
          <target state="translated">Эти классы определены в базе &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;данных символов Unicode, являющейся&lt;/a&gt; частью стандарта Unicode. В том же документе определяется, что является, а что не является &amp;laquo;Символом&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d2bbab454e59aff928df94b81f4e1ad9b21ee61e" translate="yes" xml:space="preserve">
          <source>These classes are needed to express the constraints on arguments of transformers in portable Haskell. Thus for a new transformer &lt;code&gt;T&lt;/code&gt;, one might write instances like</source>
          <target state="translated">Эти классы необходимы для выражения ограничений на аргументы преобразователей в переносимом Haskell. Таким образом, для нового трансформатора &lt;code&gt;T&lt;/code&gt; можно написать такие экземпляры, как</target>
        </trans-unit>
        <trans-unit id="ecabcfc2f9f8f1c027e2b554e4eeb92b03b4ed7a" translate="yes" xml:space="preserve">
          <source>These considerations lead to the following definition of an orphan module:</source>
          <target state="translated">Эти соображения приводят к следующему определению модуля для сирот:</target>
        </trans-unit>
        <trans-unit id="69b631231106b6921f1338cd2572fe5af0f2aed2" translate="yes" xml:space="preserve">
          <source>These ensure by parametricity:</source>
          <target state="translated">Они обеспечивают параметричность:</target>
        </trans-unit>
        <trans-unit id="1c94b9ce2b7b8a075e14ec3d210b949731ecf5dd" translate="yes" xml:space="preserve">
          <source>These events are &lt;em&gt;always&lt;/em&gt; bugs in the GHC system&amp;mdash;please report them.</source>
          <target state="translated">Эти события &lt;em&gt;всегда&lt;/em&gt; являются ошибками в системе GHC - пожалуйста, сообщайте о них.</target>
        </trans-unit>
        <trans-unit id="09f4acb6e8b78da06e81f543939fe79889775b0e" translate="yes" xml:space="preserve">
          <source>These flags cause a warning to be emitted whenever the module contains an &amp;ldquo;orphan&amp;rdquo; instance declaration or rewrite rule. An instance declaration is an orphan if it appears in a module in which neither the class nor the type being instanced are declared in the same module. A rule is an orphan if it is a rule for a function declared in another module. A module containing any orphans is called an orphan module.</source>
          <target state="translated">Эти флаги вызывают выдачу предупреждения всякий раз, когда модуль содержит объявление экземпляра &amp;laquo;сироты&amp;raquo; или правило перезаписи. Объявление экземпляра является сиротой, если оно появляется в модуле, в котором ни класс, ни тип, экземпляры которого не объявлены в одном и том же модуле. Правило считается бессмысленным, если оно является правилом для функции, объявленной в другом модуле. Модуль, содержащий сирот, называется сиротским модулем.</target>
        </trans-unit>
        <trans-unit id="f0be1d5ef4d9e5d0305e16236e92919668b3542f" translate="yes" xml:space="preserve">
          <source>These flags dump various bits of information from other backends.</source>
          <target state="translated">Эти флаги сбрасывают различные биты информации из других бэкэндов.</target>
        </trans-unit>
        <trans-unit id="75f158b9172ea17ad4d5194db1770cdf0cf93969" translate="yes" xml:space="preserve">
          <source>These flags dump various information from GHC&amp;rsquo;s frontend. This includes the parser and interface file reader.</source>
          <target state="translated">Эти флаги сбрасывают различную информацию из внешнего интерфейса GHC. Сюда входят парсер и программа чтения файлов интерфейса.</target>
        </trans-unit>
        <trans-unit id="80527f61b7ffbd366f80d35ee856592a4fb81ac7" translate="yes" xml:space="preserve">
          <source>These flags dump various information from GHC&amp;rsquo;s typechecker and renamer.</source>
          <target state="translated">Эти флаги сбрасывают различную информацию из средства проверки типов и переименования GHC.</target>
        </trans-unit>
        <trans-unit id="737447733be0073bcfb0ebe996cc210f9d81061b" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s C-\- pipeline.</source>
          <target state="translated">Эти флаги сбрасывают различные фазы конвейера C - \ - GHC.</target>
        </trans-unit>
        <trans-unit id="c31a5070b8b7325f8e684e34ef92ab92bce24202" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s Core-to-Core pipeline. This begins with the desugarer and includes the simplifier, worker-wrapper transformation, the rule engine, the specialiser, the strictness/occurrence analyser, and a common subexpression elimination pass.</source>
          <target state="translated">Эти флаги выводят различные фазы конвейера GHC Core-to-Core. Это начинается с десугарера и включает в себя упрощение, преобразование рабочего-обертки, механизм правил, специализацию, анализатор строгости / вхождения и общий проход исключения подвыражения.</target>
        </trans-unit>
        <trans-unit id="32dfc551027fdbf9ccfd3e77612e0c59b50c9935" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s STG pipeline.</source>
          <target state="translated">Эти флаги сбрасывают различные фазы конвейера STG GHC.</target>
        </trans-unit>
        <trans-unit id="f8953ce25d58cce161a8b147fdb564f9d26b5f79" translate="yes" xml:space="preserve">
          <source>These flags dump various stages of the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&amp;rsquo;s&lt;/a&gt; pipeline, which starts with C-\- and produces native assembler.</source>
          <target state="translated">Эти флаги выводят различные этапы конвейера &lt;a href=&quot;codegens#native-code-gen&quot;&gt;генератора машинного кода&lt;/a&gt; , который начинается с C - \ - и производит собственный ассемблер.</target>
        </trans-unit>
        <trans-unit id="5a9c258270b924908c72940341b1bf3870701ad6" translate="yes" xml:space="preserve">
          <source>These flags turn on and off individual optimisations. Flags marked as on by default are enabled by &lt;code&gt;-O&lt;/code&gt;, and as such you shouldn&amp;rsquo;t need to set any of them explicitly. A flag &lt;code&gt;-fwombat&lt;/code&gt; can be negated by saying &lt;code&gt;-fno-wombat&lt;/code&gt;.</source>
          <target state="translated">Эти флаги включают и выключают индивидуальную оптимизацию. Флаги, помеченные как включенные по умолчанию, включаются параметром &lt;code&gt;-O&lt;/code&gt; , и поэтому вам не нужно устанавливать какие-либо из них явно. Флаг &lt;code&gt;-fwombat&lt;/code&gt; можно отменить , сказав &lt;code&gt;-fno-wombat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ece68321e5560730979acb0e7829aea5fbe330bb" translate="yes" xml:space="preserve">
          <source>These formatters for standard types are provided for convenience in writting new type-specific formatters: a common pattern is to throw to &lt;code&gt;&lt;a href=&quot;text-printf#v:formatString&quot;&gt;formatString&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:formatInteger&quot;&gt;formatInteger&lt;/a&gt;&lt;/code&gt; to do most of the format handling for a new type.</source>
          <target state="translated">Эти средства форматирования для стандартных типов предоставляются для удобства при написании новых средств форматирования для конкретных типов: общий шаблон - это бросить в &lt;code&gt;&lt;a href=&quot;text-printf#v:formatString&quot;&gt;formatString&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;text-printf#v:formatInteger&quot;&gt;formatInteger&lt;/a&gt;&lt;/code&gt; для выполнения большей части обработки форматирования для нового типа.</target>
        </trans-unit>
        <trans-unit id="fc91b827c083dbd45f008d452eca5cbbc4e33106" translate="yes" xml:space="preserve">
          <source>These four properties guarantee that in the safe language you can trust the types, can trust that module export lists are respected, and can trust that code that successfully compiles has the same meaning as it normally would.</source>
          <target state="translated">Эти четыре свойства гарантируют,что в безопасном языке вы можете доверять типам,доверять спискам экспорта модулей и доверять тому коду,который успешно компилируется,имеет то же значение,что и обычно.</target>
        </trans-unit>
        <trans-unit id="35ae2beea0fb02fcbb417bbf0693881c21546df6" translate="yes" xml:space="preserve">
          <source>These functions are also exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;.</source>
          <target state="translated">Эти функции также экспортируются &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c604c71a535978679ce64e0e3febc1178933cc0" translate="yes" xml:space="preserve">
          <source>These functions are different from their &lt;code&gt;CAString&lt;/code&gt; counterparts in that they will use an encoding determined by the current locale, rather than always assuming ASCII.</source>
          <target state="translated">Эти функции отличаются от своих аналогов в &lt;code&gt;CAString&lt;/code&gt; тем, что они будут использовать кодировку, определяемую текущей локалью, а не всегда предполагать ASCII.</target>
        </trans-unit>
        <trans-unit id="e34dd974b452bf37c7be3a6a7ec33bf5624e1212" translate="yes" xml:space="preserve">
          <source>These functions are overloaded because they need to return a different result, depending on the type at which they are instantiated.</source>
          <target state="translated">Эти функции перегружены,так как они должны возвращать различный результат в зависимости от типа,при котором они инстанциированы.</target>
        </trans-unit>
        <trans-unit id="3fd5d872cb809dc7eab9796c42ba21fcde97b5d0" translate="yes" xml:space="preserve">
          <source>These functions are undefined when the amount being shifted by is greater than the size in bits of a machine Int#.</source>
          <target state="translated">Эти функции не определены,если перемещаемая сумма больше,чем размер в битах машины Int#.</target>
        </trans-unit>
        <trans-unit id="cd72a3a3a954bf10ebc8f9a2fc149a849293aaa3" translate="yes" xml:space="preserve">
          <source>These functions are used internally to raise various errors, and are exported for use by new type-specific formatters.</source>
          <target state="translated">Эти функции используются внутри организации для поднятия различных ошибок,и экспортируются для использования в новых форматорах,специфичных для данного типа.</target>
        </trans-unit>
        <trans-unit id="c27bbed0c97953b2719d8da964d4e3a7142b3841" translate="yes" xml:space="preserve">
          <source>These functions can be used to assemble &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instances for new algebraic types. For example, given the definition</source>
          <target state="translated">Эти функции могут использоваться для сборки экземпляров &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; для новых алгебраических типов. Например, учитывая определение</target>
        </trans-unit>
        <trans-unit id="e463371a563c760dcfec2c52c04107908b9de66f" translate="yes" xml:space="preserve">
          <source>These functions do not bind a levity-polymorphic variable, and so are accepted. Their polymorphism allows users to use these to conveniently stub out functions that return unboxed types.</source>
          <target state="translated">Эти функции не связывают летучесть-полиморфную переменную,и поэтому принимаются.Их полиморфизм позволяет пользователям использовать их для удобного удаления функций,возвращающих неупакованные типы.</target>
        </trans-unit>
        <trans-unit id="ac46513bf01921ab26c4cb23e80d8b1179daf25b" translate="yes" xml:space="preserve">
          <source>These functions generalize their namesakes in the portable &lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt; module by allowing arbitrary &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions as finalizers. These finalizers necessarily run in a separate thread, cf. &lt;em&gt;Destructors, Finalizers and Synchronization&lt;/em&gt;, by Hans Boehm, &lt;em&gt;POPL&lt;/em&gt;, 2003.</source>
          <target state="translated">Эти функции обобщают своих тезок в переносном модуле &lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt; , разрешая произвольные действия &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; качестве финализаторов. Эти финализаторы обязательно запускаются в отдельном потоке, см. &lt;em&gt;Деструкторы, финализаторы и синхронизация&lt;/em&gt; , Ханс Бём, &lt;em&gt;POPL&lt;/em&gt; , 2003.</target>
        </trans-unit>
        <trans-unit id="b06b54f2742e82f9cabcd9c259ec3cd116dcc35a" translate="yes" xml:space="preserve">
          <source>These functions perform sequential searches from the left or right ends of the sequence, returning indices of matching elements.</source>
          <target state="translated">Эти функции выполняют последовательный поиск с левого или правого конца последовательности,возвращая индексы совпадающих элементов.</target>
        </trans-unit>
        <trans-unit id="87221aea594a26d1e5e903734013d102fe1beb59" translate="yes" xml:space="preserve">
          <source>These functions pre-date &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; which is much more flexible.</source>
          <target state="translated">Эти функции предшествуют &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; , что гораздо более гибко.</target>
        </trans-unit>
        <trans-unit id="1eeda2971d19159845b63c113a7cf985d383a44c" translate="yes" xml:space="preserve">
          <source>These functions treat a list &lt;code&gt;xs&lt;/code&gt; as a indexed collection, with indices ranging from 0 to &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt;.</source>
          <target state="translated">Эти функции обрабатывают список &lt;code&gt;xs&lt;/code&gt; как индексированную коллекцию с индексами в диапазоне от 0 до &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7ede5395fcce38fdb04439abff0ca42b7e07f35" translate="yes" xml:space="preserve">
          <source>These functions treat a list &lt;code&gt;xs&lt;/code&gt; as a indexed collection, with indices ranging from 0 to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt;.</source>
          <target state="translated">Эти функции обрабатывают список &lt;code&gt;xs&lt;/code&gt; как индексированную коллекцию с индексами в диапазоне от 0 до &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6835f6ad62f6fd820ed297487e2ff455f3cd8e7d" translate="yes" xml:space="preserve">
          <source>These instances are compatible because they differ in their implicit kind parameter; the first uses &lt;code&gt;Type&lt;/code&gt; while the second uses &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;.</source>
          <target state="translated">Эти экземпляры совместимы, потому что они различаются неявным параметром вида; первый использует &lt;code&gt;Type&lt;/code&gt; , а второй &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc48d2e2d27233c00c2c501c66ece98f84417e79" translate="yes" xml:space="preserve">
          <source>These macros are available starting with GHC 7.10.1.</source>
          <target state="translated">Эти макросы доступны,начиная с GHC 7.10.1.</target>
        </trans-unit>
        <trans-unit id="ae04819a18b26fdceb2be29551deb7ed3acdae2e" translate="yes" xml:space="preserve">
          <source>These macros are provided for allowing finer granularity than is provided by &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt;. Usually, this should not be necessary as it&amp;rsquo;s expected for most APIs to remain stable between patchlevel releases, but occasionally internal API changes are necessary to fix bugs. Also conditional compilation on the patchlevel can be useful for working around bugs in older releases.</source>
          <target state="translated">Эти макросы предназначены для обеспечения &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; детализации, чем это предусмотрено __GLASGOW_HASKELL__ . Обычно в этом нет необходимости, поскольку ожидается, что большинство API-интерфейсов будут оставаться стабильными между выпусками уровня исправлений, но иногда для исправления ошибок необходимы внутренние изменения API. Также условная компиляция на уровне исправлений может быть полезна для работы с ошибками в старых выпусках.</target>
        </trans-unit>
        <trans-unit id="51848f2520dc3b8114fc872d0ac65b69f5df9473" translate="yes" xml:space="preserve">
          <source>These macros are set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. &lt;code&gt;.hs&lt;/code&gt;, &lt;code&gt;.lhs&lt;/code&gt;, &lt;code&gt;.c&lt;/code&gt; and &lt;code&gt;.hc&lt;/code&gt; files).</source>
          <target state="translated">Эти макросы устанавливаются при предварительной обработке исходного кода Haskell и исходного кода C, включая исходный код C, созданный из модуля Haskell (т.е. &lt;code&gt;.hs&lt;/code&gt; , &lt;code&gt;.lhs&lt;/code&gt; , &lt;code&gt;.c&lt;/code&gt; и &lt;code&gt;.hc&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="11abca0ebcb35da15e9aef05f3cdf6611aa84840" translate="yes" xml:space="preserve">
          <source>These modules are intended to be imported qualified, to avoid name clashes with Prelude functions, e.g.</source>
          <target state="translated">Эти модули предназначены для импорта квалифицированными,чтобы избежать столкновения имен с функциями Prelude,например.</target>
        </trans-unit>
        <trans-unit id="d535f64275335663d5441026d12ac809514c2eb8" translate="yes" xml:space="preserve">
          <source>These operations return &lt;code&gt;0#&lt;/code&gt; and &lt;code&gt;1#&lt;/code&gt; instead of &lt;code&gt;False&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt; respectively. See &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/PrimBool&quot;&gt;PrimBool wiki-page&lt;/a&gt; for more details</source>
          <target state="translated">Эти операции возвращают &lt;code&gt;0#&lt;/code&gt; и &lt;code&gt;1#&lt;/code&gt; вместо &lt;code&gt;False&lt;/code&gt; и &lt;code&gt;True&lt;/code&gt; соответственно. См. &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/PrimBool&quot;&gt;Вики-страницу PrimBool&lt;/a&gt; для получения более подробной информации.</target>
        </trans-unit>
        <trans-unit id="8961645f51f3a1b4a6c3aeed91a6e9fbf3f8051c" translate="yes" xml:space="preserve">
          <source>These options are described in more detail in &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;. If a flag is implied by &lt;code&gt;-O&lt;/code&gt; then it is also implied by &lt;code&gt;-O2&lt;/code&gt; (unless flag description explicitly says otherwise). If a flag is implied by &lt;code&gt;-O0&lt;/code&gt; only then the flag is not implied by &lt;code&gt;-O&lt;/code&gt; and &lt;code&gt;-O2&lt;/code&gt;.</source>
          <target state="translated">Эти параметры описаны более подробно в &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f *: независимые от платформы флаги&lt;/a&gt; . Если флаг подразумевается &lt;code&gt;-O&lt;/code&gt; , то он также подразумевается &lt;code&gt;-O2&lt;/code&gt; (если в описании флага явно не указано иное). Если флаг подразумевается только &lt;code&gt;-O0&lt;/code&gt; , тогда флаг не подразумевается &lt;code&gt;-O&lt;/code&gt; и &lt;code&gt;-O2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9993a1a47c7b56cbbe65138c2297b44c73f9916e" translate="yes" xml:space="preserve">
          <source>These options are described in more detail in &lt;a href=&quot;using-optimisation#options-optimise&quot;&gt;Optimisation (code improvement)&lt;/a&gt;.</source>
          <target state="translated">Эти параметры более подробно описаны в &lt;a href=&quot;using-optimisation#options-optimise&quot;&gt;разделе Оптимизация (улучшение кода)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44d239e97dcf0e2e0c134a87fda302f26adf7c6a" translate="yes" xml:space="preserve">
          <source>These options control which warnings are considered fatal and cause compilation to abort.</source>
          <target state="translated">Эти опции контролируют,какие предупреждения считаются фатальными и приводят к прерыванию компиляции.</target>
        </trans-unit>
        <trans-unit id="edb593ad00abb81748bd2751cf62f6efe475d39f" translate="yes" xml:space="preserve">
          <source>These options produce runtime-system statistics, such as the amount of time spent executing the program and in the garbage collector, the amount of memory allocated, the maximum size of the heap, and so on. The three variants give different levels of detail: &lt;code&gt;-T&lt;/code&gt; collects the data but produces no output &lt;code&gt;-t&lt;/code&gt; produces a single line of output in the same format as GHC&amp;rsquo;s &lt;code&gt;-Rghc-timing&lt;/code&gt; option, &lt;code&gt;-s&lt;/code&gt; produces a more detailed summary at the end of the program, and &lt;code&gt;-S&lt;/code&gt; additionally produces information about each and every garbage collection. Passing &lt;code&gt;--internal-counters&lt;/code&gt; to a threaded runtime will cause a detailed summary to include various internal counts accumulated during the run; note that these are unspecified and may change between releases.</source>
          <target state="translated">Эти параметры производят статистику системы времени выполнения, такую ​​как время, потраченное на выполнение программы и сборщик мусора, объем выделенной памяти, максимальный размер кучи и т. Д. Три варианта дают разные уровни детализации: &lt;code&gt;-T&lt;/code&gt; собирает данные, но не выводит &lt;code&gt;-t&lt;/code&gt; производит одну строку вывода в том же формате, что и параметр &lt;code&gt;-Rghc-timing&lt;/code&gt; в GHC , &lt;code&gt;-s&lt;/code&gt; выводит более подробную сводку в конце program, а &lt;code&gt;-S&lt;/code&gt; дополнительно выдает информацию о каждой сборке мусора. Проходящие &lt;code&gt;--internal-counters&lt;/code&gt; для потоковой среды выполнения приведет к тому, что подробный отчет будет включать различные внутренние счетчики, накопленные во время выполнения; обратите внимание, что они не указаны и могут меняться между выпусками.</target>
        </trans-unit>
        <trans-unit id="dba900fff87161f43a1a12316670eef680c82d4e" translate="yes" xml:space="preserve">
          <source>These overheads can all be reduced by 1 word (4 or 8 bytes) when the &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;ByteString&lt;/code&gt; is unpacked into another constructor.</source>
          <target state="translated">Эти накладные расходы могут быть уменьшены на 1 слово (4 или 8 байтов), когда &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;ByteString&lt;/code&gt; распакованы в другой конструктор.</target>
        </trans-unit>
        <trans-unit id="77a27181cfeb12715305d9aa476246d068b548fa" translate="yes" xml:space="preserve">
          <source>These papers and more information on arrows can be found at &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;.</source>
          <target state="translated">Эти документы и дополнительную информацию о стрелках можно найти на &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5504af0f139900075ad2b30112ac4cea1fe57d9" translate="yes" xml:space="preserve">
          <source>These patterns are only available with GHC version 8.0 or later, and version 8.2 works better with them. When writing for such recent versions of GHC, the patterns can be used in place of &lt;code&gt;&lt;a href=&quot;data-sequence#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:-60--124-&quot;&gt;&amp;lt;|&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:-124--62-&quot;&gt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewl&quot;&gt;viewl&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewr&quot;&gt;viewr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эти шаблоны доступны только в GHC версии 8.0 или новее, и версия 8.2 лучше с ними работает. При написании для таких последних версий GHC шаблоны можно использовать вместо &lt;code&gt;&lt;a href=&quot;data-sequence#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:-60--124-&quot;&gt;&amp;lt;|&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:-124--62-&quot;&gt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewl&quot;&gt;viewl&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewr&quot;&gt;viewr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f52ff49b136cf09c728f4803c3178f859a7070f" translate="yes" xml:space="preserve">
          <source>These potentially overlap, but GHC will not complain about the instance declarations themselves, regardless of flag settings. If we later try to solve the constraint &lt;code&gt;(C Int Char)&lt;/code&gt; then only the first instance matches, and all is well. Similarly with &lt;code&gt;(C Bool Bool)&lt;/code&gt;. But if we try to solve &lt;code&gt;(C Int Bool)&lt;/code&gt;, both instances match and an error is reported.</source>
          <target state="translated">Они потенциально перекрываются, но GHC не будет жаловаться на сами объявления экземпляров, независимо от настроек флага. Если позже мы попытаемся решить ограничение &lt;code&gt;(C Int Char)&lt;/code&gt; , то будет соответствовать только первый экземпляр, и все будет хорошо. Аналогично &lt;code&gt;(C Bool Bool)&lt;/code&gt; . Но если мы попытаемся решить &lt;code&gt;(C Int Bool)&lt;/code&gt; , оба экземпляра совпадают, и выдается сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="78d456d26025630626ea67fc9dac499928672c61" translate="yes" xml:space="preserve">
          <source>These pragmas control the inlining of function definitions.</source>
          <target state="translated">Эти прагмы контролируют включение определений функций.</target>
        </trans-unit>
        <trans-unit id="22fb4604da24a31c3e12ce8e599a649d4ce43f31" translate="yes" xml:space="preserve">
          <source>These restrictions are easily verified and ensure termination of type inference. However, they are not sufficient to guarantee completeness of type inference in the presence of, so called, &amp;lsquo;&amp;rsquo;loopy equalities&amp;rsquo;&amp;lsquo;, such as &lt;code&gt;a ~ [F a]&lt;/code&gt;, where a recursive occurrence of a type variable is underneath a family application and data constructor application - see the above mentioned paper for details.</source>
          <target state="translated">Эти ограничения легко проверяются и обеспечивают завершение вывода типа. Однако их недостаточно, чтобы гарантировать полноту вывода типа при наличии так называемых &amp;laquo;зацикленных равенств&amp;raquo;, таких как &lt;code&gt;a ~ [F a]&lt;/code&gt; , где рекурсивное вхождение переменной типа находится под приложением семейства и приложение конструктора данных - подробности см. в упомянутой выше статье.</target>
        </trans-unit>
        <trans-unit id="48d1370baaba0621634fda1bb9a7a71066b21b10" translate="yes" xml:space="preserve">
          <source>These restrictions ensure that instance resolution terminates: each reduction step makes the problem smaller by at least one constructor. You can find lots of background material about the reason for these restrictions in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp06.pdf&quot;&gt;Understanding functional dependencies via Constraint Handling Rules&lt;/a&gt;.</source>
          <target state="translated">Эти ограничения гарантируют прекращение разрешения экземпляра: каждый шаг сокращения уменьшает проблему по крайней мере на один конструктор. Вы можете найти множество справочных материалов о причинах этих ограничений в статье &amp;laquo; &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp06.pdf&quot;&gt;Понимание функциональных зависимостей с помощью правил обработки ограничений&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="592370c8132dc473f31cbaadabc6eeb1ffecffbf" translate="yes" xml:space="preserve">
          <source>These rules restrict record wildcards to the situations in which the user could have written the expanded version. For example</source>
          <target state="translated">Эти правила ограничивают подстановочные знаки записи ситуациями,в которых пользователь мог бы написать расширенную версию.Например</target>
        </trans-unit>
        <trans-unit id="abaf6ec94bf4ef17c830c2d7ac28ed21cea0a752" translate="yes" xml:space="preserve">
          <source>These types are needed for implementing processing variable numbers of arguments to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;. Their implementation is intentionally not visible from this module. If you attempt to pass an argument of a type which is not an instance of the appropriate class to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;, then the compiler will report it as a missing instance of &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt;. (All &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; instances are &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; instances.)</source>
          <target state="translated">Эти типы необходимы для реализации обработки переменного числа аргументов для &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; . Их реализация намеренно не видна из этого модуля. Если вы попытаетесь передать аргумент типа, который не является экземпляром соответствующего класса, в &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; , компилятор сообщит об этом как об отсутствующем экземпляре &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; . (Все &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; экземпляры &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; экземпляров.)</target>
        </trans-unit>
        <trans-unit id="3469c326f3dbcba25a670f8c1849f69a780e1258" translate="yes" xml:space="preserve">
          <source>These types are needed to accurately represent C function prototypes, in order to access C library interfaces in Haskell. The Haskell system is not required to represent those types exactly as C does, but the following guarantees are provided concerning a Haskell type &lt;code&gt;CT&lt;/code&gt; representing a C type &lt;code&gt;t&lt;/code&gt;:</source>
          <target state="translated">Эти типы необходимы для точного представления прототипов функций C, чтобы получить доступ к интерфейсам библиотеки C в Haskell. Система Haskell не обязана представлять эти типы точно так, как это делает C, но следующие гарантии предоставляются в отношении типа &lt;code&gt;CT&lt;/code&gt; Haskell, представляющего тип C &lt;code&gt;t&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b652ab9b4675e4c25fc44cf381751d29366f1a60" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt;. That does mean that &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CFloat&quot;&gt;CFloat&lt;/a&gt;&lt;/code&gt;'s (respectively &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CDouble&quot;&gt;CDouble&lt;/a&gt;&lt;/code&gt;'s) instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; are as badly behaved as &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s (respectively &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s).</source>
          <target state="translated">Эти типы представлены как &lt;code&gt;newtype&lt;/code&gt; s для &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; и являются экземплярами &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; . Это означает, что &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CFloat&quot;&gt;CFloat&lt;/a&gt;&lt;/code&gt; (соответственно &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CDouble&quot;&gt;CDouble&lt;/a&gt;&lt;/code&gt; ) &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; ведут себя так же плохо, как и &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; (соответственно &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="295b080f792318eefb2add5c8eb45291f13a7e87" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of basic foreign types, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эти типы представлены как &lt;code&gt;newtype&lt;/code&gt; базовых внешних типов и являются экземплярами &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f054008a97c12316c3d9d18cd331b115ccbe12b8" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of types in &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt; and &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эти типы представлены как &lt;code&gt;newtype&lt;/code&gt; типов в &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt; и &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt; и являются экземплярами &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b7b616a2441a5d70ac85ff090a7d0d4463488a1" translate="yes" xml:space="preserve">
          <source>These variants of the above functions are for use with C libraries that are ignorant of Unicode. These functions should be used with care, as a loss of information can occur.</source>
          <target state="translated">Эти варианты вышеуказанных функций предназначены для использования с библиотеками Си,которые не знают Юникода.Эти функции следует использовать с осторожностью,так как может произойти потеря информации.</target>
        </trans-unit>
        <trans-unit id="aa092d86f68a166e6d23f0ee7479403178f2a4af" translate="yes" xml:space="preserve">
          <source>These variants of the above functions are for use with C libraries that encode Unicode using the C &lt;code&gt;wchar_t&lt;/code&gt; type in a system-dependent way. The only encodings supported are</source>
          <target state="translated">Эти варианты вышеуказанных функций предназначены для использования с библиотеками C, которые кодируют Unicode с использованием типа C &lt;code&gt;wchar_t&lt;/code&gt; системно-зависимым способом. Поддерживаются только кодировки:</target>
        </trans-unit>
        <trans-unit id="cf17f1abe56035fa55a6c2c80d745a4d6a39b4ee" translate="yes" xml:space="preserve">
          <source>They tell &lt;code&gt;make&lt;/code&gt; that if any of &lt;code&gt;Foo.o&lt;/code&gt;, &lt;code&gt;Foo.hc&lt;/code&gt; or &lt;code&gt;Foo.s&lt;/code&gt; have an earlier modification date than &lt;code&gt;Baz.hi&lt;/code&gt;, then the out-of-date file must be brought up to date. To bring it up to date, &lt;code&gt;make&lt;/code&gt; looks for a rule to do so; one of the preceding suffix rules does the job nicely. These dependencies can be generated automatically by &lt;code&gt;ghc&lt;/code&gt;; see &lt;a href=&quot;#makefile-dependencies&quot;&gt;Dependency generation&lt;/a&gt;</source>
          <target state="translated">Они говорят &lt;code&gt;make&lt;/code&gt; , что если какой-либо из &lt;code&gt;Foo.o&lt;/code&gt; , &lt;code&gt;Foo.hc&lt;/code&gt; или &lt;code&gt;Foo.s&lt;/code&gt; имеет более раннюю дату модификации, чем &lt;code&gt;Baz.hi&lt;/code&gt; , то устаревший файл должен быть обновлен. Для того, чтобы довести его до настоящего времени, &lt;code&gt;make&lt;/code&gt; внешний вид для правила , чтобы сделать это; одно из предыдущих суффиксных правил отлично справляется с этой задачей. Эти зависимости могут быть созданы автоматически с помощью &lt;code&gt;ghc&lt;/code&gt; ; см. &lt;a href=&quot;#makefile-dependencies&quot;&gt;Генерация зависимостей&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b503ef61ed50540af2f4fe9c35e29285e4503b69" translate="yes" xml:space="preserve">
          <source>They were introduced in the paper &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;&quot;Concurrent Haskell&quot;&lt;/a&gt; by Simon Peyton Jones, Andrew Gordon and Sigbjorn Finne, though some details of their implementation have since then changed (in particular, a put on a full &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; used to error, but now merely blocks.)</source>
          <target state="translated">Они были представлены в статье Саймона Пейтона Джонса, Эндрю Гордона и Сигбьорна Финна &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;&amp;laquo;Параллельный Haskell&amp;raquo;&lt;/a&gt; , хотя некоторые детали их реализации с тех пор изменились (в частности, установка полного &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; раньше приводила к ошибке, а теперь просто блокирует. )</target>
        </trans-unit>
        <trans-unit id="a212ed0a68d3d89040f3257b134393f9ede21b72" translate="yes" xml:space="preserve">
          <source>Things to be aware of:</source>
          <target state="translated">Вещи,о которых нужно знать:</target>
        </trans-unit>
        <trans-unit id="51a09d230b46ace5589e6c42048887aed8066c2f" translate="yes" xml:space="preserve">
          <source>This &quot;function&quot; has a superficial similarity to &lt;code&gt;unsafePerformIO&lt;/code&gt; but it is in fact a malevolent agent of chaos. It unpicks the seams of reality (and the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad) so that the normal rules no longer apply. It lulls you into thinking it is reasonable, but when you are not looking it stabs you in the back and aliases all of your mutable buffers. The carcass of many a seasoned Haskell programmer lie strewn at its feet.</source>
          <target state="translated">Эта &amp;laquo;функция&amp;raquo; внешне &lt;code&gt;unsafePerformIO&lt;/code&gt; на unsafePerformIO, но на самом деле является злонамеренным агентом хаоса. Он вскрывает швы реальности (и монаду &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ), так что обычные правила больше не применяются. Это убаюкивает вас, заставляя думать, что это разумно, но когда вы не смотрите, он наносит удар вам в спину и накладывает псевдонимы на все ваши изменяемые буферы. У его ног валяется труп многих опытных программистов на Haskell.</target>
        </trans-unit>
        <trans-unit id="a3b104d1663bc84a172a1db33ed85dad6c3f818f" translate="yes" xml:space="preserve">
          <source>This &amp;ldquo;feature&amp;rdquo; can be counterintuitive: &lt;code&gt;ghc -C -o foo.o foo.hs&lt;/code&gt; will put the intermediate C code in the file &lt;code&gt;foo.o&lt;/code&gt;, name notwithstanding!</source>
          <target state="translated">Эта &amp;laquo;особенность&amp;raquo; может показаться нелогичной: &lt;code&gt;ghc -C -o foo.o foo.hs&lt;/code&gt; поместит промежуточный код C в файл &lt;code&gt;foo.o&lt;/code&gt; , независимо от имени!</target>
        </trans-unit>
        <trans-unit id="88c2cc5c70d23600b5ecc8b34beba93891daa625" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; equality predicate is used when desugaring pattern-matches against strings.</source>
          <target state="translated">Этот предикат равенства &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; используется при удалении сопоставления шаблонов со строками.</target>
        </trans-unit>
        <trans-unit id="2a20dfa3119742b981763464b6142a5a6307df21" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">Этот &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; используется для декодирования и кодирования аргументов командной строки и переменных среды на платформах, отличных от Windows.</target>
        </trans-unit>
        <trans-unit id="85350ad73428364818dabe9da2493156b00515d0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">Этот &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; используется для декодирования и кодирования аргументов командной строки и переменных среды на платформах, отличных от Windows.</target>
        </trans-unit>
        <trans-unit id="90972741151c3e380f6a4e1b7843a38442017cba" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; can be extended to format types other than those provided for by default. This is done by instantiating &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; and providing a &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; for the type. It is possible to provide a &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; to process type-specific modifiers, but the default instance is usually the best choice.</source>
          <target state="translated">Этот &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; может быть расширен до типов формата, отличных от тех, которые предусмотрены по умолчанию. Это делается путем создания экземпляра &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; и предоставления &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; для типа. Можно предоставить &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; для обработки модификаторов, зависящих от типа, но экземпляр по умолчанию обычно является лучшим выбором.</target>
        </trans-unit>
        <trans-unit id="235914be792722663cf0e67d05a491027df38a5c" translate="yes" xml:space="preserve">
          <source>This abbreviation makes top-level declaration slices quieter and less intimidating.</source>
          <target state="translated">Эта аббревиатура делает объявления верхнего уровня более тихими и менее пугающими.</target>
        </trans-unit>
        <trans-unit id="798b63450aaded668eb204ce38b4ea09a77050c7" translate="yes" xml:space="preserve">
          <source>This abstract data type represents parse error messages. There are four kinds of messages:</source>
          <target state="translated">Этот абстрактный тип данных представляет собой сообщения об ошибках при разборе.Существует четыре типа сообщений:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
