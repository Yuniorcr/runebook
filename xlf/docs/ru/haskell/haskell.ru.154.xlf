<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="ef2cf419db4400f92d4c16bda25b7b49de7c246f" translate="yes" xml:space="preserve">
          <source>Evaluate the argument to weak head normal form.</source>
          <target state="translated">Оцените аргумент до нормальной формы слабой головы.</target>
        </trans-unit>
        <trans-unit id="6060f4f46d5f080bbe6d3a4e15ea7e03aae4d623" translate="yes" xml:space="preserve">
          <source>Evaluates the given expression (or from the last breakpoint if no expression is given), and additionally logs the evaluation steps for later inspection using &lt;a href=&quot;#ghci-cmd-:history&quot;&gt;&lt;code&gt;:history&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#tracing&quot;&gt;Tracing and history&lt;/a&gt;.</source>
          <target state="translated">Оценивает данное выражение (или от последней точки останова, если выражение не задано) и дополнительно регистрирует шаги оценки для последующей проверки с помощью &lt;a href=&quot;#ghci-cmd-:history&quot;&gt; &lt;code&gt;:history&lt;/code&gt; &lt;/a&gt; . См. &lt;a href=&quot;#tracing&quot;&gt;Отслеживание и история&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7bc4cf67d5d67cdacfaa5ff060fb29cd523c09db" translate="yes" xml:space="preserve">
          <source>Evaluates the relevant functions at each element in the structure, running the action, and builds a new structure with the same shape, using the results produced from sequencing the actions.</source>
          <target state="translated">Оценивает соответствующие функции на каждом элементе структуры,выполняющем действие,и строит новую структуру с той же самой формой,используя результаты,полученные в результате последовательности действий.</target>
        </trans-unit>
        <trans-unit id="5600c714a91cbc3264f491ad475c86811b22d09a" translate="yes" xml:space="preserve">
          <source>Evaluating &lt;code&gt;f&lt;/code&gt; directly shows a call stack with a single entry, while evaluating &lt;code&gt;g&lt;/code&gt;, which also requests its call-site, shows two entries, one for each computation &amp;ldquo;annotated&amp;rdquo; with &lt;code&gt;HasCallStack&lt;/code&gt;.</source>
          <target state="translated">Оценка &lt;code&gt;f&lt;/code&gt; напрямую показывает стек вызовов с одной записью, а оценка &lt;code&gt;g&lt;/code&gt; , которая также запрашивает свой сайт вызова, показывает две записи, по одной для каждого вычисления, &amp;laquo;аннотированного&amp;raquo; с помощью &lt;code&gt;HasCallStack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6de480eeff47d7212d5e046acac48253bd022e55" translate="yes" xml:space="preserve">
          <source>Evaluating the \( i \)th prefix takes \( O(\log(\min(i, n-i))) \), but evaluating every prefix in the sequence takes \( O(n) \) due to sharing.</source>
          <target state="translated">Оценивая \(i \)этот префикс принимает \(O(\log(\min(i,n-i)))\),но оценивая каждый префикс в последовательности принимает \(O(n)\)из-за совместного использования.</target>
        </trans-unit>
        <trans-unit id="6396b8883a4c5c234f705d6f1fbf827f38a7835a" translate="yes" xml:space="preserve">
          <source>Evaluating the \( i \)th suffix takes \( O(\log(\min(i, n-i))) \), but evaluating every suffix in the sequence takes \( O(n) \) due to sharing.</source>
          <target state="translated">Оценивая суффикс \(i \)этот принимает \(O(\log(\min(i,n-i)))\),но оценивая каждый суффикс в последовательности принимает \(O(n)\)из-за совместного использования.</target>
        </trans-unit>
        <trans-unit id="ea09e351bce3db4c6389ffff16dcaf057265f37f" translate="yes" xml:space="preserve">
          <source>Evaluation has started on a spark.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcce67319f3801a5d8320bd2ddeb26734158769d" translate="yes" xml:space="preserve">
          <source>Even if data families are defined as toplevel declarations, functions that perform different computations for different family instances may still need to be defined as methods of type classes. In particular, the following is not possible:</source>
          <target state="translated">Даже если семейства данных определены как объявления верхнего уровня,функции,выполняющие различные вычисления для различных экземпляров семейства,все равно могут нуждаться в определении как методы классов типов.В частности,следующее невозможно:</target>
        </trans-unit>
        <trans-unit id="712f436fb09e995690fe8d40968566162f8678b8" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;a&lt;/code&gt; is ill-typed, it is not used in the end, so if all that we&amp;rsquo;re interested in is &lt;code&gt;main&lt;/code&gt; it can be useful to be able to ignore the problems in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Несмотря на то, плохо напечатанный, он не используется , в конце концов, так что если все , что мы заинтересованы в том , &lt;code&gt;main&lt;/code&gt; это может быть полезно , чтобы иметь возможность игнорировать проблемы в . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c423833e7459f388f7a025deca957c83022894ae" translate="yes" xml:space="preserve">
          <source>Even though a field label is duplicated in its defining module, it may be possible to use the selector unambiguously elsewhere. For example, another module could import &lt;code&gt;S(x)&lt;/code&gt; but not &lt;code&gt;T(x)&lt;/code&gt;, and then use &lt;code&gt;x&lt;/code&gt; unambiguously.</source>
          <target state="translated">Несмотря на то, что метка поля дублируется в его определяющем модуле, можно однозначно использовать селектор в другом месте. Например, другой модуль может импортировать &lt;code&gt;S(x)&lt;/code&gt; но не &lt;code&gt;T(x)&lt;/code&gt; , а затем однозначно использовать &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="852a6172c09d70538bebcbe548e6b3e70b6d5e28" translate="yes" xml:space="preserve">
          <source>Even though most of these examples are using the list monad, monad comprehensions work for any monad. The &lt;code&gt;base&lt;/code&gt; package offers all necessary instances for lists, which make &lt;a href=&quot;#extension-MonadComprehensions&quot;&gt;&lt;code&gt;MonadComprehensions&lt;/code&gt;&lt;/a&gt; backward compatible to built-in, transform and parallel list comprehensions.</source>
          <target state="translated">Несмотря на то, что большинство этих примеров использует монаду списка, понимание монад работает для любой монады. В &lt;code&gt;base&lt;/code&gt; пакетах предлагают все необходимые экземпляры списков, которые делают &lt;a href=&quot;#extension-MonadComprehensions&quot;&gt; &lt;code&gt;MonadComprehensions&lt;/code&gt; &lt;/a&gt; обратной совместимости встроенными, преобразование и параллельные списочные.</target>
        </trans-unit>
        <trans-unit id="1e2fd9aaf66af88d1fa27ea41b45f571960a585c" translate="yes" xml:space="preserve">
          <source>Even though the shift-amount is expressed as &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;, the result is undefined for negative shift-amounts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5f2b0889226d76221df5eba41dfdfd027c049a" translate="yes" xml:space="preserve">
          <source>Even though the shift-amount is expressed as &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;, the result is undefined for negative shift-amounts.</source>
          <target state="translated">Даже если величина сдвига выражается как &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; , результат не определен для отрицательных величин сдвига.</target>
        </trans-unit>
        <trans-unit id="8a98b3fabc4357473affe9eff5dad04c75f7f6eb" translate="yes" xml:space="preserve">
          <source>Even though there are two &lt;code&gt;x&lt;/code&gt;&amp;lsquo;s in scope, it is clear that the &lt;code&gt;x&lt;/code&gt; in the pattern in the definition of &lt;code&gt;ok1&lt;/code&gt; can only mean the field &lt;code&gt;x&lt;/code&gt; from type &lt;code&gt;S&lt;/code&gt;. Similarly for the function &lt;code&gt;ok2&lt;/code&gt;. However, in the record update in &lt;code&gt;bad1&lt;/code&gt; and the record selection in &lt;code&gt;bad2&lt;/code&gt; it is not clear which of the two types is intended.</source>
          <target state="translated">Несмотря на то, есть два &lt;code&gt;x&lt;/code&gt; лет в объеме, то ясно , что &lt;code&gt;x&lt;/code&gt; в образце в определении &lt;code&gt;ok1&lt;/code&gt; может означать только поле &lt;code&gt;x&lt;/code&gt; от типа &lt;code&gt;S&lt;/code&gt; . Аналогично для функции &lt;code&gt;ok2&lt;/code&gt; . Однако при обновлении записи в &lt;code&gt;bad1&lt;/code&gt; и выборе записи в &lt;code&gt;bad2&lt;/code&gt; неясно, какой из двух типов предназначен.</target>
        </trans-unit>
        <trans-unit id="4622930c8ec60ffdcb4687bdfc5e61a4075cdba8" translate="yes" xml:space="preserve">
          <source>Even though there are two &lt;code&gt;x&lt;/code&gt;&amp;rsquo;s in scope, it is clear that the &lt;code&gt;x&lt;/code&gt; in the pattern in the definition of &lt;code&gt;ok1&lt;/code&gt; can only mean the field &lt;code&gt;x&lt;/code&gt; from type &lt;code&gt;S&lt;/code&gt;. Similarly for the function &lt;code&gt;ok2&lt;/code&gt;. However, in the record update in &lt;code&gt;bad1&lt;/code&gt; and the record selection in &lt;code&gt;bad2&lt;/code&gt; it is not clear which of the two types is intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2711d7494e1ded0fd3622ca6129c265f52351d7e" translate="yes" xml:space="preserve">
          <source>Even when set to &lt;code&gt;ignore&lt;/code&gt;, a local script will still be processed if given by &lt;a href=&quot;#ghc-flag--ghci-script&quot;&gt;&lt;code&gt;-ghci-script&lt;/code&gt;&lt;/a&gt; on the command line, or sourced via &lt;a href=&quot;#ghci-cmd-:script&quot;&gt;&lt;code&gt;:script&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e0cceb61d9188b63cc75de845a0be5868e83b8" translate="yes" xml:space="preserve">
          <source>Even with the flags &lt;a href=&quot;../using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, the field of the constructor &lt;code&gt;T&lt;/code&gt; is not unpacked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d7a0d774535278c1215097572fe0930f17dd2b" translate="yes" xml:space="preserve">
          <source>Even with the flags &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, the field of the constructor &lt;code&gt;T&lt;/code&gt; is not unpacked.</source>
          <target state="translated">Даже с флагами &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; поле конструктора &lt;code&gt;T&lt;/code&gt; не распаковывается.</target>
        </trans-unit>
        <trans-unit id="ad8919ace091b14011c6439cfd5e1707b58f5abd" translate="yes" xml:space="preserve">
          <source>Event</source>
          <target state="translated">Event</target>
        </trans-unit>
        <trans-unit id="0c619c8d6ba2035f81d9f010c08ec0b1177929e5" translate="yes" xml:space="preserve">
          <source>Event logging</source>
          <target state="translated">Регистрация событий</target>
        </trans-unit>
        <trans-unit id="913641e09266e8cb48d5e95316fd86cbe16755ba" translate="yes" xml:space="preserve">
          <source>EventManager</source>
          <target state="translated">EventManager</target>
        </trans-unit>
        <trans-unit id="ff23fd7f42569a5bfa090dd486d103be85fd0164" translate="yes" xml:space="preserve">
          <source>Eventlog tracing</source>
          <target state="translated">Отслеживание событийных журналов</target>
        </trans-unit>
        <trans-unit id="c19ae7eba2908ba6569d481309090a0fda383fe3" translate="yes" xml:space="preserve">
          <source>Eventlog tracing is a performance profiling system. These functions emit extra events into the eventlog. In combination with eventlog profiling tools these functions can be used for monitoring execution and investigating performance problems.</source>
          <target state="translated">Трассировка событийных журналов-это система профилирования производительности.Эти функции излучают в журнал событий дополнительные события.В сочетании с инструментами профилирования в журнале событий эти функции могут быть использованы для мониторинга исполнения и исследования проблем производительности.</target>
        </trans-unit>
        <trans-unit id="9202d6978f7b6c56daee6dab6c663c232e9764fd" translate="yes" xml:space="preserve">
          <source>Events can have extra information added, but existing fields cannot be changed. Tools should ignore extra fields at the end of the event record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d16de768c1684f419fe23bd359b377e6758d1e" translate="yes" xml:space="preserve">
          <source>Every complete Haskell program must define &lt;code&gt;main&lt;/code&gt; in module &lt;code&gt;Main&lt;/code&gt; in package &lt;code&gt;main&lt;/code&gt;. Omitting the &lt;a href=&quot;#ghc-flag--this-unit-id%20%E2%9F%A8unit-id%E2%9F%A9&quot;&gt;&lt;code&gt;-this-unit-id ⟨unit-id⟩&lt;/code&gt;&lt;/a&gt; flag compiles code for package &lt;code&gt;main&lt;/code&gt;. Failure to do so leads to a somewhat obscure link-time error of the form:</source>
          <target state="translated">Каждая полная программа на Haskell должна определять &lt;code&gt;main&lt;/code&gt; в модуле &lt;code&gt;Main&lt;/code&gt; в пакете &lt;code&gt;main&lt;/code&gt; . Опуская &lt;a href=&quot;#ghc-flag--this-unit-id%20%E2%9F%A8unit-id%E2%9F%A9&quot;&gt; &lt;code&gt;-this-unit-id ⟨unit-id⟩&lt;/code&gt; &lt;/a&gt; флаг компилирует код для пакета &lt;code&gt;main&lt;/code&gt; . Невыполнение этого требования приводит к несколько неясной ошибке времени компоновки в форме:</target>
        </trans-unit>
        <trans-unit id="d0912fd6d2a0271d302c52a4acaff179b0c6995b" translate="yes" xml:space="preserve">
          <source>Every cycle in the module import graph must be broken by a &lt;code&gt;hs-boot&lt;/code&gt; file. Suppose that modules &lt;code&gt;A.hs&lt;/code&gt; and &lt;code&gt;B.hs&lt;/code&gt; are Haskell source files, thus:</source>
          <target state="translated">Каждый цикл в графе импорта модуля должен &lt;code&gt;hs-boot&lt;/code&gt; файлом hs-boot . Предположим, что модули &lt;code&gt;A.hs&lt;/code&gt; и &lt;code&gt;B.hs&lt;/code&gt; являются исходными файлами Haskell, таким образом:</target>
        </trans-unit>
        <trans-unit id="33d86826edcd97dcbde5f7c16a0f10d7e8256a5b" translate="yes" xml:space="preserve">
          <source>Every language extension can also be turned into a command-line flag by prefixing it with &amp;ldquo;&lt;code&gt;-X&lt;/code&gt;&amp;rdquo;; for example &lt;code&gt;-XForeignFunctionInterface&lt;/code&gt;. (Similarly, all &amp;ldquo;&lt;code&gt;-X&lt;/code&gt;&amp;rdquo; flags can be written as &lt;code&gt;LANGUAGE&lt;/code&gt; pragmas.)</source>
          <target state="translated">Каждое языковое расширение можно также превратить в флаг командной строки, поставив перед ним префикс &amp;laquo; &lt;code&gt;-X&lt;/code&gt; &amp;raquo;; например &lt;code&gt;-XForeignFunctionInterface&lt;/code&gt; . (Точно так же все флаги &amp;laquo; &lt;code&gt;-X&lt;/code&gt; &amp;raquo; могут быть записаны как прагмы &lt;code&gt;LANGUAGE&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="3b078eee456a9f087a6cc6922257a7666e3223df" translate="yes" xml:space="preserve">
          <source>Every language extension can be switched on by a command-line flag &amp;ldquo;&lt;code&gt;-X...&lt;/code&gt;&amp;rdquo; (e.g. &lt;code&gt;-XTemplateHaskell&lt;/code&gt;), and switched off by the flag &amp;ldquo;&lt;code&gt;-XNo...&lt;/code&gt;&amp;rdquo;; (e.g. &lt;code&gt;-XNoTemplateHaskell&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89191834b0668388b7f06081ebe85c6fc7aa3ea9" translate="yes" xml:space="preserve">
          <source>Every language option can switched on by a command-line flag &amp;ldquo;&lt;code&gt;-X...&lt;/code&gt;&amp;rdquo; (e.g. &lt;code&gt;-XTemplateHaskell&lt;/code&gt;), and switched off by the flag &amp;ldquo;&lt;code&gt;-XNo...&lt;/code&gt;&amp;rdquo;; (e.g. &lt;code&gt;-XNoTemplateHaskell&lt;/code&gt;).</source>
          <target state="translated">Каждый языковой параметр может быть включен с помощью флага командной строки &amp;laquo; &lt;code&gt;-X...&lt;/code&gt; &amp;raquo; (например, &lt;code&gt;-XTemplateHaskell&lt;/code&gt; ) и отключен с помощью флага &amp;laquo; &lt;code&gt;-XNo...&lt;/code&gt; &amp;raquo;; (например, &lt;code&gt;-XNoTemplateHaskell&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c21e6f680a01c2f8b28c8d60711b7527a58afada" translate="yes" xml:space="preserve">
          <source>Every module has a &lt;em&gt;module name&lt;/em&gt; defined in its source code (&lt;code&gt;module A.B.C where ...&lt;/code&gt;).</source>
          <target state="translated">Каждый модуль имеет &lt;em&gt;имя модуля,&lt;/em&gt; определенное в его исходном коде ( &lt;code&gt;module A.B.C where ...&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b9fd929db55af9188984a5b1f15ada92d9684dba" translate="yes" xml:space="preserve">
          <source>Every new binding shadows any existing bindings of the same name, including entities that are in scope in the current module context.</source>
          <target state="translated">Каждая новая привязка отбрасывает тень на все существующие одноименные привязки,включая сущности,которые находятся в области видимости в текущем контексте модуля.</target>
        </trans-unit>
        <trans-unit id="f7098378d870c69a4432ef9315748f42a7c6f2be" translate="yes" xml:space="preserve">
          <source>Every thread has an allocation counter that tracks how much memory has been allocated by the thread. The counter is initialized to zero, and &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; sets the current value. The allocation counter counts *down*, so in the absence of a call to &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; its value is the negation of the number of bytes of memory allocated by the thread.</source>
          <target state="translated">У каждого потока есть счетчик распределения, который отслеживает, сколько памяти было выделено потоком. Счетчик инициализируется нулем, а &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; устанавливает текущее значение. Счетчик распределения ведет * &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; отсчет *, поэтому в отсутствие вызова setAllocationCounter его значение является отрицанием количества байтов памяти, выделенной потоком.</target>
        </trans-unit>
        <trans-unit id="87fea7be991371f64729bc8780fc11210c633480" translate="yes" xml:space="preserve">
          <source>Every thread has an allocation counter that tracks how much memory has been allocated by the thread. The counter is initialized to zero, and &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; sets the current value. The allocation counter counts *down*, so in the absence of a call to &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; its value is the negation of the number of bytes of memory allocated by the thread.</source>
          <target state="translated">У каждого потока есть счетчик распределения, который отслеживает, сколько памяти было выделено потоком. Счетчик инициализируется нулем, а &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; устанавливает текущее значение. Счетчик распределения ведет * &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; отсчет *, поэтому в отсутствие вызова setAllocationCounter его значение является отрицанием количества байтов памяти, выделенной потоком.</target>
        </trans-unit>
        <trans-unit id="abfc0f0b13db0da312949b88776c9010f5397cef" translate="yes" xml:space="preserve">
          <source>Every thread has an allocation counter that tracks how much memory has been allocated by the thread. The counter is initialized to zero, and &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; sets the current value. The allocation counter counts *down*, so in the absence of a call to &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; its value is the negation of the number of bytes of memory allocated by the thread.</source>
          <target state="translated">У каждого потока есть счетчик распределения, который отслеживает, сколько памяти было выделено потоком. Счетчик инициализируется нулем, а &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; устанавливает текущее значение. Счетчик распределения ведет * &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; отсчет *, поэтому в отсутствие вызова setAllocationCounter его значение является отрицанием количества байтов памяти, выделенной потоком.</target>
        </trans-unit>
        <trans-unit id="2cdcb7a5f8b0e5da9d82d98917b19bde316858e5" translate="yes" xml:space="preserve">
          <source>Exactly the same reasoning applies to &lt;code&gt;ExNumPat&lt;/code&gt;: matching against &lt;code&gt;ExNumPat&lt;/code&gt;&lt;em&gt;requires&lt;/em&gt; the constraints &lt;code&gt;(Num a, Eq a)&lt;/code&gt;, and &lt;em&gt;provides&lt;/em&gt; the constraint &lt;code&gt;(Show b)&lt;/code&gt;.</source>
          <target state="translated">Точно такие же рассуждения применимы к &lt;code&gt;ExNumPat&lt;/code&gt; : сопоставление с &lt;code&gt;ExNumPat&lt;/code&gt; &lt;em&gt;требует&lt;/em&gt; ограничений &lt;code&gt;(Num a, Eq a)&lt;/code&gt; и &lt;em&gt;обеспечивает&lt;/em&gt; ограничение &lt;code&gt;(Show b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b96d27d4acb5d7b08b44caf941f831bab1b616f" translate="yes" xml:space="preserve">
          <source>Exactly the same situation can arise in instance declarations themselves. Suppose we have</source>
          <target state="translated">Точно такая же ситуация может возникнуть и с самими декларациями.Предположим,у нас</target>
        </trans-unit>
        <trans-unit id="fe669a2e98268a4e3f1914eea2b10b28c27678b1" translate="yes" xml:space="preserve">
          <source>Examine the generated profiling information, use the information to optimise your program, and repeat as necessary.</source>
          <target state="translated">Изучите сгенерированную информацию профилирования,используйте ее для оптимизации программы и повторите при необходимости.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="5ab5c95eb13c56a3fee4135ddda2d5191c14c8f0" translate="yes" xml:space="preserve">
          <source>Example 1: Custom Error Data Type</source>
          <target state="translated">Пример 1:Пользовательский тип данных об ошибках</target>
        </trans-unit>
        <trans-unit id="9341e16e31da6f2a70822dbce4c15a6563123345" translate="yes" xml:space="preserve">
          <source>Example 1: Simple Continuation Usage</source>
          <target state="translated">Пример 1:Простое продолжение использования</target>
        </trans-unit>
        <trans-unit id="65d8343070f8245126756e9e6474efdb37e4866c" translate="yes" xml:space="preserve">
          <source>Example 1: Simple Reader Usage</source>
          <target state="translated">Пример 1:Простое использование читателя</target>
        </trans-unit>
        <trans-unit id="e7b57a0dcf99e0a81e45002d7fa9585327408c44" translate="yes" xml:space="preserve">
          <source>Example 2: Modifying Reader Content With &lt;code&gt;local&lt;/code&gt;</source>
          <target state="translated">Пример 2: изменение содержимого Reader с помощью &lt;code&gt;local&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7af5856636b2b3dd64495544e0d58ec7921152b" translate="yes" xml:space="preserve">
          <source>Example 2: Using &lt;code&gt;callCC&lt;/code&gt;</source>
          <target state="translated">Пример 2: Использование &lt;code&gt;callCC&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f1f4d7e09a4ce050bc861cd17fcfb325ccd1802" translate="yes" xml:space="preserve">
          <source>Example 2: Using ErrorT Monad Transformer</source>
          <target state="translated">Пример 2:Использование трансформатора монаддува ErrorT</target>
        </trans-unit>
        <trans-unit id="49670fce677705355449a0491c747c92f53b6377" translate="yes" xml:space="preserve">
          <source>Example 2: Using ExceptT Monad Transformer</source>
          <target state="translated">Пример 2:Использование исключающего трансформатора Монад</target>
        </trans-unit>
        <trans-unit id="3b38bf4f99b69316fc2cabc16fe8efbc23e17cdb" translate="yes" xml:space="preserve">
          <source>Example 3: &lt;code&gt;ReaderT&lt;/code&gt; Monad Transformer</source>
          <target state="translated">Пример 3: &lt;code&gt;ReaderT&lt;/code&gt; монад ReaderT</target>
        </trans-unit>
        <trans-unit id="2f4dd83523e08d239122d5d7b82fdc40b87078e4" translate="yes" xml:space="preserve">
          <source>Example 3: Using &lt;code&gt;ContT&lt;/code&gt; Monad Transformer</source>
          <target state="translated">Пример 3: Использование &lt;code&gt;ContT&lt;/code&gt; Monad Transformer</target>
        </trans-unit>
        <trans-unit id="589c32b6f4517cdf800a8b3876ce51a0178b7a54" translate="yes" xml:space="preserve">
          <source>Example type:</source>
          <target state="translated">Тип примера:</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="fa37f54302b03973bfbf2aa3fb535779d3383bb4" translate="yes" xml:space="preserve">
          <source>Examples (with behaviour identical to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">Примеры (с поведением, идентичным &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="790f2b42181ca616b7c127aef6e902fd9e8081ef" translate="yes" xml:space="preserve">
          <source>Examples (with behaviour identical to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d081741e630d4cf15f0c6ba49848ab7e7fafe785" translate="yes" xml:space="preserve">
          <source>Examples (with behaviour identical to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65ef181bf5a5a0563ded8a2fc63cfcae3d45812a" translate="yes" xml:space="preserve">
          <source>Examples of differences from &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Примеры отличий от &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="80e96827fe2478980a86e49ef7458c4629812185" translate="yes" xml:space="preserve">
          <source>Examples of differences from &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddfe2a057d0d4bd32c75bee00a3afd1b7f3cd6fd" translate="yes" xml:space="preserve">
          <source>Examples of differences from &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e6a1dcd0a3510c1fa35b2c9952fa51f9d56da66" translate="yes" xml:space="preserve">
          <source>Examples of short-cicuit reduction include various boolean predicates that test whether some or all the elements of a structure satisfy a given condition. Because these don't necessarily consume the entire list, they typically employ &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; with an operator that is conditionally strict in its second argument. Once the termination condition is met the second argument (tail of the input structure) is ignored. No result is returned until that happens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="498245f3f1e8f9b6f80d7ed20c13e42f043f24d9" translate="yes" xml:space="preserve">
          <source>Except</source>
          <target state="translated">Except</target>
        </trans-unit>
        <trans-unit id="150f49a28cd9890f5d74255011dd9ae13178dd32" translate="yes" xml:space="preserve">
          <source>ExceptT</source>
          <target state="translated">ExceptT</target>
        </trans-unit>
        <trans-unit id="20049bc069b0a04404c23d571b5e0b56f0660c02" translate="yes" xml:space="preserve">
          <source>Exception</source>
          <target state="translated">Exception</target>
        </trans-unit>
        <trans-unit id="53a706616e11935ca633fadc1928372183e733d2" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">Доставка исключений синхронизируется между исходным и целевым потоками: &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; не возвращается, пока исключение не будет создано в целевом потоке. Таким образом, вызывающий поток может быть уверен, что целевой поток получил исключение. Доставка исключений также атомарна по отношению к другим исключениям. Атомарность - полезное свойство при работе с условиями гонки: например, если есть два потока, которые могут убить друг друга, гарантируется, что только один из потоков сможет убить другой.</target>
        </trans-unit>
        <trans-unit id="6b1c0dab2d59aa101f6c17d2f3c37c8dbb32aef4" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">Доставка исключений синхронизируется между исходным и целевым потоками: &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; не возвращается, пока исключение не будет создано в целевом потоке. Таким образом, вызывающий поток может быть уверен, что целевой поток получил исключение. Доставка исключений также атомарна по отношению к другим исключениям. Атомарность - полезное свойство при работе с условиями гонки: например, если есть два потока, которые могут убить друг друга, гарантируется, что только один из потоков сможет убить другой.</target>
        </trans-unit>
        <trans-unit id="f9ca0b055b03c1b83f5d783045937b6b971fc2c7" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">Доставка исключений синхронизируется между исходным и целевым потоками: &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; не возвращается, пока исключение не будет создано в целевом потоке. Таким образом, вызывающий поток может быть уверен, что целевой поток получил исключение. Доставка исключений также атомарна по отношению к другим исключениям. Атомарность - полезное свойство при работе с условиями гонки: например, если есть два потока, которые могут убить друг друга, гарантируется, что только один из потоков сможет убить другой.</target>
        </trans-unit>
        <trans-unit id="63b8e6291d3f08aeaec124c66c6cff001d6c6ea4" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">Доставка исключений синхронизируется между исходным и целевым потоками: &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; не возвращается, пока исключение не будет создано в целевом потоке. Таким образом, вызывающий поток может быть уверен, что целевой поток получил исключение. Доставка исключений также атомарна по отношению к другим исключениям. Атомарность - полезное свойство при работе с условиями гонки: например, если есть два потока, которые могут убить друг друга, гарантируется, что только один из потоков сможет убить другой.</target>
        </trans-unit>
        <trans-unit id="e0356c4346732233d71d4ad17145a3a7d64d539e" translate="yes" xml:space="preserve">
          <source>Exception handling in the I/O monad</source>
          <target state="translated">Обработка исключений в модуле ввода/вывода</target>
        </trans-unit>
        <trans-unit id="4aba3643c6de6f96be69c3234f88f2d7abee91b2" translate="yes" xml:space="preserve">
          <source>Exception handling within STM actions.</source>
          <target state="translated">Обработка исключений в рамках действий STM.</target>
        </trans-unit>
        <trans-unit id="eda52cb4b163a3d91ebc6efd255a35eb5c788dd0" translate="yes" xml:space="preserve">
          <source>Exception operations</source>
          <target state="translated">Исключительные операции</target>
        </trans-unit>
        <trans-unit id="1e0456156d2599fba71e66665c8effe9eb0cdf9b" translate="yes" xml:space="preserve">
          <source>Exception thrown by &lt;code&gt;&lt;a href=&quot;ghc-io-handle-lock#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt; on non-Windows platforms that don't support &lt;code&gt;flock&lt;/code&gt;.</source>
          <target state="translated">Исключение, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-lock#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt; на платформах, отличных от Windows, которые не поддерживают &lt;code&gt;flock&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab0e1caad4d21b7759b69123f35074bf121ac468" translate="yes" xml:space="preserve">
          <source>Exception thrown by &lt;code&gt;hLock&lt;/code&gt; on non-Windows platforms that don't support &lt;code&gt;flock&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bcbec4a21f1200ac1b10210e0b80c9fa92ae9e7" translate="yes" xml:space="preserve">
          <source>Exceptions (e.g. pattern matching failure and &lt;code&gt;error&lt;/code&gt;) can be treated as breakpoints, to help locate the source of an exception in the program.</source>
          <target state="translated">Исключения (например, сбой и &lt;code&gt;error&lt;/code&gt; сопоставления с образцом ) можно рассматривать как точки останова, чтобы помочь найти источник исключения в программе.</target>
        </trans-unit>
        <trans-unit id="19252ae3666000a0b6f93913a391be3ee8a0b825" translate="yes" xml:space="preserve">
          <source>Exceptions and exception-handling functions.</source>
          <target state="translated">Исключения и функции обработки исключений.</target>
        </trans-unit>
        <trans-unit id="581d67742f82ff9913666449de206cda75556316" translate="yes" xml:space="preserve">
          <source>Exceptions generated by array operations</source>
          <target state="translated">Исключения,генерируемые операциями с массивами</target>
        </trans-unit>
        <trans-unit id="934839970d31235dc74d44785440bb7587cc9762" translate="yes" xml:space="preserve">
          <source>Exceptions that occur in the &lt;code&gt;IO&lt;/code&gt; monad. An &lt;code&gt;IOException&lt;/code&gt; records a more specific error type, a descriptive string and maybe the handle that was used when the error was flagged.</source>
          <target state="translated">Исключения, возникающие в монаде &lt;code&gt;IO&lt;/code&gt; . &lt;code&gt;IOException&lt;/code&gt; записывает более конкретный тип ошибки, описательную строку и , возможно, ручка , которая использовалась при помеченной ошибке.</target>
        </trans-unit>
        <trans-unit id="08dd9b4521175f2b7645b6d05dd66e3f5d1e5a7a" translate="yes" xml:space="preserve">
          <source>ExclusiveLock</source>
          <target state="translated">ExclusiveLock</target>
        </trans-unit>
        <trans-unit id="a9e5edeee4b6bddbc59b5bc41ce4029d4ec4727e" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">Исполняемый файл &amp;amp; аргументы или команда оболочки. Если &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; равно &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , относительные пути разрешаются относительно текущего рабочего каталога. Если &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; , это зависит от реализации, разрешаются ли относительные пути относительно &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; или текущего рабочего каталога, поэтому для обеспечения переносимости следует использовать абсолютные пути.</target>
        </trans-unit>
        <trans-unit id="42e1121c05300716bc1e0f10a008032170bf3cee" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d633fda1eda86ee2dbe83ca841bdba34c00b7fb" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da49c4c138af06cdc6e4ed0555a2d722ce3bbf8b" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">Исполняемый файл &amp;amp; аргументы или команда оболочки. Если &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; равно &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , относительные пути разрешаются относительно текущего рабочего каталога. Если &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; , это зависит от реализации, разрешаются ли относительные пути относительно &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; или текущего рабочего каталога, поэтому для обеспечения переносимости следует использовать абсолютные пути.</target>
        </trans-unit>
        <trans-unit id="fbbcf8ab79fd69b3cdf42660517413d00119f401" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08446105cf0896c803b6a80b50cd0e07cfad78bd" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e45ade933abb2dbef129bbe667e5f06567379e" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; and return the generated chunks as a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The work is performed lazy, i.e., only when a chunk of the lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is forced.</source>
          <target state="translated">Запустите &lt;code&gt;&lt;a href=&quot;data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; и верните сгенерированные фрагменты в виде ленивой &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . Работа выполняется лениво, т. &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; Только тогда, когда кусок ленивой ByteString принудительно запускается .</target>
        </trans-unit>
        <trans-unit id="bbdca60aa1528cc59e2424298bc2fbc065b117a6" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; and return the generated chunks as a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The work is performed lazy, i.e., only when a chunk of the lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is forced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44cef8606c2d8d69b084ef725295c455661c70d1" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; and return the generated chunks as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The work is performed lazy, i.e., only when a chunk of the lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is forced.</source>
          <target state="translated">Запустите &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; и верните сгенерированные фрагменты в виде ленивой &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . Работа выполняется лениво, т. &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; Только тогда, когда кусок ленивой ByteString принудительно запускается .</target>
        </trans-unit>
        <trans-unit id="2d4c37228081ad690471866bfb49855698ac1573" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; and return the computed result and the bytes written during the computation as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Выполните &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; и верните вычисленный результат и байты, записанные во время вычисления, как ленивую &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a91780a4fbc0b4b5a96ff84d0f2ad27c4390b00" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; with a buffer-allocation strategy and a continuation. For example, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:putToLazyByteString&quot;&gt;putToLazyByteString&lt;/a&gt;&lt;/code&gt; is implemented as follows.</source>
          <target state="translated">Выполните &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; со стратегией распределения буфера и продолжением. Например, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:putToLazyByteString&quot;&gt;putToLazyByteString&lt;/a&gt;&lt;/code&gt; реализован следующим образом.</target>
        </trans-unit>
        <trans-unit id="34b863a511860977e79077de7a231a7aecf1ada7" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment</source>
          <target state="translated">Выполнение вычислений в модифицированной среде</target>
        </trans-unit>
        <trans-unit id="9074ee855e6397968c72ac1444df19911eaa577a" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a more general version of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Выполните вычисление в измененной среде (более общая версия &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9bad7ac26cf07893f9cefd43f5bb9c7a61a20d5d" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a more general version of &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Выполните вычисление в измененной среде (более общая версия &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1c369096a8c214ef9f4515d93a67dbb9c70e723b" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Выполнить вычисление в измененной среде (специализация &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e148fe739f9c54b1accabc69b62a9d19fee91018" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Выполнить вычисление в измененной среде (специализация &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="53f59c8f15736e3200571bde489e9c2748a0204d" translate="yes" xml:space="preserve">
          <source>Execute an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action, throwing a &lt;code&gt;&lt;a href=&quot;system-io-error#v:userError&quot;&gt;userError&lt;/a&gt;&lt;/code&gt; if the predicate yields &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to the result returned by the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action. If no exception is raised, return the result of the computation.</source>
          <target state="translated">Выполните действие &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; , выбрасывая &lt;code&gt;&lt;a href=&quot;system-io-error#v:userError&quot;&gt;userError&lt;/a&gt;&lt;/code&gt; если предикат дает значение &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; при применении к результату, возвращенному действием &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; . Если исключение не возникает, вернуть результат вычисления.</target>
        </trans-unit>
        <trans-unit id="42c77fe8561e333489414079969807a39fd1e151" translate="yes" xml:space="preserve">
          <source>Execute an action with a fresh memory pool, which gets automatically deallocated (including its contents) after the action has finished.</source>
          <target state="translated">Выполнить действие со свежим пулом памяти,который получает автоматически разобраться (включая его содержимое)после завершения действия.</target>
        </trans-unit>
        <trans-unit id="1262c3e03a483c6a9341f4b12dfc5bd8ac87a7c4" translate="yes" xml:space="preserve">
          <source>Executes a computation in a modified environment.</source>
          <target state="translated">Выполняет вычисления в модифицированной среде.</target>
        </trans-unit>
        <trans-unit id="8210b4609b3b832c81bcd8b6f74a6b3190413ae8" translate="yes" xml:space="preserve">
          <source>Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</source>
          <target state="translated">Выполняет вычисление ввода-вывода с &lt;em&gt;замаскированными&lt;/em&gt; асинхронными исключениями . То есть любой поток, который пытается вызвать исключение в текущем потоке с помощью &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; , будет заблокирован до тех пор, пока асинхронные исключения не будут снова демаскированы.</target>
        </trans-unit>
        <trans-unit id="46ec0e1cddb9075cc884b834b53f50ddc817ddcc" translate="yes" xml:space="preserve">
          <source>Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60c9626b83b84fd2f338afec521f991b9505634c" translate="yes" xml:space="preserve">
          <source>Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778dbd9e9bf309d9af09860bc9150a182f094e04" translate="yes" xml:space="preserve">
          <source>Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</source>
          <target state="translated">Выполняет вычисление ввода-вывода с &lt;em&gt;замаскированными&lt;/em&gt; асинхронными исключениями . То есть любой поток, который пытается вызвать исключение в текущем потоке с помощью &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; , будет заблокирован до тех пор, пока асинхронные исключения не будут снова демаскированы.</target>
        </trans-unit>
        <trans-unit id="a7ed1222c5da10b5796d9be8df9484fce7ea06e0" translate="yes" xml:space="preserve">
          <source>Executes the GHCi built-in command (e.g. &lt;code&gt;::type 3&lt;/code&gt;). That is, look up on the list of builtin commands, excluding defined macros. See also: &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbee69c7c6cc3983066537c6b9014eb13e8768e2" translate="yes" xml:space="preserve">
          <source>Executes the lines of a file as a series of GHCi commands. The syntax for file-name arguments respects shell quoting rules, i.e., file names containing spaces can be enclosed in double quotes or with spaces escaped with a backslash. This command is compatible with multiline statements as set by &lt;a href=&quot;#ghci-cmd-:set%20+m&quot;&gt;&lt;code&gt;:set +m&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33de9056690f98ecc8c217e510931ae85b64fa5" translate="yes" xml:space="preserve">
          <source>Executes the lines of a file as a series of GHCi commands. This command is compatible with multiline statements as set by &lt;a href=&quot;#ghci-cmd-:set%20+m&quot;&gt;&lt;code&gt;:set +m&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Выполняет строки файла как серию команд GHCi. Эта команда совместима с многострочными операторами, как установлено &lt;a href=&quot;#ghci-cmd-:set%20+m&quot;&gt; &lt;code&gt;:set +m&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88c84a00bbe497217dba4b84e9db2cf8c6f33404" translate="yes" xml:space="preserve">
          <source>Executes the shell command ⟨command⟩.</source>
          <target state="translated">Выполняет команду оболочки ⟨command⟩.</target>
        </trans-unit>
        <trans-unit id="130a9408743cf5a376559c419e05f9b8d8b461ba" translate="yes" xml:space="preserve">
          <source>Executes ⟨expr⟩ as a computation of type &lt;code&gt;IO String&lt;/code&gt;, and then executes the resulting string as a list of GHCi commands. Multiple commands are separated by newlines. The &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt;&lt;code&gt;:cmd&lt;/code&gt;&lt;/a&gt; command is useful with &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt;&lt;code&gt;:set stop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Выполняет expr как вычисление типа &lt;code&gt;IO String&lt;/code&gt; , а затем выполняет полученную строку как список команд GHCi. Несколько команд разделяются символами новой строки. Команда &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt; &lt;code&gt;:cmd&lt;/code&gt; &lt;/a&gt; полезна с &lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt; &lt;code&gt;:set stop&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df5c4bfe66f918bc7c61afbbe38d05d87f6b7882" translate="yes" xml:space="preserve">
          <source>Executing Builders</source>
          <target state="translated">Исполнители строительных работ</target>
        </trans-unit>
        <trans-unit id="520995e98a5bbbbf4ce95c15e55e45c660e4b3b8" translate="yes" xml:space="preserve">
          <source>Executing an external command.</source>
          <target state="translated">Выполнение внешней команды.</target>
        </trans-unit>
        <trans-unit id="6d525b71568c2d982f46feb96b332bedcdc6e4a0" translate="yes" xml:space="preserve">
          <source>Execution</source>
          <target state="translated">Execution</target>
        </trans-unit>
        <trans-unit id="b0b8748c9d02d8c4d95223629ecf3c2f6ccc5b43" translate="yes" xml:space="preserve">
          <source>Execution can be single-stepped: the evaluator will suspend execution approximately after every reduction, allowing local variables to be inspected. This is equivalent to setting a breakpoint at every point in the program.</source>
          <target state="translated">Выполнение может быть одношаговым:вычислитель будет приостанавливать выполнение примерно после каждого уменьшения,позволяя проверять локальные переменные.Это эквивалентно установке точки останова в каждой точке программы.</target>
        </trans-unit>
        <trans-unit id="52ff4dea904274d587ed05e7bceeb9003bc66ab2" translate="yes" xml:space="preserve">
          <source>Execution can take place in tracing mode, in which the evaluator remembers each evaluation step as it happens, but doesn&amp;rsquo;t suspend execution until an actual breakpoint is reached. When this happens, the history of evaluation steps can be inspected.</source>
          <target state="translated">Выполнение может происходить в режиме трассировки, в котором оценщик запоминает каждый шаг оценки по мере его возникновения, но не приостанавливает выполнение, пока не будет достигнута фактическая точка останова. Когда это происходит, можно просмотреть историю шагов оценки.</target>
        </trans-unit>
        <trans-unit id="d4a32174885111edde7b30c063a41b35b8521952" translate="yes" xml:space="preserve">
          <source>Execution has stopped at the breakpoint. The prompt has changed to indicate that we are currently stopped at a breakpoint, and the location: &lt;code&gt;[qsort.hs:2:15-46]&lt;/code&gt;. To further clarify the location, we can use the &lt;a href=&quot;#ghci-cmd-:list&quot;&gt;&lt;code&gt;:list&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">Выполнение остановлено на точке останова. Приглашение изменилось, чтобы указать, что в настоящее время мы остановились на точке останова и расположении: &lt;code&gt;[qsort.hs:2:15-46]&lt;/code&gt; . Чтобы дополнительно уточнить местоположение, мы можем использовать команду &lt;a href=&quot;#ghci-cmd-:list&quot;&gt; &lt;code&gt;:list&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b38d4aa4381d31a400e67cc71ccd460974a035c6" translate="yes" xml:space="preserve">
          <source>Execution phase markers</source>
          <target state="translated">маркеры фазы выполнения</target>
        </trans-unit>
        <trans-unit id="b6a16f53ed00195637e6e17e5494787580135e59" translate="yes" xml:space="preserve">
          <source>Execution strategies</source>
          <target state="translated">Стратегии исполнения</target>
        </trans-unit>
        <trans-unit id="cadc56108302cd7d8880934930f927b8c99fbe2b" translate="yes" xml:space="preserve">
          <source>Existence tests</source>
          <target state="translated">Испытания на существование</target>
        </trans-unit>
        <trans-unit id="5e7584235c55bf0269fd90b3b4973495fe948001" translate="yes" xml:space="preserve">
          <source>ExistentialQuantification</source>
          <target state="translated">ExistentialQuantification</target>
        </trans-unit>
        <trans-unit id="e47aae11b0445849d13a157318e577826b351212" translate="yes" xml:space="preserve">
          <source>Exit the iserv process</source>
          <target state="translated">Выход из нервного процесса</target>
        </trans-unit>
        <trans-unit id="cb193431524e4fae58710e9d90f4bc84b69056c1" translate="yes" xml:space="preserve">
          <source>ExitCaseAbort</source>
          <target state="translated">ExitCaseAbort</target>
        </trans-unit>
        <trans-unit id="0ff1b7133e455e31a96b40324f51f574297a78d9" translate="yes" xml:space="preserve">
          <source>ExitCode</source>
          <target state="translated">ExitCode</target>
        </trans-unit>
        <trans-unit id="9627d6dbece3ab140288e68f186ca8a53c5850a2" translate="yes" xml:space="preserve">
          <source>ExitSuccess</source>
          <target state="translated">ExitSuccess</target>
        </trans-unit>
        <trans-unit id="85e8ee4560b4d8b0a12df383127ad6ef2e825d1e" translate="yes" xml:space="preserve">
          <source>Exiting</source>
          <target state="translated">Exiting</target>
        </trans-unit>
        <trans-unit id="c80dbce7b21ef649a1c74b9ef8ebe0514f23c1e1" translate="yes" xml:space="preserve">
          <source>Exiting the program.</source>
          <target state="translated">Выход из программы.</target>
        </trans-unit>
        <trans-unit id="5871b8d86fba0af13c05dc83a5e5933bb7903327" translate="yes" xml:space="preserve">
          <source>Exp</source>
          <target state="translated">Exp</target>
        </trans-unit>
        <trans-unit id="78e98755476e343b08d10ea6578596f90d796f0c" translate="yes" xml:space="preserve">
          <source>ExpQ</source>
          <target state="translated">ExpQ</target>
        </trans-unit>
        <trans-unit id="9869e506c38f643f1fe985347c015deace6baa22" translate="yes" xml:space="preserve">
          <source>Expand</source>
          <target state="translated">Expand</target>
        </trans-unit>
        <trans-unit id="8f96935efd9a006ac921c7dacf0d186433812322" translate="yes" xml:space="preserve">
          <source>Expects an absolute file path.</source>
          <target state="translated">Ожидает абсолютный путь к файлу.</target>
        </trans-unit>
        <trans-unit id="51dd39f18dcb2e2562fb241ac2f6aeea3606be0c" translate="yes" xml:space="preserve">
          <source>Explicit &lt;code&gt;forall&lt;/code&gt; is not always required &amp;ndash; see &lt;a href=&quot;#pattern-equiv-form&quot;&gt;pattern signature equivalent&lt;/a&gt; for the example in this section, or &lt;a href=&quot;#pattern-type-sigs&quot;&gt;Pattern type signatures&lt;/a&gt;.</source>
          <target state="translated">Явный &lt;code&gt;forall&lt;/code&gt; не всегда требуется - см. &lt;a href=&quot;#pattern-equiv-form&quot;&gt;Эквивалент сигнатуры шаблона&lt;/a&gt; в примере в этом разделе или &lt;a href=&quot;#pattern-type-sigs&quot;&gt;сигнатуры типа шаблона&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6fa2778c6121e57a5aad745d718637106bc0e5c3" translate="yes" xml:space="preserve">
          <source>Explicit braces and semicolons can be used instead of layout:</source>
          <target state="translated">Вместо компоновки можно использовать явные скобки и точки с запятой:</target>
        </trans-unit>
        <trans-unit id="5cda5ab7163622c96737f0b582eb504bee024916" translate="yes" xml:space="preserve">
          <source>Explicit lists (e.g. &lt;code&gt;[True, False]&lt;/code&gt;)</source>
          <target state="translated">Явные списки (например, &lt;code&gt;[True, False]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9833c09c86535a2d945ed19a1102c3bdf82ae3e8" translate="yes" xml:space="preserve">
          <source>ExplicitForAll</source>
          <target state="translated">ExplicitForAll</target>
        </trans-unit>
        <trans-unit id="8d15960eecc2d5f40b4acc3f555b51fa8aaf3c23" translate="yes" xml:space="preserve">
          <source>ExplicitNamespaces</source>
          <target state="translated">ExplicitNamespaces</target>
        </trans-unit>
        <trans-unit id="02890a2e735d14626c63f3129c86c7cdabb1bec5" translate="yes" xml:space="preserve">
          <source>Explicitly Bidirectional</source>
          <target state="translated">Явно двунаправленный</target>
        </trans-unit>
        <trans-unit id="2d4285ba133d39020951d187ad418ec009ca8997" translate="yes" xml:space="preserve">
          <source>Explicitly bidirectional pattern synonyms offer greater flexibility than implicitly bidirectional ones in terms of the syntax that is permitted. For instance, the following is not a legal implicitly bidirectional pattern synonym:</source>
          <target state="translated">Явно двунаправленные синонимы предлагают большую гибкость,чем неявно двунаправленные с точки зрения разрешенного синтаксиса.Например,следующее не является юридическим синонимом двунаправленного шаблона в неявном виде:</target>
        </trans-unit>
        <trans-unit id="ef7581dde501937e3e482f6cd7c00557b65093e7" translate="yes" xml:space="preserve">
          <source>Explicitly run the finaliser associated with a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. References to this value after finalisation may generate invalid memory references.</source>
          <target state="translated">Явно запустите финализатор, связанный с &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . Ссылки на это значение после завершения могут создавать недопустимые ссылки на память.</target>
        </trans-unit>
        <trans-unit id="e9b873f46071db66ba372c05baac4fdf01be75c1" translate="yes" xml:space="preserve">
          <source>Exponent</source>
          <target state="translated">Exponent</target>
        </trans-unit>
        <trans-unit id="877e2989e6c895bad022c9991582cbad6570c551" translate="yes" xml:space="preserve">
          <source>Exponentiation of type-level naturals.</source>
          <target state="translated">Экспоненцирование на уровне типов.</target>
        </trans-unit>
        <trans-unit id="00626a4a235bb8c7d8a4523a50b2711b29b68253" translate="yes" xml:space="preserve">
          <source>Exponentiation.</source>
          <target state="translated">Exponentiation.</target>
        </trans-unit>
        <trans-unit id="f3e4fadb9e370a1e2c0c622c01fc8c77daf93a2c" translate="yes" xml:space="preserve">
          <source>Export</source>
          <target state="translated">Export</target>
        </trans-unit>
        <trans-unit id="e32d807a50078398a9f45631a08c1c50a2f61bc8" translate="yes" xml:space="preserve">
          <source>Exports just the class name.</source>
          <target state="translated">Экспорт только название класса.</target>
        </trans-unit>
        <trans-unit id="3fc8d12d849fbc12100a92378eb6aae4e19b9f4a" translate="yes" xml:space="preserve">
          <source>Exports the class, the associated type &lt;code&gt;GMap&lt;/code&gt; and the member functions &lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;lookup&lt;/code&gt;, and &lt;code&gt;insert&lt;/code&gt;. The data constructors of &lt;code&gt;GMap&lt;/code&gt; (in this case &lt;code&gt;GMapEither&lt;/code&gt;) are not exported.</source>
          <target state="translated">Экспортирует класс, связанный тип &lt;code&gt;GMap&lt;/code&gt; и функции-члены &lt;code&gt;empty&lt;/code&gt; , &lt;code&gt;lookup&lt;/code&gt; и &lt;code&gt;insert&lt;/code&gt; . Конструкторы данных &lt;code&gt;GMap&lt;/code&gt; (в данном случае &lt;code&gt;GMapEither&lt;/code&gt; ) не экспортируются.</target>
        </trans-unit>
        <trans-unit id="96d97ba437aa14160758958471b9ae9dd5fd0d5d" translate="yes" xml:space="preserve">
          <source>Expose all unfoldings, even for very large or recursive functions.</source>
          <target state="translated">Выставляйте все разворачивающиеся фигуры,даже для очень больших или рекурсивных функций.</target>
        </trans-unit>
        <trans-unit id="97a05c5e3c535062788e96f9df6b2c9df3c0c670" translate="yes" xml:space="preserve">
          <source>Expose package by id ⟨unit-id⟩</source>
          <target state="translated">Разместить пакет по адресу ⟨unit-id⟩.</target>
        </trans-unit>
        <trans-unit id="37688778d1dbdfb3378a202fe8582b76a44a828a" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩</source>
          <target state="translated">Разместить пакет ⟨pkg⟩</target>
        </trans-unit>
        <trans-unit id="81f3b1cdb0761f66a9a464a1c7c58d8507de68a8" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be distrusted. See &lt;a href=&quot;exts/safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c2973c3230c9855092c9a09e0ad4f1866c0b24" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be distrusted. See &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="translated">Откройте пакет &amp;laquo;pkg&amp;raquo; и установите для него режим недоверия. См. &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11e656340a6337a3a218f8e6e5a6343ef2676dc0" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be trusted. See &lt;a href=&quot;exts/safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e66e14fce5ee7a55e29cdb00dc7373ae77bc67" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be trusted. See &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="translated">Откройте пакет &amp;laquo;pkg&amp;raquo; и сделайте его доверенным. См. &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a89902d15adce30fd9f53b376aa347621678477" translate="yes" xml:space="preserve">
          <source>Expose ⟨pkg-id⟩ for plugins</source>
          <target state="translated">Выставить ⟨pkg-id⟩ для плагинов</target>
        </trans-unit>
        <trans-unit id="0d375bc2563394c46196316fad7e222d95093011" translate="yes" xml:space="preserve">
          <source>Expose ⟨pkg⟩ for plugins</source>
          <target state="translated">Выставить ⟨pkg⟩ для плагинов</target>
        </trans-unit>
        <trans-unit id="31273b92a37ac408e2bf693485bae87890959943" translate="yes" xml:space="preserve">
          <source>Exposes a package in the plugin namespace like &lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package
⟨pkg⟩&lt;/code&gt;&lt;/a&gt;, but the package is named by its installed package ID rather than by name. This is a more robust way to name packages, and can be used to select packages that would otherwise be shadowed. Cabal passes &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt;&lt;/a&gt; flags to GHC. &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt;&lt;/a&gt; supports thinning and renaming described in &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt;.</source>
          <target state="translated">Предоставляет пакет в пространстве имен плагина, например &lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; , но пакет называется по идентификатору установленного пакета, а не по имени. Это более надежный способ именования пакетов, который может использоваться для выбора пакетов, которые в противном случае были бы затенены. Кабал передает &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt; &lt;/a&gt; в GHC. &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt; &lt;/a&gt; поддерживает прореживание и переименование, описанное в разделе &amp;laquo;&lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt; Прореживание и переименование модулей&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7282a9f671014a5a12b95db9b6e9d0017367cafb" translate="yes" xml:space="preserve">
          <source>Exposes a package like &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt;, but the package is named by its unit ID (i.e. the value of &lt;code&gt;id&lt;/code&gt; in its entry in the installed package database, also previously known as an installed package ID) rather than by name. This is a more robust way to name packages, and can be used to select packages that would otherwise be shadowed. Cabal passes &lt;code&gt;-package-id&lt;/code&gt; flags to GHC. &lt;code&gt;-package-id&lt;/code&gt; supports thinning and renaming described in &lt;a href=&quot;#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt;.</source>
          <target state="translated">Предоставляет пакет наподобие &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; , но пакет назван по его идентификатору модуля (т. Е. Значению &lt;code&gt;id&lt;/code&gt; в его записи в базе данных установленных пакетов, также ранее известной как идентификатор установленного пакета), а не по имени. Это более надежный способ именования пакетов, который может использоваться для выбора пакетов, которые в противном случае были бы затенены. Кабал передает флаги &lt;code&gt;-package-id&lt;/code&gt; в GHC. &lt;code&gt;-package-id&lt;/code&gt; поддерживает прореживание и переименование, описанное в &lt;a href=&quot;#package-thinning-and-renaming&quot;&gt;разделе &amp;laquo;Прореживание и переименование модулей&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eba39a9246ec8d3133e56adef9502fd5768f6301" translate="yes" xml:space="preserve">
          <source>Exposes package ⟨pkg⟩ if it was hidden and considers it a trusted package regardless of the package database.</source>
          <target state="translated">Выставляет пакет ⟨pkg⟩,если он был скрыт и считает его доверенным пакетом независимо от базы данных пакета.</target>
        </trans-unit>
        <trans-unit id="1863c0103a35229fbd10f03c71eaa9dfd10d3726" translate="yes" xml:space="preserve">
          <source>Exposes package ⟨pkg⟩ if it was hidden and considers it an untrusted package regardless of the package database.</source>
          <target state="translated">Выставляет пакет ⟨pkg⟩,если он был скрыт и считает его недоверенным,независимо от базы данных пакетов.</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="b4b58a3bd3bca39250be0caf31bc3f191c3d3f5c" translate="yes" xml:space="preserve">
          <source>Expression quotations accept most Haskell language constructs. However, there are some GHC-specific extensions which expression quotations currently do not support, including</source>
          <target state="translated">Цитаты выражений принимают большинство конструкций языка Хаскелла.Тем не менее,существуют некоторые специфичные для GHC расширения,которые в настоящее время не поддерживаются цитатами выражений,включая</target>
        </trans-unit>
        <trans-unit id="776e1ed70ff53446d3e23e14206d1868975984de" translate="yes" xml:space="preserve">
          <source>Expression splices: anonymous and named wildcards can be used in expression signatures. Extra-constraints wildcards are not supported, just like in regular expression signatures.</source>
          <target state="translated">Сплетения выражений:в подписях выражений могут использоваться анонимные и именованные подстановочные знаки.Символы подстановки с дополнительными ограничениями не поддерживаются,как и в подписях регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="4c356f5e7e4d5da3fa92f3a447cf549c220408dd" translate="yes" xml:space="preserve">
          <source>Expression type annotations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3da441768abbdbc67e62f834d5dc1520b1d2404c" translate="yes" xml:space="preserve">
          <source>Expression-evaluation mode. This is very similar to interactive mode, except that there is a single expression to evaluate (⟨expr⟩) which is given on the command line. See &lt;a href=&quot;#eval-mode&quot;&gt;Expression evaluation mode&lt;/a&gt; for more details.</source>
          <target state="translated">Режим оценки выражений. Это очень похоже на интерактивный режим, за исключением того, что есть одно выражение для вычисления (expr⟩), которое задается в командной строке. Подробнее см. &lt;a href=&quot;#eval-mode&quot;&gt;Режим оценки выражения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="275a91a95ab556ed8f4f58810f3754cc004740c4" translate="yes" xml:space="preserve">
          <source>Exquisitely unsafe.</source>
          <target state="translated">Исключительно небезопасно.</target>
        </trans-unit>
        <trans-unit id="f20ecbb0b8def6d6be9c1c1d5504d4aa8e121b40" translate="yes" xml:space="preserve">
          <source>Extended euclidean algorithm.</source>
          <target state="translated">Расширенный эвклидовый алгоритм.</target>
        </trans-unit>
        <trans-unit id="1376ee00053aa4b8f335d718cd6b32eade0d6b7b" translate="yes" xml:space="preserve">
          <source>Extended version of &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Расширенная версия &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2fde66be8f0b7d74100f58661df4304a6a4125c1" translate="yes" xml:space="preserve">
          <source>ExtendedDefaultRules</source>
          <target state="translated">ExtendedDefaultRules</target>
        </trans-unit>
        <trans-unit id="a5fe846d7930403bb12925a53f1812f6d7b386f3" translate="yes" xml:space="preserve">
          <source>ExtendedFormat</source>
          <target state="translated">ExtendedFormat</target>
        </trans-unit>
        <trans-unit id="d297572cdf75e0fc69b0851ecb181ba44e9e43c3" translate="yes" xml:space="preserve">
          <source>ExtendedFunctions</source>
          <target state="translated">ExtendedFunctions</target>
        </trans-unit>
        <trans-unit id="19831f202245d7d2e8594d815d8ec9b0ca11a673" translate="yes" xml:space="preserve">
          <source>Extending To New Types</source>
          <target state="translated">Расширение до новых типов</target>
        </trans-unit>
        <trans-unit id="d9d7e1571d0f21e76efd77f308d22979ff95823f" translate="yes" xml:space="preserve">
          <source>Extending the atomicity to multiple &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;s is problematic, so it is recommended that if you need to do anything more complicated then using &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; instead is a good idea.</source>
          <target state="translated">Расширение атомарности на несколько &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; проблематично, поэтому рекомендуется, если вам нужно сделать что-нибудь более сложное, вместо этого использовать &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32e045360ba1cab276fc39bb4d35f14e0162488f" translate="yes" xml:space="preserve">
          <source>Extensible Exceptions</source>
          <target state="translated">Расширяемые исключения</target>
        </trans-unit>
        <trans-unit id="659087d3ca23db6ae11e0a43579b5f4a260dda11" translate="yes" xml:space="preserve">
          <source>Extension</source>
          <target state="translated">Extension</target>
        </trans-unit>
        <trans-unit id="0508e77219f46be972ce3c02c3d431e8dfa41ced" translate="yes" xml:space="preserve">
          <source>Extension functions</source>
          <target state="translated">Функции расширения</target>
        </trans-unit>
        <trans-unit id="b548c2c0e4fdd3a3b443d1717032aa1c37d0f158" translate="yes" xml:space="preserve">
          <source>External API for GHC's Handle implementation</source>
          <target state="translated">Внешний API для реализации ручки GHC</target>
        </trans-unit>
        <trans-unit id="16bb88e5a699d082f65df34dff99c2cc562f221d" translate="yes" xml:space="preserve">
          <source>Extra attributes in XHTML Frameset</source>
          <target state="translated">Дополнительные атрибуты в кадре XHTML</target>
        </trans-unit>
        <trans-unit id="f69729e705bc5ed85ac415d6b079562cec0ad227" translate="yes" xml:space="preserve">
          <source>Extra attributes in XHTML Transitional</source>
          <target state="translated">Дополнительные атрибуты в XHTML Transitional</target>
        </trans-unit>
        <trans-unit id="553906fce6304e8619f26f965d66b3c128e56184" translate="yes" xml:space="preserve">
          <source>Extra elements in XHTML Frameset</source>
          <target state="translated">Дополнительные элементы в XHTML-каркасе</target>
        </trans-unit>
        <trans-unit id="26b12138ed5c4f776e03e07094f229d75bf93c68" translate="yes" xml:space="preserve">
          <source>Extra elements in XHTML Transitional</source>
          <target state="translated">Дополнительные элементы в XHTML Transitional</target>
        </trans-unit>
        <trans-unit id="da60db19e688c9d65306dbe01f15f0fdb2f70b5e" translate="yes" xml:space="preserve">
          <source>Extra functions for creating and executing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. They are intended for application-specific fine-tuning the performance of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">Дополнительные функции для создания и выполнения &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; s. Они предназначены для точной настройки производительности &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; для конкретных приложений .</target>
        </trans-unit>
        <trans-unit id="376098e515a5a7a4ad09f15cc26f6f580a3f3f98" translate="yes" xml:space="preserve">
          <source>Extra instances</source>
          <target state="translated">Дополнительные случаи</target>
        </trans-unit>
        <trans-unit id="9007458c8fef52cf2dfc82ca45560435a502b151" translate="yes" xml:space="preserve">
          <source>Extra libraries may be specified on the command line using the normal &lt;code&gt;-llib&lt;/code&gt; option. (The term &lt;em&gt;library&lt;/em&gt; here refers to libraries of foreign object code; for using libraries of Haskell source code, see &lt;a href=&quot;#ghci-modules-filenames&quot;&gt;Modules vs. filenames&lt;/a&gt;.) For example, to load the &amp;ldquo;m&amp;rdquo; library:</source>
          <target state="translated">Дополнительные библиотеки можно указать в командной строке с помощью обычной опции &lt;code&gt;-llib&lt;/code&gt; . (Термин &lt;em&gt;библиотека&lt;/em&gt; здесь относится к библиотекам кода сторонних объектов; для использования библиотек исходного кода Haskell см. &lt;a href=&quot;#ghci-modules-filenames&quot;&gt;Модули и имена файлов&lt;/a&gt; .) Например, чтобы загрузить библиотеку &amp;laquo;m&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="94db6ab5b7a358912d06ebf314fa45afb8a5bfbb" translate="yes" xml:space="preserve">
          <source>Extra-constraints wildcards cannot be named.</source>
          <target state="translated">Подстановочные знаки ограничения не могут быть названы.</target>
        </trans-unit>
        <trans-unit id="85204331cdc5a5234455094d82f670148ee95ebf" translate="yes" xml:space="preserve">
          <source>Extract &lt;em&gt;n&lt;/em&gt;-th (0-based) limb in &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;. &lt;em&gt;n&lt;/em&gt; must be less than size as reported by &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeofBigNat-35-&quot;&gt;sizeofBigNat#&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Извлеките &lt;em&gt;n&lt;/em&gt; -ю конечность ( &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 0) в BigNat . &lt;em&gt;n&lt;/em&gt; должно быть меньше размера, &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeofBigNat-35-&quot;&gt;sizeofBigNat#&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83cd2d2591e39909edf59b0149e6f118b65261cb" translate="yes" xml:space="preserve">
          <source>Extract a Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; from a Haskell &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and perform an action on it.</source>
          <target state="translated">Извлечение Windows , &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; от Haskell &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; и выполнить действие на него.</target>
        </trans-unit>
        <trans-unit id="8caedd806eb75a1dd1593915008b003746bd2766" translate="yes" xml:space="preserve">
          <source>Extract a Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; from a Haskell &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and perform an action on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1fa28e22bcf37a9620ff9632c0178f62249b64b" translate="yes" xml:space="preserve">
          <source>Extract a Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; from a Haskell &lt;code&gt;&lt;a href=&quot;../base/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and perform an action on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19459f6f6029b9562ac7b8bae42f2d17949ad995" translate="yes" xml:space="preserve">
          <source>Extract a list of call-sites from the &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Извлеките список call-сайтов из &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dac372cf1e3a7a31e848e034a3e801d7adfa82f1" translate="yes" xml:space="preserve">
          <source>Extract a list of call-sites from the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Извлеките список call-сайтов из &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15320bf99294a6713c984fb7ea9afb23bf9f7574" translate="yes" xml:space="preserve">
          <source>Extract a list of call-sites from the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Извлеките список call-сайтов из &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3c94be241aef7a388442a14750ccab2863f4fb0" translate="yes" xml:space="preserve">
          <source>Extract a witness of equality of two types</source>
          <target state="translated">Извлечь свидетеля равенства двух типов</target>
        </trans-unit>
        <trans-unit id="1c9f2b2fd473a09dd65773f2fc4162151096161e" translate="yes" xml:space="preserve">
          <source>Extract bits from a word at locations specified by a mask.</source>
          <target state="translated">Извлечение битов из слова в местах,указанных маской.</target>
        </trans-unit>
        <trans-unit id="f3c5f3c2ea4a5cd70d10527f67daa863bccf6943" translate="yes" xml:space="preserve">
          <source>Extract bits from lower 16 bits of a word at locations specified by a mask.</source>
          <target state="translated">Извлекайте биты из нижних 16 бит слова в местах,заданных маской.</target>
        </trans-unit>
        <trans-unit id="c24c9008df295389591cc7deb4f2a2d68e7c6b1c" translate="yes" xml:space="preserve">
          <source>Extract bits from lower 32 bits of a word at locations specified by a mask.</source>
          <target state="translated">Извлекайте биты из нижних 32 бит слова в местах,заданных маской.</target>
        </trans-unit>
        <trans-unit id="f2cc34ff176f2175e6e34bb0cdc8cd7517e09bd6" translate="yes" xml:space="preserve">
          <source>Extract bits from lower 8 bits of a word at locations specified by a mask.</source>
          <target state="translated">Извлекайте биты из нижних 8 бит слова в местах,указанных маской.</target>
        </trans-unit>
        <trans-unit id="f1857d7fa6cd46609ec91ad030bedb1462ff8de3" translate="yes" xml:space="preserve">
          <source>Extract equality of the arguments from an equality of applied types</source>
          <target state="translated">Извлечь равенство аргументов из равенства применяемых типов</target>
        </trans-unit>
        <trans-unit id="a99a8380cb42a1ba110471522ef91ef98bfe57c8" translate="yes" xml:space="preserve">
          <source>Extract equality of type constructors from an equality of applied types</source>
          <target state="translated">Извлечь равенство типовых конструкторов из равенства применяемых типов</target>
        </trans-unit>
        <trans-unit id="209b131507b67783064eca27720c5bbe3fbc4b1e" translate="yes" xml:space="preserve">
          <source>Extract everything except the last element of the stream.</source>
          <target state="translated">Извлеките все,кроме последнего элемента потока.</target>
        </trans-unit>
        <trans-unit id="e6da9a2e3b63f515594693602b689849079aaa62" translate="yes" xml:space="preserve">
          <source>Extract the denominator of the ratio in reduced form: the numerator and denominator have no common factor and the denominator is positive.</source>
          <target state="translated">Извлеките знаменатель соотношения в уменьшенном виде:числитель и знаменатель не имеют общего коэффициента,а знаменатель положительный.</target>
        </trans-unit>
        <trans-unit id="faa5733bddece05d48a2d5fab4a6b5d19927ff0f" translate="yes" xml:space="preserve">
          <source>Extract the first component of a pair.</source>
          <target state="translated">Извлеките первый компонент пары.</target>
        </trans-unit>
        <trans-unit id="8e1431bbaba37fcca3d788ca32422f37c47e0f53" translate="yes" xml:space="preserve">
          <source>Extract the first element of the stream.</source>
          <target state="translated">Извлеките первый элемент потока.</target>
        </trans-unit>
        <trans-unit id="74dba7610acef8dde9eb95e9dcdd115a56c67e63" translate="yes" xml:space="preserve">
          <source>Extract the last element of the stream.</source>
          <target state="translated">Извлеките последний элемент потока.</target>
        </trans-unit>
        <trans-unit id="71672882a12f0371a79613a5b2a1896e09a4aea8" translate="yes" xml:space="preserve">
          <source>Extract the message string from an error message</source>
          <target state="translated">Извлечь строку сообщения из сообщения об ошибке</target>
        </trans-unit>
        <trans-unit id="0627b6c102c0812e00a5765ad3ea478aeb42dc0d" translate="yes" xml:space="preserve">
          <source>Extract the numerator of the ratio in reduced form: the numerator and denominator have no common factor and the denominator is positive.</source>
          <target state="translated">Извлеките числитель коэффициента в уменьшенном виде:числитель и знаменатель не имеют общего коэффициента,а знаменатель положительный.</target>
        </trans-unit>
        <trans-unit id="ccae588e4f18a0d7150f16e84a2466cf53e67121" translate="yes" xml:space="preserve">
          <source>Extract the output from a writer computation.</source>
          <target state="translated">Извлечь выходные данные из вычислений писателя.</target>
        </trans-unit>
        <trans-unit id="e13a7d27f5717a8051ad34044b84ac3c322dad08" translate="yes" xml:space="preserve">
          <source>Extract the output from an accumulation computation.</source>
          <target state="translated">Извлечь выходные данные из расчета накопления.</target>
        </trans-unit>
        <trans-unit id="9b59da5a9fb1822fe3838decbce6b18c7bb10353" translate="yes" xml:space="preserve">
          <source>Extract the possibly-empty tail of the stream.</source>
          <target state="translated">Извлеките возможно пустой хвост ручья.</target>
        </trans-unit>
        <trans-unit id="c80d49f20d5312d630bb4c89de7be96ba635eeb8" translate="yes" xml:space="preserve">
          <source>Extract the second component of a pair.</source>
          <target state="translated">Извлеките второй компонент пары.</target>
        </trans-unit>
        <trans-unit id="048e8268764c5263423031088d1cd0a66e5df985" translate="yes" xml:space="preserve">
          <source>Extract the untyped representation from the typed representation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87182d58b2e5c3b8ac01884cc785fccbf6f2e02" translate="yes" xml:space="preserve">
          <source>Extracting components of fractions.</source>
          <target state="translated">Извлечение компонентов фракций.</target>
        </trans-unit>
        <trans-unit id="66c1d08c125187599a1f446de72b7b3934ea1356" translate="yes" xml:space="preserve">
          <source>Extracting sublists</source>
          <target state="translated">Добыча подлистов</target>
        </trans-unit>
        <trans-unit id="1e06f8844a90f3392493e9ddf149b5c480a88612" translate="yes" xml:space="preserve">
          <source>Extractor for computations in the exception monad. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Экстрактор для вычислений в монаде исключений. (Инверсия &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f6f7a3f48fe2a36a8d1f4f84df1cff70314fddb2" translate="yes" xml:space="preserve">
          <source>Extractor for computations in the exception monad. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Экстрактор для вычислений в монаде исключений. (Инверсия &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3aca5f828a77e707fa46ed0c55a1b00b856836a4" translate="yes" xml:space="preserve">
          <source>Extractor for computations with accumulating errors.</source>
          <target state="translated">Экстрактор для вычислений с накопившимися ошибками.</target>
        </trans-unit>
        <trans-unit id="e2053668b7ebb2019a802842e9789436a8c0f771" translate="yes" xml:space="preserve">
          <source>Extracts from a list of &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; all the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; elements. All the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; elements are extracted in order.</source>
          <target state="translated">Извлекает из списка &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; все элементы &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; . Все элементы &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; извлекаются по порядку.</target>
        </trans-unit>
        <trans-unit id="23593562fd69e1de66ae4e632731e63b67f94b89" translate="yes" xml:space="preserve">
          <source>Extracts from a list of &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; all the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; elements. All the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; elements are extracted in order.</source>
          <target state="translated">Выдержки из списка &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; всех &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; элементов. Все элементы &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; извлекаются по порядку.</target>
        </trans-unit>
        <trans-unit id="47765e86c15d457b99a9254fc457aec3171dfef3" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This function has the side effect of closing the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and flushing its write buffer, if necessary.</source>
          <target state="translated">Извлекает &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; из &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; . Эта функция имеет побочный эффект закрытия &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; и очистки его буфера записи, если это необходимо.</target>
        </trans-unit>
        <trans-unit id="56cd8ea295a261029ef6e0001e10564c02952e69" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This function has the side effect of closing the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and flushing its write buffer, if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12df19590e3fea55c64fb5d4077a86cd9854c08f" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This function has the side effect of closing the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and flushing its write buffer, if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37c14699604a03fd4d86810b3d7950f2e52cc77" translate="yes" xml:space="preserve">
          <source>Extracts the bounds of an immutable array</source>
          <target state="translated">Извлекает границы непреложного массива</target>
        </trans-unit>
        <trans-unit id="3927ad512fc6801a8c448cfc25e6c4a5aa1e6fdc" translate="yes" xml:space="preserve">
          <source>Extracts the column number from a source position.</source>
          <target state="translated">Извлекает номер столбца из исходной позиции.</target>
        </trans-unit>
        <trans-unit id="f98a98ccf1f30629f52ac9fd6ceee04b851c3cb8" translate="yes" xml:space="preserve">
          <source>Extracts the imaginary part of a complex number.</source>
          <target state="translated">Извлекает воображаемую часть комплексного числа.</target>
        </trans-unit>
        <trans-unit id="72b735a2e8cc21e50312444f0be2cba46269cdb2" translate="yes" xml:space="preserve">
          <source>Extracts the line number from a source position.</source>
          <target state="translated">Извлекает номер строки из исходной позиции.</target>
        </trans-unit>
        <trans-unit id="5aa85df9b78b3e81e43bd5f3eef197d388f12497" translate="yes" xml:space="preserve">
          <source>Extracts the list of error messages from the parse error</source>
          <target state="translated">Извлекает список сообщений об ошибках из анализа ошибки</target>
        </trans-unit>
        <trans-unit id="1d52fc67cbb595042e4bfe8748fe75b10e3bfaf9" translate="yes" xml:space="preserve">
          <source>Extracts the name of the source from a source position.</source>
          <target state="translated">Извлекает имя источника из позиции источника.</target>
        </trans-unit>
        <trans-unit id="fa7820eeb9c8d1f0372901d7c48b937c85bd82cf" translate="yes" xml:space="preserve">
          <source>Extracts the real part of a complex number.</source>
          <target state="translated">Извлекает реальную часть комплексного числа.</target>
        </trans-unit>
        <trans-unit id="1463e681d793be66e7fe209521155ad317d859f8" translate="yes" xml:space="preserve">
          <source>Extracts the source position from the parse error</source>
          <target state="translated">Извлекает исходную позицию из ошибки разбора</target>
        </trans-unit>
        <trans-unit id="3b729075855fa307e52f7a82b9acfe92bcb6b2c8" translate="yes" xml:space="preserve">
          <source>F. Lundh: The Fast Search Algorithm. &lt;a href=&quot;http://effbot.org/zone/stringlib.htm&quot;&gt;http://effbot.org/zone/stringlib.htm&lt;/a&gt; (2006)</source>
          <target state="translated">Ф. Лунд: Алгоритм быстрого поиска. &lt;a href=&quot;http://effbot.org/zone/stringlib.htm&quot;&gt;http://effbot.org/zone/stringlib.htm&lt;/a&gt; (2006 г.)</target>
        </trans-unit>
        <trans-unit id="280c80844f01a9db84ec5402a6bd821338a8cfbf" translate="yes" xml:space="preserve">
          <source>FD</source>
          <target state="translated">FD</target>
        </trans-unit>
        <trans-unit id="07e3e68b1daed47acfe17b62cf16a3642bb89af6" translate="yes" xml:space="preserve">
          <source>FD_CLOEXEC</source>
          <target state="translated">FD_CLOEXEC</target>
        </trans-unit>
        <trans-unit id="6f76a711154e10c8b7d9ded2ab1414e67e29bdbc" translate="yes" xml:space="preserve">
          <source>FFExponent</source>
          <target state="translated">FFExponent</target>
        </trans-unit>
        <trans-unit id="9aa9cec1f34d9fa7339b6f9c8dfdf9bf6e52e0d8" translate="yes" xml:space="preserve">
          <source>FFFixed</source>
          <target state="translated">FFFixed</target>
        </trans-unit>
        <trans-unit id="de69c96e4288f9614d0d84273990ab542079c11c" translate="yes" xml:space="preserve">
          <source>FFFormat</source>
          <target state="translated">FFFormat</target>
        </trans-unit>
        <trans-unit id="b3876baa83fd86b2878e18b0db680254a946fea2" translate="yes" xml:space="preserve">
          <source>FFGeneric</source>
          <target state="translated">FFGeneric</target>
        </trans-unit>
        <trans-unit id="62b8d6cc22c479012823c38f9f1c4e6a0ca2ec3f" translate="yes" xml:space="preserve">
          <source>FFI datatypes and operations that use or require concurrency (GHC only).</source>
          <target state="translated">Типы данных FFI и операции,использующие или требующие параллелизма (только GHC).</target>
        </trans-unit>
        <trans-unit id="72ef38f5a65a645f475c68f4dff976400453ed6a" translate="yes" xml:space="preserve">
          <source>FFI support is enabled by default, but can be enabled or disabled explicitly with the &lt;a href=&quot;#extension-ForeignFunctionInterface&quot;&gt;&lt;code&gt;ForeignFunctionInterface&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">Поддержка FFI включена по умолчанию, но может быть включена или отключена явно с &lt;a href=&quot;#extension-ForeignFunctionInterface&quot;&gt; &lt;code&gt;ForeignFunctionInterface&lt;/code&gt; &lt;/a&gt; флага ForeignFunctionInterface .</target>
        </trans-unit>
        <trans-unit id="e54402f59eaf0ee8458f6bec4af7033bf2817f96" translate="yes" xml:space="preserve">
          <source>FFI-bindings to interact with SimpleMAPI</source>
          <target state="translated">FFI-связки для взаимодействия с SimpleMAPI</target>
        </trans-unit>
        <trans-unit id="d9f5ec79f6b4ceeadbaeb6e44d31fab891b6c294" translate="yes" xml:space="preserve">
          <source>FFI-bindings to interact with Win32 Security</source>
          <target state="translated">FFI-связи для взаимодействия с Win32 Security</target>
        </trans-unit>
        <trans-unit id="cd98ae36981ee80a267c314ec60000c7f9d30870" translate="yes" xml:space="preserve">
          <source>FLOAT</source>
          <target state="translated">FLOAT</target>
        </trans-unit>
        <trans-unit id="b5842d158a0ef95bb05982b944ce15a5f0702019" translate="yes" xml:space="preserve">
          <source>FOR ALL</source>
          <target state="translated">НА ВСЕХ</target>
        </trans-unit>
        <trans-unit id="cc069309a71a6b082f46a01f71efc1df948b1806" translate="yes" xml:space="preserve">
          <source>FORCE</source>
          <target state="translated">FORCE</target>
        </trans-unit>
        <trans-unit id="e7c189bd9105436a22b6dc9c0118398b753dc2ec" translate="yes" xml:space="preserve">
          <source>FPFormat</source>
          <target state="translated">FPFormat</target>
        </trans-unit>
        <trans-unit id="b332cee2f39f6c7203f896ba88110e82aff15a68" translate="yes" xml:space="preserve">
          <source>Faced with the problems described above, some Haskell programmers might be tempted to use something like the following version of the class declaration:</source>
          <target state="translated">Столкнувшись с описанными выше проблемами,некоторые программисты Haskell могут поддаться искушению использовать что-то вроде следующей версии объявления класса:</target>
        </trans-unit>
        <trans-unit id="dae896f141aeb2a67159098fa3c417c9d9c6e0ef" translate="yes" xml:space="preserve">
          <source>Failure records information about the cause/location of the failure. Failure values bypass the bound function, other values are used as inputs to the bound function.</source>
          <target state="translated">Сбой записывает информацию о причине/расположении сбоя.Значения отказа обходят связанную функцию,другие значения используются в качестве входов для связанной функции.</target>
        </trans-unit>
        <trans-unit id="9a507f0e5168c6ed30b03a96ee64617f5b05c7fe" translate="yes" xml:space="preserve">
          <source>Fairness</source>
          <target state="translated">Fairness</target>
        </trans-unit>
        <trans-unit id="97cdbdc7feff827efb082a6b6dd2727237cd49fd" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="translated">False</target>
        </trans-unit>
        <trans-unit id="93d46a9da7001524df4cde3ca05b775fe0b85bf2" translate="yes" xml:space="preserve">
          <source>Family instances are implicitly exported, just like class instances. However, this applies only to the heads of instances, not to the data constructors an instance defines.</source>
          <target state="translated">Семейные экземпляры неявно экспортируются,как и экземпляры классов.Однако,это относится только к головкам экземпляров,а не к конструкторам данных,которые определяет экземпляр.</target>
        </trans-unit>
        <trans-unit id="7c03cfd18e7c0aa33fb0869c7db1ce2c71a9f1e4" translate="yes" xml:space="preserve">
          <source>FamilyResultSig</source>
          <target state="translated">FamilyResultSig</target>
        </trans-unit>
        <trans-unit id="5709a3aacba98eb7dab9b3ec1486beeceefdb838" translate="yes" xml:space="preserve">
          <source>FamilyResultSigQ</source>
          <target state="translated">FamilyResultSigQ</target>
        </trans-unit>
        <trans-unit id="6ee40b96a43fdbccb9bc7964f655f965fe647da5" translate="yes" xml:space="preserve">
          <source>Fanin: Split the input between the two argument arrows and merge their outputs.</source>
          <target state="translated">Фанин:Разделите вход между двумя стрелками аргументов и объедините их выходы.</target>
        </trans-unit>
        <trans-unit id="3d081b433b8a30d7f41b2cdd2ab22d0c446b40a8" translate="yes" xml:space="preserve">
          <source>Fanout: send the input to both argument arrows and combine their output.</source>
          <target state="translated">Fanout:отправьте входные данные на обе стрелки аргументов и объедините их выходные данные.</target>
        </trans-unit>
        <trans-unit id="a1448d14f32031abf80a6b03dd5aed71399356a2" translate="yes" xml:space="preserve">
          <source>Fast &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; logarithms to base 2. &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:wordLog2-35-&quot;&gt;wordLog2#&lt;/a&gt;&lt;/code&gt; are of general usefulness, the others are only needed for a fast implementation of &lt;code&gt;fromRational&lt;/code&gt;. Since they are needed in &lt;a href=&quot;ghc-float&quot;&gt;GHC.Float&lt;/a&gt;, we must expose this module, but it should not show up in the docs.</source>
          <target state="translated">Быстрые &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; логарифмы с основанием 2. &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:wordLog2-35-&quot;&gt;wordLog2#&lt;/a&gt;&lt;/code&gt; имеют общую полезность, остальные нужны только для быстрой реализации &lt;code&gt;fromRational&lt;/code&gt; . Поскольку они необходимы в &lt;a href=&quot;ghc-float&quot;&gt;GHC.Float&lt;/a&gt; , мы должны раскрыть этот модуль, но он не должен отображаться в документации.</target>
        </trans-unit>
        <trans-unit id="604c30fffeb97fca92cde7e102ee6fa4c46126b4" translate="yes" xml:space="preserve">
          <source>Fast access to the system clock.</source>
          <target state="translated">Быстрый доступ к системным часам.</target>
        </trans-unit>
        <trans-unit id="dd750b3188ada6606559e5e05cd316edbb060aa4" translate="yes" xml:space="preserve">
          <source>Fast character manipulation functions.</source>
          <target state="translated">Функции быстрого манипулирования персонажами.</target>
        </trans-unit>
        <trans-unit id="a12096fc3f71f15571f0bdb559c8a630fd59e216" translate="yes" xml:space="preserve">
          <source>Fast substring search for &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, based on work by Boyer, Moore, Horspool, Sunday, and Lundh.</source>
          <target state="translated">Быстрый поиск подстроки для &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; , основанный на работе Бойера, Мура, Хорспула, Сандей и Лунда.</target>
        </trans-unit>
        <trans-unit id="ff1949d07a3568ece3a1b271a32199c64e456437" translate="yes" xml:space="preserve">
          <source>Fast substring search for lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, based on work by Boyer, Moore, Horspool, Sunday, and Lundh. Adapted from the strict implementation.</source>
          <target state="translated">Быстрый поиск подстроки для отложенного &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; , основанный на работах Бойера, Мура, Хорспула, Сандей и Лунда. Адаптирован из строгой реализации.</target>
        </trans-unit>
        <trans-unit id="d5053d7cd5f1b006c98595f6bd4ac62f10f404ea" translate="yes" xml:space="preserve">
          <source>Fast, unchecked bit shifting functions.</source>
          <target state="translated">Быстрые,непроверенные функции сдвига битов.</target>
        </trans-unit>
        <trans-unit id="6ce335ee3b25f9d7b908119c787dacbffab32155" translate="yes" xml:space="preserve">
          <source>Fd</source>
          <target state="translated">Fd</target>
        </trans-unit>
        <trans-unit id="f4e08a048eae08fd45b1d7080137ccedd2e9a232" translate="yes" xml:space="preserve">
          <source>FdKey</source>
          <target state="translated">FdKey</target>
        </trans-unit>
        <trans-unit id="9075ca9a523e56d968e61c7fa9bd0c125d3dbaa9" translate="yes" xml:space="preserve">
          <source>FdOption</source>
          <target state="translated">FdOption</target>
        </trans-unit>
        <trans-unit id="ff381dc1fa65f2d09b763ebd9d555902bb4b8aa8" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="translated">Загрузите в &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; больше входных данных. Если &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; будет &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; это добавит вход в &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; из неизрасходованного ввода.</target>
        </trans-unit>
        <trans-unit id="4e9b2c02289e4857fb2ab57f2809114796555b9f" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="translated">Загрузите в &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; больше входных данных. Если &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; будет &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; это добавит вход в &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; из неизрасходованного ввода.</target>
        </trans-unit>
        <trans-unit id="69e3b2b59aa4aebef05a2ee1ed5b935914ea9021" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b4648ed500c37b8a76ac1f7c07fc6a62b9d886" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd5bf737c14ded7353e41c04daecd9804c7b9d6" translate="yes" xml:space="preserve">
          <source>Feed marked inputs through the argument arrow, passing the rest through unchanged to the output.</source>
          <target state="translated">Подача помеченных входов через стрелку-параметр,передача остальных без изменений на выход.</target>
        </trans-unit>
        <trans-unit id="c8d7677e19495f21da984fe4e2829b7ca91b27c7" translate="yes" xml:space="preserve">
          <source>Feedback</source>
          <target state="translated">Feedback</target>
        </trans-unit>
        <trans-unit id="b1673adba303c1f23dda58f316aeab11e438ee50" translate="yes" xml:space="preserve">
          <source>Fetch the current value of the state within the monad.</source>
          <target state="translated">Получите текущее значение состояния внутри монады.</target>
        </trans-unit>
        <trans-unit id="9655bb220d4cd1a7d2999eacc755e15eb55c9e74" translate="yes" xml:space="preserve">
          <source>Fetch the value of the environment.</source>
          <target state="translated">Получите значение окружающей среды.</target>
        </trans-unit>
        <trans-unit id="c251e678b25c081d063a5d28ed8182955bdb81eb" translate="yes" xml:space="preserve">
          <source>Fewest inaccessible clauses</source>
          <target state="translated">Наименьшее количество недоступных положений</target>
        </trans-unit>
        <trans-unit id="7e2728111a7fab96f0d3a4080311c545fe9cc7bf" translate="yes" xml:space="preserve">
          <source>Fewest redundant clauses</source>
          <target state="translated">Наименьшее количество избыточных пунктов</target>
        </trans-unit>
        <trans-unit id="d6b6429e633d85c9027c14440388d087da532ae3" translate="yes" xml:space="preserve">
          <source>Fewest uncovered clauses</source>
          <target state="translated">Наименьшее количество непокрытых пунктов</target>
        </trans-unit>
        <trans-unit id="28f549c52b7931248dae14989071407da27552c4" translate="yes" xml:space="preserve">
          <source>Field CapNo</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03ded020bc6474da975890833ccd8f148e8a07d9" translate="yes" xml:space="preserve">
          <source>Field CapNo:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4fe29f979583aef741d1f90e93bfaa345f64333" translate="yes" xml:space="preserve">
          <source>Field CapSetId</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac78598db657aa0c38e0a7b064e261405764b90" translate="yes" xml:space="preserve">
          <source>Field CapSetId:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d376a5f188ba09d0575c030e75276555ef3037b" translate="yes" xml:space="preserve">
          <source>Field String</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a62e5ff1d5e101aeed17e5d052a10aaa3017be5b" translate="yes" xml:space="preserve">
          <source>Field String:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e33298c696fedbed9fc0116f43829e5721d9f07" translate="yes" xml:space="preserve">
          <source>Field TaskId</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3803a8cbdbe813e945dd95bbdc4dffab8ccbfd7" translate="yes" xml:space="preserve">
          <source>Field TaskId:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee11d3a290e704407e05db1631372bf1b3dbe72" translate="yes" xml:space="preserve">
          <source>Field ThreadId</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a47467c208f9af64bcfa1d0225564748d7312c" translate="yes" xml:space="preserve">
          <source>Field ThreadId:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033928db92181f79852ddc994a0c003ec14b17e1" translate="yes" xml:space="preserve">
          <source>Field Word16</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbcfd83bc4c9e590b27d81c7a0808713eab58ee9" translate="yes" xml:space="preserve">
          <source>Field Word16:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e5a07512e61c7eb3e794df15878325a5e53713" translate="yes" xml:space="preserve">
          <source>Field Word32</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f1a115395af35bce115c6c82b59e4a4a5087fa" translate="yes" xml:space="preserve">
          <source>Field Word32:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0536b1c8eb0eeac80c4b4a595b342d8367bd6a0" translate="yes" xml:space="preserve">
          <source>Field Word32[]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e59e9060dc4635660cb6bfaff4355ba8a486745a" translate="yes" xml:space="preserve">
          <source>Field Word32[]:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="727d70feadcbb92b2fc2f2668935aa3272996214" translate="yes" xml:space="preserve">
          <source>Field Word64</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cbbdf7e0b7dfdebe7dfe21d03bf00d60a18f320" translate="yes" xml:space="preserve">
          <source>Field Word64:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a846bfa3518bf3d88d0ce3066df98c589343374a" translate="yes" xml:space="preserve">
          <source>Field Word8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7b88f825a8de27b63373e28f7a77a5b201a208" translate="yes" xml:space="preserve">
          <source>Field Word8:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="038766ad89a5656bc1a23b0e43bb712d94a7a368" translate="yes" xml:space="preserve">
          <source>Field [String]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a2dd2f21d7d7ea1bc52b694a50f6bf5a257e793" translate="yes" xml:space="preserve">
          <source>Field [String]:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb83d98e1af99f389ea1d7d36d6591ca3c321b0c" translate="yes" xml:space="preserve">
          <source>Field disambiguation can be combined with punning (see &lt;a href=&quot;#record-puns&quot;&gt;Record puns&lt;/a&gt;). For example:</source>
          <target state="translated">Устранение неоднозначности полей можно комбинировать с каламбуром (см. &lt;a href=&quot;#record-puns&quot;&gt;Запись слов&lt;/a&gt; ). Например:</target>
        </trans-unit>
        <trans-unit id="6f697941f4e61d5357bc8e695debb7df5928ebe4" translate="yes" xml:space="preserve">
          <source>Field disambiguation can be combined with punning (see &lt;a href=&quot;record_puns#record-puns&quot;&gt;Record puns&lt;/a&gt;). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ba709dee54d841422d5cda9c86dc36f0733a53e" translate="yes" xml:space="preserve">
          <source>Field names used as selector functions or in record updates must be unambiguous, either because there is only one such field in scope, or because a type signature is supplied, as described in the following sections.</source>
          <target state="translated">Имена полей,используемых в качестве селекторных функций или при обновлении записей,должны быть однозначными,либо потому,что в области видимости есть только одно такое поле,либо потому,что поставляется сигнатура типа,как описано в следующих разделах.</target>
        </trans-unit>
        <trans-unit id="9a36bac12f2598c38413b503ceea750d14ea1043" translate="yes" xml:space="preserve">
          <source>Field selectors can be used in conjunction with &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt;, as described in &lt;a href=&quot;type_applications#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;. The type of a field selector is constructed by using the surrounding definition as context. This section provides a specification for how this construction works. We will explain it by considering three different forms of field selector, each of which is a minor variation of the same general theme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd7785607bbf364d54013deccebdf1687696229" translate="yes" xml:space="preserve">
          <source>Field selectors for GADT constructors (&lt;a href=&quot;gadt_syntax#gadt-style&quot;&gt;Declaring data types with explicit constructor signatures&lt;/a&gt;) are slightly more involved. Consider the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="553b7393804c0c51c21d68612ff28deebee6c2a3" translate="yes" xml:space="preserve">
          <source>FieldExp</source>
          <target state="translated">FieldExp</target>
        </trans-unit>
        <trans-unit id="96c72c07ebaaebcb224edc3159fd04027f378cf3" translate="yes" xml:space="preserve">
          <source>FieldExpQ</source>
          <target state="translated">FieldExpQ</target>
        </trans-unit>
        <trans-unit id="52cf3a69b95afcaef5b9552017ab1d7a46942649" translate="yes" xml:space="preserve">
          <source>FieldFormat</source>
          <target state="translated">FieldFormat</target>
        </trans-unit>
        <trans-unit id="ab3ea29114e079d7ead09ebd02437860e63f295e" translate="yes" xml:space="preserve">
          <source>FieldFormatter</source>
          <target state="translated">FieldFormatter</target>
        </trans-unit>
        <trans-unit id="9056803e7437f22b8f8eb0183fd8d5b6660b20fa" translate="yes" xml:space="preserve">
          <source>FieldPat</source>
          <target state="translated">FieldPat</target>
        </trans-unit>
        <trans-unit id="99b0c84f03868d4e48b3119185190cb080d238ad" translate="yes" xml:space="preserve">
          <source>FieldPatQ</source>
          <target state="translated">FieldPatQ</target>
        </trans-unit>
        <trans-unit id="e8b685271238adf161cffed3c91f54d97023262b" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Fields</target>
        </trans-unit>
        <trans-unit id="6047eeaf6d96600fc3b89f57d9a82133eebd5fc4" translate="yes" xml:space="preserve">
          <source>Fields may be used as selector functions only if they are unambiguous, so this is still not allowed if both &lt;code&gt;S(x)&lt;/code&gt; and &lt;code&gt;T(x)&lt;/code&gt; are in scope:</source>
          <target state="translated">Поля могут использоваться в качестве селекторных функций, только если они недвусмысленны, поэтому это все еще недопустимо, если и &lt;code&gt;S(x)&lt;/code&gt; и &lt;code&gt;T(x)&lt;/code&gt; входят в область действия:</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="7ab560f3cbaa2fc5f6b6fc34d0cb745e71f21f9f" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;$HOME/.ghc/arch-os-version/environments/default&lt;/code&gt; if it exists.</source>
          <target state="translated">Файл &lt;code&gt;$HOME/.ghc/arch-os-version/environments/default&lt;/code&gt; если он существует.</target>
        </trans-unit>
        <trans-unit id="a167c672375de2f34928b4566c71bf22a7ede991" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; if the environment variable &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-8&quot;&gt;&lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt;&lt;/a&gt; is set to ⟨name⟩.</source>
          <target state="translated">Файл &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; если для переменной среды &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-8&quot;&gt; &lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt; &lt;/a&gt; установлено значение ⟨name⟩.</target>
        </trans-unit>
        <trans-unit id="3a01ef2357593bcb0e4fedb3c673c8bc39be504e" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; if you pass the option &lt;code&gt;-package-env ⟨name⟩&lt;/code&gt;.</source>
          <target state="translated">Файл &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; если вы передаете опцию &lt;code&gt;-package-env ⟨name⟩&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d06905a4f43f7d68d079a1292926a4fcdc15ef19" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;.ghc.environment.arch-os-version&lt;/code&gt; if it exists in the current directory or any parent directory (but not the user&amp;rsquo;s home directory).</source>
          <target state="translated">Файл &lt;code&gt;.ghc.environment.arch-os-version&lt;/code&gt; , если он существует в текущем каталоге или любом родительском каталоге (но не в домашнем каталоге пользователя).</target>
        </trans-unit>
        <trans-unit id="47f3e4a191350f85b1fb6c184e322e3d2487d97a" translate="yes" xml:space="preserve">
          <source>File allocation</source>
          <target state="translated">Распределение файлов</target>
        </trans-unit>
        <trans-unit id="d5a78f8cfc23c487b733c48af2524d1ee745f3b1" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">Имена файлов и каталогов являются значениями типа &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , точное значение которых зависит от операционной системы. Файлы можно открывать, получая дескриптор, который затем можно использовать для работы с содержимым этого файла.</target>
        </trans-unit>
        <trans-unit id="838ab5322e72167e410c8392a44814f02f10e077" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd52e06d55d1bf7bfbc10d5c00841d3fab42c29d" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="effea5a9629c10713fe758f268aee8fd6abebbd6" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">Имена файлов и каталогов являются значениями типа &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , точное значение которых зависит от операционной системы. Файлы можно открывать, получая дескриптор, который затем можно использовать для работы с содержимым этого файла.</target>
        </trans-unit>
        <trans-unit id="3d0b0e37f272404afcc389cc877def43f90e9575" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">Имена файлов и каталогов являются значениями типа &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , точное значение которых зависит от операционной системы. Файлы можно открывать, получая дескриптор, который затем можно использовать для работы с содержимым этого файла.</target>
        </trans-unit>
        <trans-unit id="f47bb7024cb7d59562a12c46b66ef954ecbf1490" translate="yes" xml:space="preserve">
          <source>File descriptor to close.</source>
          <target state="translated">Дескриптор файла закрыть.</target>
        </trans-unit>
        <trans-unit id="b66bde9fc5bb83fdf4ea939e331fb8664459ca24" translate="yes" xml:space="preserve">
          <source>File extension character</source>
          <target state="translated">Символ расширения файла</target>
        </trans-unit>
        <trans-unit id="1c0021e329eb90f6a7b2780c57945209da61a258" translate="yes" xml:space="preserve">
          <source>File locking</source>
          <target state="translated">Файловый замок</target>
        </trans-unit>
        <trans-unit id="0c722e113405e21abbf91991823e490fd909ebc5" translate="yes" xml:space="preserve">
          <source>File mode (such as permissions).</source>
          <target state="translated">Файловый режим (например,разрешения).</target>
        </trans-unit>
        <trans-unit id="44351e19bb95196b5909f0387569e8792f24a314" translate="yes" xml:space="preserve">
          <source>File modes</source>
          <target state="translated">Режимы файлов</target>
        </trans-unit>
        <trans-unit id="79327cb41236e902d5cca2599b9eff800842dc2d" translate="yes" xml:space="preserve">
          <source>File name manipulations</source>
          <target state="translated">Манипуляции с именами файлов</target>
        </trans-unit>
        <trans-unit id="e5ec2bfca476afbb5e2e6543807ac3bfb533a1ec" translate="yes" xml:space="preserve">
          <source>File name template. If the template is &quot;foo.ext&quot; then the created file will be &quot;fooXXX.ext&quot; where XXX is some random number. Note that this should not contain any path separator characters.</source>
          <target state="translated">Шаблон имени файла.Если шаблон &quot;foo.ext&quot;,то созданный файл будет &quot;fooXXX.ext&quot;,где XXX-некоторое случайное число.Обратите внимание,что он не должен содержать символов,разделяющих пути.</target>
        </trans-unit>
        <trans-unit id="8cdd2b3998531feb2e79d752bcd3196891becba3" translate="yes" xml:space="preserve">
          <source>File names with &amp;ldquo;meaningful&amp;rdquo; suffixes (e.g., &lt;code&gt;.lhs&lt;/code&gt; or &lt;code&gt;.o&lt;/code&gt;) cause the &amp;ldquo;right thing&amp;rdquo; to happen to those files.</source>
          <target state="translated">Имена файлов со &amp;laquo;значимыми&amp;raquo; суффиксами (например, &lt;code&gt;.lhs&lt;/code&gt; или &lt;code&gt;.o&lt;/code&gt; ) заставляют &amp;laquo;правильные вещи&amp;raquo; происходить с этими файлами.</target>
        </trans-unit>
        <trans-unit id="50384c5cc1d9206b4a0bea9f93b399ae83f9025e" translate="yes" xml:space="preserve">
          <source>File options</source>
          <target state="translated">Параметры файла</target>
        </trans-unit>
        <trans-unit id="23d0dc8812f4ca4c291d107ca6848e74d92c16dd" translate="yes" xml:space="preserve">
          <source>File status</source>
          <target state="translated">Статус файла</target>
        </trans-unit>
        <trans-unit id="af9774e2bc6c59627690a0dedee37b68e10ba597" translate="yes" xml:space="preserve">
          <source>File synchronisation</source>
          <target state="translated">Файл синхронизации</target>
        </trans-unit>
        <trans-unit id="0d3da9368089813c88f07b933bfd9982df74058a" translate="yes" xml:space="preserve">
          <source>File ⟨file⟩ if the environment variable &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-7&quot;&gt;&lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt;&lt;/a&gt; is set to ⟨file⟩.</source>
          <target state="translated">Файл &amp;laquo;файл&amp;raquo;, если для переменной среды &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-7&quot;&gt; &lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt; &lt;/a&gt; задано значение &amp;laquo;файл&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b068141256755be393e8c5f4ab9d5a23cddf020c" translate="yes" xml:space="preserve">
          <source>File ⟨file⟩ if you pass the option &lt;a href=&quot;#ghc-flag--package-env%20%E2%9F%A8file%E2%9F%A9%7C%E2%9F%A8name%E2%9F%A9&quot;&gt;&lt;code&gt;-package-env ⟨file⟩|⟨name⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Файл &amp;laquo;файл&amp;raquo;, если вы передаете параметр &lt;a href=&quot;#ghc-flag--package-env%20%E2%9F%A8file%E2%9F%A9%7C%E2%9F%A8name%E2%9F%A9&quot;&gt; &lt;code&gt;-package-env ⟨file⟩|⟨name⟩&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e845ec2f1dbe4ebb6bd5b44fdbd30e02fb4fa0b5" translate="yes" xml:space="preserve">
          <source>File-header pragmas are read once only, before pre-processing the file (e.g. with cpp).</source>
          <target state="translated">Файловые прагмы читаются только один раз,перед предварительной обработкой файла (например,с помощью cpp).</target>
        </trans-unit>
        <trans-unit id="67f0fd4191e0b800a67e17dea08cd79d328c985d" translate="yes" xml:space="preserve">
          <source>FileAttributeOrFlag</source>
          <target state="translated">FileAttributeOrFlag</target>
        </trans-unit>
        <trans-unit id="419fb1d579fa24f7d06409a1560297bf55604fcb" translate="yes" xml:space="preserve">
          <source>FileID</source>
          <target state="translated">FileID</target>
        </trans-unit>
        <trans-unit id="5f8df2e8132fa7064ada28629c5b3817e3b4756e" translate="yes" xml:space="preserve">
          <source>FileLock</source>
          <target state="translated">FileLock</target>
        </trans-unit>
        <trans-unit id="80805853ea06d36fa4fd830be6185f04c78d62c7" translate="yes" xml:space="preserve">
          <source>FileLockingNotSupported</source>
          <target state="translated">FileLockingNotSupported</target>
        </trans-unit>
        <trans-unit id="a85de67499f0473cd81c3a219d6d486f9eeb80fa" translate="yes" xml:space="preserve">
          <source>FileMapAccess</source>
          <target state="translated">FileMapAccess</target>
        </trans-unit>
        <trans-unit id="0b25eeca51a2e908f97898c9ef3aefb4ac120d01" translate="yes" xml:space="preserve">
          <source>FileMode</source>
          <target state="translated">FileMode</target>
        </trans-unit>
        <trans-unit id="96e38f15ed4165180f2f72b882ad922453b8f857" translate="yes" xml:space="preserve">
          <source>FileNameLimit</source>
          <target state="translated">FileNameLimit</target>
        </trans-unit>
        <trans-unit id="cf5d49897833b10ad5a74c57196b79bf6729d833" translate="yes" xml:space="preserve">
          <source>FileNamesAreNotTruncated</source>
          <target state="translated">FileNamesAreNotTruncated</target>
        </trans-unit>
        <trans-unit id="d680e5e98dcdbf2c7c4f9799336719546329a1dd" translate="yes" xml:space="preserve">
          <source>FileNotificationFlag</source>
          <target state="translated">FileNotificationFlag</target>
        </trans-unit>
        <trans-unit id="2ee875689c41837c399f4d2c32f5259de761b9de" translate="yes" xml:space="preserve">
          <source>FileOffset</source>
          <target state="translated">FileOffset</target>
        </trans-unit>
        <trans-unit id="6c82ffd5741d0c27e25cc781899c3fe7b6f8fa63" translate="yes" xml:space="preserve">
          <source>FilePath</source>
          <target state="translated">FilePath</target>
        </trans-unit>
        <trans-unit id="c3604acc9cca295c426ebae9f7a5c570e9e3927d" translate="yes" xml:space="preserve">
          <source>FilePtrDirection</source>
          <target state="translated">FilePtrDirection</target>
        </trans-unit>
        <trans-unit id="3b19d1904d22317055740540571508037b9e04a5" translate="yes" xml:space="preserve">
          <source>FileSizeBits</source>
          <target state="translated">FileSizeBits</target>
        </trans-unit>
        <trans-unit id="15bb173707cc00113315f136acf915560a27f60c" translate="yes" xml:space="preserve">
          <source>FileStatus</source>
          <target state="translated">FileStatus</target>
        </trans-unit>
        <trans-unit id="6774947837a99235d0bd2076b121b3dd3a43aa95" translate="yes" xml:space="preserve">
          <source>FileTag</source>
          <target state="translated">FileTag</target>
        </trans-unit>
        <trans-unit id="1baa34e6560f1522cca6ce9d9df461092e8ec59b" translate="yes" xml:space="preserve">
          <source>FileType</source>
          <target state="translated">FileType</target>
        </trans-unit>
        <trans-unit id="4324ba3b44136bad26f9c65258416f168b463786" translate="yes" xml:space="preserve">
          <source>Filename completion</source>
          <target state="translated">Завершение работы над именем Фильма</target>
        </trans-unit>
        <trans-unit id="2ebfcb3969f0ba497b6130046dbc6f62106ac185" translate="yes" xml:space="preserve">
          <source>Filename extension for executable files (including the dot if any) (usually &lt;code&gt;&quot;&quot;&lt;/code&gt; on POSIX systems and &lt;code&gt;&quot;.exe&quot;&lt;/code&gt; on Windows or OS/2).</source>
          <target state="translated">Расширение имени файла для исполняемых файлов (включая точку, если есть) (обычно &lt;code&gt;&quot;&quot;&lt;/code&gt; в системах POSIX и &lt;code&gt;&quot;.exe&quot;&lt;/code&gt; в Windows или OS / 2).</target>
        </trans-unit>
        <trans-unit id="430a7fb7f4eedabcec0ba92367e6b4e3cc37cb65" translate="yes" xml:space="preserve">
          <source>Filename of the executable (see &lt;code&gt;&lt;a href=&quot;system-process#v:RawCommand&quot;&gt;RawCommand&lt;/a&gt;&lt;/code&gt; for details)</source>
          <target state="translated">Имя исполняемого файла ( подробности см. В &lt;code&gt;&lt;a href=&quot;system-process#v:RawCommand&quot;&gt;RawCommand&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c1e5594cbcf5d29cd4606ef3b29742013aa676d3" translate="yes" xml:space="preserve">
          <source>Filename/directory functions</source>
          <target state="translated">Фамилия/функции каталога</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="1d68fcbcaa9e6c0596bd77cd85d8ef1430e2e255" translate="yes" xml:space="preserve">
          <source>Files and handles</source>
          <target state="translated">Файлы и ручки</target>
        </trans-unit>
        <trans-unit id="8c12ce59fd07366870c4918986c036d5b1718b2d" translate="yes" xml:space="preserve">
          <source>Files with other suffixes (or without suffixes) are passed straight to the linker.</source>
          <target state="translated">Файлы с другими суффиксами (или без суффиксов)передаются прямо в компоновщик.</target>
        </trans-unit>
        <trans-unit id="0bcfe196150a905d9689e141f80a3a2ecefe16ce" translate="yes" xml:space="preserve">
          <source>Fill a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Заполните &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; , используя &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74e773234ce1275af1c68adf87a3b4bc236bada9" translate="yes" xml:space="preserve">
          <source>Fill a given number of bytes in memory area with a byte value.</source>
          <target state="translated">Заполните заданное количество байт в области памяти значением байта.</target>
        </trans-unit>
        <trans-unit id="cd4d3d8bc69124ec20ace02425021dd9178e5281" translate="yes" xml:space="preserve">
          <source>Filling up memory area with required values</source>
          <target state="translated">Заполнение области памяти требуемыми значениями</target>
        </trans-unit>
        <trans-unit id="d7decf1aa22b02ae8abf9a96849ee423eee838e4" translate="yes" xml:space="preserve">
          <source>Filter</source>
          <target state="translated">Filter</target>
        </trans-unit>
        <trans-unit id="8022a4851f7324da6865a694a01b0bcaab7a2f99" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">Отфильтруйте записи, ключи которых отсутствуют на другой карте, используя какое-либо действие &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee2b47e5e988f9baa37856993c9dc8cd3c328a52" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="296c67f523b9ac6e28bfc4ebfa4d796103625519" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787c541edc37e7915b5310e8847885791e0e7bf2" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map.</source>
          <target state="translated">Фильтровать записи,ключи которых отсутствуют на другой карте.</target>
        </trans-unit>
        <trans-unit id="86fec396e3e13493b2a91cd89771fd664be0f9b3" translate="yes" xml:space="preserve">
          <source>FinalPtr</source>
          <target state="translated">FinalPtr</target>
        </trans-unit>
        <trans-unit id="65039e687d346fc2cb3b9e4ba3fdebf8936d6f9e" translate="yes" xml:space="preserve">
          <source>FinalQuote</source>
          <target state="translated">FinalQuote</target>
        </trans-unit>
        <trans-unit id="e068667dac3c14788401a6fb7eba398f0213b990" translate="yes" xml:space="preserve">
          <source>Finalised data pointers</source>
          <target state="translated">Окончательные указатели данных</target>
        </trans-unit>
        <trans-unit id="4654b2a5f2578ac85eb620c7f87d7844f6e0bb05" translate="yes" xml:space="preserve">
          <source>Finalization</source>
          <target state="translated">Finalization</target>
        </trans-unit>
        <trans-unit id="4bf1c69e4a67738c229264f62b72b00175b94776" translate="yes" xml:space="preserve">
          <source>Finalization means (a) arrange that subsequent calls to &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;; and (b) run the finalizer.</source>
          <target state="translated">Завершение означает (а) обеспечить, чтобы последующие вызовы &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; не возвращали &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ; и (б) запустить финализатор.</target>
        </trans-unit>
        <trans-unit id="4f4bcb977484412c1a687b2717df3db42e0223d6" translate="yes" xml:space="preserve">
          <source>Finalize a weak pointer. The return value is an unboxed tuple containing the new state of the world and an &quot;unboxed Maybe&quot;, represented by an &lt;code&gt;Int#&lt;/code&gt; and a (possibly invalid) finalization action. An &lt;code&gt;Int#&lt;/code&gt; of &lt;code&gt;1&lt;/code&gt; indicates that the finalizer is valid. The return value &lt;code&gt;b&lt;/code&gt; from the finalizer should be ignored.</source>
          <target state="translated">Доработайте слабый указатель. Возвращаемое значение - распакованный кортеж, содержащий новое состояние мира и &amp;laquo;распакованный объект Maybe&amp;raquo;, представленный &lt;code&gt;Int#&lt;/code&gt; и (возможно, недопустимым) действием завершения. &lt;code&gt;Int#&lt;/code&gt; из &lt;code&gt;1&lt;/code&gt; указывает на то, что финализации является действительным. Возвращаемое значение &lt;code&gt;b&lt;/code&gt; от финализатора следует игнорировать.</target>
        </trans-unit>
        <trans-unit id="f43bcd35f75b6b03cc41d4b7b36c9671eee326a4" translate="yes" xml:space="preserve">
          <source>FinalizerEnvPtr</source>
          <target state="translated">FinalizerEnvPtr</target>
        </trans-unit>
        <trans-unit id="b1542ae832d41717b2363b38f917247984d58f95" translate="yes" xml:space="preserve">
          <source>FinalizerPtr</source>
          <target state="translated">FinalizerPtr</target>
        </trans-unit>
        <trans-unit id="86d2d2c2528b5945d0ddc3f7f67ee4046606e5af" translate="yes" xml:space="preserve">
          <source>Finalizers &lt;em&gt;can&lt;/em&gt; be used reliably for types that are created explicitly and have identity, such as &lt;code&gt;IORef&lt;/code&gt; and &lt;code&gt;MVar&lt;/code&gt;. However, to place a finalizer on one of these types, you should use the specific operation provided for that type, e.g. &lt;code&gt;mkWeakIORef&lt;/code&gt; and &lt;code&gt;addMVarFinalizer&lt;/code&gt; respectively (the non-uniformity is accidental). These operations attach the finalizer to the primitive object inside the box (e.g. &lt;code&gt;MutVar#&lt;/code&gt; in the case of &lt;code&gt;IORef&lt;/code&gt;), because attaching the finalizer to the box itself fails when the outer box is optimised away by the compiler.</source>
          <target state="translated">Финализаторы &lt;em&gt;можно&lt;/em&gt; надежно использовать для типов, которые создаются явно и имеют идентичность, например &lt;code&gt;IORef&lt;/code&gt; и &lt;code&gt;MVar&lt;/code&gt; . Однако, чтобы поместить финализатор в один из этих типов, вы должны использовать определенную операцию, предусмотренную для этого типа, например, &lt;code&gt;mkWeakIORef&lt;/code&gt; и &lt;code&gt;addMVarFinalizer&lt;/code&gt; соответственно (неоднородность случайна). Эти операции присоединяют финализатор к примитивному объекту внутри блока (например, &lt;code&gt;MutVar#&lt;/code&gt; в случае &lt;code&gt;IORef&lt;/code&gt; ), потому что присоединение финализатора к самому блоку не удается, когда внешний блок оптимизируется компилятором.</target>
        </trans-unit>
        <trans-unit id="521c7faf6958e48a574367992f9c07725b55b76b" translate="yes" xml:space="preserve">
          <source>Finalizers are all C functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce238574b6a6dbcd2a65c4596886dabb147b08b1" translate="yes" xml:space="preserve">
          <source>Finalizers are all Haskell functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d549824ec075b07eaad0c57b8862f0cccdfc5850" translate="yes" xml:space="preserve">
          <source>Finally, GHC calls &lt;code&gt;tcPluginStop&lt;/code&gt; after constraint solving is finished, allowing the plugin to dispose of any resources it has allocated (e.g. terminating the SMT solver process).</source>
          <target state="translated">Наконец, GHC вызывает &lt;code&gt;tcPluginStop&lt;/code&gt; после завершения решения ограничений, позволяя плагину распоряжаться любыми выделенными им ресурсами (например, завершая процесс решателя SMT).</target>
        </trans-unit>
        <trans-unit id="cc10bc2ea70467315012d5ca45b95d793b626303" translate="yes" xml:space="preserve">
          <source>Finally, after the &lt;code&gt;interruptible&lt;/code&gt; foreign call returns into Haskell, the Haskell code should allow exceptions to be raised (&lt;code&gt;Control.Exception&lt;/code&gt;&amp;lsquo;s &lt;code&gt;allowInterrupt&lt;/code&gt;, or &lt;code&gt;interruptible yield&lt;/code&gt; for non-&lt;code&gt;-threaded&lt;/code&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/8684&quot;&gt;https://gitlab.haskell.org/ghc/ghc/issues/8684&lt;/a&gt;), and implement the &lt;code&gt;EINTR&lt;/code&gt;-retrying in Haskell (e.g. using e.g. &lt;a href=&quot;../../libraries/base-4.15.0.0/foreign-c-error#v:throwErrnoIfMinus1Retry&quot;&gt;Foreign.C.Error.throwErrnoIfMinus1Retry&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd050ec35a76e1f6b5c1338ce2268aeea42675b" translate="yes" xml:space="preserve">
          <source>Finally, here's an exception safe variant of the &lt;code&gt;readFile'&lt;/code&gt; example:</source>
          <target state="translated">Наконец, вот безопасный вариант &lt;code&gt;readFile'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="17da083d84fc49d2631cf9ff7d2f3b4b5c95891b" translate="yes" xml:space="preserve">
          <source>Finally, other functions can be called, either with the &lt;code&gt;-main-is&lt;/code&gt; flag or the &lt;a href=&quot;#ghci-cmd-:run&quot;&gt;&lt;code&gt;:run&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">Наконец, можно вызвать другие функции либо с флагом &lt;code&gt;-main-is&lt;/code&gt; , либо с помощью команды &lt;a href=&quot;#ghci-cmd-:run&quot;&gt; &lt;code&gt;:run&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="17193f32610866d1f4357bb64bd6417d7a0e85e0" translate="yes" xml:space="preserve">
          <source>Finally, since those &lt;code&gt;DynFlags&lt;/code&gt; updates happen after the plugins are loaded, you cannot from a &lt;code&gt;DynFlags&lt;/code&gt; plugin register other plugins by just adding them to the &lt;code&gt;plugins&lt;/code&gt; field of &lt;code&gt;DynFlags&lt;/code&gt;. In order to achieve this, you would have to load them yourself and store the result into the &lt;code&gt;cachedPlugins&lt;/code&gt; field of &lt;code&gt;DynFlags&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c467715713120e1ab32f93515b00b2a5a923fdd5" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;Just&lt;/code&gt; results are collected into a map:</source>
          <target state="translated">Наконец, результаты &lt;code&gt;Just&lt;/code&gt; собираются в карту:</target>
        </trans-unit>
        <trans-unit id="3ed43b18c0eb498b61dd7767854552765f4cd553" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;m&lt;/code&gt; implementation of &lt;code&gt;generalBracket&lt;/code&gt; returns the pairs &lt;code&gt;(b, s)&lt;/code&gt; and &lt;code&gt;(c, s)&lt;/code&gt;. For monad transformers other than &lt;code&gt;StateT&lt;/code&gt;, this will be some other type representing the effects and values performed and returned by the &lt;code&gt;use&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; actions. The effect part of the &lt;code&gt;use&lt;/code&gt; result, in this case &lt;code&gt;_s2&lt;/code&gt;, usually needs to be discarded, since those effects have already been incorporated in the &lt;code&gt;release&lt;/code&gt; action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c8dcc229ec5ccc377436c171a4012c21910c22" translate="yes" xml:space="preserve">
          <source>Finally, the option &lt;code&gt;-hcsuf&lt;/code&gt; ⟨suffix⟩ will change the &lt;code&gt;.hc&lt;/code&gt; file suffix for compiler-generated intermediate C files.</source>
          <target state="translated">Наконец, опция &lt;code&gt;-hcsuf&lt;/code&gt; ⟨suffix⟩ изменит &lt;code&gt;.hc&lt;/code&gt; файла .hc для промежуточных C-файлов, созданных компилятором.</target>
        </trans-unit>
        <trans-unit id="5463d0aeddf364c8fd3a47a2799ef56cd3b82670" translate="yes" xml:space="preserve">
          <source>Finally, there's one more special case, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldlM&quot;&gt;foldlM&lt;/a&gt;&lt;/code&gt;, which can short-circuit when the monad &lt;code&gt;m&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;, and the operator invokes &lt;code&gt;&lt;a href=&quot;control-monad#v:mzero&quot;&gt;mzero&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc21bc943ef04af59cbece2a0d2f3e7aa3c249b5" translate="yes" xml:space="preserve">
          <source>Finally, we can continue the current execution:</source>
          <target state="translated">Наконец,мы можем продолжить текущее исполнение:</target>
        </trans-unit>
        <trans-unit id="824e9c7851504a7db73de275ca7092aca8efe89b" translate="yes" xml:space="preserve">
          <source>Finally, we need a primitive parser that matches a single character, from which arbitrarily complex parsers may be constructed:</source>
          <target state="translated">Наконец,нам нужен примитивный парсер,соответствующий одному символу,из которого можно построить произвольно сложные парсеры:</target>
        </trans-unit>
        <trans-unit id="15a842f146978f80ebeda74728fb6bdd46209f69" translate="yes" xml:space="preserve">
          <source>Finally, we run the decoder:</source>
          <target state="translated">Наконец-то мы запустили декодер:</target>
        </trans-unit>
        <trans-unit id="58b7317f6459da4bc2d4c53f36913a47893253c7" translate="yes" xml:space="preserve">
          <source>Find all instances \(I\) that &lt;em&gt;match&lt;/em&gt; the target constraint; that is, the target constraint is a substitution instance of \(I\). These instance declarations are the &lt;em&gt;candidates&lt;/em&gt;.</source>
          <target state="translated">Найдите все экземпляры \ (I \), которые &lt;em&gt;соответствуют&lt;/em&gt; целевому ограничению; то есть целевое ограничение является экземпляром подстановки \ (I \). Эти объявления экземпляров являются &lt;em&gt;кандидатами&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a7248c9b5f73c1345281963f4418269f1f39c210" translate="yes" xml:space="preserve">
          <source>Find all the unsolved constraints. Then:</source>
          <target state="translated">Найдите все неразрешенные ограничения.Тогда..:</target>
        </trans-unit>
        <trans-unit id="2ba0bc35b28ca786d80a16baa1ce7be74e4b397c" translate="yes" xml:space="preserve">
          <source>Find depth of the tree; i.e. the number of branches from the root of the tree to the furthest leaf:</source>
          <target state="translated">Найдите глубину дерева,т.е.количество ветвей от корня до самого дальнего листа:</target>
        </trans-unit>
        <trans-unit id="f29c9313754b1cc2ec832d12ee7fe9edac95906b" translate="yes" xml:space="preserve">
          <source>Find system-specific limits for a file</source>
          <target state="translated">Поиск системных ограничений для файла</target>
        </trans-unit>
        <trans-unit id="386219c63f990092e910133ace2da72816782f7e" translate="yes" xml:space="preserve">
          <source>Find the indexes of all (possibly overlapping) occurences of a substring in a string.</source>
          <target state="translated">Найдите индексы всех (возможно,перекрывающихся)подстрок в строке.</target>
        </trans-unit>
        <trans-unit id="113e5a7f7ef4741af748a8e459880c7c315f837d" translate="yes" xml:space="preserve">
          <source>Find the indices of all non-overlapping occurences of a substring in a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e1b44278f49d501705a64e05bbba0c134de2fb" translate="yes" xml:space="preserve">
          <source>Find the maximum value in the tree:</source>
          <target state="translated">Найдите максимальное значение в дереве:</target>
        </trans-unit>
        <trans-unit id="d1f6a92389a4b52704904fd8094536f941eee60f" translate="yes" xml:space="preserve">
          <source>Find those that are of form &lt;code&gt;(C a)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is a type variable, and partition those constraints into groups that share a common type variable &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Найдите те, которые имеют форму &lt;code&gt;(C a)&lt;/code&gt; , где &lt;code&gt;a&lt;/code&gt; - переменная типа, и разделите эти ограничения на группы, которые имеют общую переменную типа &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f82c18b0ef12da1e73963f388a45c81ada40f595" translate="yes" xml:space="preserve">
          <source>FindData</source>
          <target state="translated">FindData</target>
        </trans-unit>
        <trans-unit id="9cebb52c73ccfc1577160b27a264b7adee7d64e0" translate="yes" xml:space="preserve">
          <source>Finding the length</source>
          <target state="translated">Поиск длины</target>
        </trans-unit>
        <trans-unit id="fed4c9053d8c85c9d95957c6e01431c7805f793d" translate="yes" xml:space="preserve">
          <source>Fingerprint</source>
          <target state="translated">Fingerprint</target>
        </trans-unit>
        <trans-unit id="3e9225380b48c0d61062495100edfad871bc3253" translate="yes" xml:space="preserve">
          <source>Finish and clean up the line-oriented user interaction session. Blocks on an existing call to &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Завершите и очистите сеанс линейно-ориентированного взаимодействия с пользователем. Блокирует существующий вызов &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fec3922ffd4b25efcef1a899d1768f35b7868ec0" translate="yes" xml:space="preserve">
          <source>Finite Graphs</source>
          <target state="translated">Конечные графики</target>
        </trans-unit>
        <trans-unit id="522d06d1d6ea9ca0805eab7331127be7478e7382" translate="yes" xml:space="preserve">
          <source>Finite Int Maps (lazy interface)</source>
          <target state="translated">Конечные карты (ленивый интерфейс)</target>
        </trans-unit>
        <trans-unit id="747317a4e3d40d7a20e3837df1cd88296c1c8b01" translate="yes" xml:space="preserve">
          <source>Finite Int Maps (strict interface)</source>
          <target state="translated">Конечные карты (строгий интерфейс)</target>
        </trans-unit>
        <trans-unit id="4d744986315c5e9c1268a1c78b68b2bbeb84e7e9" translate="yes" xml:space="preserve">
          <source>Finite Int Sets</source>
          <target state="translated">Конечные наборы</target>
        </trans-unit>
        <trans-unit id="29c95a33910ced5bead65681b4bd0706727df804" translate="yes" xml:space="preserve">
          <source>Finite Maps (lazy interface)</source>
          <target state="translated">Конечные карты (ленивый интерфейс)</target>
        </trans-unit>
        <trans-unit id="f94c42dd95ea5ef128c8b03aa31efa72d11ac882" translate="yes" xml:space="preserve">
          <source>Finite Maps (strict interface)</source>
          <target state="translated">Конечные карты (строгий интерфейс)</target>
        </trans-unit>
        <trans-unit id="215000a5770bdb612d30ff0a9cffc3c9f4c807d0" translate="yes" xml:space="preserve">
          <source>Finite Sets</source>
          <target state="translated">Конечные наборы</target>
        </trans-unit>
        <trans-unit id="5e413d7374fdcec7f72bf32287ef8fde5eb28ea8" translate="yes" xml:space="preserve">
          <source>Finite sequences</source>
          <target state="translated">Конечные последовательности</target>
        </trans-unit>
        <trans-unit id="90b6286ad1ab4887e55ec1d1c65eee759a111435" translate="yes" xml:space="preserve">
          <source>FiniteBits</source>
          <target state="translated">FiniteBits</target>
        </trans-unit>
        <trans-unit id="916a78d701ded328cd66da58a97ef8cd28a99e84" translate="yes" xml:space="preserve">
          <source>First</source>
          <target state="translated">First</target>
        </trans-unit>
        <trans-unit id="6f8344a8752e429a8925c432e27736350eeb7113" translate="yes" xml:space="preserve">
          <source>First arg is whether to chop off trailing zeros</source>
          <target state="translated">Первый аргумент-отрубить ли замыкающие нули?</target>
        </trans-unit>
        <trans-unit id="b8249d53487d925c0152bda624de2b210dac99de" translate="yes" xml:space="preserve">
          <source>First component of result is &lt;code&gt;log2 n&lt;/code&gt;, second is &lt;code&gt;0#&lt;/code&gt; iff &lt;em&gt;n&lt;/em&gt; is a power of two.</source>
          <target state="translated">Первый компонент результата - &lt;code&gt;log2 n&lt;/code&gt; , второй - &lt;code&gt;0#&lt;/code&gt; если &lt;em&gt;n&lt;/em&gt; - степень двойки.</target>
        </trans-unit>
        <trans-unit id="a9cad0415018d8c69517c0334ce25bcce363662a" translate="yes" xml:space="preserve">
          <source>First offset in destination &lt;em&gt;not&lt;/em&gt; to copy (i.e. &lt;em&gt;not&lt;/em&gt; length)</source>
          <target state="translated">Первое смещение в месте назначения, которое &lt;em&gt;не&lt;/em&gt; копируется (т.е. &lt;em&gt;не&lt;/em&gt; длина)</target>
        </trans-unit>
        <trans-unit id="39654ea89be5465e22c967a1c060f3374651a48d" translate="yes" xml:space="preserve">
          <source>First see if there is a given un-quantified constraint &lt;code&gt;C t&lt;/code&gt;. If so, use it to solve the constraint.</source>
          <target state="translated">Сначала посмотрите, существует ли заданное ограничение &lt;code&gt;C t&lt;/code&gt; ,не имеющее количественной оценки . Если да, используйте его для решения ограничения.</target>
        </trans-unit>
        <trans-unit id="8529e6d22ea6c668f307a8a09698c6b3be2a8a1c" translate="yes" xml:space="preserve">
          <source>First, &lt;code&gt;M&lt;/code&gt; imports &lt;code&gt;System.IO.Unsafe&lt;/code&gt;. This is an unsafe module, however &lt;code&gt;M&lt;/code&gt; was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; , so &lt;code&gt;P&lt;/code&gt;&amp;lsquo;s author takes responsibility for that import. &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;P&lt;/code&gt;&amp;lsquo;s author, so this import is fine.</source>
          <target state="translated">Во-первых, &lt;code&gt;M&lt;/code&gt; импортирует &lt;code&gt;System.IO.Unsafe&lt;/code&gt; . Это небезопасный модуль, однако &lt;code&gt;M&lt;/code&gt; был скомпилирован с помощью &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; , поэтому автор &lt;code&gt;P&lt;/code&gt; берет на себя ответственность за этот импорт. &lt;code&gt;C&lt;/code&gt; доверяет автору &lt;code&gt;P&lt;/code&gt; , так что этот импорт подходит.</target>
        </trans-unit>
        <trans-unit id="3ce8d182339545e607fa71963b2eed8264ebafc8" translate="yes" xml:space="preserve">
          <source>First, &lt;code&gt;M&lt;/code&gt; imports &lt;code&gt;System.IO.Unsafe&lt;/code&gt;. This is an unsafe module, however &lt;code&gt;M&lt;/code&gt; was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; , so &lt;code&gt;P&lt;/code&gt;&amp;rsquo;s author takes responsibility for that import. &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;P&lt;/code&gt;&amp;rsquo;s author, so this import is fine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b49ba602a9142b1d175089fed4f6f1f4747d3e6" translate="yes" xml:space="preserve">
          <source>First, load the module into GHCi:</source>
          <target state="translated">Сначала загрузите модуль в GHCi:</target>
        </trans-unit>
        <trans-unit id="a26ce7d1c9ec3e2375b176ca79a824e47e99e926" translate="yes" xml:space="preserve">
          <source>First, look up an exact match on the name from the defined macros.</source>
          <target state="translated">Сначала найдите точное совпадение по имени из определенных макросов.</target>
        </trans-unit>
        <trans-unit id="72664d951135405f560298e2723cacf7238281f9" translate="yes" xml:space="preserve">
          <source>Firstly, they enable terminating resolution where this was not possible before. Consider for instance the following instance declaration for the general rose datatype</source>
          <target state="translated">Во-первых,они позволяют прекратить разрешение там,где раньше это было невозможно.Рассмотрим,например,следующее объявление для общего типа данных розы</target>
        </trans-unit>
        <trans-unit id="b6ac73901d489c6617642d5ff6f615191248b174" translate="yes" xml:space="preserve">
          <source>FixIOException</source>
          <target state="translated">FixIOException</target>
        </trans-unit>
        <trans-unit id="ab98f5b85764b8561cacbb055a963cd334928cba" translate="yes" xml:space="preserve">
          <source>Fixed</source>
          <target state="translated">Fixed</target>
        </trans-unit>
        <trans-unit id="a9ea98de04db18cc178f8c2aef76ded13d01953b" translate="yes" xml:space="preserve">
          <source>Fixed-size builder primitives</source>
          <target state="translated">Примитивисты-строители фиксированного размера</target>
        </trans-unit>
        <trans-unit id="183fb4772d6165cb8789b4e327df15e3ac4d66f2" translate="yes" xml:space="preserve">
          <source>Fixed-size primitives</source>
          <target state="translated">Примитивы фиксированного размера</target>
        </trans-unit>
        <trans-unit id="7fb4ae59c760325c298601ab13e509f25fc37166" translate="yes" xml:space="preserve">
          <source>Fixed-width hexadecimal numbers</source>
          <target state="translated">Фиксированная ширина шестнадцатеричных чисел</target>
        </trans-unit>
        <trans-unit id="9b5b062b987d276248796f56a62721479458d294" translate="yes" xml:space="preserve">
          <source>FixedPrim</source>
          <target state="translated">FixedPrim</target>
        </trans-unit>
        <trans-unit id="094a567c1926190b7bfd7c0b37606606648002d4" translate="yes" xml:space="preserve">
          <source>Fixities may be declared for type constructors, or classes, just as for data constructors. However, one cannot distinguish between the two in a fixity declaration; a fixity declaration sets the fixity for a data constructor and the corresponding type constructor. For example:</source>
          <target state="translated">Фиксации могут быть объявлены для конструкторов типов или классов,так же как и для конструкторов данных.Однако,в декларации фиксации невозможно отличить их;декларация фиксации устанавливает фиксацию для конструктора данных и соответствующего конструктора типов.Например:</target>
        </trans-unit>
        <trans-unit id="2b82bbf7b0c566bd4539bf8810f46c5179f626f4" translate="yes" xml:space="preserve">
          <source>Fixity</source>
          <target state="translated">Fixity</target>
        </trans-unit>
        <trans-unit id="57d494452eec64b65e5dc39ee592c4fe9616d8e2" translate="yes" xml:space="preserve">
          <source>Fixity declarations are exactly as in Haskell.</source>
          <target state="translated">Заявления о фиксации точно такие же,как и в Хаскелле.</target>
        </trans-unit>
        <trans-unit id="eb3a8c37524386d27f7d07ee18bd0c65f631fe49" translate="yes" xml:space="preserve">
          <source>Fixity lookup</source>
          <target state="translated">Поиск исправлений</target>
        </trans-unit>
        <trans-unit id="ff8a94000f86e8a577cd0b25a42fc9985d6fd243" translate="yes" xml:space="preserve">
          <source>Fixity of constructors</source>
          <target state="translated">Фиксированность конструкторов</target>
        </trans-unit>
        <trans-unit id="3b3ce8c52db6806c8b912790bee2abcfa0095fad" translate="yes" xml:space="preserve">
          <source>Fixity, type synonym, open type/data family declarations are permitted as in normal Haskell.</source>
          <target state="translated">Допускаются исправления,синонимы типов,открытые декларации типов/семейства данных,как и в обычном Haskell.</target>
        </trans-unit>
        <trans-unit id="88b3259b4db22b3078551b6bfb8b24795404727c" translate="yes" xml:space="preserve">
          <source>FixityDirection</source>
          <target state="translated">FixityDirection</target>
        </trans-unit>
        <trans-unit id="ce8b7e3c9475365f4009091caff86162598e45a6" translate="yes" xml:space="preserve">
          <source>FixityI</source>
          <target state="translated">FixityI</target>
        </trans-unit>
        <trans-unit id="a774409a00c21de377cf8ed5c6a56b8547973042" translate="yes" xml:space="preserve">
          <source>Flag</source>
          <target state="translated">Flag</target>
        </trans-unit>
        <trans-unit id="97377a994fd4b8ac108223fa55cd48065f0287d8" translate="yes" xml:space="preserve">
          <source>Flag saying &amp;ldquo;stop after&amp;rdquo;</source>
          <target state="translated">Отметьте &quot;остановись после&quot;</target>
        </trans-unit>
        <trans-unit id="c79a88ff731c8edaa92ba0e1a888148cff60ea92" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlopen&quot;&gt;dlopen&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Флаги для &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlopen&quot;&gt;dlopen&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aea2c8ec1977d6e31bcb021cb1dabebaa2c6f4b8" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Флаги для &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; может быть недоступен на вашей конкретной платформе! Используйте &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68646c4bfdfb2b77627104cc76a37fdf802fe2ab" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Флаги для &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; может быть недоступен на вашей конкретной платформе! Используйте &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43b5985213e56988275f428db4afd1aca092b76c" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Флаги для &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; может быть недоступен на вашей конкретной платформе! Используйте &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6604408a39b5823a2d8caf9d995d09a15ce36fdd" translate="yes" xml:space="preserve">
          <source>Flags to control debugging output &amp;amp; extra checking in various subsystems.</source>
          <target state="translated">Флаги для управления выводом отладки и дополнительной проверкой в ​​различных подсистемах.</target>
        </trans-unit>
        <trans-unit id="953fe397d4a88b2eb7a202d8c11d1d4f2b2605c7" translate="yes" xml:space="preserve">
          <source>Flatten strict constructor fields</source>
          <target state="translated">Плоские строгие строительные поля</target>
        </trans-unit>
        <trans-unit id="32ce3a4131c78ef5b3006aaff0098352e801ebfd" translate="yes" xml:space="preserve">
          <source>Flatten strict constructor fields with a pointer-sized representation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Сглаживайте строгие поля конструктора с помощью представления размером с указатель. Подразумевается &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50dc207a02ef3d6c64feba0eb22a156d325327b3" translate="yes" xml:space="preserve">
          <source>FlexibleContexts</source>
          <target state="translated">FlexibleContexts</target>
        </trans-unit>
        <trans-unit id="dcec06754c91ecfff545b2f2cce80146b795726a" translate="yes" xml:space="preserve">
          <source>FlexibleInstances</source>
          <target state="translated">FlexibleInstances</target>
        </trans-unit>
        <trans-unit id="e4ccb090ca696917e5de23363132c4238087f15c" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aa9a79151c09f2b1c44f8f5b45f86e26536f4e8" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12167983d0afff206c046e1d6d922143291d5f3e" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd78f746eff5d069a4c69da8e38598e4dcbf4a4c" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a015af1d71e496c444ce3c462d153241cce86f16" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dafc2e8e7144d1472eedd451318a1d1537aeb13" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:handleJust&quot;&gt;handleJust&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f081d19b6a1634db731d6fc797a0dd377b306de" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:handleJust&quot;&gt;handleJust&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f4b18a46cb894bc45a39a5999838fa58714fd24" translate="yes" xml:space="preserve">
          <source>Flipped version of &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Перевернутая версия &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb11700d163e40830d0bae242266c3294e9edd3a" translate="yes" xml:space="preserve">
          <source>Flipped version of &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Перевернутая версия &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64435fd82de7b1d614dfb9844848a48b14c6cd2c" translate="yes" xml:space="preserve">
          <source>Float</source>
          <target state="translated">Float</target>
        </trans-unit>
        <trans-unit id="11c392eaf9a273578cddca36e05784e7ec0207b3" translate="yes" xml:space="preserve">
          <source>Float let-bindings inwards, nearer their binding site. See &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;Let-floating: moving bindings to give faster programs (ICFP&amp;lsquo;96)&lt;/a&gt;.</source>
          <target state="translated">Плавайте let-связки внутрь, ближе к месту их связывания. См. &amp;laquo; &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;Плавающий&amp;raquo;: перемещение привязок для ускорения программ (ICFP'96)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5e0526b9852afffdf9689fa74f06581b7f3b3784" translate="yes" xml:space="preserve">
          <source>Float let-bindings inwards, nearer their binding site. See &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;Let-floating: moving bindings to give faster programs (ICFP&amp;rsquo;96)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a99a789a6440d2e0783c52c14f1b895aa85ee6da" translate="yes" xml:space="preserve">
          <source>Float methods</source>
          <target state="translated">Поплавковые методы</target>
        </trans-unit>
        <trans-unit id="03c6a3d4a620ad6a95690d9257e6602cfa12ec6b" translate="yes" xml:space="preserve">
          <source>Float#</source>
          <target state="translated">Float#</target>
        </trans-unit>
        <trans-unit id="e84ef7c494482d98641252e0399d1dd94c8bfe32" translate="yes" xml:space="preserve">
          <source>Float/Int conversions, wrapped primops</source>
          <target state="translated">Преобразования Float/Int,обернутые примулы</target>
        </trans-unit>
        <trans-unit id="471bcd60035338d11d9230973a397e8b65fdb767" translate="yes" xml:space="preserve">
          <source>FloatElemRep</source>
          <target state="translated">FloatElemRep</target>
        </trans-unit>
        <trans-unit id="89b3a61017b0b9614ae8ccc16d0818a913c0e924" translate="yes" xml:space="preserve">
          <source>FloatRep</source>
          <target state="translated">FloatRep</target>
        </trans-unit>
        <trans-unit id="a653d15a4777ec0f86a07afd7ce540d8514fe97b" translate="yes" xml:space="preserve">
          <source>FloatX16#</source>
          <target state="translated">FloatX16#</target>
        </trans-unit>
        <trans-unit id="11e6eacae4a18d2e4bd76e48d4a57fa313675caf" translate="yes" xml:space="preserve">
          <source>FloatX4#</source>
          <target state="translated">FloatX4#</target>
        </trans-unit>
        <trans-unit id="29c459076fc63798f4132325e3f3f308a1e5b6f4" translate="yes" xml:space="preserve">
          <source>FloatX8#</source>
          <target state="translated">FloatX8#</target>
        </trans-unit>
        <trans-unit id="ab224b51965363d31db26ddc6738fa145bb46562" translate="yes" xml:space="preserve">
          <source>Floating</source>
          <target state="translated">Floating</target>
        </trans-unit>
        <trans-unit id="26f84222b978702da534998cccf7e093da992898" translate="yes" xml:space="preserve">
          <source>Floating types</source>
          <target state="translated">Плавучие типы</target>
        </trans-unit>
        <trans-unit id="450e2ff7d08682a58ebee70fca61dbfb6a6e7063" translate="yes" xml:space="preserve">
          <source>FlowAction</source>
          <target state="translated">FlowAction</target>
        </trans-unit>
        <trans-unit id="6e5ef5487191e4dd22398274011cf12de9a91e94" translate="yes" xml:space="preserve">
          <source>Flush all the data from the supplied write buffer out to the device. The returned buffer should be empty, and ready for writing.</source>
          <target state="translated">Промойте все данные из входящего в комплект буфера записи в устройство.Возвращаемый буфер должен быть пустым и готовым к записи.</target>
        </trans-unit>
        <trans-unit id="bf6064155984dcdefe2820b834eb03fc5450e184" translate="yes" xml:space="preserve">
          <source>Flush buffers (if any) of your custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;. This can be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Очистите буферы (если есть) вашего настраиваемого &lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt; . Это может быть &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="358b7b4736340628089a578a4f127145e9f86637" translate="yes" xml:space="preserve">
          <source>Flush data from the supplied write buffer out to the device without blocking. Returns the number of bytes written and the remaining buffer.</source>
          <target state="translated">Промойте данные из входящего в комплект поставки буфера записи в устройство без блокировки.Возвращает количество записанных байт и оставшийся буфер.</target>
        </trans-unit>
        <trans-unit id="cd61c8c15dd02466359a4d4a7b35cb820213dbe9" translate="yes" xml:space="preserve">
          <source>Flush the current buffer. This introduces a chunk boundary.</source>
          <target state="translated">Промойте текущий буфер.Это вводит границу фрагмента.</target>
        </trans-unit>
        <trans-unit id="8f2757271a40ce096379108294905c1babb07ac2" translate="yes" xml:space="preserve">
          <source>Flushing the buffer state</source>
          <target state="translated">Промывание буферного состояния</target>
        </trans-unit>
        <trans-unit id="245ac1ca610984dee51983b1a19924096b479a7d" translate="yes" xml:space="preserve">
          <source>Flushing the implicit parse state</source>
          <target state="translated">Смывание неявного состояния разбора</target>
        </trans-unit>
        <trans-unit id="2374f7905efdc0f4f714c25a7472902042311cdf" translate="yes" xml:space="preserve">
          <source>Fold a list using the monoid.</source>
          <target state="translated">Сложите список,используя моноид.</target>
        </trans-unit>
        <trans-unit id="0a7cc99c934753ce6e6950e7c43626ab6fa6d2f5" translate="yes" xml:space="preserve">
          <source>Fold a tree into a &quot;summary&quot; value in depth-first order.</source>
          <target state="translated">Сложите дерево в &quot;итоговом&quot; значении в первом порядке по глубине.</target>
        </trans-unit>
        <trans-unit id="f67973842ff2d508f50cd5451a0e67d4a63ae01e" translate="yes" xml:space="preserve">
          <source>Fold an &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; case-wise, just like &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Сложите в &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; случае мудр, как &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f671e4bd34a867cbf0e6b25023adc640a86e3db" translate="yes" xml:space="preserve">
          <source>Fold from right to left.</source>
          <target state="translated">Согните справа налево.</target>
        </trans-unit>
        <trans-unit id="8b610be124aa3a40ce1b39d37fc11b0b04c6263e" translate="yes" xml:space="preserve">
          <source>Foldable</source>
          <target state="translated">Foldable</target>
        </trans-unit>
        <trans-unit id="37d91c80ee36726ccf43b2e7f00be807a7045256" translate="yes" xml:space="preserve">
          <source>Foldable structures are reduced to a summary value by accumulating contributions to the result one element at a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b84829350dde1e376868f53c48ad67c4112eee6" translate="yes" xml:space="preserve">
          <source>Folding actions</source>
          <target state="translated">Сворачивание действий</target>
        </trans-unit>
        <trans-unit id="2d8b815138c38106cf926a1dd7d970d8c84885c4" translate="yes" xml:space="preserve">
          <source>Folds</source>
          <target state="translated">Folds</target>
        </trans-unit>
        <trans-unit id="c88897f7a995c31a2d98d1a61bd0b6af136abc63" translate="yes" xml:space="preserve">
          <source>Folds and traversals</source>
          <target state="translated">сгибы и обходы</target>
        </trans-unit>
        <trans-unit id="2186e55af17afc5fa2144b8775a49f1290a3d33b" translate="yes" xml:space="preserve">
          <source>Folds in order of increasing key.</source>
          <target state="translated">Складывается в порядке возрастания ключа.</target>
        </trans-unit>
        <trans-unit id="8bd6a5b4641abf50c3fa996016c263fddb09d728" translate="yes" xml:space="preserve">
          <source>Folds of unbounded structures do not terminate when the monoid's &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; operator is strict:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57295c01bef2c30b4729669a29577172c281ea3" translate="yes" xml:space="preserve">
          <source>Following a suggestion of Mark Jones, in his paper &lt;a href=&quot;https://web.cecs.pdx.edu/~mpj/thih/&quot;&gt;Typing Haskell in Haskell&lt;/a&gt;, GHC implements a more general scheme. In GHC &lt;em&gt;the dependency analysis ignores references to variables that have an explicit type signature&lt;/em&gt;. As a result of this refined dependency analysis, the dependency groups are smaller, and more bindings will typecheck. For example, consider:</source>
          <target state="translated">Следуя предложению Марка Джонса в его статье &lt;a href=&quot;https://web.cecs.pdx.edu/~mpj/thih/&quot;&gt;Typing Haskell in Haskell&lt;/a&gt; , GHC реализует более общую схему. В GHC &lt;em&gt;анализ зависимостей игнорирует ссылки на переменные, которые имеют явную сигнатуру типа&lt;/em&gt; . В результате этого усовершенствованного анализа зависимостей группы зависимостей стали меньше, и большее количество привязок будет проверять типы. Например, рассмотрим:</target>
        </trans-unit>
        <trans-unit id="5cb7231f65ffda9aaf11e030c71a231be4c4e62b" translate="yes" xml:space="preserve">
          <source>Following the ISO-10646 standard, &lt;code&gt;maxBound :: Char&lt;/code&gt; in GHC is &lt;code&gt;0x10FFFF&lt;/code&gt;.</source>
          <target state="translated">В соответствии со стандартом ISO-10646 &lt;code&gt;maxBound :: Char&lt;/code&gt; в GHC имеет значение &lt;code&gt;0x10FFFF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="683450681a094431fa846533675f44d1e8b059fa" translate="yes" xml:space="preserve">
          <source>Follows the recommendations in &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&lt;/a&gt;</source>
          <target state="translated">Соответствует рекомендациям &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24f8eb6fedbc854f6eb4756da6cd5c7a8c568aea" translate="yes" xml:space="preserve">
          <source>Follows the recommendations in &lt;a href=&quot;https://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d946127399c2228b066615f8fa0d54aa0a373b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt;, the &lt;em&gt;non-deterministic&lt;/em&gt; behaviour of &lt;code&gt;List&lt;/code&gt; is most easily seen in the case of a list of lists (of elements of some common fixed type). The result is a cross-product of all the sublists:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8a1a6a78e6e0c64059181cdc137c3f13446688" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;/code&gt; and &lt;code&gt;&lt;em&gt;b&lt;/em&gt;&lt;/code&gt;, compute their greatest common divisor &lt;code&gt;&lt;em&gt;g&lt;/em&gt;&lt;/code&gt; and the coefficient &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt; satisfying &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;s&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g&lt;/em&gt;&lt;/code&gt;.</source>
          <target state="translated">Для &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;/code&gt; и &lt;code&gt;&lt;em&gt;b&lt;/em&gt;&lt;/code&gt; вычислите их наибольший общий делитель &lt;code&gt;&lt;em&gt;g&lt;/em&gt;&lt;/code&gt; и коэффициент &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt; , удовлетворяющие условию &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;s&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g&lt;/em&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="438754bee88837ce49606e1c3c4cb154a8fdc138" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;CalendarDiffDays&lt;/code&gt; (and &lt;code&gt;CalendarDiffTime&lt;/code&gt;):</source>
          <target state="translated">Для &lt;code&gt;CalendarDiffDays&lt;/code&gt; (и &lt;code&gt;CalendarDiffTime&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="38c17a34f43461761882cc425a0ecd3ab0e949ec" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;CalendarDiffTime&lt;/code&gt;:</source>
          <target state="translated">Для &lt;code&gt;CalendarDiffTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1c0143b791c012f113a8232c3ab197fb3753fd36" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Day&lt;/code&gt; (and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">Для &lt;code&gt;Day&lt;/code&gt; (и &lt;code&gt;LocalTime&lt;/code&gt; , и &lt;code&gt;ZonedTime&lt;/code&gt; , и &lt;code&gt;UTCTime&lt;/code&gt; и &lt;code&gt;UniversalTime&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="20a7a91f2f957f2a10870727acfcfa4a35d3973b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DayOfWeek&lt;/code&gt; (and &lt;code&gt;Day&lt;/code&gt; and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">Для &lt;code&gt;DayOfWeek&lt;/code&gt; (и &lt;code&gt;Day&lt;/code&gt; , и &lt;code&gt;LocalTime&lt;/code&gt; , и &lt;code&gt;ZonedTime&lt;/code&gt; , и &lt;code&gt;UTCTime&lt;/code&gt; , и &lt;code&gt;UniversalTime&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="72a84ee2f0f4c4168eef092af153fed065cacbf6" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;LocalTime&lt;/code&gt; (and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">Для &lt;code&gt;LocalTime&lt;/code&gt; (и &lt;code&gt;ZonedTime&lt;/code&gt; , и &lt;code&gt;UTCTime&lt;/code&gt; , и &lt;code&gt;UniversalTime&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="43312a6d64a5882430cc27d6c5bcaff6112fd683" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;NominalDiffTime&lt;/code&gt; and &lt;code&gt;DiffTime&lt;/code&gt;:</source>
          <target state="translated">Для &lt;code&gt;NominalDiffTime&lt;/code&gt; и &lt;code&gt;DiffTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="58ae54bfb7d2d0244bc285d96a987c748a014820" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;TimeOfDay&lt;/code&gt; (and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">Для &lt;code&gt;TimeOfDay&lt;/code&gt; (и &lt;code&gt;LocalTime&lt;/code&gt; , и &lt;code&gt;ZonedTime&lt;/code&gt; , и &lt;code&gt;UTCTime&lt;/code&gt; и &lt;code&gt;UniversalTime&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="de676cebc1b71a848f33653aed6cf2c30d41ec6c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;TimeZone&lt;/code&gt; (and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt;):</source>
          <target state="translated">Для &lt;code&gt;TimeZone&lt;/code&gt; (и &lt;code&gt;ZonedTime&lt;/code&gt; и &lt;code&gt;UTCTime&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="780610a5f5cec081a6e5e8e4fd872022d4b9ccd3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt;:</source>
          <target state="translated">Для &lt;code&gt;UTCTime&lt;/code&gt; и &lt;code&gt;ZonedTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="41f6ee1958af63054f1e2c3d4dd9c1a48d13ac68" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;base &amp;gt;= 4.8.0&lt;/code&gt; and &lt;code&gt;containers &amp;gt;= 0.5.11&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; is a synonym for &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateA&quot;&gt;replicateA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для &lt;code&gt;base &amp;gt;= 4.8.0&lt;/code&gt; и &lt;code&gt;containers &amp;gt;= 0.5.11&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; является синонимом &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateA&quot;&gt;replicateA&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc47e5122f21703f2a3de45263a7aaf0eac1316f" translate="yes" xml:space="preserve">
          <source>For POSIX users, this is equivalent to &lt;code&gt;&lt;a href=&quot;../unix-2.7.2.2/system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для пользователей POSIX это эквивалентно &lt;code&gt;&lt;a href=&quot;../unix-2.7.2.2/system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c17acddc624fd77e3cb189ccd12fd6ee29107023" translate="yes" xml:space="preserve">
          <source>For POSIX users, this is equivalent to &lt;code&gt;&lt;a href=&quot;system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для пользователей POSIX это эквивалентно &lt;code&gt;&lt;a href=&quot;system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12834118955436c30a4e545201bc91502d57a5e3" translate="yes" xml:space="preserve">
          <source>For a bidirectional pattern synonym, a use of the pattern synonym as an expression has the type</source>
          <target state="translated">Для двунаправленного синонима шаблона использование синонима шаблона в качестве выражения имеет тип</target>
        </trans-unit>
        <trans-unit id="68e1aba695e3ce91a31fd34537a2f0dd4c81abe3" translate="yes" xml:space="preserve">
          <source>For a class, every type variable must be annotated with a kind.</source>
          <target state="translated">Для класса каждая переменная типа должна быть аннотирована типом.</target>
        </trans-unit>
        <trans-unit id="8fe53f9ccf4406924e6b6d736fa635a1f07be35e" translate="yes" xml:space="preserve">
          <source>For a complex number &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; z&lt;/code&gt; is a number with the magnitude of &lt;code&gt;z&lt;/code&gt;, but oriented in the positive real direction, whereas &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt; z&lt;/code&gt; has the phase of &lt;code&gt;z&lt;/code&gt;, but unit magnitude.</source>
          <target state="translated">Для комплексного числа &lt;code&gt;z&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; z&lt;/code&gt; - это число с величиной &lt;code&gt;z&lt;/code&gt; , но ориентированное в положительном действительном направлении, тогда как &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt; z&lt;/code&gt; имеет фазу &lt;code&gt;z&lt;/code&gt; , но единичную величину.</target>
        </trans-unit>
        <trans-unit id="bde3bc31dcf2451837a45deb22082c15149b6c7b" translate="yes" xml:space="preserve">
          <source>For a comprehensive listing of supported platforms, please refer to &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/-/wikis/platforms&quot;&gt;https://gitlab.haskell.org/ghc/ghc/-/wikis/platforms&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381187e4f3ff0b6bc5d10ac5d2f67f7b97f7590a" translate="yes" xml:space="preserve">
          <source>For a datatype with a top-level &lt;code&gt;::&lt;/code&gt;: all kind variables introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified.</source>
          <target state="translated">Для типа данных с верхним уровнем &lt;code&gt;::&lt;/code&gt; : все переменные вида, введенные после &lt;code&gt;::&lt;/code&gt; , должны быть явно количественно определены.</target>
        </trans-unit>
        <trans-unit id="ee774f603ab065899ff7fb5a9bcaeae920fd5a55" translate="yes" xml:space="preserve">
          <source>For a datatype, every type variable must be annotated with a kind. In a GADT-style declaration, there may also be a kind signature (with a top-level &lt;code&gt;::&lt;/code&gt; in the header), but the presence or absence of this annotation does not affect whether or not the declaration has a complete signature.</source>
          <target state="translated">Для типа данных каждая переменная типа должна быть аннотирована типом. В объявлении в стиле GADT также может быть подпись вида (с верхним уровнем &lt;code&gt;::&lt;/code&gt; в заголовке), но наличие или отсутствие этой аннотации не влияет на то, имеет ли объявление полную подпись.</target>
        </trans-unit>
        <trans-unit id="7c12c8fb4a7f215c82a05683a5710f3a85d7f1fd" translate="yes" xml:space="preserve">
          <source>For a detailed discussion, see Levent Erkok's thesis, &lt;em&gt;Value Recursion in Monadic Computations&lt;/em&gt;, Oregon Graduate Institute, 2002.</source>
          <target state="translated">Подробное обсуждение см. В диссертации Левента Эркока &amp;laquo; &lt;em&gt;Рекурсия значений в монадических вычислениях&amp;raquo;&lt;/em&gt; , Oregon Graduate Institute, 2002.</target>
        </trans-unit>
        <trans-unit id="ff2aa12fcb0881466720f2e80b4f0d096c83a123" translate="yes" xml:space="preserve">
          <source>For a full specification of the algorithms used in &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/DeriveFunctor&quot;&gt;this wiki page&lt;/a&gt;.</source>
          <target state="translated">Полную спецификацию алгоритмов, используемых в &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; , см. На &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/DeriveFunctor&quot;&gt;этой странице вики&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa43273cfde854c1384910a8e3bf21706a4937f0" translate="yes" xml:space="preserve">
          <source>For a full specification of the algorithms used in &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/derive-functor&quot;&gt;this wiki page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f753874b80e6283217fbd2405e5d7bb6c4151408" translate="yes" xml:space="preserve">
          <source>For a fully working example, see &lt;code&gt;testsuite/tests/concurrent/should_run/hs_try_putmvar001.hs&lt;/code&gt; in the GHC source tree.</source>
          <target state="translated">Полностью рабочий пример см. В &lt;code&gt;testsuite/tests/concurrent/should_run/hs_try_putmvar001.hs&lt;/code&gt; в дереве исходных текстов GHC.</target>
        </trans-unit>
        <trans-unit id="b02bfdafd93af69d743b0ce3c0a4317ebee1f2be" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to,</source>
          <target state="translated">Для общей структуры &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; это должно быть семантически идентично,</target>
        </trans-unit>
        <trans-unit id="f4c2f154344db246f733b27e08b4fac32576674c" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce4b8eeb28d94d8e7c6254b4d94c9ba94f5eaa06" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to,</source>
          <target state="translated">Для общей структуры &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; это должно быть семантически идентично,</target>
        </trans-unit>
        <trans-unit id="eb1a2ffe8319962a0d9758d8d5c92f844737e908" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ffd351d10bb1cc76d3c976825e9c103713a2402" translate="yes" xml:space="preserve">
          <source>For a given heap size (using the &lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-H [⟨size⟩]&lt;/code&gt;&lt;/a&gt; option), compaction can in fact reduce the GC cost by allowing fewer GCs to be performed. This is more likely when the ratio of live data to heap size is high, say greater than 30%.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690c81581725977a80c5ea6bb4e5ee9018b2f21a" translate="yes" xml:space="preserve">
          <source>For a given heap size (using the &lt;code&gt;-H ⟨size⟩&lt;/code&gt; option), compaction can in fact reduce the GC cost by allowing fewer GCs to be performed. This is more likely when the ratio of live data to heap size is high, say greater than 30%.</source>
          <target state="translated">Для заданного размера кучи (с использованием параметра &lt;code&gt;-H ⟨size⟩&lt;/code&gt; ) уплотнение может фактически снизить стоимость сборки мусора , позволяя выполнять меньшее количество сборок мусора . Это более вероятно, когда отношение живых данных к размеру кучи велико, скажем, превышает 30%.</target>
        </trans-unit>
        <trans-unit id="dade435c995cd800c773d6e4aa166b67efb6ca38" translate="yes" xml:space="preserve">
          <source>For a handle &lt;code&gt;hdl&lt;/code&gt; which attached to a physical file, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns the size of that file in 8-bit bytes.</source>
          <target state="translated">Для дескриптора &lt;code&gt;hdl&lt;/code&gt; , прикрепленного к физическому файлу, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; возвращает размер этого файла в 8-битных байтах.</target>
        </trans-unit>
        <trans-unit id="d3c63f5fcdc6df7421dc6b15f96e58c2cd3eb2d6" translate="yes" xml:space="preserve">
          <source>For a handle &lt;code&gt;hdl&lt;/code&gt; which attached to a physical file, &lt;code&gt;&lt;a href=&quot;system-io#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns the size of that file in 8-bit bytes.</source>
          <target state="translated">Для дескриптора &lt;code&gt;hdl&lt;/code&gt; , прикрепленного к физическому файлу, &lt;code&gt;&lt;a href=&quot;system-io#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; возвращает размер этого файла в 8-битных байтах.</target>
        </trans-unit>
        <trans-unit id="346fb7900fc27cffc7ae7ee52aedbaed80128cb6" translate="yes" xml:space="preserve">
          <source>For a lambda-bound or case-bound variable, x, either the programmer provides an explicit polymorphic type for x, or GHC&amp;rsquo;s type inference will assume that x&amp;rsquo;s type has no foralls in it.</source>
          <target state="translated">Для переменной x с привязкой к лямбда или регистру либо программист предоставляет явный полиморфный тип для x, либо вывод типа GHC будет предполагать, что тип x не содержит в себе forall-ов.</target>
        </trans-unit>
        <trans-unit id="f6acc7fc1a003a7f2eed93e34c1d5012a4db3a7b" translate="yes" xml:space="preserve">
          <source>For a monadic version see &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldForestM_BF&quot;&gt;unfoldForestM_BF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для монадической версии см. &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldForestM_BF&quot;&gt;unfoldForestM_BF&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7723435d9290343f2201698a48102c4e2963ac9" translate="yes" xml:space="preserve">
          <source>For a monadic version see &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldTreeM_BF&quot;&gt;unfoldTreeM_BF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для монадической версии см. &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldTreeM_BF&quot;&gt;unfoldTreeM_BF&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41fb437ba339dfd70d91e29e645efbb597123e67" translate="yes" xml:space="preserve">
          <source>For a newtype, the rules are the same as they are for a data type unless &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; is enabled. With &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt;, the type constructor only has a CUSK if a kind signature is present. As with a datatype with a top-level &lt;code&gt;::&lt;/code&gt;, all kind variables must introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d8cf6ad049da3ffe486c394fe0bd5021d502284" translate="yes" xml:space="preserve">
          <source>For a newtype, the rules are the same as they are for a data type unless &lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; is enabled. With &lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt;, the type constructor only has a CUSK if a kind signature is present. As with a datatype with a top-level &lt;code&gt;::&lt;/code&gt;, all kind variables introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb1847901cd6f8ebc084093215bfbec76990b3e" translate="yes" xml:space="preserve">
          <source>For a plain &lt;code&gt;foreign export&lt;/code&gt;, the file &lt;code&gt;M_stub.h&lt;/code&gt; contains a C prototype for the foreign exported function. For example, if we compile the following module:</source>
          <target state="translated">Для простого &lt;code&gt;foreign export&lt;/code&gt; за &lt;code&gt;M_stub.h&lt;/code&gt; файл M_stub.h содержит прототип C для экспортируемой функции за границу . Например, если мы скомпилируем следующий модуль:</target>
        </trans-unit>
        <trans-unit id="2010d0ed548d603dcd6e8de87d973f011d76f796" translate="yes" xml:space="preserve">
          <source>For a polykinded type family, the kinds are checked for apartness just like types. For example, the following is accepted:</source>
          <target state="translated">Для семейства поливидовые типы проверяются на квартиры так же,как и типы.Например,принимается следующее:</target>
        </trans-unit>
        <trans-unit id="1ec55d48cfc12f5eb55df6ee4c9fc9967d025743" translate="yes" xml:space="preserve">
          <source>For a read-only state, see &lt;a href=&quot;control-monad-trans-reader&quot;&gt;Control.Monad.Trans.Reader&lt;/a&gt;.</source>
          <target state="translated">Для состояния только для чтения см. &lt;a href=&quot;control-monad-trans-reader&quot;&gt;Control.Monad.Trans.Reader&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89e5871716007219289211d50f9f31d07f96bebe" translate="yes" xml:space="preserve">
          <source>For a readable handle &lt;code&gt;hdl&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if no further input can be taken from &lt;code&gt;hdl&lt;/code&gt; or for a physical file, if the current I/O position is equal to the length of the file. Otherwise, it returns &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для читаемого дескриптора &lt;code&gt;hdl&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если никакой дальнейший ввод не может быть взят из &lt;code&gt;hdl&lt;/code&gt; или физического файла, если текущее положение I / O, равна длине файла. В противном случае возвращается &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2287783eee0e5de776e32c05f70808452f33fbd" translate="yes" xml:space="preserve">
          <source>For a readable handle &lt;code&gt;hdl&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if no further input can be taken from &lt;code&gt;hdl&lt;/code&gt; or for a physical file, if the current I/O position is equal to the length of the file. Otherwise, it returns &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для читаемого дескриптора &lt;code&gt;hdl&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если никакой дальнейший ввод не может быть взят из &lt;code&gt;hdl&lt;/code&gt; или физического файла, если текущее положение I / O, равна длине файла. В противном случае возвращается &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adff34a3466fde4a9da78cc13745c730ac48fbdb" translate="yes" xml:space="preserve">
          <source>For a strict version with the same interface, see &lt;a href=&quot;control-monad-trans-state-strict&quot;&gt;Control.Monad.Trans.State.Strict&lt;/a&gt;.</source>
          <target state="translated">Для строгой версии с тем же интерфейсом см. &lt;a href=&quot;control-monad-trans-state-strict&quot;&gt;Control.Monad.Trans.State.Strict&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7841e1d83167e58d01ed6bbf031eb35a3b28a384" translate="yes" xml:space="preserve">
          <source>For a type synonym, every type variable and the result type must all be annotated with kinds:</source>
          <target state="translated">Для синонима типа каждая переменная типа и тип результата должны быть аннотированы типами:</target>
        </trans-unit>
        <trans-unit id="8a7dabb4a59eac239d73f8d88adf219f4a141e0a" translate="yes" xml:space="preserve">
          <source>For a unidirectional record pattern synonym we define record selectors but do not allow record updates or construction.</source>
          <target state="translated">Для однонаправленного синонима шаблона записи мы определяем селекторы записей,но не разрешаем обновление или построение записи.</target>
        </trans-unit>
        <trans-unit id="ea4172896e3aa016d0abf8c8c8b0c573b135be3c" translate="yes" xml:space="preserve">
          <source>For a variant allowing a range of exception values, see &lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Except&lt;/a&gt;.</source>
          <target state="translated">Вариант, допускающий диапазон значений исключения, см. В &lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Except&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="348fe1968c9295273d516331a948a6159bdca8cf" translate="yes" xml:space="preserve">
          <source>For a version that ignores the results, see &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для версии, которая игнорирует результаты, см. &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd461bef656027f3a267dac7f770cf766ddc2c2e" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see the &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/map.html&quot;&gt;maps introduction&lt;/a&gt;.</source>
          <target state="translated">Пошаговое руководство по наиболее часто используемым функциям см. Во &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/map.html&quot;&gt;введении&lt;/a&gt; к картам .</target>
        </trans-unit>
        <trans-unit id="93f1a6621ab377cb23e0289b270fa1e8b0fea36d" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see the &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;sets introduction&lt;/a&gt;.</source>
          <target state="translated">Для ознакомления с наиболее часто используемыми функциями см. &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;Введение&lt;/a&gt; в наборы .</target>
        </trans-unit>
        <trans-unit id="d40c81c0c5fac25219b486dd4532b6661cea779f" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see their &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;sets introduction&lt;/a&gt;.</source>
          <target state="translated">Пошаговое руководство по наиболее часто используемым функциям см. Во &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;введении к&lt;/a&gt; их наборам .</target>
        </trans-unit>
        <trans-unit id="0b41a37cf99caafb018a9e5b3dc8989fdb6d5ec4" translate="yes" xml:space="preserve">
          <source>For all types (note these three are done by &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;, not by &lt;code&gt;&lt;a href=&quot;data-time-format-internal#v:formatCharacter&quot;&gt;formatCharacter&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">Для всех типов (обратите внимание, что эти три выполняются с помощью &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; , а не &lt;code&gt;&lt;a href=&quot;data-time-format-internal#v:formatCharacter&quot;&gt;formatCharacter&lt;/a&gt;&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="5679f68c9f6e5d539aa213e495939714c629e80c" translate="yes" xml:space="preserve">
          <source>For almost all sensible programs this will indicate a bug, and you probably intended to write:</source>
          <target state="translated">Почти для всех здравомыслящих программ это будет указывать на ошибку,и вы,вероятно,собирались писать:</target>
        </trans-unit>
        <trans-unit id="63a574ff5f92276a16df15dd4fc8478ad9638408" translate="yes" xml:space="preserve">
          <source>For an &amp;ldquo;unpackable&amp;rdquo; &lt;code&gt;U(...)&lt;/code&gt; argument, the info inside tells the strictness of its components. So, if the argument is a pair, and it says &lt;code&gt;U(AU(LSS))&lt;/code&gt;, that means &amp;ldquo;the first component of the pair isn&amp;rsquo;t used; the second component is itself unpackable, with three components (lazy in the first, strict in the second \&amp;amp; third).&amp;rdquo;</source>
          <target state="translated">Для &amp;laquo;неупаковываемого&amp;raquo; аргумента &lt;code&gt;U(...)&lt;/code&gt; информация внутри говорит о строгости его компонентов. Итак, если аргумент - пара, и он говорит &lt;code&gt;U(AU(LSS))&lt;/code&gt; , это означает, что &amp;laquo;первый компонент пары не используется; второй компонент сам по себе распаковывается и состоит из трех компонентов (ленивый в первом, строгий во втором \ и третьем) &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d1cb9e82bcd8a245aaf6652f2e48d70c05a6dea5" translate="yes" xml:space="preserve">
          <source>For an &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; functor &lt;strong&gt;&lt;code&gt;f&lt;/code&gt;&lt;/strong&gt; and a Traversable functor &lt;strong&gt;&lt;code&gt;t&lt;/code&gt;&lt;/strong&gt;, the type signatures of &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; are rather similar:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b4aadcc9e022579cc277ee1163fd8f6a08abf6" translate="yes" xml:space="preserve">
          <source>For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</source>
          <target state="translated">Для &lt;em&gt;эффективной реализации кодирования&lt;/em&gt; важно, чтобы (а) мало времени тратилось на преобразование значений Haskell в результирующую последовательность байтов &lt;em&gt;и&lt;/em&gt; (б) чтобы представление результирующей последовательности было таким, чтобы ее можно было эффективно использовать. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; поддерживает (а) путем предоставления операции конкатенации O (1) и эффективных реализаций базовых кодировок для &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; и других стандартных значений Haskell. Они поддерживают (b), предоставляя свой результат в виде ленивой &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; , которая внутри представляет собой просто связанный список указателей на &lt;em&gt;блоки&lt;/em&gt; последовательной необработанной памяти. Ленивая &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; s могут быть эффективно использованы функциями, которые записывают их в файл или отправляют через сетевой сокет. Обратите внимание, что каждая граница блока требует дорогостоящей дополнительной работы (например, системного вызова), которая должна быть амортизирована по сравнению с работой, потраченной на потребление тела блока. Поэтому &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; уделяет особое внимание тому, чтобы средний размер блока был достаточно большим. Точное значение слова &amp;laquo;достаточно большой&amp;raquo; зависит от приложения. Текущая реализация настроена на средний размер блока от 4 до 32 КБ, что должно подходить для большинства приложений.</target>
        </trans-unit>
        <trans-unit id="c98483df7da3278fbc5172993ad0a88f8fc1d389" translate="yes" xml:space="preserve">
          <source>For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3496a2b758ef763c20485808c9274b5b6efa235b" translate="yes" xml:space="preserve">
          <source>For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85427d3349c7624ec90481011c2c435a5c350f38" translate="yes" xml:space="preserve">
          <source>For an enumeration, the nullary constructors are assumed to be numbered left-to-right with the indices being 0 to n-1 inclusive. This is the same numbering defined by the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class. For example, given the datatype:</source>
          <target state="translated">Для перечисления предполагается, что нулевые конструкторы пронумерованы слева направо с индексами от 0 до n-1 включительно. Это та же нумерация, которая определяется классом &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; . Например, учитывая тип данных:</target>
        </trans-unit>
        <trans-unit id="2317d704439c0e816415f233729962e630340d1c" translate="yes" xml:space="preserve">
          <source>For an example demonstrating why this is unsafe, see &lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&quot;&gt;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&lt;/a&gt;</source>
          <target state="translated">Пример, демонстрирующий, почему это небезопасно, см. &lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&quot;&gt;Https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5f98c16b96cd9f3dba7b2312cfd924a11d7ac8d" translate="yes" xml:space="preserve">
          <source>For an example we have a program, called &lt;code&gt;Recip.hs&lt;/code&gt;, which computes exact decimal representations of reciprocals, with recurring parts indicated in brackets.</source>
          <target state="translated">В качестве примера у нас есть программа под названием &lt;code&gt;Recip.hs&lt;/code&gt; , которая вычисляет точные десятичные представления обратных чисел с повторяющимися частями, указанными в скобках.</target>
        </trans-unit>
        <trans-unit id="6f3c284585c0a604bb804752c3dde88c28f43321" translate="yes" xml:space="preserve">
          <source>For an interactive application, it is probably a good idea to use the idle GC, because this will allow finalizers to run and deadlocked threads to be detected in the idle time when no Haskell computation is happening. Also, it will mean that a GC is less likely to happen when the application is busy, and so responsiveness may be improved. However, if the amount of live data in the heap is particularly large, then the idle GC can cause a significant delay, and too small an interval could adversely affect interactive responsiveness.</source>
          <target state="translated">Для интерактивного приложения,вероятно,будет хорошей идеей использовать простаивающий GC,потому что это позволит финализаторам запускать и обнаруживать заблокированные потоки во время простоя,когда не происходит вычислений Хаскелла.Кроме того,это будет означать,что GC с меньшей вероятностью произойдет,когда приложение будет занято,и поэтому отзывчивость может быть улучшена.Однако,если количество живых данных в куче особенно велико,то холостой ГХ может вызвать значительную задержку,а слишком маленький интервал может негативно сказаться на интерактивной скорости отклика.</target>
        </trans-unit>
        <trans-unit id="945a445d8ac893cd2e10d46914fbf37b660fe8b4" translate="yes" xml:space="preserve">
          <source>For any module that is imported, GHC requires that the name of the module in the import statement exactly matches the name of the module in the interface file (or source file) found using the strategy specified in &lt;a href=&quot;#search-path&quot;&gt;The search path&lt;/a&gt;. This means that for most modules, the source file name should match the module name.</source>
          <target state="translated">Для любого импортируемого модуля GHC требует, чтобы имя модуля в операторе импорта точно совпадало с именем модуля в интерфейсном файле (или исходном файле), найденном с использованием стратегии, указанной в &lt;a href=&quot;#search-path&quot;&gt;Пути поиска&lt;/a&gt; . Это означает, что для большинства модулей имя исходного файла должно совпадать с именем модуля.</target>
        </trans-unit>
        <trans-unit id="c4fde380f1c057e17c4834c04b581f9f36e12710" translate="yes" xml:space="preserve">
          <source>For any type that is an instance of class &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; as well as &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, the following should hold:</source>
          <target state="translated">Для любого типа, который является экземпляром класса &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; , а также &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; , должно выполняться следующее:</target>
        </trans-unit>
        <trans-unit id="2668d63ce3c1412ab95942782c64db8a803782a5" translate="yes" xml:space="preserve">
          <source>For any type that is an instance of class &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; as well as &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, the following should hold:</source>
          <target state="translated">Для любого типа, который является экземпляром класса &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; , а также &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; , должно выполняться следующее:</target>
        </trans-unit>
        <trans-unit id="f5b0590b7a86a642764875b6c543da9446390b3c" translate="yes" xml:space="preserve">
          <source>For applications with large numbers of string literals, &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; can be a bottleneck. In such cases, consider using &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackAddress&quot;&gt;unsafePackAddress&lt;/a&gt;&lt;/code&gt; (GHC only).</source>
          <target state="translated">Для приложений с большим количеством строковых литералов &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; может быть узким местом. В таких случаях рассмотрите возможность использования &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackAddress&quot;&gt;unsafePackAddress&lt;/a&gt;&lt;/code&gt; (только GHC).</target>
        </trans-unit>
        <trans-unit id="157ede2fd9143a8b3502fbb97415660d94e7cb64" translate="yes" xml:space="preserve">
          <source>For applications with large numbers of string literals, pack can be a bottleneck.</source>
          <target state="translated">Для приложений с большим количеством строковых литералов упаковка может быть узким местом.</target>
        </trans-unit>
        <trans-unit id="56b658eb8fe6b5f04e699bc25917bb161ec51372" translate="yes" xml:space="preserve">
          <source>For backward compatibility with existing make scripts, when used in combination with &lt;a href=&quot;#ghc-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt;, the linking phase is omitted (same as &lt;code&gt;--make -no-link&lt;/code&gt;).</source>
          <target state="translated">Для обратной совместимости с существующими сценариями make при использовании в сочетании с &lt;a href=&quot;#ghc-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt; этап компоновки опускается (так же, как &lt;code&gt;--make -no-link&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a0f746a46394a3d26c67f678278e9c3f5556799d" translate="yes" xml:space="preserve">
          <source>For backward compatibility, kind variables &lt;em&gt;do not&lt;/em&gt; need to be bound explicitly, even if the type starts with &lt;code&gt;forall&lt;/code&gt;.</source>
          <target state="translated">Для обратной совместимости переменные вида &lt;em&gt;не&lt;/em&gt; нужно связывать явно, даже если тип начинается с &lt;code&gt;forall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1eb9aa8c4991a1b62e3c275f5d3018b0177bfba7" translate="yes" xml:space="preserve">
          <source>For backwards compatibility</source>
          <target state="translated">Для обратной совместимости</target>
        </trans-unit>
        <trans-unit id="27a3fb60d0c46913898e711aaa2f8bee288627da" translate="yes" xml:space="preserve">
          <source>For binary constructors</source>
          <target state="translated">Для бинарных конструкторов</target>
        </trans-unit>
        <trans-unit id="113ecb566c4518b38725ad5c1d8eb800bb73f6cc" translate="yes" xml:space="preserve">
          <source>For both &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt;, the phase number says when inlining is allowed at all.</source>
          <target state="translated">И для &lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; ,&lt;/a&gt; и для &lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt; номер фазы указывает, когда встраивание вообще разрешено.</target>
        </trans-unit>
        <trans-unit id="62d66553e100d412ce77e1fe48bae79aaea2144a" translate="yes" xml:space="preserve">
          <source>For both pattern and expression wildcards, the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo; expands to the missing &lt;em&gt;in-scope&lt;/em&gt; record fields. Specifically the expansion of &amp;ldquo;&lt;code&gt;C {..}&lt;/code&gt;&amp;rdquo; includes &lt;code&gt;f&lt;/code&gt; if and only if:</source>
          <target state="translated">И для шаблонов, и для подстановочных знаков выражения &quot; &lt;code&gt;..&lt;/code&gt; &quot; заменяется на отсутствующие поля записи в области &lt;em&gt;видимости&lt;/em&gt; . В частности, расширение &amp;laquo; &lt;code&gt;C {..}&lt;/code&gt; &amp;raquo; включает &lt;code&gt;f&lt;/code&gt; тогда и только тогда, когда:</target>
        </trans-unit>
        <trans-unit id="c79b50d69800a59416d8d5cf9c81be241c6cfd46" translate="yes" xml:space="preserve">
          <source>For boxed values (that is, values that are represented by a pointer), a further distinction is made, between lifted types (that contain &amp;perp;), and unlifted ones (that don't).</source>
          <target state="translated">Для упакованных значений (то есть значений, представленных указателем) проводится дополнительное различие между повышенными типами (которые содержат) и неподнятыми (которые не содержат).</target>
        </trans-unit>
        <trans-unit id="5ac3a49892d34dca6a91a788fcd33beaec7c04fe" translate="yes" xml:space="preserve">
          <source>For capabilities which may contain variable-length padding, use &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput&quot;&gt;tiGetOutput&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Для возможностей, которые могут содержать заполнение переменной длины, используйте вместо этого &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput&quot;&gt;tiGetOutput&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a6e2851e87788aba1413fa210db4c6f6c972b19" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для перехвата исключений в чистых (не &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ) выражениях см. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; функции .</target>
        </trans-unit>
        <trans-unit id="347db935aa14d91363ea82db49f93c38e6d9eb78" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9a7a9bf985a5fc7968bcd7963a4107803bb41d4" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b49217666ee344468a322492b5c79e209e32151" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для перехвата исключений в чистых (не &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ) выражениях см. &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; функции .</target>
        </trans-unit>
        <trans-unit id="ec5a20c491f4c7cf4edd8064f53d84a0223202bb" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для перехвата исключений в чистых (не &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ) выражениях см. &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; функции .</target>
        </trans-unit>
        <trans-unit id="ad72b8f09f320f536c51fd5fb47c559cb7126920" translate="yes" xml:space="preserve">
          <source>For coercing between any two integer types, use &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt;, which is specialized for all the common cases so should be fast enough. Coercing word types (see &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;) to and from integer types preserves representation, not sign.</source>
          <target state="translated">Для принуждения между любыми двумя целочисленными типами используйте &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt; , который предназначен для всех распространенных случаев, поэтому должен быть достаточно быстрым. Приведение типов слов (см. &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt; ) к целочисленным типам и обратно сохраняет представление, а не знак.</target>
        </trans-unit>
        <trans-unit id="6af5be5e40fc3970696dd7cb02cedeef47e8ddad" translate="yes" xml:space="preserve">
          <source>For coercing between any two integer types, use &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt;, which is specialized for all the common cases so should be fast enough. Coercing word types to and from integer types preserves representation, not sign.</source>
          <target state="translated">Для принуждения между любыми двумя целочисленными типами используйте &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt; , который предназначен для всех распространенных случаев, поэтому должен быть достаточно быстрым. Приведение типов слов к целочисленным типам и обратно сохраняет представление, а не знак.</target>
        </trans-unit>
        <trans-unit id="d569e185ce7fabcffce84351a9be98fa6e429e2d" translate="yes" xml:space="preserve">
          <source>For configuration files. It uses the &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;/etc/xdg&lt;/code&gt;. On Windows, the default is &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; or &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (e.g. &lt;code&gt;C:/ProgramData&lt;/code&gt;).</source>
          <target state="translated">Для файлов конфигурации. Он использует переменную среды &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; . В системах, отличных от Windows, по умолчанию используется &lt;code&gt;/etc/xdg&lt;/code&gt; . В Windows по умолчанию используется &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; или &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (например, &lt;code&gt;C:/ProgramData&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ecc757e7efb65d0598236167a0b25a6cc54dc8ed" translate="yes" xml:space="preserve">
          <source>For configuration files. It uses the &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.config&lt;/code&gt;. On Windows, the default is &lt;code&gt;%APPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">Для файлов конфигурации. Он использует переменную среды &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; . В системах, отличных от Windows, по умолчанию используется &lt;code&gt;~/.config&lt;/code&gt; . В Windows по умолчанию используется &lt;code&gt;%APPDATA%&lt;/code&gt; (например, &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt; ). Может рассматриваться как конкретный пользователем эквивалент &lt;code&gt;/etc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8bbf2f4e0dcd53b9576e5192a8bbd3f2edac0bb" translate="yes" xml:space="preserve">
          <source>For data files (e.g. images). It uses the &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;/usr/local/share/&lt;/code&gt; and &lt;code&gt;/usr/share/&lt;/code&gt;. On Windows, the default is &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; or &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (e.g. &lt;code&gt;C:/ProgramData&lt;/code&gt;).</source>
          <target state="translated">Для файлов данных (например, изображений). Он использует переменную среды &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; . В системах, отличных от Windows, по умолчанию используется &lt;code&gt;/usr/local/share/&lt;/code&gt; и &lt;code&gt;/usr/share/&lt;/code&gt; . В Windows по умолчанию используется &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; или &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (например, &lt;code&gt;C:/ProgramData&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f2c0b2306c8d3878f085903482b9a90782cfe6b1" translate="yes" xml:space="preserve">
          <source>For data files (e.g. images). It uses the &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.local/share&lt;/code&gt;. On Windows, the default is &lt;code&gt;%APPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/usr/share&lt;/code&gt;.</source>
          <target state="translated">Для файлов данных (например, изображений). Он использует переменную среды &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; . В системах, отличных от Windows, значение по умолчанию &lt;code&gt;~/.local/share&lt;/code&gt; . В Windows по умолчанию используется &lt;code&gt;%APPDATA%&lt;/code&gt; (например, &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt; ). Может рассматриваться как пользовательский эквивалент &lt;code&gt;/usr/share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fae8b417bf3bf5318948c8b0b508758745adb6f5" translate="yes" xml:space="preserve">
          <source>For decoding and generating simple external binary formats (e.g. C structures), Binary may be used, but in general is not suitable for complex protocols. Instead use the &lt;code&gt;&lt;a href=&quot;data-binary#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; primitives directly.</source>
          <target state="translated">Для декодирования и генерации простых внешних двоичных форматов (например, структур C) можно использовать двоичный формат, но в целом он не подходит для сложных протоколов. Вместо этого используйте примитивы &lt;code&gt;&lt;a href=&quot;data-binary#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-binary#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; напрямую.</target>
        </trans-unit>
        <trans-unit id="af244705c99bde3579744323c9a3a740b23bae24" translate="yes" xml:space="preserve">
          <source>For details on Remote GHCi, see Note [Remote GHCi] in compiler&lt;em&gt;GHC&lt;/em&gt;Runtime/Interpreter.hs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e906ad780906310d51f386651923755220b051e" translate="yes" xml:space="preserve">
          <source>For details on Remote GHCi, see Note [Remote GHCi] in compiler&lt;em&gt;ghci&lt;/em&gt;GHCi.hs.</source>
          <target state="translated">Подробнее о Remote GHCi см. В примечании [Remote GHCi] в компиляторе &lt;em&gt;ghci&lt;/em&gt; GHCi.hs.</target>
        </trans-unit>
        <trans-unit id="e1ce5f8e660c7a1a97eb8290bd06346fb0073e69" translate="yes" xml:space="preserve">
          <source>For each alternative of the sum type, a layout that consists of these fields is generated. For example, if an alternative has &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Float#&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; fields, the layout will have an 32bit word, 32bit float and pointer fields.</source>
          <target state="translated">Для каждой альтернативы типа суммы создается макет, состоящий из этих полей. Например, если у альтернативы есть поля &lt;code&gt;Int&lt;/code&gt; , &lt;code&gt;Float#&lt;/code&gt; и &lt;code&gt;String&lt;/code&gt; , макет будет иметь 32-битные поля слова, 32-битные поля с плавающей запятой и поля указателя.</target>
        </trans-unit>
        <trans-unit id="757a36cc9fb80bb745216ef2b4ffc5c6499465dc" translate="yes" xml:space="preserve">
          <source>For each garbage collection, we print:</source>
          <target state="translated">Для каждой коллекции мусора мы печатаем:</target>
        </trans-unit>
        <trans-unit id="482f5994f6e216e0ba86b514f2ee819b9680d690" translate="yes" xml:space="preserve">
          <source>For each import declaration &lt;code&gt;import X&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;, a line recording the dependence of &lt;code&gt;M&lt;/code&gt; on &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">Для каждой декларации &lt;code&gt;import X&lt;/code&gt; в &lt;code&gt;M&lt;/code&gt; строка, в которой записана зависимость &lt;code&gt;M&lt;/code&gt; от &lt;code&gt;X&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c02e72408897c523f9a6c45e14bb555eade7491d" translate="yes" xml:space="preserve">
          <source>For each import declaration &lt;code&gt;import {-# SOURCE #-} X&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;, a line recording the dependence of &lt;code&gt;M&lt;/code&gt; on &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">Для каждого объявления &lt;code&gt;import {-# SOURCE #-} X&lt;/code&gt; в &lt;code&gt;M&lt;/code&gt; , строка, записывающая зависимость &lt;code&gt;M&lt;/code&gt; от &lt;code&gt;X&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2200dfec6b12718042bc1df9e4ba8ac51a77f634" translate="yes" xml:space="preserve">
          <source>For each node in the tree, apply &lt;code&gt;f&lt;/code&gt; to the &lt;code&gt;rootLabel&lt;/code&gt; and the result of applying &lt;code&gt;f&lt;/code&gt; to each &lt;code&gt;subForest&lt;/code&gt;.</source>
          <target state="translated">Для каждого узла в дереве примените &lt;code&gt;f&lt;/code&gt; к &lt;code&gt;rootLabel&lt;/code&gt; и результат применения &lt;code&gt;f&lt;/code&gt; к каждому &lt;code&gt;subForest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3057e0dd6d54e41f208fa76fa96588cff9717be1" translate="yes" xml:space="preserve">
          <source>For empty datatypes, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; is used as a representation. For example,</source>
          <target state="translated">Для пустых типов данных &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; используется как представление. Например,</target>
        </trans-unit>
        <trans-unit id="367e92ce36a947e0da868cc6cdcfc2f796641103" translate="yes" xml:space="preserve">
          <source>For even more detail on this topic, see &lt;a href=&quot;http://www.cons.org/cracauer/sigint.html&quot;&gt;&quot;Proper handling of SIGINT/SIGQUIT&quot;&lt;/a&gt;.</source>
          <target state="translated">Для получения более подробной информации по этой теме см. &lt;a href=&quot;http://www.cons.org/cracauer/sigint.html&quot;&gt;&amp;laquo;Правильная обработка SIGINT / SIGQUIT&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bdb8867f7ccd15d71a69ed939e98d09ad4ef1b15" translate="yes" xml:space="preserve">
          <source>For every module &lt;code&gt;A.hs&lt;/code&gt; that is &lt;code&gt;{-# SOURCE #-}&lt;/code&gt;-imported in this way there must exist a source file &lt;code&gt;A.hs-boot&lt;/code&gt;. This file contains an abbreviated version of &lt;code&gt;A.hs&lt;/code&gt;, thus:</source>
          <target state="translated">Для каждого модуля &lt;code&gt;A.hs&lt;/code&gt; , который &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; -импортирован таким образом, должен существовать исходный файл &lt;code&gt;A.hs-boot&lt;/code&gt; . Этот файл содержит сокращенную версию &lt;code&gt;A.hs&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="b0f621e891e9171328261480a78acacdfb576180" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;-l-ag&lt;/code&gt; would disable all event classes (&lt;code&gt;-a&lt;/code&gt;) except for GC events (&lt;code&gt;g&lt;/code&gt;).</source>
          <target state="translated">Например, &lt;code&gt;-l-ag&lt;/code&gt; отключит все классы событий ( &lt;code&gt;-a&lt;/code&gt; ), кроме событий GC ( &lt;code&gt;g&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e539a440aea70f6c1e340e284061ee3f7564fb32" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0faa4a03eb1b621e96ddafa75b4d631885ce8235" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54977218cb67963281b7e0eb298f559214d3d420" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8c5988831e8e7e699f73f0c98007bcd1ce68a11" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a52ed97184e92138a6e73030c8150e134f0bb680" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;Fixed 1000&lt;/code&gt; will give you a &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; with a resolution of 1000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7adc62b058c0496c81ae2687046d64f2c845f5f6" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;IO&lt;/code&gt; or &lt;code&gt;Either&lt;/code&gt; would be invalid base monads, but &lt;code&gt;Reader&lt;/code&gt; or &lt;code&gt;State&lt;/code&gt; would be acceptable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a47ad65e0c2a3d400457a0b11356459b95bcb1d" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;byteStringThreshold 1024&lt;/code&gt; copies strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose size is less or equal to 1kb, and inserts them directly otherwise. This implies that the average chunk-size of the generated lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; may be as low as 513 bytes, as there could always be just a single byte between the directly inserted 1025 byte, strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">Например, &lt;code&gt;byteStringThreshold 1024&lt;/code&gt; копирует строгие &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; , размер которых меньше или равен 1 КБ, и вставляет их напрямую в противном случае. Это означает, что средний размер блока сгенерированной ленивой &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; может быть всего 513 байтов, так как всегда может быть только один байт между непосредственно вставленными 1025 байтами, строгими &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="6fde4b70734a8fac9093ea2a07235b341112181d" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;f \a -&amp;gt; a b&lt;/code&gt; will be parsed as &lt;code&gt;f (\a -&amp;gt; a b)&lt;/code&gt;, not as &lt;code&gt;f
(\a -&amp;gt; a) b&lt;/code&gt;.</source>
          <target state="translated">Например, &lt;code&gt;f \a -&amp;gt; a b&lt;/code&gt; будет анализироваться как &lt;code&gt;f (\a -&amp;gt; a b)&lt;/code&gt; , а не как &lt;code&gt;f (\a -&amp;gt; a) b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d68c2abf3bd572e6b394677caea8c74a91c6ffaa" translate="yes" xml:space="preserve">
          <source>For example, UTF-8 is an encoding of Unicode characters into a sequence of bytes. The &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; for UTF-8 is &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Например, UTF-8 - это кодирование символов Юникода в последовательность байтов. &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; для UTF-8, &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a131281d0c878473b424da7f5958a8ee1d5ccf4b" translate="yes" xml:space="preserve">
          <source>For example, UTF-8 is an encoding of Unicode characters into a sequence of bytes. The &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; for UTF-8 is &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Например, UTF-8 - это кодирование символов Юникода в последовательность байтов. &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; для UTF-8, &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="025997d25e9ad541ddb4bccc051a89bbfefa2c23" translate="yes" xml:space="preserve">
          <source>For example, a program might have several distinct phases with different performance or resource behaviour in each phase. To properly interpret the profile graph we really want to see when each phase starts and ends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d40901ab3bf757ac476fdd101797decf03e3512" translate="yes" xml:space="preserve">
          <source>For example, a program to print the first 20 integers and their powers of 2 could be written as:</source>
          <target state="translated">Например,программа для печати первых 20 целых чисел и их силы 2 могут быть записаны как:</target>
        </trans-unit>
        <trans-unit id="a9ef3024ea8891eb534acb48c1b294262c997e19" translate="yes" xml:space="preserve">
          <source>For example, a user-defined datatype of trees</source>
          <target state="translated">Например,определяемый пользователем тип дерева данных</target>
        </trans-unit>
        <trans-unit id="744409e78bf68170b982ca29c657867bee8ffa37" translate="yes" xml:space="preserve">
          <source>For example, compiling the following module with GHC:</source>
          <target state="translated">Например,компиляция следующего модуля с GHC:</target>
        </trans-unit>
        <trans-unit id="e6d6e2ba2b5ca72099050bc51954934eb60bffb4" translate="yes" xml:space="preserve">
          <source>For example, consider</source>
          <target state="translated">Например,рассмотрим</target>
        </trans-unit>
        <trans-unit id="7bb345fb3af895621bd1d63c6e6ef0f332232c9b" translate="yes" xml:space="preserve">
          <source>For example, consider a program &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">Например, рассмотрим программу &lt;code&gt;foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c25100ceaa78174d12c46a1aeb9aca894d0c3090" translate="yes" xml:space="preserve">
          <source>For example, consider a type class that is not intended to be used with functions, but the user accidentally used it at a function type, perhaps because they missed an argument to some function. Then, instead of getting the standard GHC message about a missing instance, it would be nicer to emit a more friendly message specific to the EDSL. Similarly, the reduction of a type-level function may get stuck due to an error, at which point it would be nice to report an EDSL specific error, rather than a generic error about an ambiguous type.</source>
          <target state="translated">Например,рассмотрим класс типа,который не предназначен для использования с функциями,но пользователь случайно использовал его на типе функции,возможно,потому,что пропустил аргумент в какой-то функции.Затем,вместо того,чтобы получать стандартное GHC-сообщение об отсутствующем экземпляре,было бы лучше выдать более дружественное сообщение,специфичное для EDSL.Аналогично,сокращение функции уровня типа может застрять из-за ошибки,и в этот момент было бы неплохо сообщить об ошибке,специфичной для EDSL,а не об общей ошибке,связанной с неоднозначным типом.</target>
        </trans-unit>
        <trans-unit id="d37882239b62f8f60c67248b5ef090444ecd46a4" translate="yes" xml:space="preserve">
          <source>For example, consider if you had a macro named &lt;code&gt;:time&lt;/code&gt; and in the shell, typed &lt;code&gt;:t 3&lt;/code&gt; &amp;mdash; what should happen? The current algorithm we use for completing commands is:</source>
          <target state="translated">Например, представьте, есть ли у вас макрос с именем &lt;code&gt;:time&lt;/code&gt; и в оболочке набран &lt;code&gt;:t 3&lt;/code&gt; - что должно произойти? Текущий алгоритм, который мы используем для выполнения команд:</target>
        </trans-unit>
        <trans-unit id="65686db81caecd61279e7eeb51586e09d8ed9938" translate="yes" xml:space="preserve">
          <source>For example, consider the following parallel version of our old nemesis, &lt;code&gt;nfib&lt;/code&gt;:</source>
          <target state="translated">Например, рассмотрим следующую параллельную версию нашего старого заклятого врага, &lt;code&gt;nfib&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="93bbe6300a112cc074a95237a2b5bafd43171b4b" translate="yes" xml:space="preserve">
          <source>For example, consider these definitions (with &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">Например, рассмотрите эти определения (с &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="1e3fcef7520fd5f38bbab6908aface3e182c9e1f" translate="yes" xml:space="preserve">
          <source>For example, consider these definitions (with &lt;a href=&quot;scoped_type_variables#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d42fd5e5b201e8c6886f2c95796540ee28c71bc6" translate="yes" xml:space="preserve">
          <source>For example, given a data type</source>
          <target state="translated">Например,при заданном типе данных</target>
        </trans-unit>
        <trans-unit id="4bdc75c67cb68db483ee29ec3c932f3c07d61e7e" translate="yes" xml:space="preserve">
          <source>For example, given a list of values of some index type, &lt;code&gt;hist&lt;/code&gt; produces a histogram of the number of occurrences of each index within a specified range:</source>
          <target state="translated">Например, учитывая список значений некоторого типа индекса, &lt;code&gt;hist&lt;/code&gt; создает гистограмму количества вхождений каждого индекса в указанном диапазоне:</target>
        </trans-unit>
        <trans-unit id="c355f67c4b8d78811097c4401689f016752e1ba0" translate="yes" xml:space="preserve">
          <source>For example, given a list of values of some index type, hist produces a histogram of the number of occurrences of each index within a specified range:</source>
          <target state="translated">Например,при задании списка значений какого-либо типа индекса,на гистограмме отображается количество вхождений каждого индекса в заданном диапазоне:</target>
        </trans-unit>
        <trans-unit id="1eab4f69e1d74fb57993a017da4c8e140181fdb5" translate="yes" xml:space="preserve">
          <source>For example, given the declarations</source>
          <target state="translated">Например,учитывая заявления</target>
        </trans-unit>
        <trans-unit id="092e743ba03cbd9f10aa95f011412e94dc868f41" translate="yes" xml:space="preserve">
          <source>For example, here is a heap profile produced for the &lt;code&gt;sphere&lt;/code&gt; program from GHC&amp;rsquo;s &lt;code&gt;nofib&lt;/code&gt; benchmark suite,</source>
          <target state="translated">Например, вот профиль кучи, созданный для &lt;code&gt;sphere&lt;/code&gt; программы из &lt;code&gt;nofib&lt;/code&gt; тестов GHC nofib ,</target>
        </trans-unit>
        <trans-unit id="7a34f8af22ee4347fe8ec5e1224bf70e5de3ef73" translate="yes" xml:space="preserve">
          <source>For example, here is how we might implement an &lt;a href=&quot;https://en.wikipedia.org/wiki/Echo_Protocol&quot;&gt;echo server&lt;/a&gt;, using &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; both to listen for client connections on a network socket and to echo client input on client connection handles:</source>
          <target state="translated">Например, вот как мы могли бы реализовать &lt;a href=&quot;https://en.wikipedia.org/wiki/Echo_Protocol&quot;&gt;эхо-сервер&lt;/a&gt; , используя &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; как для прослушивания клиентских подключений в сетевом сокете, так и для отражения клиентского ввода на дескрипторах клиентских подключений:</target>
        </trans-unit>
        <trans-unit id="ee6da42913659645d60841805c91275892b69538" translate="yes" xml:space="preserve">
          <source>For example, if GHC compiles the module &lt;code&gt;A.B.C&lt;/code&gt; in the file &lt;code&gt;src/A/B/C.hs&lt;/code&gt;, with no &lt;code&gt;-odir&lt;/code&gt; or &lt;code&gt;-hidir&lt;/code&gt; flags, the interface file will be put in &lt;code&gt;src/A/B/C.hi&lt;/code&gt; and the object file in &lt;code&gt;src/A/B/C.o&lt;/code&gt;.</source>
          <target state="translated">Например, если GHC компилирует модуль &lt;code&gt;A.B.C&lt;/code&gt; в файле &lt;code&gt;src/A/B/C.hs&lt;/code&gt; , без &lt;code&gt;-odir&lt;/code&gt; или &lt;code&gt;-hidir&lt;/code&gt; , файл интерфейса будет помещен в &lt;code&gt;src/A/B/C.hi&lt;/code&gt; , а объект файл в &lt;code&gt;src/A/B/C.o&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4fd5a35e83d4d92107628f0b0a526842c88f6f3" translate="yes" xml:space="preserve">
          <source>For example, if an interface is lying about the type of an imported value then GHC may well generate duff code for the importing module. &lt;em&gt;This applies to pragmas inside interfaces too!&lt;/em&gt; If the pragma is lying (e.g., about the &amp;ldquo;arity&amp;rdquo; of a value), then duff code may result. Furthermore, arities may change even if types do not.</source>
          <target state="translated">Например, если интерфейс лжет о типе импортируемого значения, тогда GHC вполне может сгенерировать тупой код для модуля импорта. &lt;em&gt;Это относится и к прагмам внутри интерфейсов! &lt;/em&gt;Если прагма лжет (например, о &amp;laquo;арности&amp;raquo; значения), может возникнуть код ошибки. Более того, арности могут измениться, даже если типы не изменятся.</target>
        </trans-unit>
        <trans-unit id="01897242c453eafb4b01262fb63540cca636483f" translate="yes" xml:space="preserve">
          <source>For example, if the following datatype is in scope</source>
          <target state="translated">Например,если в области видимости находится следующий тип данных</target>
        </trans-unit>
        <trans-unit id="feecbb8b0e63385c2814e7a6c80293daa6efef5d" translate="yes" xml:space="preserve">
          <source>For example, if we specify a Haskell library as &lt;code&gt;HSfoo&lt;/code&gt; in the package spec, then the various flavours of library that GHC actually uses will be called:</source>
          <target state="translated">Например, если мы укажем библиотеку Haskell как &lt;code&gt;HSfoo&lt;/code&gt; в спецификации пакета, будут вызываться различные разновидности библиотеки, которые фактически использует GHC:</target>
        </trans-unit>
        <trans-unit id="5aac58398382b1dc4e6fa1f8a176b54c3c8f6891" translate="yes" xml:space="preserve">
          <source>For example, if you are inspecting the core of your program and you observe that &lt;code&gt;foo&lt;/code&gt; is not being inlined. You can pass &lt;code&gt;-dinline-check foo&lt;/code&gt; and you will see a report about why &lt;code&gt;foo&lt;/code&gt; is not inlined.</source>
          <target state="translated">Например, если вы проверяете ядро своей программы и видите, что &lt;code&gt;foo&lt;/code&gt; не встраивается. Вы можете передать &lt;code&gt;-dinline-check foo&lt;/code&gt; , и вы увидите отчет о том, почему &lt;code&gt;foo&lt;/code&gt; не встроен.</target>
        </trans-unit>
        <trans-unit id="b110bc690a93e5b10bf8e0914df1a07ee1433b91" translate="yes" xml:space="preserve">
          <source>For example, in an 80-column terminal with this behavior, the following will print single-spaced instead of double-spaced:</source>
          <target state="translated">Например,в 80-колоночном терминале с таким поведением,вместо двойного пространства будет печататься одноразовое:</target>
        </trans-unit>
        <trans-unit id="6ed162bad590f5003d7d426fd5ae42fa4f804a10" translate="yes" xml:space="preserve">
          <source>For example, in the following program, &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;f'&lt;/code&gt; are equivalent:</source>
          <target state="translated">Например, в следующей программе &lt;code&gt;f&lt;/code&gt; и &lt;code&gt;f'&lt;/code&gt; эквивалентны:</target>
        </trans-unit>
        <trans-unit id="f4f0daf85ba8e99d49b00ae49cc0b4883f326a6b" translate="yes" xml:space="preserve">
          <source>For example, item can be written as:</source>
          <target state="translated">Например,элемент может быть написан как:</target>
        </trans-unit>
        <trans-unit id="23d438828de5a37dbac482cecf3993a3fb389e7b" translate="yes" xml:space="preserve">
          <source>For example, multiple calls to &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; using the same &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; will share the same input history. In constrast, multiple calls to &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputT&quot;&gt;runInputT&lt;/a&gt;&lt;/code&gt; will use distinct histories unless they share the same history file.</source>
          <target state="translated">Например, несколько вызовов &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; с использованием одного и того же &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; будут использовать одну и ту же историю ввода. Напротив, несколько вызовов &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputT&quot;&gt;runInputT&lt;/a&gt;&lt;/code&gt; будут использовать разные истории, если они не используют один и тот же файл истории.</target>
        </trans-unit>
        <trans-unit id="cccb8365a356d9204a1e3e6be4d959bd5de7a6a9" translate="yes" xml:space="preserve">
          <source>For example, one possible application is to reify dictionaries:</source>
          <target state="translated">Например,одним из возможных применений является повторная унификация словарей:</target>
        </trans-unit>
        <trans-unit id="f442cf832dad88fc0e7646f66ee10e0363b7080d" translate="yes" xml:space="preserve">
          <source>For example, remembering that &lt;code&gt;putStrLn :: String -&amp;gt; IO ()&lt;/code&gt;:</source>
          <target state="translated">Например, вспомнив, что &lt;code&gt;putStrLn :: String -&amp;gt; IO ()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d9a2c926ccbb0f9d553917af57bd1f41d6413ed1" translate="yes" xml:space="preserve">
          <source>For example, sometimes you might want to use the following to get the effect of a &amp;ldquo;class synonym&amp;rdquo;:</source>
          <target state="translated">Например, иногда вы можете захотеть использовать следующее, чтобы получить эффект &amp;laquo;синонима класса&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="e5b7402fa6acb4a815984441e87927a1f6479149" translate="yes" xml:space="preserve">
          <source>For example, suppose the search path contains directories &lt;code&gt;d1&lt;/code&gt;, &lt;code&gt;d2&lt;/code&gt;, and &lt;code&gt;d3&lt;/code&gt;, and we are in &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode looking for the source file for a module &lt;code&gt;A.B.C&lt;/code&gt;. GHC will look in &lt;code&gt;d1/A/B/C.hs&lt;/code&gt;, &lt;code&gt;d1/A/B/C.lhs&lt;/code&gt;, &lt;code&gt;d2/A/B/C.hs&lt;/code&gt;, and so on.</source>
          <target state="translated">Например, предположим, что путь поиска содержит каталоги &lt;code&gt;d1&lt;/code&gt; , &lt;code&gt;d2&lt;/code&gt; и &lt;code&gt;d3&lt;/code&gt; , и мы находимся в режиме &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; и&lt;/a&gt; ищем исходный файл для модуля &lt;code&gt;A.B.C&lt;/code&gt; . GHC будет искать в &lt;code&gt;d1/A/B/C.hs&lt;/code&gt; , &lt;code&gt;d1/A/B/C.lhs&lt;/code&gt; , &lt;code&gt;d2/A/B/C.hs&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="bdd681ea0a0383fa82b3cb4fd238264b1f0a0e95" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a string that you want to split on the substring &lt;code&gt;&quot;::&quot;&lt;/code&gt;, such as &lt;code&gt;&quot;foo::bar::quux&quot;&lt;/code&gt;. Instead of searching for the index of &lt;code&gt;&quot;::&quot;&lt;/code&gt; and taking the substrings before and after that index, you would instead use &lt;code&gt;breakOnAll &quot;::&quot;&lt;/code&gt;.</source>
          <target state="translated">Например, предположим, что у вас есть строка, которую вы хотите разбить на подстроку &lt;code&gt;&quot;::&quot;&lt;/code&gt; , например &lt;code&gt;&quot;foo::bar::quux&quot;&lt;/code&gt; . Вместо поиска индекса &lt;code&gt;&quot;::&quot;&lt;/code&gt; и взятия подстрок до и после этого индекса вы бы вместо этого использовали &lt;code&gt;breakOnAll &quot;::&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac114f663d8e987abd5e387676a684751e04a820" translate="yes" xml:space="preserve">
          <source>For example, suppose you want to read a file, but if it doesn't exist then continue as if it contained &quot;&quot;. You might be tempted to just catch all exceptions and return &quot;&quot; in the handler. However, this has all sorts of undesirable consequences. For example, if the user presses control-C at just the right moment then the &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; exception will be caught, and the program will continue running under the belief that the file contains &quot;&quot;. Similarly, if another thread tries to kill the thread reading the file then the &lt;code&gt;&lt;a href=&quot;control-exception#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; exception will be ignored.</source>
          <target state="translated">Например, предположим, что вы хотите прочитать файл, но если он не существует, продолжайте, как если бы он содержал &quot;&quot;. У вас может возникнуть соблазн просто перехватить все исключения и вернуть &quot;&quot; в обработчике. Однако это имеет всевозможные нежелательные последствия. Например, если пользователь нажимает &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; -C в нужный момент, то будет перехвачено исключение UserInterrupt , и программа продолжит работу, полагая, что файл содержит &quot;&quot;. Точно так же, если другой поток пытается убить поток, читающий файл, исключение &lt;code&gt;&lt;a href=&quot;control-exception#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; будет проигнорировано.</target>
        </trans-unit>
        <trans-unit id="2b47a77367f051fe58214e2454bd4b98b948cadb" translate="yes" xml:space="preserve">
          <source>For example, the constructor fields in the following data types</source>
          <target state="translated">Например,поля конструктора в следующих типах данных</target>
        </trans-unit>
        <trans-unit id="7651edd96e5c58d56d08d8f8dadcaee786526668" translate="yes" xml:space="preserve">
          <source>For example, the data types &lt;code&gt;2 * A&lt;/code&gt; and &lt;code&gt;A + A&lt;/code&gt; are isomorphic but some computations are more naturally expressed in terms of one or the other. To get the best of both worlds, we can choose one as our implementation and then provide a set of pattern synonyms so that users can use the other representation if they desire. We can then specify a &lt;code&gt;COMPLETE&lt;/code&gt; pragma in order to inform the pattern match checker that a function which matches on both &lt;code&gt;LeftChoice&lt;/code&gt; and &lt;code&gt;RightChoice&lt;/code&gt; is total.</source>
          <target state="translated">Например, типы данных &lt;code&gt;2 * A&lt;/code&gt; и &lt;code&gt;A + A&lt;/code&gt; изоморфны, но некоторые вычисления более естественно выражаются в терминах одного или другого. Чтобы получить лучшее из обоих миров, мы можем выбрать один в качестве нашей реализации, а затем предоставить набор синонимов шаблонов, чтобы пользователи могли использовать другое представление, если захотят. Затем мы можем указать прагму &lt;code&gt;COMPLETE&lt;/code&gt; , чтобы проинформировать средство проверки совпадения с шаблоном, что функция, которая соответствует как &lt;code&gt;LeftChoice&lt;/code&gt; ,так и &lt;code&gt;RightChoice&lt;/code&gt; , является полной.</target>
        </trans-unit>
        <trans-unit id="ee57ef376af738c0cc39be9b8a3aeffd655a9804" translate="yes" xml:space="preserve">
          <source>For example, the following code is accepted by GHC:</source>
          <target state="translated">Например,следующий код принимается GHC:</target>
        </trans-unit>
        <trans-unit id="ed55721fe5eca931044c06dd74e928c1a9366863" translate="yes" xml:space="preserve">
          <source>For example, the following options will generate a retainer profile restricted to &lt;code&gt;Branch&lt;/code&gt; and &lt;code&gt;Leaf&lt;/code&gt; constructors:</source>
          <target state="translated">Например, следующие параметры создадут профиль фиксатора, ограниченный конструкторами &lt;code&gt;Branch&lt;/code&gt; и &lt;code&gt;Leaf&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e24297250355b4a78eb62d1dc56e97787e232bfc" translate="yes" xml:space="preserve">
          <source>For example, these are okay:</source>
          <target state="translated">Например,это нормально:</target>
        </trans-unit>
        <trans-unit id="15e69e99eeb37907f6273e21ee4ff58bdd61a0ee" translate="yes" xml:space="preserve">
          <source>For example, this code will require a &lt;code&gt;Monad&lt;/code&gt; constraint:</source>
          <target state="translated">Например, для этого кода потребуется ограничение &lt;code&gt;Monad&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="900e1e6015412435fcee921be92977f023f6a57e" translate="yes" xml:space="preserve">
          <source>For example, this instance would make the &lt;code&gt;name&lt;/code&gt; field of &lt;code&gt;Person&lt;/code&gt; accessible using &lt;code&gt;#fullname&lt;/code&gt; as well:</source>
          <target state="translated">Например, этот экземпляр будет сделать &lt;code&gt;name&lt;/code&gt; поля &lt;code&gt;Person&lt;/code&gt; , доступной с помощью &lt;code&gt;#fullname&lt;/code&gt; , а также:</target>
        </trans-unit>
        <trans-unit id="47bbb9c1056126a12b9da3b641c5bfc651a0ba80" translate="yes" xml:space="preserve">
          <source>For example, this returns the value of &lt;code&gt;f x&lt;/code&gt; but first outputs the message.</source>
          <target state="translated">Например, это возвращает значение &lt;code&gt;f x&lt;/code&gt; но сначала выводит сообщение.</target>
        </trans-unit>
        <trans-unit id="225929f65a69a76a61aa35be9e43fc3fd618afeb" translate="yes" xml:space="preserve">
          <source>For example, this:</source>
          <target state="translated">Например,это:</target>
        </trans-unit>
        <trans-unit id="9016b1102f311501fac46c1e7eecc35288f12dcc" translate="yes" xml:space="preserve">
          <source>For example, to enable the FFI and preprocessing with CPP:</source>
          <target state="translated">Например,для включения FFI и препроцессирования с помощью CPP:</target>
        </trans-unit>
        <trans-unit id="26497d08a388e4d2412b7f1fab7c57d63571afa3" translate="yes" xml:space="preserve">
          <source>For example, to execute a simple &lt;code&gt;ls&lt;/code&gt; command:</source>
          <target state="translated">Например, чтобы выполнить простую команду &lt;code&gt;ls&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a3311a9da6750dc8b9fba90d3be35024a5d05bc0" translate="yes" xml:space="preserve">
          <source>For example, to link a program consisting of objects &lt;code&gt;Foo.o&lt;/code&gt; and &lt;code&gt;Main.o&lt;/code&gt;, where we made use of the &lt;code&gt;network&lt;/code&gt; package, we need to give GHC the &lt;code&gt;-package&lt;/code&gt; flag thus:</source>
          <target state="translated">Например, чтобы связать программу, состоящую из объектов &lt;code&gt;Foo.o&lt;/code&gt; и &lt;code&gt;Main.o&lt;/code&gt; , в которой мы использовали &lt;code&gt;network&lt;/code&gt; пакет, нам нужно указать GHC флаг &lt;code&gt;-package&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="275c801d323aafd23c71b3f1fd4a2ba975854334" translate="yes" xml:space="preserve">
          <source>For example, to load and run a Haskell program containing a module &lt;code&gt;Main&lt;/code&gt;, we might say:</source>
          <target state="translated">Например, чтобы загрузить и запустить программу Haskell, содержащую модуль &lt;code&gt;Main&lt;/code&gt; , можно сказать:</target>
        </trans-unit>
        <trans-unit id="24c8dec48e12a5f61c3e7a6ffbc6374c90c7019e" translate="yes" xml:space="preserve">
          <source>For example, to parse a date in YYYY-MM-DD format, while allowing the month and date to have optional leading zeros (notice the &lt;code&gt;-&lt;/code&gt; modifier used for &lt;code&gt;%m&lt;/code&gt; and &lt;code&gt;%d&lt;/code&gt;):</source>
          <target state="translated">Например, чтобы проанализировать дату в формате ГГГГ-ММ-ДД, разрешив месяц и дату иметь необязательные ведущие нули (обратите внимание на модификатор &lt;code&gt;-&lt;/code&gt; , используемый для &lt;code&gt;%m&lt;/code&gt; и &lt;code&gt;%d&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="76f9ac11e3675b26b9adf85da24c93afef2ec32c" translate="yes" xml:space="preserve">
          <source>For example, to start a process and feed a string to its stdin:</source>
          <target state="translated">Например,для запуска процесса и подачи строки на его stdin:</target>
        </trans-unit>
        <trans-unit id="5fcd1945807a0dc794011bc0d68f612088c3c98d" translate="yes" xml:space="preserve">
          <source>For example, to tokenise a string, dropping delimiters:</source>
          <target state="translated">Например,для токенирования строки,бросая разделители:</target>
        </trans-unit>
        <trans-unit id="e8a9d355c1624f157a17b017f14330568fefc5e8" translate="yes" xml:space="preserve">
          <source>For example, we can write the factorial function using direct recursion as</source>
          <target state="translated">Например,мы можем написать факториальную функцию,используя прямую рекурсию как</target>
        </trans-unit>
        <trans-unit id="c57a91fc90c21d96ad621001af54d878ab863159" translate="yes" xml:space="preserve">
          <source>For example, when &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;(:)&lt;/code&gt;, all three cases return an immediate value, respectively &lt;code&gt;z&lt;/code&gt; or a &lt;em&gt;cons cell&lt;/em&gt; holding &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;l&lt;/code&gt;, with the remainder the structure, if any, encapsulated in a lazy thunk. This meets the expected efficient &lt;a href=&quot;#corec&quot;&gt;corecursive&lt;/a&gt; behaviour of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd38bf999f51a8e6ab980a4cc02677fcbb4c986c" translate="yes" xml:space="preserve">
          <source>For example, when compiling module A, you can only run Template Haskell functions imported from B if B does not import A (directly or indirectly). The reason should be clear: to run B we must compile and run A, but we are currently type-checking A.</source>
          <target state="translated">Например,при компиляции модуля A,вы можете запускать функции Template Haskell,импортируемые из B,только в том случае,если B не импортирует A (прямо или косвенно).Причина должна быть ясна:чтобы запустить B,мы должны скомпилировать и запустить A,но в настоящее время мы проверяем тип A.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="17c57644c0265103527c3af40403358dc202cd31" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;&amp;hellip;warning: \`Foo' declared \`static' but never
defined.&lt;/code&gt; Unsightly, but shouldn&amp;rsquo;t be a problem.</source>
          <target state="translated">Например: &lt;code&gt;&amp;hellip;warning: \`Foo' declared \`static' but never defined.&lt;/code&gt; Некрасиво, но не должно быть проблемой.</target>
        </trans-unit>
        <trans-unit id="476b28066e3c89df50c21f73368a0e01098fb0aa" translate="yes" xml:space="preserve">
          <source>For four-part GHC version numbers &lt;code&gt;x.y.z.z'&lt;/code&gt;, the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; is the integer ⟨z⟩ while the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL2__&lt;/code&gt; is set to the integer ⟨z&amp;rsquo;⟩.</source>
          <target state="translated">Для четырехчастных номеров версий GHC &lt;code&gt;x.y.z.z'&lt;/code&gt; значение &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; представляет собой целое число ⟨z⟩, а значение &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL2__&lt;/code&gt; устанавливается равным целому числу z'⟩.</target>
        </trans-unit>
        <trans-unit id="ebd87276392f86aa606645575def965bf344530d" translate="yes" xml:space="preserve">
          <source>For full details on injective type families refer to Haskell Symposium 2015 paper &lt;a href=&quot;http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf&quot;&gt;Injective type families for Haskell&lt;/a&gt;.</source>
          <target state="translated">Полную информацию о семействах инъективных типов см. В статье на симпозиуме Haskell Symposium 2015 г. &lt;a href=&quot;http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf&quot;&gt;Семейства&lt;/a&gt; инъективных типов для Haskell .</target>
        </trans-unit>
        <trans-unit id="01178e47382bdc6446961872841b23fc4c45fd85" translate="yes" xml:space="preserve">
          <source>For hidden packages, however, you need to request the package be loaded by using the &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; flag:</source>
          <target state="translated">Однако для скрытых пакетов вам необходимо запросить загрузку пакета с помощью флага &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b3a5c6fd42825560c95317b78e19114644f5b7ff" translate="yes" xml:space="preserve">
          <source>For historical reasons, the preserved values are /&lt;em&gt;not&lt;/em&gt;/ forced. To force them, use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:preserveMissing-39-&quot;&gt;preserveMissing'&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">По историческим причинам сохраненные значения принудительно / &lt;em&gt;не&lt;/em&gt; / принудительно. Чтобы заставить их использовать &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:preserveMissing-39-&quot;&gt;preserveMissing'&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75f8792d57e48a774641d9734879dcb766f223ec" translate="yes" xml:space="preserve">
          <source>For infinite structures, &lt;code&gt;&lt;a href=&quot;data-foldable#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; terminates if the value exists at a finite distance from the left side of the structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="462ce6044e470f38fd8877b9aec9d317b89c01cb" translate="yes" xml:space="preserve">
          <source>For infinite structures, &lt;code&gt;&lt;a href=&quot;data-list#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; terminates if the value exists at a finite distance from the left side of the structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1265e702058729814c9070a553091ab6668e71f9" translate="yes" xml:space="preserve">
          <source>For infinite structures, &lt;code&gt;&lt;a href=&quot;prelude#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; terminates if the value exists at a finite distance from the left side of the structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b4e1b52d9313f4a64b67c682815f36e8dd1565" translate="yes" xml:space="preserve">
          <source>For infinite structures, the default implementation of &lt;code&gt;&lt;a href=&quot;data-foldable#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; terminates if the sought-after value exists at a finite distance from the left side of the structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4930b164ff12550352bb2ae49b0f3eafab2481e2" translate="yes" xml:space="preserve">
          <source>For infinite structures, the default implementation of &lt;code&gt;&lt;a href=&quot;data-list#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; terminates if the sought-after value exists at a finite distance from the left side of the structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ce546ec8413f6538f8a26e19ca0ec25047ae9e5" translate="yes" xml:space="preserve">
          <source>For infinite structures, the default implementation of &lt;code&gt;&lt;a href=&quot;prelude#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; terminates if the sought-after value exists at a finite distance from the left side of the structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c30b64ae65331781837d75efd9f6decbae446e0c" translate="yes" xml:space="preserve">
          <source>For information on what bound threads are, see the documentation for the &lt;a href=&quot;../../libraries/base-4.15.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="2937ae469e44a6da2ea2b9c7c56013ccc4d03ea5" translate="yes" xml:space="preserve">
          <source>For instance, a simple profile might look like this,</source>
          <target state="translated">Например,простой профиль может выглядеть так,</target>
        </trans-unit>
        <trans-unit id="2df4182fc612ce7805e7516eb9a2b62d1493ffae" translate="yes" xml:space="preserve">
          <source>For instance, if you had the following type family:</source>
          <target state="translated">Например,если бы у вас была следующая семья:</target>
        </trans-unit>
        <trans-unit id="ce40606b41f00effc4c8dc141b9ea10bdc0fc070" translate="yes" xml:space="preserve">
          <source>For instance, running a program with &lt;code&gt;+RTS -h -p -pohello-world&lt;/code&gt; would produce a heap profile named &lt;code&gt;hello-world.hp&lt;/code&gt; and a cost-centre profile named &lt;code&gt;hello-world.prof&lt;/code&gt;.</source>
          <target state="translated">Например, запуск программы с &lt;code&gt;+RTS -h -p -pohello-world&lt;/code&gt; приведет к созданию профиля кучи с именем &lt;code&gt;hello-world.hp&lt;/code&gt; и профиля центра затрат с именем &lt;code&gt;hello-world.prof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dea0253ba024112a72eb14c4873c0ade6c78487c" translate="yes" xml:space="preserve">
          <source>For instance, take the example of &lt;code&gt;-fno-specialise -O1&lt;/code&gt;. Despite the &lt;code&gt;-fno-specialise&lt;/code&gt; appearing in the command line, specialisation will still be enabled. This is the case as &lt;code&gt;-O1&lt;/code&gt; implies &lt;code&gt;-fspecialise&lt;/code&gt;, overriding the previous flag. By contrast, &lt;code&gt;-O1 -fno-specialise&lt;/code&gt; will compile without specialisation, as one would expect.</source>
          <target state="translated">Например, возьмем пример &lt;code&gt;-fno-specialise -O1&lt;/code&gt; . Несмотря на &lt;code&gt;-fno-specialise&lt;/code&gt; в командной строке отображается -fno-specialize , специализация все равно будет включена. Это тот случай , когда &lt;code&gt;-O1&lt;/code&gt; подразумевает &lt;code&gt;-fspecialise&lt;/code&gt; , перекрывая предыдущий флаг. Напротив, &lt;code&gt;-O1 -fno-specialise&lt;/code&gt; будет компилироваться без специализации, как и следовало ожидать.</target>
        </trans-unit>
        <trans-unit id="a6868e1fb2efeb3425d8a627bfc9d0ba2d117c39" translate="yes" xml:space="preserve">
          <source>For instance, the first wildcard in the type signature &lt;code&gt;not'&lt;/code&gt; would produce the following error message:</source>
          <target state="translated">Например, первый подстановочный знак в сигнатуре типа &lt;code&gt;not'&lt;/code&gt; вызовет следующее сообщение об ошибке:</target>
        </trans-unit>
        <trans-unit id="958aeaf1ba8d61f0734b35c84475403f19531d00" translate="yes" xml:space="preserve">
          <source>For instance, we might use this interface to provide a more useful error message for applications of &lt;code&gt;show&lt;/code&gt; on unsaturated functions like this,</source>
          <target state="translated">Например, мы могли бы использовать этот интерфейс, чтобы предоставить более полезное сообщение об ошибке для приложений &lt;code&gt;show&lt;/code&gt; на ненасыщенных функциях, подобных этой,</target>
        </trans-unit>
        <trans-unit id="be75888101f27133692a26f5d016cfc15af97616" translate="yes" xml:space="preserve">
          <source>For lists we get the natural order of effects by using &lt;strong&gt;&lt;code&gt;(prepend &amp;lt;$&amp;gt; f a)&lt;/code&gt;&lt;/strong&gt; as the operator and &lt;strong&gt;&lt;code&gt;(traverse f as)&lt;/code&gt;&lt;/strong&gt; as the operand (the actual definition is written as an equivalent right fold in order to enable &lt;em&gt;fusion&lt;/em&gt; rules):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e819cf0fe0a721d8aa2edb789360b689a7c6df8a" translate="yes" xml:space="preserve">
          <source>For lists, &lt;code&gt;&lt;a href=&quot;data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; is the identity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd75721614a832379340eb5515b1192ef0f86e97" translate="yes" xml:space="preserve">
          <source>For many structures reasonably efficient &lt;code&gt;Foldable&lt;/code&gt; instances can be derived automatically, by enabling the &lt;code&gt;DeriveFoldable&lt;/code&gt; GHC extension. When this works, it is generally not necessary to define a custom instance by hand. Though in some cases one may be able to get slightly faster hand-tuned code, care is required to avoid producing slower code, or code that is not sufficiently lazy, strict or &lt;em&gt;lawful&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2512d10fb7fc1b9dbc0084916fcb3b49c0227bdb" translate="yes" xml:space="preserve">
          <source>For many years the type of a quotation was fixed to be `Q Exp` but by more precisely specifying the minimal interface it enables the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Exp&quot;&gt;Exp&lt;/a&gt;&lt;/code&gt; to be extracted purely from the quotation without interacting with &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15ee88f85580b5f1cfacfb67956f3e66087a0c8d" translate="yes" xml:space="preserve">
          <source>For many years the type of a quotation was fixed to be `Q Exp` but by more precisely specifying the minimal interface it enables the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Exp&quot;&gt;Exp&lt;/a&gt;&lt;/code&gt; to be extracted purely from the quotation without interacting with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="529b0aa96caf3e90c0267b32ba2bc9db119509d3" translate="yes" xml:space="preserve">
          <source>For monads that do belong to the &lt;code&gt;MonadFix&lt;/code&gt; class, GHC provides an extended version of the do-notation that allows recursive bindings. The &lt;a href=&quot;#extension-RecursiveDo&quot;&gt;&lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/a&gt; (language pragma: &lt;code&gt;RecursiveDo&lt;/code&gt;) provides the necessary syntactic support, introducing the keywords &lt;code&gt;mdo&lt;/code&gt; and &lt;code&gt;rec&lt;/code&gt; for higher and lower levels of the notation respectively. Unlike bindings in a &lt;code&gt;do&lt;/code&gt; expression, those introduced by &lt;code&gt;mdo&lt;/code&gt; and &lt;code&gt;rec&lt;/code&gt; are recursively defined, much like in an ordinary let-expression. Due to the new keyword &lt;code&gt;mdo&lt;/code&gt;, we also call this notation the &lt;em&gt;mdo-notation&lt;/em&gt;.</source>
          <target state="translated">Для монад, принадлежащих классу &lt;code&gt;MonadFix&lt;/code&gt; , GHC предоставляет расширенную версию do-notation, которая допускает рекурсивные привязки. &lt;a href=&quot;#extension-RecursiveDo&quot;&gt; &lt;code&gt;RecursiveDo&lt;/code&gt; &lt;/a&gt; (язык прагма: &lt;code&gt;RecursiveDo&lt;/code&gt; ) обеспечивает необходимую поддержку синтаксической, вводя ключевые слова &lt;code&gt;mdo&lt;/code&gt; и &lt;code&gt;rec&lt;/code&gt; для более высоких и более низких уровней обозначений соответственно. В отличие от привязок в выражении &lt;code&gt;do&lt;/code&gt; , привязки , вводимые &lt;code&gt;mdo&lt;/code&gt; и &lt;code&gt;rec&lt;/code&gt; , определяются рекурсивно, как и в обычном let-выражении. Из-за нового ключевого слова &lt;code&gt;mdo&lt;/code&gt; мы также называем эту запись &lt;em&gt;mdo-notation&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="aadaa664cff3605a3ecf9e7a3dabf2341d6ea100" translate="yes" xml:space="preserve">
          <source>For more details about this feature, please refer to &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf&quot;&gt;Safe Coercions&lt;/a&gt; by Joachim Breitner, Richard A. Eisenberg, Simon Peyton Jones and Stephanie Weirich.</source>
          <target state="translated">Для получения дополнительных сведений об этой функции см. &amp;laquo; &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf&quot;&gt;Безопасное принуждение&lt;/a&gt; &amp;raquo; Иоахима Брайтнера, Ричарда А. Айзенберга, Саймона Пейтона Джонса и Стефани Вейрих.</target>
        </trans-unit>
        <trans-unit id="8f223131e45f78084be7dce3cc5c1c0ae03a548a" translate="yes" xml:space="preserve">
          <source>For more details on the implementation see the Paper: &amp;ldquo;Extending the Haskell Foreign Function Interface with Concurrency&amp;rdquo;. Last known to be accessible &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2004/09/conc-ffi.pdf&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a68e78d61b7ecc371a39ec450b9f0dee51b088" translate="yes" xml:space="preserve">
          <source>For more details please refer to the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id100&quot;&gt;[Generics2010]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddd7518e52d21c45b5c0164d5371d0d7f78e6094" translate="yes" xml:space="preserve">
          <source>For more details please refer to the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id98&quot;&gt;[Generics2010]&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительных сведений обратитесь к &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;странице Haskell Wiki&lt;/a&gt; или в исходной статье &lt;a href=&quot;#generics2010&quot; id=&quot;id98&quot;&gt;[Generics2010]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b72896971c07169fb5840e32ce47aee311c5c705" translate="yes" xml:space="preserve">
          <source>For more details please refer to the &lt;a href=&quot;https://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id2&quot;&gt;[Generics2010]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68f5a6bc7d7f62ba632eabd939ff41eed834fc73" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;http://www.soi.city.ac.uk/~ross/papers/Applicative.html&quot;&gt;Applicative Programming with Effects&lt;/a&gt;, by Conor McBride and Ross Paterson.</source>
          <target state="translated">Дополнительные сведения см. В разделе &amp;laquo; &lt;a href=&quot;http://www.soi.city.ac.uk/~ross/papers/Applicative.html&quot;&gt;Аппликативное программирование с эффектами&lt;/a&gt; &amp;raquo; Конора Макбрайда и Росс Патерсон.</target>
        </trans-unit>
        <trans-unit id="60fb5a666c6a0eaff8450effcf1a6d5878676b82" translate="yes" xml:space="preserve">
          <source>For more details, see documentation of &lt;code&gt;posix_fadvise(2)&lt;/code&gt;.</source>
          <target state="translated">Для получения дополнительной информации см. Документацию &lt;code&gt;posix_fadvise(2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f151a8de0b0ae047ee77db2f883d4d612f14350" translate="yes" xml:space="preserve">
          <source>For more information about the debug information produced by GHC see Peter Wortmann&amp;rsquo;s PhD thesis, &lt;a href=&quot;http://etheses.whiterose.ac.uk/8321/&quot;&gt;*Profiling Optimized Haskell: Causal Analysis and Implementation*&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации об отладочной информации, производимой GHC, см. Докторскую диссертацию Питера Вортмана, &lt;a href=&quot;http://etheses.whiterose.ac.uk/8321/&quot;&gt;* Профилирование оптимизированного Haskell: причинный анализ и реализация *&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da91b931841e7893478b07acb85bd4ccd0928c7e" translate="yes" xml:space="preserve">
          <source>For more information about this type's representation, see the comments in its implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8560ce11100cb4fa01d3828472236f160a993060" translate="yes" xml:space="preserve">
          <source>For more information on ticky-ticky profiling, see &lt;a href=&quot;profiling#ticky-ticky&quot;&gt;Using &amp;ldquo;ticky-ticky&amp;rdquo; profiling (for implementors)&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации о тикающем профилировании см. &lt;a href=&quot;profiling#ticky-ticky&quot;&gt;Использование тикающего профилирования (для разработчиков)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90f12f7b9c44042f6fe71df1a74617adb00702bb" translate="yes" xml:space="preserve">
          <source>For more information on using the API, as well as more samples and references, please see &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;this Haskell.org wiki page&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации об использовании API, а также дополнительных примеров и ссылок, пожалуйста, посетите &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;эту вики-страницу Haskell.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="586a78695eb0609dc531b936f637d0814cfd2fee" translate="yes" xml:space="preserve">
          <source>For more information on using the API, as well as more samples and references, please see &lt;a href=&quot;https://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;this Haskell.org wiki page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ef63ab6766f7302158ada5c6e4dcb9f048e311" translate="yes" xml:space="preserve">
          <source>For more information you can refer to the &lt;a href=&quot;http://belle.sourceforge.net/doc/hughes95design.pdf&quot;&gt;original paper&lt;/a&gt; that serves as the basis for this libraries design: /The Design of a Pretty-printing Library/ by John Hughes, in Advanced Functional Programming, 1995.</source>
          <target state="translated">Для получения дополнительной информации вы можете обратиться к &lt;a href=&quot;http://belle.sourceforge.net/doc/hughes95design.pdf&quot;&gt;исходному документу,&lt;/a&gt; который служит основой для дизайна этой библиотеки: / The Design of a Pretty-Printing Library / John Hughes, in Advanced Functional Programming, 1995.</target>
        </trans-unit>
        <trans-unit id="c0bed00e62b5493248939b4aa33a94f717129c1a" translate="yes" xml:space="preserve">
          <source>For more information, please visit the new SYB wiki: &lt;a href=&quot;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&quot;&gt;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации посетите новую вики-страницу SYB: &lt;a href=&quot;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&quot;&gt;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11f58187631ea148f4d89e652dfc9bc68f732d9a" translate="yes" xml:space="preserve">
          <source>For more information, refer to the documentation for the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">Дополнительные сведения см. В документации по классу &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3bff78a356bfb09cb0493c71dac3667a53fc420" translate="yes" xml:space="preserve">
          <source>For more information, refer to the documentation for the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class. @since 4.9.0.0</source>
          <target state="translated">Дополнительные сведения см. В документации по классу &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; . @since 4.9.0.0</target>
        </trans-unit>
        <trans-unit id="8573bf99480b0bd0d6d5a2fda62633bf25a04224" translate="yes" xml:space="preserve">
          <source>For more motivation and details please refer to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/DeferErrorsToRuntime&quot;&gt;Wiki&lt;/a&gt; page or the &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;original paper&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной мотивации и подробностей см. Страницу &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/DeferErrorsToRuntime&quot;&gt;Wiki&lt;/a&gt; или &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;исходный документ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53c2c97747aa9fe39ba73a8b92072d90e3a4f755" translate="yes" xml:space="preserve">
          <source>For more motivation and details please refer to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/defer-errors-to-runtime&quot;&gt;Wiki&lt;/a&gt; page or the &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;original paper&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b784e8618e297958090335defe46f4624f38965b" translate="yes" xml:space="preserve">
          <source>For most application, it should suffice to instead use the following &lt;code&gt;Settings&lt;/code&gt; flags:</source>
          <target state="translated">Для большинства приложений вместо этого должно быть достаточно использовать следующие флаги &lt;code&gt;Settings&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ff5273016b7cb616c8b49961a6a41e99d096cb1a" translate="yes" xml:space="preserve">
          <source>For most applications (e.g., a REPL), &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; should have the correct effect.</source>
          <target state="translated">Для большинства приложений (например, REPL) &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; должен иметь правильный эффект.</target>
        </trans-unit>
        <trans-unit id="311f2e122e6dc16e2237dcd6b98b5829a7cc728a" translate="yes" xml:space="preserve">
          <source>For most array types, this operation is O(&lt;em&gt;n&lt;/em&gt;) where &lt;em&gt;n&lt;/em&gt; is the size of the array. However, the diffarray package provides an array type for which this operation has complexity linear in the number of updates.</source>
          <target state="translated">Для большинства типов массивов эта операция - O ( &lt;em&gt;n&lt;/em&gt; ), где &lt;em&gt;n&lt;/em&gt; - размер массива. Однако пакет diffarray предоставляет тип массива, для которого эта операция имеет сложность, линейную по количеству обновлений.</target>
        </trans-unit>
        <trans-unit id="4b9cb8cf6aa6594114627e9c8f2d2cd6fbe2360a" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">Для большинства типов будет использоваться определение по умолчанию для &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; , но функция включена в определение класса, так что оптимизированная версия может быть предоставлена ​​для определенных типов.</target>
        </trans-unit>
        <trans-unit id="25d34b5c0599445985c48feed3e52ab547a8c854" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;ghc-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">Для большинства типов будет использоваться определение по умолчанию для &lt;code&gt;&lt;a href=&quot;ghc-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; , но функция включена в определение класса, так что оптимизированная версия может быть предоставлена ​​для определенных типов.</target>
        </trans-unit>
        <trans-unit id="afe02a91645487a5cca5e4dc2b2da47de7589838" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">Для большинства типов будет использоваться определение по умолчанию для &lt;code&gt;&lt;a href=&quot;prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; , но функция включена в определение класса, так что оптимизированная версия может быть предоставлена ​​для определенных типов.</target>
        </trans-unit>
        <trans-unit id="6484245051d629100f2583ede948c431b601c733" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">Для большинства типов будет использоваться определение по умолчанию для &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; , но функция включена в определение класса, так что оптимизированная версия может быть предоставлена ​​для определенных типов.</target>
        </trans-unit>
        <trans-unit id="fe6e0410468523c927a0d7a9f8ddef7668228bfb" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">Для большинства типов будет использоваться определение по умолчанию для &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; , но функция включена в определение класса, так что оптимизированная версия может быть предоставлена ​​для определенных типов.</target>
        </trans-unit>
        <trans-unit id="aa070a0116630a05d217085a9df4b403160dd6f8" translate="yes" xml:space="preserve">
          <source>For nested &lt;code&gt;foralls&lt;/code&gt;, e.g.</source>
          <target state="translated">Для вложенных &lt;code&gt;foralls&lt;/code&gt; , например</target>
        </trans-unit>
        <trans-unit id="458047bcd2a4d374f9800d54638670eed4df239c" translate="yes" xml:space="preserve">
          <source>For newtypes, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt; and &lt;code&gt;Bounded&lt;/code&gt; are always derived using the &lt;code&gt;newtype&lt;/code&gt; strategy, even without &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; enabled. (There should be no observable difference to instances derived using the stock strategy.)</source>
          <target state="translated">Для новых типов &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Ix&lt;/code&gt; и &lt;code&gt;Bounded&lt;/code&gt; всегда выводятся с использованием стратегии &lt;code&gt;newtype&lt;/code&gt; , даже если не включен &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; . (Не должно быть заметных отличий от экземпляров, полученных с использованием стратегии акций.)</target>
        </trans-unit>
        <trans-unit id="4694f0c96ed1c1078475be69652119149e496dc9" translate="yes" xml:space="preserve">
          <source>For non-essential files (e.g. cache). It uses the &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.cache&lt;/code&gt;. On Windows, the default is &lt;code&gt;%LOCALAPPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Local&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/var/cache&lt;/code&gt;.</source>
          <target state="translated">Для несущественных файлов (например, кеша). Он использует переменную среды &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; . В системах, отличных от Windows, по умолчанию используется &lt;code&gt;~/.cache&lt;/code&gt; . В Windows по умолчанию используется &lt;code&gt;%LOCALAPPDATA%&lt;/code&gt; (например, &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Local&lt;/code&gt; ). Может рассматриваться как пользовательский эквивалент &lt;code&gt;/var/cache&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bb8c51cac0d107dff7666d44f386ca6ef354c70" translate="yes" xml:space="preserve">
          <source>For non-portable support of Haskell finalizers, see the &lt;a href=&quot;foreign-concurrent&quot;&gt;Foreign.Concurrent&lt;/a&gt; module.</source>
          <target state="translated">Для &lt;a href=&quot;foreign-concurrent&quot;&gt;непереносимой&lt;/a&gt; поддержки финализаторов Haskell см. Модуль Foreign.Concurrent .</target>
        </trans-unit>
        <trans-unit id="3383003efe56493c3ba8ee51d572a1bd3e32533a" translate="yes" xml:space="preserve">
          <source>For now, this module is the API for working with type-level literals. However, please note that it is a work in progress and is subject to change. Once the design of the &lt;code&gt;DataKinds&lt;/code&gt; feature is more stable, this will be considered only an internal GHC module, and the programmer interface for working with type-level data will be defined in a separate library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b56c18b23f9ecb1cf4345cdf08508ff77d0dd4" translate="yes" xml:space="preserve">
          <source>For open and closed type families it is OK to name the result but skip the injectivity annotation. This is not the case for associated type synonyms, where the named result without injectivity annotation will be interpreted as associated type synonym default.</source>
          <target state="translated">Для семейств открытого и закрытого типа можно назвать результат,но пропустить аннотацию о приёмистости.Это не относится к синонимам ассоциированных типов,где именованный результат без аннотации приёма будет интерпретироваться как синоним ассоциированного типа по умолчанию.</target>
        </trans-unit>
        <trans-unit id="37dc725ee9dc508be5d616956f4278bb5bbb1e54" translate="yes" xml:space="preserve">
          <source>For other any type class:</source>
          <target state="translated">Для других классов любого типа:</target>
        </trans-unit>
        <trans-unit id="8992b141ebf84616833ad66b803c7e3a3842868f" translate="yes" xml:space="preserve">
          <source>For other documentation, refer to: &lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http://www.haskell.org/haskellwiki/Template_Haskell&lt;/a&gt;</source>
          <target state="translated">Для получения другой документации посетите: &lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http://www.haskell.org/haskellwiki/Template_Haskell&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91b1fc2b5558fcebb47a9cb90615ec89658550a4" translate="yes" xml:space="preserve">
          <source>For other documentation, refer to: &lt;a href=&quot;https://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http://www.haskell.org/haskellwiki/Template_Haskell&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f140c5422fa14edb971c7e4308e840e46380100" translate="yes" xml:space="preserve">
          <source>For part 1, we define a class &lt;code&gt;Encode'&lt;/code&gt;. Perhaps surprisingly, this class is parameterized over a type constructor &lt;code&gt;f&lt;/code&gt; of kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt;. This is a technicality: all the representation type constructors operate with kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt; as base kind. But the type argument is never being used. This may be changed at some point in the future. The class has a single method, and we use the type we want our final function to have, but we replace the occurrences of the generic type argument &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;f p&lt;/code&gt; (where the &lt;code&gt;p&lt;/code&gt; is any argument; it will not be used).</source>
          <target state="translated">Для части 1 мы определяем класс &lt;code&gt;Encode'&lt;/code&gt; . Возможно, удивительно, что этот класс параметризуется конструктором типа &lt;code&gt;f&lt;/code&gt; вида &lt;code&gt;* -&amp;gt; *&lt;/code&gt; . Это техническая особенность: все конструкторы типов представления работают с типом &lt;code&gt;* -&amp;gt; *&lt;/code&gt; качестве базового типа. Но аргумент типа никогда не используется. Это может быть изменено в какой-то момент в будущем. У класса есть единственный метод, и мы используем тип, который должен иметь наша последняя функция, но мы заменяем вхождения аргумента универсального типа &lt;code&gt;a&lt;/code&gt; на &lt;code&gt;f p&lt;/code&gt; (где &lt;code&gt;p&lt;/code&gt; - это любой аргумент; он не будет использоваться).</target>
        </trans-unit>
        <trans-unit id="f87b5de1b3b5f32164f5ee5dc4fb8f8f96f8dc64" translate="yes" xml:space="preserve">
          <source>For real numbers, the &lt;code&gt;&lt;a href=&quot;ghc-num#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;-1&lt;/code&gt; (negative), &lt;code&gt;0&lt;/code&gt; (zero) or &lt;code&gt;1&lt;/code&gt; (positive).</source>
          <target state="translated">Для действительных чисел &lt;code&gt;&lt;a href=&quot;ghc-num#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; равно &lt;code&gt;-1&lt;/code&gt; (отрицательное значение), &lt;code&gt;0&lt;/code&gt; (ноль) или &lt;code&gt;1&lt;/code&gt; (положительное значение).</target>
        </trans-unit>
        <trans-unit id="9e94d05b9e837b15d27a9fea860bba07c986003d" translate="yes" xml:space="preserve">
          <source>For real numbers, the &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;-1&lt;/code&gt; (negative), &lt;code&gt;0&lt;/code&gt; (zero) or &lt;code&gt;1&lt;/code&gt; (positive).</source>
          <target state="translated">Для действительных чисел &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; равно &lt;code&gt;-1&lt;/code&gt; (отрицательное значение), &lt;code&gt;0&lt;/code&gt; (ноль) или &lt;code&gt;1&lt;/code&gt; (положительное значение).</target>
        </trans-unit>
        <trans-unit id="378724e14b1bb63abfcba6089e6f23a18b0dbb9a" translate="yes" xml:space="preserve">
          <source>For records with many fields, it can be tiresome to write out each field individually in a record pattern, as in</source>
          <target state="translated">Для записей с большим количеством полей может быть утомительно записывать каждое поле по отдельности в схеме записи,как в случае с</target>
        </trans-unit>
        <trans-unit id="7aac7c40c3604036ed41bcd7832a5e3d3aad7a7a" translate="yes" xml:space="preserve">
          <source>For single-constructor datatypes, the derived instance declarations are as shown for tuples in chapter 19, section 2 of the Haskell 2010 report: &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&lt;/a&gt;.</source>
          <target state="translated">Для типов данных с одним конструктором объявления производных экземпляров показаны для кортежей в разделе 2 главы 19 отчета Haskell 2010: &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd08981965b6a477e0c93e10e8a2c46079dd7254" translate="yes" xml:space="preserve">
          <source>For some reason, Mingw ships with the &lt;code&gt;readline&lt;/code&gt; library, but not with the &lt;code&gt;readline&lt;/code&gt; headers. As a result, GHC (like Hugs) does not use &lt;code&gt;readline&lt;/code&gt; for interactive input on Windows. You can get a close simulation by using an emacs shell buffer!</source>
          <target state="translated">По какой-то причине Mingw поставляется с библиотекой &lt;code&gt;readline&lt;/code&gt; , но не с заголовками &lt;code&gt;readline&lt;/code&gt; . В результате GHC (как и Hugs) не использует &lt;code&gt;readline&lt;/code&gt; для интерактивного ввода в Windows. Вы можете получить точную симуляцию, используя буфер оболочки emacs!</target>
        </trans-unit>
        <trans-unit id="c3d65c0e9a2a6354ca7a3aa3f79014b97e396ace" translate="yes" xml:space="preserve">
          <source>For some special use cases you may want more control over which events are included. The ⟨flags⟩ is a sequence of zero or more characters indicating which classes of events to log. Currently these the classes of events that can be enabled/disabled:</source>
          <target state="translated">Для некоторых особых случаев использования вы можете захотеть больше контроля над тем,какие события включены.⟨flags⟩-это последовательность из нуля и более символов,указывающая,какие классы событий регистрировать.В настоящее время это классы событий,которые могут быть включены/выключены:</target>
        </trans-unit>
        <trans-unit id="6c52999f5dadb28c826189af8598c10c0d62c8c4" translate="yes" xml:space="preserve">
          <source>For some values, we only care about the lists contents, not their order,</source>
          <target state="translated">Для некоторых значений,мы заботимся только о содержании списков,а не об их порядке,</target>
        </trans-unit>
        <trans-unit id="5a30fff547bbac81b4549d50a582f44afe1ea5d2" translate="yes" xml:space="preserve">
          <source>For spark events there are two modes: sampled and fully accurate. There are various events in the life cycle of each spark, usually just creating and running, but there are some more exceptional possibilities. In the sampled mode the number of occurrences of each kind of spark event is sampled at frequent intervals. In the fully accurate mode every spark event is logged individually. The latter has a higher runtime overhead and is not enabled by default.</source>
          <target state="translated">Для искровых событий существует два режима:выборочный и полностью точный.В жизненном цикле каждой искры есть различные события,как правило,только создающие и работающие,но есть и другие исключительные возможности.В режиме дискретизации количество событий каждого вида искры дискретизируется с частыми интервалами.В полностью точном режиме каждая искра регистрируется индивидуально.Последнее имеет более высокую продолжительность работы и не включается по умолчанию.</target>
        </trans-unit>
        <trans-unit id="8e967e8009285dc0e4dfe1b3126affb641d4d480" translate="yes" xml:space="preserve">
          <source>For technical reasons, GHCi can only support the &lt;code&gt;*&lt;/code&gt;-form for modules that are interpreted. Compiled modules and package modules can only contribute their exports to the current scope. To ensure that GHCi loads the interpreted version of a module, add the &lt;code&gt;*&lt;/code&gt; when loading the module, e.g. &lt;code&gt;:load *M&lt;/code&gt;.</source>
          <target state="translated">По техническим причинам GHCi может поддерживать форму &lt;code&gt;*&lt;/code&gt; только для интерпретируемых модулей. Скомпилированные модули и модули пакетов могут вносить свой экспорт только в текущую область. Для того, чтобы гарантировать , что GHCI загружает интерпретирована версия модуля, добавьте &lt;code&gt;*&lt;/code&gt; при загрузке модуля, например &lt;code&gt;:load *M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0829deec59e025f397584544c425b37ed5413ca9" translate="yes" xml:space="preserve">
          <source>For technical reasons, the bytecode compiler doesn&amp;rsquo;t interact well with one of the optimisation passes, so we have disabled optimisation when using the interpreter. This isn&amp;rsquo;t a great loss: you&amp;rsquo;ll get a much bigger win by compiling the bits of your code that need to go fast, rather than interpreting them with optimisation turned on.</source>
          <target state="translated">По техническим причинам компилятор байт-кода плохо взаимодействует с одним из проходов оптимизации, поэтому мы отключили оптимизацию при использовании интерпретатора. Это небольшая потеря: вы получите гораздо больший выигрыш, если скомпилируете те части кода, которые должны выполняться быстро, а не интерпретируете их с включенной оптимизацией.</target>
        </trans-unit>
        <trans-unit id="f3841d95008ee269104a63c61bf0120449a66e76" translate="yes" xml:space="preserve">
          <source>For the derived &lt;code&gt;Bad Int&lt;/code&gt; instance, GHC would need to generate something like this:</source>
          <target state="translated">Для производного экземпляра &lt;code&gt;Bad Int&lt;/code&gt; GHC потребуется создать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="4eaf58a3a8ca8af861b90aa91e9b822949a939a3" translate="yes" xml:space="preserve">
          <source>For the derived &lt;code&gt;Ex&lt;/code&gt; instance, GHC would need to generate something like this:</source>
          <target state="translated">Для производного экземпляра &lt;code&gt;Ex&lt;/code&gt; GHC потребуется сгенерировать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="ffa588946311197a1b2c4ff685a498c96580d6ce" translate="yes" xml:space="preserve">
          <source>For the first trust definition the trust guarantee is provided by GHC through the restrictions imposed by the safe language. For the second definition of trust, the guarantee is provided initially by the module author. The client C then establishes that they trust the module author by indicating they trust the package the module resides in. This trust chain is required as GHC provides no guarantee for &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; compiled modules.</source>
          <target state="translated">Для первого определения доверия гарантия доверия предоставляется GHC посредством ограничений, налагаемых безопасным языком. Для второго определения доверия гарантия изначально предоставляется автором модуля. Затем клиент C подтверждает, что он доверяет автору модуля, указывая, что он доверяет пакету, в котором находится модуль. Эта цепочка доверия требуется, поскольку GHC не дает гарантии для &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; скомпилированных модулей.</target>
        </trans-unit>
        <trans-unit id="060c8275f3511e9a847d9b963216480ea97ce2de" translate="yes" xml:space="preserve">
          <source>For the first two examples we show sequenceA fully evaluating a a structure and collecting the results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d323edf5bc66a27abef8680a58a3a1cdc8c8ab90" translate="yes" xml:space="preserve">
          <source>For the string data itself, both &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;b#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; use one byte per element, rounded up to the nearest word. For example, including the overheads, a length 10 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; would take &lt;code&gt;16 + 12 = 28&lt;/code&gt; bytes on a 32bit platform and &lt;code&gt;32 + 16 = 48&lt;/code&gt; bytes on a 64bit platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32cc9253b78847faffaa8325c66bc83a4331016c" translate="yes" xml:space="preserve">
          <source>For the string data itself, both &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;ByteString&lt;/code&gt; use one byte per element, rounded up to the nearest word. For example, including the overheads, a length 10 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; would take &lt;code&gt;16 + 12 = 28&lt;/code&gt; bytes on a 32bit platform and &lt;code&gt;32 + 16 = 48&lt;/code&gt; bytes on a 64bit platform.</source>
          <target state="translated">Для самих строковых данных и &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; , и &lt;code&gt;ByteString&lt;/code&gt; используют один байт на элемент, округленный до ближайшего слова. Например, включая накладные расходы, длина 10 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; займет &lt;code&gt;16 + 12 = 28&lt;/code&gt; байтов на 32-битной платформе и &lt;code&gt;32 + 16 = 48&lt;/code&gt; байтов на 64-битной платформе.</target>
        </trans-unit>
        <trans-unit id="2dfb67f7f13b2578a8003b1f16579b450e09d029" translate="yes" xml:space="preserve">
          <source>For these monad transformers, &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; is a natural transformation in the category of monads, i.e. for any monad transformation &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt;,</source>
          <target state="translated">Для этих преобразователей монад &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; является естественным преобразованием в категории монад, т.е. для любого преобразования монад &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="67e40ed20b98dd2eb671037144a5a29659a48929" translate="yes" xml:space="preserve">
          <source>For these reasons GHC provides an external API to &lt;code&gt;tryPutMVar&lt;/code&gt;, &lt;code&gt;hs_try_putmvar&lt;/code&gt;, which you can use to cheaply and asynchronously wake up a Haskell thread from C/C++.</source>
          <target state="translated">По этим причинам GHC предоставляет внешний API для &lt;code&gt;tryPutMVar&lt;/code&gt; , &lt;code&gt;hs_try_putmvar&lt;/code&gt; , который вы можете использовать для дешевого и асинхронного пробуждения потока Haskell из C / C ++.</target>
        </trans-unit>
        <trans-unit id="5539b287ec186ea0d65a4fd7ea031c83904aceb1" translate="yes" xml:space="preserve">
          <source>For this reason we should be cautious when interpreting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targeting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt;) when assigning costs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3771cc36c2c4040313b7547f14f2698b45ba9921" translate="yes" xml:space="preserve">
          <source>For this reason we should be cautious when interpreting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targetting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt;) when assigning costs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b01d6140708791731ce8e176317b02d04ed594b" translate="yes" xml:space="preserve">
          <source>For this reason we should be cautious when interpretting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targetting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt;) when assigning costs.</source>
          <target state="translated">По этой причине мы должны проявлять осторожность при интерпретации местоположения источников, предоставленных GDB. Хотя эти местоположения обычно в некотором смысле &amp;laquo;правильные&amp;raquo;, они не всегда полезны. Вот почему инструменты профилирования, нацеленные на Haskell, должны дополнять стандартную информацию о местоположении источника специфичными для GHC аннотациями (генерируемыми с помощью &lt;code&gt;-g2&lt;/code&gt; ) при назначении затрат.</target>
        </trans-unit>
        <trans-unit id="cacc0718d7e72594c1a05f793c384e9988e904e4" translate="yes" xml:space="preserve">
          <source>For three-part GHC version numbers &lt;code&gt;x.y.z&lt;/code&gt;, the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; is the integer ⟨z⟩.</source>
          <target state="translated">Для трехчастных номеров версий GHC &lt;code&gt;x.y.z&lt;/code&gt; значение &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; является целым числом ⟨z⟩.</target>
        </trans-unit>
        <trans-unit id="188a9697d8960ecca4fddfef544f2b460160723f" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">Для кортежей ограничение &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; на &lt;code&gt;a&lt;/code&gt; определяет, как объединяются первые значения. Например, &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; s concatenate:</target>
        </trans-unit>
        <trans-unit id="3ada1c90cd5232324681478bf68909f9821cd1f0" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">Для кортежей ограничение &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; на &lt;code&gt;a&lt;/code&gt; определяет, как объединяются первые значения. Например, &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; s concatenate:</target>
        </trans-unit>
        <trans-unit id="477f18a8cee4f79bac4ee3f97a03e846b9653542" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">Для кортежей ограничение &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; на &lt;code&gt;a&lt;/code&gt; определяет, как объединяются первые значения. Например, &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; s concatenate:</target>
        </trans-unit>
        <trans-unit id="7016d35532abd78914b16b8e9e5320cbf10c3da6" translate="yes" xml:space="preserve">
          <source>For type-level lists of &lt;em&gt;two or more elements&lt;/em&gt;, such as the signature of &lt;code&gt;foo2&lt;/code&gt; above, the quote may be omitted because the meaning is unambiguous. But for lists of one or zero elements (as in &lt;code&gt;foo0&lt;/code&gt; and &lt;code&gt;foo1&lt;/code&gt;), the quote is required, because the types &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;[Int]&lt;/code&gt; have existing meanings in Haskell.</source>
          <target state="translated">Для списков уровня типа из &lt;em&gt;двух или более элементов&lt;/em&gt; , таких как подпись &lt;code&gt;foo2&lt;/code&gt; выше, кавычка может быть опущена, поскольку значение однозначно. Но для списков из одного или нуля элементов (как в &lt;code&gt;foo0&lt;/code&gt; и &lt;code&gt;foo1&lt;/code&gt; ) кавычки необходимы, потому что типы &lt;code&gt;[]&lt;/code&gt; и &lt;code&gt;[Int]&lt;/code&gt; имеют существующие значения в Haskell.</target>
        </trans-unit>
        <trans-unit id="f9d5f6ee9e1d0773bd91e69a976df850879bd39d" translate="yes" xml:space="preserve">
          <source>For types and classes, GHCi also summarises instances that mention them. To avoid showing irrelevant information, an instance is shown only if (a) its head mentions ⟨name⟩, and (b) all the other things mentioned in the instance are in scope (either qualified or otherwise) as a result of a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; commands.</source>
          <target state="translated">Для типов и классов GHCi также суммирует экземпляры, в которых они упоминаются. Чтобы избежать показа нерелевантной информации, экземпляр отображается только в том случае, если (а) его заголовок упоминает ⟨name⟩, и (б) все другие вещи, упомянутые в экземпляре, находятся в области видимости (либо уточнены, либо нет) в результате &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; команды модуля .</target>
        </trans-unit>
        <trans-unit id="47016a9c155d56e31c98a5182e288d8d66335bae" translate="yes" xml:space="preserve">
          <source>For unary constructors</source>
          <target state="translated">Для унарных строителей</target>
        </trans-unit>
        <trans-unit id="3804078f78b2c6305b48a6307a75661e75a4d323" translate="yes" xml:space="preserve">
          <source>For unbounded types like &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для неограниченных типов, таких как &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; эквивалентен &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4299789099cbf566592e41318a28abf099452da3" translate="yes" xml:space="preserve">
          <source>For use with GHCi, each library should have an object file too. The name of the object file does &lt;em&gt;not&lt;/em&gt; have a &lt;code&gt;lib&lt;/code&gt; prefix, and has the normal object suffix for your platform.</source>
          <target state="translated">Для использования с GHCi каждая библиотека также должна иметь объектный файл. Имя объектного файла &lt;em&gt;не&lt;/em&gt; имеет префикса &lt;code&gt;lib&lt;/code&gt; и имеет обычный суффикс объекта для вашей платформы.</target>
        </trans-unit>
        <trans-unit id="2630e9cec4ca5b11b5ae4aa835141d30d2fd8d21" translate="yes" xml:space="preserve">
          <source>For values of &lt;code&gt;n&lt;/code&gt; greater than 1, we use &lt;code&gt;par&lt;/code&gt; to spark a thread to evaluate &lt;code&gt;nfib (n-1)&lt;/code&gt;, and then we use &lt;code&gt;pseq&lt;/code&gt; to force the parent thread to evaluate &lt;code&gt;nfib (n-2)&lt;/code&gt; before going on to add together these two subexpressions. In this divide-and-conquer approach, we only spark a new thread for one branch of the computation (leaving the parent to evaluate the other branch). Also, we must use &lt;code&gt;pseq&lt;/code&gt; to ensure that the parent will evaluate &lt;code&gt;n2&lt;/code&gt;&lt;em&gt;before&lt;/em&gt;&lt;code&gt;n1&lt;/code&gt; in the expression &lt;code&gt;(n1 + n2 + 1)&lt;/code&gt;. It is not sufficient to reorder the expression as &lt;code&gt;(n2 + n1 + 1)&lt;/code&gt;, because the compiler may not generate code to evaluate the addends from left to right.</source>
          <target state="translated">Для значений &lt;code&gt;n&lt;/code&gt; больше 1 мы используем &lt;code&gt;par&lt;/code&gt; , чтобы вызвать поток для оценки &lt;code&gt;nfib (n-1)&lt;/code&gt; , а затем мы используем &lt;code&gt;pseq&lt;/code&gt; , чтобы заставить родительский поток оценивать &lt;code&gt;nfib (n-2)&lt;/code&gt; , прежде чем продолжить сложение этих двух подвыражения. В этом подходе &amp;laquo;разделяй и властвуй&amp;raquo; мы запускаем новый поток только для одной ветви вычислений (оставляя родителю оценивать другую ветвь). Кроме того, мы должны использовать &lt;code&gt;pseq&lt;/code&gt; , чтобы гарантировать, что родитель будет оценивать &lt;code&gt;n2&lt;/code&gt; &lt;em&gt;перед &lt;/em&gt; &lt;code&gt;n1&lt;/code&gt; в выражении &lt;code&gt;(n1 + n2 + 1)&lt;/code&gt; . Недостаточно переупорядочить выражение как &lt;code&gt;(n2 + n1 + 1)&lt;/code&gt; , потому что компилятор может не сгенерировать код для оценки слагаемых слева направо.</target>
        </trans-unit>
        <trans-unit id="833cc29e3ca3cd40dea4e5990721a0c2c0e6e2a7" translate="yes" xml:space="preserve">
          <source>For version &lt;code&gt;x.y.z&lt;/code&gt; of GHC, the value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example in version 6.2 of GHC, &lt;code&gt;__GLASGOW_HASKELL__==602&lt;/code&gt;). More information in &lt;a href=&quot;intro#version-numbering&quot;&gt;GHC version numbering policy&lt;/a&gt;.</source>
          <target state="translated">Для версии &lt;code&gt;x.y.z&lt;/code&gt; GHC значение &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; - это целое число ⟨xyy⟩ (если ⟨y⟩ - однозначное число, то добавляется начальный ноль, например, в версии 6.2 GHC &lt;code&gt;__GLASGOW_HASKELL__==602&lt;/code&gt; ). Дополнительная информация в &lt;a href=&quot;intro#version-numbering&quot;&gt;политике нумерации версий GHC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="930d459a31fb0c473c8d3d450ef14232e956aa5e" translate="yes" xml:space="preserve">
          <source>ForallInvis</source>
          <target state="translated">ForallInvis</target>
        </trans-unit>
        <trans-unit id="fc5f64a4d6f12d0fb09adaae4cd55424315fc13f" translate="yes" xml:space="preserve">
          <source>ForallVis</source>
          <target state="translated">ForallVis</target>
        </trans-unit>
        <trans-unit id="9f28be70ee0e5b943be20d61fc496445d3c212bd" translate="yes" xml:space="preserve">
          <source>Force GHC to inline a value.</source>
          <target state="translated">Заставить GHC ввести значение.</target>
        </trans-unit>
        <trans-unit id="a7d87bafad299b2161dda9a58e63b3f96665d77f" translate="yes" xml:space="preserve">
          <source>Force a &lt;code&gt;&lt;a href=&quot;data-typeable#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; to normal form.</source>
          <target state="translated">Принудительная &lt;code&gt;&lt;a href=&quot;data-typeable#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; к нормальной форме.</target>
        </trans-unit>
        <trans-unit id="b3e1df0f2bdfd332765ff5812d39df923d34d2d6" translate="yes" xml:space="preserve">
          <source>Force the entries whose keys are missing from the other map and otherwise preserve them unchanged.</source>
          <target state="translated">Принудить записи,ключи которых отсутствуют на другой карте,и в противном случае сохранить их без изменений.</target>
        </trans-unit>
        <trans-unit id="50ca9997d86f8ded3e64badd3d8a285f7f58295a" translate="yes" xml:space="preserve">
          <source>ForceSpecConstr</source>
          <target state="translated">ForceSpecConstr</target>
        </trans-unit>
        <trans-unit id="316d9703cf033d39685405519176248df170f94f" translate="yes" xml:space="preserve">
          <source>Foreign</source>
          <target state="translated">Foreign</target>
        </trans-unit>
        <trans-unit id="c0146d93cdce22c9be8cd3f9cab8d08969353dc4" translate="yes" xml:space="preserve">
          <source>Foreign formats supported by GHC via TH</source>
          <target state="translated">Иностранные форматы,поддерживаемые GHC через TH</target>
        </trans-unit>
        <trans-unit id="7f40d160ba2387e27fcd81cc062ef6d270959462" translate="yes" xml:space="preserve">
          <source>Foreign functions that use UTF-16 internally may return indices in units of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; instead of characters. These functions may safely be used with such indices, as they will adjust offsets if necessary to preserve the validity of a Unicode string.</source>
          <target state="translated">Внешние функции, которые используют UTF-16 внутри, могут возвращать индексы в единицах &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; вместо символов. Эти функции можно безопасно использовать с такими индексами, поскольку они будут корректировать смещения, если необходимо, чтобы сохранить достоверность строки Unicode.</target>
        </trans-unit>
        <trans-unit id="f235bf33c8f99af06dcf27d617dccc24437bf4f1" translate="yes" xml:space="preserve">
          <source>Foreign functions that use UTF-16 internally may return indices in units of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; instead of characters. These functions may safely be used with such indices, as they will adjust offsets if necessary to preserve the validity of a Unicode string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f04f5e4c57ead75bb6944301f5d150eaeca514" translate="yes" xml:space="preserve">
          <source>Foreign functions that use UTF-16 internally may return indices in units of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; instead of characters. These functions may safely be used with such indices, as they will adjust offsets if necessary to preserve the validity of a Unicode string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1286675988bccc3af5f10d1742d504ae15e29428" translate="yes" xml:space="preserve">
          <source>Foreign marshalling support for CStrings with configurable encodings</source>
          <target state="translated">Поддержка иностранного маркетинга для CStrings с настраиваемыми кодировками</target>
        </trans-unit>
        <trans-unit id="0859bd97836968ae374d07116e3dc9cd1c792332" translate="yes" xml:space="preserve">
          <source>Foreign.C.Error</source>
          <target state="translated">Foreign.C.Error</target>
        </trans-unit>
        <trans-unit id="690f9c43315bf0f53c59f0ead7261289984f80cc" translate="yes" xml:space="preserve">
          <source>Foreign.C.String</source>
          <target state="translated">Foreign.C.String</target>
        </trans-unit>
        <trans-unit id="0d8c0c0c869725d3e5a290ea1bd0154f90329b54" translate="yes" xml:space="preserve">
          <source>Foreign.C.Types</source>
          <target state="translated">Foreign.C.Types</target>
        </trans-unit>
        <trans-unit id="7d97c94339d1338677ead19d873092b037a681ee" translate="yes" xml:space="preserve">
          <source>Foreign.Concurrent</source>
          <target state="translated">Foreign.Concurrent</target>
        </trans-unit>
        <trans-unit id="ca33d0224eada8a62673063ebb4beeb1d5c364b8" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr</source>
          <target state="translated">Foreign.ForeignPtr</target>
        </trans-unit>
        <trans-unit id="fec1ff9f155f7aecb8a9c9afbbd7c199f0ad0a4d" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr.Safe</source>
          <target state="translated">Foreign.ForeignPtr.Safe</target>
        </trans-unit>
        <trans-unit id="f69294eb7e08c8d22462d5d33a8ed6a7e1d095e1" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr.Unsafe</source>
          <target state="translated">Foreign.ForeignPtr.Unsafe</target>
        </trans-unit>
        <trans-unit id="25bc28e29c71c1f9e77e3144861913407d39a05a" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal</source>
          <target state="translated">Foreign.Marshal</target>
        </trans-unit>
        <trans-unit id="7d1de99ecec974a4cc06846997a5642ce7e5207e" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Alloc</source>
          <target state="translated">Foreign.Marshal.Alloc</target>
        </trans-unit>
        <trans-unit id="34878c43ce6c0c1af86d41cd9921a4ee5f245a03" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Array</source>
          <target state="translated">Foreign.Marshal.Array</target>
        </trans-unit>
        <trans-unit id="92e3167a907bdc1222dc2d026cf2ba11246d8dc3" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Error</source>
          <target state="translated">Foreign.Marshal.Error</target>
        </trans-unit>
        <trans-unit id="8a7a411fa1f5af48f3df4c5bc1f61cb7696fe119" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Pool</source>
          <target state="translated">Foreign.Marshal.Pool</target>
        </trans-unit>
        <trans-unit id="7b25d01718919e3ce39586acacb255d2ed0d2a1f" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Safe</source>
          <target state="translated">Foreign.Marshal.Safe</target>
        </trans-unit>
        <trans-unit id="7c7103fd359ba066b392b41f8f6b0763350b3734" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Unsafe</source>
          <target state="translated">Foreign.Marshal.Unsafe</target>
        </trans-unit>
        <trans-unit id="af4a982e3ee46919384a0fa17fa230e3fcff9621" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Utils</source>
          <target state="translated">Foreign.Marshal.Utils</target>
        </trans-unit>
        <trans-unit id="3223be426d0cdd1356fd2286241936ef6d3776c4" translate="yes" xml:space="preserve">
          <source>Foreign.Ptr</source>
          <target state="translated">Foreign.Ptr</target>
        </trans-unit>
        <trans-unit id="5027f6a00f24a331a0a2c00858c48833746f143a" translate="yes" xml:space="preserve">
          <source>Foreign.StablePtr</source>
          <target state="translated">Foreign.StablePtr</target>
        </trans-unit>
        <trans-unit id="819868f38d58136fcaa5d12146fb0f0c1e93f966" translate="yes" xml:space="preserve">
          <source>Foreign.Storable</source>
          <target state="translated">Foreign.Storable</target>
        </trans-unit>
        <trans-unit id="f2e5ff4797622913221ace3c0f488aecb6763737" translate="yes" xml:space="preserve">
          <source>ForeignFunctionInterface</source>
          <target state="translated">ForeignFunctionInterface</target>
        </trans-unit>
        <trans-unit id="c2ad3b41dcfdfcb4cdc30a8b1047888336b299be" translate="yes" xml:space="preserve">
          <source>ForeignHANDLE</source>
          <target state="translated">ForeignHANDLE</target>
        </trans-unit>
        <trans-unit id="15867b934b9041f19d00947d6efc59ac6319cf3c" translate="yes" xml:space="preserve">
          <source>ForeignHValue</source>
          <target state="translated">ForeignHValue</target>
        </trans-unit>
        <trans-unit id="4c81499005daf21faf5cf91d16a0534956f2909d" translate="yes" xml:space="preserve">
          <source>ForeignPtr</source>
          <target state="translated">ForeignPtr</target>
        </trans-unit>
        <trans-unit id="c624eaa10676fb999d8a5b6feb05f3b52f934560" translate="yes" xml:space="preserve">
          <source>ForeignPtrContents</source>
          <target state="translated">ForeignPtrContents</target>
        </trans-unit>
        <trans-unit id="6f2e78934322ebeb373ed863a4f0571cb731dad3" translate="yes" xml:space="preserve">
          <source>ForeignRef</source>
          <target state="translated">ForeignRef</target>
        </trans-unit>
        <trans-unit id="625b683a019ce7ae97d5cf12c7b91734ec7d1897" translate="yes" xml:space="preserve">
          <source>ForeignSrcLang</source>
          <target state="translated">ForeignSrcLang</target>
        </trans-unit>
        <trans-unit id="f41c4e4dab0b44d75dad0c04a0156d326c95b774" translate="yes" xml:space="preserve">
          <source>Forest</source>
          <target state="translated">Forest</target>
        </trans-unit>
        <trans-unit id="210c313feac20bb8ddb1dd7cbec2b356b3072a0a" translate="yes" xml:space="preserve">
          <source>Fork a thread and call the supplied function when the thread is about to terminate, with an exception or a returned value. The function is called with asynchronous exceptions masked.</source>
          <target state="translated">Вовлеките поток и вызовите поставляемую функцию,когда поток собирается прекратить,с исключением или возвращаемым значением.Функция вызывается с маскировкой асинхронных исключений.</target>
        </trans-unit>
        <trans-unit id="b1cbaa12a8b3d860d7a7e72293e672a2ff7acd71" translate="yes" xml:space="preserve">
          <source>Forking and executing</source>
          <target state="translated">Подборка и выполнение</target>
        </trans-unit>
        <trans-unit id="4017d24e3f2f76b82ff8d264b0bfa897d184d50d" translate="yes" xml:space="preserve">
          <source>Forking and killing threads.</source>
          <target state="translated">Вилки и убойные нити.</target>
        </trans-unit>
        <trans-unit id="062c8f7ca75a391f115434ac85e20074eaf4a4b6" translate="yes" xml:space="preserve">
          <source>Forking and suchlike</source>
          <target state="translated">Волочащийся и подобный</target>
        </trans-unit>
        <trans-unit id="142946f950e6a3c69461157ecd922afefd29abfb" translate="yes" xml:space="preserve">
          <source>Form a complex number from polar components of magnitude and phase.</source>
          <target state="translated">Сформируйте сложное число из полярных составляющих величины и фазы.</target>
        </trans-unit>
        <trans-unit id="a60392868ec861fd3b4efe2f9b78306da95d0a07" translate="yes" xml:space="preserve">
          <source>Formally speaking, in Haskell 98, an entity (function, type or class) in a program is uniquely identified by the pair of the module name in which it is defined and its name. In GHC, an entity is uniquely defined by a triple: package, module, and name.</source>
          <target state="translated">Формально говоря,в Haskell 98 сущность (функция,тип или класс)в программе однозначно идентифицируется по паре имени модуля,в котором она определена,и его имени.В GHC сущность уникально определяется тройкой:пакет,модуль и имя.</target>
        </trans-unit>
        <trans-unit id="f76337fdd96b77e407773d674b30b0bcd18c1c85" translate="yes" xml:space="preserve">
          <source>Formally, the class &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; represents a bifunctor from &lt;code&gt;Hask&lt;/code&gt; -&amp;gt; &lt;code&gt;Hask&lt;/code&gt;.</source>
          <target state="translated">Формально класс &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; представляет собой бифунктор из &lt;code&gt;Hask&lt;/code&gt; -&amp;gt; &lt;code&gt;Hask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="817d72cb0e35af2d4da048907c1e9f5d6dc84fe4" translate="yes" xml:space="preserve">
          <source>Format a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; as a list of lines.</source>
          <target state="translated">Отформатируйте &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; как список строк.</target>
        </trans-unit>
        <trans-unit id="9b3c1914896872682c2c5207b9848f7bd13b8136" translate="yes" xml:space="preserve">
          <source>Format a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; as a list of lines.</source>
          <target state="translated">Отформатируйте &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; как список строк.</target>
        </trans-unit>
        <trans-unit id="64f559e1932e1e1e55a815f201bd5318c25248c5" translate="yes" xml:space="preserve">
          <source>Format a variable number of arguments with the C-style formatting string.</source>
          <target state="translated">Отформатируйте переменное количество аргументов строкой форматирования в стиле C.</target>
        </trans-unit>
        <trans-unit id="6c1b349cc09f134d48d7a222aba9e73980432c3a" translate="yes" xml:space="preserve">
          <source>Format picture translation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f544ee1a7acc5ea325b43ab1bc03f12126274ad5" translate="yes" xml:space="preserve">
          <source>Format string</source>
          <target state="translated">Форматная строка</target>
        </trans-unit>
        <trans-unit id="15a38fe668d67202702d0adb7731f3ab46da832d" translate="yes" xml:space="preserve">
          <source>Format string according to &lt;a href=&quot;http://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt;.</source>
          <target state="translated">Строка формата согласно &lt;a href=&quot;http://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e7448bd68705edd6cbfa67e98ce2811cf8f693f" translate="yes" xml:space="preserve">
          <source>Format string according to &lt;a href=&quot;https://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c69b10975ea22ae776aa724f607ec9f6aa5721da" translate="yes" xml:space="preserve">
          <source>Format string.</source>
          <target state="translated">Строка формата.</target>
        </trans-unit>
        <trans-unit id="c49ce58749cd62ae589b86a35e201efa147e3749" translate="yes" xml:space="preserve">
          <source>FormatAdjustment</source>
          <target state="translated">FormatAdjustment</target>
        </trans-unit>
        <trans-unit id="70e56ae13abeac549bcfdb5f59450b6d50c08e51" translate="yes" xml:space="preserve">
          <source>FormatExtension</source>
          <target state="translated">FormatExtension</target>
        </trans-unit>
        <trans-unit id="5d785a947d237d49fab80da22e92f51d9955949e" translate="yes" xml:space="preserve">
          <source>FormatParse</source>
          <target state="translated">FormatParse</target>
        </trans-unit>
        <trans-unit id="b72b753c33b18ecb90ec05cd82bed66f783d6a0c" translate="yes" xml:space="preserve">
          <source>FormatSign</source>
          <target state="translated">FormatSign</target>
        </trans-unit>
        <trans-unit id="7e09c6d5d576e97515cc176e731476beaa374961" translate="yes" xml:space="preserve">
          <source>FormatTime</source>
          <target state="translated">FormatTime</target>
        </trans-unit>
        <trans-unit id="2a8d33f179c3fdae21d8031b20bfc9d0ae643b20" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">Средство форматирования для значений &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0565c40664395019883a78394d3992cdd6a29f2a" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">Средство форматирования для значений типа &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e70e56ba2ac14918e7e20dbc0ecdc4f08e831a7" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">Средство форматирования для &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; значений.</target>
        </trans-unit>
        <trans-unit id="f4f8c93e825cbbd257bef8a02316190482d9eebc" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">Средство форматирования для &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; значений.</target>
        </trans-unit>
        <trans-unit id="99b405a8b0c3cbb2780273aefe5ba19eb6dfc98f" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; форматирования для значений RealFloat .</target>
        </trans-unit>
        <trans-unit id="1fb27c72113587f58e32eab2d4c73f0ebb454ce4" translate="yes" xml:space="preserve">
          <source>Formatting dumps</source>
          <target state="translated">Отвалы для форматирования</target>
        </trans-unit>
        <trans-unit id="052cfbf508f19822df3fa5723c6e45d70e424a82" translate="yes" xml:space="preserve">
          <source>Formatting numbers as text</source>
          <target state="translated">Форматирование номеров в виде текста</target>
        </trans-unit>
        <trans-unit id="9756f760957e76b727a94e2c4ebba6cd0fc0c583" translate="yes" xml:space="preserve">
          <source>Formatting of numbers as ASCII text.</source>
          <target state="translated">Форматирование чисел в виде ASCII текста.</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="deab3e00883d05a243bf5b0e77d440ef22fdfed1" translate="yes" xml:space="preserve">
          <source>Forms the ratio of two integral numbers.</source>
          <target state="translated">Формирует соотношение двух интегральных чисел.</target>
        </trans-unit>
        <trans-unit id="63d9155e692b47f7489ea16b510f66604795ffc2" translate="yes" xml:space="preserve">
          <source>Fortunately GHC provides two workarounds.</source>
          <target state="translated">К счастью,GHC обеспечивает два обходных пути.</target>
        </trans-unit>
        <trans-unit id="3285674b1fed9c0d76a5d4be734aa793887b9b9c" translate="yes" xml:space="preserve">
          <source>Fortunately, the debugger includes a generic printing command, &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;, which can inspect the actual runtime value of a variable and attempt to reconstruct its type. If we try it on &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="translated">К счастью, отладчик включает в себя общую команду &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; , которая может проверять фактическое значение переменной во время выполнения и пытаться восстановить ее тип. Если попробовать &lt;code&gt;left&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5de5f3adc837b664b0c550c9600b073ca7c029bb" translate="yes" xml:space="preserve">
          <source>Fractional</source>
          <target state="translated">Fractional</target>
        </trans-unit>
        <trans-unit id="4ee506c817db93cddd17a9bfc7e90e7929ba9ac1" translate="yes" xml:space="preserve">
          <source>Fractional division.</source>
          <target state="translated">Дробное деление.</target>
        </trans-unit>
        <trans-unit id="b7f4445862e6ae9531f4b6c20b5111d59a0f6376" translate="yes" xml:space="preserve">
          <source>Fractional literals are handled in just the same way, except that the translation is &lt;code&gt;fromRational (3.68::Rational)&lt;/code&gt;.</source>
          <target state="translated">Дробные литералы обрабатываются точно так же, за исключением того, что перевод из &lt;code&gt;fromRational (3.68::Rational)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c28c0e5aed14aa92c66ee9d85b73c91926a063b" translate="yes" xml:space="preserve">
          <source>Fractional numbers, supporting real division.</source>
          <target state="translated">Дробные числа,поддерживающие реальное деление.</target>
        </trans-unit>
        <trans-unit id="82bc6ab69601270775fa67172582c91fb0a4a8cd" translate="yes" xml:space="preserve">
          <source>Free a block of memory that was allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt; or any of the &lt;code&gt;new&lt;/code&gt;&lt;em&gt;X&lt;/em&gt; functions in &lt;a href=&quot;foreign-marshal-array&quot;&gt;Foreign.Marshal.Array&lt;/a&gt; or &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt;.</source>
          <target state="translated">Освободите блок памяти, который был выделен с помощью &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt; или любой из &lt;code&gt;new&lt;/code&gt; функций &lt;em&gt;X&lt;/em&gt; в &lt;a href=&quot;foreign-marshal-array&quot;&gt;Foreign.Marshal.Array&lt;/a&gt; или &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99ee535db19c7fed33ade7d6567514f1b90cbd2f" translate="yes" xml:space="preserve">
          <source>Free data previously created by &lt;code&gt;&lt;a href=&quot;ghci-message#v:PrepFFI&quot;&gt;PrepFFI&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Бесплатные данные, ранее созданные &lt;code&gt;&lt;a href=&quot;ghci-message#v:PrepFFI&quot;&gt;PrepFFI&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4149e5ff6e145e457b073182334b5e7994374fef" translate="yes" xml:space="preserve">
          <source>Free the cached debug data.</source>
          <target state="translated">Освободите кэшированные отладочные данные.</target>
        </trans-unit>
        <trans-unit id="11a51d8a12071a090bc68657f6d6227b831062a8" translate="yes" xml:space="preserve">
          <source>Frees a function pointer to the window closure which has been set directly by &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:setWindowClosure&quot;&gt;setWindowClosure&lt;/a&gt;&lt;/code&gt; or indirectly by &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:createWindowEx&quot;&gt;createWindowEx&lt;/a&gt;&lt;/code&gt;. You should call this function in your window closure's &lt;code&gt;&lt;a href=&quot;graphics-win32-message#v:wM_NCDESTROY&quot;&gt;wM_NCDESTROY&lt;/a&gt;&lt;/code&gt; case unless you delegate that case to &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:defWindowProc&quot;&gt;defWindowProc&lt;/a&gt;&lt;/code&gt; (e.g. as part of the default).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835a9413b3500f88ebd65d3f3a099585661ce5a1" translate="yes" xml:space="preserve">
          <source>Freeze a call-stack, preventing any further call-sites from being appended.</source>
          <target state="translated">Заморозьте пакет вызовов,чтобы предотвратить добавление дополнительных сайтов вызовов.</target>
        </trans-unit>
        <trans-unit id="d77d8d6f00b87c26b8cacf7082e9df15e70c77ad" translate="yes" xml:space="preserve">
          <source>Freeze a mutable array. Do not mutate the &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; afterwards!</source>
          <target state="translated">Заморозить изменяемый массив. Не &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; впоследствии!</target>
        </trans-unit>
        <trans-unit id="3cbf8b26c0873962d81de4914650cb76bb9b807d" translate="yes" xml:space="preserve">
          <source>Freeze the stack at the given &lt;code&gt;CallStack&lt;/code&gt;, preventing any further call-sites from being pushed onto it.</source>
          <target state="translated">Заморозьте стек в данном &lt;code&gt;CallStack&lt;/code&gt; , не допуская попадания на него дальнейших сайтов вызовов.</target>
        </trans-unit>
        <trans-unit id="b9fc39f5344fe15184815d93e0ed318d916cfe42" translate="yes" xml:space="preserve">
          <source>Fresh names</source>
          <target state="translated">Свежие имена</target>
        </trans-unit>
        <trans-unit id="d166e844a3f3f87149cc4f866eb998e9a751c72a" translate="yes" xml:space="preserve">
          <source>Friday</source>
          <target state="translated">Friday</target>
        </trans-unit>
        <trans-unit id="37dda3a9ea66f14ada71778600674c8b446efe85" translate="yes" xml:space="preserve">
          <source>From Ascending Lists</source>
          <target state="translated">Из восходящих списков</target>
        </trans-unit>
        <trans-unit id="dde237215ea6fcfcb47d350794652f262577482d" translate="yes" xml:space="preserve">
          <source>From Descending Lists</source>
          <target state="translated">Из понижающихся списков</target>
        </trans-unit>
        <trans-unit id="ea889b16fbe49283cc535ae8005c5b414dd907d0" translate="yes" xml:space="preserve">
          <source>From Unordered Lists</source>
          <target state="translated">Из неупорядоченных списков</target>
        </trans-unit>
        <trans-unit id="ec5ec9c6f6fb9b3f12cb867846a71ac3385b451b" translate="yes" xml:space="preserve">
          <source>From a different module than &lt;code&gt;Ix&lt;/code&gt;</source>
          <target state="translated">Из модуля, отличного от &lt;code&gt;Ix&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="773618ef2831cbf23002ae5536fc39efbf8e5287" translate="yes" xml:space="preserve">
          <source>From a semantic point of view:</source>
          <target state="translated">С семантической точки зрения:</target>
        </trans-unit>
        <trans-unit id="2fc93a684c9bf3e71ee51e44f522a8a42caa44d2" translate="yes" xml:space="preserve">
          <source>From a syntactic point of view:</source>
          <target state="translated">С синтаксической точки зрения:</target>
        </trans-unit>
        <trans-unit id="9c95c79505f22121b4295dc89b0deedb0cd62bb1" translate="yes" xml:space="preserve">
          <source>From here, we can apply f to any argument of type Integer and observe the results.</source>
          <target state="translated">Отсюда мы можем применить f к любому аргументу типа Integer и наблюдать за результатами.</target>
        </trans-unit>
        <trans-unit id="65237fa5c41874136927b1dd87c188874f9356a5" translate="yes" xml:space="preserve">
          <source>From strings to constructors and vice versa: all data types</source>
          <target state="translated">От строк к конструкторам и наоборот:все типы данных</target>
        </trans-unit>
        <trans-unit id="3b2239783ff3d9519a980e73646e0d065f0b5416" translate="yes" xml:space="preserve">
          <source>From the &lt;code&gt;x1==x2&lt;/code&gt; we need &lt;code&gt;Eq a&lt;/code&gt;, which is fine. From &lt;code&gt;c1==c2&lt;/code&gt; we need &lt;code&gt;Eq (f (Rose f a))&lt;/code&gt; which is &lt;em&gt;not&lt;/em&gt; fine in Haskell today; we have no way to solve such a constraint.</source>
          <target state="translated">Из &lt;code&gt;x1==x2&lt;/code&gt; нам нужно &lt;code&gt;Eq a&lt;/code&gt; , и это нормально. Из &lt;code&gt;c1==c2&lt;/code&gt; нам нужно &lt;code&gt;Eq (f (Rose f a))&lt;/code&gt; что сегодня &lt;em&gt;не&lt;/em&gt; подходит для Haskell; у нас нет возможности разрешить такое ограничение.</target>
        </trans-unit>
        <trans-unit id="fe6c0223120c23453cd68ad8351310715d567d44" translate="yes" xml:space="preserve">
          <source>From the &lt;code&gt;x==x&lt;/code&gt; we need an &lt;code&gt;Eq (m Int)&lt;/code&gt; constraint, but the context only gives us a way to figure out &lt;code&gt;Ord (m a)&lt;/code&gt; constraints. But from the given constraint &lt;code&gt;forall a. Ord a =&amp;gt; Ord (m a)&lt;/code&gt; we derive a second given constraint &lt;code&gt;forall a. Ord a =&amp;gt; Eq (m a)&lt;/code&gt;, and from that we can readily solve &lt;code&gt;Eq (m Int)&lt;/code&gt;. This process is very similar to the way that superclasses already work: given an &lt;code&gt;Ord a&lt;/code&gt; constraint we derive a second given &lt;code&gt;Eq a&lt;/code&gt; constraint.</source>
          <target state="translated">Из &lt;code&gt;x==x&lt;/code&gt; нам нужно ограничение &lt;code&gt;Eq (m Int)&lt;/code&gt; , но контекст только дает нам способ выяснить ограничения &lt;code&gt;Ord (m a)&lt;/code&gt; . Но из данного ограничения для &lt;code&gt;forall a. Ord a =&amp;gt; Ord (m a)&lt;/code&gt; мы получаем второе заданное ограничение для &lt;code&gt;forall a. Ord a =&amp;gt; Eq (m a)&lt;/code&gt; , и отсюда мы можем легко решить &lt;code&gt;Eq (m Int)&lt;/code&gt; . Этот процесс очень похож на способ, которым уже работают суперклассы: при заданном ограничении &lt;code&gt;Ord a&lt;/code&gt; мы выводим второе ограничение из &lt;code&gt;Eq a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3ccd46c83ed0ec15b20ac59a4d1d0cd9e4d0387" translate="yes" xml:space="preserve">
          <source>From the abstract:</source>
          <target state="translated">Из абстракции:</target>
        </trans-unit>
        <trans-unit id="8f586d4299cff81ec9f4dbb22fee7f8864d5b6b4" translate="yes" xml:space="preserve">
          <source>From the type signatures involved, this looks like it should allocate one &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; value, and two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values. However, when a module is compiled with optimisation enabled under GHC, the two intermediate &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values will be optimised away, and the function will be compiled down to a single loop over the source &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; задействованным сигнатурам типа, похоже, что он должен выделить одно значение ByteString и два значения &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; . Однако, когда модуль компилируется с включенной оптимизацией в GHC, два промежуточных значения &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; будут оптимизированы, и функция будет скомпилирована до одного цикла по исходной &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="694096b3017c32a2a22ef4b2a40ca9ccd292d59e" translate="yes" xml:space="preserve">
          <source>From the type signatures involved, this looks like it should allocate one &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; value, and two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values. However, when a module is compiled with optimisation enabled under GHC, the two intermediate &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values will be optimised away, and the function will be compiled down to a single loop over the source &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da1b74e67991ce47776d51a891d2ebaba67a4de6" translate="yes" xml:space="preserve">
          <source>From the type signatures involved, this looks like it should allocate one &lt;code&gt;ByteString&lt;/code&gt; value, and two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values. However, when a module is compiled with optimisation enabled under GHC, the two intermediate &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values will be optimised away, and the function will be compiled down to a single loop over the source &lt;code&gt;ByteString&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ByteString&lt;/code&gt; задействованным сигнатурам типа, похоже, что он должен выделить одно значение ByteString и два значения &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; . Однако, когда модуль компилируется с включенной оптимизацией в GHC, два промежуточных значения &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; будут оптимизированы, и функция будет скомпилирована до одного цикла по исходной &lt;code&gt;ByteString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6319621270065df2076d59ecc28d7681834cf630" translate="yes" xml:space="preserve">
          <source>Front-end</source>
          <target state="translated">Front-end</target>
        </trans-unit>
        <trans-unit id="9cba7ac0176caf9e0fd3fa137920b3f27031c36f" translate="yes" xml:space="preserve">
          <source>Frontend plugins, like compiler plugins, are exported by registered plugins. However, unlike compiler modules, frontend plugins are modules that export at least a single identifier &lt;code&gt;frontendPlugin&lt;/code&gt; of type &lt;code&gt;GHC.Plugins.FrontendPlugin&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62d9c8956bde0556d61352d45bccf3852eca058" translate="yes" xml:space="preserve">
          <source>Frontend plugins, like compiler plugins, are exported by registered plugins. However, unlike compiler modules, frontend plugins are modules that export at least a single identifier &lt;code&gt;frontendPlugin&lt;/code&gt; of type &lt;code&gt;GhcPlugins.FrontendPlugin&lt;/code&gt;.</source>
          <target state="translated">Плагины Frontend, как и плагины компилятора, экспортируются зарегистрированными плагинами. Однако, в отличие от модулей компилятора, подключаемые модули &lt;code&gt;GhcPlugins.FrontendPlugin&lt;/code&gt; интерфейса - это модули, которые экспортируют хотя бы один идентификатор &lt;code&gt;frontendPlugin&lt;/code&gt; типа GhcPlugins.FrontendPlugin .</target>
        </trans-unit>
        <trans-unit id="276f7c7cbfb0b8260fdd7e80f21f3c6030a9846c" translate="yes" xml:space="preserve">
          <source>FsModifier</source>
          <target state="translated">FsModifier</target>
        </trans-unit>
        <trans-unit id="18e66a137332691b1ae47570995daffc16926de1" translate="yes" xml:space="preserve">
          <source>FsModifiers</source>
          <target state="translated">FsModifiers</target>
        </trans-unit>
        <trans-unit id="ba860eaf95bc28dd3ebf66d6ea432e5dcf5bfbfd" translate="yes" xml:space="preserve">
          <source>Full list of currently supported flags:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f941ab65fbabe87f41cd73c9136f5a4c97087e8" translate="yes" xml:space="preserve">
          <source>Fun</source>
          <target state="translated">Fun</target>
        </trans-unit>
        <trans-unit id="a49f394638f73a008e2a6ab49d4b6e70abd398cc" translate="yes" xml:space="preserve">
          <source>FunDep</source>
          <target state="translated">FunDep</target>
        </trans-unit>
        <trans-unit id="92c04eeff3f0a42e14b1ae0e114869df39b965bc" translate="yes" xml:space="preserve">
          <source>FunLike</source>
          <target state="translated">FunLike</target>
        </trans-unit>
        <trans-unit id="5c9b47aa1445e6cb4d1617a035b8bafcb7684dca" translate="yes" xml:space="preserve">
          <source>FunPtr</source>
          <target state="translated">FunPtr</target>
        </trans-unit>
        <trans-unit id="a86870628cb20261d52821b6306ebd7581fdea16" translate="yes" xml:space="preserve">
          <source>Function composition.</source>
          <target state="translated">Функциональный состав.</target>
        </trans-unit>
        <trans-unit id="d6054df2c54398efbf27ace21713f95c0a24cb59" translate="yes" xml:space="preserve">
          <source>Function pointers</source>
          <target state="translated">Функциональные указатели</target>
        </trans-unit>
        <trans-unit id="aa8776b9cbbee9db87d3477fe33414619d326897" translate="yes" xml:space="preserve">
          <source>Function to produce a list of possible completions</source>
          <target state="translated">Функция составления списка возможных завершений</target>
        </trans-unit>
        <trans-unit id="4ddcb5893b8b93e1794a989e859abc36b85a0805" translate="yes" xml:space="preserve">
          <source>Function to produce a list of possible completions. The first argument is the line contents to the left of the word, reversed. The second argument is the word to be completed.</source>
          <target state="translated">Функция создания списка возможных завершений.Первый аргумент-содержимое строки слева от слова,перевернутое.Второй аргумент-слово,которое должно быть завершено.</target>
        </trans-unit>
        <trans-unit id="04d492d7d7dbe814e8a3fb4f74d794a0b412f642" translate="yes" xml:space="preserve">
          <source>Function type for handling a coding error. It is supplied with two inputs:</source>
          <target state="translated">Тип функции для обработки ошибки кодирования.Поставляется с двумя входами:</target>
        </trans-unit>
        <trans-unit id="ebada3a4561582f6522218c04a731fcb04129871" translate="yes" xml:space="preserve">
          <source>Function types. The last type parameter can appear anywhere in a function type as long as it occurs in a &lt;em&gt;covariant&lt;/em&gt; position. To illustrate what this means, consider the following three examples:</source>
          <target state="translated">Типы функций. Последний параметр типа может появляться где угодно в типе функции, если он находится в &lt;em&gt;ковариантной&lt;/em&gt; позиции. Чтобы проиллюстрировать, что это означает, рассмотрим следующие три примера:</target>
        </trans-unit>
        <trans-unit id="a1f17265bebe4b2d092da403bdca66fa2464fc46" translate="yes" xml:space="preserve">
          <source>Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id2&quot;&gt;[Jones2000]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22db9b73edaf2bfe5c3f6cffd0e6f0cc95517cd8" translate="yes" xml:space="preserve">
          <source>Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id30&quot;&gt;[Jones2000]&lt;/a&gt;.</source>
          <target state="translated">Функциональные зависимости реализованы, как описано Марком Джонсом в &lt;a href=&quot;#jones2000&quot; id=&quot;id30&quot;&gt;[Jones2000]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7435c5d7a8b15c59a912dbfd0c1a6479554619cb" translate="yes" xml:space="preserve">
          <source>Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id31&quot;&gt;[Jones2000]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac158651392c4f27c972abe1cd7fb99ffc1d8e40" translate="yes" xml:space="preserve">
          <source>Functional dependencies are introduced by a vertical bar in the syntax of a class declaration; e.g.</source>
          <target state="translated">Функциональные зависимости вводятся вертикальным столбцом в синтаксис объявления класса;например</target>
        </trans-unit>
        <trans-unit id="d1cf447b9d82509bd034707bd67b6d2cd8a410e7" translate="yes" xml:space="preserve">
          <source>Functional dependencies complicate matters. Suppose we have:</source>
          <target state="translated">Функциональные зависимости усложняют дело.Предположим,что да:</target>
        </trans-unit>
        <trans-unit id="a36463ef34fd5c22a3ab6a871cfc8a4acae515ba" translate="yes" xml:space="preserve">
          <source>FunctionalDependencies</source>
          <target state="translated">FunctionalDependencies</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="45b91122a610c434ec9ea5fb0448a65fa46cc4f4" translate="yes" xml:space="preserve">
          <source>Functions associated with the tuple data types.</source>
          <target state="translated">Функции,связанные с типами данных кортежа.</target>
        </trans-unit>
        <trans-unit id="654ea9aec402ec9bb954f259abf37b24e92ef692" translate="yes" xml:space="preserve">
          <source>Functions called when a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is finalized. Note that C finalizers and Haskell finalizers cannot be mixed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2bc2aa5709cf3957c4e61f48d1f5ceec2be3360" translate="yes" xml:space="preserve">
          <source>Functions defined by the POSIX standards for manipulating and querying the file system. Names of underlying POSIX functions are indicated whenever possible. A more complete documentation of the POSIX functions together with a more detailed description of different error conditions are usually available in the system's manual pages or from &lt;a href=&quot;http://www.unix.org/version3/online.html&quot;&gt;http://www.unix.org/version3/online.html&lt;/a&gt; (free registration required).</source>
          <target state="translated">Функции, определенные стандартами POSIX для управления файловой системой и запросов к ней. По возможности указываются имена основных функций POSIX. Более полная документация по функциям POSIX вместе с более подробным описанием различных состояний ошибок обычно доступна на страницах справочника системы или на &lt;a href=&quot;http://www.unix.org/version3/online.html&quot;&gt;http://www.unix.org/version3/online.html&lt;/a&gt; (требуется бесплатная регистрация).</target>
        </trans-unit>
        <trans-unit id="ef2638ff979efc064c3b114a029ccd9016977415" translate="yes" xml:space="preserve">
          <source>Functions for converting &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values to and from &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, using several standard encodings.</source>
          <target state="translated">Функции для преобразования &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; значений в &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; и обратно с использованием нескольких стандартных кодировок.</target>
        </trans-unit>
        <trans-unit id="db91a2c7ff023def688156c0f6c192f7664fb169" translate="yes" xml:space="preserve">
          <source>Functions for converting &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values to and from &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, using several standard encodings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8073ea9327a4d7c6639e6bad896a175b4a67c6eb" translate="yes" xml:space="preserve">
          <source>Functions for converting lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values to and from lazy &lt;code&gt;ByteString&lt;/code&gt;, using several standard encodings.</source>
          <target state="translated">Функции для преобразования значений ленивого &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; в ленивую &lt;code&gt;ByteString&lt;/code&gt; и обратно с использованием нескольких стандартных кодировок.</target>
        </trans-unit>
        <trans-unit id="1cbb4c1f2e7daa321ba6fcea8db0876732346830" translate="yes" xml:space="preserve">
          <source>Functions for tracing and monitoring execution.</source>
          <target state="translated">Функции отслеживания и контроля исполнения.</target>
        </trans-unit>
        <trans-unit id="16479fdb416d456904dff714b27125ccc720f7ec" translate="yes" xml:space="preserve">
          <source>Functions in the module &lt;code&gt;GHC.Stack&lt;/code&gt; can be used to get the current stack and render it.</source>
          <target state="translated">Функции модуля &lt;code&gt;GHC.Stack&lt;/code&gt; можно использовать для получения текущего стека и его рендеринга.</target>
        </trans-unit>
        <trans-unit id="4b4538c6823abddd718b4a67c6f47e9707112536" translate="yes" xml:space="preserve">
          <source>Functions loaded from MAPI DLL</source>
          <target state="translated">Функции загружаются из MAPI DLL</target>
        </trans-unit>
        <trans-unit id="991363ecbdab5aa793ffe2963ab2340e55ed7869" translate="yes" xml:space="preserve">
          <source>Functions on strings</source>
          <target state="translated">Функции на струнах</target>
        </trans-unit>
        <trans-unit id="acd1d73a01569b4597b066ffad662bac0febbd6d" translate="yes" xml:space="preserve">
          <source>Functions on type literals</source>
          <target state="translated">Функции на типовых буквах</target>
        </trans-unit>
        <trans-unit id="eae4e0d01438335e190495d84c53f36a1091da41" translate="yes" xml:space="preserve">
          <source>Functions that can be fused by the compiler are documented with the phrase &quot;Subject to fusion&quot;.</source>
          <target state="translated">Функции,которые могут быть сплавлены компилятором,документируются фразой &quot;Subject to fusion&quot; (подлежит слиянию).</target>
        </trans-unit>
        <trans-unit id="bf76ba3ead8b51a76bd5375c7610a24216c56497" translate="yes" xml:space="preserve">
          <source>Functions used frequently when reading textual data.</source>
          <target state="translated">Функции,часто используемые при чтении текстовых данных.</target>
        </trans-unit>
        <trans-unit id="bf5a0c8672a8cfdd38dd0c49de54779584af909e" translate="yes" xml:space="preserve">
          <source>Functor</source>
          <target state="translated">Functor</target>
        </trans-unit>
        <trans-unit id="4e092e6221592052ff27de9c36b604a94b3b2bfa" translate="yes" xml:space="preserve">
          <source>Functor and monad classes</source>
          <target state="translated">занятия по фанктору и монаде</target>
        </trans-unit>
        <trans-unit id="5d9b79097d152d34620f656052ce7bc908e4adee" translate="yes" xml:space="preserve">
          <source>Functors representing data structures that can be traversed from left to right, performing an action on each element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de3a870c86fad9ae631a01eb1c00a47d95865fc9" translate="yes" xml:space="preserve">
          <source>Functors representing data structures that can be traversed from left to right.</source>
          <target state="translated">Функторы,представляющие структуры данных,которые можно перемещать слева направо.</target>
        </trans-unit>
        <trans-unit id="bbce868c145bac81161a114f3f858a43df4b009e" translate="yes" xml:space="preserve">
          <source>Further bindings can be added to this &lt;code&gt;let&lt;/code&gt; statement, so GHCi indicates that the next line continues the previous one by changing the prompt. Note that layout is in effect, so to add more bindings to this &lt;code&gt;let&lt;/code&gt; we have to line them up:</source>
          <target state="translated">К этому оператору &lt;code&gt;let&lt;/code&gt; можно добавить дополнительные привязки , поэтому GHCi указывает, что следующая строка продолжает предыдущую, изменяя приглашение. Обратите внимание , что расположение в сущности, так , чтобы добавить больше привязок к этому &lt;code&gt;let&lt;/code&gt; мы должны выстроить их:</target>
        </trans-unit>
        <trans-unit id="49fac13714bb93079e42783f2bb2ccb3989a542a" translate="yes" xml:space="preserve">
          <source>Further, any definition must satisfy the following:</source>
          <target state="translated">Кроме того,любое определение должно удовлетворять следующим требованиям:</target>
        </trans-unit>
        <trans-unit id="2d13054939bf42393691d74b91312a9380f6750a" translate="yes" xml:space="preserve">
          <source>Furthermore GHC lets you specify the way event log data (see &lt;a href=&quot;#rts-flag--l%20%E2%9F%A8flags%E2%9F%A9&quot;&gt;&lt;code&gt;-l
⟨flags⟩&lt;/code&gt;&lt;/a&gt;) is written through a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08da0d9c9c42c5828b70fcadcfc0cc2b4842f426" translate="yes" xml:space="preserve">
          <source>Furthermore GHC lets you specify the way event log data (see &lt;a href=&quot;profiling#rts-flag--l&quot;&gt;&lt;code&gt;-l&lt;/code&gt;&lt;/a&gt;) is written through a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Кроме того, GHC позволяет указать способ записи данных журнала событий (см. &lt;a href=&quot;profiling#rts-flag--l&quot;&gt; &lt;code&gt;-l&lt;/code&gt; &lt;/a&gt; ) с помощью настраиваемого &lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="66b3cc6f1053b257141eef62d3c7cec2ae3a9542" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt; do not obey the &lt;code&gt;forall&lt;/code&gt;-or-nothing rule when their type variables are not explicitly quantified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec453e68989fa3914f8826d8c0c518b544aaa06f" translate="yes" xml:space="preserve">
          <source>Furthermore, GADT constructors do not permit outermost parentheses that surround the &lt;code&gt;opt_forall&lt;/code&gt; or &lt;code&gt;opt_ctxt&lt;/code&gt;, if at least one of them are used. For example, &lt;code&gt;MkU :: (forall a. a -&amp;gt; U)&lt;/code&gt; would be rejected, since it would treat the &lt;code&gt;forall&lt;/code&gt; as being nested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20e7c89627716c573e1aa633f5ad999d25b91e8d" translate="yes" xml:space="preserve">
          <source>Furthermore, GHC offers a lightweight annotation mechanism that you can use to annotate your source code with metadata, which you can later inspect with either the compiler API or a compiler plugin.</source>
          <target state="translated">Кроме того,GHC предлагает легкий механизм аннотирования,который можно использовать для аннотирования исходного кода с помощью метаданных,которые можно впоследствии просматривать либо с помощью API компилятора,либо с помощью плагина компилятора.</target>
        </trans-unit>
        <trans-unit id="82324c0c7e914d3c23571245dd382b3b90349133" translate="yes" xml:space="preserve">
          <source>Furthermore, GHCi will print the result of the I/O action if (and only if):</source>
          <target state="translated">Кроме того,GHCi распечатает результат действия ввода/вывода,если (и только если):</target>
        </trans-unit>
        <trans-unit id="6db505903547bc2c8bcd995bca119457f6ba82f6" translate="yes" xml:space="preserve">
          <source>Furthermore, as sketched below, you may have big problems running programs compiled using unstable interfaces.</source>
          <target state="translated">Более того,как показано ниже,у Вас могут возникнуть большие проблемы при выполнении программ,скомпилированных с использованием нестабильных интерфейсов.</target>
        </trans-unit>
        <trans-unit id="cb2c15d21b992fb8a453c178e3d2d2c870eaaae3" translate="yes" xml:space="preserve">
          <source>Furthermore, distinct lexical type variables stand for distinct type variables. This means that every programmer-written type signature (including one that contains free scoped type variables) denotes a &lt;em&gt;rigid&lt;/em&gt; type; that is, the type is fully known to the type checker, and no inference is involved.</source>
          <target state="translated">Кроме того, различные переменные лексического типа обозначают переменные разных типов. Это означает, что каждая сигнатура типа, написанная программистом (включая сигнатуру, содержащую переменные типа со свободной областью видимости), обозначает &lt;em&gt;жесткий&lt;/em&gt; тип; то есть тип полностью известен средству проверки типов, и никакого вывода не требуется.</target>
        </trans-unit>
        <trans-unit id="80b236431e261295b1f5b32062e509044fb85c6f" translate="yes" xml:space="preserve">
          <source>Furthermore, for every type constructor there is an instance that allows to coerce under the type constructor. For example, let &lt;code&gt;D&lt;/code&gt; be a prototypical type constructor (&lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt;) with three type arguments, which have roles &lt;code&gt;nominal&lt;/code&gt;, &lt;code&gt;representational&lt;/code&gt; resp. &lt;code&gt;phantom&lt;/code&gt;. Then there is an instance of the form</source>
          <target state="translated">Более того, для каждого конструктора типа существует экземпляр, который позволяет выполнять приведение под конструктор типа. Например, пусть &lt;code&gt;D&lt;/code&gt; будет конструктором прототипа типа ( &lt;code&gt;data&lt;/code&gt; или &lt;code&gt;newtype&lt;/code&gt; ) с тремя аргументами типа, которые имеют роли &lt;code&gt;nominal&lt;/code&gt; , &lt;code&gt;representational&lt;/code&gt; соответственно. &lt;code&gt;phantom&lt;/code&gt; . Затем есть экземпляр формы</target>
        </trans-unit>
        <trans-unit id="e69b97115f19d41bf37478c44ac8035f4b89ab99" translate="yes" xml:space="preserve">
          <source>Furthermore, instance declarations types do not permit outermost parentheses that surround the &lt;code&gt;opt_forall&lt;/code&gt; or &lt;code&gt;opt_ctxt&lt;/code&gt;, if at least one of them are used. For example, &lt;code&gt;instance (forall a. C a)&lt;/code&gt; would be rejected, since GHC would treat the &lt;code&gt;forall&lt;/code&gt; as being nested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406f927a9f4a120e269216ff8cb7178a7f5cb0c5" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">Кроме того, операции &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; должны соотноситься следующим образом:</target>
        </trans-unit>
        <trans-unit id="dad09ada7622a5ff58effb3bd3aac868b8da28f5" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">Кроме того, операции &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; должны соотноситься следующим образом:</target>
        </trans-unit>
        <trans-unit id="6b37d25bdd8ec825cf9b78ad8552aaf509c01998" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-base#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">Кроме того, операции &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-base#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; должны соотноситься следующим образом:</target>
        </trans-unit>
        <trans-unit id="44ff1800f7634bcf2c0b0c914a264ded817850d3" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">Кроме того, операции &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; должны соотноситься следующим образом:</target>
        </trans-unit>
        <trans-unit id="2cb5d14e799a2d7958a05582a6f9320def2c5536" translate="yes" xml:space="preserve">
          <source>Furthermore, the closing &lt;code&gt;#-}&lt;/code&gt; should start in a column to the right of the opening &lt;code&gt;{-#&lt;/code&gt;.</source>
          <target state="translated">Кроме того, закрывающий &lt;code&gt;#-}&lt;/code&gt; должен начинаться в столбце справа от открывающего &lt;code&gt;{-#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa16c9671ec072c0212b1b51c49a6c158062b0d0" translate="yes" xml:space="preserve">
          <source>Furthermore, type &lt;code&gt;t&lt;/code&gt; is constrained to have a &lt;code&gt;Typeable&lt;/code&gt; instance. The following are therefore illegal:</source>
          <target state="translated">Более того, тип &lt;code&gt;t&lt;/code&gt; должен иметь экземпляр &lt;code&gt;Typeable&lt;/code&gt; . Следовательно, следующее незаконно:</target>
        </trans-unit>
        <trans-unit id="2081970b86a7491a8d3bcc2579c359ea225ff58b" translate="yes" xml:space="preserve">
          <source>Furthermore, we restrict the following features:</source>
          <target state="translated">Кроме того,мы ограничиваем следующие возможности:</target>
        </trans-unit>
        <trans-unit id="db033d11f970572cb3e9cddec9da0ae34cfa380a" translate="yes" xml:space="preserve">
          <source>Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;-oriented functions for converting between &lt;code&gt;Text&lt;/code&gt; and several common encodings.</source>
          <target state="translated">Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; - ориентированные функции для преобразования &lt;code&gt;Text&lt;/code&gt; несколько распространенных кодировок.</target>
        </trans-unit>
        <trans-unit id="a475567b5216c28471ecd6c4d8d53d3b335fb9fb" translate="yes" xml:space="preserve">
          <source>Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;-oriented functions for converting between lazy &lt;code&gt;Text&lt;/code&gt; and several common encodings.</source>
          <target state="translated">Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; - ориентированные функции для преобразования ленивого &lt;code&gt;Text&lt;/code&gt; несколько распространенных кодировок.</target>
        </trans-unit>
        <trans-unit id="cdf2e5fcd33e60c149dbaeb7315f4ef9de629849" translate="yes" xml:space="preserve">
          <source>Fusion</source>
          <target state="translated">Fusion</target>
        </trans-unit>
        <trans-unit id="159a326f6758bdce7f9997d0ada252499a6c2735" translate="yes" xml:space="preserve">
          <source>Future versions of &lt;code&gt;integer_gmp&lt;/code&gt; may not support negative &lt;code&gt;&lt;em&gt;e&lt;/em&gt;&lt;/code&gt; values anymore.</source>
          <target state="translated">Будущие версии &lt;code&gt;integer_gmp&lt;/code&gt; могут больше не поддерживать отрицательные значения &lt;code&gt;&lt;em&gt;e&lt;/em&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce2582f55bf244541fd784a5f9f776bd503eadbf" translate="yes" xml:space="preserve">
          <source>GADT constructor types are currently not permitted to have nested &lt;code&gt;forall&lt;/code&gt;s or &lt;code&gt;=&amp;gt;&lt;/code&gt;s. (e.g., something like &lt;code&gt;MkT :: Int -&amp;gt; forall a. a -&amp;gt; T&lt;/code&gt; would be rejected.) As a result, &lt;code&gt;gadt_sig&lt;/code&gt; puts all of its quantification and constraints up front with &lt;code&gt;opt_forall&lt;/code&gt; and &lt;code&gt;opt_context&lt;/code&gt;. Note that higher-rank &lt;code&gt;forall&lt;/code&gt;s and &lt;code&gt;=&amp;gt;&lt;/code&gt;s are only permitted if they do not appear directly to the right of a function arrow in a &lt;code&gt;prefix_gadt_body&lt;/code&gt;. (e.g., something like &lt;code&gt;MkS :: Int -&amp;gt; (forall a. a) -&amp;gt; S&lt;/code&gt; is allowed, since parentheses separate the &lt;code&gt;forall&lt;/code&gt; from the &lt;code&gt;-&amp;gt;&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844bd170f572f4ec24f5e9600fd9f1281aa26e3c" translate="yes" xml:space="preserve">
          <source>GADT constructors are extra particular about their &lt;code&gt;forall&lt;/code&gt;s. In addition to adhering to the &lt;code&gt;forall&lt;/code&gt;-or-nothing rule, GADT constructors also forbid nested &lt;code&gt;forall&lt;/code&gt;s. For example, GHC would reject the following GADT:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5254c66df5fb20f0f8f5d6b6fad2ca033bf6a230" translate="yes" xml:space="preserve">
          <source>GADT-style data declarations may either bind their inputs or use an inline signature in addition to the standalone kind signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a55c9301ac576415d00c242a35c90cc869774f23" translate="yes" xml:space="preserve">
          <source>GADTSyntax</source>
          <target state="translated">GADTSyntax</target>
        </trans-unit>
        <trans-unit id="b91e38c288753eac615e73903fc03c7c3f13ec52" translate="yes" xml:space="preserve">
          <source>GADTs</source>
          <target state="translated">GADTs</target>
        </trans-unit>
        <trans-unit id="f31ea1a5194f51cb6d88f62e8060b3252067edcb" translate="yes" xml:space="preserve">
          <source>GBinaryGet</source>
          <target state="translated">GBinaryGet</target>
        </trans-unit>
        <trans-unit id="630e224c436c0a989f821b5b56c84b74804fbf46" translate="yes" xml:space="preserve">
          <source>GBinaryPut</source>
          <target state="translated">GBinaryPut</target>
        </trans-unit>
        <trans-unit id="7a52054f44519ad82fe4dc7c2dba3037f7ea46fd" translate="yes" xml:space="preserve">
          <source>GCC style response files.</source>
          <target state="translated">Ответные файлы в стиле GCC.</target>
        </trans-unit>
        <trans-unit id="9b8227183b46b7bedd6daac69544744f519a2020" translate="yes" xml:space="preserve">
          <source>GCDetails</source>
          <target state="translated">GCDetails</target>
        </trans-unit>
        <trans-unit id="1fb7f8ebd1ef6f3150ef633cd4b56e250a52dea9" translate="yes" xml:space="preserve">
          <source>GCFlags</source>
          <target state="translated">GCFlags</target>
        </trans-unit>
        <trans-unit id="726e40cb883acbb4ae39a6abc67af0f3d15c0557" translate="yes" xml:space="preserve">
          <source>GET_FILEEX_INFO_LEVELS</source>
          <target state="translated">GET_FILEEX_INFO_LEVELS</target>
        </trans-unit>
        <trans-unit id="4deab4e364b1f9987c532fb9308d3fa747de34eb" translate="yes" xml:space="preserve">
          <source>GHC</source>
          <target state="translated">GHC</target>
        </trans-unit>
        <trans-unit id="71e2fb25bf34a1d6ca4d0e65e2d0d3bee84e64bf" translate="yes" xml:space="preserve">
          <source>GHC (mostly) conforms to the Haskell Foreign Function Interface as specified in the Haskell Report. Refer to the &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch8.html&quot;&gt;relevant chapter&lt;/a&gt; of the Haskell Report for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b0fde53dfe6ccde028a6e0d7a726451f64e9f6" translate="yes" xml:space="preserve">
          <source>GHC (mostly) conforms to the Haskell Foreign Function Interface, whose definition is part of the Haskell Report on &lt;a href=&quot;http://www.haskell.org/&quot;&gt;http://www.haskell.org/&lt;/a&gt;.</source>
          <target state="translated">GHC (в основном) соответствует интерфейсу внешних функций Haskell, определение которого является частью отчета Haskell на &lt;a href=&quot;http://www.haskell.org/&quot;&gt;http://www.haskell.org/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0064178248eb2eacd8d3ac6bab315de2aca56d04" translate="yes" xml:space="preserve">
          <source>GHC (with &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, as always) tries to inline (or &amp;ldquo;unfold&amp;rdquo;) functions/values that are &amp;ldquo;small enough,&amp;rdquo; thus avoiding the call overhead and possibly exposing other more-wonderful optimisations. GHC has a set of heuristics, tuned over a long period of time using many benchmarks, that decide when it is beneficial to inline a function at its call site. The heuristics are designed to inline functions when it appears to be beneficial to do so, but without incurring excessive code bloat. If a function looks too big, it won&amp;rsquo;t be inlined, and functions larger than a certain size will not even have their definition exported in the interface file. Some of the thresholds that govern these heuristic decisions can be changed using flags, see &lt;a href=&quot;../using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a795962bc4f20caecc626cc98073806d56af3d" translate="yes" xml:space="preserve">
          <source>GHC (with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, as always) tries to inline (or &amp;ldquo;unfold&amp;rdquo;) functions/values that are &amp;ldquo;small enough,&amp;rdquo; thus avoiding the call overhead and possibly exposing other more-wonderful optimisations. GHC has a set of heuristics, tuned over a long period of time using many benchmarks, that decide when it is beneficial to inline a function at its call site. The heuristics are designed to inline functions when it appears to be beneficial to do so, but without incurring excessive code bloat. If a function looks too big, it won&amp;rsquo;t be inlined, and functions larger than a certain size will not even have their definition exported in the interface file. Some of the thresholds that govern these heuristic decisions can be changed using flags, see &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;.</source>
          <target state="translated">GHC (с &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; , как всегда) пытается встроить (или &amp;laquo;развернуть&amp;raquo;) функции / значения, которые &amp;laquo;достаточно малы&amp;raquo;, таким образом избегая накладных расходов на вызовы и, возможно, подвергая другие более замечательные оптимизации. GHC имеет набор эвристик, настраиваемых в течение длительного периода времени с использованием множества тестов, которые решают, когда выгодно встроить функцию на ее сайте вызова. Эвристика предназначена для встраивания функций, когда это кажется полезным, но без чрезмерного раздувания кода. Если функция выглядит слишком большой, она не будет встроена, а для функций, размер которых превышает определенный размер, даже не будет экспортировано их определение в файл интерфейса. Некоторые из пороговых значений, которые управляют этими эвристическими решениями, можно изменить с помощью флагов, см. &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-F *: независимые от платформы флаги&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd5aeb70f3062d7e5273699b9f6ad00fc86027b7" translate="yes" xml:space="preserve">
          <source>GHC 7.8 can evaluate arithmetic expressions involving type-level natural numbers. Such expressions may be constructed using the type-families &lt;code&gt;(+), (*), (^)&lt;/code&gt; for addition, multiplication, and exponentiation. Numbers may be compared using &lt;code&gt;(&amp;lt;=?)&lt;/code&gt;, which returns a promoted boolean value, or &lt;code&gt;(&amp;lt;=)&lt;/code&gt;, which compares numbers as a constraint. For example:</source>
          <target state="translated">GHC 7.8 может вычислять арифметические выражения, содержащие натуральные числа уровня типа. Такие выражения могут быть построены с использованием семейств типов &lt;code&gt;(+), (*), (^)&lt;/code&gt; для сложения, умножения и возведения в степень. Числа можно сравнивать с помощью &lt;code&gt;(&amp;lt;=?)&lt;/code&gt; , Который возвращает повышенное логическое значение, или &lt;code&gt;(&amp;lt;=)&lt;/code&gt; , который сравнивает числа как ограничение. Например:</target>
        </trans-unit>
        <trans-unit id="93d695e035decd28303f08218eaa7d61529f41ac" translate="yes" xml:space="preserve">
          <source>GHC 8 extends the idea of kind polymorphism by declaring that types and kinds are indeed one and the same. Nothing within GHC distinguishes between types and kinds. Another way of thinking about this is that the type &lt;code&gt;Bool&lt;/code&gt; and the &amp;ldquo;promoted kind&amp;rdquo; &lt;code&gt;Bool&lt;/code&gt; are actually identical. (Note that term &lt;code&gt;True&lt;/code&gt; and the type &lt;code&gt;'True&lt;/code&gt; are still distinct, because the former can be used in expressions and the latter in types.) This lack of distinction between types and kinds is a hallmark of dependently typed languages. Full dependently typed languages also remove the difference between expressions and types, but doing that in GHC is a story for another day.</source>
          <target state="translated">GHC 8 расширяет идею полиморфизма видов, объявляя, что типы и виды действительно являются одним и тем же. Ничто в GHC не делает различий между типами и видами. Другой способ думать об этом заключается в том, что тип &lt;code&gt;Bool&lt;/code&gt; и &amp;laquo;продвинутый тип&amp;raquo; &lt;code&gt;Bool&lt;/code&gt; на самом деле идентичны. (Обратите внимание, что термин &lt;code&gt;True&lt;/code&gt; и тип &lt;code&gt;'True&lt;/code&gt; по-прежнему различны, потому что первый может использоваться в выражениях, а второй - в типах.) Отсутствие различия между типами и видами является отличительной чертой языков с зависимой типизацией. Языки с полностью зависимой типизацией также устраняют разницу между выражениями и типами, но сделать это в GHC - это уже история для другого дня.</target>
        </trans-unit>
        <trans-unit id="83ef026940faed1f89548023088d18a255245d64" translate="yes" xml:space="preserve">
          <source>GHC 8.2 supports module signatures (&lt;code&gt;hsig&lt;/code&gt; files), which allow you to write a signature in place of a module implementation, deferring the choice of implementation until a later point in time. This feature is not intended to be used without &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;; this manual entry will focus on the syntax and semantics of signatures.</source>
          <target state="translated">GHC 8.2 поддерживает подписи модулей ( файлы &lt;code&gt;hsig&lt;/code&gt; ), которые позволяют писать подпись вместо реализации модуля, откладывая выбор реализации на более поздний момент времени. Эта функция не предназначена для использования без &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Кабала&lt;/a&gt; ; в этой ручной записи основное внимание уделяется синтаксису и семантике подписей.</target>
        </trans-unit>
        <trans-unit id="078f9d9639e0226176f8bd445a4da3cf27270446" translate="yes" xml:space="preserve">
          <source>GHC 8.2 supports module signatures (&lt;code&gt;hsig&lt;/code&gt; files), which allow you to write a signature in place of a module implementation, deferring the choice of implementation until a later point in time. This feature is not intended to be used without &lt;a href=&quot;https://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;; this manual entry will focus on the syntax and semantics of signatures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a35186132a8c1a5f44b29b9623541079c426c64" translate="yes" xml:space="preserve">
          <source>GHC Extensions: this is the Approved Way to get at GHC-specific extensions.</source>
          <target state="translated">GHC-удлинители:это одобренный способ получить GHC-удлинители.</target>
        </trans-unit>
        <trans-unit id="abcf3ed735387a1fc13551630355fd6051450c51" translate="yes" xml:space="preserve">
          <source>GHC Note: in order to call &lt;code&gt;waitForProcess&lt;/code&gt; without blocking all the other threads in the system, you must compile the program with &lt;code&gt;-threaded&lt;/code&gt;.</source>
          <target state="translated">Примечание GHC: чтобы вызвать &lt;code&gt;waitForProcess&lt;/code&gt; , не блокируя все другие потоки в системе, вы должны скомпилировать программу с &lt;code&gt;-threaded&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ef7fdb5e004e11962f2db47b8f53e696192e47e" translate="yes" xml:space="preserve">
          <source>GHC adopts &lt;strong&gt;Reject if in doubt&lt;/strong&gt; for now. We can see how painful it is in practice, and try something more ambitious if necessary.</source>
          <target state="translated">GHC принимает &lt;strong&gt;отклонение, если есть сомнения&lt;/strong&gt; . Мы видим, насколько это болезненно на практике, и при необходимости попробуем что-нибудь более амбициозное.</target>
        </trans-unit>
        <trans-unit id="41082220042afac899ff2b83b24c9b3630d70113" translate="yes" xml:space="preserve">
          <source>GHC allocates a small amount of thread-local memory when a thread calls a Haskell function via a &lt;code&gt;foreign export&lt;/code&gt;. This memory is not normally freed until &lt;code&gt;hs_exit()&lt;/code&gt;; the memory is cached so that subsequent calls into Haskell are fast. However, if your application is long-running and repeatedly creates new threads that call into Haskell, you probably want to arrange that this memory is freed in those threads that have finished calling Haskell functions. To do this, call &lt;code&gt;hs_thread_done()&lt;/code&gt; from the thread whose memory you want to free.</source>
          <target state="translated">GHC выделяет небольшой объем локальной памяти потока, когда поток вызывает функцию Haskell через &lt;code&gt;foreign export&lt;/code&gt; . Эта память обычно не освобождается до &lt;code&gt;hs_exit()&lt;/code&gt; ; память кэшируется, поэтому последующие вызовы Haskell выполняются быстро. Однако, если ваше приложение работает долго и постоянно создает новые потоки, вызывающие Haskell, вы, вероятно, захотите освободить эту память в тех потоках, которые завершили вызов функций Haskell. Для этого вызовите &lt;code&gt;hs_thread_done()&lt;/code&gt; из потока, память которого вы хотите освободить.</target>
        </trans-unit>
        <trans-unit id="1bfd38ebcc64be5e8d02f6d23ecc2c6046c1c0fd" translate="yes" xml:space="preserve">
          <source>GHC allows existentials to be used with records syntax as well. For example:</source>
          <target state="translated">GHC позволяет использовать экзистенциалы и с синтаксисом записей.Например:</target>
        </trans-unit>
        <trans-unit id="7c1ae7a2aaa5f27ea408c81b882456db054bdf4d" translate="yes" xml:space="preserve">
          <source>GHC allows for numeric literals to be given in decimal, octal, hexadecimal, binary, or float notation.</source>
          <target state="translated">GHC позволяет давать числовые буквы в десятичной,восьмеричной,шестнадцатеричной,двоичной или плавающей нотации.</target>
        </trans-unit>
        <trans-unit id="b980cf594e963e0e8219b555b4d47dab40b3eb42" translate="yes" xml:space="preserve">
          <source>GHC allows stand-alone &lt;code&gt;deriving&lt;/code&gt; declarations, enabled by &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">GHC позволяет автономное &lt;code&gt;deriving&lt;/code&gt; деклараций с помощью &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;StandaloneDeriving&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8296b4add8c32598594b426a3d8785f116cea0b4" translate="yes" xml:space="preserve">
          <source>GHC allows type constructors, classes, and type variables to be operators, and to be written infix, very much like expressions. More specifically:</source>
          <target state="translated">GHC позволяет конструкторам типов,классам и переменным типа быть операторами и быть написанным инффиксом,очень похожим на выражения.Точнее:</target>
        </trans-unit>
        <trans-unit id="eb4326185e022f2904a00d722e6d3c8a8c919585" translate="yes" xml:space="preserve">
          <source>GHC also permits visible kind application, where users can declare the kind arguments to be instantiated in kind-polymorphic cases. Its usage parallels visible type application in the term level, as specified above.</source>
          <target state="translated">GHC также разрешает применение видимого вида,где пользователи могут объявить аргументы вида,которые должны быть инстанциированы в добро-полиморфных случаях.Его использование параллельно с применением видимого типа на уровне терминов,как указано выше.</target>
        </trans-unit>
        <trans-unit id="e0505316426448a3c6e8360de65d79da12c2648e" translate="yes" xml:space="preserve">
          <source>GHC also supports &lt;em&gt;kind-heterogeneous&lt;/em&gt; equality, which relates two types of potentially different kinds. Heterogeneous equality is spelled &lt;code&gt;~~&lt;/code&gt;. Here are the kinds of &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~~&lt;/code&gt; to better understand their difference:</source>
          <target state="translated">GHC также поддерживает равенство по &lt;em&gt;типу и неоднородности&lt;/em&gt; , которое связывает два типа потенциально разных видов. Гетерогенное равенство пишется &lt;code&gt;~~&lt;/code&gt; . Вот виды &lt;code&gt;~&lt;/code&gt; и &lt;code&gt;~~&lt;/code&gt; , чтобы лучше понять их разницу:</target>
        </trans-unit>
        <trans-unit id="ba76d7ceb7b661bae37e18ce6f07732378f6626a" translate="yes" xml:space="preserve">
          <source>GHC always treats the &lt;em&gt;last&lt;/em&gt; parameter of the instance (&lt;code&gt;Foo&lt;/code&gt; in this example) as the type whose instance is being derived.</source>
          <target state="translated">GHC всегда обрабатывает &lt;em&gt;последний&lt;/em&gt; параметр экземпляра ( &lt;code&gt;Foo&lt;/code&gt; в этом примере) как тип, экземпляр которого является производным.</target>
        </trans-unit>
        <trans-unit id="3c323be157c96acdab287f807375f9b719b64a63" translate="yes" xml:space="preserve">
          <source>GHC applies the dreaded Monomorphism Restriction (section 4.5.5 of the Haskell Report) to implicit parameters. For example, consider:</source>
          <target state="translated">GHC применяет к неявным параметрам страшное ограничение мономорфизма (раздел 4.5.5 отчета Хаскелла).Например,рассмотрим:</target>
        </trans-unit>
        <trans-unit id="085bc7758e841a7674950854ea86b028e0155c10" translate="yes" xml:space="preserve">
          <source>GHC assumes that source files are ASCII or UTF-8 only, other encoding are not recognised. However, invalid UTF-8 sequences will be ignored in comments, so it is possible to use other encodings such as Latin-1, as long as the non-comment source code is ASCII only.</source>
          <target state="translated">GHC предполагает,что исходные файлы являются только ASCII или UTF-8,другие кодировки не распознаются.Однако недействительные последовательности в кодировке UTF-8 будут игнорироваться в комментариях,поэтому можно использовать другие кодировки,такие как Latin-1,при условии,что некомментируемый исходный код является только ASCII.</target>
        </trans-unit>
        <trans-unit id="db91b54c27a7f2bcbfa6b8c3b3b4820b8e9289ae" translate="yes" xml:space="preserve">
          <source>GHC attempts to detect when threads are deadlocked using the garbage collector. A thread that is not reachable (cannot be found by following pointers from live objects) must be deadlocked, and in this case the thread is sent an exception. The exception is either &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt;, depending on the way in which the thread is deadlocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3ac693ce7ba01fac9e81d67e5485761f5520b6" translate="yes" xml:space="preserve">
          <source>GHC attempts to detect when threads are deadlocked using the garbage collector. A thread that is not reachable (cannot be found by following pointers from live objects) must be deadlocked, and in this case the thread is sent an exception. The exception is either &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt;, depending on the way in which the thread is deadlocked.</source>
          <target state="translated">GHC пытается определить, когда потоки зашли в тупик, используя сборщик мусора. Поток, который недоступен (не может быть найден по указателям от живых объектов), должен быть заблокирован, и в этом случае потоку отправляется исключение. Исключение составляют &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt; , в зависимости от способа блокировки потока.</target>
        </trans-unit>
        <trans-unit id="c272c9b0ad07c2ab3a7ed8c9cf27b583eb6bbea9" translate="yes" xml:space="preserve">
          <source>GHC attempts to detect when threads are deadlocked using the garbage collector. A thread that is not reachable (cannot be found by following pointers from live objects) must be deadlocked, and in this case the thread is sent an exception. The exception is either &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt;, depending on the way in which the thread is deadlocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e22a881769a40b9be873a2cbaae3065ee10a9c" translate="yes" xml:space="preserve">
          <source>GHC builds up a wealth of information about a Haskell source file as it compiles it. Extended interface files are a way of persisting some of this information to disk so that external tools, such as IDE&amp;rsquo;s, can avoid parsing, typechecking, and renaming all over again. These files contain</source>
          <target state="translated">GHC накапливает огромное количество информации об исходном файле Haskell во время его компиляции. Файлы расширенного интерфейса - это способ сохранить часть этой информации на диске, чтобы внешние инструменты, такие как IDE, могли избежать повторного синтаксического анализа, проверки типов и переименования. Эти файлы содержат</target>
        </trans-unit>
        <trans-unit id="95040b8ff0496443822f0456826fbfe3fd01b8e2" translate="yes" xml:space="preserve">
          <source>GHC calculates a fingerprint (in fact an MD5 hash) of each interface file, and of each declaration within the interface file. It also keeps in every interface file a list of the fingerprints of everything it used when it last compiled the file. If the source file&amp;rsquo;s modification date is earlier than the &lt;code&gt;.o&lt;/code&gt; file&amp;rsquo;s date (i.e. the source hasn&amp;rsquo;t changed since the file was last compiled), and the recompilation checking is on, GHC will be clever. It compares the fingerprints on the things it needs this time with the fingerprints on the things it needed last time (gleaned from the interface file of the module being compiled); if they are all the same it stops compiling early in the process saying &amp;ldquo;Compilation IS NOT required&amp;rdquo;. What a beautiful sight!</source>
          <target state="translated">GHC вычисляет отпечаток (фактически, хэш MD5) каждого файла интерфейса и каждого объявления в файле интерфейса. Он также хранит в каждом файле интерфейса список отпечатков всего, что он использовал при последней компиляции файла. Если дата изменения исходного файла раньше, чем дата файла &lt;code&gt;.o&lt;/code&gt; (т. Е. Источник не изменился с момента последней компиляции файла), и проверка перекомпиляции включена, GHC подойдет. Он сравнивает отпечатки пальцев на предметах, которые ему нужны на этот раз, с отпечатками на предметах, которые ему понадобились в прошлый раз (взяты из интерфейсного файла компилируемого модуля); если они все одинаковы, он прекращает компиляцию на ранней стадии процесса, говоря: &amp;laquo;Компиляция НЕ требуется&amp;raquo;. Какое красивое зрелище!</target>
        </trans-unit>
        <trans-unit id="7db002a47d7a1c542bad6dcda111e3df7de5d2cf" translate="yes" xml:space="preserve">
          <source>GHC can also be configured using environment variables. Currently the only variable it supports is &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt;, which, when set, disables Unicode output regardless of locale settings. &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt; can be set to anything +(event an empty string) to trigger this behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a07d417f72643413044febaee57f46f8892bf38" translate="yes" xml:space="preserve">
          <source>GHC can be quite a bit more aggressive with pieces of code if it knows they are not exported.</source>
          <target state="translated">GHC может быть более агрессивным с кусками кода,если он знает,что они не экспортируются.</target>
        </trans-unit>
        <trans-unit id="20b3fdac58effb1981a662cd5b9d15a2246601cf" translate="yes" xml:space="preserve">
          <source>GHC comes with a number of libraries. These are described in separate documentation.</source>
          <target state="translated">GHC поставляется с несколькими библиотеками.Они описаны в отдельной документации.</target>
        </trans-unit>
        <trans-unit id="e04da29f82d35f8657a7c056280732b0f61a3942" translate="yes" xml:space="preserve">
          <source>GHC comes with a time and space profiling system, so that you can answer questions like &amp;ldquo;why is my program so slow?&amp;rdquo;, or &amp;ldquo;why is my program using so much memory?&amp;rdquo;.</source>
          <target state="translated">GHC поставляется с системой профилирования времени и пространства, так что вы можете ответить на такие вопросы, как &amp;laquo;почему моя программа такая медленная?&amp;raquo; Или &amp;laquo;почему моя программа использует так много памяти?&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="da055bb0f39bef03c75247c94877951076bed2b9" translate="yes" xml:space="preserve">
          <source>GHC compiles some program constructs slowly:</source>
          <target state="translated">GHC медленно компилирует некоторые конструкции программы:</target>
        </trans-unit>
        <trans-unit id="de2e40df6054756a65674cc009e4351de51b3690" translate="yes" xml:space="preserve">
          <source>GHC completely ignores the floating-point environment, the runtime neither modifies nor reads it.</source>
          <target state="translated">GHC полностью игнорирует окружение с плавающей точкой,время выполнения не изменяет и не читает его.</target>
        </trans-unit>
        <trans-unit id="549d84269c7b3028d7034e66451015b450c55e63" translate="yes" xml:space="preserve">
          <source>GHC creates a subdirectory &lt;code&gt;.hpc&lt;/code&gt; in the current directory, and puts HPC index (&lt;code&gt;.mix&lt;/code&gt;) files in there, one for each module compiled. You don&amp;rsquo;t need to worry about these files: they contain information needed by the &lt;code&gt;hpc&lt;/code&gt; tool to generate the coverage data for compiled modules after the program is run.</source>
          <target state="translated">GHC создает подкаталог &lt;code&gt;.hpc&lt;/code&gt; в текущем каталоге и помещает &lt;code&gt;.mix&lt;/code&gt; файлы индекса HPC ( .mix ), по одному для каждого скомпилированного модуля. Вам не нужно беспокоиться об этих файлах: они содержат информацию, необходимую инструменту &lt;code&gt;hpc&lt;/code&gt; для создания данных покрытия для скомпилированных модулей после запуска программы.</target>
        </trans-unit>
        <trans-unit id="704d8fd09c4c661d97d55003569a629d6a64a062" translate="yes" xml:space="preserve">
          <source>GHC currently does kind checking before expanding synonyms (though even that could be changed).</source>
          <target state="translated">В настоящее время GHC делает любезную проверку перед расширением синонимов (хотя даже это можно было бы изменить).</target>
        </trans-unit>
        <trans-unit id="d5c2a962ee75e672cc63c1570d298f7423d987d4" translate="yes" xml:space="preserve">
          <source>GHC currently uses a very simple, syntactic, matching algorithm for matching a rule LHS with an expression. It seeks a substitution which makes the LHS and expression syntactically equal modulo alpha conversion. The pattern (rule), but not the expression, is eta-expanded if necessary. (Eta-expanding the expression can lead to laziness bugs.) But not beta conversion (that&amp;rsquo;s called higher-order matching).</source>
          <target state="translated">В настоящее время GHC использует очень простой синтаксический алгоритм сопоставления для сопоставления правила LHS с выражением. Он ищет замену, которая делает LHS и выражение синтаксически равными по модулю альфа-преобразования. Если необходимо, шаблон (правило), но не выражение, расширяется. (Это расширение выражения может привести к ошибкам &quot;лени&quot;.) Но не бета-преобразованием (это называется сопоставлением более высокого порядка).</target>
        </trans-unit>
        <trans-unit id="ef6d67c2bca6e1b47545829cfc42b1d411dd7f6d" translate="yes" xml:space="preserve">
          <source>GHC disambiguates between multiple &lt;code&gt;COMPLETE&lt;/code&gt; sets based on this rationale. To make things more formal, when the pattern-match checker requests a set of constructors for some data type constructor &lt;code&gt;T&lt;/code&gt;, the checker returns:</source>
          <target state="translated">GHC устраняет неоднозначность между несколькими &lt;code&gt;COMPLETE&lt;/code&gt; наборами на основе этого объяснения. Чтобы сделать вещи более формальными, когда средство проверки сопоставления с образцом запрашивает набор конструкторов для некоторого конструктора типа данных &lt;code&gt;T&lt;/code&gt; , средство проверки возвращает:</target>
        </trans-unit>
        <trans-unit id="bd05d936e9882b073172126b6706e5f4c689fb33" translate="yes" xml:space="preserve">
          <source>GHC discharges the constraint as soon as it knows what concrete type-level literal is being used in the program. Note that this works only for &lt;em&gt;literals&lt;/em&gt; and not arbitrary type expressions. For example, a constraint of the form &lt;code&gt;KnownNat (a + b)&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; be simplified to &lt;code&gt;(KnownNat a, KnownNat b)&lt;/code&gt;; instead, GHC will keep the constraint as is, until it can simplify &lt;code&gt;a + b&lt;/code&gt; to a constant value.</source>
          <target state="translated">GHC снимает ограничение, как только узнает, какой конкретный литерал уровня типа используется в программе. Обратите внимание, что это работает только для &lt;em&gt;литералов,&lt;/em&gt; а не для произвольных выражений типов. Например, ограничение формы &lt;code&gt;KnownNat (a + b)&lt;/code&gt; будет &lt;em&gt;не&lt;/em&gt; быть упрощена &lt;code&gt;(KnownNat a, KnownNat b)&lt;/code&gt; ; вместо этого GHC сохранит ограничение как есть, пока не сможет упростить &lt;code&gt;a + b&lt;/code&gt; до постоянного значения.</target>
        </trans-unit>
        <trans-unit id="167343e68b8bf1a9e7ec5d0c5832fa2540cf35a0" translate="yes" xml:space="preserve">
          <source>GHC does not allow you to have a data type with a context that mentions type variables that are not data type parameters. For example:</source>
          <target state="translated">GHC не позволяет иметь тип данных с контекстом,в котором упоминаются переменные типа,не являющиеся параметрами типа данных.Например:</target>
        </trans-unit>
        <trans-unit id="b579c8b8d2f4a7ab2a00594e0e2267c4041770d7" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t do the fixity resolution in expressions during parsing as required by Haskell 98 (but not by Haskell 2010). For example, according to the Haskell 98 report, the following expression is legal:</source>
          <target state="translated">GHC не выполняет разрешение фиксации в выражениях во время синтаксического анализа, как того требует Haskell 98 (но не Haskell 2010). Например, согласно отчету Haskell 98, следующее выражение допустимо:</target>
        </trans-unit>
        <trans-unit id="8769daf9bb42ddf2fdd9c103027d5dea23101781" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t have to be restarted for each compilation, which means it can cache information between compilations. Compiling a multi-module program with &lt;code&gt;ghc --make&lt;/code&gt; can be up to twice as fast as running &lt;code&gt;ghc&lt;/code&gt; individually on each source file.</source>
          <target state="translated">GHC не нужно перезапускать для каждой компиляции, что означает, что он может кэшировать информацию между компиляциями. Компиляция многомодульной программы с помощью &lt;code&gt;ghc --make&lt;/code&gt; может быть в два раза быстрее, чем запуск &lt;code&gt;ghc&lt;/code&gt; отдельно для каждого исходного файла.</target>
        </trans-unit>
        <trans-unit id="7fc5be5c4ca5725b6d97a12bfd6fd11cb070f451" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t implement complete full laziness. Although GHC&amp;rsquo;s full-laziness optimisation does enable some transformations which would be performed by a fully lazy implementation (such as extracting repeated computations from loops), these transformations are not applied consistently, so don&amp;rsquo;t rely on them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91f388f5cbc4088b94a5ec84cec7c04e6042e38" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t implement complete full-laziness. When optimisation in on, and &lt;code&gt;-fno-full-laziness&lt;/code&gt; is not given, some transformations that increase sharing are performed, such as extracting repeated computations from a loop. These are the same transformations that a fully lazy implementation would do, the difference is that GHC doesn&amp;rsquo;t consistently apply full-laziness, so don&amp;rsquo;t rely on it.</source>
          <target state="translated">GHC не реализует полную лень. Когда оптимизация &lt;code&gt;-fno-full-laziness&lt;/code&gt; и -fno-full-laziness не задана, выполняются некоторые преобразования, увеличивающие совместное использование, например, извлечение повторяющихся вычислений из цикла. Это те же преобразования, что и при полностью ленивой реализации, разница в том, что GHC не всегда применяет полную ленивость, поэтому не полагайтесь на нее.</target>
        </trans-unit>
        <trans-unit id="bfe0f580bb15aa44cde9df1fbad436113357809b" translate="yes" xml:space="preserve">
          <source>GHC ensures that inlining cannot go on forever: every mutually-recursive group is cut by one or more &lt;em&gt;loop breakers&lt;/em&gt; that is never inlined (see &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm&quot;&gt;Secrets of the GHC inliner, JFP 12(4) July 2002&lt;/a&gt;). GHC tries not to select a function with an &lt;code&gt;INLINE&lt;/code&gt; pragma as a loop breaker, but when there is no choice even an INLINE function can be selected, in which case the &lt;code&gt;INLINE&lt;/code&gt; pragma is ignored. For example, for a self-recursive function, the loop breaker can only be the function itself, so an &lt;code&gt;INLINE&lt;/code&gt; pragma is always ignored.</source>
          <target state="translated">GHC гарантирует, что встраивание не может продолжаться вечно: каждая взаимно рекурсивная группа отсекается одним или несколькими &lt;em&gt;прерывателями цикла,&lt;/em&gt; которые никогда не встраиваются (см. &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm&quot;&gt;Секреты встроенного модуля GHC, JFP 12 (4) июль 2002 г.&lt;/a&gt; ). GHC пытается не выбирать функцию с &lt;code&gt;INLINE&lt;/code&gt; в качестве прерывателя цикла, но когда выбора нет, можно выбрать даже функцию INLINE, и в этом случае прагма &lt;code&gt;INLINE&lt;/code&gt; игнорируется. Например, для саморекурсивной функции прерывателем цикла может быть только сама функция, поэтому прагма &lt;code&gt;INLINE&lt;/code&gt; всегда игнорируется.</target>
        </trans-unit>
        <trans-unit id="d1e987d1c3d82c8013500d719ac2e258ed684a94" translate="yes" xml:space="preserve">
          <source>GHC exposes its internal APIs to users through the built-in ghc package. It allows you to write programs that leverage GHC&amp;rsquo;s entire compilation driver, in order to analyze or compile Haskell code programmatically. Furthermore, GHC gives users the ability to load compiler plugins during compilation - modules which are allowed to view and change GHC&amp;rsquo;s internal intermediate representation, Core. Plugins are suitable for things like experimental optimizations or analysis, and offer a lower barrier of entry to compiler development for many common cases.</source>
          <target state="translated">GHC предоставляет пользователям свои внутренние API через встроенный пакет ghc. Он позволяет вам писать программы, которые используют весь драйвер компиляции GHC для программного анализа или компиляции кода Haskell. Кроме того, GHC дает пользователям возможность загружать плагины компилятора во время компиляции - модули, которым разрешено просматривать и изменять внутреннее промежуточное представление GHC, Core. Плагины подходят для таких вещей, как экспериментальная оптимизация или анализ, и предлагают более низкий порог входа для разработки компилятора во многих распространенных случаях.</target>
        </trans-unit>
        <trans-unit id="7c167fa8597da83d2d6c70ee64cf8fd148a64239" translate="yes" xml:space="preserve">
          <source>GHC extends the FFI with an additional calling convention &lt;code&gt;prim&lt;/code&gt;, e.g.:</source>
          <target state="translated">GHC расширяет FFI с дополнительным вызывающему конференц - &lt;code&gt;prim&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="2709b25bb09f206c0b1acccbf37562ea657795ca" translate="yes" xml:space="preserve">
          <source>GHC extends this list with several more classes that may be automatically derived:</source>
          <target state="translated">GHC расширяет этот список еще на несколько классов,которые могут быть автоматически выведены:</target>
        </trans-unit>
        <trans-unit id="b8da89741da234fc1301b6c98edbd981b7cba345" translate="yes" xml:space="preserve">
          <source>GHC generates case expressions without a default alternative in some cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2927c8c0dcc59d688d14e863c87024ee56f40a67" translate="yes" xml:space="preserve">
          <source>GHC has a &lt;code&gt;-dynload&lt;/code&gt; linking flag to select the method that is used to find shared libraries at runtime. There are currently two modes:</source>
          <target state="translated">GHC имеет &lt;code&gt;-dynload&lt;/code&gt; связывания -dynload для выбора метода, который используется для поиска разделяемых библиотек во время выполнения. В настоящее время существует два режима:</target>
        </trans-unit>
        <trans-unit id="37868d9918c1e5d3985d0159ec2eb8abe357d679" translate="yes" xml:space="preserve">
          <source>GHC has a comprehensive optimiser, so when you want to Really Go For It (and you&amp;rsquo;ve got time to spare) GHC can produce pretty fast code. Alternatively, the default option is to compile as fast as possible while not making too much effort to optimise the generated code (although GHC probably isn&amp;rsquo;t what you&amp;rsquo;d describe as a fast compiler :-).</source>
          <target state="translated">GHC имеет комплексный оптимизатор, поэтому, если вы действительно хотите пойти на это (и у вас есть свободное время), GHC может создавать довольно быстрый код. В качестве альтернативы вариант по умолчанию - скомпилировать как можно быстрее, не прилагая особых усилий для оптимизации сгенерированного кода (хотя GHC, вероятно, не то, что вы бы описали как быстрый компилятор :-).</target>
        </trans-unit>
        <trans-unit id="50704903e2fa0767c23ef5592e01c0142e232598" translate="yes" xml:space="preserve">
          <source>GHC has a custom solver for discharging constraints that involve class &lt;code&gt;Typeable&lt;/code&gt;, and handwritten instances are forbidden. This ensures that the programmer cannot subvert the type system by writing bogus instances.</source>
          <target state="translated">GHC имеет собственный решатель для &lt;code&gt;Typeable&lt;/code&gt; ограничений, которые включают класс Typeable , а рукописные экземпляры запрещены. Это гарантирует, что программист не сможет разрушить систему типов, написав поддельные экземпляры.</target>
        </trans-unit>
        <trans-unit id="dd2651a370808140aecb0389d7da1dfec93f9973" translate="yes" xml:space="preserve">
          <source>GHC has a few built-in functions with special behaviour. In particular:</source>
          <target state="translated">GHC имеет несколько встроенных функций со специальным поведением.В частности:</target>
        </trans-unit>
        <trans-unit id="8bdd8132100b5a3de15d0bde30890b059463f096" translate="yes" xml:space="preserve">
          <source>GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt;, use &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt;. To reverse &lt;code&gt;-Werror&lt;/code&gt;, which makes all warnings into errors, use &lt;code&gt;-Wwarn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b5cd4da1d694b042ff22d18106007056b905706" translate="yes" xml:space="preserve">
          <source>GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt;, use &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt;. To reverse``-Werror``, which makes all warnings into errors, use &lt;code&gt;-Wwarn&lt;/code&gt;.</source>
          <target state="translated">В GHC есть несколько опций, которые выбирают, какие типы сообщений о нефатальных ошибках, также известных как предупреждения, могут быть сгенерированы во время компиляции. Некоторые параметры управляют отдельными предупреждениями, а другие - коллекциями предупреждений. Чтобы отключить отдельное предупреждение &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt; , используйте &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt; . Чтобы отменить ошибку -Werror, которая превращает все предупреждения в ошибки, используйте &lt;code&gt;-Wwarn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc26cabb6e31043f801f34ba96fce33c2cd76158" translate="yes" xml:space="preserve">
          <source>GHC has experimental support for &lt;em&gt;signature thinning&lt;/em&gt;, which is used when a signature has an explicit export list without a module export of the signature itself. In this case, the export list applies to the final export list &lt;em&gt;after&lt;/em&gt; merging, in particular, you may refer to entities which are not declared in the body of the local &lt;code&gt;hsig&lt;/code&gt; file.</source>
          <target state="translated">GHC имеет экспериментальную поддержку &lt;em&gt;прореживания подписи&lt;/em&gt; , которая используется, когда подпись имеет явный список экспорта без экспорта модуля самой подписи. В этом случае список экспорта применяется к окончательному списку экспорта &lt;em&gt;после&lt;/em&gt; слияния, в частности, вы можете ссылаться на объекты, которые не объявлены в теле локального файла &lt;code&gt;hsig&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae1857d5e68b869ba0f3a7a41a92f227174acdbb" translate="yes" xml:space="preserve">
          <source>GHC has extremely flaky support for &lt;em&gt;impredicative polymorphism&lt;/em&gt;, enabled with &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt;&lt;code&gt;ImpredicativeTypes&lt;/code&gt;&lt;/a&gt;. If it worked, this would mean that you &lt;em&gt;could&lt;/em&gt; call a polymorphic function at a polymorphic type, and parameterise data structures over polymorphic types. For example:</source>
          <target state="translated">GHC имеет крайне ненадежную поддержку &lt;em&gt;непредикативного полиморфизма&lt;/em&gt; , включенную с помощью &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt; &lt;code&gt;ImpredicativeTypes&lt;/code&gt; &lt;/a&gt; . Если бы это сработало, это означало бы, что вы &lt;em&gt;могли бы&lt;/em&gt; вызывать полиморфную функцию для полиморфного типа и параметризовать структуры данных по полиморфным типам. Например:</target>
        </trans-unit>
        <trans-unit id="a7863559f9ec9cb2b2a5ec1dc3cee9a5175090f2" translate="yes" xml:space="preserve">
          <source>GHC has the ability to load compiler plugins at compile time. The feature is similar to the one provided by &lt;a href=&quot;http://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt;, and allows users to write plugins that can adjust the behaviour of the constraint solver, inspect and modify the compilation pipeline, as well as transform and inspect GHC&amp;rsquo;s intermediate language, Core. Plugins are suitable for experimental analysis or optimization, and require no changes to GHC&amp;rsquo;s source code to use.</source>
          <target state="translated">GHC имеет возможность загружать плагины компилятора во время компиляции. Эта функция аналогична функции, предоставляемой &lt;a href=&quot;http://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt; , и позволяет пользователям писать плагины, которые могут настраивать поведение решателя ограничений, проверять и изменять конвейер компиляции, а также преобразовывать и проверять промежуточный язык GHC, Core. Плагины подходят для экспериментального анализа или оптимизации и не требуют изменения исходного кода GHC для использования.</target>
        </trans-unit>
        <trans-unit id="22a7c64e218b3312ad9be925711deec4357a32a4" translate="yes" xml:space="preserve">
          <source>GHC has the ability to load compiler plugins at compile time. The feature is similar to the one provided by &lt;a href=&quot;https://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt;, and allows users to write plugins that can adjust the behaviour of the constraint solver, inspect and modify the compilation pipeline, as well as transform and inspect GHC&amp;rsquo;s intermediate language, Core. Plugins are suitable for experimental analysis or optimization, and require no changes to GHC&amp;rsquo;s source code to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a2700135014d3391d235e2779538d1dbae6f7d0" translate="yes" xml:space="preserve">
          <source>GHC has to link your code with various libraries, possibly including: user-supplied, GHC-supplied, and system-supplied (&lt;code&gt;-lm&lt;/code&gt; math library, for example).</source>
          <target state="translated">GHC должен связать ваш код с различными библиотеками, в том числе, возможно, с пользовательскими, GHC и системными (например, &lt;code&gt;-lm&lt;/code&gt; math library).</target>
        </trans-unit>
        <trans-unit id="6fb872fe440b0daf385b4b8ff21367d65f6f7fa0" translate="yes" xml:space="preserve">
          <source>GHC has two main components: an interactive Haskell interpreter (also known as GHCi), described in &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt;, and a batch compiler, described throughout &lt;a href=&quot;using#using-ghc&quot;&gt;Using GHC&lt;/a&gt;. In fact, GHC consists of a single program which is just run with different options to provide either the interactive or the batch system.</source>
          <target state="translated">GHC состоит из двух основных компонентов: интерактивного интерпретатора Haskell (также известного как GHCi), описанного в &lt;a href=&quot;ghci#ghci&quot;&gt;разделе Использование GHCi&lt;/a&gt; , и пакетного компилятора, описанного в &lt;a href=&quot;using#using-ghc&quot;&gt;разделе Использование GHC&lt;/a&gt; . Фактически, GHC состоит из одной программы, которая просто запускается с разными параметрами для обеспечения либо интерактивной, либо пакетной системы.</target>
        </trans-unit>
        <trans-unit id="2dfd60f79ee4ba2079225942cc8483b2227556fc" translate="yes" xml:space="preserve">
          <source>GHC home page</source>
          <target state="translated">домашняя страница GHC</target>
        </trans-unit>
        <trans-unit id="7b51be1ff5f1ddedfd931ac8c672d1058c111c02" translate="yes" xml:space="preserve">
          <source>GHC ignores assertions when optimisation is turned on with the &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; flag. That is, expressions of the form &lt;code&gt;assert pred e&lt;/code&gt; will be rewritten to &lt;code&gt;e&lt;/code&gt;. You can also disable assertions using the &lt;a href=&quot;../using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fignore-asserts&lt;/code&gt;&lt;/a&gt; option. The option &lt;a href=&quot;../using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fno-ignore-asserts&lt;/code&gt;&lt;/a&gt; allows enabling assertions even when optimisation is turned on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f354abc94fdf02ee4cd7aec76ce15252272ca1c5" translate="yes" xml:space="preserve">
          <source>GHC ignores assertions when optimisation is turned on with the &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; flag. That is, expressions of the form &lt;code&gt;assert pred e&lt;/code&gt; will be rewritten to &lt;code&gt;e&lt;/code&gt;. You can also disable assertions using the &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fignore-asserts&lt;/code&gt;&lt;/a&gt; option. The option &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fno-ignore-asserts&lt;/code&gt;&lt;/a&gt; allows enabling assertions even when optimisation is turned on.</source>
          <target state="translated">GHC игнорирует утверждения, когда оптимизация &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; флагом -O . То есть выражения вида &lt;code&gt;assert pred e&lt;/code&gt; будут переписаны на &lt;code&gt;e&lt;/code&gt; . Вы также можете отключить утверждения, используя параметр &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fignore-asserts&lt;/code&gt; &lt;/a&gt; . Параметр &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fno-ignore-asserts&lt;/code&gt; &lt;/a&gt; позволяет включать утверждения, даже если включена оптимизация.</target>
        </trans-unit>
        <trans-unit id="d193c3b9ee9bd64a2c40a91ed8f0f72fd80e9a86" translate="yes" xml:space="preserve">
          <source>GHC implements a number of GHC-specific extensions to the FFI Chapter of the Haskell 2010 Report. These extensions are described in &lt;a href=&quot;#ffi-ghcexts&quot;&gt;GHC extensions to the FFI Chapter&lt;/a&gt;, but please note that programs using these features are not portable. Hence, these features should be avoided where possible.</source>
          <target state="translated">GHC реализует ряд специфичных для GHC расширений для главы FFI отчета Haskell 2010. Эти расширения описаны в &lt;a href=&quot;#ffi-ghcexts&quot;&gt;расширениях GHC к главе FFI&lt;/a&gt; , но учтите, что программы, использующие эти функции, не переносимы. Следовательно, по возможности следует избегать этих функций.</target>
        </trans-unit>
        <trans-unit id="1383e2906207b123b97681b2a7fc069bbcc74f65" translate="yes" xml:space="preserve">
          <source>GHC implements an &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; extension as specified in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0013-unlifted-newtypes.rst&quot;&gt;this GHC proposal&lt;/a&gt;. &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; relaxes the restrictions around what types can appear inside of a &lt;code&gt;newtype&lt;/code&gt;. For example, the type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01529699aab62d7c26cc7ea486b2bf3a314d4cc" translate="yes" xml:space="preserve">
          <source>GHC implements pre-emptive multitasking: the execution of threads are interleaved in a random fashion. More specifically, a thread may be pre-empted whenever it allocates some memory, which unfortunately means that tight loops which do no allocation tend to lock out other threads (this only seems to happen with pathological benchmark-style code, however).</source>
          <target state="translated">GHC реализует упреждающую многозадачность:выполнение нитей чередуется случайным образом.Точнее,поток может быть вытеснен всякий раз,когда он выделяет некоторую память,что,к сожалению,означает,что узкие циклы,которые не выделяются,имеют тенденцию блокировать другие потоки (это,однако,происходит только в патологическом коде в стиле бенчмарка).</target>
        </trans-unit>
        <trans-unit id="784ab21057de1abbfb56e2df7ec894a968e45b8e" translate="yes" xml:space="preserve">
          <source>GHC implements some major extensions to Haskell to support concurrent and parallel programming. Let us first establish terminology:</source>
          <target state="translated">GHC реализует некоторые основные расширения Haskell для поддержки параллельного и параллельного программирования.Давайте сначала установим терминологию:</target>
        </trans-unit>
        <trans-unit id="384027abc0c0211dec27023d54430b773e937baf" translate="yes" xml:space="preserve">
          <source>GHC implements this test conservatively when type functions, or type variables, are involved. For example</source>
          <target state="translated">GHC реализует данный тест консервативно,когда речь идет о функциях типа,или о переменных типа.Например</target>
        </trans-unit>
        <trans-unit id="0fc31183c1e70f82a9bdd1edfbb35d0be9ae0a6c" translate="yes" xml:space="preserve">
          <source>GHC includes a variety of flags that allow arbitrary processes to be run at compilation time. One such example is the &lt;a href=&quot;../phases#pre-processor&quot;&gt;custom pre-processor&lt;/a&gt; flag. Another is the ability of Template Haskell to execute Haskell code at compilation time, including IO actions. Safe Haskell &lt;em&gt;does not address this danger&lt;/em&gt; (although, Template Haskell is a disallowed feature).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0d768afcace80925944278709c9070e93b287f" translate="yes" xml:space="preserve">
          <source>GHC includes a variety of flags that allow arbitrary processes to be run at compilation time. One such example is the &lt;a href=&quot;phases#pre-processor&quot;&gt;custom pre-processor&lt;/a&gt; flag. Another is the ability of Template Haskell to execute Haskell code at compilation time, including IO actions. Safe Haskell &lt;em&gt;does not address this danger&lt;/em&gt; (although, Template Haskell is a disallowed feature).</source>
          <target state="translated">GHC включает в себя множество флагов, которые позволяют запускать произвольные процессы во время компиляции. Одним из таких примеров является &lt;a href=&quot;phases#pre-processor&quot;&gt;настраиваемый&lt;/a&gt; флаг препроцессора . Другой способ - это способность Template Haskell выполнять код Haskell во время компиляции, включая операции ввода-вывода. Safe Haskell &lt;em&gt;не устраняет эту опасность&lt;/em&gt; (хотя Template Haskell является запрещенной функцией).</target>
        </trans-unit>
        <trans-unit id="d09bb52c1f872e95bf9ee5c47a2b96510a0df672" translate="yes" xml:space="preserve">
          <source>GHC includes support for running Haskell programs in parallel on symmetric, shared-memory multi-processor (SMP). By default GHC runs your program on one processor; if you want it to run in parallel you must link your program with the &lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, and run it with the RTS &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option; see &lt;a href=&quot;../using-concurrent#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;). The runtime will schedule the running Haskell threads among the available OS threads, running as many in parallel as you specified with the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a501e79a5be96c764587e4f4a538a164615c592" translate="yes" xml:space="preserve">
          <source>GHC includes support for running Haskell programs in parallel on symmetric, shared-memory multi-processor (SMP). By default GHC runs your program on one processor; if you want it to run in parallel you must link your program with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, and run it with the RTS &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option; see &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;). The runtime will schedule the running Haskell threads among the available OS threads, running as many in parallel as you specified with the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS option.</source>
          <target state="translated">GHC включает поддержку параллельного запуска программ Haskell на симметричном мультипроцессоре с общей памятью (SMP). По умолчанию GHC запускает вашу программу на одном процессоре; если вы хотите, чтобы он работал параллельно, вы должны связать свою программу с &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; и запустить ее с параметром RTS &lt;code&gt;-N ⟨x⟩&lt;/code&gt; ; см. &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;Использование параллелизма SMP&lt;/a&gt; ). Среда выполнения будет планировать выполнение потоков Haskell среди доступных потоков ОС, выполняя столько параллельных потоков, сколько вы указали с помощью параметра &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS.</target>
        </trans-unit>
        <trans-unit id="8a61ad13cc654370f6a14c4d7207d6379e372d1d" translate="yes" xml:space="preserve">
          <source>GHC is a large program consisting of a number of stages. You can tell GHC to dump information from various stages of compilation using the &lt;code&gt;-ddump-⟨pass⟩&lt;/code&gt; flags listed below. Note that some of these tend to produce a lot of output. You can prevent them from clogging up your standard output by passing &lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHC - это большая программа, состоящая из нескольких этапов. Вы можете указать GHC сбрасывать информацию с разных этапов компиляции, используя флаги &lt;code&gt;-ddump-⟨pass⟩&lt;/code&gt; , перечисленные ниже. Обратите внимание, что некоторые из них, как правило, дают много результатов. Вы можете предотвратить засорение ими стандартного вывода, передав &lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e827b1ebcca328b1f8fef7330a8dfc0af882c0d" translate="yes" xml:space="preserve">
          <source>GHC is built on a raft of primitive data types and operations; &amp;ldquo;primitive&amp;rdquo; in the sense that they cannot be defined in Haskell itself. While you really can use this stuff to write fast code, we generally find it a lot less painful, and more satisfying in the long run, to use higher-level language features and libraries. With any luck, the code you write will be optimised to the efficient unboxed version in any case. And if it isn&amp;rsquo;t, we&amp;rsquo;d like to know about it.</source>
          <target state="translated">GHC построен на множестве примитивных типов данных и операций; &amp;laquo;Примитивные&amp;raquo; в том смысле, что они не могут быть определены в самом Haskell. Хотя вы действительно можете использовать этот материал для написания быстрого кода, мы, как правило, находим гораздо менее болезненным и более удовлетворительным в долгосрочной перспективе использовать языковые функции и библиотеки более высокого уровня. Если повезет, код, который вы пишете, в любом случае будет оптимизирован для эффективной распакованной версии. А если это не так, мы хотели бы знать об этом.</target>
        </trans-unit>
        <trans-unit id="036d822f43fafc704cccf229faeb8f39d429451c" translate="yes" xml:space="preserve">
          <source>GHC is itself a Haskell program, so if you need to pass options directly to GHC&amp;rsquo;s runtime system you can enclose them in &lt;code&gt;+RTS ... -RTS&lt;/code&gt; (see &lt;a href=&quot;runtime_control#runtime-control&quot;&gt;Running a compiled program&lt;/a&gt;).</source>
          <target state="translated">GHC сам по себе является программой Haskell, поэтому, если вам нужно передать параметры непосредственно в систему времени выполнения GHC, вы можете заключить их в &lt;code&gt;+RTS ... -RTS&lt;/code&gt; (см. &lt;a href=&quot;runtime_control#runtime-control&quot;&gt;Запуск скомпилированной программы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5f1fbb021ad6ec77459e40f9cdfa738fe516428c" translate="yes" xml:space="preserve">
          <source>GHC is surprisingly zippy for normal compilations without &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;!</source>
          <target state="translated">GHC на удивление быстр для обычных компиляций без &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; !</target>
        </trans-unit>
        <trans-unit id="e1b0068bc94f72b8b3701c6252a51b85e66a7b86" translate="yes" xml:space="preserve">
          <source>GHC is very cautious about duplicating work. For example, consider</source>
          <target state="translated">GHC очень осторожно относится к дублированию работы.Например,рассмотрим</target>
        </trans-unit>
        <trans-unit id="1e880a64634c393c137ab909ff23b9fa67d62722" translate="yes" xml:space="preserve">
          <source>GHC is very sensitive about interface files. For example, if it picks up a non-standard &lt;code&gt;Prelude.hi&lt;/code&gt; file, pretty terrible things will happen. If you turn on &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt;-XNoImplicitPrelude option, the compiler will almost surely die, unless you know what you are doing.</source>
          <target state="translated">GHC очень внимательно относится к интерфейсным файлам. Например, если он подхватит нестандартный файл &lt;code&gt;Prelude.hi&lt;/code&gt; , произойдут довольно ужасные вещи. Если вы включите параметр &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; -XNoImplicitPrelude, компилятор почти наверняка умрет, если вы не знаете, что делаете.</target>
        </trans-unit>
        <trans-unit id="8f98bd19130c85af22543d9122fb6b893c3ab021" translate="yes" xml:space="preserve">
          <source>GHC keeps trying to apply the rules as it optimises the program. For example, consider:</source>
          <target state="translated">GHC продолжает пытаться применять правила по мере оптимизации программы.Например,рассмотрим:</target>
        </trans-unit>
        <trans-unit id="c971ed60f0f8cac8a9dfb32c0fc05213d73e4927" translate="yes" xml:space="preserve">
          <source>GHC knows about two package databases in particular:</source>
          <target state="translated">В частности,GHC знает о двух пакетных базах данных:</target>
        </trans-unit>
        <trans-unit id="ee518910a69d6b3ec07ce5ab8b5533533d1b86a4" translate="yes" xml:space="preserve">
          <source>GHC lets you change the default RTS options for a program at compile time, using the &lt;code&gt;-with-rtsopts&lt;/code&gt; flag (&lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;). A common use for this is to give your program a default heap and/or stack size that is greater than the default. For example, to set &lt;code&gt;-H128m -K64m&lt;/code&gt;, link with &lt;code&gt;-with-rtsopts=&quot;-H128m -K64m&quot;&lt;/code&gt;.</source>
          <target state="translated">GHC позволяет вам изменить параметры RTS по умолчанию для программы во время компиляции, используя флаг &lt;code&gt;-with-rtsopts&lt;/code&gt; ( &lt;a href=&quot;phases#options-linker&quot;&gt;параметры, влияющие на связывание&lt;/a&gt; ). Обычно это используется для того, чтобы дать вашей программе размер кучи и / или стека по умолчанию, превышающий размер по умолчанию. Например, чтобы установить &lt;code&gt;-H128m -K64m&lt;/code&gt; , свяжите с &lt;code&gt;-with-rtsopts=&quot;-H128m -K64m&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb99e557b948da3d443c3d321414623817fdd5f6" translate="yes" xml:space="preserve">
          <source>GHC lets you exercise rudimentary control over certain RTS settings for any given program, by compiling in a &amp;ldquo;hook&amp;rdquo; that is called by the run-time system. The RTS contains stub definitions for these hooks, but by writing your own version and linking it on the GHC command line, you can override the defaults.</source>
          <target state="translated">GHC позволяет вам осуществлять элементарный контроль над некоторыми настройками RTS для любой данной программы путем компиляции в &amp;laquo;ловушку&amp;raquo;, которая вызывается системой времени выполнения. RTS содержит определения заглушек для этих хуков, но, написав свою собственную версию и связав ее в командной строке GHC, вы можете изменить значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="cad9041737a68aff4c044f186cb6f1f6cdc933e2" translate="yes" xml:space="preserve">
          <source>GHC lifts this restriction with language extension &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt;. The restriction is a pretty stupid one in the first place, so &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHC снимает это ограничение с помощью языкового расширения &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt; . Ограничение, во-первых, довольно глупое, поэтому &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt; подразумевается &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="026e2f888db92431c91e24d1a0558f32b93663ed" translate="yes" xml:space="preserve">
          <source>GHC lifts this restriction with language extension &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt;. The restriction is a pretty stupid one in the first place, so &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;multi_param_type_classes#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ba60a7f4df257517ab7d5d783f3cc489a09b60" translate="yes" xml:space="preserve">
          <source>GHC loves single-constructor data-types:</source>
          <target state="translated">GHC любит одноконструкторные типы данных:</target>
        </trans-unit>
        <trans-unit id="7fe0475e3ee29056ea60e7039fdeca427dd3ce9a" translate="yes" xml:space="preserve">
          <source>GHC maintains a property that the kind of all inhabited types (as distinct from type constructors or type-level data) tells us the runtime representation of values of that type. This datatype encodes the choice of runtime value. Note that &lt;code&gt;&lt;a href=&quot;ghc-exts#t:TYPE&quot;&gt;TYPE&lt;/a&gt;&lt;/code&gt; is parameterised by &lt;code&gt;&lt;a href=&quot;ghc-exts#t:RuntimeRep&quot;&gt;RuntimeRep&lt;/a&gt;&lt;/code&gt;; this is precisely what we mean by the fact that a type's kind encodes the runtime representation.</source>
          <target state="translated">GHC поддерживает свойство, согласно которому тип всех обитаемых типов (в отличие от конструкторов типов или данных уровня типа) сообщает нам представление значений этого типа во время выполнения. Этот тип данных кодирует выбор значения времени выполнения. Обратите внимание, что &lt;code&gt;&lt;a href=&quot;ghc-exts#t:TYPE&quot;&gt;TYPE&lt;/a&gt;&lt;/code&gt; параметризуется &lt;code&gt;&lt;a href=&quot;ghc-exts#t:RuntimeRep&quot;&gt;RuntimeRep&lt;/a&gt;&lt;/code&gt; ; именно это мы подразумеваем под тем фактом, что тип типа кодирует представление среды выполнения.</target>
        </trans-unit>
        <trans-unit id="1ff86cb3c00be570a738bdb82648ae498fe4fba6" translate="yes" xml:space="preserve">
          <source>GHC makes absolutely no attempt to verify that the LHS and RHS of a rule have the same meaning. That is undecidable in general, and infeasible in most interesting cases. The responsibility is entirely the programmer&amp;rsquo;s!</source>
          <target state="translated">GHC не делает абсолютно никаких попыток проверить, что LHS и RHS правила имеют одинаковое значение. В общем, это неразрешимо, и в большинстве интересных случаев это невозможно. Вся ответственность лежит на программисте!</target>
        </trans-unit>
        <trans-unit id="b7463d030f30e5fbf0ea5c1acd7285f721a4849a" translate="yes" xml:space="preserve">
          <source>GHC makes no attempt to make sure that the rules are confluent or terminating. For example:</source>
          <target state="translated">GHC не делает попыток убедиться в том,что правила сочетаются или прекращаются.Например:</target>
        </trans-unit>
        <trans-unit id="37534f2a655b7b54b3a6e0e503e96b3a7186887d" translate="yes" xml:space="preserve">
          <source>GHC may produce the following standard DIEs in the &lt;code&gt;.debug_info&lt;/code&gt; section,</source>
          <target state="translated">GHC может создавать следующие стандартные DIE в разделе &lt;code&gt;.debug_info&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="093f5ff97cdf917305aab74e98feadff3bea2477" translate="yes" xml:space="preserve">
          <source>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;../codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;../phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fasm&lt;/code&gt;&lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421a7300b70d01de5b5db3b095ba0095f1fbdbfa" translate="yes" xml:space="preserve">
          <source>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;phases#ghc-flag--fasm&quot;&gt;&lt;code&gt;-fasm&lt;/code&gt;&lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</source>
          <target state="translated">GHC больше не включает внешние файлы заголовков при компиляции через C, поэтому эта проверка не выполняется. Это изменение было внесено для совместимости с &lt;a href=&quot;codegens#native-code-gen&quot;&gt;генератором собственного кода&lt;/a&gt; ( &lt;a href=&quot;phases#ghc-flag--fasm&quot;&gt; &lt;code&gt;-fasm&lt;/code&gt; &lt;/a&gt; ) и для строгого соблюдения спецификации FFI, которая требует, чтобы вызовы FFI не подвергались расширению макросов и другим преобразованиям CPP, которые могут применяться при использовании файлов заголовков C. Этот подход также упрощает встраивание внешних вызовов через границы модуля и пакета: нет необходимости в том, чтобы файл заголовка был доступен при компиляции встроенной версии внешнего вызова, поэтому компилятор может встраивать внешние вызовы в любом контексте.</target>
        </trans-unit>
        <trans-unit id="9a9906447d97115265712315061f7cad299f0951" translate="yes" xml:space="preserve">
          <source>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fasm&lt;/code&gt;&lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b8ae90a6a33abf2e10b63d4f5e2fffb42594017" translate="yes" xml:space="preserve">
          <source>GHC normally imports &lt;code&gt;Prelude.hi&lt;/code&gt; files for you. If you&amp;rsquo;d rather it didn&amp;rsquo;t, then give it a &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; option. The idea is that you can then import a Prelude of your own. (But don&amp;rsquo;t call it &lt;code&gt;Prelude&lt;/code&gt;; the Haskell module namespace is flat, and you must not conflict with any Prelude module.)</source>
          <target state="translated">GHC обычно импортирует файлы &lt;code&gt;Prelude.hi&lt;/code&gt; для вас. Если вы этого не &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; укажите для него параметр -XNoImplicitPrelude . Идея состоит в том, что затем вы можете импортировать собственный Prelude. (Но не называйте это &lt;code&gt;Prelude&lt;/code&gt; ; пространство имен модуля Haskell плоское, и вы не должны конфликтовать с каким-либо модулем Prelude.)</target>
        </trans-unit>
        <trans-unit id="51a9a8d7dba56ae1e5e3495d0ce96e9d8abfbf97" translate="yes" xml:space="preserve">
          <source>GHC note: a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; will be automatically closed when the garbage collector detects that it has become unreferenced by the program. However, relying on this behaviour is not generally recommended: the garbage collector is unpredictable. If possible, use an explicit &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; to close &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s when they are no longer required. GHC does not currently attempt to free up file descriptors when they have run out, it is your responsibility to ensure that this doesn't happen.</source>
          <target state="translated">Примечание GHC: &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; будет автоматически закрыт, когда сборщик мусора обнаружит, что программа перестала ссылаться на него. Однако полагаться на это поведение обычно не рекомендуется: сборщик мусора непредсказуем. Если возможно, используйте явное &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; , чтобы закрыть &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; ы , когда они больше не нужны. GHC в настоящее время не пытается освободить файловые дескрипторы, когда они закончились, вы несете ответственность за то, чтобы этого не произошло.</target>
        </trans-unit>
        <trans-unit id="40c291d3bf2780069335f412ddeb31f3318572c7" translate="yes" xml:space="preserve">
          <source>GHC note: the number of capabilities is specified by the &lt;code&gt;+RTS -N&lt;/code&gt; option when the program is started. Capabilities can be fixed to actual processor cores with &lt;code&gt;+RTS -qa&lt;/code&gt; if the underlying operating system supports that, although in practice this is usually unnecessary (and may actually degrade performance in some cases - experimentation is recommended).</source>
          <target state="translated">Примечание GHC: количество возможностей указывается опцией &lt;code&gt;+RTS -N&lt;/code&gt; при запуске программы. Возможности могут быть зафиксированы для реальных ядер процессора с помощью &lt;code&gt;+RTS -qa&lt;/code&gt; , если базовая операционная система поддерживает это, хотя на практике в этом обычно нет необходимости (и в некоторых случаях может фактически снизить производительность - рекомендуется поэкспериментировать).</target>
        </trans-unit>
        <trans-unit id="115bd9cb4711dab5b627ce7841a7aee928c90c42" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">Примечания GHC: &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; имеет сильно оптимизированную реализацию в GHC. Он использует закрепленную память в куче со сборкой мусора, поэтому &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; не требует финализатора для освобождения памяти. Настоятельно рекомендуется использовать &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; и связанных функций, а не &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; с финализатором.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
