<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="2a4e313748880e797d1bcb646d76cb8547d19d57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type is sometimes used to represent a value which is either correct or an error; by convention, the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor is used to hold an error value and the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor is used to hold a correct value (mnemonic: &quot;right&quot; also means &quot;correct&quot;).</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; иногда используется для представления значения, которое является правильным или ошибочным; по соглашению конструктор &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; используется для хранения значения ошибки, а конструктор &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; используется для хранения правильного значения (мнемоника: &amp;laquo;right&amp;raquo; также означает &amp;laquo;правильный&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="f0e4baff05206c672300bb2b38395a9530159b34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type represents values with two possibilities: a value of type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; представляет значения с двумя возможностями: значение типа &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; равно &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c8bc066a25dbdc9345dc643976410a0121b2ada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; class defines equality (&lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) and inequality (&lt;code&gt;&lt;a href=&quot;data-eq#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt;). All the basic datatypes exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; are instances of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; may be derived for any datatype whose constituents are also instances of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; определяет равенство ( &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; ) и неравенство ( &lt;code&gt;&lt;a href=&quot;data-eq#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt; ). Все основные типы данных, экспортируемые &lt;a href=&quot;prelude&quot;&gt;Prelude,&lt;/a&gt; являются экземплярами &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; может быть получен для любого типа данных, составные части которого также являются экземплярами &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69af3900bc4a32d170db2d927f8de7596335e0e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances traverse the real part first.</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; экземплярах пересекают вещественную часть первыми.</target>
        </trans-unit>
        <trans-unit id="5eff372cb874b6edeef6ee4a0a04355990bb5ac2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a structure and returns the leftmost element of the structure matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-foldable#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; принимает предикат и структуру и возвращает самый левый элемент структуры, соответствующий предикату, или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если такого элемента нет.</target>
        </trans-unit>
        <trans-unit id="168798718c8d67f564d095b7f2c27b1f23db19a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-foldable#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; вычисляет произведение номеров конструкции.</target>
        </trans-unit>
        <trans-unit id="7cca4119f8a53ddfe67d87125c91cc29b78f8689" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; функция вычисляет сумму чисел строения.</target>
        </trans-unit>
        <trans-unit id="f9699a12c867a28d982d3293073c01ca1c9af29d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from our &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance will ignore &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values, but will apply the supplied function to values contained in a &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; из нашего &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; экземпляра будет игнорировать &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; значения, но будет применять указанную функцию к значениям , содержащимся в &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b77100b25e8a5a0820122925237280bb25f1620c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; function is also available as the infix operator &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; также доступна как инфиксный оператор &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="75d054c2f2cab23d848c32214fa7c03446c931b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; functor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; функтор.</target>
        </trans-unit>
        <trans-unit id="91affd44c758dc656c5a465b34202e2474e6eec1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-graph#t:Graph&quot;&gt;Graph&lt;/a&gt;&lt;/code&gt; type is an adjacency list representation of a finite, directed graph with vertices of type &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-graph#t:Graph&quot;&gt;Graph&lt;/a&gt;&lt;/code&gt; - это представление списка смежности конечного ориентированного графа с вершинами типа &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da965f8602a83550c13d9322bdab8f201adad863" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; type represents a &lt;a href=&quot;https://en.wikipedia.org/wiki/Strongly_connected_component&quot;&gt;strongly-connected component&lt;/a&gt; of a graph.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; представляет собой &lt;a href=&quot;https://en.wikipedia.org/wiki/Strongly_connected_component&quot;&gt;сильно связанный компонент&lt;/a&gt; графа.</target>
        </trans-unit>
        <trans-unit id="b13b673bb0340c3f60ad133cedd86aba2eebb7ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; argument specifies a &lt;em&gt;capability number&lt;/em&gt; (see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;). Typically capabilities correspond to physical processors, but the exact behaviour is implementation-dependent. The value passed to &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is interpreted modulo the total number of capabilities as returned by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; аргумент указывает &lt;em&gt;номер возможностей&lt;/em&gt; (см &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; ). Обычно возможности соответствуют физическим процессорам, но точное поведение зависит от реализации. Значение, переданное в &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; , интерпретируется по модулю общего количества возможностей, возвращаемых &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f78d4fb8fef90bc420e0f272097151354016eb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; argument specifies a &lt;em&gt;capability number&lt;/em&gt; (see &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;). Typically capabilities correspond to physical processors, but the exact behaviour is implementation-dependent. The value passed to &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is interpreted modulo the total number of capabilities as returned by &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; аргумент указывает &lt;em&gt;номер возможностей&lt;/em&gt; (см &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; ). Обычно возможности соответствуют физическим процессорам, но точное поведение зависит от реализации. Значение, переданное в &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; , интерпретируется по модулю общего количества возможностей, возвращаемых &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="990e9e27ae850a84a5975a64be27bfdd1b9f5808" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; argument specifies a &lt;em&gt;capability number&lt;/em&gt; (see &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;). Typically capabilities correspond to physical processors, but the exact behaviour is implementation-dependent. The value passed to &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is interpreted modulo the total number of capabilities as returned by &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; аргумент указывает &lt;em&gt;номер возможностей&lt;/em&gt; (см &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; ). Обычно возможности соответствуют физическим процессорам, но точное поведение зависит от реализации. Значение, переданное в &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; , интерпретируется по модулю общего количества возможностей, возвращаемых &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26c55fb3d34eb375b02ebba32fb7b2dd27c91fb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from keys of type &lt;code&gt;Int&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; представляет собой конечную карту (иногда называемую словарем) от ключей типа &lt;code&gt;Int&lt;/code&gt; до значений типа &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9babf39e61d88f08afacef329c45b58b748886e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-strict&quot;&gt;Data.Map.Merge.Strict&lt;/a&gt; then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then they will not.</source>
          <target state="translated">Функции &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; используются модулями lazy и strict. Только выбор тактики слияния определяет строгость. Если вы используете &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; из &lt;a href=&quot;data-map-merge-strict&quot;&gt;Data.Map.Merge.Strict,&lt;/a&gt; тогда результаты будут принудительно перед вставкой . Если вы используете &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; из этого модуля, они не будут.</target>
        </trans-unit>
        <trans-unit id="918fcfe1bbabd9b098a3357af6b4c10845874e4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-lazy&quot;&gt;Data.Map.Merge.Lazy&lt;/a&gt; then they will not.</source>
          <target state="translated">Функции &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; используются модулями lazy и strict. Только выбор тактики слияния определяет строгость. Если вы используете &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; из этого модуля, результаты будут принудительно перед вставкой . Если вы используете &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; из &lt;a href=&quot;data-map-merge-lazy&quot;&gt;Data.Map.Merge.Lazy,&lt;/a&gt; тогда они не будут.</target>
        </trans-unit>
        <trans-unit id="7e82dc1c0b8d264abe9b7b565b8cd539e1dbf5c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from key of type &lt;code&gt;Int&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; представляет собой конечную карту (иногда называемую словарем) от ключа типа &lt;code&gt;Int&lt;/code&gt; до значений типа &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1641ed0171bfd491e6f0e6638191a7945a81dba8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Traversable&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; является общим для ленивых и строгих модулей, что означает, что одно и то же значение &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; может быть передано функциям в обоих модулях. Это означает, что экземпляры &lt;code&gt;Functor&lt;/code&gt; , &lt;code&gt;Traversable&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; такие же, как и для модуля &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; , поэтому, если они используются, результирующая карта может содержать приостановленные значения (преобразователи).</target>
        </trans-unit>
        <trans-unit id="ca6e272f4b13fc32e4e87c18c5a09335a1d8e5ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from key of type &lt;code&gt;Int&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; представляет собой конечную карту (иногда называемую словарем) от ключа типа &lt;code&gt;Int&lt;/code&gt; до значений типа &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="318814e0b6ddaa927c58b1267d22b77390f5ece2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; является общим для ленивых и строгих модулей, что означает, что одно и то же значение &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; может быть передано функциям в обоих модулях. Это означает, что экземпляры &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; такие же, как и для модуля &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; , поэтому, если они используются, результирующая карта может содержать приостановленные значения (преобразователи).</target>
        </trans-unit>
        <trans-unit id="89f7bb2231b7f0bb854265a80968d382d2ee4a72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; type represents a set of elements of type &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; представляет собой набор элементов типа &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="235975fc327cbd37e2885a32990dd1d50e6ef2a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in a type onto integers. It is used primarily for array indexing (see the array package).</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; используется для отображения непрерывного поддиапазона значений в типе на целые числа. Он используется в основном для индексации массивов (см. Пакет с массивами).</target>
        </trans-unit>
        <trans-unit id="213033fe7d1bfa8957877f18a3b95df927b829f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in type onto integers. It is used primarily for array indexing (see the array package). &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; uses row-major order.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; используется для отображения непрерывного поддиапазона значений типа в целые числа. Он используется в основном для индексации массивов (см. Пакет с массивами). &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; использует порядок строк.</target>
        </trans-unit>
        <trans-unit id="1c9726b499ba205a67e8661afa56b3f5e6610bf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; function is list difference (non-associative). In the result of &lt;code&gt;xs&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt;&lt;code&gt;ys&lt;/code&gt;, the first occurrence of each element of &lt;code&gt;ys&lt;/code&gt; in turn (if any) has been removed from &lt;code&gt;xs&lt;/code&gt;. Thus</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; - это разность списков (неассоциативная). В результате &lt;code&gt;xs&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; &lt;code&gt;ys&lt;/code&gt; первое вхождение каждого элемента &lt;code&gt;ys&lt;/code&gt; по очереди (если есть) было удалено из &lt;code&gt;xs&lt;/code&gt; . таким образом</target>
        </trans-unit>
        <trans-unit id="d02a0fb924a1fb516ed51240226d0d6e5d964fd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; function takes a predicate and two lists and returns the first list with the first occurrence of each element of the second list removed.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; принимает предикат и два списка и возвращает первый список с первым удаленным вхождением каждого элемента второго списка.</target>
        </trans-unit>
        <trans-unit id="0d81ce03e6c4879c98e79164e27980ccd4245607" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; function drops the largest suffix of a list in which the given predicate holds for all elements. For example:</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; отбрасывает самый большой суффикс списка, в котором данный предикат выполняется для всех элементов. Например:</target>
        </trans-unit>
        <trans-unit id="8e6ebb6facf4e5e8507546d0730cd3d8aaa7cdbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given list which is equal (by &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) to the query element, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; возвращает индекс первого элемента в данном списке, который равен (на &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; ) элементу запроса, или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если такого элемента нет.</target>
        </trans-unit>
        <trans-unit id="35376b9066c242bc547e361977a97acd67654b38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements equal to the query element, in ascending order.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; расширяет &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; , возвращая индексы всех элементов, равных элементу запроса, в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="777c2200547e9739ba52a7633b954736b9823c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; function is just &lt;code&gt;&lt;a href=&quot;control-monad#v:mfilter&quot;&gt;mfilter&lt;/a&gt;&lt;/code&gt; specialized to the list monad:</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; - это просто &lt;code&gt;&lt;a href=&quot;control-monad#v:mfilter&quot;&gt;mfilter&lt;/a&gt;&lt;/code&gt; , специализированный для монады списка:</target>
        </trans-unit>
        <trans-unit id="a5d8b6f3eaba5030a68bf5d06e480657d33033a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a structure and returns the leftmost element of the structure matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; принимает предикат и структуру и возвращает самый левый элемент структуры, соответствующий предикату, или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если такого элемента нет.</target>
        </trans-unit>
        <trans-unit id="75b2422f251ce2039aaef3829d2dd5ca0ff38fd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a list and returns the index of the first element in the list satisfying the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; принимает предикат и список и возвращает индекс первого элемента в списке, удовлетворяющего этому предикату, или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если такого элемента нет.</target>
        </trans-unit>
        <trans-unit id="9ea9c7c9c9ab7b6e747e9ebc107dbbfddd67c972" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; расширяет &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; , возвращая индексы всех элементов, удовлетворяющих предикату, в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="be32822442735a04d54fa68d012d24ba5b89a668" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to drop.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; - это перегруженная версия &lt;code&gt;&lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; , которая принимает любое значение &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; в качестве количества удаляемых элементов.</target>
        </trans-unit>
        <trans-unit id="2812d742b2328d1abd314aebeef9aa75d01e9698" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the index.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; - это перегруженная версия &lt;code&gt;&lt;a href=&quot;data-list#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt; , который принимает любое &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; значение в качестве индекса.</target>
        </trans-unit>
        <trans-unit id="737fc86009d880ef7008902e996d5561992367bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of repetitions to make.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; - это перегруженная версия функции &lt;code&gt;&lt;a href=&quot;data-list#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; , которая принимает любое значение &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; в качестве количества выполняемых повторений.</target>
        </trans-unit>
        <trans-unit id="3402cafa3322e6ce9bc65e493a0acf1f2884672d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the position at which to split.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; - это перегруженная версия &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; , которая принимает любое значение &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; в качестве позиции, в которой выполняется разделение.</target>
        </trans-unit>
        <trans-unit id="f78c90a57d5cce824e07db93d2197f95aa21a155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to take.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; - это перегруженная версия &lt;code&gt;&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; , которая принимает любое значение &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; в качестве количества принимаемых элементов.</target>
        </trans-unit>
        <trans-unit id="ca4d378c787c5b9b2a06ae77c402a921da5aae20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a list and returns a list of lists such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; принимает список и возвращает список списков, так что объединение результата равно аргументу. Более того, каждый подсписок в результате содержит только равные элементы. Например,</target>
        </trans-unit>
        <trans-unit id="b33d3992fa75b8c5a7295f072191cef6471b5d58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a2aa0c2fff9d0cd85f48ee4e5c547b1e24beae0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; function returns all initial segments of the argument, shortest first. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; возвращает все начальные сегменты аргумента, сначала самые короткие. Например,</target>
        </trans-unit>
        <trans-unit id="e70f04ea60546783e780339c103b21d6a6b67467" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; function takes the list intersection of two lists. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; принимает пересечение двух списков. Например,</target>
        </trans-unit>
        <trans-unit id="a6dc46001b61fa48ad57e1c564b945db378bd949" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия элемента &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1446aaefcfea8557eabaae6ea889f9011ff1bbe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is contained, wholly and intact, anywhere within the second.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; принимает два списка и возвращает &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если первый список содержится целиком и без изменений где-нибудь во втором.</target>
        </trans-unit>
        <trans-unit id="8577e2ac2954a5de0cd6238c09ea92a58c9fb7f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:isSubsequenceOf&quot;&gt;isSubsequenceOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all the elements of the first list occur, in order, in the second. The elements do not have to occur consecutively.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:isSubsequenceOf&quot;&gt;isSubsequenceOf&lt;/a&gt;&lt;/code&gt; принимает два списка и возвращает &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если все элементы первого списка встречаются по порядку во втором. Элементы не обязательно должны располагаться последовательно.</target>
        </trans-unit>
        <trans-unit id="4a40ec49296ced12343a8fd18ca5c49b63aabe04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a suffix of the second. The second list must be finite.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; принимает два списка и возвращает &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если первый список является суффиксом второго. Второй список должен быть конечным.</target>
        </trans-unit>
        <trans-unit id="1b34469353a0b037b47cce6d230cb4cb71110874" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу структуры, передавая параметр накопления слева направо и возвращая окончательное значение этого аккумулятора вместе с новой структурой.</target>
        </trans-unit>
        <trans-unit id="b6ebf56806d59584f196cd5d11b8904d0639b1d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу структуры, передавая параметр накопления справа налево и возвращая окончательное значение этого аккумулятора вместе с новой структурой.</target>
        </trans-unit>
        <trans-unit id="7eb6f6e78bb431c6ad213eb9d21c75fa95dc7ddf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt;, except it uses a user-supplied equality predicate instead of the overloaded &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; ведет себя так же, как &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; , за исключением того, что в ней используется предикат равенства, предоставляемый пользователем, вместо перегруженной функции &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc7232b1ebffbebb739ba096d41e32596b9eedb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate a list and returns the pair of lists of elements which do and do not satisfy the predicate, respectively; i.e.,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; принимает предикат список и возвращает пару списков элементов, которые удовлетворяют и не удовлетворяют предикату, соответственно; т.е.</target>
        </trans-unit>
        <trans-unit id="2b6ed649212daaa5b7d86c6ccef6bf66b085c1db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; function returns the list of all permutations of the argument.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; возвращает список всех перестановок аргумента.</target>
        </trans-unit>
        <trans-unit id="2f287658e3d55e31f32fe140091016332ce08537" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; вычисляет произведение номеров конструкции.</target>
        </trans-unit>
        <trans-unit id="a463a93b298d3088c6a486752b752d20e4b0de19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function implements a stable sorting algorithm. It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; реализует стабильный алгоритм сортировки. Это частный случай &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; , который позволяет программисту предоставлять свою собственную функцию сравнения.</target>
        </trans-unit>
        <trans-unit id="095b73e07b36153b051dcf74ac3cefd56274581f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b88e9d47462c1b9615bcd7d7acc05eba51c65b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; function returns the list of all subsequences of the argument.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; возвращает список всех подпоследовательностей аргумента.</target>
        </trans-unit>
        <trans-unit id="eff98324d1a84c781b046e919d0b375a374d6a43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; вычисляет сумму номеров конструкции.</target>
        </trans-unit>
        <trans-unit id="ac33ccd64dfa538162e29b5368275ac3dcab2e9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its argument. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; перемещает строки и столбцы своего аргумента. Например,</target>
        </trans-unit>
        <trans-unit id="21074974ba0da203fdbe3139596e6c3eb82eacd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is a `dual' to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;: while &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; reduces a list to a summary value, &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a list from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the list or returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepended to the list and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; является двойной функцией &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; : в то время как &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; сокращает список до итогового значения, &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; строит список из начального значения. Функция принимает элемент и возвращает &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если она завершила создание списка, или возвращает &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; , и в этом случае &lt;code&gt;a&lt;/code&gt; добавляется к списку, а &lt;code&gt;b&lt;/code&gt; используется как следующий элемент в рекурсивном вызове. Например,</target>
        </trans-unit>
        <trans-unit id="6f5fe84f2f6e359d0b958ffdfd50c5ad6c942d08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; function returns the list union of the two lists. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; возвращает объединение двух списков. Например,</target>
        </trans-unit>
        <trans-unit id="26aa6f38df9eac11f0ca7ea5149a65e6f035439a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3512932a90bda2966b9c4bde2bc99fdaee65977a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; принимает список троек и возвращает три списка, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="465b134f0e0674fc306964e8911a4c8f5a23b544" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; function takes a list of quadruples and returns four lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; берет список из четверок и возвращает четыре списка, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eab7f028c5e43e9c371d7627b6af73045109e75d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; function takes a list of five-tuples and returns five lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; принимает список из пяти кортежей и возвращает пять списков, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6934051d9d7b99ca14d42b993760a93edf9a7566" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; function takes a list of six-tuples and returns six lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; принимает список из шести кортежей и возвращает шесть списков, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="782bb3363a3945b001878329fde4ebb88dcb6fb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; function takes a list of seven-tuples and returns seven lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; принимает список из семи кортежей и возвращает семь списков, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17802af283250b2eaa32a2ecb8cb86776774ec7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; function takes four lists and returns a list of quadruples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; принимает четыре списка и возвращает список из четырех элементов, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="6bce1a1341ac4dd8d73f1e68a1710aec2a623827" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; function takes five lists and returns a list of five-tuples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; принимает пять списков и возвращает список из пяти кортежей, аналогичный &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="451d4d26a4f677865f2a3a707b38064fca9f4083" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; function takes six lists and returns a list of six-tuples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; принимает шесть списков и возвращает список из шести кортежей, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="c305b363ee1ef77beb2a8edb13e3c0d40953e5c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; function takes seven lists and returns a list of seven-tuples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; принимает семь списков и возвращает список из семи кортежей, аналогичный &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="88779bb5c5d951c52ff0e703df09adaeddb2bdff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет три элемента, а также три списка, и возвращает список их точечной комбинации, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="60ff42280ef2fd04c5a52b0fb6c4ced9f80d259b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; function takes a function which combines four elements, as well as four lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет четыре элемента, а также четыре списка и возвращает список их точечных комбинаций, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="9fb3b6d637e7bdf78afcd7364064abe2b747412a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; function takes a function which combines five elements, as well as five lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет пять элементов, а также пять списков, и возвращает список их точечных комбинаций, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="76824cb1a5c46cd7971e7c2fd78abbe2f0690804" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; function takes a function which combines six elements, as well as six lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет шесть элементов, а также шесть списков, и возвращает список их точечной комбинации, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="c2eb2006a61b2e5916c9fa720bb30884f6a6a25d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; function takes a function which combines seven elements, as well as seven lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет семь элементов, а также семь списков и возвращает список их точечной комбинации, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="657b1604cfab08f6d70ddcd61991924e84fa776b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:break&quot;&gt;break&lt;/a&gt; p&lt;/code&gt; function is equivalent to &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:span&quot;&gt;span&lt;/a&gt; (not . p)&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:break&quot;&gt;break&lt;/a&gt; p&lt;/code&gt; эквивалентна &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:span&quot;&gt;span&lt;/a&gt; (not . p)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee5bf1dc8f489bf35d33f57749203f70974c1fd9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a stream and returns a list of streams such that flattening the resulting list is equal to the argument. Moreover, each stream in the resulting list contains only equal elements. For example, in list notation:</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; принимает поток и возвращает список потоков, так что сглаживание результирующего списка равно аргументу. Более того, каждый поток в результирующем списке содержит только равные элементы. Например, в обозначении списка:</target>
        </trans-unit>
        <trans-unit id="d4768abc565ec9f4747dd76eb1df6c5aed894777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; function takes a stream &lt;code&gt;xs&lt;/code&gt; and returns all the finite prefixes of &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; принимает поток &lt;code&gt;xs&lt;/code&gt; и возвращает все конечные префиксы &lt;code&gt;xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37ce52036d19badb8eb3e19e52707cf238bc5e53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the first argument is a prefix of the second.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если первый аргумент является префиксом второго.</target>
        </trans-unit>
        <trans-unit id="bd9fc5f9beeabe2f81cfc9e7c5d9e742fa36f643" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. (The name &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; means 'essence'.) It is a special case of &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own inequality test.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; удаляет повторяющиеся элементы из списка. В частности, он сохраняет только первое вхождение каждого элемента. (Название &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; означает &amp;laquo;сущность&amp;raquo;.) Это частный случай &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; , который позволяет программисту предоставить свой собственный тест на неравенство.</target>
        </trans-unit>
        <trans-unit id="1fd2343fdb59771c84cb4f982c7246f3073f744d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt;, except it uses a user-supplied equality predicate instead of the overloaded &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; ведет себя так же, как &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; , за исключением того, что в ней используется предикат равенства, предоставляемый пользователем, вместо перегруженной функции &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ca6a46f6f161da72b75fa2b96c21284bff63000" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate &lt;code&gt;p&lt;/code&gt; and a stream &lt;code&gt;xs&lt;/code&gt;, and returns a pair of lists. The first list corresponds to the elements of &lt;code&gt;xs&lt;/code&gt; for which &lt;code&gt;p&lt;/code&gt; holds; the second corresponds to the elements of &lt;code&gt;xs&lt;/code&gt; for which &lt;code&gt;p&lt;/code&gt; does not hold.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; принимает предикат &lt;code&gt;p&lt;/code&gt; и поток &lt;code&gt;xs&lt;/code&gt; и возвращает пару списков. Первый список соответствует элементам &lt;code&gt;xs&lt;/code&gt; , для которых выполняется &lt;code&gt;p&lt;/code&gt; ; второй соответствует элементам &lt;code&gt;xs&lt;/code&gt; , для которых &lt;code&gt;p&lt;/code&gt; не выполняется.</target>
        </trans-unit>
        <trans-unit id="97f203f3e97c286860c77a16076e2c5ba5e804b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; function takes a stream &lt;code&gt;xs&lt;/code&gt; and returns all the suffixes of &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; принимает поток &lt;code&gt;xs&lt;/code&gt; и возвращает все суффиксы &lt;code&gt;xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4b73a8b2bef137b1be451c67193ea1b9dd5278a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; operation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; функция аналогична &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt; &amp;laquo;s &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; операции.</target>
        </trans-unit>
        <trans-unit id="2413c236691707253e811091fb05fcbb1bf0b562" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; function is the inverse of the &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; - это обратная функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce09038022ed3cd501096c0d8a1d4d43ab363fc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; function takes two streams and returns a stream of corresponding pairs.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; принимает два потока и возвращает поток соответствующих пар.</target>
        </trans-unit>
        <trans-unit id="f10666c8af44a76f18b1cbb206ccc5dbbcf92fdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; function generalizes &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. Rather than tupling the elements, the elements are combined using the function passed as the first argument.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; обобщает &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . Вместо того, чтобы выбирать элементы, элементы объединяются с использованием функции, переданной в качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="16a4e90fc05f7eb7703f8d38de0941aad54680ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from keys of type &lt;code&gt;k&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;. A &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is strict in its keys but lazy in its values.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; представляет собой конечную карту (иногда называемую словарем) от ключей типа &lt;code&gt;k&lt;/code&gt; до значений типа &lt;code&gt;v&lt;/code&gt; . У &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; строгие ключи, но ленивые значения.</target>
        </trans-unit>
        <trans-unit id="4715b3b3e03f7ebfbfad3ed60bdf0126093bd7fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-strict&quot;&gt;Data.Map.Merge.Strict&lt;/a&gt; then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then they will not.</source>
          <target state="translated">Функции &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; используются модулями lazy и strict. Только выбор тактики слияния определяет строгость. Если вы используете &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; из &lt;a href=&quot;data-map-merge-strict&quot;&gt;Data.Map.Merge.Strict,&lt;/a&gt; тогда результаты будут принудительно перед вставкой . Если вы используете &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; из этого модуля, они не будут.</target>
        </trans-unit>
        <trans-unit id="2b155238023fcafca6284b024ed0af65f6650208" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-lazy&quot;&gt;Data.Map.Merge.Lazy&lt;/a&gt; then they will not.</source>
          <target state="translated">Функции &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; используются модулями lazy и strict. Только выбор тактики слияния определяет строгость. Если вы используете &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; из этого модуля, результаты будут принудительно перед вставкой . Если вы используете &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; из &lt;a href=&quot;data-map-merge-lazy&quot;&gt;Data.Map.Merge.Lazy,&lt;/a&gt; тогда они не будут.</target>
        </trans-unit>
        <trans-unit id="662c04a7a17ee001eac580254bab8523defdb93a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from keys of type &lt;code&gt;k&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; представляет собой конечную карту (иногда называемую словарем) от ключей типа &lt;code&gt;k&lt;/code&gt; до значений типа &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12662a5070f04b0d43497ea05090a5128c804911" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; module, so if they are used the resulting maps may contain suspended values (thunks).</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; является общим для ленивых и строгих модулей, что означает, что одно и то же значение &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; может быть передано функциям в обоих модулях. Это означает, что экземпляры &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; такие же, как и для модуля &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; , поэтому, если они используются, результирующие карты могут содержать приостановленные значения (преобразователи).</target>
        </trans-unit>
        <trans-unit id="7f52f3aa69ba900643917df0d514ebfe7065396f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type encapsulates an optional value. A value of type &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; either contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt;), or it is empty (represented as &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;). Using &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is a good way to deal with errors or exceptional cases without resorting to drastic measures such as &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; инкапсулирует необязательное значение. Значение типа &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; либо содержит значение типа &lt;code&gt;a&lt;/code&gt; (представленное как &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; ), либо оно пустое (представлено как &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ). Использование &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; - хороший способ справиться с ошибками или исключительными случаями, не прибегая к таким радикальным мерам, как &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f185e83cdbbc510aa029904011adfe83bd8b1220" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type is also a monad. It is a simple kind of error monad, where all errors are represented by &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. A richer error monad can be built using the &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; - тоже монада. Это простая монада ошибок, в которой все ошибки представлены &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; . Более богатая монада ошибок может быть построена с &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; типа Either .</target>
        </trans-unit>
        <trans-unit id="e8aa4a4fc49f7638e33b52125beaf5389284d595" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; принимает список значений &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; и возвращает список всех значений &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e3cc1728b8d32e7bd6e33d7191898329f389751" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromJust&quot;&gt;fromJust&lt;/a&gt;&lt;/code&gt; function extracts the element out of a &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and throws an error if its argument is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromJust&quot;&gt;fromJust&lt;/a&gt;&lt;/code&gt; извлекает элемент из &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; и выдает ошибку, если ее аргумент равен &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de4cf2aa7df453c08de73e06681e00b3a9d47c30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and and &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default values; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; принимает значение по умолчанию и значение &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; . Если &amp;laquo; &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; равно &amp;laquo; &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , он возвращает значения по умолчанию; в противном случае возвращается значение, содержащееся в поле &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a5a7a323996766db88ca0c88884029bb8a6704d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:isJust&quot;&gt;isJust&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff its argument is of the form &lt;code&gt;Just _&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-maybe#v:isJust&quot;&gt;isJust&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если ее аргумент имеет форму &lt;code&gt;Just _&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52483bf501d37712c976868bb9284af355744fac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:isNothing&quot;&gt;isNothing&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff its argument is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-maybe#v:isNothing&quot;&gt;isNothing&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если ее аргумент равен &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eee25b35452f5d1cfc414313539edda0a7120764" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:listToMaybe&quot;&gt;listToMaybe&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; on an empty list or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the first element of the list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-maybe#v:listToMaybe&quot;&gt;listToMaybe&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; в пустом списке или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; где &lt;code&gt;a&lt;/code&gt; является первым элементом списка.</target>
        </trans-unit>
        <trans-unit id="d9226f117113df71e3656c9e6013ce6d6bf13f04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; function is a version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; which can throw out elements. In particular, the functional argument returns something of type &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; b&lt;/code&gt;. If this is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, no element is added on to the result list. If it is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; b&lt;/code&gt;, then &lt;code&gt;b&lt;/code&gt; is included in the result list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; - это версия &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; которая может выбрасывать элементы. В частности, функциональный аргумент возвращает что-то типа &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; b&lt;/code&gt; . Если это &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , в список результатов не добавляется никаких элементов. Если это &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; b&lt;/code&gt; , то &lt;code&gt;b&lt;/code&gt; включается в список результатов.</target>
        </trans-unit>
        <trans-unit id="85d0ce65a11dff7a785fa5be5465e4febfc6e9a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; function takes a default value, a function, and a &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the function returns the default value. Otherwise, it applies the function to the value inside the &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and returns the result.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; функция принимает значение по умолчанию, функцию и &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; значение. Если значение &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; равно &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , функция возвращает значение по умолчанию. В противном случае он применяет функцию к значению внутри &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; и возвращает результат.</target>
        </trans-unit>
        <trans-unit id="5c611fd7648ec2451334092c9df4afb5e19ad5d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; возвращает пустой список, если задано &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , или одноэлементный список, если задано &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="795a9f9783333374a76593a231e073666138ebda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-monoid#t:Sum&quot;&gt;Sum&lt;/a&gt;&lt;/code&gt; monoid is defined by the numerical addition operator and `0` as neutral element:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-monoid#t:Sum&quot;&gt;Sum&lt;/a&gt;&lt;/code&gt; моноид определяются численным оператором сложения и '0' в качестве нейтрального элемента:</target>
        </trans-unit>
        <trans-unit id="9acde1593d8ad750d5ecbfa06d97960b56f05f43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; type allows you to reverse sort order conveniently. A value of type &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt;). If &lt;code&gt;a&lt;/code&gt; has an &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance associated with it then comparing two values thus wrapped will give you the opposite of their normal sort order. This is particularly useful when sorting in generalised list comprehensions, as in: &lt;code&gt;then sortWith by &lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt;</source>
          <target state="translated">Тип &amp;laquo; &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; &amp;raquo; позволяет удобно менять порядок сортировки на обратный. Значение типа &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; содержит значение типа &lt;code&gt;a&lt;/code&gt; (представленное как &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; ). Если имеет &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; экземпляр , связанный с ним , то сравнение двух значений , таким образом , обернутые даст вам противоположное их нормального порядка сортировки. Это особенно полезно при сортировке в обобщенных представлениях списка, например: &lt;code&gt;then sortWith by &lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; x &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d480aba9ca8f558b9bab4a7470c617258413273" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class is used for totally ordered datatypes.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; используется для полностью упорядоченных типов данных.</target>
        </trans-unit>
        <trans-unit id="9743e6ce1ccca02d84b310e0c03e3b64b006ece2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Min&quot;&gt;Min&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is defined to always pick the smaller number: &amp;gt;&amp;gt;&amp;gt; Min 1 &amp;lt;&amp;gt; Min 2 &amp;lt;&amp;gt; Min 3 &amp;lt;&amp;gt; Min 4 :: Min Int Min {getMin = 1}</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-semigroup#t:Min&quot;&gt;Min&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; экземпляр для &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; определяется всегда выбирают меньшее число: &amp;gt;&amp;gt;&amp;gt; Min 1 &amp;lt;&amp;gt; Минимум 2 &amp;lt;&amp;gt; Минимум 3 &amp;lt;&amp;gt; Мин 4 :: Мин Int Мин {getMin = 1}</target>
        </trans-unit>
        <trans-unit id="d415a40b49223b304b71b398a708eb25f07e68ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt; a&lt;/code&gt; type represents a finite sequence of values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt; a&lt;/code&gt; представляет собой конечную последовательность значений типа &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13ce1c3f2600f3e2f50834c056ec8fa70e4eab37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; type represents a set of elements of type &lt;code&gt;e&lt;/code&gt;. Most operations require that &lt;code&gt;e&lt;/code&gt; be an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class. A &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; is strict in its elements.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; представляет собой набор элементов типа &lt;code&gt;e&lt;/code&gt; . Для большинства операций требуется, чтобы &lt;code&gt;e&lt;/code&gt; был экземпляром класса &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; строг в своих элементах.</target>
        </trans-unit>
        <trans-unit id="8881e3fb681798d7bf981e8e9d449509800437b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is implemented using arrays that are not guaranteed to have a fixed address in the Haskell heap. All communication with native code must thus occur by copying data back and forth.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; реализован с использованием массивов, для которых не гарантируется наличие фиксированного адреса в куче Haskell. Таким образом, вся связь с машинным кодом должна происходить путем копирования данных туда и обратно.</target>
        </trans-unit>
        <trans-unit id="9d9c2733ed15ccf0d235e8a6b100f93fe8426bb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type's internal representation is UTF-16, using the platform's native endianness. This makes copied data suitable for use with native libraries that use a similar representation, such as ICU. To interoperate with native libraries that use different internal representations, such as UTF-8 or UTF-32, consider using the functions in the &lt;code&gt;&lt;a href=&quot;data-text#v:Encoding&quot;&gt;Encoding&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; внутреннее представление Type является UTF-16, используя родной порядок байтов платформы. Это делает скопированные данные пригодными для использования с собственными библиотеками, которые используют аналогичное представление, например ICU. Для взаимодействия с собственными библиотеками, которые используют различные внутренние представления, такие как UTF-8 или UTF-32, рассмотрите возможность использования функций в модуле &lt;code&gt;&lt;a href=&quot;data-text#v:Encoding&quot;&gt;Encoding&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="161f7f591d2f56a095b5a6738fe11dc948f83c20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-text#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and a strict &lt;code&gt;&lt;a href=&quot;data-text#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Performs replacement on invalid scalar values.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-text#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-text#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; и строгого &lt;code&gt;&lt;a href=&quot;data-text#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; , передавая параметр накопления справа налево и возвращая окончательное значение этого аккумулятора вместе с новым &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; . Выполняет замену недопустимых скалярных значений.</target>
        </trans-unit>
        <trans-unit id="c5823a0c22eaaaf0e0d80ffbc2bbde448d239204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; constructor is exposed since &lt;code&gt;text-1.1.1.3&lt;/code&gt;</source>
          <target state="translated">Конструктор &lt;code&gt;&lt;a href=&quot;data-text-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; &lt;code&gt;text-1.1.1.3&lt;/code&gt; с text-1.1.1.3</target>
        </trans-unit>
        <trans-unit id="7d764c078d54b6747b82b1fb65bc90cbfdc33a9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; constructor is exposed since &lt;code&gt;text-1.1.1.3&lt;/code&gt;</source>
          <target state="translated">Конструктор &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; доступен с &lt;code&gt;text-1.1.1.3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e4b96f6778d5f3fbaa9eb0f8c186a8f261148c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8&quot;&gt;streamDecodeUtf8&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; functions accept a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that represents a possibly incomplete input (e.g. a packet from a network stream) that may not end on a UTF-8 boundary.</source>
          <target state="translated">Функции &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8&quot;&gt;streamDecodeUtf8&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; принимают &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; , представляющую возможно неполный ввод (например, пакет из сетевого потока), который может не заканчиваться на границе UTF-8.</target>
        </trans-unit>
        <trans-unit id="d8de0eaf04140ba7158dddc8d0be85ce0ccccc4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a stream and returns the index of the first element in the stream satisfying the predicate.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; принимает предикат и поток и возвращает индекс первого элемента в потоке, удовлетворяющего предикату.</target>
        </trans-unit>
        <trans-unit id="bf384e38dd6fd9c82df77df8975246cdedc34701" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:findIndexI&quot;&gt;findIndexI&lt;/a&gt;&lt;/code&gt; function takes a predicate and a stream and returns the index of the first element in the stream satisfying the predicate.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:findIndexI&quot;&gt;findIndexI&lt;/a&gt;&lt;/code&gt; принимает предикат и поток и возвращает индекс первого элемента в потоке, удовлетворяющего предикату.</target>
        </trans-unit>
        <trans-unit id="ee94ea37dfd7850ffc9a486e3dd92c091c5cbec7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;n&lt;/code&gt; code points.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; по &lt;code&gt;n&lt;/code&gt; кодовых точек.</target>
        </trans-unit>
        <trans-unit id="66da5760dab680492ae3a48dc3a35550be6dc4df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; of the given code point.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; данной точки коды.</target>
        </trans-unit>
        <trans-unit id="a75e1f66c9b008e7ba6ff420a20501b8af837a38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-text-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; принимает в качестве аргумента функцию типа &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; . Весь ввод от стандартного устройства ввода передается этой функции в качестве аргумента, а результирующая строка выводится на стандартное устройство вывода.</target>
        </trans-unit>
        <trans-unit id="b417d4f678288b71d35accb0f99175761f3e1e07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The entire file is read strictly, as with &lt;code&gt;&lt;a href=&quot;data-text-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-text-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; считывает файл и возвращает содержимое файла в виде строки. Весь файл читается строго, как и в случае с &lt;code&gt;&lt;a href=&quot;data-text-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68615baf25b8a5dabb727f9a05e4f69c95e23d72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; and returns a list of &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; функция принимает &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; и возвращает список &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; s такого , что конкатенация результата равна аргументу. Более того, каждый подсписок в результате содержит только равные элементы. Например,</target>
        </trans-unit>
        <trans-unit id="448dca813f1fb16bef7c7de2c7c5fae5b0a093ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea18231a8f3d26a5fe0119fe32dfbafea55d681" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and a strict &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Performs replacement on invalid scalar values.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; и строгого &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; , передавая параметр накопления справа налево и возвращая окончательное значение этого аккумулятора вместе с новым &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; . Выполняет замену недопустимых скалярных значений.</target>
        </trans-unit>
        <trans-unit id="1a76ea813e8c21de4f80acb76647bc2ec24349f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; as its argument. The entire input from the standard input device is passed (lazily) to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-text-lazy-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; принимает в качестве аргумента функцию типа &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; . Весь ввод со стандартного устройства ввода передается (лениво) в эту функцию в качестве аргумента, а результирующая строка выводится на стандартное устройство вывода.</target>
        </trans-unit>
        <trans-unit id="0f4eb06ba150dfea2048571ec4f24a657175124e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу структуры, передавая параметр накопления слева направо и возвращая окончательное значение этого аккумулятора вместе с новой структурой.</target>
        </trans-unit>
        <trans-unit id="7d943aed90068948d72a0d5858ba1b7944e9decb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу структуры, передавая параметр накопления справа налево и возвращая окончательное значение этого аккумулятора вместе с новой структурой.</target>
        </trans-unit>
        <trans-unit id="6a5f7c77832ccee5dc8f444bf10cb820686c5a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-tree#t:Forest&quot;&gt;Forest&lt;/a&gt; a&lt;/code&gt; type represents a forest of &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt;s.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-tree#t:Forest&quot;&gt;Forest&lt;/a&gt; a&lt;/code&gt; представляет собой лес &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="4dde0b10b0f433f8901cc6d31ae5f25b888075e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt; type represents a lazy, possibly infinite, multi-way tree (also known as a &lt;em&gt;rose tree&lt;/em&gt;).</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt; представляет собой ленивое, возможно, бесконечное, многостороннее дерево (также известное как &lt;em&gt;розовое дерево&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="8007180e7dc5a974039c84bcb837081428c5c9da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; class reifies types to some extent by associating type representations to types. These type representations can be compared, and one can in turn define a type-safe cast operation. To this end, an unsafe cast is guarded by a test for type (representation) equivalence. The module &lt;a href=&quot;data-dynamic&quot;&gt;Data.Dynamic&lt;/a&gt; uses Typeable for an implementation of dynamics. The module &lt;a href=&quot;data-data&quot;&gt;Data.Data&lt;/a&gt; uses Typeable and type-safe cast (but not dynamics) to support the &quot;Scrap your boilerplate&quot; style of generic programming.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; класс материализует типов в некоторой степени, сопоставляя представления типа типам. Эти представления типов можно сравнивать и, в свою очередь, определять безопасную для типов операцию приведения. С этой целью небезопасное приведение охраняется тестом на эквивалентность типа (представления). Модуль &lt;a href=&quot;data-dynamic&quot;&gt;Data.Dynamic&lt;/a&gt; использует Typeable для реализации динамики. Модуль &lt;a href=&quot;data-data&quot;&gt;Data.Data&lt;/a&gt; использует типизируемое и безопасное для типов приведение (но не динамическое) для поддержки стиля универсального программирования &amp;laquo;Избавьтесь от шаблона&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d043229d0aba230c46b619f1751b3e8e83785014" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; function outputs the trace message given as its first argument, before returning the second argument as its result.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; выводит сообщение трассировки, указанное в качестве ее первого аргумента, перед возвращением второго аргумента в качестве результата.</target>
        </trans-unit>
        <trans-unit id="140721e416adc2345c2c2facce319e06db5e38ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; function should &lt;em&gt;only&lt;/em&gt; be used for debugging, or for monitoring execution. The function is not referentially transparent: its type indicates that it is a pure function but it has the side effect of outputting the trace message.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; функция должна &lt;em&gt;только&lt;/em&gt; использоваться для отладки или для контроля исполнения. Функция не является ссылочно прозрачной: ее тип указывает, что это чистая функция, но имеет побочный эффект вывода сообщения трассировки.</target>
        </trans-unit>
        <trans-unit id="605bec91baff60047b066d4e1ac30c1faa493023" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceShow&quot;&gt;traceShow&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; functions print messages to an output stream. They are intended for &quot;printf debugging&quot;, that is: tracing the flow of execution and printing interesting values.</source>
          <target state="translated">Функции &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceShow&quot;&gt;traceShow&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; выводят сообщения в выходной поток. Они предназначены для &amp;laquo;отладки printf&amp;raquo;, то есть отслеживания потока выполнения и вывода интересных значений.</target>
        </trans-unit>
        <trans-unit id="a88df11e31fce4c7204e009946e93a681d719b46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEvent&quot;&gt;traceEvent&lt;/a&gt;&lt;/code&gt; function behaves like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; with the difference that the message is emitted to the eventlog, if eventlog profiling is available and enabled at runtime.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEvent&quot;&gt;traceEvent&lt;/a&gt;&lt;/code&gt; ведет себя как &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; с той разницей, что сообщение отправляется в журнал событий , если профилирование журнала событий доступно и включено во время выполнения.</target>
        </trans-unit>
        <trans-unit id="49d4ea0d4504acbc4d1aca32b1293ddbe4063444" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; function emits a message to the eventlog, if eventlog profiling is available and enabled at runtime.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; отправляет сообщение в журнал событий , если профилирование журнала событий доступно и включено во время выполнения.</target>
        </trans-unit>
        <trans-unit id="b3a4eae130c3225cefb9efb90d8be9b83b521fab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; function outputs the trace message from the IO monad. This sequences the output with respect to other IO actions.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; выводит сообщение трассировки от монады ввода-вывода. Это упорядочивает вывод по отношению к другим действиям ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="d97ccf67a57dfd415eb74011cb7d1b6a77ff69bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarker&quot;&gt;traceMarker&lt;/a&gt;&lt;/code&gt; function emits a marker to the eventlog, if eventlog profiling is available and enabled at runtime. The &lt;code&gt;String&lt;/code&gt; is the name of the marker. The name is just used in the profiling tools to help you keep clear which marker is which.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarker&quot;&gt;traceMarker&lt;/a&gt;&lt;/code&gt; отправляет маркер в журнал событий , если профилирование журнала событий доступно и включено во время выполнения. &lt;code&gt;String&lt;/code&gt; это имя маркера. Название просто используется в инструментах профилирования, чтобы помочь вам понять, какой маркер какой.</target>
        </trans-unit>
        <trans-unit id="fa771e47c5e0835b60259fdc80c34fd55cfa3c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; function emits a marker to the eventlog, if eventlog profiling is available and enabled at runtime.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; отправляет маркер в журнал событий , если профилирование журнала событий доступно и включено во время выполнения.</target>
        </trans-unit>
        <trans-unit id="65a90e57ddce6b3095e1eb053172e0add59b8b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is parameterised in the same way as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;. The type argument of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; should normally be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; параметризуется таким же образом , как &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; . Аргумент типа &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; обычно должен быть экземпляром класса &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47f829e4b12e19d9b1b9c867b798c3d41bfa7cc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; type and operations. This module is part of the Foreign Function Interface (FFI) and will usually be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; типа и операции. Этот модуль является частью интерфейса внешних функций (FFI) и обычно импортируется через &lt;a href=&quot;foreign&quot;&gt;внешний&lt;/a&gt; модуль.</target>
        </trans-unit>
        <trans-unit id="4fea14f33688c221cc4b82a2e64457f2c1daf4c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is parameterised in the same way as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;. The type argument of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; should normally be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; параметризуется таким же образом , как &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; . Аргумент типа &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; обычно должен быть экземпляром класса &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46ba37e75544b376d91afd7d94cc178e3d4edd60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; type and operations. This module is part of the Foreign Function Interface (FFI) and will usually be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; типа и операции. Этот модуль является частью интерфейса внешних функций (FFI) и обычно импортируется через &lt;a href=&quot;foreign&quot;&gt;внешний&lt;/a&gt; модуль.</target>
        </trans-unit>
        <trans-unit id="05673b670d8de49659d7ca54ef48d3649d1c6cc9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; function casts a pointer from one type to another.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; переводит указатель от одного типа к другому.</target>
        </trans-unit>
        <trans-unit id="f4a69e977af812c4c1901ff0ace0b2bb4a9d9dd0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-arr#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in a type onto integers. It is used primarily for array indexing (see the array package).</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;ghc-arr#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; используется для отображения непрерывного поддиапазона значений в типе на целые числа. Он используется в основном для индексации массивов (см. Пакет с массивами).</target>
        </trans-unit>
        <trans-unit id="e348453b816674bfaf92baa8a27076b87c3aa9bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-arr#v:accumArray&quot;&gt;accumArray&lt;/a&gt;&lt;/code&gt; function deals with repeated indices in the association list using an &lt;em&gt;accumulating function&lt;/em&gt; which combines the values of associations with the same index.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-arr#v:accumArray&quot;&gt;accumArray&lt;/a&gt;&lt;/code&gt; обрабатывает повторяющиеся индексы в списке ассоциаций, используя функцию &lt;em&gt;накопления,&lt;/em&gt; которая объединяет значения ассоциаций с одним и тем же индексом.</target>
        </trans-unit>
        <trans-unit id="7873c676664db92e7ab0f598d2d48e71762b5260" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; class defines the basic operations over a &lt;em&gt;monad&lt;/em&gt;, a concept from a branch of mathematics known as &lt;em&gt;category theory&lt;/em&gt;. From the perspective of a Haskell programmer, however, it is best to think of a monad as an &lt;em&gt;abstract datatype&lt;/em&gt; of actions. Haskell's &lt;code&gt;do&lt;/code&gt; expressions provide a convenient syntax for writing monadic expressions.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; определяет основные операции над &lt;em&gt;монадой&lt;/em&gt; - концепцию из раздела математики, известного как &lt;em&gt;теория категорий&lt;/em&gt; . Однако с точки зрения программиста на Haskell лучше всего рассматривать монаду как &lt;em&gt;абстрактный тип данных&lt;/em&gt; действий. Выражения &lt;code&gt;do&lt;/code&gt; в Haskell обеспечивают удобный синтаксис для написания монадических выражений.</target>
        </trans-unit>
        <trans-unit id="ee50bbd3c67bae7f49e378336e2e433f6106ccf0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-base#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-base#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; - это обычный оператор соединения монад. Он используется для удаления одного уровня монадической структуры, проецируя связанный аргумент на внешний уровень.</target>
        </trans-unit>
        <trans-unit id="27aabb232ca4b09ca8d220a432dd7f16df59a935" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-conc#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; action allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads (if any), and is occasionally useful when implementing concurrency abstractions.</source>
          <target state="translated">Действие &lt;code&gt;&lt;a href=&quot;ghc-conc#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; позволяет (принудительно в реализации совместной многозадачности) переключать контекст на любые другие выполняемые в данный момент потоки (если они есть) и иногда полезно при реализации абстракций параллелизма.</target>
        </trans-unit>
        <trans-unit id="4a132846a2c0d7c2c3007c1d18b85a3d84e2a398" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; action allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads (if any), and is occasionally useful when implementing concurrency abstractions.</source>
          <target state="translated">Действие &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; позволяет (принудительно в реализации совместной многозадачности) переключать контекст на любые другие выполняемые в данный момент потоки (если они есть) и иногда полезно при реализации абстракций параллелизма.</target>
        </trans-unit>
        <trans-unit id="9dd95524ffc61573839150d5ca8d3bbeafd0b7a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class is used to name the upper and lower limits of a type. &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is not a superclass of &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; since types that are not totally ordered may also have upper and lower bounds.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; используется для обозначения верхнего и нижнего пределов типа. &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; не является суперклассом &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; , поскольку типы, которые не являются полностью упорядоченными, могут также иметь верхнюю и нижнюю границы.</target>
        </trans-unit>
        <trans-unit id="3e4a35f48d43f24d53c5bb16b69fba56be493a94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class may be derived for any enumeration type; &lt;code&gt;&lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; is the first constructor listed in the &lt;code&gt;data&lt;/code&gt; declaration and &lt;code&gt;&lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; is the last. &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; may also be derived for single-constructor datatypes whose constituent types are in &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; может быть производным от любого типа перечисления; &lt;code&gt;&lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; - это первый конструктор, указанный в объявлении &lt;code&gt;data&lt;/code&gt; а &lt;code&gt;&lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; - последний. &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; также может быть получен для типов данных с одним конструктором, составляющие типы которых находятся в &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="674d2d4d75029f825bd270a8d08697ebd9b70ba6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; классы.</target>
        </trans-unit>
        <trans-unit id="c5cd6d00d90b1e061059918ba18205b11c14c002" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; type allows you to reverse sort order conveniently. A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt;). If &lt;code&gt;a&lt;/code&gt; has an &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance associated with it then comparing two values thus wrapped will give you the opposite of their normal sort order. This is particularly useful when sorting in generalised list comprehensions, as in: &lt;code&gt;then sortWith by &lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt;</source>
          <target state="translated">Тип &amp;laquo; &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; &amp;raquo; позволяет удобно менять порядок сортировки на обратный. Значение типа &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; содержит значение типа &lt;code&gt;a&lt;/code&gt; (представленное как &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; ). Если имеет &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; экземпляр , связанный с ним , то сравнение двух значений , таким образом , обернутые даст вам противоположное их нормального порядка сортировки. Это особенно полезно при сортировке в обобщенных представлениях списка, например: &lt;code&gt;then sortWith by &lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; x &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf4c3fac24e8ca008ba612ac6b40c0fcd012f0f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:IsList&quot;&gt;IsList&lt;/a&gt;&lt;/code&gt; class and its methods are intended to be used in conjunction with the OverloadedLists extension.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;ghc-exts#t:IsList&quot;&gt;IsList&lt;/a&gt;&lt;/code&gt; и его методы предназначены для использования вместе с расширением OverloadedLists.</target>
        </trans-unit>
        <trans-unit id="d7ba5830092cef4d84647e79c69131dbc7adc059" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Item&quot;&gt;Item&lt;/a&gt;&lt;/code&gt; type function returns the type of items of the structure &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">Функция Тип &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Item&quot;&gt;Item&lt;/a&gt;&lt;/code&gt; возвращает тип элементов структуры &lt;code&gt;l&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f84b47ee1d124d1ca79a226e83d25027b22134b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; function constructs the structure &lt;code&gt;l&lt;/code&gt; from the given list of &lt;code&gt;Item l&lt;/code&gt;</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; создает структуру &lt;code&gt;l&lt;/code&gt; из заданного списка &lt;code&gt;Item l&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ceee73322b5e0bdd5f3091f55d6384a70d17944b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; function takes the input list's length as a hint. Its behaviour should be equivalent to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt;. The hint can be used to construct the structure &lt;code&gt;l&lt;/code&gt; more efficiently compared to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt;. If the given hint does not equal to the input list's length the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; is not specified.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; принимает длину входного списка в качестве подсказки. Его поведение должно быть эквивалентно &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; . Подсказка может быть использована для более эффективного построения структуры &lt;code&gt;l&lt;/code&gt; по сравнению с &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; . Если указанная подсказка не равна длине входного списка, поведение &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; не указывается.</target>
        </trans-unit>
        <trans-unit id="c5c04c12c048d0307d00092d987715f0d989db28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:groupWith&quot;&gt;groupWith&lt;/a&gt;&lt;/code&gt; function uses the user supplied function which projects an element out of every list element in order to first sort the input list and then to form groups by equality on these projected elements</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-exts#v:groupWith&quot;&gt;groupWith&lt;/a&gt;&lt;/code&gt; использует предоставленную пользователем функцию, которая проецирует элемент из каждого элемента списка, чтобы сначала отсортировать список ввода, а затем сформировать группы по равенству для этих проецируемых элементов.</target>
        </trans-unit>
        <trans-unit id="695facc226b98a2fdc94f961971c4ce121f69e9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; function restrains strictness analysis a little. The call &lt;code&gt;lazy e&lt;/code&gt; means the same as &lt;code&gt;e&lt;/code&gt;, but &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; has a magical property so far as strictness analysis is concerned: it is lazy in its first argument, even though its semantics is strict. After strictness analysis has run, calls to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; are inlined to be the identity function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; специальностей ограничители строгости анализ мало. Вызов &lt;code&gt;lazy e&lt;/code&gt; означает то же самое, что и &lt;code&gt;e&lt;/code&gt; , но &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; имеет волшебное свойство в том, что касается анализа строгости: он ленив в своем первом аргументе, даже несмотря на то, что его семантика строгая. После выполнения анализа строгости вызовы &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; встроены в функцию идентификации.</target>
        </trans-unit>
        <trans-unit id="c62e040021cb66d2ce6289579ad247f811fcaf97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; function can be used to give a hint to the compiler that its argument will be called at most once, which may (or may not) enable certain optimizations. It can be useful to improve the performance of code in continuation passing style.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; функция может быть использована , чтобы дать подсказку компилятору , что ее аргумент будет называться не более одного раза, что может (или не может) дать определенные оптимизации. Это может быть полезно для повышения производительности кода при продолжении передачи.</target>
        </trans-unit>
        <trans-unit id="738f70f90664f23041407e78e7481ca578a61fb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:sortWith&quot;&gt;sortWith&lt;/a&gt;&lt;/code&gt; function sorts a list of elements using the user supplied function to project something out of each element</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-exts#v:sortWith&quot;&gt;sortWith&lt;/a&gt;&lt;/code&gt; сортирует список элементов, используя предоставленную пользователем функцию для проецирования чего-либо из каждого элемента.</target>
        </trans-unit>
        <trans-unit id="f8c0871b5b6f8b978adbdfa4a64b81796ab60e0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; function extracts a list of &lt;code&gt;Item l&lt;/code&gt; from the structure &lt;code&gt;l&lt;/code&gt;. It should satisfy fromList . toList = id.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; извлекает список &lt;code&gt;Item l&lt;/code&gt; из структуры &lt;code&gt;l&lt;/code&gt; . Он должен удовлетворять fromList. toList = id.</target>
        </trans-unit>
        <trans-unit id="b18ac779aba3ac796c0284e4d2cc3bb7c69a9f44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is parameterised in the same way as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;. The type argument of &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; should normally be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; параметризуется таким же образом , как &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; . Аргумент типа &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; обычно должен быть экземпляром класса &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5c813e0c538449c8b967f68e862c925ce84f9ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Leaf&quot; 'PrefixI 'False)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Node&quot; 'PrefixI 'False)&lt;/code&gt; invocations indicate that the enclosed part is the representation of the first and second constructor of datatype &lt;code&gt;Tree&lt;/code&gt;, respectively. Here, the meta-information regarding constructor names, fixity and whether it has named fields or not is encoded at the type level. The &lt;code&gt;'MetaCons&lt;/code&gt; type is also an instance of the type class &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Constructor&quot;&gt;Constructor&lt;/a&gt;&lt;/code&gt;. This type class can be used to obtain information about the constructor at the value level.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Leaf&quot; 'PrefixI 'False)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Node&quot; 'PrefixI 'False)&lt;/code&gt; вызовы показывают , что прилагаемая часть является представление первого и второго конструктора типа данных &lt;code&gt;Tree&lt;/code&gt; , соответственно. Здесь метаинформация, касающаяся имен конструкторов, фиксации и того, имеет ли он именованные поля или нет, кодируется на уровне типа. Тип &lt;code&gt;'MetaCons&lt;/code&gt; также является экземпляром класса типа &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Constructor&quot;&gt;Constructor&lt;/a&gt;&lt;/code&gt; . Этот класс типа можно использовать для получения информации о конструкторе на уровне значения.</target>
        </trans-unit>
        <trans-unit id="4b3758b0106cdc9eb50e8251878d12e347f33b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt; ('MetaData &quot;Tree&quot; &quot;Main&quot; &quot;package-name&quot; 'False)&lt;/code&gt; tag indicates that the enclosed part is the representation of the datatype &lt;code&gt;Tree&lt;/code&gt;. Again, the meta-information is encoded at the type level. The &lt;code&gt;'MetaData&lt;/code&gt; type is an instance of class &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Datatype&quot;&gt;Datatype&lt;/a&gt;&lt;/code&gt;, which can be used to obtain the name of a datatype, the module it has been defined in, the package it is located under, and whether it has been defined using &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt; at the value level.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt; ('MetaData &quot;Tree&quot; &quot;Main&quot; &quot;package-name&quot; 'False)&lt;/code&gt; тег указывает на то, что прилагаемая часть является представление типа данных &lt;code&gt;Tree&lt;/code&gt; . Опять же, метаинформация кодируется на уровне типа. Тип &lt;code&gt;'MetaData&lt;/code&gt; - это экземпляр класса &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Datatype&quot;&gt;Datatype&lt;/a&gt;&lt;/code&gt; , который можно использовать для получения имени типа данных, модуля, в котором он был определен, пакета, в котором он расположен, и того, был ли он определен с использованием &lt;code&gt;data&lt;/code&gt; или &lt;code&gt;newtype&lt;/code&gt; в уровень стоимости.</target>
        </trans-unit>
        <trans-unit id="490133c0313c9ba8b7db7fbe7e0fe5b2bf18b53d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; class can be generalized to range over types of kind &lt;code&gt;k -&amp;gt; *&lt;/code&gt;, for any kind &lt;code&gt;k&lt;/code&gt;. To do so, derive a &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; instance with the &lt;code&gt;PolyKinds&lt;/code&gt; extension enabled. For example, the declaration</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; может быть обобщен на типы типа &lt;code&gt;k -&amp;gt; *&lt;/code&gt; для любого типа &lt;code&gt;k&lt;/code&gt; . Для этого &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; экземпляр Generic1 с &lt;code&gt;PolyKinds&lt;/code&gt; расширением PolyKinds . Например, объявление</target>
        </trans-unit>
        <trans-unit id="b51e7af78f64d86aed93f2c4d635092dabfbb762" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt; ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness
      'DecidedLazy)&lt;/code&gt; tag indicates several things. The &lt;code&gt;'Nothing&lt;/code&gt; indicates that there is no record field selector associated with this field of the constructor (if there were, it would have been marked &lt;code&gt;'Just
      &quot;recordName&quot;&lt;/code&gt; instead). The other types contain meta-information on the field's strictness:</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt; ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)&lt;/code&gt; Тег указывает несколько вещей. &lt;code&gt;'Nothing&lt;/code&gt; указует на то, что нет Селектора записи поля , связанного с этим полем конструктора (если бы это было бы отмечено &lt;code&gt;'Just &quot;recordName&quot;&lt;/code&gt; вместо этого). Остальные типы содержат метаинформацию о строгости поля:</target>
        </trans-unit>
        <trans-unit id="d0cdba7fd39b9182aef4d3fd8dd460a16d152145" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; типа.</target>
        </trans-unit>
        <trans-unit id="ccb84e64bf7ed15245460804350d5f1cb2e76cd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#t:CodingFailureMode&quot;&gt;CodingFailureMode&lt;/a&gt;&lt;/code&gt; is used to construct &lt;code&gt;&lt;a href=&quot;system-io#v:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt;s, and specifies how they handle illegal sequences.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#t:CodingFailureMode&quot;&gt;CodingFailureMode&lt;/a&gt;&lt;/code&gt; используется для построения &lt;code&gt;&lt;a href=&quot;system-io#v:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; s, и определяет , как они обрабатывают незаконные последовательности.</target>
        </trans-unit>
        <trans-unit id="727269e258ca0cc1f5b84b187e061106f48b55ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of a finite list of numbers.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; вычисляет произведение конечного списка чисел.</target>
        </trans-unit>
        <trans-unit id="29f4142ef18f41223155d901b10e8d9efcecd6fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of a finite list of numbers.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; вычисляет сумму конечного списка чисел.</target>
        </trans-unit>
        <trans-unit id="791089d56d61f4d3b56178eb7352f6df80bab567" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; принимает список троек и возвращает три списка, аналогично &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bb018b60fccf9ba007b71e9eb3d8a718941c0f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет три элемента, а также три списка, и возвращает список их точечной комбинации, аналогично &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="24f96e687e4620b9109ecaf114edba80a1baa66c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type encapsulates an optional value. A value of type &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; either contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt;), or it is empty (represented as &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;). Using &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is a good way to deal with errors or exceptional cases without resorting to drastic measures such as &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; инкапсулирует необязательное значение. Значение типа &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; либо содержит значение типа &lt;code&gt;a&lt;/code&gt; (представленное как &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; ), либо оно пустое (представлено как &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ). Использование &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; - хороший способ справиться с ошибками или исключительными случаями, не прибегая к таким радикальным мерам, как &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="266e593abd43191340f9b33fd8e15a10e0dc922a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type is also a monad. It is a simple kind of error monad, where all errors are represented by &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. A richer error monad can be built using the &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; - тоже монада. Это простая монада ошибок, в которой все ошибки представлены &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; . Более богатая монада ошибок может быть построена с &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; типа Either .</target>
        </trans-unit>
        <trans-unit id="b66270e05d2350973bd17982c61ae01a11e0a3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; class and the &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; и тип &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d90a8339ada736c69e4569a04518d30718bf0396" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; function is list difference (non-associative). In the result of &lt;code&gt;xs&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt;&lt;code&gt;ys&lt;/code&gt;, the first occurrence of each element of &lt;code&gt;ys&lt;/code&gt; in turn (if any) has been removed from &lt;code&gt;xs&lt;/code&gt;. Thus</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; - это разность списков (неассоциативная). В результате &lt;code&gt;xs&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; &lt;code&gt;ys&lt;/code&gt; первое вхождение каждого элемента &lt;code&gt;ys&lt;/code&gt; по очереди (если есть) было удалено из &lt;code&gt;xs&lt;/code&gt; . таким образом</target>
        </trans-unit>
        <trans-unit id="5f790bce52b575010739edf6cb02aa96c2885cb9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; function takes a predicate and two lists and returns the first list with the first occurrence of each element of the second list removed.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; принимает предикат и два списка и возвращает первый список с первым удаленным вхождением каждого элемента второго списка.</target>
        </trans-unit>
        <trans-unit id="a978c3a6eaa51a8f531e3682bd2d367abf6607ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; function drops the largest suffix of a list in which the given predicate holds for all elements. For example:</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; отбрасывает самый большой суффикс списка, в котором данный предикат выполняется для всех элементов. Например:</target>
        </trans-unit>
        <trans-unit id="109bdc9435b830725cf189c556de56387a5634f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given list which is equal (by &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) to the query element, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; возвращает индекс первого элемента в данном списке, который равен (на &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; ) элементу запроса, или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если такого элемента нет.</target>
        </trans-unit>
        <trans-unit id="fadb3e5498f5526f3f541154cc26a34805337369" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements equal to the query element, in ascending order.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; расширяет &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; , возвращая индексы всех элементов, равных элементу запроса, в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="6568db6f34d6f7a7bf8a446041bb3489740f3067" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a list and returns the first element in the list matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; принимает предикат и список и возвращает первый элемент в списке, соответствующий предикату, или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если такого элемента нет.</target>
        </trans-unit>
        <trans-unit id="4275cc9b36aa0e4769199e754686defa1594e4b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a list and returns the index of the first element in the list satisfying the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; принимает предикат и список и возвращает индекс первого элемента в списке, удовлетворяющего этому предикату, или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если такого элемента нет.</target>
        </trans-unit>
        <trans-unit id="2f76c76695266af5e321e89b84f46bb9a822c35f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; расширяет &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; , возвращая индексы всех элементов, удовлетворяющих предикату, в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="305fac941a1cc5c29fd70cdde5362cbcac036635" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to drop.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; - это перегруженная версия &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; , которая принимает любое значение &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; в качестве количества удаляемых элементов.</target>
        </trans-unit>
        <trans-unit id="acf544a13e18ba4358a78c184967bf2f876a1aec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the index.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; - это перегруженная версия &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt; , который принимает любое &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; значение в качестве индекса.</target>
        </trans-unit>
        <trans-unit id="813efa98177dcd58489481e0cb89e0133d9e87e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of repetitions to make.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; - это перегруженная версия функции &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; , которая принимает любое значение &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; в качестве количества выполняемых повторений.</target>
        </trans-unit>
        <trans-unit id="d7d4ee3930a7434ca7c403b4565de9be9be21b9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the position at which to split.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; - это перегруженная версия &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; , которая принимает любое значение &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; в качестве позиции, в которой выполняется разделение.</target>
        </trans-unit>
        <trans-unit id="e4afafa2336fcae4601a2eaca8e96fec05a60b92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to take.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; - это перегруженная версия &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; , которая принимает любое значение &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; в качестве количества принимаемых элементов.</target>
        </trans-unit>
        <trans-unit id="f4f6a5e91131c42f6af8de505ab848b2b5f93891" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a list and returns a list of lists such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; принимает список и возвращает список списков, так что объединение результата равно аргументу. Более того, каждый подсписок в результате содержит только равные элементы. Например,</target>
        </trans-unit>
        <trans-unit id="d100c0bef6b2c8b32f44a08a7e7eacb8db8f8cbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34b65659a51ccdb8baad87c00cd32d74ef9d403b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; function returns all initial segments of the argument, shortest first. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; возвращает все начальные сегменты аргумента, сначала самые короткие. Например,</target>
        </trans-unit>
        <trans-unit id="144853d03169fd7769ada44b12eba567928f0591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; function takes the list intersection of two lists. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; принимает пересечение двух списков. Например,</target>
        </trans-unit>
        <trans-unit id="605c4315b576beab0a53cad6a48c3adba1b2f451" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия элемента &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abf262d8a1cc937359d5c3c8f6075d27f69eb8ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is contained, wholly and intact, anywhere within the second.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; принимает два списка и возвращает &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если первый список содержится целиком и без изменений где-нибудь во втором.</target>
        </trans-unit>
        <trans-unit id="88d273a08a3e06000e98c2629e1e60ff60ea1336" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a suffix of the second. The second list must be finite.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; принимает два списка и возвращает &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если первый список является суффиксом второго. Второй список должен быть конечным.</target>
        </trans-unit>
        <trans-unit id="551caf48474039991548fe9ddb64d72b72493414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a list, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу списка, передавая параметр накопления слева направо и возвращая окончательное значение этого аккумулятора вместе с новым списком.</target>
        </trans-unit>
        <trans-unit id="8de586ae79a455858fed3746ae4e38cd05c48c19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a list, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу списка, передавая параметр накопления справа налево и возвращая окончательное значение этого аккумулятора вместе с новым списком.</target>
        </trans-unit>
        <trans-unit id="2391074ba068c80233175c59983a54b8066a4878" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:maximumBy&quot;&gt;maximumBy&lt;/a&gt;&lt;/code&gt; function takes a comparison function and a list and returns the greatest element of the list by the comparison function. The list must be finite and non-empty.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:maximumBy&quot;&gt;maximumBy&lt;/a&gt;&lt;/code&gt; принимает функцию сравнения и список и возвращает наибольший элемент списка функцией сравнения. Список должен быть конечным и непустым.</target>
        </trans-unit>
        <trans-unit id="cef47277c570e470c285b99dbd14acd85cf932dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:minimumBy&quot;&gt;minimumBy&lt;/a&gt;&lt;/code&gt; function takes a comparison function and a list and returns the least element of the list by the comparison function. The list must be finite and non-empty.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:minimumBy&quot;&gt;minimumBy&lt;/a&gt;&lt;/code&gt; принимает функцию сравнения и список и возвращает наименьший элемент списка функцией сравнения. Список должен быть конечным и непустым.</target>
        </trans-unit>
        <trans-unit id="057b661eee28e56248a47e5a122b7f8d64ae8148" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt;, except it uses a user-supplied equality predicate instead of the overloaded &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; ведет себя так же, как &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; , за исключением того, что в ней используется предикат равенства, предоставляемый пользователем, вместо перегруженной функции &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19f8893f6a607220120cf57b88c38b3c50e89e8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate a list and returns the pair of lists of elements which do and do not satisfy the predicate, respectively; i.e.,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; принимает предикат список и возвращает пару списков элементов, которые удовлетворяют и не удовлетворяют предикату, соответственно; т.е.</target>
        </trans-unit>
        <trans-unit id="2d853a061eb012af5ee71d94b4188db9e7e27bb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; function returns the list of all permutations of the argument.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; возвращает список всех перестановок аргумента.</target>
        </trans-unit>
        <trans-unit id="0d369bcd6ff7a16017fc81230836cb1e2c9c3d1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of a finite list of numbers.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; вычисляет произведение конечного списка чисел.</target>
        </trans-unit>
        <trans-unit id="7601896a58f38cef45cf3ec9dd3675ffa2b1f23a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function implements a stable sorting algorithm. It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; реализует стабильный алгоритм сортировки. Это частный случай &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; , который позволяет программисту предоставлять свою собственную функцию сравнения.</target>
        </trans-unit>
        <trans-unit id="c7da3570e28419be0578ffd1de4f0b1fde8e86aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f1f49bd6e008dde965696cc4f68b37f4c1c2ff6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; function returns the list of all subsequences of the argument.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; возвращает список всех подпоследовательностей аргумента.</target>
        </trans-unit>
        <trans-unit id="a6406e7e60d1afb305384d5af825ad223afd4d34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of a finite list of numbers.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; вычисляет сумму конечного списка чисел.</target>
        </trans-unit>
        <trans-unit id="26c98a67aa07a5febf23006c6463cf654a93d6a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its argument. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; перемещает строки и столбцы своего аргумента. Например,</target>
        </trans-unit>
        <trans-unit id="c88aa8ebb4d5e9ab3079fc636599897089099a45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is a `dual' to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;: while &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; reduces a list to a summary value, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a list from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the list or returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepended to the list and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; является двойной функцией &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; : в то время как &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; сокращает список до итогового значения, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; строит список из начального значения. Функция принимает элемент и возвращает &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если она завершила создание списка, или возвращает &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; , и в этом случае &lt;code&gt;a&lt;/code&gt; добавляется к списку, а &lt;code&gt;b&lt;/code&gt; используется как следующий элемент в рекурсивном вызове. Например,</target>
        </trans-unit>
        <trans-unit id="27a85700d4b6c91457baf0366be6c72427d177b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; function returns the list union of the two lists. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; возвращает объединение двух списков. Например,</target>
        </trans-unit>
        <trans-unit id="897e5cd71a34240e2a452fc04aada2f8a3873766" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a213a220259b72a83d767902fd9b906a21d8991" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; принимает список троек и возвращает три списка, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9f131d892100da4fd025f7a8ecff18fd3436b21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; function takes a list of quadruples and returns four lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; берет список из четверок и возвращает четыре списка, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f19f192bc7bca3bb3b366a104a1495f29a2a94b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; function takes a list of five-tuples and returns five lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; принимает список из пяти кортежей и возвращает пять списков, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12f0884943983f42126b4d7235d7fee19d6961ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; function takes a list of six-tuples and returns six lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; принимает список из шести кортежей и возвращает шесть списков, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd0ada4ba254397c7f2074cd7fe54881a14745ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; function takes a list of seven-tuples and returns seven lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; принимает список из семи кортежей и возвращает семь списков, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0a0bedc800fc663f9a45123739d0871e9842832" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; function takes four lists and returns a list of quadruples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; принимает четыре списка и возвращает список из четырех элементов, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="b833eb65f6d996a715798ed453669aa9621f8431" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; function takes five lists and returns a list of five-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; принимает пять списков и возвращает список из пяти кортежей, аналогичный &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="59728e29b809276b20b7cc9ae48caadda444d7f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; function takes six lists and returns a list of six-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; принимает шесть списков и возвращает список из шести кортежей, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="df3589322d209e15f6610db4bb0c1c54692646e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; function takes seven lists and returns a list of seven-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; принимает семь списков и возвращает список из семи кортежей, аналогичный &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="7fb675c3384f90b4e5fdef7383e6b1b6d07309c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет три элемента, а также три списка, и возвращает список их точечной комбинации, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="4d9d273ee2479cdb2c6b8ef0f65b15d495db5a7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; function takes a function which combines four elements, as well as four lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет четыре элемента, а также четыре списка и возвращает список их точечной комбинации, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="6aa1fdb5c348373284d6b8cfbe31c2976333f351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; function takes a function which combines five elements, as well as five lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет пять элементов, а также пять списков, и возвращает список их точечных комбинаций, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="5fd0df64a913d6523d2c136a1cb0ba65ca9434f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; function takes a function which combines six elements, as well as six lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет шесть элементов, а также шесть списков, и возвращает список их точечной комбинации, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="57fc99e0dcfb0d585978688443e7472a5b1473e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; function takes a function which combines seven elements, as well as seven lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет семь элементов, а также семь списков, и возвращает список их точечной комбинации, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="b1325d57361ccc732ebb070de994b0a2421219c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; types and operations.</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; типы и операции.</target>
        </trans-unit>
        <trans-unit id="5763505508dac7b11615ee08a7acaba3fb632110" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; function casts a pointer from one type to another.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; переводит указатель от одного типа к другому.</target>
        </trans-unit>
        <trans-unit id="a500ee9d80b7f54eb7f8c916b79c09da04687f2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class and instances for basic data types.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; класс и примеры для основных типов данных.</target>
        </trans-unit>
        <trans-unit id="f5c958fd454a64dcb4c746fc275eb37dbbac1200" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; считывает одну лексему из ввода, отбрасывая начальные пробелы и возвращая символы, составляющие лексему. Если входная строка содержит только пробелы, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; возвращает единственную успешную `лексему ', состоящую из пустой строки. (Таким образом, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt; .) Если в начале входной строки нет допустимой лексемы, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; не работает (т.е. возвращает &lt;code&gt;[]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="86c3288ccf7776810d20b3731af2e3b40bfcb247" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; class, and related operations.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; и связанные с ним операции.</target>
        </trans-unit>
        <trans-unit id="9d5187961ae2687bea868b7eebea12a2b0fc9457" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; Monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; Монада.</target>
        </trans-unit>
        <trans-unit id="1a6e8251d60596b015e69b7b30aa3903c1d58def" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticKey&quot;&gt;StaticKey&lt;/a&gt;&lt;/code&gt; that can be used to look up the given &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticKey&quot;&gt;StaticKey&lt;/a&gt;&lt;/code&gt; , который может быть использован для просмотра данного &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed23a830eec8e95fb04719f3ba021e908eb49a47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; function lets you run an I/O computation in the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Take care: you are guaranteed the ordering of calls to &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; within a single &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; computation, but not about the order in which splices are run.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; позволяет выполнять вычисление ввода-вывода в монаде &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; .Будьте осторожны: вам гарантируется порядок вызовов &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; в рамках одного вычисления &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; , но не порядок, в котором выполняются соединения.</target>
        </trans-unit>
        <trans-unit id="fa005a185e418ee86a0f14b966d5bed4334ff0bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; type, a value &lt;code&gt;q&lt;/code&gt; of this type can be used in the syntax &lt;code&gt;[q| ... string to parse ...|]&lt;/code&gt;. In fact, for convenience, a &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; actually defines multiple quasiquoters to be used in different splice contexts; if you are only interested in defining a quasiquoter to be used for expressions, you would define a &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; with only &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#v:quoteExp&quot;&gt;quoteExp&lt;/a&gt;&lt;/code&gt;, and leave the other fields stubbed out with errors.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; , значение &lt;code&gt;q&lt;/code&gt; этого типа может использоваться в синтаксисе &lt;code&gt;[q| ... string to parse ...|]&lt;/code&gt; . Фактически, для удобства &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; фактически определяет несколько квазиквотеров, которые будут использоваться в разных контекстах монтажа; если вас интересует только определение квазиквотера, который будет использоваться для выражений, вы должны определить &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; только с &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#v:quoteExp&quot;&gt;quoteExp&lt;/a&gt;&lt;/code&gt; , а остальные поля оставить с ошибками.</target>
        </trans-unit>
        <trans-unit id="822f6a374e5da6792e8281daef5bc8cbc52436fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; function lets you run an I/O computation in the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Take care: you are guaranteed the ordering of calls to &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; within a single &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; computation, but not about the order in which splices are run.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; позволяет выполнять вычисление ввода-вывода в монаде &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; .Будьте осторожны: вам гарантируется порядок вызовов &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; в рамках одного вычисления &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; , но не порядок, в котором выполняются соединения.</target>
        </trans-unit>
        <trans-unit id="8a0d53f38c6a950df5eadf21a9f9db4dfc69bf0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class is used to name the upper and lower limits of a type. &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is not a superclass of &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; since types that are not totally ordered may also have upper and lower bounds.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; используется для обозначения верхнего и нижнего пределов типа. &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; не является суперклассом &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; , поскольку типы, которые не являются полностью упорядоченными, могут также иметь верхнюю и нижнюю границы.</target>
        </trans-unit>
        <trans-unit id="bf58cbc6033627535675be41f7c5c26c9a969514" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class may be derived for any enumeration type; &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; is the first constructor listed in the &lt;code&gt;data&lt;/code&gt; declaration and &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; is the last. &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; may also be derived for single-constructor datatypes whose constituent types are in &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; может быть производным от любого типа перечисления; &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; - это первый конструктор, указанный в объявлении &lt;code&gt;data&lt;/code&gt; а &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; - последний. &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; также может быть получен для типов данных с одним конструктором, составляющие типы которых находятся в &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f24f4c3acddeb2d8485bbd7d048662ea4520e018" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type is sometimes used to represent a value which is either correct or an error; by convention, the &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor is used to hold an error value and the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor is used to hold a correct value (mnemonic: &quot;right&quot; also means &quot;correct&quot;).</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; иногда используется для представления значения, которое является правильным или ошибочным; по соглашению конструктор &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; используется для хранения значения ошибки, а конструктор &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; используется для хранения правильного значения (мнемоника: &amp;laquo;right&amp;raquo; также означает &amp;laquo;правильный&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="9d02c060c8f45391329e1f6687a2f0b6730500f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type represents values with two possibilities: a value of type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; представляет значения с двумя возможностями: значение типа &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; равно &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e44fd4d00d0795dea5f783f70db56faa6bffc024" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; class defines equality (&lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) and inequality (&lt;code&gt;&lt;a href=&quot;prelude#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt;). All the basic datatypes exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; are instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; may be derived for any datatype whose constituents are also instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; определяет равенство ( &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; ) и неравенство ( &lt;code&gt;&lt;a href=&quot;prelude#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt; ). Все основные типы данных, экспортируемые &lt;a href=&quot;prelude&quot;&gt;Prelude,&lt;/a&gt; являются экземплярами &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; может быть получено для любого типа данных, составные части которого также являются экземплярами &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75fb7e193c14639f9f2c840b46b6b678ecc93443" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type encapsulates an optional value. A value of type &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; either contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt;), or it is empty (represented as &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;). Using &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is a good way to deal with errors or exceptional cases without resorting to drastic measures such as &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; инкапсулирует необязательное значение. Значение типа &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; либо содержит значение типа &lt;code&gt;a&lt;/code&gt; (представленное как &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; ), либо оно пустое (представлено как &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ). Использование &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; - хороший способ справиться с ошибками или исключительными случаями, не прибегая к таким радикальным мерам, как &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d4644834b747ca6136ef2aaff7f66c325592783" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type is also a monad. It is a simple kind of error monad, where all errors are represented by &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. A richer error monad can be built using the &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; - тоже монада. Это простая монада ошибок, в которой все ошибки представлены &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; . Более богатая монада ошибок может быть построена с &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; типа Either .</target>
        </trans-unit>
        <trans-unit id="b2bc4ca3d8934e365fb80ceb2378eb5082b3a17f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; class defines the basic operations over a &lt;em&gt;monad&lt;/em&gt;, a concept from a branch of mathematics known as &lt;em&gt;category theory&lt;/em&gt;. From the perspective of a Haskell programmer, however, it is best to think of a monad as an &lt;em&gt;abstract datatype&lt;/em&gt; of actions. Haskell's &lt;code&gt;do&lt;/code&gt; expressions provide a convenient syntax for writing monadic expressions.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; определяет основные операции над &lt;em&gt;монадой&lt;/em&gt; - концепцию из раздела математики, известного как &lt;em&gt;теория категорий&lt;/em&gt; . Однако с точки зрения программиста на Haskell лучше всего рассматривать монаду как &lt;em&gt;абстрактный тип данных&lt;/em&gt; действий. Выражения &lt;code&gt;do&lt;/code&gt; в Haskell обеспечивают удобный синтаксис для написания монадических выражений.</target>
        </trans-unit>
        <trans-unit id="7aaef56b80f737eb27df9b1e3d02aefbb49c126c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; allows us to chain together multiple actions which may fail, and fail overall if any of the individual steps failed. First we'll write a function that can either parse an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, or fail.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; экземпляр для &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; позволяет связать между собой несколькими действиями , которые могут потерпеть неудачу, и не в целом , если какие - либо из отдельных шагов , не удалось. Сначала мы напишем функцию, которая может либо разбирать &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; из &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , либо терпеть неудачу.</target>
        </trans-unit>
        <trans-unit id="7b3a6ba7d1631eb7dffbc7a80d33a50655ec5cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class is used for totally ordered datatypes.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; используется для полностью упорядоченных типов данных.</target>
        </trans-unit>
        <trans-unit id="7fb9b92b465e420832be5f52da24e03070664a5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from our &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance will ignore &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values, but will apply the supplied function to values contained in a &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; из нашего &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; экземпляра будет игнорировать &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; значения, но будет применять указанную функцию к значениям , содержащимся в &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bb778616987d1ec9e7af8ce5c3a0fe1ad6f720c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; method restricted to the type &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Метод &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; ограничен типом &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdbf4d018722d263569f1a254868963b4ff029df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is read lazily as it is needed (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Операция &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; возвращает весь пользовательский ввод в виде одной строки, которая читается лениво по мере необходимости (то же самое, что и &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aa6a84a7de6790cd0de53c018c33b1487b75f830" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;String-&amp;gt;String&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; принимает в качестве аргумента функцию типа &lt;code&gt;String-&amp;gt;String&lt;/code&gt; . Весь ввод от стандартного устройства ввода передается этой функции в качестве аргумента, а результирующая строка выводится на стандартное устройство вывода.</target>
        </trans-unit>
        <trans-unit id="79b16f25ddf4b36594ea2e938465c9296ed38dc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; считывает одну лексему из ввода, отбрасывая начальные пробелы и возвращая символы, составляющие лексему. Если входная строка содержит только пробелы, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; возвращает единственную успешную `лексему ', состоящую из пустой строки. (Таким образом, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt; .) Если в начале входной строки нет допустимой лексемы, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; не работает (т.е. возвращает &lt;code&gt;[]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0e4582487867df9d645782b484418688a1f3f58c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; function takes a default value, a function, and a &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value is &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the function returns the default value. Otherwise, it applies the function to the value inside the &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and returns the result.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; функция принимает значение по умолчанию, функцию и &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; значение. Если значение &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; равно &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , функция возвращает значение по умолчанию. В противном случае он применяет функцию к значению внутри &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; и возвращает результат.</target>
        </trans-unit>
        <trans-unit id="c131692c2bade036458b0d1127914f219c7dd175" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function outputs a value of any printable type to the standard output device. Printable types are those that are instances of class &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; converts values to strings for output using the &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; operation and adds a newline.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; выводит значение любого печатаемого типа на стандартное устройство вывода. Печатные типы - это экземпляры класса &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; ; &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; преобразует значения в строки для вывода с помощью операции &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; и добавляет новую строку.</target>
        </trans-unit>
        <trans-unit id="8c7fc1c52a42ce0024aec6c65a38a9e6dc8fb7ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; вычисляет произведение номеров конструкции.</target>
        </trans-unit>
        <trans-unit id="f99911d99a3ef08fe8f375dba1db41c4eecf08d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function reads input from a string, which must be completely consumed by the input process. &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; fails with an &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the parse is unsuccessful, and it is therefore discouraged from being used in real applications. Use &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; for safe alternatives.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; считывает ввод из строки, которая должна быть полностью использована процессом ввода. &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; завершается неудачно с &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; если синтаксический анализ не удался, и поэтому не рекомендуется использовать его в реальных приложениях. Используйте &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; для безопасных альтернатив.</target>
        </trans-unit>
        <trans-unit id="4ffdc3ac1e36da7a1438f94612f331c6323f073b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; считывает файл и возвращает содержимое файла в виде строки. Файл читается лениво, по запросу, как и в случае с &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1edaaff10f2fbe79640944d7ec56cb49a4bed802" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; function is similar to &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; except that it signals parse failure to the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad instead of terminating the program.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; аналогична функции &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; за исключением того, что она сигнализирует монаде &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; об ошибке синтаксического анализа вместо завершения программы.</target>
        </trans-unit>
        <trans-unit id="9e25de194b180f1f5888a1fb8e989cb909435014" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; function combines &lt;code&gt;&lt;a href=&quot;prelude#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; объединяет &lt;code&gt;&lt;a href=&quot;prelude#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfe43d67eb01eceb873ed3fd660e71f0f5174638" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; вычисляет сумму номеров конструкции.</target>
        </trans-unit>
        <trans-unit id="bbb5313ec9e6c9e5650625c5d2da153e452b2504" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; method restricted to the type &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Метод &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; ограничен типом &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a04819fa78c89f5452b8780304a58025b2a647c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;prelude#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; принимает список троек и возвращает три списка, аналогично &lt;code&gt;&lt;a href=&quot;prelude#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="052c2b73f585f4387bcfea6e35542d389d49e8f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет три элемента, а также три списка и возвращает список их точечных комбинаций, аналогично &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="645f48f9edaa9bdfcdbd50f2978b6ca7c976e666" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;getConsoleCP&lt;/code&gt;.</source>
          <target state="translated">Функции &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; вывода (например, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; ) не преобразуются автоматически в Unicode, поэтому эта функция предназначена для преобразования многобайтовой строки в данной кодовой странице в правильную строку Unicode. Чтобы получить кодовую страницу для консоли, используйте &lt;code&gt;getConsoleCP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9915513312e5b9714f0fe4288381e0da0f72704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:InputT&quot;&gt;InputT&lt;/a&gt;&lt;/code&gt; monad transformer provides direct, low-level access to the user's line history state.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:InputT&quot;&gt;InputT&lt;/a&gt;&lt;/code&gt; монада трансформатор обеспечивает прямой, низкоуровневый доступ к архивному состоянию линии пользователя.</target>
        </trans-unit>
        <trans-unit id="77b115021e101641ef1f81dd36bd9d5f8a21f7b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:controlIO&quot;&gt;controlIO&lt;/a&gt;&lt;/code&gt; method enables us to &quot;lift&quot; a function that manages IO actions (such as &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;) into a function that wraps arbitrary monadic actions.</source>
          <target state="translated">Метод &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:controlIO&quot;&gt;controlIO&lt;/a&gt;&lt;/code&gt; позволяет нам &amp;laquo;поднять&amp;raquo; функцию, которая управляет действиями ввода-вывода (такими как &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; ), в функцию, которая обертывает произвольные монадические действия.</target>
        </trans-unit>
        <trans-unit id="d97760ad46f0a47182108cce3dd3552c71ffced8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; monoid abstracts away all padding and control sequence output. Unfortunately, that datatype is difficult to integrate into existing &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;-based APIs such as pretty-printers. Thus, as a workaround, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; also lets us access the control sequences as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The one caveat is that it will not allow you to access padded control sequences as Strings. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; Моноид абстрагирует все отступы и управления выходной последовательности. К сожалению, этот тип данных сложно интегрировать в существующие API-интерфейсы на основе &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , такие как pretty-printers. Таким образом, в качестве обходного пути &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; также позволяет нам получать доступ к управляющим последовательностям как &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; s. Единственное предостережение заключается в том, что он не позволит вам получить доступ к дополненным управляющим последовательностям как к строкам. Например:</target>
        </trans-unit>
        <trans-unit id="7ff1172a4964334b38f0ed53fd5acdd80ad6655a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-cputime#v:cpuTimePrecision&quot;&gt;cpuTimePrecision&lt;/a&gt;&lt;/code&gt; constant is the smallest measurable difference in CPU time that the implementation can record, and is given as an integral number of picoseconds.</source>
          <target state="translated">Константа &lt;code&gt;&lt;a href=&quot;system-cputime#v:cpuTimePrecision&quot;&gt;cpuTimePrecision&lt;/a&gt;&lt;/code&gt; - это наименьшая измеримая разница во времени ЦП, которую может записать реализация, и выражается в виде целого числа пикосекунд.</target>
        </trans-unit>
        <trans-unit id="d42c1bb360791782c56c45d321fb837bc1ed609e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; type is used to record whether certain operations are permissible on a file/directory. &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; get and set these permissions, respectively. Permissions apply both to files and directories. For directories, the executable field will be &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, and for files the searchable field will be &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;. Note that directories may be searchable without being readable, if permission has been given to use them as part of a path, but not to examine the directory contents.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; используется для записи, разрешены ли определенные операции с файлом / каталогом. &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; получают и устанавливают эти разрешения соответственно. Разрешения применяются как к файлам, так и к каталогам. Для каталогов поле исполняемого файла будет &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; , а для файлов доступное для поиска поле будет &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что каталоги могут быть доступны для поиска без возможности чтения, если было дано разрешение использовать их как часть пути, но не для проверки содержимого каталога.</target>
        </trans-unit>
        <trans-unit id="a7fb38ca78261525df1464df4fb698278b8051df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; принимает список значений &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; и возвращает список всех значений &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9dec7d9cce3f521b0de7412db5964162658ad1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; function establishes a handler that receives any &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; raised in the action protected by &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; is caught by the most recent handler established by one of the exception handling functions. These handlers are not selective: all &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s are caught. Exception propagation must be explicitly provided in a handler by re-raising any unwanted exceptions. For example, in</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; функция устанавливает обработчик , который получает любой &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; поднятым в действии , защищенное &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; поймана сам последним обработчик , установленного одним из обработки исключений функций. Эти обработчики не избирательны: перехватываются все &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; . Распространение исключения должно быть явно указано в обработчике путем повторного создания любых нежелательных исключений. Например, в</target>
        </trans-unit>
        <trans-unit id="ff85ed75d901b4d2c7aa0d2761fd28a6697d0178" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default values; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; принимает значение по умолчанию и значение &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; . Если &amp;laquo; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; равно &amp;laquo; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , он возвращает значения по умолчанию; в противном случае возвращается значение, содержащееся в поле &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c7eae4b2c5061e05af7d962b180cd3821808d93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; возвращает пустой список, если задано &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , или одноэлементный список, если задано &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0aa3120b7fd0765f6ac196cefe19e035c54f08e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is read lazily as it is needed (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Операция &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; возвращает весь пользовательский ввод в виде одной строки, которая читается лениво по мере необходимости (то же самое, что и &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="49101be718bf6fa482ea1ac280c8c3978edbdc76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;String-&amp;gt;String&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; принимает в качестве аргумента функцию типа &lt;code&gt;String-&amp;gt;String&lt;/code&gt; . Весь ввод от стандартного устройства ввода передается этой функции в качестве аргумента, а результирующая строка выводится на стандартное устройство вывода.</target>
        </trans-unit>
        <trans-unit id="c28c31ff8d6196f0cd154601474e1e3b9b58f9bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function outputs a value of any printable type to the standard output device. Printable types are those that are instances of class &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; converts values to strings for output using the &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; operation and adds a newline.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; выводит значение любого печатаемого типа на стандартное устройство вывода. Печатные типы - это экземпляры класса &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; ; &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; преобразует значения в строки для вывода с помощью операции &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; и добавляет новую строку.</target>
        </trans-unit>
        <trans-unit id="825ef90fdaca88a42de4c139d5e6c64085f34a5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; считывает файл и возвращает содержимое файла в виде строки. Файл читается лениво, по запросу, как и в случае с &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c55ec6a3320441e71baa3c7cddc99bb5586ab05b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; function is similar to &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; except that it signals parse failure to the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad instead of terminating the program.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; аналогична функции &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; за исключением того, что она сигнализирует монаде &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; об ошибке синтаксического анализа вместо завершения программы.</target>
        </trans-unit>
        <trans-unit id="892d5a8616ddf159523b449a487e6243305ef9c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; function combines &lt;code&gt;&lt;a href=&quot;system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-io#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; объединяет &lt;code&gt;&lt;a href=&quot;system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f01cd96e2bf006a175917ef728b5ef21ad4ad33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; function establishes a handler that receives any &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; raised in the action protected by &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; is caught by the most recent handler established by one of the exception handling functions. These handlers are not selective: all &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s are caught. Exception propagation must be explicitly provided in a handler by re-raising any unwanted exceptions. For example, in</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; функция устанавливает обработчик , который получает любой &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; поднятым в действии , защищенное &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; поймана сам последним обработчик , установленного одним из обработки исключений функций. Эти обработчики не избирательны: перехватываются все &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; . Распространение исключения должно быть явно указано в обработчике путем повторного создания любых нежелательных исключений. Например, в</target>
        </trans-unit>
        <trans-unit id="8e2935b648dbc65061463e0e0bc3ae9bc38731b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:clearEnv&quot;&gt;clearEnv&lt;/a&gt;&lt;/code&gt; function clears the environment of all name-value pairs.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-posix-env#v:clearEnv&quot;&gt;clearEnv&lt;/a&gt;&lt;/code&gt; очищает среду от всех пар имя-значение.</target>
        </trans-unit>
        <trans-unit id="369194824dad3c17becd69feafce80094511a779" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; function inserts or resets the environment variable name in the current environment list. If the variable &lt;code&gt;name&lt;/code&gt; does not exist in the list, it is inserted with the given value. If the variable does exist, the argument &lt;code&gt;overwrite&lt;/code&gt; is tested; if &lt;code&gt;overwrite&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the variable is not reset, otherwise it is reset to the given value.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-posix-env#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; вставляет или сбрасывает имя переменной среды в текущий список среды. Если &lt;code&gt;name&lt;/code&gt; переменной не существует в списке, оно вставляется с заданным значением. Если переменная действительно существует, проверяется &lt;code&gt;overwrite&lt;/code&gt; аргумента ; если &lt;code&gt;overwrite&lt;/code&gt; - &lt;code&gt;False&lt;/code&gt; , переменная не сбрасывается, в противном случае она сбрасывается до заданного значения.</target>
        </trans-unit>
        <trans-unit id="e16fdd3c2060c8b0e7dcb0de6c67a978ff67d1fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; function deletes all instances of the variable name from the environment.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-posix-env#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; удаляет все экземпляры имени переменной из среды.</target>
        </trans-unit>
        <trans-unit id="6390faf5740aef6b3fe69f665e1639661b490c68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; function inserts or resets the environment variable name in the current environment list. If the variable &lt;code&gt;name&lt;/code&gt; does not exist in the list, it is inserted with the given value. If the variable does exist, the argument &lt;code&gt;overwrite&lt;/code&gt; is tested; if &lt;code&gt;overwrite&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the variable is not reset, otherwise it is reset to the given value.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; вставляет или сбрасывает имя переменной среды в текущий список среды. Если &lt;code&gt;name&lt;/code&gt; переменной не существует в списке, оно вставляется с заданным значением. Если переменная действительно существует, проверяется &lt;code&gt;overwrite&lt;/code&gt; аргумента ; если &lt;code&gt;overwrite&lt;/code&gt; - &lt;code&gt;False&lt;/code&gt; , переменная не сбрасывается, в противном случае она сбрасывается до заданного значения.</target>
        </trans-unit>
        <trans-unit id="908e9623e5b8e5381ae3293c89d2d6a40a5a4714" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; function deletes all instances of the variable name from the environment.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; удаляет все экземпляры имени переменной из среды.</target>
        </trans-unit>
        <trans-unit id="236f78121c4a2f2bf7b4a76db19e5a7170bc2449" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-io#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; function creates a pair of connected file descriptors. The first component is the fd to read from, the second is the write end. Although pipes may be bidirectional, this behaviour is not portable and programmers should use two separate pipes for this purpose. May throw an exception if this is an invalid descriptor.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-posix-io#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; создает пару связанных файловых дескрипторов. Первый компонент - это fd для чтения, второй - конец записи. Хотя каналы могут быть двунаправленными, такое поведение непереносимо, и программисты должны использовать для этой цели два отдельных канала. Может вызвать исключение, если это недопустимый дескриптор.</target>
        </trans-unit>
        <trans-unit id="d4b473f0667d5a6b55f733ab3a3194586555807c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; function creates a pair of connected file descriptors. The first component is the fd to read from, the second is the write end. Although pipes may be bidirectional, this behaviour is not portable and programmers should use two separate pipes for this purpose. May throw an exception if this is an invalid descriptor.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; создает пару связанных файловых дескрипторов. Первый компонент - это fd для чтения, второй - конец записи. Хотя каналы могут быть двунаправленными, такое поведение непереносимо, и программисты должны использовать для этой цели два отдельных канала. Может вызвать исключение, если это недопустимый дескриптор.</target>
        </trans-unit>
        <trans-unit id="50694ec6aab0913f0db1bc83f6e0ed0aed5dd7e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-printf#t:HPrintfType&quot;&gt;HPrintfType&lt;/a&gt;&lt;/code&gt; class provides the variable argument magic for &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;. Its implementation is intentionally not visible from this module.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;text-printf#t:HPrintfType&quot;&gt;HPrintfType&lt;/a&gt;&lt;/code&gt; предоставляет магию переменных аргументов для &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; . Его реализация намеренно не видна из этого модуля.</target>
        </trans-unit>
        <trans-unit id="290847fe4ef7b4c780f17cc14317e4a804018f65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; class provides the variable argument magic for &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;. Its implementation is intentionally not visible from this module. If you attempt to pass an argument of a type which is not an instance of this class to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;, then the compiler will report it as a missing instance of &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; предоставляет магию переменных аргументов для &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; . Его реализация намеренно не видна из этого модуля. Если вы попытаетесь передать аргумент типа, который не является экземпляром этого класса, в &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; , то компилятор сообщит об этом как об отсутствующем экземпляре &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bde3b6deb5751130f8fa9aed7708139a05904e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; считывает одну лексему из ввода, отбрасывая начальные пробелы и возвращая символы, составляющие лексему. Если входная строка содержит только пробелы, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; возвращает единственную успешную `лексему ', состоящую из пустой строки. (Таким образом, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt; .) Если в начале входной строки нет допустимой лексемы, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; не работает (т.е. возвращает &lt;code&gt;[]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1a9d5cf956b4aeb4977bd49b0f7c6321ffb9b927" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function reads input from a string, which must be completely consumed by the input process. &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; fails with an &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the parse is unsuccessful, and it is therefore discouraged from being used in real applications. Use &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; for safe alternatives.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; считывает ввод из строки, которая должна быть полностью использована процессом ввода. &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; завершается неудачно с &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; если синтаксический анализ не удался, и поэтому не рекомендуется использовать его в реальных приложениях. Используйте &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; для безопасных альтернатив.</target>
        </trans-unit>
        <trans-unit id="7c81f5117934d868bf2254238529c0a48b7fea08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;em&gt;k&lt;/em&gt;&lt;/code&gt; argument controls how many test rounds are performed for determining a &lt;em&gt;probable prime&lt;/em&gt;. For more details, see &lt;a href=&quot;http://gmplib.org/manual/Number-Theoretic-Functions.html#index-mpz_005fprobab_005fprime_005fp-360&quot;&gt;GMP documentation for `mpz_probab_prime_p()`&lt;/a&gt;.</source>
          <target state="translated">В &lt;code&gt;&lt;em&gt;k&lt;/em&gt;&lt;/code&gt; контролирует аргумент , сколько тестовых раундов выполняются для определения &lt;em&gt;вероятного премьера&lt;/em&gt; . Дополнительные сведения см. В &lt;a href=&quot;http://gmplib.org/manual/Number-Theoretic-Functions.html#index-mpz_005fprobab_005fprime_005fp-360&quot;&gt;документации GMP для mpz_probab_prime_p ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bad337d10fc64d5b2ff3dbc6f2bf484df6cb613c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BigNat&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;BigNat&lt;/code&gt; типа</target>
        </trans-unit>
        <trans-unit id="b24b400b6bb089abd37b81edfb22c9c44a5b28fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Bits&lt;/code&gt; class does not have a &lt;code&gt;Num&lt;/code&gt; superclass. It therefore does not have default methods for the &lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;testBit&lt;/code&gt; and &lt;code&gt;popCount&lt;/code&gt; methods.</source>
          <target state="translated">Класс &lt;code&gt;Bits&lt;/code&gt; не имеет суперкласса &lt;code&gt;Num&lt;/code&gt; . Поэтому у него нет методов по умолчанию для методов &lt;code&gt;bit&lt;/code&gt; , &lt;code&gt;testBit&lt;/code&gt; и &lt;code&gt;popCount&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7585bf1c302df16ed91051c8a55f49dac7f27c55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ByteString&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;ByteString&lt;/code&gt; типа</target>
        </trans-unit>
        <trans-unit id="a4cb78819e2dcf3b038b0fa6fa29d124f961d0aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ByteString&lt;/code&gt; type and representation</source>
          <target state="translated">&lt;code&gt;ByteString&lt;/code&gt; типа и представление</target>
        </trans-unit>
        <trans-unit id="005e2bda030ee8e32664f998432e3befbee14062" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CApiFFI&lt;/code&gt; extension allows a calling convention of &lt;code&gt;capi&lt;/code&gt; to be used in foreign declarations, e.g.</source>
          <target state="translated">Расширение &lt;code&gt;CApiFFI&lt;/code&gt; позволяет использовать соглашение о вызовах &lt;code&gt;capi&lt;/code&gt; во внешних объявлениях, например</target>
        </trans-unit>
        <trans-unit id="13b7284405381c1e383cd0d0249cafb8eb623b0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COMPLETE&lt;/code&gt; pragma is used to inform the pattern match checker that a certain set of patterns is complete and that any function which matches on all the specified patterns is total.</source>
          <target state="translated">&lt;code&gt;COMPLETE&lt;/code&gt; прагма используется для информирования проверки соответствия шаблона, определенный набор шаблонов является полным , и что любая функция , которая соответствует по всем заданным шаблонам тотально.</target>
        </trans-unit>
        <trans-unit id="97ba5a1df665f08e5746afd5258e9f9bc0483c65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CallStack&lt;/code&gt; will only extend as far as the types allow it, for example</source>
          <target state="translated">&lt;code&gt;CallStack&lt;/code&gt; будет только распространяться, насколько типы позволяют, например ,</target>
        </trans-unit>
        <trans-unit id="b22faafc676f89394f33e91663ca60cabb6bc4b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Chan&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Chan&lt;/code&gt; типа</target>
        </trans-unit>
        <trans-unit id="56868895505567b8dd6fa6c19b6bf5118c82d7d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DOCTYPE&lt;/code&gt; for XHTML 1.0 Strict.</source>
          <target state="translated">&lt;code&gt;DOCTYPE&lt;/code&gt; для XHTML 1.0 Strict.</target>
        </trans-unit>
        <trans-unit id="ffc2f173105c8fb1fcbdf98a1d298ce5e8bba858" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dynamic&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Dynamic&lt;/code&gt; тип</target>
        </trans-unit>
        <trans-unit id="2f473b66e396d89af61f465962bc064a789e33d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorT&lt;/code&gt; Monad structure is parameterized over two things:</source>
          <target state="translated">Структура &lt;code&gt;ErrorT&lt;/code&gt; Monad параметризуется по двум параметрам:</target>
        </trans-unit>
        <trans-unit id="f105cba62162d63271c49af7cd9cd8361ee2895b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FOO.hp&lt;/code&gt; file produced when you ask for the heap profile of a program &lt;code&gt;FOO&lt;/code&gt; is a text file with a particularly simple structure. Here&amp;rsquo;s a representative example, with much of the actual data omitted:</source>
          <target state="translated">&lt;code&gt;FOO.hp&lt;/code&gt; файл , созданный при запросе профиля кучного программного &lt;code&gt;FOO&lt;/code&gt; представляет собой текстовый файл с особенно простой структурой. Вот типичный пример, в котором большая часть фактических данных опущена:</target>
        </trans-unit>
        <trans-unit id="48feef81fcfb630b464ad6ce416e6ee040c4f208" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foo @k a = a&lt;/code&gt; equation would be represented as follows:</source>
          <target state="translated">Уравнение &lt;code&gt;Foo @k a = a&lt;/code&gt; можно представить следующим образом:</target>
        </trans-unit>
        <trans-unit id="c992f175532ed7a0887c33f484f4c4856a6f5c50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foo_stub.h&lt;/code&gt; file can be redirected using the &lt;code&gt;-stubdir&lt;/code&gt; option; see &lt;a href=&quot;separate_compilation#options-output&quot;&gt;Redirecting the compilation output(s)&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Foo_stub.h&lt;/code&gt; файл может быть перенаправлен с помощью &lt;code&gt;-stubdir&lt;/code&gt; опции; см. &lt;a href=&quot;separate_compilation#options-output&quot;&gt;Перенаправление выходных данных компиляции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc9f316a3a267a4b9984d1222e0ad9feb74bf869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; environment variable may be set to a &lt;code&gt;:&lt;/code&gt;-separated (&lt;code&gt;;&lt;/code&gt;-separated on Windows) list of files containing package databases. This list of package databases, used by GHC and ghc-pkg, specifies a stack of package databases from top to bottom. This order was chosen to match the behaviour of the &lt;code id=&quot;index-5&quot;&gt;PATH&lt;/code&gt; environment variable where entries earlier in the PATH override ones that come later. See &lt;a href=&quot;#package-databases&quot;&gt;Package Databases&lt;/a&gt; for details on how the package database stack is used.</source>
          <target state="translated">&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; переменная окружения может быть установлен на &lt;code&gt;:&lt;/code&gt; -разделенное ( &lt;code&gt;;&lt;/code&gt; -разделенное на Windows) список файлов , содержащих базы данных пакетов. Этот список баз данных пакетов, используемый GHC и ghc-pkg, определяет стек баз данных пакетов сверху вниз. Этот порядок был выбран для соответствия поведению &lt;code id=&quot;index-5&quot;&gt;PATH&lt;/code&gt; среды PATH, где предыдущие записи в PATH переопределяют те, которые поступают позже. См. В разделе &lt;a href=&quot;#package-databases&quot;&gt;Базы данных пакетов&lt;/a&gt; подробные сведения об использовании стека базы данных пакетов.</target>
        </trans-unit>
        <trans-unit id="f21fc75056d50350516dd52ff5912c872b8b9460" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GenLanguageDef&lt;/code&gt; type is a record that contains all parameterizable features of the &lt;a href=&quot;text-parsec-token&quot;&gt;Text.Parsec.Token&lt;/a&gt; module. The module &lt;a href=&quot;text-parsec-language&quot;&gt;Text.Parsec.Language&lt;/a&gt; contains some default definitions.</source>
          <target state="translated">Тип &lt;code&gt;GenLanguageDef&lt;/code&gt; - это запись, содержащая все параметризуемые функции модуля &lt;a href=&quot;text-parsec-token&quot;&gt;Text.Parsec.Token&lt;/a&gt; . Модуль &lt;a href=&quot;text-parsec-language&quot;&gt;Text.Parsec.Language&lt;/a&gt; содержит некоторые определения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="c4e050756130eeb11c58b31896ace2ae245341ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Generic1&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;Generic1&lt;/code&gt; класс</target>
        </trans-unit>
        <trans-unit id="b121f20d20404180364bfd43491c63f4245f97f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Generic&lt;/code&gt; and &lt;code&gt;Generic1&lt;/code&gt; classes mediate between user-defined datatypes and their internal representation as a sum-of-products:</source>
          <target state="translated">В &lt;code&gt;Generic&lt;/code&gt; и &lt;code&gt;Generic1&lt;/code&gt; классов посредничать между определенным пользователем типами данными и их внутренним представлением в виде сумм из продуктов:</target>
        </trans-unit>
        <trans-unit id="7c04d22bf6198b566fefab29ee20c196be128ca5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HSfoo.o&lt;/code&gt; file is built by Cabal automatically; use &lt;code&gt;--disable-library-for-ghci&lt;/code&gt; to disable it. To build one manually, the following GNU &lt;code&gt;ld&lt;/code&gt; command can be used:</source>
          <target state="translated">&lt;code&gt;HSfoo.o&lt;/code&gt; файл построен заговорщиков автоматически; используйте &lt;code&gt;--disable-library-for-ghci&lt;/code&gt; , чтобы отключить его. Чтобы создать его вручную, можно использовать следующую команду GNU &lt;code&gt;ld&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4504a638df2b2b4639ba03e3b6d8a72cdcb6adda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INCLUDE&lt;/code&gt; used to be necessary for specifying header files to be included when using the FFI and compiling via C. It is no longer required for GHC, but is accepted (and ignored) for compatibility with other compilers.</source>
          <target state="translated">&lt;code&gt;INCLUDE&lt;/code&gt; раньше необходимо для указания файлов заголовков , которые будут включены при использовании FFI и не компиляции через C. Это больше не требуется для GHC, но принимается (и игнорируется) для совместимости с другими компиляторами.</target>
        </trans-unit>
        <trans-unit id="7e15878bd48bab3818efd590996e87053049c312" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INLINABLE&lt;/code&gt; pragma also works with &lt;code&gt;SPECIALISE&lt;/code&gt;: if you mark function &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;INLINABLE&lt;/code&gt;, then you can subsequently &lt;code&gt;SPECIALISE&lt;/code&gt; in another module (see &lt;a href=&quot;#specialize-pragma&quot;&gt;SPECIALIZE pragma&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;INLINABLE&lt;/code&gt; Прагма также работает с &lt;code&gt;SPECIALISE&lt;/code&gt; : если пометить функцию &lt;code&gt;f&lt;/code&gt; как &lt;code&gt;INLINABLE&lt;/code&gt; , то вы можете впоследствии &lt;code&gt;SPECIALISE&lt;/code&gt; в другом модуле (см &lt;a href=&quot;#specialize-pragma&quot;&gt;специализироваться Прагма&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="011dae688b0bf1afe030126194f5bf145fe1f133" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Int&lt;/code&gt; may well fix &lt;code&gt;b&lt;/code&gt; at the call site, so that signature should not be rejected. Moreover, the dependencies might be hidden. Consider</source>
          <target state="translated">&lt;code&gt;Int&lt;/code&gt; также может зафиксировать &lt;code&gt;b&lt;/code&gt; на месте вызова, так что подпись не должна быть отклонена. Более того, зависимости могут быть скрыты. Рассматривать</target>
        </trans-unit>
        <trans-unit id="be48930496202a998883fb4cafb1527204c88628" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Integer&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Integer&lt;/code&gt; тип</target>
        </trans-unit>
        <trans-unit id="fd53ccf97b4fdfd6c001e2465d556a7f859dcf35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IsList&lt;/code&gt; class and its methods are intended to be used in conjunction with the &lt;code&gt;OverloadedLists&lt;/code&gt; extension.</source>
          <target state="translated">Класс &lt;code&gt;IsList&lt;/code&gt; и его методы предназначены для использования вместе с расширением &lt;code&gt;OverloadedLists&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8673f7079a0b5c433c928ec58cc5f380461b598a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ix&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;Ix&lt;/code&gt; класс</target>
        </trans-unit>
        <trans-unit id="ef3790360f91e6f1db9d6be90c644fd246da75d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ix&lt;/code&gt; class and operations</source>
          <target state="translated">Класс &lt;code&gt;Ix&lt;/code&gt; и операции</target>
        </trans-unit>
        <trans-unit id="10c3ff8e25753aa68617bfab48822621de668249" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Just Refl&lt;/code&gt; case in &lt;code&gt;step2&lt;/code&gt; is inaccessible, because in order for &lt;code&gt;checkTEQ&lt;/code&gt; to be able to produce a &lt;code&gt;Just&lt;/code&gt;, &lt;code&gt;t ~ u&lt;/code&gt; must hold, but since we&amp;rsquo;re passing &lt;code&gt;Foo1&lt;/code&gt; and &lt;code&gt;Foo2&lt;/code&gt; here, it follows that &lt;code&gt;t ~
Char&lt;/code&gt;, and &lt;code&gt;u ~ Int&lt;/code&gt;, and thus &lt;code&gt;t ~ u&lt;/code&gt; cannot hold.</source>
          <target state="translated">&lt;code&gt;Just Refl&lt;/code&gt; случай &lt;code&gt;step2&lt;/code&gt; недоступен, потому что для того , чтобы &lt;code&gt;checkTEQ&lt;/code&gt; , чтобы иметь возможность производить &lt;code&gt;Just&lt;/code&gt; , &lt;code&gt;t ~ u&lt;/code&gt; должно выполняться, но так как мы проходим &lt;code&gt;Foo1&lt;/code&gt; и &lt;code&gt;Foo2&lt;/code&gt; здесь, отсюда следует , что &lt;code&gt;t ~ Char&lt;/code&gt; , а &lt;code&gt;u ~ Int&lt;/code&gt; , а значит, &lt;code&gt;t ~ u&lt;/code&gt; не может иметь места.</target>
        </trans-unit>
        <trans-unit id="50553a5059a245db41faab2319d240eba523fc59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LANGUAGE&lt;/code&gt; pragma allows language extensions to be enabled in a portable way. It is the intention that all Haskell compilers support the &lt;code&gt;LANGUAGE&lt;/code&gt; pragma with the same syntax, although not all extensions are supported by all compilers, of course. The &lt;code&gt;LANGUAGE&lt;/code&gt; pragma should be used instead of &lt;code&gt;OPTIONS_GHC&lt;/code&gt;, if possible.</source>
          <target state="translated">&lt;code&gt;LANGUAGE&lt;/code&gt; Прагма позволяет расширения языка должны быть включены в переносимом способе. Предполагается, что все компиляторы Haskell поддерживают прагму &lt;code&gt;LANGUAGE&lt;/code&gt; с одинаковым синтаксисом, хотя, конечно, не все расширения поддерживаются всеми компиляторами. По возможности следует использовать &lt;code&gt;OPTIONS_GHC&lt;/code&gt; &lt;code&gt;LANGUAGE&lt;/code&gt; вместо OPTIONS_GHC .</target>
        </trans-unit>
        <trans-unit id="9db793d0713d9096493ec702152818be66ee6bd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MArray&lt;/code&gt; class is parameterised over both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt; (so that instances specialised to certain element types can be defined, in the same way as for &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt;), and also over the type of the monad, &lt;code&gt;m&lt;/code&gt;, in which the mutable array will be manipulated.</source>
          <target state="translated">Класс &lt;code&gt;MArray&lt;/code&gt; параметризован как для &lt;code&gt;a&lt;/code&gt; ,так и для &lt;code&gt;e&lt;/code&gt; (так что экземпляры, специализированные для определенных типов элементов, могут быть определены таким же образом, как и для &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; ), а также для типа монады &lt;code&gt;m&lt;/code&gt; , в которой изменяемый массив будет манипулируют.</target>
        </trans-unit>
        <trans-unit id="d9cb8377e96ef4f0bbbfa46420220ebcc273c902" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MINIMAL&lt;/code&gt; pragma can be used to change which combination of methods will be required for instances of a particular class. See &lt;a href=&quot;glasgow_exts#minimal-pragma&quot;&gt;MINIMAL pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;MINIMAL&lt;/code&gt; прагма может быть использована для изменения , которые будут необходимы сочетание методов для экземпляров конкретного класса. См. &lt;a href=&quot;glasgow_exts#minimal-pragma&quot;&gt;Прагму MINIMAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b804211dca7a6234cc53da8eb6f7ab49bdfebd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MINIMAL&lt;/code&gt; pragma is used to specify the minimal complete definition of a class, i.e. specify which methods must be implemented by all instances. If an instance does not satisfy the minimal complete definition, then a warning is generated. This can be useful when a class has methods with circular defaults. For example</source>
          <target state="translated">&lt;code&gt;MINIMAL&lt;/code&gt; Прагма используется для указания минимального полного определения класса, то есть определить , какие методы должны быть реализованы во всех случаях. Если экземпляр не удовлетворяет минимальному полному определению, генерируется предупреждение. Это может быть полезно, когда в классе есть методы с циклическими значениями по умолчанию. Например</target>
        </trans-unit>
        <trans-unit id="179c9366f2492e385b72cb143e85887902e0ab4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Maybe Dec&lt;/code&gt; field contains &lt;code&gt;Just&lt;/code&gt; the declaration which defined the variable - including the RHS of the declaration - or else &lt;code&gt;Nothing&lt;/code&gt;, in the case where the RHS is unavailable to the compiler. At present, this value is &lt;em&gt;always&lt;/em&gt;&lt;code&gt;Nothing&lt;/code&gt;: returning the RHS has not yet been implemented because of lack of interest.</source>
          <target state="translated">Поле &lt;code&gt;Maybe Dec&lt;/code&gt; содержит &lt;code&gt;Just&lt;/code&gt; объявление, которое определило переменную, включая RHS объявления, или &lt;code&gt;Nothing&lt;/code&gt; , в случае, если RHS недоступен для компилятора. В настоящее время это значение &lt;em&gt;всегда&lt;/em&gt; равно &lt;code&gt;Nothing&lt;/code&gt; : возврат RHS еще не реализован из-за отсутствия интереса.</target>
        </trans-unit>
        <trans-unit id="833a3a82dcaf236e1a22c42275a11a48d6dd026d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Maybe String&lt;/code&gt; argument allows to supply an optional time specification. E.g.:</source>
          <target state="translated">&lt;code&gt;Maybe String&lt;/code&gt; аргумент позволяет указать необязательное указание времени. Например:</target>
        </trans-unit>
        <trans-unit id="c4cf4ef2ad7be84020f5ab8d962e61d9c5230f48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ModSummary&lt;/code&gt; contains useful meta-information about the compiled module. The &lt;code&gt;HsParsedModule&lt;/code&gt; contains the lexical and syntactical information we mentioned before. The result that you return will change the result of the parsing. If you don&amp;rsquo;t want to change the result, just return the &lt;code&gt;HsParsedModule&lt;/code&gt; that you received as the argument.</source>
          <target state="translated">&lt;code&gt;ModSummary&lt;/code&gt; содержит полезную мета-информацию о скомпилированного модуля. &lt;code&gt;HsParsedModule&lt;/code&gt; содержит лексическую и синтаксическую информацию , которую мы упоминали ранее. Результат, который вы вернете, изменит результат синтаксического анализа. Если вы не хотите изменять результат, просто верните &lt;code&gt;HsParsedModule&lt;/code&gt; , который вы получили в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="c2f1b3a94e8148014127a4f07b1372b7725a7bda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Monad&lt;/code&gt; class has an &lt;code&gt;Applicative&lt;/code&gt; superclass. You cannot write &lt;code&gt;Monad&lt;/code&gt; instances that work for GHC and also for a Haskell 2010 implementation that does not define &lt;code&gt;Applicative&lt;/code&gt;.</source>
          <target state="translated">У класса &lt;code&gt;Monad&lt;/code&gt; есть суперкласс &lt;code&gt;Applicative&lt;/code&gt; . Вы не можете писать экземпляры &lt;code&gt;Monad&lt;/code&gt; , которые работают для GHC, а также для реализации Haskell 2010, которая не определяет &lt;code&gt;Applicative&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9a442b1b9dc364891e0d9b2233f04de798d1ec7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOCLDSTOP&lt;/code&gt; flag</source>
          <target state="translated">&lt;code&gt;NOCLDSTOP&lt;/code&gt; флаг</target>
        </trans-unit>
        <trans-unit id="4dd6a67adca1f0f6b2e2bb5d6f4f6be090147329" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOINLINE&lt;/code&gt; pragma tells GHC not to inline &lt;code&gt;foo&lt;/code&gt; until Phase 0; and this property is inherited by the specialisation RULE, which will therefore only fire in Phase 0.</source>
          <target state="translated">&lt;code&gt;NOINLINE&lt;/code&gt; Прагма говорит GHC не инлайн &lt;code&gt;foo&lt;/code&gt; до фазы 0; и это свойство наследуется специализацией RULE, которая, следовательно, срабатывает только в Фазе 0.</target>
        </trans-unit>
        <trans-unit id="41cd577171aa93daf4a59092425aec6f8da57085" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOUNPACK&lt;/code&gt; pragma indicates to the compiler that it should not unpack the contents of a constructor field. Example:</source>
          <target state="translated">&lt;code&gt;NOUNPACK&lt;/code&gt; прагма указывает компилятору , что он не должен распаковать содержимое поля конструктора. Пример:</target>
        </trans-unit>
        <trans-unit id="02f6d5f3a66723750914b07b17b4152b831881eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Natural&lt;/code&gt; number type</source>
          <target state="translated">Тип &lt;code&gt;Natural&lt;/code&gt; числа</target>
        </trans-unit>
        <trans-unit id="e90151e467bb879239604777d1625aec0d519783" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Num&lt;/code&gt; class does not have &lt;code&gt;Show&lt;/code&gt; or &lt;code&gt;Eq&lt;/code&gt; superclasses.</source>
          <target state="translated">Класс &lt;code&gt;Num&lt;/code&gt; не имеет суперклассов &lt;code&gt;Show&lt;/code&gt; или &lt;code&gt;Eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="126dfab84b0966c6acff2a80c6f25e8566d4c2cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma is used to specify additional options that are given to the compiler when compiling this source file. See &lt;a href=&quot;using#source-file-options&quot;&gt;Command line options in source files&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;OPTIONS_GHC&lt;/code&gt; Прагма используется для указания дополнительных опций, которые даются компилятором при компиляции этого исходного файла. Подробнее см. &lt;a href=&quot;using#source-file-options&quot;&gt;Параметры командной строки в исходных файлах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88a0fae3e171286c99c8569a8b07482329213991" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Plugin&lt;/code&gt; type has a field &lt;code&gt;tcPlugin&lt;/code&gt; of type &lt;code&gt;[CommandLineOption] -&amp;gt; Maybe TcPlugin&lt;/code&gt;, where the &lt;code&gt;TcPlugin&lt;/code&gt; type is defined thus:</source>
          <target state="translated">Тип &lt;code&gt;Plugin&lt;/code&gt; имеет поле &lt;code&gt;tcPlugin&lt;/code&gt; типа &lt;code&gt;[CommandLineOption] -&amp;gt; Maybe TcPlugin&lt;/code&gt; , где тип &lt;code&gt;TcPlugin&lt;/code&gt; определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="fffe76b7bf3798c24838442d37709754d1c21fba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PluginRecompile&lt;/code&gt; data type is an enumeration determining how the plugin should affect recompilation.</source>
          <target state="translated">&lt;code&gt;PluginRecompile&lt;/code&gt; типа данных является перечислением определения того, как плагин должен влиять перекомпиляции.</target>
        </trans-unit>
        <trans-unit id="e585b3f2d187dee43075f1c6379003eb2f833f55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pointer&lt;/code&gt; field is not used when tag says that it&amp;rsquo;s &lt;code&gt;Nothing&lt;/code&gt;. Otherwise &lt;code&gt;Pointer&lt;/code&gt; points to the value in &lt;code&gt;Just&lt;/code&gt;. As mentioned above, this type is lazy in its lifted field. Therefore, the type</source>
          <target state="translated">Поле &lt;code&gt;Pointer&lt;/code&gt; не используется, если тег говорит, что это &lt;code&gt;Nothing&lt;/code&gt; . В противном случае &lt;code&gt;Pointer&lt;/code&gt; указывает на значение в &lt;code&gt;Just&lt;/code&gt; . Как упоминалось выше, этот тип ленив в своей поднятой области. Следовательно, тип</target>
        </trans-unit>
        <trans-unit id="eb221db19183a2bbc482de37382d307415cceaa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; класс</target>
        </trans-unit>
        <trans-unit id="c684523d6c7922654f7664f2f15207a387ba8fbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class has two extra methods, &lt;code&gt;readPrec&lt;/code&gt; and &lt;code&gt;readListPrec&lt;/code&gt;, that are not found in the Haskell 2010 since they rely on the &lt;code&gt;ReadPrec&lt;/code&gt; data type, which requires the &lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt;&lt;code&gt;-XRankNTypes&lt;/code&gt;&lt;/a&gt; extension. GHC also derives &lt;code&gt;Read&lt;/code&gt; instances by implementing &lt;code&gt;readPrec&lt;/code&gt; instead of &lt;code&gt;readsPrec&lt;/code&gt;, and relies on a default implementation of &lt;code&gt;readsPrec&lt;/code&gt; that is defined in terms of &lt;code&gt;readPrec&lt;/code&gt;. GHC adds these two extra methods simply because &lt;code&gt;ReadPrec&lt;/code&gt; is more efficient than &lt;code&gt;ReadS&lt;/code&gt; (the type on which &lt;code&gt;readsPrec&lt;/code&gt; is based).</source>
          <target state="translated">В классе &lt;code&gt;Read&lt;/code&gt; есть два дополнительных метода, &lt;code&gt;readPrec&lt;/code&gt; и &lt;code&gt;readListPrec&lt;/code&gt; , которых нет в Haskell 2010, поскольку они полагаются на &lt;code&gt;ReadPrec&lt;/code&gt; данных ReadPrec , для которого требуется расширение &lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt; &lt;code&gt;-XRankNTypes&lt;/code&gt; &lt;/a&gt; . GHC также получает экземпляры &lt;code&gt;Read&lt;/code&gt; , реализуя &lt;code&gt;readPrec&lt;/code&gt; вместо &lt;code&gt;readsPrec&lt;/code&gt; , и полагается на реализацию &lt;code&gt;readsPrec&lt;/code&gt; по умолчанию, которая определена в терминах &lt;code&gt;readPrec&lt;/code&gt; . GHC добавляет эти два дополнительных метода просто потому, что &lt;code&gt;ReadPrec&lt;/code&gt; более эффективен, чем &lt;code&gt;ReadS&lt;/code&gt; (тип, на котором основан &lt;code&gt;readsPrec&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f5a639306682ee2392defbfaca8a0612ce62725a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReadP&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;ReadP&lt;/code&gt; типа</target>
        </trans-unit>
        <trans-unit id="55f87a9866a170596d8c12e14883de0375635cbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reader&lt;/code&gt; monad (also called the Environment monad). Represents a computation, which can read values from a shared environment, pass values from function to function, and execute sub-computations in a modified environment. Using &lt;code&gt;Reader&lt;/code&gt; monad for such computations is often clearer and easier than using the &lt;code&gt;&lt;a href=&quot;control-monad-state#v:State&quot;&gt;State&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;Reader&lt;/code&gt; монада (также называется монадой Environment). Представляет вычисление, которое может считывать значения из общей среды, передавать значения от функции к функции и выполнять подвычисления в измененной среде. Использование монады &lt;code&gt;Reader&lt;/code&gt; для таких вычислений часто проще и понятнее, чем использование монады &lt;code&gt;&lt;a href=&quot;control-monad-state#v:State&quot;&gt;State&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="138e28c8c2a47ed6154d76f22441ec8c21841137" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;R{..}&lt;/code&gt; expands to &lt;code&gt;R{a=a}&lt;/code&gt;, omitting &lt;code&gt;b&lt;/code&gt; since the record field is not in scope, and omitting &lt;code&gt;c&lt;/code&gt; since the variable &lt;code&gt;c&lt;/code&gt; is not in scope (apart from the binding of the record selector &lt;code&gt;c&lt;/code&gt;, of course).</source>
          <target state="translated">&lt;code&gt;R{..}&lt;/code&gt; расширяется до &lt;code&gt;R{a=a}&lt;/code&gt; , опуская &lt;code&gt;b&lt;/code&gt; , так как поле записи не находится в области видимости, и опуская &lt;code&gt;c&lt;/code&gt; , так как переменная &lt;code&gt;c&lt;/code&gt; не находится в области действия (помимо связывания записи селектора &lt;code&gt;c&lt;/code&gt; , конечно ).</target>
        </trans-unit>
        <trans-unit id="c6082bbc59601d9a449fcc7ad9a4d5ed12a91d6c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SPARKS&lt;/code&gt; statistic refers to the use of &lt;code&gt;Control.Parallel.par&lt;/code&gt; and related functionality in the program. Each spark represents a call to &lt;code&gt;par&lt;/code&gt;; a spark is &amp;ldquo;converted&amp;rdquo; when it is executed in parallel; and a spark is &amp;ldquo;pruned&amp;rdquo; when it is found to be already evaluated and is discarded from the pool by the garbage collector. Any remaining sparks are discarded at the end of execution, so &amp;ldquo;converted&amp;rdquo; plus &amp;ldquo;pruned&amp;rdquo; does not necessarily add up to the total.</source>
          <target state="translated">&lt;code&gt;SPARKS&lt;/code&gt; статистики относится к использованию &lt;code&gt;Control.Parallel.par&lt;/code&gt; и связанной с ними функциональности в программе. Каждая искра представляет собой вызов &lt;code&gt;par&lt;/code&gt; ; искра &amp;laquo;преобразуется&amp;raquo; при параллельном запуске; и искра &amp;laquo;обрезается&amp;raquo;, когда обнаруживается, что она уже оценена, и удаляется из пула сборщиком мусора. Любые оставшиеся искры отбрасываются в конце выполнения, поэтому &amp;laquo;преобразованные&amp;raquo; плюс &amp;laquo;отсеченные&amp;raquo; не обязательно составляют общую сумму.</target>
        </trans-unit>
        <trans-unit id="0739f5ccb2bb880c7aac97c76af83b628f8a3a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ST&lt;/code&gt; Monad</source>
          <target state="translated">&lt;code&gt;ST&lt;/code&gt; Монада</target>
        </trans-unit>
        <trans-unit id="f614e141f7715f6c62aa646fdfcc09ca9d7280e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ST&lt;/code&gt; monad</source>
          <target state="translated">&lt;code&gt;ST&lt;/code&gt; монада</target>
        </trans-unit>
        <trans-unit id="95776d621e6e94b966ba5059c98ab385d9187b77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Semigroup&lt;/code&gt; operator &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; will be in &lt;code&gt;Prelude&lt;/code&gt;, which clashes with custom local definitions of such an operator</source>
          <target state="translated">&lt;code&gt;Semigroup&lt;/code&gt; оператор &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; будет в &lt;code&gt;Prelude&lt;/code&gt; , который столкновения с пользовательским локальными определениями такого оператора</target>
        </trans-unit>
        <trans-unit id="8bd15c25ef057d5bb7b4b11090add4deb0ab7363" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ShortByteString&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;ShortByteString&lt;/code&gt; типа</target>
        </trans-unit>
        <trans-unit id="42f56d1b1cf13cb62004be77c95ea28a2e463b26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ShortByteString&lt;/code&gt; type and representation</source>
          <target state="translated">&lt;code&gt;ShortByteString&lt;/code&gt; тип и представление</target>
        </trans-unit>
        <trans-unit id="9c01c63bcea3f47012ef7cb8b53521ef2f599690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SomeException&lt;/code&gt; type is the root of the exception type hierarchy. When an exception of type &lt;code&gt;e&lt;/code&gt; is thrown, behind the scenes it is encapsulated in a &lt;code&gt;SomeException&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;SomeException&lt;/code&gt; является корнем иерархии типов исключения. Когда генерируется исключение типа &lt;code&gt;e&lt;/code&gt; , за кулисами оно инкапсулируется в &lt;code&gt;SomeException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="075869aa5abeccc3e82651f71cd0b49cf876a1ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StablePtr&lt;/code&gt; is freed by &lt;code&gt;hs_try_putmvar()&lt;/code&gt;. This is because it would otherwise be difficult to arrange to free the &lt;code&gt;StablePtr&lt;/code&gt; reliably: we can&amp;rsquo;t free it in Haskell, because if the &lt;code&gt;takeMVar&lt;/code&gt; is interrupted by an asynchronous exception, then the callback will fire at a later time. We can&amp;rsquo;t free it in C, because we don&amp;rsquo;t know when to free it (not when &lt;code&gt;hs_try_putmvar()&lt;/code&gt; returns, because that is an async call that uses the &lt;code&gt;StablePtr&lt;/code&gt; at some time in the future).</source>
          <target state="translated">&lt;code&gt;StablePtr&lt;/code&gt; освобождается от &lt;code&gt;hs_try_putmvar()&lt;/code&gt; . Это связано с тем, что в противном случае было бы сложно организовать надежное освобождение &lt;code&gt;StablePtr&lt;/code&gt; : мы не можем освободить его в Haskell, потому что, если &lt;code&gt;takeMVar&lt;/code&gt; прерывается асинхронным исключением, обратный вызов сработает позже. Мы не можем освободить его в C, потому что мы не знаем, когда его освободить (не когда возвращается &lt;code&gt;hs_try_putmvar()&lt;/code&gt; , потому что это асинхронный вызов, который использует &lt;code&gt;StablePtr&lt;/code&gt; в какой-то момент в будущем).</target>
        </trans-unit>
        <trans-unit id="22a2fd434898f0f6555b4c40eb04ba5061f4dac5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type and associated operations.</source>
          <target state="translated">Тип &lt;code&gt;String&lt;/code&gt; и связанные с ним операции.</target>
        </trans-unit>
        <trans-unit id="063a241ae6b100332789afebed90ca2f9db07517" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Traversable&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;Traversable&lt;/code&gt; класс</target>
        </trans-unit>
        <trans-unit id="f3eb004bc8ea181740ab9d964eca4039846cba0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tree&lt;/code&gt; datatype has two constructors. The representation of individual constructors is combined using the binary type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип данных &lt;code&gt;Tree&lt;/code&gt; имеет два конструктора. Представление отдельных конструкторов в сочетании с использованием двоичного типа конструктора &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea0e01ff4b10acd1f300e041e7c7d24452a6bcef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Type&lt;/code&gt; field contains the type which underlies the variable. At present, this is always &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt;, but future changes may permit refinement of this.</source>
          <target state="translated">Поле &lt;code&gt;Type&lt;/code&gt; содержит тип, лежащий в основе переменной. В настоящее время это всегда &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt; , но будущие изменения могут позволить уточнить это.</target>
        </trans-unit>
        <trans-unit id="a1c62302915451aa80bfd9fc2cff479b2cf284ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Type&lt;/code&gt; field contains the type which underlies the variable. At present, this is always &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt;, but future changes may permit refinement of this.</source>
          <target state="translated">Поле &lt;code&gt;Type&lt;/code&gt; содержит тип, лежащий в основе переменной. В настоящее время это всегда &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt; , но будущие изменения могут позволить уточнить это.</target>
        </trans-unit>
        <trans-unit id="027d2a06d103d553d051280a74cf3845d60d411a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UNPACK&lt;/code&gt; indicates to the compiler that it should unpack the contents of a constructor field into the constructor itself, removing a level of indirection. For example:</source>
          <target state="translated">&lt;code&gt;UNPACK&lt;/code&gt; указывает компилятору , что он должен распаковать содержимое поля конструктора в самом конструкторе, убирая уровень косвенности. Например:</target>
        </trans-unit>
        <trans-unit id="33782bed5c646b932004c73abe54633b85489d8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Version&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Version&lt;/code&gt; типа</target>
        </trans-unit>
        <trans-unit id="5c935ef40843fda690b92bec23a2da13f0596d70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WARNING&lt;/code&gt; pragma allows you to attach an arbitrary warning to a particular function, class, or type.</source>
          <target state="translated">&lt;code&gt;WARNING&lt;/code&gt; Прагма позволяет присоединять произвольное предупреждение к конкретной функции, класса или типа.</target>
        </trans-unit>
        <trans-unit id="4b5cfd9e9013fd4cb9b04f939f4f7787609c1e73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Weak&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; тип</target>
        </trans-unit>
        <trans-unit id="f5d131550d29246afe295414037eda39ef3a4a79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[2]&lt;/code&gt; means that the rule is active in Phase 2 and subsequent phases. The inverse notation &lt;code&gt;[~2]&lt;/code&gt; is also accepted, meaning that the rule is active up to, but not including, Phase 2.</source>
          <target state="translated">В &lt;code&gt;[2]&lt;/code&gt; означает , что правило действует в фазе 2 и последующих этапах. Обратное обозначение &lt;code&gt;[~2]&lt;/code&gt; также принимается, что означает, что правило действует до Фазы 2, но не включая ее.</target>
        </trans-unit>
        <trans-unit id="e762931e5ccd90930535b3ca5e55c6d8c0924233" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binary&lt;/code&gt; package is notable in that it provides both pure, and high performance serialisation.</source>
          <target state="translated">&lt;code&gt;binary&lt;/code&gt; пакет отличается тем , что она обеспечивает как чисто, и высокая производительность сериализации.</target>
        </trans-unit>
        <trans-unit id="4bd1285d74cbd2d2cbc3ca0932f6094c43b630ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;buildExpressionParser&lt;/code&gt; takes care of all the complexity involved in building expression parser. Here is an example of an expression parser that handles prefix signs, postfix increment and basic arithmetic.</source>
          <target state="translated">&lt;code&gt;buildExpressionParser&lt;/code&gt; берет на себя все сложности , участвующих в построении выражений парсер. Вот пример парсера выражений, который обрабатывает знаки префикса, приращение постфикса и основную арифметику.</target>
        </trans-unit>
        <trans-unit id="9dc6c10898dec30b4e5dd6a9520ac4b310a891ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;catch&lt;/code&gt; functions</source>
          <target state="translated">В &lt;code&gt;catch&lt;/code&gt; функции</target>
        </trans-unit>
        <trans-unit id="ce3c62da909521366f0612be95d0d5abc18fd5df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cr&lt;/code&gt; capability, which moves the cursor to the first column of the current line.</source>
          <target state="translated">Возможность &lt;code&gt;cr&lt;/code&gt; , которая перемещает курсор в первый столбец текущей строки.</target>
        </trans-unit>
        <trans-unit id="41cac9a191aeb661ca1ba5373f54957c5ae0927f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deriving( Sizable )&lt;/code&gt; is equivalent to saying</source>
          <target state="translated">&lt;code&gt;deriving( Sizable )&lt;/code&gt; равносильно тому,</target>
        </trans-unit>
        <trans-unit id="aecea50617c919f429665961c30499dbecafe248" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode&lt;/code&gt; function translates elements of the buffer &lt;code&gt;from&lt;/code&gt; to the buffer &lt;code&gt;to&lt;/code&gt;. It should translate as many elements as possible given the sizes of the buffers, including translating zero elements if there is either not enough room in &lt;code&gt;to&lt;/code&gt;, or &lt;code&gt;from&lt;/code&gt; does not contain a complete multibyte sequence.</source>
          <target state="translated">Функция &lt;code&gt;encode&lt;/code&gt; переводит элементы буфера &lt;code&gt;from&lt;/code&gt; в буфер &lt;code&gt;to&lt;/code&gt; . Он должен перевести как много элементов , как это возможно , учитывая размеры буферов, в том числе перевод нулевых элементов , если есть или не хватает места в &lt;code&gt;to&lt;/code&gt; или &lt;code&gt;from&lt;/code&gt; не содержит полную последовательность многобайтовую.</target>
        </trans-unit>
        <trans-unit id="0a5aa4a69bcc42b7c89b78bde09cb33ccb0cfca5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enumFrom&lt;/code&gt;... methods are used in Haskell's translation of arithmetic sequences.</source>
          <target state="translated">&lt;code&gt;enumFrom&lt;/code&gt; ... методы используются в переводе в Haskell арифметических последовательностей.</target>
        </trans-unit>
        <trans-unit id="ade300f4a813bcee47f07faaadabe78ba37c7979" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; function from the Prelude supports printing the call stack that led to the error in addition to the usual error message:</source>
          <target state="translated">Функция &lt;code&gt;error&lt;/code&gt; из Prelude поддерживает печать стека вызовов, которые привели к ошибке, в дополнение к обычному сообщению об ошибке:</target>
        </trans-unit>
        <trans-unit id="511af374fd1b5b479579f0c30542d54251504918" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;evaluate&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;evaluate&lt;/code&gt; функцию</target>
        </trans-unit>
        <trans-unit id="597cda7e7f16a0e50cd5f0c4f0416902f5c0363f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromInteger&lt;/code&gt; (and hence also &lt;code&gt;fromIntegral&lt;/code&gt;) is a special case when converting to &lt;code&gt;Int&lt;/code&gt;. The value of &lt;code&gt;fromIntegral x :: Int&lt;/code&gt; is given by taking the lower ⟨n⟩ bits of &lt;code&gt;(abs x)&lt;/code&gt;, multiplied by the sign of &lt;code&gt;x&lt;/code&gt; (in 2&amp;rsquo;s complement ⟨n⟩-bit arithmetic). This behaviour was chosen so that for example writing &lt;code&gt;0xffffffff :: Int&lt;/code&gt; preserves the bit-pattern in the resulting &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fromInteger&lt;/code&gt; (а значит , и &lt;code&gt;fromIntegral&lt;/code&gt; ) представляет собой особый случай , когда преобразование в &lt;code&gt;Int&lt;/code&gt; . Значение &lt;code&gt;fromIntegral x :: Int&lt;/code&gt; дается путем умножения младших ⟨n⟩ битов &lt;code&gt;(abs x)&lt;/code&gt; на знак &lt;code&gt;x&lt;/code&gt; (в n⟩-битовой арифметике с дополнением до 2). Это поведение было выбрано таким образом, чтобы, например, запись &lt;code&gt;0xffffffff :: Int&lt;/code&gt; сохраняла битовый шаблон в результирующем &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef0f4a35a1f6d1c258b22e6d87df758fac232791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromIntegral&lt;/code&gt; function also preserves bit-patterns when converting between the sized integral types (&lt;code&gt;Int8&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt; and the unsigned &lt;code&gt;Word&lt;/code&gt; variants), see the modules &lt;code&gt;Data.Int&lt;/code&gt; and &lt;code&gt;Data.Word&lt;/code&gt; in the library documentation.</source>
          <target state="translated">Функция &lt;code&gt;fromIntegral&lt;/code&gt; также сохраняет битовые шаблоны при преобразовании между целочисленными типами размера ( &lt;code&gt;Int8&lt;/code&gt; , &lt;code&gt;Int16&lt;/code&gt; , &lt;code&gt;Int32&lt;/code&gt; , &lt;code&gt;Int64&lt;/code&gt; и варианты &lt;code&gt;Word&lt;/code&gt; без знака ), см. Модули &lt;code&gt;Data.Int&lt;/code&gt; и &lt;code&gt;Data.Word&lt;/code&gt; в документации библиотеки.</target>
        </trans-unit>
        <trans-unit id="762b16a36e554904d87f2db331ab1542095ebd78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghc-pkg&lt;/code&gt; program may be run in the ways listed below. Where a package name is required, the package can be named in full including the version number (e.g. &lt;code&gt;network-1.0&lt;/code&gt;), or without the version number. Naming a package without the version number matches all versions of the package; the specified action will be applied to all the matching packages. A package specifier that matches all version of the package can also be written &lt;code&gt;⟨pkg⟩ -*&lt;/code&gt;, to make it clearer that multiple packages are being matched. To match against the installed package ID instead of just package name and version, pass the &lt;code&gt;--ipid&lt;/code&gt; flag.</source>
          <target state="translated">Программу &lt;code&gt;ghc-pkg&lt;/code&gt; можно запустить перечисленными ниже способами. Если требуется имя пакета, пакет может быть назван полностью, включая номер версии (например, &lt;code&gt;network-1.0&lt;/code&gt; ), или без номера версии. Название пакета без номера версии соответствует всем версиям пакета; указанное действие будет применено ко всем подходящим пакетам. &lt;code&gt;⟨pkg⟩ -*&lt;/code&gt; пакета, который соответствует всем версиям пакета, также можно записать как &amp;laquo; pkg&amp;raquo; - * , чтобы было понятнее, что сопоставляются несколько пакетов. Чтобы соответствовать идентификатору установленного пакета, а не только имени и версии пакета, &lt;code&gt;--ipid&lt;/code&gt; флаг --ipid .</target>
        </trans-unit>
        <trans-unit id="70e170de84746b93a247accd0e8bc402d6a2ea08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghc&lt;/code&gt; package exposes most of GHC&amp;rsquo;s frontend to users, and thus allows you to write programs that leverage it. This library is actually the same library used by GHC&amp;rsquo;s internal, frontend compilation driver, and thus allows you to write tools that programmatically compile source code and inspect it. Such functionality is useful in order to write things like IDE or refactoring tools. As a simple example, here&amp;rsquo;s a program which compiles a module, much like ghc itself does by default when invoked:</source>
          <target state="translated">Пакет &lt;code&gt;ghc&lt;/code&gt; предоставляет пользователям большую часть интерфейса GHC и, таким образом, позволяет вам писать программы, использующие его. Эта библиотека на самом деле является той же самой библиотекой, которая используется внутренним драйвером компиляции внешнего интерфейса GHC, и, таким образом, позволяет вам писать инструменты, которые программно компилируют исходный код и проверяют его. Такая функциональность полезна для написания таких вещей, как IDE или инструменты рефакторинга. В качестве простого примера, вот программа, которая компилирует модуль, как и сам ghc по умолчанию при вызове:</target>
        </trans-unit>
        <trans-unit id="e102bed194230593a0e69925d95b61dfc6e1bb63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghci.conf&lt;/code&gt; file is most useful for turning on favourite options (e.g. &lt;code&gt;:set +s&lt;/code&gt;), and defining useful macros.</source>
          <target state="translated">&lt;code&gt;ghci.conf&lt;/code&gt; файл является наиболее полезным для включения любимых вариантов (например &lt;code&gt;:set +s&lt;/code&gt; ), и определения полезных макросов.</target>
        </trans-unit>
        <trans-unit id="2d742d7f4cd29eb0f301c0d47b2cc254469da39b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;handle&lt;/code&gt; functions</source>
          <target state="translated">В &lt;code&gt;handle&lt;/code&gt; функции</target>
        </trans-unit>
        <trans-unit id="34d765516635c10fcdf110fa543c8ace7e8ff1fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hi-boot&lt;/code&gt; generated by compiling a &lt;code&gt;hs-boot&lt;/code&gt; file is in the same machine-generated binary format as any other GHC-generated interface file (e.g. &lt;code&gt;B.hi&lt;/code&gt;). You can display its contents with &lt;code&gt;ghc --show-iface&lt;/code&gt;. If you specify a directory for interface files, the &lt;code&gt;-ohidir&lt;/code&gt; flag, then that affects &lt;code&gt;hi-boot&lt;/code&gt; files too.</source>
          <target state="translated">&lt;code&gt;hi-boot&lt;/code&gt; генерируется путем составления &lt;code&gt;hs-boot&lt;/code&gt; файл находится в той же машине сгенерированных двоичном формате , как и любой другой GHC сгенерированный файл интерфейса (например , &lt;code&gt;B.hi&lt;/code&gt; ). Вы можете отобразить его содержимое с помощью &lt;code&gt;ghc --show-iface&lt;/code&gt; . Если вы укажете каталог для файлов интерфейса, флаг &lt;code&gt;-ohidir&lt;/code&gt; , то это также повлияет на файлы &lt;code&gt;hi-boot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="355d829a4b676f5ca653b94b80c9807cda2a9d2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hsc2hs&lt;/code&gt; command can be used to automate some parts of the process of writing Haskell bindings to C code. It reads an almost-Haskell source with embedded special constructs, and outputs a real Haskell file with these constructs processed, based on information taken from some C headers. The extra constructs deal with accessing C data from Haskell.</source>
          <target state="translated">&lt;code&gt;hsc2hs&lt;/code&gt; команда может быть использована для автоматизации некоторых частей процесса написания Haskell привязки к коду C. Он читает исходный код почти на Haskell со встроенными специальными конструкциями и выводит реальный файл Haskell с обработанными конструкциями на основе информации, взятой из некоторых заголовков C. Дополнительные конструкции имеют дело с доступом к данным C из Haskell.</target>
        </trans-unit>
        <trans-unit id="e2823e69f2a65d7ce80b8fd7a101d62eed4e1c66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i2d&lt;/code&gt; function is virtually one machine instruction; the default conversion&amp;mdash;via an intermediate &lt;code&gt;Rational&lt;/code&gt;-is obscenely expensive by comparison.</source>
          <target state="translated">Функция &lt;code&gt;i2d&lt;/code&gt; - это фактически одна машинная инструкция; преобразование по умолчанию - через промежуточный &lt;code&gt;Rational&lt;/code&gt; - по сравнению с ним до неприличия дорого.</target>
        </trans-unit>
        <trans-unit id="7c8dc7d7a696a83968e6e8dd5a58a6b1ef2a23b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; of a cost-centre listed in the &lt;code&gt;cost_centres&lt;/code&gt; list.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; из затрат центра , перечисленных в &lt;code&gt;cost_centres&lt;/code&gt; списке.</target>
        </trans-unit>
        <trans-unit id="0f33c5545ef78687d7ec80abf9761102bfc37c4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import A hiding( g )&lt;/code&gt; in module &lt;code&gt;B&lt;/code&gt; is technically an error (&lt;a href=&quot;http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1&quot;&gt;Haskell Report, 5.3.1&lt;/a&gt;) because &lt;code&gt;A&lt;/code&gt; does not export &lt;code&gt;g&lt;/code&gt;. However GHC allows it, in the interests of supporting backward compatibility; for example, a newer version of &lt;code&gt;A&lt;/code&gt; might export &lt;code&gt;g&lt;/code&gt;, and you want &lt;code&gt;B&lt;/code&gt; to work in either case.</source>
          <target state="translated">&lt;code&gt;import A hiding( g )&lt;/code&gt; в модуле &lt;code&gt;B&lt;/code&gt; является технически ошибка ( &lt;a href=&quot;http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1&quot;&gt;Haskell Report, 5.3.1&lt;/a&gt; ) , потому что не делает экспорт &lt;code&gt;g&lt;/code&gt; . Однако GHC позволяет это в интересах поддержки обратной совместимости; например, более новая версия &lt;code&gt;A&lt;/code&gt; может экспортировать &lt;code&gt;g&lt;/code&gt; , и вы хотите, чтобы &lt;code&gt;B&lt;/code&gt; работал в любом случае. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f41076a0857a53fdc32d3736b60eb827f4f251e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; declaration (&lt;a href=&quot;#ghci-import-decl&quot;&gt;Controlling what is in scope with import&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; декларации ( &lt;a href=&quot;#ghci-import-decl&quot;&gt;Управление , что находится в области с импортом&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5ad2ceafe50f168640b42ddfd5b779521b31a687" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instance&lt;/code&gt; keyword is optional.</source>
          <target state="translated">&lt;code&gt;instance&lt;/code&gt; необязательное ключевое слово.</target>
        </trans-unit>
        <trans-unit id="6290f04db0b506c583506333aeba21e56f7af2ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lazyIOExample&lt;/code&gt; uses lazy I/O to read the file from the disk, which is not suitable in all applications, and certainly not if you need to read from a socket which has higher likelihood to fail. To address these needs, use the incremental input method like in &lt;code&gt;incrementalExample&lt;/code&gt;. For an example of how to read incrementally from a Handle, see the implementation of &lt;code&gt;&lt;a href=&quot;data-binary#v:decodeFileOrFail&quot;&gt;decodeFileOrFail&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lazyIOExample&lt;/code&gt; использует ленивое I / O , чтобы прочитать файл с диска, который не подходит для всех приложений, и , конечно , если вы не нужно читать из сокета , который имеет более высокую вероятность потерпеть неудачу. Чтобы удовлетворить эти потребности, используйте метод инкрементного ввода, как в &lt;code&gt;incrementalExample&lt;/code&gt; . Для примера того, как постепенно читать из Handle, см. Реализацию &lt;code&gt;&lt;a href=&quot;data-binary#v:decodeFileOrFail&quot;&gt;decodeFileOrFail&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2176a754f25110a9917a6219e63404e3208eea44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapException&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;mapException&lt;/code&gt; функция</target>
        </trans-unit>
        <trans-unit id="c837f409d9c890ff0cf84a0f23501c248975f873" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mask_&lt;/code&gt; is to avoid asynchronous exceptions before the &lt;code&gt;scheduleCallback&lt;/code&gt; call, which would leak the &lt;code&gt;StablePtr&lt;/code&gt;.</source>
          <target state="translated">Параметр &lt;code&gt;mask_&lt;/code&gt; предназначен для предотвращения асинхронных исключений перед вызовом &lt;code&gt;scheduleCallback&lt;/code&gt; , которые могут &lt;code&gt;StablePtr&lt;/code&gt; утечке StablePtr .</target>
        </trans-unit>
        <trans-unit id="88156e7be9a84c3b32b21ca9033fb9b40a86fc7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mdo&lt;/code&gt; notation removes the burden of placing explicit &lt;code&gt;rec&lt;/code&gt; blocks in the code. Unlike an ordinary &lt;code&gt;do&lt;/code&gt; expression, in which variables bound by statements are only in scope for later statements, variables bound in an &lt;code&gt;mdo&lt;/code&gt; expression are in scope for all statements of the expression. The compiler then automatically identifies minimal mutually recursively dependent segments of statements, treating them as if the user had wrapped a &lt;code&gt;rec&lt;/code&gt; qualifier around them.</source>
          <target state="translated">&lt;code&gt;mdo&lt;/code&gt; нотация снимает бремя размещения явных &lt;code&gt;rec&lt;/code&gt; блоков в коде. В отличие от обычного выражения &lt;code&gt;do&lt;/code&gt; , в котором переменные, связанные операторами, находятся в области видимости только для последующих операторов, переменные, связанные в выражении &lt;code&gt;mdo&lt;/code&gt; , находятся в области видимости всех операторов выражения. Затем компилятор автоматически определяет минимальные взаимно рекурсивно зависимые сегменты операторов, обрабатывая их так, как если бы пользователь обернул их квалификатором &lt;code&gt;rec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6a07857e87c25a69a2a85f3c6940b5d3da66364" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;needle&lt;/code&gt; parameter may not be empty.</source>
          <target state="translated">Параметр &lt;code&gt;needle&lt;/code&gt; не может быть пустым.</target>
        </trans-unit>
        <trans-unit id="03da503ca798d541eacd37351134d51c710473a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nel&lt;/code&gt; capability, which moves the cursor to the first column of the next line. It behaves like a carriage return followed by a line feed.</source>
          <target state="translated">Возможность &lt;code&gt;nel&lt;/code&gt; , которая перемещает курсор в первый столбец следующей строки. Он действует как возврат каретки, за которым следует перевод строки.</target>
        </trans-unit>
        <trans-unit id="41854e5bb2dcfb535a78b10a713fbfca69450478" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubIntOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype. For example, &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.13.0.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; can be used to nub characters and typical fixed-with numerical types efficiently.</source>
          <target state="translated">Функция &lt;code&gt;nubIntOn&lt;/code&gt; ведет себя так же, как &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; , за исключением того, что она выполняет сравнения не с исходным типом данных, а с указанной пользователем проекцией из этого типа данных. Например, &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.13.0.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; можно эффективно использовать для объединения символов и типичных фиксированных числовых типов.</target>
        </trans-unit>
        <trans-unit id="d601cddbbd9d7126bc0e97c81bf6fdd7871c9080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubOrdOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubOrd&quot;&gt;nubOrd&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype.</source>
          <target state="translated">Функция &lt;code&gt;nubOrdOn&lt;/code&gt; ведет себя так же, как &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubOrd&quot;&gt;nubOrd&lt;/a&gt;&lt;/code&gt; , за исключением того, что она выполняет сравнения не с исходным типом данных, а с указанной пользователем проекцией из этого типа данных.</target>
        </trans-unit>
        <trans-unit id="d367aba8a4bc7af80523df0833dbadc25b08592e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; методы &lt;em&gt;должны возвращать карту с подмножеством (возможно , пустым) ключей данной карты&lt;/em&gt; . Значения можно изменять произвольно. Наиболее распространенные варианты &lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; являются &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; , но, например , &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; может быть использован для любого &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87db766c3fcfe957880bc536c8055be89a67ca05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; методы &lt;em&gt;должны возвращать карту с подмножеством (возможно , пустым) ключей данной карты&lt;/em&gt; . Значения можно изменять произвольно. Наиболее распространенные варианты &lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; являются &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; , но, например , &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; может быть использован для любого &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3d76aa425b2c86fc5220b26c112435a53e249f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; методы &lt;em&gt;должны возвращать карту с подмножеством (возможно , пустым) ключей данной карты&lt;/em&gt; . Значения можно изменять произвольно. Наиболее распространенные варианты &lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; являются &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; , но, например , &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; может быть использован для любого &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe60eae85d88c9490c48aade82bc12d2974b6022" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; методы &lt;em&gt;должны возвращать карту с подмножеством (возможно , пустым) ключей данной карты&lt;/em&gt; . Значения можно изменять произвольно. Наиболее распространенные варианты &lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; являются &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; , но, например , &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; может быть использован для любого &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48239e0c803c6ef0e5cd08862ca58810b64b5781" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; методы &lt;em&gt;должны возвращать карту с подмножеством (возможно , пустым) ключей данной карты&lt;/em&gt; . Значения можно изменять произвольно. Наиболее распространенные варианты &lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; являются &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; , но, например , &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; может быть использован для любого &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46099596c66e9f01cbd3f7bcc5b5f08680659ccd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pat_lhs&lt;/code&gt; for explicitly bidirectional construction cannot use Record syntax. (Because the rhs &lt;em&gt;expr&lt;/em&gt; might be constructing different data constructors.) It can use guards with multiple equations.</source>
          <target state="translated">В &lt;code&gt;pat_lhs&lt;/code&gt; для явного двунаправленной конструкции не могут использовать синтаксис записи. (Поскольку rhs &lt;em&gt;expr&lt;/em&gt; может создавать разные конструкторы данных.) Он может использовать защитные элементы с несколькими уравнениями.</target>
        </trans-unit>
        <trans-unit id="c77daba6d5e5a119d170e42d9dd4a10538222183" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qq&lt;/code&gt; quasiquoter would be able to see the definition of &lt;code&gt;f&lt;/code&gt; from the preceding declaration group, but not the definitions of &lt;code&gt;h&lt;/code&gt; or &lt;code&gt;k&lt;/code&gt;, or any definitions from subsequent declaration groups.</source>
          <target state="translated">&lt;code&gt;qq&lt;/code&gt; quasiquoter сможет увидеть определение &lt;code&gt;f&lt;/code&gt; из предыдущей декларации группы, но не определения &lt;code&gt;h&lt;/code&gt; или &lt;code&gt;k&lt;/code&gt; , или каких - либо определений из последующих групп декларации.</target>
        </trans-unit>
        <trans-unit id="c466f28061a085d0fe280fa263ce6f774fe3c68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recover&lt;/code&gt; function is used to continue decoding in the presence of invalid or unrepresentable sequences. This includes both those detected by &lt;code&gt;encode&lt;/code&gt; returning &lt;code&gt;InvalidSequence&lt;/code&gt; and those that occur because the input byte sequence appears to be truncated.</source>
          <target state="translated">Функция &lt;code&gt;recover&lt;/code&gt; используется для продолжения декодирования при наличии недопустимых или непредставимых последовательностей. Сюда входят как те, которые обнаруживаются при &lt;code&gt;encode&lt;/code&gt; возвращающем &lt;code&gt;InvalidSequence&lt;/code&gt; ,так и те, которые возникают из-за того, что входная последовательность байтов кажется усеченной.</target>
        </trans-unit>
        <trans-unit id="a473a7ced8aa63a52d8a8ae70bef9c494ad7a2e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; function simply creates a continuation which passes the value on.</source>
          <target state="translated">Функция &lt;code&gt;return&lt;/code&gt; просто создает продолжение, которое передает значение.</target>
        </trans-unit>
        <trans-unit id="81379fa1503519747e0a096e84f164e14f442525" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;runghc&lt;/code&gt; command-line looks like:</source>
          <target state="translated">В &lt;code&gt;runghc&lt;/code&gt; командной строки выглядит следующим образом :</target>
        </trans-unit>
        <trans-unit id="aa8f29d0aba7b46039df62fe50f4c7d9ad9965c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shows&lt;/code&gt; functions return a function that prepends the output &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an existing &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. This allows constant-time concatenation of results using function composition.</source>
          <target state="translated">Функции &lt;code&gt;shows&lt;/code&gt; возвращают функцию, которая добавляет &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; вывода к существующей &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; . Это позволяет объединять результаты в постоянное время с помощью композиции функций.</target>
        </trans-unit>
        <trans-unit id="2bfd895a0337bb9829478985b48c54b24e2e9ad9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shows&lt;/code&gt; functions return a function that prepends the output &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an existing &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. This allows constant-time concatenation of results using function composition.</source>
          <target state="translated">Функции &lt;code&gt;shows&lt;/code&gt; возвращают функцию, которая добавляет &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; вывода к существующей &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; . Это позволяет объединять результаты в постоянное время с помощью композиции функций.</target>
        </trans-unit>
        <trans-unit id="8762c6cbedea04c42d6cbeebccb6250ad93ea53a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sprint&lt;/code&gt; function adds an exclamation mark at the end of any printed value. Running GHCi with the command:</source>
          <target state="translated">Функция &lt;code&gt;sprint&lt;/code&gt; добавляет восклицательный знак в конце любого напечатанного значения. Запускаем GHCi командой:</target>
        </trans-unit>
        <trans-unit id="b8ab09f95cb11cc6d3321f577cbb4de51fef8004" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state hack&lt;/code&gt; optimization can result in non-obvious changes in evaluation ordering which may hide exceptions, even with &lt;a href=&quot;using-optimisation#ghc-flag--fpedantic-bottoms&quot;&gt;&lt;code&gt;-fpedantic-bottoms&lt;/code&gt;&lt;/a&gt; (see, e.g., &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/7411&quot;&gt;Issue #7411&lt;/a&gt;). For instance,</source>
          <target state="translated">&lt;code&gt;state hack&lt;/code&gt; оптимизация может привести к неочевидные изменений в упорядочении оценки , которые могут скрыть исключения, даже с &lt;a href=&quot;using-optimisation#ghc-flag--fpedantic-bottoms&quot;&gt; &lt;code&gt;-fpedantic-bottoms&lt;/code&gt; &lt;/a&gt; (см, например, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/7411&quot;&gt;выпуск № 7411&lt;/a&gt; ). Например,</target>
        </trans-unit>
        <trans-unit id="3fc26580a12c7237de8bc3feeef150e25e82b7eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;template-haskell&lt;/code&gt; library provides &lt;code&gt;Lift&lt;/code&gt; instances for many common data types. Furthermore, it is possible to derive &lt;code&gt;Lift&lt;/code&gt; instances automatically by using the &lt;a href=&quot;#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt; language extension. See &lt;a href=&quot;#deriving-lift&quot;&gt;Deriving Lift instances&lt;/a&gt; for more information.</source>
          <target state="translated">Библиотека &lt;code&gt;template-haskell&lt;/code&gt; предоставляет экземпляры &lt;code&gt;Lift&lt;/code&gt; для многих распространенных типов данных. Кроме того, можно автоматически &lt;a href=&quot;#extension-DeriveLift&quot;&gt; &lt;code&gt;DeriveLift&lt;/code&gt; &lt;/a&gt; экземпляры &lt;code&gt;Lift&lt;/code&gt; с помощью языкового расширения DeriveLift . Дополнительную информацию см. В разделе &lt;a href=&quot;#deriving-lift&quot;&gt;Получение экземпляров лифта&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="adbf9d076f18bc800a1c0458fc70e137b98ee09f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; combinator can for example be used to distinguish identifiers and reserved words. Both reserved words and identifiers are a sequence of letters. Whenever we expect a certain reserved word where we can also expect an identifier we have to use the &lt;code&gt;try&lt;/code&gt; combinator. Suppose we write:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; комбинатор может быть, например, использоваться для различения идентификаторов и зарезервированных слов. И зарезервированные слова, и идентификаторы представляют собой последовательность букв. Когда мы ожидаем определенного зарезервированного слова, где мы также можем ожидать идентификатор, мы должны использовать комбинатор &lt;code&gt;try&lt;/code&gt; . Допустим, мы пишем:</target>
        </trans-unit>
        <trans-unit id="d03c88b23debcedbc11667e18141e6115f243880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; functions</source>
          <target state="translated">В &lt;code&gt;try&lt;/code&gt; функции</target>
        </trans-unit>
        <trans-unit id="9192255b8c683615d80a4ee64628e5e043860b7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type role&lt;/code&gt; (enabled with &lt;a href=&quot;#extension-RoleAnnotations&quot;&gt;&lt;code&gt;RoleAnnotations&lt;/code&gt;&lt;/a&gt;) declaration forces the parameter &lt;code&gt;a&lt;/code&gt; to be at role representational, not role phantom. GHC then checks the user-supplied roles to make sure they don&amp;rsquo;t break any promises. It would be bad, for example, if the user could make &lt;code&gt;BadIdea&lt;/code&gt;&amp;lsquo;s role be representational.</source>
          <target state="translated">&lt;code&gt;type role&lt;/code&gt; (с поддержкой &lt;a href=&quot;#extension-RoleAnnotations&quot;&gt; &lt;code&gt;RoleAnnotations&lt;/code&gt; &lt;/a&gt; ) декларирование силы параметр быть в роли представительские, а не роль фантома. Затем GHC проверяет предоставленные пользователем роли, чтобы убедиться, что они не нарушают никаких обещаний. Было бы плохо, например, если бы пользователь мог сделать роль &lt;code&gt;BadIdea&lt;/code&gt; репрезентативной. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b020a7d468bfda2ff2309461d916b84feeabc338" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; pragma is used only in &lt;code&gt;import&lt;/code&gt; declarations, to break a module loop. It is described in detail in &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;.</source>
          <target state="translated">Прагма &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; используется только в объявлениях &lt;code&gt;import&lt;/code&gt; , чтобы разорвать цикл модуля. Это подробно описано в разделе &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;Как компилировать взаимно рекурсивные модули&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ee4634b8912c617cc4c956549ecbf5f2fbc8ae6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;global package database&lt;/em&gt;, which comes with your GHC installation, e.g. &lt;code&gt;/usr/lib/ghc-6.12.1/package.conf.d&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Глобальная база данных пакета&lt;/em&gt; , который поставляется в комплекте с установкой GHC, например &lt;code&gt;/usr/lib/ghc-6.12.1/package.conf.d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a81be10d439420dbf2ec989064392ad08ec7838" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;interactive options&lt;/em&gt; apply when evaluating expressions and commands typed at the GHCi prompt.</source>
          <target state="translated">В &lt;em&gt;интерактивные опции&lt;/em&gt; применяются при оценке выражения и команды , введенные в командной строке GHCi.</target>
        </trans-unit>
        <trans-unit id="7491cf46ec5e1fbb15f8b7eb9e41d24a24f00f6a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;k&lt;/em&gt;th match, followed by the remainder of the string</source>
          <target state="translated">&lt;em&gt;К&lt;/em&gt; - й матч, а затем оставшуюся часть строки</target>
        </trans-unit>
        <trans-unit id="bc4c2343b61995f2f1a5ec7cbe01528dd89e1ed3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;loading options&lt;/em&gt; apply when loading modules</source>
          <target state="translated">Параметры &lt;em&gt;загрузки&lt;/em&gt; применяются при загрузке модулей</target>
        </trans-unit>
        <trans-unit id="80049228c8301318bfcd4d99de0d8c4f642d80d1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user package database&lt;/em&gt; private to each user. On Unix systems this will be &lt;code&gt;$HOME/.ghc/arch-os-version/package.conf.d&lt;/code&gt;, and on Windows it will be something like &lt;code&gt;C:\Documents&amp;nbsp;And&amp;nbsp;Settings\user\ghc\package.conf.d&lt;/code&gt;. The &lt;code&gt;ghc-pkg&lt;/code&gt; tool knows where this file should be located, and will create it if it doesn&amp;rsquo;t exist (see &lt;a href=&quot;#package-management&quot;&gt;Package management (the ghc-pkg command)&lt;/a&gt;).</source>
          <target state="translated">База &lt;em&gt;данных пользовательских пакетов является&lt;/em&gt; частной для каждого пользователя. В системах Unix это будет &lt;code&gt;$HOME/.ghc/arch-os-version/package.conf.d&lt;/code&gt; , а в Windows это будет что-то вроде &lt;code&gt;C:\Documents&amp;nbsp;And&amp;nbsp;Settings\user\ghc\package.conf.d&lt;/code&gt; . Инструмент &lt;code&gt;ghc-pkg&lt;/code&gt; знает, где должен находиться этот файл, и создаст его, если он не существует (см. &lt;a href=&quot;#package-management&quot;&gt;Управление пакетами (команда ghc-pkg)&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="06291563b1a287d734cf4e445906b8935befc784" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;ghc-pkg&lt;/strong&gt; tool is for querying and modifying package databases. To see what package databases are in use, use &lt;code&gt;ghc-pkg list&lt;/code&gt;. The stack of databases that &lt;strong&gt;ghc-pkg&lt;/strong&gt; knows about can be modified using the &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-10&quot;&gt;&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;&lt;/a&gt; environment variable (see &lt;a href=&quot;#ghc-package-path&quot;&gt;The GHC_PACKAGE_PATH environment variable&lt;/a&gt;, and using &lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-package-db ⟨file⟩&lt;/code&gt;&lt;/a&gt; options on the &lt;strong&gt;ghc-pkg&lt;/strong&gt; command line.</source>
          <target state="translated">Инструмент &lt;strong&gt;ghc-pkg&lt;/strong&gt; предназначен для запроса и изменения баз данных пакетов. Чтобы узнать, какие базы данных пакетов используются, используйте &lt;code&gt;ghc-pkg list&lt;/code&gt; . Стек баз данных, &lt;strong&gt;GHC-PKG&lt;/strong&gt; знает о том, могут быть изменены с помощью &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-10&quot;&gt; &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; &lt;/a&gt; переменной окружения (см &lt;a href=&quot;#ghc-package-path&quot;&gt;Переменная окружения GHC_PACKAGE_PATH&lt;/a&gt; , и используя &lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-package-db ⟨file⟩&lt;/code&gt; &lt;/a&gt; опции на &lt;strong&gt;GHC-упак&lt;/strong&gt; командной строки.</target>
        </trans-unit>
        <trans-unit id="21c02a6f4db72c82bb4b16489a1dc3d9f3dcd251" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;gv&lt;/strong&gt; and &lt;strong&gt;ghostview&lt;/strong&gt; programs have a &amp;ldquo;watch file&amp;rdquo; option can be used to view an up-to-date heap profile of your program as it runs. Simply generate an incremental heap profile as described in the previous section. Run &lt;strong&gt;gv&lt;/strong&gt; on your profile:</source>
          <target state="translated">У программ &lt;strong&gt;gv&lt;/strong&gt; и &lt;strong&gt;ghostview&lt;/strong&gt; есть опция &amp;laquo;смотреть файл&amp;raquo;, которую можно использовать для просмотра актуального профиля кучи вашей программы во время ее выполнения. Просто создайте инкрементный профиль кучи, как описано в предыдущем разделе. Запустите &lt;strong&gt;gv&lt;/strong&gt; в своем профиле:</target>
        </trans-unit>
        <trans-unit id="c2745da38f58a1f51bf9ab0d3486cc161c559b3b" translate="yes" xml:space="preserve">
          <source>The ASCII encoding is a 7-bit encoding. The &lt;em&gt;Char7&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 7-bits, prefixing it with a leading 0, and encoding the resulting 8-bits as a single byte. For the codepoints 0-127 this corresponds the ASCII encoding.</source>
          <target state="translated">Кодировка ASCII - это 7-битная кодировка. &lt;em&gt;Char7&lt;/em&gt; кодирование реализовано здесь работает посредством усечения Unicode элемента кода до 7 бит, префикса с ведущими 0, и кодированием полученных 8 бит в качестве одного байта. Для кодовых точек 0&amp;ndash;127 это соответствует кодировке ASCII.</target>
        </trans-unit>
        <trans-unit id="3335871b5b9fc97a659ecaa26da1b75a25e4dbb8" translate="yes" xml:space="preserve">
          <source>The Accum monad</source>
          <target state="translated">Монада Аккум</target>
        </trans-unit>
        <trans-unit id="54a2a116adb6e3d511623890991b066600f4a837" translate="yes" xml:space="preserve">
          <source>The AccumT monad transformer</source>
          <target state="translated">Трансформатор AccumT monad</target>
        </trans-unit>
        <trans-unit id="e322260aafb4a2f2a2ca6cdac3c65b6a2316bc3a" translate="yes" xml:space="preserve">
          <source>The Any type</source>
          <target state="translated">The Any type</target>
        </trans-unit>
        <trans-unit id="77184a896c809c5987a275354391bcb9afa84715" translate="yes" xml:space="preserve">
          <source>The Binary class</source>
          <target state="translated">Двоичный класс</target>
        </trans-unit>
        <trans-unit id="f21b224c49e198997a984cc9f95eb312adc1246f" translate="yes" xml:space="preserve">
          <source>The Binary instance for ResolvedBCOs.</source>
          <target state="translated">Двоичный экземпляр для ResolvedBCO.</target>
        </trans-unit>
        <trans-unit id="1340d1532cd96c08b9077a17a6e5cf354440ec03" translate="yes" xml:space="preserve">
          <source>The Builder monoid</source>
          <target state="translated">Моноид Строителя</target>
        </trans-unit>
        <trans-unit id="66e06b4ddeb35c347cf81033820bf5237468d89f" translate="yes" xml:space="preserve">
          <source>The Builder type</source>
          <target state="translated">Тип Строителя</target>
        </trans-unit>
        <trans-unit id="6f59e6c207b1a2a380dd7912a6b135a7a6ef6d7e" translate="yes" xml:space="preserve">
          <source>The C call &lt;code&gt;hs_try_putmvar(cap, mvar)&lt;/code&gt; is equivalent to the Haskell call &lt;code&gt;tryPutMVar mvar ()&lt;/code&gt;, except that it is</source>
          <target state="translated">Вызов C &lt;code&gt;hs_try_putmvar(cap, mvar)&lt;/code&gt; эквивалентен вызову Haskell &lt;code&gt;tryPutMVar mvar ()&lt;/code&gt; , за исключением того, что это</target>
        </trans-unit>
        <trans-unit id="930ac2c5a6231d7b293cf2f4934390d97c5dceec" translate="yes" xml:space="preserve">
          <source>The C code generator is only supported when GHC is built in unregisterised mode, a mode where GHC produces &amp;ldquo;portable&amp;rdquo; C code as output to facilitate porting GHC itself to a new platform. This mode produces much slower code though so it&amp;rsquo;s unlikely your version of GHC was built this way. If it has then the native code generator probably won&amp;rsquo;t be available. You can check this information by calling &lt;code&gt;ghc --info&lt;/code&gt; (see &lt;a href=&quot;using#ghc-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Генератор кода C поддерживается только в том случае, если GHC построен в незарегистрированном режиме, режиме, в котором GHC создает &amp;laquo;переносимый&amp;raquo; код C в качестве выходных данных, чтобы облегчить перенос самого GHC на новую платформу. Этот режим производит намного более медленный код, поэтому маловероятно, что ваша версия GHC была построена таким образом. Если да, то генератор машинного кода, вероятно, будет недоступен. Вы можете проверить эту информацию, вызвав &lt;code&gt;ghc --info&lt;/code&gt; (см. &lt;a href=&quot;using#ghc-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a4478e58f6a72e43562ea06bc573417edc1f53b0" translate="yes" xml:space="preserve">
          <source>The C compiler to use (default: &lt;code&gt;gcc&lt;/code&gt;)</source>
          <target state="translated">Используемый компилятор C (по умолчанию: &lt;code&gt;gcc&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="01130faef1141c2e4c47f77d4532a52f8115186a" translate="yes" xml:space="preserve">
          <source>The C pre-processor &lt;strong&gt;cpp&lt;/strong&gt; is run over your Haskell code only if the &lt;code&gt;-cpp&lt;/code&gt; option -cpp option is given. Unless you are building a large system with significant doses of conditional compilation, you really shouldn&amp;rsquo;t need it.</source>
          <target state="translated">C препроцессор &lt;strong&gt;CPP&lt;/strong&gt; запускается через ваш Haskell код , только если &lt;code&gt;-cpp&lt;/code&gt; опция опция -cpp дается. Если вы не создаете большую систему со значительными объемами условной компиляции, она вам действительно не понадобится.</target>
        </trans-unit>
        <trans-unit id="be8a30e9f725c587f4c42c5c2ac8a566321ce4b5" translate="yes" xml:space="preserve">
          <source>The C program is compiled using the Haskell compiler. This provides the include path to &lt;code&gt;HsFFI.h&lt;/code&gt; which is automatically included into the C program.</source>
          <target state="translated">Программа на C компилируется с использованием компилятора Haskell. Это обеспечивает путь включения к &lt;code&gt;HsFFI.h&lt;/code&gt; , который автоматически включается в программу C.</target>
        </trans-unit>
        <trans-unit id="e91fc210907e94074bed36ea19e87412c05ed8a0" translate="yes" xml:space="preserve">
          <source>The C-side interface</source>
          <target state="translated">С-образный интерфейс</target>
        </trans-unit>
        <trans-unit id="7ff7e343e1c6696d97347c4a9cd5a3b43c6bba9e" translate="yes" xml:space="preserve">
          <source>The CPU time used during GC itself</source>
          <target state="translated">Процессорное время,используемое во время работы самого ГХ</target>
        </trans-unit>
        <trans-unit id="9b0e04ec6361f33e0d68f7f33f77c1ab233452ad" translate="yes" xml:space="preserve">
          <source>The Chapter does &lt;em&gt;not&lt;/em&gt; require implementations to refrain from doing the same for &lt;code&gt;unsafe&lt;/code&gt; calls, so strictly Haskell 2010-conforming programs cannot pass heap-allocated references to &lt;code&gt;unsafe&lt;/code&gt; FFI calls either.</source>
          <target state="translated">В этой главе &lt;em&gt;не&lt;/em&gt; требуется, чтобы реализации воздерживались от выполнения того же действия для &lt;code&gt;unsafe&lt;/code&gt; вызовов, поэтому программы, строго соответствующие Haskell 2010, также не могут передавать ссылки, размещенные в куче, на &lt;code&gt;unsafe&lt;/code&gt; вызовы FFI.</target>
        </trans-unit>
        <trans-unit id="7a6d8be9dffe246766e3012760ad26dc58ac76a9" translate="yes" xml:space="preserve">
          <source>The Char type and associated operations.</source>
          <target state="translated">Тип Char и связанные с ним операции.</target>
        </trans-unit>
        <trans-unit id="34ab3cac27f3b7905cb71f872510098e1f28d42c" translate="yes" xml:space="preserve">
          <source>The Char8 interface to bytestrings provides an instance of IsString for the ByteString type, enabling you to use string literals, and have them implicitly packed to ByteStrings. Use &lt;code&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/code&gt; to enable this.</source>
          <target state="translated">Интерфейс Char8 для строк байтов предоставляет экземпляр IsString для типа ByteString, что позволяет использовать строковые литералы и неявно упаковывать их в ByteStrings. Используйте &lt;code&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/code&gt; чтобы включить это.</target>
        </trans-unit>
        <trans-unit id="87a20786956ef56773cf03030aa4cf8ea1fe3cb5" translate="yes" xml:space="preserve">
          <source>The Constraint kind</source>
          <target state="translated">Сдерживающий вид</target>
        </trans-unit>
        <trans-unit id="09ab3e32936ccf9f3bb679b6e68a3e00b45ed452" translate="yes" xml:space="preserve">
          <source>The Cont monad</source>
          <target state="translated">Монада Конт</target>
        </trans-unit>
        <trans-unit id="12f452e71f00e2687665dadf2d17184d0289a2e5" translate="yes" xml:space="preserve">
          <source>The ContT monad transformer</source>
          <target state="translated">Трансформатор ContT monad</target>
        </trans-unit>
        <trans-unit id="ca90c83f50ba973fabb4434d084cfad4acdcfc2a" translate="yes" xml:space="preserve">
          <source>The Continuation monad represents computations in continuation-passing style (CPS). In continuation-passing style function result is not returned, but instead is passed to another function, received as a parameter (continuation). Computations are built up from sequences of nested continuations, terminated by a final continuation (often &lt;code&gt;id&lt;/code&gt;) which produces the final result. Since continuations are functions which represent the future of a computation, manipulation of the continuation functions can achieve complex manipulations of the future of the computation, such as interrupting a computation in the middle, aborting a portion of a computation, restarting a computation, and interleaving execution of computations. The Continuation monad adapts CPS to the structure of a monad.</source>
          <target state="translated">Монада продолжения представляет вычисления в стиле передачи продолжения (CPS). В стиле с передачей продолжения результат функции не возвращается, а вместо этого передается другой функции, полученной как параметр (продолжение). Вычисления строятся из последовательностей вложенных продолжений, завершающихся финальным продолжением (часто &lt;code&gt;id&lt;/code&gt; ), которое дает окончательный результат. Поскольку продолжения - это функции, которые представляют будущее вычислений, манипулирование функциями продолжения может достигать сложных манипуляций с будущим вычислений, таких как прерывание вычисления в середине, прерывание части вычисления, перезапуск вычисления и чередование выполнение вычислений. Монада продолжения адаптирует CPS к структуре монады.</target>
        </trans-unit>
        <trans-unit id="b6f5f2130ef6b7cf3dfc8eaaad4cc1b44fc47954" translate="yes" xml:space="preserve">
          <source>The Coverage Condition. For each functional dependency, ⟨tvs⟩&lt;sub&gt;left&lt;/sub&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨tvs⟩&lt;sub&gt;right&lt;/sub&gt;, of the class, every type variable in S(⟨tvs⟩&lt;sub&gt;right&lt;/sub&gt;) must appear in S(⟨tvs⟩&lt;sub&gt;left&lt;/sub&gt;), where S is the substitution mapping each type variable in the class declaration to the corresponding type in the instance head.</source>
          <target state="translated">Условия покрытия. Для каждой функциональной зависимости, ⟨tvs⟩ &lt;sub&gt;left &lt;/sub&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨tvs⟩ &lt;sub&gt;right&lt;/sub&gt; , класса, каждая переменная типа в S (⟨tvs⟩ &lt;sub&gt;right&lt;/sub&gt; ) должна появиться в S (tvs &lt;sub&gt;left&lt;/sub&gt; ), где S - отображение подстановки каждого типа переменная в объявлении класса к соответствующему типу в заголовке экземпляра.</target>
        </trans-unit>
        <trans-unit id="312777d9f2d66605158d20bff22160d55dc26cef" translate="yes" xml:space="preserve">
          <source>The Cygwin tools aim to provide a Unix-style API on top of the windows libraries, to facilitate ports of Unix software to windows. To this end, they introduce a Unix-style directory hierarchy under some root directory (typically &lt;code&gt;/&lt;/code&gt; is &lt;code&gt;C:\cygwin\&lt;/code&gt;). Moreover, everything built against the Cygwin API (including the Cygwin tools and programs compiled with Cygwin&amp;rsquo;s GHC) will see &lt;code&gt;/&lt;/code&gt; as the root of their file system, happily pretending to work in a typical unix environment, and finding things like &lt;code&gt;/bin&lt;/code&gt; and &lt;code&gt;/usr/include&lt;/code&gt; without ever explicitly bothering with their actual location on the windows system (probably &lt;code&gt;C:\cygwin\bin&lt;/code&gt; and &lt;code&gt;C:\cygwin\usr\include&lt;/code&gt;).</source>
          <target state="translated">Инструменты Cygwin стремятся предоставить API в стиле Unix поверх библиотек Windows, чтобы облегчить перенос программного обеспечения Unix в Windows. С этой целью они вводят иерархию каталогов в стиле Unix в некотором корневом каталоге (обычно &lt;code&gt;/&lt;/code&gt; - это &lt;code&gt;C:\cygwin\&lt;/code&gt; ). Более того, все, что создано на основе Cygwin API (включая инструменты и программы Cygwin, скомпилированные с помощью Cygwin GHC), будет видеть &lt;code&gt;/&lt;/code&gt; как корень своей файловой системы, счастливо делая вид, что работает в типичной среде unix, и находя такие вещи, как &lt;code&gt;/bin&lt;/code&gt; и &lt;code&gt;/usr/include&lt;/code&gt; , даже не беспокоясь об их фактическом местонахождении в системе Windows (возможно, &lt;code&gt;C:\cygwin\bin&lt;/code&gt; и &lt;code&gt;C:\cygwin\usr\include&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="86692a9d897be5d534ba24465eb9de8f931f4ef3" translate="yes" xml:space="preserve">
          <source>The Data class for processing constructor applications</source>
          <target state="translated">Класс данных для обработки конструкторских приложений</target>
        </trans-unit>
        <trans-unit id="1bf8237029872b5da672f6b7246e84175ba43046" translate="yes" xml:space="preserve">
          <source>The Dynamic interface provides basic support for dynamic types.</source>
          <target state="translated">Динамический интерфейс обеспечивает базовую поддержку динамических типов.</target>
        </trans-unit>
        <trans-unit id="42156dbee11df6db43f4c8b1cc0a248822a7d3cd" translate="yes" xml:space="preserve">
          <source>The Either type, and associated operations.</source>
          <target state="translated">Любой тип,и связанные с ним операции.</target>
        </trans-unit>
        <trans-unit id="807130fbb4274539dfd3c0eea747aff0499d3550" translate="yes" xml:space="preserve">
          <source>The Error monad (also called the Exception monad).</source>
          <target state="translated">Ошибка-монада (также называемая Исключительной Монадой).</target>
        </trans-unit>
        <trans-unit id="8a5dc0df0c5ba4b15156469d46e722f494c0f012" translate="yes" xml:space="preserve">
          <source>The ErrorT monad transformer</source>
          <target state="translated">Трансформатор ErrorT monad</target>
        </trans-unit>
        <trans-unit id="9e8b0fd8b8d2403326182f44dc58f86de4db1bbe" translate="yes" xml:space="preserve">
          <source>The Except monad</source>
          <target state="translated">За исключением монады.</target>
        </trans-unit>
        <trans-unit id="0636fa085801d03d78d892f99e7194b6c4c5113a" translate="yes" xml:space="preserve">
          <source>The ExceptT monad transformer</source>
          <target state="translated">Трансформатор ExceptT monad</target>
        </trans-unit>
        <trans-unit id="28a34cf6c1c117fe3edc278dd4ce45f5bbb4e2ab" translate="yes" xml:space="preserve">
          <source>The Exception type</source>
          <target state="translated">Тип исключения</target>
        </trans-unit>
        <trans-unit id="fbddbb39610322fadeb3679edecc1231a3f3fbc0" translate="yes" xml:space="preserve">
          <source>The FFI features that are described in this section are specific to GHC. Your code will not be portable to other compilers if you use them.</source>
          <target state="translated">FFI-функции,описанные в этом разделе,специфичны для GHC.Ваш код не будет переноситься на другие компиляторы,если вы их используете.</target>
        </trans-unit>
        <trans-unit id="3efa5246016932362650667f0b2760b9317d9ba9" translate="yes" xml:space="preserve">
          <source>The FFI libraries are documented in the accompanying library documentation; see for example the &lt;a href=&quot;../libraries/base-4.13.0.0/foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">Библиотеки FFI задокументированы в сопроводительной библиотечной документации; см. например &lt;a href=&quot;../libraries/base-4.13.0.0/foreign&quot;&gt;Внешний&lt;/a&gt; модуль.</target>
        </trans-unit>
        <trans-unit id="761c07d2fa3147d943f9914eb230698128638338" translate="yes" xml:space="preserve">
          <source>The FFI libraries provide several ways to allocate memory for use with the FFI, and it isn&amp;rsquo;t always clear which way is the best. This decision may be affected by how efficient a particular kind of allocation is on a given compiler/platform, so this section aims to shed some light on how the different kinds of allocation perform with GHC.</source>
          <target state="translated">Библиотеки FFI предоставляют несколько способов выделения памяти для использования с FFI, и не всегда ясно, какой из них лучше. Это решение может зависеть от того, насколько эффективен конкретный тип распределения на данном компиляторе / платформе, поэтому этот раздел направлен на то, чтобы пролить свет на то, как различные виды распределения работают с GHC.</target>
        </trans-unit>
        <trans-unit id="f6c805c7ce1959f9f4d5c3417b157ba30228b2de" translate="yes" xml:space="preserve">
          <source>The FFI spec requires the IO monad to appear in various places, but it can sometimes be convenient to wrap the IO monad in a &lt;code&gt;newtype&lt;/code&gt;, thus:</source>
          <target state="translated">Спецификация FFI требует, чтобы монада ввода-вывода появлялась в разных местах, но иногда может быть удобно обернуть монаду ввода-вывода в новый &lt;code&gt;newtype&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="5f20794bdc28c9aee5608b0c0fc201d96d6b3994" translate="yes" xml:space="preserve">
          <source>The FFI spec requires the implementation to support re-initialising itself after being shut down with &lt;code&gt;hs_exit()&lt;/code&gt;, but GHC does not currently support that. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;Issue #13693&lt;/a&gt;.</source>
          <target state="translated">Спецификация FFI требует, чтобы реализация поддерживала повторную инициализацию после завершения работы с помощью &lt;code&gt;hs_exit()&lt;/code&gt; , но GHC в настоящее время не поддерживает это. См. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;Выпуск № 13693&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d26ec709c2e5283538c1c653d1aa70ca0b33423" translate="yes" xml:space="preserve">
          <source>The GC sync time, along with other GC stats, are available by calling the &lt;code&gt;getRTSStats()&lt;/code&gt; function from C, or &lt;code&gt;GHC.Stats.getRTSStats&lt;/code&gt; from Haskell.</source>
          <target state="translated">Время синхронизации GC вместе с другой статистикой GC можно получить, вызвав &lt;code&gt;getRTSStats()&lt;/code&gt; из C или &lt;code&gt;GHC.Stats.getRTSStats&lt;/code&gt; из Haskell.</target>
        </trans-unit>
        <trans-unit id="b5021fe9fe3de702f6e9a5d53a92dd7d5114b557" translate="yes" xml:space="preserve">
          <source>The GHC API exposes functions for reading and writing these files.</source>
          <target state="translated">GHC API раскрывает функции для чтения и записи этих файлов.</target>
        </trans-unit>
        <trans-unit id="44e336f3335d4bce26ff1489887e65f02d167072" translate="yes" xml:space="preserve">
          <source>The GHC RTS currently can only recover from heap overflow if it detects that an explicit memory limit (set via RTS flags). has been exceeded. Currently, failure to allocate memory from the operating system results in immediate termination of the program.</source>
          <target state="translated">В настоящее время GHC RTS может восстанавливаться после переполнения кучи только в том случае,если обнаружит превышение явного лимита памяти (установленного с помощью флагов RTS).В настоящее время невыделение памяти из операционной системы приводит к немедленному завершению программы.</target>
        </trans-unit>
        <trans-unit id="092d6db4a6acf8e0f020ffc8e891aef1e6ec0134" translate="yes" xml:space="preserve">
          <source>The GHC command line options that control packages are:</source>
          <target state="translated">Опции командной строки GHC,которые управляют пакетами:</target>
        </trans-unit>
        <trans-unit id="61df44498694cfca7ad6514a046e11ddd08beac9" translate="yes" xml:space="preserve">
          <source>The GHC developers hang out here. If you are working with the GHC API or have a question about GHC&amp;rsquo;s implementation, feel free to chime in.</source>
          <target state="translated">Здесь тусуются разработчики GHC. Если вы работаете с GHC API или у вас есть вопрос о реализации GHC, не стесняйтесь вмешиваться.</target>
        </trans-unit>
        <trans-unit id="99d5e93b8c29504ff8cde4bfb2796cf7747d055b" translate="yes" xml:space="preserve">
          <source>The GHC driver pre-defines several macros when processing Haskell source code (&lt;code&gt;.hs&lt;/code&gt; or &lt;code&gt;.lhs&lt;/code&gt; files).</source>
          <target state="translated">Драйвер GHC предварительно определяет несколько макросов при обработке исходного кода Haskell ( &lt;code&gt;.hs&lt;/code&gt; или &lt;code&gt;.lhs&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="87a5e3c32c7140b14331679393031a63e7e433b2" translate="yes" xml:space="preserve">
          <source>The GHC runtime treats program exit as a special case, to avoid the need to wait for blocked threads when a standalone executable exits. Since the program and all its threads are about to terminate at the same time that the code is removed from memory, it isn&amp;rsquo;t necessary to ensure that the threads have exited first. If you want this fast and loose version of &lt;code&gt;hs_exit()&lt;/code&gt;, you can call:</source>
          <target state="translated">Среда выполнения GHC рассматривает выход из программы как особый случай, чтобы избежать необходимости ждать заблокированных потоков при выходе из автономного исполняемого файла. Поскольку программа и все ее потоки собираются завершить работу одновременно с удалением кода из памяти, нет необходимости гарантировать, что потоки завершились первыми. Если вам нужна эта быстрая и свободная версия &lt;code&gt;hs_exit()&lt;/code&gt; , вы можете вызвать:</target>
        </trans-unit>
        <trans-unit id="657d0403b8cb260dd76b91b660bfb82ac7e59695" translate="yes" xml:space="preserve">
          <source>The GHCi &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; command shows pattern types in this format.</source>
          <target state="translated">Команда GHCi &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt; &lt;code&gt;:info&lt;/code&gt; &lt;/a&gt; показывает типы шаблонов в этом формате.</target>
        </trans-unit>
        <trans-unit id="b98fc3571126a85946312283e8cabf74b5c92953" translate="yes" xml:space="preserve">
          <source>The GHCi Monad lifting interface.</source>
          <target state="translated">Подъемный интерфейс GHCi Monad.</target>
        </trans-unit>
        <trans-unit id="ebe9d3dd8c4ab5bd81e3a57040f569e196489a32" translate="yes" xml:space="preserve">
          <source>The GHCi debugger offers a way to hopefully shed some light on these errors quickly and without modifying or recompiling the source code. One way would be to set a breakpoint on the location in the source code that throws the exception, and then use &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:history&quot;&gt;&lt;code&gt;:history&lt;/code&gt;&lt;/a&gt; to establish the context. However, &lt;code&gt;head&lt;/code&gt; is in a library and we can&amp;rsquo;t set a breakpoint on it directly. For this reason, GHCi provides the flags &lt;a href=&quot;#ghc-flag--fbreak-on-exception&quot;&gt;&lt;code&gt;-fbreak-on-exception&lt;/code&gt;&lt;/a&gt; which causes the evaluator to stop when an exception is thrown, and &lt;a href=&quot;#ghc-flag--fbreak-on-error&quot;&gt;&lt;code&gt;-fbreak-on-error&lt;/code&gt;&lt;/a&gt;, which works similarly but stops only on uncaught exceptions. When stopping at an exception, GHCi will act just as it does when a breakpoint is hit, with the deviation that it will not show you any source code location. Due to this, these commands are only really useful in conjunction with &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;, in order to log the steps leading up to the exception. For example:</source>
          <target state="translated">Отладчик GHCi предлагает способ, как мы надеемся, пролить свет на эти ошибки быстро и без изменения или перекомпиляции исходного кода. Один из способов - установить точку останова в том месте исходного кода, которое вызывает исключение, а затем использовать &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#ghci-cmd-:history&quot;&gt; &lt;code&gt;:history&lt;/code&gt; &lt;/a&gt; для установления контекста. Однако &lt;code&gt;head&lt;/code&gt; находится в библиотеке, и мы не можем установить для нее точку останова напрямую. По этой причине GHCi предоставляет флаги &lt;a href=&quot;#ghc-flag--fbreak-on-exception&quot;&gt; &lt;code&gt;-fbreak-on-exception&lt;/code&gt; ,&lt;/a&gt; заставляющие оценщик останавливаться при возникновении исключения, и &lt;a href=&quot;#ghc-flag--fbreak-on-error&quot;&gt; &lt;code&gt;-fbreak-on-error&lt;/code&gt; &lt;/a&gt;, который работает аналогично, но останавливается только при неперехваченных исключениях. При остановке при исключении GHCi будет действовать так же, как и при достижении точки останова, с той лишь разницей, что он не покажет вам расположение исходного кода. Из-за этого эти команды действительно полезны только вместе с &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt; , чтобы регистрировать шаги, ведущие к исключению. Например:</target>
        </trans-unit>
        <trans-unit id="0b891d2a1ce80a9fee00fa3b6d6737a43b10a747" translate="yes" xml:space="preserve">
          <source>The Get and Put monads</source>
          <target state="translated">The Get and Put monads</target>
        </trans-unit>
        <trans-unit id="b776a2d45a7f2c193506de5827ffca159fdaaa31" translate="yes" xml:space="preserve">
          <source>The Get monad</source>
          <target state="translated">The Get monad</target>
        </trans-unit>
        <trans-unit id="881d557edd11af5e9c88e4e2caa565a9b7f16b2b" translate="yes" xml:space="preserve">
          <source>The Handle is closed once the contents have been read, or if an exception is thrown.</source>
          <target state="translated">Ручка закрывается после прочтения содержимого,или если выбрасывается исключение.</target>
        </trans-unit>
        <trans-unit id="9fc6da9c66a23f0d4306adb850fbe34a26d020b4" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 Report specifies that &lt;code&gt;safe&lt;/code&gt; FFI calls must allow foreign calls to safely call into Haskell code. In practice, this means that the garbage collector must be able to run while these calls are in progress, moving heap-allocated Haskell values around arbitrarily.</source>
          <target state="translated">В отчете Haskell 2010 указано, что &lt;code&gt;safe&lt;/code&gt; вызовы FFI должны позволять внешним вызовам безопасно вызывать код Haskell. На практике это означает, что сборщик мусора должен иметь возможность запускаться во время выполнения этих вызовов, произвольно перемещая значения Haskell, выделенные в куче.</target>
        </trans-unit>
        <trans-unit id="e4f4e3694b9cec057dc91d201d6594fcb8794184" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 definition of &lt;code&gt;Show&lt;/code&gt; stipulates that the rendered string should only include parentheses which are necessary to unambiguously parse the result. For historical reasons, &lt;code&gt;Show&lt;/code&gt; instances derived by GHC include parentheses around records despite the fact that record syntax binds more tightly than function application; e.g.,</source>
          <target state="translated">Определение &lt;code&gt;Show&lt;/code&gt; в Haskell 2010 предусматривает, что отображаемая строка должна включать только круглые скобки, необходимые для однозначного анализа результата. По историческим причинам экземпляры &lt;code&gt;Show&lt;/code&gt; , производные GHC, включают круглые скобки вокруг записей, несмотря на то, что синтаксис записи связывает более жестко, чем приложение функции; например,</target>
        </trans-unit>
        <trans-unit id="75b51a038a288722ea47d665ae6b1906f2f2ca30" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип Haskell 2010 для исключений в монаде &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; . Любая операция ввода-вывода может вызвать &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; вместо возврата результата. Для более общего типа исключений, включая те, которые возникают в чистом коде, см. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb081bfa52eb8a4cbf05cd929cfffa397e641c26" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип Haskell 2010 для исключений в монаде &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; . Любая операция ввода-вывода может вызвать &lt;code&gt;&lt;a href=&quot;prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; вместо возврата результата. Для более общего типа исключений, включая те, которые возникают в чистом коде, см. &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a99410a64c91a4399b3bdd6ca6ecba63bbee421d" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип Haskell 2010 для исключений в монаде &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; . Любая операция ввода-вывода может вызвать &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; вместо возврата результата. Для более общего типа исключений, включая те, которые возникают в чистом коде, см. &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="608a1f6c6546f6329017b0ba471b028aef303e51" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип Haskell 2010 для исключений в монаде &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; . Любая операция ввода-вывода может вызвать &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; вместо возврата результата. Для более общего типа исключений, включая те, которые возникают в чистом коде, см. &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbd1a39cbde2acf402014630435be0c05fcd70ac" translate="yes" xml:space="preserve">
          <source>The Haskell 98 definition of &lt;code&gt;isAlpha&lt;/code&gt; is:</source>
          <target state="translated">Определение &lt;code&gt;isAlpha&lt;/code&gt; в Haskell 98 :</target>
        </trans-unit>
        <trans-unit id="bcc5878839ee58bc74d82cc3033b4e47a4421ec2" translate="yes" xml:space="preserve">
          <source>The Haskell FFI already specifies that arguments and results of foreign imports and exports will be automatically unwrapped if they are newtypes (Section 3.2 of the FFI addendum). GHC extends the FFI by automatically unwrapping any newtypes that wrap the IO monad itself. More precisely, wherever the FFI specification requires an &lt;code&gt;IO&lt;/code&gt; type, GHC will accept any newtype-wrapping of an &lt;code&gt;IO&lt;/code&gt; type. For example, these declarations are OK:</source>
          <target state="translated">FFI Haskell уже указывает, что аргументы и результаты внешнего импорта и экспорта будут автоматически разворачиваться, если они являются новыми типами (раздел 3.2 приложения FFI). GHC расширяет FFI, автоматически разворачивая все новые типы, которые обертывают саму монаду ввода-вывода. Точнее, везде, где спецификация FFI требует тип &lt;code&gt;IO&lt;/code&gt; , GHC примет любое обертывание &lt;code&gt;IO&lt;/code&gt; типа для типа ввода-вывода . Например, эти объявления допустимы:</target>
        </trans-unit>
        <trans-unit id="4680c4ac34e14b7370d55faae60bc019d40c3efc" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; is customarily expected to implement an equivalence relationship where two values comparing equal are indistinguishable by &quot;public&quot; functions, with a &quot;public&quot; function being one not allowing to see implementation details. For example, for a type representing non-normalised natural numbers modulo 100, a &quot;public&quot; function doesn't make the difference between 1 and 201. It is expected to have the following properties:</source>
          <target state="translated">Отчет Haskell не определяет законов для &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; . Однако обычно ожидается , что &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; реализует отношение эквивалентности, где два сравниваемых значения неотличимы для &amp;laquo;общедоступных&amp;raquo; функций, при этом &amp;laquo;общедоступная&amp;raquo; функция не позволяет видеть детали реализации. Например, для типа, представляющего ненормализованные натуральные числа по модулю 100, &amp;laquo;общедоступная&amp;raquo; функция не делает разницы между 1 и 201. Ожидается, что она будет иметь следующие свойства:</target>
        </trans-unit>
        <trans-unit id="b435dd60d544eb355fdb3b5a53612290c22abfda" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;data-ord#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; is customarily expected to implement a non-strict partial order and have the following properties:</source>
          <target state="translated">Отчет Haskell не определяет законов для &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; . Однако обычно ожидается , что &lt;code&gt;&lt;a href=&quot;data-ord#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; реализует нестрогий частичный порядок и имеет следующие свойства:</target>
        </trans-unit>
        <trans-unit id="88538894fe954a03ab344dde58ca70fb4af218ac" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="translated">В отчете Haskell нет никаких законов для &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; . Однако обычно ожидается , что &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; , &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-float#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; определяют экспоненциальное поле и имеют следующие свойства:</target>
        </trans-unit>
        <trans-unit id="3149c28629f6ab1e2da394471685318956b0ba8a" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a ring and have the following properties:</source>
          <target state="translated">Отчет Haskell не определяет законов для &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; . Однако обычно предполагается , что &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; определяют кольцо и обладают следующими свойствами:</target>
        </trans-unit>
        <trans-unit id="8d88eda2762d9273ae973553c58bcc0bd71af620" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a division ring and have the following properties:</source>
          <target state="translated">В отчете Haskell нет никаких законов для &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; . Однако обычно предполагается , что &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; определяют разделительное кольцо и обладают следующими свойствами:</target>
        </trans-unit>
        <trans-unit id="e76164abdc0256cd6250a3085c5fb79d40aac6bd" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; instances are customarily expected to define a Euclidean domain and have the following properties for the &lt;code&gt;&lt;a href=&quot;ghc-real#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;ghc-real#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;ghc-real#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; pairs, given suitable Euclidean functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;:</source>
          <target state="translated">Отчет Haskell не определяет законов для &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; . Однако обычно предполагается , что экземпляры &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; определяют евклидову область и имеют следующие свойства для пар &lt;code&gt;&lt;a href=&quot;ghc-real#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;ghc-real#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-real#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;ghc-real#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; , учитывая подходящие евклидовы функции &lt;code&gt;f&lt;/code&gt; и &lt;code&gt;g&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9ce7650ff72472c9e39924a0365fbdbae6a3a423" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;numeric#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="translated">В отчете Haskell нет никаких законов для &lt;code&gt;&lt;a href=&quot;numeric#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; . Однако обычно ожидается , что &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; , &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;numeric#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; определяют экспоненциальное поле и имеют следующие свойства:</target>
        </trans-unit>
        <trans-unit id="8323805ef3fcd8127cc342507191554f2e774a6e" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; is customarily expected to implement an equivalence relationship where two values comparing equal are indistinguishable by &quot;public&quot; functions, with a &quot;public&quot; function being one not allowing to see implementation details. For example, for a type representing non-normalised natural numbers modulo 100, a &quot;public&quot; function doesn't make the difference between 1 and 201. It is expected to have the following properties:</source>
          <target state="translated">Отчет Haskell не определяет законов для &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; . Однако обычно ожидается , что &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; реализует отношение эквивалентности, где два сравниваемых значения неотличимы для &amp;laquo;общедоступных&amp;raquo; функций, при этом &amp;laquo;общедоступная&amp;raquo; функция не позволяет видеть детали реализации. Например, для типа, представляющего ненормализованные натуральные числа по модулю 100, &amp;laquo;общедоступная&amp;raquo; функция не делает разницы между 1 и 201. Ожидается, что она будет иметь следующие свойства:</target>
        </trans-unit>
        <trans-unit id="b48c329c20a3981396eab2a99555375b78674fa9" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="translated">В отчете Haskell нет никаких законов для &lt;code&gt;&lt;a href=&quot;prelude#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; . Однако обычно ожидается , что &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; , &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; определяют экспоненциальное поле и имеют следующие свойства:</target>
        </trans-unit>
        <trans-unit id="1c7fa25d86a0693f27eca0a0ad84f5518dec11cf" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a division ring and have the following properties:</source>
          <target state="translated">В отчете Haskell нет никаких законов для &lt;code&gt;&lt;a href=&quot;prelude#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; . Однако обычно предполагается , что &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; определяют разделительное кольцо и обладают следующими свойствами:</target>
        </trans-unit>
        <trans-unit id="813c73ced84a637d883552041de27732ad7f49d9" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; instances are customarily expected to define a Euclidean domain and have the following properties for the &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; pairs, given suitable Euclidean functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;:</source>
          <target state="translated">Отчет Haskell не определяет законов для &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; . Однако обычно предполагается , что экземпляры &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; определяют евклидову область и имеют следующие свойства для пар &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; , учитывая подходящие евклидовы функции &lt;code&gt;f&lt;/code&gt; и &lt;code&gt;g&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="04a2d6720afe45625eeed33bd966e63b2869f306" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a ring and have the following properties:</source>
          <target state="translated">Отчет Haskell не определяет законов для &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; . Однако обычно предполагается , что &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; определяют кольцо и обладают следующими свойствами:</target>
        </trans-unit>
        <trans-unit id="79c8c45566ea3ef649482a06f412a05df4a6acfa" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; is customarily expected to implement a non-strict partial order and have the following properties:</source>
          <target state="translated">Отчет Haskell не определяет законов для &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; . Однако обычно ожидается , что &lt;code&gt;&lt;a href=&quot;prelude#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; реализует нестрогий частичный порядок и имеет следующие свойства:</target>
        </trans-unit>
        <trans-unit id="d6f54f30ee874469ea4834b2c92a3bff6d9a4e7e" translate="yes" xml:space="preserve">
          <source>The Haskell Report demands that, for infix operators &lt;code&gt;%&lt;/code&gt;, the following identities hold:</source>
          <target state="translated">Отчет Haskell требует, чтобы для инфиксных операторов &lt;code&gt;%&lt;/code&gt; выполнялись следующие идентификаторы:</target>
        </trans-unit>
        <trans-unit id="fda99c30e66a8cf02c9c342a9bf010a7836b92f1" translate="yes" xml:space="preserve">
          <source>The Haskell Report describes that &lt;code&gt;*&lt;/code&gt; (spelled &lt;code&gt;Type&lt;/code&gt; and imported from &lt;code&gt;Data.Kind&lt;/code&gt; in the GHC dialect of Haskell) is the kind of ordinary datatypes, such as &lt;code&gt;Int&lt;/code&gt;. Furthermore, type constructors can have kinds with arrows; for example, &lt;code&gt;Maybe&lt;/code&gt; has kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. Unboxed types have a kind that specifies their runtime representation. For example, the type &lt;code&gt;Int#&lt;/code&gt; has kind &lt;code&gt;TYPE 'IntRep&lt;/code&gt; and &lt;code&gt;Double#&lt;/code&gt; has kind &lt;code&gt;TYPE 'DoubleRep&lt;/code&gt;. These kinds say that the runtime representation of an &lt;code&gt;Int#&lt;/code&gt; is a machine integer, and the runtime representation of a &lt;code&gt;Double#&lt;/code&gt; is a machine double-precision floating point. In contrast, the kind &lt;code&gt;Type&lt;/code&gt; is actually just a synonym for &lt;code&gt;TYPE
'LiftedRep&lt;/code&gt;. More details of the &lt;code&gt;TYPE&lt;/code&gt; mechanisms appear in the &lt;a href=&quot;#runtime-rep&quot;&gt;section on runtime representation polymorphism&lt;/a&gt;.</source>
          <target state="translated">В отчете Haskell описывается, что &lt;code&gt;*&lt;/code&gt; (пишется &lt;code&gt;Type&lt;/code&gt; и импортировано из &lt;code&gt;Data.Kind&lt;/code&gt; на диалекте GHC Haskell) является видом обычных типов данных, таких как &lt;code&gt;Int&lt;/code&gt; . Более того, конструкторы типов могут иметь виды со стрелками; например, &lt;code&gt;Maybe&lt;/code&gt; имеет вид &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; . Распакованные типы имеют вид, определяющий их представление во время выполнения. Например, тип &lt;code&gt;Int#&lt;/code&gt; имеет вид &lt;code&gt;TYPE 'IntRep&lt;/code&gt; , а тип &lt;code&gt;Double#&lt;/code&gt; имеет вид &lt;code&gt;TYPE 'DoubleRep&lt;/code&gt; . Эти типы говорят, что представление среды выполнения &lt;code&gt;Int#&lt;/code&gt; является машинным целым числом, а представление среды выполнения &lt;code&gt;Double#&lt;/code&gt; - это машина с плавающей запятой двойной точности. Напротив, вид &lt;code&gt;Type&lt;/code&gt; на самом деле является синонимом &lt;code&gt;TYPE 'LiftedRep&lt;/code&gt; . Более подробная информация о механизмах &lt;code&gt;TYPE&lt;/code&gt; представлена ​​в &lt;a href=&quot;#runtime-rep&quot;&gt;разделе, посвященном полиморфизму представления среды выполнения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ffc08730dc1e1e7dc18e8e0b58ddcb43b8e6870" translate="yes" xml:space="preserve">
          <source>The Haskell Report is vague about exactly when a &lt;code&gt;deriving&lt;/code&gt; clause is legal. For example:</source>
          <target state="translated">В отчете Haskell неясно, когда именно &lt;code&gt;deriving&lt;/code&gt; предложение является законным. Например:</target>
        </trans-unit>
        <trans-unit id="5dd54d84f1861492e330313f2bf345ca47769e1b" translate="yes" xml:space="preserve">
          <source>The Haskell Report specifies that a group of bindings (at top level, or in a &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt;) should be sorted into strongly-connected components, and then type-checked in dependency order (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.1&quot;&gt;Haskell Report, Section 4.5.1&lt;/a&gt;). As each group is type-checked, any binders of the group that have an explicit type signature are put in the type environment with the specified polymorphic type, and all others are monomorphic until the group is generalised (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.2&quot;&gt;Haskell Report, Section 4.5.2&lt;/a&gt;).</source>
          <target state="translated">В отчете Haskell указано, что группа привязок (на верхнем уровне, в &lt;code&gt;let&lt;/code&gt; или &lt;code&gt;where&lt;/code&gt; ) должна быть отсортирована по сильно связанным компонентам, а затем проверяться типом в порядке зависимости ( &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.1&quot;&gt;Отчет Haskell, раздел 4.5.1&lt;/a&gt; ). Поскольку каждая группа проверяется на тип, любые связующие группы, которые имеют явную сигнатуру типа, помещаются в среду типов с указанным полиморфным типом, а все остальные являются мономорфными до тех пор, пока группа не будет обобщена ( &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.2&quot;&gt;Отчет Haskell, раздел 4.5.2&lt;/a&gt; ) ,</target>
        </trans-unit>
        <trans-unit id="f79c4bbad9a41e128d187b8c2ef86a8f611b12b5" translate="yes" xml:space="preserve">
          <source>The Haskell code in a package may be built into one or more archive libraries (e.g. &lt;code&gt;libHSfoo.a&lt;/code&gt;), or a single shared object (e.g. &lt;code&gt;libHSfoo.dll/.so/.dylib&lt;/code&gt;). The restriction to a single shared object is because the package system is used to tell the compiler when it should make an inter-shared-object call rather than an intra-shared-object-call call (inter-shared-object calls require an extra indirection).</source>
          <target state="translated">Код Haskell в пакете может быть встроен в одну или несколько архивных библиотек (например, &lt;code&gt;libHSfoo.a&lt;/code&gt; ) или один общий объект (например, &lt;code&gt;libHSfoo.dll/.so/.dylib&lt;/code&gt; ). Ограничение для одного общего объекта связано с тем, что система пакетов используется для того, чтобы сообщить компилятору, когда он должен выполнить вызов между общим объектом, а не вызов внутри общего объекта (вызовы между общими объектами требуют дополнительных Косвенная).</target>
        </trans-unit>
        <trans-unit id="0c75300a05da2e87e80a93270dd95d3e5ff6d9a5" translate="yes" xml:space="preserve">
          <source>The Haskell implementation with which the program was compiled or is being interpreted.</source>
          <target state="translated">Реализация Haskell,с помощью которой программа была скомпилирована или интерпретируется.</target>
        </trans-unit>
        <trans-unit id="29f87244b686c50c8127fd2dc9c33f53eb1c0ecb" translate="yes" xml:space="preserve">
          <source>The Haskell report &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;defines&lt;/a&gt; the &lt;code&gt;lexp&lt;/code&gt; nonterminal thus (&lt;code&gt;*&lt;/code&gt; indicates a rule of interest):</source>
          <target state="translated">Отчет Haskell &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;определяет&lt;/a&gt; в &lt;code&gt;lexp&lt;/code&gt; нетерминальное таким образом ( &lt;code&gt;*&lt;/code&gt; указывает правило интереса):</target>
        </trans-unit>
        <trans-unit id="75d99185af7621d262f47061ebc9fcce26c3d99a" translate="yes" xml:space="preserve">
          <source>The Haskell2010 Report specifies in &amp;lt;&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&lt;/a&gt;&amp;gt; that</source>
          <target state="translated">Отчет Haskell2010 указывает в &amp;lt; &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&lt;/a&gt; &amp;gt;, что</target>
        </trans-unit>
        <trans-unit id="18dcf9c1fa4567e3d746274c7c15cc6b75881bbb" translate="yes" xml:space="preserve">
          <source>The IO monad</source>
          <target state="translated">Монада ввода-вывода</target>
        </trans-unit>
        <trans-unit id="fc0f546679107f369d6f8715d864a3e34b5c091c" translate="yes" xml:space="preserve">
          <source>The IOArray type</source>
          <target state="translated">Тип IOArray</target>
        </trans-unit>
        <trans-unit id="737d5b10a286b500beaf74123af646266a400fbd" translate="yes" xml:space="preserve">
          <source>The IOMode type</source>
          <target state="translated">Тип IOMode</target>
        </trans-unit>
        <trans-unit id="65b73403a619cdf0ecd51edadceb4eff94590c0c" translate="yes" xml:space="preserve">
          <source>The IORef type</source>
          <target state="translated">Тип IORef</target>
        </trans-unit>
        <trans-unit id="558e32d8065fb827c731043184d460a503306a06" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding.</source>
          <target state="translated">Кодировка ISO / IEC 8859-1 - это 8-битная кодировка, часто известная как Latin-1. &lt;em&gt;Char8&lt;/em&gt; кодирование реализовано здесь работает усечение Unicode в элементе кода 8 бит и кодировании их в виде одного байта. Для кодовых точек 0-255 это соответствует кодировке ISO / IEC 8859-1.</target>
        </trans-unit>
        <trans-unit id="54ad98c5ffd0b94e42a9d57326f087c3d7345412" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding. Note that the Char8 encoding is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with Char8 encoded characters.</source>
          <target state="translated">Кодировка ISO / IEC 8859-1 - это 8-битная кодировка, часто известная как Latin-1. &lt;em&gt;Char8&lt;/em&gt; кодирование реализовано здесь работает усечение Unicode в элементе кода 8 бит и кодировании их в виде одного байта. Для кодовых точек 0-255 это соответствует кодировке ISO / IEC 8859-1. Обратите внимание, что кодировка Char8 эквивалентна кодировке ASCII в кодовых точках Unicode 0&amp;ndash;127. Следовательно, такие функции, как &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; , также могут использоваться для кодирования &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; как десятичного числа с закодированными символами Char8.</target>
        </trans-unit>
        <trans-unit id="c479ee79f8f50aa3dcf64e97781e845a99daa98d" translate="yes" xml:space="preserve">
          <source>The InputT monad transformer</source>
          <target state="translated">Трансформатор InputT monad</target>
        </trans-unit>
        <trans-unit id="f02dbfae6923c5fae8b765773db367457b1cef47" translate="yes" xml:space="preserve">
          <source>The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to the first 256 Unicode code points, and is thus not a complete Unicode encoding. An attempt to write a character greater than &lt;code&gt;'\255'&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; encoding will result in an error.</source>
          <target state="translated">Кодировка Latin1 (ISO8859-1). Эта кодировка отображает байты непосредственно в первые 256 кодовых точек Unicode и, таким образом, не является полной кодировкой Unicode. Попытка написать Greater характер , чем &lt;code&gt;'\255'&lt;/code&gt; с &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; с использованием &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; кодирования приведет к ошибке.</target>
        </trans-unit>
        <trans-unit id="ddf2c2b44bf1b6f9d563c7f3800d62394c65a764" translate="yes" xml:space="preserve">
          <source>The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to the first 256 Unicode code points, and is thus not a complete Unicode encoding. An attempt to write a character greater than &lt;code&gt;'\255'&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; encoding will result in an error.</source>
          <target state="translated">Кодировка Latin1 (ISO8859-1). Эта кодировка отображает байты непосредственно в первые 256 кодовых точек Unicode и, таким образом, не является полной кодировкой Unicode. Попытка написать Greater характер , чем &lt;code&gt;'\255'&lt;/code&gt; с &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; с использованием &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; кодирования приведет к ошибке.</target>
        </trans-unit>
        <trans-unit id="680f8c637bf3c21d4334aa840c68f7b1c0426e80" translate="yes" xml:space="preserve">
          <source>The List data type and its operations</source>
          <target state="translated">Тип данных Перечня и его операции</target>
        </trans-unit>
        <trans-unit id="527e8dadea35f6a4f5c4a4c4be123089c5e69c00" translate="yes" xml:space="preserve">
          <source>The List monad.</source>
          <target state="translated">Монада Списка.</target>
        </trans-unit>
        <trans-unit id="8aba302b7e58fc590a9afdc1a01080baae6e6ec1" translate="yes" xml:space="preserve">
          <source>The ListT monad transformer</source>
          <target state="translated">Трансформатор ListT monad</target>
        </trans-unit>
        <trans-unit id="ba07cd406a34170d4f0ecfa83e506b98d6f30534" translate="yes" xml:space="preserve">
          <source>The ListT monad transformer, adding backtracking to a given monad, which must be commutative.</source>
          <target state="translated">Трансформатор ListT monad,добавляющий обратное движение к заданной монаде,которое должно быть коммутативным.</target>
        </trans-unit>
        <trans-unit id="e0495cc6e831dd99a09b6b22275801501a83fb2b" translate="yes" xml:space="preserve">
          <source>The MVar type</source>
          <target state="translated">Тип MVar</target>
        </trans-unit>
        <trans-unit id="46396b237f9d18bcd799cea896a2640dfd6df348" translate="yes" xml:space="preserve">
          <source>The Maybe type, and associated operations.</source>
          <target state="translated">Тип &quot;Может быть&quot; и связанные с ним операции.</target>
        </trans-unit>
        <trans-unit id="e744e9e0cfe46515ef9f5bb52e48c6c750bbb1e5" translate="yes" xml:space="preserve">
          <source>The MaybeT monad transformer</source>
          <target state="translated">Трансформатор MaybeT monad</target>
        </trans-unit>
        <trans-unit id="4126903c0c38cb737f94266782af2c525510b404" translate="yes" xml:space="preserve">
          <source>The Modified Julian Date is the day with the fraction of the day, measured from UT midnight. It's used to represent UT1, which is time as measured by the earth's rotation, adjusted for various wobbles.</source>
          <target state="translated">Модифицированная юлианская дата-это день с долей дня,измеренной от полночи UT.Она используется для представления UT1,то есть времени,измеряемого вращением Земли,скорректированного для различных колебаний.</target>
        </trans-unit>
        <trans-unit id="d4fd231b0228fbbb56527d9186f84060d50a59d7" translate="yes" xml:space="preserve">
          <source>The Modified Julian Day is a standard count of days, with zero being the day 1858-11-17.</source>
          <target state="translated">Модифицированный юлианский день-это стандартный счетчик дней,ноль-день 1858-11-17.</target>
        </trans-unit>
        <trans-unit id="c771c28ba6943eb0fbd701bba8effdfe529aa2b4" translate="yes" xml:space="preserve">
          <source>The MonadException class</source>
          <target state="translated">Класс MonadException</target>
        </trans-unit>
        <trans-unit id="ad32074e930158647c5d3c0d66a82e352b9530f7" translate="yes" xml:space="preserve">
          <source>The MonadWriter class.</source>
          <target state="translated">Класс MonadWriter.</target>
        </trans-unit>
        <trans-unit id="b01bbf48e477c92aa3644550cb6f1cc37d1a0b1f" translate="yes" xml:space="preserve">
          <source>The Monomorphism Restriction is disabled (see &lt;a href=&quot;glasgow_exts#monomorphism&quot;&gt;Switching off the dreaded Monomorphism Restriction&lt;/a&gt;).</source>
          <target state="translated">Ограничение мономорфизма отключено (см. &lt;a href=&quot;glasgow_exts#monomorphism&quot;&gt;Отключение ужасного ограничения мономорфизма&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bfaad71abe81d69b989cc169fbd7881a4139c40a" translate="yes" xml:space="preserve">
          <source>The NT kernel however allows you ways to opt out of this path preprocessing by the Win32 APIs. This is done by explicitly using the desired namespace in the path.</source>
          <target state="translated">Ядро NT,тем не менее,позволяет отказаться от препроцессирования этого пути Win32 API.Это делается явным образом с помощью желаемого пространства имён в пути.</target>
        </trans-unit>
        <trans-unit id="c3d1ffc3dd3f40f1c222c841f95386202d3f7d9c" translate="yes" xml:space="preserve">
          <source>The Package Versioning Policy &lt;strong&gt;does not apply&lt;/strong&gt;.</source>
          <target state="translated">Политика управления версиями пакетов &lt;strong&gt;не применяется&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7577997f2b7e95327e240c7fc768c6dc92772fe1" translate="yes" xml:space="preserve">
          <source>The Paterson Conditions: for each class constraint &lt;code&gt;(C t1 ... tn)&lt;/code&gt; in the context</source>
          <target state="translated">Условия Патерсона: для каждого ограничения класса &lt;code&gt;(C t1 ... tn)&lt;/code&gt; в контексте</target>
        </trans-unit>
        <trans-unit id="7329aa4547685d3c70bea0407e898afb0b679e44" translate="yes" xml:space="preserve">
          <source>The Prelude: a standard module. The Prelude is imported by default into all Haskell modules unless either there is an explicit import statement for it, or the NoImplicitPrelude extension is enabled.</source>
          <target state="translated">Прелюдия:стандартный модуль.Прелюдия импортируется по умолчанию во все модули Haskell,если только для нее не задан явный импорт,или не включено расширение NoImplicitPrelude.</target>
        </trans-unit>
        <trans-unit id="0aa2000b932cfb04e1a3bcd9c14b88cf13e1335d" translate="yes" xml:space="preserve">
          <source>The Put monad</source>
          <target state="translated">The Put monad</target>
        </trans-unit>
        <trans-unit id="e6d4dd4f8b3be3cd5b857fe2de8ff602061f0af6" translate="yes" xml:space="preserve">
          <source>The Put monad. A monad for efficiently constructing lazy bytestrings.</source>
          <target state="translated">&quot;Put monad&quot;.Монада для эффективного построения ленивых байтстрингов.</target>
        </trans-unit>
        <trans-unit id="859037e4eda9b5b2f4fe55e78c68c20d023080cf" translate="yes" xml:space="preserve">
          <source>The Put type</source>
          <target state="translated">Тип &quot;Put</target>
        </trans-unit>
        <trans-unit id="ab5819377a02005c251c02732e301195c27a0049" translate="yes" xml:space="preserve">
          <source>The PutM type. A Writer monad over the efficient Builder monoid.</source>
          <target state="translated">Тип PutM.Монада Писателя над эффективным моноидом Строителя.</target>
        </trans-unit>
        <trans-unit id="2354aa5ff6e1c2d9885153e78ccf38e4f0365e83" translate="yes" xml:space="preserve">
          <source>The RTS has a lot of options to control its behaviour. For example, you can change the context-switch interval, the default size of the heap, and enable heap profiling. These options can be passed to the runtime system in a variety of different ways; the next section (&lt;a href=&quot;#setting-rts-options&quot;&gt;Setting RTS options&lt;/a&gt;) describes the various methods, and the following sections describe the RTS options themselves.</source>
          <target state="translated">У RTS есть много возможностей контролировать свое поведение. Например, вы можете изменить интервал переключения контекста, размер кучи по умолчанию и включить профилирование кучи. Эти параметры могут быть переданы системе времени выполнения множеством различных способов; в следующем разделе ( &lt;a href=&quot;#setting-rts-options&quot;&gt;Настройка параметров RTS&lt;/a&gt; ) описаны различные методы, а в следующих разделах описаны сами параметры RTS.</target>
        </trans-unit>
        <trans-unit id="80255d167f12c27a3ea54ce8b0bd00039dbf82da" translate="yes" xml:space="preserve">
          <source>The RTS options related to concurrency are described in &lt;a href=&quot;using-concurrent#using-concurrent&quot;&gt;Using Concurrent Haskell&lt;/a&gt;, and those for parallelism in &lt;a href=&quot;using-concurrent#parallel-options&quot;&gt;RTS options for SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">Параметры RTS, связанные с параллелизмом, описаны в &lt;a href=&quot;using-concurrent#using-concurrent&quot;&gt;разделе Использование параллельного Haskell&lt;/a&gt; , а параметры параллелизма - в &lt;a href=&quot;using-concurrent#parallel-options&quot;&gt;параметрах RTS для параллелизма SMP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5bb8ad1fb09a839ecffde8ca34b94bdfdcd8b691" translate="yes" xml:space="preserve">
          <source>The RTS will snaffle &lt;code&gt;-H32m -S&lt;/code&gt; for itself, and the remaining arguments &lt;code&gt;-f -h foo bar&lt;/code&gt; will be available to your program if/when it calls &lt;code&gt;System.Environment.getArgs&lt;/code&gt;.</source>
          <target state="translated">RTS &lt;code&gt;-H32m -S&lt;/code&gt; для себя -H32m -S , а остальные аргументы &lt;code&gt;-f -h foo bar&lt;/code&gt; будут доступны вашей программе, если / когда она &lt;code&gt;System.Environment.getArgs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e88b8846d8fe73958229f97485a69a53155ce170" translate="yes" xml:space="preserve">
          <source>The RULES mechanism is used to implement fusion (deforestation) of common list functions. If a &amp;ldquo;good consumer&amp;rdquo; consumes an intermediate list constructed by a &amp;ldquo;good producer&amp;rdquo;, the intermediate list should be eliminated entirely.</source>
          <target state="translated">Механизм ПРАВИЛА используется для реализации слияния (обезлесения) общих функций списков. Если &amp;laquo;хороший потребитель&amp;raquo; потребляет промежуточный список, составленный &amp;laquo;хорошим производителем&amp;raquo;, промежуточный список следует полностью исключить.</target>
        </trans-unit>
        <trans-unit id="91cc01216a24ea0cf70d53ce6831cdfd22c4c1ae" translate="yes" xml:space="preserve">
          <source>The RWS monad</source>
          <target state="translated">RWS monad</target>
        </trans-unit>
        <trans-unit id="3030e059d51b47652080afc1bf3e87a96b72964b" translate="yes" xml:space="preserve">
          <source>The RWST monad transformer</source>
          <target state="translated">Трансформатор RWST monad</target>
        </trans-unit>
        <trans-unit id="17d69ac471ca747fe3aa42940b683d831a9ef452" translate="yes" xml:space="preserve">
          <source>The Reader monad</source>
          <target state="translated">Монада Ридер</target>
        </trans-unit>
        <trans-unit id="3aea66391daa03b9cc14c2b409c118ef8792ac2b" translate="yes" xml:space="preserve">
          <source>The ReaderT monad transformer</source>
          <target state="translated">Трансформатор ReaderT monad</target>
        </trans-unit>
        <trans-unit id="7b28758084e7661741da61d05acfec540a63dcd6" translate="yes" xml:space="preserve">
          <source>The STM implementation will abort transactions that are known to be invalid and need to be restarted. This may happen in the middle of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt;, so make sure you don't acquire any resources that need releasing (exception handlers are ignored when aborting the transaction). That includes doing any IO using Handles, for example. Getting this wrong will probably lead to random deadlocks.</source>
          <target state="translated">Реализация STM прервет транзакции, о которых известно, что они недействительны и которые необходимо перезапустить. Это может произойти в середине &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; , поэтому убедитесь, что вы не приобрели какие-либо ресурсы, которые нужно освободить (обработчики исключений игнорируются при прерывании транзакции). Это включает, например, выполнение любого ввода-вывода с использованием дескрипторов. Неправильный ответ, вероятно, приведет к случайным тупикам.</target>
        </trans-unit>
        <trans-unit id="a93c60619a7c26a3aaea050cc64323b106e6a10f" translate="yes" xml:space="preserve">
          <source>The STM implementation will abort transactions that are known to be invalid and need to be restarted. This may happen in the middle of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt;, so make sure you don't acquire any resources that need releasing (exception handlers are ignored when aborting the transaction). That includes doing any IO using Handles, for example. Getting this wrong will probably lead to random deadlocks.</source>
          <target state="translated">Реализация STM прервет транзакции, о которых известно, что они недействительны и которые необходимо перезапустить. Это может произойти в середине &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; , поэтому убедитесь, что вы не приобрели какие-либо ресурсы, которые нужно освободить (обработчики исключений игнорируются при прерывании транзакции). Это включает, например, выполнение любого ввода-вывода с использованием дескрипторов. Неправильный ответ, вероятно, приведет к случайным тупикам.</target>
        </trans-unit>
        <trans-unit id="a466c95f7705b8667d496c8cad7e2978bbeba71b" translate="yes" xml:space="preserve">
          <source>The STM implementation will often run transactions multiple times, so you need to be prepared for this if your IO has any side effects.</source>
          <target state="translated">Реализация STM часто приводит к многократному запуску транзакций,поэтому вам необходимо быть готовым к этому,если у вашего ввода-вывода есть какие-либо побочные эффекты.</target>
        </trans-unit>
        <trans-unit id="d2c9be55e3be898cad081ed8cc787cc2dc0d8adc" translate="yes" xml:space="preserve">
          <source>The Safe Haskell &lt;em&gt;safe language&lt;/em&gt; (enabled by &lt;code&gt;-XSafe&lt;/code&gt;) guarantees the following properties:</source>
          <target state="translated">Безопасный &lt;em&gt;язык&lt;/em&gt; Safe Haskell (включенный &lt;code&gt;-XSafe&lt;/code&gt; ) гарантирует следующие свойства:</target>
        </trans-unit>
        <trans-unit id="7726729f19e0da000e83c79bcb8c28c6f385ffcb" translate="yes" xml:space="preserve">
          <source>The Safe Haskell checks can be disabled for a module by passing the &lt;a href=&quot;#ghc-flag--fno-safe-haskell&quot;&gt;&lt;code&gt;-fno-safe-haskell&lt;/code&gt;&lt;/a&gt; flag. This is useful in particular when compiling with source plugins as running a plugin marks the module as unsafe and can then cause downstream modules to fail the safety checks.</source>
          <target state="translated">Проверки Safe Haskell можно отключить для модуля, передав &lt;a href=&quot;#ghc-flag--fno-safe-haskell&quot;&gt; &lt;code&gt;-fno-safe-haskell&lt;/code&gt; &lt;/a&gt; . Это полезно, в частности, при компиляции с исходными плагинами, так как запуск плагина помечает модуль как небезопасный и может затем привести к тому, что последующие модули не пройдут проверки безопасности.</target>
        </trans-unit>
        <trans-unit id="6da0062c345ab61160d26f605d07d936e53000f2" translate="yes" xml:space="preserve">
          <source>The Select monad</source>
          <target state="translated">The Select monad</target>
        </trans-unit>
        <trans-unit id="14b5bf3a399f4cac6f75470d51a3a0bae35be0f1" translate="yes" xml:space="preserve">
          <source>The SelectT monad transformer</source>
          <target state="translated">Трансформатор SelectT monad</target>
        </trans-unit>
        <trans-unit id="afb2b6e8a6ae40d8e5e247b3b17b072cba473176" translate="yes" xml:space="preserve">
          <source>The Signal type</source>
          <target state="translated">Тип сигнала</target>
        </trans-unit>
        <trans-unit id="34ca6ab89d0a5929502c3b8fda82f9d7a6d4db86" translate="yes" xml:space="preserve">
          <source>The State monad</source>
          <target state="translated">Государственный монадарь</target>
        </trans-unit>
        <trans-unit id="d1d93ac3a4f1be7a558b299c04132f8bd844f80f" translate="yes" xml:space="preserve">
          <source>The StateT monad transformer</source>
          <target state="translated">Трансформатор StateT monad</target>
        </trans-unit>
        <trans-unit id="38fd4995bb0200714fd098c99380c5ce19be4b0a" translate="yes" xml:space="preserve">
          <source>The TH state, created by &lt;code&gt;&lt;a href=&quot;ghci-th#v:startTH&quot;&gt;startTH&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Состояние TH, созданное &lt;code&gt;&lt;a href=&quot;ghci-th#v:startTH&quot;&gt;startTH&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2544b8736e584c3e40b611d6a80bea3cc2e2d77" translate="yes" xml:space="preserve">
          <source>The Typeable class</source>
          <target state="translated">Типовой класс</target>
        </trans-unit>
        <trans-unit id="406c428a778ef7125e193987bbac0237ab0511cd" translate="yes" xml:space="preserve">
          <source>The UTC time zone.</source>
          <target state="translated">Часовой пояс UTC.</target>
        </trans-unit>
        <trans-unit id="38141e622e2458972c46a5896fe7f4e01687679d" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (a byte-order-mark should be used to indicate endianness).</source>
          <target state="translated">Кодировка UTF-16 Unicode (для обозначения эндианности следует использовать знак байт-ордера).</target>
        </trans-unit>
        <trans-unit id="0cf0e68f8c740d3f43a6e8c8dbc14773e82bf3fb" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (big-endian)</source>
          <target state="translated">Юникодовая кодировка UTF-16 (big-endian)</target>
        </trans-unit>
        <trans-unit id="0e56b9ac4542ba5321237f8287ad2bf793fc3af5" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (litte-endian)</source>
          <target state="translated">UTF-16 Unicode кодировка (litte-endian)</target>
        </trans-unit>
        <trans-unit id="d34bf7d79b70b504d63dce6b7b58a8119636ec3c" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (a byte-order-mark should be used to indicate endianness).</source>
          <target state="translated">UTF-32 Unicode кодировка (для обозначения эндианности следует использовать знак байт-ордера).</target>
        </trans-unit>
        <trans-unit id="67dffc3f81adbd2d24a0516022167baf8bc86322" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (big-endian)</source>
          <target state="translated">UTF-32 Unicode кодировка (big-endian)</target>
        </trans-unit>
        <trans-unit id="e1d43f77fb169e84f01193e920df4b983c3368e9" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (litte-endian)</source>
          <target state="translated">UTF-32 Unicode кодировка (litte-endian)</target>
        </trans-unit>
        <trans-unit id="52589abf36edd4349a64f7d5395f328f8a947920" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding</source>
          <target state="translated">UTF-8 кодировка Юникода</target>
        </trans-unit>
        <trans-unit id="a005af9557a056326c8b8d7c97a47bc28391bd3b" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte sequence 0xEF 0xBB 0xBF). This encoding behaves like &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;, except that on input, the BOM sequence is ignored at the beginning of the stream, and on output, the BOM sequence is prepended.</source>
          <target state="translated">Кодировка Unicode UTF-8 с отметкой порядка байтов (BOM; последовательность байтов 0xEF 0xBB 0xBF). Эта кодировка ведет себя как &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; , за исключением того, что на входе последовательность BOM игнорируется в начале потока, а на выходе последовательность BOM добавляется в начало.</target>
        </trans-unit>
        <trans-unit id="eaf74031b27da65f642c604ade4f47115637843c" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte sequence 0xEF 0xBB 0xBF). This encoding behaves like &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;, except that on input, the BOM sequence is ignored at the beginning of the stream, and on output, the BOM sequence is prepended.</source>
          <target state="translated">Кодировка Unicode UTF-8 с отметкой порядка байтов (BOM; последовательность байтов 0xEF 0xBB 0xBF). Эта кодировка ведет себя как &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; , за исключением того, что на входе последовательность BOM игнорируется в начале потока, а на выходе последовательность BOM добавляется в начало.</target>
        </trans-unit>
        <trans-unit id="48a72567fd36d1b77865bf4ea3a5534e90bd33c8" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode &lt;em&gt;all&lt;/em&gt; Unicode codepoints. We recommend using it always for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s unless an application really requires another encoding.</source>
          <target state="translated">Кодировка UTF-8 может кодировать &lt;em&gt;все&lt;/em&gt; кодовые точки Unicode. Мы рекомендуем всегда использовать его для кодирования &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , если приложению действительно не требуется другая кодировка.</target>
        </trans-unit>
        <trans-unit id="d524833742212d693f8a7a1356f8aab1e3718c22" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode all Unicode codepoints. It is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with UTF-8 encoded characters.</source>
          <target state="translated">Кодировка UTF-8 может кодировать все кодовые точки Unicode. Это эквивалентно кодировке ASCII в кодовых точках Unicode 0&amp;ndash;127. Следовательно, такие функции, как &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; , также могут использоваться для кодирования &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; как десятичного числа с символами в кодировке UTF-8.</target>
        </trans-unit>
        <trans-unit id="09093313f0f91c4b5737ad4a0fbe7d06eea9ee26" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale</source>
          <target state="translated">Юникодовая кодировка текущей локали</target>
        </trans-unit>
        <trans-unit id="3f137dd2773a7b21ca2a1977bcffe06a49397773" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale, but allowing arbitrary undecodable bytes to be round-tripped through it.</source>
          <target state="translated">Юникодовая кодировка текущей локали,но с возможностью округления через нее произвольных нераспознаваемых байтов.</target>
        </trans-unit>
        <trans-unit id="939eaac913afcf37c06343e0dee5a39351f12362" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale, but where undecodable bytes are replaced with their closest visual match. Used for the &lt;code&gt;&lt;a href=&quot;foreign-c-string#v:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; marshalling functions in &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt;</source>
          <target state="translated">Кодировка Unicode для текущей локали, но в которой не декодируемые байты заменяются их ближайшим визуальным соответствием. Используется для функций маршалинга &lt;code&gt;&lt;a href=&quot;foreign-c-string#v:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; в &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94c16bb05159c06fe3dc812d48c81e471e6e3efb" translate="yes" xml:space="preserve">
          <source>The Unicode general category of the character. This relies on the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;, which must remain in the same order as the categories are presented in the Unicode standard.</source>
          <target state="translated">Общая категория символа Unicode. Это зависит от экземпляра &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; класса &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; , который должен оставаться в том же порядке, что и категории, представленные в стандарте Unicode.</target>
        </trans-unit>
        <trans-unit id="68e199523a1fa0fa41372e425d662a0ca937ad92" translate="yes" xml:space="preserve">
          <source>The Unicode general category of the character. This relies on the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;, which must remain in the same order as the categories are presented in the Unicode standard.</source>
          <target state="translated">Общая категория символа Unicode. Это зависит от экземпляра &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; класса &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; , который должен оставаться в том же порядке, что и категории, представленные в стандарте Unicode.</target>
        </trans-unit>
        <trans-unit id="461ca2fc00cd995c7e6980fa43df6ef7503d97ca" translate="yes" xml:space="preserve">
          <source>The Windows directory</source>
          <target state="translated">Каталог Windows</target>
        </trans-unit>
        <trans-unit id="a88998b1d185995bfddbae32ddd00452270da2ae" translate="yes" xml:space="preserve">
          <source>The Writer monad</source>
          <target state="translated">Монада писателей</target>
        </trans-unit>
        <trans-unit id="0f31095d17e6be1b28728b97a802ce50d67ad701" translate="yes" xml:space="preserve">
          <source>The WriterT monad transformer</source>
          <target state="translated">Трансформатор WriterT monad</target>
        </trans-unit>
        <trans-unit id="e564641fef849b7748c52b9e3bbf79b098ce5698" translate="yes" xml:space="preserve">
          <source>The ability to &lt;em&gt;inherit&lt;/em&gt; required signatures from packages we depend upon, combining the signatures into a single merged signature which reflects the requirements of any locally defined signature, as well as the requirements of our dependencies.</source>
          <target state="translated">Возможность &lt;em&gt;наследовать&lt;/em&gt; необходимые подписи от пакетов, от которых мы зависим, объединяя подписи в единую объединенную подпись, которая отражает требования любой локально определенной подписи, а также требования наших зависимостей.</target>
        </trans-unit>
        <trans-unit id="7dbeb7f19d92db3db611e99643a65e9afeeb3443" translate="yes" xml:space="preserve">
          <source>The ability to define an &lt;code&gt;hsig&lt;/code&gt; file, containing type definitions and type signature for values which can be used by modules that import the signature, and must be provided by the eventual implementing module, and</source>
          <target state="translated">Возможность определения файла &lt;code&gt;hsig&lt;/code&gt; , содержащего определения типов и сигнатуру типа для значений, которые могут использоваться модулями, импортирующими сигнатуру, и должны предоставляться конечным модулем реализации, и</target>
        </trans-unit>
        <trans-unit id="e18a26f623d4b3d5b0afaeca9ff88864b2448314" translate="yes" xml:space="preserve">
          <source>The ability to set a breakpoint on a function definition or expression in the program. When the function is called, or the expression evaluated, GHCi suspends execution and returns to the prompt, where you can inspect the values of local variables before continuing with the execution.</source>
          <target state="translated">Возможность установки точки останова на определении или выражении функции в программе.При вызове функции или вычислении выражения GHCi приостанавливает выполнение и возвращается к подсказке,где можно проверить значения локальных переменных перед продолжением выполнения.</target>
        </trans-unit>
        <trans-unit id="310f755673bc29e8cd19bd1e50c2672bd0ba64a5" translate="yes" xml:space="preserve">
          <source>The above code is equivalent to:</source>
          <target state="translated">Вышеуказанный код эквивалентен:</target>
        </trans-unit>
        <trans-unit id="ceb853b961139ea8a430dce957f73b5c77a03245" translate="yes" xml:space="preserve">
          <source>The above declaration (which requires the language pragma &lt;code&gt;DeriveGeneric&lt;/code&gt;) causes the following representation to be generated:</source>
          <target state="translated">Вышеупомянутое объявление (которое требует языковой &lt;code&gt;DeriveGeneric&lt;/code&gt; ) вызывает создание следующего представления:</target>
        </trans-unit>
        <trans-unit id="124bdbaef2420b9e89592fec3e57e81f0de35ec8" translate="yes" xml:space="preserve">
          <source>The above declaration causes the following representation to be generated:</source>
          <target state="translated">Приведенная выше декларация вызывает следующее представление:</target>
        </trans-unit>
        <trans-unit id="f76366168215856429247956c4826993833306ed" translate="yes" xml:space="preserve">
          <source>The above definition of trust has an issue. Any module can be compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; and it will be trusted. To control this, there is an additional definition of package trust (enabled with the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag). The point of package trust is to require that the client C explicitly say which packages are allowed to contain trustworthy modules. Trustworthy packages are only trusted if they reside in a package trusted by C.</source>
          <target state="translated">Приведенное выше определение доверия имеет проблему. Любой модуль можно скомпилировать с помощью &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; ,&lt;/a&gt; и ему будут доверять. Чтобы контролировать это, существует дополнительное определение доверия пакетов (включается &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; ). Точка доверия пакетов состоит в том, чтобы потребовать, чтобы клиент C явно указывал, какие пакеты могут содержать надежные модули. Надежным пакетам можно доверять, только если они находятся в пакете, которому доверяет C.</target>
        </trans-unit>
        <trans-unit id="2df7fb2c193365ff646472a721e6b7dbe5bf63ae" translate="yes" xml:space="preserve">
          <source>The above function takes a strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; supposed to represent Base64 encoded data and the current decoding state. It writes the decoded bytes as the side-effect of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; and returns the new decoding state, if the decoding of all data in the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; was successful. The checking if the strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; represents Base64 encoded data and the actual decoding are fused. This makes the common case, where all data represents Base64 encoded data, more efficient. It also implies that all data must be decoded before the final decoding state can be returned. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are intended for implementing such fused checking and decoding/encoding, which is reflected in their strictness properties.</source>
          <target state="translated">Вышеупомянутая функция принимает строгую &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ,которая должна представлять данные в кодировке Base64 и текущее состояние декодирования. Он записывает декодированные байты как побочный эффект &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; и возвращает новое состояние декодирования, если декодирование всех данных в &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; было успешным. Проверка того, представляет ли строгая &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; данные в кодировке Base64, и фактическое декодирование объединены. Это делает более эффективным общий случай, когда все данные представляют данные в кодировке Base64. Это также подразумевает, что все данные должны быть декодированы до того, как можно будет вернуть окончательное состояние декодирования. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; предназначены для реализации такой объединенной проверки и декодирования / кодирования, что отражается в их свойствах строгости.</target>
        </trans-unit>
        <trans-unit id="0308489ed1646a7d427f7b348942d76c9c0d5d69" translate="yes" xml:space="preserve">
          <source>The above informal specification is fine for simple situations, but matters can get complicated. In particular, it needs to be clear exactly when a key dies, so that any weak pointers that refer to it can be finalized. Suppose, for example, the value of one weak pointer refers to the key of another...does that keep the key alive?</source>
          <target state="translated">Вышеприведенная неофициальная спецификация подойдет для простых ситуаций,но вопросы могут усложниться.В частности,необходимо четко указывать,когда ключ умирает,чтобы можно было завершить работу над любыми слабыми точками,которые на него ссылаются.Предположим,например,что значение одного слабого указателя относится к ключу другого...сохраняет ли это значение ключ?</target>
        </trans-unit>
        <trans-unit id="2361448fcf86f9607ed9aa3c2d047337ebd0125c" translate="yes" xml:space="preserve">
          <source>The above laws imply:</source>
          <target state="translated">Вышеуказанные законы подразумевают:</target>
        </trans-unit>
        <trans-unit id="6121e60b6f07d4583d6a2f3988fc1fab1e503635" translate="yes" xml:space="preserve">
          <source>The above will parse a string like &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt; and return a successful parse result &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt;. Compare against the below which will produce a result of &lt;code&gt;&quot;bbb&quot;&lt;/code&gt; for the same input:</source>
          <target state="translated">Вышеупомянутое будет анализировать строку типа &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt; и возвращать успешный результат синтаксического анализа &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt; . Сравните с приведенным ниже, которое даст результат &lt;code&gt;&quot;bbb&quot;&lt;/code&gt; для того же ввода:</target>
        </trans-unit>
        <trans-unit id="20d7c122429fa587037c0b158d78237d0e61f8fb" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">Абстрактный тип данных &lt;code&gt;ParseError&lt;/code&gt; представляет ошибки синтаксического анализа. Он предоставляет исходную позицию ( &lt;code&gt;&lt;a href=&quot;text-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ) ошибки и список сообщений об ошибках ( &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ). Ошибка &lt;code&gt;ParseError&lt;/code&gt; может быть возвращена функцией &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ParseError&lt;/code&gt; - это экземпляр классов &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2860dda2765620cbf0f468a55ba7b993da164fe3" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">Абстрактный тип данных &lt;code&gt;ParseError&lt;/code&gt; представляет ошибки синтаксического анализа. Он предоставляет исходную позицию ( &lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ) ошибки и список сообщений об ошибках ( &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ). Ошибка &lt;code&gt;ParseError&lt;/code&gt; может быть возвращена функцией &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ParseError&lt;/code&gt; - это экземпляр классов &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aab9864f2e792b8ac699847b4dbdbb4a77ea80ac" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">Абстрактный тип данных &lt;code&gt;ParseError&lt;/code&gt; представляет ошибки синтаксического анализа. Он предоставляет исходную позицию ( &lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ) ошибки и список сообщений об ошибках ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ). Ошибка &lt;code&gt;ParseError&lt;/code&gt; может быть возвращена функцией &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ParseError&lt;/code&gt; - это экземпляр классов &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="510da1eb070dd00ee03ec16a47305698f8cacdd9" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">Абстрактный тип данных &lt;code&gt;ParseError&lt;/code&gt; представляет ошибки синтаксического анализа. Он предоставляет исходную позицию ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ) ошибки и список сообщений об ошибках ( &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ). Ошибка &lt;code&gt;ParseError&lt;/code&gt; может быть возвращена функцией &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ParseError&lt;/code&gt; - это экземпляр классов &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de0533afad3f79319b3bf4b1fcb91b9bbdbc0565" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;SourcePos&lt;/code&gt; represents source positions. It contains the name of the source (i.e. file name), a line number and a column number. &lt;code&gt;SourcePos&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">Абстрактный тип данных &lt;code&gt;SourcePos&lt;/code&gt; представляет позиции источника. Он содержит имя источника (т.е. имя файла), номер строки и номер столбца. &lt;code&gt;SourcePos&lt;/code&gt; - это экземпляр классов &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4896de6a97029ad3c503ab35de30ebe552f9de1c" translate="yes" xml:space="preserve">
          <source>The abstract type of documents. A Doc represents a &lt;em&gt;set&lt;/em&gt; of layouts. A Doc with no occurrences of Union or NoDoc represents just one layout.</source>
          <target state="translated">Абстрактный тип документов. Документ представляет собой &lt;em&gt;набор&lt;/em&gt; макетов. Документ без использования Union или NoDoc представляет собой только один макет.</target>
        </trans-unit>
        <trans-unit id="a80b0e5c19c356bd9ef420910831b319cf81af79" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; causes any items buffered for output in handle &lt;code&gt;hdl&lt;/code&gt; to be sent immediately to the operating system.</source>
          <target state="translated">Действие &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; заставляет все элементы, буферизованные для вывода в дескрипторе &lt;code&gt;hdl&lt;/code&gt; , немедленно отправляться в операционную систему.</target>
        </trans-unit>
        <trans-unit id="ee59ce1aebad5edf7e6e4aaef4677f21c7eefc31" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlushAll&quot;&gt;hFlushAll&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; flushes all buffered data in &lt;code&gt;hdl&lt;/code&gt;, including any buffered read data. Buffered read data is flushed by seeking the file position back to the point before the bufferred data was read, and hence only works if &lt;code&gt;hdl&lt;/code&gt; is seekable (see &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Действие &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlushAll&quot;&gt;hFlushAll&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; очищает все буферизованные данные в &lt;code&gt;hdl&lt;/code&gt; , включая любые буферизованные данные чтения. Буферизованные данные чтения сбрасываются путем поиска позиции файла до точки до того, как буферизованные данные были прочитаны, и, следовательно, работает только в том случае, если &lt;code&gt;hdl&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt; поиска (см. HIsSeekable ).</target>
        </trans-unit>
        <trans-unit id="a371db2521146387741275550e657dffca505303" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt;&lt;code&gt;encoding&lt;/code&gt; changes the text encoding for the handle &lt;code&gt;hdl&lt;/code&gt; to &lt;code&gt;encoding&lt;/code&gt;. The default encoding when a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is created is &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt;, namely the default encoding for the current locale.</source>
          <target state="translated">Действие &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; &lt;code&gt;encoding&lt;/code&gt; изменяет кодировку текста для дескриптора &lt;code&gt;hdl&lt;/code&gt; на &lt;code&gt;encoding&lt;/code&gt; . Стандарт.кодировка когда &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; создается является &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; , а именно по умолчанию кодировку для текущей локали.</target>
        </trans-unit>
        <trans-unit id="2e5909c7d1c1b470eac7ec2d2a3d5f1c7a3e6b23" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; causes any items buffered for output in handle &lt;code&gt;hdl&lt;/code&gt; to be sent immediately to the operating system.</source>
          <target state="translated">Действие &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; заставляет все элементы, буферизованные для вывода в дескрипторе &lt;code&gt;hdl&lt;/code&gt; , немедленно отправляться в операционную систему.</target>
        </trans-unit>
        <trans-unit id="30e8a3b807220ec41770ad1fcda8f8906a927d36" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;system-io#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; causes any items buffered for output in handle &lt;code&gt;hdl&lt;/code&gt; to be sent immediately to the operating system.</source>
          <target state="translated">Действие &lt;code&gt;&lt;a href=&quot;system-io#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; заставляет все элементы, буферизованные для вывода в дескрипторе &lt;code&gt;hdl&lt;/code&gt; , немедленно отправляться в операционную систему.</target>
        </trans-unit>
        <trans-unit id="9c8d6d26b1ac4ce2c7a317b47737557b2e637055" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt;&lt;code&gt;encoding&lt;/code&gt; changes the text encoding for the handle &lt;code&gt;hdl&lt;/code&gt; to &lt;code&gt;encoding&lt;/code&gt;. The default encoding when a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is created is &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt;, namely the default encoding for the current locale.</source>
          <target state="translated">Действие &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; &lt;code&gt;encoding&lt;/code&gt; изменяет кодировку текста для дескриптора &lt;code&gt;hdl&lt;/code&gt; на &lt;code&gt;encoding&lt;/code&gt; . Стандарт.кодировка когда &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; создается является &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; , а именно по умолчанию кодировку для текущей локали.</target>
        </trans-unit>
        <trans-unit id="88ecb8776a874cfae1e583d670074ac14b0b3b9f" translate="yes" xml:space="preserve">
          <source>The action can handle the interrupt itself; a new &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt; exception will be thrown every time Ctrl-C is pressed.</source>
          <target state="translated">Действие может обрабатывать прерывание само; новое исключение &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt; будет генерироваться каждый раз при нажатии Ctrl-C.</target>
        </trans-unit>
        <trans-unit id="7c560f66ad19d0c44deb93f325922bbfa7a14cb7" translate="yes" xml:space="preserve">
          <source>The actions to perform when a signal is received.</source>
          <target state="translated">Действия,которые необходимо выполнить при получении сигнала.</target>
        </trans-unit>
        <trans-unit id="17c5e604d289acc48a4aeb8ca32b75ead60baded" translate="yes" xml:space="preserve">
          <source>The actual command line arguments (presumably got from &lt;code&gt;&lt;a href=&quot;system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Фактические аргументы командной строки (предположительно полученные от &lt;code&gt;&lt;a href=&quot;system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="51507a88f0049d4973537c6abea3ce2abf60b884" translate="yes" xml:space="preserve">
          <source>The actual meaning of the various columns in the output is:</source>
          <target state="translated">Фактическое значение различных столбцов на выходе:</target>
        </trans-unit>
        <trans-unit id="8d600203b76ff6ccdd7956053fbe52659d549a35" translate="yes" xml:space="preserve">
          <source>The advantage of smaller stack chunks is that the garbage collector can avoid traversing stack chunks if they are known to be unmodified since the last collection, so reducing the chunk size means that the garbage collector can identify more stack as unmodified, and the GC overhead might be reduced. On the other hand, making stack chunks too small adds some overhead as there will be more overflow/underflow between chunks. The default setting of 32k appears to be a reasonable compromise in most cases.</source>
          <target state="translated">Преимущество меньших кусков стопки состоит в том,что сборщик мусора может избежать обхода кусков стопки,если известно,что они немодифицированы с момента последнего сбора,поэтому уменьшение размера кусков означает,что сборщик мусора может идентифицировать большее количество кусков стопки как немодифицированные,и накладные расходы GC могут быть уменьшены.С другой стороны,уменьшение размеров стопки добавляет накладных расходов,так как между стопками будет происходить больше переполнения/переполнения.Установка по умолчанию 32k в большинстве случаев является разумным компромиссом.</target>
        </trans-unit>
        <trans-unit id="351839425c4046d1ef3e16ab0a651854e611c6da" translate="yes" xml:space="preserve">
          <source>The advantage of this is that the key can be retrieved by &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; in addition to the value.</source>
          <target state="translated">Преимущество этого в том, что ключ может быть &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; в дополнение к значению.</target>
        </trans-unit>
        <trans-unit id="51801fd153e97264561ce8060f8815074cf0359c" translate="yes" xml:space="preserve">
          <source>The alarm timer</source>
          <target state="translated">Таймер будильника</target>
        </trans-unit>
        <trans-unit id="e9de65a28b0e1c87c6c42bf35a90ef7382160962" translate="yes" xml:space="preserve">
          <source>The algebraic data types</source>
          <target state="translated">Алгебраические типы данных</target>
        </trans-unit>
        <trans-unit id="af0e67390188169e10bce1a919bdd538300c70aa" translate="yes" xml:space="preserve">
          <source>The algorithm for &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; is adapted from the &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; algorithm, but it generates definitions for &lt;code&gt;foldMap&lt;/code&gt;, &lt;code&gt;foldr&lt;/code&gt;, and &lt;code&gt;null&lt;/code&gt; instead of &lt;code&gt;fmap&lt;/code&gt;. In addition, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; filters out all constructor arguments on the RHS expression whose types do not mention the last type parameter, since those arguments do not need to be folded over.</source>
          <target state="translated">Алгоритм для &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; адаптирован из алгоритма &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; , но он генерирует определения для &lt;code&gt;foldMap&lt;/code&gt; , &lt;code&gt;foldr&lt;/code&gt; и &lt;code&gt;null&lt;/code&gt; вместо &lt;code&gt;fmap&lt;/code&gt; . Кроме того, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; отфильтровывает все аргументы конструктора в выражении RHS, типы которых не упоминают последний параметр типа, поскольку эти аргументы не нужно складывать.</target>
        </trans-unit>
        <trans-unit id="606c23fd4a39d6f5da98fdda576dd31c1413daef" translate="yes" xml:space="preserve">
          <source>The algorithm for &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; is adapted from the &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; algorithm, but it generates a definition for &lt;code&gt;traverse&lt;/code&gt; instead of &lt;code&gt;fmap&lt;/code&gt;. In addition, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; filters out all constructor arguments on the RHS expression whose types do not mention the last type parameter, since those arguments do not produce any effects in a traversal.</source>
          <target state="translated">Алгоритм для &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; адаптирован из алгоритма &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; , но он генерирует определение для &lt;code&gt;traverse&lt;/code&gt; вместо &lt;code&gt;fmap&lt;/code&gt; . Кроме того, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; отфильтровывает все аргументы конструктора в выражении RHS, типы которых не упоминают последний параметр типа, поскольку эти аргументы не производят никаких эффектов при обходе.</target>
        </trans-unit>
        <trans-unit id="76b01a57a6338aab828a7c6e4ed1bf39e383096b" translate="yes" xml:space="preserve">
          <source>The allowed fields, with their types, are:</source>
          <target state="translated">Допустимые поля,с их типами:</target>
        </trans-unit>
        <trans-unit id="007ff1d2ad1a216037acaa14b7a1f3887c82c2b0" translate="yes" xml:space="preserve">
          <source>The alternative spelling &lt;code&gt;INLINEABLE&lt;/code&gt; is also accepted by GHC.</source>
          <target state="translated">Альтернативное написание &lt;code&gt;INLINEABLE&lt;/code&gt; также принято GHC.</target>
        </trans-unit>
        <trans-unit id="305a13d8f5f537b644a0383d8511ddbfd1c351ee" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map and &lt;em&gt;W&lt;/em&gt; referring to the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">Амортизированное время работы дается для каждой операции, где &lt;em&gt;n&lt;/em&gt; относится к количеству записей в карте, а &lt;em&gt;W&lt;/em&gt; относится к количеству битов в &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 или 64).</target>
        </trans-unit>
        <trans-unit id="43383f5e57411cb28bfae33d1e0cb0912284dd35" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map and &lt;em&gt;W&lt;/em&gt; referring to the number of bits in an &lt;code&gt;Int&lt;/code&gt; (32 or 64).</source>
          <target state="translated">Амортизированное время работы дается для каждой операции, где &lt;em&gt;n&lt;/em&gt; относится к количеству записей в карте, а &lt;em&gt;W&lt;/em&gt; относится к количеству битов в &lt;code&gt;Int&lt;/code&gt; (32 или 64).</target>
        </trans-unit>
        <trans-unit id="9a366c01859c8d621928b2208d0c7ed30604c01f" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map.</source>
          <target state="translated">Амортизированное время работы дается для каждой операции, где &lt;em&gt;n&lt;/em&gt; означает количество записей на карте.</target>
        </trans-unit>
        <trans-unit id="a8bc34451c62ea9fef00489d326317052195ef0d" translate="yes" xml:space="preserve">
          <source>The amount of CPU time and elapsed wall clock time while initialising the runtime system (INIT), running the program itself (MUT, the mutator), and garbage collecting (GC).</source>
          <target state="translated">Количество процессорного времени и прошедшее время настенных часов при инициализации системы исполнения (INIT),запуске самой программы (MUT,мутатор)и сборе мусора (GC).</target>
        </trans-unit>
        <trans-unit id="324b96835c11121147eb9632d3d28270b6cd3cf5" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">Ответ: &amp;laquo;это может бросить и то, и другое&amp;raquo;; выбор не является детерминированным. Если вы поймали какой-либо тип исключения, вы можете поймать и то, и другое. Если вы вызываете &lt;code&gt;catch&lt;/code&gt; с типом &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; тогда обработчик может запускаться с &lt;code&gt;DivideByZero&lt;/code&gt; в качестве аргумента, или &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; может распространяться дальше. Если вы вызовете его снова, вы можете получить противоположное поведение. Это нормально, потому что &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; - это вычисление &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; вывода.</target>
        </trans-unit>
        <trans-unit id="fc2d971716bd2fe11fe8e65858d3f263f32451c4" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;ghc-io#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">Ответ: &amp;laquo;это может бросить и то, и другое&amp;raquo;; выбор не является детерминированным. Если вы поймали какой-либо тип исключения, вы можете поймать и то, и другое. Если вы вызываете &lt;code&gt;catch&lt;/code&gt; с типом &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; тогда обработчик может запускаться с &lt;code&gt;DivideByZero&lt;/code&gt; в качестве аргумента, или &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; может распространяться дальше. Если вы вызовете его снова, вы можете получить противоположное поведение. Это нормально, потому что &lt;code&gt;&lt;a href=&quot;ghc-io#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; - это вычисление &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; вывода.</target>
        </trans-unit>
        <trans-unit id="6636ed331b405e67e4aa7a8f8c1f88ee4738daae" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">Ответ: &amp;laquo;это может бросить и то, и другое&amp;raquo;; выбор не является детерминированным. Если вы поймали какой-либо тип исключения, вы можете поймать и то, и другое. Если вы вызываете &lt;code&gt;catch&lt;/code&gt; с типом &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; тогда обработчик может запускаться с &lt;code&gt;DivideByZero&lt;/code&gt; в качестве аргумента, или &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; может распространяться дальше. Если вы вызовете его снова, вы можете получить противоположное поведение. Это нормально, потому что &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; - это вычисление &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; вывода.</target>
        </trans-unit>
        <trans-unit id="215e7b52176702d87e95e2ce03acf7002f6125af" translate="yes" xml:space="preserve">
          <source>The approximate time when the program finished execution as a UNIX epoch timestamp.</source>
          <target state="translated">Приблизительное время,когда программа завершила выполнение в виде метки времени эпохи UNIX.</target>
        </trans-unit>
        <trans-unit id="bba06a7c745bfe3d2d4d032c0a5307f863b5c408" translate="yes" xml:space="preserve">
          <source>The arbitrary-precision &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; number type.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; number произвольной точности .</target>
        </trans-unit>
        <trans-unit id="77f549adbb8c3243a4f421f1caa3469b06d519cd" translate="yes" xml:space="preserve">
          <source>The arbitrary-precision &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; number type.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; number произвольной точности .</target>
        </trans-unit>
        <trans-unit id="7e4663001ff64b0062c525758c18f678a0b593f7" translate="yes" xml:space="preserve">
          <source>The argument is usually the name of the application. Since it will be integrated into the path, it must consist of valid path characters.</source>
          <target state="translated">Аргументом обычно является название приложения.Так как он будет интегрирован в путь,он должен состоять из допустимых символов пути.</target>
        </trans-unit>
        <trans-unit id="f7c4f0dc994aa251501707da51ab6248d1b7b620" translate="yes" xml:space="preserve">
          <source>The argument must be strictly positive, that condition is &lt;em&gt;not&lt;/em&gt; checked.</source>
          <target state="translated">Аргумент должен быть строго положительным, это условие &lt;em&gt;не&lt;/em&gt; проверяется.</target>
        </trans-unit>
        <trans-unit id="bfd85e788b1a4102dc5506f2821063aaee1859f8" translate="yes" xml:space="preserve">
          <source>The argument passed to &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is a function that takes as its argument another function, which can be used to restore the prevailing masking state within the context of the masked computation. For example, a common way to use &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is to protect the acquisition of a resource:</source>
          <target state="translated">Аргумент, переданный &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; - это функция, которая принимает в качестве аргумента другую функцию, которую можно использовать для восстановления преобладающего состояния маскировки в контексте замаскированного вычисления. Например, распространенный способ использования &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; - защитить получение ресурса:</target>
        </trans-unit>
        <trans-unit id="ec41714558fc08d08da55c62fab2fe097c6c6a18" translate="yes" xml:space="preserve">
          <source>The argument passed to &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is a function that takes as its argument another function, which can be used to restore the prevailing masking state within the context of the masked computation. For example, a common way to use &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is to protect the acquisition of a resource:</source>
          <target state="translated">Аргумент, переданный &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; - это функция, которая принимает в качестве аргумента другую функцию, которую можно использовать для восстановления преобладающего состояния маскировки в контексте замаскированного вычисления. Например, распространенный способ использования &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; - защитить получение ресурса:</target>
        </trans-unit>
        <trans-unit id="f8b310556e765050dba6b8aa3221dbec61d539ee" translate="yes" xml:space="preserve">
          <source>The argument passed to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is a function that takes as its argument another function, which can be used to restore the prevailing masking state within the context of the masked computation. For example, a common way to use &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is to protect the acquisition of a resource:</source>
          <target state="translated">Аргумент, переданный &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; - это функция, которая принимает в качестве аргумента другую функцию, которую можно использовать для восстановления преобладающего состояния маскировки в контексте замаскированного вычисления. Например, распространенный способ использования &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; - защитить получение ресурса:</target>
        </trans-unit>
        <trans-unit id="3c1e08fffd8f2b265d44f0c771329303cef101fc" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;runGhc&lt;/code&gt; is a bit tricky. GHC needs this to find its libraries, so the argument must refer to the directory that is printed by &lt;code&gt;ghc --print-libdir&lt;/code&gt; for the same version of GHC that the program is being compiled with. Above we therefore use the &lt;code&gt;ghc-paths&lt;/code&gt; package which provides this for us.</source>
          <target state="translated">Аргумент для &lt;code&gt;runGhc&lt;/code&gt; немного сложен . Это необходимо GHC для поиска своих библиотек, поэтому аргумент должен указывать на каталог, который печатается командой &lt;code&gt;ghc --print-libdir&lt;/code&gt; для той же версии GHC, с которой компилируется программа. Поэтому выше мы используем пакет &lt;code&gt;ghc-paths&lt;/code&gt; , который предоставляет нам это.</target>
        </trans-unit>
        <trans-unit id="629bfd4051da2fa1a32d9993713c3423b906b41a" translate="yes" xml:space="preserve">
          <source>The arguments are:</source>
          <target state="translated">Аргументы таковы:</target>
        </trans-unit>
        <trans-unit id="af48f7ebb72df2bb8fd591d8c3756cf037769ab7" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; are in this order so that we can partially apply it, e.g.:</source>
          <target state="translated">Аргументы для &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; расположены в таком порядке, чтобы мы могли частично применить их, например:</target>
        </trans-unit>
        <trans-unit id="9ab336f12a087d2ee8f1cb00edb943f2a0db5354" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; are:</source>
          <target state="translated">Аргументы в пользу &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a6d74e6182495971a70d15c2958c5a641ef0bc47" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; are in this order so that we can partially apply it, e.g.:</source>
          <target state="translated">Аргументы для &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; расположены в таком порядке, чтобы мы могли частично применить их, например:</target>
        </trans-unit>
        <trans-unit id="ecd5594ea721a5c5b4964510fa025a0ba7161ee7" translate="yes" xml:space="preserve">
          <source>The array is undefined (i.e. bottom) if any index in the list is out of bounds. The Haskell 2010 Report further specifies that if any two associations in the list have the same index, the value at that index is undefined (i.e. bottom). However in GHC's implementation, the value at such an index is the value part of the last association with that index in the list.</source>
          <target state="translated">Массив является неопределенным (т.е.нижним),если какой-либо индекс в списке находится вне пределов.В отчете Haskell 2010 Report далее указано,что если любые две ассоциации в списке имеют один и тот же индекс,то значение в этом индексе не определено (т.е.внизу).Однако в реализации GHC значение по такому индексу является ценностной частью последней ассоциации с этим индексом в списке.</target>
        </trans-unit>
        <trans-unit id="44d43a4b5ab2e55067cf3b1a8adecaad475ca23d" translate="yes" xml:space="preserve">
          <source>The array type</source>
          <target state="translated">Тип массива</target>
        </trans-unit>
        <trans-unit id="f14b40d222c3b195d28ca364c99460ad8aae96cd" translate="yes" xml:space="preserve">
          <source>The arrows web page at &lt;code&gt;http://www.haskell.org/arrows/&lt;/code&gt; &amp;lt;&lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;&amp;gt;`__.</source>
          <target state="translated">Веб-страница со стрелками по адресу &lt;code&gt;http://www.haskell.org/arrows/&lt;/code&gt; &amp;lt; &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt; &amp;gt; `__.</target>
        </trans-unit>
        <trans-unit id="5375e79ae4b0bd456d40500fcf8a53d9559263ad" translate="yes" xml:space="preserve">
          <source>The automatic loading of object files can sometimes lead to confusion, because non-exported top-level definitions of a module are only available for use in expressions at the prompt when the module is interpreted (see &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;). For this reason, you might sometimes want to force GHCi to load a module using the interpreter. This can be done by prefixing a &lt;code&gt;*&lt;/code&gt; to the module name or filename when using &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, for example</source>
          <target state="translated">Автоматическая загрузка объектных файлов иногда может привести к путанице, потому что неэкспортированные определения верхнего уровня модуля доступны для использования только в выражениях в приглашении, когда модуль интерпретируется (см. &lt;a href=&quot;#ghci-scope&quot;&gt;Что действительно находится в области действия в приглашении?&lt;/a&gt; ). По этой причине иногда может потребоваться заставить GHCi загрузить модуль с помощью интерпретатора. Это можно сделать, добавив префикс &lt;code&gt;*&lt;/code&gt; к имени модуля или имени файла при использовании &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; , например</target>
        </trans-unit>
        <trans-unit id="b8d9c5b3787a7ee0e2557b6cd2dbfe90790c68e2" translate="yes" xml:space="preserve">
          <source>The automatic specialisation of overloaded functions (with &lt;code&gt;-O&lt;/code&gt;) should take care of overloaded local and/or unexported functions.</source>
          <target state="translated">Автоматическая специализация перегруженных функций (с &lt;code&gt;-O&lt;/code&gt; ) должна заботиться о перегруженных локальных и / или неэкспортируемых функциях.</target>
        </trans-unit>
        <trans-unit id="5b4889f9c5c10822085aef8616f19dbeeab3bf53" translate="yes" xml:space="preserve">
          <source>The available GHCi options are:</source>
          <target state="translated">Доступны варианты GHCi:</target>
        </trans-unit>
        <trans-unit id="320cabfd45dc56924b1a16a731023c186da51000" translate="yes" xml:space="preserve">
          <source>The available mode flags are:</source>
          <target state="translated">Флаги доступного режима:</target>
        </trans-unit>
        <trans-unit id="7d80beedcca979af44b30619e5e06f25ee652ee4" translate="yes" xml:space="preserve">
          <source>The average and maximum &amp;ldquo;residency&amp;rdquo;, which is the amount of live data in bytes. The runtime can only determine the amount of live data during a major GC, which is why the number of samples corresponds to the number of major GCs (and is usually relatively small). To get a better picture of the heap profile of your program, use the &lt;a href=&quot;#rts-flag--hT&quot;&gt;&lt;code&gt;-hT&lt;/code&gt;&lt;/a&gt; RTS option (&lt;a href=&quot;#rts-profiling&quot;&gt;RTS options for profiling&lt;/a&gt;).</source>
          <target state="translated">Средняя и максимальная &amp;laquo;резидентность&amp;raquo;, то есть количество текущих данных в байтах. Среда выполнения может определять количество оперативных данных только во время основного GC, поэтому количество выборок соответствует количеству основных GC (и обычно относительно невелико). Чтобы получить более &lt;a href=&quot;#rts-flag--hT&quot;&gt; &lt;code&gt;-hT&lt;/code&gt; &lt;/a&gt; представление о профиле кучи вашей программы, используйте параметр -hT RTS ( &lt;a href=&quot;#rts-profiling&quot;&gt;параметры RTS для профилирования&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a46eb9d9f0c06124eb5d61df6a1e2c54302d74ae" translate="yes" xml:space="preserve">
          <source>The avoided &amp;ldquo;dangerous&amp;rdquo; optimisations are those that can make runtime or space &lt;em&gt;worse&lt;/em&gt; if you&amp;rsquo;re unlucky. They are normally turned on or off individually.</source>
          <target state="translated">Избегаемые &amp;laquo;опасные&amp;raquo; оптимизации - это те, которые могут &lt;em&gt;ухудшить&lt;/em&gt; время выполнения или пространство, если вам не повезет. Обычно они включаются или выключаются индивидуально.</target>
        </trans-unit>
        <trans-unit id="eecb19b8afe1b4ff965ad37ca33e048b7e8a4fe6" translate="yes" xml:space="preserve">
          <source>The base must be greater than &lt;code&gt;1&lt;/code&gt;, the second argument, the number whose logarithm is sought, shall be positive, otherwise the result is meaningless.</source>
          <target state="translated">Основание должно быть больше &lt;code&gt;1&lt;/code&gt; , второй аргумент, число, логарифм которого ищется, должен быть положительным, иначе результат не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="5bc476ce11547136a2a5b9c892017204522ab1a2" translate="yes" xml:space="preserve">
          <source>The basic algorithm for &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; walks the arguments of each constructor of a data type, applying a mapping function depending on the type of each argument. If a plain type variable is found that is syntactically equivalent to the last type parameter of the data type (&lt;code&gt;a&lt;/code&gt; in the above example), then we apply the function &lt;code&gt;f&lt;/code&gt; directly to it. If a type is encountered that is not syntactically equivalent to the last type parameter &lt;em&gt;but does mention&lt;/em&gt; the last type parameter somewhere in it, then a recursive call to &lt;code&gt;fmap&lt;/code&gt; is made. If a type is found which doesn&amp;rsquo;t mention the last type parameter at all, then it is left alone.</source>
          <target state="translated">Базовый алгоритм &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; просматривает&lt;/a&gt; аргументы каждого конструктора типа данных, применяя функцию сопоставления в зависимости от типа каждого аргумента. Если найдена переменная простого типа, синтаксически эквивалентная последнему параметру типа данных ( &lt;code&gt;a&lt;/code&gt; в приведенном выше примере), то мы применяем функцию &lt;code&gt;f&lt;/code&gt; непосредственно к ней. Если встречается тип, который синтаксически не эквивалентен последнему параметру типа, &lt;em&gt;но&lt;/em&gt; где-то в нем &lt;em&gt;упоминается&lt;/em&gt; последний параметр типа, то выполняется рекурсивный вызов &lt;code&gt;fmap&lt;/code&gt; . Если найден тип, который вообще не упоминает последний параметр типа, то он остается в покое.</target>
        </trans-unit>
        <trans-unit id="3880ac769d164951235b5160f553818be744abe1" translate="yes" xml:space="preserve">
          <source>The basic arrow class.</source>
          <target state="translated">Основной класс стрелок.</target>
        </trans-unit>
        <trans-unit id="f8e6230ac47ed9f2f8c9e5c744ea8b38e5723913" translate="yes" xml:space="preserve">
          <source>The basic idea is as follows:</source>
          <target state="translated">Основная идея заключается в следующем:</target>
        </trans-unit>
        <trans-unit id="ba3b2fdca46ebd4f364c251ed8663faaa8ea67c0" translate="yes" xml:space="preserve">
          <source>The basic idea is you render your structure in the form of this tree, and then use treeHtml to turn it into a Html object with the structure explicit.</source>
          <target state="translated">Основная идея заключается в том,что вы визуализируете свою структуру в виде этого дерева,а затем используете treeHtml,чтобы превратить ее в объект Html с явной структурой.</target>
        </trans-unit>
        <trans-unit id="ca1a1e0f9e4dd44a7cc3e7b636c0566990b56840" translate="yes" xml:space="preserve">
          <source>The basic syntax is that instead of specifying a package name P to the package flag &lt;code&gt;-package&lt;/code&gt;, instead we specify both a package name and a parenthesized, comma-separated list of module names to import. For example, &lt;code&gt;-package &quot;base (Data.List, Data.Bool)&quot;&lt;/code&gt; makes only &lt;code&gt;Data.List&lt;/code&gt; and &lt;code&gt;Data.Bool&lt;/code&gt; visible from package &lt;code&gt;base&lt;/code&gt;. We also support renaming of modules, in case you need to refer to both modules simultaneously; this is supporting by writing &lt;code&gt;OldModName as NewModName&lt;/code&gt;, e.g. &lt;code&gt;-package &quot;base (Data.Bool as Bool)&lt;/code&gt;. You can also write &lt;code&gt;-package &quot;base with (Data.Bool as Bool)&lt;/code&gt; to include all of the original bindings (e.g. the renaming is strictly additive). It&amp;rsquo;s important to specify quotes so that your shell passes the package name and thinning/renaming list as a single argument to GHC.</source>
          <target state="translated">Основной синтаксис заключается в том, что вместо указания имени пакета P для флага пакета &lt;code&gt;-package&lt;/code&gt; вместо этого мы указываем и имя пакета, и список импортируемых модулей, разделенный запятыми в скобках. Например, &lt;code&gt;-package &quot;base (Data.List, Data.Bool)&quot;&lt;/code&gt; делает &lt;code&gt;Data.List&lt;/code&gt; только Data.List и &lt;code&gt;Data.Bool&lt;/code&gt; из &lt;code&gt;base&lt;/code&gt; пакета . Мы также поддерживаем переименование модулей, если вам нужно обратиться к обоим модулям одновременно; это поддерживается записью &lt;code&gt;OldModName as NewModName&lt;/code&gt; , например &lt;code&gt;-package &quot;base (Data.Bool as Bool)&lt;/code&gt; . Вы также можете написать &lt;code&gt;-package &quot;base with (Data.Bool as Bool)&lt;/code&gt; чтобы включить все исходные привязки (например, переименование строго аддитивно). Важно указать кавычки, чтобы ваша оболочка передавала имя пакета и список прореживания / переименования как один аргумент в GHC.</target>
        </trans-unit>
        <trans-unit id="e4d64a56087518fa3e2214a7adad0a68d002b762" translate="yes" xml:space="preserve">
          <source>The batch compiler can be used alongside GHCi: compiled modules can be loaded into an interactive session and used in the same way as interpreted code, and in fact when using GHCi most of the library code will be pre-compiled. This means you get the best of both worlds: fast pre-compiled library code, and fast compile turnaround for the parts of your program being actively developed.</source>
          <target state="translated">Пакетный компилятор может использоваться вместе с GHCi:скомпилированные модули могут быть загружены в интерактивную сессию и использованы так же,как и интерпретируемый код,и фактически при использовании GHCi большая часть кода библиотеки будет предварительно скомпилирована.Это означает,что вы получаете лучшее из обоих миров:быстрый предкомпилированный библиотечный код,и быстрое компилирование тех частей вашей программы,которые активно разрабатываются.</target>
        </trans-unit>
        <trans-unit id="8ef12a287f244edad57a058eca9787cf5ada079d" translate="yes" xml:space="preserve">
          <source>The behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; using the given search directories and testing each file for executable permissions. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Поведение эквивалентно &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; с использованием заданных каталогов поиска и проверкой каждого файла на наличие разрешений для исполняемых файлов. Подробности можно найти в документации &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a37ab05f29aa8d1d66f30bee4471417ca0bbd0f1" translate="yes" xml:space="preserve">
          <source>The behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;, returning only the first occurrence. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Поведение эквивалентно &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; , возвращая только первое вхождение. Подробности можно найти в документации &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c8e66257c1f95cca3356ee64f960b20dcb60818" translate="yes" xml:space="preserve">
          <source>The behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt;. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Поведение эквивалентно &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; . Подробности можно найти в документации &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb1e1a3692688caa279ab0329a4e161ca0e7b861" translate="yes" xml:space="preserve">
          <source>The behaviour is simply this:</source>
          <target state="translated">Поведение просто такое:</target>
        </trans-unit>
        <trans-unit id="25a0b28ac23419d2d5d4b31eb8e82eaa74968d1a" translate="yes" xml:space="preserve">
          <source>The behaviour of parallel list comprehensions follows that of zip, in that the resulting list will have the same length as the shortest branch.</source>
          <target state="translated">Поведение параллельных списков следует за поведением zip,в том смысле,что результирующий список будет иметь ту же длину,что и самая короткая ветка.</target>
        </trans-unit>
        <trans-unit id="4c2566b6e8b4d963d45c5f213c50828df28117fe" translate="yes" xml:space="preserve">
          <source>The benefit of including dependency information is that it allows us to define more general multiple parameter classes, without ambiguity problems, and with the benefit of more accurate types. To illustrate this, we return to the collection class example, and annotate the original definition of &lt;code&gt;Collects&lt;/code&gt; with a simple dependency:</source>
          <target state="translated">Преимущество включения информации о зависимостях состоит в том, что это позволяет нам определять более общие классы с несколькими параметрами без проблем неоднозначности и с преимуществом более точных типов. Чтобы проиллюстрировать это, мы вернемся к примеру класса коллекции и аннотируем исходное определение &lt;code&gt;Collects&lt;/code&gt; с помощью простой зависимости:</target>
        </trans-unit>
        <trans-unit id="947bc2cb4d922e45d67175db691e9955f759c4f5" translate="yes" xml:space="preserve">
          <source>The biconnected components of a graph. An undirected graph is biconnected if the deletion of any vertex leaves it connected.</source>
          <target state="translated">Двухсвязные компоненты графика.Неориентированный график является биссектрисованным,если удаление любой вершины оставляет его связанным.</target>
        </trans-unit>
        <trans-unit id="fbd73ac6d922a5bdced0fb605663eb345d894008" translate="yes" xml:space="preserve">
          <source>The binder being annotated must be at the top level (i.e. no nested binders)</source>
          <target state="translated">Аннотируемое связующее вещество должно находиться на верхнем уровне (т.е.без вложенных связующих веществ).</target>
        </trans-unit>
        <trans-unit id="63969d96d060c4b503447fa167a99cc5d9a634d8" translate="yes" xml:space="preserve">
          <source>The binder being annotated must be declared in the current module</source>
          <target state="translated">Аннотированное переплетное устройство должно быть задекларировано в текущем модуле.</target>
        </trans-unit>
        <trans-unit id="7e1a540e18890acf0212904549c9082483047e09" translate="yes" xml:space="preserve">
          <source>The binding is lazy, but when either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is evaluated by &lt;code&gt;b&lt;/code&gt; the entire pattern is matched, including forcing the evaluation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Связывание является ленивым, но когда либо &lt;code&gt;x&lt;/code&gt; , либо &lt;code&gt;y&lt;/code&gt; оценивается с помощью &lt;code&gt;b&lt;/code&gt; , сопоставляется весь шаблон, включая принудительное вычисление &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5313486dfdead25fb97fb53d215625b3a8e92cb9" translate="yes" xml:space="preserve">
          <source>The body &lt;code&gt;e&lt;/code&gt; of a &lt;code&gt;static e&lt;/code&gt; expression must be a closed expression. Where we say an expression is &lt;em&gt;closed&lt;/em&gt; when all of its free (type) variables are closed. And a variable is &lt;em&gt;closed&lt;/em&gt; if it is let-bound to a &lt;em&gt;closed&lt;/em&gt; expression and its type is &lt;em&gt;closed&lt;/em&gt; as well. And a type is &lt;em&gt;closed&lt;/em&gt; if it has no free variables.</source>
          <target state="translated">Тело &lt;code&gt;e&lt;/code&gt; из &lt;code&gt;static e&lt;/code&gt; выражения должны быть замкнутым выражением. Где мы говорим, что выражение &lt;em&gt;закрыто,&lt;/em&gt; когда все его свободные (тип) переменные закрыты. И переменная &lt;em&gt;закрывается,&lt;/em&gt; если она привязана к &lt;em&gt;закрытому&lt;/em&gt; выражению и ее тип также &lt;em&gt;закрыт&lt;/em&gt; . И тип &lt;em&gt;закрывается,&lt;/em&gt; если у него нет свободных переменных.</target>
        </trans-unit>
        <trans-unit id="592ada029a062869cce6e9bab58606be6defb777" translate="yes" xml:space="preserve">
          <source>The body of &lt;code&gt;f&lt;/code&gt; requires a &lt;code&gt;Num Int&lt;/code&gt; instance. We could solve this constraint from the context because we have &lt;code&gt;C Int b&lt;/code&gt; and that provides us a solution for &lt;code&gt;Num Int&lt;/code&gt;. However, we can often produce much better code by directly solving for an available &lt;code&gt;Num Int&lt;/code&gt; dictionary we might have at hand. This removes potentially many layers of indirection and crucially allows other optimisations to fire as the dictionary will be statically known and selector functions can be inlined.</source>
          <target state="translated">Тело &lt;code&gt;f&lt;/code&gt; требует экземпляра &lt;code&gt;Num Int&lt;/code&gt; . Мы могли бы решить это ограничение из контекста, потому что у нас есть &lt;code&gt;C Int b&lt;/code&gt; , и это дает нам решение для &lt;code&gt;Num Int&lt;/code&gt; . Тем не менее, мы часто можем создать намного лучший код, напрямую решая для доступного словаря &lt;code&gt;Num Int&lt;/code&gt; , который может быть у нас под рукой. Это устраняет потенциально многие уровни косвенного обращения и, что очень важно, позволяет запускать другие оптимизации, поскольку словарь будет статически известен, а функции выбора могут быть встроены.</target>
        </trans-unit>
        <trans-unit id="6d145adb9d3d5724f47490428e23e3c43d0c8235" translate="yes" xml:space="preserve">
          <source>The body of &lt;code&gt;h&lt;/code&gt;&lt;em&gt;can&lt;/em&gt; refer to the function &lt;code&gt;k&lt;/code&gt; appearing on the other side of the declaration quasiquoter, as quasiquoters do not cause a declaration group to be broken up.</source>
          <target state="translated">Тело &lt;code&gt;h&lt;/code&gt; &lt;em&gt;может&lt;/em&gt; относиться к функции &lt;code&gt;k&lt;/code&gt; , появляющейся с другой стороны квазиквотера объявления, поскольку квазиквотеры не вызывают разбиение группы объявлений.</target>
        </trans-unit>
        <trans-unit id="8c2a782fcf9cc8cd32d7c6db0f011051b79d7285" translate="yes" xml:space="preserve">
          <source>The bound on the size of sequences of bytes generated by this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; размера последовательностей байтов, генерируемых этим BoundedPrim .</target>
        </trans-unit>
        <trans-unit id="efcab014d352f2160b0e056ce4481103488be8c8" translate="yes" xml:space="preserve">
          <source>The bounds are specified as a pair of the lowest and highest bounds in the array respectively. For example, a one-origin vector of length 10 has bounds (1,10), and a one-origin 10 by 10 matrix has bounds ((1,1),(10,10)).</source>
          <target state="translated">Границы задаются как пара нижних и верхних границ массива соответственно.Например,односторонний вектор длиной 10 имеет границы (1,10),а матрица 10 на 10 имеет границы ((1,1),(10,10)).</target>
        </trans-unit>
        <trans-unit id="ba1cb6f6655a10a0c6294b458c9d83470571695d" translate="yes" xml:space="preserve">
          <source>The bounds of an &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">Границы &lt;code&gt;Array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55a1eeab90b32df97217b33a312a220ee3d8254d" translate="yes" xml:space="preserve">
          <source>The bounds of the array</source>
          <target state="translated">Границы массива</target>
        </trans-unit>
        <trans-unit id="5e0f777f52cc6d21bfe3b719f3991ded42b0a70a" translate="yes" xml:space="preserve">
          <source>The bounds with which an array was constructed.</source>
          <target state="translated">Границы,с которыми строился массив.</target>
        </trans-unit>
        <trans-unit id="606c7ca088c78a3f35afe2ec49468115c18dfed0" translate="yes" xml:space="preserve">
          <source>The buffer is represented by a record, where the record contains the raw buffer and the start/end points of the filled portion. The buffer contents itself is mutable, but the rest of the record is immutable. This is a slightly odd mix, but it turns out to be quite practical: by making all the buffer metadata immutable, we can have operations on buffer metadata outside of the IO monad.</source>
          <target state="translated">Буфер представлен записью,где запись содержит сырой буфер и точки начала/конца заполненной порции.Содержимое буфера само по себе является мутируемым,а остальная часть записи-неизменяемой.Это немного странная смесь,но получается довольно практично:сделав все метаданные буфера неизменяемыми,мы можем получить операции с метаданными буфера вне IO monad.</target>
        </trans-unit>
        <trans-unit id="7e80cbba3a922b5261d972496342488e7c081b28" translate="yes" xml:space="preserve">
          <source>The bug tracker lists bugs that have been reported in GHC but not yet fixed: see the &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/&quot;&gt;GHC Trac&lt;/a&gt;. In addition to those, GHC also has the following known bugs or infelicities. These bugs are more permanent; it is unlikely that any of them will be fixed in the short term.</source>
          <target state="translated">В трекере ошибок перечислены ошибки, которые были зарегистрированы в GHC, но еще не исправлены: см. &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/&quot;&gt;GHC Trac&lt;/a&gt; . В дополнение к ним, GHC также имеет следующие известные ошибки или недостатки. Эти ошибки более постоянны; маловероятно, что какая-либо из них будет исправлена ​​в ближайшее время.</target>
        </trans-unit>
        <trans-unit id="7c15ff27610c2478bb9e4d3ab87096d2c276c0af" translate="yes" xml:space="preserve">
          <source>The byte ordering of the target machine.</source>
          <target state="translated">Заказ байтов целевой машины.</target>
        </trans-unit>
        <trans-unit id="9d60877c7df977c480a2e8c741eba795e8186655" translate="yes" xml:space="preserve">
          <source>The byte-order-mark is strictly unnecessary in UTF-8, but is sometimes used to identify the encoding of a file.</source>
          <target state="translated">В UTF-8 метка порядка байт строго не нужна,но иногда используется для идентификации кодировки файла.</target>
        </trans-unit>
        <trans-unit id="8e514a824a293915d542219870ba513432dcaf11" translate="yes" xml:space="preserve">
          <source>The bytes read, how many bytes were read.</source>
          <target state="translated">Сколько байт прочитано,сколько байт прочитано.</target>
        </trans-unit>
        <trans-unit id="b6a0060fcedfd8a68377b3d1eb2b5aba06d7d975" translate="yes" xml:space="preserve">
          <source>The call</source>
          <target state="translated">Звонок</target>
        </trans-unit>
        <trans-unit id="39398c8eae38902a5e0ff83f99f6b2f202aad4e7" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;inline f&lt;/code&gt; arranges that &lt;code&gt;f&lt;/code&gt; is inlined, regardless of its size. More precisely, the call &lt;code&gt;inline f&lt;/code&gt; rewrites to the right-hand side of &lt;code&gt;f&lt;/code&gt;'s definition. This allows the programmer to control inlining from a particular call site rather than the definition site of the function (c.f. &lt;code&gt;INLINE&lt;/code&gt; pragmas).</source>
          <target state="translated">Вызов &lt;code&gt;inline f&lt;/code&gt; делает так, чтобы &lt;code&gt;f&lt;/code&gt; был встроен, независимо от его размера. Точнее, &lt;code&gt;inline f&lt;/code&gt; вызов f переписывается в правую часть определения &lt;code&gt;f&lt;/code&gt; . Это позволяет программисту управлять встраиванием из определенного сайта вызова, а не из сайта определения функции (см. &lt;code&gt;INLINE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7b04d6b098bff47077a3361dce7c4b2060070b35" translate="yes" xml:space="preserve">
          <source>The call may block for a long time if a GC is in progress. We can&amp;rsquo;t use this method if the C API we&amp;rsquo;re calling doesn&amp;rsquo;t allow blocking in the callback.</source>
          <target state="translated">Вызов может заблокироваться на долгое время, если выполняется сборщик мусора. Мы не можем использовать этот метод, если вызываемый нами C API не разрешает блокировку в обратном вызове.</target>
        </trans-unit>
        <trans-unit id="0f662e8be9b1e8327dfadad6256f93b3102227e4" translate="yes" xml:space="preserve">
          <source>The call stack</source>
          <target state="translated">Счет вызовов</target>
        </trans-unit>
        <trans-unit id="0b95e6d04b2d9db9df511faee23c172fb043db56" translate="yes" xml:space="preserve">
          <source>The call stack here consists of a single entry, pinpointing the source of the call to &lt;code&gt;error&lt;/code&gt;. However, by annotating several computations with &lt;code&gt;HasCallStack&lt;/code&gt;, figuring out the exact circumstances and sequences of calls that lead to a call to &lt;code&gt;error&lt;/code&gt; becomes a lot easier, as demonstrated with the simple example below.</source>
          <target state="translated">Стек вызовов здесь состоит из единственной записи, точно определяющей источник вызова &lt;code&gt;error&lt;/code&gt; . Однако, аннотируя несколько вычислений с помощью &lt;code&gt;HasCallStack&lt;/code&gt; , выяснение точных обстоятельств и последовательностей вызовов, которые приводят к вызову &lt;code&gt;error&lt;/code&gt; становится намного проще, как показано на простом примере ниже.</target>
        </trans-unit>
        <trans-unit id="e65b75e639ba49f45b306162220bcb4b4e376b49" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;hs_init()&lt;/code&gt; initializes GHC&amp;rsquo;s runtime system. Do NOT try to invoke any Haskell functions before calling &lt;code&gt;hs_init()&lt;/code&gt;: bad things will undoubtedly happen.</source>
          <target state="translated">Вызов &lt;code&gt;hs_init()&lt;/code&gt; инициализирует систему времени выполнения GHC. НЕ пытайтесь вызывать какие-либо функции Haskell перед вызовом &lt;code&gt;hs_init()&lt;/code&gt; : несомненно, случатся плохие вещи.</target>
        </trans-unit>
        <trans-unit id="b0d2f80290077bea927d89a134d957a184f32cc5" translate="yes" xml:space="preserve">
          <source>The calls &lt;code&gt;&lt;a href=&quot;ghc-enum#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-enum#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; should result in a runtime error.</source>
          <target state="translated">Призывы &lt;code&gt;&lt;a href=&quot;ghc-enum#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-enum#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; должно привести к ошибке во время выполнения.</target>
        </trans-unit>
        <trans-unit id="319dd86afb1a88f29e7d25a55be6766bfa4bbc86" translate="yes" xml:space="preserve">
          <source>The calls &lt;code&gt;&lt;a href=&quot;prelude#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; should result in a runtime error.</source>
          <target state="translated">Призывы &lt;code&gt;&lt;a href=&quot;prelude#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; должно привести к ошибке во время выполнения.</target>
        </trans-unit>
        <trans-unit id="82bb223904345033a341142d4c4dc792513b34b0" translate="yes" xml:space="preserve">
          <source>The case for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; is rather interesting. Here, we call the final function &lt;code&gt;encode&lt;/code&gt; that we yet have to define, recursively. We will use another type class &lt;code&gt;Encode&lt;/code&gt; for that function:</source>
          <target state="translated">Случай с &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; довольно интересен. Здесь мы рекурсивно вызываем последнюю функцию &lt;code&gt;encode&lt;/code&gt; , которую нам еще предстоит определить. Для этой функции мы будем использовать другой класс типа &lt;code&gt;Encode&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dbeba971901c44630a87f3ab4af1926015f93dc7" translate="yes" xml:space="preserve">
          <source>The channels are implemented with &lt;code&gt;MVar&lt;/code&gt;s and therefore inherit all the caveats that apply to &lt;code&gt;MVar&lt;/code&gt;s (possibility of races, deadlocks etc). The stm (software transactional memory) library has a more robust implementation of channels called &lt;code&gt;TChan&lt;/code&gt;s.</source>
          <target state="translated">Каналы реализованы с помощью &lt;code&gt;MVar&lt;/code&gt; s и, следовательно, наследуют все предостережения, которые применяются к &lt;code&gt;MVar&lt;/code&gt; s (возможность гонок, взаимоблокировок и т. Д.). Библиотека stm (программная транзакционная память) имеет более надежную реализацию каналов, называемых &lt;code&gt;TChan&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="4069bea430852a057890df955f47a154334cab42" translate="yes" xml:space="preserve">
          <source>The character that is used to separate the entries in the $PATH environment variable.</source>
          <target state="translated">Символ,который используется для разделения записей в переменной окружения $PATH.</target>
        </trans-unit>
        <trans-unit id="ba11d47bc9956242fbb3ca66e5d4200f63de5f8d" translate="yes" xml:space="preserve">
          <source>The character that separates directories. In the case where more than one character is possible, &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; is the 'ideal' one.</source>
          <target state="translated">Символ, разделяющий каталоги. В случае, когда возможно более одного символа, &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; является &amp;laquo;идеальным&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="0adbd55b5e31c8dee6ffdd25e981917f83978616" translate="yes" xml:space="preserve">
          <source>The character that separates directories. In the case where more than one character is possible, &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; is the 'ideal' one.</source>
          <target state="translated">Символ, разделяющий каталоги. В случае, когда возможно более одного символа, &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; является &amp;laquo;идеальным&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="3300c6070d1ff47cc64a9cd4f2a57598bed4fe49" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип символа &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; - это перечисление, значения которого представляют собой кодовые точки Unicode (или эквивалентно ISO / IEC 10646) (т.е. символы, подробности см. На &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; ). Этот набор расширяет набор символов ISO 8859-1 (Latin-1) (первые 256 символов), который сам является расширением набора символов ASCII (первые 128 символов). Символьный литерал в Haskell имеет тип &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a83bfe2a3131f5d1fa9053b377b2dd8ef00abbee" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип символа &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; - это перечисление, значения которого представляют собой кодовые точки Unicode (или эквивалентно ISO / IEC 10646) (т.е. символы, подробности см. На &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; ). Этот набор расширяет набор символов ISO 8859-1 (Latin-1) (первые 256 символов), который сам является расширением набора символов ASCII (первые 128 символов). Символьный литерал в Haskell имеет тип &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e57b1fe87f343495401c4e61909f138148056d67" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип символа &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; - это перечисление, значения которого представляют собой кодовые точки Unicode (или эквивалентно ISO / IEC 10646) (т.е. символы, подробности см. На &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; ). Этот набор расширяет набор символов ISO 8859-1 (Latin-1) (первые 256 символов), который сам является расширением набора символов ASCII (первые 128 символов). Символьный литерал в Haskell имеет тип &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47f8f2f2dc9e65ebc1b9adf566bdf62f3dc06201" translate="yes" xml:space="preserve">
          <source>The chunk size used for I/O. Currently set to 32k, less the memory management overhead</source>
          <target state="translated">Размер куска,используемый для ввода/вывода.В настоящее время установлен на 32k,за вычетом накладных расходов на управление памятью.</target>
        </trans-unit>
        <trans-unit id="c4ebe1e22516dcf7d377102ba02d7a72071fb54c" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; allows a concrete representation of a type to be calculated.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; позволяет вычислить конкретное представление типа.</target>
        </trans-unit>
        <trans-unit id="26ec99c0bc5533ce5fa506bf5dd334d666afbabf" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; allows a concrete representation of a type to be calculated.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; позволяет вычислить конкретное представление типа.</target>
        </trans-unit>
        <trans-unit id="95e5985c3bffdb6706bd6da87ba82bb2b1f9502b" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; allows a concrete representation of a type to be calculated.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; позволяет вычислить конкретное представление типа.</target>
        </trans-unit>
        <trans-unit id="a0793307c198436ef6cbb2b38d12d842f11f5daa" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;IsLabel&lt;/code&gt; is defined as:</source>
          <target state="translated">Класс &lt;code&gt;IsLabel&lt;/code&gt; определяется как:</target>
        </trans-unit>
        <trans-unit id="da702fa4f893f1ff84ab94ead774536cedcefc5d" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;IsString&lt;/code&gt; is defined as:</source>
          <target state="translated">Класс &lt;code&gt;IsString&lt;/code&gt; определяется как:</target>
        </trans-unit>
        <trans-unit id="314c44e92114b49583eff2b98f5eb8171a7374ef" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;IsString&lt;/code&gt; is not in scope by default. If you want to mention it explicitly (for example, to give an instance declaration for it), you can import it from module &lt;code&gt;Data.String&lt;/code&gt;.</source>
          <target state="translated">По &lt;code&gt;IsString&lt;/code&gt; класс IsString не входит в область видимости. Если вы хотите упомянуть его явно (например, чтобы дать для него объявление экземпляра), вы можете импортировать его из модуля &lt;code&gt;Data.String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46c25aa9d510e6dfd769a86618af627836e67d95" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Lift&lt;/code&gt;, unlike other derivable classes, lives in &lt;code&gt;template-haskell&lt;/code&gt; instead of &lt;code&gt;base&lt;/code&gt;. Having a data type be an instance of &lt;code&gt;Lift&lt;/code&gt; permits its values to be promoted to Template Haskell expressions (of type &lt;code&gt;ExpQ&lt;/code&gt;), which can then be spliced into Haskell source code.</source>
          <target state="translated">Класс &lt;code&gt;Lift&lt;/code&gt; , в отличие от других производных классов, живет в &lt;code&gt;template-haskell&lt;/code&gt; а не в &lt;code&gt;base&lt;/code&gt; . Если тип данных является экземпляром &lt;code&gt;Lift&lt;/code&gt; , его значения могут быть продвинуты в выражения Template Haskell (типа &lt;code&gt;ExpQ&lt;/code&gt; ), которые затем могут быть вставлены в исходный код Haskell.</target>
        </trans-unit>
        <trans-unit id="cfedc7f27395d9e14f3b5dcae9116c684144dba3" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Typeable&lt;/code&gt; is very special:</source>
          <target state="translated">Класс &lt;code&gt;Typeable&lt;/code&gt; очень особенный:</target>
        </trans-unit>
        <trans-unit id="a352e3bea5c92259e258192deb3bd391cda34543" translate="yes" xml:space="preserve">
          <source>The class instances for sequences are all based very closely on those for lists.</source>
          <target state="translated">Все экземпляры классов для последовательностей очень близки к экземплярам для списков.</target>
        </trans-unit>
        <trans-unit id="f29fdb13c7afe65c971d977ce119c943fb00e75f" translate="yes" xml:space="preserve">
          <source>The class of contravariant functors.</source>
          <target state="translated">Класс противопоказаний.</target>
        </trans-unit>
        <trans-unit id="15b84a81fb0f85cb419535a3a61b9ad1d3da02f7" translate="yes" xml:space="preserve">
          <source>The class of monad transformers.</source>
          <target state="translated">Класс монадских трансформаторов.</target>
        </trans-unit>
        <trans-unit id="1aba4d36676a8723cc042f0ef18005b4207f229e" translate="yes" xml:space="preserve">
          <source>The class of monad transformers. Instances should satisfy the following laws, which state that &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; is a monad transformation:</source>
          <target state="translated">Класс преобразователей монад. Экземпляры должны удовлетворять следующим законам, согласно которым &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; является преобразованием монады:</target>
        </trans-unit>
        <trans-unit id="968994db3d9c45181b57f61fe4736e2627f5c6a6" translate="yes" xml:space="preserve">
          <source>The class of monoids (types with an associative binary operation that has an identity). Instances should satisfy the following:</source>
          <target state="translated">Класс моноидов (типы с ассоциативной двоичной операцией,имеющей идентичность).Случаи должны удовлетворять следующим требованиям:</target>
        </trans-unit>
        <trans-unit id="80aae29c2b395ab518f6cbf2867e04f61aabbf53" translate="yes" xml:space="preserve">
          <source>The class of semigroups (types with an associative binary operation).</source>
          <target state="translated">Класс полугрупп (типы с ассоциативной двоичной операцией).</target>
        </trans-unit>
        <trans-unit id="ef50832e806510cb4bbe9f9aafa22744526d2ab1" translate="yes" xml:space="preserve">
          <source>The class of the instance declaration is not declared in &lt;code&gt;M&lt;/code&gt;, and</source>
          <target state="translated">Класс объявления экземпляра не объявлен в &lt;code&gt;M&lt;/code&gt; , и</target>
        </trans-unit>
        <trans-unit id="cc31daa90372a8a474d012704a661ac277d958aa" translate="yes" xml:space="preserve">
          <source>The class of types which can be parsed given a UNIX-style time format string.</source>
          <target state="translated">Класс типов,которые могут быть обработаны с помощью строки формата времени в UNIX-стиле.</target>
        </trans-unit>
        <trans-unit id="380a9b6da5c050f1cf3fa8febdb6d2797a540fc9" translate="yes" xml:space="preserve">
          <source>The closure of the superclass relation over these local axioms : &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; and &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt;</source>
          <target state="translated">Замыкание отношения суперкласса над этими локальными аксиомами: &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; и &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0848f15a7a4cc86662e9097e3f0cf4b1532d9192" translate="yes" xml:space="preserve">
          <source>The code for the method in the instance declaration is typechecked against the type signature supplied in the instance declaration, as you would expect. So if the instance signature is more polymorphic than required, the code must be too.</source>
          <target state="translated">Как и следовало ожидать,код метода в объявлении экземпляра проверяется на соответствие подписи типа,поставленной в объявлении экземпляра.Таким образом,если подпись экземпляра более полиморфна,чем требуется,код тоже должен быть.</target>
        </trans-unit>
        <trans-unit id="e5001edd8f78114b36e24d8f0a44754ee90b2f4d" translate="yes" xml:space="preserve">
          <source>The code generator tries to generate as compact layout as possible for each unboxed sum. In the best case, size of an unboxed sum is size of its biggest alternative plus one word (for a tag). The algorithm for generating the memory layout for a sum type works like this:</source>
          <target state="translated">Генератор кодов пытается сгенерировать как можно более компактную компоновку для каждой необлагаемой суммы.В лучшем случае,размер небоксовой суммы-это размер ее наибольшей альтернативы плюс одно слово (для тега).Алгоритм генерации компоновки памяти для типа sum работает следующим образом:</target>
        </trans-unit>
        <trans-unit id="3837898dd791b811ea7932889c5130e161088d94" translate="yes" xml:space="preserve">
          <source>The code of the &quot;dominant&quot; language of the webpage.</source>
          <target state="translated">Код &quot;доминирующего&quot; языка веб-страницы.</target>
        </trans-unit>
        <trans-unit id="a45302a43608cfe9a77b37998c0a415b8fef0ffc" translate="yes" xml:space="preserve">
          <source>The code should be mostly self-explanatory. The slightly awkward syntax is because the combinators are written such that the size-bound of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; can be computed at compile time. We also explicitly inline the &lt;code&gt;fixed2&lt;/code&gt; primitive, which encodes a fixed tuple of characters, to ensure that the bound computation happens at compile time. When encoding the following list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, the optimized implementation of &lt;code&gt;renderString&lt;/code&gt; is two times faster.</source>
          <target state="translated">Код должен быть в основном понятным. Немного неудобный синтаксис состоит в том, что комбинаторы написаны так, что граница размера результирующего &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; может быть вычислена во время компиляции. Мы также явно встраиваем примитив &lt;code&gt;fixed2&lt;/code&gt; , который кодирует фиксированный кортеж символов, чтобы гарантировать, что связанное вычисление происходит во время компиляции. При кодировании следующего списка &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; оптимизированная реализация &lt;code&gt;renderString&lt;/code&gt; выполняется в два раза быстрее.</target>
        </trans-unit>
        <trans-unit id="4421b2e89d7c073b3eeabb7b626aa07e05c2b134" translate="yes" xml:space="preserve">
          <source>The combinators &lt;code&gt;&lt;a href=&quot;data-data#v:gmapT&quot;&gt;gmapT&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQ&quot;&gt;gmapQ&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-data#v:gmapM&quot;&gt;gmapM&lt;/a&gt;&lt;/code&gt;, etc are all provided with default definitions in terms of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt;, leaving open the opportunity to provide datatype-specific definitions. (The inclusion of the &lt;code&gt;gmap&lt;/code&gt; combinators as members of class &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; allows the programmer or the compiler to derive specialised, and maybe more efficient code per datatype. &lt;em&gt;Note&lt;/em&gt;: &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is more higher-order than the &lt;code&gt;gmap&lt;/code&gt; combinators. This is subject to ongoing benchmarking experiments. It might turn out that the &lt;code&gt;gmap&lt;/code&gt; combinators will be moved out of the class &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Комбинаторы &lt;code&gt;&lt;a href=&quot;data-data#v:gmapT&quot;&gt;gmapT&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQ&quot;&gt;gmapQ&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-data#v:gmapM&quot;&gt;gmapM&lt;/a&gt;&lt;/code&gt; и т. Д. Снабжены определениями по умолчанию в терминах &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; , оставляя открытой возможность предоставить определения для конкретных типов данных. (Включение комбинаторов &lt;code&gt;gmap&lt;/code&gt; в качестве членов класса &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; позволяет программисту или компилятору получить специализированный и, возможно, более эффективный код для каждого типа данных. &lt;em&gt;Примечание&lt;/em&gt; : &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; более высокого порядка, чем комбинаторы &lt;code&gt;gmap&lt;/code&gt; . Это является предметом текущих экспериментов по тестированию Может оказаться, что комбинаторы &lt;code&gt;gmap&lt;/code&gt; будут перемещены из класса &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="8d6f1f7c8a32c8db29cc4151cc5a6c27c5f31776" translate="yes" xml:space="preserve">
          <source>The combinators for &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s are implemented such that the size of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; can be computed at compile time.</source>
          <target state="translated">Комбинаторы для &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; реализованы так, что размер результирующего &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; может быть вычислен во время компиляции.</target>
        </trans-unit>
        <trans-unit id="b36fb23ba2c0fd5cf9cc5fbcaa48f3fa3936ed5b" translate="yes" xml:space="preserve">
          <source>The combinators for &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;s are implemented such that the &lt;code&gt;size&lt;/code&gt; of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; is computed at compile time.</source>
          <target state="translated">Комбинаторы для &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; реализованы так, что &lt;code&gt;size&lt;/code&gt; результирующего &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; вычисляется во время компиляции.</target>
        </trans-unit>
        <trans-unit id="2acc0788b34136669ccf2620396da51b7563e2c2" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt; will show a summary of which modules contribute to the top-level scope.</source>
          <target state="translated">Команда &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; &lt;/a&gt; покажет сводку о том, какие модули участвуют в области верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="5fdeb122c09642094fcfc48bef6bdcdff89e8605" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;#ghci-cmd-:step&quot;&gt;&lt;code&gt;:step expr&lt;/code&gt;&lt;/a&gt; begins the evaluation of ⟨expr⟩ in single-stepping mode. If ⟨expr⟩ is omitted, then it single-steps from the current breakpoint. &lt;a href=&quot;#ghci-cmd-:steplocal&quot;&gt;&lt;code&gt;:steplocal&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:stepmodule&quot;&gt;&lt;code&gt;:stepmodule&lt;/code&gt;&lt;/a&gt; commands work similarly.</source>
          <target state="translated">Команда &lt;a href=&quot;#ghci-cmd-:step&quot;&gt; &lt;code&gt;:step expr&lt;/code&gt; &lt;/a&gt; начинает вычисление &amp;laquo;expr &amp;raquo;в пошаговом режиме. Если expr⟩ опущено, то выполняется один шаг от текущей точки останова. &lt;a href=&quot;#ghci-cmd-:steplocal&quot;&gt; &lt;code&gt;:steplocal&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#ghci-cmd-:stepmodule&quot;&gt; &lt;code&gt;:stepmodule&lt;/code&gt; &lt;/a&gt; работают аналогично.</target>
        </trans-unit>
        <trans-unit id="a632ebd88f50b8ac78cacda34b5408a0be9ab51c" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;:break 2&lt;/code&gt; sets a breakpoint on line 2 of the most recently-loaded module, in this case &lt;code&gt;qsort.hs&lt;/code&gt;. Specifically, it picks the leftmost complete subexpression on that line on which to set the breakpoint, which in this case is the expression &lt;code&gt;(qsort left ++ [a] ++ qsort right)&lt;/code&gt;.</source>
          <target state="translated">Команда &lt;code&gt;:break 2&lt;/code&gt; устанавливает &lt;code&gt;qsort.hs&lt;/code&gt; останова в строке 2 последнего загруженного модуля, в данном случае qsort.hs . В частности, он выбирает крайнее левое полное подвыражение в этой строке, на котором устанавливается точка останова, которая в данном случае является выражением &lt;code&gt;(qsort left ++ [a] ++ qsort right)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e40dd230e05a9e07fe62ec45624d094d383aa421" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;:info!&lt;/code&gt; works in a similar fashion but it removes restriction (b), showing all instances that are in scope and mention ⟨name⟩ in their head.</source>
          <target state="translated">Команда &lt;code&gt;:info!&lt;/code&gt; работает аналогичным образом, но снимает ограничение (b), показывая все экземпляры, которые находятся в области видимости, и упоминает name⟩ в их голове.</target>
        </trans-unit>
        <trans-unit id="db3abb134ad672048db99caf88a85888bde3b864" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;fgrep -n END_SAMPLE FOO.hp&lt;/code&gt; finds the end of every complete sample in &lt;code&gt;FOO.hp&lt;/code&gt;, and labels each sample with its ending line number. We then select the line number of the last complete sample using &lt;strong&gt;tail&lt;/strong&gt; and &lt;strong&gt;cut&lt;/strong&gt;. This is used as a parameter to &lt;strong&gt;head&lt;/strong&gt;; the result is as if we deleted the final incomplete sample from &lt;code&gt;FOO.hp&lt;/code&gt;. This results in a properly-formatted .hp file which we feed directly to &lt;strong&gt;hp2ps&lt;/strong&gt;.</source>
          <target state="translated">Команда &lt;code&gt;fgrep -n END_SAMPLE FOO.hp&lt;/code&gt; находит конец каждой полной выборки в &lt;code&gt;FOO.hp&lt;/code&gt; и маркирует каждую выборку ее номером конечной строки. Затем мы выбираем номер строки последнего полного образца, используя &lt;strong&gt;хвост&lt;/strong&gt; и &lt;strong&gt;вырез&lt;/strong&gt; . Используется как параметр для &lt;strong&gt;заголовка&lt;/strong&gt; ; результат , как если бы мы удалили окончательную неполную выборку из &lt;code&gt;FOO.hp&lt;/code&gt; . В результате получается правильно отформатированный файл .hp, который мы загружаем напрямую в &lt;strong&gt;hp2ps&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="270408c21f336615635c1e2a2c6f2941c9ac84d6" translate="yes" xml:space="preserve">
          <source>The command line arguments passed to the program</source>
          <target state="translated">Аргументы командной строки,передаваемые программе</target>
        </trans-unit>
        <trans-unit id="e7e794e0f93c2fa925b60afdb7fbdedb64d80c09" translate="yes" xml:space="preserve">
          <source>The command line arguments passed to the runtime system</source>
          <target state="translated">Аргументы командной строки,передаваемые в систему исполнения</target>
        </trans-unit>
        <trans-unit id="77b364d49a3dfa5e15b2ed62d447248ab845ef6f" translate="yes" xml:space="preserve">
          <source>The command to run, which must be in the $PATH, or an absolute or relative path</source>
          <target state="translated">Команда для выполнения,которая должна быть в $PATH,или абсолютным или относительным путем</target>
        </trans-unit>
        <trans-unit id="a9eb0075b8efba5d950b353dc2ba8dd18856c0b6" translate="yes" xml:space="preserve">
          <source>The command versions of lambda abstraction and application are analogous to the expression versions. In particular, the beta and eta rules describe equivalences of commands. These three features (operators, lambda abstraction and application) are the core of the notation; everything else can be built using them, though the results would be somewhat clumsy. For example, we could simulate &lt;code&gt;do&lt;/code&gt;-notation by defining</source>
          <target state="translated">Версии команд лямбда-абстракции и приложения аналогичны версиям выражений. В частности, правила бета и эта описывают эквивалентность команд. Эти три функции (операторы, лямбда-абстракция и приложение) составляют основу нотации; все остальное можно построить с их помощью, хотя результаты будут несколько неуклюжими. Например, мы могли бы смоделировать &lt;code&gt;do&lt;/code&gt; - нотацию, определив</target>
        </trans-unit>
        <trans-unit id="8a1e2c9e679e0ed25e609bb32dccdb1dffa31a77" translate="yes" xml:space="preserve">
          <source>The comparable symbols for other systems are: &lt;code&gt;__HUGS__&lt;/code&gt; for Hugs, &lt;code&gt;__NHC__&lt;/code&gt; for nhc98, and &lt;code&gt;__HBC__&lt;/code&gt; for hbc).</source>
          <target state="translated">Соответствующие символы для других систем: &lt;code&gt;__HUGS__&lt;/code&gt; для Hugs, &lt;code&gt;__NHC__&lt;/code&gt; для nhc98 и &lt;code&gt;__HBC__&lt;/code&gt; для hbc).</target>
        </trans-unit>
        <trans-unit id="b172d1caf74bb5840fcb833db8910b15eee4ccf4" translate="yes" xml:space="preserve">
          <source>The compiler does not overwrite an existing &lt;code&gt;.hi&lt;/code&gt; interface file if the new one is the same as the old one; this is friendly to &lt;strong&gt;make&lt;/strong&gt;. When an interface does change, it is often enlightening to be informed. The &lt;a href=&quot;#ghc-flag--ddump-hi-diffs&quot;&gt;&lt;code&gt;-ddump-hi-diffs&lt;/code&gt;&lt;/a&gt; option will make GHC report the differences between the old and new &lt;code&gt;.hi&lt;/code&gt; files.</source>
          <target state="translated">Компилятор не перезаписывает существующий интерфейсный файл &lt;code&gt;.hi&lt;/code&gt; , если новый такой же, как старый; это удобно &lt;strong&gt;делать&lt;/strong&gt; . Когда интерфейс действительно меняется, часто бывает полезно получить информацию. Параметр &lt;a href=&quot;#ghc-flag--ddump-hi-diffs&quot;&gt; &lt;code&gt;-ddump-hi-diffs&lt;/code&gt; &lt;/a&gt; заставит GHC сообщать о различиях между старым и новым файлами &lt;code&gt;.hi&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b50c4e0495b638bc78f832720f50e287f9de7a05" translate="yes" xml:space="preserve">
          <source>The compiler infers that the field is lazy, so it is tagged with &lt;code&gt;'DecidedLazy&lt;/code&gt;. Bear in mind that what the compiler decides may be quite different from what is written in the source. See &lt;code&gt;&lt;a href=&quot;ghc-generics#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; for a more detailed explanation.</source>
          <target state="translated">Компилятор делает вывод, что поле является ленивым, поэтому оно помечается тегом &lt;code&gt;'DecidedLazy&lt;/code&gt; . Помните, что решение компилятора может сильно отличаться от того, что написано в исходном коде. См. Более подробное объяснение в &lt;code&gt;&lt;a href=&quot;ghc-generics#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9774a668aa7877058c555311f9fc25aa40959a13" translate="yes" xml:space="preserve">
          <source>The compiler version can be tested within compiled code with the &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; CPP macro (defined only when &lt;a href=&quot;phases#extension-CPP&quot;&gt;&lt;code&gt;-XCPP&lt;/code&gt;&lt;/a&gt; is used). See &lt;a href=&quot;phases#standard-cpp-macros&quot;&gt;Standard CPP macros&lt;/a&gt; for details.</source>
          <target state="translated">Версия компилятора может быть протестирована в скомпилированном коде с помощью макроса &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; CPP (определяется только при использовании &lt;a href=&quot;phases#extension-CPP&quot;&gt; &lt;code&gt;-XCPP&lt;/code&gt; &lt;/a&gt; ). Подробнее см. &lt;a href=&quot;phases#standard-cpp-macros&quot;&gt;Стандартные макросы CPP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d31425166e0b9b41d209465f54952b68c26f02ba" translate="yes" xml:space="preserve">
          <source>The compiler will avoid reboxing &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt; by inlining &lt;code&gt;+&lt;/code&gt; on floats, but only when &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">Компилятор избегает переупаковки &lt;code&gt;f1&lt;/code&gt; и &lt;code&gt;f2&lt;/code&gt; , вставляя &lt;code&gt;+&lt;/code&gt; в числа с плавающей запятой, но только когда &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; включено .</target>
        </trans-unit>
        <trans-unit id="a57eab48089d44200f2aa63903639e1a99c72105" translate="yes" xml:space="preserve">
          <source>The compiler will warn here that the deriving clause doesn&amp;rsquo;t specify a strategy. If the warning is enabled, but &lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; is not enabled, the compiler will suggest turning on the &lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; extension. This option is not on by default, having to be turned on manually or with &lt;a href=&quot;#ghc-flag--Weverything&quot;&gt;&lt;code&gt;-Weverything&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Здесь компилятор предупредит, что в производном предложении не указана стратегия. Если предупреждение включено, но &lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt; &lt;code&gt;DerivingStrategies&lt;/code&gt; &lt;/a&gt; не включено, компилятор предложит включить расширение &lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt; &lt;code&gt;DerivingStrategies&lt;/code&gt; &lt;/a&gt; . Этот параметр не включен по умолчанию, его нужно включать вручную или с помощью &lt;a href=&quot;#ghc-flag--Weverything&quot;&gt; &lt;code&gt;-Weverything&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="281ed5525515ea0993e70db30ed197e71b26abff" translate="yes" xml:space="preserve">
          <source>The complete user-supplied kind signature specifies the polymorphic kind for &lt;code&gt;T&lt;/code&gt;, and this signature is used for all the calls to &lt;code&gt;T&lt;/code&gt; including the recursive ones. In particular, the recursive use of &lt;code&gt;T&lt;/code&gt; is at kind &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">Полная подпись вида, предоставляемая пользователем, определяет полиморфный вид для &lt;code&gt;T&lt;/code&gt; , и эта подпись используется для всех вызовов &lt;code&gt;T&lt;/code&gt; , включая рекурсивные. В частности, рекурсивное использование &lt;code&gt;T&lt;/code&gt; имеет вид &lt;code&gt;Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2bfd3d94f53069effc94df0d648f9c72f750ccc" translate="yes" xml:space="preserve">
          <source>The comprehension should typecheck when its desugaring would typecheck, except that (as discussed in &lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;Generalised (SQL-like) List Comprehensions&lt;/a&gt;) in the &amp;ldquo;then &lt;code&gt;f&lt;/code&gt;&amp;rdquo; and &amp;ldquo;then group using &lt;code&gt;f&lt;/code&gt;&amp;rdquo; clauses, when the &amp;ldquo;by &lt;code&gt;b&lt;/code&gt;&amp;rdquo; qualifier is omitted, argument &lt;code&gt;f&lt;/code&gt; should have a polymorphic type. In particular, &amp;ldquo;then &lt;code&gt;Data.List.sort&lt;/code&gt;&amp;rdquo; and &amp;ldquo;then group using &lt;code&gt;Data.List.group&lt;/code&gt;&amp;rdquo; are insufficiently polymorphic.</source>
          <target state="translated">Понимание должно проверять тип, когда его удаление сахара будет проверять тип, за исключением того, что (как описано в &lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;Обобщенных (SQL-подобных)&lt;/a&gt; компонентах списка ) в предложениях &amp;laquo;then &lt;code&gt;f&lt;/code&gt; &amp;raquo; и &amp;laquo;then group using &lt;code&gt;f&lt;/code&gt; &amp;raquo;, когда квалификатор &amp;laquo;by &lt;code&gt;b&lt;/code&gt; &amp;raquo; опущен, аргумент &lt;code&gt;f&lt;/code&gt; должен иметь полиморфный тип. В частности, &amp;laquo;затем &lt;code&gt;Data.List.sort&lt;/code&gt; &amp;raquo; и &amp;laquo;затем группировать с помощью &lt;code&gt;Data.List.group&lt;/code&gt; &amp;raquo; недостаточно полиморфны.</target>
        </trans-unit>
        <trans-unit id="e59db8b8873fb6251bff5cd6dfad77bf9b5938cd" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; is identical to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;, except that it works only on &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вычисление &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; идентично &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; , за исключением того, что оно работает только на &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cebda4e55c3afba7a9d7719124e3ada63e52bb27" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;prelude#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function appends the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">Вычислительная &lt;code&gt;&lt;a href=&quot;prelude#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; добавляет строку &lt;code&gt;str&lt;/code&gt; к файлу &lt;code&gt;file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46965f614145fd2e0bb961350e8543a37e0dd3ca" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;prelude#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function writes the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">Вычислительная &lt;code&gt;&lt;a href=&quot;prelude#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; записывает строку &lt;code&gt;str&lt;/code&gt; в файл &lt;code&gt;file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a4547aaf52f671ee4d0ac2c8d5630bfc87a6e62" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-cmd#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; runs the operating system command &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; in such a way that it receives as arguments the &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; strings exactly as given, with no funny escaping or shell meta-syntax expansion. It will therefore behave more portably between operating systems than &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вычисление &lt;code&gt;&lt;a href=&quot;system-cmd#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; запускает команду &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; операционной системы таким образом, что она получает в качестве аргументов строки &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; точно в том виде, в каком они заданы, без забавного экранирования или расширения метасинтаксиса оболочки. Следовательно, он будет вести себя более переносимо между операционными системами, чем &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9a90ff37849eb4211f81461b5303f42712fea0c" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exitfail&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, where &lt;em&gt;exitfail&lt;/em&gt; is implementation-dependent.</source>
          <target state="translated">Вычисление &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; эквивалентно &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exitfail &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; , где &lt;em&gt;exitfail&lt;/em&gt; зависит от реализации.</target>
        </trans-unit>
        <trans-unit id="fc29dbc900c1c24c106776b04df9bca05e5cfe6e" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exitfail&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, where &lt;em&gt;exitfail&lt;/em&gt; is implementation-dependent.</source>
          <target state="translated">Вычисление &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; эквивалентно &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exitfail &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; , где &lt;em&gt;exitfail&lt;/em&gt; зависит от реализации.</target>
        </trans-unit>
        <trans-unit id="fb6d36ed658ece003695ded60aa84d344703fa74" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-exit#v:exitSuccess&quot;&gt;exitSuccess&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt;, It terminates the program successfully.</source>
          <target state="translated">Вычисление &lt;code&gt;&lt;a href=&quot;system-exit#v:exitSuccess&quot;&gt;exitSuccess&lt;/a&gt;&lt;/code&gt; эквивалентно &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt; , оно успешно завершает программу.</target>
        </trans-unit>
        <trans-unit id="a4d04e67ce9ab76c0bbbdea2ad0f01cd7fcbeeb5" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-io#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function appends the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">Вычислительная &lt;code&gt;&lt;a href=&quot;system-io#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; добавляет строку &lt;code&gt;str&lt;/code&gt; к файлу &lt;code&gt;file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18d116851ac5689419eab11fff58738d4aba225b" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-io#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; is identical to &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;, except that it works only on &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вычисление &lt;code&gt;&lt;a href=&quot;system-io#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; идентично &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; , за исключением того, что оно работает только на &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46ebfbedadd3b348e49908c00c7a136ae0a3b598" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-io#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function writes the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">Вычислительная &lt;code&gt;&lt;a href=&quot;system-io#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; записывает строку &lt;code&gt;str&lt;/code&gt; в файл &lt;code&gt;file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="beccc8e7666a74c9241e66c916390d713f7e9a28" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-process#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; runs the operating system command &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; in such a way that it receives as arguments the &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; strings exactly as given, with no funny escaping or shell meta-syntax expansion. It will therefore behave more portably between operating systems than &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вычисление &lt;code&gt;&lt;a href=&quot;system-process#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; запускает команду &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; операционной системы таким образом, что она получает в качестве аргументов строки &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; точно в том виде, в каком они заданы, без забавного экранирования или расширения метасинтаксиса оболочки. Следовательно, он будет вести себя более переносимо между операционными системами, чем &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f1a05335883c13dae3be1b4a36833b306a5efd1" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To ensure that the computation is performed only once, use &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Вычисление может выполняться несколько раз разными потоками, возможно, в одно и то же время. Чтобы гарантировать, что вычисление выполняется только один раз, используйте вместо этого &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44b39b2d94fcf4d161bbbadc2ba27b97f45eae93" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To ensure that the computation is performed only once, use &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Вычисление может выполняться несколько раз разными потоками, возможно, в одно и то же время. Чтобы гарантировать, что вычисление выполняется только один раз, используйте вместо этого &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="add1c55634d2623f9699ebad8b5515dd2d17e5c6" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To prevent this, use &lt;code&gt;&lt;a href=&quot;control-monad-st-unsafe#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Вычисление может выполняться несколько раз разными потоками, возможно, в одно и то же время. Чтобы предотвратить это, используйте вместо этого &lt;code&gt;&lt;a href=&quot;control-monad-st-unsafe#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07d17cfabe3f3fcfca85238e3259375c3de9c784" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To prevent this, use &lt;code&gt;&lt;a href=&quot;ghc-st#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Вычисление может выполняться несколько раз разными потоками, возможно, в одно и то же время. Чтобы предотвратить это, используйте вместо этого &lt;code&gt;&lt;a href=&quot;ghc-st#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52f9695a125810fcb1729c58e4b509090979268c" translate="yes" xml:space="preserve">
          <source>The computation to run</source>
          <target state="translated">Расчёт на выполнение</target>
        </trans-unit>
        <trans-unit id="7849b8b63ccfaa0ec4dad86a18080d47939b33fc" translate="yes" xml:space="preserve">
          <source>The concatenation of all the elements of a container of lists.</source>
          <target state="translated">Конкатенация всех элементов контейнера списков.</target>
        </trans-unit>
        <trans-unit id="511dfe8f476504df65281a958ed6b2922f8e44b9" translate="yes" xml:space="preserve">
          <source>The concurrency extension for Haskell is described in the paper &lt;em&gt;Concurrent Haskell&lt;/em&gt;&lt;a href=&quot;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&lt;/a&gt;.</source>
          <target state="translated">Расширение параллелизма для Haskell описано в статье &lt;em&gt;Concurrent Haskell &lt;/em&gt;&lt;a href=&quot;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00393330d59cb21f77b62b7a951195b4749b08f5" translate="yes" xml:space="preserve">
          <source>The conjugate of a complex number.</source>
          <target state="translated">Конъюгат сложного числа.</target>
        </trans-unit>
        <trans-unit id="7e61d83010032d16fcd6d96bc1ee67e74abc2ee7" translate="yes" xml:space="preserve">
          <source>The connected components of a graph. Two vertices are connected if there is a path between them, traversing edges in either direction.</source>
          <target state="translated">Подключенные компоненты графика.Две вершины соединяются,если между ними есть путь,пересекающий рёбра в любом направлении.</target>
        </trans-unit>
        <trans-unit id="b5b6ceffe39d0d5eedc736955541b7ffa6430ede" translate="yes" xml:space="preserve">
          <source>The cons constructor (e.g &lt;code&gt;3:4:[]&lt;/code&gt;)</source>
          <target state="translated">Конструктор cons (например, &lt;code&gt;3:4:[]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8ba3b2a290b55dc2fc0d0d6af5a22e45514ed39e" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">Константа &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; содержит отличительное значение &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; , которое не связано с допустимой ячейкой памяти.</target>
        </trans-unit>
        <trans-unit id="28d23ff9245e92f331af466af03ff314f5479be2" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">Константа &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; содержит выделенное значение &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; , которое не связано с допустимой ячейкой памяти.</target>
        </trans-unit>
        <trans-unit id="9836a72bb97f8856c19c64a657d43deda4d232f2" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">Константа &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; содержит отличительное значение &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; , которое не связано с допустимой ячейкой памяти.</target>
        </trans-unit>
        <trans-unit id="f76a0e137f54f18c3f7ac1708ea489f83a12cf45" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">Константа &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; содержит выделенное значение &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; , которое не связано с допустимой ячейкой памяти.</target>
        </trans-unit>
        <trans-unit id="86d0acfb8c600d07e3b3575390f9c70049148847" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">Константа &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; содержит выделенное значение &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; , которое не связано с допустимой ячейкой памяти.</target>
        </trans-unit>
        <trans-unit id="aee9b6f259cc959b36e11590eea5cb4db85f0c33" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;system-win32-types#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">Константа &lt;code&gt;&lt;a href=&quot;system-win32-types#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; содержит выделенное значение &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; , которое не связано с допустимой ячейкой памяти.</target>
        </trans-unit>
        <trans-unit id="799dc66320c38ca69a9441401db6bffcbf9eb360" translate="yes" xml:space="preserve">
          <source>The constant functor.</source>
          <target state="translated">Постоянный весельчак.</target>
        </trans-unit>
        <trans-unit id="15ca88cd220e51ba407b106275a1029cb4b766e9" translate="yes" xml:space="preserve">
          <source>The constraint &lt;code&gt;Coercible t1 t2&lt;/code&gt; is similar to &lt;code&gt;t1 ~ t2&lt;/code&gt;, but denotes representational equality between &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; in the sense of Roles (&lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;). It is exported by &lt;a href=&quot;../libraries/base-4.13.0.0/data-coerce&quot;&gt;Data.Coerce&lt;/a&gt;, which also contains the documentation. More details and discussion can be found in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf&quot;&gt;&amp;ldquo;Safe Coercions&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">Ограничение &lt;code&gt;Coercible t1 t2&lt;/code&gt; похоже на &lt;code&gt;t1 ~ t2&lt;/code&gt; , но обозначает репрезентативное равенство между &lt;code&gt;t1&lt;/code&gt; и &lt;code&gt;t2&lt;/code&gt; в смысле ролей ( &lt;a href=&quot;#roles&quot;&gt;ролей&lt;/a&gt; ). Его экспортирует &lt;a href=&quot;../libraries/base-4.13.0.0/data-coerce&quot;&gt;Data.Coerce&lt;/a&gt; , который также содержит документацию. Более подробную информацию и обсуждение можно найти в статье &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf&quot;&gt;&amp;laquo;Безопасное принуждение&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b45d0e4831d974f0b76095cef9bc4b87f2ec6bb" translate="yes" xml:space="preserve">
          <source>The constraint has fewer constructors and variables (taken together and counting repetitions) than the head</source>
          <target state="translated">Ограничение имеет меньшее количество конструкторов и переменных (взятых вместе и считающих повторы),чем головка</target>
        </trans-unit>
        <trans-unit id="a50d755f429fad42bcff479620bc13360a0c4b46" translate="yes" xml:space="preserve">
          <source>The constraint mentions at least one type variable. So this is allowed:</source>
          <target state="translated">Ограничение упоминает хотя бы одну переменную типа.Так что это разрешено:</target>
        </trans-unit>
        <trans-unit id="ce649c6fe844bb02501d53bdc8fcdcf10a388961" translate="yes" xml:space="preserve">
          <source>The constraint mentions no type functions. A type function application can in principle expand to a type of arbitrary size, and so are rejected out of hand</source>
          <target state="translated">Ограничение указывает на отсутствие функций типа.Применение функции типа в принципе может расширяться до типа произвольного размера,а потому отвергается из рук в руки</target>
        </trans-unit>
        <trans-unit id="e1443e2e18615f60be07422db9598a6ab2679217" translate="yes" xml:space="preserve">
          <source>The constraints: &lt;code&gt;(C1, C2, ..)&lt;/code&gt;</source>
          <target state="translated">Ограничения: &lt;code&gt;(C1, C2, ..)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="112775bf1168cc3582de7a46d153e201b0ce10f8" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt;&lt;code&gt;comp&lt;/code&gt; exposes IO errors which occur within a computation, and which are not fully handled.</source>
          <target state="translated">Конструкция &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt; &lt;code&gt;comp&lt;/code&gt; выявляет ошибки ввода-вывода, которые возникают в процессе вычислений и не обрабатываются полностью.</target>
        </trans-unit>
        <trans-unit id="f2cbf6e1527ac15029debb90371be54661016768" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;&lt;a href=&quot;system-io-error#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt;&lt;code&gt;comp&lt;/code&gt; exposes IO errors which occur within a computation, and which are not fully handled.</source>
          <target state="translated">Конструкция &lt;code&gt;&lt;a href=&quot;system-io-error#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt; &lt;code&gt;comp&lt;/code&gt; выявляет ошибки ввода-вывода, которые возникают в процессе вычислений и не обрабатываются полностью.</target>
        </trans-unit>
        <trans-unit id="d9cb341bdfdb67d6c8abafd06a4a86c8917f60b5" translate="yes" xml:space="preserve">
          <source>The constructors for &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; can roughly be divided up into two categories: those for constructors with &quot;vanilla&quot; syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt;), and those for constructors with GADT syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt;). The &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; constructor, which quantifies additional type variables and class contexts, can surround either variety of constructor. However, the type variables that it quantifies are different depending on what constructor syntax is used:</source>
          <target state="translated">Конструкторы для &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; можно условно разделить на две категории: конструкторы с &amp;laquo;ванильным&amp;raquo; синтаксисом ( &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt; ) и конструкторы с синтаксисом GADT ( &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt; ). Конструктор &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; , который количественно определяет переменные дополнительных типов и контексты классов, может окружать любой из вариантов конструктора. Однако переменные типа, которые он определяет количественно, различаются в зависимости от того, какой синтаксис конструктора используется:</target>
        </trans-unit>
        <trans-unit id="96dfdfe1a048f1f49896be9e99d5931a975888f5" translate="yes" xml:space="preserve">
          <source>The constructors for &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; can roughly be divided up into two categories: those for constructors with &quot;vanilla&quot; syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt;), and those for constructors with GADT syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt;). The &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; constructor, which quantifies additional type variables and class contexts, can surround either variety of constructor. However, the type variables that it quantifies are different depending on what constructor syntax is used:</source>
          <target state="translated">Конструкторы для &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; можно условно разделить на две категории: конструкторы с &amp;laquo;ванильным&amp;raquo; синтаксисом ( &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt; ) и конструкторы с синтаксисом GADT ( &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt; ). Конструктор &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; , который количественно определяет переменные дополнительных типов и контексты классов, может окружать любой из вариантов конструктора. Однако переменные типа, которые он определяет количественно, различаются в зависимости от того, какой синтаксис конструктора используется:</target>
        </trans-unit>
        <trans-unit id="d2ef5f16504fcf65ef460021616315706e1e4d2a" translate="yes" xml:space="preserve">
          <source>The constructors have rank-2 types:</source>
          <target state="translated">Строители занимают 2-е место:</target>
        </trans-unit>
        <trans-unit id="f9e51adba83704f5afe34590e66e2249e5965154" translate="yes" xml:space="preserve">
          <source>The contents of &lt;code&gt;OPTIONS_GHC&lt;/code&gt; are appended to the command-line options, so options given in the source file override those given on the command-line.</source>
          <target state="translated">Содержимое &lt;code&gt;OPTIONS_GHC&lt;/code&gt; добавляется к параметрам командной строки, поэтому параметры, указанные в исходном файле, переопределяют параметры, указанные в командной строке.</target>
        </trans-unit>
        <trans-unit id="dff9227ff63668c69518bca492a298e49c135a62" translate="yes" xml:space="preserve">
          <source>The contents of this module is liable to change, or disappear entirely. Please &lt;a href=&quot;https://github.com/haskell/time/issues/new&quot;&gt;let me know&lt;/a&gt; if you depend on anything here.</source>
          <target state="translated">Содержимое этого модуля может измениться или полностью исчезнуть. Пожалуйста, &lt;a href=&quot;https://github.com/haskell/time/issues/new&quot;&gt;дайте мне знать,&lt;/a&gt; если вы здесь от чего-то зависите.</target>
        </trans-unit>
        <trans-unit id="8a40246a3e18d1d7e41c15d6857dbf0b4d63fa72" translate="yes" xml:space="preserve">
          <source>The contents of this module may change &lt;strong&gt;in any way whatsoever&lt;/strong&gt; and &lt;strong&gt;without any warning&lt;/strong&gt; between minor versions of this package.</source>
          <target state="translated">Содержимое этого модуля может измениться &lt;strong&gt;в любой форме&lt;/strong&gt; и &lt;strong&gt;без какого - либо предупреждения&lt;/strong&gt; между незначительными версиями этого пакета.</target>
        </trans-unit>
        <trans-unit id="bf37f21b6a3daad2c6c95d66502066032ad944e9" translate="yes" xml:space="preserve">
          <source>The continuation monad transformer. Can be used to add continuation handling to any type constructor: the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance and most of the operations do not require &lt;code&gt;m&lt;/code&gt; to be a monad.</source>
          <target state="translated">Преобразователь монад продолжения. Может использоваться для добавления обработки продолжения к любому конструктору типа: экземпляр &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; и большинство операций не требуют, чтобы &lt;code&gt;m&lt;/code&gt; был монадой.</target>
        </trans-unit>
        <trans-unit id="f75193e312873c254935fbb8e4b2cdc1397df81b" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;code&gt;makeAbsolute&lt;/code&gt; function can be found in &lt;code&gt;System.Directory&lt;/code&gt;.</source>
          <target state="translated">Соответствующую функцию &lt;code&gt;makeAbsolute&lt;/code&gt; можно найти в &lt;code&gt;System.Directory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbffcb96186edf6acc0b855b93198f4a5cdf1151" translate="yes" xml:space="preserve">
          <source>The corresponding translation for an IO-typed &lt;code&gt;e&lt;/code&gt; is</source>
          <target state="translated">Соответствующий перевод для &lt;code&gt;e&lt;/code&gt; с типом ввода-вывода :</target>
        </trans-unit>
        <trans-unit id="86d8b09707b93cf768c10a7d141f2453f73455d0" translate="yes" xml:space="preserve">
          <source>The costs of all CAFs in a module are usually attributed to one &amp;ldquo;big&amp;rdquo; CAF cost-centre. With this option, all CAFs get their own cost-centre. An &amp;ldquo;if all else fails&amp;rdquo; option&amp;hellip;</source>
          <target state="translated">Затраты на все CAF в модуле обычно относятся к одному &amp;laquo;большому&amp;raquo; центру затрат CAF. При использовании этого варианта все CAF получают собственный центр затрат. Вариант &amp;laquo;если ничего не помогает&amp;raquo;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="7cf65e46a7de9baa89f7b3eb6db073c4649dd328" translate="yes" xml:space="preserve">
          <source>The cumulative allocations of the program in bytes.</source>
          <target state="translated">Суммарные распределения программы в байтах.</target>
        </trans-unit>
        <trans-unit id="7a3b930a34c98c0e41a7bef5730a3bbf42841f7f" translate="yes" xml:space="preserve">
          <source>The current implementation of the &lt;code&gt;OverloadedLists&lt;/code&gt; extension can be improved by handling the lists that are only populated with literals in a special way. More specifically, the compiler could allocate such lists statically using a compact representation and allow &lt;code&gt;IsList&lt;/code&gt; instances to take advantage of the compact representation. Equipped with this capability the &lt;code&gt;OverloadedLists&lt;/code&gt; extension will be in a good position to subsume the &lt;code&gt;OverloadedStrings&lt;/code&gt; extension (currently, as a special case, string literals benefit from statically allocated compact representation).</source>
          <target state="translated">Текущая реализация расширения &lt;code&gt;OverloadedLists&lt;/code&gt; может быть улучшена путем обработки списков, которые содержат только литералы особым образом. В частности, компилятор может &lt;code&gt;IsList&lt;/code&gt; такие списки статически, используя компактное представление, и позволяет экземплярам IsList использовать преимущества компактного представления. Обладая этой возможностью, расширение &lt;code&gt;OverloadedLists&lt;/code&gt; будет в хорошей позиции для включения расширения &lt;code&gt;OverloadedStrings&lt;/code&gt; (в настоящее время, как особый случай, строковые литералы выигрывают от статически распределенного компактного представления).</target>
        </trans-unit>
        <trans-unit id="1ad91c37c3debcd3611b7e9c0f27ffd87d2d02eb" translate="yes" xml:space="preserve">
          <source>The current notion of when two view pattern expressions are &amp;ldquo;the same&amp;rdquo; is very restricted: it is not even full syntactic equality. However, it does include variables, literals, applications, and tuples; e.g., two instances of &lt;code&gt;view (&quot;hi&quot;, &quot;there&quot;)&lt;/code&gt; will be collected. However, the current implementation does not compare up to alpha-equivalence, so two instances of &lt;code&gt;(x, view x -&amp;gt; y)&lt;/code&gt; will not be coalesced.</source>
          <target state="translated">Текущее понятие того, когда два выражения шаблона представления являются &amp;laquo;одинаковыми&amp;raquo;, очень ограничено: это даже не полное синтаксическое равенство. Однако он включает переменные, литералы, приложения и кортежи; например, будут собраны два экземпляра &lt;code&gt;view (&quot;hi&quot;, &quot;there&quot;)&lt;/code&gt; . Однако текущая реализация не сравнивается до альфа-эквивалентности, поэтому два экземпляра &lt;code&gt;(x, view x -&amp;gt; y)&lt;/code&gt; не будут объединены.</target>
        </trans-unit>
        <trans-unit id="2a1a29ae3433386a16c919320319cfdd85da4c46" translate="yes" xml:space="preserve">
          <source>The current status of a thread</source>
          <target state="translated">Текущее состояние резьбы</target>
        </trans-unit>
        <trans-unit id="82c826fe4c2ec0dd5e2b6732f42c3a1009fa7e05" translate="yes" xml:space="preserve">
          <source>The current thread's stack exceeded its limit. Since an exception has been raised, the thread's stack will certainly be below its limit again, but the programmer should take remedial action immediately.</source>
          <target state="translated">Текущая резьба в стопке превысила свой предел.Поскольку было поднято исключение,стек потока,конечно,снова будет ниже своего предела,но программист должен немедленно принять меры по исправлению ситуации.</target>
        </trans-unit>
        <trans-unit id="ed3b026bad78c443d4533994012a8c4a2846cb3c" translate="yes" xml:space="preserve">
          <source>The current value of the &lt;code&gt;-N&lt;/code&gt; option is available to the Haskell program via &lt;code&gt;Control.Concurrent.getNumCapabilities&lt;/code&gt;, and it may be changed while the program is running by calling &lt;code&gt;Control.Concurrent.setNumCapabilities&lt;/code&gt;.</source>
          <target state="translated">Текущее значение параметра &lt;code&gt;-N&lt;/code&gt; доступно программе Haskell через &lt;code&gt;Control.Concurrent.getNumCapabilities&lt;/code&gt; , и его можно изменить во время работы программы, вызвав &lt;code&gt;Control.Concurrent.setNumCapabilities&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ec8f77a94455e151e4c1a9e7ec7c517542a0b66" translate="yes" xml:space="preserve">
          <source>The cut-down Haskell lexer, used by Text.Read</source>
          <target state="translated">Сокращенный лексер Хаскелла,используемый в Text.Read.</target>
        </trans-unit>
        <trans-unit id="00bd3d9662d83ac9ec53f0ae935356d4eabc4566" translate="yes" xml:space="preserve">
          <source>The data family &lt;code&gt;URec&lt;/code&gt; is provided to enable generic programming over datatypes with certain unlifted arguments. There are six instances corresponding to common unlifted types:</source>
          <target state="translated">Семейство данных &lt;code&gt;URec&lt;/code&gt; предоставляется для обеспечения универсального программирования над типами данных с определенными неподтвержденными аргументами. Есть шесть экземпляров, соответствующих распространенным типам без лифтинга:</target>
        </trans-unit>
        <trans-unit id="7cc312cbbdd186a59028317a6d6a5545651161f0" translate="yes" xml:space="preserve">
          <source>The data or type family instance for an associated type must follow the rule that the type indexes corresponding to class parameters must have precisely the same as type given in the instance head. For example:</source>
          <target state="translated">Экземпляр данных или семейства типов для ассоциированного типа должен следовать правилу,согласно которому индексы типов,соответствующие параметрам класса,должны иметь точно такой же тип,как и в заголовке экземпляра.Например:</target>
        </trans-unit>
        <trans-unit id="5c9753438fba7e9bfbfa96374f6632d59b89893a" translate="yes" xml:space="preserve">
          <source>The data type &lt;code&gt;Foo&lt;/code&gt; has two constructors with types:</source>
          <target state="translated">Тип данных &lt;code&gt;Foo&lt;/code&gt; имеет два конструктора с типами:</target>
        </trans-unit>
        <trans-unit id="e622f9e9a73471a6364b9efb8251bd756d0f5650" translate="yes" xml:space="preserve">
          <source>The data type invariant for lazy &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;: Every &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; or consists of non-null &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s. All functions must preserve this, and the QC properties must check this.</source>
          <target state="translated">Инвариант типа данных для отложенного &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; : каждый &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; либо &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; либо состоит из ненулевых &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; . Все функции должны сохранять это, и свойства QC должны это проверять.</target>
        </trans-unit>
        <trans-unit id="5d0441bbee470c2143c8f36a2d1679d26b7e70ba" translate="yes" xml:space="preserve">
          <source>The data type invariant: Every ByteString is either &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; or consists of non-null &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. All functions must preserve this, and the QC properties must check this.</source>
          <target state="translated">Инвариант типа данных: каждая ByteString либо &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; либо состоит из ненулевых &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; s. Все функции должны сохранять это, и свойства QC должны это проверять.</target>
        </trans-unit>
        <trans-unit id="7d85f04588f07b22aadb87552b730e4cf6174d81" translate="yes" xml:space="preserve">
          <source>The data types and monadic constructor functions for Template Haskell are in the library &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt;.</source>
          <target state="translated">Типы данных и функции монадического конструктора для Template Haskell находятся в библиотеке &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65cb9fa712c4ef1743587a031048fc3377115bf6" translate="yes" xml:space="preserve">
          <source>The datatype below derives the &lt;code&gt;Eq&lt;/code&gt; typeclass, but doesn&amp;rsquo;t specify a strategy. When &lt;a href=&quot;#ghc-flag--Wmissing-deriving-strategies&quot;&gt;&lt;code&gt;-Wmissing-deriving-strategies&lt;/code&gt;&lt;/a&gt; is enabled, the compiler will emit a warning about this.</source>
          <target state="translated">Тип данных ниже является производным от класса типов &lt;code&gt;Eq&lt;/code&gt; , но не определяет стратегию. Когда &lt;a href=&quot;#ghc-flag--Wmissing-deriving-strategies&quot;&gt; &lt;code&gt;-Wmissing-deriving-strategies&lt;/code&gt; &lt;/a&gt; включен, компилятор выдаст предупреждение об этом.</target>
        </trans-unit>
        <trans-unit id="09ea5a667a11159497b7db70c8ac2393a6a6a569" translate="yes" xml:space="preserve">
          <source>The day of the epoch of &lt;code&gt;&lt;a href=&quot;data-time-clock-system#t:SystemTime&quot;&gt;SystemTime&lt;/a&gt;&lt;/code&gt;, 1970-01-01</source>
          <target state="translated">День эпохи &lt;code&gt;&lt;a href=&quot;data-time-clock-system#t:SystemTime&quot;&gt;SystemTime&lt;/a&gt;&lt;/code&gt; , 01.01.1970</target>
        </trans-unit>
        <trans-unit id="425505b50ca94bcb223c9489d59b624f0fd02138" translate="yes" xml:space="preserve">
          <source>The debugger provides the following:</source>
          <target state="translated">Отладчик предоставляет следующее:</target>
        </trans-unit>
        <trans-unit id="d008597f45a1f7e417f2daa3afa26ed473de0e47" translate="yes" xml:space="preserve">
          <source>The debugging options &lt;code&gt;-Dx&lt;/code&gt; also generate events which are logged using the tracing framework. By default those events are dumped as text to stdout (&lt;code&gt;-Dx&lt;/code&gt; implies &lt;code&gt;-v&lt;/code&gt;), but they may instead be stored in the binary eventlog file by using the &lt;code&gt;-l&lt;/code&gt; option.</source>
          <target state="translated">Параметры отладки &lt;code&gt;-Dx&lt;/code&gt; также генерируют события, которые регистрируются с помощью среды трассировки. По умолчанию эти события &lt;code&gt;-Dx&lt;/code&gt; виде текста на стандартный вывод ( -Dx подразумевает &lt;code&gt;-v&lt;/code&gt; ), но вместо этого они могут быть сохранены в двоичном файле журнала событий с помощью параметра &lt;code&gt;-l&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8dbf33fb940a3d9f2a5b57f121f6732a25396c40" translate="yes" xml:space="preserve">
          <source>The declaration</source>
          <target state="translated">Декларация</target>
        </trans-unit>
        <trans-unit id="61598f72e2c92204906e453b4899d9c4f265e7a4" translate="yes" xml:space="preserve">
          <source>The declaration for &lt;code&gt;HCons&lt;/code&gt; also requires &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; because of infix type operator &lt;code&gt;(':)&lt;/code&gt;</source>
          <target state="translated">Объявление &lt;code&gt;HCons&lt;/code&gt; также требует &lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt; из-за оператора инфиксного типа &lt;code&gt;(':)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e4404a7232bfc86c4b3054c2503dd6ddca4de51d" translate="yes" xml:space="preserve">
          <source>The declaration group containing &lt;code&gt;D&lt;/code&gt; is terminated by the empty top-level declaration splice &lt;code&gt;$(return [])&lt;/code&gt; (recall, &lt;code&gt;Q&lt;/code&gt; is a Monad, so we may simply &lt;code&gt;return&lt;/code&gt; the empty list of declarations).</source>
          <target state="translated">Группа объявлений, содержащая &lt;code&gt;D&lt;/code&gt; , завершается пустым объявлением верхнего уровня splice &lt;code&gt;$(return [])&lt;/code&gt; (напомним, &lt;code&gt;Q&lt;/code&gt; - это монада, поэтому мы можем просто &lt;code&gt;return&lt;/code&gt; пустой список объявлений).</target>
        </trans-unit>
        <trans-unit id="4f3eb1e20a19137970a20b350de0e993090c5f42" translate="yes" xml:space="preserve">
          <source>The declarations and types from signatures of dependencies that will be merged in are not in scope when type checking an &lt;code&gt;hsig&lt;/code&gt; file. To refer to any such type, you must declare it yourself:</source>
          <target state="translated">Объявления и типы из сигнатур зависимостей, которые будут объединены, не входят в область видимости при проверке &lt;code&gt;hsig&lt;/code&gt; файла hsig . Чтобы ссылаться на любой такой тип, вы должны объявить его самостоятельно:</target>
        </trans-unit>
        <trans-unit id="28bc248b719a26880d510c50487bc9904247476f" translate="yes" xml:space="preserve">
          <source>The decoder has consumed the available input and needs more to continue. Provide &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; if more input is available and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; otherwise, and you will get a new &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Декодер израсходовал доступный вход, и для продолжения требуется больше. Укажите &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; , если доступно больше входных данных, и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; в противном случае, и вы получите новый &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7be60721ea4767c773d4ff5809e621bbad6d744b" translate="yes" xml:space="preserve">
          <source>The decoder has successfully finished. Except for the output value you also get any unused input as well as the number of bytes consumed.</source>
          <target state="translated">Декодер успешно закончил.Кроме выходного значения вы также получаете любой неиспользованный вход,а также количество потребленных байтов.</target>
        </trans-unit>
        <trans-unit id="c50453020b64e1b5897a128e6a4b8f6fd0ce71b8" translate="yes" xml:space="preserve">
          <source>The decoder ran into an error. The decoder either used &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; or was not provided enough input. Contains any unconsumed input and the number of bytes consumed.</source>
          <target state="translated">В декодере произошла ошибка. Декодер либо использовал &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; либо не получил достаточного ввода. Содержит все неиспользованные входные данные и количество использованных байтов.</target>
        </trans-unit>
        <trans-unit id="1106af4463a8221ffa09eb5ef1181409ca7b66ab" translate="yes" xml:space="preserve">
          <source>The decoder to isolate</source>
          <target state="translated">Декодер для изоляции</target>
        </trans-unit>
        <trans-unit id="9109ffd32c6c50a2b3bbde42b4613b2367726367" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; for a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:nativeNewlineMode&quot;&gt;nativeNewlineMode&lt;/a&gt;&lt;/code&gt;, which does no translation on Unix systems, but translates &lt;code&gt;'\r\n'&lt;/code&gt; to &lt;code&gt;'\n'&lt;/code&gt; and back on Windows.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; по умолчанию для &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; - &lt;code&gt;&lt;a href=&quot;system-io#v:nativeNewlineMode&quot;&gt;nativeNewlineMode&lt;/a&gt;&lt;/code&gt; , который не переводится в системах Unix, но переводит &lt;code&gt;'\r\n'&lt;/code&gt; в &lt;code&gt;'\n'&lt;/code&gt; и обратно в Windows.</target>
        </trans-unit>
        <trans-unit id="e1abf9eda04f648cec0d055b085fe295d921786f" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is the same as the default encoding on your system, which is also available as &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt;. (GHC note: on Windows, we currently do not support double-byte encodings; if the console's code page is unsupported, then &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; will be &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; по умолчанию совпадает с кодировкой по умолчанию в вашей системе, которая также доступна как &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; . (Примечание GHC: в Windows мы в настоящее время не поддерживаем двухбайтовые кодировки; если кодовая страница консоли не поддерживается, то &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; будет &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="1f7510baab521b5948629307f9f6f4dc19cd4a03" translate="yes" xml:space="preserve">
          <source>The default backend for GHC. It is a native code generator, compiling Cmm all the way to assembly code. It is the fastest backend and generally produces good performance code. It has the best support for compiling shared libraries. Select it with the &lt;code&gt;-fasm&lt;/code&gt; flag.</source>
          <target state="translated">Бэкэнд по умолчанию для GHC. Это генератор собственного кода, полностью компилирующий Cmm до кода сборки. Это самый быстрый бэкэнд и обычно производит код с хорошей производительностью. Он имеет лучшую поддержку для компиляции разделяемых библиотек. Выберите его с &lt;code&gt;-fasm&lt;/code&gt; флага -fasm .</target>
        </trans-unit>
        <trans-unit id="372a76ca948e47b638039a6cfbc912e969dc50c4" translate="yes" xml:space="preserve">
          <source>The default buffering mode is different in GHCi to GHC.</source>
          <target state="translated">Режим буферизации по умолчанию отличается в GHCi от GHC.</target>
        </trans-unit>
        <trans-unit id="612f5aad425db1f69a9dbdbaaa3947648f24e8cc" translate="yes" xml:space="preserve">
          <source>The default buffering mode when a handle is opened is implementation-dependent and may depend on the file system object which is attached to that handle. For most implementations, physical files will normally be block-buffered and terminals will normally be line-buffered.</source>
          <target state="translated">Режим буферизации по умолчанию при открытии дескриптора зависит от реализации и может зависеть от объекта файловой системы,который прикреплен к этому дескриптору.Для большинства реализаций физические файлы обычно будут блочно буферизироваться,а терминалы-линейно буферизироваться.</target>
        </trans-unit>
        <trans-unit id="0961e4a3376f291925aa422749fabd42ce25f975" translate="yes" xml:space="preserve">
          <source>The default declaration must mention only type &lt;em&gt;variables&lt;/em&gt; on the left hand side, and the right hand side must mention only type variables that are explicitly bound on the left hand side. This restriction is relaxed for &lt;em&gt;kind&lt;/em&gt; variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound on the left hand side.</source>
          <target state="translated">Объявление по умолчанию должно упоминать только &lt;em&gt;переменные&lt;/em&gt; типа с левой стороны, а с правой стороны должны упоминаться только переменные типа, которые явно привязаны к левой стороне. Это ограничение смягчается для &lt;em&gt;рода&lt;/em&gt; переменных, однако, как правая рука разрешается упоминать рода переменные, которые неявно связанные с левой стороны.</target>
        </trans-unit>
        <trans-unit id="e629035dab4042ca2e3774c6dd02fa07a19ca5ba" translate="yes" xml:space="preserve">
          <source>The default definition for &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt;, which is suitable for abstract datatypes with no substructures.</source>
          <target state="translated">Определением по умолчанию для &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; , который подходит для абстрактных типов данных без подструктур.</target>
        </trans-unit>
        <trans-unit id="b37307a1a8b5c8a76936f7e75a2ac6d6c53b888a" translate="yes" xml:space="preserve">
          <source>The default definition instantiates the type constructor &lt;code&gt;c&lt;/code&gt; in the type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; to an identity datatype constructor, using the isomorphism pair as injection and projection.</source>
          <target state="translated">Определение по умолчанию создает экземпляр конструктора типа &lt;code&gt;c&lt;/code&gt; в типе &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; для конструктора типа данных идентичности, используя пару изоморфизма в качестве внедрения и проекции.</target>
        </trans-unit>
        <trans-unit id="0ebc5859a93e62be528328f3201553481af2edf0" translate="yes" xml:space="preserve">
          <source>The default definition instantiates the type constructor &lt;code&gt;c&lt;/code&gt; in the type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; to the monad datatype constructor, defining injection and projection using &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Определение по умолчанию создает экземпляр конструктора типа &lt;code&gt;c&lt;/code&gt; в типе &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; для конструктора типа данных монады, определяя внедрение и проекцию с помощью &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bd4056577869d6ffa3c25c8d2085ea54f8f3b3d" translate="yes" xml:space="preserve">
          <source>The default definition is</source>
          <target state="translated">Определение по умолчанию</target>
        </trans-unit>
        <trans-unit id="0c68a975cf82f38a807abb27f8056b694f43e039" translate="yes" xml:space="preserve">
          <source>The default definition is &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, which is appropriate for instances of other forms.</source>
          <target state="translated">Определение по умолчанию - &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , что подходит для экземпляров других форм.</target>
        </trans-unit>
        <trans-unit id="aa9945acbeccb98293938a8f8c707927dd353e5f" translate="yes" xml:space="preserve">
          <source>The default definition may be overridden with a more efficient version if desired.</source>
          <target state="translated">Определение по умолчанию при желании может быть переопределено более эффективной версией.</target>
        </trans-unit>
        <trans-unit id="71589b344fdce3f6d3065162df2b93817e514841" translate="yes" xml:space="preserve">
          <source>The default definition should be sufficient, but this can be overridden for efficiency.</source>
          <target state="translated">Определение по умолчанию должно быть достаточным,но это может быть перекрыто для эффективности.</target>
        </trans-unit>
        <trans-unit id="b230bf83d4661530a10d60a3a4832bae81967728" translate="yes" xml:space="preserve">
          <source>The default definition uses &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList&quot;&gt;liftReadList&lt;/a&gt;&lt;/code&gt;. Instances that define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; should also define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrecDefault&quot;&gt;liftReadListPrecDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В определении по умолчанию используется &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList&quot;&gt;liftReadList&lt;/a&gt;&lt;/code&gt; . Экземпляры, которые определяют &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; , также должны определять &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; как &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrecDefault&quot;&gt;liftReadListPrecDefault&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b8f0470f58f998c4d12f0e8356a21d2ca7b5de3" translate="yes" xml:space="preserve">
          <source>The default definition uses &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList2&quot;&gt;liftReadList2&lt;/a&gt;&lt;/code&gt;. Instances that define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; should also define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2Default&quot;&gt;liftReadListPrec2Default&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В определении по умолчанию используется &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList2&quot;&gt;liftReadList2&lt;/a&gt;&lt;/code&gt; . Экземпляры, которые определяют &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; , также должны определять &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; как &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2Default&quot;&gt;liftReadListPrec2Default&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c58343eea6290f399d2ab6ad1cadcd380e922e3" translate="yes" xml:space="preserve">
          <source>The default definitions of the &lt;code&gt;&lt;a href=&quot;ghc-real#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; functions are in terms of &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Определения по умолчанию для функций &lt;code&gt;&lt;a href=&quot;ghc-real#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-real#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-real#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-real#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; даны в терминах &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec66529839a9863362b72c24581910fe9d869109" translate="yes" xml:space="preserve">
          <source>The default definitions of the &lt;code&gt;&lt;a href=&quot;prelude#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; functions are in terms of &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Определения по умолчанию для функций &lt;code&gt;&lt;a href=&quot;prelude#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; даны в терминах &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="491d8a12b5fa1e7b0bec380645e2c6e813fe0eda" translate="yes" xml:space="preserve">
          <source>The default method definitions in the &lt;code&gt;Exception&lt;/code&gt; class do what we need in this case. You can now throw and catch &lt;code&gt;ThisException&lt;/code&gt; and &lt;code&gt;ThatException&lt;/code&gt; as exceptions:</source>
          <target state="translated">Определения методов по умолчанию в классе &lt;code&gt;Exception&lt;/code&gt; делают то, что нам нужно в этом случае. Теперь вы можете генерировать и перехватывать &lt;code&gt;ThisException&lt;/code&gt; и &lt;code&gt;ThatException&lt;/code&gt; как исключения:</target>
        </trans-unit>
        <trans-unit id="06f71be64b1eace75a4676b9f81b6631fa302e4c" translate="yes" xml:space="preserve">
          <source>The default method for &lt;code&gt;put&lt;/code&gt; is then used, corresponding to the generic implementation of serialization. If you are using &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, the same instance is generated by simply attaching a &lt;code&gt;deriving Serialize&lt;/code&gt; clause to the &lt;code&gt;UserTree&lt;/code&gt; datatype declaration. For more examples of generic functions please refer to the &lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;generic-deriving&lt;/a&gt; package on Hackage.</source>
          <target state="translated">Затем используется метод по умолчанию для &lt;code&gt;put&lt;/code&gt; , соответствующий общей реализации сериализации. Если вы используете &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; , тот же экземпляр создается путем простого присоединения &lt;code&gt;deriving Serialize&lt;/code&gt; предложения Serialize к &lt;code&gt;UserTree&lt;/code&gt; типа данных UserTree . Дополнительные примеры общих функций , пожалуйста , обратитесь к &lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;родовым-вывода&lt;/a&gt; пакета на Hackage.</target>
        </trans-unit>
        <trans-unit id="84a8076800f1a94cd466a3ca2cb82ca67bed6590" translate="yes" xml:space="preserve">
          <source>The default parallel GC settings are usually suitable for parallel programs (i.e. those using &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:par&quot;&gt;GHC.Conc.par&lt;/a&gt;, Strategies, or with multiple threads). However, it is sometimes beneficial to enable the parallel GC for a single-threaded sequential program too, especially if the program has a large amount of heap data and GC is a significant fraction of runtime. To use the parallel GC in a sequential program, enable the parallel runtime with a suitable &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option, and additionally it might be beneficial to restrict parallel GC to the old generation with &lt;code&gt;-qg1&lt;/code&gt;.</source>
          <target state="translated">Параметры параллельного GC по умолчанию обычно подходят для параллельных программ (т. &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:par&quot;&gt;Е. Тех&lt;/a&gt; , которые используют GHC.Conc.par , Strategies или с несколькими потоками). Однако иногда полезно включить параллельный сборщик мусора и для однопоточной последовательной программы, особенно если программа имеет большой объем данных в куче, а сборщик мусора составляет значительную часть времени выполнения. Чтобы использовать параллельный &lt;code&gt;-N ⟨x⟩&lt;/code&gt; в последовательной программе, включите параллельную среду выполнения с помощью подходящей опции -N ⟨x⟩ , и, кроме того, может быть полезно ограничить параллельный &lt;code&gt;-qg1&lt;/code&gt; старым поколением с помощью -qg1 .</target>
        </trans-unit>
        <trans-unit id="1c469f1e0fe0a399e3c8b4ab9c90096159140285" translate="yes" xml:space="preserve">
          <source>The default preferences which may be overwritten in the &lt;code&gt;.haskeline&lt;/code&gt; file.</source>
          <target state="translated">Настройки по умолчанию, которые могут быть перезаписаны в файле &lt;code&gt;.haskeline&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2646b613e6eb1c1c85aa64b66ff2f7d3602d210c" translate="yes" xml:space="preserve">
          <source>The default role for abstract datatype parameters is now representational. (An abstract datatype is one with no constructors listed.) To get another role, use a role annotation. (See &lt;a href=&quot;glasgow_exts#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="translated">Роль по умолчанию для параметров абстрактного типа данных теперь является репрезентативной. (Абстрактный тип данных - это тип без перечисленных конструкторов.) Чтобы получить другую роль, используйте аннотацию роли. (См. &lt;a href=&quot;glasgow_exts#roles&quot;&gt;Роли&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="60620248a38bdba79e7fcf67abe638e2752d6a16" translate="yes" xml:space="preserve">
          <source>The default seems to work well here. If you have plenty of memory, it is usually better to use &lt;code&gt;-H ⟨size⟩&lt;/code&gt; (see &lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-H [⟨size⟩]&lt;/code&gt;&lt;/a&gt;) than to increase &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt;&lt;code&gt;-F ⟨factor⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Похоже, что по умолчанию здесь работает хорошо. Если у вас много памяти, обычно лучше использовать &lt;code&gt;-H ⟨size⟩&lt;/code&gt; (см. &lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; &lt;/a&gt; ), чем увеличивать &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt; &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3395f0bc00fd88ab55e5b4f27b7ed6fe2e944e0a" translate="yes" xml:space="preserve">
          <source>The default style (&lt;code&gt;mode=PageMode, lineLength=100, ribbonsPerLine=1.5&lt;/code&gt;).</source>
          <target state="translated">Стиль по умолчанию ( &lt;code&gt;mode=PageMode, lineLength=100, ribbonsPerLine=1.5&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="af2102e497ed3634f45c2fd75b234c6748ca55b8" translate="yes" xml:space="preserve">
          <source>The definition (of a function, variable, struct or typedef) is written to the C file, and its prototype or extern declaration to the C header. Inline functions are handled correctly. struct definitions and typedefs are written to the C program too. The &lt;code&gt;inline&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;typedef&lt;/code&gt; keyword must come just after &lt;code&gt;def&lt;/code&gt;.</source>
          <target state="translated">Определение (функции, переменной, структуры или typedef) записывается в файл C, а его прототип или объявление extern - в заголовок C. Встроенные функции обрабатываются правильно. Определения структур и typedef также записываются в программу C. &lt;code&gt;inline&lt;/code&gt; , &lt;code&gt;struct&lt;/code&gt; или &lt;code&gt;typedef&lt;/code&gt; ключевое слово должно прийти только после того, как &lt;code&gt;def&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c8661345439bef92de6f21733c68492b49b19b5" translate="yes" xml:space="preserve">
          <source>The definition for &amp;ldquo;compatible&amp;rdquo; uses a notion of &amp;ldquo;apart&amp;rdquo;, whose definition in turn relies on type family reduction. This condition of &amp;ldquo;apartness&amp;rdquo;, as stated, is impossible to check, so we use this conservative approximation: two types are considered to be apart when the two types cannot be unified, even by a potentially infinite unifier. Allowing the unifier to be infinite disallows the following pair of instances:</source>
          <target state="translated">В определении &amp;laquo;совместимый&amp;raquo; используется понятие &amp;laquo;отдельный&amp;raquo;, определение которого, в свою очередь, основывается на сокращении семейства типов. Это условие &amp;laquo;обособленности&amp;raquo;, как было сказано, невозможно проверить, поэтому мы используем это консервативное приближение: два типа считаются отдельными, когда два типа не могут быть объединены даже с помощью потенциально бесконечного объединителя. Разрешение объединителю быть бесконечным запрещает следующую пару экземпляров:</target>
        </trans-unit>
        <trans-unit id="70f33fa7b9f96d835ab103c50be5ec10b816d10e" translate="yes" xml:space="preserve">
          <source>The definition is syntactic:</source>
          <target state="translated">Определение синтаксическое:</target>
        </trans-unit>
        <trans-unit id="df390321900febf5a604611d2971ac50e861f17b" translate="yes" xml:space="preserve">
          <source>The definition of &quot;math symbol&quot; may be a little counter-intuitive depending on one's background:</source>
          <target state="translated">Определение &quot;математического символа&quot; может быть немного контр-интуитивным в зависимости от фона:</target>
        </trans-unit>
        <trans-unit id="9142eae3b3df142878b925196063f3a19a7bf511" translate="yes" xml:space="preserve">
          <source>The definition of (say) &lt;code&gt;build&lt;/code&gt; in &lt;code&gt;GHC/Base.hs&lt;/code&gt; looks like this:</source>
          <target state="translated">Определение (скажем) &lt;code&gt;build&lt;/code&gt; в &lt;code&gt;GHC/Base.hs&lt;/code&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="c2ee65e9c75aa9258dca0f16a6b10f4fd9a759a9" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;foo&lt;/code&gt; is rejected because one would have to instantiate &lt;code&gt;id&lt;/code&gt;&amp;lsquo;s type with &lt;code&gt;b := (forall s. ST s a) -&amp;gt; a&lt;/code&gt;, and that is not allowed. Instantiating polymorphic type variables with polymorphic types is called &lt;em&gt;impredicative polymorphism&lt;/em&gt;.</source>
          <target state="translated">Определение &lt;code&gt;foo&lt;/code&gt; отклоняется, потому что нужно было бы создать экземпляр типа &lt;code&gt;id&lt;/code&gt; с помощью &lt;code&gt;b := (forall s. ST s a) -&amp;gt; a&lt;/code&gt; , а это недопустимо. Создание экземпляров переменных полиморфного типа с помощью полиморфных типов называется &lt;em&gt;импредикативным полиморфизмом&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ed024c34bd63c1441cb3695b992556af082202b2" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;inst&lt;/code&gt; is unchanged from the Haskell Report (roughly, just a type). The &lt;code&gt;context =&amp;gt;&lt;/code&gt; part is optional. That is the only syntactic change to the language.</source>
          <target state="translated">Определение &lt;code&gt;inst&lt;/code&gt; не изменилось по сравнению с отчетом Haskell (грубо говоря, это просто тип). Часть &lt;code&gt;context =&amp;gt;&lt;/code&gt; не является обязательной. Это единственное синтаксическое изменение языка.</target>
        </trans-unit>
        <trans-unit id="0bfdf9f8e4b0cf4d6ac3380a527908a80562e1fe" translate="yes" xml:space="preserve">
          <source>The definition of retainers is designed to reflect a common cause of space leaks: a large structure is retained by an unevaluated computation, and will be released once the computation is forced. A good example is looking up a value in a finite map, where unless the lookup is forced in a timely manner the unevaluated lookup will cause the whole mapping to be retained. These kind of space leaks can often be eliminated by forcing the relevant computations to be performed eagerly, using &lt;code&gt;seq&lt;/code&gt; or strictness annotations on data constructor fields.</source>
          <target state="translated">Определение фиксаторов предназначено для отражения общей причины утечки пространства: большая структура сохраняется с помощью неоцененных вычислений и будет освобождена после принудительного вычисления. Хорошим примером является поиск значения в конечной карте, где, если поиск не будет выполнен своевременно, неоцененный поиск приведет к сохранению всего отображения. Такого рода утечки пространства часто можно устранить, принудительно выполняя соответствующие вычисления с нетерпением, используя аннотации &lt;code&gt;seq&lt;/code&gt; или strictness в полях конструктора данных.</target>
        </trans-unit>
        <trans-unit id="f9455c27066e060f9c4ed319a5e6f962fe125ba2" translate="yes" xml:space="preserve">
          <source>The dependency &lt;code&gt;ce -&amp;gt; e&lt;/code&gt; here specifies that the type &lt;code&gt;e&lt;/code&gt; of elements is uniquely determined by the type of the collection &lt;code&gt;ce&lt;/code&gt;. Note that both parameters of Collects are of kind &lt;code&gt;Type&lt;/code&gt;; there are no constructor classes here. Note too that all of the instances of &lt;code&gt;Collects&lt;/code&gt; that we gave earlier can be used together with this new definition.</source>
          <target state="translated">Зависимость &lt;code&gt;ce -&amp;gt; e&lt;/code&gt; здесь указывает, что тип элементов &lt;code&gt;e&lt;/code&gt; однозначно определяется типом коллекции &lt;code&gt;ce&lt;/code&gt; . Обратите внимание, что оба параметра Collects относятся к типу &lt;code&gt;Type&lt;/code&gt; ; здесь нет классов конструкторов. Также обратите внимание, что все экземпляры &lt;code&gt;Collects&lt;/code&gt; , которые мы дали ранее, могут использоваться вместе с этим новым определением.</target>
        </trans-unit>
        <trans-unit id="0ed435c3cbe535cb6b31533a151482c8d2a49765" translate="yes" xml:space="preserve">
          <source>The dependency generation phase of GHC can take some additional options, which you may find useful. The options which affect dependency generation are:</source>
          <target state="translated">Фаза генерации зависимостей GHC может принять некоторые дополнительные опции,которые вы можете найти полезными.Опциями,которые влияют на генерацию зависимостей,являются:</target>
        </trans-unit>
        <trans-unit id="b14601aa73f99ec94b5c907467d51ea631241fb4" translate="yes" xml:space="preserve">
          <source>The dependency is based on file content, not a modification time</source>
          <target state="translated">Зависимость основана на содержимом файла,а не на времени модификации.</target>
        </trans-unit>
        <trans-unit id="adeb50d906769008b71fc1da461a1b88d5c5394a" translate="yes" xml:space="preserve">
          <source>The derivation mechanism can be used separtely from the data type declaration, using the &lt;a href=&quot;#stand-alone-deriving&quot;&gt;standalone deriving mechanism&lt;/a&gt;.</source>
          <target state="translated">Механизм деривации может использоваться отдельно от объявления типа данных с помощью &lt;a href=&quot;#stand-alone-deriving&quot;&gt;автономного механизма&lt;/a&gt; деривации .</target>
        </trans-unit>
        <trans-unit id="b7b9b515a6b382dc8b30446310290e049039607a" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance allows arbitrary Haskell whitespace between tokens of the input string. Extra parentheses are also allowed.</source>
          <target state="translated">Производный экземпляр &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; допускает произвольные пробелы Haskell между токенами входной строки. Допускаются также дополнительные скобки.</target>
        </trans-unit>
        <trans-unit id="0df45d847dca83db9351f4d864dd9921bcab85be" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance allows arbitrary Haskell whitespace between tokens of the input string. Extra parentheses are also allowed.</source>
          <target state="translated">Производный экземпляр &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; допускает произвольные пробелы Haskell между токенами входной строки. Допускаются также дополнительные скобки.</target>
        </trans-unit>
        <trans-unit id="827987dc4d21c55f29757d61b2ead342246251b4" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance allows arbitrary Haskell whitespace between tokens of the input string. Extra parentheses are also allowed.</source>
          <target state="translated">Производный экземпляр &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; допускает произвольные пробелы Haskell между токенами входной строки. Допускаются также дополнительные скобки.</target>
        </trans-unit>
        <trans-unit id="181a26c0ac10388c1c28e3a4a0bb2c744983c69d" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;HasRing&lt;/code&gt; instance would look like</source>
          <target state="translated">Выведенная &lt;code&gt;HasRing&lt;/code&gt; экземпляр будет выглядеть</target>
        </trans-unit>
        <trans-unit id="4744374c6426f29a0ece90c5038f8bb5efa3725d" translate="yes" xml:space="preserve">
          <source>The derived instance in GHC is equivalent to</source>
          <target state="translated">Производный экземпляр в GHC эквивалентен</target>
        </trans-unit>
        <trans-unit id="2aa9649e650abb1ccfd00ab90d331d7948d62cc4" translate="yes" xml:space="preserve">
          <source>The derived instance is obtained by completing the application of the class to the new type:</source>
          <target state="translated">Полученный экземпляр получается путем завершения применения класса к новому типу:</target>
        </trans-unit>
        <trans-unit id="75901f130a621087c5df4e3c7ff2bcd908627e72" translate="yes" xml:space="preserve">
          <source>The design also relies on &lt;code&gt;Danger&lt;/code&gt; not being able to access the &lt;code&gt;UnsafeRIO&lt;/code&gt; constructor. Unfortunately Template Haskell can be used to subvert module boundaries and so could be used to gain access to this constructor.</source>
          <target state="translated">Дизайн также основан на том, что &lt;code&gt;Danger&lt;/code&gt; не может получить доступ к конструктору &lt;code&gt;UnsafeRIO&lt;/code&gt; . К сожалению, Template Haskell можно использовать для нарушения границ модуля, а значит, и для получения доступа к этому конструктору.</target>
        </trans-unit>
        <trans-unit id="49cc72101ca9237972311dd03a0fd606151e4195" translate="yes" xml:space="preserve">
          <source>The design attempts to restrict the operations that &lt;code&gt;Danger&lt;/code&gt; can perform by using types, specifically the &lt;code&gt;RIO&lt;/code&gt; type wrapper around &lt;code&gt;IO&lt;/code&gt; . The author of &lt;code&gt;Danger&lt;/code&gt; can subvert this though by simply writing arbitrary &lt;code&gt;IO&lt;/code&gt; actions and using &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; to execute them as pure functions.</source>
          <target state="translated">Дизайн пытается ограничить операции, которые &lt;code&gt;Danger&lt;/code&gt; может выполнять, используя типы, в частности оболочку типа &lt;code&gt;RIO&lt;/code&gt; для ввода- &lt;code&gt;IO&lt;/code&gt; . Автор &lt;code&gt;Danger&lt;/code&gt; может изменить это, просто написав произвольные действия &lt;code&gt;IO&lt;/code&gt; и используя &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; для их выполнения как чистых функций.</target>
        </trans-unit>
        <trans-unit id="cd2da32dc935177290030f66437b8442e648de85" translate="yes" xml:space="preserve">
          <source>The design follows the following principles</source>
          <target state="translated">При проектировании были использованы следующие принципы</target>
        </trans-unit>
        <trans-unit id="8290c7ce1697900c8e40df8ad0fc8ee4040a8ead" translate="yes" xml:space="preserve">
          <source>The design of Safe Haskell covers the following aspects:</source>
          <target state="translated">Дизайн Safe Haskell охватывает следующие аспекты:</target>
        </trans-unit>
        <trans-unit id="db9668c7f3a96172360c5f50287354a3f36ed64a" translate="yes" xml:space="preserve">
          <source>The design of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; monoid is optimized such that</source>
          <target state="translated">Конструкция моноида &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; оптимизирована таким образом, чтобы</target>
        </trans-unit>
        <trans-unit id="d69ade52bf3d6bc1c9e9d54294cef3da66243040" translate="yes" xml:space="preserve">
          <source>The design of this combinator was guided by the objective that &lt;code&gt;timeout n f&lt;/code&gt; should behave exactly the same as &lt;code&gt;f&lt;/code&gt; as long as &lt;code&gt;f&lt;/code&gt; doesn't time out. This means that &lt;code&gt;f&lt;/code&gt; has the same &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; it would have without the timeout wrapper. Any exceptions &lt;code&gt;f&lt;/code&gt; might throw cancel the timeout and propagate further up. It also possible for &lt;code&gt;f&lt;/code&gt; to receive exceptions thrown to it by another thread.</source>
          <target state="translated">Дизайн этого комбинатора был основан на том, что &lt;code&gt;timeout n f&lt;/code&gt; должен вести себя точно так же, как и &lt;code&gt;f&lt;/code&gt; , пока &lt;code&gt;f&lt;/code&gt; не истекает. Это означает, что &lt;code&gt;f&lt;/code&gt; имеет тот же &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; , что и без оболочки тайм-аута. Любые исключения &lt;code&gt;f&lt;/code&gt; могут отменить тайм-аут и распространиться дальше. Также &lt;code&gt;f&lt;/code&gt; может получать исключения, брошенные ему другим потоком.</target>
        </trans-unit>
        <trans-unit id="ddf2c08a7e7a13b99ab3673124ddb5f1ed0a8e6e" translate="yes" xml:space="preserve">
          <source>The design of this combinator was guided by the objective that &lt;code&gt;timeout n f&lt;/code&gt; should behave exactly the same as &lt;code&gt;f&lt;/code&gt; as long as &lt;code&gt;f&lt;/code&gt; doesn't time out. This means that &lt;code&gt;f&lt;/code&gt; has the same &lt;code&gt;&lt;a href=&quot;control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; it would have without the timeout wrapper. Any exceptions &lt;code&gt;f&lt;/code&gt; might throw cancel the timeout and propagate further up. It also possible for &lt;code&gt;f&lt;/code&gt; to receive exceptions thrown to it by another thread.</source>
          <target state="translated">Дизайн этого комбинатора был основан на том, что &lt;code&gt;timeout n f&lt;/code&gt; должен вести себя точно так же, как и &lt;code&gt;f&lt;/code&gt; , пока &lt;code&gt;f&lt;/code&gt; не истекает. Это означает, что &lt;code&gt;f&lt;/code&gt; имеет тот же &lt;code&gt;&lt;a href=&quot;control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; , что и без оболочки тайм-аута. Любые исключения &lt;code&gt;f&lt;/code&gt; могут отменить тайм-аут и распространиться дальше. Также &lt;code&gt;f&lt;/code&gt; может получать исключения, брошенные ему другим потоком.</target>
        </trans-unit>
        <trans-unit id="069d6b594d5ec9b69dd4d93d8ec6094f3feb0544" translate="yes" xml:space="preserve">
          <source>The details of how to create the process are passed in the &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; record. To make it easier to construct a &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt;, the functions &lt;code&gt;&lt;a href=&quot;system-process#v:proc&quot;&gt;proc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-process#v:shell&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; are supplied that fill in the fields with default values which can be overriden as needed.</source>
          <target state="translated">Подробная информация о том, как создать процесс, передается в записи &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; . Чтобы упростить создание &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; , предоставляются функции &lt;code&gt;&lt;a href=&quot;system-process#v:proc&quot;&gt;proc&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;system-process#v:shell&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; , которые заполняют поля значениями по умолчанию, которые при необходимости можно переопределить.</target>
        </trans-unit>
        <trans-unit id="ed02330a1fbdda98a3ba7bccd58b777f6e21c2c1" translate="yes" xml:space="preserve">
          <source>The developer knows that a monad transformer takes a monad &lt;code&gt;m&lt;/code&gt; into a new monad &lt;code&gt;t m&lt;/code&gt;. But this property is not formally specified in the above declaration. This omission becomes an issue when defining monad transformer composition:</source>
          <target state="translated">Разработчик знает, что преобразователь монад переводит монаду &lt;code&gt;m&lt;/code&gt; в новую монаду &lt;code&gt;t m&lt;/code&gt; . Но это свойство официально не указано в приведенном выше объявлении. Это упущение становится проблемой при определении состава преобразователя монад:</target>
        </trans-unit>
        <trans-unit id="baaf6bdd8fde5eba43c6847cbbb88e9af95ebd7b" translate="yes" xml:space="preserve">
          <source>The difference between this and &lt;a href=&quot;#ghc-flag--funfolding-creation-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-funfolding-creation-threshold=⟨n⟩&lt;/code&gt;&lt;/a&gt; is that this one determines if a function definition will be inlined &lt;em&gt;at a call site&lt;/em&gt;. The other option determines if a function definition will be kept around at all for potential inlining.</source>
          <target state="translated">Разница между этим и &lt;a href=&quot;#ghc-flag--funfolding-creation-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-funfolding-creation-threshold=⟨n⟩&lt;/code&gt; в&lt;/a&gt; том, что он определяет, будет ли определение функции встроено &lt;em&gt;в сайт вызова&lt;/em&gt; . Другой вариант определяет, будет ли вообще сохраняться определение функции для потенциального встраивания.</target>
        </trans-unit>
        <trans-unit id="7ce598ae08dc7d0d31f3dc6c209cf1408d599371" translate="yes" xml:space="preserve">
          <source>The difference between using &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; for recovery is that in &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; the handler is inside an implicit &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; (see &quot;Asynchronous Exceptions&quot;) which is important when catching asynchronous exceptions, but when catching other kinds of exception it is unnecessary. Furthermore it is possible to accidentally stay inside the implicit &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; by tail-calling rather than returning from the handler, which is why we recommend using &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; for ordinary exception recovery.</source>
          <target state="translated">Разница между использованием &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; для восстановления заключается в том, что в &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; обработчик находится внутри неявной &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; (см. &amp;laquo;Асинхронные исключения&amp;raquo;), что важно при перехвате асинхронных исключений, но при перехвате других видов исключений в этом нет необходимости. Кроме того, можно случайно остаться внутри неявной &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; , вызвав хвостовой вызов, а не вернувшись из обработчика, поэтому мы рекомендуем использовать &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; , а не &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; для обычного восстановления исключения.</target>
        </trans-unit>
        <trans-unit id="7baf36ea1c4b3f790ba00b9fa8c653d9d8edc0dc" translate="yes" xml:space="preserve">
          <source>The difference involves the placement of the last type parameter, &lt;code&gt;a&lt;/code&gt;. In the &lt;code&gt;Right&lt;/code&gt; case, &lt;code&gt;a&lt;/code&gt; occurs within the type &lt;code&gt;Either Int a&lt;/code&gt;, and moreover, it appears as the last type argument of &lt;code&gt;Either&lt;/code&gt;. In the &lt;code&gt;Wrong&lt;/code&gt; case, however, &lt;code&gt;a&lt;/code&gt; is not the last type argument to &lt;code&gt;Either&lt;/code&gt;; rather, &lt;code&gt;Int&lt;/code&gt; is.</source>
          <target state="translated">Разница заключается в размещении последнего параметра типа &lt;code&gt;a&lt;/code&gt; . В случае &lt;code&gt;Right&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; встречается в типе &lt;code&gt;Either Int a&lt;/code&gt; и, более того, появляется как последний аргумент типа &lt;code&gt;Either&lt;/code&gt; . Однако в &lt;code&gt;Wrong&lt;/code&gt; случае &lt;code&gt;a&lt;/code&gt; не является последним аргументом типа для &lt;code&gt;Either&lt;/code&gt; ; скорее &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b237dd43561a7048051c81d4534c2c8653cc063" translate="yes" xml:space="preserve">
          <source>The directory returned is expected to be writable by the current user, but note that it isn't generally considered good practice to store application-specific data here; use &lt;code&gt;&lt;a href=&quot;system-directory#v:getXdgDirectory&quot;&gt;getXdgDirectory&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-directory#v:getAppUserDataDirectory&quot;&gt;getAppUserDataDirectory&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Ожидается, что возвращенный каталог будет доступен для записи текущему пользователю, но обратите внимание, что обычно не считается хорошей практикой хранить здесь данные, специфичные для приложения; вместо этого используйте &lt;code&gt;&lt;a href=&quot;system-directory#v:getXdgDirectory&quot;&gt;getXdgDirectory&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;system-directory#v:getAppUserDataDirectory&quot;&gt;getAppUserDataDirectory&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d678522b8fbe1bfba9bfaea6f20349fc6c790192" translate="yes" xml:space="preserve">
          <source>The do-notation of Haskell 98 does not allow &lt;em&gt;recursive bindings&lt;/em&gt;, that is, the variables bound in a do-expression are visible only in the textually following code block. Compare this to a let-expression, where bound variables are visible in the entire binding group.</source>
          <target state="translated">Нотация do Haskell 98 не допускает &lt;em&gt;рекурсивных привязок&lt;/em&gt; , то есть переменные, связанные в do-выражении, видны только в текстовом следующем блоке кода. Сравните это с let-выражением, где связанные переменные видны во всей группе привязки.</target>
        </trans-unit>
        <trans-unit id="ed0761a6931cceb4a4d7abb1349cfebd091b9cae" translate="yes" xml:space="preserve">
          <source>The document type</source>
          <target state="translated">Тип документа</target>
        </trans-unit>
        <trans-unit id="b44ad1035675a222470b757eea4beb20cf50c47b" translate="yes" xml:space="preserve">
          <source>The document.</source>
          <target state="translated">Документ.</target>
        </trans-unit>
        <trans-unit id="f1cdc66d16588511d035499d8789d0de0a61455f" translate="yes" xml:space="preserve">
          <source>The documentation here describes the realisation of Template Haskell in GHC. It is not detailed enough to understand Template Haskell; see the &lt;a href=&quot;http://haskell.org/haskellwiki/Template_Haskell&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">В документации здесь описывается реализация Template Haskell в GHC. Он недостаточно подробный для понимания Template Haskell; см. &lt;a href=&quot;http://haskell.org/haskellwiki/Template_Haskell&quot;&gt;страницу Wiki&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d161d8e5801d84e4bc6cb6d1ba3399418931f1f" translate="yes" xml:space="preserve">
          <source>The down-side is that, if the boilerplate code fails to typecheck, you will get an error message about that code, which you did not write. Whereas, with a &lt;code&gt;deriving&lt;/code&gt; clause the side-conditions are necessarily more conservative, but any error message may be more comprehensible.</source>
          <target state="translated">Обратной стороной является то, что если шаблонный код не проходит проверку типов, вы получите сообщение об ошибке, связанное с этим кодом, который вы не писали. Принимая во внимание, что с &lt;code&gt;deriving&lt;/code&gt; предложением побочные условия обязательно более консервативны, но любое сообщение об ошибке может быть более понятным.</target>
        </trans-unit>
        <trans-unit id="0d40a85296a889e2235c05d3e594413e6271c9b0" translate="yes" xml:space="preserve">
          <source>The downside of having lightweight threads is that only one can run at a time, so if one thread blocks in a foreign call, for example, the other threads cannot continue. The GHC runtime works around this by making use of full OS threads where necessary. When the program is built with the &lt;code&gt;-threaded&lt;/code&gt; option (to link against the multithreaded version of the runtime), a thread making a &lt;code&gt;safe&lt;/code&gt; foreign call will not block the other threads in the system; another OS thread will take over running Haskell threads until the original call returns. The runtime maintains a pool of these &lt;em&gt;worker&lt;/em&gt; threads so that multiple Haskell threads can be involved in external calls simultaneously.</source>
          <target state="translated">Обратной стороной облегченных потоков является то, что одновременно может выполняться только один, поэтому, если, например, один поток блокируется во внешнем вызове, другие потоки не могут продолжать работу. Среда выполнения GHC работает над этим, используя при необходимости полные потоки ОС. Когда программа построена с опцией &lt;code&gt;-threaded&lt;/code&gt; (для связывания с многопоточной версией среды выполнения), поток, выполняющий &lt;code&gt;safe&lt;/code&gt; внешний вызов, не будет блокировать другие потоки в системе; другой поток ОС будет выполнять потоки Haskell, пока не вернется исходный вызов. Среда выполнения поддерживает пул этих &lt;em&gt;рабочих&lt;/em&gt; потоков, так что несколько потоков Haskell могут одновременно участвовать во внешних вызовах.</target>
        </trans-unit>
        <trans-unit id="7e1ca2d2eeb59a37201caba0870b3b617ae2b6e7" translate="yes" xml:space="preserve">
          <source>The drag stage, which lasts from the final use until the last reference to the object is dropped.</source>
          <target state="translated">Этап перетаскивания,который длится от конечного использования до последней ссылки на объект,опускается.</target>
        </trans-unit>
        <trans-unit id="5112337835e0aaa1f4501d77e936abde1e9f5833" translate="yes" xml:space="preserve">
          <source>The dual of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;, obtained by swapping the arguments of &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; к моноиду , полученный заменой аргументов &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fab6e06621905edcea476fea0795c21d73fe816" translate="yes" xml:space="preserve">
          <source>The dynamic binding constraints are just a new form of predicate in the type class system.</source>
          <target state="translated">Ограничения динамической привязки-это только новая форма предиката в системе классов типов.</target>
        </trans-unit>
        <trans-unit id="c9658faad340c4e37684884e4b4de1d55529e10f" translate="yes" xml:space="preserve">
          <source>The easiest way to see what &lt;code&gt;-O&lt;/code&gt; (etc.) &amp;ldquo;really mean&amp;rdquo; is to run with &lt;a href=&quot;using#ghc-flag--v&quot;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/a&gt;, then stand back in amazement.</source>
          <target state="translated">Самый простой способ увидеть, что &amp;laquo;на самом деле означает&amp;raquo; &lt;code&gt;-O&lt;/code&gt; (и т. Д.), - это запустить с &lt;a href=&quot;using#ghc-flag--v&quot;&gt; &lt;code&gt;-v&lt;/code&gt; &lt;/a&gt; , а затем отойти в изумлении.</target>
        </trans-unit>
        <trans-unit id="9d5eb6a79829c0b2ad6433410a38b38fee844c58" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Пустой &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ac8593ee22b444a0803d2615c08c3ad783eddab" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Пустой &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffb10a0d9ca8c58bdee511053f10bf4fc11e9fd3" translate="yes" xml:space="preserve">
          <source>The empty document, with no height and no width. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is the identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt;, and anywhere in the argument list for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="translated">Пустой документ без высоты и без ширины. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; - это идентификатор для &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; , а также где угодно в списке аргументов для &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; и т. д.</target>
        </trans-unit>
        <trans-unit id="c38333a804d1c05d76e22c031e0de30532f2b0b2" translate="yes" xml:space="preserve">
          <source>The empty document, with no height and no width. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is the identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt;, and anywhere in the argument list for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="translated">Пустой документ без высоты и без ширины. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; - это идентификатор для &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; , а также где угодно в списке аргументов для &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; и т. д.</target>
        </trans-unit>
        <trans-unit id="57055327e0a4ff0414ff005dc9f2d958097b63a1" translate="yes" xml:space="preserve">
          <source>The empty document, with no height and no width. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is the identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt;, and anywhere in the argument list for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="translated">Пустой документ без высоты и без ширины. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; - это идентификатор для &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; , а также где угодно в списке аргументов для &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; и т. д.</target>
        </trans-unit>
        <trans-unit id="322d102fb89074ac997d55fe8155256f83635242" translate="yes" xml:space="preserve">
          <source>The empty stream.</source>
          <target state="translated">Пустой поток.</target>
        </trans-unit>
        <trans-unit id="aaade1a4c344a06009213d97ea6d90338497c9b0" translate="yes" xml:space="preserve">
          <source>The entire string prior to the &lt;em&gt;k&lt;/em&gt;th match (i.e. the prefix)</source>
          <target state="translated">Вся строка до &lt;em&gt;k-&lt;/em&gt; го совпадения (т.е. префикс)</target>
        </trans-unit>
        <trans-unit id="7e6880e4680eabaf9b865ccc3e11f4776c77ad73" translate="yes" xml:space="preserve">
          <source>The environment variable can also be set to the magical values &lt;code&gt;never&lt;/code&gt; or &lt;code&gt;always&lt;/code&gt;, which is equivalent to setting the corresponding &lt;code&gt;-fdiagnostics-color&lt;/code&gt; flag but with lower precedence.</source>
          <target state="translated">Переменная окружения также может быть установлена ​​на волшебные значения &lt;code&gt;never&lt;/code&gt; или &lt;code&gt;always&lt;/code&gt; , что эквивалентно установке соответствующего &lt;code&gt;-fdiagnostics-color&lt;/code&gt; но с более низким приоритетом.</target>
        </trans-unit>
        <trans-unit id="a78af08f35ea577d78dded305fcc5c4e9509b316" translate="yes" xml:space="preserve">
          <source>The epoch of TAI, which is 1858-11-17 00:00:00 TAI.</source>
          <target state="translated">Эпоха ТАИ,которая составляет 1858-11-17 00:00:00 ТАИ.</target>
        </trans-unit>
        <trans-unit id="81943c20c210a66a07a8f11e6429a84649f3e7b2" translate="yes" xml:space="preserve">
          <source>The equality test in an overloaded numeric pattern uses whatever &lt;code&gt;(==)&lt;/code&gt; is in scope.</source>
          <target state="translated">Проверка на равенство в перегруженном числовом шаблоне использует все &lt;code&gt;(==)&lt;/code&gt; в области видимости.</target>
        </trans-unit>
        <trans-unit id="afd1105a178de8acf9d4f7264289cbff2eca2561" translate="yes" xml:space="preserve">
          <source>The equality types</source>
          <target state="translated">Типы равенства</target>
        </trans-unit>
        <trans-unit id="1199dfc965e5955380e63499fadc65f9cbd20ac3" translate="yes" xml:space="preserve">
          <source>The equivalent REPL example is:</source>
          <target state="translated">Эквивалентный пример REPL:</target>
        </trans-unit>
        <trans-unit id="7d39f7dfb145cb81010fc146adcc072a6753c454" translate="yes" xml:space="preserve">
          <source>The error message contains some clues as to the transformation happening internally.</source>
          <target state="translated">Сообщение об ошибке содержит некоторые подсказки о том,что трансформация происходит внутренне.</target>
        </trans-unit>
        <trans-unit id="59e467fc1987c039f09f1829c27318997a022a9d" translate="yes" xml:space="preserve">
          <source>The error monad transformer. It can be used to add error handling to other monads.</source>
          <target state="translated">Трансформатор &quot;Монад-Ошибка&quot;.Может использоваться для добавления обработки ошибок к другим монадам.</target>
        </trans-unit>
        <trans-unit id="584676bca032e15cb39d4d01b07dc527b1765a4e" translate="yes" xml:space="preserve">
          <source>The errors that can be deferred are:</source>
          <target state="translated">Ошибки,которые могут быть отложены:</target>
        </trans-unit>
        <trans-unit id="53caa6a4eadedbc6b469bff64565461d1ccdfebf" translate="yes" xml:space="preserve">
          <source>The event manager state.</source>
          <target state="translated">Менеджер по мероприятиям в штате.</target>
        </trans-unit>
        <trans-unit id="5f9ab52fbe55b01321892b7fd29ab1a98bb7681d" translate="yes" xml:space="preserve">
          <source>The example below shows quasi-quotation in action. The quoter &lt;code&gt;expr&lt;/code&gt; is bound to a value of type &lt;code&gt;QuasiQuoter&lt;/code&gt; defined in module &lt;code&gt;Expr&lt;/code&gt;. The example makes use of an antiquoted variable &lt;code&gt;n&lt;/code&gt;, indicated by the syntax &lt;code&gt;'int:n&lt;/code&gt; (this syntax for anti-quotation was defined by the parser&amp;rsquo;s author, &lt;em&gt;not&lt;/em&gt; by GHC). This binds &lt;code&gt;n&lt;/code&gt; to the integer value argument of the constructor &lt;code&gt;IntExpr&lt;/code&gt; when pattern matching. Please see the referenced paper for further details regarding anti-quotation as well as the description of a technique that uses SYB to leverage a single parser of type &lt;code&gt;String -&amp;gt; a&lt;/code&gt; to generate both an expression parser that returns a value of type &lt;code&gt;Q Exp&lt;/code&gt; and a pattern parser that returns a value of type &lt;code&gt;Q Pat&lt;/code&gt;.</source>
          <target state="translated">В приведенном ниже примере показано действие квази-цитаты. Кавычки &lt;code&gt;expr&lt;/code&gt; привязаны к значению типа &lt;code&gt;QuasiQuoter&lt;/code&gt; , определенному в модуле &lt;code&gt;Expr&lt;/code&gt; . В этом примере используется переменная &lt;code&gt;n&lt;/code&gt; , заключенная в кавычки , обозначенная синтаксисом &lt;code&gt;'int:n&lt;/code&gt; (этот синтаксис для антицитирования был определен автором парсера, а &lt;em&gt;не&lt;/em&gt; GHC). Это связывает &lt;code&gt;n&lt;/code&gt; с аргументом целочисленного значения конструктора &lt;code&gt;IntExpr&lt;/code&gt; при сопоставлении с образцом. Пожалуйста, см. Упомянутую статью для получения дополнительных сведений об антицитировании, а также описание техники, которая использует SYB для использования одного синтаксического анализатора типа &lt;code&gt;String -&amp;gt; a&lt;/code&gt; чтобы сгенерировать как синтаксический анализатор выражений, который возвращает значение типа &lt;code&gt;Q Exp&lt;/code&gt; ,так и анализатор шаблона, который возвращает значение типа &lt;code&gt;Q Pat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e130d4a858cd5958b963d63c7fe21940f766b4ef" translate="yes" xml:space="preserve">
          <source>The exception itself is bound to a new variable, &lt;code&gt;_exception&lt;/code&gt;.</source>
          <target state="translated">Само исключение привязано к новой переменной &lt;code&gt;_exception&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="988d36edf500c18480e248b3ba03ea83da4d2cbf" translate="yes" xml:space="preserve">
          <source>The exception masking state of the executed action is inherited (c.f. &lt;code&gt;forkIO&lt;/code&gt;), see also &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; (&lt;em&gt;since: 2.7.0.0&lt;/em&gt;).</source>
          <target state="translated">Состояние маскировки исключений выполняемого действия наследуется (см. &lt;code&gt;forkIO&lt;/code&gt; ), см. Также &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; ( &lt;em&gt;начиная с: 2.7.0.0&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="cc8f732aa9ca323261d4591444f25b148d16268f" translate="yes" xml:space="preserve">
          <source>The exception masking state of the executed action is inherited (c.f. &lt;code&gt;forkIO&lt;/code&gt;), see also &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; (&lt;em&gt;since: 2.7.0.0&lt;/em&gt;).</source>
          <target state="translated">Состояние маскировки исключений выполняемого действия наследуется (см. &lt;code&gt;forkIO&lt;/code&gt; ), см. Также &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; ( &lt;em&gt;начиная с: 2.7.0.0&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="ebf03146e8f23e21eb8275358c982d6013264e4c" translate="yes" xml:space="preserve">
          <source>The exception thrown by &quot;fail&quot; in the GHCiQ monad</source>
          <target state="translated">Исключение,брошенное &quot;неудачей&quot; в GHCiQ monad.</target>
        </trans-unit>
        <trans-unit id="ceefa01748ad0dcbb4f9adc6b0c343de52816f7c" translate="yes" xml:space="preserve">
          <source>The exception thrown when an infinite cycle is detected in &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Исключение возникает при обнаружении бесконечного цикла в &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e73e797f0aaf19c29e3a38b80b61adffd05c8530" translate="yes" xml:space="preserve">
          <source>The exception to this rule is that the context of a standalone deriving declaration can infer its context when a single, extra-wildcards constraint is used as the context, such as in:</source>
          <target state="translated">Исключением из этого правила является то,что контекст отдельного производного объявления может выводить его контекст,когда в качестве контекста используется единственное,экстрадиктивное ограничение,например in:</target>
        </trans-unit>
        <trans-unit id="2a9b0765cdd57857b495fa1668f0cbcf42055c10" translate="yes" xml:space="preserve">
          <source>The execution continued at the point it previously stopped, and has now stopped at the breakpoint for a second time.</source>
          <target state="translated">Выполнение продолжилось в точке,в которой оно было остановлено ранее,а теперь остановилось в точке останова во второй раз.</target>
        </trans-unit>
        <trans-unit id="11953fb00b8ad70bb93132200530ed5421e8c22b" translate="yes" xml:space="preserve">
          <source>The exit status of a process</source>
          <target state="translated">Статус выхода из процесса</target>
        </trans-unit>
        <trans-unit id="927dcdbea9e7b5ba6ac39897b83ff1c61f46b2d3" translate="yes" xml:space="preserve">
          <source>The expansion is purely syntactic, so the expanded right-hand side expression refers to the nearest enclosing variable that is spelled the same as the field name.</source>
          <target state="translated">Развертывание является чисто синтаксическим,поэтому развернутое правое выражение относится к ближайшей охватывающей переменной,которая пишется так же,как и имя поля.</target>
        </trans-unit>
        <trans-unit id="0bb43782d3d91d6c0cfe9ab486e0facf443af806" translate="yes" xml:space="preserve">
          <source>The expansion is purely syntactic, so the record wildcard expression refers to the nearest enclosing variables that are spelled the same as the omitted field names.</source>
          <target state="translated">Развертывание является чисто синтаксическим,поэтому выражение подстановочного знака записи относится к ближайшим окружающим переменным,которые пишутся так же,как и опущенные имена полей.</target>
        </trans-unit>
        <trans-unit id="6fa2123bab4a96fc3dff4e1405c75b76df70f413" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;(x `par` y)&lt;/code&gt;&lt;em&gt;sparks&lt;/em&gt; the evaluation of &lt;code&gt;x&lt;/code&gt; (to weak head normal form) and returns &lt;code&gt;y&lt;/code&gt;. Sparks are queued for execution in FIFO order, but are not executed immediately. If the runtime detects that there is an idle CPU, then it may convert a spark into a real thread, and run the new thread on the idle CPU. In this way the available parallelism is spread amongst the real CPUs.</source>
          <target state="translated">Выражение &lt;code&gt;(x `par` y)&lt;/code&gt; &lt;em&gt;искры&lt;/em&gt; оценки &lt;code&gt;x&lt;/code&gt; (в слабую голову нормальной формы) , и возвращает &lt;code&gt;y&lt;/code&gt; . Искры ставятся в очередь на выполнение в порядке FIFO, но не выполняются немедленно. Если среда выполнения обнаруживает простаивающий ЦП, она может преобразовать искру в реальный поток и запустить новый поток на простаивающем ЦП. Таким образом, доступный параллелизм распределяется между реальными процессорами.</target>
        </trans-unit>
        <trans-unit id="60035052d2f9f9dbcb2234d0c35b5862aef3671d" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;encodeUtf8CSV table&lt;/code&gt; results in the following lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Выражение &lt;code&gt;encodeUtf8CSV table&lt;/code&gt; приводит к следующей ленивой &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ec7656c8e0e128b3c718fea844b6924e7c9db92" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; creates a fresh permutation parser consisting of parser &lt;code&gt;p&lt;/code&gt;. The the final result of the permutation parser is the function &lt;code&gt;f&lt;/code&gt; applied to the return value of &lt;code&gt;p&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead.</source>
          <target state="translated">Выражение &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; создает новый синтаксический анализатор перестановок, состоящий из синтаксического анализатора &lt;code&gt;p&lt;/code&gt; . Конечным результатом синтаксического анализатора перестановок является функция &lt;code&gt;f&lt;/code&gt; , применяемая к возвращаемому значению &lt;code&gt;p&lt;/code&gt; . Синтаксическому анализатору &lt;code&gt;p&lt;/code&gt; не разрешено принимать пустой ввод - вместо этого используйте необязательный комбинатор ( &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="688562a46f3c26c92c14ba3e2ae41abc13cf015e" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; creates a fresh permutation parser consisting of parser &lt;code&gt;p&lt;/code&gt;. The the final result of the permutation parser is the function &lt;code&gt;f&lt;/code&gt; applied to the return value of &lt;code&gt;p&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead.</source>
          <target state="translated">Выражение &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; создает новый синтаксический анализатор перестановок, состоящий из синтаксического анализатора &lt;code&gt;p&lt;/code&gt; . Конечным результатом синтаксического анализатора перестановок является функция &lt;code&gt;f&lt;/code&gt; , применяемая к возвращаемому значению &lt;code&gt;p&lt;/code&gt; . Синтаксическому анализатору &lt;code&gt;p&lt;/code&gt; не разрешено принимать пустой ввод - вместо этого используйте необязательный комбинатор ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="133ce73b1396f38f1c484e835e97b17e44814c41" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;f &amp;lt;$?&amp;gt; (x,p)&lt;/code&gt; creates a fresh permutation parser consisting of parser &lt;code&gt;p&lt;/code&gt;. The the final result of the permutation parser is the function &lt;code&gt;f&lt;/code&gt; applied to the return value of &lt;code&gt;p&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is optional - if it can not be applied, the default value &lt;code&gt;x&lt;/code&gt; will be used instead.</source>
          <target state="translated">Выражение &lt;code&gt;f &amp;lt;$?&amp;gt; (x,p)&lt;/code&gt; создает новый синтаксический анализатор перестановок, состоящий из синтаксического анализатора &lt;code&gt;p&lt;/code&gt; . Конечным результатом синтаксического анализатора перестановок является функция &lt;code&gt;f&lt;/code&gt; , применяемая к возвращаемому значению &lt;code&gt;p&lt;/code&gt; . Парсер &lt;code&gt;p&lt;/code&gt; является необязательным - если его нельзя применить, вместо него будет использоваться значение по умолчанию &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fb79b3e4e6a014a406705b86fa9c5b9e188c8b4" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;makeTokenParser language&lt;/code&gt; creates a &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; record that contains lexical parsers that are defined using the definitions in the &lt;code&gt;language&lt;/code&gt; record.</source>
          <target state="translated">Выражение &lt;code&gt;makeTokenParser language&lt;/code&gt; создает запись &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; , которая содержит лексические синтаксические анализаторы, определенные с использованием определений в &lt;code&gt;language&lt;/code&gt; записи.</target>
        </trans-unit>
        <trans-unit id="d2c369052f3c05736ed3d0aa835e5b9167fa8ef9" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;makeTokenParser language&lt;/code&gt; creates a &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; record that contains lexical parsers that are defined using the definitions in the &lt;code&gt;language&lt;/code&gt; record.</source>
          <target state="translated">Выражение &lt;code&gt;makeTokenParser language&lt;/code&gt; создает запись &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; , которая содержит лексические синтаксические анализаторы, определенные с использованием определений в &lt;code&gt;language&lt;/code&gt; записи.</target>
        </trans-unit>
        <trans-unit id="8b086207ac432a47ad80161d4b4db423c87b1bcf" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;parseTest p input&lt;/code&gt; applies a parser &lt;code&gt;p&lt;/code&gt; against input &lt;code&gt;input&lt;/code&gt; and prints the result to stdout. Used for testing parsers.</source>
          <target state="translated">Выражение &lt;code&gt;parseTest p input&lt;/code&gt; применяет синтаксический анализатор &lt;code&gt;p&lt;/code&gt; к входному &lt;code&gt;input&lt;/code&gt; и выводит результат на стандартный вывод. Используется для тестирования парсеров.</target>
        </trans-unit>
        <trans-unit id="7d09630aef55bc10a1cc5f993e20aa9d2c8fa633" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;perm &amp;lt;||&amp;gt; (x,p)&lt;/code&gt; adds parser &lt;code&gt;p&lt;/code&gt; to the permutation parser &lt;code&gt;perm&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is optional - if it can not be applied, the default value &lt;code&gt;x&lt;/code&gt; will be used instead. Returns a new permutation parser that includes the optional parser &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Выражение &lt;code&gt;perm &amp;lt;||&amp;gt; (x,p)&lt;/code&gt; добавляет синтаксический анализатор &lt;code&gt;p&lt;/code&gt; к синтаксическому анализатору перестановок &lt;code&gt;perm&lt;/code&gt; . Парсер &lt;code&gt;p&lt;/code&gt; является необязательным - если его нельзя применить, вместо него будет использоваться значение по умолчанию &lt;code&gt;x&lt;/code&gt; . Возвращает новый синтаксический анализатор перестановок, который включает дополнительный синтаксический анализатор &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9774c66620e8ebb6dc4947bd7a30ad32d4083961" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; adds parser &lt;code&gt;p&lt;/code&gt; to the permutation parser &lt;code&gt;perm&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead. Returns a new permutation parser that includes &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Выражение &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; добавляет синтаксический анализатор &lt;code&gt;p&lt;/code&gt; к синтаксическому анализатору перестановок &lt;code&gt;perm&lt;/code&gt; . Синтаксическому анализатору &lt;code&gt;p&lt;/code&gt; не разрешено принимать пустой ввод - вместо этого используйте необязательный комбинатор ( &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt; ). Возвращает новый синтаксический анализатор перестановок, который включает &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1eff7acfdc904aa55b95ecd8fd5d523b792b889" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; adds parser &lt;code&gt;p&lt;/code&gt; to the permutation parser &lt;code&gt;perm&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead. Returns a new permutation parser that includes &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Выражение &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; добавляет синтаксический анализатор &lt;code&gt;p&lt;/code&gt; к синтаксическому анализатору перестановок &lt;code&gt;perm&lt;/code&gt; . Синтаксическому анализатору &lt;code&gt;p&lt;/code&gt; не разрешено принимать пустой ввод - вместо этого используйте необязательный комбинатор ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt; ). Возвращает новый синтаксический анализатор перестановок, который включает &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b91ada54b3ba346f8466cd7a2f1f8bea7674bcd" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;s (t xs)&lt;/code&gt; does not match the rule &lt;code&gt;&quot;map/map&quot;&lt;/code&gt;, but GHC will substitute for &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;, giving an expression which does match. If &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt; was (a) used more than once, and (b) large or a redex, then it would not be substituted, and the rule would not fire.</source>
          <target state="translated">Выражение &lt;code&gt;s (t xs)&lt;/code&gt; не соответствует правилу &lt;code&gt;&quot;map/map&quot;&lt;/code&gt; , но GHC заменит &lt;code&gt;s&lt;/code&gt; и &lt;code&gt;t&lt;/code&gt; , давая выражение, которое действительно соответствует. Если &lt;code&gt;s&lt;/code&gt; или &lt;code&gt;t&lt;/code&gt; (а) использовались более одного раза и (б) большие или редекс, то они не будут заменены, и правило не сработает.</target>
        </trans-unit>
        <trans-unit id="efeb52340545b81120b442152fbbc21924dfa6d1" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;updatePosString pos s&lt;/code&gt; updates the source position &lt;code&gt;pos&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;text-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; on every character in &lt;code&gt;s&lt;/code&gt;, ie. &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt;.</source>
          <target state="translated">Выражение &lt;code&gt;updatePosString pos s&lt;/code&gt; обновляет исходную позицию &lt;code&gt;pos&lt;/code&gt; путем вызова &lt;code&gt;&lt;a href=&quot;text-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; для каждого символа в &lt;code&gt;s&lt;/code&gt; , т.е. &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a46b242264f8f265b934b320d1ad118b5d5d70f9" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;updatePosString pos s&lt;/code&gt; updates the source position &lt;code&gt;pos&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; on every character in &lt;code&gt;s&lt;/code&gt;, ie. &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt;.</source>
          <target state="translated">Выражение &lt;code&gt;updatePosString pos s&lt;/code&gt; обновляет исходную позицию &lt;code&gt;pos&lt;/code&gt; путем вызова &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; для каждого символа в &lt;code&gt;s&lt;/code&gt; , т.е. &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5483b1f876b299153ecdf0ce5e6d8239b22dcf61" translate="yes" xml:space="preserve">
          <source>The expression must be convertible to &lt;code&gt;long&lt;/code&gt; or &lt;code&gt;unsigned long&lt;/code&gt;. Its value (literal or negated literal) will be output.</source>
          <target state="translated">Выражение должно быть преобразовано в &lt;code&gt;long&lt;/code&gt; или &lt;code&gt;unsigned long&lt;/code&gt; . Его значение (буквальное или отрицательное) будет выводиться.</target>
        </trans-unit>
        <trans-unit id="820e3f9e6884aadccb720549e1d4a6de8381de85" translate="yes" xml:space="preserve">
          <source>The expression must be convertible to const char pointer. Its value (string literal) will be output.</source>
          <target state="translated">Выражение должно быть конвертировано в указатель const char.Будет выведено его значение (строковый литерал).</target>
        </trans-unit>
        <trans-unit id="0a5b6e32463e5a84d94f6198a0b148bf41758e64" translate="yes" xml:space="preserve">
          <source>The expression you are annotating with must have a type with &lt;code&gt;Typeable&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; instances</source>
          <target state="translated">Выражение вы аннотирование с должны иметь тип с &lt;code&gt;Typeable&lt;/code&gt; и &lt;code&gt;Data&lt;/code&gt; экземпляров</target>
        </trans-unit>
        <trans-unit id="6a2b1973077b8ad117174952fdf79b72f3549905" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; and (for some reason) by &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Расширение &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt; &lt;code&gt;ExplicitNamespaces&lt;/code&gt; &lt;/a&gt; подразумевается &lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt; и (по какой-то причине) &lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="56045ff1bf81ad580973e6c5e5797cb6699258d1" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. You can switch it off again with &lt;code&gt;NoMonoLocalBinds&lt;/code&gt; but type inference becomes less predictable if you do so. (Read the papers!)</source>
          <target state="translated">Выдвижные &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt; подразумевается &lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt; . Вы можете снова отключить его с помощью &lt;code&gt;NoMonoLocalBinds&lt;/code&gt; , но если вы это сделаете, вывод типа станет менее предсказуемым. (Прочтите газеты!)</target>
        </trans-unit>
        <trans-unit id="6edfbf43884f0659ca2c3eed2dacc284530ca4be" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-QuantifiedConstraints&quot;&gt;&lt;code&gt;QuantifiedConstraints&lt;/code&gt;&lt;/a&gt; introduces &lt;strong&gt;quantified constraints&lt;/strong&gt;, which give a new level of expressiveness in constraints. For example, consider</source>
          <target state="translated">Расширение &lt;a href=&quot;#extension-QuantifiedConstraints&quot;&gt; &lt;code&gt;QuantifiedConstraints&lt;/code&gt; &lt;/a&gt; вводит &lt;strong&gt;количественные ограничения&lt;/strong&gt; , которые дают новый уровень выразительности ограничений. Например, рассмотрим</target>
        </trans-unit>
        <trans-unit id="5a1fbd6833d7bf7f6b464ba5557bf0f418ef8516" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-RecursiveDo&quot;&gt;&lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/a&gt; also introduces a new keyword &lt;code&gt;rec&lt;/code&gt;, which wraps a mutually-recursive group of monadic statements inside a &lt;code&gt;do&lt;/code&gt; expression, producing a single statement. Similar to a &lt;code&gt;let&lt;/code&gt; statement inside a &lt;code&gt;do&lt;/code&gt;, variables bound in the &lt;code&gt;rec&lt;/code&gt; are visible throughout the &lt;code&gt;rec&lt;/code&gt; group, and below it. For example, compare</source>
          <target state="translated">Расширение &lt;a href=&quot;#extension-RecursiveDo&quot;&gt; &lt;code&gt;RecursiveDo&lt;/code&gt; &lt;/a&gt; также вводит новое ключевое слово &lt;code&gt;rec&lt;/code&gt; , которое обертывает взаимно рекурсивную группу монадических операторов внутри выражения &lt;code&gt;do&lt;/code&gt; , создавая один оператор. Подобно оператору &lt;code&gt;let&lt;/code&gt; внутри &lt;code&gt;do&lt;/code&gt; , переменные, связанные в &lt;code&gt;rec&lt;/code&gt; , видны во всей группе &lt;code&gt;rec&lt;/code&gt; и под ней. Например, сравните</target>
        </trans-unit>
        <trans-unit id="2340bd5004afb06c66885f9f37fdc1ab908eab6d" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-TypeInType&quot;&gt;&lt;code&gt;TypeInType&lt;/code&gt;&lt;/a&gt; is now deprecated: its sole effect is to switch on &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; (and hence &lt;a href=&quot;#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;) and &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Расширение &lt;a href=&quot;#extension-TypeInType&quot;&gt; &lt;code&gt;TypeInType&lt;/code&gt; &lt;/a&gt; устарело: его единственное действие - включить &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; (и, следовательно, &lt;a href=&quot;#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; &lt;/a&gt; ) и &lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d7aee131ad6d19c93d8e0e5cef004d81b83103a" translate="yes" xml:space="preserve">
          <source>The extension adds a new kind of expression for defining arrows:</source>
          <target state="translated">Расширение добавляет новый вид выражения для определения стрелок:</target>
        </trans-unit>
        <trans-unit id="68fc04e40e72e9a26d6e832da587e68cf89dce71" translate="yes" xml:space="preserve">
          <source>The extension does not extend to the left-hand side of function definitions; you must define such a function in prefix form.</source>
          <target state="translated">Расширение не распространяется на левую сторону определений функций;необходимо определить такую функцию в префиксном виде.</target>
        </trans-unit>
        <trans-unit id="ad6ad2707106caf932a9bcc6bc55d2c587ffc598" translate="yes" xml:space="preserve">
          <source>The extension is enabled with the extension &lt;a href=&quot;#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Расширение включено с расширением &lt;a href=&quot;#extension-TransformListComp&quot;&gt; &lt;code&gt;TransformListComp&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="592f0075b3be7dea40fca2f7b78b5f78b8bee1db" translate="yes" xml:space="preserve">
          <source>The extension only affects definitions in this module.</source>
          <target state="translated">Расширение влияет только на определения в этом модуле.</target>
        </trans-unit>
        <trans-unit id="dbed722a20b0c81708629361d2e36ddb255e740e" translate="yes" xml:space="preserve">
          <source>The fact that as many elements as possible are translated is used by the IO library in order to report translation errors at the point they actually occur, rather than when the buffer is translated.</source>
          <target state="translated">Тот факт,что переводится как можно больше элементов,используется библиотекой IO для того,чтобы сообщать об ошибках перевода в момент их возникновения,а не в момент перевода буфера.</target>
        </trans-unit>
        <trans-unit id="c9688a61970d69ede4ef28783b4cdd7a6fa982ec" translate="yes" xml:space="preserve">
          <source>The field width is a minimum, not a maximum: it will be expanded as needed to avoid mutilating a value.</source>
          <target state="translated">Ширина поля-минимальная,а не максимальная:она будет расширяться по мере необходимости во избежание искажения значения.</target>
        </trans-unit>
        <trans-unit id="766dc6dc2e472365cee52e53c97df5ee0cb680d9" translate="yes" xml:space="preserve">
          <source>The fields in &lt;code&gt;Trade&lt;/code&gt; are marked as strict (using &lt;code&gt;!&lt;/code&gt;) since we don't need laziness here. In practise, you would probably consider using the UNPACK pragma as well. &lt;a href=&quot;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&quot;&gt;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&lt;/a&gt;</source>
          <target state="translated">Поля в &lt;code&gt;Trade&lt;/code&gt; помечены как строгие (использующие &lt;code&gt;!&lt;/code&gt; ), Так как нам здесь не нужна лень. На практике вы, вероятно, также рассмотрите возможность использования прагмы UNPACK. &lt;a href=&quot;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&quot;&gt;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5972e4dbbb1da0195c707d37fda525d476ee44e9" translate="yes" xml:space="preserve">
          <source>The fields of &lt;code&gt;ExampleConstructor&lt;/code&gt; have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceStrictness&quot;&gt;NoSourceStrictness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceLazy&quot;&gt;SourceLazy&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceStrict&quot;&gt;SourceStrict&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">Поля &lt;code&gt;ExampleConstructor&lt;/code&gt; имеют &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceStrictness&quot;&gt;NoSourceStrictness&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceLazy&quot;&gt;SourceLazy&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceStrict&quot;&gt;SourceStrict&lt;/a&gt;&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="90aff6649fd9e503bb0cd5dab7faab1470bbcfc9" translate="yes" xml:space="preserve">
          <source>The fields of &lt;code&gt;ExampleConstructor&lt;/code&gt; have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceUnpackedness&quot;&gt;NoSourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceNoUnpack&quot;&gt;SourceNoUnpack&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceUnpack&quot;&gt;SourceUnpack&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">Поля &lt;code&gt;ExampleConstructor&lt;/code&gt; имеют &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceUnpackedness&quot;&gt;NoSourceUnpackedness&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceNoUnpack&quot;&gt;SourceNoUnpack&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceUnpack&quot;&gt;SourceUnpack&lt;/a&gt;&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="867052d71989ead15b5268bf62e49c7c19eae92d" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;A.hs-boot&lt;/code&gt; is a programmer-written source file. It must live in the same directory as its parent source file &lt;code&gt;A.hs&lt;/code&gt;. Currently, if you use a literate source file &lt;code&gt;A.lhs&lt;/code&gt; you must also use a literate boot file, &lt;code&gt;A.lhs-boot&lt;/code&gt;; and vice versa.</source>
          <target state="translated">Файл &lt;code&gt;A.hs-boot&lt;/code&gt; - это исходный файл, написанный программистом. Он должен жить в том же каталоге, что и его родительский исходный файл &lt;code&gt;A.hs&lt;/code&gt; . В настоящее время, если вы используете грамотный исходный файл &lt;code&gt;A.lhs&lt;/code&gt; , вы также должны использовать грамотный загрузочный файл &lt;code&gt;A.lhs-boot&lt;/code&gt; ; и наоборот.</target>
        </trans-unit>
        <trans-unit id="9a674c835d28bfb6d72a5275286859913c1e00bf" translate="yes" xml:space="preserve">
          <source>The file contains package IDs and optionally package databases, one directive per line:</source>
          <target state="translated">Файл содержит идентификаторы пакетов и опционально пакетные базы данных,по одной директиве на строку:</target>
        </trans-unit>
        <trans-unit id="d3dad592ba2c56d2ff45ef3e10379f2cd7056cb1" translate="yes" xml:space="preserve">
          <source>The file descriptor is ready to accept a write.</source>
          <target state="translated">Файловый дескриптор готов принять запись.</target>
        </trans-unit>
        <trans-unit id="0a87aafdf7c80c25cee8605761116960c822dc15" translate="yes" xml:space="preserve">
          <source>The file is created with permissions such that only the current user can read/write it.</source>
          <target state="translated">Файл создается с разрешениями,чтобы только текущий пользователь мог его читать/записывать.</target>
        </trans-unit>
        <trans-unit id="cfb39651c9d8c9724affb75edf0166a16b2ab2da" translate="yes" xml:space="preserve">
          <source>The file-header pragmas are: &lt;code&gt;{-# LANGUAGE #-}&lt;/code&gt;, &lt;code&gt;{-# OPTIONS_GHC #-}&lt;/code&gt;, and &lt;code&gt;{-# INCLUDE #-}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{-# OPTIONS_GHC #-}&lt;/code&gt; заголовка файла: &lt;code&gt;{-# LANGUAGE #-}&lt;/code&gt; , {- # OPTIONS_GHC # -} и &lt;code&gt;{-# INCLUDE #-}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ce398b5e4e0b12caa271926c6711a527e411174" translate="yes" xml:space="preserve">
          <source>The final build step that returns the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; signal.</source>
          <target state="translated">Заключительный этап сборки , который возвращает &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; сигнал.</target>
        </trans-unit>
        <trans-unit id="87005632e427f20e49e6f8bedc0a39a36ece9f40" translate="yes" xml:space="preserve">
          <source>The final bullet (about unifiying instances) makes GHC conservative about committing to an overlapping instance. For example:</source>
          <target state="translated">Последний пункт (об унифицированных экземплярах)делает GHC консервативным в отношении фиксации перекрывающихся экземпляров.Например:</target>
        </trans-unit>
        <trans-unit id="1913f6cc3ff526a515670ed4f1b49aa9b4f8a2bf" translate="yes" xml:space="preserve">
          <source>The final form is just what we want: a simple case expression.</source>
          <target state="translated">Заключительная форма-это то,что мы хотим:простое выражение случая.</target>
        </trans-unit>
        <trans-unit id="f7d925c1be71fce63599be5c5644561348c21d6e" translate="yes" xml:space="preserve">
          <source>The final layout will be something like</source>
          <target state="translated">Окончательный макет будет что-то вроде</target>
        </trans-unit>
        <trans-unit id="509bc33604e7ee8a244ab55cc215005d17244214" translate="yes" xml:space="preserve">
          <source>The finalizer is given the local type environment at the splice point. Thus &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reify&quot;&gt;reify&lt;/a&gt;&lt;/code&gt; is able to find the local definitions when executed inside the finalizer.</source>
          <target state="translated">Финализатору дается окружение локального типа в точке соединения. Таким образом, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reify&quot;&gt;reify&lt;/a&gt;&lt;/code&gt; может находить локальные определения при выполнении внутри финализатора.</target>
        </trans-unit>
        <trans-unit id="147a1899cc99c9241165663b9d1797441102fedd" translate="yes" xml:space="preserve">
          <source>The finalizer, and the relationship between the key and the value, exist regardless of whether the program keeps a reference to the &lt;code&gt;&lt;a href=&quot;ghc-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; object or not.</source>
          <target state="translated">Финализатор и связь между ключом и значением существуют независимо от того, хранит ли программа ссылку на &lt;code&gt;&lt;a href=&quot;ghc-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; объект или нет.</target>
        </trans-unit>
        <trans-unit id="d9f13e14cac52cb8d1ac6c69d4a111452644d3b2" translate="yes" xml:space="preserve">
          <source>The finalizer, and the relationship between the key and the value, exist regardless of whether the program keeps a reference to the &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; object or not.</source>
          <target state="translated">Финализатор и связь между ключом и значением существуют независимо от того, хранит ли программа ссылку на &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; объект или нет.</target>
        </trans-unit>
        <trans-unit id="deaaee000865e026093bdaeb2c9fc2020dfc3055" translate="yes" xml:space="preserve">
          <source>The fine distinction between different kinds of parse errors allows the system to generate quite good error messages for the user. It also allows error messages that are formatted in different languages. Each kind of message is generated by different combinators:</source>
          <target state="translated">Тонкое разграничение между различными видами ошибок при разборе позволяет системе генерировать достаточно хорошие сообщения об ошибках для пользователя.Она также позволяет выдавать сообщения об ошибках,отформатированные на разных языках.Каждый вид сообщений генерируется разными комбинаторами:</target>
        </trans-unit>
        <trans-unit id="c672354048c81f22453abece53dcb4410b87ec06" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; argument is the contents of the line to the left of the cursor, reversed. The second &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; argument is the contents of the line to the right of the cursor.</source>
          <target state="translated">Первый аргумент &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; - это содержимое строки слева от курсора в обратном порядке. Второй аргумент &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; - это содержимое строки справа от курсора.</target>
        </trans-unit>
        <trans-unit id="e20d358fcdcc868c8bd11a6755028db0bb2e37f3" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;Int32&lt;/code&gt; is for the tag. There are two &lt;code&gt;Float32&lt;/code&gt; fields because floating point types can&amp;rsquo;t overlap with other types, because of limitations of the code generator that we&amp;rsquo;re hoping to overcome in the future. The second alternative needs two &lt;code&gt;Float32&lt;/code&gt; fields: The &lt;code&gt;Word32&lt;/code&gt; field is for the &lt;code&gt;Word32#&lt;/code&gt; in the first alternative. The &lt;code&gt;Pointer&lt;/code&gt; field is shared between &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Maybe Int&lt;/code&gt; values of the alternatives.</source>
          <target state="translated">Первый &lt;code&gt;Int32&lt;/code&gt; предназначен для тега. Есть два поля &lt;code&gt;Float32&lt;/code&gt; , потому что типы с плавающей запятой не могут перекрываться с другими типами из-за ограничений генератора кода, которые мы надеемся преодолеть в будущем. Для второго варианта нужны два поля &lt;code&gt;Float32&lt;/code&gt; : поле &lt;code&gt;Word32&lt;/code&gt; предназначено для &lt;code&gt;Word32#&lt;/code&gt; в первом варианте. Поле &lt;code&gt;Pointer&lt;/code&gt; используется совместно значениями &lt;code&gt;String&lt;/code&gt; и &lt;code&gt;Maybe Int&lt;/code&gt; альтернатив.</target>
        </trans-unit>
        <trans-unit id="349930f2f6ac001a1f1d9bc41ac40db08cbf14ec" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;(l,u)&lt;/code&gt; of each of these operations is a pair specifying the lower and upper bounds of a contiguous subrange of values.</source>
          <target state="translated">Первый аргумент &lt;code&gt;(l,u)&lt;/code&gt; каждой из этих операций - это пара, определяющая нижнюю и верхнюю границы непрерывного поддиапазона значений.</target>
        </trans-unit>
        <trans-unit id="da354ca0b85aa26c68bc2b60c29e2527cd434859" translate="yes" xml:space="preserve">
          <source>The first bullet simply means that the dependency must be well-scoped. The second bullet concerns GHC&amp;rsquo;s ability to infer dependency. Inferring this dependency is difficult, and GHC currently requires the dependency to be made explicit, meaning that &lt;code&gt;k&lt;/code&gt; must appear in the kind of a type variable, making it obvious to GHC that dependency is intended. For example:</source>
          <target state="translated">Первый пункт просто означает, что зависимость должна быть хорошо определена. Второй пункт касается способности GHC сделать вывод о зависимости. Сделать вывод об этой зависимости сложно, и в настоящее время GHC требует, чтобы зависимость была сделана явной, что означает, что &lt;code&gt;k&lt;/code&gt; должно появиться в виде переменной типа, что делает очевидным для GHC, что зависимость предназначена. Например:</target>
        </trans-unit>
        <trans-unit id="5990c2111448ff95032208b84313c09eb4e8e7c7" translate="yes" xml:space="preserve">
          <source>The first clause of &amp;ldquo;compatible&amp;rdquo; is the more straightforward one. It says that the patterns of two distinct type family instances cannot overlap. For example, the following is disallowed:</source>
          <target state="translated">Первый пункт &amp;laquo;совместимого&amp;raquo; является более простым. В нем говорится, что образцы двух экземпляров разных семейств типов не могут перекрываться. Например, запрещено следующее:</target>
        </trans-unit>
        <trans-unit id="0d05ff555d4b0984db447de192b3bf9a34809e33" translate="yes" xml:space="preserve">
          <source>The first component of &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt;, scaled to lie in the open interval (&lt;code&gt;-1&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;), either &lt;code&gt;0.0&lt;/code&gt; or of absolute value &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix. The behaviour is unspecified on infinite or &lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">Первый компонент &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; , масштабируемый так, чтобы лежать в открытом интервале ( &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; ), либо &lt;code&gt;0.0&lt;/code&gt; либо абсолютное значение &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt; , где &lt;code&gt;b&lt;/code&gt; - основание с плавающей запятой. Поведение не определено для бесконечных значений или значений &lt;code&gt;NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4f7b2948c8c1ae005bcea73d45f0bbfbc9162d6" translate="yes" xml:space="preserve">
          <source>The first component of &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt;, scaled to lie in the open interval (&lt;code&gt;-1&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;), either &lt;code&gt;0.0&lt;/code&gt; or of absolute value &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix. The behaviour is unspecified on infinite or &lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">Первый компонент &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; , масштабируемый так, чтобы лежать в открытом интервале ( &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; ), либо &lt;code&gt;0.0&lt;/code&gt; либо абсолютное значение &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt; , где &lt;code&gt;b&lt;/code&gt; - основание с плавающей запятой. Поведение не определено для бесконечных значений или значений &lt;code&gt;NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a78b840c5ec7a8bd0522ac73f6d9db7e7f7c6e2" translate="yes" xml:space="preserve">
          <source>The first constructor consists of a single field, which is the parameter &lt;code&gt;a&lt;/code&gt;. This is represented as &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; a&lt;/code&gt;.</source>
          <target state="translated">Первый конструктор состоит из одного поля, которое является параметром &lt;code&gt;a&lt;/code&gt; . Это представлено как &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a491a7e0c75f57c1c82c6779842a217b78376985" translate="yes" xml:space="preserve">
          <source>The first element of the returned tuple is the prefix of &lt;code&gt;haystack&lt;/code&gt; up to and including the last match of &lt;code&gt;needle&lt;/code&gt;. The second is the remainder of &lt;code&gt;haystack&lt;/code&gt;, following the match.</source>
          <target state="translated">Первый элемент возвращаемого кортежа - это префикс &lt;code&gt;haystack&lt;/code&gt; до последнего совпадения &lt;code&gt;needle&lt;/code&gt; включительно . Второй - остаток &lt;code&gt;haystack&lt;/code&gt; после матча.</target>
        </trans-unit>
        <trans-unit id="d48cef11152d7e2e71a8b3fb779c57c59642ed57" translate="yes" xml:space="preserve">
          <source>The first example from that paper is set out below (&lt;a href=&quot;#th-example&quot;&gt;A Template Haskell Worked Example&lt;/a&gt;) as a worked example to help get you started.</source>
          <target state="translated">Первый пример из этой статьи приведен ниже ( &lt;a href=&quot;#th-example&quot;&gt;Пример&lt;/a&gt; , работающий на Haskell с шаблоном ) в качестве рабочего примера, который поможет вам начать работу.</target>
        </trans-unit>
        <trans-unit id="9f5e8571c06e192e03c26745db1bf9e5167e5bff" translate="yes" xml:space="preserve">
          <source>The first example is a parser monad in the style of</source>
          <target state="translated">Первый пример-парсерная монада в стиле</target>
        </trans-unit>
        <trans-unit id="0db21633e5e7584a4e85ed5e4b67955d4a3ea721" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">Первый пример вызовет возникновение исключения &lt;code&gt;e&lt;/code&gt; , а второй - нет. Фактически, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; вызовет исключение только тогда, когда он используется в монаде &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; . Вариант &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; следует использовать вместо &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; для вызова исключения в монаде &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; поскольку он гарантирует упорядочение по отношению к другим операциям &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; , тогда как &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="7a9264a11b232afb865bd5a70544aaa9c229ee38" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">Первый пример вызовет возникновение исключения &lt;code&gt;e&lt;/code&gt; , а второй - нет. Фактически, &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; вызовет исключение только тогда, когда он используется в монаде &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; вариант должен использоваться в предпочтении , чтобы &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , чтобы вызвать исключение в &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; монада , поскольку она гарантирует порядок в отношении других &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; операций, в то время как &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; не делает.</target>
        </trans-unit>
        <trans-unit id="00088afbc5cbb44faba064e52d1c85ccc7ca138f" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">Первый пример вызовет возникновение исключения &lt;code&gt;e&lt;/code&gt; , а второй - нет. Фактически, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; вызовет исключение только тогда, когда он используется в монаде &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; вариант должен использоваться в предпочтении , чтобы &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , чтобы вызвать исключение в &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; монада , поскольку она гарантирует порядок в отношении других &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; операций, в то время как &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; не делает.</target>
        </trans-unit>
        <trans-unit id="d99c86cee59c7b0e9addd7c9710d9c1d2d607961" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">Первый пример вызовет возникновение исключения &lt;code&gt;e&lt;/code&gt; , а второй - нет. Фактически, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; вызовет исключение только тогда, когда он используется в монаде &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; вариант должен использоваться в предпочтении , чтобы &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , чтобы вызвать исключение в &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; монада , поскольку она гарантирует порядок в отношении других &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; операций, в то время как &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; не делает.</target>
        </trans-unit>
        <trans-unit id="b34efd21f2daa7d49fe1224a63934d829e838b06" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">Первый пример вызовет возникновение исключения &lt;code&gt;e&lt;/code&gt; , а второй - нет. Фактически, &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; вызовет исключение только тогда, когда он используется в монаде &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; . Вариант &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; следует использовать вместо &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; для вызова исключения в монаде &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; поскольку он гарантирует упорядочение по отношению к другим операциям &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; , тогда как &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="c46e0719305fcb7afbedd529b28ef7ed1317a3e9" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">Первый пример вызовет возникновение исключения &lt;code&gt;e&lt;/code&gt; , а второй - нет. Фактически, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; вызовет исключение только тогда, когда он используется в монаде &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; . Вариант &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; следует использовать вместо &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; для вызова исключения в монаде &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; поскольку он гарантирует упорядочение по отношению к другим операциям &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; , тогда как &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="8377e7f947ca82c2d03b9e96804a9cc74da945a8" translate="yes" xml:space="preserve">
          <source>The first form declares that &lt;code&gt;f&lt;/code&gt; is a (pure) C function that takes no arguments and returns a pointer to a C function with type &lt;code&gt;t&lt;/code&gt;, whereas the second form declares that &lt;code&gt;f&lt;/code&gt; itself is a C function with type &lt;code&gt;t&lt;/code&gt;. The first declaration is usually a mistake, and one that is hard to debug because it results in a crash, hence this warning.</source>
          <target state="translated">Первая форма объявляет, что &lt;code&gt;f&lt;/code&gt; является (чистой) функцией C, которая не принимает аргументов и возвращает указатель на функцию C с типом &lt;code&gt;t&lt;/code&gt; , тогда как вторая форма объявляет, что сама &lt;code&gt;f&lt;/code&gt; является функцией C с типом &lt;code&gt;t&lt;/code&gt; . Первое объявление обычно является ошибкой, и его трудно отладить, поскольку оно приводит к сбою, отсюда и это предупреждение.</target>
        </trans-unit>
        <trans-unit id="b437c04b578dcbe34c5b61a20dafa47889b4aaf9" translate="yes" xml:space="preserve">
          <source>The first four lines (&lt;code&gt;JOB&lt;/code&gt;, &lt;code&gt;DATE&lt;/code&gt;, &lt;code&gt;SAMPLE_UNIT&lt;/code&gt;, &lt;code&gt;VALUE_UNIT&lt;/code&gt;) form a header. Each block of lines starting with &lt;code&gt;BEGIN_SAMPLE&lt;/code&gt; and ending with &lt;code&gt;END_SAMPLE&lt;/code&gt; forms a single sample (you can think of this as a vertical slice of your heap profile). The hp2ps utility should accept any input with a properly-formatted header followed by a series of &lt;em&gt;complete&lt;/em&gt; samples.</source>
          <target state="translated">Первые четыре строки ( &lt;code&gt;JOB&lt;/code&gt; , &lt;code&gt;DATE&lt;/code&gt; , &lt;code&gt;SAMPLE_UNIT&lt;/code&gt; , &lt;code&gt;VALUE_UNIT&lt;/code&gt; ) образуют заголовок. Каждый блок строк, начинающийся с &lt;code&gt;BEGIN_SAMPLE&lt;/code&gt; и заканчивающийся на &lt;code&gt;END_SAMPLE&lt;/code&gt; , образует один образец (вы можете думать об этом как о вертикальном срезе вашего профиля кучи). Утилита hp2ps должна принимать любой ввод с правильно отформатированным заголовком, за которым следует серия &lt;em&gt;полных&lt;/em&gt; образцов.</target>
        </trans-unit>
        <trans-unit id="c2b82a03029ef67f0b50718409c503eea389a692" translate="yes" xml:space="preserve">
          <source>The first letter of the input is converted to title case, as is every subsequent letter that immediately follows a non-letter. Every letter that immediately follows another letter is converted to lower case.</source>
          <target state="translated">Первая буква вводимого текста конвертируется в регистр заголовка,как и каждая последующая буква,следующая непосредственно за небуквенным текстом.Каждая буква,следующая сразу за другой буквой,преобразуется в строчный регистр.</target>
        </trans-unit>
        <trans-unit id="63efb85344c0aa9c20ebac363da48aba559537ad" translate="yes" xml:space="preserve">
          <source>The first matching axiom we encounter while entailing &lt;code&gt;C a&lt;/code&gt;, is &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt;. We have a local axiom &lt;code&gt;B a&lt;/code&gt; available, so now the program is suddenly accepted. This behaviour, where the ordering of an instance context determines whether or not the program is accepted, seems rather confusing for the developer.</source>
          <target state="translated">Первая аксиома соответствия, с которой мы сталкиваемся при выводе &lt;code&gt;C a&lt;/code&gt; , - это &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt; . У нас есть локальная аксиома &lt;code&gt;B a&lt;/code&gt; , поэтому теперь программа неожиданно принимается. Такое поведение, когда порядок контекста экземпляра определяет, будет ли принята программа или нет, кажется разработчику довольно запутанным.</target>
        </trans-unit>
        <trans-unit id="0123b61d2574afe7df7113981a9973c5d86d2592" translate="yes" xml:space="preserve">
          <source>The first most common step is the concatenation of two &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. Internally, concatenation corresponds to function composition. (Note that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s can be seen as difference-lists of buffer-filling functions; cf. &lt;a href=&quot;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&quot;&gt;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&lt;/a&gt;. ) Function composition is a fast O(1) operation. However, we can use bounded primitives to remove some of these function compositions altogether, which is more efficient.</source>
          <target state="translated">Первый наиболее распространенный шаг - это объединение двух &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; . Внутри конкатенация соответствует композиции функций. (Обратите внимание, что &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; можно рассматривать как списки различий функций заполнения буфера; см. &lt;a href=&quot;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&quot;&gt;Http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&lt;/a&gt; .) Композиция функций - это быстрый O ( 1) операция. Однако мы можем использовать ограниченные примитивы, чтобы полностью удалить некоторые из этих функциональных композиций, что более эффективно.</target>
        </trans-unit>
        <trans-unit id="2b6aa4f035d3b73aa4ab4041c788e09ed98100cf" translate="yes" xml:space="preserve">
          <source>The first of the &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; operations, &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt;, is a simple action, so we can lift it through &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;InterpM&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Первая из операций &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt; , является простым действием, поэтому мы можем поднять ее через &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;InterpM&lt;/code&gt; с помощью &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2faac1fc5843e8344edfa39159393215c540048a" translate="yes" xml:space="preserve">
          <source>The first of these is obviously fine. The second is still fine, although less obviously. The third is not Haskell 98, and risks losing termination of instances.</source>
          <target state="translated">Первое из них,очевидно,в порядке.Вторая все еще в порядке,хотя и менее очевидна.Третий-не Хаскелл 98,и рискует лишиться возможности прекратить рассмотрение дел.</target>
        </trans-unit>
        <trans-unit id="a23c2d18f54a6700ee1bddf4a4ced9e452ae0f90" translate="yes" xml:space="preserve">
          <source>The first option is to compile the program twice:</source>
          <target state="translated">Первый вариант-скомпилировать программу дважды:</target>
        </trans-unit>
        <trans-unit id="b7637c081a47d73b9bc11cd583b13a110b93646f" translate="yes" xml:space="preserve">
          <source>The first part of the file gives the program name and options, and the total time and total memory allocation measured during the run of the program (note that the total memory allocation figure isn&amp;rsquo;t the same as the amount of &lt;em&gt;live&lt;/em&gt; memory needed by the program at any one time; the latter can be determined using heap profiling, which we will describe later in &lt;a href=&quot;#prof-heap&quot;&gt;Profiling memory usage&lt;/a&gt;).</source>
          <target state="translated">Первая часть файла содержит имя программы и параметры, а также общее время и общее распределение памяти , измеренное во время запуска программы (обратите внимание , что общая цифра выделения памяти не совпадает с количеством &lt;em&gt;живой&lt;/em&gt; памяти , в которой нуждается программу в любое время; последнее можно определить с помощью профилирования кучи, которое мы опишем позже в &lt;a href=&quot;#prof-heap&quot;&gt;разделе Профилирование использования памяти&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fef3e13957b592e13b7450a30e6df7cd6f143a71" translate="yes" xml:space="preserve">
          <source>The first phase to run is determined by each input-file suffix, and the last phase is determined by a flag. If no relevant flag is present, then go all the way through to linking. This table summarises:</source>
          <target state="translated">Первая фаза определяется суффиксом каждого входного файла,а последняя-флагом.Если соответствующий флаг отсутствует,то следует пройти весь путь до линковки.В этой таблице приведены сводные данные:</target>
        </trans-unit>
        <trans-unit id="145ee321d09d8f6c8d70bccf9d36b9f9aa7af807" translate="yes" xml:space="preserve">
          <source>The first thing we need is generic representations. The &lt;code&gt;GHC.Generics&lt;/code&gt; module defines a couple of primitive types that are used to represent Haskell datatypes:</source>
          <target state="translated">Первое, что нам нужно, это общие представления. Модуль &lt;code&gt;GHC.Generics&lt;/code&gt; определяет пару примитивных типов, которые используются для представления типов данных Haskell:</target>
        </trans-unit>
        <trans-unit id="4a1ecb3ae40da3aae2e8c25cd4cee41373d627e8" translate="yes" xml:space="preserve">
          <source>The fixed point of a monadic computation. &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; executes the action &lt;code&gt;f&lt;/code&gt; only once, with the eventual output fed back as the input. Hence &lt;code&gt;f&lt;/code&gt; should not be strict, for then &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; would diverge.</source>
          <target state="translated">Неподвижная точка монадического вычисления. &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; выполняет действие &lt;code&gt;f&lt;/code&gt; только один раз, а конечный результат возвращается как вход. Следовательно, &lt;code&gt;f&lt;/code&gt; не должно быть строгим, &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; расходится.</target>
        </trans-unit>
        <trans-unit id="3b861bc9465ad5c567e33d3c5ea5e7f4fe10fe04" translate="yes" xml:space="preserve">
          <source>The fixity of a type operator may be set using the usual fixity declarations but, as in &lt;a href=&quot;#infix-tycons&quot;&gt;Infix type constructors, classes, and type variables&lt;/a&gt;, the function and type constructor share a single fixity.</source>
          <target state="translated">Фиксированность оператора типа может быть установлена ​​с использованием обычных объявлений фиксации, но, как и в &lt;a href=&quot;#infix-tycons&quot;&gt;конструкторах типа Infix, классах и переменных&lt;/a&gt; типа, конструктор функции и типа имеет единую фиксацию.</target>
        </trans-unit>
        <trans-unit id="397ad5d952fd5d1bd350537f1bb34e2a9d3464c7" translate="yes" xml:space="preserve">
          <source>The fixity of the constructor</source>
          <target state="translated">Фиксированность конструктора</target>
        </trans-unit>
        <trans-unit id="0127191c720e27284ab5a66b202e3464fd573afd" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; also lifts the corresponding restriction on class declarations (&lt;a href=&quot;#superclass-rules&quot;&gt;The superclasses of a class declaration&lt;/a&gt;) and instance declarations (&lt;a href=&quot;#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;).</source>
          <target state="translated">Флаг &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt; также снимает соответствующее ограничение на объявления классов ( &lt;a href=&quot;#superclass-rules&quot;&gt;суперклассы объявления класса&lt;/a&gt; ) и объявления экземпляров ( &lt;a href=&quot;#instance-rules&quot;&gt;упрощенные правила для контекстов экземпляров&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="680d808c4989476cdf108f73531ac73891762a24" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#ghc-flag--Wincomplete-uni-patterns&quot;&gt;&lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt;&lt;/a&gt; is similar to &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt;, except that it applies only to lambda-expressions and pattern bindings, constructs that only allow a single pattern:</source>
          <target state="translated">Флаг &lt;a href=&quot;#ghc-flag--Wincomplete-uni-patterns&quot;&gt; &lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt; &lt;/a&gt; похож на &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt; , за исключением того, что он применяется только к лямбда-выражениям и привязкам шаблонов, конструкциям, которые допускают только один шаблон:</target>
        </trans-unit>
        <trans-unit id="0b79e0ee85c7165a369baa04cb9639b641623921" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Worphans&lt;/code&gt;&lt;/a&gt; warns about user-written orphan rules or instances.</source>
          <target state="translated">Флаг &lt;a href=&quot;#ghc-flag--Worphans&quot;&gt; &lt;code&gt;-Worphans&lt;/code&gt; &lt;/a&gt; предупреждает о написанных пользователем правилах или экземплярах-сиротах.</target>
        </trans-unit>
        <trans-unit id="47cb0b5fb9b4f5cbc05ae1ed28f5f328bb28aed6" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt; shows the expansion of all top-level declaration splices, both typed and untyped, as they happen. As with all dump flags, the default is for this output to be sent to stdout. For a non-trivial program, you may be interested in combining this with the &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt; flag (see &lt;a href=&quot;debugging#dumping-output&quot;&gt;Dumping out compiler intermediate structures&lt;/a&gt;. For each file using Template Haskell, this will show the output in a &lt;code&gt;.dump-splices&lt;/code&gt; file.</source>
          <target state="translated">Флаг &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt; &lt;code&gt;-ddump-splices&lt;/code&gt; &lt;/a&gt; показывает расширение всех соединений объявлений верхнего уровня, как типизированных, так и нетипизированных, по мере их появления. Как и все флаги дампа, по умолчанию этот вывод отправляется на стандартный вывод. Для нетривиальной программы, вы можете быть заинтересованы в объединении этого с &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt; флагом (см &lt;a href=&quot;debugging#dumping-output&quot;&gt;сбросов из компилятора промежуточных структур&lt;/a&gt; . Для каждого файла с помощью шаблона Haskell, это покажет выход в &lt;code&gt;.dump-splices&lt;/code&gt; файл ,</target>
        </trans-unit>
        <trans-unit id="4495b2a19abefc172f62863056de3aa383544711" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;debugging#ghc-flag--dth-dec-file&quot;&gt;&lt;code&gt;-dth-dec-file&lt;/code&gt;&lt;/a&gt; dumps the expansions of all top-level TH declaration splices, both typed and untyped, in the file &lt;code&gt;M.th.hs&lt;/code&gt; for each module &lt;code&gt;M&lt;/code&gt; being compiled. Note that other types of splices (expressions, types, and patterns) are not shown. Application developers can check this into their repository so that they can grep for identifiers that were defined in Template Haskell. This is similar to using &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt; but it always generates a file instead of being coupled to &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;. The format is also different: it does not show code from the original file, instead it only shows generated code and has a comment for the splice location of the original file.</source>
          <target state="translated">Флаг &lt;a href=&quot;debugging#ghc-flag--dth-dec-file&quot;&gt; &lt;code&gt;-dth-dec-file&lt;/code&gt; &lt;/a&gt; выгружает расширения всех склейок объявлений TH верхнего уровня, как типизированных, так и нетипизированных, в файл &lt;code&gt;M.th.hs&lt;/code&gt; для каждого компилируемого модуля &lt;code&gt;M&lt;/code&gt; .Обратите внимание, что другие типы соединений (выражения, типы и шаблоны) не показаны. Разработчики приложений могут проверить это в своем репозитории, чтобы найти идентификаторы, определенные в Template Haskell. Это похоже на использование &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt; с &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt; &lt;code&gt;-ddump-splices&lt;/code&gt; ,&lt;/a&gt; но всегда генерирует файл вместо того, чтобы быть связанным с &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt;, Формат также отличается: он не показывает код из исходного файла, вместо этого он показывает только сгенерированный код и имеет комментарий для места соединения исходного файла.</target>
        </trans-unit>
        <trans-unit id="b93b2c7d1b9eda88e393a8f5e74873331f11d482" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; controls whether type errors are deferred to runtime. Type errors will still be emitted as warnings, but will not prevent compilation. You can use &lt;code&gt;-Wno-type-errors&lt;/code&gt; to suppress these warnings.</source>
          <target state="translated">Флаг &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt; определяет, откладываются ли ошибки типа во время выполнения. Ошибки типа по-прежнему будут выдаваться как предупреждения, но не препятствуют компиляции. Вы можете использовать &lt;code&gt;-Wno-type-errors&lt;/code&gt; для подавления этих предупреждений.</target>
        </trans-unit>
        <trans-unit id="1b3baa03b1de2ae2d10fcb9504c97b6f24d46a7f" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; works in GHCi as well, with one exception: for &amp;ldquo;naked&amp;rdquo; expressions typed at the prompt, type errors don&amp;rsquo;t get delayed, so for example:</source>
          <target state="translated">Флаг &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; также&lt;/a&gt; работает в GHCi, за одним исключением: для &amp;laquo;голых&amp;raquo; выражений, вводимых в командной строке, ошибки типа не задерживаются, например:</target>
        </trans-unit>
        <trans-unit id="7bc71daa56ee822998e1d64f92a7832d0f7badec" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;-fglasgow-exts&lt;/code&gt; is equivalent to enabling the following extensions:</source>
          <target state="translated">Флаг &lt;code&gt;-fglasgow-exts&lt;/code&gt; эквивалентен включению следующих расширений:</target>
        </trans-unit>
        <trans-unit id="bfe7b59eddf66920c11dffff433c9395a1cc1d4e" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;-fprint-evld-with-show&lt;/code&gt; instructs &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; to reuse available &lt;code&gt;Show&lt;/code&gt; instances when possible. This happens only when the contents of the variable being inspected are completely evaluated.</source>
          <target state="translated">Флаг &lt;code&gt;-fprint-evld-with-show&lt;/code&gt; указывает &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; для повторного использования доступных экземпляров &lt;code&gt;Show&lt;/code&gt; , когда это возможно. Это происходит только тогда, когда содержимое проверяемой переменной полностью оценивается.</target>
        </trans-unit>
        <trans-unit id="d43a045f4632b27bf091372de67333d21d36a1ae" translate="yes" xml:space="preserve">
          <source>The flag reference tables (&lt;a href=&quot;flags#flag-reference&quot;&gt;Flag reference&lt;/a&gt;) lists the status of each flag.</source>
          <target state="translated">В справочных таблицах &lt;a href=&quot;flags#flag-reference&quot;&gt;флагов&lt;/a&gt; ( Flag reference ) перечислены состояния каждого флага.</target>
        </trans-unit>
        <trans-unit id="960b0cead1ab39ce475efd50a401951d0d90317c" translate="yes" xml:space="preserve">
          <source>The flags &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--static&quot;&gt;&lt;code&gt;-static&lt;/code&gt;&lt;/a&gt; control whether the resulting shared object links statically or dynamically to Haskell package libraries given as &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; option. Non-Haskell libraries are linked as gcc would regularly link it on your system, e.g. on most ELF system the linker uses the dynamic libraries when found.</source>
          <target state="translated">Флаги &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#ghc-flag--static&quot;&gt; &lt;code&gt;-static&lt;/code&gt; &lt;/a&gt; контролируют, будет ли результирующий общий объект статически или динамически &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; библиотеками пакетов Haskell, заданными как опция -package ⟨pkg⟩ . Библиотеки, не относящиеся к Haskell, связаны, поскольку gcc будет регулярно связывать их в вашей системе, например, в большинстве систем ELF компоновщик использует динамические библиотеки при обнаружении.</target>
        </trans-unit>
        <trans-unit id="7668d5e6fe85390adb7a3ecf19db212413e1eebc" translate="yes" xml:space="preserve">
          <source>The flags &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt;&lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;&lt;/a&gt; have no effect when used with &lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;, because they are implemented by changing the definition of &lt;code&gt;main&lt;/code&gt; that GHC generates. See &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt; for how to get the effect of &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt;&lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;&lt;/a&gt; when using your own &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">Флаги &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt; &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; &lt;/a&gt; имеют никакого эффекта при использовании с &lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt; , потому что они реализуются путем изменения определения &lt;code&gt;main&lt;/code&gt; что генерирует GHC. См. Раздел &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Использование собственного main (),&lt;/a&gt; чтобы узнать, как получить эффект от &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt; &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; &lt;/a&gt; при использовании собственного &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe514827a2bc8cfeb3427c13cc2ba47f6aba7300" translate="yes" xml:space="preserve">
          <source>The flags are:</source>
          <target state="translated">Флаги:</target>
        </trans-unit>
        <trans-unit id="bcad0a34c93b0b86bbc687fc84b1ffd20b52d6a1" translate="yes" xml:space="preserve">
          <source>The floating-point environment is not saved over a normal thread context-switch. So if you modify the floating-point state in one thread, those changes may be visible in other threads. Furthermore, testing the exception state is not reliable, because a context switch may change it. If you need to modify or test the floating point state and use threads, then you must use bound threads (&lt;code&gt;Control.Concurrent.forkOS&lt;/code&gt;), because a bound thread has its own OS thread, and OS threads do save and restore the floating-point state.</source>
          <target state="translated">Среда с плавающей запятой не сохраняется при переключении контекста обычного потока. Поэтому, если вы измените состояние с плавающей запятой в одном потоке, эти изменения могут быть видны в других потоках. Кроме того, проверка состояния исключения ненадежна, поскольку переключение контекста может изменить его. Если вам нужно изменить или протестировать состояние с плавающей запятой и использовать потоки, вы должны использовать связанные потоки ( &lt;code&gt;Control.Concurrent.forkOS&lt;/code&gt; ), потому что связанный поток имеет свой собственный поток ОС, а потоки ОС сохраняют и восстанавливают плавающую точку. штат.</target>
        </trans-unit>
        <trans-unit id="d84e5b1b19c72a9f2f8e38f56f6835541ed5d999" translate="yes" xml:space="preserve">
          <source>The following RTS option(s) affect the behaviour of Concurrent Haskell programs:</source>
          <target state="translated">Следующие опции RTS влияют на поведение параллельных программ Haskell:</target>
        </trans-unit>
        <trans-unit id="52952117f68d88486d7181f97f7977ad0131a484" translate="yes" xml:space="preserve">
          <source>The following are QuickCheck specifications of what the combinators do. These can be seen as formal specifications of the behavior of the combinators.</source>
          <target state="translated">Ниже приведены спецификации комбинаторов QuickCheck.Они могут рассматриваться как формальные спецификации поведения комбинаторов.</target>
        </trans-unit>
        <trans-unit id="880afa09746074737763ff34c90d8a824dfb1e1a" translate="yes" xml:space="preserve">
          <source>The following are definitions for &quot;merge&quot; for each of the heaps above. Each takes a comparison function which is used to order the elements.</source>
          <target state="translated">Ниже приведены определения &quot;слияния&quot; для каждой из кучи,описанных выше.Каждая из них берет функцию сравнения,которая используется для упорядочения элементов.</target>
        </trans-unit>
        <trans-unit id="9031e690866836bd079eb18cd7f2cf6f4a7c0278" translate="yes" xml:space="preserve">
          <source>The following are definitions for &lt;code&gt;popMin&lt;/code&gt;, a function which constructs a stateful action which pops the smallest element from the queue, where &quot;smallest&quot; is according to the supplied comparison function.</source>
          <target state="translated">Ниже приведены определения &lt;code&gt;popMin&lt;/code&gt; , функции, которая создает действие с отслеживанием состояния, которое выталкивает наименьший элемент из очереди, где &quot;наименьший&quot; соответствует предоставленной функции сравнения.</target>
        </trans-unit>
        <trans-unit id="853c1b2416dd00409c8f94cbaaab4d500ad921b0" translate="yes" xml:space="preserve">
          <source>The following are definitions for functions to build queues, given a comparison function.</source>
          <target state="translated">Ниже приведены определения функций для построения очередей с помощью функции сравнения.</target>
        </trans-unit>
        <trans-unit id="00e5f1459a91351f85b76ba47f587250af056d92" translate="yes" xml:space="preserve">
          <source>The following are definitions for various specialized pairing heaps.</source>
          <target state="translated">Ниже приведены определения для различных специализированных парных кучи.</target>
        </trans-unit>
        <trans-unit id="bcfac859b1b4efae75f25f72bc0530006c88e6e1" translate="yes" xml:space="preserve">
          <source>The following are good consumers:</source>
          <target state="translated">Ниже перечислены хорошие потребители:</target>
        </trans-unit>
        <trans-unit id="415fb3cf16155d23aebc101af30f40f1175a4761" translate="yes" xml:space="preserve">
          <source>The following are good producers:</source>
          <target state="translated">Ниже перечислены хорошие производители:</target>
        </trans-unit>
        <trans-unit id="fc2c73f87b7ae21e5d1bff7544c615fae9cb5d03" translate="yes" xml:space="preserve">
          <source>The following behaves as expected:</source>
          <target state="translated">Следующие ведут себя так,как и ожидалось:</target>
        </trans-unit>
        <trans-unit id="0f147698ae3534209b092f6955e20175ff56a36f" translate="yes" xml:space="preserve">
          <source>The following command works to load new packages into a running GHCi:</source>
          <target state="translated">Следующая команда работает для загрузки новых пакетов в работающий GHCi:</target>
        </trans-unit>
        <trans-unit id="e7ad1243df876884047bbd1cfa2abad6fc2f257e" translate="yes" xml:space="preserve">
          <source>The following commands turn the keypad on/off (&lt;code&gt;smkx&lt;/code&gt; and &lt;code&gt;rmkx&lt;/code&gt;). They have no effect if those capabilities are not defined. For portability between terminals, the keypad should be explicitly turned on before accepting user key input.</source>
          <target state="translated">Следующие команды включают / выключают клавиатуру ( &lt;code&gt;smkx&lt;/code&gt; и &lt;code&gt;rmkx&lt;/code&gt; ). Они не действуют, если эти возможности не определены. Для обеспечения переносимости между терминалами клавиатура должна быть явно включена, прежде чем принимать ввод с клавиатуры.</target>
        </trans-unit>
        <trans-unit id="25f14bebf678b2e0c7df12fa6531f8bc946288ab" translate="yes" xml:space="preserve">
          <source>The following definition is available to C programs inter-operating with Haskell code when including the header &lt;code&gt;HsFFI.h&lt;/code&gt;.</source>
          <target state="translated">Следующее определение доступно для программ C, взаимодействующих с кодом Haskell при включении заголовка &lt;code&gt;HsFFI.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6d695a5cf6d19ccd0a26b89aff9c95dd12f497b" translate="yes" xml:space="preserve">
          <source>The following description of the motivation and use of functional dependencies is taken from the Hugs user manual, reproduced here (with minor changes) by kind permission of Mark Jones.</source>
          <target state="translated">Следующее описание мотивации и использования функциональных зависимостей взято из руководства пользователя Hugs,воспроизведенного здесь (с незначительными изменениями)с любезного разрешения Марка Джонса.</target>
        </trans-unit>
        <trans-unit id="255eb2a60233998edc485b972b2b920903f06efc" translate="yes" xml:space="preserve">
          <source>The following equation relates &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Следующее уравнение связывает &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="713d7c0768135036f33a7e1109e709b8e968874e" translate="yes" xml:space="preserve">
          <source>The following equation relates &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Следующее уравнение связывает &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dbc7d38cb4fbd659d01d9a4ef580cbd8a454bdc2" translate="yes" xml:space="preserve">
          <source>The following extra instances are defined:</source>
          <target state="translated">Определены следующие дополнительные экземпляры:</target>
        </trans-unit>
        <trans-unit id="219485ecc6b675dce37eba80ce2494e945235236" translate="yes" xml:space="preserve">
          <source>The following flags are simple ways to select standard &amp;ldquo;packages&amp;rdquo; of warnings:</source>
          <target state="translated">Следующие флаги представляют собой простые способы выбора стандартных &amp;laquo;пакетов&amp;raquo; предупреждений:</target>
        </trans-unit>
        <trans-unit id="9e8f2bd1d4e584f03bc71486665d6449cff997d8" translate="yes" xml:space="preserve">
          <source>The following flags control the way in which GHC displays types in error messages and in GHCi:</source>
          <target state="translated">Следующие флаги управляют тем,как GHC отображает типы в сообщениях об ошибках и в GHCi:</target>
        </trans-unit>
        <trans-unit id="369fd24532366a269db0dd996324b5e45dfd6c9e" translate="yes" xml:space="preserve">
          <source>The following functions allow a thread to control delivery of asynchronous exceptions during a critical region.</source>
          <target state="translated">Следующие функции позволяют потоку контролировать доставку асинхронных исключений во время критической области.</target>
        </trans-unit>
        <trans-unit id="cf919ec9ecd009bd434b357d75af7e1bf8279715" translate="yes" xml:space="preserve">
          <source>The following functions enable cross-platform output of text that may contain Unicode characters.</source>
          <target state="translated">Следующие функции позволяют осуществлять кроссплатформенный вывод текста,который может содержать символы Юникода.</target>
        </trans-unit>
        <trans-unit id="38af53e84d563801f65a6120a4900e75bb8e39ff" translate="yes" xml:space="preserve">
          <source>The following functions for cursor movement will combine the more primitive capabilities. For example, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:moveDown&quot;&gt;moveDown&lt;/a&gt;&lt;/code&gt; may use either &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown&quot;&gt;cursorDown&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown1&quot;&gt;cursorDown1&lt;/a&gt;&lt;/code&gt; depending on the parameter and which of &lt;code&gt;cud&lt;/code&gt; and &lt;code&gt;cud1&lt;/code&gt; are defined.</source>
          <target state="translated">Следующие функции для перемещения курсора объединят более примитивные возможности. Например, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:moveDown&quot;&gt;moveDown&lt;/a&gt;&lt;/code&gt; может использовать либо &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown&quot;&gt;cursorDown&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown1&quot;&gt;cursorDown1&lt;/a&gt;&lt;/code&gt; в зависимости от параметра , и какие из &lt;code&gt;cud&lt;/code&gt; и &lt;code&gt;cud1&lt;/code&gt; определены.</target>
        </trans-unit>
        <trans-unit id="0b7bd1ee8d2490e346b323a061ee5d6bf4bd98aa" translate="yes" xml:space="preserve">
          <source>The following functions read one line or character of input from the user.</source>
          <target state="translated">Следующие функции считывают от пользователя одну строку или символ ввода.</target>
        </trans-unit>
        <trans-unit id="defeb72fa9fc8defce3095a722d77cd56b0b0897" translate="yes" xml:space="preserve">
          <source>The following holds:</source>
          <target state="translated">Следующие приказы:</target>
        </trans-unit>
        <trans-unit id="0e843336042b652d443e731d806dae137491a142" translate="yes" xml:space="preserve">
          <source>The following instances of &lt;code&gt;MonadFix&lt;/code&gt; are automatically provided: List, Maybe, IO. Furthermore, the &lt;code&gt;Control.Monad.ST&lt;/code&gt; and &lt;code&gt;Control.Monad.ST.Lazy&lt;/code&gt; modules provide the instances of the &lt;code&gt;MonadFix&lt;/code&gt; class for Haskell&amp;rsquo;s internal state monad (strict and lazy, respectively).</source>
          <target state="translated">Следующие экземпляры &lt;code&gt;MonadFix&lt;/code&gt; предоставляются автоматически: List, Maybe, IO. Кроме того, модули &lt;code&gt;Control.Monad.ST&lt;/code&gt; и &lt;code&gt;Control.Monad.ST.Lazy&lt;/code&gt; предоставляют экземпляры класса &lt;code&gt;MonadFix&lt;/code&gt; для внутренней монады состояния Haskell (строгой и ленивой соответственно).</target>
        </trans-unit>
        <trans-unit id="974f2bea79592d4497c7bb6f1878062d29b69e35" translate="yes" xml:space="preserve">
          <source>The following laws ought to hold (for all valid bit indices &lt;code&gt;&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;):</source>
          <target state="translated">Должны выполняться следующие законы (для всех допустимых битовых индексов &lt;code&gt;&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="3bc96821c04daf88673e5973fb7e13baaeb66bc4" translate="yes" xml:space="preserve">
          <source>The following operations are guaranteed not to be interruptible:</source>
          <target state="translated">Следующие операции гарантированно не будут прерываться:</target>
        </trans-unit>
        <trans-unit id="740d5fed1fd466547dd8bedbd7c0b84313346d32" translate="yes" xml:space="preserve">
          <source>The following options affect the way the runtime schedules threads on CPUs:</source>
          <target state="translated">Следующие опции влияют на то,как выполняются потоки расписания на CPU:</target>
        </trans-unit>
        <trans-unit id="2b8d3fdea7e46b30a4c9898c10dbf48da92a4aa0" translate="yes" xml:space="preserve">
          <source>The following options are useful for keeping (or not keeping) certain intermediate files around, when normally GHC would throw these away after compilation:</source>
          <target state="translated">Следующие опции полезны для хранения (или не хранения)некоторых промежуточных файлов,когда обычно GHC выбрасывает их после компиляции:</target>
        </trans-unit>
        <trans-unit id="38c3f1cd516a144b167f804cbad9091a110d7738" translate="yes" xml:space="preserve">
          <source>The following property holds</source>
          <target state="translated">Ниже перечислены имущественные права</target>
        </trans-unit>
        <trans-unit id="c4d20004308e57029d6af08f5d4d162927106726" translate="yes" xml:space="preserve">
          <source>The following relationships hold:</source>
          <target state="translated">Следующие отношения сохраняются:</target>
        </trans-unit>
        <trans-unit id="78400d597f1cd2c8bbeafc9eb8299b783cc0473e" translate="yes" xml:space="preserve">
          <source>The following sections also give some hints and tips on the use of the foreign function interface in GHC.</source>
          <target state="translated">В следующих разделах также даются некоторые подсказки и советы по использованию интерфейса посторонней функции в GHC.</target>
        </trans-unit>
        <trans-unit id="f17c609e8f1c6b37d3130d2dff0e1652b3175021" translate="yes" xml:space="preserve">
          <source>The following should work, since both &lt;code&gt;'1'&lt;/code&gt; and &lt;code&gt;'2'&lt;/code&gt; can be parsed as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">Следующее должно работать, так как &lt;code&gt;'1'&lt;/code&gt; и &lt;code&gt;'2'&lt;/code&gt; могут быть проанализированы как &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f604ae57c21e961a4347d16a255de560a7918fb" translate="yes" xml:space="preserve">
          <source>The following should work, since both &lt;code&gt;'1'&lt;/code&gt; and &lt;code&gt;'2'&lt;/code&gt; can be parsed as &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">Следующее должно работать, так как &lt;code&gt;'1'&lt;/code&gt; и &lt;code&gt;'2'&lt;/code&gt; могут быть проанализированы как &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f68ed3cdb6c1e1e040a389af1a8ea7b8ca3ea19d" translate="yes" xml:space="preserve">
          <source>The following syntax is stolen:</source>
          <target state="translated">Следующий синтаксис украден:</target>
        </trans-unit>
        <trans-unit id="f24a325a1df690e88417cf55ef160f4f9b155bda" translate="yes" xml:space="preserve">
          <source>The following unboxed types may be used as basic foreign types (see FFI Chapter, Section 8.6): &lt;code&gt;Int#&lt;/code&gt;, &lt;code&gt;Word#&lt;/code&gt;, &lt;code&gt;Char#&lt;/code&gt;, &lt;code&gt;Float#&lt;/code&gt;, &lt;code&gt;Double#&lt;/code&gt;, &lt;code&gt;Addr#&lt;/code&gt;, &lt;code&gt;StablePtr# a&lt;/code&gt;, &lt;code&gt;MutableByteArray#&lt;/code&gt;, &lt;code&gt;ForeignObj#&lt;/code&gt;, and &lt;code&gt;ByteArray#&lt;/code&gt;.</source>
          <target state="translated">Следующие неупакованные типы могут использоваться в качестве основных внешних типов (см. Главу FFI, раздел 8.6): &lt;code&gt;Int#&lt;/code&gt; , &lt;code&gt;Word#&lt;/code&gt; , &lt;code&gt;Char#&lt;/code&gt; , &lt;code&gt;Float#&lt;/code&gt; , &lt;code&gt;Double#&lt;/code&gt; , &lt;code&gt;Addr#&lt;/code&gt; , &lt;code&gt;StablePtr# a&lt;/code&gt; , &lt;code&gt;MutableByteArray#&lt;/code&gt; , &lt;code&gt;ForeignObj#&lt;/code&gt; и &lt;code&gt;ByteArray#&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
