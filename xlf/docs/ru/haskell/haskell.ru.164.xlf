<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="b77b2a992aaa4c5d69ac5d9df4c739fffdace5ec" translate="yes" xml:space="preserve">
          <source>Text.ParserCombinators.ReadP</source>
          <target state="translated">Text.ParserCombinators.ReadP</target>
        </trans-unit>
        <trans-unit id="bd62cb34823dd96a921d926b9390b7652930d50d" translate="yes" xml:space="preserve">
          <source>Text.ParserCombinators.ReadPrec</source>
          <target state="translated">Text.ParserCombinators.ReadPrec</target>
        </trans-unit>
        <trans-unit id="841f953fb25d967de66bdc2bfa7b808a4902b9cc" translate="yes" xml:space="preserve">
          <source>Text.PrettyPrint.Annotated</source>
          <target state="translated">Text.PrettyPrint.Annotated</target>
        </trans-unit>
        <trans-unit id="933dae42a8460538e7deec160889c28236a5659e" translate="yes" xml:space="preserve">
          <source>Text.PrettyPrint.Annotated.HughesPJ</source>
          <target state="translated">Text.PrettyPrint.Annotated.HughesPJ</target>
        </trans-unit>
        <trans-unit id="6ba7533c729a21d883c35ea710a41810576fe3f9" translate="yes" xml:space="preserve">
          <source>Text.PrettyPrint.Annotated.HughesPJClass</source>
          <target state="translated">Text.PrettyPrint.Annotated.HughesPJClass</target>
        </trans-unit>
        <trans-unit id="75d296916408b85ed138aacae307021f81e9b105" translate="yes" xml:space="preserve">
          <source>Text.PrettyPrint.HughesPJ</source>
          <target state="translated">Text.PrettyPrint.HughesPJ</target>
        </trans-unit>
        <trans-unit id="070a1b0e3666fba02bf11cf21864f94454e18fee" translate="yes" xml:space="preserve">
          <source>Text.PrettyPrint.HughesPJClass</source>
          <target state="translated">Text.PrettyPrint.HughesPJClass</target>
        </trans-unit>
        <trans-unit id="852f9faf333892c8bfed010752077687bc710eb3" translate="yes" xml:space="preserve">
          <source>Text.Printf</source>
          <target state="translated">Text.Printf</target>
        </trans-unit>
        <trans-unit id="3e467eeda741670cee0544e799baf3bc68f8f6af" translate="yes" xml:space="preserve">
          <source>Text.Read</source>
          <target state="translated">Text.Read</target>
        </trans-unit>
        <trans-unit id="e7d2b433e6b1a5bfaf0e500258b53ab2699f6b40" translate="yes" xml:space="preserve">
          <source>Text.Read.Lex</source>
          <target state="translated">Text.Read.Lex</target>
        </trans-unit>
        <trans-unit id="82d6f31f8994e83ef79b1676df6acd06d40c0952" translate="yes" xml:space="preserve">
          <source>Text.Show</source>
          <target state="translated">Text.Show</target>
        </trans-unit>
        <trans-unit id="a8c2710c3553b8ef538c168f7f038d784360e352" translate="yes" xml:space="preserve">
          <source>Text.XHtml</source>
          <target state="translated">Text.XHtml</target>
        </trans-unit>
        <trans-unit id="1c794c577eeed3e827f3f4434b0b677541efc237" translate="yes" xml:space="preserve">
          <source>Text.XHtml.Frameset</source>
          <target state="translated">Text.XHtml.Frameset</target>
        </trans-unit>
        <trans-unit id="4e310429294785c3e4ed13f69b32d21e7e3c6e8a" translate="yes" xml:space="preserve">
          <source>Text.XHtml.Strict</source>
          <target state="translated">Text.XHtml.Strict</target>
        </trans-unit>
        <trans-unit id="eaaae80f3e09d76e5b52e5458697c3fd39663493" translate="yes" xml:space="preserve">
          <source>Text.XHtml.Table</source>
          <target state="translated">Text.XHtml.Table</target>
        </trans-unit>
        <trans-unit id="b60bd5c761b5c1a8480926f234df22b56fc27ec9" translate="yes" xml:space="preserve">
          <source>Text.XHtml.Transitional</source>
          <target state="translated">Text.XHtml.Transitional</target>
        </trans-unit>
        <trans-unit id="840c7e38544dbd613fa0b1f9a59f6f627ea3dd88" translate="yes" xml:space="preserve">
          <source>TextDecoder</source>
          <target state="translated">TextDecoder</target>
        </trans-unit>
        <trans-unit id="b1ec439dd8ac6da12ff0821c5bfa7393b4881faa" translate="yes" xml:space="preserve">
          <source>TextEncoder</source>
          <target state="translated">TextEncoder</target>
        </trans-unit>
        <trans-unit id="9195c9a1d76bd3421ac42c82a5d2ce786ab09b23" translate="yes" xml:space="preserve">
          <source>TextEncoding</source>
          <target state="translated">TextEncoding</target>
        </trans-unit>
        <trans-unit id="ef309892f2826f378147927737ca881b40420a37" translate="yes" xml:space="preserve">
          <source>Textual name of this user (pw_name)</source>
          <target state="translated">Текстовое имя этого пользователя (pw_name)</target>
        </trans-unit>
        <trans-unit id="45b3ae04eef9762e57f97f506e36c837398301fc" translate="yes" xml:space="preserve">
          <source>Textual source positions.</source>
          <target state="translated">Текстовые позиции источника.</target>
        </trans-unit>
        <trans-unit id="6a2ec719ddee27b8ee0018e15dcb0d3552659a4c" translate="yes" xml:space="preserve">
          <source>Th32SnapFlags</source>
          <target state="translated">Th32SnapFlags</target>
        </trans-unit>
        <trans-unit id="f1c71aeaa559503cb5c111582956f3709a70b40b" translate="yes" xml:space="preserve">
          <source>Th32SnapHandle</source>
          <target state="translated">Th32SnapHandle</target>
        </trans-unit>
        <trans-unit id="78e1c498231e4965c95cd3fcf27fb9a7f46b40a8" translate="yes" xml:space="preserve">
          <source>That being said, with the appropriate use of wrapper datatypes, the above limitations induce no loss of generality:</source>
          <target state="translated">При этом,при надлежащем использовании типов данных обертки,вышеуказанные ограничения не приводят к потере универсальности:</target>
        </trans-unit>
        <trans-unit id="58dcecccbdfb19a6c28d4e72b8694cf3a95079aa" translate="yes" xml:space="preserve">
          <source>That gives rise to a &lt;code&gt;(X [Bool] beta)&lt;/code&gt; constraint, and using the instance means we need &lt;code&gt;(D Bool beta)&lt;/code&gt; and that fixes &lt;code&gt;beta&lt;/code&gt; via &lt;code&gt;D&lt;/code&gt;&amp;lsquo;s fundep!</source>
          <target state="translated">Это приводит к &lt;code&gt;(X [Bool] beta)&lt;/code&gt; ограничение, и использование экземпляра означает необходимость &lt;code&gt;(D Bool beta)&lt;/code&gt; и который фиксирует &lt;code&gt;beta&lt;/code&gt; через &lt;code&gt;D&lt;/code&gt; fundep &amp;laquo;s!</target>
        </trans-unit>
        <trans-unit id="6a7f123da8ed9434c97040e703694b356a4d2399" translate="yes" xml:space="preserve">
          <source>That gives rise to a &lt;code&gt;(X [Bool] beta)&lt;/code&gt; constraint, and using the instance means we need &lt;code&gt;(D Bool beta)&lt;/code&gt; and that fixes &lt;code&gt;beta&lt;/code&gt; via &lt;code&gt;D&lt;/code&gt;&amp;rsquo;s fundep!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2a29bc8dbb5ee0c4a1930b318abbbb60994a117" translate="yes" xml:space="preserve">
          <source>That is because we require an &lt;code&gt;Eq (Option a)&lt;/code&gt; instance from the default type signature for &lt;code&gt;(==#)&lt;/code&gt;, which in turn requires an &lt;code&gt;Eq a&lt;/code&gt; instance, which we don&amp;rsquo;t have in scope. But if you tweak the definition of &lt;code&gt;HigherEq&lt;/code&gt; slightly:</source>
          <target state="translated">Это потому, что нам нужен экземпляр &lt;code&gt;Eq (Option a)&lt;/code&gt; из сигнатуры типа по умолчанию для &lt;code&gt;(==#)&lt;/code&gt; , который, в свою очередь, требует экземпляра &lt;code&gt;Eq a&lt;/code&gt; , которого у нас нет в области видимости. Но если вы немного &lt;code&gt;HigherEq&lt;/code&gt; определение HigherEq :</target>
        </trans-unit>
        <trans-unit id="462366d2ca673f43337d58fb2f79b52eb40d828a" translate="yes" xml:space="preserve">
          <source>That is the same as the dynamic linking on other platforms, and it is described in &lt;a href=&quot;shared_libs#using-shared-libs&quot;&gt;Using shared libraries&lt;/a&gt;.</source>
          <target state="translated">Это то же самое, что и динамическое связывание на других платформах, и оно описано в разделе &lt;a href=&quot;shared_libs#using-shared-libs&quot;&gt;Использование общих библиотек&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5adb8f6d680643cb988e19cd9ebd95685b0e9084" translate="yes" xml:space="preserve">
          <source>That is, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; pattern-matches its way into tuples and maps over each type that constitutes the tuple. The generated code is reminiscent of what would be generated from &lt;code&gt;data Triple a = Triple a Int [a]&lt;/code&gt;, except with extra machinery to handle the tuple.</source>
          <target state="translated">То есть шаблон &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; сопоставляется с кортежами и сопоставляет каждый тип, составляющий кортеж. Сгенерированный код напоминает то, что было бы сгенерировано из &lt;code&gt;data Triple a = Triple a Int [a]&lt;/code&gt; , за исключением дополнительных механизмов для обработки кортежа.</target>
        </trans-unit>
        <trans-unit id="4a82aebf2ff4e63f82086bf2da9eae4d7a61ab25" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; parses the string produced by &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, and delivers the value that &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; started with.</source>
          <target state="translated">То есть &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; анализирует строку, &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; , и доставляет значение, с &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; запущена команда showsPrec .</target>
        </trans-unit>
        <trans-unit id="9e481507876f41c367fe06e578b12b78a4e7b1ac" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; parses the string produced by &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, and delivers the value that &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; started with.</source>
          <target state="translated">То есть &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; анализирует строку, &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; , и доставляет значение, с &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; запущена команда showsPrec .</target>
        </trans-unit>
        <trans-unit id="49ebb42c3d6e117d12265da60c750a18218cde33" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; parses the string produced by &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, and delivers the value that &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; started with.</source>
          <target state="translated">То есть &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; анализирует строку, &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; , и доставляет значение, с &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; запущена команда showsPrec .</target>
        </trans-unit>
        <trans-unit id="924d09ba70f052db4b220a5f8dac59b3109fa413" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; parses the string produced by &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, and delivers the value that &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; started with.</source>
          <target state="translated">То есть &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; анализирует строку, &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; , и доставляет значение, с &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; запущена команда showsPrec .</target>
        </trans-unit>
        <trans-unit id="5981428896475a8992aaf356fb600c2886c3b975" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; parses the string produced by &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, and delivers the value that &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; started with.</source>
          <target state="translated">То есть &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; анализирует строку, &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; , и доставляет значение, с &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; запущена команда showsPrec .</target>
        </trans-unit>
        <trans-unit id="a0d56a2fcb64d6ff47305c969e3cc186106c4d12" translate="yes" xml:space="preserve">
          <source>That is, a quoter is a tuple of four parsers, one for each of the contexts in which a quasi-quote can occur.</source>
          <target state="translated">То есть цитата-это кортеж из четырех парсеров,по одному для каждого из контекстов,в которых может происходить квазицитата.</target>
        </trans-unit>
        <trans-unit id="1ac21267c135501bf8d1d0d91f2b069a3782591d" translate="yes" xml:space="preserve">
          <source>That is, an &lt;code&gt;SPretty Foo&lt;/code&gt; instance will be created with empty implementations for all methods. Since we are using &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt; in this example, a default implementation of &lt;code&gt;sPpr&lt;/code&gt; is filled in automatically.</source>
          <target state="translated">То есть будет создан экземпляр &lt;code&gt;SPretty Foo&lt;/code&gt; с пустыми реализациями для всех методов. Поскольку в этом примере мы используем &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt; , реализация &lt;code&gt;sPpr&lt;/code&gt; по умолчанию заполняется автоматически.</target>
        </trans-unit>
        <trans-unit id="663aa2118010ecc8a1e027d6bf82ba72221ad60a" translate="yes" xml:space="preserve">
          <source>That is, an &lt;code&gt;SPretty Foo&lt;/code&gt; instance will be created with empty implementations for all methods. Since we are using &lt;a href=&quot;default_signatures#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt; in this example, a default implementation of &lt;code&gt;sPpr&lt;/code&gt; is filled in automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b860dffaafb771638ee538e2b0ac1693cebe622" translate="yes" xml:space="preserve">
          <source>That is, since the type variable &lt;code&gt;a&lt;/code&gt; isn&amp;rsquo;t in scope, it&amp;rsquo;s implicitly universally quantified.</source>
          <target state="translated">То есть, поскольку переменная типа &lt;code&gt;a&lt;/code&gt; не входит в область видимости, она неявно универсально определяется количественно.</target>
        </trans-unit>
        <trans-unit id="d7a4e9e2c0f64dd1b628ca2224d1a3e388241d4f" translate="yes" xml:space="preserve">
          <source>That is, the &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; methods should be the inverse of each other. A range of instances are provided for basic Haskell types.</source>
          <target state="translated">То есть методы &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; должны быть противоположными друг другу. Для базовых типов Haskell предоставляется ряд экземпляров.</target>
        </trans-unit>
        <trans-unit id="2de858dbd3f42f7a78dc46a1d661e4c45116e634" translate="yes" xml:space="preserve">
          <source>That is, the operator must be a function of two arguments. GHC allows it to take only one argument, and that in turn allows you to write the function postfix.</source>
          <target state="translated">То есть оператор должен быть функцией двух аргументов.GHC позволяет ему принимать только один аргумент,а это,в свою очередь,позволяет написать постфикс функции.</target>
        </trans-unit>
        <trans-unit id="de2666094f8dd3b89fcecfae7a344b137b1c390e" translate="yes" xml:space="preserve">
          <source>That is, the scoping is the same as it would be if the curried arguments were collected into a tuple.</source>
          <target state="translated">Т.е.,диапазон измерений такой же,как и в случае,если бы аргументы с карри,собранные в кортеж,были бы собраны.</target>
        </trans-unit>
        <trans-unit id="a08280c0c335de4d817b47c060a3f4af660b030a" translate="yes" xml:space="preserve">
          <source>That is, to match a variable ⟨v⟩ against a pattern &lt;code&gt;(&lt;/code&gt; ⟨exp⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt;, evaluate &lt;code&gt;(&lt;/code&gt; ⟨exp⟩ ⟨v⟩ &lt;code&gt;)&lt;/code&gt; and match the result against ⟨pat⟩.</source>
          <target state="translated">То есть, чтобы сопоставить переменную ⟨v⟩ с шаблоном &lt;code&gt;(&lt;/code&gt; ⟨exp⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; pat⟩ &lt;code&gt;)&lt;/code&gt; , оценить &lt;code&gt;(&lt;/code&gt; ⟨exp⟩ ⟨v⟩ &lt;code&gt;)&lt;/code&gt; и сопоставить результат с ⟨pat⟩.</target>
        </trans-unit>
        <trans-unit id="f81ae30760fa45f0027ed10944dbae9bf4a7947d" translate="yes" xml:space="preserve">
          <source>That is, we add a new form of pattern, written ⟨expression⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pattern⟩ that means &amp;ldquo;apply the expression to whatever we&amp;rsquo;re trying to match against, and then match the result of that application against the pattern&amp;rdquo;. The expression can be any Haskell expression of function type, and view patterns can be used wherever patterns are used.</source>
          <target state="translated">То есть мы добавляем новую форму шаблона, записанную &amp;laquo;выражение&amp;raquo; &lt;code&gt;-&amp;gt;&lt;/code&gt; &amp;laquo; шаблон&amp;raquo;, что означает &amp;laquo;применить выражение ко всему, что мы пытаемся сопоставить, а затем сопоставить результат этого приложения с шаблоном&amp;raquo;. Выражение может быть любым выражением Haskell типа функции, и шаблоны представления могут использоваться везде, где используются шаблоны.</target>
        </trans-unit>
        <trans-unit id="e4472bb74389d304d179494e5f818bbd3e2091fe" translate="yes" xml:space="preserve">
          <source>That is, we represent every functional dependency (FD) &lt;code&gt;a1 .. an -&amp;gt; b&lt;/code&gt; by an FD type family &lt;code&gt;F a1 .. an&lt;/code&gt; and a superclass context equality &lt;code&gt;F a1 .. an ~ b&lt;/code&gt;, essentially giving a name to the functional dependency. In class instances, we define the type instances of FD families in accordance with the class head. Method signatures are not affected by that process.</source>
          <target state="translated">То есть мы представляем каждую функциональную зависимость (FD) &lt;code&gt;a1 .. an -&amp;gt; b&lt;/code&gt; семейством FD-типов &lt;code&gt;F a1 .. an&lt;/code&gt; и контекстным равенством суперкласса &lt;code&gt;F a1 .. an ~ b&lt;/code&gt; , по существу давая имя функциональной зависимости. В экземплярах классов мы определяем экземпляры типов семейств FD в соответствии с заголовком класса. Этот процесс не влияет на сигнатуры методов.</target>
        </trans-unit>
        <trans-unit id="087a1186066043015d53285a25aa834f074c4bb9" translate="yes" xml:space="preserve">
          <source>That last one deserves a special mention, however, since &lt;code&gt;a -&amp;gt; Int -&amp;gt; Int&lt;/code&gt; is a straightforward instantiation of &lt;code&gt;forall b. a -&amp;gt; b -&amp;gt; b&lt;/code&gt;. You can still write such a default type signature, but you now must use type equalities to do so:</source>
          <target state="translated">Последнее, однако, заслуживает особого упоминания, поскольку &lt;code&gt;a -&amp;gt; Int -&amp;gt; Int&lt;/code&gt; является прямым экземпляром &lt;code&gt;forall b. a -&amp;gt; b -&amp;gt; b&lt;/code&gt; . Вы все еще можете написать такую ​​сигнатуру типа по умолчанию, но теперь вы должны использовать для этого равенства типов:</target>
        </trans-unit>
        <trans-unit id="7aa747ff9513051d2f3e0f63c5ab4677db5c86d5" translate="yes" xml:space="preserve">
          <source>That leaves let expressions, whose translation is given in &lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.12&quot;&gt;Section 3.12&lt;/a&gt; of the Haskell Report. Replace the &amp;ldquo;Translation&amp;rdquo; there with the following one. Given &lt;code&gt;let { bind1 ... bindn } in body&lt;/code&gt;:</source>
          <target state="translated">Это оставляет выражения let, перевод которых приведен в &lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.12&quot;&gt;Разделе 3.12&lt;/a&gt; отчета Haskell. Замени там &amp;laquo;Перевод&amp;raquo; на следующий. Учитывая &lt;code&gt;let { bind1 ... bindn } in body&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cd50fc2b9c34278d98468c36da785c66b0803c5a" translate="yes" xml:space="preserve">
          <source>That leaves let expressions, whose translation is given in &lt;a href=&quot;https://www.haskell.org/onlinereport/exps.html#sect3.12&quot;&gt;Section 3.12&lt;/a&gt; of the Haskell Report. Replace the &amp;ldquo;Translation&amp;rdquo; there with the following one. Given &lt;code&gt;let { bind1 ... bindn } in body&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9239200a2fcf1e520b700775bc66f764a197c669" translate="yes" xml:space="preserve">
          <source>That postpones the question of which instance to pick to the call site for &lt;code&gt;f&lt;/code&gt; by which time more is known about the type &lt;code&gt;b&lt;/code&gt;. You can write this type signature yourself if you use the &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">Это откладывает вопрос о том, какой экземпляр выбрать на сайт вызова для &lt;code&gt;f&lt;/code&gt; ,и к тому времени больше известно о типе &lt;code&gt;b&lt;/code&gt; . Вы можете написать сигнатуру этого типа самостоятельно, если используете расширение &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d389a135a3109bdad0320beb8a57c6c2152f2179" translate="yes" xml:space="preserve">
          <source>That postpones the question of which instance to pick to the call site for &lt;code&gt;f&lt;/code&gt; by which time more is known about the type &lt;code&gt;b&lt;/code&gt;. You can write this type signature yourself if you use the &lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af663474763fbec92b5233bfe0db021c376fce2" translate="yes" xml:space="preserve">
          <source>That would make no sense if the expression to the left of &lt;code&gt;-&amp;lt;&lt;/code&gt; involves the bound variable &lt;code&gt;x&lt;/code&gt;. More generally, the expression to the left of &lt;code&gt;-&amp;lt;&lt;/code&gt; may not involve any local variable, i.e. a variable bound in the current arrow abstraction. For such a situation there is a variant &lt;code&gt;-&amp;lt;&amp;lt;&lt;/code&gt;, as in</source>
          <target state="translated">Это не имело бы смысла, если бы выражение слева от &lt;code&gt;-&amp;lt;&lt;/code&gt; включает связанную переменную &lt;code&gt;x&lt;/code&gt; . В более общем смысле, выражение слева от &lt;code&gt;-&amp;lt;&lt;/code&gt; может не включать никаких локальных переменных, то есть переменных, связанных в текущей абстракции стрелки. Для такой ситуации есть вариант &lt;code&gt;-&amp;lt;&amp;lt;&lt;/code&gt; , как в</target>
        </trans-unit>
        <trans-unit id="8395997f12760883e7bd00deba567522fa0be628" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all a little confusing, so here&amp;rsquo;s a few examples. To start with, here&amp;rsquo;s a new GHCi command which doesn&amp;rsquo;t take any arguments or produce any results, it just outputs the current date and time:</source>
          <target state="translated">Это все немного сбивает с толку, поэтому вот несколько примеров. Для начала, вот новая команда GHCi, которая не принимает никаких аргументов и не дает никаких результатов, она просто выводит текущую дату и время:</target>
        </trans-unit>
        <trans-unit id="3a5d327acf1cda84e99ba8c8418f8a6e3f1a6041" translate="yes" xml:space="preserve">
          <source>The &quot;%v&quot; specifier is provided for all built-in types, and should be provided for user-defined type formatters as well. It picks a &quot;best&quot; representation for the given type. For the built-in types the &quot;%v&quot; specifier is converted as follows:</source>
          <target state="translated">Спецификатор &quot;%v&quot; предусмотрен для всех встроенных типов,а также для пользовательских форматоров типов.Он выбирает &quot;лучшее&quot; представление для данного типа.Для встроенных типов спецификатор &quot;%v&quot; приводится следующим образом:</target>
        </trans-unit>
        <trans-unit id="307d8dbf7393ba19bad8b70f752ec95aa046ce44" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;By&lt;/code&gt;&quot; operations</source>
          <target state="translated">Операции &quot; &lt;code&gt;By&lt;/code&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="599928469bbf0c1871f851f1ade723c44533fb25" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;generic&lt;/code&gt;&quot; operations</source>
          <target state="translated">&amp;laquo; &lt;code&gt;generic&lt;/code&gt; &amp;raquo; операции</target>
        </trans-unit>
        <trans-unit id="d6bed068edef8687960252343aec2dce4a6f9960" translate="yes" xml:space="preserve">
          <source>The &quot;alternate form&quot; for unsigned radix conversions is as in C &lt;code&gt;printf(3)&lt;/code&gt;:</source>
          <target state="translated">&amp;laquo;Альтернативная форма&amp;raquo; для преобразования системы счисления без знака такая же, как в C &lt;code&gt;printf(3)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="594cda52526f7a4ced49e3f563eb6b3d2f24eeb4" translate="yes" xml:space="preserve">
          <source>The &quot;format parser&quot; walks over argument-type-specific modifier characters to find the primary format character. This is the type of its result.</source>
          <target state="translated">Форматный парсер&quot; проходит через символы модификаторов,специфичные для типа аргумента,чтобы найти символ первичного формата.Это тип его результата.</target>
        </trans-unit>
        <trans-unit id="7723ee8b77a369d6247096077763bfcd23d475ce" translate="yes" xml:space="preserve">
          <source>The &quot;live&quot; elements of the buffer are those between the &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufL&quot;&gt;bufL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufR&quot;&gt;bufR&lt;/a&gt;&lt;/code&gt; offsets. In an empty buffer, &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufL&quot;&gt;bufL&lt;/a&gt;&lt;/code&gt; is equal to &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufR&quot;&gt;bufR&lt;/a&gt;&lt;/code&gt;, but they might not be zero: for example, the buffer might correspond to a memory-mapped file and in which case &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufL&quot;&gt;bufL&lt;/a&gt;&lt;/code&gt; will point to the next location to be written, which is not necessarily the beginning of the file.</source>
          <target state="translated">&amp;laquo;Живые&amp;raquo; элементы буфера находятся между смещениями &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufL&quot;&gt;bufL&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufR&quot;&gt;bufR&lt;/a&gt;&lt;/code&gt; . В пустом буфере &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufL&quot;&gt;bufL&lt;/a&gt;&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufR&quot;&gt;bufR&lt;/a&gt;&lt;/code&gt; , но они не могут быть равны нулю: например, буфер может соответствовать отображенному в память файлу, и в этом случае &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufL&quot;&gt;bufL&lt;/a&gt;&lt;/code&gt; будет указывать на следующее место для записи, что не обязательно начало файла.</target>
        </trans-unit>
        <trans-unit id="2a8382d16990b13cd15a39a55ae784945d07894a" translate="yes" xml:space="preserve">
          <source>The &quot;normal&quot; (Level 0) of detail.</source>
          <target state="translated">Нормальный&quot; (уровень 0)детализация.</target>
        </trans-unit>
        <trans-unit id="f72b6aeac8d85eeec70693b005224f9243157a76" translate="yes" xml:space="preserve">
          <source>The &quot;reflection trick&quot;, which takes advantanage of the fact that in &lt;code&gt;class C a where { op :: ty }&lt;/code&gt;, we can safely coerce between &lt;code&gt;C a&lt;/code&gt; and &lt;code&gt;ty&lt;/code&gt; (which have different kinds!) because it's really just a newtype. Note: there is &lt;em&gt;no guarantee, at all&lt;/em&gt; that this behavior will be supported into perpetuity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c953365586bc5a5e627fb11bde8ec6bbd7800149" translate="yes" xml:space="preserve">
          <source>The &quot;value&quot; exposed via the &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; etc. instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="667c18fb4c63293a30cf0ae6252784353ac2d4c3" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;&lt;code&gt;forall a&lt;/code&gt;&amp;rdquo; brings &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; into scope in the definition of &amp;ldquo;&lt;code&gt;f&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">&amp;laquo; &lt;code&gt;forall a&lt;/code&gt; &amp;raquo; вводит &amp;laquo; &lt;code&gt;a&lt;/code&gt; &amp;raquo; в объем определения &amp;laquo; &lt;code&gt;f&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="c6c6c6b0c9636ffbfcb145dd52b6cf329767257a" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;bytes allocated in the heap&amp;rdquo; is the total bytes allocated by the program over the whole run.</source>
          <target state="translated">&amp;laquo;Байты, выделенные в куче&amp;raquo; - это общее количество байтов, выделенных программой за весь прогон.</target>
        </trans-unit>
        <trans-unit id="584d620fa2734b6b5eaa0370f4dc4f644b3e240e" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;bytes maximum slop&amp;rdquo; tells you the most space that is ever wasted due to the way GHC allocates memory in blocks. Slop is memory at the end of a block that was wasted. There&amp;rsquo;s no way to control this; we just like to see how much memory is being lost this way.</source>
          <target state="translated">&amp;laquo;Максимальный интервал времени в байтах&amp;raquo; показывает наибольшее количество пространства, которое когда-либо было потрачено впустую из-за того, как GHC выделяет память блоками. Slop - это память в конце блока, который был потрачен впустую. Это невозможно контролировать; нам просто нравится видеть, сколько памяти теряется таким образом.</target>
        </trans-unit>
        <trans-unit id="45090aca257e8cf2e737992e0dab8be6af802dda" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;general principle&amp;rdquo; described here is meant to make all this more predictable for users. It would not be hard to extend GHC to relax this principle. If you should want a change here, consider writing a &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/&quot;&gt;proposal&lt;/a&gt; to do so.</source>
          <target state="translated">Описанный здесь &amp;laquo;общий принцип&amp;raquo; призван сделать все это более предсказуемым для пользователей. Было бы нетрудно расширить GHC, чтобы ослабить этот принцип. Если вы хотите, чтобы здесь что-то изменилось, подумайте о написании соответствующего &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/&quot;&gt;предложения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4fef8e475f005ce6d6f926436263775847cc3803" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;i&amp;rdquo; stands for &amp;ldquo;Interactive&amp;rdquo;</source>
          <target state="translated">&amp;laquo;I&amp;raquo; означает &amp;laquo;интерактивный&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="fc84efa3e37fb0d48e7458b75c4700965bef870a" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;total memory in use&amp;rdquo; tells you the peak memory the RTS has allocated from the OS.</source>
          <target state="translated">&amp;laquo;Общий объем используемой памяти&amp;raquo; показывает пиковую память, выделенную системой RTS из ОС.</target>
        </trans-unit>
        <trans-unit id="c4ca1b8698b4c3c42a66add6d5685bab0dd89277" translate="yes" xml:space="preserve">
          <source>The (binary) &lt;code&gt;Tree&lt;/code&gt; instance example makes use of both, after defining the &lt;code&gt;Empty&lt;/code&gt; base case and the singleton &lt;code&gt;Leaf&lt;/code&gt; node case, non-empty internal nodes introduce both a prepended child node on the left and an appended child node on the right:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb3433e82abbee6557ae4932640c2d8da6b781db" translate="yes" xml:space="preserve">
          <source>The (mono)type: &lt;code&gt;tau&lt;/code&gt;</source>
          <target state="translated">Тип (моно): &lt;code&gt;tau&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60b26e67d917cc3a857c71a7f8b8990a2841e52f" translate="yes" xml:space="preserve">
          <source>The 0 pointer. Used to indicate the empty Bytestring.</source>
          <target state="translated">Указатель 0.Используется для указания пустого Байтстринга.</target>
        </trans-unit>
        <trans-unit id="b0f2110e66ee660be4c8c2f43b8e22fc7b2ac364" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-BlockArguments&quot;&gt;&lt;code&gt;BlockArguments&lt;/code&gt;&lt;/a&gt; extension allows these constructs to be directly used as a function argument. For example:</source>
          <target state="translated">Расширение &lt;a href=&quot;#extension-BlockArguments&quot;&gt; &lt;code&gt;BlockArguments&lt;/code&gt; &lt;/a&gt; позволяет напрямую использовать эти конструкции в качестве аргумента функции. Например:</target>
        </trans-unit>
        <trans-unit id="64bdb3d073f079d531b8a96572945cc8af7548ae" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-BlockArguments&quot;&gt;&lt;code&gt;BlockArguments&lt;/code&gt;&lt;/a&gt; extension moves these production rules under &lt;code&gt;aexp&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6312d568cf2735ca75edec69b8ff484ecdbef9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-BlockArguments&quot;&gt;&lt;code&gt;BlockArguments&lt;/code&gt;&lt;/a&gt; extension moves these production rules under &lt;code&gt;aexp&lt;/code&gt;:</source>
          <target state="translated">Расширение &lt;a href=&quot;#extension-BlockArguments&quot;&gt; &lt;code&gt;BlockArguments&lt;/code&gt; &lt;/a&gt; перемещает эти производственные правила под &lt;code&gt;aexp&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1c11e29052e1ea592c72c0d937dab2a12cd84eac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-CPP&quot;&gt;&lt;code&gt;CPP&lt;/code&gt;&lt;/a&gt; language extension can also be enabled using the &lt;a href=&quot;exts/pragmas#language-pragma&quot;&gt;LANGUAGE&lt;/a&gt; pragma; For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c65f0dc74f4931d91c01fa9c6d3700981ddac7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-CPP&quot;&gt;&lt;code&gt;CPP&lt;/code&gt;&lt;/a&gt; language extension can also be enabled using the &lt;a href=&quot;glasgow_exts#language-pragma&quot;&gt;LANGUAGE&lt;/a&gt; pragma; For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb9ce911311ab5062d718c76033a5381bcc759c1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-CPP&quot;&gt;&lt;code&gt;CPP&lt;/code&gt;&lt;/a&gt; language extension enables the C pre-processor. This can be turned into a command-line flag by prefixing it with &lt;code&gt;-X&lt;/code&gt;; For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4cf567699873d6594767b8148b3283fe3e91e5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-EmptyCase&quot;&gt;&lt;code&gt;EmptyCase&lt;/code&gt;&lt;/a&gt; extension enables case expressions, or lambda-case expressions, that have no alternatives, thus:</source>
          <target state="translated">Расширение &lt;a href=&quot;#extension-EmptyCase&quot;&gt; &lt;code&gt;EmptyCase&lt;/code&gt; &lt;/a&gt; позволяет использовать выражения case или лямбда-выражения, которые не имеют альтернативы, таким образом:</target>
        </trans-unit>
        <trans-unit id="abbd0ecca5ae43844dd2d11341709a7cbf2688b3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt;&lt;code&gt;EmptyDataDeriving&lt;/code&gt;&lt;/a&gt; flag is only required to enable deriving of these four &amp;ldquo;standard&amp;rdquo; type classes (which are mentioned in the Haskell Report). Other extensions to the &lt;code&gt;deriving&lt;/code&gt; mechanism, which are explained below in greater detail, do not require &lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt;&lt;code&gt;EmptyDataDeriving&lt;/code&gt;&lt;/a&gt; to be used in conjunction with empty data types. These include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012817880879ac3870d5610c6cda1f372d2afa1d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; extension allows you to prefix the name of a type constructor in an import or export list with &amp;ldquo;&lt;code&gt;type&lt;/code&gt;&amp;rdquo; to disambiguate this case, thus:</source>
          <target state="translated">Расширение &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt; &lt;code&gt;ExplicitNamespaces&lt;/code&gt; &lt;/a&gt; позволяет вам добавлять к имени конструктора типа в списке импорта или экспорта префикс &amp;laquo; &lt;code&gt;type&lt;/code&gt; &amp;raquo;, чтобы устранить неоднозначность в этом случае, таким образом:</target>
        </trans-unit>
        <trans-unit id="5ba167f467ba97a573f10efce8b6b966cd314396" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension lifts the Haskell 98 restriction that the type-class constraints in a type signature must have the form &lt;em&gt;(class type-variable)&lt;/em&gt; or &lt;em&gt;(class (type-variable type1 type2 &amp;hellip; typen))&lt;/em&gt;. With &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; these type signatures are perfectly okay</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e42ac5c594dfd901f58792044e9a9041c4003be" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension lifts the Haskell 98 restriction that the type-class constraints in a type signature must have the form &lt;em&gt;(class type-variable)&lt;/em&gt; or &lt;em&gt;(class (type-variable type1 type2 ... typen))&lt;/em&gt;. With &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; these type signatures are perfectly okay</source>
          <target state="translated">Расширение &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt; снимает ограничение Haskell 98, согласно которому ограничения типа-класса в сигнатуре типа должны иметь форму &lt;em&gt;(класс-переменная-тип)&lt;/em&gt; или &lt;em&gt;(класс (тип-переменная тип1 тип2 ... тип))&lt;/em&gt; . С &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt; эти сигнатуры типов совершенно нормальны</target>
        </trans-unit>
        <trans-unit id="7a3b07e5c3b3f792ae9a2205da0ebe6f644dadb1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension relaxes this rule, as well as relaxing the corresponding rule for type signatures (see &lt;a href=&quot;#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;). Specifically, &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt;, allows (well-kinded) class constraints of form &lt;code&gt;(C t1 ... tn)&lt;/code&gt; in the context of an instance declaration.</source>
          <target state="translated">Расширение &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt; ослабляет это правило, а также ослабляет соответствующее правило для сигнатур типа (см &lt;a href=&quot;#flexible-contexts&quot;&gt;. Контекст сигнатуры типа&lt;/a&gt; ). В частности, &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt; допускает (хорошо подобранные) ограничения класса формы &lt;code&gt;(C t1 ... tn)&lt;/code&gt; в контексте объявления экземпляра.</target>
        </trans-unit>
        <trans-unit id="0562613b8f75a0cd91d39da3210ac809ea1b3a19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt; extension allows the head of the instance declaration to mention arbitrary nested types. For example, this becomes a legal instance declaration</source>
          <target state="translated">Расширение &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt; &lt;code&gt;FlexibleInstances&lt;/code&gt; &lt;/a&gt; позволяет заголовку объявления экземпляра упоминать произвольные вложенные типы. Например, это становится декларацией юридической инстанции.</target>
        </trans-unit>
        <trans-unit id="661ec8113ef99ccdd08a9cd1e3cdeaf21af63fa6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt; extension implies &lt;a href=&quot;#extension-TypeSynonymInstances&quot;&gt;&lt;code&gt;TypeSynonymInstances&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Расширение &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt; &lt;code&gt;FlexibleInstances&lt;/code&gt; &lt;/a&gt; подразумевает &lt;a href=&quot;#extension-TypeSynonymInstances&quot;&gt; &lt;code&gt;TypeSynonymInstances&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bdcc91b25b9ed4cc5c0260c1f012c1a5f82d2927" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-LambdaCase&quot;&gt;&lt;code&gt;LambdaCase&lt;/code&gt;&lt;/a&gt; extension enables expressions of the form</source>
          <target state="translated">Расширение &lt;a href=&quot;#extension-LambdaCase&quot;&gt; &lt;code&gt;LambdaCase&lt;/code&gt; &lt;/a&gt; позволяет использовать выражения формы</target>
        </trans-unit>
        <trans-unit id="ae186343574b4460d96f7f83aeb4d511026cbbfd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; also enables some new forms of literals (see &lt;a href=&quot;#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt;):</source>
          <target state="translated">&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt; также позволяет некоторые новые формы литералов (см &lt;a href=&quot;#glasgow-unboxed&quot;&gt;Unboxed типов&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="e3929c268c7ca8099bc7fccc912027c58685a7e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; also enables some new forms of literals (see &lt;a href=&quot;primitives#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f156d0b8de4e1a07b993f716b37564cac76a1370" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-PostfixOperators&quot;&gt;&lt;code&gt;PostfixOperators&lt;/code&gt;&lt;/a&gt; extension enables a small extension to the syntax of left operator sections, which allows you to define postfix operators. The extension is this: the left section</source>
          <target state="translated">Расширение &lt;a href=&quot;#extension-PostfixOperators&quot;&gt; &lt;code&gt;PostfixOperators&lt;/code&gt; &lt;/a&gt; включает небольшое расширение синтаксиса секций левых операторов, которое позволяет вам определять постфиксные операторы. Расширение это: левая секция</target>
        </trans-unit>
        <trans-unit id="a89c98a9a3a672e6e0625684027419f38aef7f06" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; option is also required for any type with a &lt;code&gt;forall&lt;/code&gt; or context to the right of an arrow (e.g. &lt;code&gt;f :: Int -&amp;gt; forall a. a-&amp;gt;a&lt;/code&gt;, or &lt;code&gt;g :: Int -&amp;gt; Ord a =&amp;gt; a -&amp;gt; a&lt;/code&gt;). Such types are technically rank 1, but are clearly not Haskell-98, and an extra extension did not seem worth the bother.</source>
          <target state="translated">Параметр &lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt; также требуется для любого типа с &lt;code&gt;forall&lt;/code&gt; или контекстом справа от стрелки (например, &lt;code&gt;f :: Int -&amp;gt; forall a. a-&amp;gt;a&lt;/code&gt; или &lt;code&gt;g :: Int -&amp;gt; Ord a =&amp;gt; a -&amp;gt; a&lt;/code&gt; ). Такие типы технически имеют ранг 1, но явно не относятся к Haskell-98, и дополнительное расширение, похоже, не стоило хлопот.</target>
        </trans-unit>
        <trans-unit id="35fe223925e3329d9b396b0289c0f1edb80c5f64" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-TupleSections&quot;&gt;&lt;code&gt;TupleSections&lt;/code&gt;&lt;/a&gt; extension enables partially applied tuple constructors. For example, the following program</source>
          <target state="translated">Расширение &lt;a href=&quot;#extension-TupleSections&quot;&gt; &lt;code&gt;TupleSections&lt;/code&gt; &lt;/a&gt; позволяет использовать частично применяемые конструкторы кортежей. Например, следующая программа</target>
        </trans-unit>
        <trans-unit id="b17d31417452ac7082cc9ac3c80a11f860e37344" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; extension allows you to use &lt;em&gt;visible type application&lt;/em&gt; in expressions. Here is an example: &lt;code&gt;show (read @Int &quot;5&quot;)&lt;/code&gt;. The &lt;code&gt;@Int&lt;/code&gt; is the visible type application; it specifies the value of the type variable in &lt;code&gt;read&lt;/code&gt;&amp;lsquo;s type.</source>
          <target state="translated">Расширение &lt;a href=&quot;#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt; позволяет использовать &lt;em&gt;приложение видимого типа&lt;/em&gt; в выражениях. Вот пример: &lt;code&gt;show (read @Int &quot;5&quot;)&lt;/code&gt; . &lt;code&gt;@Int&lt;/code&gt; является применение видимым типа; он определяет значение переменной типа в типе &lt;code&gt;read&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="815a49f2870c920071d25b5de51faa8078cb6a12" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; extension allows you to use &lt;em&gt;visible type application&lt;/em&gt; in expressions. Here is an example: &lt;code&gt;show (read @Int &quot;5&quot;)&lt;/code&gt;. The &lt;code&gt;@Int&lt;/code&gt; is the visible type application; it specifies the value of the type variable in &lt;code&gt;read&lt;/code&gt;&amp;rsquo;s type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ebe94937368bfa68f3a743d993e9e33b0ab16eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; extension is also used to lift some of the restrictions imposed on type family instances. See &lt;a href=&quot;#type-family-decidability&quot;&gt;Decidability of type synonym instances&lt;/a&gt;.</source>
          <target state="translated">Расширение &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt; также используется для снятия некоторых ограничений, накладываемых на экземпляры семейства типов. См. &lt;a href=&quot;#type-family-decidability&quot;&gt;Раздел &amp;laquo;Разрешимость экземпляров синонимов типа&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f4536f5d8a26219603d39e37690a74527cca915" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; extension is also used to lift some of the restrictions imposed on type family instances. See &lt;a href=&quot;type_families#type-family-decidability&quot;&gt;Decidability of type synonym instances&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a40f430193c52ab9a3cf3f22af8fbf5bb4348a51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--Wmissing-export-lists&quot;&gt;&lt;code&gt;-Wmissing-export-lists&lt;/code&gt;&lt;/a&gt; flag will warn that &lt;code&gt;M&lt;/code&gt; does not declare an export list. Declaring an explicit export list for &lt;code&gt;M&lt;/code&gt; enables GHC dead code analysis, prevents accidental export of names and can ease optimizations like inlining.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wmissing-export-lists&quot;&gt; &lt;code&gt;-Wmissing-export-lists&lt;/code&gt; &lt;/a&gt; флаг предупредит , что &lt;code&gt;M&lt;/code&gt; не объявляет список экспорта. Объявление явного списка экспорта для &lt;code&gt;M&lt;/code&gt; включает анализ мертвого кода GHC, предотвращает случайный экспорт имен и может упростить оптимизацию, такую ​​как встраивание.</target>
        </trans-unit>
        <trans-unit id="2a474ac6ba444d90bd68f49cf89271d299c2d550" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--Wmissing-import-lists&quot;&gt;&lt;code&gt;-Wmissing-import-lists&lt;/code&gt;&lt;/a&gt; flag will warn about the import of &lt;code&gt;Y&lt;/code&gt; but not &lt;code&gt;X&lt;/code&gt; If module &lt;code&gt;Y&lt;/code&gt; is later changed to export (say) &lt;code&gt;f&lt;/code&gt;, then the reference to &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt; will become ambiguous. No warning is produced for the import of &lt;code&gt;Z&lt;/code&gt; because extending &lt;code&gt;Z&lt;/code&gt;&amp;lsquo;s exports would be unlikely to produce ambiguity in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wmissing-import-lists&quot;&gt; &lt;code&gt;-Wmissing-import-lists&lt;/code&gt; &lt;/a&gt; флаг предупредит об импорте &lt;code&gt;Y&lt;/code&gt; , но не &lt;code&gt;X&lt;/code&gt; Если модуль &lt;code&gt;Y&lt;/code&gt; позже изменен на экспорт (скажет) &lt;code&gt;f&lt;/code&gt; , то ссылка на &lt;code&gt;f&lt;/code&gt; в &lt;code&gt;M&lt;/code&gt; будет неоднозначной. Предупреждение не производятся для импорта &lt;code&gt;Z&lt;/code&gt; потому , проходящего &lt;code&gt;Z&lt;/code&gt; экспорта &amp;laquo;сек будет вряд ли приведет к неоднозначности в &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e9463d37bc7356ac89d64ece95dfb6664646492" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--Wmissing-import-lists&quot;&gt;&lt;code&gt;-Wmissing-import-lists&lt;/code&gt;&lt;/a&gt; flag will warn about the import of &lt;code&gt;Y&lt;/code&gt; but not &lt;code&gt;X&lt;/code&gt; If module &lt;code&gt;Y&lt;/code&gt; is later changed to export (say) &lt;code&gt;f&lt;/code&gt;, then the reference to &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt; will become ambiguous. No warning is produced for the import of &lt;code&gt;Z&lt;/code&gt; because extending &lt;code&gt;Z&lt;/code&gt;&amp;rsquo;s exports would be unlikely to produce ambiguity in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36bf4d5a27eab719495aba2d65180ff3cb627fe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt;&lt;code&gt;-XEmptyDataDeriving&lt;/code&gt;&lt;/a&gt; flag is only required to enable deriving of these four &amp;ldquo;standard&amp;rdquo; type classes (which are mentioned in the Haskell Report). Other extensions to the &lt;code&gt;deriving&lt;/code&gt; mechanism, which are explained below in greater detail, do not require &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt;&lt;code&gt;-XEmptyDataDeriving&lt;/code&gt;&lt;/a&gt; to be used in conjunction with empty data types. These include:</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt; &lt;code&gt;-XEmptyDataDeriving&lt;/code&gt; &lt;/a&gt; флаг требуется только для того, чтобы получения этих четырех &amp;laquo;стандартных&amp;raquo; классов типа (которые упоминаются в докладе Haskell). Другие расширения механизма &lt;code&gt;deriving&lt;/code&gt; , которые более подробно объясняются ниже, не требуют использования &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt; &lt;code&gt;-XEmptyDataDeriving&lt;/code&gt; &lt;/a&gt; вместе с пустыми типами данных. Это включает:</target>
        </trans-unit>
        <trans-unit id="db722c4293a180623ff6c051b1d85ff7e25c05ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8expr%E2%9F%A9&quot;&gt;&lt;code&gt;-interactive-print ⟨expr⟩&lt;/code&gt;&lt;/a&gt; flag allows to specify any function of type &lt;code&gt;C a =&amp;gt; a -&amp;gt; IO ()&lt;/code&gt;, for some constraint &lt;code&gt;C&lt;/code&gt;, as the function for printing evaluated expressions. The function can reside in any loaded module or any registered package, but only when it resides in a registered package will it survive a &lt;a href=&quot;#ghci-cmd-:cd&quot;&gt;&lt;code&gt;:cd&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; or, &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В &lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8expr%E2%9F%A9&quot;&gt; &lt;code&gt;-interactive-print ⟨expr⟩&lt;/code&gt; &lt;/a&gt; флаг позволяет задать любую функцию типа &lt;code&gt;C a =&amp;gt; a -&amp;gt; IO ()&lt;/code&gt; , для некоторого ограничения &lt;code&gt;C&lt;/code&gt; , как функция для печати вычисленных выражений. Функция может находиться в любом загруженном модуле или любого зарегистрированного пакета, но только тогда , когда он находится в зарегистрированном пакете будет выжить &lt;a href=&quot;#ghci-cmd-:cd&quot;&gt; &lt;code&gt;:cd&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; или, &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="630c44ffedd4dd17a812ef0191fcfe9f164168e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8expr%E2%9F%A9&quot;&gt;&lt;code&gt;-interactive-print ⟨expr⟩&lt;/code&gt;&lt;/a&gt; flag can also be used when running GHC in &lt;code&gt;-e mode&lt;/code&gt;:</source>
          <target state="translated">В &lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8expr%E2%9F%A9&quot;&gt; &lt;code&gt;-interactive-print ⟨expr⟩&lt;/code&gt; &lt;/a&gt; флаг также может быть использован при работе GHC в &lt;code&gt;-e mode&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="78f35da957d4cd52b15e9fdc17483788082f1d5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8name%E2%9F%A9&quot;&gt;&lt;code&gt;-interactive-print ⟨name⟩&lt;/code&gt;&lt;/a&gt; flag allows to specify any function of type &lt;code&gt;C a =&amp;gt; a -&amp;gt; IO ()&lt;/code&gt;, for some constraint &lt;code&gt;C&lt;/code&gt;, as the function for printing evaluated expressions. The function can reside in any loaded module or any registered package, but only when it resides in a registered package will it survive a &lt;a href=&quot;#ghci-cmd-:cd&quot;&gt;&lt;code&gt;:cd&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; or, &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21b2b57c36c8c1575a9d46ca71c9857aa94c645d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8name%E2%9F%A9&quot;&gt;&lt;code&gt;-interactive-print ⟨name⟩&lt;/code&gt;&lt;/a&gt; flag can also be used when running GHC in &lt;code&gt;-e mode&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ee5aa0e4404a66caea5cfa0e31661321a8a071" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--v&quot;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/a&gt; option makes GHC &lt;em&gt;verbose&lt;/em&gt;: it reports its version number and shows (on stderr) exactly how it invokes each phase of the compilation system. Moreover, it passes the &lt;code&gt;-v&lt;/code&gt; flag to most phases; each reports its version number (and possibly some other information).</source>
          <target state="translated">Параметр &lt;a href=&quot;#ghc-flag--v&quot;&gt; &lt;code&gt;-v&lt;/code&gt; &lt;/a&gt; делает GHC &lt;em&gt;подробным&lt;/em&gt; : он сообщает номер своей версии и показывает (на stderr), как именно он вызывает каждую фазу системы компиляции. Более того, он передает флаг &lt;code&gt;-v&lt;/code&gt; большинству фаз; каждый сообщает номер своей версии (и, возможно, некоторую другую информацию).</target>
        </trans-unit>
        <trans-unit id="f2aaf666449f19ca504a747ac617450334ac0091" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:list&quot;&gt;&lt;code&gt;:list&lt;/code&gt;&lt;/a&gt; command is particularly useful when single-stepping, to see where you currently are:</source>
          <target state="translated">Команда &lt;a href=&quot;#ghci-cmd-:list&quot;&gt; &lt;code&gt;:list&lt;/code&gt; &lt;/a&gt; особенно полезна при пошаговом режиме, чтобы узнать, где вы сейчас находитесь:</target>
        </trans-unit>
        <trans-unit id="c742c2c7dca48891181fe9d4cdbd89257e05f404" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:list&quot;&gt;&lt;code&gt;:list&lt;/code&gt;&lt;/a&gt; command lists the source code around the current breakpoint. If your output device supports it, then GHCi will highlight the active subexpression in bold.</source>
          <target state="translated">Команда &lt;a href=&quot;#ghci-cmd-:list&quot;&gt; &lt;code&gt;:list&lt;/code&gt; &lt;/a&gt; перечисляет исходный код вокруг текущей точки останова. Если ваше устройство вывода поддерживает это, GHCi выделит активное подвыражение жирным шрифтом.</target>
        </trans-unit>
        <trans-unit id="207cb516d01051ef8920382f50ac703484da325f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; commands (&lt;a href=&quot;#ghci-load-scope&quot;&gt;The effect of :load on what is in scope&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt; , и &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; команды ( &lt;a href=&quot;#ghci-load-scope&quot;&gt;Эффект: нагрузки на то , что находится в области видимости&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8573f5c2fc7b5e00d88d28e04c98a9bc731777f4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; commands (&lt;a href=&quot;#loading-source-files&quot;&gt;Loading source files&lt;/a&gt; and &lt;a href=&quot;#ghci-compiled&quot;&gt;Loading compiled code&lt;/a&gt;) affect the top-level scope. Let&amp;rsquo;s start with the simple cases; when you start GHCi the prompt looks like this:</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt; , и &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; команда ( &lt;a href=&quot;#loading-source-files&quot;&gt;Загрузка исходных файлы&lt;/a&gt; и &lt;a href=&quot;#ghci-compiled&quot;&gt;загрузка скомпилированный код&lt;/a&gt; ) влияют на объем верхнего уровня. Начнем с простых случаев; когда вы запускаете GHCi, подсказка выглядит так:</target>
        </trans-unit>
        <trans-unit id="37bb2b0da32b33f4372a12f64ecdf95d300dbf99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; command (&lt;a href=&quot;#ghci-module-cmd&quot;&gt;Controlling what is in scope with the :module command&lt;/a&gt;).</source>
          <target state="translated">Команда &lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;#ghci-module-cmd&quot;&gt;управление тем, что находится в области действия с помощью команды: module&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f54887dc2345c58aa577bced9bca30f40c4398ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; command provides a way to do two things that cannot be done with ordinary &lt;code&gt;import&lt;/code&gt; declarations:</source>
          <target state="translated">Команда &lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; предоставляет способ делать две вещи, которые нельзя сделать с обычными объявлениями &lt;code&gt;import&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="18bed73a85898df39bbfb21bec72caa1d380f65e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; command modifies both, but there is also a &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; command (for &amp;ldquo;set interactive&amp;rdquo;) that affects only the interactive options set.</source>
          <target state="translated">Команда &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; изменяет и то, и другое, но есть также команда &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt; (для &amp;laquo;установить интерактивный&amp;raquo;), которая влияет только на набор интерактивных параметров.</target>
        </trans-unit>
        <trans-unit id="93a4b5fbe24659bd6501066dacfcac63a656645a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; command sets two types of options: GHCi options, which begin with &amp;ldquo;&lt;code&gt;+&lt;/code&gt;&amp;rdquo;, and &amp;ldquo;command-line&amp;rdquo; options, which begin with &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;ldquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a5d114307bab84d24ded440bb5e92a7d6743f5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; command sets two types of options: GHCi options, which begin with &amp;ldquo;&lt;code&gt;+&lt;/code&gt;&amp;rdquo;, and &amp;ldquo;command-line&amp;rdquo; options, which begin with &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">Команда &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; устанавливает два типа параметров: параметры GHCi, которые начинаются с &amp;laquo; &lt;code&gt;+&lt;/code&gt; &amp;raquo;, и параметры &amp;laquo;командной строки&amp;raquo;, которые начинаются с &amp;laquo; &lt;code&gt;-&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="994ae649374ddd00dcbdb0398a07b789d70d3ee6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt; command can be used with or without an expression. When used without an expression, tracing begins from the current breakpoint, just like &lt;a href=&quot;#ghci-cmd-:step&quot;&gt;&lt;code&gt;:step&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Команду &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt; можно использовать с выражением или без него. При использовании без выражения трассировка начинается с текущей точки останова, как &lt;a href=&quot;#ghci-cmd-:step&quot;&gt; &lt;code&gt;:step&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d895b0d326a117dc38216e64627bcf0b504cc040" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:type-at&quot;&gt;&lt;code&gt;:type-at&lt;/code&gt;&lt;/a&gt; command requires &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt;&lt;code&gt;:set +c&lt;/code&gt;&lt;/a&gt; to be set.</source>
          <target state="translated">Для команды &lt;a href=&quot;#ghci-cmd-:type-at&quot;&gt; &lt;code&gt;:type-at&lt;/code&gt; &lt;/a&gt; требуется &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt; &lt;code&gt;:set +c&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="199a238337750e7292c80d8483aa164b1180ba95" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:uses&quot;&gt;&lt;code&gt;:uses&lt;/code&gt;&lt;/a&gt; command requires &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt;&lt;code&gt;:set +c&lt;/code&gt;&lt;/a&gt; to be set.</source>
          <target state="translated">Для команды &lt;a href=&quot;#ghci-cmd-:uses&quot;&gt; &lt;code&gt;:uses&lt;/code&gt; &lt;/a&gt; необходимо &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt; &lt;code&gt;:set +c&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa13aae9cfabe1538d35b3d45ac31cfcc6173609" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; pragma has the additional effect of making the function body look small, so that when inlining is allowed it is very likely to happen.</source>
          <target state="translated">&lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; &lt;/a&gt; прагма имеет дополнительный эффект : внешний вид тела функции мала, так что , когда встраивание разрешено это очень вероятно , произойдет.</target>
        </trans-unit>
        <trans-unit id="3f27181af99e9c0027aecbaabc8044d1c05e8049" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma does exactly what you&amp;rsquo;d expect: it stops the named function from being inlined by the compiler. You shouldn&amp;rsquo;t ever need to do this, unless you&amp;rsquo;re very cautious about code size.</source>
          <target state="translated">&lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt; Прагма делает именно то , что вы ожидали бы: он останавливает указанную функцию от того встраиваемого компилятора. В этом нет необходимости, если только вы не очень осторожны с размером кода.</target>
        </trans-unit>
        <trans-unit id="c1a5fffbed9c12afd5da25081d7fe2ae31e2b1e9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; pragma lets you specify rewrite rules. It is described in &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; Прагма позволяет определить правила перезаписи. Это описано в &lt;a href=&quot;#rewrite-rules&quot;&gt;правилах перезаписи&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf0632a671131031d8937312a06897d2e45574c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt;&lt;code&gt;-F ⟨factor⟩&lt;/code&gt;&lt;/a&gt; setting will be automatically reduced by the garbage collector when the maximum heap size (the &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-M ⟨size⟩&lt;/code&gt;&lt;/a&gt; setting) is approaching.</source>
          <target state="translated">Параметр &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt; &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; &lt;/a&gt; будет автоматически уменьшен сборщиком мусора при приближении максимального размера кучи (параметр &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-M ⟨size⟩&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e8b0c5124d5ea3dd22ec93a4e1efaee8762c585c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#rts-flag--P&quot;&gt;&lt;code&gt;-P&lt;/code&gt;&lt;/a&gt; option produces a more detailed report containing the actual time and allocation data as well. (Not used much.)</source>
          <target state="translated">Параметр &lt;a href=&quot;#rts-flag--P&quot;&gt; &lt;code&gt;-P&lt;/code&gt; &lt;/a&gt; создает более подробный отчет, содержащий фактическое время и данные о распределении. (Не очень много.)</target>
        </trans-unit>
        <trans-unit id="1bd683aedc043a933d9975ed15640d3bb66f7a3a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt; option produces a standard &lt;em&gt;time profile&lt;/em&gt; report. It is written into the file &lt;code&gt;&amp;lt;stem&amp;gt;.prof&lt;/code&gt;; the stem is taken to be the program name by default, but can be overridden by the &lt;a href=&quot;#rts-flag--po%20%E2%9F%A8stem%E2%9F%A9&quot;&gt;&lt;code&gt;-po
⟨stem⟩&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">Параметр &lt;a href=&quot;#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt; создает стандартный отчет &lt;em&gt;временного профиля&lt;/em&gt; . &lt;code&gt;&amp;lt;stem&amp;gt;.prof&lt;/code&gt; в файл &amp;lt;stem&amp;gt; .prof ; по умолчанию в качестве основы используется имя программы, но его можно переопределить с &lt;a href=&quot;#rts-flag--po%20%E2%9F%A8stem%E2%9F%A9&quot;&gt; &lt;code&gt;-po ⟨stem⟩&lt;/code&gt; &lt;/a&gt; флага -po ⟨stem⟩ .</target>
        </trans-unit>
        <trans-unit id="6f811997f5e52254e16a04cd53e244ebe3b6c6f7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#rts-flag--pa&quot;&gt;&lt;code&gt;-pa&lt;/code&gt;&lt;/a&gt; option produces the most detailed report containing all cost centres in addition to the actual time and allocation data.</source>
          <target state="translated">Параметр &lt;a href=&quot;#rts-flag--pa&quot;&gt; &lt;code&gt;-pa&lt;/code&gt; &lt;/a&gt; создает наиболее подробный отчет, содержащий все центры затрат, а также данные о фактическом времени и распределении.</target>
        </trans-unit>
        <trans-unit id="7a84a3b7430c33f4f0db03022262f484fb7742f5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#rts-flag--pj&quot;&gt;&lt;code&gt;-pj&lt;/code&gt;&lt;/a&gt; option produces a time/allocation profile report in JSON format written into the file &lt;code&gt;&amp;lt;program&amp;gt;.prof&lt;/code&gt;.</source>
          <target state="translated">Параметр &lt;a href=&quot;#rts-flag--pj&quot;&gt; &lt;code&gt;-pj&lt;/code&gt; &lt;/a&gt; создает отчет о профиле времени / распределения в формате JSON, записанный в файл &lt;code&gt;&amp;lt;program&amp;gt;.prof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49e571794c298f99f38543a85d7967e52fd97375" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#rts-flag--po%20%E2%9F%A8stem%E2%9F%A9&quot;&gt;&lt;code&gt;-po ⟨stem⟩&lt;/code&gt;&lt;/a&gt; option overrides the stem used to form the output file paths for the cost-centre profiler (see &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#rts-flag--pj&quot;&gt;&lt;code&gt;-pj&lt;/code&gt;&lt;/a&gt; flags above) and heap profiler (see &lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Параметр &lt;a href=&quot;#rts-flag--po%20%E2%9F%A8stem%E2%9F%A9&quot;&gt; &lt;code&gt;-po ⟨stem⟩&lt;/code&gt; &lt;/a&gt; переопределяет основу, используемую для формирования путей к выходным файлам для профилировщика центра затрат (см. Флаги &lt;a href=&quot;#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#rts-flag--pj&quot;&gt; &lt;code&gt;-pj&lt;/code&gt; &lt;/a&gt; выше) и профилировщика кучи (см. &lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b5635087d38bc262bde4371eac4de7d97f976c29" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../base-4.13.0.0/system-io&quot;&gt;System.IO&lt;/a&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функции ввода &lt;a href=&quot;../base-4.13.0.0/system-io&quot;&gt;System.IO&lt;/a&gt; (например, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; ) не преобразуются автоматически в Unicode, поэтому эта функция предназначена для преобразования многобайтовой строки в данной кодовой странице в правильную строку Unicode. Чтобы получить кодовую страницу для консоли, используйте &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9765ad4ea03f4950380592b31970ad8c5c5f3ec8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../base-4.13.0.0/system-io&quot;&gt;System.IO&lt;/a&gt; output functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;) don't automatically convert to multibyte string on Windows, so this function is provided to make the conversion from a Unicode string in the given code page to a proper multibyte string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функции вывода &lt;a href=&quot;../base-4.13.0.0/system-io&quot;&gt;System.IO&lt;/a&gt; (например, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; ) не преобразуются автоматически в многобайтовую строку в Windows, поэтому эта функция предназначена для преобразования строки Unicode в данной кодовой странице в правильную многобайтовую строку. Чтобы получить кодовую страницу для консоли, используйте &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ce9122f50ea53be58cbd2cf028ecc8f4c1bc2e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../base-4.14.1.0/system-io&quot;&gt;System.IO&lt;/a&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcced739f4877615ca0b1d338f8fe3c56b49eea5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../base-4.14.1.0/system-io&quot;&gt;System.IO&lt;/a&gt; output functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;) don't automatically convert to multibyte string on Windows, so this function is provided to make the conversion from a Unicode string in the given code page to a proper multibyte string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7715095f5c8ef807cdbc23a84037a885e460b586" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../base/system-io&quot;&gt;System.IO&lt;/a&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8e728d7d3436bf9c9bfd3d9742877fbe0b85c6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../base/system-io&quot;&gt;System.IO&lt;/a&gt; output functions (e.g. &lt;code&gt;&lt;a href=&quot;../base/system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;) don't automatically convert to multibyte string on Windows, so this function is provided to make the conversion from a Unicode string in the given code page to a proper multibyte string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b352da45baeb9202cb7df82ff50b474eca2ca6d4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM code generator&lt;/a&gt; can sometimes do a far better job at producing fast code than the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt;. This is not universal and depends on the code. Numeric heavy code seems to show the best improvement when compiled via LLVM. You can also experiment with passing specific flags to LLVM with the &lt;code&gt;-optlo ⟨option⟩&lt;/code&gt; and &lt;code&gt;-optlc ⟨option⟩&lt;/code&gt; flags. Be careful though as setting these flags stops GHC from setting its usual flags for the LLVM optimiser and compiler.</source>
          <target state="translated">&lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;Генератор LLVM кода&lt;/a&gt; иногда может сделать гораздо лучшую работу на производство быстрого кода , чем &lt;a href=&quot;codegens#native-code-gen&quot;&gt;родной генератор кода&lt;/a&gt; . Это не универсально и зависит от кода. Числовой тяжелый код, кажется, показывает лучшее улучшение при компиляции через LLVM. Вы также можете поэкспериментировать с передачей определенных флагов в LLVM с помощью &lt;code&gt;-optlo ⟨option⟩&lt;/code&gt; и &lt;code&gt;-optlc ⟨option⟩&lt;/code&gt; . Однако будьте осторожны, поскольку установка этих флагов не позволяет GHC устанавливать свои обычные флаги для оптимизатора и компилятора LLVM.</target>
        </trans-unit>
        <trans-unit id="23545e3e460bae073f6181734f7192afe90ccb39" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;exts/template_haskell#th-usage&quot;&gt;Template Haskell staging restrictions&lt;/a&gt; apply to the expression being annotated with, so for example you cannot run a function from the module being compiled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441b96de5f40c0b544a2b13e929cf0a32ab969bc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension lifts the Haskell 98 restriction that the type-class constraints in a type signature must have the form &lt;em&gt;(class type-variable)&lt;/em&gt; or &lt;em&gt;(class (type-variable type1 type2 ... typen))&lt;/em&gt;. With &lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; these type signatures are perfectly okay</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a4611a6bd66536dd5d384f455f6f4187e13b84f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension relaxes this rule, as well as relaxing the corresponding rule for type signatures (see &lt;a href=&quot;flexible_contexts_signature#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;). Specifically, &lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt;, allows (well-kinded) class constraints of form &lt;code&gt;(C t1 ... tn)&lt;/code&gt; in the context of an instance declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f2f2f377d7a4d9d4c30076fac395670f976ba5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;ghc-err&quot;&gt;GHC.Err&lt;/a&gt; module defines the code for the wired-in error functions, which have a special type in the compiler (with &quot;open tyvars&quot;).</source>
          <target state="translated">Модуль &lt;a href=&quot;ghc-err&quot;&gt;GHC.Err&lt;/a&gt; определяет код для встроенных функций ошибок, которые имеют специальный тип в компиляторе (с &amp;laquo;открытыми тиварами&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="be2bac9dc3e1c4a106dab0bef04844b8cf103571" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;glasgow_exts#th-usage&quot;&gt;Template Haskell staging restrictions&lt;/a&gt; apply to the expression being annotated with, so for example you cannot run a function from the module being compiled.</source>
          <target state="translated">Эти &lt;a href=&quot;glasgow_exts#th-usage&quot;&gt;ограничения стадирования Template Haskell&lt;/a&gt; применяется к выражению аннотируемого с, так, например , вы не можете запустить функцию из модуля компилируются.</target>
        </trans-unit>
        <trans-unit id="7bcd2aebd16cff6eded9cdf9d7624bc94b45657f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;Template Haskell&lt;/a&gt; page on the GHC Wiki has a wealth of information. You may also consult the Haddock reference documentation &amp;lt;Language.Haskell.TH.&amp;gt;. Many changes to the original design are described in &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/th2.ps&quot;&gt;Notes on Template Haskell version 2&lt;/a&gt;. Not all of these changes are in GHC, however.</source>
          <target state="translated">Страница &lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;Template Haskell&lt;/a&gt; в GHC Wiki содержит огромное количество информации. Вы также можете обратиться к справочной документации Haddock &amp;lt;Language.Haskell.TH.&amp;gt;. Многие изменения в исходном дизайне описаны в &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/th2.ps&quot;&gt;Примечаниях к Template Haskell версии 2&lt;/a&gt; . Однако не все эти изменения внесены в GHC.</target>
        </trans-unit>
        <trans-unit id="813ef8b7c698943925b858288d022656cbf4c0e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-compact-0.1.0.0/GHC-Compact.html&quot;&gt;GHC.Compact&lt;/a&gt; module provides a way to make garbage collection more efficient for long-lived data structures. Compacting a data structure collects the objects together in memory, where they are treated as a single object by the garbage collector and not traversed individually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b007f5500c0bf2359ef4d7c48a45339585e270b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-compact-0.1.0.0/GHC-Compact.html&quot;&gt;GHC.Compact&lt;/a&gt; module provides a way to make garbage collection more efficient for long-lived data structures. Compacting a data structure collects the objects together in memory, where they are treated as a single object by the garbage collector and not traversed individually.</source>
          <target state="translated">Модуль &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-compact-0.1.0.0/GHC-Compact.html&quot;&gt;GHC.Compact&lt;/a&gt; позволяет сделать сборку мусора более эффективной для долгоживущих структур данных. При сжатии структуры данных объекты собираются вместе в памяти, где они обрабатываются сборщиком мусора как один объект и не обрабатываются по отдельности.</target>
        </trans-unit>
        <trans-unit id="846fd4cdbb42806031c1db4eb657c7e293898b2c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-compact-0.1.0.0/GHC-Compact.html&quot;&gt;GHC.Compact&lt;/a&gt; module provides a way to make garbage collection more efficient for long-lived data structures. Compacting a data structure collects the objects together in memory, where they are treated as a single object by the garbage collector and not traversed individually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5f20ac4d1c46620e544e0b73094893e035e0db" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hackage.haskell.org/package/fmlist&quot;&gt;&lt;code&gt;fmlist&lt;/code&gt;&lt;/a&gt; package takes this approach, by representing a list via its &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419b4e0aea1efdbf0b01d8b1d21faeb75cc776ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hackage.haskell.org/package/foldl&quot;&gt;&lt;code&gt;foldl&lt;/code&gt;&lt;/a&gt; package implements a robust general framework for dealing with this situation. If you choose to to do it yourself, with a bit of care, the simplest cases are not difficult to handle directly. You just need to accumulate the individual aggregates as &lt;strong&gt;strict&lt;/strong&gt; components of a single data type, and then apply a final transformation to it to extract the composite result. For example, computing an average requires computing both the &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; of a (non-empty) structure and dividing the sum by the length:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b627e268f4e5e65bb4d343165c72971cc53747cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;Template Haskell&lt;/a&gt; page on the GHC Wiki has a wealth of information. You may also consult the Haddock reference documentation &lt;a href=&quot;../../libraries/template-haskell-2.17.0.0/language-haskell-th&quot;&gt;Language.Haskell.TH&lt;/a&gt;. Many changes to the original design are described in &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/th2.ps&quot;&gt;Notes on Template Haskell version 2&lt;/a&gt;. Not all of these changes are in GHC, however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="070dd57b8d8cd78717786ee303fe48951109a4cd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; flag is required for all code that will end up in a shared library. The &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; flag specifies to make a shared library rather than a program. To make this clearer we can break this down into separate compilation and link steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ecf85c887a15b246620bb154b24adf3249c4f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rewrite_rules#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; pragma lets you specify rewrite rules. It is described in &lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="096f364a4638bd5a30481fff7cf63dd60a75f2bb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;system-io&quot;&gt;System.IO&lt;/a&gt; library manages multiplexing in its own way. On Windows systems it uses &lt;code&gt;safe&lt;/code&gt; foreign calls to ensure that threads doing I/O operations don't block the whole runtime, whereas on Unix systems all the currently blocked I/O requests are managed by a single thread (the &lt;em&gt;IO manager thread&lt;/em&gt;) using a mechanism such as &lt;code&gt;epoll&lt;/code&gt; or &lt;code&gt;kqueue&lt;/code&gt;, depending on what is provided by the host operating system.</source>
          <target state="translated">Библиотека &lt;a href=&quot;system-io&quot;&gt;System.IO&lt;/a&gt; по-своему управляет мультиплексированием. В системах Windows он использует &lt;code&gt;safe&lt;/code&gt; внешние вызовы, чтобы гарантировать, что потоки, выполняющие операции ввода-вывода, не блокируют всю среду выполнения, тогда как в системах Unix все заблокированные в настоящее время запросы ввода-вывода управляются одним потоком ( &lt;em&gt;поток диспетчера ввода-вывода&lt;/em&gt; ) с использованием механизм, такой как &lt;code&gt;epoll&lt;/code&gt; или &lt;code&gt;kqueue&lt;/code&gt; , в зависимости от того, что предоставляется операционной системой хоста.</target>
        </trans-unit>
        <trans-unit id="ad73609e01e96153a93cfebddc86a915d6769a77" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;text-read&quot;&gt;Text.Read&lt;/a&gt; library is the canonical library to import for &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;-class facilities. For GHC only, it offers an extended and much improved &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class, which constitutes a proposed alternative to the Haskell 2010 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;. In particular, writing parsers is easier, and the parsers are much more efficient.</source>
          <target state="translated">Библиотека &lt;a href=&quot;text-read&quot;&gt;Text.Read&lt;/a&gt; - это каноническая библиотека для импорта для средств класса &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; . Только для GHC он предлагает расширенный и значительно улучшенный класс &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; , который представляет собой предлагаемую альтернативу Haskell 2010 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; . В частности, писать парсеры проще, а парсеры намного эффективнее.</target>
        </trans-unit>
        <trans-unit id="6049bb328d08178d103c9076445b562b087834cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;using-optimisation#ghc-flag--fno-state-hack&quot;&gt;&lt;code&gt;state hack&lt;/code&gt;&lt;/a&gt; optimization can result in non-obvious changes in evaluation ordering which may hide exceptions, even with &lt;a href=&quot;using-optimisation#ghc-flag--fpedantic-bottoms&quot;&gt;&lt;code&gt;-fpedantic-bottoms&lt;/code&gt;&lt;/a&gt; (see, e.g., &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/7411&quot;&gt;#7411&lt;/a&gt;). For instance,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6bc8b6c64115e4a7c4698a00f5d0d1bc2ad89f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; operator adds the bound function into the continuation chain.</source>
          <target state="translated">Оператор &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; добавляет связанную функцию в цепочку продолжения.</target>
        </trans-unit>
        <trans-unit id="5c388ccd0a655842d446db681e2ea71ce5783acf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'MetaSel&lt;/code&gt; type is also an instance of the type class &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Selector&quot;&gt;Selector&lt;/a&gt;&lt;/code&gt;, which can be used to obtain information about the field at the value level.</source>
          <target state="translated">Тип &lt;code&gt;'MetaSel&lt;/code&gt; также является экземпляром класса &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Selector&quot;&gt;Selector&lt;/a&gt;&lt;/code&gt; типа , который можно использовать для получения информации о поле на уровне значения.</target>
        </trans-unit>
        <trans-unit id="d0fc85998eb7929a8a09016834cb15b185c38b52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(!)&lt;/code&gt; operator, when written in prefix form (preceded by whitespace and not followed by whitespace, as in &lt;code&gt;f !x = ...&lt;/code&gt;), is interpreted as a bang pattern, contrary to the Haskell Report, which prescribes to treat &lt;code&gt;!&lt;/code&gt; as an operator regardless of surrounding whitespace. Note that this does not imply that GHC always enables &lt;a href=&quot;exts/strict#extension-BangPatterns&quot;&gt;&lt;code&gt;BangPatterns&lt;/code&gt;&lt;/a&gt;. Without the extension, GHC will issue a parse error on &lt;code&gt;f !x&lt;/code&gt;, asking to enable the extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="866373df1d7e4a2d96c88db426b8a4e214a580f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(C t1..tj)&lt;/code&gt; is a partial applications of the class &lt;code&gt;C&lt;/code&gt;, where the arity of &lt;code&gt;C&lt;/code&gt; is exactly &lt;code&gt;j+1&lt;/code&gt;. That is, &lt;code&gt;C&lt;/code&gt; lacks exactly one type argument.</source>
          <target state="translated">&lt;code&gt;(C t1..tj)&lt;/code&gt; представляет собой частичное применение класса &lt;code&gt;C&lt;/code&gt; , где арностью &lt;code&gt;C&lt;/code&gt; является точно &lt;code&gt;j+1&lt;/code&gt; . То есть в &lt;code&gt;C&lt;/code&gt; отсутствует ровно один аргумент типа.</target>
        </trans-unit>
        <trans-unit id="0e53d457109427ef5ddcdce2f9d16292b3ffd5e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt;-form is only available for modules which are interpreted; for compiled modules (including modules from packages) only the non-&lt;code&gt;*&lt;/code&gt; form of &lt;a href=&quot;#ghci-cmd-:browse&quot;&gt;&lt;code&gt;:browse&lt;/code&gt;&lt;/a&gt; is available.</source>
          <target state="translated">Форма &lt;code&gt;*&lt;/code&gt; доступна только для интерпретируемых модулей; для скомпилированных модулей (включая модули из пакетов) доступна только не- &lt;code&gt;*&lt;/code&gt; форма &lt;a href=&quot;#ghci-cmd-:browse&quot;&gt; &lt;code&gt;:browse&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b53e971ecc81a3e0c6bf1b64d28ddf52cdda1a1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-#include&lt;/code&gt; option is now deprecated, and the &lt;code&gt;include-files&lt;/code&gt; field in a Cabal package specification is ignored.</source>
          <target state="translated">Опция &lt;code&gt;-#include&lt;/code&gt; теперь устарела, а поле &lt;code&gt;include-files&lt;/code&gt; в спецификации пакета Cabal игнорируется.</target>
        </trans-unit>
        <trans-unit id="ab34545a3d0cf93b61e2311037778df3c80a23fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--numa&lt;/code&gt; flag is typically beneficial when a program is using all cores of a large multi-core NUMA system, with a large allocation area (&lt;code&gt;-A&lt;/code&gt;). All memory accesses to the allocation area will go to local memory, which can save a significant amount of remote memory access. A runtime speedup on the order of 10% is typical, but can vary a lot depending on the hardware and the memory behaviour of the program.</source>
          <target state="translated">&lt;code&gt;--numa&lt;/code&gt; флаг , как правило , полезно , когда программа использует все ядра большой многоядерной системы NUMA, с большой площадью распределения ( &lt;code&gt;-A&lt;/code&gt; ). Все обращения к памяти в области выделения будут осуществляться в локальную память, что может сэкономить значительный объем удаленного доступа к памяти. Ускорение времени выполнения порядка 10% является типичным, но может сильно варьироваться в зависимости от оборудования и поведения памяти программы.</target>
        </trans-unit>
        <trans-unit id="561f71da812b2bddee25afb3e6e2e25bcb2e2f87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--numa&lt;/code&gt; option tells the RTS to tune its memory usage to maximize local memory accesses. In particular, the RTS will:</source>
          <target state="translated">Параметр &lt;code&gt;--numa&lt;/code&gt; указывает RTS настроить использование памяти для максимального доступа к локальной памяти. В частности, РТС:</target>
        </trans-unit>
        <trans-unit id="82790760e32203fbe3b3708f08a40fb1f26d4abb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-O*&lt;/code&gt; options specify convenient &amp;ldquo;packages&amp;rdquo; of optimisation flags; the &lt;code&gt;-f*&lt;/code&gt; options described later on specify &lt;em&gt;individual&lt;/em&gt; optimisations to be turned on/off; the &lt;code&gt;-m*&lt;/code&gt; options specify &lt;em&gt;machine-specific&lt;/em&gt; optimisations to be turned on/off.</source>
          <target state="translated">&lt;code&gt;-O*&lt;/code&gt; опции задают удобные &amp;laquo;пакеты&amp;raquo; из флагов оптимизации; параметры &lt;code&gt;-f*&lt;/code&gt; , описанные ниже, определяют &lt;em&gt;отдельные&lt;/em&gt; оптимизации, которые нужно включить / выключить; параметры &lt;code&gt;-m*&lt;/code&gt; указывают включение / выключение оптимизации для &lt;em&gt;конкретной машины&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="00acee18a5b40f8ae0cd328101fb51b5648ea410" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-S&lt;/code&gt; flag, as well as giving the same output as the &lt;code&gt;-s&lt;/code&gt; flag, prints information about each GC as it happens:</source>
          <target state="translated">&lt;code&gt;-S&lt;/code&gt; флаг, а также дает тот же результат, что и &lt;code&gt;-s&lt;/code&gt; флаг, печатает информацию о каждом GC , как это происходит:</target>
        </trans-unit>
        <trans-unit id="5abe89944b59b5975a75aacf7b4842e37070b39c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-XMonadFailDesugaring&lt;/code&gt; extension switches the desugaring of &lt;code&gt;do&lt;/code&gt;-blocks to use &lt;code&gt;MonadFail.fail&lt;/code&gt; instead of &lt;code&gt;Monad.fail&lt;/code&gt;.</source>
          <target state="translated">Расширение &lt;code&gt;-XMonadFailDesugaring&lt;/code&gt; переключает деактивацию &lt;code&gt;do&lt;/code&gt; -blocks на использование &lt;code&gt;MonadFail.fail&lt;/code&gt; вместо &lt;code&gt;Monad.fail&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97d0f469a862a380331313f906971c001e89be36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-fno-gen-manifest&lt;/code&gt; disables generation of the manifest file. One reason to do this would be if you had a manifest file of your own, for example.</source>
          <target state="translated">&lt;code&gt;-fno-gen-manifest&lt;/code&gt; отключает поколение файла манифеста. Одна из причин для этого может быть, например, если у вас есть собственный файл манифеста.</target>
        </trans-unit>
        <trans-unit id="f09316b31fc22fa8a933567bd8337abedb8c8a8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-hiesuf&lt;/code&gt; ⟨suffix⟩ will change the &lt;code&gt;.hie&lt;/code&gt; file suffix for extended interface files to whatever you specify.</source>
          <target state="translated">&lt;code&gt;-hiesuf&lt;/code&gt; ⟨suffix⟩ изменит &lt;code&gt;.hie&lt;/code&gt; суффикс файла для расширенных файлов интерфейса к тому , что вы укажете.</target>
        </trans-unit>
        <trans-unit id="181c112c9b1448494d00b3a0eb2345692c427713" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-hisuf&lt;/code&gt;/&lt;code&gt;-osuf&lt;/code&gt; game is particularly useful if you want to compile a program both with and without profiling, in the same directory. You can say:</source>
          <target state="translated">Игра &lt;code&gt;-hisuf&lt;/code&gt; / &lt;code&gt;-osuf&lt;/code&gt; особенно полезна, если вы хотите скомпилировать программу как с профилированием, так и без него, в одном каталоге. Ты можешь сказать:</target>
        </trans-unit>
        <trans-unit id="9cfd0028b8c4e48cc0b0a43a4c0d4e8fc3d08a43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-no-hs-main&lt;/code&gt; flag can also be used to persuade the compiler to do the link step in &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode when there is no Haskell &lt;code&gt;Main&lt;/code&gt; module present (normally the compiler will not attempt linking when there is no &lt;code&gt;Main&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;-no-hs-main&lt;/code&gt; флаг может также использоваться , чтобы убедить компилятор , чтобы сделать шаг ссылки в &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; режима , когда нет Haskell &lt;code&gt;Main&lt;/code&gt; модуля присутствует ( как правило , компилятор не будет пытаться связью , когда нет &lt;code&gt;Main&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cfb7b69d0673862e9ddfa0a4b5f54819de95e5d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-osuf&lt;/code&gt; ⟨suffix⟩ will change the &lt;code&gt;.o&lt;/code&gt; file suffix for object files to whatever you specify. We use this when compiling libraries, so that objects for the profiling versions of the libraries don&amp;rsquo;t clobber the normal ones.</source>
          <target state="translated">&lt;code&gt;-osuf&lt;/code&gt; ⟨suffix⟩ изменит &lt;code&gt;.o&lt;/code&gt; суффикс файла для объектных файлов , что вы укажете. Мы используем это при компиляции библиотек, чтобы объекты для профилирующих версий библиотек не затирали обычные.</target>
        </trans-unit>
        <trans-unit id="cf7cc663be7922fef0739796260273d9b72b496e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-outputdir&lt;/code&gt; option is shorthand for the combination of &lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-odir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--hiedir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-hiedir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--stubdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-stubdir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--dumpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-dumpdir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fc191cffb134d6d4bcb21e65f27ae26e638ff7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-outputdir&lt;/code&gt; option is shorthand for the combination of &lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-odir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--stubdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-stubdir
⟨dir⟩&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--dumpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-dumpdir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Параметр &lt;code&gt;-outputdir&lt;/code&gt; является сокращением для комбинации &lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-odir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghc-flag--stubdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-stubdir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#ghc-flag--dumpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-dumpdir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ae93959276ca239dd5463c43ee8f6f822a7abcd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; option also causes package ⟨pkg⟩ to be linked into the resulting executable or shared object. Whether a packages&amp;rsquo; library is linked statically or dynamically is controlled by the flag pair &lt;a href=&quot;phases#ghc-flag--static&quot;&gt;&lt;code&gt;-static&lt;/code&gt;&lt;/a&gt;/ &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Опция &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; также приводит к тому, что пакет &amp;laquo;pkg&amp;raquo; связывается с результирующим исполняемым или общим объектом. Независимо от того, связана ли библиотека пакетов статически или динамически, используется пара флагов &lt;a href=&quot;phases#ghc-flag--static&quot;&gt; &lt;code&gt;-static&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="712c183f0262639bdefc67f670ef5786d9f9839d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-qn&lt;/code&gt; flag may be useful when running with a large &lt;code&gt;-A&lt;/code&gt; value (so that GC is infrequent), and a large &lt;code&gt;-N&lt;/code&gt; value (so as to make use of hyperthreaded cores, for example). For example, on a 24-core machine with 2 hyperthreads per core, we might use &lt;code&gt;-N48 -qn24 -A128m&lt;/code&gt; to specify that the mutator should use hyperthreads but the GC should only use real cores. Note that this configuration would use 6GB for the allocation area.</source>
          <target state="translated">&lt;code&gt;-qn&lt;/code&gt; флаг может быть полезно при работе с большим &lt;code&gt;-A&lt;/code&gt; значением (таким образом , что ГК является нечастым), и большим &lt;code&gt;-N&lt;/code&gt; значением (таким образом , чтобы использование hyperthreaded ядер, например). Например, на 24-ядерной машине с 2 гиперпотоками на ядро ​​мы можем использовать &lt;code&gt;-N48 -qn24 -A128m&lt;/code&gt; , чтобы указать, что мутатор должен использовать гиперпотоки, а сборщик мусора должен использовать только реальные ядра. Обратите внимание, что эта конфигурация будет использовать 6 ГБ для области распределения.</target>
        </trans-unit>
        <trans-unit id="b8f8cb8014da701a79e6b46cb3e225b86d226612" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; is meant literally &amp;ndash; you should write two dots in your file. Note that the &lt;code&gt;where&lt;/code&gt; clause is still necessary to distinguish closed families from open ones. If you give any equations of a closed family, you must give all of them, in the same order as they appear in the accompanying Haskell file.</source>
          <target state="translated">Символ &lt;code&gt;..&lt;/code&gt; означает буквально - вы должны написать две точки в вашем файле. Обратите внимание, что предложение &lt;code&gt;where&lt;/code&gt; по-прежнему необходимо, чтобы отличать закрытые семейства от открытых. Если вы приводите какие-либо уравнения замкнутого семейства, вы должны указывать их все в том же порядке, в каком они указаны в прилагаемом файле Haskell.</target>
        </trans-unit>
        <trans-unit id="83164f5917a7372adba9f0624f17681c738f05e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; is meant literally &amp;ndash; you should write two dots in your file. The &lt;code&gt;where&lt;/code&gt; clause distinguishes closed families from open ones.</source>
          <target state="translated">Символ &lt;code&gt;..&lt;/code&gt; означает буквально - вы должны написать две точки в вашем файле. Предложение &lt;code&gt;where&lt;/code&gt; отличает закрытые семейства от открытых.</target>
        </trans-unit>
        <trans-unit id="dcb0143d4440c731a3c677d373f63d932883b86d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.hp&lt;/code&gt; file is generated incrementally as your program runs. In principle, running &lt;strong&gt;hp2ps&lt;/strong&gt; on the incomplete file should produce a snapshot of your program&amp;rsquo;s heap usage. However, the last sample in the file may be incomplete, causing &lt;strong&gt;hp2ps&lt;/strong&gt; to fail. If you are using a machine with UNIX utilities installed, it&amp;rsquo;s not too hard to work around this problem (though the resulting command line looks rather Byzantine):</source>
          <target state="translated">&lt;code&gt;.hp&lt;/code&gt; файл создается постепенно , как ваши прогонов программы. В принципе, запуск &lt;strong&gt;hp2ps&lt;/strong&gt; для неполного файла должен создать моментальный снимок использования кучи вашей программы. Однако последний образец в файле может быть неполным, что &lt;strong&gt;приведет&lt;/strong&gt; к сбою &lt;strong&gt;hp2ps&lt;/strong&gt; . Если вы используете компьютер с установленными утилитами UNIX, эту проблему не так сложно решить (хотя итоговая командная строка выглядит скорее византийской):</target>
        </trans-unit>
        <trans-unit id="cc7ae67c0b8544a12cdcfe050a8d2d65b4d2d666" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:loc-at&lt;/code&gt; command requires &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt;&lt;code&gt;:set +c&lt;/code&gt;&lt;/a&gt; to be set.</source>
          <target state="translated">Для команды &lt;code&gt;:loc-at&lt;/code&gt; требуется &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt; &lt;code&gt;:set +c&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="868acbe7a67a816021798517632096beabaa53fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; методах &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="245cbed390fbb3e5caa7e31d436f7995b13c904c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; экземпляры для &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; тактики включена , потому что они являются действительными. Однако во многих случаях они неэффективны, и их обычно следует избегать. Экземпляры для тактики &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; не должны создавать серьезных проблем с эффективностью.</target>
        </trans-unit>
        <trans-unit id="642ea10a7ef999e759dd2a8003076f1bb542bca1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; экземпляры для &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; тактики включена , потому что они являются действительными. Однако во многих случаях они неэффективны, и их обычно следует избегать. Экземпляры для тактики &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; не должны создавать серьезных проблем с эффективностью.</target>
        </trans-unit>
        <trans-unit id="a07f81de1f86161a74a26e3f56178d074bbb9cb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; экземпляры для &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; тактики включена , потому что они являются действительными. Однако во многих случаях они неэффективны, и их обычно следует избегать. Экземпляры для тактики &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; не должны создавать серьезных проблем с эффективностью.</target>
        </trans-unit>
        <trans-unit id="2d902fab64461e51ee2d74548c6c487fbabdaebf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; экземпляры для &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; тактики включена , потому что они являются действительными. Однако во многих случаях они неэффективны, и их обычно следует избегать. Экземпляры для тактики &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; не должны создавать серьезных проблем с эффективностью.</target>
        </trans-unit>
        <trans-unit id="3c17f4dbd13e6f82990bc913e1553422faf7c0d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function ignores the environment, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; passes the inherited environment to both subcomputations.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; игнорирует среду, а &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; передает унаследованную среду обоим подвычислениям.</target>
        </trans-unit>
        <trans-unit id="51a96013d171e823610e883b0dcca6ee8756149e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function leaves the state unchanged, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; uses the final state of the first computation as the initial state of the second.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; оставляет состояние неизменным, а &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; использует конечное состояние первого вычисления как начальное состояние второго.</target>
        </trans-unit>
        <trans-unit id="d443b950974bb112ab951f3d2eeff5624ca7c870" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; производит &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; , а &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; объединяет выходные данные подвычислений с &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; mappend .</target>
        </trans-unit>
        <trans-unit id="a5978bf75b4f58ddc37c3dcfcb955a35e4410f24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; производит &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; , а &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; объединяет выходные данные подвычислений с &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; mappend .</target>
        </trans-unit>
        <trans-unit id="eefac33165054643d0f820e7473410a1e3ca417e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; возвращает нормальное значение, а &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; завершает работу при первом исключении. Для варианта, который продолжается после ошибки и собирает все ошибки, см. &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="197b7d8676ceb906c4004a1522862a02b89f5e72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; возвращает нормальное значение, а &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; завершает работу при первом исключении. Для варианта, который продолжается после ошибки и собирает все ошибки, см. &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e2a2bef52e7aaec2926a366a49ef4ff7f5dc015" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces that value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting if either computation does.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; дает вычисление, которое производит это значение, в то время как &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; последовательно выполняет два подвычисления, завершаясь, если выполняется какое-либо из вычислений.</target>
        </trans-unit>
        <trans-unit id="a772099ec423a1c20cd2f57c2352719bbfc68ad0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces the given value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting on the first exception.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; дает вычисление, которое дает заданное значение, а &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; последовательно выполняет два подвычисления, выходя из первого исключения.</target>
        </trans-unit>
        <trans-unit id="0c02e3b1c74fff6be8fd138b7b81638f5520f137" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a successful computation, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, failing on the first error.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; дает успешное вычисление, в то время как &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; последовательно выполняет два подсчета, завершаясь неудачей при первой ошибке.</target>
        </trans-unit>
        <trans-unit id="591c2084b78ba16832d7264b63d440c1c164a1fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt;, along with &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; методы &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt; , наряду с &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fd5d1becb199aae7fcf8f5cddb1b46323f94938" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; экземпляр для &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; используется для тех же целей, что и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; , например.</target>
        </trans-unit>
        <trans-unit id="b9caf64cdefb09c64255eb7f22c88a16a5fc1ad7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; экземпляр для &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; используется для тех же целей, что и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; , например.</target>
        </trans-unit>
        <trans-unit id="d633291de962b83e64a4f5366d8780f130fabd29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; type supports about 16 decimal places of accuracy. For 94.2% of numbers, this function and &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; give identical results, but for the remaining 5.8%, this function loses precision around the 15th decimal place. For 0.001% of numbers, this function will lose precision at the 13th or 14th decimal place.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; поддерживает около 16 десятичных знаков точности. Для 94,2% чисел эта функция и &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; дают одинаковые результаты, но для остальных 5,8% эта функция теряет точность около 15-го десятичного знака. Для 0,001% чисел эта функция потеряет точность до 13-го или 14-го десятичного знака.</target>
        </trans-unit>
        <trans-unit id="d703712be7881bd93cfd2bc01dfee32118d427e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; type supports about 16 decimal places of accuracy. For 94.2% of numbers, this function and &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; give identical results, but for the remaining 5.8%, this function loses precision around the 15th decimal place. For 0.001% of numbers, this function will lose precision at the 13th or 14th decimal place.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; поддерживает около 16 десятичных знаков точности. Для 94,2% чисел эта функция и &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; дают одинаковые результаты, но для остальных 5,8% эта функция теряет точность около 15-го десятичного знака. Для 0,001% чисел эта функция потеряет точность до 13-го или 14-го десятичного знака.</target>
        </trans-unit>
        <trans-unit id="f8c0ff807ccff9eb26062cb229ca77b0ed057850" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; экземпляр для &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; используются для добавления результата нескольких анализаторов, например:</target>
        </trans-unit>
        <trans-unit id="9c784a6d7ab10d7763556a008a4766e1b2eda4a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; экземпляр для &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; используются для добавления результата нескольких анализаторов, например:</target>
        </trans-unit>
        <trans-unit id="8d81a3f4c85b4191151075e8c67e5bf6b30eb413" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt;, and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt;, then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt;.</source>
          <target state="translated">Операция &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; , который предпочитает значения из левого операнда. Если &lt;code&gt;m1&lt;/code&gt; отображает ключ &lt;code&gt;k&lt;/code&gt; в значение &lt;code&gt;a1&lt;/code&gt; , а &lt;code&gt;m2&lt;/code&gt; отображает тот же ключ в другое значение &lt;code&gt;a2&lt;/code&gt; , то их объединение &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; отображает &lt;code&gt;k&lt;/code&gt; в &lt;code&gt;a1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="886078b2aaab08d590ba45d81857ef8f5563600b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt;, and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt;, then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt;.</source>
          <target state="translated">Операция &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; , который предпочитает значения из левого операнда. Если &lt;code&gt;m1&lt;/code&gt; отображает ключ &lt;code&gt;k&lt;/code&gt; в значение &lt;code&gt;a1&lt;/code&gt; , а &lt;code&gt;m2&lt;/code&gt; отображает тот же ключ в другое значение &lt;code&gt;a2&lt;/code&gt; , то их объединение &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; отображает &lt;code&gt;k&lt;/code&gt; в &lt;code&gt;a1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="519517bb832149c99d7d65f9e38c30f74e55d8c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; argument names the executable, and is interpreted according to the platform's standard policy for searching for executables. Specifically:</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; имена аргументов исполняемого файла, и интерпретируется в соответствии со стандартной политикой платформы для поиска исполняемых файлов. В частности:</target>
        </trans-unit>
        <trans-unit id="9c0ad1ae490321b15fc5c17f80550d3243babef6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dece6bc59608b974325c5124d02a6f75ef4c62d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7a9c0b4e24f513886a0fe3de6f9f53dadcdf0d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc09e39326ac463b521633cc81f1ec225a8a20d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68eed02a9714eb35cf81751d72df7caa308a61f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f2da1b81116404bb6e8b43cb3a0637a688bb46e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function ignores the environment, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; passes the inherited environment to both subcomputations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260fcde2dc8277fbba23a670e261449948424309" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function leaves the state unchanged, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; uses the final state of the first computation as the initial state of the second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6d56b3f6d2c5e6f40ede452ae79b597fe5912c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c0f713409cb9cf5a1a1a5c72fd485b5db43eb31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7de8acf7cc9bc186692daa7881912af0fc23a852" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1706a86dea612dae3883f17c7ddf1ff83583e970" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56aecaa933008307756b2efe20503802422650bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces that value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting if either computation does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cc201c4c6a6bfd3a1b5af7fbb6792cb6cd39609" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces the given value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting on the first exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d623297a7b53d6225cb0faf61fb94fa727435ae3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a successful computation, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, failing on the first error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ee7b9be2c0feeeaeb3c31adf4da82d6f854ddf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt;, along with &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e1aa3150c01618910f02e8bbc7bf355bd69cbe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is necessary for handling tuple sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b5bc40c86fffa7a6076174b1bffbac140f29df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95780e47c020eeeda31a8c201eb535a8974578f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a75b664a9646e6aa02764c34d0fe587f5a1dfbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; type supports about 16 decimal places of accuracy. For 94.2% of numbers, this function and &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; give identical results, but for the remaining 5.8%, this function loses precision around the 15th decimal place. For 0.001% of numbers, this function will lose precision at the 13th or 14th decimal place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1201c6da12de4aba1276a3d6388e0825a36aceda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; type supports about 16 decimal places of accuracy. For 94.2% of numbers, this function and &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; give identical results, but for the remaining 5.8%, this function loses precision around the 15th decimal place. For 0.001% of numbers, this function will lose precision at the 13th or 14th decimal place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2acb16e4a1657fdc3b4413dfd0838f6380ef5ab8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9de1cc1416c3082400d8b6dfbf1289ad2cbe6d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d955c1b4b45545a54049a0a44af93865745803be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt;, and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt;, then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e8a62dc2c0577ea2e4fa388d91268432827035" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt;, and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt;, then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6e7c89abb8ca4cf07ac674bde1a74e6e1be7e25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; argument names the executable, and is interpreted according to the platform's standard policy for searching for executables. Specifically:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f78ea894305fa2f92651eb848a796e984b4e4110" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d405feb3a6b9895afaa0f318b7f28398f4bd6aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f1266aae7ad8bdc0dba42358ae53d2bcc3771f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458e0e129dcbdfa5cce87aefa9e19048a965d645" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc0c4cd9b9fd204bedd14ea51fb195630c8139d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72da00b002507603215122aff2a0c788a0b577d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function ignores the environment, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; passes the inherited environment to both subcomputations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975265378d608c7754aeb46eef5e343d004094c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function leaves the state unchanged, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; uses the final state of the first computation as the initial state of the second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="046b9ec685e02d0b7255d415f7a53e51ece44c02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce59aa9aa7770be720fe2f9ab4b78c390dafeca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2094e6381df03e75161328d5b93c89ad3d9048" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc17f1fd4fad20e7ff547a572bbb918d61a43edc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9fbc9218ae7816a7764ba8f4b7ea997abf1ec4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces that value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting if either computation does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbde8b545bd4180a31e36b9eaf901736baf44dd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces the given value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting on the first exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70d2fe74f9a13fe2abf46ab4a20202c52ca11c4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a successful computation, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, failing on the first error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0392dbac15f5a29ace95ddc3854629ee10a2c673" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt;, along with &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a49a233b3aaeb66c434e12308ae79ebd04f8c90b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is necessary for handling tuple sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a31b665a96aa687aea00989af736838ac7b1ad7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba0b18140a235048175aac50f5fcbba208d418d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ca3a40e1687acc199ba4ae4156a478a2153d5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; type supports about 16 decimal places of accuracy. For 94.2% of numbers, this function and &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; give identical results, but for the remaining 5.8%, this function loses precision around the 15th decimal place. For 0.001% of numbers, this function will lose precision at the 13th or 14th decimal place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28366f4f1cc4165989efbd16469d4c39f286fe41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; type supports about 16 decimal places of accuracy. For 94.2% of numbers, this function and &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; give identical results, but for the remaining 5.8%, this function loses precision around the 15th decimal place. For 0.001% of numbers, this function will lose precision at the 13th or 14th decimal place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54880289dd15dc1c7fcd477651a6537f2d2ab48b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc53a4659b8ab96fd92904a1a6f76268c60e672b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89cddb92704acf6ee37cc5e18ac776492c7fd174" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt;, and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt;, then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece285de7b69fb6ebec656427cb5d85fead59f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt;, and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt;, then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="161eb66f14a2659bb4450195c7fef766d0c5fa15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; argument names the executable, and is interpreted according to the platform's standard policy for searching for executables. Specifically:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ec1a27d9645ead49a8fac70722d498afadafab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-applicative#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; functor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-applicative#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; функтор.</target>
        </trans-unit>
        <trans-unit id="404d7369c3ed5cd7574fad867737a14afb444a12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; class is equivalent to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;: any monad gives rise to a &lt;code&gt;&lt;a href=&quot;control-arrow#t:Kleisli&quot;&gt;Kleisli&lt;/a&gt;&lt;/code&gt; arrow, and any instance of &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; defines a monad.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; эквивалентен &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; : любая монада порождает стрелку &lt;code&gt;&lt;a href=&quot;control-arrow#t:Kleisli&quot;&gt;Kleisli&lt;/a&gt;&lt;/code&gt; , а любой экземпляр &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; определяет монаду.</target>
        </trans-unit>
        <trans-unit id="712abe7e2f78e39742519eb3d9a6b4a2f4ce365d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-arrow#v:loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; operator expresses computations in which an output value is fed back as input, although the computation occurs only once. It underlies the &lt;code&gt;rec&lt;/code&gt; value recursion construct in arrow notation. &lt;code&gt;&lt;a href=&quot;control-arrow#v:loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; should satisfy the following laws:</source>
          <target state="translated">Оператор &lt;code&gt;&lt;a href=&quot;control-arrow#v:loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; выражает вычисления, в которых выходное значение возвращается как входное, хотя вычисление происходит только один раз. Он лежит в основе конструкции рекурсии значения &lt;code&gt;rec&lt;/code&gt; в виде стрелок. &lt;code&gt;&lt;a href=&quot;control-arrow#v:loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; должна удовлетворять следующим законам:</target>
        </trans-unit>
        <trans-unit id="4d5ea08c77b20ca5949edb787e87c9bfc18d424c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-concurrent#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; action allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads (if any), and is occasionally useful when implementing concurrency abstractions.</source>
          <target state="translated">Действие &lt;code&gt;&lt;a href=&quot;control-concurrent#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; позволяет (принудительно в реализации совместной многозадачности) переключать контекст на любые другие выполняемые в данный момент потоки (если они есть) и иногда полезно при реализации абстракций параллелизма.</target>
        </trans-unit>
        <trans-unit id="2aecf2fbfb3505dad21f83e912f2781f57633420" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; classes, with some useful operations on monads.</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;control-monad#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; классы, с некоторыми полезными операциями на монады.</target>
        </trans-unit>
        <trans-unit id="e42cbe3850d6befefe426ee80a44a4c35d7e57b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; class defines the basic operations over a &lt;em&gt;monad&lt;/em&gt;, a concept from a branch of mathematics known as &lt;em&gt;category theory&lt;/em&gt;. From the perspective of a Haskell programmer, however, it is best to think of a monad as an &lt;em&gt;abstract datatype&lt;/em&gt; of actions. Haskell's &lt;code&gt;do&lt;/code&gt; expressions provide a convenient syntax for writing monadic expressions.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; определяет основные операции над &lt;em&gt;монадой&lt;/em&gt; - концепцию из раздела математики, известного как &lt;em&gt;теория категорий&lt;/em&gt; . Однако с точки зрения программиста на Haskell лучше всего рассматривать монаду как &lt;em&gt;абстрактный тип данных&lt;/em&gt; действий. Выражения &lt;code&gt;do&lt;/code&gt; в Haskell обеспечивают удобный синтаксис для написания монадических выражений.</target>
        </trans-unit>
        <trans-unit id="4fc32a4cddc34ade233961b4012b777dbb17097e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; allows us to chain together multiple actions which may fail, and fail overall if any of the individual steps failed. First we'll write a function that can either parse an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, or fail.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; экземпляр для &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; позволяет связать между собой несколькими действиями , которые могут потерпеть неудачу, и не в целом , если какие - либо из отдельных шагов , не удалось. Сначала мы напишем функцию, которая может либо разбирать &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; из &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , либо терпеть неудачу.</target>
        </trans-unit>
        <trans-unit id="841e7fb83df459d53e389056b37c0fc15cd60e41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; operations are not strict in the state. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; операции не являются строгими в государстве. Например,</target>
        </trans-unit>
        <trans-unit id="8492deac48ede758cea8f52bc65fb3e2f9ba2826" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; operations are strict in the state (though not in values stored in the state). For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; операции строго в состоянии (хотя и не в значениях , хранящихся в состоянии). Например,</target>
        </trans-unit>
        <trans-unit id="27d5a6c8ea1acb5010f2c9679c264fd5c989ebdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt; function is analogous to &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, except that its result is encapsulated in a monad. Note that &lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt; works from left-to-right over the list arguments. This could be an issue where &lt;code&gt;(&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; and the `folded function' are not commutative.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt; аналогична функции &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; , за исключением того, что ее результат инкапсулируется в монаду. Обратите внимание, что &lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt; работает с аргументами списка слева направо. Это может быть проблемой, когда &lt;code&gt;(&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; и `свернутая функция 'не коммутативны.</target>
        </trans-unit>
        <trans-unit id="9ee235b387a6a14db33bdf2a6b2158fa66bc38c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;control-monad#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; - это обычный оператор соединения монад. Он используется для удаления одного уровня монадической структуры, проецируя связанный аргумент на внешний уровень.</target>
        </trans-unit>
        <trans-unit id="b7e9731c305b0f549055c674d9ac68832bd130e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#v:mapAndUnzipM&quot;&gt;mapAndUnzipM&lt;/a&gt;&lt;/code&gt; function maps its first argument over a list, returning the result as a pair of lists. This function is mainly used with complicated data structures or a state monad.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;control-monad#v:mapAndUnzipM&quot;&gt;mapAndUnzipM&lt;/a&gt;&lt;/code&gt; отображает свой первый аргумент по списку, возвращая результат в виде пары списков. Эта функция в основном используется со сложными структурами данных или монадой состояния.</target>
        </trans-unit>
        <trans-unit id="adfaa2036ac4e96d2cf9b7c53ce9041b46c41b72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#v:zipWithM&quot;&gt;zipWithM&lt;/a&gt;&lt;/code&gt; function generalizes &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; to arbitrary applicative functors.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;control-monad#v:zipWithM&quot;&gt;zipWithM&lt;/a&gt;&lt;/code&gt; обобщает &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; на произвольные аппликативные функторы.</target>
        </trans-unit>
        <trans-unit id="9e4c77f8896de4159de2b19d91214d29c830fc9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; class defines the basic operations over a &lt;em&gt;monad&lt;/em&gt;, a concept from a branch of mathematics known as &lt;em&gt;category theory&lt;/em&gt;. From the perspective of a Haskell programmer, however, it is best to think of a monad as an &lt;em&gt;abstract datatype&lt;/em&gt; of actions. Haskell's &lt;code&gt;do&lt;/code&gt; expressions provide a convenient syntax for writing monadic expressions.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; определяет основные операции над &lt;em&gt;монадой&lt;/em&gt; - концепцию из раздела математики, известного как &lt;em&gt;теория категорий&lt;/em&gt; . Однако с точки зрения программиста на Haskell лучше всего рассматривать монаду как &lt;em&gt;абстрактный тип данных&lt;/em&gt; действий. Выражения &lt;code&gt;do&lt;/code&gt; в Haskell обеспечивают удобный синтаксис для написания монадических выражений.</target>
        </trans-unit>
        <trans-unit id="680d557813d267dc8f3ee06e2da84590ab3ebc77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad-reader#t:Reader&quot;&gt;Reader&lt;/a&gt;&lt;/code&gt; monad (also called the Environment monad). Represents a computation, which can read values from a shared environment, pass values from function to function, and execute sub-computations in a modified environment. Using &lt;code&gt;&lt;a href=&quot;control-monad-reader#t:Reader&quot;&gt;Reader&lt;/a&gt;&lt;/code&gt; monad for such computations is often clearer and easier than using the &lt;code&gt;&lt;a href=&quot;control-monad-state#v:State&quot;&gt;State&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-reader#t:Reader&quot;&gt;Reader&lt;/a&gt;&lt;/code&gt; монада (также называется монадой Environment). Представляет вычисление, которое может считывать значения из общей среды, передавать значения от функции к функции и выполнять подвычисления в измененной среде. Использование монады &lt;code&gt;&lt;a href=&quot;control-monad-reader#t:Reader&quot;&gt;Reader&lt;/a&gt;&lt;/code&gt; для таких вычислений часто проще и понятнее, чем использование монады &lt;code&gt;&lt;a href=&quot;control-monad-state#v:State&quot;&gt;State&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81283641c0b20f0b2748a09d602fde66cbffe272" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:catchE&quot;&gt;catchE&lt;/a&gt;&lt;/code&gt; operation has a more complex type, so we need to use the special-purpose lifting function &lt;code&gt;liftCatch&lt;/code&gt; provided by most monad transformers. Here we use the &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; version followed by the &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; version:</source>
          <target state="translated">Операция &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:catchE&quot;&gt;catchE&lt;/a&gt;&lt;/code&gt; имеет более сложный тип, поэтому нам нужно использовать специальную подъемную функцию &lt;code&gt;liftCatch&lt;/code&gt; , предоставляемую большинством монадных трансформаторов. Здесь мы используем версию &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; , за которой &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; версия StateT :</target>
        </trans-unit>
        <trans-unit id="545d7b475a316b28ef1da840a21adda70380c2c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad-trans-maybe#t:MaybeT&quot;&gt;MaybeT&lt;/a&gt;&lt;/code&gt; monad transformer extends a monad with the ability to exit the computation without returning a value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-maybe#t:MaybeT&quot;&gt;MaybeT&lt;/a&gt;&lt;/code&gt; монада трансформатор расширяет монаду с возможностью выхода вычисления без возвращения значения.</target>
        </trans-unit>
        <trans-unit id="a2118806ea587f5911ee90a60aa429d89bdcab96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-array#v:accumArray&quot;&gt;accumArray&lt;/a&gt;&lt;/code&gt; function deals with repeated indices in the association list using an &lt;em&gt;accumulating function&lt;/em&gt; which combines the values of associations with the same index.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-array#v:accumArray&quot;&gt;accumArray&lt;/a&gt;&lt;/code&gt; обрабатывает повторяющиеся индексы в списке ассоциаций, используя функцию &lt;em&gt;накопления,&lt;/em&gt; которая объединяет значения ассоциаций с одним и тем же индексом.</target>
        </trans-unit>
        <trans-unit id="0179248504c3fa08ab2a958c9b5147b68d6c33e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifind&quot;&gt;bifind&lt;/a&gt;&lt;/code&gt; function takes a predicate and a structure and returns the leftmost element of the structure matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifind&quot;&gt;bifind&lt;/a&gt;&lt;/code&gt; принимает предикат и структуру и возвращает крайний левый элемент структуры, соответствующий предикату, или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если такого элемента нет.</target>
        </trans-unit>
        <trans-unit id="87802a775d4245309a8eade317e7d18abe967e8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biproduct&quot;&gt;biproduct&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biproduct&quot;&gt;biproduct&lt;/a&gt;&lt;/code&gt; вычисляет произведение номеров конструкции.</target>
        </trans-unit>
        <trans-unit id="e6a2674d1a15617e9adc9ceb2614394b34abbb43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bisum&quot;&gt;bisum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bisum&quot;&gt;bisum&lt;/a&gt;&lt;/code&gt; вычисляет сумму номеров структуры.</target>
        </trans-unit>
        <trans-unit id="dc2ecd95ed8a8f0c6f2cf1d560aaa6d8aea4ed41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class provides &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt;, methods to encode and decode a Haskell value to a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It mirrors the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; classes for textual representation of Haskell types, and is suitable for serialising Haskell values to disk, over the network.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; предоставляет методы &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; для кодирования и декодирования значения Haskell в ленивую &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . Он отражает классы &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; для текстового представления типов Haskell и подходит для сериализации значений Haskell на диск по сети.</target>
        </trans-unit>
        <trans-unit id="ef67bb75d4cd691a3105fe1fbf4dfcaa9ea238dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class provides &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt;, methods to encode and decode a Haskell value to a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It mirrors the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; classes for textual representation of Haskell types, and is suitable for serialising Haskell values to disk, over the network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="359a7c862ec288bde5c781831027b2789d88d4e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class provides &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt;, methods to encode and decode a Haskell value to a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It mirrors the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; classes for textual representation of Haskell types, and is suitable for serialising Haskell values to disk, over the network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc3c4e321db0da5c60f5e57209330b5697cd8103" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; monad. A monad for efficiently building structures from encoded lazy ByteStrings.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; монады. Монада для эффективного построения структур из закодированных ленивых байтовых строк.</target>
        </trans-unit>
        <trans-unit id="4d3613093bfbb78cd7a2a16f8922cee7681b2bed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapAccumL&quot;&gt;bimapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt;; it traverses a structure from left to right, threading a state of type &lt;code&gt;a&lt;/code&gt; and using the given actions to compute new elements for the structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapAccumL&quot;&gt;bimapAccumL&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; ; он проходит структуру слева направо, распределяя состояние типа &lt;code&gt;a&lt;/code&gt; и используя заданные действия для вычисления новых элементов для структуры.</target>
        </trans-unit>
        <trans-unit id="9a87ec27622ff13e398e24344f3a64ac0e1395d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapAccumR&quot;&gt;bimapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt;; it traverses a structure from right to left, threading a state of type &lt;code&gt;a&lt;/code&gt; and using the given actions to compute new elements for the structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapAccumR&quot;&gt;bimapAccumR&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; ; он проходит структуру справа налево, распределяя состояние типа &lt;code&gt;a&lt;/code&gt; и используя заданные действия для вычисления новых элементов для структуры.</target>
        </trans-unit>
        <trans-unit id="8fde160a7fc5705892a4e1ea87c284f4780166ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapAccumR&quot;&gt;bimapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt;; it traverses a structure from right to left, threading a state of type &lt;code&gt;a&lt;/code&gt; and using the given actions to compute new elements for the structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48db54c46d3aa624ae5d297b1ebeb1fa3977d71b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; class defines bitwise operations over integral types.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; определяет побитовые операции над целыми типами.</target>
        </trans-unit>
        <trans-unit id="0ad9b411edb3c5e8c1b9471ab75ecc126a6721eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bits#t:FiniteBits&quot;&gt;FiniteBits&lt;/a&gt;&lt;/code&gt; class denotes types with a finite, fixed number of bits.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;data-bits#t:FiniteBits&quot;&gt;FiniteBits&lt;/a&gt;&lt;/code&gt; обозначает типы с конечным фиксированным числом битов.</target>
        </trans-unit>
        <trans-unit id="20817eeecc682279fcdb27f8168c9dc5e0bd900f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; type and related functions.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; и связанные с ним функции.</target>
        </trans-unit>
        <trans-unit id="0ac698df5fa5f3ca66ad118ffad20bf3b266295d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and returns the index of the first element in the ByteString satisfying the predicate.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; принимает предикат и &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; и возвращает индекс первого элемента в ByteString, удовлетворяющего предикату.</target>
        </trans-unit>
        <trans-unit id="a88a45076c0dfb13c7596a49a77c0da26a873595" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-bytestring#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; расширяет &lt;code&gt;&lt;a href=&quot;data-bytestring#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; , возвращая индексы всех элементов, удовлетворяющих предикату, в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="d89ae35b30db39f44c3fe60d6b3d04049f068a4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a ByteString and returns a list of ByteStrings such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; функция принимает байтовую строку и возвращает список байтовых строк таким образом, что конкатенация результата равна аргументу. Более того, каждый подсписок в результате содержит только равные элементы. Например,</target>
        </trans-unit>
        <trans-unit id="4ee4acaf8e9d95a9f5ef4c31e80b5ce11a67d031" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-bytestring#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия &lt;code&gt;&lt;a href=&quot;data-bytestring#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e617691064b9b4b87d847163f54ff7d363170a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-bytestring#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bytestring#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу ByteString, передавая параметр накопления слева направо и возвращая окончательное значение этого аккумулятора вместе с новым списком.</target>
        </trans-unit>
        <trans-unit id="2ea34718a3c5162fce3eb666e6adf60a8a7d062c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new ByteString.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-bytestring#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bytestring#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу ByteString, передавая параметр накопления справа налево и возвращая окончательное значение этого аккумулятора вместе с новой ByteString.</target>
        </trans-unit>
        <trans-unit id="fd51442d30fe2b55d7fe46723f9d58913d2aa41f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; argument.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; перемещает строки и столбцы своего аргумента &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1aa92f924157b1d391e0c5573f2c097c3b5ec16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; itself is an IO action: you supply it with a buffer (as a pointer and length) and it will write data into the buffer. It returns a number indicating how many bytes were actually written (which can be &lt;code&gt;0&lt;/code&gt;). It also returns a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; which describes what comes next.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; само действие IO: вы поставляете его с буфером ( в качестве указателя и длины) , и она будет записывать данные в буфер. Он возвращает число, показывающее, сколько байтов было фактически записано (может быть &lt;code&gt;0&lt;/code&gt; ). Он также возвращает &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; , который описывает, что будет дальше.</target>
        </trans-unit>
        <trans-unit id="ea2d270840cc8c9daa194a459da571d928cff274" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; denoting a zero-length sequence of bytes. This function is only exported for use in rewriting rules. Use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; обозначающей последовательности нулевой длины в байтах. Эта функция экспортируется только для использования в правилах перезаписи. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; противном случае используйте mempty .</target>
        </trans-unit>
        <trans-unit id="77e9d20b09fe3cb5d3e34c82f2d34d8c4d1fbd52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; denoting a zero-length sequence of bytes. This function is only exported for use in rewriting rules. Use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93dd19fcd92601ecabd679db17cd19a75a81c1a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; denoting a zero-length sequence of bytes. This function is only exported for use in rewriting rules. Use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02c6b6ed74cc07d8a8ef6b6a51e39f07fbdde207" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; that always results in the zero-length sequence.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; , что всегда приводит к последовательности нулевой длины.</target>
        </trans-unit>
        <trans-unit id="386c97767c9a0e690099a424827f366fbf618180" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; that always results in the zero-length sequence.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; , что всегда приводит к последовательности нулевой длины.</target>
        </trans-unit>
        <trans-unit id="e4a29465a0ac4c8f6fffb025991665c12b63f1c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;(&amp;gt;*&amp;lt;)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--36--60-&quot;&gt;(&amp;gt;$&amp;lt;)&lt;/a&gt;&lt;/code&gt; pairing and mapping operators can be used with &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Операторы сопряжения и сопоставления &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;(&amp;gt;*&amp;lt;)&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--36--60-&quot;&gt;(&amp;gt;$&amp;lt;)&lt;/a&gt;&lt;/code&gt; могут использоваться с &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdd16a4104dcd27da4c5d7c015155569458cf5d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; that always results in the zero-length sequence.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; , что всегда приводит к последовательности нулевой длины.</target>
        </trans-unit>
        <trans-unit id="f5ca076d9cd96bbcd373168527623c2c7280cd67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; that always results in the zero-length sequence.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; , что всегда приводит к последовательности нулевой длины.</target>
        </trans-unit>
        <trans-unit id="34fcdbaf6996fe7f65d389f0c0fdfc1f2f89c754" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and returns the index of the first element in the ByteString satisfying the predicate.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; принимает предикат и &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; и возвращает индекс первого элемента в ByteString, удовлетворяющего предикату.</target>
        </trans-unit>
        <trans-unit id="2808d77c990696b44b127af7d539f85921526158" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; расширяет &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; , возвращая индексы всех элементов, удовлетворяющих предикату, в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="3b2f3c13460a923ec70902424b286392ebcf4ee2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a ByteString and returns a list of ByteStrings such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; функция принимает байтовую строку и возвращает список байтовых строк таким образом, что конкатенация результата равна аргументу. Более того, каждый подсписок в результате содержит только равные элементы. Например,</target>
        </trans-unit>
        <trans-unit id="011ecd68a05489bd1b20ac9d77a9cea0655b8352" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72cc5f08d56e30d247f072343ee4d0e1aa87e68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу ByteString, передавая параметр накопления слева направо и возвращая окончательное значение этого аккумулятора вместе с новым списком.</target>
        </trans-unit>
        <trans-unit id="c9e160c9ad7473babd1af40af00cbf0162bdef7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new ByteString.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу ByteString, передавая параметр накопления справа налево и возвращая окончательное значение этого аккумулятора вместе с новой ByteString.</target>
        </trans-unit>
        <trans-unit id="83f55a6f846dc49344b68895528bedee225f9b95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; argument.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; перемещает строки и столбцы своего аргумента &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfef4b206c70c32eec3092e778efb683d81d66b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unwords&quot;&gt;unwords&lt;/a&gt;&lt;/code&gt; function is analogous to the &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unlines&quot;&gt;unlines&lt;/a&gt;&lt;/code&gt; function, on words.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unwords&quot;&gt;unwords&lt;/a&gt;&lt;/code&gt; аналогична функции &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unlines&quot;&gt;unlines&lt;/a&gt;&lt;/code&gt; для слов.</target>
        </trans-unit>
        <trans-unit id="1d758a0f563300419f025322f07bdf29baaf99ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and returns the index of the first element in the ByteString satisfying the predicate.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; принимает предикат и &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; и возвращает индекс первого элемента в ByteString, удовлетворяющего предикату.</target>
        </trans-unit>
        <trans-unit id="014ce90607c5489f1d18b6f1c446b9bba5ae0212" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndexEnd&quot;&gt;findIndexEnd&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and returns the index of the last element in the ByteString satisfying the predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc3fedbb007a3889a87db49cdfcce211f6dec12f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; расширяет &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; , возвращая индексы всех элементов, удовлетворяющих предикату, в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="11978bfbf1d81f38393dc6440b94501585d47dc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a ByteString and returns a list of ByteStrings such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; функция принимает байтовую строку и возвращает список байтовых строк таким образом, что конкатенация результата равна аргументу. Более того, каждый подсписок в результате содержит только равные элементы. Например,</target>
        </trans-unit>
        <trans-unit id="063223aebad86f89a99e6e89e5807a67aa057281" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de39eec2cad2fac68f9d8a352ebb2380e3936c42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and `intersperses' that byte between the elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It is analogous to the intersperse function on Lists.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; принимает &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; и ByteString и &quot; &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; &quot; этот байт между элементами &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . Это аналогично функции вкрапления списков.</target>
        </trans-unit>
        <trans-unit id="6625add11fa1e445312d92a0c6788839896adacf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and `intersperses' that byte between the elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It is analogous to the intersperse function on Lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca33e217cddf98a06cc4dd73bac5dae5740289e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and `intersperses' that byte between the elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It is analogous to the intersperse function on Lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b89a766d13b74128a8333abb002900f94b6b437" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new ByteString.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу ByteString, передавая параметр накопления слева направо и возвращая окончательное значение этого аккумулятора вместе с новой ByteString.</target>
        </trans-unit>
        <trans-unit id="c773ca1b34d782e061cf0d6996806a66376f97f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new ByteString.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу ByteString, передавая параметр накопления справа налево и возвращая окончательное значение этого аккумулятора вместе с новой ByteString.</target>
        </trans-unit>
        <trans-unit id="612dd81abb27b510de3a02ab1ed120cd76a9a6a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; argument.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; перемещает строки и столбцы своего аргумента &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b02cc89d4861343dc4906429c0519e1e575b9b01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and returns the index of the first element in the ByteString satisfying the predicate.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; принимает предикат и &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; и возвращает индекс первого элемента в ByteString, удовлетворяющего предикату.</target>
        </trans-unit>
        <trans-unit id="89e6612f1c49c256bb1909e6d5ea7235d2f56477" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; расширяет &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; , возвращая индексы всех элементов, удовлетворяющих предикату, в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="0683ca6fb89db86c531b2e317168c1b2a68d2259" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a ByteString and returns a list of ByteStrings such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; функция принимает байтовую строку и возвращает список байтовых строк таким образом, что конкатенация результата равна аргументу. Более того, каждый подсписок в результате содержит только равные элементы. Например,</target>
        </trans-unit>
        <trans-unit id="7f63028123ecc27ee69e82bdcdeb63da564a6078" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9318a5a01ea45d555a0875fa484d9ff476c3e0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new ByteString.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу ByteString, передавая параметр накопления слева направо и возвращая окончательное значение этого аккумулятора вместе с новой ByteString.</target>
        </trans-unit>
        <trans-unit id="e142671c8576be4ab4d32dbd1993a19bfee360ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new ByteString.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу ByteString, передавая параметр накопления справа налево и возвращая окончательное значение этого аккумулятора вместе с новой ByteString.</target>
        </trans-unit>
        <trans-unit id="21e9a6162eb970619d9172486dd0b5106006c4bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; argument.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; перемещает строки и столбцы своего аргумента &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="981ef85d841145750af6b8e72525229c75f0ae12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unwords&quot;&gt;unwords&lt;/a&gt;&lt;/code&gt; function is analogous to the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unlines&quot;&gt;unlines&lt;/a&gt;&lt;/code&gt; function, on words.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unwords&quot;&gt;unwords&lt;/a&gt;&lt;/code&gt; аналогична функции &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unlines&quot;&gt;unlines&lt;/a&gt;&lt;/code&gt; для слов.</target>
        </trans-unit>
        <trans-unit id="70b1e8ad66966b19620f6916e96d89ef82853d69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; class comprehends a fundamental primitive &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; for folding over constructor applications, say terms. This primitive can be instantiated in several ways to map over the immediate subterms of a term; see the &lt;code&gt;gmap&lt;/code&gt; combinators later in this class. Indeed, a generic programmer does not necessarily need to use the ingenious gfoldl primitive but rather the intuitive &lt;code&gt;gmap&lt;/code&gt; combinators. The &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; primitive is completed by means to query top-level constructors, to turn constructor representations into proper terms, and to list all possible datatype constructors. This completion allows us to serve generic programming scenarios like read, show, equality, term generation.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; охватывает фундаментальный примитив &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; для свертывания приложений-конструкторов, скажем, терминов. Этот примитив может быть создан несколькими способами, чтобы отображать непосредственные подтермы термина; см. комбинаторы &lt;code&gt;gmap&lt;/code&gt; далее в этом классе. В самом деле, универсальный программист не обязательно должен использовать гениальный примитив gfoldl, а скорее интуитивные комбинаторы &lt;code&gt;gmap&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; примитивный завершаются посредством запроса к конструкторам верхнего уровня, чтобы превратить конструктор представление в соответствующие сроки, и перечислить все возможные конструктор типов данных. Это завершение позволяет нам обслуживать общие сценарии программирования, такие как чтение, показ, равенство, генерация терминов.</target>
        </trans-unit>
        <trans-unit id="2a4e313748880e797d1bcb646d76cb8547d19d57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type is sometimes used to represent a value which is either correct or an error; by convention, the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor is used to hold an error value and the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor is used to hold a correct value (mnemonic: &quot;right&quot; also means &quot;correct&quot;).</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; иногда используется для представления значения, которое является правильным или ошибочным; по соглашению конструктор &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; используется для хранения значения ошибки, а конструктор &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; используется для хранения правильного значения (мнемоника: &amp;laquo;right&amp;raquo; также означает &amp;laquo;правильный&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="f0e4baff05206c672300bb2b38395a9530159b34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type represents values with two possibilities: a value of type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; представляет значения с двумя возможностями: значение типа &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; равно &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c8bc066a25dbdc9345dc643976410a0121b2ada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; class defines equality (&lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) and inequality (&lt;code&gt;&lt;a href=&quot;data-eq#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt;). All the basic datatypes exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; are instances of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; may be derived for any datatype whose constituents are also instances of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; определяет равенство ( &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; ) и неравенство ( &lt;code&gt;&lt;a href=&quot;data-eq#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt; ). Все основные типы данных, экспортируемые &lt;a href=&quot;prelude&quot;&gt;Prelude,&lt;/a&gt; являются экземплярами &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; может быть получен для любого типа данных, составные части которого также являются экземплярами &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69af3900bc4a32d170db2d927f8de7596335e0e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances traverse the real part first.</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; экземплярах пересекают вещественную часть первыми.</target>
        </trans-unit>
        <trans-unit id="5eff372cb874b6edeef6ee4a0a04355990bb5ac2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a structure and returns the leftmost element of the structure matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-foldable#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; принимает предикат и структуру и возвращает самый левый элемент структуры, соответствующий предикату, или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если такого элемента нет.</target>
        </trans-unit>
        <trans-unit id="1b7c06198a94e0e0bdce1efceb1fa1157608eeea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;` method is a special case of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;`, in which the initial accumulator is &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; and the operator is &lt;code&gt;mappend . f&lt;/code&gt;, where &lt;code&gt;f&lt;/code&gt; maps each input element into the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; in question. Therefore, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;` is an appropriate choice under essentially the same conditions as &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;`, and its implementation for a given &lt;code&gt;Foldable&lt;/code&gt; structure should also be a strict left-associative reduction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40cadb370f92894eea0177fbad74525b49368dd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; form works verbatim if the type of &lt;strong&gt;&lt;code&gt;mvalue&lt;/code&gt;&lt;/strong&gt; is later refactored from &lt;strong&gt;&lt;code&gt;Maybe a&lt;/code&gt;&lt;/strong&gt; to &lt;strong&gt;&lt;code&gt;Either e a&lt;/code&gt;&lt;/strong&gt; (assuming it remains OK to silently do nothing in the error case).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168798718c8d67f564d095b7f2c27b1f23db19a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-foldable#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; вычисляет произведение номеров конструкции.</target>
        </trans-unit>
        <trans-unit id="7cca4119f8a53ddfe67d87125c91cc29b78f8689" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; функция вычисляет сумму чисел строения.</target>
        </trans-unit>
        <trans-unit id="4e16e1b415ac8aa1d79a0e8941de4b3fd089e939" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; base class means that the container cannot impose any constraints on the element type, so containers that require elements to be comparable, or hashable, etc., cannot be instances of the &lt;code&gt;Traversable&lt;/code&gt; class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9699a12c867a28d982d3293073c01ca1c9af29d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from our &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance will ignore &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values, but will apply the supplied function to values contained in a &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; из нашего &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; экземпляра будет игнорировать &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; значения, но будет применять указанную функцию к значениям , содержащимся в &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b77100b25e8a5a0820122925237280bb25f1620c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; function is also available as the infix operator &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; также доступна как инфиксный оператор &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="75d054c2f2cab23d848c32214fa7c03446c931b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; functor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; функтор.</target>
        </trans-unit>
        <trans-unit id="91affd44c758dc656c5a465b34202e2474e6eec1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-graph#t:Graph&quot;&gt;Graph&lt;/a&gt;&lt;/code&gt; type is an adjacency list representation of a finite, directed graph with vertices of type &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-graph#t:Graph&quot;&gt;Graph&lt;/a&gt;&lt;/code&gt; - это представление списка смежности конечного ориентированного графа с вершинами типа &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da965f8602a83550c13d9322bdab8f201adad863" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; type represents a &lt;a href=&quot;https://en.wikipedia.org/wiki/Strongly_connected_component&quot;&gt;strongly-connected component&lt;/a&gt; of a graph.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; представляет собой &lt;a href=&quot;https://en.wikipedia.org/wiki/Strongly_connected_component&quot;&gt;сильно связанный компонент&lt;/a&gt; графа.</target>
        </trans-unit>
        <trans-unit id="b13b673bb0340c3f60ad133cedd86aba2eebb7ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; argument specifies a &lt;em&gt;capability number&lt;/em&gt; (see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;). Typically capabilities correspond to physical processors, but the exact behaviour is implementation-dependent. The value passed to &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is interpreted modulo the total number of capabilities as returned by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; аргумент указывает &lt;em&gt;номер возможностей&lt;/em&gt; (см &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; ). Обычно возможности соответствуют физическим процессорам, но точное поведение зависит от реализации. Значение, переданное в &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; , интерпретируется по модулю общего количества возможностей, возвращаемых &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f78d4fb8fef90bc420e0f272097151354016eb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; argument specifies a &lt;em&gt;capability number&lt;/em&gt; (see &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;). Typically capabilities correspond to physical processors, but the exact behaviour is implementation-dependent. The value passed to &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is interpreted modulo the total number of capabilities as returned by &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; аргумент указывает &lt;em&gt;номер возможностей&lt;/em&gt; (см &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; ). Обычно возможности соответствуют физическим процессорам, но точное поведение зависит от реализации. Значение, переданное в &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; , интерпретируется по модулю общего количества возможностей, возвращаемых &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="990e9e27ae850a84a5975a64be27bfdd1b9f5808" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; argument specifies a &lt;em&gt;capability number&lt;/em&gt; (see &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;). Typically capabilities correspond to physical processors, but the exact behaviour is implementation-dependent. The value passed to &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is interpreted modulo the total number of capabilities as returned by &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; аргумент указывает &lt;em&gt;номер возможностей&lt;/em&gt; (см &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; ). Обычно возможности соответствуют физическим процессорам, но точное поведение зависит от реализации. Значение, переданное в &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; , интерпретируется по модулю общего количества возможностей, возвращаемых &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26c55fb3d34eb375b02ebba32fb7b2dd27c91fb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from keys of type &lt;code&gt;Int&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; представляет собой конечную карту (иногда называемую словарем) от ключей типа &lt;code&gt;Int&lt;/code&gt; до значений типа &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9babf39e61d88f08afacef329c45b58b748886e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-strict&quot;&gt;Data.Map.Merge.Strict&lt;/a&gt; then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then they will not.</source>
          <target state="translated">Функции &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; используются модулями lazy и strict. Только выбор тактики слияния определяет строгость. Если вы используете &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; из &lt;a href=&quot;data-map-merge-strict&quot;&gt;Data.Map.Merge.Strict,&lt;/a&gt; тогда результаты будут принудительно перед вставкой . Если вы используете &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; из этого модуля, они не будут.</target>
        </trans-unit>
        <trans-unit id="918fcfe1bbabd9b098a3357af6b4c10845874e4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-lazy&quot;&gt;Data.Map.Merge.Lazy&lt;/a&gt; then they will not.</source>
          <target state="translated">Функции &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; используются модулями lazy и strict. Только выбор тактики слияния определяет строгость. Если вы используете &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; из этого модуля, результаты будут принудительно перед вставкой . Если вы используете &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; из &lt;a href=&quot;data-map-merge-lazy&quot;&gt;Data.Map.Merge.Lazy,&lt;/a&gt; тогда они не будут.</target>
        </trans-unit>
        <trans-unit id="7e82dc1c0b8d264abe9b7b565b8cd539e1dbf5c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from key of type &lt;code&gt;Int&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; представляет собой конечную карту (иногда называемую словарем) от ключа типа &lt;code&gt;Int&lt;/code&gt; до значений типа &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1641ed0171bfd491e6f0e6638191a7945a81dba8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Traversable&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; является общим для ленивых и строгих модулей, что означает, что одно и то же значение &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; может быть передано функциям в обоих модулях. Это означает, что экземпляры &lt;code&gt;Functor&lt;/code&gt; , &lt;code&gt;Traversable&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; такие же, как и для модуля &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; , поэтому, если они используются, результирующая карта может содержать приостановленные значения (преобразователи).</target>
        </trans-unit>
        <trans-unit id="5d01cac285dd99db980e4e71910e5f17ef1269f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Traversable&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de110598e79367090ddf9a9502e16c3db920c1a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Traversable&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6e272f4b13fc32e4e87c18c5a09335a1d8e5ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from key of type &lt;code&gt;Int&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; представляет собой конечную карту (иногда называемую словарем) от ключа типа &lt;code&gt;Int&lt;/code&gt; до значений типа &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="318814e0b6ddaa927c58b1267d22b77390f5ece2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; является общим для ленивых и строгих модулей, что означает, что одно и то же значение &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; может быть передано функциям в обоих модулях. Это означает, что экземпляры &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; такие же, как и для модуля &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; , поэтому, если они используются, результирующая карта может содержать приостановленные значения (преобразователи).</target>
        </trans-unit>
        <trans-unit id="352aafc40cb132717ac79f053c1b34a159a6c7a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df8970586f0c961dd4f430a41d51d650439ca67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f7bb2231b7f0bb854265a80968d382d2ee4a72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; type represents a set of elements of type &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; представляет собой набор элементов типа &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="235975fc327cbd37e2885a32990dd1d50e6ef2a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in a type onto integers. It is used primarily for array indexing (see the array package).</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; используется для отображения непрерывного поддиапазона значений в типе на целые числа. Он используется в основном для индексации массивов (см. Пакет с массивами).</target>
        </trans-unit>
        <trans-unit id="213033fe7d1bfa8957877f18a3b95df927b829f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in type onto integers. It is used primarily for array indexing (see the array package). &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; uses row-major order.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; используется для отображения непрерывного поддиапазона значений типа в целые числа. Он используется в основном для индексации массивов (см. Пакет с массивами). &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; использует порядок строк.</target>
        </trans-unit>
        <trans-unit id="1c9726b499ba205a67e8661afa56b3f5e6610bf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; function is list difference (non-associative). In the result of &lt;code&gt;xs&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt;&lt;code&gt;ys&lt;/code&gt;, the first occurrence of each element of &lt;code&gt;ys&lt;/code&gt; in turn (if any) has been removed from &lt;code&gt;xs&lt;/code&gt;. Thus</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; - это разность списков (неассоциативная). В результате &lt;code&gt;xs&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; &lt;code&gt;ys&lt;/code&gt; первое вхождение каждого элемента &lt;code&gt;ys&lt;/code&gt; по очереди (если есть) было удалено из &lt;code&gt;xs&lt;/code&gt; . таким образом</target>
        </trans-unit>
        <trans-unit id="d02a0fb924a1fb516ed51240226d0d6e5d964fd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; function takes a predicate and two lists and returns the first list with the first occurrence of each element of the second list removed.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; принимает предикат и два списка и возвращает первый список с первым удаленным вхождением каждого элемента второго списка.</target>
        </trans-unit>
        <trans-unit id="0d81ce03e6c4879c98e79164e27980ccd4245607" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; function drops the largest suffix of a list in which the given predicate holds for all elements. For example:</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; отбрасывает самый большой суффикс списка, в котором данный предикат выполняется для всех элементов. Например:</target>
        </trans-unit>
        <trans-unit id="8e6ebb6facf4e5e8507546d0730cd3d8aaa7cdbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given list which is equal (by &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) to the query element, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; возвращает индекс первого элемента в данном списке, который равен (на &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; ) элементу запроса, или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если такого элемента нет.</target>
        </trans-unit>
        <trans-unit id="35376b9066c242bc547e361977a97acd67654b38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements equal to the query element, in ascending order.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; расширяет &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; , возвращая индексы всех элементов, равных элементу запроса, в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="777c2200547e9739ba52a7633b954736b9823c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; function is just &lt;code&gt;&lt;a href=&quot;control-monad#v:mfilter&quot;&gt;mfilter&lt;/a&gt;&lt;/code&gt; specialized to the list monad:</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; - это просто &lt;code&gt;&lt;a href=&quot;control-monad#v:mfilter&quot;&gt;mfilter&lt;/a&gt;&lt;/code&gt; , специализированный для монады списка:</target>
        </trans-unit>
        <trans-unit id="a5d8b6f3eaba5030a68bf5d06e480657d33033a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a structure and returns the leftmost element of the structure matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; принимает предикат и структуру и возвращает самый левый элемент структуры, соответствующий предикату, или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если такого элемента нет.</target>
        </trans-unit>
        <trans-unit id="75b2422f251ce2039aaef3829d2dd5ca0ff38fd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a list and returns the index of the first element in the list satisfying the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; принимает предикат и список и возвращает индекс первого элемента в списке, удовлетворяющего этому предикату, или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если такого элемента нет.</target>
        </trans-unit>
        <trans-unit id="9ea9c7c9c9ab7b6e747e9ebc107dbbfddd67c972" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; расширяет &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; , возвращая индексы всех элементов, удовлетворяющих предикату, в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="be32822442735a04d54fa68d012d24ba5b89a668" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to drop.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; - это перегруженная версия &lt;code&gt;&lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; , которая принимает любое значение &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; в качестве количества удаляемых элементов.</target>
        </trans-unit>
        <trans-unit id="2812d742b2328d1abd314aebeef9aa75d01e9698" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the index.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; - это перегруженная версия &lt;code&gt;&lt;a href=&quot;data-list#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt; , который принимает любое &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; значение в качестве индекса.</target>
        </trans-unit>
        <trans-unit id="737fc86009d880ef7008902e996d5561992367bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of repetitions to make.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; - это перегруженная версия функции &lt;code&gt;&lt;a href=&quot;data-list#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; , которая принимает любое значение &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; в качестве количества выполняемых повторений.</target>
        </trans-unit>
        <trans-unit id="3402cafa3322e6ce9bc65e493a0acf1f2884672d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the position at which to split.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; - это перегруженная версия &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; , которая принимает любое значение &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; в качестве позиции, в которой выполняется разделение.</target>
        </trans-unit>
        <trans-unit id="f78c90a57d5cce824e07db93d2197f95aa21a155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to take.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; - это перегруженная версия &lt;code&gt;&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; , которая принимает любое значение &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; в качестве количества принимаемых элементов.</target>
        </trans-unit>
        <trans-unit id="ca4d378c787c5b9b2a06ae77c402a921da5aae20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a list and returns a list of lists such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; принимает список и возвращает список списков, так что объединение результата равно аргументу. Более того, каждый подсписок в результате содержит только равные элементы. Например,</target>
        </trans-unit>
        <trans-unit id="b33d3992fa75b8c5a7295f072191cef6471b5d58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a2aa0c2fff9d0cd85f48ee4e5c547b1e24beae0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; function returns all initial segments of the argument, shortest first. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; возвращает все начальные сегменты аргумента, сначала самые короткие. Например,</target>
        </trans-unit>
        <trans-unit id="e70f04ea60546783e780339c103b21d6a6b67467" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; function takes the list intersection of two lists. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; принимает пересечение двух списков. Например,</target>
        </trans-unit>
        <trans-unit id="a6dc46001b61fa48ad57e1c564b945db378bd949" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия элемента &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1446aaefcfea8557eabaae6ea889f9011ff1bbe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is contained, wholly and intact, anywhere within the second.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; принимает два списка и возвращает &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если первый список содержится целиком и без изменений где-нибудь во втором.</target>
        </trans-unit>
        <trans-unit id="8577e2ac2954a5de0cd6238c09ea92a58c9fb7f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:isSubsequenceOf&quot;&gt;isSubsequenceOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all the elements of the first list occur, in order, in the second. The elements do not have to occur consecutively.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:isSubsequenceOf&quot;&gt;isSubsequenceOf&lt;/a&gt;&lt;/code&gt; принимает два списка и возвращает &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если все элементы первого списка встречаются по порядку во втором. Элементы не обязательно должны располагаться последовательно.</target>
        </trans-unit>
        <trans-unit id="4a40ec49296ced12343a8fd18ca5c49b63aabe04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a suffix of the second. The second list must be finite.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; принимает два списка и возвращает &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если первый список является суффиксом второго. Второй список должен быть конечным.</target>
        </trans-unit>
        <trans-unit id="1b34469353a0b037b47cce6d230cb4cb71110874" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу структуры, передавая параметр накопления слева направо и возвращая окончательное значение этого аккумулятора вместе с новой структурой.</target>
        </trans-unit>
        <trans-unit id="8dd53e15a4486e163e923e5edcb16e98edcfede4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ebf56806d59584f196cd5d11b8904d0639b1d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу структуры, передавая параметр накопления справа налево и возвращая окончательное значение этого аккумулятора вместе с новой структурой.</target>
        </trans-unit>
        <trans-unit id="58255312061a37b729a440f59df1d47f433cf4a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb6f6e78bb431c6ad213eb9d21c75fa95dc7ddf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt;, except it uses a user-supplied equality predicate instead of the overloaded &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; ведет себя так же, как &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; , за исключением того, что в ней используется предикат равенства, предоставляемый пользователем, вместо перегруженной функции &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc7232b1ebffbebb739ba096d41e32596b9eedb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate a list and returns the pair of lists of elements which do and do not satisfy the predicate, respectively; i.e.,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; принимает предикат список и возвращает пару списков элементов, которые удовлетворяют и не удовлетворяют предикату, соответственно; т.е.</target>
        </trans-unit>
        <trans-unit id="2b6ed649212daaa5b7d86c6ccef6bf66b085c1db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; function returns the list of all permutations of the argument.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; возвращает список всех перестановок аргумента.</target>
        </trans-unit>
        <trans-unit id="2f287658e3d55e31f32fe140091016332ce08537" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; вычисляет произведение номеров конструкции.</target>
        </trans-unit>
        <trans-unit id="a463a93b298d3088c6a486752b752d20e4b0de19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function implements a stable sorting algorithm. It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; реализует стабильный алгоритм сортировки. Это частный случай &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; , который позволяет программисту предоставлять свою собственную функцию сравнения.</target>
        </trans-unit>
        <trans-unit id="095b73e07b36153b051dcf74ac3cefd56274581f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b88e9d47462c1b9615bcd7d7acc05eba51c65b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; function returns the list of all subsequences of the argument.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; возвращает список всех подпоследовательностей аргумента.</target>
        </trans-unit>
        <trans-unit id="eff98324d1a84c781b046e919d0b375a374d6a43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; вычисляет сумму номеров конструкции.</target>
        </trans-unit>
        <trans-unit id="ac33ccd64dfa538162e29b5368275ac3dcab2e9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its argument. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; перемещает строки и столбцы своего аргумента. Например,</target>
        </trans-unit>
        <trans-unit id="21074974ba0da203fdbe3139596e6c3eb82eacd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is a `dual' to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;: while &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; reduces a list to a summary value, &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a list from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the list or returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepended to the list and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; является двойной функцией &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; : в то время как &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; сокращает список до итогового значения, &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; строит список из начального значения. Функция принимает элемент и возвращает &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если она завершила создание списка, или возвращает &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; , и в этом случае &lt;code&gt;a&lt;/code&gt; добавляется к списку, а &lt;code&gt;b&lt;/code&gt; используется как следующий элемент в рекурсивном вызове. Например,</target>
        </trans-unit>
        <trans-unit id="6f5fe84f2f6e359d0b958ffdfd50c5ad6c942d08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; function returns the list union of the two lists. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; возвращает объединение двух списков. Например,</target>
        </trans-unit>
        <trans-unit id="26aa6f38df9eac11f0ca7ea5149a65e6f035439a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3512932a90bda2966b9c4bde2bc99fdaee65977a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; принимает список троек и возвращает три списка, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="465b134f0e0674fc306964e8911a4c8f5a23b544" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; function takes a list of quadruples and returns four lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; берет список из четверок и возвращает четыре списка, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eab7f028c5e43e9c371d7627b6af73045109e75d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; function takes a list of five-tuples and returns five lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; принимает список из пяти кортежей и возвращает пять списков, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6934051d9d7b99ca14d42b993760a93edf9a7566" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; function takes a list of six-tuples and returns six lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; принимает список из шести кортежей и возвращает шесть списков, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="782bb3363a3945b001878329fde4ebb88dcb6fb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; function takes a list of seven-tuples and returns seven lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; принимает список из семи кортежей и возвращает семь списков, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17802af283250b2eaa32a2ecb8cb86776774ec7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; function takes four lists and returns a list of quadruples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; принимает четыре списка и возвращает список из четырех элементов, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="6bce1a1341ac4dd8d73f1e68a1710aec2a623827" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; function takes five lists and returns a list of five-tuples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; принимает пять списков и возвращает список из пяти кортежей, аналогичный &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="451d4d26a4f677865f2a3a707b38064fca9f4083" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; function takes six lists and returns a list of six-tuples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; принимает шесть списков и возвращает список из шести кортежей, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="c305b363ee1ef77beb2a8edb13e3c0d40953e5c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; function takes seven lists and returns a list of seven-tuples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; принимает семь списков и возвращает список из семи кортежей, аналогичный &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="808a6c884122f71311b11b7294556f8f16861f57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of the function applied to corresponding elements, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88779bb5c5d951c52ff0e703df09adaeddb2bdff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет три элемента, а также три списка, и возвращает список их точечной комбинации, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="60ff42280ef2fd04c5a52b0fb6c4ced9f80d259b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; function takes a function which combines four elements, as well as four lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет четыре элемента, а также четыре списка и возвращает список их точечных комбинаций, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="9fb3b6d637e7bdf78afcd7364064abe2b747412a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; function takes a function which combines five elements, as well as five lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет пять элементов, а также пять списков, и возвращает список их точечных комбинаций, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="76824cb1a5c46cd7971e7c2fd78abbe2f0690804" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; function takes a function which combines six elements, as well as six lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет шесть элементов, а также шесть списков, и возвращает список их точечной комбинации, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="c2eb2006a61b2e5916c9fa720bb30884f6a6a25d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; function takes a function which combines seven elements, as well as seven lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет семь элементов, а также семь списков и возвращает список их точечной комбинации, аналогично &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="657b1604cfab08f6d70ddcd61991924e84fa776b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:break&quot;&gt;break&lt;/a&gt; p&lt;/code&gt; function is equivalent to &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:span&quot;&gt;span&lt;/a&gt; (not . p)&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:break&quot;&gt;break&lt;/a&gt; p&lt;/code&gt; эквивалентна &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:span&quot;&gt;span&lt;/a&gt; (not . p)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee5bf1dc8f489bf35d33f57749203f70974c1fd9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a stream and returns a list of streams such that flattening the resulting list is equal to the argument. Moreover, each stream in the resulting list contains only equal elements. For example, in list notation:</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; принимает поток и возвращает список потоков, так что сглаживание результирующего списка равно аргументу. Более того, каждый поток в результирующем списке содержит только равные элементы. Например, в обозначении списка:</target>
        </trans-unit>
        <trans-unit id="d4768abc565ec9f4747dd76eb1df6c5aed894777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; function takes a stream &lt;code&gt;xs&lt;/code&gt; and returns all the finite prefixes of &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; принимает поток &lt;code&gt;xs&lt;/code&gt; и возвращает все конечные префиксы &lt;code&gt;xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37ce52036d19badb8eb3e19e52707cf238bc5e53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the first argument is a prefix of the second.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если первый аргумент является префиксом второго.</target>
        </trans-unit>
        <trans-unit id="bd9fc5f9beeabe2f81cfc9e7c5d9e742fa36f643" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. (The name &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; means 'essence'.) It is a special case of &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own inequality test.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; удаляет повторяющиеся элементы из списка. В частности, он сохраняет только первое вхождение каждого элемента. (Название &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; означает &amp;laquo;сущность&amp;raquo;.) Это частный случай &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; , который позволяет программисту предоставить свой собственный тест на неравенство.</target>
        </trans-unit>
        <trans-unit id="1fd2343fdb59771c84cb4f982c7246f3073f744d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt;, except it uses a user-supplied equality predicate instead of the overloaded &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; ведет себя так же, как &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; , за исключением того, что в ней используется предикат равенства, предоставляемый пользователем, вместо перегруженной функции &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ca6a46f6f161da72b75fa2b96c21284bff63000" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate &lt;code&gt;p&lt;/code&gt; and a stream &lt;code&gt;xs&lt;/code&gt;, and returns a pair of lists. The first list corresponds to the elements of &lt;code&gt;xs&lt;/code&gt; for which &lt;code&gt;p&lt;/code&gt; holds; the second corresponds to the elements of &lt;code&gt;xs&lt;/code&gt; for which &lt;code&gt;p&lt;/code&gt; does not hold.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; принимает предикат &lt;code&gt;p&lt;/code&gt; и поток &lt;code&gt;xs&lt;/code&gt; и возвращает пару списков. Первый список соответствует элементам &lt;code&gt;xs&lt;/code&gt; , для которых выполняется &lt;code&gt;p&lt;/code&gt; ; второй соответствует элементам &lt;code&gt;xs&lt;/code&gt; , для которых &lt;code&gt;p&lt;/code&gt; не выполняется.</target>
        </trans-unit>
        <trans-unit id="97f203f3e97c286860c77a16076e2c5ba5e804b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; function takes a stream &lt;code&gt;xs&lt;/code&gt; and returns all the suffixes of &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; принимает поток &lt;code&gt;xs&lt;/code&gt; и возвращает все суффиксы &lt;code&gt;xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4b73a8b2bef137b1be451c67193ea1b9dd5278a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; operation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; функция аналогична &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt; &amp;laquo;s &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; операции.</target>
        </trans-unit>
        <trans-unit id="2413c236691707253e811091fb05fcbb1bf0b562" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; function is the inverse of the &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; - это обратная функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce09038022ed3cd501096c0d8a1d4d43ab363fc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; function takes two streams and returns a stream of corresponding pairs.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; принимает два потока и возвращает поток соответствующих пар.</target>
        </trans-unit>
        <trans-unit id="f10666c8af44a76f18b1cbb206ccc5dbbcf92fdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; function generalizes &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. Rather than tupling the elements, the elements are combined using the function passed as the first argument.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; обобщает &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . Вместо того, чтобы выбирать элементы, элементы объединяются с использованием функции, переданной в качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="16a4e90fc05f7eb7703f8d38de0941aad54680ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from keys of type &lt;code&gt;k&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;. A &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is strict in its keys but lazy in its values.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; представляет собой конечную карту (иногда называемую словарем) от ключей типа &lt;code&gt;k&lt;/code&gt; до значений типа &lt;code&gt;v&lt;/code&gt; . У &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; строгие ключи, но ленивые значения.</target>
        </trans-unit>
        <trans-unit id="4715b3b3e03f7ebfbfad3ed60bdf0126093bd7fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-strict&quot;&gt;Data.Map.Merge.Strict&lt;/a&gt; then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then they will not.</source>
          <target state="translated">Функции &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; используются модулями lazy и strict. Только выбор тактики слияния определяет строгость. Если вы используете &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; из &lt;a href=&quot;data-map-merge-strict&quot;&gt;Data.Map.Merge.Strict,&lt;/a&gt; тогда результаты будут принудительно перед вставкой . Если вы используете &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; из этого модуля, они не будут.</target>
        </trans-unit>
        <trans-unit id="2b155238023fcafca6284b024ed0af65f6650208" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-lazy&quot;&gt;Data.Map.Merge.Lazy&lt;/a&gt; then they will not.</source>
          <target state="translated">Функции &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; используются модулями lazy и strict. Только выбор тактики слияния определяет строгость. Если вы используете &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; из этого модуля, результаты будут принудительно перед вставкой . Если вы используете &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; из &lt;a href=&quot;data-map-merge-lazy&quot;&gt;Data.Map.Merge.Lazy,&lt;/a&gt; тогда они не будут.</target>
        </trans-unit>
        <trans-unit id="662c04a7a17ee001eac580254bab8523defdb93a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from keys of type &lt;code&gt;k&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; представляет собой конечную карту (иногда называемую словарем) от ключей типа &lt;code&gt;k&lt;/code&gt; до значений типа &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12662a5070f04b0d43497ea05090a5128c804911" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; module, so if they are used the resulting maps may contain suspended values (thunks).</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; является общим для ленивых и строгих модулей, что означает, что одно и то же значение &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; может быть передано функциям в обоих модулях. Это означает, что экземпляры &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; такие же, как и для модуля &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; , поэтому, если они используются, результирующие карты могут содержать приостановленные значения (преобразователи).</target>
        </trans-unit>
        <trans-unit id="80a0485ade9c643df5c2ea0bf0c47d55fb54166e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; module, so if they are used the resulting maps may contain suspended values (thunks).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff715be94759f4fe46e742d1184a2a615aa793fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; module, so if they are used the resulting maps may contain suspended values (thunks).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f52f3aa69ba900643917df0d514ebfe7065396f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type encapsulates an optional value. A value of type &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; either contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt;), or it is empty (represented as &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;). Using &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is a good way to deal with errors or exceptional cases without resorting to drastic measures such as &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; инкапсулирует необязательное значение. Значение типа &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; либо содержит значение типа &lt;code&gt;a&lt;/code&gt; (представленное как &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; ), либо оно пустое (представлено как &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ). Использование &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; - хороший способ справиться с ошибками или исключительными случаями, не прибегая к таким радикальным мерам, как &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f185e83cdbbc510aa029904011adfe83bd8b1220" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type is also a monad. It is a simple kind of error monad, where all errors are represented by &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. A richer error monad can be built using the &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; - тоже монада. Это простая монада ошибок, в которой все ошибки представлены &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; . Более богатая монада ошибок может быть построена с &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; типа Either .</target>
        </trans-unit>
        <trans-unit id="e8aa4a4fc49f7638e33b52125beaf5389284d595" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; принимает список значений &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; и возвращает список всех значений &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e3cc1728b8d32e7bd6e33d7191898329f389751" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromJust&quot;&gt;fromJust&lt;/a&gt;&lt;/code&gt; function extracts the element out of a &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and throws an error if its argument is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromJust&quot;&gt;fromJust&lt;/a&gt;&lt;/code&gt; извлекает элемент из &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; и выдает ошибку, если ее аргумент равен &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9e0e0ae5827a91039e8b0c00412d73abae7c014" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and a &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default value; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de4cf2aa7df453c08de73e06681e00b3a9d47c30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and and &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default values; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; принимает значение по умолчанию и значение &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; . Если &amp;laquo; &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; равно &amp;laquo; &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , он возвращает значения по умолчанию; в противном случае возвращается значение, содержащееся в поле &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a5a7a323996766db88ca0c88884029bb8a6704d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:isJust&quot;&gt;isJust&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff its argument is of the form &lt;code&gt;Just _&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-maybe#v:isJust&quot;&gt;isJust&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если ее аргумент имеет форму &lt;code&gt;Just _&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52483bf501d37712c976868bb9284af355744fac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:isNothing&quot;&gt;isNothing&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff its argument is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-maybe#v:isNothing&quot;&gt;isNothing&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если ее аргумент равен &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eee25b35452f5d1cfc414313539edda0a7120764" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:listToMaybe&quot;&gt;listToMaybe&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; on an empty list or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the first element of the list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-maybe#v:listToMaybe&quot;&gt;listToMaybe&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; в пустом списке или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; где &lt;code&gt;a&lt;/code&gt; является первым элементом списка.</target>
        </trans-unit>
        <trans-unit id="d9226f117113df71e3656c9e6013ce6d6bf13f04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; function is a version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; which can throw out elements. In particular, the functional argument returns something of type &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; b&lt;/code&gt;. If this is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, no element is added on to the result list. If it is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; b&lt;/code&gt;, then &lt;code&gt;b&lt;/code&gt; is included in the result list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; - это версия &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; которая может выбрасывать элементы. В частности, функциональный аргумент возвращает что-то типа &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; b&lt;/code&gt; . Если это &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , в список результатов не добавляется никаких элементов. Если это &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; b&lt;/code&gt; , то &lt;code&gt;b&lt;/code&gt; включается в список результатов.</target>
        </trans-unit>
        <trans-unit id="85d0ce65a11dff7a785fa5be5465e4febfc6e9a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; function takes a default value, a function, and a &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the function returns the default value. Otherwise, it applies the function to the value inside the &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and returns the result.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; функция принимает значение по умолчанию, функцию и &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; значение. Если значение &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; равно &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , функция возвращает значение по умолчанию. В противном случае он применяет функцию к значению внутри &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; и возвращает результат.</target>
        </trans-unit>
        <trans-unit id="5c611fd7648ec2451334092c9df4afb5e19ad5d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; возвращает пустой список, если задано &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , или одноэлементный список, если задано &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="795a9f9783333374a76593a231e073666138ebda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-monoid#t:Sum&quot;&gt;Sum&lt;/a&gt;&lt;/code&gt; monoid is defined by the numerical addition operator and `0` as neutral element:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-monoid#t:Sum&quot;&gt;Sum&lt;/a&gt;&lt;/code&gt; моноид определяются численным оператором сложения и '0' в качестве нейтрального элемента:</target>
        </trans-unit>
        <trans-unit id="7f108b74d9d0f499180865c6097577550b780ef6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; type allows you to reverse sort order conveniently. A value of type &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9acde1593d8ad750d5ecbfa06d97960b56f05f43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; type allows you to reverse sort order conveniently. A value of type &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt;). If &lt;code&gt;a&lt;/code&gt; has an &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance associated with it then comparing two values thus wrapped will give you the opposite of their normal sort order. This is particularly useful when sorting in generalised list comprehensions, as in: &lt;code&gt;then sortWith by &lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt;</source>
          <target state="translated">Тип &amp;laquo; &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; &amp;raquo; позволяет удобно менять порядок сортировки на обратный. Значение типа &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; содержит значение типа &lt;code&gt;a&lt;/code&gt; (представленное как &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; ). Если имеет &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; экземпляр , связанный с ним , то сравнение двух значений , таким образом , обернутые даст вам противоположное их нормального порядка сортировки. Это особенно полезно при сортировке в обобщенных представлениях списка, например: &lt;code&gt;then sortWith by &lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; x &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d480aba9ca8f558b9bab4a7470c617258413273" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class is used for totally ordered datatypes.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; используется для полностью упорядоченных типов данных.</target>
        </trans-unit>
        <trans-unit id="9743e6ce1ccca02d84b310e0c03e3b64b006ece2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Min&quot;&gt;Min&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is defined to always pick the smaller number: &amp;gt;&amp;gt;&amp;gt; Min 1 &amp;lt;&amp;gt; Min 2 &amp;lt;&amp;gt; Min 3 &amp;lt;&amp;gt; Min 4 :: Min Int Min {getMin = 1}</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-semigroup#t:Min&quot;&gt;Min&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; экземпляр для &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; определяется всегда выбирают меньшее число: &amp;gt;&amp;gt;&amp;gt; Min 1 &amp;lt;&amp;gt; Минимум 2 &amp;lt;&amp;gt; Минимум 3 &amp;lt;&amp;gt; Мин 4 :: Мин Int Мин {getMin = 1}</target>
        </trans-unit>
        <trans-unit id="d415a40b49223b304b71b398a708eb25f07e68ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt; a&lt;/code&gt; type represents a finite sequence of values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt; a&lt;/code&gt; представляет собой конечную последовательность значений типа &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13ce1c3f2600f3e2f50834c056ec8fa70e4eab37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; type represents a set of elements of type &lt;code&gt;e&lt;/code&gt;. Most operations require that &lt;code&gt;e&lt;/code&gt; be an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class. A &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; is strict in its elements.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; представляет собой набор элементов типа &lt;code&gt;e&lt;/code&gt; . Для большинства операций требуется, чтобы &lt;code&gt;e&lt;/code&gt; был экземпляром класса &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; строг в своих элементах.</target>
        </trans-unit>
        <trans-unit id="1038dcfb90af9b5c0cfcdb7ab1311da4e5ed3150" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; type represents a set of elements of type &lt;code&gt;e&lt;/code&gt;. Most operations require that &lt;code&gt;e&lt;/code&gt; be an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class. A &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; is strict in its elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9efbd927cc3f3d70bf87d84d4a730da30c040e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; type represents a set of elements of type &lt;code&gt;e&lt;/code&gt;. Most operations require that &lt;code&gt;e&lt;/code&gt; be an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class. A &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; is strict in its elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8881e3fb681798d7bf981e8e9d449509800437b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is implemented using arrays that are not guaranteed to have a fixed address in the Haskell heap. All communication with native code must thus occur by copying data back and forth.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; реализован с использованием массивов, для которых не гарантируется наличие фиксированного адреса в куче Haskell. Таким образом, вся связь с машинным кодом должна происходить путем копирования данных туда и обратно.</target>
        </trans-unit>
        <trans-unit id="9d9c2733ed15ccf0d235e8a6b100f93fe8426bb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type's internal representation is UTF-16, using the platform's native endianness. This makes copied data suitable for use with native libraries that use a similar representation, such as ICU. To interoperate with native libraries that use different internal representations, such as UTF-8 or UTF-32, consider using the functions in the &lt;code&gt;&lt;a href=&quot;data-text#v:Encoding&quot;&gt;Encoding&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; внутреннее представление Type является UTF-16, используя родной порядок байтов платформы. Это делает скопированные данные пригодными для использования с собственными библиотеками, которые используют аналогичное представление, например ICU. Для взаимодействия с собственными библиотеками, которые используют различные внутренние представления, такие как UTF-8 или UTF-32, рассмотрите возможность использования функций в модуле &lt;code&gt;&lt;a href=&quot;data-text#v:Encoding&quot;&gt;Encoding&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="161f7f591d2f56a095b5a6738fe11dc948f83c20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-text#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and a strict &lt;code&gt;&lt;a href=&quot;data-text#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Performs replacement on invalid scalar values.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-text#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-text#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; и строгого &lt;code&gt;&lt;a href=&quot;data-text#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; , передавая параметр накопления справа налево и возвращая окончательное значение этого аккумулятора вместе с новым &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; . Выполняет замену недопустимых скалярных значений.</target>
        </trans-unit>
        <trans-unit id="c5823a0c22eaaaf0e0d80ffbc2bbde448d239204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; constructor is exposed since &lt;code&gt;text-1.1.1.3&lt;/code&gt;</source>
          <target state="translated">Конструктор &lt;code&gt;&lt;a href=&quot;data-text-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; &lt;code&gt;text-1.1.1.3&lt;/code&gt; с text-1.1.1.3</target>
        </trans-unit>
        <trans-unit id="7d764c078d54b6747b82b1fb65bc90cbfdc33a9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; constructor is exposed since &lt;code&gt;text-1.1.1.3&lt;/code&gt;</source>
          <target state="translated">Конструктор &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; доступен с &lt;code&gt;text-1.1.1.3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e4b96f6778d5f3fbaa9eb0f8c186a8f261148c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8&quot;&gt;streamDecodeUtf8&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; functions accept a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that represents a possibly incomplete input (e.g. a packet from a network stream) that may not end on a UTF-8 boundary.</source>
          <target state="translated">Функции &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8&quot;&gt;streamDecodeUtf8&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; принимают &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; , представляющую возможно неполный ввод (например, пакет из сетевого потока), который может не заканчиваться на границе UTF-8.</target>
        </trans-unit>
        <trans-unit id="651e438c6d91bc7b186512f8dad01a122ee5eab0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8&quot;&gt;streamDecodeUtf8&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; functions accept a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that represents a possibly incomplete input (e.g. a packet from a network stream) that may not end on a UTF-8 boundary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8de0eaf04140ba7158dddc8d0be85ce0ccccc4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a stream and returns the index of the first element in the stream satisfying the predicate.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; принимает предикат и поток и возвращает индекс первого элемента в потоке, удовлетворяющего предикату.</target>
        </trans-unit>
        <trans-unit id="bf384e38dd6fd9c82df77df8975246cdedc34701" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:findIndexI&quot;&gt;findIndexI&lt;/a&gt;&lt;/code&gt; function takes a predicate and a stream and returns the index of the first element in the stream satisfying the predicate.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:findIndexI&quot;&gt;findIndexI&lt;/a&gt;&lt;/code&gt; принимает предикат и поток и возвращает индекс первого элемента в потоке, удовлетворяющего предикату.</target>
        </trans-unit>
        <trans-unit id="ee94ea37dfd7850ffc9a486e3dd92c091c5cbec7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;n&lt;/code&gt; code points.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; по &lt;code&gt;n&lt;/code&gt; кодовых точек.</target>
        </trans-unit>
        <trans-unit id="66da5760dab680492ae3a48dc3a35550be6dc4df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; of the given code point.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; данной точки коды.</target>
        </trans-unit>
        <trans-unit id="a75e1f66c9b008e7ba6ff420a20501b8af837a38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-text-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; принимает в качестве аргумента функцию типа &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; . Весь ввод от стандартного устройства ввода передается этой функции в качестве аргумента, а результирующая строка выводится на стандартное устройство вывода.</target>
        </trans-unit>
        <trans-unit id="b417d4f678288b71d35accb0f99175761f3e1e07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The entire file is read strictly, as with &lt;code&gt;&lt;a href=&quot;data-text-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-text-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; считывает файл и возвращает содержимое файла в виде строки. Весь файл читается строго, как и в случае с &lt;code&gt;&lt;a href=&quot;data-text-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68615baf25b8a5dabb727f9a05e4f69c95e23d72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; and returns a list of &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; функция принимает &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; и возвращает список &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; s такого , что конкатенация результата равна аргументу. Более того, каждый подсписок в результате содержит только равные элементы. Например,</target>
        </trans-unit>
        <trans-unit id="448dca813f1fb16bef7c7de2c7c5fae5b0a093ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea18231a8f3d26a5fe0119fe32dfbafea55d681" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and a strict &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Performs replacement on invalid scalar values.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; и строгого &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; , передавая параметр накопления справа налево и возвращая окончательное значение этого аккумулятора вместе с новым &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; . Выполняет замену недопустимых скалярных значений.</target>
        </trans-unit>
        <trans-unit id="1a76ea813e8c21de4f80acb76647bc2ec24349f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; as its argument. The entire input from the standard input device is passed (lazily) to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-text-lazy-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; принимает в качестве аргумента функцию типа &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; . Весь ввод со стандартного устройства ввода передается (лениво) в эту функцию в качестве аргумента, а результирующая строка выводится на стандартное устройство вывода.</target>
        </trans-unit>
        <trans-unit id="0f4eb06ba150dfea2048571ec4f24a657175124e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу структуры, передавая параметр накопления слева направо и возвращая окончательное значение этого аккумулятора вместе с новой структурой.</target>
        </trans-unit>
        <trans-unit id="7d943aed90068948d72a0d5858ba1b7944e9decb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу структуры, передавая параметр накопления справа налево и возвращая окончательное значение этого аккумулятора вместе с новой структурой.</target>
        </trans-unit>
        <trans-unit id="37d7ebaf143b71c90e000c5e485da2fe61a5ea4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; methods are useful when what you have is a container of applicative or, respectively, monadic actions, and you want to evaluate them left-to-right to obtain a container of the computed values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5f7c77832ccee5dc8f444bf10cb820686c5a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-tree#t:Forest&quot;&gt;Forest&lt;/a&gt; a&lt;/code&gt; type represents a forest of &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt;s.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-tree#t:Forest&quot;&gt;Forest&lt;/a&gt; a&lt;/code&gt; представляет собой лес &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="4dde0b10b0f433f8901cc6d31ae5f25b888075e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt; type represents a lazy, possibly infinite, multi-way tree (also known as a &lt;em&gt;rose tree&lt;/em&gt;).</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt; представляет собой ленивое, возможно, бесконечное, многостороннее дерево (также известное как &lt;em&gt;розовое дерево&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="8007180e7dc5a974039c84bcb837081428c5c9da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; class reifies types to some extent by associating type representations to types. These type representations can be compared, and one can in turn define a type-safe cast operation. To this end, an unsafe cast is guarded by a test for type (representation) equivalence. The module &lt;a href=&quot;data-dynamic&quot;&gt;Data.Dynamic&lt;/a&gt; uses Typeable for an implementation of dynamics. The module &lt;a href=&quot;data-data&quot;&gt;Data.Data&lt;/a&gt; uses Typeable and type-safe cast (but not dynamics) to support the &quot;Scrap your boilerplate&quot; style of generic programming.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; класс материализует типов в некоторой степени, сопоставляя представления типа типам. Эти представления типов можно сравнивать и, в свою очередь, определять безопасную для типов операцию приведения. С этой целью небезопасное приведение охраняется тестом на эквивалентность типа (представления). Модуль &lt;a href=&quot;data-dynamic&quot;&gt;Data.Dynamic&lt;/a&gt; использует Typeable для реализации динамики. Модуль &lt;a href=&quot;data-data&quot;&gt;Data.Data&lt;/a&gt; использует типизируемое и безопасное для типов приведение (но не динамическое) для поддержки стиля универсального программирования &amp;laquo;Избавьтесь от шаблона&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d043229d0aba230c46b619f1751b3e8e83785014" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; function outputs the trace message given as its first argument, before returning the second argument as its result.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; выводит сообщение трассировки, указанное в качестве ее первого аргумента, перед возвращением второго аргумента в качестве результата.</target>
        </trans-unit>
        <trans-unit id="140721e416adc2345c2c2facce319e06db5e38ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; function should &lt;em&gt;only&lt;/em&gt; be used for debugging, or for monitoring execution. The function is not referentially transparent: its type indicates that it is a pure function but it has the side effect of outputting the trace message.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; функция должна &lt;em&gt;только&lt;/em&gt; использоваться для отладки или для контроля исполнения. Функция не является ссылочно прозрачной: ее тип указывает, что это чистая функция, но имеет побочный эффект вывода сообщения трассировки.</target>
        </trans-unit>
        <trans-unit id="605bec91baff60047b066d4e1ac30c1faa493023" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceShow&quot;&gt;traceShow&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; functions print messages to an output stream. They are intended for &quot;printf debugging&quot;, that is: tracing the flow of execution and printing interesting values.</source>
          <target state="translated">Функции &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceShow&quot;&gt;traceShow&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; выводят сообщения в выходной поток. Они предназначены для &amp;laquo;отладки printf&amp;raquo;, то есть отслеживания потока выполнения и вывода интересных значений.</target>
        </trans-unit>
        <trans-unit id="a88df11e31fce4c7204e009946e93a681d719b46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEvent&quot;&gt;traceEvent&lt;/a&gt;&lt;/code&gt; function behaves like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; with the difference that the message is emitted to the eventlog, if eventlog profiling is available and enabled at runtime.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEvent&quot;&gt;traceEvent&lt;/a&gt;&lt;/code&gt; ведет себя как &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; с той разницей, что сообщение отправляется в журнал событий , если профилирование журнала событий доступно и включено во время выполнения.</target>
        </trans-unit>
        <trans-unit id="49d4ea0d4504acbc4d1aca32b1293ddbe4063444" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; function emits a message to the eventlog, if eventlog profiling is available and enabled at runtime.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; отправляет сообщение в журнал событий , если профилирование журнала событий доступно и включено во время выполнения.</target>
        </trans-unit>
        <trans-unit id="b3a4eae130c3225cefb9efb90d8be9b83b521fab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; function outputs the trace message from the IO monad. This sequences the output with respect to other IO actions.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; выводит сообщение трассировки от монады ввода-вывода. Это упорядочивает вывод по отношению к другим действиям ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="d97ccf67a57dfd415eb74011cb7d1b6a77ff69bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarker&quot;&gt;traceMarker&lt;/a&gt;&lt;/code&gt; function emits a marker to the eventlog, if eventlog profiling is available and enabled at runtime. The &lt;code&gt;String&lt;/code&gt; is the name of the marker. The name is just used in the profiling tools to help you keep clear which marker is which.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarker&quot;&gt;traceMarker&lt;/a&gt;&lt;/code&gt; отправляет маркер в журнал событий , если профилирование журнала событий доступно и включено во время выполнения. &lt;code&gt;String&lt;/code&gt; это имя маркера. Название просто используется в инструментах профилирования, чтобы помочь вам понять, какой маркер какой.</target>
        </trans-unit>
        <trans-unit id="fa771e47c5e0835b60259fdc80c34fd55cfa3c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; function emits a marker to the eventlog, if eventlog profiling is available and enabled at runtime.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; отправляет маркер в журнал событий , если профилирование журнала событий доступно и включено во время выполнения.</target>
        </trans-unit>
        <trans-unit id="65a90e57ddce6b3095e1eb053172e0add59b8b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is parameterised in the same way as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;. The type argument of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; should normally be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; параметризуется таким же образом , как &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; . Аргумент типа &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; обычно должен быть экземпляром класса &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47f829e4b12e19d9b1b9c867b798c3d41bfa7cc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; type and operations. This module is part of the Foreign Function Interface (FFI) and will usually be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; типа и операции. Этот модуль является частью интерфейса внешних функций (FFI) и обычно импортируется через &lt;a href=&quot;foreign&quot;&gt;внешний&lt;/a&gt; модуль.</target>
        </trans-unit>
        <trans-unit id="4fea14f33688c221cc4b82a2e64457f2c1daf4c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is parameterised in the same way as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;. The type argument of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; should normally be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; параметризуется таким же образом , как &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; . Аргумент типа &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; обычно должен быть экземпляром класса &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46ba37e75544b376d91afd7d94cc178e3d4edd60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; type and operations. This module is part of the Foreign Function Interface (FFI) and will usually be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; типа и операции. Этот модуль является частью интерфейса внешних функций (FFI) и обычно импортируется через &lt;a href=&quot;foreign&quot;&gt;внешний&lt;/a&gt; модуль.</target>
        </trans-unit>
        <trans-unit id="05673b670d8de49659d7ca54ef48d3649d1c6cc9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; function casts a pointer from one type to another.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; переводит указатель от одного типа к другому.</target>
        </trans-unit>
        <trans-unit id="f4a69e977af812c4c1901ff0ace0b2bb4a9d9dd0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-arr#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in a type onto integers. It is used primarily for array indexing (see the array package).</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;ghc-arr#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; используется для отображения непрерывного поддиапазона значений в типе на целые числа. Он используется в основном для индексации массивов (см. Пакет с массивами).</target>
        </trans-unit>
        <trans-unit id="e348453b816674bfaf92baa8a27076b87c3aa9bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-arr#v:accumArray&quot;&gt;accumArray&lt;/a&gt;&lt;/code&gt; function deals with repeated indices in the association list using an &lt;em&gt;accumulating function&lt;/em&gt; which combines the values of associations with the same index.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-arr#v:accumArray&quot;&gt;accumArray&lt;/a&gt;&lt;/code&gt; обрабатывает повторяющиеся индексы в списке ассоциаций, используя функцию &lt;em&gt;накопления,&lt;/em&gt; которая объединяет значения ассоциаций с одним и тем же индексом.</target>
        </trans-unit>
        <trans-unit id="7873c676664db92e7ab0f598d2d48e71762b5260" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; class defines the basic operations over a &lt;em&gt;monad&lt;/em&gt;, a concept from a branch of mathematics known as &lt;em&gt;category theory&lt;/em&gt;. From the perspective of a Haskell programmer, however, it is best to think of a monad as an &lt;em&gt;abstract datatype&lt;/em&gt; of actions. Haskell's &lt;code&gt;do&lt;/code&gt; expressions provide a convenient syntax for writing monadic expressions.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; определяет основные операции над &lt;em&gt;монадой&lt;/em&gt; - концепцию из раздела математики, известного как &lt;em&gt;теория категорий&lt;/em&gt; . Однако с точки зрения программиста на Haskell лучше всего рассматривать монаду как &lt;em&gt;абстрактный тип данных&lt;/em&gt; действий. Выражения &lt;code&gt;do&lt;/code&gt; в Haskell обеспечивают удобный синтаксис для написания монадических выражений.</target>
        </trans-unit>
        <trans-unit id="ee50bbd3c67bae7f49e378336e2e433f6106ccf0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-base#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-base#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; - это обычный оператор соединения монад. Он используется для удаления одного уровня монадической структуры, проецируя связанный аргумент на внешний уровень.</target>
        </trans-unit>
        <trans-unit id="27aabb232ca4b09ca8d220a432dd7f16df59a935" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-conc#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; action allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads (if any), and is occasionally useful when implementing concurrency abstractions.</source>
          <target state="translated">Действие &lt;code&gt;&lt;a href=&quot;ghc-conc#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; позволяет (принудительно в реализации совместной многозадачности) переключать контекст на любые другие выполняемые в данный момент потоки (если они есть) и иногда полезно при реализации абстракций параллелизма.</target>
        </trans-unit>
        <trans-unit id="4a132846a2c0d7c2c3007c1d18b85a3d84e2a398" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; action allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads (if any), and is occasionally useful when implementing concurrency abstractions.</source>
          <target state="translated">Действие &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; позволяет (принудительно в реализации совместной многозадачности) переключать контекст на любые другие выполняемые в данный момент потоки (если они есть) и иногда полезно при реализации абстракций параллелизма.</target>
        </trans-unit>
        <trans-unit id="9dd95524ffc61573839150d5ca8d3bbeafd0b7a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class is used to name the upper and lower limits of a type. &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is not a superclass of &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; since types that are not totally ordered may also have upper and lower bounds.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; используется для обозначения верхнего и нижнего пределов типа. &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; не является суперклассом &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; , поскольку типы, которые не являются полностью упорядоченными, могут также иметь верхнюю и нижнюю границы.</target>
        </trans-unit>
        <trans-unit id="3e4a35f48d43f24d53c5bb16b69fba56be493a94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class may be derived for any enumeration type; &lt;code&gt;&lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; is the first constructor listed in the &lt;code&gt;data&lt;/code&gt; declaration and &lt;code&gt;&lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; is the last. &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; may also be derived for single-constructor datatypes whose constituent types are in &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; может быть производным от любого типа перечисления; &lt;code&gt;&lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; - это первый конструктор, указанный в объявлении &lt;code&gt;data&lt;/code&gt; а &lt;code&gt;&lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; - последний. &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; также может быть получен для типов данных с одним конструктором, составляющие типы которых находятся в &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="674d2d4d75029f825bd270a8d08697ebd9b70ba6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; классы.</target>
        </trans-unit>
        <trans-unit id="5927fd518988da69d26cdf922ae3e2a15412bf75" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; type allows you to reverse sort order conveniently. A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5cd6d00d90b1e061059918ba18205b11c14c002" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; type allows you to reverse sort order conveniently. A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt;). If &lt;code&gt;a&lt;/code&gt; has an &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance associated with it then comparing two values thus wrapped will give you the opposite of their normal sort order. This is particularly useful when sorting in generalised list comprehensions, as in: &lt;code&gt;then sortWith by &lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt;</source>
          <target state="translated">Тип &amp;laquo; &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; &amp;raquo; позволяет удобно менять порядок сортировки на обратный. Значение типа &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; содержит значение типа &lt;code&gt;a&lt;/code&gt; (представленное как &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; ). Если имеет &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; экземпляр , связанный с ним , то сравнение двух значений , таким образом , обернутые даст вам противоположное их нормального порядка сортировки. Это особенно полезно при сортировке в обобщенных представлениях списка, например: &lt;code&gt;then sortWith by &lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; x &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf4c3fac24e8ca008ba612ac6b40c0fcd012f0f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:IsList&quot;&gt;IsList&lt;/a&gt;&lt;/code&gt; class and its methods are intended to be used in conjunction with the OverloadedLists extension.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;ghc-exts#t:IsList&quot;&gt;IsList&lt;/a&gt;&lt;/code&gt; и его методы предназначены для использования вместе с расширением OverloadedLists.</target>
        </trans-unit>
        <trans-unit id="d7ba5830092cef4d84647e79c69131dbc7adc059" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Item&quot;&gt;Item&lt;/a&gt;&lt;/code&gt; type function returns the type of items of the structure &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">Функция Тип &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Item&quot;&gt;Item&lt;/a&gt;&lt;/code&gt; возвращает тип элементов структуры &lt;code&gt;l&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f84b47ee1d124d1ca79a226e83d25027b22134b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; function constructs the structure &lt;code&gt;l&lt;/code&gt; from the given list of &lt;code&gt;Item l&lt;/code&gt;</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; создает структуру &lt;code&gt;l&lt;/code&gt; из заданного списка &lt;code&gt;Item l&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39677f8a87165f5afc7795359f53bb6627c8c811" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; function takes the input list's length and potentially uses it to construct the structure &lt;code&gt;l&lt;/code&gt; more efficiently compared to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt;. If the given number does not equal to the input list's length the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; is not specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceee73322b5e0bdd5f3091f55d6384a70d17944b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; function takes the input list's length as a hint. Its behaviour should be equivalent to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt;. The hint can be used to construct the structure &lt;code&gt;l&lt;/code&gt; more efficiently compared to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt;. If the given hint does not equal to the input list's length the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; is not specified.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; принимает длину входного списка в качестве подсказки. Его поведение должно быть эквивалентно &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; . Подсказка может быть использована для более эффективного построения структуры &lt;code&gt;l&lt;/code&gt; по сравнению с &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; . Если указанная подсказка не равна длине входного списка, поведение &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; не указывается.</target>
        </trans-unit>
        <trans-unit id="c5c04c12c048d0307d00092d987715f0d989db28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:groupWith&quot;&gt;groupWith&lt;/a&gt;&lt;/code&gt; function uses the user supplied function which projects an element out of every list element in order to first sort the input list and then to form groups by equality on these projected elements</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-exts#v:groupWith&quot;&gt;groupWith&lt;/a&gt;&lt;/code&gt; использует предоставленную пользователем функцию, которая проецирует элемент из каждого элемента списка, чтобы сначала отсортировать список ввода, а затем сформировать группы по равенству для этих проецируемых элементов.</target>
        </trans-unit>
        <trans-unit id="695facc226b98a2fdc94f961971c4ce121f69e9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; function restrains strictness analysis a little. The call &lt;code&gt;lazy e&lt;/code&gt; means the same as &lt;code&gt;e&lt;/code&gt;, but &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; has a magical property so far as strictness analysis is concerned: it is lazy in its first argument, even though its semantics is strict. After strictness analysis has run, calls to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; are inlined to be the identity function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; специальностей ограничители строгости анализ мало. Вызов &lt;code&gt;lazy e&lt;/code&gt; означает то же самое, что и &lt;code&gt;e&lt;/code&gt; , но &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; имеет волшебное свойство в том, что касается анализа строгости: он ленив в своем первом аргументе, даже несмотря на то, что его семантика строгая. После выполнения анализа строгости вызовы &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; встроены в функцию идентификации.</target>
        </trans-unit>
        <trans-unit id="c62e040021cb66d2ce6289579ad247f811fcaf97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; function can be used to give a hint to the compiler that its argument will be called at most once, which may (or may not) enable certain optimizations. It can be useful to improve the performance of code in continuation passing style.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; функция может быть использована , чтобы дать подсказку компилятору , что ее аргумент будет называться не более одного раза, что может (или не может) дать определенные оптимизации. Это может быть полезно для повышения производительности кода при продолжении передачи.</target>
        </trans-unit>
        <trans-unit id="738f70f90664f23041407e78e7481ca578a61fb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:sortWith&quot;&gt;sortWith&lt;/a&gt;&lt;/code&gt; function sorts a list of elements using the user supplied function to project something out of each element</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-exts#v:sortWith&quot;&gt;sortWith&lt;/a&gt;&lt;/code&gt; сортирует список элементов, используя предоставленную пользователем функцию для проецирования чего-либо из каждого элемента.</target>
        </trans-unit>
        <trans-unit id="f8c0871b5b6f8b978adbdfa4a64b81796ab60e0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; function extracts a list of &lt;code&gt;Item l&lt;/code&gt; from the structure &lt;code&gt;l&lt;/code&gt;. It should satisfy fromList . toList = id.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; извлекает список &lt;code&gt;Item l&lt;/code&gt; из структуры &lt;code&gt;l&lt;/code&gt; . Он должен удовлетворять fromList. toList = id.</target>
        </trans-unit>
        <trans-unit id="b18ac779aba3ac796c0284e4d2cc3bb7c69a9f44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is parameterised in the same way as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;. The type argument of &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; should normally be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; параметризуется таким же образом , как &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; . Аргумент типа &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; обычно должен быть экземпляром класса &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5c813e0c538449c8b967f68e862c925ce84f9ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Leaf&quot; 'PrefixI 'False)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Node&quot; 'PrefixI 'False)&lt;/code&gt; invocations indicate that the enclosed part is the representation of the first and second constructor of datatype &lt;code&gt;Tree&lt;/code&gt;, respectively. Here, the meta-information regarding constructor names, fixity and whether it has named fields or not is encoded at the type level. The &lt;code&gt;'MetaCons&lt;/code&gt; type is also an instance of the type class &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Constructor&quot;&gt;Constructor&lt;/a&gt;&lt;/code&gt;. This type class can be used to obtain information about the constructor at the value level.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Leaf&quot; 'PrefixI 'False)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Node&quot; 'PrefixI 'False)&lt;/code&gt; вызовы показывают , что прилагаемая часть является представление первого и второго конструктора типа данных &lt;code&gt;Tree&lt;/code&gt; , соответственно. Здесь метаинформация, касающаяся имен конструкторов, фиксации и того, имеет ли он именованные поля или нет, кодируется на уровне типа. Тип &lt;code&gt;'MetaCons&lt;/code&gt; также является экземпляром класса типа &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Constructor&quot;&gt;Constructor&lt;/a&gt;&lt;/code&gt; . Этот класс типа можно использовать для получения информации о конструкторе на уровне значения.</target>
        </trans-unit>
        <trans-unit id="4b3758b0106cdc9eb50e8251878d12e347f33b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt; ('MetaData &quot;Tree&quot; &quot;Main&quot; &quot;package-name&quot; 'False)&lt;/code&gt; tag indicates that the enclosed part is the representation of the datatype &lt;code&gt;Tree&lt;/code&gt;. Again, the meta-information is encoded at the type level. The &lt;code&gt;'MetaData&lt;/code&gt; type is an instance of class &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Datatype&quot;&gt;Datatype&lt;/a&gt;&lt;/code&gt;, which can be used to obtain the name of a datatype, the module it has been defined in, the package it is located under, and whether it has been defined using &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt; at the value level.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt; ('MetaData &quot;Tree&quot; &quot;Main&quot; &quot;package-name&quot; 'False)&lt;/code&gt; тег указывает на то, что прилагаемая часть является представление типа данных &lt;code&gt;Tree&lt;/code&gt; . Опять же, метаинформация кодируется на уровне типа. Тип &lt;code&gt;'MetaData&lt;/code&gt; - это экземпляр класса &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Datatype&quot;&gt;Datatype&lt;/a&gt;&lt;/code&gt; , который можно использовать для получения имени типа данных, модуля, в котором он был определен, пакета, в котором он расположен, и того, был ли он определен с использованием &lt;code&gt;data&lt;/code&gt; или &lt;code&gt;newtype&lt;/code&gt; в уровень стоимости.</target>
        </trans-unit>
        <trans-unit id="490133c0313c9ba8b7db7fbe7e0fe5b2bf18b53d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; class can be generalized to range over types of kind &lt;code&gt;k -&amp;gt; *&lt;/code&gt;, for any kind &lt;code&gt;k&lt;/code&gt;. To do so, derive a &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; instance with the &lt;code&gt;PolyKinds&lt;/code&gt; extension enabled. For example, the declaration</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; может быть обобщен на типы типа &lt;code&gt;k -&amp;gt; *&lt;/code&gt; для любого типа &lt;code&gt;k&lt;/code&gt; . Для этого &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; экземпляр Generic1 с &lt;code&gt;PolyKinds&lt;/code&gt; расширением PolyKinds . Например, объявление</target>
        </trans-unit>
        <trans-unit id="b51e7af78f64d86aed93f2c4d635092dabfbb762" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt; ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness
      'DecidedLazy)&lt;/code&gt; tag indicates several things. The &lt;code&gt;'Nothing&lt;/code&gt; indicates that there is no record field selector associated with this field of the constructor (if there were, it would have been marked &lt;code&gt;'Just
      &quot;recordName&quot;&lt;/code&gt; instead). The other types contain meta-information on the field's strictness:</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt; ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)&lt;/code&gt; Тег указывает несколько вещей. &lt;code&gt;'Nothing&lt;/code&gt; указует на то, что нет Селектора записи поля , связанного с этим полем конструктора (если бы это было бы отмечено &lt;code&gt;'Just &quot;recordName&quot;&lt;/code&gt; вместо этого). Остальные типы содержат метаинформацию о строгости поля:</target>
        </trans-unit>
        <trans-unit id="d0cdba7fd39b9182aef4d3fd8dd460a16d152145" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; типа.</target>
        </trans-unit>
        <trans-unit id="ccb84e64bf7ed15245460804350d5f1cb2e76cd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#t:CodingFailureMode&quot;&gt;CodingFailureMode&lt;/a&gt;&lt;/code&gt; is used to construct &lt;code&gt;&lt;a href=&quot;system-io#v:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt;s, and specifies how they handle illegal sequences.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#t:CodingFailureMode&quot;&gt;CodingFailureMode&lt;/a&gt;&lt;/code&gt; используется для построения &lt;code&gt;&lt;a href=&quot;system-io#v:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; s, и определяет , как они обрабатывают незаконные последовательности.</target>
        </trans-unit>
        <trans-unit id="71ec4fbd1cac8b401802c535c7f65214143acd87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt; operation reads all input on the given handle before returning it as a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and closing the handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787de66be7bec193d5479d5569e0c178f340123a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt; operation reads all input on the given handle before returning it as a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and closing the handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="755de46cccecfaefa5e6388cdeaf72d6ecd06136" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in a type onto integers. It is used primarily for array indexing (see the array package).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="727269e258ca0cc1f5b84b187e061106f48b55ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of a finite list of numbers.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; вычисляет произведение конечного списка чисел.</target>
        </trans-unit>
        <trans-unit id="29f4142ef18f41223155d901b10e8d9efcecd6fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of a finite list of numbers.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; вычисляет сумму конечного списка чисел.</target>
        </trans-unit>
        <trans-unit id="791089d56d61f4d3b56178eb7352f6df80bab567" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; принимает список троек и возвращает три списка, аналогично &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5514609ab8e7a4d1ade5d1bc201f6e65aae2801a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of the function applied to corresponding elements, analogous to &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb018b60fccf9ba007b71e9eb3d8a718941c0f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет три элемента, а также три списка, и возвращает список их точечной комбинации, аналогично &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="24f96e687e4620b9109ecaf114edba80a1baa66c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type encapsulates an optional value. A value of type &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; either contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt;), or it is empty (represented as &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;). Using &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is a good way to deal with errors or exceptional cases without resorting to drastic measures such as &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; инкапсулирует необязательное значение. Значение типа &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; либо содержит значение типа &lt;code&gt;a&lt;/code&gt; (представленное как &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; ), либо оно пустое (представлено как &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ). Использование &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; - хороший способ справиться с ошибками или исключительными случаями, не прибегая к таким радикальным мерам, как &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="266e593abd43191340f9b33fd8e15a10e0dc922a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type is also a monad. It is a simple kind of error monad, where all errors are represented by &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. A richer error monad can be built using the &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; - тоже монада. Это простая монада ошибок, в которой все ошибки представлены &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; . Более богатая монада ошибок может быть построена с &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; типа Either .</target>
        </trans-unit>
        <trans-unit id="b66270e05d2350973bd17982c61ae01a11e0a3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; class and the &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; и тип &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d90a8339ada736c69e4569a04518d30718bf0396" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; function is list difference (non-associative). In the result of &lt;code&gt;xs&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt;&lt;code&gt;ys&lt;/code&gt;, the first occurrence of each element of &lt;code&gt;ys&lt;/code&gt; in turn (if any) has been removed from &lt;code&gt;xs&lt;/code&gt;. Thus</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; - это разность списков (неассоциативная). В результате &lt;code&gt;xs&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; &lt;code&gt;ys&lt;/code&gt; первое вхождение каждого элемента &lt;code&gt;ys&lt;/code&gt; по очереди (если есть) было удалено из &lt;code&gt;xs&lt;/code&gt; . таким образом</target>
        </trans-unit>
        <trans-unit id="5f790bce52b575010739edf6cb02aa96c2885cb9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; function takes a predicate and two lists and returns the first list with the first occurrence of each element of the second list removed.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; принимает предикат и два списка и возвращает первый список с первым удаленным вхождением каждого элемента второго списка.</target>
        </trans-unit>
        <trans-unit id="a978c3a6eaa51a8f531e3682bd2d367abf6607ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; function drops the largest suffix of a list in which the given predicate holds for all elements. For example:</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; отбрасывает самый большой суффикс списка, в котором данный предикат выполняется для всех элементов. Например:</target>
        </trans-unit>
        <trans-unit id="109bdc9435b830725cf189c556de56387a5634f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given list which is equal (by &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) to the query element, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; возвращает индекс первого элемента в данном списке, который равен (на &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; ) элементу запроса, или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если такого элемента нет.</target>
        </trans-unit>
        <trans-unit id="fadb3e5498f5526f3f541154cc26a34805337369" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements equal to the query element, in ascending order.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; расширяет &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; , возвращая индексы всех элементов, равных элементу запроса, в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="6568db6f34d6f7a7bf8a446041bb3489740f3067" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a list and returns the first element in the list matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; принимает предикат и список и возвращает первый элемент в списке, соответствующий предикату, или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если такого элемента нет.</target>
        </trans-unit>
        <trans-unit id="4275cc9b36aa0e4769199e754686defa1594e4b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a list and returns the index of the first element in the list satisfying the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; принимает предикат и список и возвращает индекс первого элемента в списке, удовлетворяющего этому предикату, или &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если такого элемента нет.</target>
        </trans-unit>
        <trans-unit id="2f76c76695266af5e321e89b84f46bb9a822c35f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; расширяет &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; , возвращая индексы всех элементов, удовлетворяющих предикату, в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="305fac941a1cc5c29fd70cdde5362cbcac036635" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to drop.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; - это перегруженная версия &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; , которая принимает любое значение &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; в качестве количества удаляемых элементов.</target>
        </trans-unit>
        <trans-unit id="acf544a13e18ba4358a78c184967bf2f876a1aec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the index.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; - это перегруженная версия &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt; , который принимает любое &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; значение в качестве индекса.</target>
        </trans-unit>
        <trans-unit id="813efa98177dcd58489481e0cb89e0133d9e87e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of repetitions to make.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; - это перегруженная версия функции &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; , которая принимает любое значение &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; в качестве количества выполняемых повторений.</target>
        </trans-unit>
        <trans-unit id="d7d4ee3930a7434ca7c403b4565de9be9be21b9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the position at which to split.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; - это перегруженная версия &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; , которая принимает любое значение &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; в качестве позиции, в которой выполняется разделение.</target>
        </trans-unit>
        <trans-unit id="e4afafa2336fcae4601a2eaca8e96fec05a60b92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to take.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; - это перегруженная версия &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; , которая принимает любое значение &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; в качестве количества принимаемых элементов.</target>
        </trans-unit>
        <trans-unit id="f4f6a5e91131c42f6af8de505ab848b2b5f93891" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a list and returns a list of lists such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; принимает список и возвращает список списков, так что объединение результата равно аргументу. Более того, каждый подсписок в результате содержит только равные элементы. Например,</target>
        </trans-unit>
        <trans-unit id="d100c0bef6b2c8b32f44a08a7e7eacb8db8f8cbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34b65659a51ccdb8baad87c00cd32d74ef9d403b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; function returns all initial segments of the argument, shortest first. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; возвращает все начальные сегменты аргумента, сначала самые короткие. Например,</target>
        </trans-unit>
        <trans-unit id="144853d03169fd7769ada44b12eba567928f0591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; function takes the list intersection of two lists. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; принимает пересечение двух списков. Например,</target>
        </trans-unit>
        <trans-unit id="605c4315b576beab0a53cad6a48c3adba1b2f451" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия элемента &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abf262d8a1cc937359d5c3c8f6075d27f69eb8ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is contained, wholly and intact, anywhere within the second.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; принимает два списка и возвращает &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если первый список содержится целиком и без изменений где-нибудь во втором.</target>
        </trans-unit>
        <trans-unit id="88d273a08a3e06000e98c2629e1e60ff60ea1336" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a suffix of the second. The second list must be finite.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; принимает два списка и возвращает &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если первый список является суффиксом второго. Второй список должен быть конечным.</target>
        </trans-unit>
        <trans-unit id="551caf48474039991548fe9ddb64d72b72493414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a list, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу списка, передавая параметр накопления слева направо и возвращая окончательное значение этого аккумулятора вместе с новым списком.</target>
        </trans-unit>
        <trans-unit id="8de586ae79a455858fed3746ae4e38cd05c48c19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a list, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; ведет себя как комбинация &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; он применяет функцию к каждому элементу списка, передавая параметр накопления справа налево и возвращая окончательное значение этого аккумулятора вместе с новым списком.</target>
        </trans-unit>
        <trans-unit id="2391074ba068c80233175c59983a54b8066a4878" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:maximumBy&quot;&gt;maximumBy&lt;/a&gt;&lt;/code&gt; function takes a comparison function and a list and returns the greatest element of the list by the comparison function. The list must be finite and non-empty.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:maximumBy&quot;&gt;maximumBy&lt;/a&gt;&lt;/code&gt; принимает функцию сравнения и список и возвращает наибольший элемент списка функцией сравнения. Список должен быть конечным и непустым.</target>
        </trans-unit>
        <trans-unit id="cef47277c570e470c285b99dbd14acd85cf932dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:minimumBy&quot;&gt;minimumBy&lt;/a&gt;&lt;/code&gt; function takes a comparison function and a list and returns the least element of the list by the comparison function. The list must be finite and non-empty.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:minimumBy&quot;&gt;minimumBy&lt;/a&gt;&lt;/code&gt; принимает функцию сравнения и список и возвращает наименьший элемент списка функцией сравнения. Список должен быть конечным и непустым.</target>
        </trans-unit>
        <trans-unit id="057b661eee28e56248a47e5a122b7f8d64ae8148" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt;, except it uses a user-supplied equality predicate instead of the overloaded &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; ведет себя так же, как &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; , за исключением того, что в ней используется предикат равенства, предоставляемый пользователем, вместо перегруженной функции &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19f8893f6a607220120cf57b88c38b3c50e89e8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate a list and returns the pair of lists of elements which do and do not satisfy the predicate, respectively; i.e.,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; принимает предикат список и возвращает пару списков элементов, которые удовлетворяют и не удовлетворяют предикату, соответственно; т.е.</target>
        </trans-unit>
        <trans-unit id="2d853a061eb012af5ee71d94b4188db9e7e27bb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; function returns the list of all permutations of the argument.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; возвращает список всех перестановок аргумента.</target>
        </trans-unit>
        <trans-unit id="0d369bcd6ff7a16017fc81230836cb1e2c9c3d1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of a finite list of numbers.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; вычисляет произведение конечного списка чисел.</target>
        </trans-unit>
        <trans-unit id="7601896a58f38cef45cf3ec9dd3675ffa2b1f23a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function implements a stable sorting algorithm. It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; реализует стабильный алгоритм сортировки. Это частный случай &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; , который позволяет программисту предоставлять свою собственную функцию сравнения.</target>
        </trans-unit>
        <trans-unit id="c7da3570e28419be0578ffd1de4f0b1fde8e86aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f1f49bd6e008dde965696cc4f68b37f4c1c2ff6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; function returns the list of all subsequences of the argument.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; возвращает список всех подпоследовательностей аргумента.</target>
        </trans-unit>
        <trans-unit id="a6406e7e60d1afb305384d5af825ad223afd4d34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of a finite list of numbers.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; вычисляет сумму конечного списка чисел.</target>
        </trans-unit>
        <trans-unit id="26c98a67aa07a5febf23006c6463cf654a93d6a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its argument. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; перемещает строки и столбцы своего аргумента. Например,</target>
        </trans-unit>
        <trans-unit id="c88aa8ebb4d5e9ab3079fc636599897089099a45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is a `dual' to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;: while &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; reduces a list to a summary value, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a list from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the list or returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepended to the list and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; является двойной функцией &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; : в то время как &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; сокращает список до итогового значения, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; строит список из начального значения. Функция принимает элемент и возвращает &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если она завершила создание списка, или возвращает &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; , и в этом случае &lt;code&gt;a&lt;/code&gt; добавляется к списку, а &lt;code&gt;b&lt;/code&gt; используется как следующий элемент в рекурсивном вызове. Например,</target>
        </trans-unit>
        <trans-unit id="27a85700d4b6c91457baf0366be6c72427d177b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; function returns the list union of the two lists. For example,</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; возвращает объединение двух списков. Например,</target>
        </trans-unit>
        <trans-unit id="897e5cd71a34240e2a452fc04aada2f8a3873766" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; - это неперегруженная версия &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a213a220259b72a83d767902fd9b906a21d8991" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; принимает список троек и возвращает три списка, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9f131d892100da4fd025f7a8ecff18fd3436b21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; function takes a list of quadruples and returns four lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; берет список из четверок и возвращает четыре списка, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f19f192bc7bca3bb3b366a104a1495f29a2a94b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; function takes a list of five-tuples and returns five lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; принимает список из пяти кортежей и возвращает пять списков, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12f0884943983f42126b4d7235d7fee19d6961ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; function takes a list of six-tuples and returns six lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; принимает список из шести кортежей и возвращает шесть списков, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd0ada4ba254397c7f2074cd7fe54881a14745ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; function takes a list of seven-tuples and returns seven lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; принимает список из семи кортежей и возвращает семь списков, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0a0bedc800fc663f9a45123739d0871e9842832" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; function takes four lists and returns a list of quadruples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; принимает четыре списка и возвращает список из четырех элементов, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="b833eb65f6d996a715798ed453669aa9621f8431" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; function takes five lists and returns a list of five-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; принимает пять списков и возвращает список из пяти кортежей, аналогичный &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="59728e29b809276b20b7cc9ae48caadda444d7f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; function takes six lists and returns a list of six-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; принимает шесть списков и возвращает список из шести кортежей, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="df3589322d209e15f6610db4bb0c1c54692646e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; function takes seven lists and returns a list of seven-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; принимает семь списков и возвращает список из семи кортежей, аналогичный &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="ebe2dcade01df40ba8567bc29c6d76d5179227b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of the function applied to corresponding elements, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb675c3384f90b4e5fdef7383e6b1b6d07309c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет три элемента, а также три списка, и возвращает список их точечной комбинации, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="4d9d273ee2479cdb2c6b8ef0f65b15d495db5a7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; function takes a function which combines four elements, as well as four lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет четыре элемента, а также четыре списка и возвращает список их точечной комбинации, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="6aa1fdb5c348373284d6b8cfbe31c2976333f351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; function takes a function which combines five elements, as well as five lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет пять элементов, а также пять списков, и возвращает список их точечных комбинаций, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="5fd0df64a913d6523d2c136a1cb0ba65ca9434f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; function takes a function which combines six elements, as well as six lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет шесть элементов, а также шесть списков, и возвращает список их точечной комбинации, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="57fc99e0dcfb0d585978688443e7472a5b1473e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; function takes a function which combines seven elements, as well as seven lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет семь элементов, а также семь списков, и возвращает список их точечной комбинации, аналогично &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="b1325d57361ccc732ebb070de994b0a2421219c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; types and operations.</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; типы и операции.</target>
        </trans-unit>
        <trans-unit id="5763505508dac7b11615ee08a7acaba3fb632110" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; function casts a pointer from one type to another.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; переводит указатель от одного типа к другому.</target>
        </trans-unit>
        <trans-unit id="a500ee9d80b7f54eb7f8c916b79c09da04687f2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class and instances for basic data types.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; класс и примеры для основных типов данных.</target>
        </trans-unit>
        <trans-unit id="f5c958fd454a64dcb4c746fc275eb37dbbac1200" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; считывает одну лексему из ввода, отбрасывая начальные пробелы и возвращая символы, составляющие лексему. Если входная строка содержит только пробелы, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; возвращает единственную успешную `лексему ', состоящую из пустой строки. (Таким образом, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt; .) Если в начале входной строки нет допустимой лексемы, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; не работает (т.е. возвращает &lt;code&gt;[]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="86c3288ccf7776810d20b3731af2e3b40bfcb247" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; class, and related operations.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; и связанные с ним операции.</target>
        </trans-unit>
        <trans-unit id="9d5187961ae2687bea868b7eebea12a2b0fc9457" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; Monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; Монада.</target>
        </trans-unit>
        <trans-unit id="1a6e8251d60596b015e69b7b30aa3903c1d58def" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticKey&quot;&gt;StaticKey&lt;/a&gt;&lt;/code&gt; that can be used to look up the given &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticKey&quot;&gt;StaticKey&lt;/a&gt;&lt;/code&gt; , который может быть использован для просмотра данного &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7476e9e0f102360787454857433b298127a63a2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Quote&quot;&gt;Quote&lt;/a&gt;&lt;/code&gt; class implements the minimal interface which is necessary for desugaring quotations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed23a830eec8e95fb04719f3ba021e908eb49a47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; function lets you run an I/O computation in the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Take care: you are guaranteed the ordering of calls to &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; within a single &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; computation, but not about the order in which splices are run.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; позволяет выполнять вычисление ввода-вывода в монаде &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; .Будьте осторожны: вам гарантируется порядок вызовов &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; в рамках одного вычисления &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; , но не порядок, в котором выполняются соединения.</target>
        </trans-unit>
        <trans-unit id="fa005a185e418ee86a0f14b966d5bed4334ff0bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; type, a value &lt;code&gt;q&lt;/code&gt; of this type can be used in the syntax &lt;code&gt;[q| ... string to parse ...|]&lt;/code&gt;. In fact, for convenience, a &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; actually defines multiple quasiquoters to be used in different splice contexts; if you are only interested in defining a quasiquoter to be used for expressions, you would define a &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; with only &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#v:quoteExp&quot;&gt;quoteExp&lt;/a&gt;&lt;/code&gt;, and leave the other fields stubbed out with errors.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; , значение &lt;code&gt;q&lt;/code&gt; этого типа может использоваться в синтаксисе &lt;code&gt;[q| ... string to parse ...|]&lt;/code&gt; . Фактически, для удобства &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; фактически определяет несколько квазиквотеров, которые будут использоваться в разных контекстах монтажа; если вас интересует только определение квазиквотера, который будет использоваться для выражений, вы должны определить &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; только с &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#v:quoteExp&quot;&gt;quoteExp&lt;/a&gt;&lt;/code&gt; , а остальные поля оставить с ошибками.</target>
        </trans-unit>
        <trans-unit id="312071dde460138e1108547da6f4f1b6fb25ee33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Quote&quot;&gt;Quote&lt;/a&gt;&lt;/code&gt; class implements the minimal interface which is necessary for desugaring quotations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="822f6a374e5da6792e8281daef5bc8cbc52436fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; function lets you run an I/O computation in the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Take care: you are guaranteed the ordering of calls to &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; within a single &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; computation, but not about the order in which splices are run.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; позволяет выполнять вычисление ввода-вывода в монаде &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; .Будьте осторожны: вам гарантируется порядок вызовов &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; в рамках одного вычисления &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; , но не порядок, в котором выполняются соединения.</target>
        </trans-unit>
        <trans-unit id="8a0d53f38c6a950df5eadf21a9f9db4dfc69bf0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class is used to name the upper and lower limits of a type. &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is not a superclass of &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; since types that are not totally ordered may also have upper and lower bounds.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; используется для обозначения верхнего и нижнего пределов типа. &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; не является суперклассом &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; , поскольку типы, которые не являются полностью упорядоченными, могут также иметь верхнюю и нижнюю границы.</target>
        </trans-unit>
        <trans-unit id="bf58cbc6033627535675be41f7c5c26c9a969514" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class may be derived for any enumeration type; &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; is the first constructor listed in the &lt;code&gt;data&lt;/code&gt; declaration and &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; is the last. &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; may also be derived for single-constructor datatypes whose constituent types are in &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; может быть производным от любого типа перечисления; &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; - это первый конструктор, указанный в объявлении &lt;code&gt;data&lt;/code&gt; а &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; - последний. &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; также может быть получен для типов данных с одним конструктором, составляющие типы которых находятся в &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f24f4c3acddeb2d8485bbd7d048662ea4520e018" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type is sometimes used to represent a value which is either correct or an error; by convention, the &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor is used to hold an error value and the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor is used to hold a correct value (mnemonic: &quot;right&quot; also means &quot;correct&quot;).</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; иногда используется для представления значения, которое является правильным или ошибочным; по соглашению конструктор &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; используется для хранения значения ошибки, а конструктор &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; используется для хранения правильного значения (мнемоника: &amp;laquo;right&amp;raquo; также означает &amp;laquo;правильный&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="9d02c060c8f45391329e1f6687a2f0b6730500f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type represents values with two possibilities: a value of type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; представляет значения с двумя возможностями: значение типа &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; равно &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e44fd4d00d0795dea5f783f70db56faa6bffc024" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; class defines equality (&lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) and inequality (&lt;code&gt;&lt;a href=&quot;prelude#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt;). All the basic datatypes exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; are instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; may be derived for any datatype whose constituents are also instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; определяет равенство ( &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; ) и неравенство ( &lt;code&gt;&lt;a href=&quot;prelude#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt; ). Все основные типы данных, экспортируемые &lt;a href=&quot;prelude&quot;&gt;Prelude,&lt;/a&gt; являются экземплярами &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; может быть получено для любого типа данных, составные части которого также являются экземплярами &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75fb7e193c14639f9f2c840b46b6b678ecc93443" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type encapsulates an optional value. A value of type &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; either contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt;), or it is empty (represented as &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;). Using &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is a good way to deal with errors or exceptional cases without resorting to drastic measures such as &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; инкапсулирует необязательное значение. Значение типа &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; либо содержит значение типа &lt;code&gt;a&lt;/code&gt; (представленное как &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; ), либо оно пустое (представлено как &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ). Использование &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; - хороший способ справиться с ошибками или исключительными случаями, не прибегая к таким радикальным мерам, как &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d4644834b747ca6136ef2aaff7f66c325592783" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type is also a monad. It is a simple kind of error monad, where all errors are represented by &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. A richer error monad can be built using the &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; - тоже монада. Это простая монада ошибок, в которой все ошибки представлены &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; . Более богатая монада ошибок может быть построена с &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; типа Either .</target>
        </trans-unit>
        <trans-unit id="b2bc4ca3d8934e365fb80ceb2378eb5082b3a17f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; class defines the basic operations over a &lt;em&gt;monad&lt;/em&gt;, a concept from a branch of mathematics known as &lt;em&gt;category theory&lt;/em&gt;. From the perspective of a Haskell programmer, however, it is best to think of a monad as an &lt;em&gt;abstract datatype&lt;/em&gt; of actions. Haskell's &lt;code&gt;do&lt;/code&gt; expressions provide a convenient syntax for writing monadic expressions.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; определяет основные операции над &lt;em&gt;монадой&lt;/em&gt; - концепцию из раздела математики, известного как &lt;em&gt;теория категорий&lt;/em&gt; . Однако с точки зрения программиста на Haskell лучше всего рассматривать монаду как &lt;em&gt;абстрактный тип данных&lt;/em&gt; действий. Выражения &lt;code&gt;do&lt;/code&gt; в Haskell обеспечивают удобный синтаксис для написания монадических выражений.</target>
        </trans-unit>
        <trans-unit id="7aaef56b80f737eb27df9b1e3d02aefbb49c126c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; allows us to chain together multiple actions which may fail, and fail overall if any of the individual steps failed. First we'll write a function that can either parse an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, or fail.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; экземпляр для &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; позволяет связать между собой несколькими действиями , которые могут потерпеть неудачу, и не в целом , если какие - либо из отдельных шагов , не удалось. Сначала мы напишем функцию, которая может либо разбирать &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; из &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , либо терпеть неудачу.</target>
        </trans-unit>
        <trans-unit id="7b3a6ba7d1631eb7dffbc7a80d33a50655ec5cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class is used for totally ordered datatypes.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; используется для полностью упорядоченных типов данных.</target>
        </trans-unit>
        <trans-unit id="7fb9b92b465e420832be5f52da24e03070664a5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from our &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance will ignore &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values, but will apply the supplied function to values contained in a &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; из нашего &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; экземпляра будет игнорировать &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; значения, но будет применять указанную функцию к значениям , содержащимся в &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bb778616987d1ec9e7af8ce5c3a0fe1ad6f720c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; method restricted to the type &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Метод &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; ограничен типом &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdbf4d018722d263569f1a254868963b4ff029df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is read lazily as it is needed (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Операция &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; возвращает весь пользовательский ввод в виде одной строки, которая читается лениво по мере необходимости (то же самое, что и &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="15b8f72cef1878abf7fe3c9117a25867af1d77b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is read lazily as it is needed (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6a84a7de6790cd0de53c018c33b1487b75f830" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;String-&amp;gt;String&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; принимает в качестве аргумента функцию типа &lt;code&gt;String-&amp;gt;String&lt;/code&gt; . Весь ввод от стандартного устройства ввода передается этой функции в качестве аргумента, а результирующая строка выводится на стандартное устройство вывода.</target>
        </trans-unit>
        <trans-unit id="79b16f25ddf4b36594ea2e938465c9296ed38dc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; считывает одну лексему из ввода, отбрасывая начальные пробелы и возвращая символы, составляющие лексему. Если входная строка содержит только пробелы, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; возвращает единственную успешную `лексему ', состоящую из пустой строки. (Таким образом, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt; .) Если в начале входной строки нет допустимой лексемы, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; не работает (т.е. возвращает &lt;code&gt;[]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0e4582487867df9d645782b484418688a1f3f58c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; function takes a default value, a function, and a &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value is &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the function returns the default value. Otherwise, it applies the function to the value inside the &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and returns the result.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; функция принимает значение по умолчанию, функцию и &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; значение. Если значение &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; равно &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , функция возвращает значение по умолчанию. В противном случае он применяет функцию к значению внутри &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; и возвращает результат.</target>
        </trans-unit>
        <trans-unit id="c131692c2bade036458b0d1127914f219c7dd175" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function outputs a value of any printable type to the standard output device. Printable types are those that are instances of class &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; converts values to strings for output using the &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; operation and adds a newline.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; выводит значение любого печатаемого типа на стандартное устройство вывода. Печатные типы - это экземпляры класса &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; ; &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; преобразует значения в строки для вывода с помощью операции &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; и добавляет новую строку.</target>
        </trans-unit>
        <trans-unit id="8c7fc1c52a42ce0024aec6c65a38a9e6dc8fb7ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; вычисляет произведение номеров конструкции.</target>
        </trans-unit>
        <trans-unit id="f99911d99a3ef08fe8f375dba1db41c4eecf08d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function reads input from a string, which must be completely consumed by the input process. &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; fails with an &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the parse is unsuccessful, and it is therefore discouraged from being used in real applications. Use &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; for safe alternatives.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; считывает ввод из строки, которая должна быть полностью использована процессом ввода. &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; завершается неудачно с &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; если синтаксический анализ не удался, и поэтому не рекомендуется использовать его в реальных приложениях. Используйте &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; для безопасных альтернатив.</target>
        </trans-unit>
        <trans-unit id="4ffdc3ac1e36da7a1438f94612f331c6323f073b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; считывает файл и возвращает содержимое файла в виде строки. Файл читается лениво, по запросу, как и в случае с &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1edaaff10f2fbe79640944d7ec56cb49a4bed802" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; function is similar to &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; except that it signals parse failure to the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad instead of terminating the program.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; аналогична функции &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; за исключением того, что она сигнализирует монаде &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; об ошибке синтаксического анализа вместо завершения программы.</target>
        </trans-unit>
        <trans-unit id="9e25de194b180f1f5888a1fb8e989cb909435014" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; function combines &lt;code&gt;&lt;a href=&quot;prelude#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; объединяет &lt;code&gt;&lt;a href=&quot;prelude#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfe43d67eb01eceb873ed3fd660e71f0f5174638" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; вычисляет сумму номеров конструкции.</target>
        </trans-unit>
        <trans-unit id="bbb5313ec9e6c9e5650625c5d2da153e452b2504" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; method restricted to the type &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Метод &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; ограничен типом &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a04819fa78c89f5452b8780304a58025b2a647c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;prelude#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; принимает список троек и возвращает три списка, аналогично &lt;code&gt;&lt;a href=&quot;prelude#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="164c0899882615aec29723262627c2283ba64928" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of the function applied to corresponding elements, analogous to &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052c2b73f585f4387bcfea6e35542d389d49e8f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет три элемента, а также три списка и возвращает список их точечных комбинаций, аналогично &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; . Он поддерживает объединение списков, но ограничен первым аргументом списка и его результирующим списком.</target>
        </trans-unit>
        <trans-unit id="645f48f9edaa9bdfcdbd50f2978b6ca7c976e666" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;getConsoleCP&lt;/code&gt;.</source>
          <target state="translated">Функции &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; вывода (например, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; ) не преобразуются автоматически в Unicode, поэтому эта функция предназначена для преобразования многобайтовой строки в данной кодовой странице в правильную строку Unicode. Чтобы получить кодовую страницу для консоли, используйте &lt;code&gt;getConsoleCP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d9c12dfa8f43bbbd8a126756fa99035e9751842" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;getConsoleCP&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e61834da932da0adacdc02d3dfdbd2e02c1903" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;getConsoleCP&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9915513312e5b9714f0fe4288381e0da0f72704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:InputT&quot;&gt;InputT&lt;/a&gt;&lt;/code&gt; monad transformer provides direct, low-level access to the user's line history state.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:InputT&quot;&gt;InputT&lt;/a&gt;&lt;/code&gt; монада трансформатор обеспечивает прямой, низкоуровневый доступ к архивному состоянию линии пользователя.</target>
        </trans-unit>
        <trans-unit id="77b115021e101641ef1f81dd36bd9d5f8a21f7b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:controlIO&quot;&gt;controlIO&lt;/a&gt;&lt;/code&gt; method enables us to &quot;lift&quot; a function that manages IO actions (such as &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;) into a function that wraps arbitrary monadic actions.</source>
          <target state="translated">Метод &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:controlIO&quot;&gt;controlIO&lt;/a&gt;&lt;/code&gt; позволяет нам &amp;laquo;поднять&amp;raquo; функцию, которая управляет действиями ввода-вывода (такими как &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; ), в функцию, которая обертывает произвольные монадические действия.</target>
        </trans-unit>
        <trans-unit id="d97760ad46f0a47182108cce3dd3552c71ffced8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; monoid abstracts away all padding and control sequence output. Unfortunately, that datatype is difficult to integrate into existing &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;-based APIs such as pretty-printers. Thus, as a workaround, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; also lets us access the control sequences as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The one caveat is that it will not allow you to access padded control sequences as Strings. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; Моноид абстрагирует все отступы и управления выходной последовательности. К сожалению, этот тип данных сложно интегрировать в существующие API-интерфейсы на основе &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , такие как pretty-printers. Таким образом, в качестве обходного пути &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; также позволяет нам получать доступ к управляющим последовательностям как &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; s. Единственное предостережение заключается в том, что он не позволит вам получить доступ к дополненным управляющим последовательностям как к строкам. Например:</target>
        </trans-unit>
        <trans-unit id="aa804a6c1292fd02b3dfa80191cff02ea40114ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; monoid abstracts away all padding and control sequence output. Unfortunately, that datatype is difficult to integrate into existing &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;-based APIs such as pretty-printers. Thus, as a workaround, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; also lets us access the control sequences as &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The one caveat is that it will not allow you to access padded control sequences as Strings. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9841931aa367ad9ec0fec011cdda76359ac86c24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; monoid abstracts away all padding and control sequence output. Unfortunately, that datatype is difficult to integrate into existing &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;-based APIs such as pretty-printers. Thus, as a workaround, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; also lets us access the control sequences as &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The one caveat is that it will not allow you to access padded control sequences as Strings. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ff1172a4964334b38f0ed53fd5acdd80ad6655a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-cputime#v:cpuTimePrecision&quot;&gt;cpuTimePrecision&lt;/a&gt;&lt;/code&gt; constant is the smallest measurable difference in CPU time that the implementation can record, and is given as an integral number of picoseconds.</source>
          <target state="translated">Константа &lt;code&gt;&lt;a href=&quot;system-cputime#v:cpuTimePrecision&quot;&gt;cpuTimePrecision&lt;/a&gt;&lt;/code&gt; - это наименьшая измеримая разница во времени ЦП, которую может записать реализация, и выражается в виде целого числа пикосекунд.</target>
        </trans-unit>
        <trans-unit id="d42c1bb360791782c56c45d321fb837bc1ed609e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; type is used to record whether certain operations are permissible on a file/directory. &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; get and set these permissions, respectively. Permissions apply both to files and directories. For directories, the executable field will be &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, and for files the searchable field will be &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;. Note that directories may be searchable without being readable, if permission has been given to use them as part of a path, but not to examine the directory contents.</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; используется для записи, разрешены ли определенные операции с файлом / каталогом. &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; получают и устанавливают эти разрешения соответственно. Разрешения применяются как к файлам, так и к каталогам. Для каталогов поле исполняемого файла будет &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; , а для файлов доступное для поиска поле будет &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что каталоги могут быть доступны для поиска без возможности чтения, если было дано разрешение использовать их как часть пути, но не для проверки содержимого каталога.</target>
        </trans-unit>
        <trans-unit id="4d69896f050cda9242fbd0b11650fb1d4798c283" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; type is used to record whether certain operations are permissible on a file/directory. &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; get and set these permissions, respectively. Permissions apply both to files and directories. For directories, the executable field will be &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, and for files the searchable field will be &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;. Note that directories may be searchable without being readable, if permission has been given to use them as part of a path, but not to examine the directory contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b34c5c4fafcde21f795d5b394e5bb5a6d86701" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; type is used to record whether certain operations are permissible on a file/directory. &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; get and set these permissions, respectively. Permissions apply both to files and directories. For directories, the executable field will be &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, and for files the searchable field will be &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;. Note that directories may be searchable without being readable, if permission has been given to use them as part of a path, but not to examine the directory contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7fb38ca78261525df1464df4fb698278b8051df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; принимает список значений &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; и возвращает список всех значений &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c024b37fca52e47d642918b547e5abf37fb3fa6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7508fdaba8c4fef16bb54aaa518032f06b07a40c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9dec7d9cce3f521b0de7412db5964162658ad1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; function establishes a handler that receives any &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; raised in the action protected by &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; is caught by the most recent handler established by one of the exception handling functions. These handlers are not selective: all &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s are caught. Exception propagation must be explicitly provided in a handler by re-raising any unwanted exceptions. For example, in</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; функция устанавливает обработчик , который получает любой &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; поднятым в действии , защищенное &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; поймана сам последним обработчик , установленного одним из обработки исключений функций. Эти обработчики не избирательны: перехватываются все &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; . Распространение исключения должно быть явно указано в обработчике путем повторного создания любых нежелательных исключений. Например, в</target>
        </trans-unit>
        <trans-unit id="6f3b229367a29bd9496f06fab85e58716c437cd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default value; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff85ed75d901b4d2c7aa0d2761fd28a6697d0178" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default values; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; принимает значение по умолчанию и значение &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; . Если &amp;laquo; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; равно &amp;laquo; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , он возвращает значения по умолчанию; в противном случае возвращается значение, содержащееся в поле &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9769cc1036b71fdb3662c8da0daae0ce7bf97a68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default values; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7eae4b2c5061e05af7d962b180cd3821808d93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; возвращает пустой список, если задано &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , или одноэлементный список, если задано &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fbaf05deefa3d41622751d07a352a608fb45d85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98dbef89b986d97360e7b13124294962d761670e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0aa3120b7fd0765f6ac196cefe19e035c54f08e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is read lazily as it is needed (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Операция &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; возвращает весь пользовательский ввод в виде одной строки, которая читается лениво по мере необходимости (то же самое, что и &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9903da760704cfbe9ebaf26276c9f6d1fe29b948" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:getContents-39-&quot;&gt;getContents'&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is fully read before being returned (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1624a7bf77b1533080ced7e88bbdc61480bcdf9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt; operation reads all input on the given handle before returning it as a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and closing the handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49101be718bf6fa482ea1ac280c8c3978edbdc76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;String-&amp;gt;String&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; принимает в качестве аргумента функцию типа &lt;code&gt;String-&amp;gt;String&lt;/code&gt; . Весь ввод от стандартного устройства ввода передается этой функции в качестве аргумента, а результирующая строка выводится на стандартное устройство вывода.</target>
        </trans-unit>
        <trans-unit id="c28c31ff8d6196f0cd154601474e1e3b9b58f9bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function outputs a value of any printable type to the standard output device. Printable types are those that are instances of class &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; converts values to strings for output using the &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; operation and adds a newline.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; выводит значение любого печатаемого типа на стандартное устройство вывода. Печатные типы - это экземпляры класса &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; ; &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; преобразует значения в строки для вывода с помощью операции &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; и добавляет новую строку.</target>
        </trans-unit>
        <trans-unit id="825ef90fdaca88a42de4c139d5e6c64085f34a5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; считывает файл и возвращает содержимое файла в виде строки. Файл читается лениво, по запросу, как и в случае с &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a31c1b6bd7ac14eeefe46c3d60ed2cc1bc11f6d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readFile-39-&quot;&gt;readFile'&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The file is fully read before being returned, as with &lt;code&gt;&lt;a href=&quot;system-io#v:getContents-39-&quot;&gt;getContents'&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c55ec6a3320441e71baa3c7cddc99bb5586ab05b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; function is similar to &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; except that it signals parse failure to the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad instead of terminating the program.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; аналогична функции &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; за исключением того, что она сигнализирует монаде &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; об ошибке синтаксического анализа вместо завершения программы.</target>
        </trans-unit>
        <trans-unit id="892d5a8616ddf159523b449a487e6243305ef9c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; function combines &lt;code&gt;&lt;a href=&quot;system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-io#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; объединяет &lt;code&gt;&lt;a href=&quot;system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f01cd96e2bf006a175917ef728b5ef21ad4ad33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; function establishes a handler that receives any &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; raised in the action protected by &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; is caught by the most recent handler established by one of the exception handling functions. These handlers are not selective: all &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s are caught. Exception propagation must be explicitly provided in a handler by re-raising any unwanted exceptions. For example, in</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; функция устанавливает обработчик , который получает любой &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; поднятым в действии , защищенное &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; поймана сам последним обработчик , установленного одним из обработки исключений функций. Эти обработчики не избирательны: перехватываются все &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; . Распространение исключения должно быть явно указано в обработчике путем повторного создания любых нежелательных исключений. Например, в</target>
        </trans-unit>
        <trans-unit id="8e2935b648dbc65061463e0e0bc3ae9bc38731b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:clearEnv&quot;&gt;clearEnv&lt;/a&gt;&lt;/code&gt; function clears the environment of all name-value pairs.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-posix-env#v:clearEnv&quot;&gt;clearEnv&lt;/a&gt;&lt;/code&gt; очищает среду от всех пар имя-значение.</target>
        </trans-unit>
        <trans-unit id="369194824dad3c17becd69feafce80094511a779" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; function inserts or resets the environment variable name in the current environment list. If the variable &lt;code&gt;name&lt;/code&gt; does not exist in the list, it is inserted with the given value. If the variable does exist, the argument &lt;code&gt;overwrite&lt;/code&gt; is tested; if &lt;code&gt;overwrite&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the variable is not reset, otherwise it is reset to the given value.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-posix-env#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; вставляет или сбрасывает имя переменной среды в текущий список среды. Если &lt;code&gt;name&lt;/code&gt; переменной не существует в списке, оно вставляется с заданным значением. Если переменная действительно существует, проверяется &lt;code&gt;overwrite&lt;/code&gt; аргумента ; если &lt;code&gt;overwrite&lt;/code&gt; - &lt;code&gt;False&lt;/code&gt; , переменная не сбрасывается, в противном случае она сбрасывается до заданного значения.</target>
        </trans-unit>
        <trans-unit id="e16fdd3c2060c8b0e7dcb0de6c67a978ff67d1fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; function deletes all instances of the variable name from the environment.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-posix-env#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; удаляет все экземпляры имени переменной из среды.</target>
        </trans-unit>
        <trans-unit id="6390faf5740aef6b3fe69f665e1639661b490c68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; function inserts or resets the environment variable name in the current environment list. If the variable &lt;code&gt;name&lt;/code&gt; does not exist in the list, it is inserted with the given value. If the variable does exist, the argument &lt;code&gt;overwrite&lt;/code&gt; is tested; if &lt;code&gt;overwrite&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the variable is not reset, otherwise it is reset to the given value.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; вставляет или сбрасывает имя переменной среды в текущий список среды. Если &lt;code&gt;name&lt;/code&gt; переменной не существует в списке, оно вставляется с заданным значением. Если переменная действительно существует, проверяется &lt;code&gt;overwrite&lt;/code&gt; аргумента ; если &lt;code&gt;overwrite&lt;/code&gt; - &lt;code&gt;False&lt;/code&gt; , переменная не сбрасывается, в противном случае она сбрасывается до заданного значения.</target>
        </trans-unit>
        <trans-unit id="908e9623e5b8e5381ae3293c89d2d6a40a5a4714" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; function deletes all instances of the variable name from the environment.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; удаляет все экземпляры имени переменной из среды.</target>
        </trans-unit>
        <trans-unit id="236f78121c4a2f2bf7b4a76db19e5a7170bc2449" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-io#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; function creates a pair of connected file descriptors. The first component is the fd to read from, the second is the write end. Although pipes may be bidirectional, this behaviour is not portable and programmers should use two separate pipes for this purpose. May throw an exception if this is an invalid descriptor.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-posix-io#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; создает пару связанных файловых дескрипторов. Первый компонент - это fd для чтения, второй - конец записи. Хотя каналы могут быть двунаправленными, такое поведение непереносимо, и программисты должны использовать для этой цели два отдельных канала. Может вызвать исключение, если это недопустимый дескриптор.</target>
        </trans-unit>
        <trans-unit id="d4b473f0667d5a6b55f733ab3a3194586555807c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; function creates a pair of connected file descriptors. The first component is the fd to read from, the second is the write end. Although pipes may be bidirectional, this behaviour is not portable and programmers should use two separate pipes for this purpose. May throw an exception if this is an invalid descriptor.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; создает пару связанных файловых дескрипторов. Первый компонент - это fd для чтения, второй - конец записи. Хотя каналы могут быть двунаправленными, такое поведение непереносимо, и программисты должны использовать для этой цели два отдельных канала. Может вызвать исключение, если это недопустимый дескриптор.</target>
        </trans-unit>
        <trans-unit id="50694ec6aab0913f0db1bc83f6e0ed0aed5dd7e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-printf#t:HPrintfType&quot;&gt;HPrintfType&lt;/a&gt;&lt;/code&gt; class provides the variable argument magic for &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;. Its implementation is intentionally not visible from this module.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;text-printf#t:HPrintfType&quot;&gt;HPrintfType&lt;/a&gt;&lt;/code&gt; предоставляет магию переменных аргументов для &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; . Его реализация намеренно не видна из этого модуля.</target>
        </trans-unit>
        <trans-unit id="290847fe4ef7b4c780f17cc14317e4a804018f65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; class provides the variable argument magic for &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;. Its implementation is intentionally not visible from this module. If you attempt to pass an argument of a type which is not an instance of this class to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;, then the compiler will report it as a missing instance of &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Класс &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; предоставляет магию переменных аргументов для &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; . Его реализация намеренно не видна из этого модуля. Если вы попытаетесь передать аргумент типа, который не является экземпляром этого класса, в &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; , то компилятор сообщит об этом как об отсутствующем экземпляре &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bde3b6deb5751130f8fa9aed7708139a05904e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; считывает одну лексему из ввода, отбрасывая начальные пробелы и возвращая символы, составляющие лексему. Если входная строка содержит только пробелы, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; возвращает единственную успешную `лексему ', состоящую из пустой строки. (Таким образом, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt; .) Если в начале входной строки нет допустимой лексемы, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; не работает (т.е. возвращает &lt;code&gt;[]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1a9d5cf956b4aeb4977bd49b0f7c6321ffb9b927" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function reads input from a string, which must be completely consumed by the input process. &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; fails with an &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the parse is unsuccessful, and it is therefore discouraged from being used in real applications. Use &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; for safe alternatives.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; считывает ввод из строки, которая должна быть полностью использована процессом ввода. &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; завершается неудачно с &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; если синтаксический анализ не удался, и поэтому не рекомендуется использовать его в реальных приложениях. Используйте &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; для безопасных альтернатив.</target>
        </trans-unit>
        <trans-unit id="7c81f5117934d868bf2254238529c0a48b7fea08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;em&gt;k&lt;/em&gt;&lt;/code&gt; argument controls how many test rounds are performed for determining a &lt;em&gt;probable prime&lt;/em&gt;. For more details, see &lt;a href=&quot;http://gmplib.org/manual/Number-Theoretic-Functions.html#index-mpz_005fprobab_005fprime_005fp-360&quot;&gt;GMP documentation for `mpz_probab_prime_p()`&lt;/a&gt;.</source>
          <target state="translated">В &lt;code&gt;&lt;em&gt;k&lt;/em&gt;&lt;/code&gt; контролирует аргумент , сколько тестовых раундов выполняются для определения &lt;em&gt;вероятного премьера&lt;/em&gt; . Дополнительные сведения см. В &lt;a href=&quot;http://gmplib.org/manual/Number-Theoretic-Functions.html#index-mpz_005fprobab_005fprime_005fp-360&quot;&gt;документации GMP для mpz_probab_prime_p ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bad337d10fc64d5b2ff3dbc6f2bf484df6cb613c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BigNat&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;BigNat&lt;/code&gt; типа</target>
        </trans-unit>
        <trans-unit id="b24b400b6bb089abd37b81edfb22c9c44a5b28fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Bits&lt;/code&gt; class does not have a &lt;code&gt;Num&lt;/code&gt; superclass. It therefore does not have default methods for the &lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;testBit&lt;/code&gt; and &lt;code&gt;popCount&lt;/code&gt; methods.</source>
          <target state="translated">Класс &lt;code&gt;Bits&lt;/code&gt; не имеет суперкласса &lt;code&gt;Num&lt;/code&gt; . Поэтому у него нет методов по умолчанию для методов &lt;code&gt;bit&lt;/code&gt; , &lt;code&gt;testBit&lt;/code&gt; и &lt;code&gt;popCount&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7585bf1c302df16ed91051c8a55f49dac7f27c55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ByteString&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;ByteString&lt;/code&gt; типа</target>
        </trans-unit>
        <trans-unit id="a4cb78819e2dcf3b038b0fa6fa29d124f961d0aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ByteString&lt;/code&gt; type and representation</source>
          <target state="translated">&lt;code&gt;ByteString&lt;/code&gt; типа и представление</target>
        </trans-unit>
        <trans-unit id="005e2bda030ee8e32664f998432e3befbee14062" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CApiFFI&lt;/code&gt; extension allows a calling convention of &lt;code&gt;capi&lt;/code&gt; to be used in foreign declarations, e.g.</source>
          <target state="translated">Расширение &lt;code&gt;CApiFFI&lt;/code&gt; позволяет использовать соглашение о вызовах &lt;code&gt;capi&lt;/code&gt; во внешних объявлениях, например</target>
        </trans-unit>
        <trans-unit id="13b7284405381c1e383cd0d0249cafb8eb623b0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COMPLETE&lt;/code&gt; pragma is used to inform the pattern match checker that a certain set of patterns is complete and that any function which matches on all the specified patterns is total.</source>
          <target state="translated">&lt;code&gt;COMPLETE&lt;/code&gt; прагма используется для информирования проверки соответствия шаблона, определенный набор шаблонов является полным , и что любая функция , которая соответствует по всем заданным шаблонам тотально.</target>
        </trans-unit>
        <trans-unit id="97ba5a1df665f08e5746afd5258e9f9bc0483c65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CallStack&lt;/code&gt; will only extend as far as the types allow it, for example</source>
          <target state="translated">&lt;code&gt;CallStack&lt;/code&gt; будет только распространяться, насколько типы позволяют, например ,</target>
        </trans-unit>
        <trans-unit id="b22faafc676f89394f33e91663ca60cabb6bc4b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Chan&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Chan&lt;/code&gt; типа</target>
        </trans-unit>
        <trans-unit id="d49e2d29e0d016b816ecb90ca81622c4424ea99a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Coercible&lt;/code&gt; machinery works with unlifted newtypes just like it does with lifted types. In either of the equivalent formulations of &lt;code&gt;A&lt;/code&gt; given above, users would additionally have access to a coercion between &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56868895505567b8dd6fa6c19b6bf5118c82d7d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DOCTYPE&lt;/code&gt; for XHTML 1.0 Strict.</source>
          <target state="translated">&lt;code&gt;DOCTYPE&lt;/code&gt; для XHTML 1.0 Strict.</target>
        </trans-unit>
        <trans-unit id="ffc2f173105c8fb1fcbdf98a1d298ce5e8bba858" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dynamic&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Dynamic&lt;/code&gt; тип</target>
        </trans-unit>
        <trans-unit id="2f473b66e396d89af61f465962bc064a789e33d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorT&lt;/code&gt; Monad structure is parameterized over two things:</source>
          <target state="translated">Структура &lt;code&gt;ErrorT&lt;/code&gt; Monad параметризуется по двум параметрам:</target>
        </trans-unit>
        <trans-unit id="f105cba62162d63271c49af7cd9cd8361ee2895b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FOO.hp&lt;/code&gt; file produced when you ask for the heap profile of a program &lt;code&gt;FOO&lt;/code&gt; is a text file with a particularly simple structure. Here&amp;rsquo;s a representative example, with much of the actual data omitted:</source>
          <target state="translated">&lt;code&gt;FOO.hp&lt;/code&gt; файл , созданный при запросе профиля кучного программного &lt;code&gt;FOO&lt;/code&gt; представляет собой текстовый файл с особенно простой структурой. Вот типичный пример, в котором большая часть фактических данных опущена:</target>
        </trans-unit>
        <trans-unit id="141ca8f382c40e251a5df604ac774ed0428d094e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FieldName&lt;/code&gt; is open-ended, but typically it should contain the producing package name, along with the actual field name. Then, the version number can either be attached to the serialised data for that field, or in cases where multiple versions of a field could exist in the same interface file, included in the field name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04db3a4ce85cd545b2791b532c1d65a006beea18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foldable&lt;/code&gt; class makes it possible to use idioms familiar from the List type with container structures that are better suited to the task at hand. This allows a user to substitute more appropriate &lt;code&gt;Foldable&lt;/code&gt; data types for Lists without requiring new idioms (see &lt;a href=&quot;#uselistsnot&quot;&gt;[1]&lt;/a&gt; for when not to use lists).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46bbc9453d0aa157f0a481b32f1e12742cfde543" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foldable&lt;/code&gt; instance should be defined in a manner that avoids construction of an unnecesary copy of the container.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3310324645be48c511e536603b07bcff55b712f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foldable&lt;/code&gt; method &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; and its flipped version &lt;code&gt;&lt;a href=&quot;data-foldable#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; can be used to sequence IO actions over all the elements of a &lt;code&gt;Traversable&lt;/code&gt; container (just for their side-effects, ignoring any results) . One special case is a &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; container that optionally holds a value. Given:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48feef81fcfb630b464ad6ce416e6ee040c4f208" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foo @k a = a&lt;/code&gt; equation would be represented as follows:</source>
          <target state="translated">Уравнение &lt;code&gt;Foo @k a = a&lt;/code&gt; можно представить следующим образом:</target>
        </trans-unit>
        <trans-unit id="4c4c7a176e62f2d3f87095896756c7aad5096548" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foo_stub.h&lt;/code&gt; file can be redirected using the &lt;code&gt;-stubdir&lt;/code&gt; option; see &lt;a href=&quot;../separate_compilation#options-output&quot;&gt;Redirecting the compilation output(s)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c992f175532ed7a0887c33f484f4c4856a6f5c50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foo_stub.h&lt;/code&gt; file can be redirected using the &lt;code&gt;-stubdir&lt;/code&gt; option; see &lt;a href=&quot;separate_compilation#options-output&quot;&gt;Redirecting the compilation output(s)&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Foo_stub.h&lt;/code&gt; файл может быть перенаправлен с помощью &lt;code&gt;-stubdir&lt;/code&gt; опции; см. &lt;a href=&quot;separate_compilation#options-output&quot;&gt;Перенаправление выходных данных компиляции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc9f316a3a267a4b9984d1222e0ad9feb74bf869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; environment variable may be set to a &lt;code&gt;:&lt;/code&gt;-separated (&lt;code&gt;;&lt;/code&gt;-separated on Windows) list of files containing package databases. This list of package databases, used by GHC and ghc-pkg, specifies a stack of package databases from top to bottom. This order was chosen to match the behaviour of the &lt;code id=&quot;index-5&quot;&gt;PATH&lt;/code&gt; environment variable where entries earlier in the PATH override ones that come later. See &lt;a href=&quot;#package-databases&quot;&gt;Package Databases&lt;/a&gt; for details on how the package database stack is used.</source>
          <target state="translated">&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; переменная окружения может быть установлен на &lt;code&gt;:&lt;/code&gt; -разделенное ( &lt;code&gt;;&lt;/code&gt; -разделенное на Windows) список файлов , содержащих базы данных пакетов. Этот список баз данных пакетов, используемый GHC и ghc-pkg, определяет стек баз данных пакетов сверху вниз. Этот порядок был выбран для соответствия поведению &lt;code id=&quot;index-5&quot;&gt;PATH&lt;/code&gt; среды PATH, где предыдущие записи в PATH переопределяют те, которые поступают позже. См. В разделе &lt;a href=&quot;#package-databases&quot;&gt;Базы данных пакетов&lt;/a&gt; подробные сведения об использовании стека базы данных пакетов.</target>
        </trans-unit>
        <trans-unit id="f21fc75056d50350516dd52ff5912c872b8b9460" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GenLanguageDef&lt;/code&gt; type is a record that contains all parameterizable features of the &lt;a href=&quot;text-parsec-token&quot;&gt;Text.Parsec.Token&lt;/a&gt; module. The module &lt;a href=&quot;text-parsec-language&quot;&gt;Text.Parsec.Language&lt;/a&gt; contains some default definitions.</source>
          <target state="translated">Тип &lt;code&gt;GenLanguageDef&lt;/code&gt; - это запись, содержащая все параметризуемые функции модуля &lt;a href=&quot;text-parsec-token&quot;&gt;Text.Parsec.Token&lt;/a&gt; . Модуль &lt;a href=&quot;text-parsec-language&quot;&gt;Text.Parsec.Language&lt;/a&gt; содержит некоторые определения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="c4e050756130eeb11c58b31896ace2ae245341ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Generic1&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;Generic1&lt;/code&gt; класс</target>
        </trans-unit>
        <trans-unit id="b121f20d20404180364bfd43491c63f4245f97f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Generic&lt;/code&gt; and &lt;code&gt;Generic1&lt;/code&gt; classes mediate between user-defined datatypes and their internal representation as a sum-of-products:</source>
          <target state="translated">В &lt;code&gt;Generic&lt;/code&gt; и &lt;code&gt;Generic1&lt;/code&gt; классов посредничать между определенным пользователем типами данными и их внутренним представлением в виде сумм из продуктов:</target>
        </trans-unit>
        <trans-unit id="7c04d22bf6198b566fefab29ee20c196be128ca5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HSfoo.o&lt;/code&gt; file is built by Cabal automatically; use &lt;code&gt;--disable-library-for-ghci&lt;/code&gt; to disable it. To build one manually, the following GNU &lt;code&gt;ld&lt;/code&gt; command can be used:</source>
          <target state="translated">&lt;code&gt;HSfoo.o&lt;/code&gt; файл построен заговорщиков автоматически; используйте &lt;code&gt;--disable-library-for-ghci&lt;/code&gt; , чтобы отключить его. Чтобы создать его вручную, можно использовать следующую команду GNU &lt;code&gt;ld&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4504a638df2b2b4639ba03e3b6d8a72cdcb6adda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INCLUDE&lt;/code&gt; used to be necessary for specifying header files to be included when using the FFI and compiling via C. It is no longer required for GHC, but is accepted (and ignored) for compatibility with other compilers.</source>
          <target state="translated">&lt;code&gt;INCLUDE&lt;/code&gt; раньше необходимо для указания файлов заголовков , которые будут включены при использовании FFI и не компиляции через C. Это больше не требуется для GHC, но принимается (и игнорируется) для совместимости с другими компиляторами.</target>
        </trans-unit>
        <trans-unit id="7e15878bd48bab3818efd590996e87053049c312" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INLINABLE&lt;/code&gt; pragma also works with &lt;code&gt;SPECIALISE&lt;/code&gt;: if you mark function &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;INLINABLE&lt;/code&gt;, then you can subsequently &lt;code&gt;SPECIALISE&lt;/code&gt; in another module (see &lt;a href=&quot;#specialize-pragma&quot;&gt;SPECIALIZE pragma&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;INLINABLE&lt;/code&gt; Прагма также работает с &lt;code&gt;SPECIALISE&lt;/code&gt; : если пометить функцию &lt;code&gt;f&lt;/code&gt; как &lt;code&gt;INLINABLE&lt;/code&gt; , то вы можете впоследствии &lt;code&gt;SPECIALISE&lt;/code&gt; в другом модуле (см &lt;a href=&quot;#specialize-pragma&quot;&gt;специализироваться Прагма&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b36c40931e360e8d5c5cef07a830cd7b25a1fd89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ImportQualifiedPost&lt;/code&gt; extension allows &lt;code&gt;qualified&lt;/code&gt; to appear in postpositive position : &lt;code&gt;import M qualified&lt;/code&gt;. With this extension enabled, one can write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="011dae688b0bf1afe030126194f5bf145fe1f133" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Int&lt;/code&gt; may well fix &lt;code&gt;b&lt;/code&gt; at the call site, so that signature should not be rejected. Moreover, the dependencies might be hidden. Consider</source>
          <target state="translated">&lt;code&gt;Int&lt;/code&gt; также может зафиксировать &lt;code&gt;b&lt;/code&gt; на месте вызова, так что подпись не должна быть отклонена. Более того, зависимости могут быть скрыты. Рассматривать</target>
        </trans-unit>
        <trans-unit id="be48930496202a998883fb4cafb1527204c88628" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Integer&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Integer&lt;/code&gt; тип</target>
        </trans-unit>
        <trans-unit id="fd53ccf97b4fdfd6c001e2465d556a7f859dcf35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IsList&lt;/code&gt; class and its methods are intended to be used in conjunction with the &lt;code&gt;OverloadedLists&lt;/code&gt; extension.</source>
          <target state="translated">Класс &lt;code&gt;IsList&lt;/code&gt; и его методы предназначены для использования вместе с расширением &lt;code&gt;OverloadedLists&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8673f7079a0b5c433c928ec58cc5f380461b598a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ix&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;Ix&lt;/code&gt; класс</target>
        </trans-unit>
        <trans-unit id="ef3790360f91e6f1db9d6be90c644fd246da75d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ix&lt;/code&gt; class and operations</source>
          <target state="translated">Класс &lt;code&gt;Ix&lt;/code&gt; и операции</target>
        </trans-unit>
        <trans-unit id="10c3ff8e25753aa68617bfab48822621de668249" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Just Refl&lt;/code&gt; case in &lt;code&gt;step2&lt;/code&gt; is inaccessible, because in order for &lt;code&gt;checkTEQ&lt;/code&gt; to be able to produce a &lt;code&gt;Just&lt;/code&gt;, &lt;code&gt;t ~ u&lt;/code&gt; must hold, but since we&amp;rsquo;re passing &lt;code&gt;Foo1&lt;/code&gt; and &lt;code&gt;Foo2&lt;/code&gt; here, it follows that &lt;code&gt;t ~
Char&lt;/code&gt;, and &lt;code&gt;u ~ Int&lt;/code&gt;, and thus &lt;code&gt;t ~ u&lt;/code&gt; cannot hold.</source>
          <target state="translated">&lt;code&gt;Just Refl&lt;/code&gt; случай &lt;code&gt;step2&lt;/code&gt; недоступен, потому что для того , чтобы &lt;code&gt;checkTEQ&lt;/code&gt; , чтобы иметь возможность производить &lt;code&gt;Just&lt;/code&gt; , &lt;code&gt;t ~ u&lt;/code&gt; должно выполняться, но так как мы проходим &lt;code&gt;Foo1&lt;/code&gt; и &lt;code&gt;Foo2&lt;/code&gt; здесь, отсюда следует , что &lt;code&gt;t ~ Char&lt;/code&gt; , а &lt;code&gt;u ~ Int&lt;/code&gt; , а значит, &lt;code&gt;t ~ u&lt;/code&gt; не может иметь места.</target>
        </trans-unit>
        <trans-unit id="50553a5059a245db41faab2319d240eba523fc59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LANGUAGE&lt;/code&gt; pragma allows language extensions to be enabled in a portable way. It is the intention that all Haskell compilers support the &lt;code&gt;LANGUAGE&lt;/code&gt; pragma with the same syntax, although not all extensions are supported by all compilers, of course. The &lt;code&gt;LANGUAGE&lt;/code&gt; pragma should be used instead of &lt;code&gt;OPTIONS_GHC&lt;/code&gt;, if possible.</source>
          <target state="translated">&lt;code&gt;LANGUAGE&lt;/code&gt; Прагма позволяет расширения языка должны быть включены в переносимом способе. Предполагается, что все компиляторы Haskell поддерживают прагму &lt;code&gt;LANGUAGE&lt;/code&gt; с одинаковым синтаксисом, хотя, конечно, не все расширения поддерживаются всеми компиляторами. По возможности следует использовать &lt;code&gt;OPTIONS_GHC&lt;/code&gt; &lt;code&gt;LANGUAGE&lt;/code&gt; вместо OPTIONS_GHC .</target>
        </trans-unit>
        <trans-unit id="9db793d0713d9096493ec702152818be66ee6bd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MArray&lt;/code&gt; class is parameterised over both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt; (so that instances specialised to certain element types can be defined, in the same way as for &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt;), and also over the type of the monad, &lt;code&gt;m&lt;/code&gt;, in which the mutable array will be manipulated.</source>
          <target state="translated">Класс &lt;code&gt;MArray&lt;/code&gt; параметризован как для &lt;code&gt;a&lt;/code&gt; ,так и для &lt;code&gt;e&lt;/code&gt; (так что экземпляры, специализированные для определенных типов элементов, могут быть определены таким же образом, как и для &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; ), а также для типа монады &lt;code&gt;m&lt;/code&gt; , в которой изменяемый массив будет манипулируют.</target>
        </trans-unit>
        <trans-unit id="c2c38f8bb84f00cd772ad558cf0397e189ff32c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MINIMAL&lt;/code&gt; pragma can be used to change which combination of methods will be required for instances of a particular class. See &lt;a href=&quot;exts/pragmas#minimal-pragma&quot;&gt;MINIMAL pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9cb8377e96ef4f0bbbfa46420220ebcc273c902" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MINIMAL&lt;/code&gt; pragma can be used to change which combination of methods will be required for instances of a particular class. See &lt;a href=&quot;glasgow_exts#minimal-pragma&quot;&gt;MINIMAL pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;MINIMAL&lt;/code&gt; прагма может быть использована для изменения , которые будут необходимы сочетание методов для экземпляров конкретного класса. См. &lt;a href=&quot;glasgow_exts#minimal-pragma&quot;&gt;Прагму MINIMAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b804211dca7a6234cc53da8eb6f7ab49bdfebd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MINIMAL&lt;/code&gt; pragma is used to specify the minimal complete definition of a class, i.e. specify which methods must be implemented by all instances. If an instance does not satisfy the minimal complete definition, then a warning is generated. This can be useful when a class has methods with circular defaults. For example</source>
          <target state="translated">&lt;code&gt;MINIMAL&lt;/code&gt; Прагма используется для указания минимального полного определения класса, то есть определить , какие методы должны быть реализованы во всех случаях. Если экземпляр не удовлетворяет минимальному полному определению, генерируется предупреждение. Это может быть полезно, когда в классе есть методы с циклическими значениями по умолчанию. Например</target>
        </trans-unit>
        <trans-unit id="179c9366f2492e385b72cb143e85887902e0ab4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Maybe Dec&lt;/code&gt; field contains &lt;code&gt;Just&lt;/code&gt; the declaration which defined the variable - including the RHS of the declaration - or else &lt;code&gt;Nothing&lt;/code&gt;, in the case where the RHS is unavailable to the compiler. At present, this value is &lt;em&gt;always&lt;/em&gt;&lt;code&gt;Nothing&lt;/code&gt;: returning the RHS has not yet been implemented because of lack of interest.</source>
          <target state="translated">Поле &lt;code&gt;Maybe Dec&lt;/code&gt; содержит &lt;code&gt;Just&lt;/code&gt; объявление, которое определило переменную, включая RHS объявления, или &lt;code&gt;Nothing&lt;/code&gt; , в случае, если RHS недоступен для компилятора. В настоящее время это значение &lt;em&gt;всегда&lt;/em&gt; равно &lt;code&gt;Nothing&lt;/code&gt; : возврат RHS еще не реализован из-за отсутствия интереса.</target>
        </trans-unit>
        <trans-unit id="833a3a82dcaf236e1a22c42275a11a48d6dd026d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Maybe String&lt;/code&gt; argument allows to supply an optional time specification. E.g.:</source>
          <target state="translated">&lt;code&gt;Maybe String&lt;/code&gt; аргумент позволяет указать необязательное указание времени. Например:</target>
        </trans-unit>
        <trans-unit id="1242be218ada359701dd67c2a646eb32b9e883ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MkG&lt;/code&gt; GADT constructor has two records, &lt;code&gt;unG1&lt;/code&gt; and &lt;code&gt;unG2&lt;/code&gt;. However, only &lt;code&gt;unG1&lt;/code&gt; can be used as a top-level field selector. &lt;code&gt;unG2&lt;/code&gt; cannot because it is a &amp;ldquo;hidden&amp;rdquo; selector (see &lt;a href=&quot;existential_quantification#existential-records&quot;&gt;Record Constructors&lt;/a&gt;); its type mentions a free variable &lt;code&gt;n&lt;/code&gt; that does not appear in the result type &lt;code&gt;G a (Maybe x)&lt;/code&gt;. On the other hand, the only free type variables in the type of &lt;code&gt;unG1&lt;/code&gt; are &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, so &lt;code&gt;unG1&lt;/code&gt; is fine to use as a top-level function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc66baaebfeab0512a0b98ea32973ef95be01d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ModIface&lt;/code&gt; datatype also contains facilities for extending it with extra data, stored in a &lt;code&gt;Map&lt;/code&gt; of serialised fields, indexed by field names and using GHC&amp;rsquo;s internal &lt;code&gt;Binary&lt;/code&gt; class. The interface to work with these fields is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4cf4ef2ad7be84020f5ab8d962e61d9c5230f48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ModSummary&lt;/code&gt; contains useful meta-information about the compiled module. The &lt;code&gt;HsParsedModule&lt;/code&gt; contains the lexical and syntactical information we mentioned before. The result that you return will change the result of the parsing. If you don&amp;rsquo;t want to change the result, just return the &lt;code&gt;HsParsedModule&lt;/code&gt; that you received as the argument.</source>
          <target state="translated">&lt;code&gt;ModSummary&lt;/code&gt; содержит полезную мета-информацию о скомпилированного модуля. &lt;code&gt;HsParsedModule&lt;/code&gt; содержит лексическую и синтаксическую информацию , которую мы упоминали ранее. Результат, который вы вернете, изменит результат синтаксического анализа. Если вы не хотите изменять результат, просто верните &lt;code&gt;HsParsedModule&lt;/code&gt; , который вы получили в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="48e5172db92414aea034dae74f377abfc598950a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Monad m&lt;/code&gt; superclass is needed to stitch together the different AST fragments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f1b3a94e8148014127a4f07b1372b7725a7bda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Monad&lt;/code&gt; class has an &lt;code&gt;Applicative&lt;/code&gt; superclass. You cannot write &lt;code&gt;Monad&lt;/code&gt; instances that work for GHC and also for a Haskell 2010 implementation that does not define &lt;code&gt;Applicative&lt;/code&gt;.</source>
          <target state="translated">У класса &lt;code&gt;Monad&lt;/code&gt; есть суперкласс &lt;code&gt;Applicative&lt;/code&gt; . Вы не можете писать экземпляры &lt;code&gt;Monad&lt;/code&gt; , которые работают для GHC, а также для реализации Haskell 2010, которая не определяет &lt;code&gt;Applicative&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9a442b1b9dc364891e0d9b2233f04de798d1ec7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOCLDSTOP&lt;/code&gt; flag</source>
          <target state="translated">&lt;code&gt;NOCLDSTOP&lt;/code&gt; флаг</target>
        </trans-unit>
        <trans-unit id="4dd6a67adca1f0f6b2e2bb5d6f4f6be090147329" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOINLINE&lt;/code&gt; pragma tells GHC not to inline &lt;code&gt;foo&lt;/code&gt; until Phase 0; and this property is inherited by the specialisation RULE, which will therefore only fire in Phase 0.</source>
          <target state="translated">&lt;code&gt;NOINLINE&lt;/code&gt; Прагма говорит GHC не инлайн &lt;code&gt;foo&lt;/code&gt; до фазы 0; и это свойство наследуется специализацией RULE, которая, следовательно, срабатывает только в Фазе 0.</target>
        </trans-unit>
        <trans-unit id="41cd577171aa93daf4a59092425aec6f8da57085" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOUNPACK&lt;/code&gt; pragma indicates to the compiler that it should not unpack the contents of a constructor field. Example:</source>
          <target state="translated">&lt;code&gt;NOUNPACK&lt;/code&gt; прагма указывает компилятору , что он не должен распаковать содержимое поля конструктора. Пример:</target>
        </trans-unit>
        <trans-unit id="02f6d5f3a66723750914b07b17b4152b831881eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Natural&lt;/code&gt; number type</source>
          <target state="translated">Тип &lt;code&gt;Natural&lt;/code&gt; числа</target>
        </trans-unit>
        <trans-unit id="8cad6ad0a7f69274a3358108b76be507fd692fa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; case is a right fold of the left subtree whose initial value is a right fold of the rest of the tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e90151e467bb879239604777d1625aec0d519783" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Num&lt;/code&gt; class does not have &lt;code&gt;Show&lt;/code&gt; or &lt;code&gt;Eq&lt;/code&gt; superclasses.</source>
          <target state="translated">Класс &lt;code&gt;Num&lt;/code&gt; не имеет суперклассов &lt;code&gt;Show&lt;/code&gt; или &lt;code&gt;Eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47f8c2780da53550af283e3c4d79cd73d8a4eb47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma is used to specify additional options that are given to the compiler when compiling this source file. See &lt;a href=&quot;../using#source-file-options&quot;&gt;Command line options in source files&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="126dfab84b0966c6acff2a80c6f25e8566d4c2cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma is used to specify additional options that are given to the compiler when compiling this source file. See &lt;a href=&quot;using#source-file-options&quot;&gt;Command line options in source files&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;OPTIONS_GHC&lt;/code&gt; Прагма используется для указания дополнительных опций, которые даются компилятором при компиляции этого исходного файла. Подробнее см. &lt;a href=&quot;using#source-file-options&quot;&gt;Параметры командной строки в исходных файлах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88a0fae3e171286c99c8569a8b07482329213991" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Plugin&lt;/code&gt; type has a field &lt;code&gt;tcPlugin&lt;/code&gt; of type &lt;code&gt;[CommandLineOption] -&amp;gt; Maybe TcPlugin&lt;/code&gt;, where the &lt;code&gt;TcPlugin&lt;/code&gt; type is defined thus:</source>
          <target state="translated">Тип &lt;code&gt;Plugin&lt;/code&gt; имеет поле &lt;code&gt;tcPlugin&lt;/code&gt; типа &lt;code&gt;[CommandLineOption] -&amp;gt; Maybe TcPlugin&lt;/code&gt; , где тип &lt;code&gt;TcPlugin&lt;/code&gt; определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="fffe76b7bf3798c24838442d37709754d1c21fba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PluginRecompile&lt;/code&gt; data type is an enumeration determining how the plugin should affect recompilation.</source>
          <target state="translated">&lt;code&gt;PluginRecompile&lt;/code&gt; типа данных является перечислением определения того, как плагин должен влиять перекомпиляции.</target>
        </trans-unit>
        <trans-unit id="e585b3f2d187dee43075f1c6379003eb2f833f55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pointer&lt;/code&gt; field is not used when tag says that it&amp;rsquo;s &lt;code&gt;Nothing&lt;/code&gt;. Otherwise &lt;code&gt;Pointer&lt;/code&gt; points to the value in &lt;code&gt;Just&lt;/code&gt;. As mentioned above, this type is lazy in its lifted field. Therefore, the type</source>
          <target state="translated">Поле &lt;code&gt;Pointer&lt;/code&gt; не используется, если тег говорит, что это &lt;code&gt;Nothing&lt;/code&gt; . В противном случае &lt;code&gt;Pointer&lt;/code&gt; указывает на значение в &lt;code&gt;Just&lt;/code&gt; . Как упоминалось выше, этот тип ленив в своей поднятой области. Следовательно, тип</target>
        </trans-unit>
        <trans-unit id="6e89ab13d6b3312a22f1cb7af0a4c7b83065d7ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Q&lt;/code&gt; monad is a monad defined in &lt;a href=&quot;../../libraries/template-haskell-2.17.0.0/language-haskell-th-syntax&quot;&gt;Language.Haskell.TH.Syntax&lt;/a&gt; which supports several useful operations during code generation such as reporting errors or looking up identifiers in the environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c6b11868285014da3646f38b0333396538986f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Quote&lt;/code&gt; type class (&lt;a href=&quot;../../libraries/template-haskell-2.17.0.0/language-haskell-th-syntax#t:Quote&quot;&gt;Language.Haskell.TH.Syntax.Quote&lt;/a&gt;) is the minimal interface necessary to implement the desugaring of quotations. The &lt;code&gt;Q&lt;/code&gt; monad is an instance of &lt;code&gt;Quote&lt;/code&gt; but contains many more operations which are not needed for defining quotations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb221db19183a2bbc482de37382d307415cceaa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; класс</target>
        </trans-unit>
        <trans-unit id="e93842ca545a852f968c15b8fc8e56550de74c3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class has two extra methods, &lt;code&gt;readPrec&lt;/code&gt; and &lt;code&gt;readListPrec&lt;/code&gt;, that are not found in the Haskell 2010 since they rely on the &lt;code&gt;ReadPrec&lt;/code&gt; data type, which requires the &lt;a href=&quot;exts/rank_polymorphism#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; extension. GHC also derives &lt;code&gt;Read&lt;/code&gt; instances by implementing &lt;code&gt;readPrec&lt;/code&gt; instead of &lt;code&gt;readsPrec&lt;/code&gt;, and relies on a default implementation of &lt;code&gt;readsPrec&lt;/code&gt; that is defined in terms of &lt;code&gt;readPrec&lt;/code&gt;. GHC adds these two extra methods simply because &lt;code&gt;ReadPrec&lt;/code&gt; is more efficient than &lt;code&gt;ReadS&lt;/code&gt; (the type on which &lt;code&gt;readsPrec&lt;/code&gt; is based).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c684523d6c7922654f7664f2f15207a387ba8fbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class has two extra methods, &lt;code&gt;readPrec&lt;/code&gt; and &lt;code&gt;readListPrec&lt;/code&gt;, that are not found in the Haskell 2010 since they rely on the &lt;code&gt;ReadPrec&lt;/code&gt; data type, which requires the &lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt;&lt;code&gt;-XRankNTypes&lt;/code&gt;&lt;/a&gt; extension. GHC also derives &lt;code&gt;Read&lt;/code&gt; instances by implementing &lt;code&gt;readPrec&lt;/code&gt; instead of &lt;code&gt;readsPrec&lt;/code&gt;, and relies on a default implementation of &lt;code&gt;readsPrec&lt;/code&gt; that is defined in terms of &lt;code&gt;readPrec&lt;/code&gt;. GHC adds these two extra methods simply because &lt;code&gt;ReadPrec&lt;/code&gt; is more efficient than &lt;code&gt;ReadS&lt;/code&gt; (the type on which &lt;code&gt;readsPrec&lt;/code&gt; is based).</source>
          <target state="translated">В классе &lt;code&gt;Read&lt;/code&gt; есть два дополнительных метода, &lt;code&gt;readPrec&lt;/code&gt; и &lt;code&gt;readListPrec&lt;/code&gt; , которых нет в Haskell 2010, поскольку они полагаются на &lt;code&gt;ReadPrec&lt;/code&gt; данных ReadPrec , для которого требуется расширение &lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt; &lt;code&gt;-XRankNTypes&lt;/code&gt; &lt;/a&gt; . GHC также получает экземпляры &lt;code&gt;Read&lt;/code&gt; , реализуя &lt;code&gt;readPrec&lt;/code&gt; вместо &lt;code&gt;readsPrec&lt;/code&gt; , и полагается на реализацию &lt;code&gt;readsPrec&lt;/code&gt; по умолчанию, которая определена в терминах &lt;code&gt;readPrec&lt;/code&gt; . GHC добавляет эти два дополнительных метода просто потому, что &lt;code&gt;ReadPrec&lt;/code&gt; более эффективен, чем &lt;code&gt;ReadS&lt;/code&gt; (тип, на котором основан &lt;code&gt;readsPrec&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1bac9e36b9c420f9455517fb66bd240e808467c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class has two extra methods, &lt;code&gt;readPrec&lt;/code&gt; and &lt;code&gt;readListPrec&lt;/code&gt;, that are not found in the Haskell 2010 since they rely on the &lt;code&gt;ReadPrec&lt;/code&gt; data type, which requires the &lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; extension. GHC also derives &lt;code&gt;Read&lt;/code&gt; instances by implementing &lt;code&gt;readPrec&lt;/code&gt; instead of &lt;code&gt;readsPrec&lt;/code&gt;, and relies on a default implementation of &lt;code&gt;readsPrec&lt;/code&gt; that is defined in terms of &lt;code&gt;readPrec&lt;/code&gt;. GHC adds these two extra methods simply because &lt;code&gt;ReadPrec&lt;/code&gt; is more efficient than &lt;code&gt;ReadS&lt;/code&gt; (the type on which &lt;code&gt;readsPrec&lt;/code&gt; is based).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5a639306682ee2392defbfaca8a0612ce62725a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReadP&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;ReadP&lt;/code&gt; типа</target>
        </trans-unit>
        <trans-unit id="55f87a9866a170596d8c12e14883de0375635cbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reader&lt;/code&gt; monad (also called the Environment monad). Represents a computation, which can read values from a shared environment, pass values from function to function, and execute sub-computations in a modified environment. Using &lt;code&gt;Reader&lt;/code&gt; monad for such computations is often clearer and easier than using the &lt;code&gt;&lt;a href=&quot;control-monad-state#v:State&quot;&gt;State&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;Reader&lt;/code&gt; монада (также называется монадой Environment). Представляет вычисление, которое может считывать значения из общей среды, передавать значения от функции к функции и выполнять подвычисления в измененной среде. Использование монады &lt;code&gt;Reader&lt;/code&gt; для таких вычислений часто проще и понятнее, чем использование монады &lt;code&gt;&lt;a href=&quot;control-monad-state#v:State&quot;&gt;State&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="138e28c8c2a47ed6154d76f22441ec8c21841137" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;R{..}&lt;/code&gt; expands to &lt;code&gt;R{a=a}&lt;/code&gt;, omitting &lt;code&gt;b&lt;/code&gt; since the record field is not in scope, and omitting &lt;code&gt;c&lt;/code&gt; since the variable &lt;code&gt;c&lt;/code&gt; is not in scope (apart from the binding of the record selector &lt;code&gt;c&lt;/code&gt;, of course).</source>
          <target state="translated">&lt;code&gt;R{..}&lt;/code&gt; расширяется до &lt;code&gt;R{a=a}&lt;/code&gt; , опуская &lt;code&gt;b&lt;/code&gt; , так как поле записи не находится в области видимости, и опуская &lt;code&gt;c&lt;/code&gt; , так как переменная &lt;code&gt;c&lt;/code&gt; не находится в области действия (помимо связывания записи селектора &lt;code&gt;c&lt;/code&gt; , конечно ).</target>
        </trans-unit>
        <trans-unit id="c6082bbc59601d9a449fcc7ad9a4d5ed12a91d6c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SPARKS&lt;/code&gt; statistic refers to the use of &lt;code&gt;Control.Parallel.par&lt;/code&gt; and related functionality in the program. Each spark represents a call to &lt;code&gt;par&lt;/code&gt;; a spark is &amp;ldquo;converted&amp;rdquo; when it is executed in parallel; and a spark is &amp;ldquo;pruned&amp;rdquo; when it is found to be already evaluated and is discarded from the pool by the garbage collector. Any remaining sparks are discarded at the end of execution, so &amp;ldquo;converted&amp;rdquo; plus &amp;ldquo;pruned&amp;rdquo; does not necessarily add up to the total.</source>
          <target state="translated">&lt;code&gt;SPARKS&lt;/code&gt; статистики относится к использованию &lt;code&gt;Control.Parallel.par&lt;/code&gt; и связанной с ними функциональности в программе. Каждая искра представляет собой вызов &lt;code&gt;par&lt;/code&gt; ; искра &amp;laquo;преобразуется&amp;raquo; при параллельном запуске; и искра &amp;laquo;обрезается&amp;raquo;, когда обнаруживается, что она уже оценена, и удаляется из пула сборщиком мусора. Любые оставшиеся искры отбрасываются в конце выполнения, поэтому &amp;laquo;преобразованные&amp;raquo; плюс &amp;laquo;отсеченные&amp;raquo; не обязательно составляют общую сумму.</target>
        </trans-unit>
        <trans-unit id="0739f5ccb2bb880c7aac97c76af83b628f8a3a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ST&lt;/code&gt; Monad</source>
          <target state="translated">&lt;code&gt;ST&lt;/code&gt; Монада</target>
        </trans-unit>
        <trans-unit id="f614e141f7715f6c62aa646fdfcc09ca9d7280e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ST&lt;/code&gt; monad</source>
          <target state="translated">&lt;code&gt;ST&lt;/code&gt; монада</target>
        </trans-unit>
        <trans-unit id="95776d621e6e94b966ba5059c98ab385d9187b77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Semigroup&lt;/code&gt; operator &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; will be in &lt;code&gt;Prelude&lt;/code&gt;, which clashes with custom local definitions of such an operator</source>
          <target state="translated">&lt;code&gt;Semigroup&lt;/code&gt; оператор &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; будет в &lt;code&gt;Prelude&lt;/code&gt; , который столкновения с пользовательским локальными определениями такого оператора</target>
        </trans-unit>
        <trans-unit id="8bd15c25ef057d5bb7b4b11090add4deb0ab7363" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ShortByteString&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;ShortByteString&lt;/code&gt; типа</target>
        </trans-unit>
        <trans-unit id="42f56d1b1cf13cb62004be77c95ea28a2e463b26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ShortByteString&lt;/code&gt; type and representation</source>
          <target state="translated">&lt;code&gt;ShortByteString&lt;/code&gt; тип и представление</target>
        </trans-unit>
        <trans-unit id="9c01c63bcea3f47012ef7cb8b53521ef2f599690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SomeException&lt;/code&gt; type is the root of the exception type hierarchy. When an exception of type &lt;code&gt;e&lt;/code&gt; is thrown, behind the scenes it is encapsulated in a &lt;code&gt;SomeException&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;SomeException&lt;/code&gt; является корнем иерархии типов исключения. Когда генерируется исключение типа &lt;code&gt;e&lt;/code&gt; , за кулисами оно инкапсулируется в &lt;code&gt;SomeException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="075869aa5abeccc3e82651f71cd0b49cf876a1ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StablePtr&lt;/code&gt; is freed by &lt;code&gt;hs_try_putmvar()&lt;/code&gt;. This is because it would otherwise be difficult to arrange to free the &lt;code&gt;StablePtr&lt;/code&gt; reliably: we can&amp;rsquo;t free it in Haskell, because if the &lt;code&gt;takeMVar&lt;/code&gt; is interrupted by an asynchronous exception, then the callback will fire at a later time. We can&amp;rsquo;t free it in C, because we don&amp;rsquo;t know when to free it (not when &lt;code&gt;hs_try_putmvar()&lt;/code&gt; returns, because that is an async call that uses the &lt;code&gt;StablePtr&lt;/code&gt; at some time in the future).</source>
          <target state="translated">&lt;code&gt;StablePtr&lt;/code&gt; освобождается от &lt;code&gt;hs_try_putmvar()&lt;/code&gt; . Это связано с тем, что в противном случае было бы сложно организовать надежное освобождение &lt;code&gt;StablePtr&lt;/code&gt; : мы не можем освободить его в Haskell, потому что, если &lt;code&gt;takeMVar&lt;/code&gt; прерывается асинхронным исключением, обратный вызов сработает позже. Мы не можем освободить его в C, потому что мы не знаем, когда его освободить (не когда возвращается &lt;code&gt;hs_try_putmvar()&lt;/code&gt; , потому что это асинхронный вызов, который использует &lt;code&gt;StablePtr&lt;/code&gt; в какой-то момент в будущем).</target>
        </trans-unit>
        <trans-unit id="93f61b2e2afac0b4f71ea13ddcca5d653fa2b424" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StateT s m&lt;/code&gt; implementation of &lt;code&gt;generalBracket&lt;/code&gt; delegates to the &lt;code&gt;m&lt;/code&gt; implementation of &lt;code&gt;generalBracket&lt;/code&gt;. The &lt;code&gt;acquire&lt;/code&gt;, &lt;code&gt;use&lt;/code&gt;, and &lt;code&gt;release&lt;/code&gt; arguments given to &lt;code&gt;StateT&lt;/code&gt;'s implementation produce actions of type &lt;code&gt;StateT s m a&lt;/code&gt;, &lt;code&gt;StateT s m b&lt;/code&gt;, and &lt;code&gt;StateT s m c&lt;/code&gt;. In order to run those actions in the base monad, we need to call &lt;code&gt;runStateT&lt;/code&gt;, from which we obtain actions of type &lt;code&gt;m (a, s)&lt;/code&gt;, &lt;code&gt;m (b, s)&lt;/code&gt;, and &lt;code&gt;m (c, s)&lt;/code&gt;. Since each action produces the next state, it is important to feed the state produced by the previous action to the next action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22a2fd434898f0f6555b4c40eb04ba5061f4dac5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type and associated operations.</source>
          <target state="translated">Тип &lt;code&gt;String&lt;/code&gt; и связанные с ним операции.</target>
        </trans-unit>
        <trans-unit id="063a241ae6b100332789afebed90ca2f9db07517" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Traversable&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;Traversable&lt;/code&gt; класс</target>
        </trans-unit>
        <trans-unit id="f3eb004bc8ea181740ab9d964eca4039846cba0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tree&lt;/code&gt; datatype has two constructors. The representation of individual constructors is combined using the binary type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип данных &lt;code&gt;Tree&lt;/code&gt; имеет два конструктора. Представление отдельных конструкторов в сочетании с использованием двоичного типа конструктора &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea0e01ff4b10acd1f300e041e7c7d24452a6bcef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Type&lt;/code&gt; field contains the type which underlies the variable. At present, this is always &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt;, but future changes may permit refinement of this.</source>
          <target state="translated">Поле &lt;code&gt;Type&lt;/code&gt; содержит тип, лежащий в основе переменной. В настоящее время это всегда &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt; , но будущие изменения могут позволить уточнить это.</target>
        </trans-unit>
        <trans-unit id="a1c62302915451aa80bfd9fc2cff479b2cf284ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Type&lt;/code&gt; field contains the type which underlies the variable. At present, this is always &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt;, but future changes may permit refinement of this.</source>
          <target state="translated">Поле &lt;code&gt;Type&lt;/code&gt; содержит тип, лежащий в основе переменной. В настоящее время это всегда &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt; , но будущие изменения могут позволить уточнить это.</target>
        </trans-unit>
        <trans-unit id="027d2a06d103d553d051280a74cf3845d60d411a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UNPACK&lt;/code&gt; indicates to the compiler that it should unpack the contents of a constructor field into the constructor itself, removing a level of indirection. For example:</source>
          <target state="translated">&lt;code&gt;UNPACK&lt;/code&gt; указывает компилятору , что он должен распаковать содержимое поля конструктора в самом конструкторе, убирая уровень косвенности. Например:</target>
        </trans-unit>
        <trans-unit id="33782bed5c646b932004c73abe54633b85489d8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Version&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Version&lt;/code&gt; типа</target>
        </trans-unit>
        <trans-unit id="5c935ef40843fda690b92bec23a2da13f0596d70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WARNING&lt;/code&gt; pragma allows you to attach an arbitrary warning to a particular function, class, or type.</source>
          <target state="translated">&lt;code&gt;WARNING&lt;/code&gt; Прагма позволяет присоединять произвольное предупреждение к конкретной функции, класса или типа.</target>
        </trans-unit>
        <trans-unit id="4b5cfd9e9013fd4cb9b04f939f4f7787609c1e73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Weak&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; тип</target>
        </trans-unit>
        <trans-unit id="f5d131550d29246afe295414037eda39ef3a4a79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[2]&lt;/code&gt; means that the rule is active in Phase 2 and subsequent phases. The inverse notation &lt;code&gt;[~2]&lt;/code&gt; is also accepted, meaning that the rule is active up to, but not including, Phase 2.</source>
          <target state="translated">В &lt;code&gt;[2]&lt;/code&gt; означает , что правило действует в фазе 2 и последующих этапах. Обратное обозначение &lt;code&gt;[~2]&lt;/code&gt; также принимается, что означает, что правило действует до Фазы 2, но не включая ее.</target>
        </trans-unit>
        <trans-unit id="e762931e5ccd90930535b3ca5e55c6d8c0924233" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binary&lt;/code&gt; package is notable in that it provides both pure, and high performance serialisation.</source>
          <target state="translated">&lt;code&gt;binary&lt;/code&gt; пакет отличается тем , что она обеспечивает как чисто, и высокая производительность сериализации.</target>
        </trans-unit>
        <trans-unit id="4bd1285d74cbd2d2cbc3ca0932f6094c43b630ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;buildExpressionParser&lt;/code&gt; takes care of all the complexity involved in building expression parser. Here is an example of an expression parser that handles prefix signs, postfix increment and basic arithmetic.</source>
          <target state="translated">&lt;code&gt;buildExpressionParser&lt;/code&gt; берет на себя все сложности , участвующих в построении выражений парсер. Вот пример парсера выражений, который обрабатывает знаки префикса, приращение постфикса и основную арифметику.</target>
        </trans-unit>
        <trans-unit id="9dc6c10898dec30b4e5dd6a9520ac4b310a891ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;catch&lt;/code&gt; functions</source>
          <target state="translated">В &lt;code&gt;catch&lt;/code&gt; функции</target>
        </trans-unit>
        <trans-unit id="ce3c62da909521366f0612be95d0d5abc18fd5df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cr&lt;/code&gt; capability, which moves the cursor to the first column of the current line.</source>
          <target state="translated">Возможность &lt;code&gt;cr&lt;/code&gt; , которая перемещает курсор в первый столбец текущей строки.</target>
        </trans-unit>
        <trans-unit id="41cac9a191aeb661ca1ba5373f54957c5ae0927f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deriving( Sizable )&lt;/code&gt; is equivalent to saying</source>
          <target state="translated">&lt;code&gt;deriving( Sizable )&lt;/code&gt; равносильно тому,</target>
        </trans-unit>
        <trans-unit id="aecea50617c919f429665961c30499dbecafe248" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode&lt;/code&gt; function translates elements of the buffer &lt;code&gt;from&lt;/code&gt; to the buffer &lt;code&gt;to&lt;/code&gt;. It should translate as many elements as possible given the sizes of the buffers, including translating zero elements if there is either not enough room in &lt;code&gt;to&lt;/code&gt;, or &lt;code&gt;from&lt;/code&gt; does not contain a complete multibyte sequence.</source>
          <target state="translated">Функция &lt;code&gt;encode&lt;/code&gt; переводит элементы буфера &lt;code&gt;from&lt;/code&gt; в буфер &lt;code&gt;to&lt;/code&gt; . Он должен перевести как много элементов , как это возможно , учитывая размеры буферов, в том числе перевод нулевых элементов , если есть или не хватает места в &lt;code&gt;to&lt;/code&gt; или &lt;code&gt;from&lt;/code&gt; не содержит полную последовательность многобайтовую.</target>
        </trans-unit>
        <trans-unit id="0a5aa4a69bcc42b7c89b78bde09cb33ccb0cfca5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enumFrom&lt;/code&gt;... methods are used in Haskell's translation of arithmetic sequences.</source>
          <target state="translated">&lt;code&gt;enumFrom&lt;/code&gt; ... методы используются в переводе в Haskell арифметических последовательностей.</target>
        </trans-unit>
        <trans-unit id="ade300f4a813bcee47f07faaadabe78ba37c7979" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; function from the Prelude supports printing the call stack that led to the error in addition to the usual error message:</source>
          <target state="translated">Функция &lt;code&gt;error&lt;/code&gt; из Prelude поддерживает печать стека вызовов, которые привели к ошибке, в дополнение к обычному сообщению об ошибке:</target>
        </trans-unit>
        <trans-unit id="511af374fd1b5b479579f0c30542d54251504918" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;evaluate&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;evaluate&lt;/code&gt; функцию</target>
        </trans-unit>
        <trans-unit id="2fbc5531096df720b55b588e7e44b2f7fb05c108" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forall&lt;/code&gt;-or-nothing rule takes effect in the following places:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597cda7e7f16a0e50cd5f0c4f0416902f5c0363f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromInteger&lt;/code&gt; (and hence also &lt;code&gt;fromIntegral&lt;/code&gt;) is a special case when converting to &lt;code&gt;Int&lt;/code&gt;. The value of &lt;code&gt;fromIntegral x :: Int&lt;/code&gt; is given by taking the lower ⟨n⟩ bits of &lt;code&gt;(abs x)&lt;/code&gt;, multiplied by the sign of &lt;code&gt;x&lt;/code&gt; (in 2&amp;rsquo;s complement ⟨n⟩-bit arithmetic). This behaviour was chosen so that for example writing &lt;code&gt;0xffffffff :: Int&lt;/code&gt; preserves the bit-pattern in the resulting &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fromInteger&lt;/code&gt; (а значит , и &lt;code&gt;fromIntegral&lt;/code&gt; ) представляет собой особый случай , когда преобразование в &lt;code&gt;Int&lt;/code&gt; . Значение &lt;code&gt;fromIntegral x :: Int&lt;/code&gt; дается путем умножения младших ⟨n⟩ битов &lt;code&gt;(abs x)&lt;/code&gt; на знак &lt;code&gt;x&lt;/code&gt; (в n⟩-битовой арифметике с дополнением до 2). Это поведение было выбрано таким образом, чтобы, например, запись &lt;code&gt;0xffffffff :: Int&lt;/code&gt; сохраняла битовый шаблон в результирующем &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef0f4a35a1f6d1c258b22e6d87df758fac232791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromIntegral&lt;/code&gt; function also preserves bit-patterns when converting between the sized integral types (&lt;code&gt;Int8&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt; and the unsigned &lt;code&gt;Word&lt;/code&gt; variants), see the modules &lt;code&gt;Data.Int&lt;/code&gt; and &lt;code&gt;Data.Word&lt;/code&gt; in the library documentation.</source>
          <target state="translated">Функция &lt;code&gt;fromIntegral&lt;/code&gt; также сохраняет битовые шаблоны при преобразовании между целочисленными типами размера ( &lt;code&gt;Int8&lt;/code&gt; , &lt;code&gt;Int16&lt;/code&gt; , &lt;code&gt;Int32&lt;/code&gt; , &lt;code&gt;Int64&lt;/code&gt; и варианты &lt;code&gt;Word&lt;/code&gt; без знака ), см. Модули &lt;code&gt;Data.Int&lt;/code&gt; и &lt;code&gt;Data.Word&lt;/code&gt; в документации библиотеки.</target>
        </trans-unit>
        <trans-unit id="762b16a36e554904d87f2db331ab1542095ebd78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghc-pkg&lt;/code&gt; program may be run in the ways listed below. Where a package name is required, the package can be named in full including the version number (e.g. &lt;code&gt;network-1.0&lt;/code&gt;), or without the version number. Naming a package without the version number matches all versions of the package; the specified action will be applied to all the matching packages. A package specifier that matches all version of the package can also be written &lt;code&gt;⟨pkg⟩ -*&lt;/code&gt;, to make it clearer that multiple packages are being matched. To match against the installed package ID instead of just package name and version, pass the &lt;code&gt;--ipid&lt;/code&gt; flag.</source>
          <target state="translated">Программу &lt;code&gt;ghc-pkg&lt;/code&gt; можно запустить перечисленными ниже способами. Если требуется имя пакета, пакет может быть назван полностью, включая номер версии (например, &lt;code&gt;network-1.0&lt;/code&gt; ), или без номера версии. Название пакета без номера версии соответствует всем версиям пакета; указанное действие будет применено ко всем подходящим пакетам. &lt;code&gt;⟨pkg⟩ -*&lt;/code&gt; пакета, который соответствует всем версиям пакета, также можно записать как &amp;laquo; pkg&amp;raquo; - * , чтобы было понятнее, что сопоставляются несколько пакетов. Чтобы соответствовать идентификатору установленного пакета, а не только имени и версии пакета, &lt;code&gt;--ipid&lt;/code&gt; флаг --ipid .</target>
        </trans-unit>
        <trans-unit id="70e170de84746b93a247accd0e8bc402d6a2ea08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghc&lt;/code&gt; package exposes most of GHC&amp;rsquo;s frontend to users, and thus allows you to write programs that leverage it. This library is actually the same library used by GHC&amp;rsquo;s internal, frontend compilation driver, and thus allows you to write tools that programmatically compile source code and inspect it. Such functionality is useful in order to write things like IDE or refactoring tools. As a simple example, here&amp;rsquo;s a program which compiles a module, much like ghc itself does by default when invoked:</source>
          <target state="translated">Пакет &lt;code&gt;ghc&lt;/code&gt; предоставляет пользователям большую часть интерфейса GHC и, таким образом, позволяет вам писать программы, использующие его. Эта библиотека на самом деле является той же самой библиотекой, которая используется внутренним драйвером компиляции внешнего интерфейса GHC, и, таким образом, позволяет вам писать инструменты, которые программно компилируют исходный код и проверяют его. Такая функциональность полезна для написания таких вещей, как IDE или инструменты рефакторинга. В качестве простого примера, вот программа, которая компилирует модуль, как и сам ghc по умолчанию при вызове:</target>
        </trans-unit>
        <trans-unit id="e102bed194230593a0e69925d95b61dfc6e1bb63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghci.conf&lt;/code&gt; file is most useful for turning on favourite options (e.g. &lt;code&gt;:set +s&lt;/code&gt;), and defining useful macros.</source>
          <target state="translated">&lt;code&gt;ghci.conf&lt;/code&gt; файл является наиболее полезным для включения любимых вариантов (например &lt;code&gt;:set +s&lt;/code&gt; ), и определения полезных макросов.</target>
        </trans-unit>
        <trans-unit id="2d742d7f4cd29eb0f301c0d47b2cc254469da39b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;handle&lt;/code&gt; functions</source>
          <target state="translated">В &lt;code&gt;handle&lt;/code&gt; функции</target>
        </trans-unit>
        <trans-unit id="34d765516635c10fcdf110fa543c8ace7e8ff1fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hi-boot&lt;/code&gt; generated by compiling a &lt;code&gt;hs-boot&lt;/code&gt; file is in the same machine-generated binary format as any other GHC-generated interface file (e.g. &lt;code&gt;B.hi&lt;/code&gt;). You can display its contents with &lt;code&gt;ghc --show-iface&lt;/code&gt;. If you specify a directory for interface files, the &lt;code&gt;-ohidir&lt;/code&gt; flag, then that affects &lt;code&gt;hi-boot&lt;/code&gt; files too.</source>
          <target state="translated">&lt;code&gt;hi-boot&lt;/code&gt; генерируется путем составления &lt;code&gt;hs-boot&lt;/code&gt; файл находится в той же машине сгенерированных двоичном формате , как и любой другой GHC сгенерированный файл интерфейса (например , &lt;code&gt;B.hi&lt;/code&gt; ). Вы можете отобразить его содержимое с помощью &lt;code&gt;ghc --show-iface&lt;/code&gt; . Если вы укажете каталог для файлов интерфейса, флаг &lt;code&gt;-ohidir&lt;/code&gt; , то это также повлияет на файлы &lt;code&gt;hi-boot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="355d829a4b676f5ca653b94b80c9807cda2a9d2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hsc2hs&lt;/code&gt; command can be used to automate some parts of the process of writing Haskell bindings to C code. It reads an almost-Haskell source with embedded special constructs, and outputs a real Haskell file with these constructs processed, based on information taken from some C headers. The extra constructs deal with accessing C data from Haskell.</source>
          <target state="translated">&lt;code&gt;hsc2hs&lt;/code&gt; команда может быть использована для автоматизации некоторых частей процесса написания Haskell привязки к коду C. Он читает исходный код почти на Haskell со встроенными специальными конструкциями и выводит реальный файл Haskell с обработанными конструкциями на основе информации, взятой из некоторых заголовков C. Дополнительные конструкции имеют дело с доступом к данным C из Haskell.</target>
        </trans-unit>
        <trans-unit id="e2823e69f2a65d7ce80b8fd7a101d62eed4e1c66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i2d&lt;/code&gt; function is virtually one machine instruction; the default conversion&amp;mdash;via an intermediate &lt;code&gt;Rational&lt;/code&gt;-is obscenely expensive by comparison.</source>
          <target state="translated">Функция &lt;code&gt;i2d&lt;/code&gt; - это фактически одна машинная инструкция; преобразование по умолчанию - через промежуточный &lt;code&gt;Rational&lt;/code&gt; - по сравнению с ним до неприличия дорого.</target>
        </trans-unit>
        <trans-unit id="7c8dc7d7a696a83968e6e8dd5a58a6b1ef2a23b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; of a cost-centre listed in the &lt;code&gt;cost_centres&lt;/code&gt; list.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; из затрат центра , перечисленных в &lt;code&gt;cost_centres&lt;/code&gt; списке.</target>
        </trans-unit>
        <trans-unit id="0f33c5545ef78687d7ec80abf9761102bfc37c4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import A hiding( g )&lt;/code&gt; in module &lt;code&gt;B&lt;/code&gt; is technically an error (&lt;a href=&quot;http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1&quot;&gt;Haskell Report, 5.3.1&lt;/a&gt;) because &lt;code&gt;A&lt;/code&gt; does not export &lt;code&gt;g&lt;/code&gt;. However GHC allows it, in the interests of supporting backward compatibility; for example, a newer version of &lt;code&gt;A&lt;/code&gt; might export &lt;code&gt;g&lt;/code&gt;, and you want &lt;code&gt;B&lt;/code&gt; to work in either case.</source>
          <target state="translated">&lt;code&gt;import A hiding( g )&lt;/code&gt; в модуле &lt;code&gt;B&lt;/code&gt; является технически ошибка ( &lt;a href=&quot;http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1&quot;&gt;Haskell Report, 5.3.1&lt;/a&gt; ) , потому что не делает экспорт &lt;code&gt;g&lt;/code&gt; . Однако GHC позволяет это в интересах поддержки обратной совместимости; например, более новая версия &lt;code&gt;A&lt;/code&gt; может экспортировать &lt;code&gt;g&lt;/code&gt; , и вы хотите, чтобы &lt;code&gt;B&lt;/code&gt; работал в любом случае. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6ee2a5c41770c7a1baf9d025dcbc42759f0fdd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import A hiding( g )&lt;/code&gt; in module &lt;code&gt;B&lt;/code&gt; is technically an error (&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1&quot;&gt;Haskell Report, 5.3.1&lt;/a&gt;) because &lt;code&gt;A&lt;/code&gt; does not export &lt;code&gt;g&lt;/code&gt;. However GHC allows it, in the interests of supporting backward compatibility; for example, a newer version of &lt;code&gt;A&lt;/code&gt; might export &lt;code&gt;g&lt;/code&gt;, and you want &lt;code&gt;B&lt;/code&gt; to work in either case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f41076a0857a53fdc32d3736b60eb827f4f251e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; declaration (&lt;a href=&quot;#ghci-import-decl&quot;&gt;Controlling what is in scope with import&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; декларации ( &lt;a href=&quot;#ghci-import-decl&quot;&gt;Управление , что находится в области с импортом&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5ad2ceafe50f168640b42ddfd5b779521b31a687" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instance&lt;/code&gt; keyword is optional.</source>
          <target state="translated">&lt;code&gt;instance&lt;/code&gt; необязательное ключевое слово.</target>
        </trans-unit>
        <trans-unit id="6290f04db0b506c583506333aeba21e56f7af2ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lazyIOExample&lt;/code&gt; uses lazy I/O to read the file from the disk, which is not suitable in all applications, and certainly not if you need to read from a socket which has higher likelihood to fail. To address these needs, use the incremental input method like in &lt;code&gt;incrementalExample&lt;/code&gt;. For an example of how to read incrementally from a Handle, see the implementation of &lt;code&gt;&lt;a href=&quot;data-binary#v:decodeFileOrFail&quot;&gt;decodeFileOrFail&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lazyIOExample&lt;/code&gt; использует ленивое I / O , чтобы прочитать файл с диска, который не подходит для всех приложений, и , конечно , если вы не нужно читать из сокета , который имеет более высокую вероятность потерпеть неудачу. Чтобы удовлетворить эти потребности, используйте метод инкрементного ввода, как в &lt;code&gt;incrementalExample&lt;/code&gt; . Для примера того, как постепенно читать из Handle, см. Реализацию &lt;code&gt;&lt;a href=&quot;data-binary#v:decodeFileOrFail&quot;&gt;decodeFileOrFail&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2176a754f25110a9917a6219e63404e3208eea44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapException&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;mapException&lt;/code&gt; функция</target>
        </trans-unit>
        <trans-unit id="c837f409d9c890ff0cf84a0f23501c248975f873" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mask_&lt;/code&gt; is to avoid asynchronous exceptions before the &lt;code&gt;scheduleCallback&lt;/code&gt; call, which would leak the &lt;code&gt;StablePtr&lt;/code&gt;.</source>
          <target state="translated">Параметр &lt;code&gt;mask_&lt;/code&gt; предназначен для предотвращения асинхронных исключений перед вызовом &lt;code&gt;scheduleCallback&lt;/code&gt; , которые могут &lt;code&gt;StablePtr&lt;/code&gt; утечке StablePtr .</target>
        </trans-unit>
        <trans-unit id="88156e7be9a84c3b32b21ca9033fb9b40a86fc7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mdo&lt;/code&gt; notation removes the burden of placing explicit &lt;code&gt;rec&lt;/code&gt; blocks in the code. Unlike an ordinary &lt;code&gt;do&lt;/code&gt; expression, in which variables bound by statements are only in scope for later statements, variables bound in an &lt;code&gt;mdo&lt;/code&gt; expression are in scope for all statements of the expression. The compiler then automatically identifies minimal mutually recursively dependent segments of statements, treating them as if the user had wrapped a &lt;code&gt;rec&lt;/code&gt; qualifier around them.</source>
          <target state="translated">&lt;code&gt;mdo&lt;/code&gt; нотация снимает бремя размещения явных &lt;code&gt;rec&lt;/code&gt; блоков в коде. В отличие от обычного выражения &lt;code&gt;do&lt;/code&gt; , в котором переменные, связанные операторами, находятся в области видимости только для последующих операторов, переменные, связанные в выражении &lt;code&gt;mdo&lt;/code&gt; , находятся в области видимости всех операторов выражения. Затем компилятор автоматически определяет минимальные взаимно рекурсивно зависимые сегменты операторов, обрабатывая их так, как если бы пользователь обернул их квалификатором &lt;code&gt;rec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6a07857e87c25a69a2a85f3c6940b5d3da66364" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;needle&lt;/code&gt; parameter may not be empty.</source>
          <target state="translated">Параметр &lt;code&gt;needle&lt;/code&gt; не может быть пустым.</target>
        </trans-unit>
        <trans-unit id="03da503ca798d541eacd37351134d51c710473a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nel&lt;/code&gt; capability, which moves the cursor to the first column of the next line. It behaves like a carriage return followed by a line feed.</source>
          <target state="translated">Возможность &lt;code&gt;nel&lt;/code&gt; , которая перемещает курсор в первый столбец следующей строки. Он действует как возврат каретки, за которым следует перевод строки.</target>
        </trans-unit>
        <trans-unit id="41854e5bb2dcfb535a78b10a713fbfca69450478" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubIntOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype. For example, &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.13.0.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; can be used to nub characters and typical fixed-with numerical types efficiently.</source>
          <target state="translated">Функция &lt;code&gt;nubIntOn&lt;/code&gt; ведет себя так же, как &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; , за исключением того, что она выполняет сравнения не с исходным типом данных, а с указанной пользователем проекцией из этого типа данных. Например, &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.13.0.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; можно эффективно использовать для объединения символов и типичных фиксированных числовых типов.</target>
        </trans-unit>
        <trans-unit id="238764eaf45a1a62c1753a2837a1022054e829ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubIntOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype. For example, &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.14.1.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; can be used to nub characters and typical fixed-with numerical types efficiently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0766c52e5da98e96b097f0b2e8a0cc9028ac4ec7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubIntOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype. For example, &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.15.0.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; can be used to nub characters and typical fixed-with numerical types efficiently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d601cddbbd9d7126bc0e97c81bf6fdd7871c9080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubOrdOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubOrd&quot;&gt;nubOrd&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype.</source>
          <target state="translated">Функция &lt;code&gt;nubOrdOn&lt;/code&gt; ведет себя так же, как &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubOrd&quot;&gt;nubOrd&lt;/a&gt;&lt;/code&gt; , за исключением того, что она выполняет сравнения не с исходным типом данных, а с указанной пользователем проекцией из этого типа данных.</target>
        </trans-unit>
        <trans-unit id="d367aba8a4bc7af80523df0833dbadc25b08592e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; методы &lt;em&gt;должны возвращать карту с подмножеством (возможно , пустым) ключей данной карты&lt;/em&gt; . Значения можно изменять произвольно. Наиболее распространенные варианты &lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; являются &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; , но, например , &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; может быть использован для любого &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87db766c3fcfe957880bc536c8055be89a67ca05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; методы &lt;em&gt;должны возвращать карту с подмножеством (возможно , пустым) ключей данной карты&lt;/em&gt; . Значения можно изменять произвольно. Наиболее распространенные варианты &lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; являются &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; , но, например , &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; может быть использован для любого &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3d76aa425b2c86fc5220b26c112435a53e249f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; методы &lt;em&gt;должны возвращать карту с подмножеством (возможно , пустым) ключей данной карты&lt;/em&gt; . Значения можно изменять произвольно. Наиболее распространенные варианты &lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; являются &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; , но, например , &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; может быть использован для любого &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe60eae85d88c9490c48aade82bc12d2974b6022" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; методы &lt;em&gt;должны возвращать карту с подмножеством (возможно , пустым) ключей данной карты&lt;/em&gt; . Значения можно изменять произвольно. Наиболее распространенные варианты &lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; являются &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; , но, например , &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; может быть использован для любого &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48239e0c803c6ef0e5cd08862ca58810b64b5781" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; методы &lt;em&gt;должны возвращать карту с подмножеством (возможно , пустым) ключей данной карты&lt;/em&gt; . Значения можно изменять произвольно. Наиболее распространенные варианты &lt;code&gt;only1&lt;/code&gt; и &lt;code&gt;only2&lt;/code&gt; являются &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; , но, например , &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; может быть использован для любого &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50f7df8b96731582ad5998e199bcd7caa6862256" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ef6fce0bb77b22860c0010c07608d5a890578fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd6ba4c2792acbb3c2aab713f7ac895331441da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373d721989cc654150bbf0bfb255a4af1891905b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b92d866131bfc652b2f085c78ccedd7098e50a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77efcf307eb6a39e1b4f69936ca978bcecf7066" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ce2ccedbe6bd5ac1d94120db777fbb8337511f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d2e43e335cb4eb09e7735f3bdddf48bef57b356" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a6515b2ab89354c9fee21d1ff0883f508eeed3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c215bc0ca5c8d4414abd0c0e1f3423af0982dbdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46099596c66e9f01cbd3f7bcc5b5f08680659ccd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pat_lhs&lt;/code&gt; for explicitly bidirectional construction cannot use Record syntax. (Because the rhs &lt;em&gt;expr&lt;/em&gt; might be constructing different data constructors.) It can use guards with multiple equations.</source>
          <target state="translated">В &lt;code&gt;pat_lhs&lt;/code&gt; для явного двунаправленной конструкции не могут использовать синтаксис записи. (Поскольку rhs &lt;em&gt;expr&lt;/em&gt; может создавать разные конструкторы данных.) Он может использовать защитные элементы с несколькими уравнениями.</target>
        </trans-unit>
        <trans-unit id="c77daba6d5e5a119d170e42d9dd4a10538222183" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qq&lt;/code&gt; quasiquoter would be able to see the definition of &lt;code&gt;f&lt;/code&gt; from the preceding declaration group, but not the definitions of &lt;code&gt;h&lt;/code&gt; or &lt;code&gt;k&lt;/code&gt;, or any definitions from subsequent declaration groups.</source>
          <target state="translated">&lt;code&gt;qq&lt;/code&gt; quasiquoter сможет увидеть определение &lt;code&gt;f&lt;/code&gt; из предыдущей декларации группы, но не определения &lt;code&gt;h&lt;/code&gt; или &lt;code&gt;k&lt;/code&gt; , или каких - либо определений из последующих групп декларации.</target>
        </trans-unit>
        <trans-unit id="c466f28061a085d0fe280fa263ce6f774fe3c68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recover&lt;/code&gt; function is used to continue decoding in the presence of invalid or unrepresentable sequences. This includes both those detected by &lt;code&gt;encode&lt;/code&gt; returning &lt;code&gt;InvalidSequence&lt;/code&gt; and those that occur because the input byte sequence appears to be truncated.</source>
          <target state="translated">Функция &lt;code&gt;recover&lt;/code&gt; используется для продолжения декодирования при наличии недопустимых или непредставимых последовательностей. Сюда входят как те, которые обнаруживаются при &lt;code&gt;encode&lt;/code&gt; возвращающем &lt;code&gt;InvalidSequence&lt;/code&gt; ,так и те, которые возникают из-за того, что входная последовательность байтов кажется усеченной.</target>
        </trans-unit>
        <trans-unit id="a473a7ced8aa63a52d8a8ae70bef9c494ad7a2e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; function simply creates a continuation which passes the value on.</source>
          <target state="translated">Функция &lt;code&gt;return&lt;/code&gt; просто создает продолжение, которое передает значение.</target>
        </trans-unit>
        <trans-unit id="81379fa1503519747e0a096e84f164e14f442525" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;runghc&lt;/code&gt; command-line looks like:</source>
          <target state="translated">В &lt;code&gt;runghc&lt;/code&gt; командной строки выглядит следующим образом :</target>
        </trans-unit>
        <trans-unit id="cebfe6013064a220b5cba39faaac05a83ca046c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; type is hidden from the outside; any attempt to apply &lt;code&gt;_this&lt;/code&gt;, &lt;code&gt;_inc&lt;/code&gt; or &lt;code&gt;_display&lt;/code&gt; as functions will raise a compile-time error. In other words, &lt;em&gt;GHC defines a record selector function only for fields whose type does not mention the existentially-quantified variables&lt;/em&gt;. (This example used an underscore in the fields for which record selectors will not be defined, but that is only programming style; GHC ignores them.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e3f0a426cb551b465e32dbdd47361e262cdb1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sequenceA&lt;/code&gt; and &lt;code&gt;sequence&lt;/code&gt; methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8f29d0aba7b46039df62fe50f4c7d9ad9965c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shows&lt;/code&gt; functions return a function that prepends the output &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an existing &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. This allows constant-time concatenation of results using function composition.</source>
          <target state="translated">Функции &lt;code&gt;shows&lt;/code&gt; возвращают функцию, которая добавляет &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; вывода к существующей &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; . Это позволяет объединять результаты в постоянное время с помощью композиции функций.</target>
        </trans-unit>
        <trans-unit id="2bfd895a0337bb9829478985b48c54b24e2e9ad9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shows&lt;/code&gt; functions return a function that prepends the output &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an existing &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. This allows constant-time concatenation of results using function composition.</source>
          <target state="translated">Функции &lt;code&gt;shows&lt;/code&gt; возвращают функцию, которая добавляет &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; вывода к существующей &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; . Это позволяет объединять результаты в постоянное время с помощью композиции функций.</target>
        </trans-unit>
        <trans-unit id="8762c6cbedea04c42d6cbeebccb6250ad93ea53a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sprint&lt;/code&gt; function adds an exclamation mark at the end of any printed value. Running GHCi with the command:</source>
          <target state="translated">Функция &lt;code&gt;sprint&lt;/code&gt; добавляет восклицательный знак в конце любого напечатанного значения. Запускаем GHCi командой:</target>
        </trans-unit>
        <trans-unit id="b8ab09f95cb11cc6d3321f577cbb4de51fef8004" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state hack&lt;/code&gt; optimization can result in non-obvious changes in evaluation ordering which may hide exceptions, even with &lt;a href=&quot;using-optimisation#ghc-flag--fpedantic-bottoms&quot;&gt;&lt;code&gt;-fpedantic-bottoms&lt;/code&gt;&lt;/a&gt; (see, e.g., &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/7411&quot;&gt;Issue #7411&lt;/a&gt;). For instance,</source>
          <target state="translated">&lt;code&gt;state hack&lt;/code&gt; оптимизация может привести к неочевидные изменений в упорядочении оценки , которые могут скрыть исключения, даже с &lt;a href=&quot;using-optimisation#ghc-flag--fpedantic-bottoms&quot;&gt; &lt;code&gt;-fpedantic-bottoms&lt;/code&gt; &lt;/a&gt; (см, например, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/7411&quot;&gt;выпуск № 7411&lt;/a&gt; ). Например,</target>
        </trans-unit>
        <trans-unit id="3fc26580a12c7237de8bc3feeef150e25e82b7eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;template-haskell&lt;/code&gt; library provides &lt;code&gt;Lift&lt;/code&gt; instances for many common data types. Furthermore, it is possible to derive &lt;code&gt;Lift&lt;/code&gt; instances automatically by using the &lt;a href=&quot;#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt; language extension. See &lt;a href=&quot;#deriving-lift&quot;&gt;Deriving Lift instances&lt;/a&gt; for more information.</source>
          <target state="translated">Библиотека &lt;code&gt;template-haskell&lt;/code&gt; предоставляет экземпляры &lt;code&gt;Lift&lt;/code&gt; для многих распространенных типов данных. Кроме того, можно автоматически &lt;a href=&quot;#extension-DeriveLift&quot;&gt; &lt;code&gt;DeriveLift&lt;/code&gt; &lt;/a&gt; экземпляры &lt;code&gt;Lift&lt;/code&gt; с помощью языкового расширения DeriveLift . Дополнительную информацию см. В разделе &lt;a href=&quot;#deriving-lift&quot;&gt;Получение экземпляров лифта&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cc491cbafae8602aedcf7deb49e4b74f8a072567" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;template-haskell&lt;/code&gt; library provides &lt;code&gt;Lift&lt;/code&gt; instances for many common data types. Furthermore, it is possible to derive &lt;code&gt;Lift&lt;/code&gt; instances automatically by using the &lt;a href=&quot;deriving_extra#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt; language extension. See &lt;a href=&quot;deriving_extra#deriving-lift&quot;&gt;Deriving Lift instances&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="979881d56bf63876025a9e6ac559a5d09f689295" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toList&lt;/code&gt; function below lazily transforms a &lt;code&gt;Foldable&lt;/code&gt; structure to a List. Note that this transformation may be lossy, e.g. for a keyed container (&lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;HashMap&lt;/code&gt;, &amp;hellip;) the output stream holds only the values, not the keys. Lossless transformations to/from lists of &lt;code&gt;(key,
 value)&lt;/code&gt; pairs are typically available in the modules for the specific container types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cedaf35635e98aff14e2be2770e441c0a4ccd4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transformers&lt;/code&gt;-style monad transfomer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db916f09ae9ad82e1c17b85b42a3e324b1b316a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;traverse&lt;/code&gt; and &lt;code&gt;mapM&lt;/code&gt; methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adbf9d076f18bc800a1c0458fc70e137b98ee09f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; combinator can for example be used to distinguish identifiers and reserved words. Both reserved words and identifiers are a sequence of letters. Whenever we expect a certain reserved word where we can also expect an identifier we have to use the &lt;code&gt;try&lt;/code&gt; combinator. Suppose we write:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; комбинатор может быть, например, использоваться для различения идентификаторов и зарезервированных слов. И зарезервированные слова, и идентификаторы представляют собой последовательность букв. Когда мы ожидаем определенного зарезервированного слова, где мы также можем ожидать идентификатор, мы должны использовать комбинатор &lt;code&gt;try&lt;/code&gt; . Допустим, мы пишем:</target>
        </trans-unit>
        <trans-unit id="d03c88b23debcedbc11667e18141e6115f243880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; functions</source>
          <target state="translated">В &lt;code&gt;try&lt;/code&gt; функции</target>
        </trans-unit>
        <trans-unit id="9192255b8c683615d80a4ee64628e5e043860b7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type role&lt;/code&gt; (enabled with &lt;a href=&quot;#extension-RoleAnnotations&quot;&gt;&lt;code&gt;RoleAnnotations&lt;/code&gt;&lt;/a&gt;) declaration forces the parameter &lt;code&gt;a&lt;/code&gt; to be at role representational, not role phantom. GHC then checks the user-supplied roles to make sure they don&amp;rsquo;t break any promises. It would be bad, for example, if the user could make &lt;code&gt;BadIdea&lt;/code&gt;&amp;lsquo;s role be representational.</source>
          <target state="translated">&lt;code&gt;type role&lt;/code&gt; (с поддержкой &lt;a href=&quot;#extension-RoleAnnotations&quot;&gt; &lt;code&gt;RoleAnnotations&lt;/code&gt; &lt;/a&gt; ) декларирование силы параметр быть в роли представительские, а не роль фантома. Затем GHC проверяет предоставленные пользователем роли, чтобы убедиться, что они не нарушают никаких обещаний. Было бы плохо, например, если бы пользователь мог сделать роль &lt;code&gt;BadIdea&lt;/code&gt; репрезентативной. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ab97fc80353826963fc8f16937897a7d19ff2bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type role&lt;/code&gt; (enabled with &lt;a href=&quot;#extension-RoleAnnotations&quot;&gt;&lt;code&gt;RoleAnnotations&lt;/code&gt;&lt;/a&gt;) declaration forces the parameter &lt;code&gt;a&lt;/code&gt; to be at role representational, not role phantom. GHC then checks the user-supplied roles to make sure they don&amp;rsquo;t break any promises. It would be bad, for example, if the user could make &lt;code&gt;BadIdea&lt;/code&gt;&amp;rsquo;s role be representational.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbd3777e534f72ef4343d8ae216222c351c56937" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u&lt;/code&gt; statement uses &lt;code&gt;(M.&amp;gt;&amp;gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf4bd8ddd7070927041be90584a981f460d98709" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x &amp;lt;- u&lt;/code&gt; statement uses &lt;code&gt;(M.&amp;gt;&amp;gt;=)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="163ed70634e5daf67472449520f0d0d1c209a86f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; pragma is used only in &lt;code&gt;import&lt;/code&gt; declarations, to break a module loop. It is described in detail in &lt;a href=&quot;../separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b020a7d468bfda2ff2309461d916b84feeabc338" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; pragma is used only in &lt;code&gt;import&lt;/code&gt; declarations, to break a module loop. It is described in detail in &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;.</source>
          <target state="translated">Прагма &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; используется только в объявлениях &lt;code&gt;import&lt;/code&gt; , чтобы разорвать цикл модуля. Это подробно описано в разделе &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;Как компилировать взаимно рекурсивные модули&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c4e367df2b1b94e86aa02176ef763523fb3307a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; annotation must be written in prefix form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee4634b8912c617cc4c956549ecbf5f2fbc8ae6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;global package database&lt;/em&gt;, which comes with your GHC installation, e.g. &lt;code&gt;/usr/lib/ghc-6.12.1/package.conf.d&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Глобальная база данных пакета&lt;/em&gt; , который поставляется в комплекте с установкой GHC, например &lt;code&gt;/usr/lib/ghc-6.12.1/package.conf.d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a81be10d439420dbf2ec989064392ad08ec7838" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;interactive options&lt;/em&gt; apply when evaluating expressions and commands typed at the GHCi prompt.</source>
          <target state="translated">В &lt;em&gt;интерактивные опции&lt;/em&gt; применяются при оценке выражения и команды , введенные в командной строке GHCi.</target>
        </trans-unit>
        <trans-unit id="7491cf46ec5e1fbb15f8b7eb9e41d24a24f00f6a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;k&lt;/em&gt;th match, followed by the remainder of the string</source>
          <target state="translated">&lt;em&gt;К&lt;/em&gt; - й матч, а затем оставшуюся часть строки</target>
        </trans-unit>
        <trans-unit id="bc4c2343b61995f2f1a5ec7cbe01528dd89e1ed3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;loading options&lt;/em&gt; apply when loading modules</source>
          <target state="translated">Параметры &lt;em&gt;загрузки&lt;/em&gt; применяются при загрузке модулей</target>
        </trans-unit>
        <trans-unit id="80049228c8301318bfcd4d99de0d8c4f642d80d1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user package database&lt;/em&gt; private to each user. On Unix systems this will be &lt;code&gt;$HOME/.ghc/arch-os-version/package.conf.d&lt;/code&gt;, and on Windows it will be something like &lt;code&gt;C:\Documents&amp;nbsp;And&amp;nbsp;Settings\user\ghc\package.conf.d&lt;/code&gt;. The &lt;code&gt;ghc-pkg&lt;/code&gt; tool knows where this file should be located, and will create it if it doesn&amp;rsquo;t exist (see &lt;a href=&quot;#package-management&quot;&gt;Package management (the ghc-pkg command)&lt;/a&gt;).</source>
          <target state="translated">База &lt;em&gt;данных пользовательских пакетов является&lt;/em&gt; частной для каждого пользователя. В системах Unix это будет &lt;code&gt;$HOME/.ghc/arch-os-version/package.conf.d&lt;/code&gt; , а в Windows это будет что-то вроде &lt;code&gt;C:\Documents&amp;nbsp;And&amp;nbsp;Settings\user\ghc\package.conf.d&lt;/code&gt; . Инструмент &lt;code&gt;ghc-pkg&lt;/code&gt; знает, где должен находиться этот файл, и создаст его, если он не существует (см. &lt;a href=&quot;#package-management&quot;&gt;Управление пакетами (команда ghc-pkg)&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4df33777d071258dc6c9c7cc4bf4b2806b728297" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;FRList&lt;/code&gt;&lt;/strong&gt; type could be further extended with instances of &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-applicative#t:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;, etc., and could then provide a fully-featured list type, optimised for reuse without space-leaks. If, however, all that's required is space-efficient, re-use friendly iteration, less is perhaps more, and just &lt;code&gt;Foldable&lt;/code&gt; may be sufficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="941913194462867445681166d58a9caadf6e06c1" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/strong&gt; list structure works as an efficient iterator when used just once. When space-leaks via list reuse are not a concern, and/or memoisation is actually desirable, the regular list implementation is likely to be faster. This is not a suggestion to replace all your uses of &lt;strong&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/strong&gt; with a generative alternative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e1c7ee8fcc39fc1932af678408736014433965" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;unFR&lt;/code&gt;&lt;/strong&gt; field of this type is essentially its &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; method with the list as its first rather than last argument. Thus we immediately get a &lt;code&gt;Foldable&lt;/code&gt; instance (and a &lt;code&gt;&lt;a href=&quot;data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; function mapping an &lt;strong&gt;&lt;code&gt;FRList&lt;/code&gt;&lt;/strong&gt; to a regular list).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06291563b1a287d734cf4e445906b8935befc784" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;ghc-pkg&lt;/strong&gt; tool is for querying and modifying package databases. To see what package databases are in use, use &lt;code&gt;ghc-pkg list&lt;/code&gt;. The stack of databases that &lt;strong&gt;ghc-pkg&lt;/strong&gt; knows about can be modified using the &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-10&quot;&gt;&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;&lt;/a&gt; environment variable (see &lt;a href=&quot;#ghc-package-path&quot;&gt;The GHC_PACKAGE_PATH environment variable&lt;/a&gt;, and using &lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-package-db ⟨file⟩&lt;/code&gt;&lt;/a&gt; options on the &lt;strong&gt;ghc-pkg&lt;/strong&gt; command line.</source>
          <target state="translated">Инструмент &lt;strong&gt;ghc-pkg&lt;/strong&gt; предназначен для запроса и изменения баз данных пакетов. Чтобы узнать, какие базы данных пакетов используются, используйте &lt;code&gt;ghc-pkg list&lt;/code&gt; . Стек баз данных, &lt;strong&gt;GHC-PKG&lt;/strong&gt; знает о том, могут быть изменены с помощью &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-10&quot;&gt; &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; &lt;/a&gt; переменной окружения (см &lt;a href=&quot;#ghc-package-path&quot;&gt;Переменная окружения GHC_PACKAGE_PATH&lt;/a&gt; , и используя &lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-package-db ⟨file⟩&lt;/code&gt; &lt;/a&gt; опции на &lt;strong&gt;GHC-упак&lt;/strong&gt; командной строки.</target>
        </trans-unit>
        <trans-unit id="21c02a6f4db72c82bb4b16489a1dc3d9f3dcd251" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;gv&lt;/strong&gt; and &lt;strong&gt;ghostview&lt;/strong&gt; programs have a &amp;ldquo;watch file&amp;rdquo; option can be used to view an up-to-date heap profile of your program as it runs. Simply generate an incremental heap profile as described in the previous section. Run &lt;strong&gt;gv&lt;/strong&gt; on your profile:</source>
          <target state="translated">У программ &lt;strong&gt;gv&lt;/strong&gt; и &lt;strong&gt;ghostview&lt;/strong&gt; есть опция &amp;laquo;смотреть файл&amp;raquo;, которую можно использовать для просмотра актуального профиля кучи вашей программы во время ее выполнения. Просто создайте инкрементный профиль кучи, как описано в предыдущем разделе. Запустите &lt;strong&gt;gv&lt;/strong&gt; в своем профиле:</target>
        </trans-unit>
        <trans-unit id="c2745da38f58a1f51bf9ab0d3486cc161c559b3b" translate="yes" xml:space="preserve">
          <source>The ASCII encoding is a 7-bit encoding. The &lt;em&gt;Char7&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 7-bits, prefixing it with a leading 0, and encoding the resulting 8-bits as a single byte. For the codepoints 0-127 this corresponds the ASCII encoding.</source>
          <target state="translated">Кодировка ASCII - это 7-битная кодировка. &lt;em&gt;Char7&lt;/em&gt; кодирование реализовано здесь работает посредством усечения Unicode элемента кода до 7 бит, префикса с ведущими 0, и кодированием полученных 8 бит в качестве одного байта. Для кодовых точек 0&amp;ndash;127 это соответствует кодировке ASCII.</target>
        </trans-unit>
        <trans-unit id="3335871b5b9fc97a659ecaa26da1b75a25e4dbb8" translate="yes" xml:space="preserve">
          <source>The Accum monad</source>
          <target state="translated">Монада Аккум</target>
        </trans-unit>
        <trans-unit id="54a2a116adb6e3d511623890991b066600f4a837" translate="yes" xml:space="preserve">
          <source>The AccumT monad transformer</source>
          <target state="translated">Трансформатор AccumT monad</target>
        </trans-unit>
        <trans-unit id="e322260aafb4a2f2a2ca6cdac3c65b6a2316bc3a" translate="yes" xml:space="preserve">
          <source>The Any type</source>
          <target state="translated">The Any type</target>
        </trans-unit>
        <trans-unit id="77184a896c809c5987a275354391bcb9afa84715" translate="yes" xml:space="preserve">
          <source>The Binary class</source>
          <target state="translated">Двоичный класс</target>
        </trans-unit>
        <trans-unit id="f21b224c49e198997a984cc9f95eb312adc1246f" translate="yes" xml:space="preserve">
          <source>The Binary instance for ResolvedBCOs.</source>
          <target state="translated">Двоичный экземпляр для ResolvedBCO.</target>
        </trans-unit>
        <trans-unit id="1340d1532cd96c08b9077a17a6e5cf354440ec03" translate="yes" xml:space="preserve">
          <source>The Builder monoid</source>
          <target state="translated">Моноид Строителя</target>
        </trans-unit>
        <trans-unit id="66e06b4ddeb35c347cf81033820bf5237468d89f" translate="yes" xml:space="preserve">
          <source>The Builder type</source>
          <target state="translated">Тип Строителя</target>
        </trans-unit>
        <trans-unit id="6f59e6c207b1a2a380dd7912a6b135a7a6ef6d7e" translate="yes" xml:space="preserve">
          <source>The C call &lt;code&gt;hs_try_putmvar(cap, mvar)&lt;/code&gt; is equivalent to the Haskell call &lt;code&gt;tryPutMVar mvar ()&lt;/code&gt;, except that it is</source>
          <target state="translated">Вызов C &lt;code&gt;hs_try_putmvar(cap, mvar)&lt;/code&gt; эквивалентен вызову Haskell &lt;code&gt;tryPutMVar mvar ()&lt;/code&gt; , за исключением того, что это</target>
        </trans-unit>
        <trans-unit id="930ac2c5a6231d7b293cf2f4934390d97c5dceec" translate="yes" xml:space="preserve">
          <source>The C code generator is only supported when GHC is built in unregisterised mode, a mode where GHC produces &amp;ldquo;portable&amp;rdquo; C code as output to facilitate porting GHC itself to a new platform. This mode produces much slower code though so it&amp;rsquo;s unlikely your version of GHC was built this way. If it has then the native code generator probably won&amp;rsquo;t be available. You can check this information by calling &lt;code&gt;ghc --info&lt;/code&gt; (see &lt;a href=&quot;using#ghc-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Генератор кода C поддерживается только в том случае, если GHC построен в незарегистрированном режиме, режиме, в котором GHC создает &amp;laquo;переносимый&amp;raquo; код C в качестве выходных данных, чтобы облегчить перенос самого GHC на новую платформу. Этот режим производит намного более медленный код, поэтому маловероятно, что ваша версия GHC была построена таким образом. Если да, то генератор машинного кода, вероятно, будет недоступен. Вы можете проверить эту информацию, вызвав &lt;code&gt;ghc --info&lt;/code&gt; (см. &lt;a href=&quot;using#ghc-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a4478e58f6a72e43562ea06bc573417edc1f53b0" translate="yes" xml:space="preserve">
          <source>The C compiler to use (default: &lt;code&gt;gcc&lt;/code&gt;)</source>
          <target state="translated">Используемый компилятор C (по умолчанию: &lt;code&gt;gcc&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e1af0dbad65022684bd70994a6b169612ac3f0f8" translate="yes" xml:space="preserve">
          <source>The C pre-processor &lt;strong&gt;cpp&lt;/strong&gt; is run over your Haskell code if the &lt;code&gt;-cpp&lt;/code&gt; option or &lt;code&gt;-XCPP&lt;/code&gt; extension are given. Unless you are building a large system with significant doses of conditional compilation, you really shouldn&amp;rsquo;t need it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01130faef1141c2e4c47f77d4532a52f8115186a" translate="yes" xml:space="preserve">
          <source>The C pre-processor &lt;strong&gt;cpp&lt;/strong&gt; is run over your Haskell code only if the &lt;code&gt;-cpp&lt;/code&gt; option -cpp option is given. Unless you are building a large system with significant doses of conditional compilation, you really shouldn&amp;rsquo;t need it.</source>
          <target state="translated">C препроцессор &lt;strong&gt;CPP&lt;/strong&gt; запускается через ваш Haskell код , только если &lt;code&gt;-cpp&lt;/code&gt; опция опция -cpp дается. Если вы не создаете большую систему со значительными объемами условной компиляции, она вам действительно не понадобится.</target>
        </trans-unit>
        <trans-unit id="be8a30e9f725c587f4c42c5c2ac8a566321ce4b5" translate="yes" xml:space="preserve">
          <source>The C program is compiled using the Haskell compiler. This provides the include path to &lt;code&gt;HsFFI.h&lt;/code&gt; which is automatically included into the C program.</source>
          <target state="translated">Программа на C компилируется с использованием компилятора Haskell. Это обеспечивает путь включения к &lt;code&gt;HsFFI.h&lt;/code&gt; , который автоматически включается в программу C.</target>
        </trans-unit>
        <trans-unit id="e91fc210907e94074bed36ea19e87412c05ed8a0" translate="yes" xml:space="preserve">
          <source>The C-side interface</source>
          <target state="translated">С-образный интерфейс</target>
        </trans-unit>
        <trans-unit id="7ff7e343e1c6696d97347c4a9cd5a3b43c6bba9e" translate="yes" xml:space="preserve">
          <source>The CPU time used during GC itself</source>
          <target state="translated">Процессорное время,используемое во время работы самого ГХ</target>
        </trans-unit>
        <trans-unit id="9d849fe5e03e42e4cfc89679d13718f7c8ec55fb" translate="yes" xml:space="preserve">
          <source>The CPU time used during the post-mark pause phase of the concurrent nonmoving GC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd9ffd9c0904c0c2f55fc70386db0a7ddaf3815" translate="yes" xml:space="preserve">
          <source>The Chapter &lt;em&gt;does&lt;/em&gt; allow for implementations to move objects around during &lt;code&gt;unsafe&lt;/code&gt; calls as well. So strictly Haskell 2010-conforming programs cannot pass heap-allocated references to &lt;code&gt;unsafe&lt;/code&gt; FFI calls either.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0e04ec6361f33e0d68f7f33f77c1ab233452ad" translate="yes" xml:space="preserve">
          <source>The Chapter does &lt;em&gt;not&lt;/em&gt; require implementations to refrain from doing the same for &lt;code&gt;unsafe&lt;/code&gt; calls, so strictly Haskell 2010-conforming programs cannot pass heap-allocated references to &lt;code&gt;unsafe&lt;/code&gt; FFI calls either.</source>
          <target state="translated">В этой главе &lt;em&gt;не&lt;/em&gt; требуется, чтобы реализации воздерживались от выполнения того же действия для &lt;code&gt;unsafe&lt;/code&gt; вызовов, поэтому программы, строго соответствующие Haskell 2010, также не могут передавать ссылки, размещенные в куче, на &lt;code&gt;unsafe&lt;/code&gt; вызовы FFI.</target>
        </trans-unit>
        <trans-unit id="7a6d8be9dffe246766e3012760ad26dc58ac76a9" translate="yes" xml:space="preserve">
          <source>The Char type and associated operations.</source>
          <target state="translated">Тип Char и связанные с ним операции.</target>
        </trans-unit>
        <trans-unit id="34ab3cac27f3b7905cb71f872510098e1f28d42c" translate="yes" xml:space="preserve">
          <source>The Char8 interface to bytestrings provides an instance of IsString for the ByteString type, enabling you to use string literals, and have them implicitly packed to ByteStrings. Use &lt;code&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/code&gt; to enable this.</source>
          <target state="translated">Интерфейс Char8 для строк байтов предоставляет экземпляр IsString для типа ByteString, что позволяет использовать строковые литералы и неявно упаковывать их в ByteStrings. Используйте &lt;code&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/code&gt; чтобы включить это.</target>
        </trans-unit>
        <trans-unit id="87a20786956ef56773cf03030aa4cf8ea1fe3cb5" translate="yes" xml:space="preserve">
          <source>The Constraint kind</source>
          <target state="translated">Сдерживающий вид</target>
        </trans-unit>
        <trans-unit id="09ab3e32936ccf9f3bb679b6e68a3e00b45ed452" translate="yes" xml:space="preserve">
          <source>The Cont monad</source>
          <target state="translated">Монада Конт</target>
        </trans-unit>
        <trans-unit id="12f452e71f00e2687665dadf2d17184d0289a2e5" translate="yes" xml:space="preserve">
          <source>The ContT monad transformer</source>
          <target state="translated">Трансформатор ContT monad</target>
        </trans-unit>
        <trans-unit id="ca90c83f50ba973fabb4434d084cfad4acdcfc2a" translate="yes" xml:space="preserve">
          <source>The Continuation monad represents computations in continuation-passing style (CPS). In continuation-passing style function result is not returned, but instead is passed to another function, received as a parameter (continuation). Computations are built up from sequences of nested continuations, terminated by a final continuation (often &lt;code&gt;id&lt;/code&gt;) which produces the final result. Since continuations are functions which represent the future of a computation, manipulation of the continuation functions can achieve complex manipulations of the future of the computation, such as interrupting a computation in the middle, aborting a portion of a computation, restarting a computation, and interleaving execution of computations. The Continuation monad adapts CPS to the structure of a monad.</source>
          <target state="translated">Монада продолжения представляет вычисления в стиле передачи продолжения (CPS). В стиле с передачей продолжения результат функции не возвращается, а вместо этого передается другой функции, полученной как параметр (продолжение). Вычисления строятся из последовательностей вложенных продолжений, завершающихся финальным продолжением (часто &lt;code&gt;id&lt;/code&gt; ), которое дает окончательный результат. Поскольку продолжения - это функции, которые представляют будущее вычислений, манипулирование функциями продолжения может достигать сложных манипуляций с будущим вычислений, таких как прерывание вычисления в середине, прерывание части вычисления, перезапуск вычисления и чередование выполнение вычислений. Монада продолжения адаптирует CPS к структуре монады.</target>
        </trans-unit>
        <trans-unit id="b6f5f2130ef6b7cf3dfc8eaaad4cc1b44fc47954" translate="yes" xml:space="preserve">
          <source>The Coverage Condition. For each functional dependency, ⟨tvs⟩&lt;sub&gt;left&lt;/sub&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨tvs⟩&lt;sub&gt;right&lt;/sub&gt;, of the class, every type variable in S(⟨tvs⟩&lt;sub&gt;right&lt;/sub&gt;) must appear in S(⟨tvs⟩&lt;sub&gt;left&lt;/sub&gt;), where S is the substitution mapping each type variable in the class declaration to the corresponding type in the instance head.</source>
          <target state="translated">Условия покрытия. Для каждой функциональной зависимости, ⟨tvs⟩ &lt;sub&gt;left &lt;/sub&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨tvs⟩ &lt;sub&gt;right&lt;/sub&gt; , класса, каждая переменная типа в S (⟨tvs⟩ &lt;sub&gt;right&lt;/sub&gt; ) должна появиться в S (tvs &lt;sub&gt;left&lt;/sub&gt; ), где S - отображение подстановки каждого типа переменная в объявлении класса к соответствующему типу в заголовке экземпляра.</target>
        </trans-unit>
        <trans-unit id="312777d9f2d66605158d20bff22160d55dc26cef" translate="yes" xml:space="preserve">
          <source>The Cygwin tools aim to provide a Unix-style API on top of the windows libraries, to facilitate ports of Unix software to windows. To this end, they introduce a Unix-style directory hierarchy under some root directory (typically &lt;code&gt;/&lt;/code&gt; is &lt;code&gt;C:\cygwin\&lt;/code&gt;). Moreover, everything built against the Cygwin API (including the Cygwin tools and programs compiled with Cygwin&amp;rsquo;s GHC) will see &lt;code&gt;/&lt;/code&gt; as the root of their file system, happily pretending to work in a typical unix environment, and finding things like &lt;code&gt;/bin&lt;/code&gt; and &lt;code&gt;/usr/include&lt;/code&gt; without ever explicitly bothering with their actual location on the windows system (probably &lt;code&gt;C:\cygwin\bin&lt;/code&gt; and &lt;code&gt;C:\cygwin\usr\include&lt;/code&gt;).</source>
          <target state="translated">Инструменты Cygwin стремятся предоставить API в стиле Unix поверх библиотек Windows, чтобы облегчить перенос программного обеспечения Unix в Windows. С этой целью они вводят иерархию каталогов в стиле Unix в некотором корневом каталоге (обычно &lt;code&gt;/&lt;/code&gt; - это &lt;code&gt;C:\cygwin\&lt;/code&gt; ). Более того, все, что создано на основе Cygwin API (включая инструменты и программы Cygwin, скомпилированные с помощью Cygwin GHC), будет видеть &lt;code&gt;/&lt;/code&gt; как корень своей файловой системы, счастливо делая вид, что работает в типичной среде unix, и находя такие вещи, как &lt;code&gt;/bin&lt;/code&gt; и &lt;code&gt;/usr/include&lt;/code&gt; , даже не беспокоясь об их фактическом местонахождении в системе Windows (возможно, &lt;code&gt;C:\cygwin\bin&lt;/code&gt; и &lt;code&gt;C:\cygwin\usr\include&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="86692a9d897be5d534ba24465eb9de8f931f4ef3" translate="yes" xml:space="preserve">
          <source>The Data class for processing constructor applications</source>
          <target state="translated">Класс данных для обработки конструкторских приложений</target>
        </trans-unit>
        <trans-unit id="1bf8237029872b5da672f6b7246e84175ba43046" translate="yes" xml:space="preserve">
          <source>The Dynamic interface provides basic support for dynamic types.</source>
          <target state="translated">Динамический интерфейс обеспечивает базовую поддержку динамических типов.</target>
        </trans-unit>
        <trans-unit id="42156dbee11df6db43f4c8b1cc0a248822a7d3cd" translate="yes" xml:space="preserve">
          <source>The Either type, and associated operations.</source>
          <target state="translated">Любой тип,и связанные с ним операции.</target>
        </trans-unit>
        <trans-unit id="807130fbb4274539dfd3c0eea747aff0499d3550" translate="yes" xml:space="preserve">
          <source>The Error monad (also called the Exception monad).</source>
          <target state="translated">Ошибка-монада (также называемая Исключительной Монадой).</target>
        </trans-unit>
        <trans-unit id="8a5dc0df0c5ba4b15156469d46e722f494c0f012" translate="yes" xml:space="preserve">
          <source>The ErrorT monad transformer</source>
          <target state="translated">Трансформатор ErrorT monad</target>
        </trans-unit>
        <trans-unit id="9e8b0fd8b8d2403326182f44dc58f86de4db1bbe" translate="yes" xml:space="preserve">
          <source>The Except monad</source>
          <target state="translated">За исключением монады.</target>
        </trans-unit>
        <trans-unit id="0636fa085801d03d78d892f99e7194b6c4c5113a" translate="yes" xml:space="preserve">
          <source>The ExceptT monad transformer</source>
          <target state="translated">Трансформатор ExceptT monad</target>
        </trans-unit>
        <trans-unit id="28a34cf6c1c117fe3edc278dd4ce45f5bbb4e2ab" translate="yes" xml:space="preserve">
          <source>The Exception type</source>
          <target state="translated">Тип исключения</target>
        </trans-unit>
        <trans-unit id="fbddbb39610322fadeb3679edecc1231a3f3fbc0" translate="yes" xml:space="preserve">
          <source>The FFI features that are described in this section are specific to GHC. Your code will not be portable to other compilers if you use them.</source>
          <target state="translated">FFI-функции,описанные в этом разделе,специфичны для GHC.Ваш код не будет переноситься на другие компиляторы,если вы их используете.</target>
        </trans-unit>
        <trans-unit id="fa5c3008de574108a3fc529118d05f0ae264146f" translate="yes" xml:space="preserve">
          <source>The FFI libraries are documented in the accompanying library documentation; see for example the &lt;a href=&quot;../../libraries/base-4.15.0.0/foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3efa5246016932362650667f0b2760b9317d9ba9" translate="yes" xml:space="preserve">
          <source>The FFI libraries are documented in the accompanying library documentation; see for example the &lt;a href=&quot;../libraries/base-4.13.0.0/foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">Библиотеки FFI задокументированы в сопроводительной библиотечной документации; см. например &lt;a href=&quot;../libraries/base-4.13.0.0/foreign&quot;&gt;Внешний&lt;/a&gt; модуль.</target>
        </trans-unit>
        <trans-unit id="5ed7160bf5541192af12531389c2d242c62248cf" translate="yes" xml:space="preserve">
          <source>The FFI libraries are documented in the accompanying library documentation; see for example the &lt;a href=&quot;../libraries/base-4.14.1.0/foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761c07d2fa3147d943f9914eb230698128638338" translate="yes" xml:space="preserve">
          <source>The FFI libraries provide several ways to allocate memory for use with the FFI, and it isn&amp;rsquo;t always clear which way is the best. This decision may be affected by how efficient a particular kind of allocation is on a given compiler/platform, so this section aims to shed some light on how the different kinds of allocation perform with GHC.</source>
          <target state="translated">Библиотеки FFI предоставляют несколько способов выделения памяти для использования с FFI, и не всегда ясно, какой из них лучше. Это решение может зависеть от того, насколько эффективен конкретный тип распределения на данном компиляторе / платформе, поэтому этот раздел направлен на то, чтобы пролить свет на то, как различные виды распределения работают с GHC.</target>
        </trans-unit>
        <trans-unit id="f6c805c7ce1959f9f4d5c3417b157ba30228b2de" translate="yes" xml:space="preserve">
          <source>The FFI spec requires the IO monad to appear in various places, but it can sometimes be convenient to wrap the IO monad in a &lt;code&gt;newtype&lt;/code&gt;, thus:</source>
          <target state="translated">Спецификация FFI требует, чтобы монада ввода-вывода появлялась в разных местах, но иногда может быть удобно обернуть монаду ввода-вывода в новый &lt;code&gt;newtype&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="f1df7ad812566b24077279b5c70b3b3b84e28607" translate="yes" xml:space="preserve">
          <source>The FFI spec requires the implementation to support re-initialising itself after being shut down with &lt;code&gt;hs_exit()&lt;/code&gt;, but GHC does not currently support that. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;#13693&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f20794bdc28c9aee5608b0c0fc201d96d6b3994" translate="yes" xml:space="preserve">
          <source>The FFI spec requires the implementation to support re-initialising itself after being shut down with &lt;code&gt;hs_exit()&lt;/code&gt;, but GHC does not currently support that. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;Issue #13693&lt;/a&gt;.</source>
          <target state="translated">Спецификация FFI требует, чтобы реализация поддерживала повторную инициализацию после завершения работы с помощью &lt;code&gt;hs_exit()&lt;/code&gt; , но GHC в настоящее время не поддерживает это. См. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;Выпуск № 13693&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d82e5c0000a3a4523ec1f2606c3f0201a3a2af5" translate="yes" xml:space="preserve">
          <source>The Foldable class represents data structures that can be reduced to a summary value one element at a time. Strict left-associative folds are a good fit for space-efficient reduction, while lazy right-associative folds are a good fit for corecursive iteration, or for folds that short-circuit after processing an initial subsequence of the structure's elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c810fb3026eea84c07b1ddbb163add991beb6f3b" translate="yes" xml:space="preserve">
          <source>The GADT return type (&lt;code&gt;&amp;lt;...&amp;gt; G a (Maybe x) -&amp;gt; ...&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d26ec709c2e5283538c1c653d1aa70ca0b33423" translate="yes" xml:space="preserve">
          <source>The GC sync time, along with other GC stats, are available by calling the &lt;code&gt;getRTSStats()&lt;/code&gt; function from C, or &lt;code&gt;GHC.Stats.getRTSStats&lt;/code&gt; from Haskell.</source>
          <target state="translated">Время синхронизации GC вместе с другой статистикой GC можно получить, вызвав &lt;code&gt;getRTSStats()&lt;/code&gt; из C или &lt;code&gt;GHC.Stats.getRTSStats&lt;/code&gt; из Haskell.</target>
        </trans-unit>
        <trans-unit id="b5021fe9fe3de702f6e9a5d53a92dd7d5114b557" translate="yes" xml:space="preserve">
          <source>The GHC API exposes functions for reading and writing these files.</source>
          <target state="translated">GHC API раскрывает функции для чтения и записи этих файлов.</target>
        </trans-unit>
        <trans-unit id="44e336f3335d4bce26ff1489887e65f02d167072" translate="yes" xml:space="preserve">
          <source>The GHC RTS currently can only recover from heap overflow if it detects that an explicit memory limit (set via RTS flags). has been exceeded. Currently, failure to allocate memory from the operating system results in immediate termination of the program.</source>
          <target state="translated">В настоящее время GHC RTS может восстанавливаться после переполнения кучи только в том случае,если обнаружит превышение явного лимита памяти (установленного с помощью флагов RTS).В настоящее время невыделение памяти из операционной системы приводит к немедленному завершению программы.</target>
        </trans-unit>
        <trans-unit id="092d6db4a6acf8e0f020ffc8e891aef1e6ec0134" translate="yes" xml:space="preserve">
          <source>The GHC command line options that control packages are:</source>
          <target state="translated">Опции командной строки GHC,которые управляют пакетами:</target>
        </trans-unit>
        <trans-unit id="61df44498694cfca7ad6514a046e11ddd08beac9" translate="yes" xml:space="preserve">
          <source>The GHC developers hang out here. If you are working with the GHC API or have a question about GHC&amp;rsquo;s implementation, feel free to chime in.</source>
          <target state="translated">Здесь тусуются разработчики GHC. Если вы работаете с GHC API или у вас есть вопрос о реализации GHC, не стесняйтесь вмешиваться.</target>
        </trans-unit>
        <trans-unit id="99d5e93b8c29504ff8cde4bfb2796cf7747d055b" translate="yes" xml:space="preserve">
          <source>The GHC driver pre-defines several macros when processing Haskell source code (&lt;code&gt;.hs&lt;/code&gt; or &lt;code&gt;.lhs&lt;/code&gt; files).</source>
          <target state="translated">Драйвер GHC предварительно определяет несколько макросов при обработке исходного кода Haskell ( &lt;code&gt;.hs&lt;/code&gt; или &lt;code&gt;.lhs&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="87a5e3c32c7140b14331679393031a63e7e433b2" translate="yes" xml:space="preserve">
          <source>The GHC runtime treats program exit as a special case, to avoid the need to wait for blocked threads when a standalone executable exits. Since the program and all its threads are about to terminate at the same time that the code is removed from memory, it isn&amp;rsquo;t necessary to ensure that the threads have exited first. If you want this fast and loose version of &lt;code&gt;hs_exit()&lt;/code&gt;, you can call:</source>
          <target state="translated">Среда выполнения GHC рассматривает выход из программы как особый случай, чтобы избежать необходимости ждать заблокированных потоков при выходе из автономного исполняемого файла. Поскольку программа и все ее потоки собираются завершить работу одновременно с удалением кода из памяти, нет необходимости гарантировать, что потоки завершились первыми. Если вам нужна эта быстрая и свободная версия &lt;code&gt;hs_exit()&lt;/code&gt; , вы можете вызвать:</target>
        </trans-unit>
        <trans-unit id="cf6aec65a614d7a8b43aacde5373b850e4763ef9" translate="yes" xml:space="preserve">
          <source>The GHCi &lt;a href=&quot;../ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; command shows pattern types in this format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657d0403b8cb260dd76b91b660bfb82ac7e59695" translate="yes" xml:space="preserve">
          <source>The GHCi &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; command shows pattern types in this format.</source>
          <target state="translated">Команда GHCi &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt; &lt;code&gt;:info&lt;/code&gt; &lt;/a&gt; показывает типы шаблонов в этом формате.</target>
        </trans-unit>
        <trans-unit id="b98fc3571126a85946312283e8cabf74b5c92953" translate="yes" xml:space="preserve">
          <source>The GHCi Monad lifting interface.</source>
          <target state="translated">Подъемный интерфейс GHCi Monad.</target>
        </trans-unit>
        <trans-unit id="ebe9d3dd8c4ab5bd81e3a57040f569e196489a32" translate="yes" xml:space="preserve">
          <source>The GHCi debugger offers a way to hopefully shed some light on these errors quickly and without modifying or recompiling the source code. One way would be to set a breakpoint on the location in the source code that throws the exception, and then use &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:history&quot;&gt;&lt;code&gt;:history&lt;/code&gt;&lt;/a&gt; to establish the context. However, &lt;code&gt;head&lt;/code&gt; is in a library and we can&amp;rsquo;t set a breakpoint on it directly. For this reason, GHCi provides the flags &lt;a href=&quot;#ghc-flag--fbreak-on-exception&quot;&gt;&lt;code&gt;-fbreak-on-exception&lt;/code&gt;&lt;/a&gt; which causes the evaluator to stop when an exception is thrown, and &lt;a href=&quot;#ghc-flag--fbreak-on-error&quot;&gt;&lt;code&gt;-fbreak-on-error&lt;/code&gt;&lt;/a&gt;, which works similarly but stops only on uncaught exceptions. When stopping at an exception, GHCi will act just as it does when a breakpoint is hit, with the deviation that it will not show you any source code location. Due to this, these commands are only really useful in conjunction with &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;, in order to log the steps leading up to the exception. For example:</source>
          <target state="translated">Отладчик GHCi предлагает способ, как мы надеемся, пролить свет на эти ошибки быстро и без изменения или перекомпиляции исходного кода. Один из способов - установить точку останова в том месте исходного кода, которое вызывает исключение, а затем использовать &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#ghci-cmd-:history&quot;&gt; &lt;code&gt;:history&lt;/code&gt; &lt;/a&gt; для установления контекста. Однако &lt;code&gt;head&lt;/code&gt; находится в библиотеке, и мы не можем установить для нее точку останова напрямую. По этой причине GHCi предоставляет флаги &lt;a href=&quot;#ghc-flag--fbreak-on-exception&quot;&gt; &lt;code&gt;-fbreak-on-exception&lt;/code&gt; ,&lt;/a&gt; заставляющие оценщик останавливаться при возникновении исключения, и &lt;a href=&quot;#ghc-flag--fbreak-on-error&quot;&gt; &lt;code&gt;-fbreak-on-error&lt;/code&gt; &lt;/a&gt;, который работает аналогично, но останавливается только при неперехваченных исключениях. При остановке при исключении GHCi будет действовать так же, как и при достижении точки останова, с той лишь разницей, что он не покажет вам расположение исходного кода. Из-за этого эти команды действительно полезны только вместе с &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt; , чтобы регистрировать шаги, ведущие к исключению. Например:</target>
        </trans-unit>
        <trans-unit id="0b891d2a1ce80a9fee00fa3b6d6737a43b10a747" translate="yes" xml:space="preserve">
          <source>The Get and Put monads</source>
          <target state="translated">The Get and Put monads</target>
        </trans-unit>
        <trans-unit id="b776a2d45a7f2c193506de5827ffca159fdaaa31" translate="yes" xml:space="preserve">
          <source>The Get monad</source>
          <target state="translated">The Get monad</target>
        </trans-unit>
        <trans-unit id="881d557edd11af5e9c88e4e2caa565a9b7f16b2b" translate="yes" xml:space="preserve">
          <source>The Handle is closed once the contents have been read, or if an exception is thrown.</source>
          <target state="translated">Ручка закрывается после прочтения содержимого,или если выбрасывается исключение.</target>
        </trans-unit>
        <trans-unit id="7aa13d6fda768933256ad6bc36a2d66a70dfef90" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 Report specifies that &lt;code&gt;safe&lt;/code&gt; FFI calls must allow foreign calls to safely call into Haskell code. In practice, this means that called functions also have to assume heap-allocated Haskell values may move around arbitrarily in order to allow for GC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc6da9c66a23f0d4306adb850fbe34a26d020b4" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 Report specifies that &lt;code&gt;safe&lt;/code&gt; FFI calls must allow foreign calls to safely call into Haskell code. In practice, this means that the garbage collector must be able to run while these calls are in progress, moving heap-allocated Haskell values around arbitrarily.</source>
          <target state="translated">В отчете Haskell 2010 указано, что &lt;code&gt;safe&lt;/code&gt; вызовы FFI должны позволять внешним вызовам безопасно вызывать код Haskell. На практике это означает, что сборщик мусора должен иметь возможность запускаться во время выполнения этих вызовов, произвольно перемещая значения Haskell, выделенные в куче.</target>
        </trans-unit>
        <trans-unit id="e4f4e3694b9cec057dc91d201d6594fcb8794184" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 definition of &lt;code&gt;Show&lt;/code&gt; stipulates that the rendered string should only include parentheses which are necessary to unambiguously parse the result. For historical reasons, &lt;code&gt;Show&lt;/code&gt; instances derived by GHC include parentheses around records despite the fact that record syntax binds more tightly than function application; e.g.,</source>
          <target state="translated">Определение &lt;code&gt;Show&lt;/code&gt; в Haskell 2010 предусматривает, что отображаемая строка должна включать только круглые скобки, необходимые для однозначного анализа результата. По историческим причинам экземпляры &lt;code&gt;Show&lt;/code&gt; , производные GHC, включают круглые скобки вокруг записей, несмотря на то, что синтаксис записи связывает более жестко, чем приложение функции; например,</target>
        </trans-unit>
        <trans-unit id="75b51a038a288722ea47d665ae6b1906f2f2ca30" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип Haskell 2010 для исключений в монаде &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; . Любая операция ввода-вывода может вызвать &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; вместо возврата результата. Для более общего типа исключений, включая те, которые возникают в чистом коде, см. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0ce36d06fc25e64c6b77302cc8e5115d7e36509" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f5848499bd728182625d195bb7424161811e1c" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb081bfa52eb8a4cbf05cd929cfffa397e641c26" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип Haskell 2010 для исключений в монаде &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; . Любая операция ввода-вывода может вызвать &lt;code&gt;&lt;a href=&quot;prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; вместо возврата результата. Для более общего типа исключений, включая те, которые возникают в чистом коде, см. &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a99410a64c91a4399b3bdd6ca6ecba63bbee421d" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип Haskell 2010 для исключений в монаде &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; . Любая операция ввода-вывода может вызвать &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; вместо возврата результата. Для более общего типа исключений, включая те, которые возникают в чистом коде, см. &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="608a1f6c6546f6329017b0ba471b028aef303e51" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип Haskell 2010 для исключений в монаде &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; . Любая операция ввода-вывода может вызвать &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; вместо возврата результата. Для более общего типа исключений, включая те, которые возникают в чистом коде, см. &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbd1a39cbde2acf402014630435be0c05fcd70ac" translate="yes" xml:space="preserve">
          <source>The Haskell 98 definition of &lt;code&gt;isAlpha&lt;/code&gt; is:</source>
          <target state="translated">Определение &lt;code&gt;isAlpha&lt;/code&gt; в Haskell 98 :</target>
        </trans-unit>
        <trans-unit id="bcc5878839ee58bc74d82cc3033b4e47a4421ec2" translate="yes" xml:space="preserve">
          <source>The Haskell FFI already specifies that arguments and results of foreign imports and exports will be automatically unwrapped if they are newtypes (Section 3.2 of the FFI addendum). GHC extends the FFI by automatically unwrapping any newtypes that wrap the IO monad itself. More precisely, wherever the FFI specification requires an &lt;code&gt;IO&lt;/code&gt; type, GHC will accept any newtype-wrapping of an &lt;code&gt;IO&lt;/code&gt; type. For example, these declarations are OK:</source>
          <target state="translated">FFI Haskell уже указывает, что аргументы и результаты внешнего импорта и экспорта будут автоматически разворачиваться, если они являются новыми типами (раздел 3.2 приложения FFI). GHC расширяет FFI, автоматически разворачивая все новые типы, которые обертывают саму монаду ввода-вывода. Точнее, везде, где спецификация FFI требует тип &lt;code&gt;IO&lt;/code&gt; , GHC примет любое обертывание &lt;code&gt;IO&lt;/code&gt; типа для типа ввода-вывода . Например, эти объявления допустимы:</target>
        </trans-unit>
        <trans-unit id="4680c4ac34e14b7370d55faae60bc019d40c3efc" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; is customarily expected to implement an equivalence relationship where two values comparing equal are indistinguishable by &quot;public&quot; functions, with a &quot;public&quot; function being one not allowing to see implementation details. For example, for a type representing non-normalised natural numbers modulo 100, a &quot;public&quot; function doesn't make the difference between 1 and 201. It is expected to have the following properties:</source>
          <target state="translated">Отчет Haskell не определяет законов для &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; . Однако обычно ожидается , что &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; реализует отношение эквивалентности, где два сравниваемых значения неотличимы для &amp;laquo;общедоступных&amp;raquo; функций, при этом &amp;laquo;общедоступная&amp;raquo; функция не позволяет видеть детали реализации. Например, для типа, представляющего ненормализованные натуральные числа по модулю 100, &amp;laquo;общедоступная&amp;raquo; функция не делает разницы между 1 и 201. Ожидается, что она будет иметь следующие свойства:</target>
        </trans-unit>
        <trans-unit id="b435dd60d544eb355fdb3b5a53612290c22abfda" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;data-ord#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; is customarily expected to implement a non-strict partial order and have the following properties:</source>
          <target state="translated">Отчет Haskell не определяет законов для &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; . Однако обычно ожидается , что &lt;code&gt;&lt;a href=&quot;data-ord#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; реализует нестрогий частичный порядок и имеет следующие свойства:</target>
        </trans-unit>
        <trans-unit id="88538894fe954a03ab344dde58ca70fb4af218ac" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="translated">В отчете Haskell нет никаких законов для &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; . Однако обычно ожидается , что &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; , &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-float#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; определяют экспоненциальное поле и имеют следующие свойства:</target>
        </trans-unit>
        <trans-unit id="3149c28629f6ab1e2da394471685318956b0ba8a" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a ring and have the following properties:</source>
          <target state="translated">Отчет Haskell не определяет законов для &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; . Однако обычно предполагается , что &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; определяют кольцо и обладают следующими свойствами:</target>
        </trans-unit>
        <trans-unit id="8d88eda2762d9273ae973553c58bcc0bd71af620" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a division ring and have the following properties:</source>
          <target state="translated">В отчете Haskell нет никаких законов для &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; . Однако обычно предполагается , что &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; определяют разделительное кольцо и обладают следующими свойствами:</target>
        </trans-unit>
        <trans-unit id="e76164abdc0256cd6250a3085c5fb79d40aac6bd" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; instances are customarily expected to define a Euclidean domain and have the following properties for the &lt;code&gt;&lt;a href=&quot;ghc-real#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;ghc-real#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;ghc-real#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; pairs, given suitable Euclidean functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;:</source>
          <target state="translated">Отчет Haskell не определяет законов для &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; . Однако обычно предполагается , что экземпляры &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; определяют евклидову область и имеют следующие свойства для пар &lt;code&gt;&lt;a href=&quot;ghc-real#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;ghc-real#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-real#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;ghc-real#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; , учитывая подходящие евклидовы функции &lt;code&gt;f&lt;/code&gt; и &lt;code&gt;g&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9ce7650ff72472c9e39924a0365fbdbae6a3a423" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;numeric#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="translated">В отчете Haskell нет никаких законов для &lt;code&gt;&lt;a href=&quot;numeric#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; . Однако обычно ожидается , что &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; , &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;numeric#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; определяют экспоненциальное поле и имеют следующие свойства:</target>
        </trans-unit>
        <trans-unit id="8323805ef3fcd8127cc342507191554f2e774a6e" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; is customarily expected to implement an equivalence relationship where two values comparing equal are indistinguishable by &quot;public&quot; functions, with a &quot;public&quot; function being one not allowing to see implementation details. For example, for a type representing non-normalised natural numbers modulo 100, a &quot;public&quot; function doesn't make the difference between 1 and 201. It is expected to have the following properties:</source>
          <target state="translated">Отчет Haskell не определяет законов для &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; . Однако обычно ожидается , что &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; реализует отношение эквивалентности, где два сравниваемых значения неотличимы для &amp;laquo;общедоступных&amp;raquo; функций, при этом &amp;laquo;общедоступная&amp;raquo; функция не позволяет видеть детали реализации. Например, для типа, представляющего ненормализованные натуральные числа по модулю 100, &amp;laquo;общедоступная&amp;raquo; функция не делает разницы между 1 и 201. Ожидается, что она будет иметь следующие свойства:</target>
        </trans-unit>
        <trans-unit id="b48c329c20a3981396eab2a99555375b78674fa9" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="translated">В отчете Haskell нет никаких законов для &lt;code&gt;&lt;a href=&quot;prelude#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; . Однако обычно ожидается , что &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; , &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; определяют экспоненциальное поле и имеют следующие свойства:</target>
        </trans-unit>
        <trans-unit id="1c7fa25d86a0693f27eca0a0ad84f5518dec11cf" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a division ring and have the following properties:</source>
          <target state="translated">В отчете Haskell нет никаких законов для &lt;code&gt;&lt;a href=&quot;prelude#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; . Однако обычно предполагается , что &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; определяют разделительное кольцо и обладают следующими свойствами:</target>
        </trans-unit>
        <trans-unit id="813c73ced84a637d883552041de27732ad7f49d9" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; instances are customarily expected to define a Euclidean domain and have the following properties for the &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; pairs, given suitable Euclidean functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;:</source>
          <target state="translated">Отчет Haskell не определяет законов для &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; . Однако обычно предполагается , что экземпляры &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; определяют евклидову область и имеют следующие свойства для пар &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; , учитывая подходящие евклидовы функции &lt;code&gt;f&lt;/code&gt; и &lt;code&gt;g&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="04a2d6720afe45625eeed33bd966e63b2869f306" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a ring and have the following properties:</source>
          <target state="translated">Отчет Haskell не определяет законов для &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; . Однако обычно предполагается , что &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; определяют кольцо и обладают следующими свойствами:</target>
        </trans-unit>
        <trans-unit id="79c8c45566ea3ef649482a06f412a05df4a6acfa" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; is customarily expected to implement a non-strict partial order and have the following properties:</source>
          <target state="translated">Отчет Haskell не определяет законов для &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; . Однако обычно ожидается , что &lt;code&gt;&lt;a href=&quot;prelude#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; реализует нестрогий частичный порядок и имеет следующие свойства:</target>
        </trans-unit>
        <trans-unit id="d6f54f30ee874469ea4834b2c92a3bff6d9a4e7e" translate="yes" xml:space="preserve">
          <source>The Haskell Report demands that, for infix operators &lt;code&gt;%&lt;/code&gt;, the following identities hold:</source>
          <target state="translated">Отчет Haskell требует, чтобы для инфиксных операторов &lt;code&gt;%&lt;/code&gt; выполнялись следующие идентификаторы:</target>
        </trans-unit>
        <trans-unit id="fda99c30e66a8cf02c9c342a9bf010a7836b92f1" translate="yes" xml:space="preserve">
          <source>The Haskell Report describes that &lt;code&gt;*&lt;/code&gt; (spelled &lt;code&gt;Type&lt;/code&gt; and imported from &lt;code&gt;Data.Kind&lt;/code&gt; in the GHC dialect of Haskell) is the kind of ordinary datatypes, such as &lt;code&gt;Int&lt;/code&gt;. Furthermore, type constructors can have kinds with arrows; for example, &lt;code&gt;Maybe&lt;/code&gt; has kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. Unboxed types have a kind that specifies their runtime representation. For example, the type &lt;code&gt;Int#&lt;/code&gt; has kind &lt;code&gt;TYPE 'IntRep&lt;/code&gt; and &lt;code&gt;Double#&lt;/code&gt; has kind &lt;code&gt;TYPE 'DoubleRep&lt;/code&gt;. These kinds say that the runtime representation of an &lt;code&gt;Int#&lt;/code&gt; is a machine integer, and the runtime representation of a &lt;code&gt;Double#&lt;/code&gt; is a machine double-precision floating point. In contrast, the kind &lt;code&gt;Type&lt;/code&gt; is actually just a synonym for &lt;code&gt;TYPE
'LiftedRep&lt;/code&gt;. More details of the &lt;code&gt;TYPE&lt;/code&gt; mechanisms appear in the &lt;a href=&quot;#runtime-rep&quot;&gt;section on runtime representation polymorphism&lt;/a&gt;.</source>
          <target state="translated">В отчете Haskell описывается, что &lt;code&gt;*&lt;/code&gt; (пишется &lt;code&gt;Type&lt;/code&gt; и импортировано из &lt;code&gt;Data.Kind&lt;/code&gt; на диалекте GHC Haskell) является видом обычных типов данных, таких как &lt;code&gt;Int&lt;/code&gt; . Более того, конструкторы типов могут иметь виды со стрелками; например, &lt;code&gt;Maybe&lt;/code&gt; имеет вид &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; . Распакованные типы имеют вид, определяющий их представление во время выполнения. Например, тип &lt;code&gt;Int#&lt;/code&gt; имеет вид &lt;code&gt;TYPE 'IntRep&lt;/code&gt; , а тип &lt;code&gt;Double#&lt;/code&gt; имеет вид &lt;code&gt;TYPE 'DoubleRep&lt;/code&gt; . Эти типы говорят, что представление среды выполнения &lt;code&gt;Int#&lt;/code&gt; является машинным целым числом, а представление среды выполнения &lt;code&gt;Double#&lt;/code&gt; - это машина с плавающей запятой двойной точности. Напротив, вид &lt;code&gt;Type&lt;/code&gt; на самом деле является синонимом &lt;code&gt;TYPE 'LiftedRep&lt;/code&gt; . Более подробная информация о механизмах &lt;code&gt;TYPE&lt;/code&gt; представлена ​​в &lt;a href=&quot;#runtime-rep&quot;&gt;разделе, посвященном полиморфизму представления среды выполнения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ffc08730dc1e1e7dc18e8e0b58ddcb43b8e6870" translate="yes" xml:space="preserve">
          <source>The Haskell Report is vague about exactly when a &lt;code&gt;deriving&lt;/code&gt; clause is legal. For example:</source>
          <target state="translated">В отчете Haskell неясно, когда именно &lt;code&gt;deriving&lt;/code&gt; предложение является законным. Например:</target>
        </trans-unit>
        <trans-unit id="90561213a1b6d66157821a9e10425e8dc3a64c9d" translate="yes" xml:space="preserve">
          <source>The Haskell Report only requires implementations to provide tuple types and their accompanying standard instances up to size 15. GHC limits the size of tuple types to 62 and provides instances of &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, &lt;code&gt;Show&lt;/code&gt;, and &lt;code&gt;Ix&lt;/code&gt; for tuples up to size 15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac5deab8ae658158332cbfbbabb6e8e4c0757f95" translate="yes" xml:space="preserve">
          <source>The Haskell Report only requires implementations to provide tuple types and their accompanying standard instances up to size 15. GHC limits the size of tuple types to 62 and provides instances of &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt; for tuples up to size 15. However, &lt;code&gt;Ix&lt;/code&gt; instances are provided only for tuples up to size 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd54d84f1861492e330313f2bf345ca47769e1b" translate="yes" xml:space="preserve">
          <source>The Haskell Report specifies that a group of bindings (at top level, or in a &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt;) should be sorted into strongly-connected components, and then type-checked in dependency order (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.1&quot;&gt;Haskell Report, Section 4.5.1&lt;/a&gt;). As each group is type-checked, any binders of the group that have an explicit type signature are put in the type environment with the specified polymorphic type, and all others are monomorphic until the group is generalised (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.2&quot;&gt;Haskell Report, Section 4.5.2&lt;/a&gt;).</source>
          <target state="translated">В отчете Haskell указано, что группа привязок (на верхнем уровне, в &lt;code&gt;let&lt;/code&gt; или &lt;code&gt;where&lt;/code&gt; ) должна быть отсортирована по сильно связанным компонентам, а затем проверяться типом в порядке зависимости ( &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.1&quot;&gt;Отчет Haskell, раздел 4.5.1&lt;/a&gt; ). Поскольку каждая группа проверяется на тип, любые связующие группы, которые имеют явную сигнатуру типа, помещаются в среду типов с указанным полиморфным типом, а все остальные являются мономорфными до тех пор, пока группа не будет обобщена ( &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.2&quot;&gt;Отчет Haskell, раздел 4.5.2&lt;/a&gt; ) ,</target>
        </trans-unit>
        <trans-unit id="8b75c250a4a929abcdfd7f96fd88dc38f5bfcd9e" translate="yes" xml:space="preserve">
          <source>The Haskell Report specifies that a group of bindings (at top level, or in a &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt;) should be sorted into strongly-connected components, and then type-checked in dependency order (&lt;a href=&quot;https://www.haskell.org/onlinereport/decls.html#sect4.5.1&quot;&gt;Haskell Report, Section 4.5.1&lt;/a&gt;). As each group is type-checked, any binders of the group that have an explicit type signature are put in the type environment with the specified polymorphic type, and all others are monomorphic until the group is generalised (&lt;a href=&quot;https://www.haskell.org/onlinereport/decls.html#sect4.5.2&quot;&gt;Haskell Report, Section 4.5.2&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f79c4bbad9a41e128d187b8c2ef86a8f611b12b5" translate="yes" xml:space="preserve">
          <source>The Haskell code in a package may be built into one or more archive libraries (e.g. &lt;code&gt;libHSfoo.a&lt;/code&gt;), or a single shared object (e.g. &lt;code&gt;libHSfoo.dll/.so/.dylib&lt;/code&gt;). The restriction to a single shared object is because the package system is used to tell the compiler when it should make an inter-shared-object call rather than an intra-shared-object-call call (inter-shared-object calls require an extra indirection).</source>
          <target state="translated">Код Haskell в пакете может быть встроен в одну или несколько архивных библиотек (например, &lt;code&gt;libHSfoo.a&lt;/code&gt; ) или один общий объект (например, &lt;code&gt;libHSfoo.dll/.so/.dylib&lt;/code&gt; ). Ограничение для одного общего объекта связано с тем, что система пакетов используется для того, чтобы сообщить компилятору, когда он должен выполнить вызов между общим объектом, а не вызов внутри общего объекта (вызовы между общими объектами требуют дополнительных Косвенная).</target>
        </trans-unit>
        <trans-unit id="0c75300a05da2e87e80a93270dd95d3e5ff6d9a5" translate="yes" xml:space="preserve">
          <source>The Haskell implementation with which the program was compiled or is being interpreted.</source>
          <target state="translated">Реализация Haskell,с помощью которой программа была скомпилирована или интерпретируется.</target>
        </trans-unit>
        <trans-unit id="60ce9c55f4fa0cf40f27dcde7ee4087164650d58" translate="yes" xml:space="preserve">
          <source>The Haskell implementation with which the program was compiled or is being interpreted. On the GHC platform, the value is &quot;ghc&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bcb6ef9eb76436588cc0d8da0bf323ce2da12ae" translate="yes" xml:space="preserve">
          <source>The Haskell report &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;defines&lt;/a&gt; the &lt;code&gt;lexp&lt;/code&gt; nonterminal thus (&lt;code&gt;*&lt;/code&gt; indicates a rule of interest)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f87244b686c50c8127fd2dc9c33f53eb1c0ecb" translate="yes" xml:space="preserve">
          <source>The Haskell report &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;defines&lt;/a&gt; the &lt;code&gt;lexp&lt;/code&gt; nonterminal thus (&lt;code&gt;*&lt;/code&gt; indicates a rule of interest):</source>
          <target state="translated">Отчет Haskell &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;определяет&lt;/a&gt; в &lt;code&gt;lexp&lt;/code&gt; нетерминальное таким образом ( &lt;code&gt;*&lt;/code&gt; указывает правило интереса):</target>
        </trans-unit>
        <trans-unit id="75d99185af7621d262f47061ebc9fcce26c3d99a" translate="yes" xml:space="preserve">
          <source>The Haskell2010 Report specifies in &amp;lt;&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&lt;/a&gt;&amp;gt; that</source>
          <target state="translated">Отчет Haskell2010 указывает в &amp;lt; &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&lt;/a&gt; &amp;gt;, что</target>
        </trans-unit>
        <trans-unit id="85d12b1c3d53edaed978aecf46c9e3e3b26b841c" translate="yes" xml:space="preserve">
          <source>The I/O SubSystem to use in the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18dcf9c1fa4567e3d746274c7c15cc6b75881bbb" translate="yes" xml:space="preserve">
          <source>The IO monad</source>
          <target state="translated">Монада ввода-вывода</target>
        </trans-unit>
        <trans-unit id="fc0f546679107f369d6f8715d864a3e34b5c091c" translate="yes" xml:space="preserve">
          <source>The IOArray type</source>
          <target state="translated">Тип IOArray</target>
        </trans-unit>
        <trans-unit id="737d5b10a286b500beaf74123af646266a400fbd" translate="yes" xml:space="preserve">
          <source>The IOMode type</source>
          <target state="translated">Тип IOMode</target>
        </trans-unit>
        <trans-unit id="65b73403a619cdf0ecd51edadceb4eff94590c0c" translate="yes" xml:space="preserve">
          <source>The IORef type</source>
          <target state="translated">Тип IORef</target>
        </trans-unit>
        <trans-unit id="558e32d8065fb827c731043184d460a503306a06" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding.</source>
          <target state="translated">Кодировка ISO / IEC 8859-1 - это 8-битная кодировка, часто известная как Latin-1. &lt;em&gt;Char8&lt;/em&gt; кодирование реализовано здесь работает усечение Unicode в элементе кода 8 бит и кодировании их в виде одного байта. Для кодовых точек 0-255 это соответствует кодировке ISO / IEC 8859-1.</target>
        </trans-unit>
        <trans-unit id="54ad98c5ffd0b94e42a9d57326f087c3d7345412" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding. Note that the Char8 encoding is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with Char8 encoded characters.</source>
          <target state="translated">Кодировка ISO / IEC 8859-1 - это 8-битная кодировка, часто известная как Latin-1. &lt;em&gt;Char8&lt;/em&gt; кодирование реализовано здесь работает усечение Unicode в элементе кода 8 бит и кодировании их в виде одного байта. Для кодовых точек 0-255 это соответствует кодировке ISO / IEC 8859-1. Обратите внимание, что кодировка Char8 эквивалентна кодировке ASCII в кодовых точках Unicode 0&amp;ndash;127. Следовательно, такие функции, как &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; , также могут использоваться для кодирования &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; как десятичного числа с закодированными символами Char8.</target>
        </trans-unit>
        <trans-unit id="49fa9b80f4fa24e3bcc0042f7b61d0c844f15e6b" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding. Note that the Char8 encoding is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with Char8 encoded characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c77ebed88d6a61f3f19c1021d1825a839754219" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding. Note that the Char8 encoding is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with Char8 encoded characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c479ee79f8f50aa3dcf64e97781e845a99daa98d" translate="yes" xml:space="preserve">
          <source>The InputT monad transformer</source>
          <target state="translated">Трансформатор InputT monad</target>
        </trans-unit>
        <trans-unit id="f02dbfae6923c5fae8b765773db367457b1cef47" translate="yes" xml:space="preserve">
          <source>The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to the first 256 Unicode code points, and is thus not a complete Unicode encoding. An attempt to write a character greater than &lt;code&gt;'\255'&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; encoding will result in an error.</source>
          <target state="translated">Кодировка Latin1 (ISO8859-1). Эта кодировка отображает байты непосредственно в первые 256 кодовых точек Unicode и, таким образом, не является полной кодировкой Unicode. Попытка написать Greater характер , чем &lt;code&gt;'\255'&lt;/code&gt; с &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; с использованием &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; кодирования приведет к ошибке.</target>
        </trans-unit>
        <trans-unit id="ddf2c2b44bf1b6f9d563c7f3800d62394c65a764" translate="yes" xml:space="preserve">
          <source>The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to the first 256 Unicode code points, and is thus not a complete Unicode encoding. An attempt to write a character greater than &lt;code&gt;'\255'&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; encoding will result in an error.</source>
          <target state="translated">Кодировка Latin1 (ISO8859-1). Эта кодировка отображает байты непосредственно в первые 256 кодовых точек Unicode и, таким образом, не является полной кодировкой Unicode. Попытка написать Greater характер , чем &lt;code&gt;'\255'&lt;/code&gt; с &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; с использованием &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; кодирования приведет к ошибке.</target>
        </trans-unit>
        <trans-unit id="680f8c637bf3c21d4334aa840c68f7b1c0426e80" translate="yes" xml:space="preserve">
          <source>The List data type and its operations</source>
          <target state="translated">Тип данных Перечня и его операции</target>
        </trans-unit>
        <trans-unit id="527e8dadea35f6a4f5c4a4c4be123089c5e69c00" translate="yes" xml:space="preserve">
          <source>The List monad.</source>
          <target state="translated">Монада Списка.</target>
        </trans-unit>
        <trans-unit id="8aba302b7e58fc590a9afdc1a01080baae6e6ec1" translate="yes" xml:space="preserve">
          <source>The ListT monad transformer</source>
          <target state="translated">Трансформатор ListT monad</target>
        </trans-unit>
        <trans-unit id="ba07cd406a34170d4f0ecfa83e506b98d6f30534" translate="yes" xml:space="preserve">
          <source>The ListT monad transformer, adding backtracking to a given monad, which must be commutative.</source>
          <target state="translated">Трансформатор ListT monad,добавляющий обратное движение к заданной монаде,которое должно быть коммутативным.</target>
        </trans-unit>
        <trans-unit id="e0495cc6e831dd99a09b6b22275801501a83fb2b" translate="yes" xml:space="preserve">
          <source>The MVar type</source>
          <target state="translated">Тип MVar</target>
        </trans-unit>
        <trans-unit id="46396b237f9d18bcd799cea896a2640dfd6df348" translate="yes" xml:space="preserve">
          <source>The Maybe type, and associated operations.</source>
          <target state="translated">Тип &quot;Может быть&quot; и связанные с ним операции.</target>
        </trans-unit>
        <trans-unit id="e744e9e0cfe46515ef9f5bb52e48c6c750bbb1e5" translate="yes" xml:space="preserve">
          <source>The MaybeT monad transformer</source>
          <target state="translated">Трансформатор MaybeT monad</target>
        </trans-unit>
        <trans-unit id="4126903c0c38cb737f94266782af2c525510b404" translate="yes" xml:space="preserve">
          <source>The Modified Julian Date is the day with the fraction of the day, measured from UT midnight. It's used to represent UT1, which is time as measured by the earth's rotation, adjusted for various wobbles.</source>
          <target state="translated">Модифицированная юлианская дата-это день с долей дня,измеренной от полночи UT.Она используется для представления UT1,то есть времени,измеряемого вращением Земли,скорректированного для различных колебаний.</target>
        </trans-unit>
        <trans-unit id="d4fd231b0228fbbb56527d9186f84060d50a59d7" translate="yes" xml:space="preserve">
          <source>The Modified Julian Day is a standard count of days, with zero being the day 1858-11-17.</source>
          <target state="translated">Модифицированный юлианский день-это стандартный счетчик дней,ноль-день 1858-11-17.</target>
        </trans-unit>
        <trans-unit id="c771c28ba6943eb0fbd701bba8effdfe529aa2b4" translate="yes" xml:space="preserve">
          <source>The MonadException class</source>
          <target state="translated">Класс MonadException</target>
        </trans-unit>
        <trans-unit id="ad32074e930158647c5d3c0d66a82e352b9530f7" translate="yes" xml:space="preserve">
          <source>The MonadWriter class.</source>
          <target state="translated">Класс MonadWriter.</target>
        </trans-unit>
        <trans-unit id="51acf2e9a1f450466332b8327436f6eceb7c3f17" translate="yes" xml:space="preserve">
          <source>The Monomorphism Restriction is disabled (see &lt;a href=&quot;exts/monomorphism#monomorphism&quot;&gt;Switching off the Monomorphism Restriction&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01bbf48e477c92aa3644550cb6f1cc37d1a0b1f" translate="yes" xml:space="preserve">
          <source>The Monomorphism Restriction is disabled (see &lt;a href=&quot;glasgow_exts#monomorphism&quot;&gt;Switching off the dreaded Monomorphism Restriction&lt;/a&gt;).</source>
          <target state="translated">Ограничение мономорфизма отключено (см. &lt;a href=&quot;glasgow_exts#monomorphism&quot;&gt;Отключение ужасного ограничения мономорфизма&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bfaad71abe81d69b989cc169fbd7881a4139c40a" translate="yes" xml:space="preserve">
          <source>The NT kernel however allows you ways to opt out of this path preprocessing by the Win32 APIs. This is done by explicitly using the desired namespace in the path.</source>
          <target state="translated">Ядро NT,тем не менее,позволяет отказаться от препроцессирования этого пути Win32 API.Это делается явным образом с помощью желаемого пространства имён в пути.</target>
        </trans-unit>
        <trans-unit id="c3d1ffc3dd3f40f1c222c841f95386202d3f7d9c" translate="yes" xml:space="preserve">
          <source>The Package Versioning Policy &lt;strong&gt;does not apply&lt;/strong&gt;.</source>
          <target state="translated">Политика управления версиями пакетов &lt;strong&gt;не применяется&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7577997f2b7e95327e240c7fc768c6dc92772fe1" translate="yes" xml:space="preserve">
          <source>The Paterson Conditions: for each class constraint &lt;code&gt;(C t1 ... tn)&lt;/code&gt; in the context</source>
          <target state="translated">Условия Патерсона: для каждого ограничения класса &lt;code&gt;(C t1 ... tn)&lt;/code&gt; в контексте</target>
        </trans-unit>
        <trans-unit id="7329aa4547685d3c70bea0407e898afb0b679e44" translate="yes" xml:space="preserve">
          <source>The Prelude: a standard module. The Prelude is imported by default into all Haskell modules unless either there is an explicit import statement for it, or the NoImplicitPrelude extension is enabled.</source>
          <target state="translated">Прелюдия:стандартный модуль.Прелюдия импортируется по умолчанию во все модули Haskell,если только для нее не задан явный импорт,или не включено расширение NoImplicitPrelude.</target>
        </trans-unit>
        <trans-unit id="0aa2000b932cfb04e1a3bcd9c14b88cf13e1335d" translate="yes" xml:space="preserve">
          <source>The Put monad</source>
          <target state="translated">The Put monad</target>
        </trans-unit>
        <trans-unit id="e6d4dd4f8b3be3cd5b857fe2de8ff602061f0af6" translate="yes" xml:space="preserve">
          <source>The Put monad. A monad for efficiently constructing lazy bytestrings.</source>
          <target state="translated">&quot;Put monad&quot;.Монада для эффективного построения ленивых байтстрингов.</target>
        </trans-unit>
        <trans-unit id="859037e4eda9b5b2f4fe55e78c68c20d023080cf" translate="yes" xml:space="preserve">
          <source>The Put type</source>
          <target state="translated">Тип &quot;Put</target>
        </trans-unit>
        <trans-unit id="ab5819377a02005c251c02732e301195c27a0049" translate="yes" xml:space="preserve">
          <source>The PutM type. A Writer monad over the efficient Builder monoid.</source>
          <target state="translated">Тип PutM.Монада Писателя над эффективным моноидом Строителя.</target>
        </trans-unit>
        <trans-unit id="2354aa5ff6e1c2d9885153e78ccf38e4f0365e83" translate="yes" xml:space="preserve">
          <source>The RTS has a lot of options to control its behaviour. For example, you can change the context-switch interval, the default size of the heap, and enable heap profiling. These options can be passed to the runtime system in a variety of different ways; the next section (&lt;a href=&quot;#setting-rts-options&quot;&gt;Setting RTS options&lt;/a&gt;) describes the various methods, and the following sections describe the RTS options themselves.</source>
          <target state="translated">У RTS есть много возможностей контролировать свое поведение. Например, вы можете изменить интервал переключения контекста, размер кучи по умолчанию и включить профилирование кучи. Эти параметры могут быть переданы системе времени выполнения множеством различных способов; в следующем разделе ( &lt;a href=&quot;#setting-rts-options&quot;&gt;Настройка параметров RTS&lt;/a&gt; ) описаны различные методы, а в следующих разделах описаны сами параметры RTS.</target>
        </trans-unit>
        <trans-unit id="80255d167f12c27a3ea54ce8b0bd00039dbf82da" translate="yes" xml:space="preserve">
          <source>The RTS options related to concurrency are described in &lt;a href=&quot;using-concurrent#using-concurrent&quot;&gt;Using Concurrent Haskell&lt;/a&gt;, and those for parallelism in &lt;a href=&quot;using-concurrent#parallel-options&quot;&gt;RTS options for SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">Параметры RTS, связанные с параллелизмом, описаны в &lt;a href=&quot;using-concurrent#using-concurrent&quot;&gt;разделе Использование параллельного Haskell&lt;/a&gt; , а параметры параллелизма - в &lt;a href=&quot;using-concurrent#parallel-options&quot;&gt;параметрах RTS для параллелизма SMP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5bb8ad1fb09a839ecffde8ca34b94bdfdcd8b691" translate="yes" xml:space="preserve">
          <source>The RTS will snaffle &lt;code&gt;-H32m -S&lt;/code&gt; for itself, and the remaining arguments &lt;code&gt;-f -h foo bar&lt;/code&gt; will be available to your program if/when it calls &lt;code&gt;System.Environment.getArgs&lt;/code&gt;.</source>
          <target state="translated">RTS &lt;code&gt;-H32m -S&lt;/code&gt; для себя -H32m -S , а остальные аргументы &lt;code&gt;-f -h foo bar&lt;/code&gt; будут доступны вашей программе, если / когда она &lt;code&gt;System.Environment.getArgs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e88b8846d8fe73958229f97485a69a53155ce170" translate="yes" xml:space="preserve">
          <source>The RULES mechanism is used to implement fusion (deforestation) of common list functions. If a &amp;ldquo;good consumer&amp;rdquo; consumes an intermediate list constructed by a &amp;ldquo;good producer&amp;rdquo;, the intermediate list should be eliminated entirely.</source>
          <target state="translated">Механизм ПРАВИЛА используется для реализации слияния (обезлесения) общих функций списков. Если &amp;laquo;хороший потребитель&amp;raquo; потребляет промежуточный список, составленный &amp;laquo;хорошим производителем&amp;raquo;, промежуточный список следует полностью исключить.</target>
        </trans-unit>
        <trans-unit id="91cc01216a24ea0cf70d53ce6831cdfd22c4c1ae" translate="yes" xml:space="preserve">
          <source>The RWS monad</source>
          <target state="translated">RWS monad</target>
        </trans-unit>
        <trans-unit id="3030e059d51b47652080afc1bf3e87a96b72964b" translate="yes" xml:space="preserve">
          <source>The RWST monad transformer</source>
          <target state="translated">Трансформатор RWST monad</target>
        </trans-unit>
        <trans-unit id="17d69ac471ca747fe3aa42940b683d831a9ef452" translate="yes" xml:space="preserve">
          <source>The Reader monad</source>
          <target state="translated">Монада Ридер</target>
        </trans-unit>
        <trans-unit id="3aea66391daa03b9cc14c2b409c118ef8792ac2b" translate="yes" xml:space="preserve">
          <source>The ReaderT monad transformer</source>
          <target state="translated">Трансформатор ReaderT monad</target>
        </trans-unit>
        <trans-unit id="7b28758084e7661741da61d05acfec540a63dcd6" translate="yes" xml:space="preserve">
          <source>The STM implementation will abort transactions that are known to be invalid and need to be restarted. This may happen in the middle of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt;, so make sure you don't acquire any resources that need releasing (exception handlers are ignored when aborting the transaction). That includes doing any IO using Handles, for example. Getting this wrong will probably lead to random deadlocks.</source>
          <target state="translated">Реализация STM прервет транзакции, о которых известно, что они недействительны и которые необходимо перезапустить. Это может произойти в середине &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; , поэтому убедитесь, что вы не приобрели какие-либо ресурсы, которые нужно освободить (обработчики исключений игнорируются при прерывании транзакции). Это включает, например, выполнение любого ввода-вывода с использованием дескрипторов. Неправильный ответ, вероятно, приведет к случайным тупикам.</target>
        </trans-unit>
        <trans-unit id="a93c60619a7c26a3aaea050cc64323b106e6a10f" translate="yes" xml:space="preserve">
          <source>The STM implementation will abort transactions that are known to be invalid and need to be restarted. This may happen in the middle of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt;, so make sure you don't acquire any resources that need releasing (exception handlers are ignored when aborting the transaction). That includes doing any IO using Handles, for example. Getting this wrong will probably lead to random deadlocks.</source>
          <target state="translated">Реализация STM прервет транзакции, о которых известно, что они недействительны и которые необходимо перезапустить. Это может произойти в середине &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; , поэтому убедитесь, что вы не приобрели какие-либо ресурсы, которые нужно освободить (обработчики исключений игнорируются при прерывании транзакции). Это включает, например, выполнение любого ввода-вывода с использованием дескрипторов. Неправильный ответ, вероятно, приведет к случайным тупикам.</target>
        </trans-unit>
        <trans-unit id="a466c95f7705b8667d496c8cad7e2978bbeba71b" translate="yes" xml:space="preserve">
          <source>The STM implementation will often run transactions multiple times, so you need to be prepared for this if your IO has any side effects.</source>
          <target state="translated">Реализация STM часто приводит к многократному запуску транзакций,поэтому вам необходимо быть готовым к этому,если у вашего ввода-вывода есть какие-либо побочные эффекты.</target>
        </trans-unit>
        <trans-unit id="d2c9be55e3be898cad081ed8cc787cc2dc0d8adc" translate="yes" xml:space="preserve">
          <source>The Safe Haskell &lt;em&gt;safe language&lt;/em&gt; (enabled by &lt;code&gt;-XSafe&lt;/code&gt;) guarantees the following properties:</source>
          <target state="translated">Безопасный &lt;em&gt;язык&lt;/em&gt; Safe Haskell (включенный &lt;code&gt;-XSafe&lt;/code&gt; ) гарантирует следующие свойства:</target>
        </trans-unit>
        <trans-unit id="7726729f19e0da000e83c79bcb8c28c6f385ffcb" translate="yes" xml:space="preserve">
          <source>The Safe Haskell checks can be disabled for a module by passing the &lt;a href=&quot;#ghc-flag--fno-safe-haskell&quot;&gt;&lt;code&gt;-fno-safe-haskell&lt;/code&gt;&lt;/a&gt; flag. This is useful in particular when compiling with source plugins as running a plugin marks the module as unsafe and can then cause downstream modules to fail the safety checks.</source>
          <target state="translated">Проверки Safe Haskell можно отключить для модуля, передав &lt;a href=&quot;#ghc-flag--fno-safe-haskell&quot;&gt; &lt;code&gt;-fno-safe-haskell&lt;/code&gt; &lt;/a&gt; . Это полезно, в частности, при компиляции с исходными плагинами, так как запуск плагина помечает модуль как небезопасный и может затем привести к тому, что последующие модули не пройдут проверки безопасности.</target>
        </trans-unit>
        <trans-unit id="6da0062c345ab61160d26f605d07d936e53000f2" translate="yes" xml:space="preserve">
          <source>The Select monad</source>
          <target state="translated">The Select monad</target>
        </trans-unit>
        <trans-unit id="14b5bf3a399f4cac6f75470d51a3a0bae35be0f1" translate="yes" xml:space="preserve">
          <source>The SelectT monad transformer</source>
          <target state="translated">Трансформатор SelectT monad</target>
        </trans-unit>
        <trans-unit id="afb2b6e8a6ae40d8e5e247b3b17b072cba473176" translate="yes" xml:space="preserve">
          <source>The Signal type</source>
          <target state="translated">Тип сигнала</target>
        </trans-unit>
        <trans-unit id="34ca6ab89d0a5929502c3b8fda82f9d7a6d4db86" translate="yes" xml:space="preserve">
          <source>The State monad</source>
          <target state="translated">Государственный монадарь</target>
        </trans-unit>
        <trans-unit id="d1d93ac3a4f1be7a558b299c04132f8bd844f80f" translate="yes" xml:space="preserve">
          <source>The StateT monad transformer</source>
          <target state="translated">Трансформатор StateT monad</target>
        </trans-unit>
        <trans-unit id="19f67896d1f6937e580c15a10e0aa19b08a4f845" translate="yes" xml:space="preserve">
          <source>The SubSystem control interface. These methods can be used to disambiguate between the two operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38fd4995bb0200714fd098c99380c5ce19be4b0a" translate="yes" xml:space="preserve">
          <source>The TH state, created by &lt;code&gt;&lt;a href=&quot;ghci-th#v:startTH&quot;&gt;startTH&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Состояние TH, созданное &lt;code&gt;&lt;a href=&quot;ghci-th#v:startTH&quot;&gt;startTH&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2544b8736e584c3e40b611d6a80bea3cc2e2d77" translate="yes" xml:space="preserve">
          <source>The Typeable class</source>
          <target state="translated">Типовой класс</target>
        </trans-unit>
        <trans-unit id="406c428a778ef7125e193987bbac0237ab0511cd" translate="yes" xml:space="preserve">
          <source>The UTC time zone.</source>
          <target state="translated">Часовой пояс UTC.</target>
        </trans-unit>
        <trans-unit id="38141e622e2458972c46a5896fe7f4e01687679d" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (a byte-order-mark should be used to indicate endianness).</source>
          <target state="translated">Кодировка UTF-16 Unicode (для обозначения эндианности следует использовать знак байт-ордера).</target>
        </trans-unit>
        <trans-unit id="0cf0e68f8c740d3f43a6e8c8dbc14773e82bf3fb" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (big-endian)</source>
          <target state="translated">Юникодовая кодировка UTF-16 (big-endian)</target>
        </trans-unit>
        <trans-unit id="0e56b9ac4542ba5321237f8287ad2bf793fc3af5" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (litte-endian)</source>
          <target state="translated">UTF-16 Unicode кодировка (litte-endian)</target>
        </trans-unit>
        <trans-unit id="8c4b2968dfc559f607c84276e6deaa90e4bc09b8" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (little-endian)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34bf7d79b70b504d63dce6b7b58a8119636ec3c" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (a byte-order-mark should be used to indicate endianness).</source>
          <target state="translated">UTF-32 Unicode кодировка (для обозначения эндианности следует использовать знак байт-ордера).</target>
        </trans-unit>
        <trans-unit id="67dffc3f81adbd2d24a0516022167baf8bc86322" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (big-endian)</source>
          <target state="translated">UTF-32 Unicode кодировка (big-endian)</target>
        </trans-unit>
        <trans-unit id="e1d43f77fb169e84f01193e920df4b983c3368e9" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (litte-endian)</source>
          <target state="translated">UTF-32 Unicode кодировка (litte-endian)</target>
        </trans-unit>
        <trans-unit id="7aac7a838ca04e2d0239351dada786d53acef1d2" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (little-endian)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52589abf36edd4349a64f7d5395f328f8a947920" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding</source>
          <target state="translated">UTF-8 кодировка Юникода</target>
        </trans-unit>
        <trans-unit id="a005af9557a056326c8b8d7c97a47bc28391bd3b" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte sequence 0xEF 0xBB 0xBF). This encoding behaves like &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;, except that on input, the BOM sequence is ignored at the beginning of the stream, and on output, the BOM sequence is prepended.</source>
          <target state="translated">Кодировка Unicode UTF-8 с отметкой порядка байтов (BOM; последовательность байтов 0xEF 0xBB 0xBF). Эта кодировка ведет себя как &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; , за исключением того, что на входе последовательность BOM игнорируется в начале потока, а на выходе последовательность BOM добавляется в начало.</target>
        </trans-unit>
        <trans-unit id="eaf74031b27da65f642c604ade4f47115637843c" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte sequence 0xEF 0xBB 0xBF). This encoding behaves like &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;, except that on input, the BOM sequence is ignored at the beginning of the stream, and on output, the BOM sequence is prepended.</source>
          <target state="translated">Кодировка Unicode UTF-8 с отметкой порядка байтов (BOM; последовательность байтов 0xEF 0xBB 0xBF). Эта кодировка ведет себя как &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; , за исключением того, что на входе последовательность BOM игнорируется в начале потока, а на выходе последовательность BOM добавляется в начало.</target>
        </trans-unit>
        <trans-unit id="48a72567fd36d1b77865bf4ea3a5534e90bd33c8" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode &lt;em&gt;all&lt;/em&gt; Unicode codepoints. We recommend using it always for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s unless an application really requires another encoding.</source>
          <target state="translated">Кодировка UTF-8 может кодировать &lt;em&gt;все&lt;/em&gt; кодовые точки Unicode. Мы рекомендуем всегда использовать его для кодирования &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , если приложению действительно не требуется другая кодировка.</target>
        </trans-unit>
        <trans-unit id="ad5a08465846c2ed90f1e4740e5e95b9f0ebef47" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode &lt;em&gt;all&lt;/em&gt; Unicode codepoints. We recommend using it always for encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s unless an application really requires another encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd2c9a45b06c5bc52330c023a465b428ccfa7702" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode &lt;em&gt;all&lt;/em&gt; Unicode codepoints. We recommend using it always for encoding &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s unless an application really requires another encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d524833742212d693f8a7a1356f8aab1e3718c22" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode all Unicode codepoints. It is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with UTF-8 encoded characters.</source>
          <target state="translated">Кодировка UTF-8 может кодировать все кодовые точки Unicode. Это эквивалентно кодировке ASCII в кодовых точках Unicode 0&amp;ndash;127. Следовательно, такие функции, как &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; , также могут использоваться для кодирования &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; как десятичного числа с символами в кодировке UTF-8.</target>
        </trans-unit>
        <trans-unit id="51b4cc22b8af376450ca69ff9b57ead5e922d46c" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode all Unicode codepoints. It is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with UTF-8 encoded characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e548216f1a033464f97b8c8251bc89165b536d" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode all Unicode codepoints. It is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with UTF-8 encoded characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09093313f0f91c4b5737ad4a0fbe7d06eea9ee26" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale</source>
          <target state="translated">Юникодовая кодировка текущей локали</target>
        </trans-unit>
        <trans-unit id="3f137dd2773a7b21ca2a1977bcffe06a49397773" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale, but allowing arbitrary undecodable bytes to be round-tripped through it.</source>
          <target state="translated">Юникодовая кодировка текущей локали,но с возможностью округления через нее произвольных нераспознаваемых байтов.</target>
        </trans-unit>
        <trans-unit id="939eaac913afcf37c06343e0dee5a39351f12362" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale, but where undecodable bytes are replaced with their closest visual match. Used for the &lt;code&gt;&lt;a href=&quot;foreign-c-string#v:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; marshalling functions in &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt;</source>
          <target state="translated">Кодировка Unicode для текущей локали, но в которой не декодируемые байты заменяются их ближайшим визуальным соответствием. Используется для функций маршалинга &lt;code&gt;&lt;a href=&quot;foreign-c-string#v:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; в &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94c16bb05159c06fe3dc812d48c81e471e6e3efb" translate="yes" xml:space="preserve">
          <source>The Unicode general category of the character. This relies on the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;, which must remain in the same order as the categories are presented in the Unicode standard.</source>
          <target state="translated">Общая категория символа Unicode. Это зависит от экземпляра &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; класса &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; , который должен оставаться в том же порядке, что и категории, представленные в стандарте Unicode.</target>
        </trans-unit>
        <trans-unit id="68e199523a1fa0fa41372e425d662a0ca937ad92" translate="yes" xml:space="preserve">
          <source>The Unicode general category of the character. This relies on the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;, which must remain in the same order as the categories are presented in the Unicode standard.</source>
          <target state="translated">Общая категория символа Unicode. Это зависит от экземпляра &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; класса &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; , который должен оставаться в том же порядке, что и категории, представленные в стандарте Unicode.</target>
        </trans-unit>
        <trans-unit id="b3874853724a4d3f79b5cf848ac2f78cd971528d" translate="yes" xml:space="preserve">
          <source>The Weak Head Normal Form of an &lt;strong&gt;&lt;code&gt;FRList&lt;/code&gt;&lt;/strong&gt; is a lambda abstraction not a data value, and reuse does not lead to memoisation. Reuse of the iterator above is somewhat contrived, when computing multiple folds over a common list, you should generally traverse a list only &lt;a href=&quot;#multipass&quot;&gt;once&lt;/a&gt;. The goal is to demonstrate that the separate computations of the &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; run efficiently in constant space, despite reuse. This would not be the case with the list &lt;code&gt;[1..10000000]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="461ca2fc00cd995c7e6980fa43df6ef7503d97ca" translate="yes" xml:space="preserve">
          <source>The Windows directory</source>
          <target state="translated">Каталог Windows</target>
        </trans-unit>
        <trans-unit id="a88998b1d185995bfddbae32ddd00452270da2ae" translate="yes" xml:space="preserve">
          <source>The Writer monad</source>
          <target state="translated">Монада писателей</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
