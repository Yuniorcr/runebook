<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="adf54fd7881b01dd5fbb317fe0878e5876b7ee5a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qvulkanwindow#supportsGrab&quot;&gt;supportsGrab&lt;/a&gt;() returns true, &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; can perform readbacks from the color buffer into a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. &lt;a href=&quot;qvulkanwindow#grab&quot;&gt;grab&lt;/a&gt;() is a slow and inefficient operation, so frequent usage should be avoided. It is nonetheless valuable since it allows applications to take screenshots, or tools and tests to process and verify the output of the GPU rendering.</source>
          <target state="translated">Когда &lt;a href=&quot;qvulkanwindow#supportsGrab&quot;&gt;supportsGrab&lt;/a&gt; () возвращает true, &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; может выполнять обратное считывание из буфера цвета в &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; . &lt;a href=&quot;qvulkanwindow#grab&quot;&gt;grab&lt;/a&gt; () - медленная и неэффективная операция, поэтому следует избегать частого использования. Тем не менее, он полезен, поскольку позволяет приложениям делать снимки экрана или инструменты и тесты для обработки и проверки вывода рендеринга графического процессора.</target>
        </trans-unit>
        <trans-unit id="a855aaf2660d645fa9b8949d66a891591b9ae74f" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qvulkanwindow#supportsGrab&quot;&gt;supportsGrab&lt;/a&gt;() returns true, QVulkanWindow can perform readbacks from the color buffer into a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. &lt;a href=&quot;qvulkanwindow#grab&quot;&gt;grab&lt;/a&gt;() is a slow and inefficient operation, so frequent usage should be avoided. It is nonetheless valuable since it allows applications to take screenshots, or tools and tests to process and verify the output of the GPU rendering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6823f0c205033d4ea128122af4b97d19b1b0c274" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; accesses resources (e.g., calling &lt;code&gt;fn:doc()&lt;/code&gt; to load a file, or accessing a device via a bound variable), the event loop is used, which means events will be processed. To avoid processing events when &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; accesses resources, create your &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; instance in a separate thread.</source>
          <target state="translated">Когда &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; обращается к ресурсам (например, вызывает &lt;code&gt;fn:doc()&lt;/code&gt; для загрузки файла или обращается к устройству через связанную переменную), используется цикл событий, что означает, что события будут обрабатываться. Чтобы избежать обработки событий, когда &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; обращается к ресурсам, создайте экземпляр &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; в отдельном потоке.</target>
        </trans-unit>
        <trans-unit id="5a4303763eb160478daacc616e1e09a84ccb3fd3" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; calls &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler::message&lt;/a&gt;(), the arguments are as follows:</source>
          <target state="translated">Когда &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; вызывает &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler :: message&lt;/a&gt; (), аргументы следующие:</target>
        </trans-unit>
        <trans-unit id="2414e2eb1638148ea5acad1b6c425e2a2fa8d639" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt;() is called, the query text is compiled into an internal data structure and optimized. The optimized form can then be reused for multiple evaluations of the query. Since the compile-and-optimize process can be expensive, repeating it for the same query should be avoided by using a separate instance of &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; for each query text.</source>
          <target state="translated">Когда &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;вызывается setQuery&lt;/a&gt; (), текст запроса компилируется во внутреннюю структуру данных и оптимизируется. Затем оптимизированную форму можно повторно использовать для нескольких оценок запроса. Поскольку процесс компиляции и оптимизации может быть дорогостоящим, следует избегать его повторения для одного и того же запроса, используя отдельный экземпляр &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; для каждого текста запроса.</target>
        </trans-unit>
        <trans-unit id="df60f13705bccbfb1ebe641d5980c4f255529f48" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt;() is called, the query text is compiled into an internal data structure and optimized. The optimized form can then be reused for multiple evaluations of the query. Since the compile-and-optimize process can be expensive, repeating it for the same query should be avoided by using a separate instance of QXmlQuery for each query text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f0e33d48640a9980a60399682ba53ff818618de" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlschema&quot;&gt;QXmlSchema&lt;/a&gt; calls &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler::message&lt;/a&gt;(), the arguments are as follows:</source>
          <target state="translated">Когда &lt;a href=&quot;qxmlschema&quot;&gt;QXmlSchema&lt;/a&gt; вызывает &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler :: message&lt;/a&gt; (), аргументы следующие:</target>
        </trans-unit>
        <trans-unit id="34a36de9f3978a9dc52660020f38e10757c3b33a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlschemavalidator&quot;&gt;QXmlSchemaValidator&lt;/a&gt; calls &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler::message&lt;/a&gt;(), the arguments are as follows:</source>
          <target state="translated">Когда &lt;a href=&quot;qxmlschemavalidator&quot;&gt;QXmlSchemaValidator&lt;/a&gt; вызывает &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler :: message&lt;/a&gt; (), аргументы следующие:</target>
        </trans-unit>
        <trans-unit id="abc180cdaa67db2334bc9aec8221bc677db91dc0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;param&amp;gt;&lt;/code&gt; elements are used in the &lt;code&gt;&amp;lt;send&amp;gt;&lt;/code&gt; element, the data will contain a &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; where the key is the</source>
          <target state="translated">Когда элементы &lt;code&gt;&amp;lt;param&amp;gt;&lt;/code&gt; используются в элементе &lt;code&gt;&amp;lt;send&amp;gt;&lt;/code&gt; , данные будут содержать &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap,&lt;/a&gt; где ключом является</target>
        </trans-unit>
        <trans-unit id="a06133ee79a232acbfba343775e247dd1fc22db2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GL_ARB_framebuffer_sRGB&lt;/code&gt; or &lt;code&gt;GL_EXT_framebuffer_sRGB&lt;/code&gt; is supported by the platform and this value is set, the window will be created with an sRGB-capable default framebuffer. Note that some platforms may return windows with a sRGB-capable default framebuffer even when not requested explicitly.</source>
          <target state="translated">Когда &lt;code&gt;GL_ARB_framebuffer_sRGB&lt;/code&gt; или &lt;code&gt;GL_EXT_framebuffer_sRGB&lt;/code&gt; поддерживается платформой и это значение установлено, окно будет создано с фреймбуфером по умолчанию, поддерживающим sRGB. Обратите внимание, что некоторые платформы могут возвращать окна с кадровым буфером по умолчанию, поддерживающим sRGB, даже если не запрашивается явно.</target>
        </trans-unit>
        <trans-unit id="aa3913ff2ab5c3e811ba7c183222c6fcac1a3447" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;QT_OPENGL_BUGLIST&lt;/code&gt; is not specified, a built-in list will be used. This typically includes some older, less-capable graphics cards with &lt;code&gt;disable_desktopgl&lt;/code&gt; set, in order to prevent Qt from using their unstable desktop OpenGL implementations and instead fall back to ANGLE right away.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed4d9b70602719a6967792783570916cdfb715ef" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;button&lt;/code&gt; is clicked, the machine will transition into state &lt;code&gt;s2&lt;/code&gt;, which will set the geometry of the button, and then pop up a message box to alert the user that the geometry has been changed.</source>
          <target state="translated">Когда &lt;code&gt;button&lt;/code&gt; нажата, машина переходит в состояние &lt;code&gt;s2&lt;/code&gt; , которое устанавливает геометрию кнопки, а затем всплывает окно сообщения, чтобы предупредить пользователя об изменении геометрии.</target>
        </trans-unit>
        <trans-unit id="2388f2e21addac6210aabde322ea581bb6afffb1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mode&lt;/code&gt; is not defined, the mode that is reported as preferred by the system is chosen. The accepted values for &lt;code&gt;mode&lt;/code&gt; are: &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;current&lt;/code&gt;, &lt;code&gt;preferred&lt;/code&gt;, &lt;code&gt;skip&lt;/code&gt;, width&lt;code&gt;x&lt;/code&gt;height, width&lt;code&gt;x&lt;/code&gt;height&lt;code&gt;@&lt;/code&gt;vrefresh, or a modeline string.</source>
          <target state="translated">Если &lt;code&gt;mode&lt;/code&gt; не определен, выбирается режим, который сообщается системой как предпочтительный. Допустимые значения для &lt;code&gt;mode&lt;/code&gt; : &lt;code&gt;off&lt;/code&gt; , &lt;code&gt;current&lt;/code&gt; , &lt;code&gt;preferred&lt;/code&gt; , &lt;code&gt;skip&lt;/code&gt; , ширина &lt;code&gt;x&lt;/code&gt; высота, ширина &lt;code&gt;x&lt;/code&gt; высота &lt;code&gt;@&lt;/code&gt; vrefresh или строка строки режима.</target>
        </trans-unit>
        <trans-unit id="ad2de4e55d4aebd9b4557d94a6cf5c7e0065f8b8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mode&lt;/code&gt; is not defined, the system's preferred mode is chosen. The accepted values for &lt;code&gt;mode&lt;/code&gt; are: &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;current&lt;/code&gt;, &lt;code&gt;preferred&lt;/code&gt;, &lt;code&gt;skip&lt;/code&gt;, width&lt;code&gt;x&lt;/code&gt;height, width&lt;code&gt;x&lt;/code&gt;height&lt;code&gt;@&lt;/code&gt;vrefresh, or a modeline string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bebb2b33e2691fc3d175656c1b70af1ee1b6346d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;reanchorToRight&lt;/code&gt; is called, the function first sets the right anchor. At that point, both left and right anchors are set, and the item will be stretched horizontally to fill its parent. When the left anchor is unset, the new width will remain. Thus when updating anchors within JavaScript, you should first unset any anchors that are no longer required, and only then set any new anchors that are required, as shown below:</source>
          <target state="translated">Когда &lt;code&gt;reanchorToRight&lt;/code&gt; , функция сначала устанавливает правую привязку. В этот момент установлены как левая, так и правая привязка, и элемент будет растянут по горизонтали, чтобы заполнить своего родителя. Когда левый якорь не установлен, новая ширина останется. Таким образом, при обновлении якорей в JavaScript вы должны сначала отключить все якоря, которые больше не требуются, и только затем установить любые новые якоря, которые требуются, как показано ниже:</target>
        </trans-unit>
        <trans-unit id="8825f7725f1dc91940c2a034ec29bd99db520ddf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;s1&lt;/code&gt; 's final state is entered, &lt;code&gt;s1&lt;/code&gt; will automatically emit &lt;a href=&quot;qml-qtqml-statemachine-state#finished-signal&quot;&gt;finished&lt;/a&gt;. We use a signal transition to cause this event to trigger a state change:</source>
          <target state="translated">Когда &lt;code&gt;s1&lt;/code&gt; конечное состояние &amp;laquo;s вводится, &lt;code&gt;s1&lt;/code&gt; будет автоматически испускать &lt;a href=&quot;qml-qtqml-statemachine-state#finished-signal&quot;&gt;закончена&lt;/a&gt; . Мы используем переход сигнала, чтобы это событие запускало изменение состояния:</target>
        </trans-unit>
        <trans-unit id="a068e7c1d71be79be1747b295f8d0bdf7d0f76ad" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;s1&lt;/code&gt; 's final state is entered, &lt;code&gt;s1&lt;/code&gt; will automatically emit &lt;a href=&quot;qstate#finished&quot;&gt;finished()&lt;/a&gt;. We use a signal transition to cause this event to trigger a state change:</source>
          <target state="translated">Когда &lt;code&gt;s1&lt;/code&gt; конечное состояние &amp;laquo;ы вводится, &lt;code&gt;s1&lt;/code&gt; автоматически испустит &lt;a href=&quot;qstate#finished&quot;&gt;закончил ()&lt;/a&gt; . Мы используем переход сигнала, чтобы это событие запускало изменение состояния:</target>
        </trans-unit>
        <trans-unit id="7c85d7dd31dd96c49b09a16e731e181b35179393" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; changes, the C++ property &lt;code&gt;enteredText&lt;/code&gt; will update automatically.</source>
          <target state="translated">При изменении &lt;code&gt;text&lt;/code&gt; свойство C ++ &lt;code&gt;enteredText&lt;/code&gt; обновляется автоматически.</target>
        </trans-unit>
        <trans-unit id="274f974610c7463228dfb5154f647e8c8a8ccdcb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, all generated numbers appearing in various series and axis labels will be localized using the &lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt; set with the &lt;a href=&quot;qchart#locale-prop&quot;&gt;locale&lt;/a&gt; property. When &lt;code&gt;false&lt;/code&gt;, the</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , все сгенерированные числа, появляющиеся в различных сериях и метках осей, будут локализованы с использованием набора &lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt; со свойством &lt;a href=&quot;qchart#locale-prop&quot;&gt;locale&lt;/a&gt; . Когда &lt;code&gt;false&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="36e568b70799170c0d96b90a8147537bfc741c8b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, all generated numbers appearing in various series and axis labels will be localized using the &lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt; set with the &lt;a href=&quot;qml-qtcharts-chartview#locale-prop&quot;&gt;locale&lt;/a&gt; property. When &lt;code&gt;false&lt;/code&gt;, the</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , все сгенерированные числа, появляющиеся в различных сериях и метках осей, будут локализованы с использованием набора &lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt; со свойством &lt;a href=&quot;qml-qtcharts-chartview#locale-prop&quot;&gt;locale&lt;/a&gt; . Когда &lt;code&gt;false&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="3e953b3a9be5222efb277759886bb97613fdfda7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, the style should underline the menu item's label mnemonic.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , стиль должен подчеркивать мнемонику метки пункта меню.</target>
        </trans-unit>
        <trans-unit id="3172ee2682029786deccd528a524db012a091668" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;virtualIndex&lt;/code&gt; is not sufficient, the &lt;code&gt;virtualPos&lt;/code&gt; property can be used to explicitly specify the top-left position of the screen in question. Taking the previous example and assuming a resolution of 1080p for HDMI1, the following code snippet places a second HDMI-based screen below the first one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21a5b61887b0cac6a56dd588dce0ad7f3bbdb837" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;virtualIndex&lt;/code&gt; is not sufficient, the property &lt;code&gt;virtualPos&lt;/code&gt; can be used to explicitly specify the top-left position of the screen in question. Taking the previous example and assuming a resolution of 1080p for HDMI1, the following places a second HDMI-based screen below the first one:</source>
          <target state="translated">Когда &lt;code&gt;virtualIndex&lt;/code&gt; недостаточен, свойство &lt;code&gt;virtualPos&lt;/code&gt; может использоваться для явного указания верхней левой позиции рассматриваемого экрана. Взяв предыдущий пример и предполагая разрешение 1080p для HDMI1, следующее помещает второй экран на основе HDMI под первым:</target>
        </trans-unit>
        <trans-unit id="ce9c2c5e673edc4df91dd9cd97b16eb59ee71073" translate="yes" xml:space="preserve">
          <source>When DPI scaling is used by the system, the logical surface size, which is used by mouse events, and the actual 'physical' size of the surface can differ. The &lt;a href=&quot;qml-qt3d-render-rendersurfaceselector#surfacePixelRatio-prop&quot;&gt;surfacePixelRatio&lt;/a&gt; is the factor to convert the logical size to the physical size.</source>
          <target state="translated">Когда система использует масштабирование DPI, логический размер поверхности, который используется событиями мыши, и фактический &amp;laquo;физический&amp;raquo; размер поверхности могут отличаться. &lt;a href=&quot;qml-qt3d-render-rendersurfaceselector#surfacePixelRatio-prop&quot;&gt;SurfacePixelRatio&lt;/a&gt; является фактором , чтобы преобразовать логический размер физического размера.</target>
        </trans-unit>
        <trans-unit id="67b4917a54c5a1f83822bb816252770e66fe2a99" translate="yes" xml:space="preserve">
          <source>When DPI scaling is used by the system, the logical surface size, which is used by mouse events, and the actual 'physical' size of the surface can differ. The &lt;a href=&quot;qt3drender-qrendersurfaceselector#surfacePixelRatio-prop&quot;&gt;surfacePixelRatio&lt;/a&gt; is the factor to convert the logical size to the physical size.</source>
          <target state="translated">Когда система использует масштабирование DPI, логический размер поверхности, который используется событиями мыши, и фактический &amp;laquo;физический&amp;raquo; размер поверхности могут отличаться. &lt;a href=&quot;qt3drender-qrendersurfaceselector#surfacePixelRatio-prop&quot;&gt;SurfacePixelRatio&lt;/a&gt; является фактором , чтобы преобразовать логический размер физического размера.</target>
        </trans-unit>
        <trans-unit id="f1b60dd5dc0ba61c9eadb5e24ff7b6a22b038279" translate="yes" xml:space="preserve">
          <source>When FPS measuring is enabled, the results for the last second are stored in this read-only property. It takes at least a second before this value updates after measuring is activated.</source>
          <target state="translated">Когда функция измерения FPS включена,результаты за последнюю секунду сохраняются в этом свойстве только для чтения.Обновление этого значения после активации измерения занимает не менее секунды.</target>
        </trans-unit>
        <trans-unit id="c6d97e48bea8d713090e390fc1224dfc4ec5d0cc" translate="yes" xml:space="preserve">
          <source>When HSTS is enabled, for each HTTP response containing HSTS header and received over a secure transport, &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; will update its HSTS cache, either remembering a host with a valid policy or removing a host with an expired or disabled HSTS policy.</source>
          <target state="translated">Когда HSTS включен, для каждого HTTP-ответа, содержащего заголовок HSTS и полученного через безопасный транспорт, &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; обновит свой HSTS-кеш, запоминая хост с действующей политикой или удаляя хост с истекшей или отключенной политикой HSTS.</target>
        </trans-unit>
        <trans-unit id="c813b063d1c6a422bc40a6bf5d97ec4ee0b41451" translate="yes" xml:space="preserve">
          <source>When HTML markup is used for text, Qt follows the rules defined by the &lt;a href=&quot;http://www.w3.org/TR/html401/&quot;&gt;HTML 4&lt;/a&gt; specification. This includes default properties for text layout, such as the direction of the text flow (left-to-right) which can be changed by applying the &lt;a href=&quot;#block-attributes&quot;&gt;&lt;code&gt;dir&lt;/code&gt;&lt;/a&gt; attribute to blocks of text.</source>
          <target state="translated">Когда разметка HTML используется для текста, Qt следует правилам, определенным спецификацией &lt;a href=&quot;http://www.w3.org/TR/html401/&quot;&gt;HTML 4&lt;/a&gt; . Сюда входят свойства по умолчанию для макета текста, такие как направление потока текста (слева направо), которое можно изменить, применив атрибут &lt;a href=&quot;#block-attributes&quot;&gt; &lt;code&gt;dir&lt;/code&gt; &lt;/a&gt; к блокам текста.</target>
        </trans-unit>
        <trans-unit id="19e584a3c410cba7dfa95ae08639cd95d012b6b9" translate="yes" xml:space="preserve">
          <source>When HTML markup is used for text, Qt follows the rules defined by the &lt;a href=&quot;http://www.w3.org/TR/html401/&quot;&gt;HTML 4&lt;/a&gt; specification. This includes default properties for text layout, such as the direction of the text flow (left-to-right) which can be changed by applying the &lt;a href=&quot;richtext-html-subset#block-attributes&quot;&gt;&lt;code&gt;dir&lt;/code&gt;&lt;/a&gt; attribute to blocks of text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d031a5aad62e51b34085c95c6997afabca63874d" translate="yes" xml:space="preserve">
          <source>When LayoutDirectionAuto is used in conjunction with text layouting, it will imply that the text directionality is determined from the content of the string to be layouted.</source>
          <target state="translated">Когда LayoutDirectionAuto используется в сочетании с версткой текста,это будет означать,что направленность текста определяется из содержимого строки,которую необходимо верстать.</target>
        </trans-unit>
        <trans-unit id="66418f264bb909da3c52c062e8ec0fb65ed558c8" translate="yes" xml:space="preserve">
          <source>When QDoc generates documentation for a project, it will also generate an &lt;code&gt;.index&lt;/code&gt; file containing URLs to each linkable entity in the project. Each dependency is a (lowercase) name of a project. This name must match with the base name of the index file generated for that project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dc427b9427e3f31178f1302dfba94644ceb86f8" translate="yes" xml:space="preserve">
          <source>When QML types produce logging messages, it improves traceability if they include the QML file and line number on which the particular instance was instantiated.</source>
          <target state="translated">Когда типы QML создают протоколирующие сообщения,это улучшает прослеживаемость,если они включают QML файл и номер строки,на которой был инстанцирован конкретный экземпляр.</target>
        </trans-unit>
        <trans-unit id="28bd2e83bcbfe95859e587b4383125510038621a" translate="yes" xml:space="preserve">
          <source>When QPickingSettings::pickMode() is set to &lt;a href=&quot;qt3drender-qpickingsettings#PickMethod-enum&quot;&gt;QPickingSettings::TrianglePicking&lt;/a&gt;, the signals on &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; will carry an instance of &lt;a href=&quot;qt3drender-qpicktriangleevent&quot;&gt;QPickTriangleEvent&lt;/a&gt;.</source>
          <target state="translated">Когда для QPickingSettings :: pickMode () установлено значение &lt;a href=&quot;qt3drender-qpickingsettings#PickMethod-enum&quot;&gt;QPickingSettings :: TrianglePicking&lt;/a&gt; , сигналы на &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; будут нести экземпляр &lt;a href=&quot;qt3drender-qpicktriangleevent&quot;&gt;QPickTriangleEvent&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df9dd3cc9e117bbee05447ec8831a1da2303f862" translate="yes" xml:space="preserve">
          <source>When QPickingSettings::pickMode() is set to &lt;a href=&quot;qt3drender-qpickingsettings#PickMethod-enum&quot;&gt;QPickingSettings::TrianglePicking&lt;/a&gt;, the signals on &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; will carry an instance of QPickTriangleEvent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457be61d0f002d025c887c713d51fbbfadff17ad" translate="yes" xml:space="preserve">
          <source>When QPickingSettings::pickMode() is set to QPickingSettings::TrianglePicking, the signals on QObjectPicker will carry an instance of QPickTriangleEvent.</source>
          <target state="translated">Когда QPickingSettings::pickMode()установлен в QPickingSettings::TrianglePicking,сигналы на QObjectPicker будут нести экземпляр QPickTriangleEvent.</target>
        </trans-unit>
        <trans-unit id="508f9df752233b565bb26370c5a26e20603658ac" translate="yes" xml:space="preserve">
          <source>When QPlainTextEdit is used read-only the key bindings are limited to navigation, and text may only be selected with the mouse:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3dce7cb91174e257ba7a5b773f5733c0ba5ef8" translate="yes" xml:space="preserve">
          <source>When QRegExpValidator determines whether a string is &lt;a href=&quot;qvalidator#State-enum&quot;&gt;Acceptable&lt;/a&gt; or not, the regexp is treated as if it begins with the start of string assertion (&lt;b&gt;^&lt;/b&gt;) and ends with the end of string assertion (&lt;b&gt;$&lt;/b&gt;); the match is against the entire input string, or from the given position if a start position greater than zero is given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44b35bfd10db30a7d0a3ac39d2072ec92e99876a" translate="yes" xml:space="preserve">
          <source>When QTextEdit is used read-only the key bindings are limited to navigation, and text may only be selected with the mouse:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b100506a7296cf4856e2d55c43642a514b0d282b" translate="yes" xml:space="preserve">
          <source>When QXmlQuery accesses resources (e.g., calling &lt;code&gt;fn:doc()&lt;/code&gt; to load a file, or accessing a device via a bound variable), the event loop is used, which means events will be processed. To avoid processing events when QXmlQuery accesses resources, create your QXmlQuery instance in a separate thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228d842e43fc176fb1a2d3aa0180185c47dc88bd" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns calls &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver::resolve&lt;/a&gt;() the absolute URI is the URI mandated by the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; language, and the relative URI is the URI specified by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ad967bec3128bd4f1fd05f2c5749f62466760b" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns calls &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver::resolve&lt;/a&gt;() the absolute URI is the URI mandated by the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; language, and the relative URI is the URI specified by the user.</source>
          <target state="translated">Когда Qt XML Patterns вызывает &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver :: resolve&lt;/a&gt; (), абсолютный URI - это URI, предписанный языком &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; , а относительный URI - это URI, указанный пользователем.</target>
        </trans-unit>
        <trans-unit id="f47f9cfcc0372f2d7543bfb2e549c724e778aa90" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns calls &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver::resolve&lt;/a&gt;() the absolute URI is the URI mandated by the schema specification, and the relative URI is the URI specified by the user.</source>
          <target state="translated">Когда Qt XML Patterns вызывает &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver :: resolve&lt;/a&gt; (), абсолютный URI - это URI, предписанный спецификацией схемы, а относительный URI - это URI, указанный пользователем.</target>
        </trans-unit>
        <trans-unit id="b7e889092d153ecf78cedbfcbcb9a5e6e6e850e1" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns evaluate path expressions, it emulate them through a combination of calls with &lt;a href=&quot;qabstractxmlnodemodel#SimpleAxis-enum&quot;&gt;QSimpleXmlNodeModel::SimpleAxis&lt;/a&gt; values. Therefore, the implementation of this function must return the node, if any, that appears on the</source>
          <target state="translated">Когда Qt XML Patterns оценивает выражения пути, он имитирует их посредством комбинации вызовов со значениями &lt;a href=&quot;qabstractxmlnodemodel#SimpleAxis-enum&quot;&gt;QSimpleXmlNodeModel :: SimpleAxis&lt;/a&gt; . Следовательно, реализация этой функции должна возвращать узел, если он есть, который появляется на</target>
        </trans-unit>
        <trans-unit id="e87346c400d28fb6331382be4402bbe0f7b9fc30" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns loads an XML resource, e.g., using the &lt;code&gt;fn:doc()&lt;/code&gt; function, the following schemes are supported:</source>
          <target state="translated">Когда Qt XML Patterns загружает ресурс XML, например, с помощью функции &lt;code&gt;fn:doc()&lt;/code&gt; , поддерживаются следующие схемы:</target>
        </trans-unit>
        <trans-unit id="8d2df247c302bc0aef9cb5b8701b3ccf2c5556f3" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns loads and queries XML files and produces XML output, it can always load the XML data into its default XML node model, where it can be traversed efficiently. The &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; below traverses the product orders found in the XML file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbd1af30e0b1f7879d2e090097ce1ee9bc1b1e77" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns loads and queries XML files and produces XML output, it can always load the XML data into its default XML node model, where it can be traversed efficiently. The XQuery below traverses the product orders found in the XML file</source>
          <target state="translated">Когда Qt XML Patterns загружает и запрашивает XML файлы и производит XML вывод,он всегда может загрузить данные XML в свою модель XML узла по умолчанию,где их можно эффективно обойти.Приведенный ниже XQuery обходит заказы продукции,найденные в XML файле</target>
        </trans-unit>
        <trans-unit id="27bec0f91bee9a8e04a2b33675d236e7ab402351" translate="yes" xml:space="preserve">
          <source>When Qt's translation tool, &lt;a href=&quot;https://doc.qt.io/qt-5.13/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;, is used to process a set of source files, the text wrapped in tr() calls is stored in a section of the translation file that corresponds to its translation context.</source>
          <target state="translated">Когда инструмент перевода Qt, &lt;a href=&quot;https://doc.qt.io/qt-5.13/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt; , используется для обработки набора исходных файлов, текст, заключенный в вызовы tr (), сохраняется в разделе файла перевода, который соответствует его контексту перевода.</target>
        </trans-unit>
        <trans-unit id="785ca6db3b40442948e6e7e14bdd25ed39799f88" translate="yes" xml:space="preserve">
          <source>When Qt's translation tool, &lt;a href=&quot;https://doc.qt.io/qt-5.15/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;, is used to process a set of source files, the text wrapped in tr() calls is stored in a section of the translation file that corresponds to its translation context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d716f69d72489992d975e006d6741d1a3935bbd6" translate="yes" xml:space="preserve">
          <source>When Qt5 came along, Qt was divided into modules. Since then, many new modules have been added to Qt. As of version 5.5, there are over 40 separate modules in Qt5, each with its own documentation that links to (depends on) the documentation of other Qt modules.</source>
          <target state="translated">Когда появилась Qt5,Qt была разделена на модули.С тех пор в Qt было добавлено много новых модулей.Начиная с версии 5.5,в Qt5 есть более 40 отдельных модулей,каждый со своей собственной документацией,которая ссылается на (зависит от)документации других модулей Qt.</target>
        </trans-unit>
        <trans-unit id="f177dcbb96dea9d408ace28c5d859883092740d9" translate="yes" xml:space="preserve">
          <source>When ScrollBar is attached &lt;a href=&quot;qml-qtquick-controls2-scrollbar#vertical-attached-prop&quot;&gt;vertically&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-controls2-scrollbar#horizontal-attached-prop&quot;&gt;horizontally&lt;/a&gt; to a Flickable, its geometry and the following properties are automatically set and updated as appropriate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="709f09eba453dec3aff9d67b6d37f765373bd46f" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; is opened using this function, behaviour of &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt;() is controlled by the &lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle&lt;/a&gt; flag. If &lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle&lt;/a&gt; is specified, and this function succeeds, then calling &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt;() closes the adopted handle. Otherwise, &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt;() does not actually close the file, but only flushes it.</source>
          <target state="translated">Когда &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; открывается с помощью этой функции, поведение &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt; () управляется флагом &lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle&lt;/a&gt; . Если &lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle&lt;/a&gt; указан и эта функция завершается успешно, то вызов &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt; () закрывает принятый дескриптор. В противном случае &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt; () фактически не закрывает файл, а только сбрасывает его.</target>
        </trans-unit>
        <trans-unit id="cb1e3502bc0fff8a5da1c27970f713a4cbcb877b" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives Qt mouse, keyboard, and drag and drop events (&lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, &lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent&lt;/a&gt;, QDragEvent, etc.), it translates them into instances of &lt;a href=&quot;qgraphicssceneevent&quot;&gt;QGraphicsSceneEvent&lt;/a&gt; subclasses and forwards them to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; it displays. The scene then forwards the events to the relevant items.</source>
          <target state="translated">Когда &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; получает события мыши, клавиатуры и перетаскивания Qt ( &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt; , &lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent&lt;/a&gt; , QDragEvent и т. Д.), Он переводит их в экземпляры подклассов &lt;a href=&quot;qgraphicssceneevent&quot;&gt;QGraphicsSceneEvent&lt;/a&gt; и пересылает их в отображаемый &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; . Затем сцена перенаправляет события в соответствующие элементы.</target>
        </trans-unit>
        <trans-unit id="5554f9846d1af01927d9497ed433e3fe74b4e0e1" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives Qt mouse, keyboard, and drag and drop events (&lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, &lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent&lt;/a&gt;, QDragEvent, etc.), it translates them into instances of QGraphicsSceneEvent subclasses and forwards them to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; it displays. The scene then forwards the events to the relevant items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca650c784a62d89aa1bd61df5a5c661ba25f79c" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;, it creates a &lt;a href=&quot;qgraphicsscenehelpevent&quot;&gt;QGraphicsSceneHelpEvent&lt;/a&gt;, which is forwarded to the scene. You can set a tooltip on a &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with &lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip()&lt;/a&gt;; by default &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; displays the tooltip of the &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with the highest z-value (i.e, the top-most item) under the mouse position.</source>
          <target state="translated">Когда &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; получает &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; типа &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: ToolTip&lt;/a&gt; , он создает &lt;a href=&quot;qgraphicsscenehelpevent&quot;&gt;QGraphicsSceneHelpEvent&lt;/a&gt; , который перенаправляется в сцену. Вы можете установить всплывающую подсказку для &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; с помощью &lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip ()&lt;/a&gt; ; по умолчанию &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; отображает всплывающую подсказку &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; с наивысшим z-значением (т. е. самым верхним элементом) под положением мыши.</target>
        </trans-unit>
        <trans-unit id="405906d74ba9d56a4a09585d6f6ec8dd6144ef07" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;, it creates a QGraphicsSceneHelpEvent, which is forwarded to the scene. You can set a tooltip on a &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with &lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip()&lt;/a&gt;; by default &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; displays the tooltip of the &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with the highest z-value (i.e, the top-most item) under the mouse position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="393e354c9ea9f2a89f579509e189a24bb7a827a0" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt; event, it translates it into &lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt;. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view.</source>
          <target state="translated">Когда &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; получает событие &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt; , он переводит его в &lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt; . Затем событие перенаправляется в &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene,&lt;/a&gt; связанный с представлением.</target>
        </trans-unit>
        <trans-unit id="3ae68b18a5e42b2ce917dd23d94ec19620288dec" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt; event, it translates it into QGraphicsSceneHoverEvent. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beba9444d0901cd09b88793cbb92e83a0fb0a4c8" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, it translates it to a &lt;a href=&quot;qgraphicsscenemouseevent&quot;&gt;QGraphicsSceneMouseEvent&lt;/a&gt;. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view. If the event is not handled by the scene, the view may use it, e.g., for the &lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragMode&lt;/a&gt;.</source>
          <target state="translated">Когда &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; получает &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt; , он преобразует его в &lt;a href=&quot;qgraphicsscenemouseevent&quot;&gt;QGraphicsSceneMouseEvent&lt;/a&gt; . Затем событие перенаправляется в &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene,&lt;/a&gt; связанный с представлением. Если событие не обрабатывается сценой, представление может использовать его, например, для &lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragMode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d58e00a0b32556ea464156ee58eaa63878af86f" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, it translates it to a QGraphicsSceneMouseEvent. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view. If the event is not handled by the scene, the view may use it, e.g., for the &lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragMode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1aa704cf88adf38927fd01a2a14f929a34849e2" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">Когда узел &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; присутствует в ветви FrameGraph, это предотвращает рендеринг любого примитива средством визуализации. &lt;a href=&quot;#details&quot;&gt;Больше...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d712cc482a400f11481ce544723b23f89d2fced9" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;, clients that are listening to events are notified of the change. The function is used to post events to the assistive technology, and accessible &lt;a href=&quot;qaccessible#Event-enum&quot;&gt;events&lt;/a&gt; are posted by &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;.</source>
          <target state="translated">Когда &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; вызывает &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility ()&lt;/a&gt; , клиенты, которые слушают события, уведомляются об изменении. Функция используется для отправки событий вспомогательной технологии, а доступные &lt;a href=&quot;qaccessible#Event-enum&quot;&gt;события&lt;/a&gt; отправляются с помощью &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a44c30b5bf2354f4fd8f996e028fe8735a8ada05" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;, clients that are listening to events are notified of the change. The function is used to post events to the assistive technology, and accessible &lt;a href=&quot;qaccessible#Event-enum&quot;&gt;events&lt;/a&gt; are posted by &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc5c853e12ceaddd145dd8068a3f01709b57c0cc" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is deleted, it emits this &lt;a href=&quot;qobject#destroyed&quot;&gt;QObject::destroyed&lt;/a&gt;() signal. We want to catch this signal, wherever we might have a dangling reference to the deleted &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, so we can clean it up. A suitable slot signature might be:</source>
          <target state="translated">Когда &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; удаляется, он испускает этот сигнал &lt;a href=&quot;qobject#destroyed&quot;&gt;QObject :: destroy&lt;/a&gt; (). Мы хотим поймать этот сигнал везде, где у нас может быть свисающая ссылка на удаленный &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; , чтобы мы могли его очистить. Подходящая подпись слота может быть:</target>
        </trans-unit>
        <trans-unit id="d5dd864966ee74351524f25c84e86e7278c96ac6" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is moved to another thread, all its children will be automatically moved too.</source>
          <target state="translated">Когда &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; перемещается в другой поток, все его дочерние объекты также будут перемещены автоматически.</target>
        </trans-unit>
        <trans-unit id="5954371cae64cc8ee9901844bd7778dc5d52aaf5" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is passed to the &lt;a href=&quot;qjsengine#newQObject&quot;&gt;QJSEngine::newQObject&lt;/a&gt;() function, a Qt Script wrapper object is created that can be used to make the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;'s signals, slots, properties, and child objects available to scripts.</source>
          <target state="translated">Когда &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; передается в &lt;a href=&quot;qjsengine#newQObject&quot;&gt;функцию QJSEngine :: newQObject&lt;/a&gt; (), создается объект-оболочка Qt Script, который можно использовать, чтобы сделать сигналы, слоты, свойства и дочерние объекты &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; доступными для скриптов.</target>
        </trans-unit>
        <trans-unit id="3af90ba954a525651c11676587fb2037323acba5" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; instance is deliberately hidden with &lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;() or &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;(false), it will stop rendering and its scene graph and graphics context might be released. The &lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;sceneGraphInvalidated&lt;/a&gt;() signal will be emitted when this happens.</source>
          <target state="translated">Когда экземпляр &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; намеренно скрыт с помощью &lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt; () или &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt; (false), он прекращает рендеринг, и его граф сцены и графический контекст могут быть освобождены. &lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;SceneGraphInvalidated&lt;/a&gt; сигнал () будет сгенерирован , когда это происходит.</target>
        </trans-unit>
        <trans-unit id="5554553d845c524ddee2156401f7cea7ba23f3a7" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qmemorybarrier&quot;&gt;QMemoryBarrier&lt;/a&gt; node is found in a FrameGraph branch, the barrier will be enforced prior to any draw or compute command even if these are defined deeper in the branch.</source>
          <target state="translated">Когда узел &lt;a href=&quot;qt3drender-qmemorybarrier&quot;&gt;QMemoryBarrier&lt;/a&gt; найден в ветви FrameGraph, барьер будет применен до любой команды рисования или вычисления, даже если они определены глубже в ветви.</target>
        </trans-unit>
        <trans-unit id="ba17b5ca58006cf8654bdb06b74fa570795c9e22" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">Когда узел &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw&lt;/a&gt; присутствует в ветви FrameGraph, это предотвращает рендеринг любого примитива средством визуализации. &lt;a href=&quot;#details&quot;&gt;Больше...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="548a84d157a52956b642a6c79fa3b16cff4cbb88" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;qt3drender-qnodraw#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">Когда узел &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw&lt;/a&gt; присутствует в ветви FrameGraph, это предотвращает рендеринг любого примитива средством визуализации. &lt;a href=&quot;qt3drender-qnodraw#details&quot;&gt;Больше...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3cd19e17aad321610c519687f38dc05666afdeec" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48029ceeb2e178ce68055405481fb634ea787fe6" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch. &lt;a href=&quot;qt3drender-qnopicking#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88153895f9568d781c480af110178d98fc9ac494" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt; is not a child of a &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;, it loses the ability to populate the extension pop up with widgets added to the toolbar using &lt;a href=&quot;qtoolbar#addWidget&quot;&gt;addWidget&lt;/a&gt;(). Please use widget actions created by inheriting &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; and implementing &lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetAction::createWidget&lt;/a&gt;() instead.</source>
          <target state="translated">Когда &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt; не является дочерним элементом &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; , он теряет возможность заполнять всплывающее окно расширения виджетами, добавленными на панель инструментов с помощью &lt;a href=&quot;qtoolbar#addWidget&quot;&gt;addWidget&lt;/a&gt; (). Пожалуйста, используйте действия виджета, созданные путем наследования &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; и реализации &lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;вместо этого QWidgetAction :: createWidget&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="ea339d196247f8a4535ab539b791214e5503ae1d" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;subTitle&lt;/a&gt; is set, &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; displays it in a header, in which case it also uses the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt; and the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmap&lt;/a&gt; to decorate the header. The &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmap&lt;/a&gt; is displayed on the left side, below the header. At the bottom, there is a row of buttons allowing the user to navigate through the pages.</source>
          <target state="translated">Когда &lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;подзаголовок&lt;/a&gt; установлен, &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; отображает его в заголовке, и в этом случае он также использует &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt; и &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmap&lt;/a&gt; для украшения заголовка. &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmap&lt;/a&gt; отображается на левой стороне, под заголовком. Внизу находится ряд кнопок, позволяющих пользователю перемещаться по страницам.</target>
        </trans-unit>
        <trans-unit id="399d5e73a4a8b06dd36c1720633609c913f08193" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;subTitle&lt;/a&gt; is set, QWizard displays it in a header, in which case it also uses the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt; and the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmap&lt;/a&gt; to decorate the header. The &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmap&lt;/a&gt; is displayed on the left side, below the header. At the bottom, there is a row of buttons allowing the user to navigate through the pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7322771e8958658ead503160124f934fb65197f8" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&amp;lt;content&amp;gt;&lt;/code&gt; element is used, the data will contain a single item with either the value of the</source>
          <target state="translated">Когда используется элемент &lt;code&gt;&amp;lt;content&amp;gt;&lt;/code&gt; , данные будут содержать один элемент со значением</target>
        </trans-unit>
        <trans-unit id="2672663ccea1c72ceff571e1774f7c56bc159e61" translate="yes" xml:space="preserve">
          <source>When a D-Bus function returns a D-Bus variant, it can be retrieved as follows:</source>
          <target state="translated">Когда функция D-Bus возвращает вариант D-Bus,его можно получить следующим образом:</target>
        </trans-unit>
        <trans-unit id="1017702957d7db1428d00195f1759c2c2ce9ca31" translate="yes" xml:space="preserve">
          <source>When a JavaScript file is imported this way, it is imported with a qualifier. The functions in that file are then accessible from the importing script via the qualifier (that is, as &lt;code&gt;Qualifier.functionName(params)&lt;/code&gt;).</source>
          <target state="translated">Когда файл JavaScript импортируется таким образом, он импортируется с квалификатором. Затем функции в этом файле доступны из импортирующего сценария через квалификатор (то есть как &lt;code&gt;Qualifier.functionName(params)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8955c961f4e03b5b4c423d7e27242490dcc367cd" translate="yes" xml:space="preserve">
          <source>When a NoDraw node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9346322a98372696210b54e5c6837cb02553ab5b" translate="yes" xml:space="preserve">
          <source>When a NoPicking node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5239011b0ce80a40d0520fced8dbad82a40aa0a" translate="yes" xml:space="preserve">
          <source>When a Plugin object is created, it is &quot;detached&quot; and not associated with any actual service plugin. Once it has received information via setting its &lt;a href=&quot;qml-qtlocation-plugin#name-prop&quot;&gt;name&lt;/a&gt;, &lt;a href=&quot;qml-qtlocation-plugin#preferred-prop&quot;&gt;preferred&lt;/a&gt;, or &lt;a href=&quot;qml-qtlocation-plugin#required-prop&quot;&gt;required&lt;/a&gt; properties, it will choose an appropriate service plugin to attach to. Plugin objects can only be attached once; to use multiple plugins, create multiple Plugin objects.</source>
          <target state="translated">Когда создается объект подключаемого модуля, он &amp;laquo;отсоединяется&amp;raquo; и не связан с каким-либо фактическим подключаемым модулем службы. После того, как он получил информацию, задав свое &lt;a href=&quot;qml-qtlocation-plugin#name-prop&quot;&gt;имя&lt;/a&gt; , &lt;a href=&quot;qml-qtlocation-plugin#preferred-prop&quot;&gt;предпочтительные&lt;/a&gt; или &lt;a href=&quot;qml-qtlocation-plugin#required-prop&quot;&gt;обязательные&lt;/a&gt; свойства, он выберет соответствующий плагин службы для подключения. Объекты плагина можно прикрепить только один раз; чтобы использовать несколько плагинов, создайте несколько объектов плагинов.</target>
        </trans-unit>
        <trans-unit id="b6f220e6e802d62e7eddcb10a35ca79f2887d75d" translate="yes" xml:space="preserve">
          <source>When a QML &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; explicitly relinquishes focus (by setting its &lt;code&gt;focus&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt; while it has active focus), the system does not automatically select another type to receive focus. That is, it is possible for there to be no currently active focus.</source>
          <target state="translated">Когда QML &lt;a href=&quot;qml-qtquick-item&quot;&gt;Пункт&lt;/a&gt; явно отказывается от фокуса (установив его &lt;code&gt;focus&lt;/code&gt; свойство &lt;code&gt;false&lt;/code&gt; в то время как он имеет активную направленность), система не будет автоматически выбрать другой тип , чтобы получить фокус. То есть может не быть активного в данный момент фокуса.</target>
        </trans-unit>
        <trans-unit id="7001a12de2df6c574e67e9da9ad3f2fc320aad4f" translate="yes" xml:space="preserve">
          <source>When a QML object type is used as a signal parameter, the parameter should use &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; as the type, and the value should be received in C++ using the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; type:</source>
          <target state="translated">Когда тип объекта QML используется в качестве параметра сигнала, параметр должен использовать &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; в качестве типа, а значение должно быть получено в C ++ с использованием типа &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="15f000278e72ce7b8d6c307887252da7193e1ede" translate="yes" xml:space="preserve">
          <source>When a QMemoryBarrier node is found in a FrameGraph branch, the barrier will be enforced prior to any draw or compute command even if these are defined deeper in the branch.</source>
          <target state="translated">Когда узел QMemoryBarrier найден в ветке FrameGraph,барьер будет принудительно установлен перед любой командой отрисовки или вычисления,даже если они определены глубже в ветке.</target>
        </trans-unit>
        <trans-unit id="d860d62ecdfb8b15dcaa97f6730ceece19277c00" translate="yes" xml:space="preserve">
          <source>When a QObject is moved to another thread, all its children will be automatically moved too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bcadc0cb5a7c58faa28e7459e38798e9f6a2b6b" translate="yes" xml:space="preserve">
          <source>When a QQuickWindow instance is deliberately hidden with &lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;() or &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;(false), it will stop rendering and its scene graph and graphics context might be released. The &lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;sceneGraphInvalidated&lt;/a&gt;() signal will be emitted when this happens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc28ed271581b3aeebbcb657c64d87496cc2b2e9" translate="yes" xml:space="preserve">
          <source>When a QToolBar is not a child of a &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;, it loses the ability to populate the extension pop up with widgets added to the toolbar using &lt;a href=&quot;qtoolbar#addWidget&quot;&gt;addWidget&lt;/a&gt;(). Please use widget actions created by inheriting &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; and implementing &lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetAction::createWidget&lt;/a&gt;() instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8aa88cb70cc32f83b8553c1a39321db3fc1b25e" translate="yes" xml:space="preserve">
          <source>When a Qt3DRender::QNoDraw node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive</source>
          <target state="translated">Когда узел Qt3DRender::QNoDraw присутствует в ветке FrameGraph,это препятствует рендереру отрисовки любого примитива</target>
        </trans-unit>
        <trans-unit id="7f62ed373c0ee65b35bdb2fc2d57ef6032e4e244" translate="yes" xml:space="preserve">
          <source>When a Qt3DRender::QNoPicking node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40263f24ec17a09841c1926737df4393300f3b67" translate="yes" xml:space="preserve">
          <source>When a button is clicked in the button box, the &lt;a href=&quot;qdialogbuttonbox#clicked&quot;&gt;clicked&lt;/a&gt;() signal is emitted for the actual button is that is pressed. For convenience, if the button has an &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;AcceptRole&lt;/a&gt;, &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;RejectRole&lt;/a&gt;, or &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;HelpRole&lt;/a&gt;, the &lt;a href=&quot;qdialogbuttonbox#accepted&quot;&gt;accepted&lt;/a&gt;(), &lt;a href=&quot;qdialogbuttonbox#rejected&quot;&gt;rejected&lt;/a&gt;(), or &lt;a href=&quot;qdialogbuttonbox#helpRequested&quot;&gt;helpRequested&lt;/a&gt;() signals are emitted respectively.</source>
          <target state="translated">Когда нажимается кнопка в кнопочном блоке, &lt;a href=&quot;qdialogbuttonbox#clicked&quot;&gt;выдается&lt;/a&gt; сигнал clicked () для самой нажатой кнопки. Для удобства, если кнопка имеет &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;AcceptRole&lt;/a&gt; , &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;RejectRole&lt;/a&gt; или &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;HelpRole&lt;/a&gt; , то &lt;a href=&quot;qdialogbuttonbox#accepted&quot;&gt;принято&lt;/a&gt; (), &lt;a href=&quot;qdialogbuttonbox#rejected&quot;&gt;отклонено&lt;/a&gt; (), или &lt;a href=&quot;qdialogbuttonbox#helpRequested&quot;&gt;HelpRequested&lt;/a&gt; сигналов () испускается соответственно.</target>
        </trans-unit>
        <trans-unit id="3391d8c7ccaaea73a623e4d861dba6f56e546160" translate="yes" xml:space="preserve">
          <source>When a button is clicked in the button box, the &lt;a href=&quot;qml-qtquick-controls2-dialogbuttonbox#clicked-signal&quot;&gt;clicked()&lt;/a&gt; signal is emitted for the actual button that is pressed. In addition, the following signals are automatically emitted when a button with the respective role(s) is pressed:</source>
          <target state="translated">Когда нажимается кнопка в блоке кнопок, &lt;a href=&quot;qml-qtquick-controls2-dialogbuttonbox#clicked-signal&quot;&gt;выдается&lt;/a&gt; сигнал clicked () для самой нажатой кнопки. Кроме того, при нажатии кнопки с соответствующей ролью автоматически издаются следующие сигналы:</target>
        </trans-unit>
        <trans-unit id="06c02f6a9dbac4345d72fdb9bb347db0a2b3bcdc" translate="yes" xml:space="preserve">
          <source>When a category is removed, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit the &lt;a href=&quot;qplacemanager#categoryRemoved&quot;&gt;QPlaceManager::categoryRemoved&lt;/a&gt;() signal. Whether a manager does so is provider specific. Managers accessing places from a web service will typically not emit these signals, while managers accessing places stored locally generally will.</source>
          <target state="translated">Когда категория удаляется, &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; может испустить &lt;a href=&quot;qplacemanager#categoryRemoved&quot;&gt;сигнал QPlaceManager :: categoryRemoved&lt;/a&gt; (). Будет ли это делать менеджер, зависит от поставщика. Менеджеры, получающие доступ к местам из веб-службы, обычно не будут излучать эти сигналы, в то время как менеджеры, обращающиеся к местам, хранящимся локально, обычно будут.</target>
        </trans-unit>
        <trans-unit id="2153d9fed3f02a16b6a6ca1c21681db29241b851" translate="yes" xml:space="preserve">
          <source>When a category is saved, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit &lt;a href=&quot;qplacemanager#categoryAdded&quot;&gt;QPlaceManager::categoryAdded&lt;/a&gt;() or &lt;a href=&quot;qplacemanager#categoryUpdated&quot;&gt;QPlaceManager::categoryUpdated&lt;/a&gt;() signals. However whether a manager does so or not is provider specific, managers accessing places from a web service will typically not emit these signals while managers accessing places locally stored generally will.</source>
          <target state="translated">Когда категория сохранена, &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; может испускать &lt;a href=&quot;qplacemanager#categoryAdded&quot;&gt;сигналы QPlaceManager :: categoryAdded&lt;/a&gt; () или &lt;a href=&quot;qplacemanager#categoryUpdated&quot;&gt;QPlaceManager :: categoryUpdated&lt;/a&gt; (). Однако независимо от того, делает это менеджер или нет, зависит от поставщика, менеджеры, получающие доступ к местам из веб-службы, обычно не будут излучать эти сигналы, в то время как менеджеры, обращающиеся к местам, хранящимся локально, обычно будут.</target>
        </trans-unit>
        <trans-unit id="74e1cabc1808cac1af0ca6415a34d8121f46bf6d" translate="yes" xml:space="preserve">
          <source>When a certain configuration is requested explicitly, no checks are done at application startup, that is, the system-provided opengl32.dll will not be examined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7ef2995bb1b9278679a4db6eb4f1c8a80df088" translate="yes" xml:space="preserve">
          <source>When a child layout object is selected, its parent layout object can be selected by pressing down the &lt;b&gt;Shift&lt;/b&gt; key while clicking on it. This makes it possible to select a specific layout in a hierarchy, which is otherwise difficult due to the small frame.</source>
          <target state="translated">Когда выбран дочерний объект макета, его родительский объект макета можно выбрать, нажав клавишу &lt;b&gt;Shift&lt;/b&gt; и щелкнув по нему. Это позволяет выбрать конкретный макет в иерархии, что в противном случае затруднительно из-за небольшого размера рамки.</target>
        </trans-unit>
        <trans-unit id="4d44facce222efbda291b9b00896c00605e23c4d" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using the &lt;a href=&quot;#nonreentrant-command&quot;&gt;\nonreentrant&lt;/a&gt; command.</source>
          <target state="translated">Когда класс помечен как &lt;a href=&quot;#reentrant-command&quot;&gt;\ &lt;/a&gt;&lt;a href=&quot;#threadsafe-command&quot;&gt;reentrant&lt;/a&gt; или \ threadsafe , функции в этом классе могут быть помечены как &lt;code&gt;nonreentrant&lt;/code&gt; с помощью команды &lt;a href=&quot;#nonreentrant-command&quot;&gt;\ nonreentrant&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0630e10d812ca6a44e69948c6fbb1d3fde2d9e6c" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using this command in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#fn-command&quot;&gt;\fn&lt;/a&gt; comment of the functions to be excluded.</source>
          <target state="translated">Когда класс отмечен как &lt;a href=&quot;#reentrant-command&quot;&gt;\ реентерабельный&lt;/a&gt; или &lt;a href=&quot;#threadsafe-command&quot;&gt;\ threadsafe&lt;/a&gt; , функции в этом классе могут быть помечены как &lt;code&gt;nonreentrant&lt;/code&gt; используя эту команду в комментарии &lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#fn-command&quot;&gt;\ fn&lt;/a&gt; функций, которые нужно исключить.</target>
        </trans-unit>
        <trans-unit id="2cd634a18329e27eaf5d023e852ce4e96a7d4f77" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using the &lt;a href=&quot;17-qdoc-commands-thread#nonreentrant-command&quot;&gt;\nonreentrant&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7d7a9372711646e9a74f31e8f75f68b4197251e" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using this command in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/13-qdoc-commands-topics.html#fn-command&quot;&gt;\fn&lt;/a&gt; comment of the functions to be excluded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb8493d30c9e50739fc7b9788b39ac10cc03ca43" translate="yes" xml:space="preserve">
          <source>When a composition mode is set it applies to all painting operator, pens, brushes, gradients and pixmap/image drawing.</source>
          <target state="translated">Когда установлен режим композиции,он применяется ко всем операторам рисования,ручкам,кистям,градиентам и рисованию пикселей/изображений.</target>
        </trans-unit>
        <trans-unit id="38b6f0bc81c40f221944d8b87c8853be0ed28449" translate="yes" xml:space="preserve">
          <source>When a container extension is required,</source>
          <target state="translated">Когда требуется удлинение контейнера,</target>
        </trans-unit>
        <trans-unit id="0e4a24a47776590b3614eff94072d51c15c8244d" translate="yes" xml:space="preserve">
          <source>When a custom valueBar is defined, its &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; property must be set.</source>
          <target state="translated">Когда определяется настраиваемый valueBar, должно быть установлено его свойство &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c4b40a6fbd23b160b7fe00aefbf0818b8bf8785" translate="yes" xml:space="preserve">
          <source>When a data stream operates on an asynchronous device, the chunks of data can arrive at arbitrary points in time. The &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; class implements a transaction mechanism that provides the ability to read the data atomically with a series of stream operators. As an example, you can handle incomplete reads from a socket by using a transaction in a slot connected to the readyRead() signal:</source>
          <target state="translated">Когда поток данных работает на асинхронном устройстве, фрагменты данных могут поступать в произвольные моменты времени. Класс &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; реализует механизм транзакций, который обеспечивает возможность атомарного чтения данных с помощью ряда потоковых операторов. Например, вы можете обрабатывать неполные чтения из сокета, используя транзакцию в слоте, подключенном к сигналу readyRead ():</target>
        </trans-unit>
        <trans-unit id="2309abfd6e3825de006d2babd2f4bdd6e5bf7873" translate="yes" xml:space="preserve">
          <source>When a data stream operates on an asynchronous device, the chunks of data can arrive at arbitrary points in time. The QDataStream class implements a transaction mechanism that provides the ability to read the data atomically with a series of stream operators. As an example, you can handle incomplete reads from a socket by using a transaction in a slot connected to the readyRead() signal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b820cde4dc4a7341cb53aee76f1d46245199229" translate="yes" xml:space="preserve">
          <source>When a delay is set, the event will be queued for delivery after the timeout has passed. The state machine takes ownership of</source>
          <target state="translated">Когда установлена задержка,событие будет поставлено в очередь на доставку по истечении таймаута.Государственная машина берет на себя</target>
        </trans-unit>
        <trans-unit id="23bd60283b08b2b77caeefa53fd2bdd658b2b566" translate="yes" xml:space="preserve">
          <source>When a delay is set, the event will be queued for delivery after the timeout has passed. The state machine takes ownership of the event and deletes it after processing.</source>
          <target state="translated">Когда установлена задержка,событие будет поставлено в очередь на доставку по истечении таймаута.Государственная машина берет на себя ответственность за событие и удаляет его после обработки.</target>
        </trans-unit>
        <trans-unit id="d09fa2d377e5a85c50e883812625f0a7a5fde3e3" translate="yes" xml:space="preserve">
          <source>When a dock widget or tool bar is dragged over the main window, the main window adjusts its contents to indicate where the dock widget or tool bar will be docked if it is dropped. Setting this property causes &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; to move its contents in a smooth animation. Clearing this property causes the contents to snap into their new positions.</source>
          <target state="translated">Когда закрепляемый виджет или панель инструментов перетаскивается по главному окну, главное окно корректирует свое содержимое, чтобы указать, где закрепляемый виджет или панель инструментов будет закреплен, если он будет отброшен. Установка этого свойства заставляет &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; перемещать свое содержимое в плавной анимации. Очистка этого свойства приводит к тому, что содержимое фиксируется на своих новых позициях.</target>
        </trans-unit>
        <trans-unit id="da9490d3c1f9946041e7eb1512b2be2ffa63a1b3" translate="yes" xml:space="preserve">
          <source>When a drag and drop operation is performed over a view, the underlying model is queried to determine which types of operation it supports and the MIME types it can accept. This information is provided by the &lt;a href=&quot;qabstractitemmodel#supportedDropActions&quot;&gt;QAbstractItemModel::supportedDropActions&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel::mimeTypes&lt;/a&gt;() functions. Models that do not override the implementations provided by &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; support copy operations and the default internal MIME type for items.</source>
          <target state="translated">Когда операция перетаскивания выполняется над представлением, запрашивается базовая модель, чтобы определить, какие типы операций она поддерживает и какие типы MIME она может принимать. Эта информация предоставляется функциями &lt;a href=&quot;qabstractitemmodel#supportedDropActions&quot;&gt;QAbstractItemModel :: supportedDropActions&lt;/a&gt; () и &lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel :: mimeTypes&lt;/a&gt; (). Модели, которые не переопределяют реализации, предоставляемые &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel,&lt;/a&gt; поддерживают операции копирования и внутренний MIME-тип по умолчанию для элементов.</target>
        </trans-unit>
        <trans-unit id="e9b8c9681d5d37404723c8f5a9ebfc9d97539a77" translate="yes" xml:space="preserve">
          <source>When a drag is &lt;a href=&quot;qml-qtquick-drag#active-attached-prop&quot;&gt;active&lt;/a&gt; on an item, any change in that item's position will generate a drag event that will be sent to any &lt;a href=&quot;qml-qtquick-droparea&quot;&gt;DropArea&lt;/a&gt; that intersects with the new position of the item. Other items which implement drag and drop event handlers can also receive these events.</source>
          <target state="translated">Когда на элементе &lt;a href=&quot;qml-qtquick-drag#active-attached-prop&quot;&gt;активно&lt;/a&gt; перетаскивание , любое изменение положения этого элемента вызовет событие перетаскивания, которое будет отправлено в любую область &lt;a href=&quot;qml-qtquick-droparea&quot;&gt;DropArea,&lt;/a&gt; которая пересекается с новой позицией элемента. Другие элементы, которые реализуют обработчики событий перетаскивания, также могут получать эти события.</target>
        </trans-unit>
        <trans-unit id="c95a54f3a1918c06f2cbe85cf290554fb693d8ac" translate="yes" xml:space="preserve">
          <source>When a drag is not active this property holds the object that accepted the drop event that ended the drag, if no object accepted the drop or the drag was canceled the target will then be null.</source>
          <target state="translated">Когда перетаскивание не активно,это свойство удерживает объект,принявший событие перетаскивания,которое завершило перетаскивание,если ни один объект не принял перетаскивание или перетаскивание было отменено,целевое значение будет равно нулю.</target>
        </trans-unit>
        <trans-unit id="8dd9d07c03937978798b7bb1627270a6ea3c810d" translate="yes" xml:space="preserve">
          <source>When a drop occurs elsewhere in the view, and the row number is unusable, we append items to the top level of the model.</source>
          <target state="translated">Когда происходит падение в другом месте представления,и номер строки непригоден для использования,мы добавляем элементы на верхний уровень модели.</target>
        </trans-unit>
        <trans-unit id="f51c41bb148e0dd3152b4f6f3f9915d8028fe189" translate="yes" xml:space="preserve">
          <source>When a drop occurs in the widget, the dropEvent() handler function is called, and we can deal with each possible action in turn. First, we deal with drag and drop operations within the same widget:</source>
          <target state="translated">При возникновении падения в виджет вызывается функция-обработчик dropEvent(),и мы можем по очереди работать с каждым возможным действием.Во-первых,мы имеем дело с операциями перетаскивания внутри одного и того же виджета:</target>
        </trans-unit>
        <trans-unit id="b42ee2ab5c63e4e31745c7c35ebc8cf0bcf255bd" translate="yes" xml:space="preserve">
          <source>When a drop occurs, the model index corresponding to the parent item will either be valid, indicating that the drop occurred on an item, or it will be invalid, indicating that the drop occurred somewhere in the view that corresponds to top level of the model.</source>
          <target state="translated">Когда происходит падение,индекс модели,соответствующий родительскому элементу,будет либо действительным,указывая на то,что падение произошло на элемент,либо недействительным,указывая на то,что падение произошло где-то во взгляде,соответствующем верхнему уровню модели.</target>
        </trans-unit>
        <trans-unit id="fa514711ce33d2215ed2e3d6a6f7e5ed0189a13b" translate="yes" xml:space="preserve">
          <source>When a focus scope receives active focus, the contained type with &lt;code&gt;focus&lt;/code&gt; set (if any) also gets the active focus. If this type is also a &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt;, the proxying behavior continues. Both the focus scope and the sub-focused item will have the &lt;code&gt;activeFocus&lt;/code&gt; property set.</source>
          <target state="translated">Когда область фокуса получает активный фокус, содержащийся тип с установленным &lt;code&gt;focus&lt;/code&gt; (если есть) также получает активный фокус. Если этот тип также является &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt; , проксирование продолжается. Как для области фокуса, так и для &lt;code&gt;activeFocus&lt;/code&gt; элемента будет установлено свойство activeFocus .</target>
        </trans-unit>
        <trans-unit id="9e613a8bc60ebbcd1e9e0949919a88ee9070005d" translate="yes" xml:space="preserve">
          <source>When a formatter is attached to a value axis, the axis range cannot include negative values or the zero.</source>
          <target state="translated">Если к оси значений прикреплена форматерия,то диапазон осей не может включать отрицательные значения или ноль.</target>
        </trans-unit>
        <trans-unit id="6f6b92c6c88b8efb6145fe6bc4f3bfc2d29e118a" translate="yes" xml:space="preserve">
          <source>When a gesture is canceled, the &lt;a href=&quot;qgesturerecognizer#reset&quot;&gt;reset&lt;/a&gt;() function is called, giving the recognizer the chance to update the appropriate properties in the corresponding &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; object.</source>
          <target state="translated">Когда жест отменяется, вызывается функция &lt;a href=&quot;qgesturerecognizer#reset&quot;&gt;reset&lt;/a&gt; (), которая дает распознавателю возможность обновить соответствующие свойства в соответствующем объекте &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="428d7789009cbf1fc7ea52cad52f4379b3aabfc7" translate="yes" xml:space="preserve">
          <source>When a highlighted item is activated, the popup is closed, &lt;a href=&quot;qml-qtquick-controls2-combobox#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; is set to &lt;code&gt;highlightedIndex&lt;/code&gt;, and the value of this property is reset to &lt;code&gt;-1&lt;/code&gt;, as there is no longer a highlighted item.</source>
          <target state="translated">Когда активирован выделенный элемент, всплывающее окно закрывается, для &lt;a href=&quot;qml-qtquick-controls2-combobox#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; устанавливается значение &lt;code&gt;highlightedIndex&lt;/code&gt; , а значение этого свойства сбрасывается на &lt;code&gt;-1&lt;/code&gt; , так как выделенного элемента больше нет.</target>
        </trans-unit>
        <trans-unit id="4eebccda1013bfd9e4d9b4103626dd2994ae925f" translate="yes" xml:space="preserve">
          <source>When a key is pressed or released, a key event is generated and delivered to the focused Qt Quick &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt;. To facilitate the construction of reusable components and to address some of the cases unique to fluid user interfaces, the Qt Quick items add a scope based extension to Qt's traditional keyboard focus model.</source>
          <target state="translated">Когда клавиша нажата или отпущена, событие клавиши генерируется и доставляется в выбранный Qt Quick &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; . Чтобы упростить конструирование повторно используемых компонентов и рассмотреть некоторые случаи, уникальные для гибких пользовательских интерфейсов, элементы Qt Quick добавляют расширение на основе области видимости к традиционной модели фокуса клавиатуры Qt.</target>
        </trans-unit>
        <trans-unit id="5280aa5c73ecda9d4fb3b4f001bfc13d6e4c77a0" translate="yes" xml:space="preserve">
          <source>When a key sequence is being typed at the keyboard, it is said to be ambiguous as long as it matches the start of more than one shortcut.</source>
          <target state="translated">Когда на клавиатуре набирается последовательность клавиш,считается,что она неоднозначна,если совпадает с началом более чем одной комбинации клавиш.</target>
        </trans-unit>
        <trans-unit id="332bb39a2cb3399af84efd51d32cde06e1b10d08" translate="yes" xml:space="preserve">
          <source>When a language/country pair is specified in the constructor, one of three things can happen:</source>
          <target state="translated">Когда в конструкторе указана пара язык/страна,может произойти одна из трех вещей:</target>
        </trans-unit>
        <trans-unit id="8c010514fe89fada083c82bb7ef5814f38b6c278" translate="yes" xml:space="preserve">
          <source>When a layout is resized, items may grow or shrink. Due to this, items have a &lt;a href=&quot;qml-qtquick-layouts-layout#minimumWidth-attached-prop&quot;&gt;minimum size&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-layouts-layout#preferredWidth-attached-prop&quot;&gt;preferred size&lt;/a&gt; and a &lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;maximum size&lt;/a&gt;.</source>
          <target state="translated">При изменении размера макета элементы могут увеличиваться или уменьшаться. Благодаря этому у предметов есть &lt;a href=&quot;qml-qtquick-layouts-layout#minimumWidth-attached-prop&quot;&gt;минимальный размер&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-layouts-layout#preferredWidth-attached-prop&quot;&gt;предпочтительный размер&lt;/a&gt; и &lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;максимальный размер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2aaeb9d71f67c32d894e19f355e445af1f673900" translate="yes" xml:space="preserve">
          <source>When a low-level graphics API is in use, the scenegraph will make sure there is a CPU-side wait for the GPU to complete all work submitted to the scenegraph's graphics command queue before the scenegraph's nodes are deleted. Therefore there is no need to issue additional waits here, unless the &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;() implementation is using additional command queues.</source>
          <target state="translated">Когда используется низкоуровневый графический API, граф сцены будет обеспечивать ожидание на стороне ЦП, пока графический процессор не завершит всю работу, отправленную в очередь графических команд графа сцены, прежде чем узлы графа сцены будут удалены. Следовательно, здесь нет необходимости создавать дополнительные ожидания, если только реализация &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt; () не использует дополнительные очереди команд.</target>
        </trans-unit>
        <trans-unit id="c845af89f01e419749914b45895c1bb235d5ce01" translate="yes" xml:space="preserve">
          <source>When a menu is torn off a second menu is shown to display the menu contents in a new window. When the menu is in this mode and the menu is visible returns &lt;code&gt;true&lt;/code&gt;; otherwise false.</source>
          <target state="translated">Когда меню прерывается, отображается второе меню для отображения содержимого меню в новом окне. Когда меню находится в этом режиме и меню отображается, возвращается &lt;code&gt;true&lt;/code&gt; ; в противном случае - ложь.</target>
        </trans-unit>
        <trans-unit id="728dd6daea54bbbc47c1c0afd43ec24383ab26a3" translate="yes" xml:space="preserve">
          <source>When a model is reset it means that any previous data reported from the model is now invalid and has to be queried for again. This also means that the current item and any selected items will become invalid.</source>
          <target state="translated">Когда модель сбрасывается,это означает,что все предыдущие данные,сообщенные из модели,теперь недействительны и должны быть запрошены еще раз.Это также означает,что текущий элемент и любые выбранные элементы станут недействительными.</target>
        </trans-unit>
        <trans-unit id="5f301e5dc3d747cffb379d30922ea2160d2c0277" translate="yes" xml:space="preserve">
          <source>When a model radically changes its data it can sometimes be easier to just call this function rather than emit &lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged&lt;/a&gt;() to inform other components when the underlying data source, or its structure, has changed.</source>
          <target state="translated">Когда модель радикально изменяет свои данные, иногда может быть проще просто вызвать эту функцию, чем испустить &lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged&lt;/a&gt; (), чтобы сообщить другим компонентам, когда базовый источник данных или его структура изменились.</target>
        </trans-unit>
        <trans-unit id="798d38793d411f71af72b3a052c51c022e51937d" translate="yes" xml:space="preserve">
          <source>When a module name is used as the</source>
          <target state="translated">Когда имя модуля используется в качестве</target>
        </trans-unit>
        <trans-unit id="c8bb4a36e1cc58b9d2f69c2e0e1701bc5743d489" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;q3dcamera&quot;&gt;Q3DCamera&lt;/a&gt; object is set, it is automatically added as child of the scene.</source>
          <target state="translated">Когда устанавливается новый объект &lt;a href=&quot;q3dcamera&quot;&gt;Q3DCamera&lt;/a&gt; , он автоматически добавляется как дочерний объект сцены.</target>
        </trans-unit>
        <trans-unit id="8b455ee9f46ef6792f12c0936577f332d927c927" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;q3dlight&quot;&gt;Q3DLight&lt;/a&gt; objects is set, it is automatically added as child of the scene.</source>
          <target state="translated">Когда устанавливается новый &lt;a href=&quot;q3dlight&quot;&gt;объект Q3DLight&lt;/a&gt; , он автоматически добавляется в качестве дочернего элемента сцены.</target>
        </trans-unit>
        <trans-unit id="92c136ff15dc3f6e6eb98af265af4b77642b9592" translate="yes" xml:space="preserve">
          <source>When a new column is flicked into view, &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; will determine its width by calling the &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; function. &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; itself will never store row height or column width, as it's designed to support large models containing any number of rows and columns. Instead, it will ask the application whenever it needs to know.</source>
          <target state="translated">Когда появляется новый столбец, &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; определяет его ширину, вызывая функцию &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; . Сам &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; никогда не будет хранить высоту строки или ширину столбца, поскольку он предназначен для поддержки больших моделей, содержащих любое количество строк и столбцов. Вместо этого он будет спрашивать приложение, когда ему нужно знать.</target>
        </trans-unit>
        <trans-unit id="bd3977fd3b9d0fff4ce92833839e9fd254909e52" translate="yes" xml:space="preserve">
          <source>When a new column is flicked into view, TableView will determine its width by calling the &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; function. TableView does not store row height or column width, as it's designed to support large models containing any number of rows and columns. Instead, it will ask the application whenever it needs to know.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be74d7e819d89ccb9b1b730a61146409cce1e842" translate="yes" xml:space="preserve">
          <source>When a new connection is received, the client &lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt; is retrieved (`nextPendingConnection()`), and the signals we are interested in are connected to our slots (`textMessageReceived()`, `binaryMessageReceived()` and `disconnected()`). The client socket is remembered in a list, in case we would like to use it later (in this example, nothing is done with it).</source>
          <target state="translated">Когда новое соединение получено, клиентский &lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt; извлекается (`nextPendingConnection ()`), и сигналы, которые нас интересуют, подключаются к нашим слотам (`textMessageReceived ()`, `binaryMessageReceived ()` и `disconnected ()` ). Клиентский сокет запоминается в списке на тот случай, если мы захотим использовать его позже (в этом примере с ним ничего не делается).</target>
        </trans-unit>
        <trans-unit id="bda773011b553996318d1ca0425ceb0218190f09" translate="yes" xml:space="preserve">
          <source>When a new group is pushed onto the debug groups stack, it will inherit the configuration of the group that was previously on the top of the stack. Vice versa, popping a debug group will restore the configuration of the debug group that becomes the new top.</source>
          <target state="translated">Когда новая группа попадает в стек отладочных групп,она наследует конфигурацию группы,которая ранее находилась в верхней части стека.И наоборот,при нажатии на группу отладки восстанавливается конфигурация группы отладки,которая становится новой вершиной стека.</target>
        </trans-unit>
        <trans-unit id="ec32af560002a3f2954d27992ea538e7e19a3001" translate="yes" xml:space="preserve">
          <source>When a node acquires a replica for a known source, it sends a request for that source to the host node. Upon receipt of this request, the host will create a reply packet with the current values of all properties of the source. If the requested replica is dynamic, it will include the API definition for the source. The replica's node will be included in the list of connections that receive changes to that source from then on.</source>
          <target state="translated">Когда узел получает копию известного исходного текста,он посылает запрос на этот исходный текст на узел.После получения этого запроса узел создает пакет ответа с текущими значениями всех свойств источника.Если запрашиваемая копия является динамической,она будет включать определение API для источника.Узел реплики будет включен в список соединений,которые получают изменения в этом источнике с этого момента.</target>
        </trans-unit>
        <trans-unit id="2f9bbe722b869b83db0e2263dc70c8abde11f7e3" translate="yes" xml:space="preserve">
          <source>When a node acquires a replica for a known source, it sends a request for that source to the host node. Upon receiving this request, the host creates a reply packet with the current values for all properties of that source. If the requested replica is &lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;dynamic&lt;/a&gt;, the reply packet includes the API definition for the source. From then on, the replica's node will be included in the list of connections that receive changes to that source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d63ba8e6603b8cbc973323b39127ee0bc0ad55ba" translate="yes" xml:space="preserve">
          <source>When a page is about to be shown, &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; calls &lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt;() (which in turn calls &lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage::initializePage&lt;/a&gt;()) to fill the page with default values. By default, this function does nothing, but it can be reimplemented to initialize the page's contents based on other pages' fields (see the &lt;a href=&quot;qwizard#initialize-page&quot;&gt;example above&lt;/a&gt;).</source>
          <target state="translated">Когда страница должна быть показана, &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; вызывает &lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt; () (который, в свою очередь, вызывает &lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage :: initializePage&lt;/a&gt; ()), чтобы заполнить страницу значениями по умолчанию. По умолчанию эта функция ничего не делает, но ее можно повторно реализовать для инициализации содержимого страницы на основе полей других страниц (см. &lt;a href=&quot;qwizard#initialize-page&quot;&gt;Пример выше&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="52b8a1c2a004bc4ae73bcc37ab97f637d0e15877" translate="yes" xml:space="preserve">
          <source>When a page is about to be shown, QWizard calls &lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt;() (which in turn calls &lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage::initializePage&lt;/a&gt;()) to fill the page with default values. By default, this function does nothing, but it can be reimplemented to initialize the page's contents based on other pages' fields (see the &lt;a href=&quot;qwizard#initialize-page&quot;&gt;example above&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63e8b4686c2ce6ea480da0dde82d96ac157403d" translate="yes" xml:space="preserve">
          <source>When a parallel state group is entered, all its child states will be simultaneously entered. Transitions within the individual child states operate normally. However, any of the child states may take a transition which exits the parent state. When this happens, the parent state and all of its child states are exited.</source>
          <target state="translated">При вводе группы параллельных состояний одновременно вводятся все ее дочерние состояния.Переходы внутри отдельных дочерних состояний работают нормально.Однако в любом из дочерних состояний может произойти переход,выходящий из родительского состояния.В этом случае родительское состояние и все его дочерние состояния выходят из него.</target>
        </trans-unit>
        <trans-unit id="f1b2b5f7aefbb0cb0ec4ae4792cb7356d5cdee30" translate="yes" xml:space="preserve">
          <source>When a partial match is found, no captured substrings are returned, and the (implicit) capturing group 0 corresponding to the whole match captures the partially matched substring of the subject string.</source>
          <target state="translated">Когда найдено частичное совпадение,захваченные подстроки не возвращаются,а (неявно)захватывающая группа 0,соответствующая всему совпадению,захватывает частично совпадающие подстроки предметной строки.</target>
        </trans-unit>
        <trans-unit id="949ea8688bbfcd915778d80bb9ad32883794d483" translate="yes" xml:space="preserve">
          <source>When a pinch gesture is started, the rotation is &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">Когда запускается жест сжатия, поворот равен &lt;code&gt;0.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6eeed75e83f5493322e8f521ba32040bf1a5bd87" translate="yes" xml:space="preserve">
          <source>When a pinch gesture is started, the scale is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">При запуске жеста щипка масштаб равен &lt;code&gt;1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3947f323d774ee42a9f53aab29ffa36c8280798a" translate="yes" xml:space="preserve">
          <source>When a pixmap is inserted and the cache is about to exceed its limit, it removes pixmaps until there is enough room for the pixmap to be inserted.</source>
          <target state="translated">Когда растровое изображение вставлено и кэш почти превысил свой предел,оно удаляет растровое изображение до тех пор,пока не будет достаточно места для вставки растрового изображения.</target>
        </trans-unit>
        <trans-unit id="14e43d5273a0f220d3f6cca0d60985a5d4b8fc21" translate="yes" xml:space="preserve">
          <source>When a place is removed, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit the &lt;a href=&quot;qplacemanager#placeRemoved&quot;&gt;QPlaceManager::placeRemoved&lt;/a&gt;() signal. Whether a manager does so is provider specific. Managers accessing places from a web service will typically not emit these signals, while managers accessing places stored locally generally will.</source>
          <target state="translated">Когда место удаляется, &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; может испустить &lt;a href=&quot;qplacemanager#placeRemoved&quot;&gt;сигнал QPlaceManager :: placeRemoved&lt;/a&gt; (). Будет ли это делать менеджер, зависит от поставщика. Менеджеры, получающие доступ к местам из веб-службы, обычно не будут излучать эти сигналы, в то время как менеджеры, обращающиеся к местам, хранящимся локально, обычно будут.</target>
        </trans-unit>
        <trans-unit id="955b392e62b44331ff658695f8bca3787dde24b9" translate="yes" xml:space="preserve">
          <source>When a place is saved, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit QPlaceManager::placedAdded() or &lt;a href=&quot;qplacemanager#placeUpdated&quot;&gt;QPlaceManager::placeUpdated&lt;/a&gt;() signals. However whether a manager does so or not is provider specific, managers accessing places from a web service will typically not emit these signals while managers accessing places locally stored generally will.</source>
          <target state="translated">Когда место сохранено, &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; может испускать сигналы QPlaceManager :: placeAdded () или &lt;a href=&quot;qplacemanager#placeUpdated&quot;&gt;QPlaceManager :: placeUpdated&lt;/a&gt; (). Однако независимо от того, делает это менеджер или нет, зависит от поставщика, менеджеры, получающие доступ к местам из веб-службы, обычно не будут излучать эти сигналы, в то время как менеджеры, обращающиеся к местам, хранящимся локально, обычно будут.</target>
        </trans-unit>
        <trans-unit id="bb76ccab6b6330b8216b91871b1f1a7518967e70" translate="yes" xml:space="preserve">
          <source>When a preprocessor symbol is specified using the &lt;code&gt;defines&lt;/code&gt; variable, you can also use the &lt;a href=&quot;12-0-qdoc-commands-miscellaneous#if-command&quot;&gt;\if&lt;/a&gt; command to enclose documentation that only will be included if the preprocessor symbol is defined.</source>
          <target state="translated">Когда символ препроцессора задается с помощью &lt;code&gt;defines&lt;/code&gt; переменную, вы можете также использовать &lt;a href=&quot;12-0-qdoc-commands-miscellaneous#if-command&quot;&gt;\ если&lt;/a&gt; команда Заключите документации , которая будет включена только тогда , когда символ препроцессора определяется.</target>
        </trans-unit>
        <trans-unit id="f785beae5730b83f41acbcf90ef75b7556aac2f1" translate="yes" xml:space="preserve">
          <source>When a press event occurs, each instance of &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; chooses a single point which is not yet &quot;taken&quot; at that moment: if the press occurs within the bounds of the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt;, and no sibling &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; within the same &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; has yet acquired a passive grab on that point, and if the other constraints such as &lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt; etc. are satisfied, it's eligible, and the &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; then acquires a passive grab. In this way, the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; acts like an exclusive group: there can be multiple instances of &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt;, and the set of pressed touchpoints will be distributed among them. Each &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; which has chosen a point to track has its &lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt; property &lt;code&gt;true&lt;/code&gt;. It then continues to track its chosen point until release: the properties of the &lt;a href=&quot;qml-point&quot;&gt;point&lt;/a&gt; will be kept up-to-date. Any Item can bind to these properties, and thereby follow the point's movements.</source>
          <target state="translated">Когда происходит событие нажатия, каждый экземпляр &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; выбирает единственную точку, которая еще не &amp;laquo;занята&amp;raquo; в этот момент: если нажатие происходит в границах &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt; , и нет родственного &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler в&lt;/a&gt; пределах того же &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt; до сих пор приобрела пассивный захват по этому вопросу, и если другие ограничения , такие как &lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt; и т.д. удовлетворены, это право, а &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; затем приобретает пассивный захват. Таким образом, &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt; действует как исключительная группа: может быть несколько экземпляров &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler.&lt;/a&gt;, и набор нажатых точек взаимодействия будет распределен между ними. Каждый &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; , выбравший точку для отслеживания, имеет &lt;a href=&quot;stylesheet-reference#active&quot;&gt;активное&lt;/a&gt; свойство &lt;code&gt;true&lt;/code&gt; . Затем он продолжает отслеживать выбранную точку до выпуска: свойства &lt;a href=&quot;qml-point&quot;&gt;точки&lt;/a&gt; будут постоянно обновляться. Любой элемент может быть привязан к этим свойствам и, таким образом, отслеживать движения точки.</target>
        </trans-unit>
        <trans-unit id="10016a67871d70f0506ab0f762c8c06369cdb0ed" translate="yes" xml:space="preserve">
          <source>When a press event occurs, each instance of PointHandler chooses a single point which is not yet &quot;taken&quot; at that moment: if the press occurs within the bounds of the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt;, and no sibling PointHandler within the same &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; has yet acquired a passive grab on that point, and if the other constraints such as &lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt; etc. are satisfied, it's eligible, and the PointHandler then acquires a passive grab. In this way, the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; acts like an exclusive group: there can be multiple instances of PointHandler, and the set of pressed touchpoints will be distributed among them. Each PointHandler which has chosen a point to track has its &lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt; property &lt;code&gt;true&lt;/code&gt;. It then continues to track its chosen point until release: the properties of the &lt;a href=&quot;qml-point&quot;&gt;point&lt;/a&gt; will be kept up-to-date. Any Item can bind to these properties, and thereby follow the point's movements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfbfb0ebbd6646025b981fa339de3293519a353e" translate="yes" xml:space="preserve">
          <source>When a print request is accepted, the printer status would change, triggering a change in the status property. This would then be reported to all Replicas.</source>
          <target state="translated">Когда запрос на печать принимается,состояние принтера меняется,вызывая изменение свойства состояния.Затем об этом сообщалось бы всем репликам.</target>
        </trans-unit>
        <trans-unit id="666537301706b87af8a406d9ea46793d0d017481" translate="yes" xml:space="preserve">
          <source>When a process using &lt;a href=&quot;qsystemsemaphore&quot;&gt;QSystemSemaphore&lt;/a&gt; terminates for any reason, Unix automatically reverses the effect of all acquire operations that were not released. Thus if the process acquires a resource and then exits without releasing it, Unix will release that resource.</source>
          <target state="translated">Когда процесс, использующий &lt;a href=&quot;qsystemsemaphore&quot;&gt;QSystemSemaphore,&lt;/a&gt; завершается по какой-либо причине, Unix автоматически отменяет действие всех невыполненных операций получения. Таким образом, если процесс получает ресурс, а затем выходит, не освобождая его, Unix освободит этот ресурс.</target>
        </trans-unit>
        <trans-unit id="df1a65bbb3d9b167018ca0c5cdabe5195c1a5eea" translate="yes" xml:space="preserve">
          <source>When a process using QSystemSemaphore terminates for any reason, Unix automatically reverses the effect of all acquire operations that were not released. Thus if the process acquires a resource and then exits without releasing it, Unix will release that resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fb2e9f6ef5f613c87a38c8fd666c38c8b51fe6f" translate="yes" xml:space="preserve">
          <source>When a property sheet extension is required,</source>
          <target state="translated">Когда требуется продление имущественного листа,</target>
        </trans-unit>
        <trans-unit id="a0431b9169541b5942ac50072a09a56ca2303178" translate="yes" xml:space="preserve">
          <source>When a property value source object is assigned to a property, QML first tries to assign it normally, as though it were a regular QML type. Only if this assignment fails does the engine call the &lt;a href=&quot;qqmlpropertyvaluesource#setTarget&quot;&gt;setTarget()&lt;/a&gt; method. This allows the type to also be used in contexts other than just as a value source.</source>
          <target state="translated">Когда объект-источник значения свойства присваивается свойству, QML сначала пытается назначить его обычным образом, как если бы это был обычный тип QML. Только если это присвоение не удается, движок вызывает метод &lt;a href=&quot;qqmlpropertyvaluesource#setTarget&quot;&gt;setTarget ()&lt;/a&gt; . Это позволяет использовать тип не только в качестве источника значения, но и в других контекстах.</target>
        </trans-unit>
        <trans-unit id="5c0c5db3829a8327c7d24036abbfab378bf7a77f" translate="yes" xml:space="preserve">
          <source>When a query is run on XML data, as in the snippet above, the &lt;code&gt;doc()&lt;/code&gt; function returns the node in the built-in data model where the query evaluation will begin. But when a query is run on a custom node model containing non-XML data, one of the &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt;() functions must be called to bind a variable name to a starting node in the custom model. A $variable reference is used in the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; text to access the starting node in the custom model. It is not necessary to declare the variable name external in the query. See the example in the documentation for &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="865208c91375893b92d822994a4204209a37ba98" translate="yes" xml:space="preserve">
          <source>When a query is run on XML data, as in the snippet above, the &lt;code&gt;doc()&lt;/code&gt; function returns the node in the built-in data model where the query evaluation will begin. But when a query is run on a custom node model containing non-XML data, one of the &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt;() functions must be called to bind a variable name to a starting node in the custom model. A $variable reference is used in the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; text to access the starting node in the custom model. It is not necessary to declare the variable name external in the query. See the example in the documentation for &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;.</source>
          <target state="translated">Когда запрос выполняется для данных XML, как показано в приведенном выше фрагменте, функция &lt;code&gt;doc()&lt;/code&gt; возвращает узел во встроенной модели данных, с которого начнется оценка запроса. Но когда запрос выполняется в пользовательской модели узла, содержащей данные не в формате XML, должна быть вызвана одна из &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;функций bindVariable&lt;/a&gt; (), чтобы привязать имя переменной к начальному узлу в пользовательской модели. Ссылка на переменную $ используется в тексте &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; для доступа к начальному узлу в пользовательской модели. Необязательно объявлять имя переменной внешней в запросе. См. Пример в документации для &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b9712c67436ef44e2898fc4063b230c597593f7" translate="yes" xml:space="preserve">
          <source>When a query runs, it parses documents, allocating internal data structures to hold them, and it may load other resources over the network. It reuses these allocated resources when possible, to avoid having to reload and reparse them.</source>
          <target state="translated">Когда запрос выполняется,он анализирует документы,выделяя внутренние структуры данных для их хранения,и может загружать другие ресурсы по сети.Он использует эти выделенные ресурсы повторно,когда это возможно,чтобы избежать необходимости их перезагрузки и повторного использования.</target>
        </trans-unit>
        <trans-unit id="8a593010a6662d2b59e4a72e57582a95f2f8033f" translate="yes" xml:space="preserve">
          <source>When a rectangular clip is set in combination with &lt;a href=&quot;qsgclipnode#setIsRectangular&quot;&gt;setIsRectangular&lt;/a&gt; the renderer may in some cases use a more optimal clip method.</source>
          <target state="translated">Когда прямоугольный клип установлен в сочетании с &lt;a href=&quot;qsgclipnode#setIsRectangular&quot;&gt;setIsRectangular,&lt;/a&gt; средство визуализации в некоторых случаях может использовать более оптимальный метод клипа.</target>
        </trans-unit>
        <trans-unit id="65c8e122245f9ff6c381bb4990517a1724e6f958" translate="yes" xml:space="preserve">
          <source>When a relative URL is written to a &lt;code&gt;url&lt;/code&gt; type property, it is converted into a URL object, so &lt;b&gt;matching the URL value against the input string value will fail&lt;/b&gt;. Instead, convert the string to a URL using Qt.resolvedUrl() for means of comparison, and use &lt;code&gt;toString()&lt;/code&gt; to get the contents of the URL:</source>
          <target state="translated">Когда это относительный адрес записываются в &lt;code&gt;url&lt;/code&gt; имущества типа, он преобразуется в объект URL, так что &lt;b&gt;соответствующее значения URL против строкового значения входного потерпит неудачу&lt;/b&gt; . Вместо этого преобразуйте строку в URL-адрес, используя Qt.resolvedUrl () для сравнения, и используйте &lt;code&gt;toString()&lt;/code&gt; для получения содержимого URL-адреса:</target>
        </trans-unit>
        <trans-unit id="fccc71619fd1248dd374a7ce2288a8bbb7a01715" translate="yes" xml:space="preserve">
          <source>When a scene is set on a view, the &lt;a href=&quot;qgraphicsscene#changed&quot;&gt;QGraphicsScene::changed&lt;/a&gt;() signal is automatically connected to this view's &lt;a href=&quot;qgraphicsview#updateScene&quot;&gt;updateScene&lt;/a&gt;() slot, and the view's scroll bars are adjusted to fit the size of the scene.</source>
          <target state="translated">Когда сцена установлена ​​в представлении, сигнал &lt;a href=&quot;qgraphicsscene#changed&quot;&gt;QGraphicsScene :: changed&lt;/a&gt; () автоматически подключается к &lt;a href=&quot;qgraphicsview#updateScene&quot;&gt;слоту updateScene&lt;/a&gt; () этого представления, и полосы прокрутки представления настраиваются в соответствии с размером сцены.</target>
        </trans-unit>
        <trans-unit id="a9d5b266152d0f4cd9bb69c2a4c651cf03cd822b" translate="yes" xml:space="preserve">
          <source>When a shared object is created, it sets the reference count to 1. The reference count is incremented whenever a new object references the shared data, and decremented when the object dereferences the shared data. The shared data is deleted when the reference count becomes zero.</source>
          <target state="translated">При создании совместно используемого объекта счетчик ссылок устанавливается равным 1.Счетчик ссылок увеличивается всякий раз,когда новый объект ссылается на совместно используемые данные,и уменьшается,когда объект разыменовывает совместно используемые данные.Общие данные удаляются,когда счетчик ссылок становится равным нулю.</target>
        </trans-unit>
        <trans-unit id="cc3649a6da4b8adb60932067105d0642a4d24c46" translate="yes" xml:space="preserve">
          <source>When a shortcut's key sequence is completed, activatedAmbiguously() is emitted if the key sequence is still ambiguous (i.e., it is the start of one or more other shortcuts). The &lt;a href=&quot;qshortcut#activated&quot;&gt;activated&lt;/a&gt;() signal is not emitted in this case.</source>
          <target state="translated">Когда последовательность клавиш для ярлыка завершена, активируется activeAmbiguously (), если последовательность клавиш все еще неоднозначна (т. Е. Это начало одного или нескольких других ярлыков). В этом случае сигнал &lt;a href=&quot;qshortcut#activated&quot;&gt;active&lt;/a&gt; () не излучается.</target>
        </trans-unit>
        <trans-unit id="6332ae030a9135a45f7906377ec58084cbfab446" translate="yes" xml:space="preserve">
          <source>When a signal is emitted, the slots connected to it are usually executed immediately, just like a normal function call. When this happens, the signals and slots mechanism is totally independent of any GUI event loop. Execution of the code following the &lt;code&gt;emit&lt;/code&gt; statement will occur once all slots have returned. The situation is slightly different when using &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;queued connections&lt;/a&gt;; in such a case, the code following the &lt;code&gt;emit&lt;/code&gt; keyword will continue immediately, and the slots will be executed later.</source>
          <target state="translated">Когда сигнал испускается, подключенные к нему слоты обычно выполняются немедленно, как при обычном вызове функции. Когда это происходит, механизм сигналов и слотов полностью независим от любого цикла событий графического интерфейса. Выполнение кода, следующего за оператором &lt;code&gt;emit&lt;/code&gt; , произойдет после возврата всех слотов. Ситуация немного иная при использовании &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;соединений в очереди&lt;/a&gt; ; в таком случае код, следующий за ключевым словом &lt;code&gt;emit&lt;/code&gt; , будет продолжен немедленно, а слоты будут выполнены позже.</target>
        </trans-unit>
        <trans-unit id="9ddb05e9c434f565919399ed11ae59e44adc1a53" translate="yes" xml:space="preserve">
          <source>When a slot is called in an object due to a signal delivery or due to a remote method call, it is sometimes necessary to know the context in which that happened. In particular, if the slot determines that it wants to send the reply at a later opportunity or if it wants to reply with an error, the context is needed.</source>
          <target state="translated">Когда слот вызывается в объекте в связи с доставкой сигнала или вызовом удаленного метода,иногда необходимо знать контекст,в котором это произошло.В частности,если слот определяет,что он хочет отправить ответ при более поздней возможности,или если он хочет ответить с ошибкой,то необходим контекст.</target>
        </trans-unit>
        <trans-unit id="b82f70b447a179232f4e12d074947bc0969bd039" translate="yes" xml:space="preserve">
          <source>When a split handle is dragged, the &lt;code&gt;SplitView.preferredWidth&lt;/code&gt; or &lt;code&gt;SplitView.preferredHeight&lt;/code&gt; property is overwritten, depending on the &lt;a href=&quot;qml-qtquick-controls2-splitview#orientation-prop&quot;&gt;orientation&lt;/a&gt; of the view.</source>
          <target state="translated">При перетаскивании &lt;code&gt;SplitView.preferredWidth&lt;/code&gt; &lt;code&gt;SplitView.preferredHeight&lt;/code&gt; свойство SplitView.preferredWidth или SplitView.preferredHeight перезаписывается в зависимости от &lt;a href=&quot;qml-qtquick-controls2-splitview#orientation-prop&quot;&gt;ориентации&lt;/a&gt; представления.</target>
        </trans-unit>
        <trans-unit id="7d4d5ea445229544da0d5338a305894b8698bdd0" translate="yes" xml:space="preserve">
          <source>When a split item is resized, the preferredHeight will be set in order to keep track of the new size.</source>
          <target state="translated">При изменении размера разделенного элемента будет установлен параметр preferredHeight для отслеживания нового размера.</target>
        </trans-unit>
        <trans-unit id="161235a5aac72fca97ccfb11b438ac5fe662b266" translate="yes" xml:space="preserve">
          <source>When a split item is resized, the preferredWidth will be set in order to keep track of the new size.</source>
          <target state="translated">При изменении размера разделенного элемента будет установлен параметр preferredWidth для отслеживания нового размера.</target>
        </trans-unit>
        <trans-unit id="2a09b738b648e2f453338d46763c1dca7735230f" translate="yes" xml:space="preserve">
          <source>When a stack is added to a group using &lt;a href=&quot;qundogroup#addStack&quot;&gt;addStack&lt;/a&gt;(), the group does not take ownership of the stack. This means the stack has to be deleted separately from the group. When a stack is deleted, it is automatically removed from a group. A stack may belong to only one group. Adding it to another group will cause it to be removed from the previous group.</source>
          <target state="translated">Когда стек добавляется в группу с помощью &lt;a href=&quot;qundogroup#addStack&quot;&gt;addStack&lt;/a&gt; (), группа не становится владельцем стека. Это означает, что стек необходимо удалить отдельно от группы. Когда стопка удаляется, она автоматически удаляется из группы. Стек может принадлежать только одной группе. Добавление его в другую группу приведет к его удалению из предыдущей группы.</target>
        </trans-unit>
        <trans-unit id="3d6e4a2b53c50f2891abb48a8f6f6cc25d79ab52" translate="yes" xml:space="preserve">
          <source>When a state extends another state, it inherits all the changes of that state.</source>
          <target state="translated">Когда государство расширяет другое состояние,оно наследует все изменения этого состояния.</target>
        </trans-unit>
        <trans-unit id="6a4a099453c8a8d91cb5a5c167ee9f1538c09b8c" translate="yes" xml:space="preserve">
          <source>When a state is active, all its parent states are active by definition. When</source>
          <target state="translated">Когда состояние активно,все его родительские состояния активны по определению.Когда</target>
        </trans-unit>
        <trans-unit id="ba9d99ab4b7d6deb7d6417df3035d1441aabe91d" translate="yes" xml:space="preserve">
          <source>When a state is exited prior to the animation finishing, the behavior of the state machine depends on the target state of the transition. If the target state explicitly assigns a value to the property, no additional action will be taken. The property will be assigned the value defined by the target state.</source>
          <target state="translated">При выходе из состояния до окончания анимации поведение машины состояния зависит от целевого состояния перехода.Если целевое состояние явно назначает значение свойству,то никаких дополнительных действий предпринято не будет.Свойству будет присвоено значение,определенное целевым состоянием.</target>
        </trans-unit>
        <trans-unit id="537b863aa4165206f1678fd45b68c897e7e5bb32" translate="yes" xml:space="preserve">
          <source>When a string is surrounded by slashes, it is interpreted as a &lt;a href=&quot;qregularexpression&quot;&gt;regular expression&lt;/a&gt;.</source>
          <target state="translated">Когда строка окружена косой чертой, она интерпретируется как &lt;a href=&quot;qregularexpression&quot;&gt;регулярное выражение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4d38a1eefb6595f564c6b5c58858271837243de" translate="yes" xml:space="preserve">
          <source>When a style sheet is active, the &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; returned by &lt;a href=&quot;qwidget#style&quot;&gt;QWidget::style&lt;/a&gt;() is a wrapper &quot;style sheet&quot; style,</source>
          <target state="translated">Когда таблица стилей активна, &lt;a href=&quot;qstyle&quot;&gt;QStyle,&lt;/a&gt; возвращаемый &lt;a href=&quot;qwidget#style&quot;&gt;QWidget :: style&lt;/a&gt; (), является стилем &amp;laquo;таблицы стилей&amp;raquo; оболочки,</target>
        </trans-unit>
        <trans-unit id="e7f2cf6a190dccb2e1846d702f8b4fdcc1492b48" translate="yes" xml:space="preserve">
          <source>When a task menu extension is required,</source>
          <target state="translated">Когда требуется расширение меню задач,</target>
        </trans-unit>
        <trans-unit id="b2160c5e21033a9cae7267b16da76e63faf558c9" translate="yes" xml:space="preserve">
          <source>When a texture is sub-sampled, fewer pixels than in the original are displayed, resulting in undesirable artifacts based on which pixels are chosen. This effect is worsened when the model is moving, as different pixels are chosen at different times. In the image below, notice how the line between E3 and F3 is missing, strongly present between G3 and H3, then gone for the next 5 columns, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67462236b92450150e95164abdc0c9f99abaed6b" translate="yes" xml:space="preserve">
          <source>When a timer is started, the first trigger is usually after the specified interval has elapsed. It is sometimes desirable to trigger immediately when the timer is started; for example, to establish an initial state.</source>
          <target state="translated">При запуске таймера первый триггер,как правило,происходит по истечении заданного интервала.Иногда желательно срабатывать сразу после запуска таймера,например,для установления начального состояния.</target>
        </trans-unit>
        <trans-unit id="af89fc9ae90b687bd3803dfbbaa74da9d0b068bb" translate="yes" xml:space="preserve">
          <source>When a toolbar is resized in such a way that it is too small to show all the items it contains, an extension button will appear as the last item in the toolbar. Pressing the extension button will pop up a menu containing the items that do not currently fit in the toolbar.</source>
          <target state="translated">Когда панель инструментов изменена таким образом,что ее размер слишком мал,чтобы показывать все элементы,которые она содержит,кнопка расширения появится как последний элемент на панели инструментов.При нажатии кнопки расширения появится меню,содержащее элементы,которые в данный момент не помещаются на панели инструментов.</target>
        </trans-unit>
        <trans-unit id="fd7d3a341e5fbdb2b1a43242fcba495d019b0218" translate="yes" xml:space="preserve">
          <source>When a validator is set, the text field will only accept input which leaves the text property in an intermediate state. The &lt;a href=&quot;qml-qtquick-controls2-combobox#accepted-signal&quot;&gt;accepted&lt;/a&gt; signal will only be emitted if the text is in an acceptable state when the &lt;b&gt;Return&lt;/b&gt; or &lt;b&gt;Enter&lt;/b&gt; key is pressed.</source>
          <target state="translated">Когда установлен валидатор, текстовое поле будет принимать только ввод, который оставляет свойство текста в промежуточном состоянии. &lt;a href=&quot;qml-qtquick-controls2-combobox#accepted-signal&quot;&gt;Принятый&lt;/a&gt; сигнал будет только если текст находится в приемлемом состоянии , когда &lt;b&gt;Return&lt;/b&gt; или &lt;b&gt;Enter&lt;/b&gt; нажата клавиша.</target>
        </trans-unit>
        <trans-unit id="9881f5360fc059aa0376cd9d05bbf2f898c14217" translate="yes" xml:space="preserve">
          <source>When a variable or property holds a basic type and it is assigned to another variable or property, then a copy of the value is made. In JavaScript, this value is called a primitive value.</source>
          <target state="translated">Когда переменная или свойство имеет базовый тип и оно присваивается другой переменной или свойству,то создается копия значения.В JavaScript это значение называется примитивным значением.</target>
        </trans-unit>
        <trans-unit id="c53c2d5ff931b774b8c26a43310ae5dc80383c71" translate="yes" xml:space="preserve">
          <source>When a version number is specified (using the &lt;code&gt;&lt;a href=&quot;#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; variables in a &lt;code&gt;.qdocconf&lt;/code&gt; file), it is accessible through the corresponding \version command for use in the documentation.</source>
          <target state="translated">Когда номер версии указан (с использованием переменных &lt;code&gt;&lt;a href=&quot;#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; в файле &lt;code&gt;.qdocconf&lt;/code&gt; ), он доступен через соответствующую команду \ version для использования в документации.</target>
        </trans-unit>
        <trans-unit id="684ca00eacddf983276d3d465bca149ba5b62e18" translate="yes" xml:space="preserve">
          <source>When a version number is specified (using the &lt;code&gt;&lt;a href=&quot;22-qdoc-configuration-generalvariables#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;22-qdoc-configuration-generalvariables#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; variables in a &lt;code&gt;.qdocconf&lt;/code&gt; file), it is accessible through the corresponding \version command for use in the documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aed6e59537ae181997a746ca0c8b7b7d30d9468" translate="yes" xml:space="preserve">
          <source>When a view transition is initialized, any property bindings that refer to the &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; attached property are evaluated in preparation for the transition. Due to the nature of the internal construction of a view transition, the attributes of the &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; attached property are only valid for the relevant item when the transition is initialized, and may not be valid when the transition is actually run.</source>
          <target state="translated">При инициализации перехода представления все привязки свойств, которые относятся к вложенному свойству &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; , оцениваются при подготовке к переходу. Из-за природы внутренней конструкции перехода представления атрибуты присоединенного свойства &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; действительны только для соответствующего элемента при инициализации перехода и могут быть недействительными при фактическом запуске перехода.</target>
        </trans-unit>
        <trans-unit id="2f1582c86a02339dce081b982fa7bf2aabd7e9cf" translate="yes" xml:space="preserve">
          <source>When a view transition is initialized, any property bindings that refer to the ViewTransition attached property are evaluated in preparation for the transition. Due to the nature of the internal construction of a view transition, the attributes of the ViewTransition attached property are only valid for the relevant item when the transition is initialized, and may not be valid when the transition is actually run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="079663e19f7c1ba992af80c0570d23237432e8c5" translate="yes" xml:space="preserve">
          <source>When a web site requests an SSL client certificate, and one or more certificates are found in the system's client certificate store, this class provides access to the certificates to choose from, as well as a method for selecting one.</source>
          <target state="translated">Когда веб-сайт запрашивает сертификат SSL-клиента,и один или несколько сертификатов находятся в хранилище клиентских сертификатов системы,этот класс предоставляет доступ к сертификатам на выбор,а также к способу их выбора.</target>
        </trans-unit>
        <trans-unit id="47f6110b5cfc30bcf437b8673336a30eccbb3a9e" translate="yes" xml:space="preserve">
          <source>When a web site requests an SSL client certificate, and one or more certificates are found in the system's client certificate store, this type provides access to the certificates to choose from, as well as a method for selecting one.</source>
          <target state="translated">Когда веб-сайт запрашивает сертификат SSL-клиента,и один или несколько сертификатов находятся в хранилище клиентских сертификатов системы,этот тип предоставляет доступ к сертификатам на выбор,а также способ их выбора.</target>
        </trans-unit>
        <trans-unit id="1a0abde4adaf9ada28bc188c310ca57b1baed315" translate="yes" xml:space="preserve">
          <source>When a widget &lt;a href=&quot;qwidget#acceptDrops-prop&quot;&gt;accepts drop events&lt;/a&gt;, it will receive this event if it has accepted the most recent &lt;a href=&quot;qdragenterevent&quot;&gt;QDragEnterEvent&lt;/a&gt; or &lt;a href=&quot;qdragmoveevent&quot;&gt;QDragMoveEvent&lt;/a&gt; sent to it.</source>
          <target state="translated">Когда виджет &lt;a href=&quot;qwidget#acceptDrops-prop&quot;&gt;принимает события перетаскивания&lt;/a&gt; , он получит это событие, если он принял самое последнее отправленное ему событие &lt;a href=&quot;qdragenterevent&quot;&gt;QDragEnterEvent&lt;/a&gt; или &lt;a href=&quot;qdragmoveevent&quot;&gt;QDragMoveEvent&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="460e4079ae7809950eebb7e9e8f3fa669aaa1958" translate="yes" xml:space="preserve">
          <source>When a widget asks a style to draw an element, it provides the style with a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;, which is a class that contains the information necessary for drawing. Thanks to &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;, it is possible to make &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; draw widgets without linking in any code for the widget. This makes it possible to use &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;'s draw functions on any paint device, i.e., you can draw a combobox on any widget, not just on a &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;.</source>
          <target state="translated">Когда виджет запрашивает стиль для рисования элемента, он предоставляет стиль с помощью &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; , который представляет собой класс, содержащий информацию, необходимую для рисования. Благодаря &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; можно создавать виджеты &lt;a href=&quot;qstyle&quot;&gt;QStyle для&lt;/a&gt; рисования без ссылки в каком-либо коде для виджета. Это дает возможность использовать функции &lt;a href=&quot;qstyle&quot;&gt;рисования QStyle&lt;/a&gt; на любом устройстве рисования, т.е. вы можете рисовать поле со списком на любом виджете, а не только на &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6f3f2c1aa86e2bdbf72b92865fad22cdf8f8992" translate="yes" xml:space="preserve">
          <source>When a widget is selected, normal clipboard operations such as cut, copy, and paste can be performed on it. All of these operations can be done and undone, as necessary.</source>
          <target state="translated">При выборе виджета над ним можно выполнять обычные операции с буфером обмена,такие как вырезание,копирование и вставка.Все эти операции можно выполнять и отменять по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="32939db177a40f178792d1ab4a3586964a02a117" translate="yes" xml:space="preserve">
          <source>When a widget is used as a container to group a number of child widgets, it is known as a composite widget. These can be created by constructing a widget with the required visual properties - a &lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt;, for example - and adding child widgets to it, usually managed by a layout. The above diagram shows such a composite widget that was created using Qt Designer.</source>
          <target state="translated">Когда виджет используется в качестве контейнера для группировки нескольких дочерних виджетов, он известен как составной виджет. Их можно создать, построив виджет с необходимыми визуальными свойствами - например, &lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt; - и добавив к нему дочерние виджеты, обычно управляемые макетом. На приведенной выше диаграмме показан такой составной виджет, который был создан с помощью Qt Designer.</target>
        </trans-unit>
        <trans-unit id="752f1a934fb7040e2a75e0adc0d7c4e3b00e3529" translate="yes" xml:space="preserve">
          <source>When a widget's font changes, it resolves its entries against its parent widget. If the widget does not have a parent widget, it resolves its entries against the scene. The widget then sends itself a &lt;a href=&quot;qevent#Type-enum&quot;&gt;FontChange&lt;/a&gt; event and notifies all its descendants so that they can resolve their fonts as well.</source>
          <target state="translated">Когда шрифт виджета изменяется, он сравнивает свои записи с родительским виджетом. Если виджет не имеет родительского виджета, он разрешает свои записи относительно сцены. Затем виджет отправляет себе событие &lt;a href=&quot;qevent#Type-enum&quot;&gt;FontChange&lt;/a&gt; и уведомляет всех своих потомков, чтобы они также могли разрешить свои шрифты.</target>
        </trans-unit>
        <trans-unit id="8a4c47081bd0d78ce71a943dd5b9dd67bf60e6f3" translate="yes" xml:space="preserve">
          <source>When a widget's palette changes, it resolves its entries against its parent widget, or if it doesn't have a parent widget, it resolves against the scene. It then sends itself a &lt;a href=&quot;qevent#Type-enum&quot;&gt;PaletteChange&lt;/a&gt; event, and notifies all its descendants so they can resolve their palettes as well.</source>
          <target state="translated">Когда палитра виджета изменяется, он разрешает свои записи относительно своего родительского виджета, или, если у него нет родительского виджета, он разрешает против сцены. Затем он отправляет себе событие &lt;a href=&quot;qevent#Type-enum&quot;&gt;PaletteChange&lt;/a&gt; и уведомляет всех своих потомков, чтобы они также могли разрешить свои палитры.</target>
        </trans-unit>
        <trans-unit id="6c935a584189a93e055ba79f2173aba07e5d505b" translate="yes" xml:space="preserve">
          <source>When a window is not visible its visibility is Hidden, and setting visibility to &lt;a href=&quot;qwindow#Visibility-enum&quot;&gt;Hidden&lt;/a&gt; is the same as setting &lt;a href=&quot;qml-qtquick-window-window#visible-prop&quot;&gt;visible&lt;/a&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Когда окно не видно его видимость скрытые и установка видимость &lt;a href=&quot;qwindow#Visibility-enum&quot;&gt;скрытого&lt;/a&gt; такая же , как установка &lt;a href=&quot;qml-qtquick-window-window#visible-prop&quot;&gt;видна&lt;/a&gt; в &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="328cfe9dc26b3602c3dd93834eca6371ca53bcbc" translate="yes" xml:space="preserve">
          <source>When a window is using an OpenGL based surface and is appearing in full screen mode, problems can occur with other top-level windows which are part of the application. Due to limitations of the Windows DWM, compositing is not handled correctly for OpenGL based windows when going into full screen mode. As a result, other top-level windows are not placed on top of the full screen window when they are made visible. For example, menus may not appear correctly, or dialogs fail to show up.</source>
          <target state="translated">Когда окно использует поверхность,основанную на OpenGL,и появляется в полноэкранном режиме,могут возникнуть проблемы с другими окнами верхнего уровня,которые являются частью приложения.Из-за ограничений Windows DWM,при переходе в полноэкранный режим композиция не обрабатывается корректно для окон на основе OpenGL.В результате,другие окна верхнего уровня не помещаются поверх полноэкранного окна,когда они становятся видимыми.Например,меню может отображаться некорректно,или диалоговые окна не отображаются.</target>
        </trans-unit>
        <trans-unit id="e6e925bbf3d90d27901234a3378310aa8ca76a99" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;. Be aware however that this breaks stacking order, for example it will not be possible to have other widgets on top of the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;, so it should only be used in situations where a semi-transparent &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; with other widgets visible underneath is required.</source>
          <target state="translated">В случае крайней необходимости это ограничение можно преодолеть, установив атрибут &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_AlwaysStackOnTop&lt;/a&gt; в &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; . Однако &lt;a href=&quot;qopenglwidget&quot;&gt;имейте&lt;/a&gt; в виду , что это нарушает порядок наложения, например, невозможно будет иметь другие виджеты поверх QOpenGLWidget , поэтому его следует использовать только в ситуациях, когда требуется полупрозрачный &lt;a href=&quot;qopenglwidget&quot;&gt;виджет QOpenGLWidget&lt;/a&gt; с другими виджетами, видимыми под ним.</target>
        </trans-unit>
        <trans-unit id="b6f91c3f1d20bbeecc7d389e5ae573aae0f28831" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;. Be aware, however that this breaks stacking order. For example it will not be possible to have other widgets on top of the &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;, so it should only be used in situations where a semi-transparent &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; with other widgets visible underneath is required.</source>
          <target state="translated">В случае крайней необходимости это ограничение можно преодолеть, установив атрибут &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_AlwaysStackOnTop&lt;/a&gt; в &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; . Однако имейте в виду, что это нарушает порядок наложения. Например, невозможно будет разместить другие виджеты поверх &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; , поэтому его следует использовать только в ситуациях, когда требуется полупрозрачный &lt;a href=&quot;qquickwidget&quot;&gt;виджет QQuickWidget&lt;/a&gt; с другими видимыми под ним виджетами.</target>
        </trans-unit>
        <trans-unit id="dd97e50e2c67a4ead279bf8d8832fc9a85185034" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the QOpenGLWidget. Be aware however that this breaks stacking order, for example it will not be possible to have other widgets on top of the QOpenGLWidget, so it should only be used in situations where a semi-transparent QOpenGLWidget with other widgets visible underneath is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e79a7fffcc2719cd295404f96fe561b573e17000" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the QQuickWidget. Be aware, however that this breaks stacking order. For example it will not be possible to have other widgets on top of the QQuickWidget, so it should only be used in situations where a semi-transparent QQuickWidget with other widgets visible underneath is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9df5199ed73ebbcc06766d6511a4572850a19641" translate="yes" xml:space="preserve">
          <source>When access to the data is no longer needed be sure to call the &lt;a href=&quot;qabstractvideobuffer#unmap&quot;&gt;unmap&lt;/a&gt;() function to release the mapped memory and possibly update the buffer contents.</source>
          <target state="translated">Когда доступ к данным больше не нужен, обязательно вызовите &lt;a href=&quot;qabstractvideobuffer#unmap&quot;&gt;функцию unmap&lt;/a&gt; (), чтобы освободить отображаемую память и, возможно, обновить содержимое буфера.</target>
        </trans-unit>
        <trans-unit id="7f19c431a0d32b110924683908433279ea139496" translate="yes" xml:space="preserve">
          <source>When access to the data is no longer needed, be sure to call the &lt;a href=&quot;qvideoframe#unmap&quot;&gt;unmap&lt;/a&gt;() function to release the mapped memory and possibly update the video frame contents.</source>
          <target state="translated">Когда доступ к данным больше не нужен, обязательно вызовите &lt;a href=&quot;qvideoframe#unmap&quot;&gt;функцию unmap&lt;/a&gt; (), чтобы освободить отображаемую память и, возможно, обновить содержимое видеокадра.</target>
        </trans-unit>
        <trans-unit id="76c2596888d85f6b2c006508a41b7c104d68f3e1" translate="yes" xml:space="preserve">
          <source>When active is &lt;code&gt;true&lt;/code&gt;, and the delegate component is ready, the Instantiator will create objects according to the model. When active is &lt;code&gt;false&lt;/code&gt;, no objects will be created and any previously created objects will be destroyed.</source>
          <target state="translated">Когда active имеет значение &lt;code&gt;true&lt;/code&gt; и компонент делегата готов, Instantiator будет создавать объекты в соответствии с моделью. Если active - &lt;code&gt;false&lt;/code&gt; , объекты не будут созданы, а все ранее созданные объекты будут уничтожены.</target>
        </trans-unit>
        <trans-unit id="12b8ae889e8cb41399d2e7e574fc759816dcd949" translate="yes" xml:space="preserve">
          <source>When active is true, and the delegate component is ready, the Instantiator will create objects according to the model. When active is false, no objects will be created and any previously created objects will be destroyed.</source>
          <target state="translated">Когда активный компонент верен,а компонент делегата готов,Instantiator будет создавать объекты в соответствии с моделью.Когда active равен false,никакие объекты не будут созданы,а любые ранее созданные объекты будут уничтожены.</target>
        </trans-unit>
        <trans-unit id="bb891bbb3b1590bf7288c70b1d889bb5699abbfb" translate="yes" xml:space="preserve">
          <source>When adding or removing intervals from the time range, existing intervals within the range may be expanded, trimmed, deleted, merged or split to ensure that all intervals within the time range remain distinct and disjoint. As a consequence, all intervals added or removed from a time range must be &lt;a href=&quot;qmediatimeinterval#isNormal&quot;&gt;normal&lt;/a&gt;.</source>
          <target state="translated">При добавлении или удалении интервалов из временного диапазона существующие интервалы внутри диапазона могут быть расширены, обрезаны, удалены, объединены или разделены, чтобы гарантировать, что все интервалы внутри временного диапазона остаются отдельными и непересекающимися. Как следствие, все интервалы, добавленные или удаленные из временного диапазона, должны быть &lt;a href=&quot;qmediatimeinterval#isNormal&quot;&gt;нормальными&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d4f3812ee3ea698da8238994dd265c1c75c9c45" translate="yes" xml:space="preserve">
          <source>When adding text to a text edit, it is an advantage to add it in an edit block (see example below). The result is that the text edit does not need to build the entire document structure at once.</source>
          <target state="translated">При добавлении текста в текстовое редактирование преимущество заключается в том,что он добавляется в блок редактирования (см.пример ниже).В результате текстовое редактирование не требует создания всей структуры документа сразу.</target>
        </trans-unit>
        <trans-unit id="bb84371278c0809ff19ae10f5e09e0a84286da38" translate="yes" xml:space="preserve">
          <source>When adding touch events to the sequence,</source>
          <target state="translated">При добавлении событий касания в последовательность,</target>
        </trans-unit>
        <trans-unit id="f1538eed1aaf041d2e66701f8146b1df9ccdc51d" translate="yes" xml:space="preserve">
          <source>When additional touch points are detected, Qt first looks to see if there are any active touch points on any ancestor or descendent of the widget under the new touch point. If there are, the new touch point is grouped with the first, and the new touch point will be sent in a single &lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent&lt;/a&gt; to the widget that handled the first touch point. (The widget under the new touch point will not receive an event).</source>
          <target state="translated">Когда обнаруживаются дополнительные точки касания, Qt сначала проверяет, есть ли какие-либо активные точки касания на каком-либо предке или потомке виджета под новой точкой касания. Если есть, новая точка касания группируется с первой, и новая точка касания будет отправлена ​​в одном &lt;a href=&quot;qtouchevent&quot;&gt;событии QTouchEvent&lt;/a&gt; виджету, который обработал первую точку касания. (Виджет под новой точкой касания не получит событие).</target>
        </trans-unit>
        <trans-unit id="e556c9c43b8715d0148015f22447dd2e38354307" translate="yes" xml:space="preserve">
          <source>When additional touch points are detected, Qt first looks to see if there are any active touch points on any ancestor or descendent of the widget under the new touch point. If there are, the new touch point is grouped with the first, and the new touch point will be sent in a single QTouchEvent to the widget that handled the first touch point. (The widget under the new touch point will not receive an event).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4c9f17f04f10fedd1f9fd887395ad46b2aa135" translate="yes" xml:space="preserve">
          <source>When all content of the scene has stopped moving, the camera is jiggled very slightly between frames, and the result of each new frame is blended with the previous frames. The more frames you accumulate, the better looking the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e831f4eb7ef019746768c98e62442552c2eec2dc" translate="yes" xml:space="preserve">
          <source>When all the class attribute values are defined as they are in the style.css file that is used for rendering the Qt documentation, the above example is rendered as:</source>
          <target state="translated">Когда все значения атрибутов класса определены как они есть в файле style.css,который используется для отрисовки документации Qt,приведенный выше пример отображается как:</target>
        </trans-unit>
        <trans-unit id="bddff14c450c718712b8166ec8a19a179f1d175d" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-identifiedmodules.html#&quot;&gt;identified module&lt;/a&gt; is imported, the QML engine searches the</source>
          <target state="translated">Когда &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-identifiedmodules.html#&quot;&gt;идентифицированный модуль&lt;/a&gt; импортируется, механизм QML ищет</target>
        </trans-unit>
        <trans-unit id="9add852e9635e48ec41c6e958905759815f12454" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-modules-identifiedmodules.html&quot;&gt;identified module&lt;/a&gt; is imported, the QML engine searches the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb0af928cd358589c97b0ea36760a95bf56bf0a" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;qml-qtquick-anchoranimation&quot;&gt;AnchorAnimation&lt;/a&gt; is used in a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, it will animate any &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt; that have occurred during the state change. This can be overridden by setting a specific target item using the &lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt; property.</source>
          <target state="translated">Когда &lt;a href=&quot;qml-qtquick-anchoranimation&quot;&gt;AnchorAnimation&lt;/a&gt; используется в &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt; , он &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;анимирует&lt;/a&gt; любые AnchorChanges , произошедшие во время изменения состояния. Это можно изменить, установив конкретный целевой элемент с &lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;помощью&lt;/a&gt; свойства AnchorChanges.target .</target>
        </trans-unit>
        <trans-unit id="f7ee3afe1168f0981bdb0b13f0d2799a8598f876" translate="yes" xml:space="preserve">
          <source>When an AnchorAnimation is used in a &lt;a href=&quot;https://doc.qt.io/qt-5.15/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, it will animate any &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt; that have occurred during the state change. This can be overridden by setting a specific target item using the &lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba28642fdd34030f92c386fbe056673579dd0c3" translate="yes" xml:space="preserve">
          <source>When an accessible object is changed in a way that users need to know about, it notifies clients of the change by sending them an event via the accessible interface. This is how &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt; to indicate that its value has changed:</source>
          <target state="translated">Когда доступный объект изменяется способом, о котором должны знать пользователи, он уведомляет клиентов об изменении, отправляя им событие через доступный интерфейс. Вот как &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; вызывает &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility (),&lt;/a&gt; чтобы указать, что его значение изменилось:</target>
        </trans-unit>
        <trans-unit id="b37fb5dbdfd3c126b6bb96b69ea36eec43900147" translate="yes" xml:space="preserve">
          <source>When an accessible object is changed in a way that users need to know about, it notifies clients of the change by sending them an event via the accessible interface. This is how &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt; to indicate that its value has changed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6576db350133d85ab8ecdf7d5ae903317f8a0480" translate="yes" xml:space="preserve">
          <source>When an action is paired with buttons and menu items, the &lt;code&gt;enabled&lt;/code&gt;, &lt;code&gt;checkable&lt;/code&gt;, and &lt;code&gt;checked&lt;/code&gt; states are synced automatically. For example, in a word processor, if the user clicks a &quot;Bold&quot; toolbar button, the &quot;Bold&quot; menu item will automatically be checked. Buttons and menu items get their &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;icon&lt;/code&gt; from the action by default. An action-specific &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;icon&lt;/code&gt; can be overridden for a specific control by specifying &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;icon&lt;/code&gt; directly on the control.</source>
          <target state="translated">Когда действие сопряжено с кнопками и элементами меню, &lt;code&gt;enabled&lt;/code&gt; , &lt;code&gt;checkable&lt;/code&gt; и &lt;code&gt;checked&lt;/code&gt; состояния синхронизируются автоматически. Например, в текстовом редакторе, если пользователь нажимает кнопку панели инструментов &amp;laquo;Полужирный&amp;raquo;, автоматически будет отмечен пункт меню &amp;laquo;Полужирный&amp;raquo;. По умолчанию кнопки и пункты меню получают свой &lt;code&gt;text&lt;/code&gt; и &lt;code&gt;icon&lt;/code&gt; от действия. &lt;code&gt;text&lt;/code&gt; или &lt;code&gt;icon&lt;/code&gt; конкретного действия можно переопределить для определенного элемента управления, указав &lt;code&gt;text&lt;/code&gt; или &lt;code&gt;icon&lt;/code&gt; непосредственно в элементе управления.</target>
        </trans-unit>
        <trans-unit id="afbbfa71a43b518eb49ebc7fe0e3a201130db196" translate="yes" xml:space="preserve">
          <source>When an animation is used as a value source or in a Behavior, the default target and property name to be animated can both be inferred.</source>
          <target state="translated">Когда анимация используется в качестве источника значений или в Поведении,можно сделать вывод,что цель по умолчанию и имя свойства,которое должно быть анимировано.</target>
        </trans-unit>
        <trans-unit id="336fbed65cc485dcf3185a5f916cafb70ff1cbed" translate="yes" xml:space="preserve">
          <source>When an animation is used standalone, both the target and property need to be explicitly specified.</source>
          <target state="translated">При использовании анимации в автономном режиме необходимо явно указывать как цель,так и свойства.</target>
        </trans-unit>
        <trans-unit id="3e063384f01e7cc982fe175643205033a89ac5c6" translate="yes" xml:space="preserve">
          <source>When an application modal dialog is opened, the user must finish interacting with the dialog and close it before they can access any other window in the application. Window modal dialogs only block access to the window associated with the dialog, allowing the user to continue to use other windows in an application.</source>
          <target state="translated">При открытии диалога модального приложения пользователь должен закончить взаимодействие с этим диалогом и закрыть его,прежде чем получить доступ к любому другому окну приложения.Диалоги модального окна только блокируют доступ к окну,связанному с диалогом,позволяя пользователю продолжать использовать другие окна в приложении.</target>
        </trans-unit>
        <trans-unit id="03f1ac029efa0e89898412a8bc3f237fc158d829" translate="yes" xml:space="preserve">
          <source>When an error occurs during a transaction (including an inner transaction failing), reading from the data stream is suspended (all subsequent read operations return empty/zero values) and subsequent inner transactions are forced to fail. Starting a new outermost transaction recovers from this state. This behavior makes it unnecessary to error-check every read operation separately.</source>
          <target state="translated">При возникновении ошибки во время транзакции (в том числе при отказе внутренней транзакции)чтение из потока данных приостанавливается (все последующие операции чтения возвращают пустые/нулевые значения),а последующие внутренние транзакции принудительно завершаются неудачей.Запуск новой самой внешней транзакции восстанавливается из этого состояния.Такое поведение избавляет от необходимости проверять каждую операцию чтения по отдельности.</target>
        </trans-unit>
        <trans-unit id="d4d4dd6c5a276f9a88210865c11ad3239fc05498" translate="yes" xml:space="preserve">
          <source>When an escape button can't be determined using these rules, pressing &lt;b&gt;Esc&lt;/b&gt; has no effect.</source>
          <target state="translated">Если с помощью этих правил нельзя определить кнопку выхода, нажатие &lt;b&gt;Esc&lt;/b&gt; не действует.</target>
        </trans-unit>
        <trans-unit id="88e91d6c3ac2f70e9dc327611729bb3fc23462f4" translate="yes" xml:space="preserve">
          <source>When an escape button could not be automatically detected, pressing &lt;b&gt;Esc&lt;/b&gt; has no effect.</source>
          <target state="translated">Если кнопка выхода не может быть обнаружена автоматически, нажатие &lt;b&gt;Esc не&lt;/b&gt; имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="60deb4d5ec6470a1989d6f1aae50fd37df3fb27a" translate="yes" xml:space="preserve">
          <source>When an event notification identified by</source>
          <target state="translated">Когда уведомление о событии идентифицируется</target>
        </trans-unit>
        <trans-unit id="cc1c8c604562d809abc5eea2fc6d1c3875525ea6" translate="yes" xml:space="preserve">
          <source>When an event occurs, Qt creates an event object to represent it by constructing an instance of the appropriate &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; subclass, and delivers it to a particular instance of &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; (or one of its subclasses) by calling its &lt;a href=&quot;qobject#event&quot;&gt;event()&lt;/a&gt; function.</source>
          <target state="translated">Когда происходит событие, Qt создает объект события, чтобы представить его, создавая экземпляр соответствующего подкласса &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; , и доставляет его конкретному экземпляру &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; (или одному из его подклассов), вызывая его функцию &lt;a href=&quot;qobject#event&quot;&gt;event ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de6f46d25c54bf3f5ae53599544aff515fdc8c6f" translate="yes" xml:space="preserve">
          <source>When an extension is requested,</source>
          <target state="translated">Когда запрашивается продление,</target>
        </trans-unit>
        <trans-unit id="82176d3ebc0806a90e56a238f12634352670b5cd" translate="yes" xml:space="preserve">
          <source>When an extension is required,</source>
          <target state="translated">Когда требуется продление,</target>
        </trans-unit>
        <trans-unit id="15891740de686f6443de37f1b681bce112b87311" translate="yes" xml:space="preserve">
          <source>When an input mask is set, the &lt;a href=&quot;qlineedit#text-prop&quot;&gt;text&lt;/a&gt;() method returns a modified copy of the line edit content where all the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58900421752248eb5fa9c7e1a8662c806ac6e45" translate="yes" xml:space="preserve">
          <source>When an item becomes the child of another item:</source>
          <target state="translated">Когда предмет становится ребенком другого предмета:</target>
        </trans-unit>
        <trans-unit id="6de19d2590d4fe0fe6e06630c40b5632e67df7b0" translate="yes" xml:space="preserve">
          <source>When an item gains the keyboard grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::GrabKeyboard&lt;/a&gt; event. When it loses the keyboard grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::UngrabKeyboard&lt;/a&gt; event. These events can be used to detect when your item gains or loses the keyboard grab through other means than gaining input focus.</source>
          <target state="translated">Когда элемент захватывает клавиатуру, он получает событие &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: GrabKeyboard&lt;/a&gt; . Когда он теряет захват клавиатуры, он получает событие &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: UngrabKeyboard&lt;/a&gt; . Эти события можно использовать для обнаружения, когда ваш элемент получает или теряет захват клавиатуры другими способами, кроме получения фокуса ввода.</target>
        </trans-unit>
        <trans-unit id="64c535dc14ed7e2aa62d21df9de2e71bdefba665" translate="yes" xml:space="preserve">
          <source>When an item gains the mouse grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::GrabMouse&lt;/a&gt; event. When it loses the mouse grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::UngrabMouse&lt;/a&gt; event. These events can be used to detect when your item gains or loses the mouse grab through other means than receiving mouse button events.</source>
          <target state="translated">Когда элемент захватывает мышь, он получает событие &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: GrabMouse&lt;/a&gt; . Когда он теряет захват мыши, он получает событие &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: UngrabMouse&lt;/a&gt; . Эти события можно использовать для определения того, получает ли ваш элемент или теряет захват мыши, другими способами, кроме получения событий кнопки мыши.</target>
        </trans-unit>
        <trans-unit id="6f8dc2c7ef923f949343da800eb159af2c1dde1c" translate="yes" xml:space="preserve">
          <source>When an item in an item view is selected, also highlight the branch or other decoration.</source>
          <target state="translated">При выборе элемента в просмотре элементов,также выделите ветвь или другое украшение.</target>
        </trans-unit>
        <trans-unit id="fcc2ea9c9f7cae3dd849abe3ca69b4158eef37eb" translate="yes" xml:space="preserve">
          <source>When an item is disabled, it is not possible to trigger it through its &lt;a href=&quot;qml-qt-labs-platform-menuitem#shortcut-prop&quot;&gt;shortcut&lt;/a&gt;.</source>
          <target state="translated">Когда элемент отключен, его невозможно запустить с помощью его &lt;a href=&quot;qml-qt-labs-platform-menuitem#shortcut-prop&quot;&gt;ярлыка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="452a0cf012b3cb9c186457a25f7cb1b1b7718e16" translate="yes" xml:space="preserve">
          <source>When an item is editable (and enabled), the user can edit the item by invoking one of the view's edit triggers; see &lt;a href=&quot;qabstractitemview#editTriggers-prop&quot;&gt;QAbstractItemView::editTriggers&lt;/a&gt;.</source>
          <target state="translated">Когда элемент доступен для редактирования (и включен), пользователь может редактировать элемент, вызвав один из триггеров редактирования представления; см. &lt;a href=&quot;qabstractitemview#editTriggers-prop&quot;&gt;QAbstractItemView :: editTriggers&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53f7062365ff27f397c1a00527a4d2f3130aae95" translate="yes" xml:space="preserve">
          <source>When an item is enabled, the user can interact with it. The possible types of interaction are specified by the other item flags, such as &lt;a href=&quot;qstandarditem#isEditable&quot;&gt;isEditable&lt;/a&gt;() and &lt;a href=&quot;qstandarditem#isSelectable&quot;&gt;isSelectable&lt;/a&gt;().</source>
          <target state="translated">Когда элемент включен, пользователь может с ним взаимодействовать. Возможные типы взаимодействия указываются другими флагами элемента, такими как &lt;a href=&quot;qstandarditem#isEditable&quot;&gt;isEditable&lt;/a&gt; () и &lt;a href=&quot;qstandarditem#isSelectable&quot;&gt;isSelectable&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="cc78ed51b3f4dd69fbf5c809ac07b2202ac93036" translate="yes" xml:space="preserve">
          <source>When an item is flicked out, it moves to the</source>
          <target state="translated">Когда элемент отброшен,он переходит в режим</target>
        </trans-unit>
        <trans-unit id="edf649890497fe5584e977a2ddf9e845a6d9adbb" translate="yes" xml:space="preserve">
          <source>When an item's layer is enabled, the scene graph will allocate memory in the GPU equal to &lt;code&gt;width x height x 4&lt;/code&gt;. In memory constrained configurations, large layers should be used with care.</source>
          <target state="translated">Когда слой элемента включен, граф сцены будет выделять память в графическом процессоре, равную &lt;code&gt;width x height x 4&lt;/code&gt; . В конфигурациях с ограниченным объемом памяти большие слои следует использовать с осторожностью.</target>
        </trans-unit>
        <trans-unit id="01223f794ced4ae7d5d61d347c9ab920ed50ad46" translate="yes" xml:space="preserve">
          <source>When an object is deleted, it emits a &lt;a href=&quot;qobject#destroyed&quot;&gt;destroyed&lt;/a&gt;() signal. You can catch this signal to avoid dangling references to QObjects.</source>
          <target state="translated">Когда объект удаляется, он испускает &lt;a href=&quot;qobject#destroyed&quot;&gt;уничтожил&lt;/a&gt; сигнал (). Вы можете поймать этот сигнал, чтобы избежать висящих ссылок на QObjects.</target>
        </trans-unit>
        <trans-unit id="b5486876fa77fcc351c0468b0f817e3d9df8a75d" translate="yes" xml:space="preserve">
          <source>When and whether you actually</source>
          <target state="translated">Когда и действительно ли ты</target>
        </trans-unit>
        <trans-unit id="9d01348a9aece3a4b6e828d26241b1bbac417b30" translate="yes" xml:space="preserve">
          <source>When animations are used to assign properties, a state no longer defines the exact values that a property will have when the machine is in the given state. While the animation is running, the property can potentially have any value, depending on the animation.</source>
          <target state="translated">Когда для присвоения свойств используются анимации,состояние больше не определяет точные значения,которые будут иметь свойства,когда машина находится в данном состоянии.Пока анимация запущена,свойство потенциально может иметь любое значение,в зависимости от анимации.</target>
        </trans-unit>
        <trans-unit id="e2fc21797749a0f52070944bd489489ff6abab01" translate="yes" xml:space="preserve">
          <source>When any item is added, moved or removed within the above view, the items below it are displaced, causing them to move down (or sideways, if horizontally orientated) within the view. As this displacement occurs, the items' movement to their new x,y positions within the view will be animated by a &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; over one second, as specified.</source>
          <target state="translated">Когда какой-либо элемент добавляется, перемещается или удаляется в пределах вида выше, элементы под ним перемещаются, заставляя их перемещаться вниз (или в сторону, если они ориентированы горизонтально) внутри вида. Когда это смещение происходит, перемещение элементов к своим новым позициям x, y в представлении будет анимировано &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation в&lt;/a&gt; течение одной секунды, как указано.</target>
        </trans-unit>
        <trans-unit id="6ad254e9576e1f6e7ddb5f7d88c66a573a0635ac" translate="yes" xml:space="preserve">
          <source>When any of the states is entered, the label's text will be changed accordingly.</source>
          <target state="translated">При вводе любого из состояний текст метки будет соответствующим образом изменен.</target>
        </trans-unit>
        <trans-unit id="92871574343d3169789071570bca986c9cf96ef4" translate="yes" xml:space="preserve">
          <source>When any of these are needed, the Connections type can be used instead.</source>
          <target state="translated">Когда любой из них необходим,вместо него можно использовать тип &quot;Соединения&quot;.</target>
        </trans-unit>
        <trans-unit id="684810257cd0aed1db1716426f1de0a6c11c6d93" translate="yes" xml:space="preserve">
          <source>When any visible part of the scene changes or is reexposed, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will update the entire viewport. This approach is fastest when &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; spends more time figuring out what to draw than it would spend drawing (e.g., when very many small items are repeatedly updated). This is the preferred update mode for viewports that do not support partial updates, such as &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;, and for viewports that need to disable scroll optimization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="217cf31f7ecab879e6aeaf0c5c92b52eaff625db" translate="yes" xml:space="preserve">
          <source>When any visible part of the scene changes or is reexposed, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will update the entire viewport. This approach is fastest when &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; spends more time figuring out what to draw than it would spend drawing (e.g., when very many small items are repeatedly updated). This is the preferred update mode for viewports that do not support partial updates, such as QGLWidget, and for viewports that need to disable scroll optimization.</source>
          <target state="translated">Когда любая видимая часть сцены изменяется или повторно экспонируется, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; обновит всю область просмотра. Этот подход является самым быстрым, когда &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; тратит больше времени на выяснение того, что рисовать, чем на рисование (например, когда очень много мелких элементов повторно обновляется). Это предпочтительный режим обновления для видовых экранов, которые не поддерживают частичные обновления, таких как QGLWidget, и для видовых экранов, которым необходимо отключить оптимизацию прокрутки.</target>
        </trans-unit>
        <trans-unit id="a06bc6d7390ca623b0217a85f5d3800a53cff310" translate="yes" xml:space="preserve">
          <source>When applying &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-effects-topic.html#opacity&quot;&gt;opacity&lt;/a&gt; to an item hierarchy the opacity is applied to each item individually. This can lead to undesired visual results when the opacity is applied to a subtree. Consider the following example:</source>
          <target state="translated">При применении &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-effects-topic.html#opacity&quot;&gt;непрозрачности&lt;/a&gt; к иерархии элементов непрозрачность применяется к каждому элементу индивидуально. Это может привести к нежелательным визуальным результатам при применении непрозрачности к поддереву. Рассмотрим следующий пример:</target>
        </trans-unit>
        <trans-unit id="5a74e7e50f43c1fdec3974065e7b6a9d890d2418" translate="yes" xml:space="preserve">
          <source>When applying &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-effects-topic.html#opacity&quot;&gt;opacity&lt;/a&gt; to an item hierarchy the opacity is applied to each item individually. This can lead to undesired visual results when the opacity is applied to a subtree. Consider the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f4da2f8d439defdd9e3b555f171b3b3c94fa9c" translate="yes" xml:space="preserve">
          <source>When applying a clip to a subtree, that subtree needs to be rendered with a unique OpenGL state. This means that when &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item::clip&lt;/a&gt; is true, batching of that item is limited to its children. When there are many children, like a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt;, or complex children, like a &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt;, this is fine. One should, however, use clip on smaller items with caution as it prevents batching. This includes button label, text field or list delegate and table cells.</source>
          <target state="translated">При применении клипа к поддереву это поддерево должно быть визуализировано с уникальным состоянием OpenGL. Это означает, что когда &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item :: clip&lt;/a&gt; имеет значение true, пакетирование этого элемента ограничено его дочерними элементами. Когда есть много дочерних &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;элементов&lt;/a&gt; , таких как &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; или &lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt; , или сложных дочерних элементов , например TextArea , это нормально. Однако следует с осторожностью использовать клипсы для небольших предметов, так как это предотвращает группирование. Сюда входят метка кнопки, текстовое поле или список делегатов и ячейки таблицы.</target>
        </trans-unit>
        <trans-unit id="74f4063795ab227fe7ae24a79df545f1ccc36474" translate="yes" xml:space="preserve">
          <source>When applying a clip to a subtree, that subtree needs to be rendered with a unique OpenGL state. This means that when &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item::clip&lt;/a&gt; is true, batching of that item is limited to its children. When there are many children, like a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt;, or complex children, like a &lt;a href=&quot;qml-qtquick-controls2-textarea&quot;&gt;TextArea&lt;/a&gt;, this is fine. One should, however, use clip on smaller items with caution as it prevents batching. This includes button label, text field or list delegate and table cells.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46cb236869034e639f5c98ef59e6e0dc79b743e" translate="yes" xml:space="preserve">
          <source>When assigning values to properties in QML, any layouting the item must do as a result of the assignment might not take effect immediately, but can instead be postponed until the item is polished. For these cases, you can use this function to ensure that the item has been polished before the execution of the test continues. For example:</source>
          <target state="translated">При присваивании значений свойствам в QML,любая компоновка,которую элемент должен сделать в результате присваивания,может не вступить в силу немедленно,а вместо этого может быть отложена до тех пор,пока элемент не будет отполирован.Для этих случаев,вы можете использовать эту функцию,чтобы убедиться,что элемент был отполирован до того,как выполнение теста продолжится.Например:</target>
        </trans-unit>
        <trans-unit id="9aade8d1fb980c82f7d60913e871590165c272dc" translate="yes" xml:space="preserve">
          <source>When asynchronous is true the Instantiator will attempt to create objects asynchronously. This means that objects may not be available immediately, even if active is set to true.</source>
          <target state="translated">Когда асинхронность верна,Instantiator будет пытаться создавать объекты асинхронно.Это означает,что объекты могут быть недоступны немедленно,даже если active установлено в true.</target>
        </trans-unit>
        <trans-unit id="ed095d8711f54124e3343d3e3564a7eefda4e48d" translate="yes" xml:space="preserve">
          <source>When atEnd() and &lt;a href=&quot;qxmlstreamreader#hasError&quot;&gt;hasError&lt;/a&gt;() return true and &lt;a href=&quot;qxmlstreamreader#error&quot;&gt;error&lt;/a&gt;() returns &lt;a href=&quot;qxmlstreamreader#Error-enum&quot;&gt;PrematureEndOfDocumentError&lt;/a&gt;, it means the XML has been well-formed so far, but a complete XML document has not been parsed. The next chunk of XML can be added with &lt;a href=&quot;qxmlstreamreader#addData&quot;&gt;addData&lt;/a&gt;(), if the XML is being read from a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;, or by waiting for more data to arrive if the XML is being read from a &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;. Either way, atEnd() will return false once more data is available.</source>
          <target state="translated">Когда atEnd () и &lt;a href=&quot;qxmlstreamreader#hasError&quot;&gt;hasError&lt;/a&gt; () возвращают true, а &lt;a href=&quot;qxmlstreamreader#error&quot;&gt;error&lt;/a&gt; () возвращает &lt;a href=&quot;qxmlstreamreader#Error-enum&quot;&gt;PrematureEndOfDocumentError&lt;/a&gt; , это означает, что XML до сих пор был правильно сформирован, но полный XML-документ не был проанализирован. Следующий фрагмент XML может быть добавлен с помощью &lt;a href=&quot;qxmlstreamreader#addData&quot;&gt;addData&lt;/a&gt; (), если XML считывается из &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; , или путем ожидания поступления дополнительных данных, если XML считывается из &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; . В любом случае atEnd () вернет false, когда станут доступны новые данные.</target>
        </trans-unit>
        <trans-unit id="b3157310c43a1e88b9499e85e194d29092d5e110" translate="yes" xml:space="preserve">
          <source>When automatically registering QML types defined in C++, register an additional version of the module using this minor version. Generally, minor versions to be registered are inferred from the meta objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769b89390fbaab8a30caa729005e13bd89dd70b2" translate="yes" xml:space="preserve">
          <source>When both the &lt;a href=&quot;qml-qtpurchasing-product#identifier-prop&quot;&gt;identifier&lt;/a&gt; and type is set, the product is queried from the external market place, and its other properties are updated asynchronously. At this point, the identifier and type can no longer be changed.</source>
          <target state="translated">Если заданы и &lt;a href=&quot;qml-qtpurchasing-product#identifier-prop&quot;&gt;идентификатор,&lt;/a&gt; и тип, продукт запрашивается на внешнем рынке, а другие его свойства обновляются асинхронно. На этом этапе изменить идентификатор и тип уже нельзя.</target>
        </trans-unit>
        <trans-unit id="e66ead871376ec31f6b0bdabc0d22f6168fd30da" translate="yes" xml:space="preserve">
          <source>When both the identifier and &lt;a href=&quot;qml-qtpurchasing-product#type-prop&quot;&gt;type&lt;/a&gt; is set, the product is queried from the external market place, and its other properties are updated asynchronously. At this point, the identifier and type can no longer be changed.</source>
          <target state="translated">Если установлены и идентификатор, и &lt;a href=&quot;qml-qtpurchasing-product#type-prop&quot;&gt;тип&lt;/a&gt; , продукт запрашивается с внешнего рынка, а другие его свойства обновляются асинхронно. На этом этапе изменить идентификатор и тип уже нельзя.</target>
        </trans-unit>
        <trans-unit id="a77db60a6597f85a3430717a9225f81f9e8efd43" translate="yes" xml:space="preserve">
          <source>When building Qt from source, the configuration system checks for the presence of the &lt;code&gt;openssl/opensslv.h&lt;/code&gt; header provided by source or developer packages of OpenSSL.</source>
          <target state="translated">При сборке Qt из исходного кода система конфигурации проверяет наличие заголовка &lt;code&gt;openssl/opensslv.h&lt;/code&gt; , предоставленного исходным кодом или пакетами разработчика OpenSSL.</target>
        </trans-unit>
        <trans-unit id="481f920a35be00bb71b2fc213b17ba321c9ce91c" translate="yes" xml:space="preserve">
          <source>When building a list or a tree that has only one column, this function provides a convenient way to append a single new</source>
          <target state="translated">При построении списка или дерева,содержащего только один столбец,эта функция обеспечивает удобный способ добавления одного нового</target>
        </trans-unit>
        <trans-unit id="f4d252c2c2fbed789c886d3ea6d5aac266ab2c26" translate="yes" xml:space="preserve">
          <source>When building a list or a tree that has only one column, this function provides a convenient way to append a single new item.</source>
          <target state="translated">При построении списка или дерева,содержащего только один столбец,эта функция обеспечивает удобный способ добавления одного нового элемента.</target>
        </trans-unit>
        <trans-unit id="c2ec3d7c6f7c3543ad312c99f702307e4ac89f3b" translate="yes" xml:space="preserve">
          <source>When building a list or a tree that has only one column, this function provides a convenient way to insert a single new item.</source>
          <target state="translated">При построении списка или дерева,содержащего только один столбец,эта функция обеспечивает удобный способ вставки одного нового элемента.</target>
        </trans-unit>
        <trans-unit id="6c09737d74d2162e6fdbbf52bfd0b26549723d50" translate="yes" xml:space="preserve">
          <source>When building a version of Qt linked against OpenSSL, the build system will attempt to link with libssl and libcrypt libraries located in the default location on the developer's system. This location is configurable: set the &lt;code&gt;OPENSSL_LIBS&lt;/code&gt; environment variable to contain the linker options required to link Qt against the installed library. For example, on a Unix/Linux system:</source>
          <target state="translated">При сборке версии Qt, связанной с OpenSSL, система сборки попытается связать с библиотеками libssl и libcrypt, расположенными по умолчанию в системе разработчика. Это место настраивается: установите &lt;code&gt;OPENSSL_LIBS&lt;/code&gt; среды OPENSSL_LIBS, чтобы она содержала параметры компоновщика, необходимые для компоновки Qt с установленной библиотекой. Например, в системе Unix / Linux:</target>
        </trans-unit>
        <trans-unit id="c9861e5ecd8580ac9329bf8a380f56f7c6afce34" translate="yes" xml:space="preserve">
          <source>When building from source, ensure that the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62819592f1c6df3a87bed54e97d13fd158256db9" translate="yes" xml:space="preserve">
          <source>When building from source, ensure that the &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt; module is also built, as Qt Quick Controls 2 requires it.</source>
          <target state="translated">При сборке из исходного кода убедитесь, что модуль &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt; также построен, поскольку этого требует Qt Quick Controls 2.</target>
        </trans-unit>
        <trans-unit id="d0d5ad78ee0d3c591ef53c8a838b7b5e7736a74d" translate="yes" xml:space="preserve">
          <source>When building from source, ensure that the &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt; module is also built, as Qt Quick Controls requires it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7251f805a1544f17a9559e9785d85be1aae09528" translate="yes" xml:space="preserve">
          <source>When building user interfaces with the &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; module, all QML objects that are to be visually rendered must derive from the &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; type, as it is the base type for all visual objects in &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt;. This &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; type is implemented by the &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; C++ class, which is provided by the &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; module. Therefore, this class should be subclassed when it is necessary to implement a visual type in C++ that can be integrated into a QML-based user interface.</source>
          <target state="translated">При построении пользовательских интерфейсов с модулем &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; все объекты QML, которые должны визуально визуализироваться, должны быть производными от типа &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; , так как это базовый тип для всех визуальных объектов в &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; . Этот тип &lt;a href=&quot;qml-qtquick-item&quot;&gt;элемента&lt;/a&gt; реализуется &lt;a href=&quot;qquickitem&quot;&gt;классом QQuickItem&lt;/a&gt; C ++, который предоставляется модулем &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; . Следовательно, этот класс следует разделить на подклассы, когда необходимо реализовать визуальный тип в C ++, который может быть интегрирован в пользовательский интерфейс на основе QML.</target>
        </trans-unit>
        <trans-unit id="573536b41f02e737bb17c87ec630c4949eebe25a" translate="yes" xml:space="preserve">
          <source>When built, the Qt Image Formats plugins are located as dynamic libraries in the runtime plugin directory (typically &lt;code&gt;plugins/imageformats&lt;/code&gt;), together with the default image format plugins. They may be deployed to the target system in the same way as other plugins, see the &lt;a href=&quot;https://doc.qt.io/qt-5.13/deployment-plugins.html&quot;&gt;Deploying Plugins&lt;/a&gt; documentation.</source>
          <target state="translated">При &lt;code&gt;plugins/imageformats&lt;/code&gt; подключаемые модули Qt Image Formats располагаются в виде динамических библиотек в каталоге подключаемых модулей времени выполнения (обычно plugins / imageformats ) вместе с подключаемыми модулями формата изображения по умолчанию. Их можно развернуть в целевой системе так же, как и другие плагины, см. Документацию по &lt;a href=&quot;https://doc.qt.io/qt-5.13/deployment-plugins.html&quot;&gt;развертыванию плагинов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e398ca745e5b7e0d76604dae601be679e6ea3ec" translate="yes" xml:space="preserve">
          <source>When built, the Qt Image Formats plugins are located as dynamic libraries in the runtime plugin directory (typically &lt;code&gt;plugins/imageformats&lt;/code&gt;), together with the default image format plugins. They may be deployed to the target system in the same way as other plugins, see the &lt;a href=&quot;https://doc.qt.io/qt-5.15/deployment-plugins.html&quot;&gt;Deploying Plugins&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85c65eea35b46ad9adc8aa9df7e19d248494566d" translate="yes" xml:space="preserve">
          <source>When caching is enabled, &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; reads the file information from the file system the first time it's needed, but generally not later.</source>
          <target state="translated">Когда кэширование включено, &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; считывает информацию о файле из файловой системы в первый раз, когда это необходимо, но обычно не позже.</target>
        </trans-unit>
        <trans-unit id="63f929311e0c136280261b1674d609c45952f607" translate="yes" xml:space="preserve">
          <source>When caching is enabled, an item's &lt;a href=&quot;qgraphicsitem#paint&quot;&gt;paint&lt;/a&gt;() function will generally draw into an offscreen pixmap cache; for any subsequent repaint requests, the Graphics View framework will redraw from the cache. This approach works particularly well with QGLWidget, which stores all the cache as OpenGL textures.</source>
          <target state="translated">Когда кэширование включено, функция &lt;a href=&quot;qgraphicsitem#paint&quot;&gt;paint&lt;/a&gt; () элемента обычно будет отрисовывать закадровый кэш растровых изображений; для любых последующих запросов на перерисовку инфраструктура графического представления будет перерисовывать из кеша. Этот подход особенно хорошо работает с QGLWidget, который хранит весь кеш в виде текстур OpenGL.</target>
        </trans-unit>
        <trans-unit id="49d3402980e692757da4d25c7f056cfbcbc4090c" translate="yes" xml:space="preserve">
          <source>When calculating the size hint, &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; fetches three pixel metrics from the style: &lt;code&gt;PM_IndicatorWidth&lt;/code&gt;, &lt;code&gt;PM_CheckBoxLabelSpacing&lt;/code&gt;, and &lt;code&gt;PM_IndicatorHeight&lt;/code&gt;. &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; has the following style element tree:</source>
          <target state="translated">При вычислении подсказки размера &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; извлекает из стиля три метрики пикселей: &lt;code&gt;PM_IndicatorWidth&lt;/code&gt; , &lt;code&gt;PM_CheckBoxLabelSpacing&lt;/code&gt; и &lt;code&gt;PM_IndicatorHeight&lt;/code&gt; . &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; имеет следующее дерево элементов стиля:</target>
        </trans-unit>
        <trans-unit id="21b955b352a198452eb600dee09c98ed26feb22d" translate="yes" xml:space="preserve">
          <source>When calculating the slider's size hint, &lt;code&gt;PM_SliderThickness&lt;/code&gt; and &lt;code&gt;PM_SliderLength&lt;/code&gt; are queried from the style. As with scroll bars, the &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; only lets the user move the handle if the mouse is within &lt;code&gt;PM_MaximumDragDistance&lt;/code&gt; from the slider bounds. When it draws itself, it creates the style option and calls &lt;code&gt;drawComplexControl()&lt;/code&gt; with &lt;code&gt;CC_Slider&lt;/code&gt;:</source>
          <target state="translated">При вычислении подсказки размера ползунка &lt;code&gt;PM_SliderThickness&lt;/code&gt; и &lt;code&gt;PM_SliderLength&lt;/code&gt; запрашиваются из стиля. Как и полосы прокрутки, &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; позволяет пользователю перемещать ручку, только если мышь находится в пределах &lt;code&gt;PM_MaximumDragDistance&lt;/code&gt; от границ ползунка. Когда он рисует себя, он создает опцию стиля и вызывает &lt;code&gt;drawComplexControl()&lt;/code&gt; с &lt;code&gt;CC_Slider&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1d40ba7fa0fde8f8ba84bf5f3be3928589a792a0" translate="yes" xml:space="preserve">
          <source>When called as a constructor, a new instance of the class will be created. Only constructors exposed by &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; will be visible from the script engine.</source>
          <target state="translated">При вызове в качестве конструктора будет создан новый экземпляр класса. Только конструкторы, представленные &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE,&lt;/a&gt; будут видны из обработчика сценария.</target>
        </trans-unit>
        <trans-unit id="1a17521f28b13cf15c64f48b6b71bf71a004d243" translate="yes" xml:space="preserve">
          <source>When called by Qt,</source>
          <target state="translated">Когда его вызвал Qt,</target>
        </trans-unit>
        <trans-unit id="914ad22810e57e0a208c0b39ab77807e77834ddd" translate="yes" xml:space="preserve">
          <source>When calling Java functions that might throw an exception, it is important that you check, handle and clear out the exception before continuing.</source>
          <target state="translated">При вызове функций Java,которые могут бросить исключение,важно,чтобы вы проверили,обработали и очистили исключение перед тем,как продолжить.</target>
        </trans-unit>
        <trans-unit id="2a2e7ae65f87e90c76479fdc5ff2e4326b27c302" translate="yes" xml:space="preserve">
          <source>When calling this function, you can use the &lt;code&gt;SIGNAL()&lt;/code&gt; macro to pass a specific signal:</source>
          <target state="translated">При вызове этой функции вы можете использовать макрос &lt;code&gt;SIGNAL()&lt;/code&gt; для передачи определенного сигнала:</target>
        </trans-unit>
        <trans-unit id="16fd68ecc7c1ca2e0fddbce432b5a471d518bb57" translate="yes" xml:space="preserve">
          <source>When changing properties with values that may be defined within a resource file,</source>
          <target state="translated">При изменении свойств со значениями,которые могут быть определены в файле ресурса,</target>
        </trans-unit>
        <trans-unit id="10172d955b561d851a1e685787b7d1f3cc20d57f" translate="yes" xml:space="preserve">
          <source>When changing the geometry, the widget, if visible, receives a move event (&lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt;()) and/or a resize event (&lt;a href=&quot;qwidget#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt;()) immediately. If the widget is not currently visible, it is guaranteed to receive appropriate events before it is shown.</source>
          <target state="translated">При изменении геометрии виджет, если он виден, &lt;a href=&quot;qwidget#moveEvent&quot;&gt;немедленно&lt;/a&gt; получает событие перемещения ( moveEvent ()) и / или событие изменения размера ( &lt;a href=&quot;qwidget#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt; ()). Если виджет в данный момент не виден, он гарантированно получит соответствующие события до того, как будет показан.</target>
        </trans-unit>
        <trans-unit id="3dcc6167c4c8ec1a522615dcd2a97bfd046a2f80" translate="yes" xml:space="preserve">
          <source>When changing the position, the widget, if visible, receives a move event (&lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt;()) immediately. If the widget is not currently visible, it is guaranteed to receive an event before it is shown.</source>
          <target state="translated">При изменении положения виджет, если он виден, немедленно получает событие перемещения ( &lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt; ()). Если виджет в настоящее время не виден, он гарантированно получит событие до его отображения.</target>
        </trans-unit>
        <trans-unit id="d10e878de0de661440ee8d64ce4885521ddfa38a" translate="yes" xml:space="preserve">
          <source>When checking the signatures of its arguments, &lt;a href=&quot;qobject#connect&quot;&gt;QObject::connect&lt;/a&gt;() compares the data types literally. Thus, &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Alignment&lt;/a&gt; and &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt::Alignment&lt;/a&gt; are treated as two distinct types. To work around this limitation, make sure to fully qualify the data types when declaring signals and slots, and when establishing connections. For example:</source>
          <target state="translated">При проверке сигнатур своих аргументов &lt;a href=&quot;qobject#connect&quot;&gt;QObject :: connect&lt;/a&gt; () буквально сравнивает типы данных. Таким образом, &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Alignment&lt;/a&gt; и &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt :: Alignment&lt;/a&gt; рассматриваются как два разных типа. Чтобы обойти это ограничение, убедитесь, что типы данных полностью определены при объявлении сигналов и слотов, а также при установлении соединений. Например:</target>
        </trans-unit>
        <trans-unit id="6c76cad238f22ed5e500ffc1b09ea0553c302ab3" translate="yes" xml:space="preserve">
          <source>When choosing a widget to use as a placeholder, it is useful to compare the API of the missing widget with those of standard Qt widgets. For specialized widgets that subclass standard classes, the obvious choice of placeholder is the base class of the custom widget; for example, &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; might be used for specialized &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; subclasses.</source>
          <target state="translated">При выборе виджета для использования в качестве заполнителя полезно сравнить API отсутствующего виджета с API стандартных виджетов Qt. Для специализированных виджетов, которые являются подклассами стандартных классов, очевидный выбор заполнителя - это базовый класс настраиваемого виджета; например, &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; может использоваться для специализированных подклассов &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="16d44be4536ee05b1e19ae36cfa871d577dd74c9" translate="yes" xml:space="preserve">
          <source>When client code handling the &lt;a href=&quot;qnetworkreply#redirected&quot;&gt;redirected&lt;/a&gt;() signal has verified the new URL, it emits this signal to allow the redirect to go ahead. This protocol applies to network requests whose redirects policy is set to &lt;a href=&quot;qnetworkrequest#RedirectPolicy-enum&quot;&gt;QNetworkRequest::UserVerifiedRedirectPolicy&lt;/a&gt;</source>
          <target state="translated">Когда клиентский код, обрабатывающий сигнал &lt;a href=&quot;qnetworkreply#redirected&quot;&gt;redirected&lt;/a&gt; (), подтвердил новый URL-адрес, он излучает этот сигнал, чтобы разрешить перенаправление. Этот протокол применяется к сетевым запросам, политика перенаправления которых установлена ​​на &lt;a href=&quot;qnetworkrequest#RedirectPolicy-enum&quot;&gt;QNetworkRequest :: UserVerifiedRedirectPolicy.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a496bd66ef281f3e102e4c15780975eb23b209d8" translate="yes" xml:space="preserve">
          <source>When combined with Subdirectories, this flag enables iterating through all subdirectories of the assigned path, following all symbolic links. Symbolic link loops (e.g., &quot;link&quot; =&amp;gt; &quot;.&quot; or &quot;link&quot; =&amp;gt; &quot;..&quot;) are automatically detected and ignored.</source>
          <target state="translated">В сочетании с подкаталогами этот флаг позволяет перебирать все подкаталоги назначенного пути, следуя всем символическим ссылкам. Циклы символических ссылок (например, &amp;laquo;ссылка&amp;raquo; =&amp;gt; &amp;laquo;.&amp;raquo; Или &amp;laquo;ссылка&amp;raquo; =&amp;gt; &amp;laquo;..&amp;raquo;) автоматически обнаруживаются и игнорируются.</target>
        </trans-unit>
        <trans-unit id="b152fe7b18bfb7ca1bd752cf950491f1cf2f642f" translate="yes" xml:space="preserve">
          <source>When communicating over a bus, applications obtain what is called a &quot;service name&quot;: it is how that application chooses to be known by other applications on the same bus. The service names are brokered by the D-Bus bus daemon and are used to route messages from one application to another. An analogous concept to service names are IP addresses and hostnames: a computer normally has one IP address and may have one or more hostnames associated with it, according to the services that it provides to the network.</source>
          <target state="translated">При обмене данными по шине приложения получают то,что называется &quot;имя службы&quot;:именно так приложение выбирает,чтобы быть известным другим приложениям на той же шине.Имена служб передаются демоном шины D-Bus и используются для маршрутизации сообщений от одного приложения к другому.Аналогом имён служб являются IP-адреса и имена хостов:компьютер обычно имеет один IP-адрес и может иметь одно или несколько имен хостов,связанных с ним,в соответствии со службами,которые он предоставляет сети.</target>
        </trans-unit>
        <trans-unit id="504bd4b97e16da478eebaa7d208820d715529e5e" translate="yes" xml:space="preserve">
          <source>When comparing floating-point types (&lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;qfloat16&lt;/code&gt;), &lt;a href=&quot;qtglobal#qFuzzyCompare&quot;&gt;qFuzzyCompare&lt;/a&gt;() is used for finite values. If &lt;a href=&quot;qtglobal#qFuzzyIsNull&quot;&gt;qFuzzyIsNull&lt;/a&gt;() is true for both values, they are also considered equal. Infinities match if they have the same sign, and any NaN as actual value matches with any NaN as expected value (even though NaN != NaN, even when they're identical).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae6fe5944e7f5e553d8111bc79c5d3e6ba7dace" translate="yes" xml:space="preserve">
          <source>When complete is &lt;code&gt;true&lt;/code&gt;, any interactive items declared in &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, or &lt;code&gt;behind&lt;/code&gt; will receive mouse events.</source>
          <target state="translated">Если для завершения установлено значение &lt;code&gt;true&lt;/code&gt; , любые интерактивные элементы, объявленные &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; или &lt;code&gt;behind&lt;/code&gt; будут получать события мыши.</target>
        </trans-unit>
        <trans-unit id="fbdde588f2333734eac7dbf667c998b588ec285f" translate="yes" xml:space="preserve">
          <source>When configured with &lt;code&gt;-opengl dynamic&lt;/code&gt;, neither Qt nor the applications built using &lt;code&gt;qmake&lt;/code&gt; will link to the opengl32 (standard desktop OpenGL) or QtANGLE libraries. Instead, the appropriate library is chosen at runtime. By default, Qt will determine whether the system's opengl32.dll provides OpenGL 2 functions. If these are present, opengl32.dll is used, otherwise the ANGLE libraries (libEGL.dll and libGLESv2.dll) will be used. In case the ANGLE libraries are missing or initialization fails for some reason, an additional fallback is attempted by trying to load &lt;code&gt;opengl32sw.dll&lt;/code&gt;. See below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1731f47b651e66fd70df77e065cbada56a586326" translate="yes" xml:space="preserve">
          <source>When conflicts arise, the widget's own style sheet is always preferred to any inherited style sheet, irrespective of the specificity of the conflicting rules. Likewise, the parent widget's style sheet is preferred to the grandparent's, etc.</source>
          <target state="translated">При возникновении конфликтов,собственная таблица стилей виджета всегда предпочтительнее любой унаследованной таблицы стилей,независимо от специфики конфликтующих правил.Аналогично,родительская таблица стилей виджета предпочтительнее бабушки и дедушки и т.д.</target>
        </trans-unit>
        <trans-unit id="0ee6235e959f1c122804e1ee8f220bac499a0e14" translate="yes" xml:space="preserve">
          <source>When connecting to an ODBC datasource, you should pass the name of the ODBC datasource to the &lt;a href=&quot;qsqldatabase#setDatabaseName&quot;&gt;QSqlDatabase::setDatabaseName&lt;/a&gt;() function, rather than the actual database name.</source>
          <target state="translated">При подключении к источнику данных ODBC вы должны передать имя источника данных ODBC функции &lt;a href=&quot;qsqldatabase#setDatabaseName&quot;&gt;QSqlDatabase :: setDatabaseName&lt;/a&gt; (), а не фактическое имя базы данных.</target>
        </trans-unit>
        <trans-unit id="2f2cbe1c8aedff9ebebfb5ee6584df1a788d8183" translate="yes" xml:space="preserve">
          <source>When connecting to signals in QML, the usual way is to create an &quot;on&amp;lt;Signal&amp;gt;&quot; handler that reacts when a signal is received, like this:</source>
          <target state="translated">При подключении к сигналам в QML обычно создается обработчик &quot;on &amp;lt;Signal&amp;gt;&quot;, который реагирует на получение сигнала, например:</target>
        </trans-unit>
        <trans-unit id="50ad6900d430167293c28de8c15b55b92afdb96d" translate="yes" xml:space="preserve">
          <source>When considering the above example, there are several parties involved:</source>
          <target state="translated">При рассмотрении приведенного выше примера задействовано несколько сторон:</target>
        </trans-unit>
        <trans-unit id="490cc9bd30b6bceb26457d2a8efbb90a6b3f5fe5" translate="yes" xml:space="preserve">
          <source>When control returns to the main event loop, all events that are stored in the queue will be sent using the &lt;a href=&quot;qcoreapplication#notify&quot;&gt;notify&lt;/a&gt;() function.</source>
          <target state="translated">Когда управление возвращается в основной цикл обработки событий, все события, хранящиеся в очереди, будут отправлены с использованием функции &lt;a href=&quot;qcoreapplication#notify&quot;&gt;notify&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="a617205988b57dea8c2826ac4ae64f29a514cd0a" translate="yes" xml:space="preserve">
          <source>When created or cleared, the line edit will be filled with a copy of the input mask string where the meta characters have been removed, and the mask characters have been replaced with the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aae57f52813e54337f9b3ba12b5d957d0e7706b" translate="yes" xml:space="preserve">
          <source>When creating a &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; using a custom &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; you can choose if you want &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; to try match the size to a standard page size. By default QPaperSize uses a &lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; mode where it will match a given page size to a standard page size if it falls within 3 postscript points of a defined standard size. You can override this to request only an exact match but this is not recommended as conversions between units can easily lose 3 points and result in incorrect page sizes.</source>
          <target state="translated">При создании &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; с использованием настраиваемого &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; вы можете выбрать, хотите ли вы, чтобы &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; попытался сопоставить размер со стандартным размером страницы. По умолчанию QPaperSize использует режим &lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch, в&lt;/a&gt; котором он сопоставляет заданный размер страницы со стандартным размером страницы, если он находится в пределах 3 пунктов постскриптума от определенного стандартного размера. Вы можете переопределить это, чтобы запрашивать только точное совпадение, но это не рекомендуется, так как при преобразовании единиц измерения можно легко потерять 3 балла и привести к неправильным размерам страницы.</target>
        </trans-unit>
        <trans-unit id="9ac98a689f6faf1b4d4a231d05990beaabb87945" translate="yes" xml:space="preserve">
          <source>When creating a &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; object, you must pass the name of your company or organization as well as the name of your application. For example, if your product is called Star Runner and your company is called MySoft, you would construct the &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; object as follows:</source>
          <target state="translated">При создании объекта &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; вы должны передать название вашей компании или организации, а также название вашего приложения. Например, если ваш продукт называется Star Runner, а ваша компания называется MySoft, вы должны &lt;a href=&quot;qsettings&quot;&gt;создать&lt;/a&gt; объект QSettings следующим образом:</target>
        </trans-unit>
        <trans-unit id="acdb8c3cb9399aef996527a1d8f6a87298ec82bb" translate="yes" xml:space="preserve">
          <source>When creating a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; to contain a URL from a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; or a char*, always use &lt;a href=&quot;qstring#fromUtf8&quot;&gt;QString::fromUtf8&lt;/a&gt;().</source>
          <target state="translated">При создании &lt;a href=&quot;qstring&quot;&gt;QString,&lt;/a&gt; содержащего URL-адрес из &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; или char *, всегда используйте &lt;a href=&quot;qstring#fromUtf8&quot;&gt;QString :: fromUtf8&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="bbe42e39685b882db1d3c259aea5067777985606" translate="yes" xml:space="preserve">
          <source>When creating a QPageSize using a custom &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; you can choose if you want QPageSize to try match the size to a standard page size. By default QPaperSize uses a &lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; mode where it will match a given page size to a standard page size if it falls within 3 postscript points of a defined standard size. You can override this to request only an exact match but this is not recommended as conversions between units can easily lose 3 points and result in incorrect page sizes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4afccd147883bbee26d5e202b95e0e3a068c0b" translate="yes" xml:space="preserve">
          <source>When creating a QSettings object, you must pass the name of your company or organization as well as the name of your application. For example, if your product is called Star Runner and your company is called MySoft, you would construct the QSettings object as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d773d0579d473100a4c07b005ea00f7960a8020" translate="yes" xml:space="preserve">
          <source>When creating a custom help viewer the viewer can be configured by writing a custom collection file which could contain various keywords to be used to configure the help engine. These keywords and values and their meaning can be found in the help information for &lt;a href=&quot;https://doc.qt.io/qt-5.13/assistant-custom-help-viewer.html&quot;&gt;creating a custom help collection file&lt;/a&gt; for Assistant.</source>
          <target state="translated">При создании настраиваемого средства просмотра справки средство просмотра можно настроить, написав настраиваемый файл коллекции, который может содержать различные ключевые слова, которые будут использоваться для настройки механизма справки. Эти ключевые слова и значения, а также их значение можно найти в справочной информации по &lt;a href=&quot;https://doc.qt.io/qt-5.13/assistant-custom-help-viewer.html&quot;&gt;созданию настраиваемого файла сбора справки&lt;/a&gt; для Assistant.</target>
        </trans-unit>
        <trans-unit id="ed02b2b618cca08d2bfb9bef8750c41344446144" translate="yes" xml:space="preserve">
          <source>When creating a custom help viewer the viewer can be configured by writing a custom collection file which could contain various keywords to be used to configure the help engine. These keywords and values and their meaning can be found in the help information for &lt;a href=&quot;https://doc.qt.io/qt-5.15/assistant-custom-help-viewer.html&quot;&gt;creating a custom help collection file&lt;/a&gt; for Assistant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65bcfdb381290d9bee6e16ff1d2353f984f24d0f" translate="yes" xml:space="preserve">
          <source>When creating a custom item, item coordinates are all you need to worry about; &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; and &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will perform all transformations for you. This makes it very easy to implement custom items. For example, if you receive a mouse press or a drag enter event, the event position is given in item coordinates. The &lt;a href=&quot;qgraphicsitem#contains&quot;&gt;QGraphicsItem::contains&lt;/a&gt;() virtual function, which returns &lt;code&gt;true&lt;/code&gt; if a certain point is inside your item, and false otherwise, takes a point argument in item coordinates. Similarly, an item's bounding rect and shape are in item coordinates.</source>
          <target state="translated">При создании пользовательского элемента координаты элемента - это все, о чем вам нужно беспокоиться; &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; и &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; выполнят все преобразования за вас. Это упрощает реализацию пользовательских элементов. Например, если вы получаете событие нажатия мыши или перетаскивания, позиция события указывается в координатах элемента. &lt;a href=&quot;qgraphicsitem#contains&quot;&gt;QGraphicsItem :: содержит&lt;/a&gt; () виртуальная функция, которая возвращает &lt;code&gt;true&lt;/code&gt; , если определенная точка находится внутри вашего элемента, и ложь в противном случае, принимает аргумент точки в координатах элемента. Точно так же ограничивающий прямоугольник и форма элемента находятся в координатах элемента.</target>
        </trans-unit>
        <trans-unit id="9e08552b85a95188c1665a4dafe6b362ee82355f" translate="yes" xml:space="preserve">
          <source>When creating a map from sorted data inserting the largest key first with &lt;a href=&quot;qmap#constBegin&quot;&gt;constBegin&lt;/a&gt;() is faster than inserting in sorted order with &lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt;(), since &lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt;() - 1 (which is needed to check if the hint is valid) needs &lt;a href=&quot;containers#logarithmic-time&quot;&gt;logarithmic time&lt;/a&gt;.</source>
          <target state="translated">При создании карты из отсортированных данных вставка сначала наибольшего ключа с помощью &lt;a href=&quot;qmap#constBegin&quot;&gt;constBegin&lt;/a&gt; () выполняется быстрее, чем вставка в отсортированном порядке с помощью &lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt; (), поскольку &lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt; () - 1 (который необходим для проверки правильности подсказки) требует &lt;a href=&quot;containers#logarithmic-time&quot;&gt;логарифмического времени&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da378fc2f1f498e22d7abb9c20072ff5f0d3d3c4" translate="yes" xml:space="preserve">
          <source>When creating a new model for an existing data structure, it is important to consider which type of model should be used to provide an interface onto the data. If the data structure can be represented as a list or table of items, you can subclass &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; or &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt; since these classes provide suitable default implementations for many functions.</source>
          <target state="translated">При создании новой модели для существующей структуры данных важно учитывать, какой тип модели следует использовать для обеспечения интерфейса для данных. Если структура данных может быть представлена ​​в виде списка или таблицы элементов, вы можете создать подкласс &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; или &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel,&lt;/a&gt; поскольку эти классы предоставляют подходящие реализации по умолчанию для многих функций.</target>
        </trans-unit>
        <trans-unit id="8500b569b9e4d2538da567830ca173bb7a100287" translate="yes" xml:space="preserve">
          <source>When creating a property binding from JavaScript, the &lt;code&gt;this&lt;/code&gt; keyword can be used to refer to the object which receives the binding. This is helpful for resolving ambiguities with property names.</source>
          <target state="translated">При создании привязки свойств из JavaScript ключевое слово &lt;code&gt;this&lt;/code&gt; можно использовать для ссылки на объект, который получает привязку. Это полезно для разрешения неоднозначности с именами свойств.</target>
        </trans-unit>
        <trans-unit id="a4acef9238768bf956778e2a447e1184f2109294" translate="yes" xml:space="preserve">
          <source>When creating an &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; that targets several versions of a graphics API, it is useful to create several &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; nodes each with a &lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt; set to match one of the targeted GL versions. At runtime, the Qt3D renderer will select the most appropriate &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; based on which graphics API versions are supported and (if specified) the &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKey&lt;/a&gt; nodes that satisfy a given &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; in the FrameGraph.</source>
          <target state="translated">При создании &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; , ориентированного на несколько версий графического API, полезно создать несколько узлов &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique,&lt;/a&gt; каждый с набором &lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter,&lt;/a&gt; соответствующим одной из целевых версий GL. Во время выполнения средство визуализации Qt3D выберет наиболее подходящий &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique на&lt;/a&gt; основе поддерживаемых версий графического API и (если указано) узлов &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKey,&lt;/a&gt; которые удовлетворяют заданному &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; в FrameGraph.</target>
        </trans-unit>
        <trans-unit id="74fe2d261fd9daef09d6ad1cf9640099d84a6e3f" translate="yes" xml:space="preserve">
          <source>When creating an &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; that targets several versions of a graphics API, it is useful to create several QTechnique nodes each with a &lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt; set to match one of the targeted GL versions. At runtime, the Qt3D renderer will select the most appropriate QTechnique based on which graphics API versions are supported and (if specified) the &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKey&lt;/a&gt; nodes that satisfy a given &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; in the FrameGraph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5a5c9f752ad47937d6434e44c62e97758c6944" translate="yes" xml:space="preserve">
          <source>When creating an Effect that targets several versions of a graphics API, it is useful to create several Technique nodes each with a &lt;a href=&quot;qml-qt3d-render-technique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt; set to match one of the targeted versions. At runtime, the Qt3D renderer will select the most appropriate Technique based on which graphics API versions are supported and (if specified) the &lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;FilterKey&lt;/a&gt; nodes that satisfy a given &lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt; in the FrameGraph.</source>
          <target state="translated">При создании эффекта, который нацелен на несколько версий графического API, полезно создать несколько узлов Technique, каждый из которых имеет &lt;a href=&quot;qml-qt3d-render-technique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter,&lt;/a&gt; соответствующий одной из целевых версий. Во время выполнения средство визуализации Qt3D выберет наиболее подходящую Технику на основе поддерживаемых версий графического API и (если указано) узлов &lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;FilterKey,&lt;/a&gt; которые удовлетворяют заданному &lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt; в FrameGraph.</target>
        </trans-unit>
        <trans-unit id="f722c75ee9a2de387fc8f2d451fedcecaaa57d68" translate="yes" xml:space="preserve">
          <source>When creating custom items, use the new &lt;a href=&quot;qsgrectanglenode&quot;&gt;QSGRectangleNode&lt;/a&gt; and &lt;a href=&quot;qsgimagenode&quot;&gt;QSGImageNode&lt;/a&gt; classes. These replace the now deprecated QSGSimpleRectNode and QSGSimpleTextureNode. Unlike their predecessors, these new classes are interfaces, and implementations are created via the &lt;a href=&quot;qquickwindow#createRectangleNode&quot;&gt;QQuickWindow::createRectangleNode&lt;/a&gt;() and &lt;a href=&quot;qquickwindow#createImageNode&quot;&gt;QQuickWindow::createImageNode&lt;/a&gt;() factory functions.</source>
          <target state="translated">При создании пользовательских элементов используйте новые &lt;a href=&quot;qsgrectanglenode&quot;&gt;классы QSGRectangleNode&lt;/a&gt; и &lt;a href=&quot;qsgimagenode&quot;&gt;QSGImageNode&lt;/a&gt; . Они заменяют устаревшие QSGSimpleRectNode и QSGSimpleTextureNode. В отличие от своих предшественников, эти новые классы являются интерфейсами, а их реализации создаются с помощью фабричных функций &lt;a href=&quot;qquickwindow#createRectangleNode&quot;&gt;QQuickWindow :: createRectangleNode&lt;/a&gt; () и &lt;a href=&quot;qquickwindow#createImageNode&quot;&gt;QQuickWindow :: createImageNode&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="ad1ca55154d7a13bb0a82b3ada46b98f3f2fa71a" translate="yes" xml:space="preserve">
          <source>When creating textures via C++ scene graph APIs like &lt;a href=&quot;qquickwindow#createTextureFromImage&quot;&gt;QQuickWindow::createTextureFromImage&lt;/a&gt;(), 32-bit formats won't involve any conversion, they'll map directly to the corresponding &lt;code&gt;R8G8B8A8_UNORM&lt;/code&gt; or &lt;code&gt;B8G8R8A8_UNORM&lt;/code&gt; format. Everything else will trigger a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;-based format conversion on the CPU first.</source>
          <target state="translated">При создании текстур с помощью API-интерфейсов графа сцены C ++, таких как &lt;a href=&quot;qquickwindow#createTextureFromImage&quot;&gt;QQuickWindow :: createTextureFromImage&lt;/a&gt; (), 32-битные форматы не будут включать никакого преобразования, они будут напрямую отображаться в соответствующий &lt;code&gt;R8G8B8A8_UNORM&lt;/code&gt; или &lt;code&gt;B8G8R8A8_UNORM&lt;/code&gt; . Все остальное сначала вызовет преобразование формата на основе &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; на ЦП.</target>
        </trans-unit>
        <trans-unit id="ac8c6318f0656d7823865940204d8f34b4f9e2dc" translate="yes" xml:space="preserve">
          <source>When creating user interfaces with Qt, particularly those with specialized controls and features, developers sometimes need to create new data types that can be used alongside or in place of Qt's existing set of value types.</source>
          <target state="translated">При создании пользовательских интерфейсов с Qt,особенно тех,которые имеют специализированные элементы управления и возможности,разработчикам иногда необходимо создавать новые типы данных,которые могут быть использованы вместе или вместо существующего набора типов значений Qt.</target>
        </trans-unit>
        <trans-unit id="7c5cad017177801067fb33fec32abbde43a2a0a2" translate="yes" xml:space="preserve">
          <source>When creating visual scenes with Qt Quick, it is important to understand the concept of the</source>
          <target state="translated">При создании визуальных сцен с помощью Qt Quick,важно понимать понятие</target>
        </trans-unit>
        <trans-unit id="d8deccb0e684f6ccb3eb82d7b6672c38b9e7d190" translate="yes" xml:space="preserve">
          <source>When data is transferred from C++ to QML, the ownership of the data always remains with C++. The exception to this rule is when a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is returned from an explicit C++ method call: in this case, the QML engine assumes ownership of the object, unless the ownership of the object has explicitly been set to remain with C++ by invoking &lt;a href=&quot;qqmlengine#setObjectOwnership&quot;&gt;QQmlEngine::setObjectOwnership&lt;/a&gt;() with &lt;a href=&quot;qqmlengine#ObjectOwnership-enum&quot;&gt;QQmlEngine::CppOwnership&lt;/a&gt; specified.</source>
          <target state="translated">Когда данные передаются из C ++ в QML, право собственности на данные всегда остается за C ++. Исключением из этого правила является случай, когда &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; возвращается из явного вызова метода C ++: в этом случае механизм QML принимает владение объектом, если только право собственности на объект не было явно установлено, чтобы оставаться с C ++ путем вызова &lt;a href=&quot;qqmlengine#setObjectOwnership&quot;&gt;QQmlEngine :: setObjectOwnership&lt;/a&gt; () с &lt;a href=&quot;qqmlengine#ObjectOwnership-enum&quot;&gt;указанным QQmlEngine :: CppOwnership&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="833825b15200463ac0253e002ab1f7246eda7871" translate="yes" xml:space="preserve">
          <source>When data values are exchanged between QML and C++, they are converted by the QML engine to have the correct data types as appropriate for use in QML or C++. This requires the exchanged data to be of a type that is recognizable by the engine.</source>
          <target state="translated">Когда значения данных обмениваются между QML и C++,они преобразуются движком QML,чтобы иметь правильные типы данных,подходящие для использования в QML или C++.Это требует,чтобы обмениваемые данные были такого типа,который распознается механизмом.</target>
        </trans-unit>
        <trans-unit id="88de44478b8ed2bd120794db0b7d5b455c64de25" translate="yes" xml:space="preserve">
          <source>When dealing with shared objects, there are two ways of copying an object. We usually speak about</source>
          <target state="translated">При работе с общими объектами существует два способа копирования объекта.Обычно мы говорим о</target>
        </trans-unit>
        <trans-unit id="880f2e372d228c68b46fdc809205b92833a51398" translate="yes" xml:space="preserve">
          <source>When dealing with the D-Bus bus service or with remote applications over D-Bus, a number of error conditions can happen. This error conditions are sometimes signalled by a returned error value or by a &lt;a href=&quot;qdbuserror&quot;&gt;QDBusError&lt;/a&gt;.</source>
          <target state="translated">При работе со службой шины D-Bus или с удаленными приложениями через D-Bus может возникнуть ряд состояний ошибки. Эти условия ошибки иногда сигнализируются возвращаемым значением ошибки или &lt;a href=&quot;qdbuserror&quot;&gt;QDBusError&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="74f0ca37c9cc12fbb98f9f5310dd3caadcb27473" translate="yes" xml:space="preserve">
          <source>When dealing with the D-Bus bus service or with remote applications over D-Bus, a number of error conditions can happen. This error conditions are sometimes signalled by a returned error value or by a QDBusError.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e1660403429a1797eb4c0aeb989abc574ce656" translate="yes" xml:space="preserve">
          <source>When declaring properties in QML, it's easy and convenient to use the &quot;var&quot; type:</source>
          <target state="translated">При декларировании свойств в QML легко и удобно использовать тип &quot;var&quot;:</target>
        </trans-unit>
        <trans-unit id="499464bd993035896d274262364a35979c761cc8" translate="yes" xml:space="preserve">
          <source>When decoding Base64-encoded data, ignores errors in the input; invalid characters are simply skipped. This enum value has been added in Qt 5.15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee82abeedacfd233e0f6aece53f4beda554b1af8" translate="yes" xml:space="preserve">
          <source>When decoding Base64-encoded data, stops at the first decoding error. This enum value has been added in Qt 5.15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c7b9b1412f471c238127a4b55f7698c8fb1c87" translate="yes" xml:space="preserve">
          <source>When defining your own needle component, the only properties that the style requires you to set are the &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#implicitHeight-prop&quot;&gt;implicitHeight&lt;/a&gt;.</source>
          <target state="translated">При определении собственного компонента-иглы единственные свойства, которые стиль требует от вас установить, - это &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; и &lt;a href=&quot;qml-qtquick-item#implicitHeight-prop&quot;&gt;implicitHeight&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a11f2000ac0edf67c2b20ae00acff6fb70863dbe" translate="yes" xml:space="preserve">
          <source>When deploying Qt applications built using Visual Studio 2005, or later, make sure that the manifest file that was created when the application was linked is handled correctly. This is handled automatically for projects that generate DLLs.</source>
          <target state="translated">При развертывании приложений Qt,собранных с помощью Visual Studio 2005 или более поздней версии,убедитесь,что файл манифеста,который был создан во время компоновки приложения,обрабатывается корректно.Это автоматически обрабатывается для проектов,которые генерируют DLL.</target>
        </trans-unit>
        <trans-unit id="e3f2fc2611c302aed3276f1510a9d174ba6db392" translate="yes" xml:space="preserve">
          <source>When deploying the app, the compression is typically handled on the server side. We recommend to compress the wasm binaries because this typically reduces the size of the binary by 50 %.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8ea9ac8ca6cf4cf6b3b5f4d012ccb4493d9e28" translate="yes" xml:space="preserve">
          <source>When developing applications that use D-Bus, it is sometimes useful to be able to see information about the messages that are sent and received across the bus by each application.</source>
          <target state="translated">При разработке приложений,использующих D-Bus,иногда полезно иметь возможность видеть информацию о сообщениях,которые отправляются и принимаются по шине каждым приложением.</target>
        </trans-unit>
        <trans-unit id="1a1c1be356204dfd455ba7ec0d01e973b146ec67" translate="yes" xml:space="preserve">
          <source>When disabled, a &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; node won't prevent the scene from being rendered. Toggling the enabled property is therefore a way to make a &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; active or inactive.</source>
          <target state="translated">Если этот параметр отключен, узел &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; не препятствует рендерингу сцены. Таким образом, переключение свойства enabled - это способ сделать &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; активным или неактивным.</target>
        </trans-unit>
        <trans-unit id="857e0ffe6bd1478d0544df44c2c658d65e015926" translate="yes" xml:space="preserve">
          <source>When disabled, a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; node won't prevent the scene from being rendered. Toggling the enabled property is therefore a way to make a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; active or inactive.</source>
          <target state="translated">Когда он отключен, узел &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw&lt;/a&gt; не препятствует рендерингу сцены. Таким образом, переключение свойства enabled - это способ сделать &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw&lt;/a&gt; активным или неактивным.</target>
        </trans-unit>
        <trans-unit id="a705f9e79dc5e0d4da74710091ca3394fb3c8ff6" translate="yes" xml:space="preserve">
          <source>When disabled, a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; node won't prevent picking from being performed. Toggling the enabled property is therefore a way to make a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; active or inactive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c03a7230ca07cd92ed1e2c5c76edb68253bdb253" translate="yes" xml:space="preserve">
          <source>When disabled, a NoDraw node won't prevent the scene from being rendered. Toggling the enabled property is therefore a way to make a NoDraw active or inactive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e738f36ac893e8cd586e71209d223aa4927c0d5" translate="yes" xml:space="preserve">
          <source>When disabled, a NoPicking node won't prevent picking from being performed. Toggling the enabled property is therefore a way to make a NoPicking active or inactive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="382c790d1bb1d0cf3f278efbd5066d3785f4f5c9" translate="yes" xml:space="preserve">
          <source>When disabled, the &lt;a href=&quot;qml-qtquick3d-sceneenvironment#depthTestEnabled-prop&quot;&gt;depthTestEnabled&lt;/a&gt; property can be used to simultaneously override depth testing and the order of rendering the objects. The operation of this property is not as obvious as many of the other properties in the system so this page offers some insight into when, where, and why this property can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc1e687319c686b682a905da3e6616cd03084a73" translate="yes" xml:space="preserve">
          <source>When disabled, the normals on the surface are interpolated making the edges look round. When enabled, the normals are kept the same on a triangle making the color of the triangle solid. This makes the data more readable from the model.</source>
          <target state="translated">При отключении,нормали на поверхности интерполируются,заставляя края выглядеть круглыми.Когда эта опция включена,нормали на поверхности треугольника остаются неизменными,делая цвет треугольника сплошным.Это делает данные более читаемыми из модели.</target>
        </trans-unit>
        <trans-unit id="24f4c0f2f49fed31d9cd8577cea9ab05b39be5e3" translate="yes" xml:space="preserve">
          <source>When displaying data from models in Qt item views, e.g., a &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, the individual items are drawn by a delegate. Also, when an item is edited, it provides an editor widget, which is placed on top of the item view while editing takes place. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; is the default delegate for all Qt item views, and is installed upon them when they are created.</source>
          <target state="translated">При отображении данных из моделей в представлениях элементов Qt, например в &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt; , отдельные элементы рисуются делегатом. Кроме того, когда элемент редактируется, он предоставляет виджет редактора, который помещается поверх представления элемента во время редактирования. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; - это делегат по умолчанию для всех представлений элементов Qt, который устанавливается на них при их создании.</target>
        </trans-unit>
        <trans-unit id="e6e55cf5ea63dc5db3857d7ad604b687dae8d030" translate="yes" xml:space="preserve">
          <source>When displaying data from models in Qt item views, e.g., a &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, the individual items are drawn by a delegate. Also, when an item is edited, it provides an editor widget, which is placed on top of the item view while editing takes place. QStyledItemDelegate is the default delegate for all Qt item views, and is installed upon them when they are created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0352c49318cb9d0b30ba555050217480183cb03e" translate="yes" xml:space="preserve">
          <source>When displaying items from a custom model in a standard view, it is often sufficient to simply ensure that the model returns appropriate data for each of the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;roles&lt;/a&gt; that determine the appearance of items in views. The default delegate used by Qt's standard views uses this role information to display items in most of the common forms expected by users. However, it is sometimes necessary to have even more control over the appearance of items than the default delegate can provide.</source>
          <target state="translated">При отображении элементов из настраиваемой модели в стандартном представлении часто достаточно просто убедиться, что модель возвращает соответствующие данные для каждой из &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;ролей,&lt;/a&gt; которые определяют внешний вид элементов в представлениях. Делегат по умолчанию, используемый стандартными представлениями Qt, использует эту информацию о роли для отображения элементов в большинстве общих форм, ожидаемых пользователями. Однако иногда необходимо иметь даже больший контроль над внешним видом элементов, чем может предоставить делегат по умолчанию.</target>
        </trans-unit>
        <trans-unit id="159720c88af83f5ac94a174365550a72f0765067" translate="yes" xml:space="preserve">
          <source>When documenting a QML type in a</source>
          <target state="translated">При документировании QML типа</target>
        </trans-unit>
        <trans-unit id="b7e55292b4abae3e9e4e7263b6533ed85abbb41e" translate="yes" xml:space="preserve">
          <source>When documenting a QML type in the</source>
          <target state="translated">При документировании QML типа</target>
        </trans-unit>
        <trans-unit id="fd4be1f4d3d4fe684047540a2b498b3e14a564e5" translate="yes" xml:space="preserve">
          <source>When doing replacement the area of the preedit string is ignored, thus a replacement starting at -1 with a length of 2 will remove the last character before the preedit string and the first character afterwards, and insert the commit string directly before the preedit string.</source>
          <target state="translated">При замене игнорируется область предисловой строки,поэтому замена,начинающаяся с -1 длиной 2,удалит последний символ перед предисловой строкой и первый символ после,и вставит коммит-строку непосредственно перед предисловой строкой.</target>
        </trans-unit>
        <trans-unit id="7b591bbff5ab07d40d7612a73ab5fcdc537e41fa" translate="yes" xml:space="preserve">
          <source>When doubleclicking an item, the item will first receive a mouse press event, followed by a release event (i.e., a click), then a doubleclick event, and finally a release event.</source>
          <target state="translated">При двойном щелчке элемент сначала получает событие нажатия мыши,затем событие освобождения (т.е.щелчок),затем событие двойного щелчка,и,наконец,событие освобождения.</target>
        </trans-unit>
        <trans-unit id="a02484f5ce286a79ae6a871b9106f5799cb1d5dc" translate="yes" xml:space="preserve">
          <source>When dragging the titlebar of a dock, all the tabs that are tabbed with it are going to be dragged. Implies AllowTabbedDocks. Does not work well if some QDockWidgets have restrictions in which area they are allowed. (This enum value was added in Qt 5.6.)</source>
          <target state="translated">При перетаскивании панели заголовков причала будут перетаскиваться все вкладки,которые с ней соединены.Вводит AllowTabbedDocks.Не работает хорошо,если некоторые QDockWidgets имеют ограничения на то,в какой области они разрешены.(Это значение перечисления было добавлено в Qt 5.6).</target>
        </trans-unit>
        <trans-unit id="19649a7c3fc63002d50d3cb1460af355d223d55e" translate="yes" xml:space="preserve">
          <source>When drawStaticText() is called, the layout of the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; will be recalculated if any part of the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; object has changed since the last time it was drawn. It will also be recalculated if the painter's font is not the same as when the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; was last drawn, or, on any other paint engine than the OpenGL2 engine, if the painter's matrix has been altered since the static text was last drawn.</source>
          <target state="translated">Когда вызывается drawStaticText (), макет &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; будет пересчитан, если какая-либо часть объекта &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; изменилась с момента последнего рисования. Он также будет пересчитан, если шрифт рисовальщика не такой, как при последнем рисовании &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; , или, в любом другом механизме рисования, кроме механизма OpenGL2, если матрица рисовальщика была изменена с момента последнего рисования статического текста.</target>
        </trans-unit>
        <trans-unit id="bb13eb36af2066f03f57ae49bb001cd98eedd84c" translate="yes" xml:space="preserve">
          <source>When drawing text, the font is specified using the &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; class. Qt will use the font with the specified attributes, or if no matching font exists, Qt will use the closest matching installed font. The attributes of the font that is actually used can be retrieved using the &lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt; class. In addition, the &lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt; class provides the font measurements, and the &lt;a href=&quot;qfontdatabase&quot;&gt;QFontDatabase&lt;/a&gt; class provides information about the fonts available in the underlying window system.</source>
          <target state="translated">При рисовании текста шрифт указывается с &lt;a href=&quot;qfont&quot;&gt;помощью&lt;/a&gt; класса QFont . Qt будет использовать шрифт с указанными атрибутами, или, если соответствующий шрифт не существует, Qt будет использовать наиболее подходящий установленный шрифт. Атрибуты шрифта, который фактически используется, можно получить с &lt;a href=&quot;qfontinfo&quot;&gt;помощью&lt;/a&gt; класса QFontInfo . Кроме того, класс &lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt; предоставляет измерения шрифтов, а класс &lt;a href=&quot;qfontdatabase&quot;&gt;QFontDatabase&lt;/a&gt; предоставляет информацию о шрифтах, доступных в базовой оконной системе.</target>
        </trans-unit>
        <trans-unit id="2b8fa7bd4261a029b6f3fdf343d1e4a3de0c8942" translate="yes" xml:space="preserve">
          <source>When drawing with &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device.</source>
          <target state="translated">При рисовании с помощью &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; мы указываем точки, используя логические координаты, которые затем преобразуются в физические координаты устройства рисования.</target>
        </trans-unit>
        <trans-unit id="410e5ecacd6f13933f5b02a517c03bf075b15730" translate="yes" xml:space="preserve">
          <source>When drawing with &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device. The mapping of the logical coordinates to the physical coordinates are handled by &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s &lt;a href=&quot;qpainter#combinedTransform&quot;&gt;combinedTransform&lt;/a&gt;(), a combination of &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() and &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() and &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;(). The &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() represents the physical coordinates specifying an arbitrary rectangle, the &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() describes the same rectangle in logical coordinates, and the &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;() is identical with the transformation matrix.</source>
          <target state="translated">При рисовании с помощью &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; мы указываем точки, используя логические координаты, которые затем преобразуются в физические координаты устройства рисования. Отображение логических координат в физические координаты обрабатываются &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; &amp;laquo;ы &lt;a href=&quot;qpainter#combinedTransform&quot;&gt;combinedTransform&lt;/a&gt; (), сочетание &lt;a href=&quot;qpainter#viewport&quot;&gt;окна просмотра&lt;/a&gt; () и &lt;a href=&quot;qpainter#window&quot;&gt;окна&lt;/a&gt; () и &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt; (). &lt;a href=&quot;qpainter#viewport&quot;&gt;Окно просмотра&lt;/a&gt; () представляет собой физические координаты , определяющие произвольный прямоугольник, то &lt;a href=&quot;qpainter#window&quot;&gt;окно&lt;/a&gt; () описывает тот же прямоугольник в логических координатах, а &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt; () совпадает с матрицей трансформации.</target>
        </trans-unit>
        <trans-unit id="fa068ff4a5704af2221f41b1b4da90e1a41df12c" translate="yes" xml:space="preserve">
          <source>When drawing with QPainter, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device. The mapping of the logical coordinates to the physical coordinates are handled by QPainter's &lt;a href=&quot;qpainter#combinedTransform&quot;&gt;combinedTransform&lt;/a&gt;(), a combination of &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() and &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() and &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;(). The &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() represents the physical coordinates specifying an arbitrary rectangle, the &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() describes the same rectangle in logical coordinates, and the &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;() is identical with the transformation matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ed330ed405cc570c36b8d34b32b0e9f282124b" translate="yes" xml:space="preserve">
          <source>When drawing, the pixel rendering is controlled by the &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter::Antialiasing&lt;/a&gt; render hint.</source>
          <target state="translated">При рисовании рендеринг пикселей управляется подсказкой рендеринга &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter :: Antialiasing&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d15b0d71322e99bde4953dbe90c85c3ef7baf9a0" translate="yes" xml:space="preserve">
          <source>When drawing, the pixel rendering is controlled by the &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter::Antialiasing&lt;/a&gt; render hint. The &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter::RenderHint&lt;/a&gt; enum is used to specify flags to &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; that may or may not be respected by any given engine.</source>
          <target state="translated">При рисовании рендеринг пикселей управляется подсказкой рендеринга &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter :: Antialiasing&lt;/a&gt; . &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter :: RenderHint&lt;/a&gt; перечисление используются для задания флагов в &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; , которые могут или не могут быть уважаться любым данным двигателем.</target>
        </trans-unit>
        <trans-unit id="6ebdf8b96fea44b5a3aed78415b3fda3d62aa0c1" translate="yes" xml:space="preserve">
          <source>When driving animations, this function should be called once after drawing has completed. Calling this function multiple times will result in a single event being delivered to the window.</source>
          <target state="translated">При вождении анимации эта функция должна вызываться один раз после завершения рисования.При многократном вызове этой функции в окно будет доставлено одно событие.</target>
        </trans-unit>
        <trans-unit id="1ce5dba37bb8921ab742160f013368e5f3259059" translate="yes" xml:space="preserve">
          <source>When duplicate skipping is enabled, successive readings with the same or very similar values are omitted. This helps reducing the amount of processing done, as less sensor readings are made available. As a consequence, readings arrive at an irregular interval.</source>
          <target state="translated">При включенном дублировании пропуска последовательные показания с одинаковыми или очень похожими значениями опускаются.Это помогает сократить объем выполняемой обработки,так как считывание показаний датчиков становится доступным в меньшем объеме.Как следствие,показания поступают с нерегулярным интервалом.</target>
        </trans-unit>
        <trans-unit id="d5e3a8786c0102ae5523b4a9dad7cca51f61d1c8" translate="yes" xml:space="preserve">
          <source>When each primitive is large, this overhead is negligible, but in the case of a typical UI, there are many small items which add up to a considerable overhead.</source>
          <target state="translated">Когда каждый примитив большой,эти накладные расходы ничтожно малы,но в случае с типичным пользовательским интерфейсом,существует много мелких элементов,которые добавляют к значительным накладным расходам.</target>
        </trans-unit>
        <trans-unit id="cbc38d0da8ee345ba2fd00eef535419aae91f344" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; provides an editor widget, which is a widget that is placed on top of the view while editing takes place. Editors are created with a &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;; a default static instance provided by &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; is installed on all item delegates. You can set a custom factory using &lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt;() or set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory::setDefaultFactory&lt;/a&gt;(). It is the data stored in the item model with the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::EditRole&lt;/a&gt; that is edited.</source>
          <target state="translated">При редактировании данных в представлении элемента &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; предоставляет виджет редактора, который является виджетом, который помещается поверх представления во время редактирования. Редакторы создаются с помощью &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; ; статический экземпляр по умолчанию, предоставляемый &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; , установлен во всех делегатах элемента. Вы можете установить собственную фабрику с помощью &lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt; () или установить новую фабрику по умолчанию с помощью &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory :: setDefaultFactory&lt;/a&gt; (). Это данные, хранящиеся в модели элемента с редактируемой &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;ролью Qt :: EditRole&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e3121493bb1879d53220fddb4bd4e0247d179ffd" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, QItemDelegate provides an editor widget, which is a widget that is placed on top of the view while editing takes place. Editors are created with a &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;; a default static instance provided by &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; is installed on all item delegates. You can set a custom factory using &lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt;() or set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory::setDefaultFactory&lt;/a&gt;(). It is the data stored in the item model with the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::EditRole&lt;/a&gt; that is edited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6344a0186d030dc605de997efbebf65f1b9a99" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, editors are created and displayed by a delegate. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;, which is the delegate by default installed on Qt's item views, uses a &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; to create editors for it. A default unique instance provided by &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; is used by all item delegates. If you set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt;(), the new factory will be used by existing and new delegates.</source>
          <target state="translated">При редактировании данных в представлении элемента редакторы создаются и отображаются делегатом. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; , который является делегатом по умолчанию, установленным в представлениях элементов Qt, использует &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; для создания для него редакторов. Уникальный экземпляр по умолчанию, предоставляемый &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; , используется всеми делегатами элементов. Если вы установите новую фабрику по умолчанию с помощью &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt; (), новая фабрика будет использоваться существующими и новыми делегатами.</target>
        </trans-unit>
        <trans-unit id="4e2f4a385e37cf62cf1b97e80df94ad25fd55a99" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, editors are created and displayed by a delegate. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;, which is the delegate by default installed on Qt's item views, uses a QItemEditorFactory to create editors for it. A default unique instance provided by QItemEditorFactory is used by all item delegates. If you set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt;(), the new factory will be used by existing and new delegates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e7a6ec88186d061ca22e9701050d741f30a191" translate="yes" xml:space="preserve">
          <source>When editing is finished, either because the line edit lost focus or Return/Enter is pressed the &lt;a href=&quot;qlineedit#editingFinished&quot;&gt;editingFinished&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">Когда редактирование завершено, либо из-за потери фокуса редактирования строки, либо из-за нажатия клавиши Return / Enter &lt;a href=&quot;qlineedit#editingFinished&quot;&gt;выдается&lt;/a&gt; сигнал editFinished ().</target>
        </trans-unit>
        <trans-unit id="d66bfe606de9465976bab385d92db6b5ec57c788" translate="yes" xml:space="preserve">
          <source>When editing of an item starts, this function is called with the</source>
          <target state="translated">Когда начинается редактирование элемента,эта функция вызывается с помощью функции</target>
        </trans-unit>
        <trans-unit id="b9a4a24a7b2e2cf96998146b51d4cf55a3e5c82a" translate="yes" xml:space="preserve">
          <source>When enabled and the label shows a pixmap, it will scale the pixmap to fill the available space.</source>
          <target state="translated">Когда эта функция включена и на этикетке отображается растровое изображение,оно будет масштабироваться,чтобы заполнить доступное пространство.</target>
        </trans-unit>
        <trans-unit id="809e3c2e92b5437339d00438d8ac5682f3c1094a" translate="yes" xml:space="preserve">
          <source>When enabled, making a Shape visible will not wait for the content to become available. Instead, the gui/main thread is not blocked and the results of the path rendering are shown only when all the asynchronous work has been finished.</source>
          <target state="translated">Когда эта опция включена,то появление видимой формы не будет ждать,пока содержимое станет доступным.Вместо этого,поток gui/main не блокируется,а результаты рендеринга путей показываются только тогда,когда вся асинхронная работа завершена.</target>
        </trans-unit>
        <trans-unit id="fee807f59e511b5dcbfdf0c512929f1021ab0586" translate="yes" xml:space="preserve">
          <source>When enabled, the renderer performs a Z-prepass for opaque objects, meaning it renders them with a simple shader and color write disabled in order to get the depth buffer pre-filled before issuing draw calls for the main rendering passes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef9dffa012fb5631fc857fa121adc562514620b" translate="yes" xml:space="preserve">
          <source>When enabled, this attribute disables the delivery of mouse events to the widget and its children. Mouse events are delivered to other widgets as if the widget and its children were not present in the widget hierarchy; mouse clicks and other events effectively &quot;pass through&quot; them. This attribute is disabled by default.</source>
          <target state="translated">При включении данный атрибут отключает доставку событий мыши к виджету и его дочерним устройствам.События мыши доставляются к другим виджетам так,как если бы виджет и его дочерние элементы не присутствовали в иерархии виджетов;щелчки мышью и другие события эффективно &quot;пропускают&quot; их.По умолчанию данный атрибут отключен.</target>
        </trans-unit>
        <trans-unit id="482662a30996d40d4a1c18a3374e7b2c360e9d38" translate="yes" xml:space="preserve">
          <source>When entering &quot;What's This?&quot; mode, a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type Qt::EnterWhatsThisMode is sent to all toplevel widgets.</source>
          <target state="translated">При вводе &amp;laquo;Что это?&amp;raquo; mode, &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; типа Qt :: EnterWhatsThisMode отправляется всем виджетам верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="6190eb6bb23c0ba0b8cd55075c9df2ea7f1a0eef" translate="yes" xml:space="preserve">
          <source>When executed together with the source-side example, the output is identical to &lt;a href=&quot;#qtro-example1&quot;&gt;Example 1&lt;/a&gt;.</source>
          <target state="translated">При выполнении вместе с примером на стороне источника вывод идентичен &lt;a href=&quot;#qtro-example1&quot;&gt;примеру 1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6558b3205936d1c2767fe9741a81481ab905734" translate="yes" xml:space="preserve">
          <source>When executed, QDoc will exclude the listed directories from further consideration. Files in these directories will not be read by QDoc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a96d672de3f61af853bd3fb2b4ddb09401c17a" translate="yes" xml:space="preserve">
          <source>When executed, QDoc will exclude the listed directories from further consideration. Files in these directories will not be read by qdoc.</source>
          <target state="translated">При выполнении QDoc исключит перечисленные каталоги из дальнейшего рассмотрения.Файлы в этих каталогах не будут считываться Qdoc.</target>
        </trans-unit>
        <trans-unit id="f0b8e30c664f1e368519b1a60f634e4ae26e999b" translate="yes" xml:space="preserve">
          <source>When executed, QDoc will ignore the directories listed. &lt;b&gt;See also&lt;/b&gt;: &lt;a href=&quot;22-qdoc-configuration-generalvariables#excludefiles&quot;&gt;excludefiles&lt;/a&gt;.</source>
          <target state="translated">При выполнении QDoc игнорирует перечисленные каталоги. &lt;b&gt;См. Также&lt;/b&gt; : &lt;a href=&quot;22-qdoc-configuration-generalvariables#excludefiles&quot;&gt;excludefiles&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca04becdda83845f40b583b367041236f99a3f37" translate="yes" xml:space="preserve">
          <source>When executed, the first thing QDoc will do is to read through the headers specified in the &lt;a href=&quot;#headers&quot;&gt;&lt;code&gt;headers&lt;/code&gt;&lt;/a&gt; variable, and the ones located in the directories specified in the &lt;code&gt;headerdir&lt;/code&gt; variable (including all subdirectories), building an internal structure of the classes and their functions.</source>
          <target state="translated">При выполнении первое, что QDoc сделает, - это прочитать заголовки, указанные в переменной &lt;a href=&quot;#headers&quot;&gt; &lt;code&gt;headers&lt;/code&gt; &lt;/a&gt; , и те, которые находятся в каталогах, указанных в переменной &lt;code&gt;headerdir&lt;/code&gt; (включая все подкаталоги), создавая внутреннюю структуру классов и их функций.</target>
        </trans-unit>
        <trans-unit id="5cb7e1f93541ac06ba092ca034af95b10f030b3f" translate="yes" xml:space="preserve">
          <source>When executed, the first thing QDoc will do is to read through the headers specified in the &lt;a href=&quot;10-qdoc-commands-tablesandlists#header-command&quot;&gt;&lt;code&gt;header&lt;/code&gt;&lt;/a&gt; variable, and the ones located in the directories specified in the &lt;code&gt;headerdir&lt;/code&gt; variable (including all subdirectories), building an internal structure of the classes and their functions.</source>
          <target state="translated">При выполнении первое, что QDoc сделает, - это прочитать заголовки, указанные в переменной &lt;a href=&quot;10-qdoc-commands-tablesandlists#header-command&quot;&gt; &lt;code&gt;header&lt;/code&gt; &lt;/a&gt; , и те, которые расположены в каталогах, указанных в переменной &lt;code&gt;headerdir&lt;/code&gt; (включая все подкаталоги), создавая внутреннюю структуру классов и их функций.</target>
        </trans-unit>
        <trans-unit id="6f35fb24ec304ed2925435889439bd5ef8cff940" translate="yes" xml:space="preserve">
          <source>When executed, the first thing QDoc will do is to read through the headers specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headers&quot;&gt;&lt;code&gt;headers&lt;/code&gt;&lt;/a&gt; variable, and the ones located in the directories specified in the &lt;code&gt;headerdir&lt;/code&gt; variable (including all subdirectories), building an internal structure of the classes and their functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ffff96391333a52eee7a9ad80e057863c3ba11" translate="yes" xml:space="preserve">
          <source>When expanding is true &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; will expand the tabs to use the empty space.</source>
          <target state="translated">Если &lt;a href=&quot;qtabbar&quot;&gt;раскрытие&lt;/a&gt; истинно, QTabBar будет расширять вкладки, чтобы использовать пустое пространство.</target>
        </trans-unit>
        <trans-unit id="2620b86db1234798b63f39503859611b9649e059" translate="yes" xml:space="preserve">
          <source>When exporting 9-patch images in several DPI variants (&lt;code&gt;@2x&lt;/code&gt;, &lt;code&gt;@3x&lt;/code&gt;, etc.), the 9-patch lines will typically be scaled up along with the image. There are several ways to fix this, but perhaps the simplest approach is to use &lt;a href=&quot;https://www.imagemagick.org/script/mogrify.php&quot;&gt;ImageMagick's mogrify&lt;/a&gt; tool. The tool has a &lt;code&gt;-shave&lt;/code&gt; feature that can be used to crop the image to reduce the thickness of the 9-patch lines:</source>
          <target state="translated">При экспорте изображений с 9 фрагментами в нескольких вариантах DPI ( &lt;code&gt;@2x&lt;/code&gt; , &lt;code&gt;@3x&lt;/code&gt; и т. Д.) Линии с 9 фрагментами обычно масштабируются вместе с изображением. Есть несколько способов исправить это, но, возможно, самый простой подход - использовать инструмент &lt;a href=&quot;https://www.imagemagick.org/script/mogrify.php&quot;&gt;mogrify ImageMagick&lt;/a&gt; . Инструмент имеет функцию &lt;code&gt;-shave&lt;/code&gt; , которую можно использовать для обрезки изображения, чтобы уменьшить толщину линий из 9 фрагментов:</target>
        </trans-unit>
        <trans-unit id="70acf7a58788a901870142345c474b753e5c2cea" translate="yes" xml:space="preserve">
          <source>When extending &lt;code&gt;QtService&lt;/code&gt;, you need to declare other items for loading all the necessary libs required for Qt, mainly the same items as in &lt;code&gt;&amp;lt;activity&amp;gt;&lt;/code&gt; section for &lt;code&gt;QtActivity&lt;/code&gt;. Add the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5abd3482bf0f9993496037be30182385378e5e2" translate="yes" xml:space="preserve">
          <source>When extending &lt;code&gt;Service&lt;/code&gt;, just declare the service section as a normal Android service. Add the following inside the &lt;code&gt;&amp;lt;application&amp;gt;&lt;/code&gt; section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd92947bef2cbe270c8052641e8c3450b891b43e" translate="yes" xml:space="preserve">
          <source>When extending QML with C++ code, a C++ class can be registered with the QML type system to enable the class to be used as a data type within QML code. While the properties, methods and signals of any &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-derived class are accessible from QML, as discussed in &lt;a href=&quot;qtqml-cppintegration-exposecppattributes&quot;&gt;Exposing Attributes of C++ Types to QML&lt;/a&gt;, such a class cannot be used as a data type from QML until it is registered with the type system. Additionally registration can provide other features, such as allowing a class to be used as an instantiable &lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;QML object type&lt;/a&gt; from QML, or enabling a singleton instance of the class to be imported and used from QML.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="426d2b133ccf9d0aab48e582602ba3229910acac" translate="yes" xml:space="preserve">
          <source>When extending QML with C++ code, a C++ class can be registered with the QML type system to enable the class to be used as a data type within QML code. While the properties, methods and signals of any &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-derived class are accessible from QML, as discussed in &lt;a href=&quot;qtqml-cppintegration-exposecppattributes#&quot;&gt;Exposing Attributes of C++ Types to QML&lt;/a&gt;, such a class cannot be used as a data type from QML until it is registered with the type system. Additionally registration can provide other features, such as allowing a class to be used as an instantiable &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML object type&lt;/a&gt; from QML, or enabling a singleton instance of the class to be imported and used from QML.</source>
          <target state="translated">При расширении QML с помощью кода C ++ класс C ++ может быть зарегистрирован в системе типов QML, чтобы позволить использовать этот класс как тип данных в коде QML. Хотя свойства, методы и сигналы любого класса, производного от &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; , доступны из QML, как описано в разделе &amp;laquo;Предоставление &lt;a href=&quot;qtqml-cppintegration-exposecppattributes#&quot;&gt;атрибутов типов C ++ для QML&amp;raquo;&lt;/a&gt; , такой класс не может использоваться как тип данных из QML, пока он не будет зарегистрирован в системе типов. Кроме того, регистрация может предоставить другие функции, такие как разрешение использования класса в качестве экземпляра &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;типа объекта&lt;/a&gt; QML из QML или разрешение импорта и использования одноэлементного экземпляра класса из QML.</target>
        </trans-unit>
        <trans-unit id="9db3502d0d4498df3a64124b7eb7242bd03e84ad" translate="yes" xml:space="preserve">
          <source>When generating DITA XML, qdoc outputs the nested</source>
          <target state="translated">При генерации DITA XML,qdoc выводит вложенный</target>
        </trans-unit>
        <trans-unit id="6359268011bd2e23ea07a88afa77e4d08fbb1147" translate="yes" xml:space="preserve">
          <source>When generating the reference documentation for a class, QDoc will create and link to a separate page documenting its obsolete functions. Usually an equivalent function is provided as an alternative.</source>
          <target state="translated">При генерации справочной документации для класса QDoc будет создавать и компоновать на отдельную страницу,документирующую его устаревшие функции.Обычно в качестве альтернативы предоставляется эквивалентная функция.</target>
        </trans-unit>
        <trans-unit id="71f447939a909dfa27ce949444c9508a3a7d93da" translate="yes" xml:space="preserve">
          <source>When getting started with developing on a given embedded device, it is often necessary to verify the behavior of the device and drivers, and that the connected displays are working as they should. One easy way is to use the hellowindow example. Launching it with &lt;code&gt;-platform eglfs --multiscreen --timeout&lt;/code&gt; arguments shows a rotating Qt logo on each connected screen for a few seconds.</source>
          <target state="translated">Приступая к разработке на конкретном встраиваемом устройстве, часто бывает необходимо проверить поведение устройства и драйверов, а также то, что подключенные дисплеи работают должным образом. Один из простых способов - использовать пример hellowindow. Запуск с &lt;code&gt;-platform eglfs --multiscreen --timeout&lt;/code&gt; arguments показывает вращающийся логотип Qt на каждом подключенном экране в течение нескольких секунд.</target>
        </trans-unit>
        <trans-unit id="b8ddc3778afe40355df31ec30ad7ce29680583ba" translate="yes" xml:space="preserve">
          <source>When handling the signal with &lt;code&gt;onLoadingChanged&lt;/code&gt;, various read-only parameters are available on the &lt;a href=&quot;qml-qtwebengine-webengineloadrequest&quot;&gt;WebEngineLoadRequest&lt;/a&gt; specified by</source>
          <target state="translated">При обработке сигнала с помощью &lt;code&gt;onLoadingChanged&lt;/code&gt; различные параметры только для чтения доступны в &lt;a href=&quot;qml-qtwebengine-webengineloadrequest&quot;&gt;WebEngineLoadRequest,&lt;/a&gt; заданном параметром</target>
        </trans-unit>
        <trans-unit id="dd3376f42ea41d22705767c518b03411a09688ef" translate="yes" xml:space="preserve">
          <source>When handling this signal, changing the &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;accepted&lt;/a&gt; property of the</source>
          <target state="translated">При обработке этого сигнала изменение &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;принятого&lt;/a&gt; свойства</target>
        </trans-unit>
        <trans-unit id="6609fd77e98998e1210abc85df3c2fabea25a8b3" translate="yes" xml:space="preserve">
          <source>When handling this signal, if the &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;accepted&lt;/a&gt; property of the</source>
          <target state="translated">При обработке этого сигнала, если &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;принятое&lt;/a&gt; свойство</target>
        </trans-unit>
        <trans-unit id="b478004d57f010bec2ae3794bb546849c254693f" translate="yes" xml:space="preserve">
          <source>When handling this signal, use the &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;accepted&lt;/a&gt; property of the</source>
          <target state="translated">При обработке этого сигнала используйте свойство &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;accept&lt;/a&gt; объекта</target>
        </trans-unit>
        <trans-unit id="6295b7b616f0d9112be806cf906b2998b3813947" translate="yes" xml:space="preserve">
          <source>When having multiple displays connected, the level of support for targeting one or more of these from one single Qt application varies between the platform plugins and often depends on the device and its graphics stack.</source>
          <target state="translated">При подключении нескольких дисплеев,уровень поддержки таргетинга одного или нескольких из них из одного приложения Qt варьируется между подключаемыми модулями платформы и часто зависит от устройства и его графического стека.</target>
        </trans-unit>
        <trans-unit id="33cb76c34e5dfbfadb36579df2b883f159a00960" translate="yes" xml:space="preserve">
          <source>When implemented, this function is responsible for checking the paint engine's current</source>
          <target state="translated">Когда эта функция реализована,она отвечает за проверку текущего состояния двигателя краски</target>
        </trans-unit>
        <trans-unit id="cb84a9cfef6f8292ec44602b7462e414abc9870a" translate="yes" xml:space="preserve">
          <source>When implementing a custom extension class, you must use Q_DECLARE_EXTENSION_INTERFACE() to enable usage of the &lt;a href=&quot;qextensionmanager#qt_extension&quot;&gt;qt_extension&lt;/a&gt;() function. The macro is normally located right after the class definition for</source>
          <target state="translated">При реализации собственного класса расширения вы должны использовать Q_DECLARE_EXTENSION_INTERFACE (), чтобы разрешить использование функции &lt;a href=&quot;qextensionmanager#qt_extension&quot;&gt;qt_extension&lt;/a&gt; (). Макрос обычно располагается сразу после определения класса для</target>
        </trans-unit>
        <trans-unit id="84772bea2f59837a3da39c7af78975341f21eb2b" translate="yes" xml:space="preserve">
          <source>When implementing a custom style, you cannot assume that the widget is a &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; just because the enum value is called &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinUp&lt;/a&gt; or &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinDown&lt;/a&gt;.</source>
          <target state="translated">При реализации пользовательского стиля вы не можете предполагать, что виджет является &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; только потому, что значение перечисления называется &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinUp&lt;/a&gt; или &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinDown&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="869ecc6a6e96e1eee7be87f15ad29e53d15bface" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, a pointer to</source>
          <target state="translated">При реализации пользовательского плагина виджета,указатель на</target>
        </trans-unit>
        <trans-unit id="b5e58b90ddc89647665b1bcd29b18d24dcef1559" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, you build it as a separate library. If you want to include several custom widget plugins in the same library, you must in addition subclass &lt;a href=&quot;qdesignercustomwidgetcollectioninterface&quot;&gt;QDesignerCustomWidgetCollectionInterface&lt;/a&gt;.</source>
          <target state="translated">При реализации подключаемого модуля пользовательского виджета вы создаете его как отдельную библиотеку. Если вы хотите включить несколько настраиваемых подключаемых &lt;a href=&quot;qdesignercustomwidgetcollectioninterface&quot;&gt;модулей&lt;/a&gt; виджетов в одну и ту же библиотеку, вы должны дополнительно создать подкласс QDesignerCustomWidgetCollectionInterface .</target>
        </trans-unit>
        <trans-unit id="5ea9264234b2724850203d32239a91745a3b4bcd" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, you build it as a separate library. If you want to include several custom widget plugins in the same library, you must in addition subclass QDesignerCustomWidgetCollectionInterface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c647a12112d8ed46e7c8ca84107c20d588614b0" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, you must subclass the &lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt; to expose your plugin to</source>
          <target state="translated">При реализации настраиваемого подключаемого модуля виджета вы должны &lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;создать&lt;/a&gt; подкласс QDesignerCustomWidgetInterface, чтобы предоставить доступ к вашему подключаемому модулю</target>
        </trans-unit>
        <trans-unit id="91021ae6ff5dfe6164732e25da258734b737eb88" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget you must subclass &lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt; to expose your widget to</source>
          <target state="translated">При реализации настраиваемого виджета вы должны &lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;создать&lt;/a&gt; подкласс QDesignerCustomWidgetInterface, чтобы предоставить виджету доступ к</target>
        </trans-unit>
        <trans-unit id="98de48237e2610b3ed96ebfc3b4b3e1647ecb00b" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget you must subclass QDesignerCustomWidgetInterface to expose your widget to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595ba0ecf978bd65b6513cd7266fa82465645c81" translate="yes" xml:space="preserve">
          <source>When implementing a model it is important to remember that &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; does not store any data itself, it merely presents an interface that the views use to access the data. For a minimal read-only model it is only necessary to implement a few functions as there are default implementations for most of the interface. The class declaration is as follows:</source>
          <target state="translated">При реализации модели важно помнить, что &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; не хранит никаких данных, он просто представляет интерфейс, который представления используют для доступа к данным. Для минимальной модели только для чтения необходимо реализовать лишь несколько функций, поскольку для большей части интерфейса существуют реализации по умолчанию. Объявление класса выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="445cd07d2a0506cd16ff907563ea7c0e381a4ac2" translate="yes" xml:space="preserve">
          <source>When implementing a new widget, it is almost always useful to reimplement &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;sizeHint&lt;/a&gt;() to provide a reasonable default size for the widget and to set the correct size policy with &lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;setSizePolicy&lt;/a&gt;().</source>
          <target state="translated">При реализации нового виджета почти всегда полезно повторно реализовать &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;sizeHint&lt;/a&gt; (), чтобы обеспечить разумный размер по умолчанию для виджета и установить правильную политику размера с помощью &lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;setSizePolicy&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="4c9d446fde723c06b31550398f72ba270ba5a90c" translate="yes" xml:space="preserve">
          <source>When implementing a subclass of this interface, there are only a handful of functions to implement, broken down into two classes:</source>
          <target state="translated">При реализации подкласса данного интерфейса существует лишь несколько функций,разбитых на два класса:</target>
        </trans-unit>
        <trans-unit id="d65384984581a6d6fbb1f4f4bccbb7923f82cdc1" translate="yes" xml:space="preserve">
          <source>When implementing a subclass, you must call this function</source>
          <target state="translated">При реализации подкласса необходимо вызывать эту функцию</target>
        </trans-unit>
        <trans-unit id="7c18f33bf2a59c6087f18cc24038056a308ad7f2" translate="yes" xml:space="preserve">
          <source>When implementing an accessibility interface for widgets, one would as a rule inherit &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;, which is a convenience class for widgets. Another available convenience class, which is inherited by &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;, is the &lt;a href=&quot;qaccessibleobject&quot;&gt;QAccessibleObject&lt;/a&gt;, which implements part of the interface for QObjects.</source>
          <target state="translated">При реализации интерфейса специальных возможностей для виджетов, как правило, следует унаследовать &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt; , который является вспомогательным классом для виджетов. Другой доступный &lt;a href=&quot;qaccessiblewidget&quot;&gt;вспомогательный&lt;/a&gt; класс, наследуемый QAccessibleWidget , - это &lt;a href=&quot;qaccessibleobject&quot;&gt;QAccessibleObject&lt;/a&gt; , который реализует часть интерфейса для QObjects.</target>
        </trans-unit>
        <trans-unit id="4e43675b73f85281cf7ffd4c9feb92576f97c666" translate="yes" xml:space="preserve">
          <source>When implementing an item model (that is, a concrete &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass) one must abide to a very strict set of rules that ensure consistency for users of the model (views, proxy models, and so on).</source>
          <target state="translated">При реализации модели элемента (то есть конкретного подкласса &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; ) необходимо соблюдать очень строгий набор правил, обеспечивающих согласованность для пользователей модели (представления, прокси-модели и т. Д.).</target>
        </trans-unit>
        <trans-unit id="71c25ae80d1eb821bd312d0369953f3099005788" translate="yes" xml:space="preserve">
          <source>When implementing drag and drop support in a custom model, if you will return data in formats other than the default internal MIME type, reimplement this function to return your list of MIME types.</source>
          <target state="translated">При реализации поддержки перетаскивания в пользовательской модели,если вы будете возвращать данные в форматах,отличных от внутреннего MIME-типа по умолчанию,переопределите эту функцию,чтобы вернуть список MIME-типов.</target>
        </trans-unit>
        <trans-unit id="3e1de2caa20c3401ccd297583ca14adb9e36f89e" translate="yes" xml:space="preserve">
          <source>When implementing drag and drop support in a custom model, it is possible to export items of data in specialized formats by reimplementing the following function:</source>
          <target state="translated">При реализации поддержки перетаскивания в пользовательской модели можно экспортировать элементы данных в специализированные форматы,переопределив следующую функцию:</target>
        </trans-unit>
        <trans-unit id="891ebe7dedc591934a24e2e5c92f98ba49623d2e" translate="yes" xml:space="preserve">
          <source>When implementing styles, it is necessary to look through the code of the widgets and code of the base class and its ancestors. This is because the widgets use the style differently, because the implementation in the different styles' virtual functions can affect the state of the drawing (e.g., by altering the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; state without restoring it and drawing some elements without using the appropriate pixel metrics and sub elements).</source>
          <target state="translated">При реализации стилей необходимо просматривать код виджетов и код базового класса и его предков. Это связано с тем, что виджеты используют стиль по-разному, поскольку реализация виртуальных функций разных стилей может влиять на состояние рисования (например, изменяя состояние &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; без его восстановления и отрисовывая некоторые элементы без использования соответствующих пиксельных метрик и вспомогательных элементов). элементы).</target>
        </trans-unit>
        <trans-unit id="1c4d91075815fdbbae33aba2b667fd4633c4c3da" translate="yes" xml:space="preserve">
          <source>When implementing the property write function, use &lt;a href=&quot;qaxbindable#requestPropertyChange&quot;&gt;requestPropertyChange&lt;/a&gt;() to get permission from the ActiveX client application to change this property. When the property changes, call &lt;a href=&quot;qaxbindable#propertyChanged&quot;&gt;propertyChanged&lt;/a&gt;() to notify the ActiveX client application about the change. If a fatal error occurs in the control, use the static &lt;a href=&quot;qaxbindable#reportError&quot;&gt;reportError&lt;/a&gt;() function to notify the client.</source>
          <target state="translated">При реализации функции записи свойства используйте &lt;a href=&quot;qaxbindable#requestPropertyChange&quot;&gt;requestPropertyChange&lt;/a&gt; (), чтобы получить разрешение от клиентского приложения ActiveX на изменение этого свойства. Когда свойство изменяется, вызовите &lt;a href=&quot;qaxbindable#propertyChanged&quot;&gt;propertyChanged&lt;/a&gt; (), чтобы уведомить клиентское приложение ActiveX об изменении. Если в элементе управления происходит фатальная ошибка, используйте статическую &lt;a href=&quot;qaxbindable#reportError&quot;&gt;функцию reportError&lt;/a&gt; (), чтобы уведомить клиента.</target>
        </trans-unit>
        <trans-unit id="5c75a646668a787fcace5c55f81aa7bf0b70d1c6" translate="yes" xml:space="preserve">
          <source>When implementing the property write functions, use the &lt;a href=&quot;qaxbindable&quot;&gt;QAxBindable&lt;/a&gt; class's requestPropertyChange() and propertyChanged() functions to allow ActiveX clients to bind to the control properties.</source>
          <target state="translated">При реализации функций записи свойств используйте функции requestPropertyChange () и propertyChanged () класса &lt;a href=&quot;qaxbindable&quot;&gt;QAxBindable,&lt;/a&gt; чтобы позволить клиентам ActiveX выполнять привязку к свойствам элемента управления.</target>
        </trans-unit>
        <trans-unit id="7b41031e55866a68b8184e142ce7198e2e1fe7ec" translate="yes" xml:space="preserve">
          <source>When implementing this function in subclasses of this class, you must construct and return new editor widgets with the parent widget specified.</source>
          <target state="translated">При реализации данной функции в подклассах данного класса необходимо построить и вернуть новые виджеты редактора с указанным родительским виджетами.</target>
        </trans-unit>
        <trans-unit id="1591d2c3ab41219fe3e148cfbb0593be15c3c678" translate="yes" xml:space="preserve">
          <source>When implementing this function in subclasses, you must ensure that the editor widget's property specified by this function can accept the type the creator is registered for. For example, a creator which constructs &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; widgets to edit boolean values would return the &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;checkable&lt;/a&gt; property name from this function, and must be registered in the item editor factory for the QVariant::Bool type.</source>
          <target state="translated">При реализации этой функции в подклассах необходимо убедиться, что свойство виджета редактора, заданное этой функцией, может принимать тип, для которого зарегистрирован создатель. Например, создатель, который &lt;a href=&quot;qcheckbox&quot;&gt;создает&lt;/a&gt; виджеты QCheckBox для редактирования логических значений, должен вернуть имя &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;проверяемого&lt;/a&gt; свойства из этой функции и должен быть зарегистрирован в фабрике редактора элементов для типа QVariant :: Bool.</target>
        </trans-unit>
        <trans-unit id="8ce39d7538e9c5292578832459d332de3effbff1" translate="yes" xml:space="preserve">
          <source>When implementing this interface you will almost certainly also want to implement &lt;a href=&quot;qaccessibletextinterface&quot;&gt;QAccessibleTextInterface&lt;/a&gt;.</source>
          <target state="translated">При реализации этого интерфейса вы почти наверняка захотите реализовать &lt;a href=&quot;qaccessibletextinterface&quot;&gt;QAccessibleTextInterface&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6268d96d04a4d653a0acc9732f0ac32216ce55c6" translate="yes" xml:space="preserve">
          <source>When implementing you own custom graphics transform, you must call this function every time you change a parameter, to let &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; know that its transformation needs to be updated.</source>
          <target state="translated">При реализации собственного преобразования графики вы должны вызывать эту функцию каждый раз при изменении параметра, чтобы &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; знал, что его преобразование необходимо обновить.</target>
        </trans-unit>
        <trans-unit id="e0faa4d1d0c8b9ed5d373ba76a73de237e335d71" translate="yes" xml:space="preserve">
          <source>When implementing your own implicitly shared classes, use the &lt;a href=&quot;qshareddata&quot;&gt;QSharedData&lt;/a&gt; and &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; classes.</source>
          <target state="translated">При реализации ваших собственных неявно разделяемых классов используйте классы &lt;a href=&quot;qshareddata&quot;&gt;QSharedData&lt;/a&gt; и &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed089988e57c5a0f9eb64a54af80f4e4cc7da5be" translate="yes" xml:space="preserve">
          <source>When implementing your own itemview setSelection should call &lt;a href=&quot;qabstractitemview#selectionModel&quot;&gt;selectionModel&lt;/a&gt;()-&amp;gt;select(selection, flags) where selection is either an empty &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; or a &lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt; that contains all items that are contained in</source>
          <target state="translated">При реализации вашего собственного представления элементов setSelection должен вызывать &lt;a href=&quot;qabstractitemview#selectionModel&quot;&gt;selectionModel&lt;/a&gt; () -&amp;gt; select (selection, flags), где selection является либо пустым &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex,&lt;/a&gt; либо &lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt; , содержащим все элементы, содержащиеся в</target>
        </trans-unit>
        <trans-unit id="90d1ebe5eabb55f03ec9c6da6079f40a2ff77a3d" translate="yes" xml:space="preserve">
          <source>When implementing your own style and customizing controls, there are some points to keep in mind to ensure that your application is as performant as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b13759dc0478b7385db4120f936b29bbec97142e" translate="yes" xml:space="preserve">
          <source>When importing a &lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;QML object type&lt;/a&gt; with a property alias in the root object, however, the property appear as a regular Qt property and consequently can be used in alias references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2c6cac0080194cff24d54acaddace27ee77592" translate="yes" xml:space="preserve">
          <source>When importing a &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML object type&lt;/a&gt; with a property alias in the root object, however, the property appear as a regular Qt property and consequently can be used in alias references.</source>
          <target state="translated">Однако при импорте &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;типа объекта QML&lt;/a&gt; с псевдонимом свойства в корневом объекте свойство отображается как обычное свойство Qt и, следовательно, может использоваться в ссылках на псевдонимы.</target>
        </trans-unit>
        <trans-unit id="63972382ca72bfae9a1039f20443d3527d3f328d" translate="yes" xml:space="preserve">
          <source>When in Running state, &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; also emits the &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;() signal when the frame changes.</source>
          <target state="translated">В состоянии &amp;laquo;Выполнение&amp;raquo; &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; также испускает сигнал &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt; () при изменении кадра.</target>
        </trans-unit>
        <trans-unit id="ef3e888a5ecf29cb8462a72debc447a17e27543a" translate="yes" xml:space="preserve">
          <source>When in StrictMode, if a parsing error is found, &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;() will return &lt;code&gt;false&lt;/code&gt; and &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;() will return a message describing the error. If more than one error is detected, it is undefined which error gets reported.</source>
          <target state="translated">Если в StrictMode обнаружена ошибка синтаксического анализа, &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt; () вернет &lt;code&gt;false&lt;/code&gt; , а &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt; () вернет сообщение с описанием ошибки. Если обнаружено более одной ошибки, не определено, о какой ошибке будет сообщено.</target>
        </trans-unit>
        <trans-unit id="3456c56afa83ec7dbd61d985f62e50c29f6549e1" translate="yes" xml:space="preserve">
          <source>When in keyboard-interactive mode, you can use the arrow and page keys to either move or resize the window. This property controls the arrow keys. The common way to enter keyboard interactive mode is to enter the subwindow menu, and select either &quot;resize&quot; or &quot;move&quot;.</source>
          <target state="translated">В интерактивном режиме с клавиатурой вы можете использовать клавиши со стрелками и страницы для перемещения или изменения размера окна.Это свойство управляет клавишами со стрелками.Обычный способ входа в интерактивный режим клавиатуры-это войти в подокно и выбрать либо &quot;изменить размер&quot;,либо &quot;переместить&quot;.</target>
        </trans-unit>
        <trans-unit id="3fb322ebc9c9cd2d657c0fb9d224a6635a538d7d" translate="yes" xml:space="preserve">
          <source>When in keyboard-interactive mode, you can use the arrow and page keys to either move or resize the window. This property controls the page keys. The common way to enter keyboard interactive mode is to enter the subwindow menu, and select either &quot;resize&quot; or &quot;move&quot;.</source>
          <target state="translated">В интерактивном режиме с клавиатурой вы можете использовать клавиши со стрелками и страницы для перемещения или изменения размера окна.Это свойство управляет ключами страниц.Обычный способ входа в интерактивный режим клавиатуры-это войти в подокно и выбрать либо &quot;изменить размер&quot;,либо &quot;переместить&quot;.</target>
        </trans-unit>
        <trans-unit id="2c08753db2a8aa137364ee7093529568335fe121" translate="yes" xml:space="preserve">
          <source>When inheriting &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt;, you need to do the following:</source>
          <target state="translated">При наследовании &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; вам необходимо сделать следующее:</target>
        </trans-unit>
        <trans-unit id="9110d9a8dc385178c6df16681bf45970bc611881" translate="yes" xml:space="preserve">
          <source>When inheriting QAbstractScrollArea, you need to do the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef5ec1307e1565c3ba533b6306e4c4fb6e84f432" translate="yes" xml:space="preserve">
          <source>When inserting action items you usually specify a receiver and a slot. The receiver will be notifed whenever the item is &lt;a href=&quot;qaction#triggered&quot;&gt;triggered()&lt;/a&gt;. In addition, &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; provides two signals, &lt;a href=&quot;qmenu#triggered&quot;&gt;triggered&lt;/a&gt;() and &lt;a href=&quot;qmenu#hovered&quot;&gt;hovered&lt;/a&gt;(), which signal the &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; that was triggered from the menu.</source>
          <target state="translated">При вставке элементов действий вы обычно указываете получателя и слот. Получатель будет уведомлен всякий раз, когда элемент будет &lt;a href=&quot;qaction#triggered&quot;&gt;запущен ()&lt;/a&gt; . Кроме того, &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; предоставляет два сигнала, &lt;a href=&quot;qmenu#triggered&quot;&gt;triggered&lt;/a&gt; () и &lt;a href=&quot;qmenu#hovered&quot;&gt;hovered&lt;/a&gt; (), которые сигнализируют о &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; , запущенном из меню.</target>
        </trans-unit>
        <trans-unit id="b0a12f123004137273217a41fe960ac1382b53f8" translate="yes" xml:space="preserve">
          <source>When inserting action items you usually specify a receiver and a slot. The receiver will be notifed whenever the item is &lt;a href=&quot;qaction#triggered&quot;&gt;triggered()&lt;/a&gt;. In addition, QMenu provides two signals, &lt;a href=&quot;qmenu#triggered&quot;&gt;triggered&lt;/a&gt;() and &lt;a href=&quot;qmenu#hovered&quot;&gt;hovered&lt;/a&gt;(), which signal the &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; that was triggered from the menu.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="864005fb46a1674119933552576b5eb471667e9c" translate="yes" xml:space="preserve">
          <source>When inserting multiple records, you only need to call &lt;a href=&quot;qsqlquery#prepare&quot;&gt;QSqlQuery::prepare&lt;/a&gt;() once. Then you call &lt;a href=&quot;qsqlquery#bindValue&quot;&gt;bindValue()&lt;/a&gt; or &lt;a href=&quot;qsqlquery#addBindValue&quot;&gt;addBindValue()&lt;/a&gt; followed by &lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec()&lt;/a&gt; as many times as necessary.</source>
          <target state="translated">При вставке нескольких записей вам нужно вызвать &lt;a href=&quot;qsqlquery#prepare&quot;&gt;QSqlQuery :: prepare&lt;/a&gt; () только один раз. Затем вы вызываете &lt;a href=&quot;qsqlquery#bindValue&quot;&gt;bindValue ()&lt;/a&gt; или &lt;a href=&quot;qsqlquery#addBindValue&quot;&gt;addBindValue (),&lt;/a&gt; а затем &lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec ()&lt;/a&gt; столько раз, сколько необходимо.</target>
        </trans-unit>
        <trans-unit id="f4a6a2c17602b8ef1614b658343d290c1bd56516" translate="yes" xml:space="preserve">
          <source>When inserting such a fragment into a &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; the current char format of the &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; used for insertion is used as format for the text.</source>
          <target state="translated">При вставке такого фрагмента в &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; текущий формат &lt;a href=&quot;qtextcursor&quot;&gt;символа QTextCursor,&lt;/a&gt; используемый для вставки, используется в качестве формата для текста.</target>
        </trans-unit>
        <trans-unit id="6ee49651f87fc18143f2662752cc1cf4e9cb8b10" translate="yes" xml:space="preserve">
          <source>When integrating existing classes and technology into QML, APIs will often need tweaking to fit better into the declarative environment. Although the best results are usually obtained by modifying the original classes directly, if this is either not possible or is complicated by some other concerns, extension objects allow limited extension possibilities without direct modifications.</source>
          <target state="translated">При интеграции существующих классов и технологий в QML,API часто нуждаются в доработке,чтобы лучше вписаться в декларативную среду.Хотя лучшие результаты обычно достигаются путем непосредственной модификации исходных классов,если это либо невозможно,либо затруднено некоторыми другими проблемами,объекты расширения допускают ограниченные возможности расширения без прямых модификаций.</target>
        </trans-unit>
        <trans-unit id="46cd534349e4b4409b3a901102a23c1cbd1d64c6" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;color&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">При интеграции с C ++ обратите внимание, что любое значение &lt;a href=&quot;qcolor&quot;&gt;QColor, &lt;/a&gt;&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;переданное в QML из C ++&lt;/a&gt; , автоматически преобразуется в значение &lt;code&gt;color&lt;/code&gt; , и наоборот.</target>
        </trans-unit>
        <trans-unit id="59e07d9cc2cac329614b7169422187bba763b0d8" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; or &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;date&lt;/code&gt; value, and vice-versa. Note, however, that converting a &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; will result in UTC's start of the day, which falls on a different date in some other time-zones. It is usually more robust to convert the &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; via a &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; explicitly, specifying local-time or a relevant time-zone and selecting a time of day (such as noon) that reliably exists (daylight-savings transitions skip an hour, near one end or the other of a day).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94f4f40b3918cac601587862fbf8acc3e95d325a" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; or &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;date&lt;/code&gt; value, and vice-versa. Note, however, that converting a &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; will result in UTC's start of the day, which falls on a different date in some other time-zones. It is usually more robust to convert the &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; via a &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; explicitly, specifying local-time or a relevant time-zone and selecting a time of day (such as noon) that reliably exists (daylight-savings transitions skip an hour, near one end or the other of a day).</source>
          <target state="translated">При интеграции с C ++, обратите внимание , что любая &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; или &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; значение &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;передается в QML из C ++&lt;/a&gt; автоматически преобразуется в &lt;code&gt;date&lt;/code&gt; значение, и наоборот. Обратите внимание, однако, что преобразование &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; приведет к началу дня в формате UTC, который выпадает на другую дату в некоторых других часовых поясах. Обычно более &lt;a href=&quot;qdate&quot;&gt;надежно&lt;/a&gt; преобразовать QDate через &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; явно, указав местное время или соответствующий часовой пояс и выбрав время суток (например, полдень), которое надежно существует (переходы на летнее время пропускают час, около одного конца или другой день).</target>
        </trans-unit>
        <trans-unit id="2a3e9ea44f85bb16e221814f180ac27358c1f643" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;font&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">При интеграции с C ++ обратите внимание, что любое значение &lt;a href=&quot;qfont&quot;&gt;QFont, &lt;/a&gt;&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;переданное в QML из C ++&lt;/a&gt; , автоматически преобразуется в значение &lt;code&gt;font&lt;/code&gt; , и наоборот.</target>
        </trans-unit>
        <trans-unit id="c80b7cd162c43b0104ef58b6d7d770bb2b3dc0c9" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;geocircle&lt;/code&gt; value, and vise-versa.</source>
          <target state="translated">При интеграции с C ++ обратите внимание, что любое значение &lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle,&lt;/a&gt; переданное в QML из C ++, автоматически преобразуется в значение &lt;code&gt;geocircle&lt;/code&gt; , и наоборот.</target>
        </trans-unit>
        <trans-unit id="f90dc519be0e60fb444dc1c5260f47cc6cd907ee" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;coordinate&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">При интеграции с C ++ обратите внимание, что любое значение &lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate,&lt;/a&gt; переданное в QML из C ++, автоматически конвертируется в значение &lt;code&gt;coordinate&lt;/code&gt; и наоборот.</target>
        </trans-unit>
        <trans-unit id="c5bbf6333d877f577a96dba2b55b5c884f293ae5" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeopath&quot;&gt;QGeoPath&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;geopath&lt;/code&gt; value, and vice versa.</source>
          <target state="translated">При интеграции с C ++ обратите внимание, что любое значение &lt;a href=&quot;qgeopath&quot;&gt;QGeoPath,&lt;/a&gt; переданное в QML из C ++, автоматически преобразуется в значение &lt;code&gt;geopath&lt;/code&gt; , и наоборот.</target>
        </trans-unit>
        <trans-unit id="fc4029c75e55b88c42d4329274584c8e9c0128eb" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeopolygon&quot;&gt;QGeoPolygon&lt;/a&gt; value passed into QML is automatically converted into a &lt;code&gt;geopolygon&lt;/code&gt;, and vice versa.</source>
          <target state="translated">При интеграции с C ++ обратите внимание, что любое значение &lt;a href=&quot;qgeopolygon&quot;&gt;QGeoPolygon,&lt;/a&gt; переданное в QML, автоматически преобразуется в &lt;code&gt;geopolygon&lt;/code&gt; , и наоборот.</target>
        </trans-unit>
        <trans-unit id="a7dba58612710895f3116ae91ec3e71bc80778eb" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeorectangle&quot;&gt;QGeoRectangle&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;georectangle&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">При интеграции с C ++ обратите внимание, что любое значение &lt;a href=&quot;qgeorectangle&quot;&gt;QGeoRectangle,&lt;/a&gt; переданное в QML из C ++, автоматически преобразуется в значение &lt;code&gt;georectangle&lt;/code&gt; , и наоборот.</target>
        </trans-unit>
        <trans-unit id="4d5c3d73097853ceb2db3f5a71a11d6fad5cb8d2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeoshape&quot;&gt;QGeoShape&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;geoshape&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">При интеграции с C ++ обратите внимание, что любое значение &lt;a href=&quot;qgeoshape&quot;&gt;QGeoShape,&lt;/a&gt; переданное в QML из C ++, автоматически преобразуется в значение &lt;code&gt;geoshape&lt;/code&gt; , и наоборот.</target>
        </trans-unit>
        <trans-unit id="babd158b5780227850bc5ed9c758d5d58d7cd1f2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; or &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;point&lt;/code&gt; value. When a &lt;code&gt;point&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f6b135e98805bdd8065da59a778cd9f4c5215e" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; or &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;point&lt;/code&gt; value. When a &lt;code&gt;point&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value.</source>
          <target state="translated">При интеграции с C ++, обратите внимание , что любая &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; или &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; значение &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;передается в QML из C ++&lt;/a&gt; автоматически преобразуется в &lt;code&gt;point&lt;/code&gt; значения. Когда значение &lt;code&gt;point&lt;/code&gt; передается в C ++, оно автоматически преобразуется в значение &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a84623eea3626c41bb0f62625b89382e6a0884d2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;list&lt;/code&gt; value, and vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4537d2f61ed5eb33aa48c28e4d1f2cbe5739fee6" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;list&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">При интеграции с C ++ обратите внимание, что любое значение &lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty, &lt;/a&gt;&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;переданное в QML из C ++&lt;/a&gt; , автоматически преобразуется в значение &lt;code&gt;list&lt;/code&gt; , и наоборот.</target>
        </trans-unit>
        <trans-unit id="892030f32ca7d95430d43e3adb51ab41646ac62c" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; or &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;rect&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;rect&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde76fc240f3c1a3b45734a6b9372df275b0771e" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; or &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;rect&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;rect&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value.</source>
          <target state="translated">При интеграции с C ++, обратите внимание , что любая &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; или &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; значение &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;передается в QML из C ++&lt;/a&gt; автоматически преобразуется в &lt;code&gt;rect&lt;/code&gt; значение, и наоборот. Когда значение &lt;code&gt;rect&lt;/code&gt; передается в C ++, оно автоматически преобразуется в значение &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7418f4bf29ec0eb129b2a465879400da12bc2de" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; or &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;size&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;size&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe91bec14c646d63c8cb49b132911ca4fb70cf2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; or &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;size&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;size&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value.</source>
          <target state="translated">При интеграции с C ++, обратите внимание , что любая &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; или &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; значение &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;передается в QML из C ++&lt;/a&gt; автоматически преобразуется в &lt;code&gt;size&lt;/code&gt; значение, и наоборот. Когда значение &lt;code&gt;size&lt;/code&gt; передается в C ++, оно автоматически преобразуется в значение &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ce59b6a0f0b4b392e20d60442b247d4ac83798d" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;string&lt;/code&gt; value, and vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd4e1a3e2c35dda93f104508cebf19c9ae03217" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;string&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">При интеграции с C ++ обратите внимание, что любое значение &lt;a href=&quot;qstring&quot;&gt;QString, &lt;/a&gt;&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;переданное в QML из C ++&lt;/a&gt; , автоматически преобразуется в &lt;code&gt;string&lt;/code&gt; значение, и наоборот.</target>
        </trans-unit>
        <trans-unit id="c9d28617421e54fcce89cbef003fdb53a193660b" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;url&lt;/code&gt; value, and vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5784d74b9c118ae7229636ff92faf312a5dfe71" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;url&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">При интеграции с C ++ обратите внимание, что любое значение &lt;a href=&quot;qurl&quot;&gt;QUrl, &lt;/a&gt;&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;переданное в QML из C ++&lt;/a&gt; , автоматически преобразуется в значение &lt;code&gt;url&lt;/code&gt; , и наоборот.</target>
        </trans-unit>
        <trans-unit id="ed02fd90e62a507cb5dc19431423e1b9374d396b" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;variant&lt;/code&gt; value, and vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4782c07688335b98c18e7337dd4cb33a506d5caa" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;variant&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">При интеграции с C ++ обратите внимание, что любое значение &lt;a href=&quot;qvariant&quot;&gt;QVariant, &lt;/a&gt;&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;переданное в QML из C ++&lt;/a&gt; , автоматически преобразуется в значение &lt;code&gt;variant&lt;/code&gt; , и наоборот.</target>
        </trans-unit>
        <trans-unit id="0f08c295ab9d317506d3417a8c5ed2ce92dffe9c" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;vector3d&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">При интеграции с C ++ обратите внимание, что любое значение &lt;a href=&quot;qvector3d&quot;&gt;QVector3D, &lt;/a&gt;&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;переданное в QML из C ++&lt;/a&gt; , автоматически преобразуется в значение &lt;code&gt;vector3d&lt;/code&gt; , и наоборот.</target>
        </trans-unit>
        <trans-unit id="91da3853e2ebc605267bec0ae228daafb92fc978" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;code&gt;enum&lt;/code&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into an &lt;code&gt;enumeration&lt;/code&gt; value, and vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="174229e59467abdea54b7e746d86e6764e7d6c9d" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;code&gt;enum&lt;/code&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into an &lt;code&gt;enumeration&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">При интеграции с C ++ обратите внимание, что любое значение &lt;code&gt;enum&lt;/code&gt; &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;переданное в QML из C ++&lt;/a&gt; , автоматически преобразуется в значение &lt;code&gt;enumeration&lt;/code&gt; , и наоборот.</target>
        </trans-unit>
        <trans-unit id="f7482e71bbdd52848ddeffbe95fcd0b8e2b5663e" translate="yes" xml:space="preserve">
          <source>When interacted with a mouse device, flicking is disabled and the scroll bars are interactive.</source>
          <target state="translated">При взаимодействии с устройством мыши щелчок отключается,а полосы прокрутки становятся интерактивными.</target>
        </trans-unit>
        <trans-unit id="8777d7fa43f475169d9e2b3537e4248eaedbf1d8" translate="yes" xml:space="preserve">
          <source>When intermixing &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; and OpenGL, it is important to notify &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; that the OpenGL state may have been cluttered so it can restore its internal state. This is achieved by calling &lt;a href=&quot;qpainter#beginNativePainting&quot;&gt;QPainter::beginNativePainting&lt;/a&gt;() before starting the OpenGL rendering and calling &lt;a href=&quot;qpainter#endNativePainting&quot;&gt;QPainter::endNativePainting&lt;/a&gt;() after finishing.</source>
          <target state="translated">При смешивании &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; и OpenGL важно уведомить &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; о том, что состояние OpenGL могло быть загромождено, чтобы он мог восстановить свое внутреннее состояние. Это достигается вызовом &lt;a href=&quot;qpainter#beginNativePainting&quot;&gt;QPainter :: beginNativePainting&lt;/a&gt; () перед запуском рендеринга OpenGL и вызовом &lt;a href=&quot;qpainter#endNativePainting&quot;&gt;QPainter :: endNativePainting&lt;/a&gt; () после завершения.</target>
        </trans-unit>
        <trans-unit id="3c3351ce7fa4daf3d510e3944f9c0b1cd89614d0" translate="yes" xml:space="preserve">
          <source>When interoperating with another graphics engine, it may be necessary to get a QRhi instance that uses the same Metal device. This can be achieved by passing a pointer to a &lt;a href=&quot;qrhimetalnativehandles&quot;&gt;QRhiMetalNativeHandles&lt;/a&gt; to &lt;a href=&quot;qrhi#create&quot;&gt;QRhi::create&lt;/a&gt;(). The device must be set to a non-null value then. Optionally, a command queue object can be specified as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61bd4cd2f160b9517401ee938d1cc345306ee16b" translate="yes" xml:space="preserve">
          <source>When invoking QDoc on a project that has dependencies and uses the &lt;code&gt;depends&lt;/code&gt; variable, one or more &lt;code&gt;-indexdir&lt;/code&gt; path(s) must be passed as command line option(s). QDoc uses these paths to search for the dependencies' index files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19950d97cb8c934f1e5c65f401298cb13bebd643" translate="yes" xml:space="preserve">
          <source>When invoking one of these options, or when an error happens (for instance an unknown option was passed), the current process will then stop, using the exit() function.</source>
          <target state="translated">При вызове одной из этих опций,или при возникновении ошибки (например,была передана неизвестная опция),текущий процесс будет остановлен с помощью функции exit().</target>
        </trans-unit>
        <trans-unit id="071c0d6d52ee604f468daeb0ab63c0a2099e201d" translate="yes" xml:space="preserve">
          <source>When it comes to more complex controls, it is sometimes better to split them up into separate building blocks. As an example, the complex &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt; control:</source>
          <target state="translated">Когда дело доходит до более сложных элементов управления, иногда лучше разделить их на отдельные строительные блоки. Например, сложный &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;элемент&lt;/a&gt; управления ScrollView :</target>
        </trans-unit>
        <trans-unit id="8e8c72fd29bc00795105647d117aa1d234784718" translate="yes" xml:space="preserve">
          <source>When it comes to rendering, deferred rendering is a different beast in terms of renderer configuration compared to forward rendering. Instead of drawing each mesh and applying a shader effect to shade it, deferred rendering adopts a</source>
          <target state="translated">Когда дело доходит до рендеринга,отложенный рендеринг является другим зверем с точки зрения конфигурации рендера по сравнению с форвардным рендерингом.Вместо того,чтобы рисовать каждый мешок и применять шейдерный эффект для его затенения,отложенный рендеринг принимает формат</target>
        </trans-unit>
        <trans-unit id="626ed890d480d0a4b856052f27b67e8d0b322b1a" translate="yes" xml:space="preserve">
          <source>When it comes to texture support, the &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; value should be set to the appropriate &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; subclass that matches the sampler type of the shader uniform.</source>
          <target state="translated">Когда дело доходит до поддержки текстур, значение &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; должно быть установлено на соответствующий подкласс &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture,&lt;/a&gt; который соответствует типу сэмплера униформы шейдера.</target>
        </trans-unit>
        <trans-unit id="5979b40af94b30c33380148b42cb7fe798d86843" translate="yes" xml:space="preserve">
          <source>When it comes to texture support, the Parameter value should be set to the appropriate &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;texture&lt;/a&gt; subclass that matches the sampler type of the shader uniform.</source>
          <target state="translated">Когда дело доходит до поддержки текстур, значение параметра должно быть установлено на соответствующий подкласс &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;текстуры,&lt;/a&gt; который соответствует типу сэмплера униформы шейдера.</target>
        </trans-unit>
        <trans-unit id="71c851f5c2d819a86267b67c443581d3b3d61a3e" translate="yes" xml:space="preserve">
          <source>When it comes to texture support, the QParameter value should be set to the appropriate &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; subclass that matches the sampler type of the shader uniform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac390c6893275dbab12f259c5a78a8285bc68bc5" translate="yes" xml:space="preserve">
          <source>When it does not call &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;, Shape interacts with &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;QFrame::Shadow&lt;/a&gt;, the &lt;a href=&quot;qframe#lineWidth-prop&quot;&gt;lineWidth&lt;/a&gt;() and the &lt;a href=&quot;qframe#midLineWidth-prop&quot;&gt;midLineWidth&lt;/a&gt;() to create the total result. See the picture of the frames in the main class documentation.</source>
          <target state="translated">Когда он не вызывает &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; , Shape взаимодействует с &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;QFrame :: Shadow&lt;/a&gt; , &lt;a href=&quot;qframe#lineWidth-prop&quot;&gt;lineWidth&lt;/a&gt; () и &lt;a href=&quot;qframe#midLineWidth-prop&quot;&gt;midLineWidth&lt;/a&gt; () для создания общего результата. Смотрите изображение фреймов в документации основного класса.</target>
        </trans-unit>
        <trans-unit id="4261303376e29e827bb3d9ad715c1736160cb00b" translate="yes" xml:space="preserve">
          <source>When it is necessary to reimplement the &lt;a href=&quot;qaccessibleinterface#child&quot;&gt;QAccessibleInterface::child&lt;/a&gt;() function and returning the child after constructing it, this function needs to be called.</source>
          <target state="translated">Когда необходимо повторно реализовать &lt;a href=&quot;qaccessibleinterface#child&quot;&gt;функцию QAccessibleInterface :: child&lt;/a&gt; () и вернуть дочерний элемент после его построения, эту функцию необходимо вызвать.</target>
        </trans-unit>
        <trans-unit id="638905df9b46e03441949d29b36f66dcb7394603" translate="yes" xml:space="preserve">
          <source>When items of data are exported from a model in a drag and drop operation, they are encoded into an appropriate format corresponding to one or more MIME types. Models declare the MIME types that they can use to supply items by reimplementing the &lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel::mimeTypes&lt;/a&gt;() function, returning a list of standard MIME types.</source>
          <target state="translated">Когда элементы данных экспортируются из модели в операции перетаскивания, они кодируются в соответствующий формат, соответствующий одному или нескольким типам MIME. Модели объявляют типы MIME, которые они могут использовать для предоставления элементов, путем повторной реализации функции &lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel :: mimeTypes&lt;/a&gt; (), возвращающей список стандартных типов MIME.</target>
        </trans-unit>
        <trans-unit id="3d596a81dc328e917e2efe8c14460f7b21b5e36e" translate="yes" xml:space="preserve">
          <source>When iterating from 0 and up, it will return the items in the visual arranged order.</source>
          <target state="translated">При итерации от 0 и выше он вернет элементы в визуально упорядоченном порядке.</target>
        </trans-unit>
        <trans-unit id="f808486c7714b611743ef8e1139711cba9bfa51a" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, the items are arbitrarily ordered. With &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, the items are always sorted by key.</source>
          <target state="translated">При повторении &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; элементы упорядочиваются произвольно. В &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; элементы всегда сортируются по ключу.</target>
        </trans-unit>
        <trans-unit id="8c6bd39523d6a042b14b93d88385549366872e15" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, the items are arbitrarily ordered. With QMap, the items are always sorted by key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8708ebbe834470a66afd3e678569b47f4a25996" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, the items are always sorted by key. With &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, the items are arbitrarily ordered.</source>
          <target state="translated">При итерации по &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; элементы всегда сортируются по ключу. В &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; элементы упорядочиваются произвольно.</target>
        </trans-unit>
        <trans-unit id="908bbde912a8e2a5301227f6ea15bedbeee803e0" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, the items are always sorted by key. With QHash, the items are arbitrarily ordered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a98982cb360d3887455667bec14b4371ac7fe09" translate="yes" xml:space="preserve">
          <source>When kerning is enabled, glyph metrics do not add up anymore, even for Latin text. In other words, the assumption that width('a') + width('b') is equal to width(&quot;ab&quot;) is not neccesairly true.</source>
          <target state="translated">При включенном кернинге,глиф-метрики больше не складываются,даже для латинского текста.Другими словами,предположение,что width('a')+width('b')равна width(&quot;ab&quot;)не является необязательно истинным.</target>
        </trans-unit>
        <trans-unit id="c7c90cd5b86c3de4a86dbc5bca9301f0623600e2" translate="yes" xml:space="preserve">
          <source>When kerning is enabled, glyph metrics do not add up anymore, even for Latin text. In other words, the assumption that width('a') + width('b') is equal to width(&quot;ab&quot;) is not necessarily true.</source>
          <target state="translated">При включенном кернинге,глиф-метрики больше не складываются,даже для латинского текста.Другими словами,предположение,что width('a')+width('b')равна width(&quot;ab&quot;)не обязательно является истинным.</target>
        </trans-unit>
        <trans-unit id="1a521e51c1250eb56a9a96122f4249b5a5690e59" translate="yes" xml:space="preserve">
          <source>When keyboard tracking is disabled, changes are only signalled when focus leaves the text field after edits have modified the content. This allows the user to edit via an invalid date-time to reach a valid one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4935f0a00031f4e75a93ae9dcce7afc6159f9c52" translate="yes" xml:space="preserve">
          <source>When leaving &quot;What's This?&quot; mode, a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type Qt::LeaveWhatsThisMode is sent to all toplevel widgets.</source>
          <target state="translated">При выходе из &quot;Что это?&quot; mode, &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; типа Qt :: LeaveWhatsThisMode отправляется всем виджетам верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="68c47022708d018c6f6b21000a13611ed6e90869" translate="yes" xml:space="preserve">
          <source>When linking a library, qmake relies on the underlying platform to know what other libraries this library links against. However, if linking statically, qmake will not get this information unless we use the following &lt;code&gt;CONFIG&lt;/code&gt; options:</source>
          <target state="translated">При компоновке библиотеки qmake полагается на базовую платформу, чтобы знать, с какими другими библиотеками связана эта библиотека. Однако при статической компоновке qmake не получит эту информацию, если мы не используем следующие параметры &lt;code&gt;CONFIG&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a540dbd6e20238800d7ddd333a082e8843bed862" translate="yes" xml:space="preserve">
          <source>When listening for connections, the address and port on which the server is listening are available as &lt;a href=&quot;qtcpserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt;() and &lt;a href=&quot;qtcpserver#serverPort&quot;&gt;serverPort&lt;/a&gt;().</source>
          <target state="translated">При прослушивании соединений адрес и порт, которые прослушивает сервер, доступны как &lt;a href=&quot;qtcpserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt; () и &lt;a href=&quot;qtcpserver#serverPort&quot;&gt;serverPort&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="e0c7db0652d32fbb04e043b9bb98640d9fdf9268" translate="yes" xml:space="preserve">
          <source>When listening for connections, the address and port on which the server is listening are available as &lt;a href=&quot;qwebsocketserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt;() and &lt;a href=&quot;qwebsocketserver#serverPort&quot;&gt;serverPort&lt;/a&gt;().</source>
          <target state="translated">При прослушивании соединений адрес и порт, которые прослушивает сервер, доступны как &lt;a href=&quot;qwebsocketserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt; () и &lt;a href=&quot;qwebsocketserver#serverPort&quot;&gt;serverPort&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="31ca6375539521ce018e40aba55ef1cfd8ac0a7b" translate="yes" xml:space="preserve">
          <source>When listening for connections, the name which the server is listening on is available through &lt;a href=&quot;qlocalserver#serverName&quot;&gt;serverName&lt;/a&gt;().</source>
          <target state="translated">При прослушивании соединений имя, которое прослушивает сервер, доступно через &lt;a href=&quot;qlocalserver#serverName&quot;&gt;serverName&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="f562b333fc7588768d7b731fad5e57e2bf351983" translate="yes" xml:space="preserve">
          <source>When loading a QML object into a C++ application, it can be useful to directly embed some C++ data that can be used from within the QML code. This makes it possible, for example, to invoke a C++ method on the embedded object, or use a C++ object instance as a data model for a QML view.</source>
          <target state="translated">При загрузке объекта QML в C++приложение может быть полезно непосредственно встраивать некоторые данные C++,которые могут быть использованы из QML кода.Это делает возможным,например,вызывать метод C++на встроенном объекте или использовать экземпляр объекта C++в качестве модели данных для представления QML.</target>
        </trans-unit>
        <trans-unit id="5937553b7180f604506425e217e2f3d3eb8c1b4d" translate="yes" xml:space="preserve">
          <source>When loading the library, &lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt; searches in all system-specific library locations (for example, &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; on Unix), unless the file name has an absolute path. After loading the library successfully, fileName() returns the fully-qualified file name of the library, including the full path to the library if one was given in the constructor or passed to setFileName().</source>
          <target state="translated">При загрузке библиотеки &lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt; ищет во всех системных библиотеках (например, &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; в Unix), если имя файла не имеет абсолютного пути. После успешной загрузки библиотеки fileName () возвращает полное имя файла библиотеки, включая полный путь к библиотеке, если он был указан в конструкторе или передан в setFileName ().</target>
        </trans-unit>
        <trans-unit id="90725888073e38b3afa3349da5a1b31dfd6e2335" translate="yes" xml:space="preserve">
          <source>When loading the plugin, &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; searches in all plugin locations specified by &lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication::libraryPaths&lt;/a&gt;(), unless the file name has an absolute path. After loading the plugin successfully, fileName() returns the fully-qualified file name of the plugin, including the full path to the plugin if one was given in the constructor or passed to setFileName().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07f1533b7f9a425f6f190f84dd677e6063996b77" translate="yes" xml:space="preserve">
          <source>When loading the plugin, &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; searches in the current directory and in all plugin locations specified by &lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication::libraryPaths&lt;/a&gt;(), unless the file name has an absolute path. After loading the plugin successfully, fileName() returns the fully-qualified file name of the plugin, including the full path to the plugin if one was given in the constructor or passed to setFileName().</source>
          <target state="translated">При загрузке подключаемого модуля &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; ищет в текущем каталоге и во всех местоположениях подключаемых модулей, указанных &lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication :: libraryPaths&lt;/a&gt; (), если имя файла не имеет абсолютного пути. После успешной загрузки плагина fileName () возвращает полное имя файла плагина, включая полный путь к плагину, если он был указан в конструкторе или передан в setFileName ().</target>
        </trans-unit>
        <trans-unit id="fed00e705cb06cd3fa7ef9acd6a2a5b4614acebf" translate="yes" xml:space="preserve">
          <source>When making OpenGL function calls, it is strongly recommended to avoid calling the functions directly. Instead, prefer using &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; (when making portable applications) or the versioned variants (for example, &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions-3-2-core.html&quot;&gt;QOpenGLFunctions_3_2_Core&lt;/a&gt; and similar, when targeting modern, desktop-only OpenGL). This way the application will work correctly in all Qt build configurations, including the ones that perform dynamic OpenGL implementation loading which means applications are not directly linking to an GL implementation and thus direct function calls are not feasible.</source>
          <target state="translated">При вызове функций OpenGL настоятельно рекомендуется избегать прямого вызова функций. Вместо этого предпочтите использовать &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; (при создании переносимых приложений) или варианты с контролем версий (например, &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions-3-2-core.html&quot;&gt;QOpenGLFunctions_3_2_Core&lt;/a&gt; и аналогичные, при нацеливании на современный OpenGL только для настольных ПК). Таким образом, приложение будет работать правильно во всех конфигурациях сборки Qt, включая те, которые выполняют динамическую загрузку реализации OpenGL, что означает, что приложения не связываются напрямую с реализацией GL и, следовательно, прямые вызовы функций невозможны.</target>
        </trans-unit>
        <trans-unit id="f276cbbad1d8799cadf78ef781192531dc7ead31" translate="yes" xml:space="preserve">
          <source>When making OpenGL function calls, it is strongly recommended to avoid calling the functions directly. Instead, prefer using &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; (when making portable applications) or the versioned variants (for example, &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions-3-2-core.html&quot;&gt;QOpenGLFunctions_3_2_Core&lt;/a&gt; and similar, when targeting modern, desktop-only OpenGL). This way the application will work correctly in all Qt build configurations, including the ones that perform dynamic OpenGL implementation loading which means applications are not directly linking to an GL implementation and thus direct function calls are not feasible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7812b8e5267196ba2ad8e65b065aaa80e3d29f0" translate="yes" xml:space="preserve">
          <source>When making a context current using &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;, do not check that the &lt;a href=&quot;qobject#thread-affinity&quot;&gt;QObject thread affinity&lt;/a&gt; of the &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; object is the same thread calling &lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent()&lt;/a&gt;. This value was added in Qt 5.8.</source>
          <target state="translated">При создании контекста тока с помощью &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; , не проверить , что &lt;a href=&quot;qobject#thread-affinity&quot;&gt;QObject нить аффинность&lt;/a&gt; в &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; объекта и тот же поток вызова &lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent ()&lt;/a&gt; . Это значение было добавлено в Qt 5.8.</target>
        </trans-unit>
        <trans-unit id="3d457ffc5179988c0d911e245311c267b3667157" translate="yes" xml:space="preserve">
          <source>When making the temporary credentials request, the client authenticates using only the client credentials. When making the token request, the client authenticates using the client credentials as well as the temporary credentials. Once the client receives and stores the token credentials, it can proceed to access protected resources on behalf of the resource owner by making authenticated requests using the client credentials together with the token credentials received.</source>
          <target state="translated">При запросе временных учетных данных клиент аутентифицируется,используя только учетные данные клиента.При запросе маркера клиент аутентифицируется,используя клиентские учетные данные,а также временные учетные данные.Как только клиент получает и хранит учетные данные маркера,он может приступить к доступу к защищенным ресурсам от имени владельца ресурса,сделав запрос аутентификации,используя учетные данные клиента вместе с полученными учетными данными маркера.</target>
        </trans-unit>
        <trans-unit id="810316d46e7d600660a66af0e59fa7e02d7433b6" translate="yes" xml:space="preserve">
          <source>When managing dynamically created objects, you must ensure the creation context outlives the created object. Otherwise, if the creation context is destroyed first, the bindings and signal handlers in the dynamic object will no longer work.</source>
          <target state="translated">При управлении динамически созданными объектами необходимо убедиться,что контекст создания перекрывает созданный объект.В противном случае,если контекст создания уничтожен первым,привязки и обработчики сигналов в динамическом объекте больше не будут работать.</target>
        </trans-unit>
        <trans-unit id="b19286d402c202adf58ff1b66a30b97e15b4a785" translate="yes" xml:space="preserve">
          <source>When manipulating selections, it is often helpful to think of &lt;a href=&quot;qitemselectionmodel&quot;&gt;QItemSelectionModel&lt;/a&gt; as a record of the selection state of all the items in an item model. Once a selection model is set up, collections of items can be selected, deselected, or their selection states can be toggled without the need to know which items are already selected. The indexes of all selected items can be retrieved at any time, and other components can be informed of changes to the selection model via the signals and slots mechanism.</source>
          <target state="translated">При манипулировании выборками часто полезно думать о &lt;a href=&quot;qitemselectionmodel&quot;&gt;QItemSelectionModel&lt;/a&gt; как о записи состояния выбора всех элементов в модели элементов. После того, как модель выбора настроена, коллекции элементов можно выбирать, отменять выбор или переключать их состояния выбора без необходимости знать, какие элементы уже выбраны. Индексы всех выбранных элементов могут быть получены в любое время, а другие компоненты могут быть проинформированы об изменениях в модели выбора через механизм сигналов и слотов.</target>
        </trans-unit>
        <trans-unit id="4fe612b6914bd28d3a91c181ce17418b66edda3f" translate="yes" xml:space="preserve">
          <source>When mirroring the layout using either the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; or by setting the &lt;a href=&quot;qml-qtquick-grid#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt;, the horizontal alignment of items will be mirrored as well. However, the property &lt;code&gt;horizontalItemAlignment&lt;/code&gt; will remain unchanged. To query the effective horizontal alignment of items, use the read-only property &lt;code&gt;effectiveHorizontalItemAlignment&lt;/code&gt;.</source>
          <target state="translated">При зеркальном отображении макета с использованием либо присоединенного свойства &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled,&lt;/a&gt; либо путем установки &lt;a href=&quot;qml-qtquick-grid#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; горизонтальное выравнивание элементов также будет зеркально отражено. Однако свойство &lt;code&gt;horizontalItemAlignment&lt;/code&gt; останется без изменений. Чтобы запросить эффективное горизонтальное выравнивание элементов, используйте доступное только для чтения свойство &lt;code&gt;effectiveHorizontalItemAlignment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9debebd9aa12f2d598528bbeb0d545c66987f90" translate="yes" xml:space="preserve">
          <source>When mixing raw graphics (OpenGL, Vulkan, Metal, etc.) commands with scene graph rendering, it is necessary to call this function after recording commands to the command buffer used by the scene graph to render its main render pass. This is to avoid clobbering state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e30ffa6a01f7853331128d4cf7b56aeea01dcd" translate="yes" xml:space="preserve">
          <source>When mixing raw graphics (OpenGL, Vulkan, Metal, etc.) commands with scene graph rendering, it is necessary to call this function before recording commands to the command buffer used by the scene graph to render its main render pass. This is to avoid clobbering state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98292e6a711c0a97d142c6900df0dd3a1198f215" translate="yes" xml:space="preserve">
          <source>When model is not explicitly set, it will be synchronized with &lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt;'s model once &lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt; is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67c4954bd29b0a4fd959263898f6a26791b7a7d0" translate="yes" xml:space="preserve">
          <source>When model is not explicitly set, the header will use the &lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt;'s model once &lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt; is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b20aa7e6cd799e3bf7fad3e47e4d5468b0303506" translate="yes" xml:space="preserve">
          <source>When multiple QOpenGLWidgets are added as children to the same top-level widget, their contexts will share with each other. This does not apply for &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; instances that belong to different windows.</source>
          <target state="translated">Когда несколько QOpenGLWidgets добавляются в качестве дочерних к одному и тому же виджету верхнего уровня, их контексты будут совместно использоваться друг с другом. Это не относится к экземплярам &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget,&lt;/a&gt; которые принадлежат разным окнам.</target>
        </trans-unit>
        <trans-unit id="a052e77d465746dc1474a9b2e904f81e2b5f4c64" translate="yes" xml:space="preserve">
          <source>When multiple QOpenGLWidgets are added as children to the same top-level widget, their contexts will share with each other. This does not apply for QOpenGLWidget instances that belong to different windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be71f48901e09c1cafec1c8d3da6f3f42996e8be" translate="yes" xml:space="preserve">
          <source>When multiple render targets are in use,</source>
          <target state="translated">Когда используется несколько целей рендеринга,</target>
        </trans-unit>
        <trans-unit id="cca7faed1dcf3acb3787eb6ed52f3e078b4e846e" translate="yes" xml:space="preserve">
          <source>When multiple selectors could be applied to the same file, the first matching selector is chosen. The order selectors are checked in are:</source>
          <target state="translated">Если к одному и тому же файлу можно применить несколько селекторов,выбирается первый селектор совпадений.Селекторы заказов отмечены галочкой &quot;Есть&quot;:</target>
        </trans-unit>
        <trans-unit id="a2d60a792f80124c96dcd07ddb164770dfe0ca59" translate="yes" xml:space="preserve">
          <source>When multiple series are added to a graph, selecting an item in one of them will clear the selection on other series.</source>
          <target state="translated">При добавлении нескольких серий на график,выделение элемента в одной из них очистит выделение на другой серии.</target>
        </trans-unit>
        <trans-unit id="b98c31c0b36eccbc7c80561d52175a75bcc24aef" translate="yes" xml:space="preserve">
          <source>When multiple textures are attached, the return value is the ID of the first one.</source>
          <target state="translated">Когда прикреплено несколько текстур,возвращаемым значением является идентификатор первой из них.</target>
        </trans-unit>
        <trans-unit id="5ea247c1f56cf273fe99668ba49d31b1b499bfbe" translate="yes" xml:space="preserve">
          <source>When multisample antialiasing is used, content rendered into framebuffer objects need additional extensions to support multisampling of framebuffers. Typically &lt;code&gt;GL_EXT_framebuffer_multisample&lt;/code&gt; and &lt;code&gt;GL_EXT_framebuffer_blit&lt;/code&gt;. Most desktop chips have these extensions present, but they are less common in embedded chips. When framebuffer multisampling is not available in the hardware, content rendered into framebuffer objects will not be antialiased, including the content of a &lt;a href=&quot;qml-qtquick-shadereffectsource&quot;&gt;ShaderEffectSource&lt;/a&gt;.</source>
          <target state="translated">Когда используется мультисэмплинг сглаживания, контент, отображаемый в объекты фреймбуфера, требует дополнительных расширений для поддержки мультисэмплинга фреймбуфера. Обычно &lt;code&gt;GL_EXT_framebuffer_multisample&lt;/code&gt; и &lt;code&gt;GL_EXT_framebuffer_blit&lt;/code&gt; . Эти расширения присутствуют в большинстве процессоров для настольных ПК, но они реже встречаются во встроенных микросхемах. Когда мультисэмплинг фреймбуфера недоступен на оборудовании, контент, отображаемый в объекты фреймбуфера, не будет сглаживаться, включая контент &lt;a href=&quot;qml-qtquick-shadereffectsource&quot;&gt;ShaderEffectSource&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fccefc8901100b2f82142ca7d8bb3223d24d7501" translate="yes" xml:space="preserve">
          <source>When navigating the document structure, it is useful to begin at the root frame because it provides access to the entire document structure.</source>
          <target state="translated">При навигации по структуре документа полезно начинать с корневого фрейма,поскольку он обеспечивает доступ ко всей структуре документа.</target>
        </trans-unit>
        <trans-unit id="3e0a254e08acf9d6be4fd4d7a634988147b26055" translate="yes" xml:space="preserve">
          <source>When nested opacity gets below a certain threshold, the subtree might be marked as blocked, causing &lt;a href=&quot;qsgnode#isSubtreeBlocked&quot;&gt;isSubtreeBlocked&lt;/a&gt;() to return true. This is done for performance reasons.</source>
          <target state="translated">Когда вложенная прозрачность становится ниже определенного порога, поддерево может быть помечено как заблокированное, в результате чего &lt;a href=&quot;qsgnode#isSubtreeBlocked&quot;&gt;isSubtreeBlocked&lt;/a&gt; () вернет true. Это сделано из соображений производительности.</target>
        </trans-unit>
        <trans-unit id="4d85ccf2069fc6eae18e11975d88bfe1fadc019f" translate="yes" xml:space="preserve">
          <source>When no windowing system is present, the mouse, keyboard and touch input are read directly via &lt;code&gt;evdev&lt;/code&gt;. Note that this requires that devices nodes &lt;code&gt;/input/event*&lt;/code&gt; are readable by the user. eglfs and vxworksfb has all the evdev input handling code built-in.</source>
          <target state="translated">Когда оконная система отсутствует, данные с мыши, клавиатуры и сенсорного ввода считываются напрямую через &lt;code&gt;evdev&lt;/code&gt; . Обратите внимание, что для этого требуется, чтобы узлы устройств &lt;code&gt;/input/event*&lt;/code&gt; доступны для чтения пользователем. eglfs и vxworksfb имеют встроенный код обработки ввода evdev.</target>
        </trans-unit>
        <trans-unit id="5b0f164920aba9354f027a11efdb935f7ff22e14" translate="yes" xml:space="preserve">
          <source>When no windowing system is present, the mouse, keyboard, and touch input are read directly via &lt;code&gt;evdev&lt;/code&gt; or using helper libraries such as &lt;code&gt;libinput&lt;/code&gt; or &lt;code&gt;tslib&lt;/code&gt;. Note that this requires that device nodes &lt;code&gt;/dev/input/event*&lt;/code&gt; are readable by the user. &lt;code&gt;eglfs&lt;/code&gt; and &lt;code&gt;linuxfb&lt;/code&gt; have all the input handling code compiled-in.</source>
          <target state="translated">Когда оконная система отсутствует, данные с мыши, клавиатуры и сенсорного ввода считываются напрямую через &lt;code&gt;evdev&lt;/code&gt; или с помощью вспомогательных библиотек, таких как &lt;code&gt;libinput&lt;/code&gt; или &lt;code&gt;tslib&lt;/code&gt; . Обратите внимание, что для этого требуется, чтобы узлы устройства &lt;code&gt;/dev/input/event*&lt;/code&gt; были доступны для чтения пользователем. &lt;code&gt;eglfs&lt;/code&gt; и &lt;code&gt;linuxfb&lt;/code&gt; скомпилирован весь код обработки ввода.</target>
        </trans-unit>
        <trans-unit id="18d39e71149ec53d71da5bdfa496288bb4064e73" translate="yes" xml:space="preserve">
          <source>When not running with the RHI (and using OpenGL directly), the signal is emitted after the renderer has cleared the render target. This makes it possible to create applications that function identically both with and without the RHI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0721c385a99233431f8667a3ee0ae4fedf149b4" translate="yes" xml:space="preserve">
          <source>When not running with the RHI (and using OpenGL directly), the signal is emitted after the renderer has finished its rendering, but before &lt;a href=&quot;qquickwindow#afterRendering&quot;&gt;afterRendering&lt;/a&gt;(). This makes it possible to create applications that function identically both with and without the RHI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dca5d911ae2265eef32ee4fee8077e25696a9db8" translate="yes" xml:space="preserve">
          <source>When one of the statements is a non-select statement a count of affected rows may be available instead of a result set.</source>
          <target state="translated">Когда одно из утверждений является невыборочным,вместо набора результатов может быть доступен подсчет затрагиваемых строк.</target>
        </trans-unit>
        <trans-unit id="e9136aaa0ef09df9e9f07e3241b2a9f838fd494d" translate="yes" xml:space="preserve">
          <source>When operating in deterministic mode, &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; may be used for bulk data generation. In fact, applications that do not need cryptographically-secure or true random data are advised to use a regular &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; instead of &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator::system&lt;/a&gt;() for their random data needs.</source>
          <target state="translated">При работе в детерминированном режиме &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; может использоваться для генерации больших объемов данных. Фактически, приложениям, которым не нужны криптографически безопасные или истинные случайные данные, рекомендуется использовать обычный &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; вместо &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator :: system&lt;/a&gt; () для своих случайных данных.</target>
        </trans-unit>
        <trans-unit id="601025c900ae42d4debb597407723c06012bd462" translate="yes" xml:space="preserve">
          <source>When operating in deterministic mode, QRandomGenerator may be used for bulk data generation. In fact, applications that do not need cryptographically-secure or true random data are advised to use a regular QRandomGenerator instead of &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator::system&lt;/a&gt;() for their random data needs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0c853a6a3df272210d1c9d0c36c813572cdfe7" translate="yes" xml:space="preserve">
          <source>When operating on managed objects in normal C++ code, a little extra care must be taken because of the CLR's garbage collection. A normal pointer variable should not</source>
          <target state="translated">При работе с управляемыми объектами в обычном Си++коде необходимо немного больше внимания уделять сбору мусора в CLR.Нормальная указательная переменная не должна</target>
        </trans-unit>
        <trans-unit id="ea7e897063825784978303959c1455b5d44412c2" translate="yes" xml:space="preserve">
          <source>When options can be grouped, you can use a partially checked &lt;a href=&quot;qml-qtquick-controls2-checkbox&quot;&gt;CheckBox&lt;/a&gt; to represent the whole group. Use the checkbox's &lt;a href=&quot;qml-qtquick-controls2-checkbox#checkState-prop&quot;&gt;partially checked state&lt;/a&gt; when a user selects some, but not all, sub-items in the group.</source>
          <target state="translated">Когда опции могут быть сгруппированы, вы можете использовать частично проверены &lt;a href=&quot;qml-qtquick-controls2-checkbox&quot;&gt;CheckBox&lt;/a&gt; , чтобы представлять всю группу. Используйте &lt;a href=&quot;qml-qtquick-controls2-checkbox#checkState-prop&quot;&gt;частично установленное состояние&lt;/a&gt; флажка, когда пользователь выбирает некоторые, но не все подпункты в группе.</target>
        </trans-unit>
        <trans-unit id="fe4c38cfe45b7ff5d5ad3092c911b19539b422d2" translate="yes" xml:space="preserve">
          <source>When painting to a &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt; using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, the state of the current OpenGL context will be altered by the paint engine to reflect its needs. Applications should not rely upon the OpenGL state being reset to its original conditions, particularly the current shader program, OpenGL viewport, texture units, and drawing modes.</source>
          <target state="translated">При рисовании в &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt; с использованием &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; состояние текущего контекста OpenGL будет изменено механизмом рисования, чтобы отразить его потребности. Приложения не должны полагаться на то, что состояние OpenGL сбрасывается до исходного состояния, особенно текущая программа шейдера, окно просмотра OpenGL, блоки текстуры и режимы рисования.</target>
        </trans-unit>
        <trans-unit id="76720392a96856f8c1e5f2c5c0b848262c8e8089" translate="yes" xml:space="preserve">
          <source>When painting to a QOpenGLPaintDevice using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, the state of the current OpenGL context will be altered by the paint engine to reflect its needs. Applications should not rely upon the OpenGL state being reset to its original conditions, particularly the current shader program, OpenGL viewport, texture units, and drawing modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e4b844ee7e4c5be1b0dab1bbe7aaa712b977db0" translate="yes" xml:space="preserve">
          <source>When paused, the current frame can be advanced manually by setting this property or calling &lt;a href=&quot;qml-qtquick-animatedsprite#advance-method&quot;&gt;advance()&lt;/a&gt;.</source>
          <target state="translated">В режиме паузы текущий кадр можно продвинуть вперед вручную, задав это свойство или вызвав &lt;a href=&quot;qml-qtquick-animatedsprite#advance-method&quot;&gt;advance ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="36bc00e334ac8aa1eea3755d12934f7608da4dea" translate="yes" xml:space="preserve">
          <source>When paused, the current frame can be advanced manually.</source>
          <target state="translated">При паузе текущий кадр можно передвинуть вручную.</target>
        </trans-unit>
        <trans-unit id="40753593df1bbb77361dbb8a61ae51ec564eb417" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnsmailexchangerecord&quot;&gt;QDnsMailExchangeRecord&lt;/a&gt; instance.</source>
          <target state="translated">При выполнении поиска в службе будет возвращено ноль или более записей. Каждая запись представлена экземпляром &lt;a href=&quot;qdnsmailexchangerecord&quot;&gt;QDnsMailExchangeRecord&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="745159504ea8964595662dfda6ea6803520cab14" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnsservicerecord&quot;&gt;QDnsServiceRecord&lt;/a&gt; instance.</source>
          <target state="translated">При выполнении поиска в службе будет возвращено ноль или более записей. Каждая запись представлена экземпляром &lt;a href=&quot;qdnsservicerecord&quot;&gt;QDnsServiceRecord&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d6001a94eae9d4e4679d672b10ebf1476ba4b97" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a QDnsMailExchangeRecord instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="183c9e6bf9945fe2d7c4f1ece374cc4634d591ca" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a QDnsServiceRecord instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b6dd291204471e81a34c81e897e2eae987238a" translate="yes" xml:space="preserve">
          <source>When performing a name server lookup, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnsdomainnamerecord&quot;&gt;QDnsDomainNameRecord&lt;/a&gt; instance.</source>
          <target state="translated">При выполнении поиска на сервере имен будет возвращено ноль или более записей. Каждая запись представлена экземпляром &lt;a href=&quot;qdnsdomainnamerecord&quot;&gt;QDnsDomainNameRecord&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d31385d56b863dd8dbd104e645dc9977d21a36cc" translate="yes" xml:space="preserve">
          <source>When performing a name server lookup, zero or more records will be returned. Each record is represented by a QDnsDomainNameRecord instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3612e920959430b2f4633a7ed7ecb7c74231f462" translate="yes" xml:space="preserve">
          <source>When performing a text lookup, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnstextrecord&quot;&gt;QDnsTextRecord&lt;/a&gt; instance.</source>
          <target state="translated">При поиске текста будет возвращено ноль или более записей. Каждая запись представлена экземпляром &lt;a href=&quot;qdnstextrecord&quot;&gt;QDnsTextRecord&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="909f4885c9471951ef724c0551ca405b8644c385" translate="yes" xml:space="preserve">
          <source>When performing a text lookup, zero or more records will be returned. Each record is represented by a QDnsTextRecord instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711a9f71466771c6e4aade7928b9960c7cefd54f" translate="yes" xml:space="preserve">
          <source>When performing an address lookup, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnshostaddressrecord&quot;&gt;QDnsHostAddressRecord&lt;/a&gt; instance.</source>
          <target state="translated">При выполнении поиска адреса будет возвращено ноль или более записей. Каждая запись представлена экземпляром &lt;a href=&quot;qdnshostaddressrecord&quot;&gt;QDnsHostAddressRecord&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be3ad2654f5fa7ba6e1f52aec206ab62cc47cc26" translate="yes" xml:space="preserve">
          <source>When performing an address lookup, zero or more records will be returned. Each record is represented by a QDnsHostAddressRecord instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63db06c50e58a3513cea1497dec1ed7741831f0b" translate="yes" xml:space="preserve">
          <source>When performing drawing using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; only, it is also possible to perform the painting like it is done for ordinary widgets: by reimplementing &lt;a href=&quot;qopenglwidget#paintEvent&quot;&gt;paintEvent&lt;/a&gt;().</source>
          <target state="translated">При выполнении рисования только с использованием &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; можно также выполнять рисование, как это делается для обычных виджетов: путем повторной реализации &lt;a href=&quot;qopenglwidget#paintEvent&quot;&gt;paintEvent&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="4873852a94448fd952353de01e74e6bb7112405f" translate="yes" xml:space="preserve">
          <source>When performing verification steps in an autotest using &lt;a href=&quot;qtest#QCOMPARE&quot;&gt;QCOMPARE&lt;/a&gt;(), &lt;a href=&quot;qtest#QVERIFY&quot;&gt;QVERIFY&lt;/a&gt;(), and so on, side-effects should be avoided. Side-effects in verification steps can make a test difficult to understand. Also, they can easily break a test in ways that are difficult to diagnose when the test is changed to use &lt;a href=&quot;qtest#QTRY_VERIFY&quot;&gt;QTRY_VERIFY&lt;/a&gt;(), &lt;a href=&quot;qtest#QTRY_COMPARE&quot;&gt;QTRY_COMPARE&lt;/a&gt;() or &lt;a href=&quot;qtest#QBENCHMARK&quot;&gt;QBENCHMARK&lt;/a&gt;(). These can execute the passed expression multiple times, thus repeating any side-effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38db5be01962103a3cc7ed36e0dd26d7c49283ec" translate="yes" xml:space="preserve">
          <source>When placed into a &lt;code&gt;.qml&lt;/code&gt; file and loaded by the QML engine, the above code creates a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; object using the &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; type supplied by the &lt;code&gt;QtQuick&lt;/code&gt; module:</source>
          <target state="translated">При помещении в файл &lt;code&gt;.qml&lt;/code&gt; и загрузке механизмом QML приведенный выше код создает объект &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; с использованием типа &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle,&lt;/a&gt; предоставленного модулем &lt;code&gt;QtQuick&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6927c0eac9201c4bf4c31b692534ebe1bbcfa831" translate="yes" xml:space="preserve">
          <source>When populating a layout, the widgets are added to an internal list. The &lt;a href=&quot;qlayout#indexOf&quot;&gt;indexOf&lt;/a&gt;() function returns the index of a widget in that list. The widgets can either be added to the end of the list using the &lt;a href=&quot;qstackedlayout#addWidget&quot;&gt;addWidget&lt;/a&gt;() function, or inserted at a given index using the &lt;a href=&quot;qstackedlayout#insertWidget&quot;&gt;insertWidget&lt;/a&gt;() function. The &lt;a href=&quot;qlayout#removeWidget&quot;&gt;removeWidget&lt;/a&gt;() function removes the widget at the given index from the layout. The number of widgets contained in the layout, can be obtained using the &lt;a href=&quot;qstackedlayout#count-prop&quot;&gt;count&lt;/a&gt;() function.</source>
          <target state="translated">При заполнении макета виджеты добавляются во внутренний список. Функция &lt;a href=&quot;qlayout#indexOf&quot;&gt;indexOf&lt;/a&gt; () возвращает индекс виджета в этом списке. Виджеты можно либо добавить в конец списка с помощью функции &lt;a href=&quot;qstackedlayout#addWidget&quot;&gt;addWidget&lt;/a&gt; (), либо вставить по заданному индексу с помощью функции &lt;a href=&quot;qstackedlayout#insertWidget&quot;&gt;insertWidget&lt;/a&gt; (). Функция &lt;a href=&quot;qlayout#removeWidget&quot;&gt;removeWidget&lt;/a&gt; () удаляет виджет по заданному индексу из макета. Количество виджетов, содержащихся в макете, можно получить с помощью функции &lt;a href=&quot;qstackedlayout#count-prop&quot;&gt;count&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="9c28b221f7e83baed059e2a307e039e7c948b005" translate="yes" xml:space="preserve">
          <source>When populating a stacked widget, the widgets are added to an internal list. The &lt;a href=&quot;qstackedwidget#indexOf&quot;&gt;indexOf&lt;/a&gt;() function returns the index of a widget in that list. The widgets can either be added to the end of the list using the &lt;a href=&quot;qstackedwidget#addWidget&quot;&gt;addWidget&lt;/a&gt;() function, or inserted at a given index using the &lt;a href=&quot;qstackedwidget#insertWidget&quot;&gt;insertWidget&lt;/a&gt;() function. The &lt;a href=&quot;qstackedwidget#removeWidget&quot;&gt;removeWidget&lt;/a&gt;() function removes a widget from the stacked widget. The number of widgets contained in the stacked widget can be obtained using the &lt;a href=&quot;qstackedwidget#count-prop&quot;&gt;count&lt;/a&gt;() function.</source>
          <target state="translated">При заполнении составного виджета виджеты добавляются во внутренний список. Функция &lt;a href=&quot;qstackedwidget#indexOf&quot;&gt;indexOf&lt;/a&gt; () возвращает индекс виджета в этом списке. Виджеты могут быть добавлены в конец списка с помощью функции &lt;a href=&quot;qstackedwidget#addWidget&quot;&gt;addWidget&lt;/a&gt; () или вставлены по заданному индексу с помощью функции &lt;a href=&quot;qstackedwidget#insertWidget&quot;&gt;insertWidget&lt;/a&gt; (). Функция &lt;a href=&quot;qstackedwidget#removeWidget&quot;&gt;removeWidget&lt;/a&gt; () удаляет виджет из сложенного виджета. Количество виджетов, содержащихся в составном виджете, можно получить с помощью функции &lt;a href=&quot;qstackedwidget#count-prop&quot;&gt;count&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="543155192f84c64b5b7246452a09145b18b3004c" translate="yes" xml:space="preserve">
          <source>When popup windows are visible, this property is &lt;code&gt;true&lt;/code&gt; for both the active window</source>
          <target state="translated">Когда всплывающие окна видны, это свойство &lt;code&gt;true&lt;/code&gt; для обоих активных окон.</target>
        </trans-unit>
        <trans-unit id="bf9f03d6670f0731b056deb6a40d087fcc1eaf19" translate="yes" xml:space="preserve">
          <source>When positioning a menu with &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;() or &lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt;(), bear in mind that you cannot rely on the menu's current &lt;a href=&quot;qwidget#size-prop&quot;&gt;size&lt;/a&gt;(). For performance reasons, the menu adapts its size only when necessary. So in many cases, the size before and after the show is different. Instead, use &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() which calculates the proper size depending on the menu's current contents.</source>
          <target state="translated">При размещении меню с помощью &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt; () или &lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt; () имейте в виду, что вы не можете полагаться на текущий &lt;a href=&quot;qwidget#size-prop&quot;&gt;размер&lt;/a&gt; меню (). Из соображений производительности меню меняет свой размер только при необходимости. Так что во многих случаях размер до и после шоу различается. Вместо этого используйте &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt; (), который вычисляет правильный размер в зависимости от текущего содержимого меню.</target>
        </trans-unit>
        <trans-unit id="d446cf9e4868843729e697b92b7ac122b7540da1" translate="yes" xml:space="preserve">
          <source>When positioning a menu with &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;() or popup(), bear in mind that you cannot rely on the menu's current &lt;a href=&quot;qwidget#size-prop&quot;&gt;size&lt;/a&gt;(). For performance reasons, the menu adapts its size only when necessary, so in many cases, the size before and after the show is different. Instead, use &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() which calculates the proper size depending on the menu's current contents.</source>
          <target state="translated">При размещении меню с помощью &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt; () или popup () имейте в виду, что вы не можете полагаться на текущий &lt;a href=&quot;qwidget#size-prop&quot;&gt;размер&lt;/a&gt; меню (). Из соображений производительности меню меняет свой размер только при необходимости, поэтому во многих случаях размер до и после шоу различается. Вместо этого используйте &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt; (), который вычисляет правильный размер в зависимости от текущего содержимого меню.</target>
        </trans-unit>
        <trans-unit id="7029c6cc034ef3f728d2bd0679222f0a517d5042" translate="yes" xml:space="preserve">
          <source>When positioning a menu with exec() or &lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt;(), bear in mind that you cannot rely on the menu's current &lt;a href=&quot;qwidget#size-prop&quot;&gt;size&lt;/a&gt;(). For performance reasons, the menu adapts its size only when necessary. So in many cases, the size before and after the show is different. Instead, use &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() which calculates the proper size depending on the menu's current contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b83e6f455038d9e44dcc627b24af2f87bdc39ec9" translate="yes" xml:space="preserve">
          <source>When possible, it is usually better style to disable the &lt;b&gt;Next&lt;/b&gt; or &lt;b&gt;Finish&lt;/b&gt; button (by specifying &lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;mandatory fields&lt;/a&gt; or by reimplementing &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;QWizardPage::isComplete&lt;/a&gt;()) than to reimplement validateCurrentPage().</source>
          <target state="translated">По возможности, обычно лучше отключить кнопку &amp;laquo; &lt;b&gt;Далее&amp;raquo;&lt;/b&gt; или &amp;laquo; &lt;b&gt;Готово&amp;raquo;&lt;/b&gt; (указав &lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;обязательные поля&lt;/a&gt; или повторно реализовав &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;QWizardPage :: isComplete&lt;/a&gt; ()), чем повторно реализовать validateCurrentPage ().</target>
        </trans-unit>
        <trans-unit id="73d1c2ff7aa2a64e8d25144a78e96a2f710b582a" translate="yes" xml:space="preserve">
          <source>When possible, it is usually better style to disable the &lt;b&gt;Next&lt;/b&gt; or &lt;b&gt;Finish&lt;/b&gt; button (by specifying &lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;mandatory fields&lt;/a&gt; or reimplementing &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt;()) than to reimplement validatePage().</source>
          <target state="translated">Когда это возможно, обычно лучше отключить кнопку &amp;laquo; &lt;b&gt;Далее&amp;raquo;&lt;/b&gt; или &amp;laquo; &lt;b&gt;Готово&amp;raquo;&lt;/b&gt; (указав &lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;обязательные поля&lt;/a&gt; или переопределив &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt; ()), чем повторно реализовать validatePage ().</target>
        </trans-unit>
        <trans-unit id="4c25870dd84e6151f006f88996bd899f2da5153f" translate="yes" xml:space="preserve">
          <source>When possible, this static function will use the native file dialog and not a &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;. On platforms which don't support selecting remote files, Qt will allow to select only local files.</source>
          <target state="translated">Когда возможно, эта статическая функция будет использовать собственное диалоговое окно файла, а не &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt; . На платформах, которые не поддерживают выбор удаленных файлов, Qt позволяет выбирать только локальные файлы.</target>
        </trans-unit>
        <trans-unit id="0b489fbd5401aea28516b412c3104164f51acbe1" translate="yes" xml:space="preserve">
          <source>When posting a custom event to the state machine, you typically also have one or more custom transitions that can be triggered from events of that type. To create such a transition, you subclass &lt;a href=&quot;qabstracttransition&quot;&gt;QAbstractTransition&lt;/a&gt; and reimplement &lt;a href=&quot;qabstracttransition#eventTest&quot;&gt;QAbstractTransition::eventTest&lt;/a&gt;(), where you check if an event matches your event type (and optionally other criteria, e.g. attributes of the event object).</source>
          <target state="translated">При отправке настраиваемого события на конечный автомат у вас обычно также есть один или несколько настраиваемых переходов, которые могут запускаться из событий этого типа. Чтобы создать такой переход, вы создаете подкласс &lt;a href=&quot;qabstracttransition&quot;&gt;QAbstractTransition&lt;/a&gt; и повторно &lt;a href=&quot;qabstracttransition#eventTest&quot;&gt;реализуете QAbstractTransition :: eventTest&lt;/a&gt; (), где вы проверяете, соответствует ли событие вашему типу события (и, возможно, другим критериям, например, атрибутам объекта события).</target>
        </trans-unit>
        <trans-unit id="c0626bfe8658560f4b9456379db258ae7347f2e4" translate="yes" xml:space="preserve">
          <source>When present in a state set, enables the seamless cubemap texture filtering as provided by the GL_ARB_seamless_cubemap extension (if available).</source>
          <target state="translated">При присутствии в наборе состояний,включает фильтрацию текстур бесшовных кубовых карт,предусмотренную расширением GL_ARB_seamless_cubemap (если доступно).</target>
        </trans-unit>
        <trans-unit id="dd42c97f91ca6cd533ba12641c6d6512a8021b98" translate="yes" xml:space="preserve">
          <source>When pressing the &quot;Pick Screen Color&quot; button, the cursor changes to a haircross and the colors on the screen are scanned. The user can pick up one by clicking the mouse or the Enter button. Pressing Escape restores the last color selected before entering this mode.</source>
          <target state="translated">При нажатии кнопки &quot;Pick Screen Color&quot; (Выбрать цвет экрана)курсор переходит в парикмахерскую и цвета на экране сканируются.Пользователь может выбрать один из них,щелкнув мышью или нажав кнопку &quot;Enter&quot;.Нажатие кнопки &quot;Побег&quot; восстанавливает последний выбранный цвет перед входом в этот режим.</target>
        </trans-unit>
        <trans-unit id="365ed507c80ed465082d4faf723c11a4f4a529f9" translate="yes" xml:space="preserve">
          <source>When printing directly to a printer on Windows or &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; uses the built-in printer drivers. On X11, &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; uses the &lt;a href=&quot;http://www.cups.org/&quot;&gt;Common Unix Printing System (CUPS)&lt;/a&gt; to send PDF output to the printer. As an alternative, the &lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt;() function can be used to specify the command or utility to use instead of the system default.</source>
          <target state="translated">При печати непосредственно на принтер Windows , или &lt;a href=&quot;internationalization#macos&quot;&gt;MacOS&lt;/a&gt; , &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; использует встроенные драйверы принтера. На X11 &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; использует &lt;a href=&quot;http://www.cups.org/&quot;&gt;Common Unix Printing System (CUPS)&lt;/a&gt; для отправки вывода PDF на принтер. В качестве альтернативы можно использовать функцию &lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt; (), чтобы указать команду или утилиту, которые будут использоваться вместо системного значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="9cee561b8e10ced76ed482af9619144ea4d1c14b" translate="yes" xml:space="preserve">
          <source>When printing directly to a printer on Windows or macOS, QPrinter uses the built-in printer drivers. On X11, QPrinter uses the &lt;a href=&quot;http://www.cups.org/&quot;&gt;Common Unix Printing System (CUPS)&lt;/a&gt; to send PDF output to the printer. As an alternative, the &lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt;() function can be used to specify the command or utility to use instead of the system default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7baf1526ab727030bb94d023b433c10155cb76be" translate="yes" xml:space="preserve">
          <source>When processing</source>
          <target state="translated">При обработке</target>
        </trans-unit>
        <trans-unit id="6d2106bb45d40ac84dd2228f91e6e53dfdbe85fe" translate="yes" xml:space="preserve">
          <source>When processing any of the \code, &lt;a href=&quot;#newcode-command&quot;&gt;\newcode&lt;/a&gt; or &lt;a href=&quot;#oldcode-command&quot;&gt;\oldcode&lt;/a&gt; commands, QDoc removes all indentation that is common for the verbatim code blocks within a &lt;code&gt;/&lt;/code&gt;&lt;code&gt;*!&lt;/code&gt; ... &lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt; comment before it adds the standard indentation.</source>
          <target state="translated">При обработке любой из команд \ code, &lt;a href=&quot;#newcode-command&quot;&gt;\ newcode&lt;/a&gt; или &lt;a href=&quot;#oldcode-command&quot;&gt;\ oldcode&lt;/a&gt; QDoc удаляет все отступы, которые являются общими для блоков дословного кода внутри &lt;code&gt;/&lt;/code&gt; &lt;code&gt;*!&lt;/code&gt; ... &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; комментарий перед добавлением стандартного отступа.</target>
        </trans-unit>
        <trans-unit id="8ac017cc68b793557123c9ce971931fa3dec416c" translate="yes" xml:space="preserve">
          <source>When processing any of the \code, &lt;a href=&quot;06-qdoc-commands-includecodeinline#newcode-command&quot;&gt;\newcode&lt;/a&gt; or &lt;a href=&quot;06-qdoc-commands-includecodeinline#oldcode-command&quot;&gt;\oldcode&lt;/a&gt; commands, QDoc removes all indentation that is common for the verbatim code blocks within a &lt;code&gt;/&lt;/code&gt;&lt;code&gt;*!&lt;/code&gt; ... &lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt; comment before it adds the standard indentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc162586167c5dda9673822a3e347c76baa904e" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;headers&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">При обработке переменной &lt;code&gt;headers&lt;/code&gt; QDoc ведет себя так же, как и при обработке переменной &lt;a href=&quot;#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt; . Для получения дополнительной информации см. Переменную &lt;a href=&quot;#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f6649e82a5699a0360075ae40dd46b9e5c7a464" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;headers&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8485caf25338b1f76aa184669dce3005f004482c" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;images&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">При обработке переменной &lt;code&gt;images&lt;/code&gt; QDoc ведет себя так же, как и при обработке переменной &lt;a href=&quot;#imagedirs&quot;&gt; &lt;code&gt;imagedirs&lt;/code&gt; &lt;/a&gt; . Для получения дополнительной информации см. Переменную &lt;a href=&quot;#imagedirs&quot;&gt; &lt;code&gt;imagedirs&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83b7b87983b264f92514be824ef568bf74fc4531" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;images&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;22-qdoc-configuration-generalvariables#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;22-qdoc-configuration-generalvariables#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ac4cb127779361e46edccdd9715135c772a6b4" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;sources&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable.</source>
          <target state="translated">При обработке переменной &lt;code&gt;sources&lt;/code&gt; QDoc ведет себя так же, как и при обработке переменной &lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; . Для получения дополнительной информации см. Переменную &lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cad134d8c8f7cf34f150e5381504660ade1079a5" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;sources&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2f6258fc95387a5c4367b7340551e8c1e093ed8" translate="yes" xml:space="preserve">
          <source>When processing the header files specified in the &lt;a href=&quot;#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;headers.fileextensions&lt;/code&gt; variable. In this way QDoc avoids spending time reading irrelevant files.</source>
          <target state="translated">При обработке файлов заголовков, указанных в переменной &lt;a href=&quot;#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt; , QDoc будет читать только файлы с расширениями файлов, указанными в переменной &lt;code&gt;headers.fileextensions&lt;/code&gt; . Таким образом QDoc избегает тратить время на чтение ненужных файлов.</target>
        </trans-unit>
        <trans-unit id="e6e737bd0bca30837e70dbf0ba50e38a69eda1ae" translate="yes" xml:space="preserve">
          <source>When processing the header files specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;headers.fileextensions&lt;/code&gt; variable. In this way QDoc avoids spending time reading irrelevant files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed979007a1c43ad6e1c65933f5ff78d1bf33f42" translate="yes" xml:space="preserve">
          <source>When processing the source files specified in the &lt;a href=&quot;#sourcedirs&quot;&gt;&lt;code&gt;sourcedirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;sources.fileextensions&lt;/code&gt; variable. In this way QDoc avoid spending time reading irrelevant files.</source>
          <target state="translated">При обработке исходных файлов, указанных в переменной &lt;a href=&quot;#sourcedirs&quot;&gt; &lt;code&gt;sourcedirs&lt;/code&gt; &lt;/a&gt; , QDoc будет читать только файлы с расширениями файлов, указанными в переменной &lt;code&gt;sources.fileextensions&lt;/code&gt; . Таким образом QDoc не тратит время на чтение ненужных файлов.</target>
        </trans-unit>
        <trans-unit id="cfdcd3052995a6aaff22f71ef5141edb96daddb2" translate="yes" xml:space="preserve">
          <source>When processing the source files specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs&quot;&gt;&lt;code&gt;sourcedirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;sources.fileextensions&lt;/code&gt; variable. In this way QDoc avoid spending time reading irrelevant files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b3725626f2e2c1e184c3a3386769f3ccdb3009" translate="yes" xml:space="preserve">
          <source>When properties are defined on a &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; subclass, their NOTIFY signal will automatically generate notifications that the Qt3D backend aspects will receive.</source>
          <target state="translated">Когда свойства определены в подклассе &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; , их сигнал NOTIFY будет автоматически генерировать уведомления, которые будут получать серверные аспекты Qt3D.</target>
        </trans-unit>
        <trans-unit id="c17f593088b99a91dc585e42d8e3fdd068f8c76c" translate="yes" xml:space="preserve">
          <source>When properties are defined on a QNode subclass, their NOTIFY signal will automatically generate notifications that the Qt3D backend aspects will receive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22650f203b3bc55d65cd8bcc3c197b3e1ae94f80" translate="yes" xml:space="preserve">
          <source>When protecting for a short-term operation, it is acceptable to call &lt;a href=&quot;qlockfile#lock&quot;&gt;lock&lt;/a&gt;() and wait until any running operation finishes. When protecting a resource over a long time, however, the application should always call &lt;a href=&quot;qlockfile#setStaleLockTime&quot;&gt;setStaleLockTime&lt;/a&gt;(0) and then &lt;a href=&quot;qlockfile#tryLock&quot;&gt;tryLock&lt;/a&gt;() with a short timeout, in order to warn the user that the resource is locked.</source>
          <target state="translated">При защите от краткосрочной операции допустимо вызвать &lt;a href=&quot;qlockfile#lock&quot;&gt;lock&lt;/a&gt; () и дождаться завершения любой выполняющейся операции. Однако при длительной защите ресурса приложение всегда должно вызывать &lt;a href=&quot;qlockfile#setStaleLockTime&quot;&gt;setStaleLockTime&lt;/a&gt; (0), а затем &lt;a href=&quot;qlockfile#tryLock&quot;&gt;tryLock&lt;/a&gt; () с коротким таймаутом, чтобы предупредить пользователя о том, что ресурс заблокирован.</target>
        </trans-unit>
        <trans-unit id="12b6bb01343a6f269ac19359f22a3d9b836dd641" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as &lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute::defaultPositionAttributeName&lt;/a&gt;() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">При предоставлении ваших собственных атрибутов может иметь смысл назвать ваш атрибут с помощью таких помощников, как &lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute :: defaultPositionAttributeName&lt;/a&gt; (), поскольку это обеспечит совместимость вашей геометрии с подборкой и различными материалами, предоставленными в модуле &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c5031580380ec45abd2184625b064726bd7956e" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as &lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute::defaultPositionAttributeName&lt;/a&gt;() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83204666112336ac2cd938437ecd85c2c9e42c43" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as QAttribute::defaultPositionAttributeName() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">При предоставлении ваших собственных атрибутов может иметь смысл назвать ваш атрибут с помощью таких помощников, как QAttribute :: defaultPositionAttributeName (), поскольку это обеспечит совместимость вашей геометрии с подборкой и различными материалами, предоставленными в модуле &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f0b771b8b6122f451fd39a4eec632c95f8abf9c" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as QAttribute::defaultPositionAttributeName() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be4e2868f53c5c712c37033765565589dd9a696" translate="yes" xml:space="preserve">
          <source>When qmake is run, an &lt;code&gt;Info.plist&lt;/code&gt; file is generated with appropriate default values.</source>
          <target state="translated">При запуске qmake создается файл &lt;code&gt;Info.plist&lt;/code&gt; с соответствующими значениями по умолчанию.</target>
        </trans-unit>
        <trans-unit id="deaab1579f95ca0cb54a7c45e2f6602842f9bf55" translate="yes" xml:space="preserve">
          <source>When qmake processes the project file, it will generate a Makefile rule to allow the project to be built in both modes. This can be invoked in the following way:</source>
          <target state="translated">Когда qmake обрабатывает файл проекта,он генерирует правило Makefile,позволяющее собрать проект в обоих режимах.Это правило может быть вызвано следующим образом:</target>
        </trans-unit>
        <trans-unit id="433bf4e26978749cad77ae5bdc38533c0acb441e" translate="yes" xml:space="preserve">
          <source>When queries are generated to be executed on the database only those fields for which &lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;isGenerated&lt;/a&gt;() is true are included in the generated SQL.</source>
          <target state="translated">Когда создаются запросы для выполнения в базе данных, только те поля, для которых &lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;isGenerated&lt;/a&gt; () истинно, включаются в сгенерированный SQL.</target>
        </trans-unit>
        <trans-unit id="9333afa0fced835478399e93823c406d22de675b" translate="yes" xml:space="preserve">
          <source>When quoting is disabled, these types are printed without quotation characters and without escaping of non-printable characters.</source>
          <target state="translated">При отключении кавычек эти типы печатаются без кавычек и без экранирования непечатаемых символов.</target>
        </trans-unit>
        <trans-unit id="2e3a5904501c88a29777d21a5ea08bedba058dd9" translate="yes" xml:space="preserve">
          <source>When reading from QByteArray(), the &lt;a href=&quot;qcborstreamreader#addData&quot;&gt;addData&lt;/a&gt;() function automatically calls this function. Calling it when the reading had not failed is a no-op.</source>
          <target state="translated">При чтении из QByteArray () &lt;a href=&quot;qcborstreamreader#addData&quot;&gt;функция addData&lt;/a&gt; () автоматически вызывает эту функцию. Вызывать его, когда чтение не было ошибочным, нельзя.</target>
        </trans-unit>
        <trans-unit id="2961583e309be088817f7af5160b0e7c63f99641" translate="yes" xml:space="preserve">
          <source>When reading, the end-of-line terminators are translated to '\n'. When writing, the end-of-line terminators are translated to the local encoding, for example '\r\n' for Win32.</source>
          <target state="translated">При чтении терминаторы в конце строки переводятся на &quot;\n&quot;.При чтении концевые терминаторы переводятся в локальную кодировку,например '\r\n' для Win32.</target>
        </trans-unit>
        <trans-unit id="0178fb06130fa3ace5f0116314a30ba2905b8155" translate="yes" xml:space="preserve">
          <source>When receiving an input method event, the text widget has to performs the following steps:</source>
          <target state="translated">При получении события метода ввода текстовый виджет должен выполнить следующие действия:</target>
        </trans-unit>
        <trans-unit id="bc54aed1354ce805c861b084074c4b15f2941b02" translate="yes" xml:space="preserve">
          <source>When registered with QML in this way, they can be used as property types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de85969ab467e39090e43789eb7746771150552" translate="yes" xml:space="preserve">
          <source>When registered with the QML engine in this way, they can be used as property types:</source>
          <target state="translated">При такой регистрации в движке QML они могут быть использованы как типы свойств:</target>
        </trans-unit>
        <trans-unit id="658aa3d331e786b5cf19cdc003900fc565a01ebd" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#insertColumns&quot;&gt;insertColumns&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">При повторной реализации &lt;a href=&quot;qabstractitemmodel#insertColumns&quot;&gt;insertColumns&lt;/a&gt; () в подклассе вы должны вызвать эту функцию</target>
        </trans-unit>
        <trans-unit id="4c93d0d6698e3e63d88035f6f5efca5fb6102f1c" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#insertRows&quot;&gt;insertRows&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">При повторной реализации &lt;a href=&quot;qabstractitemmodel#insertRows&quot;&gt;insertRows&lt;/a&gt; () в подклассе вы должны вызвать эту функцию</target>
        </trans-unit>
        <trans-unit id="85d1f3aba6b52c7b19fa00f7d1afc309113e34b8" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#removeColumns&quot;&gt;removeColumns&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">При повторной реализации &lt;a href=&quot;qabstractitemmodel#removeColumns&quot;&gt;removeColumns&lt;/a&gt; () в подклассе вы должны вызвать эту функцию</target>
        </trans-unit>
        <trans-unit id="f37a182e5a69ec7aec2bf70e9e8e6c7db8177d59" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#removeRows&quot;&gt;removeRows&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">При повторной реализации &lt;a href=&quot;qabstractitemmodel#removeRows&quot;&gt;removeRows&lt;/a&gt; () в подклассе вы должны вызвать эту функцию</target>
        </trans-unit>
        <trans-unit id="9b0330becdc29ff2c73cb6957330004540cba4dd" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; functions that take a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; parameter, you often need to cast the &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; to a subclass (e.g., &lt;a href=&quot;qstyleoptionfocusrect&quot;&gt;QStyleOptionFocusRect&lt;/a&gt;). For safety, you can use &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() to ensure that the pointer type is correct. If the object isn't of the right type, &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() returns &lt;code&gt;nullptr&lt;/code&gt;. For example:</source>
          <target state="translated">При повторной реализации функций &lt;a href=&quot;qstyle&quot;&gt;QStyle,&lt;/a&gt; которые принимают параметр &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; , вам часто необходимо &lt;a href=&quot;qstyleoption&quot;&gt;преобразовать QStyleOption&lt;/a&gt; в подкласс (например, &lt;a href=&quot;qstyleoptionfocusrect&quot;&gt;QStyleOptionFocusRect&lt;/a&gt; ). В целях безопасности вы можете использовать &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt; (), чтобы убедиться, что тип указателя правильный. Если объект не того типа, &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt; () возвращает &lt;code&gt;nullptr&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="9dfc851c4dac23e39db3f903a4238131999a47c4" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; functions that take a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; parameter, you often need to cast the &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; to a subclass. For safety, you can use &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() to ensure that the pointer type is correct. For example:</source>
          <target state="translated">При повторной реализации функций &lt;a href=&quot;qstyle&quot;&gt;QStyle,&lt;/a&gt; которые принимают параметр &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; , вам часто необходимо &lt;a href=&quot;qstyleoption&quot;&gt;преобразовать QStyleOption&lt;/a&gt; в подкласс. В целях безопасности вы можете использовать &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt; (), чтобы убедиться, что тип указателя правильный. Например:</target>
        </trans-unit>
        <trans-unit id="7c3a36cf890d4e609cd3054eba937187efb84074" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; functions that take a QStyleOption parameter, you often need to cast the QStyleOption to a subclass. For safety, you can use &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() to ensure that the pointer type is correct. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec235ac06dbbca492dcbe4cfde2eff2f73ed2863" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyleditemdelegate#paint&quot;&gt;paint&lt;/a&gt;(), one would typically handle the datatypes one would like to draw and use the superclass implementation for other types.</source>
          <target state="translated">При повторной реализации &lt;a href=&quot;qstyleditemdelegate#paint&quot;&gt;paint&lt;/a&gt; () обычно обрабатываются типы данных, которые нужно рисовать, и используется реализация суперкласса для других типов.</target>
        </trans-unit>
        <trans-unit id="fb3e42362330e9b7392e5e0ebae5fafed9a1a17a" translate="yes" xml:space="preserve">
          <source>When reimplementing a subclass, this method simplifies moving entities in your model. This method is responsible for moving persistent indexes in the model, which you would otherwise be required to do yourself. Using beginMoveColumns and &lt;a href=&quot;qabstractitemmodel#endMoveColumns&quot;&gt;endMoveColumns&lt;/a&gt; is an alternative to emitting &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt; and &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt; directly along with &lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt;.</source>
          <target state="translated">При повторной реализации подкласса этот метод упрощает перемещение объектов в вашей модели. Этот метод отвечает за перемещение постоянных индексов в модели, что в противном случае вам пришлось бы делать самостоятельно. Использование beginMoveColumns и &lt;a href=&quot;qabstractitemmodel#endMoveColumns&quot;&gt;endMoveColumns&lt;/a&gt; является альтернативой &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;отправке layoutAboutToBeChanged&lt;/a&gt; и &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt; непосредственно вместе с &lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37d54556abfd5846d3b883b6100f1fa44ae8b968" translate="yes" xml:space="preserve">
          <source>When reimplementing a subclass, this method simplifies moving entities in your model. This method is responsible for moving persistent indexes in the model, which you would otherwise be required to do yourself. Using beginMoveRows and &lt;a href=&quot;qabstractitemmodel#endMoveRows&quot;&gt;endMoveRows&lt;/a&gt; is an alternative to emitting &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt; and &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt; directly along with &lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt;.</source>
          <target state="translated">При повторной реализации подкласса этот метод упрощает перемещение объектов в вашей модели. Этот метод отвечает за перемещение постоянных индексов в модели, что в противном случае вам пришлось бы делать самостоятельно. Использование beginMoveRows и &lt;a href=&quot;qabstractitemmodel#endMoveRows&quot;&gt;endMoveRows&lt;/a&gt; является альтернативой &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;отправке layoutAboutToBeChanged&lt;/a&gt; и &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt; непосредственно вместе с &lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca95dc0c0eb787c2eeed20255a0cb245f62492af" translate="yes" xml:space="preserve">
          <source>When reimplementing canRead(), make sure that the I/O device (&lt;a href=&quot;qimageiohandler#device&quot;&gt;device&lt;/a&gt;()) is left in its original state (e.g., by using peek() rather than &lt;a href=&quot;qimageiohandler#read&quot;&gt;read&lt;/a&gt;()).</source>
          <target state="translated">При повторной реализации canRead () убедитесь, что устройство ввода-вывода ( &lt;a href=&quot;qimageiohandler#device&quot;&gt;device&lt;/a&gt; ()) осталось в исходном состоянии (например, с помощью peek () вместо &lt;a href=&quot;qimageiohandler#read&quot;&gt;read&lt;/a&gt; ()).</target>
        </trans-unit>
        <trans-unit id="028d93193544c8ed47ad98dfeadb939c5667b03b" translate="yes" xml:space="preserve">
          <source>When reimplementing paint in a subclass. Use the &lt;a href=&quot;qstyleditemdelegate#initStyleOption&quot;&gt;initStyleOption&lt;/a&gt;() to set up the</source>
          <target state="translated">При повторной реализации краски в подклассе. Используйте &lt;a href=&quot;qstyleditemdelegate#initStyleOption&quot;&gt;initStyleOption&lt;/a&gt; (), чтобы настроить</target>
        </trans-unit>
        <trans-unit id="df7f5f683e515c4160cc8d6065b4b4913422655c" translate="yes" xml:space="preserve">
          <source>When reimplementing the &lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData&lt;/a&gt;() function, this signal must be emitted explicitly.</source>
          <target state="translated">При повторной реализации функции &lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData&lt;/a&gt; () этот сигнал должен быть испущен явно.</target>
        </trans-unit>
        <trans-unit id="6f516d38e016de108e31954fe638b31e63f64384" translate="yes" xml:space="preserve">
          <source>When reimplementing the &lt;a href=&quot;qabstractitemmodel#setHeaderData&quot;&gt;setHeaderData&lt;/a&gt;() function, this signal must be emitted explicitly.</source>
          <target state="translated">При повторной реализации функции &lt;a href=&quot;qabstractitemmodel#setHeaderData&quot;&gt;setHeaderData&lt;/a&gt; () этот сигнал должен быть испущен явно.</target>
        </trans-unit>
        <trans-unit id="8bb42c54f45079c9c25f1595264e446c8f5dae51" translate="yes" xml:space="preserve">
          <source>When reimplementing the &lt;a href=&quot;qeventtransition#eventTest&quot;&gt;eventTest&lt;/a&gt;() function, you should first call the base implementation to verify that the event is a &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine::WrappedEvent&lt;/a&gt; for the proper object and event type. You may then cast the event to a &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine::WrappedEvent&lt;/a&gt; and get the original event by calling &lt;a href=&quot;qstatemachine-wrappedevent#event&quot;&gt;QStateMachine::WrappedEvent::event&lt;/a&gt;(), and perform additional checks on that object.</source>
          <target state="translated">При повторной реализации функции &lt;a href=&quot;qeventtransition#eventTest&quot;&gt;eventTest&lt;/a&gt; () вы должны сначала вызвать базовую реализацию, чтобы убедиться, что событие является &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine :: WrappedEvent&lt;/a&gt; для правильного объекта и типа события. Затем вы можете &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;преобразовать&lt;/a&gt; событие в QStateMachine :: WrappedEvent и получить исходное событие, вызвав &lt;a href=&quot;qstatemachine-wrappedevent#event&quot;&gt;QStateMachine :: WrappedEvent :: event&lt;/a&gt; (), и выполнить дополнительные проверки этого объекта.</target>
        </trans-unit>
        <trans-unit id="b124ac10b911b199139a9b1396e9a53e131374c7" translate="yes" xml:space="preserve">
          <source>When reimplementing this class, take care to return at least one element.</source>
          <target state="translated">При повторном внедрении этого класса позаботьтесь о возвращении,по крайней мере,одного элемента.</target>
        </trans-unit>
        <trans-unit id="55e2b93bd22d4647e3de872d6613c4f4629fae05" translate="yes" xml:space="preserve">
          <source>When reimplementing this function in a subclass, be careful to avoid calling &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; member functions, such as &lt;a href=&quot;qmodelindex#parent&quot;&gt;QModelIndex::parent&lt;/a&gt;(), since indexes belonging to your model will simply call your implementation, leading to infinite recursion.</source>
          <target state="translated">При повторной реализации этой функции в подклассе будьте осторожны, чтобы избежать вызова функций-членов &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; , таких как &lt;a href=&quot;qmodelindex#parent&quot;&gt;QModelIndex :: parent&lt;/a&gt; (), поскольку индексы, принадлежащие вашей модели, просто вызовут вашу реализацию, что приведет к бесконечной рекурсии.</target>
        </trans-unit>
        <trans-unit id="70e5caa7bbddd6d74b4efb7d8a7005f9825d497b" translate="yes" xml:space="preserve">
          <source>When reimplementing this function in a subclass, call &lt;a href=&quot;qabstractitemmodel#createIndex&quot;&gt;createIndex&lt;/a&gt;() to generate model indexes that other components can use to refer to items in your model.</source>
          <target state="translated">При повторной реализации этой функции в подклассе вызовите &lt;a href=&quot;qabstractitemmodel#createIndex&quot;&gt;createIndex&lt;/a&gt; () для генерации индексов модели, которые другие компоненты могут использовать для ссылки на элементы в вашей модели.</target>
        </trans-unit>
        <trans-unit id="ba7f9d147f366305cacefe9a55e635566170bc6d" translate="yes" xml:space="preserve">
          <source>When reimplementing this function in a subclass, you should update the area held by the option's &lt;a href=&quot;qstyleoption#rect-var&quot;&gt;rect&lt;/a&gt; variable, using the option's &lt;a href=&quot;qstyleoption#state-var&quot;&gt;state&lt;/a&gt; variable to determine the state of the item to be displayed, and adjust the way it is painted accordingly.</source>
          <target state="translated">При повторной реализации этой функции в подклассе вы должны обновить область, содержащуюся в переменной &lt;a href=&quot;qstyleoption#rect-var&quot;&gt;rect&lt;/a&gt; параметра, используя переменную &lt;a href=&quot;qstyleoption#state-var&quot;&gt;состояния&lt;/a&gt; параметра, чтобы определить состояние отображаемого элемента и соответствующим образом настроить способ его отображения.</target>
        </trans-unit>
        <trans-unit id="4e2d2f89b79fefee58d5613beec7b9bd5dde6fb5" translate="yes" xml:space="preserve">
          <source>When reimplementing this function it is important that this function reads all the required data before returning. This is required in order for &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; to be able to operate on the class. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; assumes all the requested information was read and therefore does not retry reading if there was a problem.</source>
          <target state="translated">При повторной реализации этой функции важно, чтобы эта функция считывала все необходимые данные перед возвратом. Это необходимо для того, чтобы &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; мог работать с классом. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; предполагает, что вся запрошенная информация была прочитана, и поэтому не пытается повторить чтение, если возникла проблема.</target>
        </trans-unit>
        <trans-unit id="e93d19bd100346fac19905c7b4a51959378ca55b" translate="yes" xml:space="preserve">
          <source>When reimplementing this function it is important that this function writes all the data available before returning. This is required in order for &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; to be able to operate on the class. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; assumes all the information was written and therefore does not retry writing if there was a problem.</source>
          <target state="translated">При повторной реализации этой функции важно, чтобы эта функция записывала все доступные данные перед возвратом. Это необходимо для того, чтобы &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; мог работать с классом. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; предполагает, что вся информация была записана, и поэтому не повторяет попытку записи, если возникла проблема.</target>
        </trans-unit>
        <trans-unit id="dbe06314296a3392519e885c147e88b10b0594de" translate="yes" xml:space="preserve">
          <source>When reimplementing this function, note that in case of text items, &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; adds a margin (i.e. 2 * &lt;a href=&quot;qstyle#PixelMetric-enum&quot;&gt;QStyle::PM_FocusFrameHMargin&lt;/a&gt;) to the length of the text.</source>
          <target state="translated">При повторной реализации этой функции обратите внимание, что в случае текстовых элементов &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; добавляет поле (т.е. 2 * &lt;a href=&quot;qstyle#PixelMetric-enum&quot;&gt;QStyle :: PM_FocusFrameHMargin&lt;/a&gt; ) к длине текста.</target>
        </trans-unit>
        <trans-unit id="197ccf9da55fd735f9643d4ab74a6bddeec9dfb0" translate="yes" xml:space="preserve">
          <source>When reimplementing this function, the &lt;a href=&quot;qabstractitemmodel#headerDataChanged&quot;&gt;headerDataChanged&lt;/a&gt;() signal must be emitted explicitly.</source>
          <target state="translated">При повторной реализации этой функции сигнал &lt;a href=&quot;qabstractitemmodel#headerDataChanged&quot;&gt;headerDataChanged&lt;/a&gt; () должен быть испущен явно.</target>
        </trans-unit>
        <trans-unit id="89a145bd42509fd307493a0a0013f21ce6e0557c" translate="yes" xml:space="preserve">
          <source>When relative paths are specified, qmake will mangle them into a form understood by the dynamic linker to be relative to the location of the referring executable or library. This is supported only by some platforms (currently Linux and Darwin-based ones) and is detectable by checking whether &lt;a href=&quot;#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE&lt;/a&gt; is set.</source>
          <target state="translated">Когда указаны относительные пути, qmake будет преобразовывать их в форму, которую динамический компоновщик понимает как относительную к местоположению ссылающегося исполняемого файла или библиотеки. Это поддерживается только некоторыми платформами (в настоящее время Linux и платформы Darwin) и обнаруживается проверкой, установлен ли &lt;a href=&quot;#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2230aceb836e5f2b704deb69243134974a878df" translate="yes" xml:space="preserve">
          <source>When relative paths are specified, qmake will mangle them into a form understood by the dynamic linker to be relative to the location of the referring executable or library. This is supported only by some platforms (currently Linux and Darwin-based ones) and is detectable by checking whether &lt;a href=&quot;qmake-variable-reference#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE&lt;/a&gt; is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b737ba18762f9d815ad8cc904c2c8daeaec43e4b" translate="yes" xml:space="preserve">
          <source>When rendering graphics, the matrix defines the transformations but the actual transformation is performed by the drawing routines in &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;.</source>
          <target state="translated">При визуализации графики матрица определяет преобразования, но фактическое преобразование выполняется процедурами рисования в &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c5109171a737854a9ba5a71e30fd9bd78572ca4" translate="yes" xml:space="preserve">
          <source>When rendering with a pen with an even number of pixels, the pixels will be rendered symetrically around the mathematical defined points, while rendering with a pen with an odd number of pixels, the spare pixel will be rendered to the right and below the mathematical point as in the one pixel case. See the &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; diagrams below for concrete examples.</source>
          <target state="translated">При рендеринге пером с четным числом пикселей пиксели будут отображаться симметрично вокруг математически определенных точек, при рендеринге с помощью пера с нечетным количеством пикселей резервный пиксель будет отображаться справа и ниже математической точки как в случае с одним пикселем. См. Конкретные примеры на диаграммах &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="f6bb9fd28f420249ac748ef0297e189cfdea3c23" translate="yes" xml:space="preserve">
          <source>When rendering with a two pixels wide pen the boundary line will be split in the middle by the mathematical rectangle. This will be the case whenever the pen is set to an even number of pixels, while rendering with a pen with an odd number of pixels, the spare pixel will be rendered to the right and below the mathematical rectangle as in the one pixel case.</source>
          <target state="translated">При рендеринге пером шириной в два пиксела граничная линия будет разделена посередине математическим прямоугольником.Это произойдёт,когда перо будет установлено на четное число пикселей,а при рендеринге ручкой с нечётным числом пикселей запасной пиксель будет рендеринговаться справа и под математическим прямоугольником,как в случае с одним пикселем.</target>
        </trans-unit>
        <trans-unit id="d7e0077b12f54b280554348b8d31ed612bede88e" translate="yes" xml:space="preserve">
          <source>When rendering, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; protects the painter state (see &lt;a href=&quot;qpainter#save&quot;&gt;QPainter::save&lt;/a&gt;()) when rendering the background or foreground, and when rendering each item. This allows you to leave the painter in an altered state (i.e., you can call &lt;a href=&quot;qpainter#setPen&quot;&gt;QPainter::setPen&lt;/a&gt;() or &lt;a href=&quot;qpainter#setBrush&quot;&gt;QPainter::setBrush&lt;/a&gt;() without restoring the state after painting). However, if the items consistently do restore the state, you should enable this flag to prevent &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; from doing the same.</source>
          <target state="translated">При рендеринге &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; защищает состояние рисовальщика (см. &lt;a href=&quot;qpainter#save&quot;&gt;QPainter :: save&lt;/a&gt; ()) при рендеринге фона или переднего плана, а также при рендеринге каждого элемента. Это позволяет вам оставить рисовальщик в измененном состоянии (т.е. вы можете вызвать &lt;a href=&quot;qpainter#setPen&quot;&gt;QPainter :: setPen&lt;/a&gt; () или &lt;a href=&quot;qpainter#setBrush&quot;&gt;QPainter :: setBrush&lt;/a&gt; () без восстановления состояния после рисования). Однако, если элементы постоянно восстанавливают состояние, вы должны включить этот флаг, чтобы &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView не&lt;/a&gt; делал то же самое.</target>
        </trans-unit>
        <trans-unit id="d51a24d95c26c19a346a37f3dd7e864ef01ea9d8" translate="yes" xml:space="preserve">
          <source>When rendering, Graphics View's scene coordinates correspond to &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s</source>
          <target state="translated">При визуализации координаты сцены графического представления соответствуют &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; &amp;laquo;с</target>
        </trans-unit>
        <trans-unit id="b351cd57358f6774989d1cb0e0f8f4b5f818e8c3" translate="yes" xml:space="preserve">
          <source>When requesting an index for a model item, we must provide some information about the item's parent. Outside the model, the only way to refer to an item is through a model index, so a parent model index must also be given:</source>
          <target state="translated">При запросе индекса для элемента модели,мы должны предоставить некоторую информацию о родителе элемента.Вне модели,единственный способ ссылки на элемент-через индекс модели,поэтому необходимо также указать индекс родительской модели:</target>
        </trans-unit>
        <trans-unit id="e3462b37efc9ed9435b6be891fff238475c5b943" translate="yes" xml:space="preserve">
          <source>When resizeEvent() is called, the viewport already has its new geometry: Its new size is accessible through the &lt;a href=&quot;qresizeevent#size&quot;&gt;QResizeEvent::size&lt;/a&gt;() function, and the old size through &lt;a href=&quot;qresizeevent#oldSize&quot;&gt;QResizeEvent::oldSize&lt;/a&gt;().</source>
          <target state="translated">Когда вызывается resizeEvent (), у области просмотра уже есть новая геометрия: его новый размер доступен через &lt;a href=&quot;qresizeevent#size&quot;&gt;функцию QResizeEvent :: size&lt;/a&gt; (), а старый размер - через &lt;a href=&quot;qresizeevent#oldSize&quot;&gt;QResizeEvent :: oldSize&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="459145d7e5e0a2dddcfe14e374a8a522472aa332" translate="yes" xml:space="preserve">
          <source>When returning from C++, the engine will interrupt the normal flow of execution and call the the next pre-registered exception handler with an error object that contains the given</source>
          <target state="translated">При возвращении из C++движок прервет нормальный поток выполнения и вызовет следующий предварительно зарегистрированный обработчик исключения с объектом ошибки,который содержит заданный</target>
        </trans-unit>
        <trans-unit id="90d305ada35629da8b28508d253830cb3271219a" translate="yes" xml:space="preserve">
          <source>When rubberband selection ends this signal will be emitted with null vales.</source>
          <target state="translated">По окончании выбора резинового диапазона этот сигнал будет излучаться с нулевыми значениями.</target>
        </trans-unit>
        <trans-unit id="d7d3ba7b84a869b7ec4d6428c30a1e381f521d40" translate="yes" xml:space="preserve">
          <source>When run in a Norwegian locale, this code could for instance display &quot;Price is kr 6,00&quot; for a one-dollar product.</source>
          <target state="translated">При запуске в норвежской местности этот код может,например,отображать &quot;Цена 6,00 кр&quot; за однодолларовое изделие.</target>
        </trans-unit>
        <trans-unit id="f4b4ea8160e44027a1643f73bd2b4fc24a630c0f" translate="yes" xml:space="preserve">
          <source>When running QDoc to generate HTML, the example above will have no effect on the generated output, but if you run QDoc to generate DITA XML, the example will generate the following:</source>
          <target state="translated">При запуске QDoc для генерации HTML,пример выше не будет иметь никакого влияния на генерируемый вывод,но если вы запустите QDoc для генерации DITA XML,то пример будет генерировать следующее:</target>
        </trans-unit>
        <trans-unit id="313916658b849b20eb8b38c2b36d5a604ba7482c" translate="yes" xml:space="preserve">
          <source>When running QDoc to generate HTML, the example above will have no effect on the generated output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68eca509dfd034e35a8f7fa47ec0779beae30c64" translate="yes" xml:space="preserve">
          <source>When running Qt Web Engine examples in a Docker container and browsing content-heavy sites, BUS errors (SIGBUS) might be reported. Typically, this is caused by Docker running a container with a too small memory space (such as 64MB). To fix this problem, increase the memory space size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba74a44a4fe513e0e864500ccf8b7805d12bdf2c" translate="yes" xml:space="preserve">
          <source>When running the advertising procedure, a number of parameters can be configured, such as how fast to advertise or which clients, if any, can connect to the advertising device. These parameters are set via this class, and their values will be used when advertising is started by calling &lt;a href=&quot;qlowenergycontroller#startAdvertising&quot;&gt;QLowEnergyController::startAdvertising&lt;/a&gt;().</source>
          <target state="translated">При запуске процедуры рекламы можно настроить ряд параметров, например, как быстро рекламировать или какие клиенты, если таковые имеются, могут подключиться к рекламному устройству. Эти параметры устанавливаются через этот класс, и их значения будут использоваться при запуске рекламы путем вызова &lt;a href=&quot;qlowenergycontroller#startAdvertising&quot;&gt;QLowEnergyController :: startAdvertising&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="1e481bcca4c1c2d1651c8ca7889240a246da99ad" translate="yes" xml:space="preserve">
          <source>When running with the OpenGL backend of Qt Quick, both the generic, triangulation-based and the NVIDIA-specific &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; methods are available. By default only the generic approach is used. Setting Shape.&lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt; property to &lt;code&gt;true&lt;/code&gt; leads to using NV_path_rendering on NVIDIA systems when running directly on OpenGL, and the generic method on others. When OpenGL is not used directly by the scene graph, for example because it is using the graphics abstraction layer (QRhi), only the generic shape renderer is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419ca242c0e809f26e319a45853b06288d62f271" translate="yes" xml:space="preserve">
          <source>When running with the OpenGL backend of the scene graph, &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; offers the possibility to disable persistent OpenGL contexts as well. This setting is currently ignored by &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; and the context is always persistent. The OpenGL context is thus not destroyed when hiding the widget. The context is destroyed only when the widget is destroyed or when the widget gets reparented into another top-level widget's child hierarchy. However, some applications, in particular those that have their own graphics resources due to performing custom OpenGL rendering in the Qt Quick scene, may wish to disable the latter since they may not be prepared to handle the loss of the context when moving a &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; into another window. Such applications can set the QCoreApplication::AA_ShareOpenGLContexts attribute. For a discussion on the details of resource initialization and cleanup, refer to the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; documentation.</source>
          <target state="translated">При работе с бэкэндом OpenGL графа сцены &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow также&lt;/a&gt; предлагает возможность отключить постоянные контексты OpenGL. Этот параметр в настоящее время игнорируется &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget,&lt;/a&gt; и контекст всегда постоянен . Таким образом, контекст OpenGL не разрушается при скрытии виджета. Контекст уничтожается только тогда, когда виджет уничтожается или когда виджет переименовывается в дочернюю иерархию другого виджета верхнего уровня. Однако некоторые приложения, в частности те, которые имеют свои собственные графические ресурсы из-за выполнения настраиваемого рендеринга OpenGL в сцене Qt Quick, могут пожелать отключить последнее, поскольку они могут быть не готовы обрабатывать потерю контекста при перемещении &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;в другое окно. Такие приложения могут устанавливать атрибут QCoreApplication :: AA_ShareOpenGLContexts. Для обсуждения деталей инициализации и очистки ресурсов обратитесь к документации &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31fa69229e2655989faeea8c24fbc639c55aaf43" translate="yes" xml:space="preserve">
          <source>When running with the OpenGL backend of the scene graph, &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; offers the possibility to disable persistent OpenGL contexts as well. This setting is currently ignored by QQuickWidget and the context is always persistent. The OpenGL context is thus not destroyed when hiding the widget. The context is destroyed only when the widget is destroyed or when the widget gets reparented into another top-level widget's child hierarchy. However, some applications, in particular those that have their own graphics resources due to performing custom OpenGL rendering in the Qt Quick scene, may wish to disable the latter since they may not be prepared to handle the loss of the context when moving a QQuickWidget into another window. Such applications can set the QCoreApplication::AA_ShareOpenGLContexts attribute. For a discussion on the details of resource initialization and cleanup, refer to the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4180cc40e3670129f26ab3b8aa7583731a04bc4b" translate="yes" xml:space="preserve">
          <source>When running with the default, OpenGL backend of Qt Quick, both the generic, triangulation-based and the NVIDIA-specific &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; methods are available. By default only the generic approach is used. Setting Shape.&lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt; property to &lt;code&gt;true&lt;/code&gt; leads to using NV_path_rendering on NVIDIA systems, and the generic method on others.</source>
          <target state="translated">При работе с &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; OpenGL Qt Quick по умолчанию доступны как общие, основанные на триангуляции, так и специфичные для NVIDIA методы GL_NV_path_rendering . По умолчанию используется только общий подход. Настройка формы. &lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt; значение &lt;code&gt;true&lt;/code&gt; приводит к использованию NV_path_rendering в системах NVIDIA и универсального метода в других.</target>
        </trans-unit>
        <trans-unit id="22c17b7b950b81783fdb923684eedfd560adcd81" translate="yes" xml:space="preserve">
          <source>When runtime compilation is not in use and the shader properties refer to files with bytecode, the status is always Compiled. The contents of the shader is not examined (apart from basic reflection to discover vertex input elements and constant buffer data) until later in the rendering pipeline so potential errors (like layout or root signature mismatches) will only be detected at a later point.</source>
          <target state="translated">Когда компиляция во время выполнения не используется и свойства шейдера относятся к файлам с байткодом,статус всегда компилируется.Содержимое шейдера не проверяется (кроме основных отражений для обнаружения входных элементов вершин и постоянных данных буфера)до тех пор,пока позже в конвейере рендеринга не будут обнаружены потенциальные ошибки (такие как несовпадение компоновки или корневых сигнатур)только на более позднем этапе.</target>
        </trans-unit>
        <trans-unit id="1cf799c203f3447ab5ee733162b36bb8365e9dec" translate="yes" xml:space="preserve">
          <source>When saving a form in</source>
          <target state="translated">При сохранении формы в</target>
        </trans-unit>
        <trans-unit id="1e9c03991883db6f31187fbe5c35791a719629dc" translate="yes" xml:space="preserve">
          <source>When saving places between managers, there are a few things to be aware of. Some fields of a place such as the id, categories and icons are manager specific entities for example the categories in one manager may not be recognized in another. Therefore trying to save a place directly from one manager to another is not possible.</source>
          <target state="translated">При сохранении мест между менеджерами,есть несколько вещей,о которых следует помнить.Некоторые поля места,такие как id,категории и иконки,являются специфическими для менеджера сущностями,например,категории в одном менеджере могут быть не распознаны в другом.Поэтому попытка сохранить место непосредственно от одного менеджера к другому невозможна.</target>
        </trans-unit>
        <trans-unit id="65dee2f6abcd14dfb6ffc451b8eef9d4e59664a3" translate="yes" xml:space="preserve">
          <source>When saving places between plugins, there are a few things to be aware of. Some fields of a place such as the id, categories and icons are plugin specific entities. For example the categories in one manager may not be recognised in another. Therefore trying to save a place directly from one plugin to another is not possible.</source>
          <target state="translated">При сохранении мест между плагинами,есть несколько вещей,о которых следует помнить.Некоторые поля места,такие как id,категории и значки,являются сущностями плагина.Например,категории в одном менеджере могут быть не распознаны в другом.Поэтому попытка сохранить место прямо из одного плагина в другой невозможна.</target>
        </trans-unit>
        <trans-unit id="16335d2940c0a9a4d44f0bf7877e3be7c7a4c25b" translate="yes" xml:space="preserve">
          <source>When scheduling cleanup of graphics resources using &lt;a href=&quot;qquickwindow#scheduleRenderJob&quot;&gt;QQuickWindow::scheduleRenderJob&lt;/a&gt;(), one should use either &lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow::BeforeSynchronizingStage&lt;/a&gt; or &lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow::AfterSynchronizingStage&lt;/a&gt;. The &lt;a href=&quot;qtquick-visualcanvas-scenegraph#scene-graph-and-rendering&quot;&gt;synchronization stage&lt;/a&gt; is where the scene graph is changed as a result of changes to the QML tree. If cleanup is scheduled at any other time, it may result in other parts of the scene graph referencing the newly deleted objects as these parts have not been updated.</source>
          <target state="translated">При планировании очистки графических ресурсов с помощью &lt;a href=&quot;qquickwindow#scheduleRenderJob&quot;&gt;QQuickWindow :: scheduleRenderJob&lt;/a&gt; () следует использовать либо &lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow :: BeforeSynchronizingStage,&lt;/a&gt; либо &lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow :: AfterSynchronizingStage&lt;/a&gt; . На &lt;a href=&quot;qtquick-visualcanvas-scenegraph#scene-graph-and-rendering&quot;&gt;этапе синхронизации&lt;/a&gt; граф сцены изменяется в результате изменений в дереве QML. Если очистка запланирована в любое другое время, это может привести к тому, что другие части графа сцены будут ссылаться на недавно удаленные объекты, поскольку эти части не были обновлены.</target>
        </trans-unit>
        <trans-unit id="0470cdb483508ebc7b70959dbd94540db4bc9c18" translate="yes" xml:space="preserve">
          <source>When sections are used, the first section command should be &lt;code&gt;section1&lt;/code&gt;.</source>
          <target state="translated">Когда используются разделы, первая команда раздела должна быть &lt;code&gt;section1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5eedde8058556feb6cb3beeca59e7888ae6ece9" translate="yes" xml:space="preserve">
          <source>When selection is changed by clicking on the graph</source>
          <target state="translated">При изменении выбора кликом по графику</target>
        </trans-unit>
        <trans-unit id="00867511fe8868752b9e077a7707775ae9c1971d" translate="yes" xml:space="preserve">
          <source>When selection is changed explicitly via series API to a visible item</source>
          <target state="translated">При явном изменении выбора через API серии на видимый элемент</target>
        </trans-unit>
        <trans-unit id="2e1af7d1ebff8ce0a52ad99867add45c86a6ae89" translate="yes" xml:space="preserve">
          <source>When sending CAN FD frames, this flag is automatically set by the CAN FD hardware. &lt;code&gt;QCanBusFrame::setErrorStateIndicator()&lt;/code&gt; should only be used for application testing, e.g. on virtual CAN FD busses.</source>
          <target state="translated">При отправке кадров CAN FD этот флаг автоматически устанавливается оборудованием CAN FD. &lt;code&gt;QCanBusFrame::setErrorStateIndicator()&lt;/code&gt; следует использовать только для тестирования приложений, например, на виртуальных шинах CAN FD.</target>
        </trans-unit>
        <trans-unit id="357729db045ad04ca40ebade91b854125d77106d" translate="yes" xml:space="preserve">
          <source>When sending CAN bus frames with &lt;a href=&quot;qcanbusdevice#ConfigurationKey-enum&quot;&gt;QCanBusDevice::ReceiveOwnKey&lt;/a&gt; enabled, all successfully sent frames are echoed to the receive queue and marked as local echo frames. &lt;code&gt;QCanBusFrame::setLocalEcho&lt;/code&gt; should therefore only be used for application testing, e.g. on virtual CAN busses.</source>
          <target state="translated">При отправке кадров шины CAN с &lt;a href=&quot;qcanbusdevice#ConfigurationKey-enum&quot;&gt;включенным QCanBusDevice :: ReceiveOwnKey&lt;/a&gt; все успешно отправленные кадры отражаются в очереди приема и помечаются как локальные эхо-кадры. &lt;code&gt;QCanBusFrame::setLocalEcho&lt;/code&gt; следует использовать только для тестирования приложений, например, на виртуальных шинах CAN.</target>
        </trans-unit>
        <trans-unit id="8bae5e50b5bdda4bb33ef7b2b1936a5c7112c234" translate="yes" xml:space="preserve">
          <source>When sending requests, to control the preference of when to use the cache and when to use the network, consider the following:</source>
          <target state="translated">При отправке запросов,чтобы контролировать предпочтения,когда использовать кэш и когда использовать сеть,учитывайте следующее:</target>
        </trans-unit>
        <trans-unit id="73e7c0c4bd2ed4ad850a956107fc733151db2cb3" translate="yes" xml:space="preserve">
          <source>When sending, the &lt;a href=&quot;qnetworkdatagram#senderAddress&quot;&gt;senderAddress&lt;/a&gt;() and &lt;a href=&quot;qnetworkdatagram#senderPort&quot;&gt;senderPort&lt;/a&gt;() should contain the local address to be used when sending. The sender address must be an address that is assigned to this machine, which can be obtained using &lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface&lt;/a&gt;, and the port number must be the port number that the socket is bound to. Either field can be left unset and will be filled in by the operating system with default values. The &lt;a href=&quot;qnetworkdatagram#destinationAddress&quot;&gt;destinationAddress&lt;/a&gt;() and &lt;a href=&quot;qnetworkdatagram#destinationPort&quot;&gt;destinationPort&lt;/a&gt;() fields may be set to a target address different from the one the UDP socket is currently associated with.</source>
          <target state="translated">При отправке &lt;a href=&quot;qnetworkdatagram#senderAddress&quot;&gt;senderAddress&lt;/a&gt; () и &lt;a href=&quot;qnetworkdatagram#senderPort&quot;&gt;senderPort&lt;/a&gt; () должны содержать локальный адрес, который будет использоваться при отправке. Адрес отправителя должен быть адресом, назначенным этому компьютеру, который можно получить с помощью &lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface&lt;/a&gt; , а номер порта должен быть номером порта, к которому привязан сокет. Любое поле можно не задавать, и оно будет заполнено операционной системой значениями по умолчанию. &lt;a href=&quot;qnetworkdatagram#destinationAddress&quot;&gt;DestinationAddress&lt;/a&gt; () и &lt;a href=&quot;qnetworkdatagram#destinationPort&quot;&gt;DestinationPort&lt;/a&gt; () поля могут быть установлены на целевой адрес , отличный от одного сокета UDP , в данный момент , связанный с.</target>
        </trans-unit>
        <trans-unit id="bbc34b6972fd5a95f0e17a1bedd0814ddeba5170" translate="yes" xml:space="preserve">
          <source>When serialized item data is dropped onto a view, the data is inserted into the current model using its implementation of &lt;a href=&quot;qabstractitemmodel#dropMimeData&quot;&gt;QAbstractItemModel::dropMimeData&lt;/a&gt;(). The default implementation of this function will never overwrite any data in the model; instead, it tries to insert the items of data either as siblings of an item, or as children of that item.</source>
          <target state="translated">Когда сериализованные данные элемента &lt;a href=&quot;qabstractitemmodel#dropMimeData&quot;&gt;перетаскиваются&lt;/a&gt; в представление, данные вставляются в текущую модель с использованием ее реализации QAbstractItemModel :: dropMimeData (). Реализация этой функции по умолчанию никогда не перезапишет какие-либо данные в модели; вместо этого он пытается вставить элементы данных либо как родственники элемента, либо как дочерние элементы этого элемента.</target>
        </trans-unit>
        <trans-unit id="beb64bc37ef9e620c83f8575bbe6997166c3df77" translate="yes" xml:space="preserve">
          <source>When set on the characterFormat of a selection, the whole width of the text will be shown selected.</source>
          <target state="translated">При установке на символФормат выделения будет показана вся ширина текста.</target>
        </trans-unit>
        <trans-unit id="270afeac1ae23334323cbd52bdb23f45e70ed478" translate="yes" xml:space="preserve">
          <source>When set to &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;AutomaticOrientation&lt;/a&gt;, the reading values are automatically rotated when the screen orientation changes. In effect, the screen orientation is canceled out.</source>
          <target state="translated">Если задано значение &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;AutomaticOrientation&lt;/a&gt; , значения показаний автоматически поворачиваются при изменении ориентации экрана. Фактически, ориентация экрана отменяется.</target>
        </trans-unit>
        <trans-unit id="e194e2df3cef00cb337af8c19d0b1fb4566ff905" translate="yes" xml:space="preserve">
          <source>When set to &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;FixedOrientation&lt;/a&gt;, which is the default mode, no automatic rotation is applied to the reading. This is the only mode available for backends that do not support the &lt;a href=&quot;qsensor#Feature-enum&quot;&gt;QSensor::AxesOrientation&lt;/a&gt; feature.</source>
          <target state="translated">Если задано значение &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;FixedOrientation&lt;/a&gt; , которое является режимом по умолчанию, автоматическое вращение к показаниям не применяется. Это единственный режим, доступный для серверных &lt;a href=&quot;qsensor#Feature-enum&quot;&gt;ВМ,&lt;/a&gt; которые не поддерживают функцию QSensor :: AxesOrientation .</target>
        </trans-unit>
        <trans-unit id="f8c2be01f19679d844258975f1b00add910e8c48" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;1&lt;/code&gt;, Qt grabs the device for exclusive use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35fbd74909144bf9e11c35c0ff6fab64956af13b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;false&lt;/code&gt;, rendering is done in single pass. In this mode the depth buffer is not used at all, and all objects are rendered in a single back to front pass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c4e86e296a0003f811fe8398c8194c0172e276" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;transparent&lt;/code&gt;, no filling occurs.</source>
          <target state="translated">Когда установлен &lt;code&gt;transparent&lt;/code&gt; , заливка не происходит.</target>
        </trans-unit>
        <trans-unit id="a494091a2d78c1c83239a6f4b1f78cd17e064c58" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;transparent&lt;/code&gt;, no stroking occurs.</source>
          <target state="translated">Если установлено значение &amp;laquo; &lt;code&gt;transparent&lt;/code&gt; , обводка не выполняется.</target>
        </trans-unit>
        <trans-unit id="d01263f2091d195480c96c2d03450e33391dffb1" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the exterior of the item is padded with a 1 pixel wide transparent edge, making sampling outside the source texture use transparency instead of the edge pixels. Without this property, an image which has opaque edges will not get a blurred shadow.</source>
          <target state="translated">Если задано значение &lt;code&gt;true&lt;/code&gt; , внешняя часть элемента дополняется прозрачным краем шириной 1 пиксель, в результате чего выборка вне исходной текстуры использует прозрачность вместо краевых пикселей. Без этого свойства изображение с непрозрачными краями не получит размытой тени.</target>
        </trans-unit>
        <trans-unit id="b450467a36089b6e8cc7c9384688033053a7e1e0" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the exterior of the item is padded with a transparent edge, making sampling outside the source texture use transparency instead of the edge pixels. Without this property, an image which has opaque edges will not get a blurred edge.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , внешняя часть элемента дополняется прозрачным краем, в результате чего выборка за пределами исходной текстуры использует прозрачность вместо краевых пикселей. Без этого свойства изображение с непрозрачными краями не получит размытых краев.</target>
        </trans-unit>
        <trans-unit id="e4147d132167beace31a7c2f2898d532610dfada" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set column categories and overwrites them with automatically generated ones whenever the data from model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если задано значение &lt;code&gt;true&lt;/code&gt; , сопоставление игнорирует любые явно заданные категории столбцов и перезаписывает их автоматически сгенерированными при каждом разрешении данных из модели. По умолчанию &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36e27ee6dcb20f63a267c063b5f0dd2344ea8112" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set column categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , сопоставление игнорирует любые явно заданные категории столбцов и перезаписывает их автоматически сгенерированными категориями всякий раз, когда разрешаются данные из модели. По умолчанию &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aeaf1add3a3c03b3752ea390e4de636b57ce02e7" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set column categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Proxy minimum and maximum column values are also autogenerated from the data when this is set to &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , сопоставление игнорирует любые явно заданные категории столбцов и перезаписывает их автоматически сгенерированными категориями всякий раз, когда разрешаются данные из модели. Минимальные и максимальные значения столбца прокси также автоматически генерируются из данных, если для него установлено значение &lt;code&gt;true&lt;/code&gt; . По умолчанию &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c86619e8213d5bed1738d02c582750355d6522a4" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set row categories and overwrites them with automatically generated ones whenever the data from model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , отображение игнорирует любые явно заданные категории строк и перезаписывает их автоматически сгенерированными категориями всякий раз, когда разрешаются данные из модели. По умолчанию &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d11c86fa7ccfd6ba9e683cd50f0c094403577ac1" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set row categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , сопоставление игнорирует любые явно заданные категории строк и перезаписывает их автоматически сгенерированными категориями всякий раз, когда разрешаются данные из модели. По умолчанию &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1301757ff1650814b570b349ec4348010d05817d" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set row categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Proxy minimum and maximum row values are also autogenerated from the data when this is set to &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , сопоставление игнорирует любые явно заданные категории строк и перезаписывает их автоматически сгенерированными категориями всякий раз, когда разрешаются данные из модели. Минимальные и максимальные значения строки прокси также автоматически генерируются из данных, если для него установлено значение &lt;code&gt;true&lt;/code&gt; . По умолчанию &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7acc0959296f9d8e8c2e2b6cb1d3a66719167a16" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores row and column roles and categories, and uses the rows and columns from the model instead. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , сопоставление игнорирует роли и категории строк и столбцов и вместо этого использует строки и столбцы из модели. По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f951719e1af643c50c67762d555cf0e850cebdd" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores row and column roles and categories, and uses the rows and columns from the model instead. Row and column headers are used for row and column labels. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , сопоставление игнорирует роли и категории строк и столбцов и вместо этого использует строки и столбцы из модели. Заголовки строк и столбцов используются для подписей строк и столбцов. По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3496a774f53b66ac5b73d84b633a1d9d7d924d85" translate="yes" xml:space="preserve">
          <source>When set to a negative value, no stroking occurs.</source>
          <target state="translated">При установке отрицательного значения поглаживание не происходит.</target>
        </trans-unit>
        <trans-unit id="4e4ee14f2ec2d88c31367b1d93f593e8267881e4" translate="yes" xml:space="preserve">
          <source>When set to an empty string, the default label of the underlying platform is used. The default label is typically &lt;b&gt;Cancel&lt;/b&gt;.</source>
          <target state="translated">Если задана пустая строка, используется метка по умолчанию базовой платформы. Ярлык по умолчанию обычно - &lt;b&gt;Отмена&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="71b7a30cacf1f3a3ee6a4172e8fb4bd21a402ed0" translate="yes" xml:space="preserve">
          <source>When set to an empty string, the default label of the underlying platform is used. The default label is typically &lt;b&gt;Open&lt;/b&gt; or &lt;b&gt;Save&lt;/b&gt; depending on which &lt;a href=&quot;qml-qt-labs-platform-filedialog#fileMode-prop&quot;&gt;fileMode&lt;/a&gt; the dialog is used in.</source>
          <target state="translated">Если задана пустая строка, используется метка по умолчанию базовой платформы. Метка по умолчанию обычно &lt;b&gt;Open&lt;/b&gt; или &lt;b&gt;Save в&lt;/b&gt; зависимости от того, в каком &lt;a href=&quot;qml-qt-labs-platform-filedialog#fileMode-prop&quot;&gt;fileMode&lt;/a&gt; используется диалоговое окно.</target>
        </trans-unit>
        <trans-unit id="fa9215824a888cc448b2b5104b3e0edb6ca3f827" translate="yes" xml:space="preserve">
          <source>When set to an empty string, the default label of the underlying platform is used. The default label is typically &lt;b&gt;Open&lt;/b&gt;.</source>
          <target state="translated">Если задана пустая строка, используется метка по умолчанию базовой платформы. Ярлык по умолчанию обычно &lt;b&gt;открыт&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="da31d475a6141d1527e3930e3b780117133be781" translate="yes" xml:space="preserve">
          <source>When set to true, a connection is made to the server with the given url. When set to false, the connection is closed. The default value is false.</source>
          <target state="translated">Если установлено значение true,соединение с сервером осуществляется с заданным url.Если установлено значение false,соединение закрывается.Значение по умолчанию равно false.</target>
        </trans-unit>
        <trans-unit id="d356d95380e0a7be709c939454d729283fff95fe" translate="yes" xml:space="preserve">
          <source>When set to true, updates are blocked and remote clients will not be notified about property changes.</source>
          <target state="translated">Если установлено значение true,обновления блокируются,и удаленные клиенты не будут уведомлены об изменениях свойств.</target>
        </trans-unit>
        <trans-unit id="9070c24af14ff16b55ce450d03070776a1d63544" translate="yes" xml:space="preserve">
          <source>When set, &lt;a href=&quot;qml-qtquick-shapes-shapepath&quot;&gt;ShapePath&lt;/a&gt;.&lt;a href=&quot;qml-qtquick-shapes-shapepath#fillColor-prop&quot;&gt;fillColor&lt;/a&gt; is ignored and filling is done using one of the &lt;a href=&quot;qml-qtquick-shapes-shapegradient&quot;&gt;ShapeGradient&lt;/a&gt; subtypes.</source>
          <target state="translated">Когда установлено, &lt;a href=&quot;qml-qtquick-shapes-shapepath&quot;&gt;ShapePath&lt;/a&gt; . &lt;a href=&quot;qml-qtquick-shapes-shapepath#fillColor-prop&quot;&gt;fillColor&lt;/a&gt; игнорируется, а заливка выполняется с использованием одного из подтипов &lt;a href=&quot;qml-qtquick-shapes-shapegradient&quot;&gt;ShapeGradient&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d5a93253ef1915d6faa59a1fad7ff2aba883814" translate="yes" xml:space="preserve">
          <source>When set, &lt;code&gt;eglfs&lt;/code&gt; requests &lt;code&gt;FBIO_WAITFORVSYNC&lt;/code&gt; on the framebuffer device after each call to eglSwapBuffers(). This variable is only relevant for backends relying on the legacy Linux &lt;code&gt;fbdev&lt;/code&gt; subsystem. Normally, with a default swap interval of 1, Qt assumes that calling eglSwapBuffers() takes care of vsync; if it doesn't (for example, due to driver bugs), try setting &lt;code&gt;QT_QPA_EGLFS_FORCEVSYNC&lt;/code&gt; to a non-zero value.</source>
          <target state="translated">Если установлено, &lt;code&gt;eglfs&lt;/code&gt; запрашивает &lt;code&gt;FBIO_WAITFORVSYNC&lt;/code&gt; на устройстве кадрового буфера после каждого вызова eglSwapBuffers (). Эта переменная актуальна только для серверных программ, использующих устаревшую подсистему Linux &lt;code&gt;fbdev&lt;/code&gt; . Обычно с интервалом подкачки по умолчанию, равным 1, Qt предполагает, что вызов eglSwapBuffers () заботится о vsync; если это не так (например, из-за ошибок драйвера), попробуйте установить &lt;code&gt;QT_QPA_EGLFS_FORCEVSYNC&lt;/code&gt; на ненулевое значение.</target>
        </trans-unit>
        <trans-unit id="9744299b5e8df688636dffff69d9ac6cfe828468" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by column role before it is used as a column category. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt; property contains the replacement string. This is useful for example in parsing row and column categories from a single timestamp field in the item model.</source>
          <target state="translated">Если задано, поиск и замена выполняются по значению, отображаемому ролью столбца, прежде чем оно будет использовано в качестве категории столбца. Это свойство указывает регулярное выражение для поиска части сопоставленного значения для замены, а свойство &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt; содержит заменяющую строку. Это полезно, например, при синтаксическом анализе категорий строк и столбцов из одного поля временной метки в модели элемента.</target>
        </trans-unit>
        <trans-unit id="8a131bdf52627ee3b863efe9743b906a421ee8f9" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by rotation role before it is used as a bar rotation angle. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">Если установлено, поиск и замена выполняются для значения, отображаемого ролью вращения, прежде чем оно будет использовано в качестве угла поворота стержня. Это свойство указывает регулярное выражение для поиска части сопоставленного значения для замены, а свойство &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt; содержит заменяющую строку.</target>
        </trans-unit>
        <trans-unit id="9108433232a1c54c0f0add6d2c59552f382b7483" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by row role before it is used as a row category. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt; property contains the replacement string. This is useful for example in parsing row and column categories from a single timestamp field in the item model.</source>
          <target state="translated">Если задано, поиск и замена выполняются для значения, отображаемого ролью строки, прежде чем оно будет использовано в качестве категории строки. Это свойство определяет регулярное выражение для поиска части сопоставленного значения для замены, а свойство &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt; содержит заменяющую строку. Это полезно, например, при синтаксическом анализе категорий строк и столбцов из одного поля временной метки в модели элемента.</target>
        </trans-unit>
        <trans-unit id="bc9c1cbcb787214aaefb29b1ef7ac7fde2064a50" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the column role before it is used as a column category. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">Если задано, поиск и замена выполняются для значения, отображаемого ролью столбца, прежде чем оно будет использовано в качестве категории столбца. Это свойство указывает регулярное выражение для поиска заменяемой части сопоставленного значения, а свойство &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt; содержит заменяющую строку.</target>
        </trans-unit>
        <trans-unit id="6c6f75996ea55b81eb144da97f4ddbf1f7b8d2df" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the rotation role before it is used as item rotation. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">Если установлено, поиск и замена выполняются на значении, отображаемом ролью вращения, прежде чем оно будет использовано в качестве вращения элемента. Это свойство указывает регулярное выражение для поиска части сопоставленного значения для замены, а свойство &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt; содержит заменяющую строку.</target>
        </trans-unit>
        <trans-unit id="4d7bce4ff7100e6fa830173aafe199aab62b818f" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the row role before it is used as a row category. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">Если установлено, поиск и замена выполняются по значению, отображаемому ролью строки, прежде чем оно будет использовано в качестве категории строки. Это свойство определяет регулярное выражение для поиска части сопоставленного значения для замены, а свойство &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt; содержит заменяющую строку.</target>
        </trans-unit>
        <trans-unit id="885cf3aa8085356e119ac0af240743c4239afe83" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the x position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">Если установлено, поиск и замена выполняются для значения, отображаемого ролью x-позиции, прежде чем оно будет использовано в качестве значения позиции элемента. Это свойство определяет регулярное выражение для поиска части сопоставленного значения для замены, а свойство &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt; содержит заменяющую строку.</target>
        </trans-unit>
        <trans-unit id="66303afda7fe28b42306b119120f8c9d8ffe13b2" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the x position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">Если установлено, поиск и замена выполняются для значения, отображаемого ролью x-позиции, прежде чем оно будет использовано в качестве значения позиции элемента. Это свойство указывает регулярное выражение для поиска части сопоставленного значения для замены, а свойство &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt; содержит строку замены.</target>
        </trans-unit>
        <trans-unit id="177b7625ed57441e9caab15b1ba52de1056c1697" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the y position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">Если установлено, поиск и замена выполняются для значения, отображаемого ролью позиции y, прежде чем оно будет использовано в качестве значения позиции элемента. Это свойство указывает регулярное выражение для поиска части сопоставленного значения для замены, а свойство &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt; содержит строку замены.</target>
        </trans-unit>
        <trans-unit id="4cd4628ea893e9ef8db7b0e103b8b8eb84582ee7" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the y position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">Если установлено, поиск и замена выполняются для значения, отображаемого ролью позиции y, прежде чем оно будет использовано в качестве значения позиции элемента. Это свойство указывает регулярное выражение для поиска части сопоставленного значения для замены, а свойство &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt; содержит заменяющую строку.</target>
        </trans-unit>
        <trans-unit id="e690058b1d8c0f0ea729f77975b58803689a29ce" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the z position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">Когда установлено, поиск и замена выполняются для значения, отображаемого ролью z-позиции, прежде чем оно будет использовано в качестве значения позиции элемента. Это свойство указывает регулярное выражение для поиска части сопоставленного значения для замены, а свойство &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt; содержит строку замены.</target>
        </trans-unit>
        <trans-unit id="8a50a48a136eb418621caa5d9975fa8698821525" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the z position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">Когда установлено, поиск и замена выполняются для значения, отображаемого ролью z-позиции, прежде чем оно будет использовано в качестве значения позиции элемента. Это свойство указывает регулярное выражение для поиска части сопоставленного значения для замены, а свойство &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt; содержит заменяющую строку.</target>
        </trans-unit>
        <trans-unit id="9e6e26fa69d41d9769f5fde960eb52cd2c8473db" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by value role before it is used as a bar value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#valueRoleReplace-prop&quot;&gt;valueRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">Если установлено, поиск и замена выполняются для значения, отображаемого ролью значения, прежде чем оно будет использоваться в качестве значения полосы. Это свойство определяет регулярное выражение для поиска части сопоставленного значения для замены, а свойство &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#valueRoleReplace-prop&quot;&gt;valueRoleReplace&lt;/a&gt; содержит заменяющую строку.</target>
        </trans-unit>
        <trans-unit id="57e671691d58c18370650113c81b9894428ab1c0" translate="yes" xml:space="preserve">
          <source>When set, some debugging information is printed on the debug output. For example, the input &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; and the properties of the chosen EGL configuration are printed while creating a new context. When used together with Qt Quick's &lt;code&gt;QSG_INFO&lt;/code&gt; variable, you can get useful information for troubleshooting issues related to the EGL configuration.</source>
          <target state="translated">Когда установлено, некоторая отладочная информация печатается в отладочных выводах. Например, входной &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; и свойства выбранной конфигурации EGL распечатываются при создании нового контекста. При использовании вместе с переменной &lt;code&gt;QSG_INFO&lt;/code&gt; Qt Quick вы можете получить полезную информацию для устранения проблем, связанных с конфигурацией EGL.</target>
        </trans-unit>
        <trans-unit id="c63ec68c079a9bce145854c06f681928a4a99fb9" translate="yes" xml:space="preserve">
          <source>When set, the red, green, and blue color channel sizes are ignored when &lt;code&gt;eglfs&lt;/code&gt; creates a new context, window or offscreen surface. Instead, the plugin requests a configuration with 8 bits per channel. This can be helpful on devices where configurations with less than 32 or 24 bits per pixel (for example, 5-6-5 or 4-4-4) are chosen by default despite knowing they are not ideal, for example, due to banding effects. Instead of changing application code, this variable provides a shortcut to force 24 or 32 bpp configurations.</source>
          <target state="translated">Если установлено, размеры канала красного, зеленого и синего цветов игнорируются, когда &lt;code&gt;eglfs&lt;/code&gt; создает новый контекст, окно или поверхность вне экрана . Вместо этого плагин запрашивает конфигурацию с 8 битами на канал. Это может быть полезно на устройствах, где конфигурации с менее чем 32 или 24 битами на пиксель (например, 5-6-5 или 4-4-4) выбираются по умолчанию, несмотря на то, что известно, что они не идеальны, например, из-за полосатости последствия. Вместо изменения кода приложения эта переменная предоставляет ярлык для принудительной настройки конфигурации с 24 или 32 битами на пиксель.</target>
        </trans-unit>
        <trans-unit id="33b3bd9431a5daf3aec6eea2743d997f576dc8d8" translate="yes" xml:space="preserve">
          <source>When setting &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item::clip&lt;/a&gt; to true, it will create a &lt;a href=&quot;qsgclipnode&quot;&gt;QSGClipNode&lt;/a&gt; with a rectangle in its geometry. The default renderer will apply this clip by using scissoring in OpenGL. If the item is rotated by a non-90-degree angle, the OpenGL's stencil buffer is used. Qt Quick Item only supports setting a rectangle as clip through QML, but the scene graph API and the default renderer can use any shape for clipping.</source>
          <target state="translated">Если для &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item :: clip установлено&lt;/a&gt; значение true, он создаст &lt;a href=&quot;qsgclipnode&quot;&gt;QSGClipNode&lt;/a&gt; с прямоугольником в его геометрии. Средство визуализации по умолчанию применит этот клип, используя обрезку в OpenGL. Если элемент повернут на угол, отличный от 90 градусов, используется буфер трафарета OpenGL. Qt Quick Item поддерживает только установку прямоугольника в качестве обрезки через QML, но API графа сцены и средство визуализации по умолчанию могут использовать любую форму для обрезки.</target>
        </trans-unit>
        <trans-unit id="a5ed62e892daca59bcdf47a39598aaed448ddccb" translate="yes" xml:space="preserve">
          <source>When setting a maximum date, the &lt;a href=&quot;qcalendarwidget#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; and &lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt; properties are adjusted if the selection range becomes invalid. If the provided date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, the setMaximumDate() function does nothing.</source>
          <target state="translated">При установке максимальной даты свойства &lt;a href=&quot;qcalendarwidget#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; и &lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt; корректируются, если диапазон выбора становится недопустимым. Если предоставленная дата не является действительным &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; объекта, функция setMaximumDate () ничего не делает.</target>
        </trans-unit>
        <trans-unit id="c4ae2d023320be5119694dfde25d7c2125941c8d" translate="yes" xml:space="preserve">
          <source>When setting a minimum date, the &lt;a href=&quot;qcalendarwidget#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; and &lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt; properties are adjusted if the selection range becomes invalid. If the provided date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, the setMinimumDate() function does nothing.</source>
          <target state="translated">При установке минимальной даты свойства &lt;a href=&quot;qcalendarwidget#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; и &lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt; корректируются, если диапазон выбора становится недопустимым. Если предоставленная дата не является действительным &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; объекта, функция setMinimumDate () ничего не делает.</target>
        </trans-unit>
        <trans-unit id="6eeb8a01ae2a0c99098eee6b5e541fd874b03835" translate="yes" xml:space="preserve">
          <source>When setting the fragment or vertex shader source code, the status will become Uncompiled. The first time the &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt; is rendered with new shader source code, the shaders are compiled and linked, and the status is updated to Compiled or Error.</source>
          <target state="translated">При установке исходного кода фрагмента или вершинного шейдера статус станет Uncompiled. При первом &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;рендеринге ShaderEffect&lt;/a&gt; с новым исходным кодом шейдера шейдеры компилируются и связываются, а статус обновляется на Compiled или Error.</target>
        </trans-unit>
        <trans-unit id="12bc8cc3889504df656aec89fdae8d32b48b48bd" translate="yes" xml:space="preserve">
          <source>When setting the pick method to &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;AllPicks&lt;/a&gt;, events will be triggered for all the entities with a &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; along the ray.</source>
          <target state="translated">При установке метода выбора &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;AllPicks&lt;/a&gt; события будут запускаться для всех сущностей с &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; вдоль луча.</target>
        </trans-unit>
        <trans-unit id="faf0f4e80eb610da479dd49899491179142a9cfd" translate="yes" xml:space="preserve">
          <source>When setting the pick method to &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;NearestPriorityPick&lt;/a&gt;, events will be triggered for the nearest highest priority picker. This can be used when a given element should always be selected even if others are in front of it.</source>
          <target state="translated">При установке метода выбора на &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;NearestPriorityPick&lt;/a&gt; события будут инициироваться для ближайшего средства выбора с наивысшим приоритетом. Это можно использовать, когда данный элемент всегда должен быть выбран, даже если другие находятся перед ним.</target>
        </trans-unit>
        <trans-unit id="46eaad0ccb2bedbfcbdda653384c06947cbb2dbb" translate="yes" xml:space="preserve">
          <source>When setting the year using the Date constructor or set(UTC)FullYear(), the convention set by ISO 8601 is used and 0 is a valid year. This means negative years set with the constructor or set(UTC)FullYear() are zero-based and thus offset by one year from what is printed with toString() and friends. Parsing the output of any of the to*String() methods will yield the same date value you printed from. Date.parse() will recognize the different formats and their convention on the existence of year 0.</source>
          <target state="translated">При установке года с помощью конструктора Date или set(UTC)FullYear(),используется соглашение,установленное ISO 8601 и 0 является действительным годом.Это означает,что отрицательные годы,установленные с помощью конструктора или set(UTC)FullYear(),являются нулевыми и,таким образом,смещены на один год от того,что напечатано с помощью функции toString()и друзей.При разборе вывода любого из методов to*String()будет получено то же самое значение даты,из которой вы распечатали.Date.parse()распознает различные форматы и их соглашение о существовании года 0.</target>
        </trans-unit>
        <trans-unit id="99af14a2050e900c54b4cf4320044307dba2671c" translate="yes" xml:space="preserve">
          <source>When setting this property &lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt; tries to find a document with the specified name in the paths of the &lt;a href=&quot;qtextbrowser#searchPaths-prop&quot;&gt;searchPaths&lt;/a&gt; property and directory of the current source, unless the value is an absolute file path. It also checks for optional anchors and scrolls the document accordingly</source>
          <target state="translated">При установке этого свойства &lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt; пытается найти документ с указанным именем в дорожках &lt;a href=&quot;qtextbrowser#searchPaths-prop&quot;&gt;SearchPaths&lt;/a&gt; собственности и каталог текущего источника, если значение не абсолютный путь к файлу. Он также проверяет наличие дополнительных привязок и соответственно прокручивает документ.</target>
        </trans-unit>
        <trans-unit id="fce20a64ddb9efcd0a6072a5a5807d0354c99c5b" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; is adjusted if necessary, to ensure that the range remains valid. If the date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">При установке этого свойства &lt;a href=&quot;qdatetimeedit#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; при необходимости корректируется, чтобы гарантировать, что диапазон остается допустимым. Если дата не является допустимым объектом &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; , эта функция ничего не делает.</target>
        </trans-unit>
        <trans-unit id="f3536a246a03f23af815f636527d6ffa980281bd" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#maximumDateTime-prop&quot;&gt;maximumDateTime&lt;/a&gt;() is adjusted if necessary to ensure that the range remains valid. If the datetime is not a valid &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">При установке этого свойства &lt;a href=&quot;qdatetimeedit#maximumDateTime-prop&quot;&gt;maximumDateTime&lt;/a&gt; () при необходимости корректируется, чтобы гарантировать, что диапазон остается допустимым. Если datetime не является допустимым объектом &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; , эта функция ничего не делает.</target>
        </trans-unit>
        <trans-unit id="1d3985b1214032de5548d5f37a050ce05224466f" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#maximumTime-prop&quot;&gt;maximumTime&lt;/a&gt; is adjusted if necessary, to ensure that the range remains valid. If the time is not a valid &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">При установке этого свойства &lt;a href=&quot;qdatetimeedit#maximumTime-prop&quot;&gt;maximumTime&lt;/a&gt; при необходимости корректируется, чтобы диапазон оставался допустимым. Если время не является допустимым объектом &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; , эта функция ничего не делает.</target>
        </trans-unit>
        <trans-unit id="3a94d8175867d402a4937ec027013411408a4199" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">При установке этого свойства &lt;a href=&quot;qdatetimeedit#minimumDate-prop&quot;&gt;минимальная дата&lt;/a&gt; при необходимости корректируется, чтобы гарантировать, что диапазон остается допустимым. Если дата не является допустимым объектом &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; , эта функция ничего не делает.</target>
        </trans-unit>
        <trans-unit id="d00e3ae41e62b165ec366eabf69c76f997cb71bc" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#minimumDateTime-prop&quot;&gt;minimumDateTime&lt;/a&gt;() is adjusted if necessary to ensure that the range remains valid. If the datetime is not a valid &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">При установке этого свойства &lt;a href=&quot;qdatetimeedit#minimumDateTime-prop&quot;&gt;minimumDateTime&lt;/a&gt; () при необходимости корректируется, чтобы гарантировать, что диапазон остается допустимым. Если datetime не является допустимым объектом &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; , эта функция ничего не делает.</target>
        </trans-unit>
        <trans-unit id="fd101378453eccdf2e848a4824798dd5c0a85b7e" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdoublespinbox#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid.</source>
          <target state="translated">При установке этого свойства при необходимости настраивается &lt;a href=&quot;qdoublespinbox#maximum-prop&quot;&gt;максимум&lt;/a&gt; , чтобы диапазон оставался допустимым.</target>
        </trans-unit>
        <trans-unit id="d52e2cb44d7f2ae6749696edb496d673ee39757f" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdoublespinbox#minimum-prop&quot;&gt;minimum&lt;/a&gt; is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">При установке этого свойства при необходимости регулируется &lt;a href=&quot;qdoublespinbox#minimum-prop&quot;&gt;минимум&lt;/a&gt; , чтобы диапазон оставался допустимым.</target>
        </trans-unit>
        <trans-unit id="47cfedf6ef21c709f13ba69a81ab6789fc8a9fd1" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qspinbox#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid.</source>
          <target state="translated">При установке этого свойства при необходимости настраивается &lt;a href=&quot;qspinbox#maximum-prop&quot;&gt;максимум&lt;/a&gt; , чтобы диапазон оставался допустимым.</target>
        </trans-unit>
        <trans-unit id="9b3aa09d9d597d2ccc6d81186f12b9dee43bde16" translate="yes" xml:space="preserve">
          <source>When setting this property the corresponding maximum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">При настройке этого свойства при необходимости корректируется соответствующее максимальное значение,чтобы диапазон оставался действительным.</target>
        </trans-unit>
        <trans-unit id="ed5abb02b8b1a236c42c80272c5d4f7b5e792484" translate="yes" xml:space="preserve">
          <source>When setting this property the corresponding minimum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">При настройке этого свойства при необходимости корректируется соответствующее минимальное значение,чтобы диапазон оставался действительным.</target>
        </trans-unit>
        <trans-unit id="0e2d22ffaa8c87cce0769e98c3a06583fa170f8d" translate="yes" xml:space="preserve">
          <source>When setting this property the minimum is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">При настройке этого свойства при необходимости корректируется минимум,чтобы диапазон оставался действительным.</target>
        </trans-unit>
        <trans-unit id="10bbb03412564a8a76a7faa470981f3e92871bb0" translate="yes" xml:space="preserve">
          <source>When setting this property the timespec of the &lt;a href=&quot;qdatetimeedit&quot;&gt;QDateTimeEdit&lt;/a&gt; remains the same and the timespec of the new &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; is ignored.</source>
          <target state="translated">При установке этого свойства спецификация времени &lt;a href=&quot;qdatetimeedit&quot;&gt;QDateTimeEdit&lt;/a&gt; остается прежней, а спецификация времени нового &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; игнорируется.</target>
        </trans-unit>
        <trans-unit id="2375a6809ff71a69632c1ba6bc4411bcbd56175e" translate="yes" xml:space="preserve">
          <source>When setting this property to a list of waypoints, each waypoint can be either a &lt;a href=&quot;qml-coordinate&quot;&gt;coordinate&lt;/a&gt; or a &lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;Waypoint&lt;/a&gt;, interchangeably. If a &lt;a href=&quot;qml-coordinate&quot;&gt;coordinate&lt;/a&gt; is passed, it will be internally converted to a &lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;Waypoint&lt;/a&gt;.</source>
          <target state="translated">При установке этого свойства в список путевых точек, каждая точка может быть либо &lt;a href=&quot;qml-coordinate&quot;&gt;координируют&lt;/a&gt; или &lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;путевой точки&lt;/a&gt; , взаимозаменяемые. Если &lt;a href=&quot;qml-coordinate&quot;&gt;координата&lt;/a&gt; передана, она будет внутренне преобразована в &lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;путевую точку&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c08c05c4f9a6cc8ebd2fa6d3ff3659b0e8d5359" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qabstractslider#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. Also the slider's current value is adjusted to be within the new range.</source>
          <target state="translated">При установке этого свойства при необходимости настраивается &lt;a href=&quot;qabstractslider#maximum-prop&quot;&gt;максимум&lt;/a&gt; , чтобы диапазон оставался допустимым. Также текущее значение ползунка корректируется, чтобы находиться в новом диапазоне.</target>
        </trans-unit>
        <trans-unit id="083344e77b31d85a0b5a8a8283eca8fda3876952" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qabstractslider#minimum-prop&quot;&gt;minimum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. Also the slider's current value is adjusted to be within the new range.</source>
          <target state="translated">При установке этого свойства при необходимости корректируется &lt;a href=&quot;qabstractslider#minimum-prop&quot;&gt;минимум&lt;/a&gt; , чтобы диапазон оставался допустимым. Также текущее значение ползунка корректируется, чтобы находиться в новом диапазоне.</target>
        </trans-unit>
        <trans-unit id="890b98dfbcb1358977a7219adcd63ac2cd2c0980" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qdatetimeedit#minimumTime-prop&quot;&gt;minimumTime&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the time is not a valid &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">При установке этого свойства &lt;a href=&quot;qdatetimeedit#minimumTime-prop&quot;&gt;минимальное время&lt;/a&gt; корректируется, если необходимо, чтобы диапазон оставался допустимым. Если время не является допустимым объектом &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; , эта функция ничего не делает.</target>
        </trans-unit>
        <trans-unit id="fa2c9bb906ff3305eef76e88d6b8655a32b982f4" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qml-qtcharts-pieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">При установке этого свойства свойство &lt;a href=&quot;qml-qtcharts-pieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt; при необходимости корректируется, чтобы размер отверстия не превышал размер круговой диаграммы.</target>
        </trans-unit>
        <trans-unit id="f435a68f9316a9aad8d0bd9214e3829a97c2384f" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qml-qtcharts-pieseries#size-prop&quot;&gt;size&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">При установке этого свойства свойство &lt;a href=&quot;qml-qtcharts-pieseries#size-prop&quot;&gt;размера&lt;/a&gt; при необходимости корректируется, чтобы размер отверстия не превышал размер круговой диаграммы.</target>
        </trans-unit>
        <trans-unit id="2614229e0748ff7798a30ec6c9a32c8bd564129c" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qpieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">При установке этого свойства свойство &lt;a href=&quot;qpieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt; при необходимости корректируется, чтобы размер отверстия не превышал размер круговой диаграммы.</target>
        </trans-unit>
        <trans-unit id="9676bb4e1b94754c72406b0dd8f30c9729452b6c" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qpieseries#size-prop&quot;&gt;size&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">При установке этого свойства свойство &lt;a href=&quot;qpieseries#size-prop&quot;&gt;размера&lt;/a&gt; при необходимости корректируется, чтобы размер отверстия не превышал размер круговой диаграммы.</target>
        </trans-unit>
        <trans-unit id="5c4c814181687e53992d25bc4a345c8885416475" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qprogressbar#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the current value falls outside the new range, the progress bar is reset with &lt;a href=&quot;qprogressbar#reset&quot;&gt;reset&lt;/a&gt;().</source>
          <target state="translated">При установке этого свойства при необходимости настраивается &lt;a href=&quot;qprogressbar#maximum-prop&quot;&gt;максимум&lt;/a&gt; , чтобы диапазон оставался допустимым. Если текущее значение выходит за пределы нового диапазона, индикатор выполнения сбрасывается с помощью &lt;a href=&quot;qprogressbar#reset&quot;&gt;reset&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="d10bb2cee1aba8ceaf054055bf90ceea6821e2bc" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qprogressbar#minimum-prop&quot;&gt;minimum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the current value falls outside the new range, the progress bar is reset with &lt;a href=&quot;qprogressbar#reset&quot;&gt;reset&lt;/a&gt;().</source>
          <target state="translated">При установке этого свойства при необходимости корректируется &lt;a href=&quot;qprogressbar#minimum-prop&quot;&gt;минимум&lt;/a&gt; , чтобы диапазон оставался допустимым. Если текущее значение выходит за пределы нового диапазона, индикатор выполнения сбрасывается с помощью &lt;a href=&quot;qprogressbar#reset&quot;&gt;reset&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="32aea66ca6d6da71cb41f4c7cc9dc10b08e8577f" translate="yes" xml:space="preserve">
          <source>When setting this property, the maximum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">При настройке этого свойства при необходимости корректируется максимальное значение,чтобы диапазон оставался действительным.</target>
        </trans-unit>
        <trans-unit id="b951c983b0aee73e158712980739ff70f149887e" translate="yes" xml:space="preserve">
          <source>When setting this property, the maximum value is adjusted if necessary, to ensure that the range remains valid. The value has to be greater than 0.</source>
          <target state="translated">При настройке этого свойства при необходимости корректируется максимальное значение,чтобы диапазон оставался действительным.Значение должно быть больше 0.</target>
        </trans-unit>
        <trans-unit id="7a55bcbc9be43eedc7805bdbb3ee9e54f14990ff" translate="yes" xml:space="preserve">
          <source>When setting this property, the minimum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">При настройке этого свойства при необходимости корректируется минимальное значение,чтобы диапазон оставался действительным.</target>
        </trans-unit>
        <trans-unit id="c7876cf5d914de6fdd878ac65bed31fe69eb59c2" translate="yes" xml:space="preserve">
          <source>When setting this property, the minimum value is adjusted if necessary, to ensure that the range remains valid. The value has to be greater than 0.</source>
          <target state="translated">При настройке этого свойства при необходимости корректируется минимальное значение,чтобы диапазон оставался действительным.Значение должно быть больше 0.</target>
        </trans-unit>
        <trans-unit id="5de4dc53f812589029ed9067e97355562cb0e1d3" translate="yes" xml:space="preserve">
          <source>When setting up the rendering pipeline, call &lt;a href=&quot;qvulkanwindow#sampleCountFlagBits&quot;&gt;sampleCountFlagBits&lt;/a&gt;() to query the active sample count as a &lt;code&gt;VkSampleCountFlagBits&lt;/code&gt; value.</source>
          <target state="translated">При настройке конвейера рендеринга вызовите &lt;a href=&quot;qvulkanwindow#sampleCountFlagBits&quot;&gt;sampleCountFlagBits&lt;/a&gt; (), чтобы запросить счетчик активных выборок как значение &lt;code&gt;VkSampleCountFlagBits&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfcd5a5c296c55f96b9ee5da99d93a616d2b11fc" translate="yes" xml:space="preserve">
          <source>When shaders were added to this program via &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceCode&quot;&gt;addCacheableShaderFromSourceCode&lt;/a&gt;() or &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceFile&quot;&gt;addCacheableShaderFromSourceFile&lt;/a&gt;(), program binaries are supported, and a cached binary is available on disk, actual compilation and linking are skipped. Instead, link() will initialize the program with the binary blob via glProgramBinary(). If there is no cached version of the program or it was generated with a different driver version, the shaders will be compiled from source and the program will get linked normally. This allows seamless upgrading of the graphics drivers, without having to worry about potentially incompatible binary formats.</source>
          <target state="translated">Когда шейдеры были добавлены в эту программу через &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceCode&quot;&gt;addCacheableShaderFromSourceCode&lt;/a&gt; () или &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceFile&quot;&gt;addCacheableShaderFromSourceFile&lt;/a&gt; (), двоичные файлы программы поддерживаются, а кешированный двоичный файл доступен на диске, фактическая компиляция и связывание пропускаются. Вместо этого link () инициализирует программу двоичным двоичным объектом через glProgramBinary (). Если кэшированной версии программы нет или она была сгенерирована с другой версией драйвера, шейдеры будут скомпилированы из исходного кода, и программа будет связана обычным образом. Это позволяет легко обновлять графические драйверы, не беспокоясь о потенциально несовместимых двоичных форматах.</target>
        </trans-unit>
        <trans-unit id="87d3d39130885f5e5c6a9174de6513c3d33b6b27" translate="yes" xml:space="preserve">
          <source>When side-effects are unavoidable, ensure that the prior state is restored at the end of the test function, even if the test fails. This commonly requires use of an RAII (resource acquisition is initialization) class that restores state when the function returns, or a &lt;code&gt;cleanup()&lt;/code&gt; method. Do not simply put the restoration code at the end of the test. If part of the test fails, such code will be skipped and the prior state will not be restored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b2c21463a05b372aacfedaa2026900f87448ca" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; or &lt;a href=&quot;qabstractproxymodel&quot;&gt;QAbstractProxyModel&lt;/a&gt;, ensure that you emit &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt;() before changing the order of items or altering the structure of the data you expose to views, and emit layoutChanged() after changing the layout.</source>
          <target state="translated">При &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;создании&lt;/a&gt; подкласса &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; или &lt;a href=&quot;qabstractproxymodel&quot;&gt;QAbstractProxyModel&lt;/a&gt; убедитесь, что вы испускаете layoutAboutToBeChanged () перед изменением порядка элементов или структурой данных, которые вы предоставляете представлениям, и испускаете layoutChanged () после изменения макета.</target>
        </trans-unit>
        <trans-unit id="29ad4f995056d1ccd3dcee88f2d1086d0349dbfd" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;, at the very least you must implement &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). These functions are used in all read-only models, and form the basis of editable models.</source>
          <target state="translated">При создании подкласса &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; вы должны как минимум реализовать &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index&lt;/a&gt; (), &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt; (), &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt; (), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt; () и &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt; (). Эти функции используются во всех моделях только для чтения и составляют основу редактируемых моделей.</target>
        </trans-unit>
        <trans-unit id="a191eed727edc2ae03b2ab93852a02163a6c05e0" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt;, you must provide implementations of the &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;() functions. Well behaved models also provide a &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;() implementation.</source>
          <target state="translated">При создании подкласса &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; вы должны предоставить реализации функций &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt; () и &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt; (). Модели с &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;хорошим&lt;/a&gt; поведением также предоставляют реализацию headerData ().</target>
        </trans-unit>
        <trans-unit id="34ee94bbac1ecea4e8ddb454d400be8aae1e7968" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;, you must implement &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). Default implementations of the &lt;a href=&quot;qabstracttablemodel#index&quot;&gt;index&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;() functions are provided by &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;. Well behaved models will also implement &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;().</source>
          <target state="translated">При &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;создании&lt;/a&gt; подкласса &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt; вы должны реализовать rowCount (), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt; () и &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt; (). Реализации функций &lt;a href=&quot;qabstracttablemodel#index&quot;&gt;index&lt;/a&gt; () и &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt; () по умолчанию предоставляются &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt; . Модели с &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;хорошим&lt;/a&gt; поведением также будут реализовывать headerData ().</target>
        </trans-unit>
        <trans-unit id="bc5ed4ae258b22a232b577325d7a45d5a74a6ae6" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qaccessibleactioninterface&quot;&gt;QAccessibleActionInterface&lt;/a&gt; you need to provide a list of &lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionNames&lt;/a&gt; which is the primary means to discover the available actions. Action names are never localized. In order to present actions to the user there are two functions that need to return localized versions of the name and give a description of the action. For the predefined action names use &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface::localizedActionName&lt;/a&gt;() and &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface::localizedActionDescription&lt;/a&gt;() to return their localized counterparts.</source>
          <target state="translated">При &lt;a href=&quot;qaccessibleactioninterface&quot;&gt;создании&lt;/a&gt; подкласса QAccessibleActionInterface вам необходимо предоставить список &lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionNames,&lt;/a&gt; который является основным средством обнаружения доступных действий. Имена действий никогда не локализуются. Чтобы представить действия пользователю, есть две функции, которые должны возвращать локализованные версии имени и давать описание действия. Для предопределенных имен действий используйте &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface :: localizedActionName&lt;/a&gt; () и &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface :: localizedActionDescription&lt;/a&gt; (), чтобы вернуть их локализованные аналоги.</target>
        </trans-unit>
        <trans-unit id="a25edef8cc00a94f017f1d9cbc6945550b8bf450" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;, you must call QIODevice::seek() at the start of your function to ensure integrity with &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;'s built-in buffer.</source>
          <target state="translated">При &lt;a href=&quot;qiodevice&quot;&gt;создании&lt;/a&gt; подкласса QIODevice вы должны вызвать QIODevice :: seek () в начале своей функции, чтобы обеспечить целостность со встроенным буфером &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d195ef9dc4d6a9738e6783d4bc0696c9278d4ef4" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; to create a delegate that displays items using a custom renderer, it is important to ensure that the delegate can render items suitably for all the required states; e.g. selected, disabled, checked. The documentation for the &lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt;() function contains some hints to show how this can be achieved.</source>
          <target state="translated">При &lt;a href=&quot;qitemdelegate&quot;&gt;создании&lt;/a&gt; подкласса QItemDelegate для создания делегата, который отображает элементы с помощью настраиваемого средства визуализации, важно убедиться, что делегат может отображать элементы соответствующим образом для всех требуемых состояний; например, выбран, отключен, отмечен. Документация по функции &lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt; () содержит некоторые подсказки, показывающие, как этого можно достичь.</target>
        </trans-unit>
        <trans-unit id="bdfab8a00f506ea4624c5ba05bcfdffa0be88abb" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qlistwidgetitem&quot;&gt;QListWidgetItem&lt;/a&gt; to provide custom items, it is possible to define new types for them enabling them to be distinguished from standard items. For subclasses that require this feature, ensure that you call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;, within</source>
          <target state="translated">При &lt;a href=&quot;qlistwidgetitem&quot;&gt;создании&lt;/a&gt; подкласса QListWidgetItem для предоставления настраиваемых элементов для них можно определить новые типы, позволяющие отличать их от стандартных элементов. Для подклассов, которым требуется эта функция, убедитесь, что вы вызываете конструктор базового класса с новым значением типа, равным или большим, чем &lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt; , внутри</target>
        </trans-unit>
        <trans-unit id="25983c5d275d61a5768d14102127d7627a6f2db7" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt; to provide custom items, it is possible to define new types for them so that they can be distinguished from the base class. The &lt;a href=&quot;qstandarditem#type&quot;&gt;type&lt;/a&gt;() function should be reimplemented to return a new type value equal to or greater than &lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">При &lt;a href=&quot;qstandarditem&quot;&gt;создании&lt;/a&gt; подкласса QStandardItem для предоставления настраиваемых элементов для них можно определить новые типы, чтобы их можно было отличить от базового класса. &lt;a href=&quot;qstandarditem#type&quot;&gt;Тип&lt;/a&gt; функции () должен быть переопределен чтобы вернуть новое значение типа , равным или большим , чем &lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;UserType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6fbf6fe9133647e06d0faf1437cba6ca2cedd98" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt;, you can reimplement this function to provide &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt; with a factory that it can use to create new items on demand.</source>
          <target state="translated">При &lt;a href=&quot;qstandarditem&quot;&gt;создании&lt;/a&gt; подкласса QStandardItem вы можете повторно реализовать эту функцию, чтобы предоставить &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt; фабрику, которую он может использовать для создания новых элементов по запросу.</target>
        </trans-unit>
        <trans-unit id="f2286413d50d08d040929b6ec39c68a3dddaf3c0" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qtablewidgetitem&quot;&gt;QTableWidgetItem&lt;/a&gt; to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">При создании подкласса &lt;a href=&quot;qtablewidgetitem&quot;&gt;QTableWidgetItem&lt;/a&gt; для предоставления настраиваемых элементов для них можно определить новые типы, чтобы их можно было отличить от стандартных элементов. Конструкторам подклассов, которым требуется эта функция, необходимо вызвать конструктор базового класса с новым значением типа, равным или большим, чем &lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1002dc2f9f72071b49f3bc6989364ec60eb22d54" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qtreewidgetitem&quot;&gt;QTreeWidgetItem&lt;/a&gt; to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">При &lt;a href=&quot;qtreewidgetitem&quot;&gt;создании&lt;/a&gt; подкласса QTreeWidgetItem для предоставления настраиваемых элементов для них можно определить новые типы, чтобы их можно было отличить от стандартных элементов. Конструкторам подклассов, которым требуется эта функция, необходимо вызвать конструктор базового класса с новым значением типа, равным или большим, чем &lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="59520faecedf14305609ce71b43c92f419907198" translate="yes" xml:space="preserve">
          <source>When subclassing QAbstractItemModel, at the very least you must implement &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). These functions are used in all read-only models, and form the basis of editable models.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3699b269f018546bac2b237f4b1ba2d9ba58cd5a" translate="yes" xml:space="preserve">
          <source>When subclassing QAbstractListModel, you must provide implementations of the &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;() functions. Well behaved models also provide a &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;() implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1062aef636e41c878017026955b733a82f0e58d" translate="yes" xml:space="preserve">
          <source>When subclassing QAbstractTableModel, you must implement &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). Default implementations of the &lt;a href=&quot;qabstracttablemodel#index&quot;&gt;index&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;() functions are provided by QAbstractTableModel. Well behaved models will also implement &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b79d67e5a46121dc5b166539f6602a7e665200" translate="yes" xml:space="preserve">
          <source>When subclassing QAccessibleActionInterface you need to provide a list of &lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionNames&lt;/a&gt; which is the primary means to discover the available actions. Action names are never localized. In order to present actions to the user there are two functions that need to return localized versions of the name and give a description of the action. For the predefined action names use &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface::localizedActionName&lt;/a&gt;() and &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface::localizedActionDescription&lt;/a&gt;() to return their localized counterparts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd6e4c37e600fd73592fb3b27ecd0ad7ca47a17" translate="yes" xml:space="preserve">
          <source>When subclassing QItemDelegate to create a delegate that displays items using a custom renderer, it is important to ensure that the delegate can render items suitably for all the required states; e.g. selected, disabled, checked. The documentation for the &lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt;() function contains some hints to show how this can be achieved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e0f5aa88b44938c261cc9eef6f6e4a41afa7675" translate="yes" xml:space="preserve">
          <source>When subclassing QListWidgetItem to provide custom items, it is possible to define new types for them enabling them to be distinguished from standard items. For subclasses that require this feature, ensure that you call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;, within</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72aca5e914ed9fefcaccb35499bea805b895d281" translate="yes" xml:space="preserve">
          <source>When subclassing QStandardItem to provide custom items, it is possible to define new types for them so that they can be distinguished from the base class. The &lt;a href=&quot;qstandarditem#type&quot;&gt;type&lt;/a&gt;() function should be reimplemented to return a new type value equal to or greater than &lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42b0b4032d93d4857496512b038b0674cfd26f89" translate="yes" xml:space="preserve">
          <source>When subclassing QTableWidgetItem to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a47ebf3a47f4b0b127eba34804babe9e0cf37bc" translate="yes" xml:space="preserve">
          <source>When subclassing QTreeWidgetItem to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="706f7b1df0260af3c55347db3db3d7c9292cb895" translate="yes" xml:space="preserve">
          <source>When successful, the pointer to this &lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt; is retrievable via the static function current().</source>
          <target state="translated">В случае успеха указатель на этот &lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt; можно получить с помощью статической функции current ().</target>
        </trans-unit>
        <trans-unit id="52f02029e2dd95fea6c58bc7c6dd438e3036694c" translate="yes" xml:space="preserve">
          <source>When successful, the returned pointer is either a direct pointer to an interface (and can be cast, for example, to &lt;code&gt;ID3D12Device *&lt;/code&gt;) or a pointer to an opaque handle that needs to be dereferenced first (for example, &lt;code&gt;VkDevice dev = *static_cast&amp;lt;VkDevice *&amp;gt;(result)&lt;/code&gt;). The latter is necessary since such handles may have sizes different from a pointer.</source>
          <target state="translated">В случае успеха возвращаемый указатель является либо прямым указателем на интерфейс (и может быть приведен, например, к &lt;code&gt;ID3D12Device *&lt;/code&gt; ), либо указателем на непрозрачный дескриптор, который необходимо сначала разыменовать (например, &lt;code&gt;VkDevice dev = *static_cast&amp;lt;VkDevice *&amp;gt;(result)&lt;/code&gt; ). Последнее необходимо, поскольку такие ручки могут иметь размеры, отличные от указателя.</target>
        </trans-unit>
        <trans-unit id="b61533f5bfe4f41a281b6739619bbe40223b42c1" translate="yes" xml:space="preserve">
          <source>When supported, the spot metering point is the (normalized) position of the point of the image where exposure metering will be performed. This is typically used to indicate an &quot;interesting&quot; area of the image that should be exposed properly.</source>
          <target state="translated">Если поддерживается,то точка точечного замера-это (нормализованное)положение точки изображения,в которой будет производиться замер экспозиции.Обычно она используется для указания &quot;интересной&quot; области изображения,которая должна быть правильно экспонирована.</target>
        </trans-unit>
        <trans-unit id="5f88abce90e32dce271b35e9107fb601ec017c62" translate="yes" xml:space="preserve">
          <source>When switching application styles, the color palette is set back to the initial colors or the system defaults. This is necessary since certain styles have to adapt the color palette to be fully style-guide compliant.</source>
          <target state="translated">При переключении стилей приложений цветовая палитра возвращается к исходным цветам или системным настройкам по умолчанию.Это необходимо,так как некоторые стили должны адаптировать цветовую палитру,чтобы она полностью соответствовала стилю.</target>
        </trans-unit>
        <trans-unit id="67873ce37a5513b0e5ae88b75e6f033ba8bb99f4" translate="yes" xml:space="preserve">
          <source>When tabsClosable is set to true a close button will appear on the tab on either the left or right hand side depending upon the style. When the button is clicked the tab the signal &lt;a href=&quot;qtabbar#tabCloseRequested&quot;&gt;tabCloseRequested&lt;/a&gt; will be emitted.</source>
          <target state="translated">Если для tabsClosable задано значение true, кнопка закрытия появится на вкладке слева или справа в зависимости от стиля. При нажатии кнопки вкладки будет &lt;a href=&quot;qtabbar#tabCloseRequested&quot;&gt;выдан&lt;/a&gt; сигнал tabCloseRequested .</target>
        </trans-unit>
        <trans-unit id="edd34e00a0649a39928db867a61af0bdd3698a54" translate="yes" xml:space="preserve">
          <source>When talking about version support on macOS, it's important to distinguish between the &lt;a href=&quot;#build-environment&quot;&gt;build environment&lt;/a&gt;; the platform you're building on or with, and the &lt;a href=&quot;#target-platforms&quot;&gt;target platforms&lt;/a&gt;; the platforms you are building for. The following macOS versions are supported.</source>
          <target state="translated">Говоря о поддержке версий в macOS, важно различать &lt;a href=&quot;#build-environment&quot;&gt;среду сборки&lt;/a&gt; ; платформа, на которой вы строите или на которой, и &lt;a href=&quot;#target-platforms&quot;&gt;целевые платформы&lt;/a&gt; ; платформы, для которых вы строите. Поддерживаются следующие версии macOS.</target>
        </trans-unit>
        <trans-unit id="46e5a0bd94336c26034fab948fd2202518bbe3a7" translate="yes" xml:space="preserve">
          <source>When talking about version support on macOS, it's important to distinguish between the &lt;a href=&quot;macos#build-environment&quot;&gt;build environment&lt;/a&gt;; the platform you're building on or with, and the &lt;a href=&quot;macos#target-platforms&quot;&gt;target platforms&lt;/a&gt;; the platforms you are building for. The following macOS versions are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b09dba91f90a77f1c0f316bc1593767614f52d" translate="yes" xml:space="preserve">
          <source>When targeting the default render target, the &lt;code&gt;rasterizationSamples&lt;/code&gt; field of &lt;code&gt;VkPipelineMultisampleStateCreateInfo&lt;/code&gt; must be set to this value.</source>
          <target state="translated">При нацеливании на цель рендеринга по умолчанию поле &lt;code&gt;rasterizationSamples&lt;/code&gt; в &lt;code&gt;VkPipelineMultisampleStateCreateInfo&lt;/code&gt; должно быть установлено на это значение.</target>
        </trans-unit>
        <trans-unit id="01a0c4cf5ca0b1b36842c832e9f49ed747142008" translate="yes" xml:space="preserve">
          <source>When testing classes that change their state based on timer events, the timer-based behavior needs to be taken into account when performing verification steps. Due to the variety of timing-dependent behavior, there is no single generic solution to this testing problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977796166650ef7b381034a2e5ab66d22d9fde20" translate="yes" xml:space="preserve">
          <source>When text is selected this signal will be emitted with</source>
          <target state="translated">При выборе текста этот сигнал будет выдаваться с помощью кнопки</target>
        </trans-unit>
        <trans-unit id="55f3e3f1e06a97818ce0ffb33865599309fb29ae" translate="yes" xml:space="preserve">
          <source>When the</source>
          <target state="translated">Когда</target>
        </trans-unit>
        <trans-unit id="277e96c69a29982435c9191c9b7dc60d6543c8df" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; is editable, use &lt;a href=&quot;qlineedit#placeholderText-prop&quot;&gt;QLineEdit::setPlaceholderText&lt;/a&gt;() instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96148eaf4c167de1a5cc9cb151bbca87c607e4e7" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qlogvalue3daxisformatter#base-prop&quot;&gt;base&lt;/a&gt; property value is non-zero, the whole axis range is often not equally divided into segments. The first and last segments are often smaller than the other segments. In extreme cases, this can lead to overlapping labels on the first and last two grid lines. By setting this property to &lt;code&gt;false&lt;/code&gt;, you can suppress showing the minimum and maximum labels for the axis in cases where the segments do not exactly fit the axis. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Когда значение &lt;a href=&quot;qlogvalue3daxisformatter#base-prop&quot;&gt;базового&lt;/a&gt; свойства не равно нулю, весь диапазон оси часто не делится на сегменты поровну. Первый и последний сегменты часто меньше других сегментов. В крайних случаях это может привести к наложению меток на первых и последних двух линиях сетки. Установив для этого свойства значение &lt;code&gt;false&lt;/code&gt; , вы можете подавить отображение минимальной и максимальной меток для оси в тех случаях, когда сегменты не точно соответствуют оси. По умолчанию &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcebf5705064ce0455ad2b9bec751e51c083ccf2" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c131bddcc8fa92f9f3b0a589fa47980eb2d439" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="translated">Когда для свойства &lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; задано значение SizeMode :: Fixed, значение устанавливается с помощью glPointSize (), если доступно. При использовании SizeMode :: Programmable gl_PointSize должен быть установлен в шейдерных программах, значение, предоставленное этому &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState,&lt;/a&gt; в этом случае игнорируется.</target>
        </trans-unit>
        <trans-unit id="31b0eaa228f2b88891ce3db774ff73a70a98110c" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtdatavisualization-logvalueaxis3dformatter#base-prop&quot;&gt;base&lt;/a&gt; property value is non-zero, the whole axis range is often not equally divided into segments. The first and last segments are often smaller than the other segments. In extreme cases, this can lead to overlapping labels on the first and last two grid lines. By setting this property to &lt;code&gt;false&lt;/code&gt;, you can suppress showing the minimum and maximum labels for the axis in cases where the segments do not exactly fit the axis. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Когда значение &lt;a href=&quot;qml-qtdatavisualization-logvalueaxis3dformatter#base-prop&quot;&gt;базового&lt;/a&gt; свойства не равно нулю, весь диапазон оси часто не делится на сегменты поровну. Первый и последний сегменты часто меньше других сегментов. В крайних случаях это может привести к наложению меток на первых и последних двух линиях сетки. Установив для этого свойства значение &lt;code&gt;false&lt;/code&gt; , вы можете подавить отображение минимальной и максимальной меток для оси в тех случаях, когда сегменты не точно соответствуют оси. По умолчанию &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="987fec2f0c2c258849a742c9e14f0174fef55ec2" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtpositioning-positionsource&quot;&gt;PositionSource&lt;/a&gt; is active, position updates can be retrieved either by simply using the &lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;position&lt;/a&gt; property in a binding (as the value of another item's property), or by providing an implementation of the &lt;code&gt;onPositionChanged&lt;/code&gt; signal-handler.</source>
          <target state="translated">Когда &lt;a href=&quot;qml-qtpositioning-positionsource&quot;&gt;PositionSource&lt;/a&gt; активен, обновления позиции можно получить либо просто используя свойство &lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;position&lt;/a&gt; в привязке (как значение свойства другого элемента), либо предоставив реализацию &lt;code&gt;onPositionChanged&lt;/code&gt; сигнала onPositionChanged .</target>
        </trans-unit>
        <trans-unit id="d6b06a8b392f311abc92743e16b8eaf852385858" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; needs a new transition, it first calls &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;StackViewDelegate.getTransition()&lt;/a&gt;. The base implementation of this function just looks for a property named &lt;code&gt;properties.name&lt;/code&gt; inside itself (root), which is how it finds &lt;code&gt;property Component pushTransition&lt;/code&gt; in the examples above.</source>
          <target state="translated">Когда &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; требуется новый переход, он сначала вызывает &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;StackViewDelegate.getTransition ()&lt;/a&gt; . Базовая реализация этой функции просто ищет свойство с именем &lt;code&gt;properties.name&lt;/code&gt; внутри себя (root), как она находит &lt;code&gt;property Component pushTransition&lt;/code&gt; в приведенных выше примерах.</target>
        </trans-unit>
        <trans-unit id="13b2463be39cc72e16c7d4ca58b0c4d0edaade26" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-flickable#boundsMovement-prop&quot;&gt;boundsMovement&lt;/a&gt; is &lt;code&gt;Flickable.FollowBoundsBehavior&lt;/code&gt;, a value other than &lt;code&gt;Flickable.StopAtBounds&lt;/code&gt; will give a feeling that the edges of the view are soft, rather than a hard physical boundary.</source>
          <target state="translated">Когда &lt;a href=&quot;qml-qtquick-flickable#boundsMovement-prop&quot;&gt;boundsMovement&lt;/a&gt; имеет значение &lt;code&gt;Flickable.FollowBoundsBehavior&lt;/code&gt; , значение, отличное от &lt;code&gt;Flickable.StopAtBounds&lt;/code&gt; , даст ощущение, что края представления мягкие, а не жесткие физические границы.</target>
        </trans-unit>
        <trans-unit id="bdd086e0b6a8d49e2b2713bf9ea24b942d740d18" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; is clicked, &lt;code&gt;fruitModel&lt;/code&gt; will have two roles,</source>
          <target state="translated">Когда &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; нажата, &lt;code&gt;fruitModel&lt;/code&gt; будет иметь две роли,</target>
        </trans-unit>
        <trans-unit id="531648fe487a96145ce0801a6bc88b47ddc3d5fa" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; object refers to its &lt;a href=&quot;qml-qtquick-item#parent-prop&quot;&gt;parent&lt;/a&gt; value in the above code, it is referring to its</source>
          <target state="translated">Когда объект &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; ссылается на свое &lt;a href=&quot;qml-qtquick-item#parent-prop&quot;&gt;родительское&lt;/a&gt; значение в приведенном выше коде, он ссылается на свое</target>
        </trans-unit>
        <trans-unit id="cfbd43c514e575cbd44c06a9f1befeb8fbc6aa47" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardlayoutloader&quot;&gt;KeyboardLayoutLoader&lt;/a&gt; is used as a root item of a keyboard layout, the actual keyboard layouts are wrapped inside Component elements. The keyboard layout is activated by assigning the id of an active component to the sourceComponent property.</source>
          <target state="translated">Когда &lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardlayoutloader&quot;&gt;KeyboardLayoutLoader&lt;/a&gt; используется в качестве корневого элемента раскладки клавиатуры, фактические раскладки клавиатуры обертываются внутри элементов Component. Раскладка клавиатуры активируется путем присвоения идентификатора активного компонента свойству sourceComponent.</target>
        </trans-unit>
        <trans-unit id="f043241c3f7cc581207444dcc1dc86dbdeb3ef7b" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; is clicked, the console prints,</source>
          <target state="translated">При нажатии &lt;a href=&quot;qpushbutton&quot;&gt;кнопки QPushButton&lt;/a&gt; консоль печатает:</target>
        </trans-unit>
        <trans-unit id="d450f4ff62c8dd3eda6ad3d118faffcc34e07662" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; instantiates a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, the context is set automatically.</source>
          <target state="translated">Когда &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; создает экземпляр &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; , контекст устанавливается автоматически.</target>
        </trans-unit>
        <trans-unit id="1a3ec88b091fae5c593926fbff02a507863cf15b" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qsensor#axesOrientationMode-prop&quot;&gt;axesOrientationMode&lt;/a&gt; property is set to &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;UserOrientation&lt;/a&gt;, the angle for rotating the reading values is taken from this property. In other modes, the property has no effect.</source>
          <target state="translated">Если для свойства &lt;a href=&quot;qsensor#axesOrientationMode-prop&quot;&gt;axesOrientationMode&lt;/a&gt; задано значение &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;UserOrientation&lt;/a&gt; , угол поворота считываемых значений берется из этого свойства. В других режимах свойство не действует.</target>
        </trans-unit>
        <trans-unit id="f8b6764b784c8d16407b8358832df499fd592a45" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qsgmaterial&quot;&gt;QSGMaterial&lt;/a&gt; reports &lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;SupportsRhiShader&lt;/a&gt; in &lt;a href=&quot;qsgmaterial#flags&quot;&gt;flags&lt;/a&gt;(), the scene graph may request a &lt;a href=&quot;qsgmaterialrhishader&quot;&gt;QSGMaterialRhiShader&lt;/a&gt; instead of &lt;a href=&quot;qsgmaterialshader&quot;&gt;QSGMaterialShader&lt;/a&gt;. This is indicated by having the &lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;RhiShaderWanted&lt;/a&gt; flag set. In this case the return value must be a QSGRhiMaterialShader subclass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec06e7607af8f8760e7b965130ca0af1c7c4afa" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qt#PenJoinStyle-enum&quot;&gt;Qt::MiterJoin&lt;/a&gt; style is applied, it is possible to use the &lt;a href=&quot;qpen#setMiterLimit&quot;&gt;setMiterLimit&lt;/a&gt;() function to specify how far the miter join can extend from the join point. The &lt;a href=&quot;qpen#miterLimit&quot;&gt;miterLimit&lt;/a&gt;() is used to reduce artifacts between line joins where the lines are close to parallel.</source>
          <target state="translated">Когда &lt;a href=&quot;qt#PenJoinStyle-enum&quot;&gt;применяется&lt;/a&gt; стиль Qt :: MiterJoin , можно использовать &lt;a href=&quot;qpen#setMiterLimit&quot;&gt;функцию setMiterLimit&lt;/a&gt; (), чтобы указать, как далеко угловое соединение может простираться от точки соединения. &lt;a href=&quot;qpen#miterLimit&quot;&gt;MiterLimit&lt;/a&gt; () используется для уменьшения артефактов между соединяющимися линиями , где линии близки к параллельным.</target>
        </trans-unit>
        <trans-unit id="8cff9e77f59469425f8797ff7538a94cb9830def" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8109269e175dc39675b846ed563d3f286803d82a" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="translated">Когда для свойства &lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; задано значение SizeMode :: Fixed, значение устанавливается с помощью glPointSize (), если доступно. При использовании SizeMode :: Programmable gl_PointSize должен быть установлен в шейдерных программах, значение, предоставленное этому &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState,&lt;/a&gt; в этом случае игнорируется.</target>
        </trans-unit>
        <trans-unit id="ef51d747b8fb0e1aaf24623fb2724ee2f97056ec" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; displays arrows, the &lt;a href=&quot;#up-arrow-sub&quot;&gt;::up-arrow&lt;/a&gt;, &lt;a href=&quot;#down-arrow-sub&quot;&gt;::down-arrow&lt;/a&gt;, &lt;a href=&quot;#left-arrow-sub&quot;&gt;::left-arrow&lt;/a&gt; and &lt;a href=&quot;#right-arrow-sub&quot;&gt;::right-arrow&lt;/a&gt; subcontrols are used.</source>
          <target state="translated">Когда &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; отображает стрелки, используются субэлементы управления &lt;a href=&quot;#up-arrow-sub&quot;&gt;:: стрелка вверх&lt;/a&gt; , &lt;a href=&quot;#down-arrow-sub&quot;&gt;:: &lt;/a&gt;стрелка вниз , &lt;a href=&quot;#left-arrow-sub&quot;&gt;:: стрелка влево&lt;/a&gt; и &lt;a href=&quot;#right-arrow-sub&quot;&gt;:: стрелка вправо&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="233835321d7949264542584e5872cf0f2ee5c9ad" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; displays arrows, the &lt;a href=&quot;stylesheet-reference#up-arrow-sub&quot;&gt;::up-arrow&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#down-arrow-sub&quot;&gt;::down-arrow&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#left-arrow-sub&quot;&gt;::left-arrow&lt;/a&gt; and &lt;a href=&quot;stylesheet-reference#right-arrow-sub&quot;&gt;::right-arrow&lt;/a&gt; subcontrols are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1a6fb9f01b0846bb260ddb329a9c95bfca49b3e" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;subdirs&lt;/code&gt; template is used, qmake generates a Makefile to examine each specified subdirectory, process any project file it finds there, and run the platform's &lt;code&gt;make&lt;/code&gt; tool on the newly-created Makefile. The &lt;code&gt;SUBDIRS&lt;/code&gt; variable is used to contain a list of all the subdirectories to be processed.</source>
          <target state="translated">Когда &lt;code&gt;subdirs&lt;/code&gt; используется шаблон, QMAKE создает файл сборки для проверки каждого подкаталога, обрабатывать любой файл проекта он находит там, и запустить платформы &lt;code&gt;make&lt;/code&gt; инструмент на вновь созданного файла сборки. &lt;code&gt;SUBDIRS&lt;/code&gt; переменный используются , чтобы содержать список всех подкаталогов, подлежащую обработке.</target>
        </trans-unit>
        <trans-unit id="5b64d4e10455a073c6c16a2676284bd8b55dc704" translate="yes" xml:space="preserve">
          <source>When the KMS/DRM backend is in use, EGLFS reports all available screens in &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication::screens&lt;/a&gt;(). Applications can target different screens with different windows via &lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow::setScreen&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13cb608250173ac51a45d65525231f711e5ba267" translate="yes" xml:space="preserve">
          <source>When the KMS/DRM backend is in use, eglfs reports all available screens in &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication::screens&lt;/a&gt;(). Applications can target different screens with different windows via &lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow::setScreen&lt;/a&gt;().</source>
          <target state="translated">Когда используется серверная часть KMS / DRM, eglfs сообщает обо всех доступных экранах в &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication :: screen&lt;/a&gt; (). Приложения могут нацеливаться на разные экраны с разными окнами через &lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow :: setScreen&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="e9c697bf2c44fd91eecd755192f28a6e88860c7e" translate="yes" xml:space="preserve">
          <source>When the PositionSource is active, position updates can be retrieved either by simply using the &lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;position&lt;/a&gt; property in a binding (as the value of another item's property), or by providing an implementation of the &lt;code&gt;onPositionChanged&lt;/code&gt; signal-handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590e6b713b7124a325673c8560f716815fb45204" translate="yes" xml:space="preserve">
          <source>When the QML engine encounters a use of &lt;code&gt;RandomNumberGenerator&lt;/code&gt; as a property value source, it invokes &lt;code&gt;RandomNumberGenerator::setTarget()&lt;/code&gt; to provide the type with the property to which the value source has been applied. When the internal timer in &lt;code&gt;RandomNumberGenerator&lt;/code&gt; triggers every 500 milliseconds, it will write a new number value to that specified property.</source>
          <target state="translated">Когда механизм QML обнаруживает использование &lt;code&gt;RandomNumberGenerator&lt;/code&gt; в качестве источника значения свойства, он вызывает &lt;code&gt;RandomNumberGenerator::setTarget()&lt;/code&gt; чтобы предоставить типу свойство, к которому был применен источник значения. Когда внутренний таймер в &lt;code&gt;RandomNumberGenerator&lt;/code&gt; срабатывает каждые 500 миллисекунд, он записывает новое числовое значение в это указанное свойство.</target>
        </trans-unit>
        <trans-unit id="55bdd73045f54c63cca63284c91153ecc1e0e57c" translate="yes" xml:space="preserve">
          <source>When the QML engine processes this code, it creates a single instance of the</source>
          <target state="translated">Когда QML-движок обрабатывает этот код,он создает единственный экземпляр</target>
        </trans-unit>
        <trans-unit id="2200e5bee9d5bde2ef75b92345abdbbd47de48d7" translate="yes" xml:space="preserve">
          <source>When the Space key is pressed, the &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;visible&lt;/a&gt; value of the green &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; is toggled. As it appears and disappears, the blue &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; moves within the Column, and the &lt;a href=&quot;qml-qtquick-column#move-prop&quot;&gt;move&lt;/a&gt; transition is automatically applied to the blue &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;:</source>
          <target state="translated">Когда нажата клавиша пробела, &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;видимое&lt;/a&gt; значение зеленого &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;прямоугольника&lt;/a&gt; переключается. По мере появления и исчезновения синий &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;прямоугольник&lt;/a&gt; перемещается внутри столбца, и переход &lt;a href=&quot;qml-qtquick-column#move-prop&quot;&gt;перемещения&lt;/a&gt; автоматически применяется к синему &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;прямоугольнику&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="9c6490ecb547781d0dc7402f03b49e5ff063c783" translate="yes" xml:space="preserve">
          <source>When the StackView needs a new transition, it first calls &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;StackViewDelegate.getTransition()&lt;/a&gt;. The base implementation of this function just looks for a property named &lt;code&gt;properties.name&lt;/code&gt; inside itself (root), which is how it finds &lt;code&gt;property Component pushTransition&lt;/code&gt; in the examples above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a3ce649d4099a8096022c6c669c9176b6fc57ee" translate="yes" xml:space="preserve">
          <source>When the \brief command is used to describe a class, we recommend using a complete sentence like this:</source>
          <target state="translated">Когда для описания класса используется команда \brief,мы рекомендуем использовать полное предложение,подобное этому:</target>
        </trans-unit>
        <trans-unit id="557b6338e75a33d13fe088abb975f18a855ab911" translate="yes" xml:space="preserve">
          <source>When the \brief command is used to describe a property or a variable, the brief text must be a sentence fragment starting with &quot;whether&quot; (for a boolean property or variable) or starting with &quot;the&quot; (for any other property or variable).</source>
          <target state="translated">Когда команда \brief используется для описания свойства или переменной,краткий текст должен быть фрагментом предложения,начинающимся со слова &quot;if&quot; (для булевого свойства или переменной)или начинающимся со слова &quot;the&quot; (для любого другого свойства или переменной).</target>
        </trans-unit>
        <trans-unit id="68de879942c076ccf49dec3b35482feaabb2b36a" translate="yes" xml:space="preserve">
          <source>When the above view is flicked beyond its bounds, it will return to its bounds using the transition specified:</source>
          <target state="translated">Когда вышеприведенный вид будет перелистываться за пределы своих границ,он вернется к своим границам с помощью указанного перехода:</target>
        </trans-unit>
        <trans-unit id="589227a0f3172c2f19894c29348f6198f079bcbc" translate="yes" xml:space="preserve">
          <source>When the active subwindow is maximized, the default behavior is to maximize the next subwindow that is activated. Set this option if you do not want this behavior.</source>
          <target state="translated">Когда активное подокно максимизировано,по умолчанию поведение заключается в максимизации следующего активированного подокна.Установите эту опцию,если вы не хотите такого поведения.</target>
        </trans-unit>
        <trans-unit id="ab36dbc74560565de3f4f93285f3477fd906523a" translate="yes" xml:space="preserve">
          <source>When the allowed &lt;a href=&quot;qdatetimeedit#setDateTimeRange&quot;&gt;range&lt;/a&gt; is narrower than some time interval whose end it straddles, keyboard tracking prevents the user editing the date or time to access the later part of the interval. For example, for a range from 29.04.2020 to 02.05.2020 and an initial date of 30.04.2020, the user can change neither the month (May 30th is outside the range) nor the day (April 2nd is outside the range).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a7ce62c114b1cc52094be5a1851abc5fc7f2e64" translate="yes" xml:space="preserve">
          <source>When the alpha channel is enabled either via &lt;a href=&quot;qquickwindow#setDefaultAlphaBuffer&quot;&gt;QQuickWindow::setDefaultAlphaBuffer&lt;/a&gt;() or by setting alphaBufferSize to a non-zero value in the window's &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; or in the global format managed by &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;(), the D3D12 backend will create a swapchain for composition and go through DirectComposition. This is necessary, because the mandatory flip model swapchain wouldn't support transparency otherwise.</source>
          <target state="translated">Когда альфа-канал включен либо через &lt;a href=&quot;qquickwindow#setDefaultAlphaBuffer&quot;&gt;QQuickWindow :: setDefaultAlphaBuffer&lt;/a&gt; (), либо путем установки для alphaBufferSize ненулевого значения в &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; окна или в глобальном формате, управляемом &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat :: setDefaultFormat&lt;/a&gt; (), бэкэнд D3D12 создаст цепочку подкачки для композиция и пройти через DirectComposition. Это необходимо, потому что в противном случае обязательная цепочка обмена модели флип не поддерживала бы прозрачность.</target>
        </trans-unit>
        <trans-unit id="9a1e6809f3ea75f0ed2e58d51575459791e1afbc" translate="yes" xml:space="preserve">
          <source>When the animation finishes it returns to the initial frame. This is the default behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c6e776224aaea188a4e49fe2b71d9eeacafa46" translate="yes" xml:space="preserve">
          <source>When the animation finishes it stays on the final frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abead2ff8ba68473ab0f073d1c6b50c8ad980ea5" translate="yes" xml:space="preserve">
          <source>When the application is running with the generic, triangulation-based Shape implementation, the geometry generation happens entirely on the CPU. This is potentially expensive. Changing the set of path elements, changing the properties of these elements, or changing certain properties of the Shape itself all lead to retriangulation of the affected paths on every change. Therefore, applying animation to such properties can affect performance on less powerful systems.</source>
          <target state="translated">Когда приложение работает с общей,триангуляционной реализацией Shape,генерация геометрии происходит полностью на центральном процессоре.Это потенциально дорого.Изменение набора элементов пути,изменение свойств этих элементов или изменение некоторых свойств самой фигуры приводит к ретриангуляции затронутых путей при каждом изменении.Поэтому применение анимации к таким свойствам может повлиять на производительность на менее мощных системах.</target>
        </trans-unit>
        <trans-unit id="2dc59efa2f06087183eee0fb11a7e9582ff61062" translate="yes" xml:space="preserve">
          <source>When the application is running, an IDE or a tool that implements the binary protocol can connect to the open port.</source>
          <target state="translated">Когда приложение запущено,IDE или инструмент,реализующий двоичный протокол,может подключаться к открытому порту.</target>
        </trans-unit>
        <trans-unit id="c469e679911aae260b7551ead885271015ff56e7" translate="yes" xml:space="preserve">
          <source>When the application is started it has to register an message handler with &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;registerNdefMessageHandler()&lt;/a&gt; The first NDEF message arriving in the handler is the message that started the application. See the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnfc-corkboard-example.html#&quot;&gt;CorkBoard&lt;/a&gt; application for an example.</source>
          <target state="translated">Когда приложение запускается, оно должно зарегистрировать обработчик сообщений с помощью &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;registerNdefMessageHandler ()&lt;/a&gt; . Первое сообщение NDEF, поступающее в обработчик, - это сообщение, которое запустило приложение. См. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnfc-corkboard-example.html#&quot;&gt;Пример в&lt;/a&gt; приложении CorkBoard .</target>
        </trans-unit>
        <trans-unit id="bf9811db4bca65a70c4bf17f4e8c83205ce8fbdb" translate="yes" xml:space="preserve">
          <source>When the application is started it has to register an message handler with &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;registerNdefMessageHandler()&lt;/a&gt; The first NDEF message arriving in the handler is the message that started the application. See the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtnfc-corkboard-example.html&quot;&gt;CorkBoard&lt;/a&gt; application for an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a549dc65fe725b80a97de046a5a0dc3b6c6fb6" translate="yes" xml:space="preserve">
          <source>When the binding becomes inactive again, any direct bindings that were previously set on the property will be restored.</source>
          <target state="translated">Когда привязка снова станет неактивной,любые прямые привязки,которые были ранее установлены на свойстве,будут восстановлены.</target>
        </trans-unit>
        <trans-unit id="447dd45f7b45ede6829150c673fe906621c3daff" translate="yes" xml:space="preserve">
          <source>When the button is clicked, the purchase process is started. At some point in the future, either the &lt;a href=&quot;qml-qtpurchasing-product#onPurchaseFailed-signal&quot;&gt;onPurchaseFailed&lt;/a&gt; handler will be called (for example if the user cancels the transaction), or the &lt;a href=&quot;qml-qtpurchasing-product#onPurchaseSucceeded-signal&quot;&gt;onPurchaseSucceeded&lt;/a&gt; handler will be called.</source>
          <target state="translated">При нажатии кнопки запускается процесс покупки. В какой-то момент в будущем будет вызван либо обработчик &lt;a href=&quot;qml-qtpurchasing-product#onPurchaseFailed-signal&quot;&gt;onPurchaseFailed&lt;/a&gt; (например, если пользователь отменяет транзакцию), либо обработчик &lt;a href=&quot;qml-qtpurchasing-product#onPurchaseSucceeded-signal&quot;&gt;onPurchaseSucceeded&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ebbf8f547dd292e8432493d1f5c0d39a31ffd9b" translate="yes" xml:space="preserve">
          <source>When the client is connected successfully, we connect to the `onTextMessageReceived()` signal, and send out &quot;Hello, world!&quot;. If connected with the EchoServer, we will receive the same message back.</source>
          <target state="translated">После успешного подключения клиента мы подключаемся к сигналу `onTextMessageReceived()` и посылаем &quot;Привет,мир!&quot;.При подключении к EchoServer мы получим такое же сообщение обратно.</target>
        </trans-unit>
        <trans-unit id="5d66decd4409859b0e6cc5ba70ca923d5222b329" translate="yes" xml:space="preserve">
          <source>When the connection to the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; object is made, the initialization step passes the current property values (see &lt;a href=&quot;qtremoteobjects-replica#replica-initialization&quot;&gt;Replica Initialization&lt;/a&gt;). In a DynamicReplica, the property/signal/slot details are also sent, allowing the replica object to be created on-the-fly. This can be conventient in QML or scripting, but has two primary disadvantages. First, the object is in effect &quot;empty&quot; until it is successfully initialized by the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt;. Second, in C++, calls must be made using &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject::invokeMethod&lt;/a&gt;(), as the moc generated lookup will not be available.</source>
          <target state="translated">Когда соединение с &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;исходным&lt;/a&gt; объектом установлено, этап инициализации передает текущие значения свойств (см. &lt;a href=&quot;qtremoteobjects-replica#replica-initialization&quot;&gt;Инициализация реплики&lt;/a&gt; ). В DynamicReplica также отправляются сведения о свойстве / сигнале / слоте, что позволяет создавать объект реплики на лету. Это может быть удобно в QML или сценариях, но имеет два основных недостатка. Во-первых, объект фактически остается &amp;laquo;пустым&amp;raquo; до тех пор, пока он не будет успешно инициализирован &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;источником&lt;/a&gt; . Во-вторых, в C ++ вызовы должны выполняться с использованием &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject :: invokeMethod&lt;/a&gt; (), так как поиск, сгенерированный moc, будет недоступен.</target>
        </trans-unit>
        <trans-unit id="08ec6e33eebed26c7c57c8ed22fb0ac60abd982e" translate="yes" xml:space="preserve">
          <source>When the content is changed using any of these functions, any previous content is cleared.</source>
          <target state="translated">При изменении содержимого с помощью любой из этих функций любое предыдущее содержимое удаляется.</target>
        </trans-unit>
        <trans-unit id="098eff2cee4bb06ded290defca5ca43aedeb73b3" translate="yes" xml:space="preserve">
          <source>When the current element is a map, you may also call &lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt;() to find out if the map's size is explicit in the CBOR stream. If it is, that size can be obtained by calling &lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt;().</source>
          <target state="translated">Когда текущий элемент является картой, вы также можете вызвать &lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt; (), чтобы узнать, явным ли размер карты в потоке CBOR. Если это так, этот размер можно получить, вызвав &lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="bea6a9143e97cc060ee75f79678b23a7773047e8" translate="yes" xml:space="preserve">
          <source>When the current element is an array, you may also call &lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt;() to find out if the array's size is explicit in the CBOR stream. If it is, that size can be obtained by calling &lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt;().</source>
          <target state="translated">Когда текущий элемент является массивом, вы также можете вызвать &lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt; (), чтобы узнать, является ли размер массива явным в потоке CBOR. Если это так, этот размер можно получить, вызвав &lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="f84400c746d8fc0a5a48647d3e3c7ab1cfd364c9" translate="yes" xml:space="preserve">
          <source>When the current file changes for local operations, this signal is emitted with the new file name as the</source>
          <target state="translated">Когда текущий файл изменяется для локальных операций,этот сигнал выдается с новым именем файла в виде файла в формате</target>
        </trans-unit>
        <trans-unit id="0a86295fc3e43e6a47bc831aed3e39216c7b217d" translate="yes" xml:space="preserve">
          <source>When the current file changes, this signal is emitted with the new file URL as the</source>
          <target state="translated">Когда текущий файл изменяется,этот сигнал выдается с новым URL-адресом файла в качестве</target>
        </trans-unit>
        <trans-unit id="8d02ddfa1e09fd4df4941f2aea01335858653f59" translate="yes" xml:space="preserve">
          <source>When the current loop changes, &lt;a href=&quot;qabstractanimation&quot;&gt;QAbstractAnimation&lt;/a&gt; emits the &lt;a href=&quot;qabstractanimation#currentLoopChanged&quot;&gt;currentLoopChanged&lt;/a&gt;() signal.</source>
          <target state="translated">Когда текущий цикл изменяется, &lt;a href=&quot;qabstractanimation&quot;&gt;QAbstractAnimation&lt;/a&gt; испускает сигнал &lt;a href=&quot;qabstractanimation#currentLoopChanged&quot;&gt;currentLoopChanged&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="0cfe43b8f234528af4d27981c91186f3fac30622" translate="yes" xml:space="preserve">
          <source>When the current size of the cache is greater than the &lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maximumCacheSize&lt;/a&gt;() older cache files are removed until the total size is less then 90% of &lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maximumCacheSize&lt;/a&gt;() starting with the oldest ones first using the file creation date to determine how old a cache file is.</source>
          <target state="translated">Когда текущий размер кеша больше, чем &lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maximumCacheSize&lt;/a&gt; (), более старые файлы кеша удаляются до тех пор, пока общий размер не станет меньше 90% от &lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maximumCacheSize&lt;/a&gt; (), начиная с самых старых, сначала используя дату создания файла для определения возраста файла кеша является.</target>
        </trans-unit>
        <trans-unit id="3e61c9290a3e31fccfacad9bcadb7f0ab37cb158" translate="yes" xml:space="preserve">
          <source>When the cursor is moved and the underlying formatting attributes change, the &lt;a href=&quot;qtextedit#currentCharFormatChanged&quot;&gt;currentCharFormatChanged&lt;/a&gt;() signal is emitted to reflect the new attributes at the new cursor position.</source>
          <target state="translated">Когда курсор перемещается и основные атрибуты форматирования меняются, излучается сигнал &lt;a href=&quot;qtextedit#currentCharFormatChanged&quot;&gt;currentCharFormatChanged&lt;/a&gt; (), отражающий новые атрибуты в новой позиции курсора.</target>
        </trans-unit>
        <trans-unit id="0bcf3c2857361e33820b911b748bda8d3e8f2499" translate="yes" xml:space="preserve">
          <source>When the cursor is over an object that can be used in a connection, the object will be highlighted.</source>
          <target state="translated">При наведении курсора на объект,который может быть использован в соединении,он будет выделен.</target>
        </trans-unit>
        <trans-unit id="d5828b4053e945be1fe64d76bbf73ddc4acecf13" translate="yes" xml:space="preserve">
          <source>When the dark theme is in use, different &lt;a href=&quot;#pre-defined-shades&quot;&gt;shades&lt;/a&gt; of the pre-defined colors are used by default:</source>
          <target state="translated">Когда используется темная тема, по умолчанию используются разные &lt;a href=&quot;#pre-defined-shades&quot;&gt;оттенки&lt;/a&gt; предопределенных цветов:</target>
        </trans-unit>
        <trans-unit id="3e63c161b63a9e90882d13f563f0753fdc02220f" translate="yes" xml:space="preserve">
          <source>When the dark theme is in use, different &lt;a href=&quot;qtquickcontrols2-material#pre-defined-shades&quot;&gt;shades&lt;/a&gt; of the pre-defined colors are used by default:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa15325522b12e3e10e05b6e7845de4c15cc9516" translate="yes" xml:space="preserve">
          <source>When the data has been set, the model must let the views know that some data has changed. This is done by emitting the &lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged()&lt;/a&gt; signal. Since only one item of data has changed, the range of items specified in the signal is limited to just one model index.</source>
          <target state="translated">Когда данные установлены, модель должна сообщить представлениям, что некоторые данные были изменены. Это делается с &lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;помощью&lt;/a&gt; сигнала dataChanged () . Поскольку изменился только один элемент данных, диапазон элементов, указанных в сигнале, ограничен только одним индексом модели.</target>
        </trans-unit>
        <trans-unit id="268c6bc406e79834c8bfc145b96838dee4c8962b" translate="yes" xml:space="preserve">
          <source>When the default OpenGL &lt;a href=&quot;qtquick-visualcanvas-scenegraph&quot;&gt;scene graph&lt;/a&gt; backend is in use, images can also be supplied in compressed texture files. The content must be a simple RGB(A) format 2D texture. Supported compression schemes are only limited by the underlying OpenGL driver and GPU. The following container file formats are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d841b77292d3e68d73048948b5c24756c32f98" translate="yes" xml:space="preserve">
          <source>When the default OpenGL &lt;a href=&quot;qtquick-visualcanvas-scenegraph#&quot;&gt;scene graph&lt;/a&gt; backend is in use, images can also be supplied in compressed texture files. The content must be a simple RGB(A) format 2D texture. Supported compression schemes are only limited by the underlying OpenGL driver and GPU. The following container file formats are supported:</source>
          <target state="translated">Когда используется бэкэнд &lt;a href=&quot;qtquick-visualcanvas-scenegraph#&quot;&gt;графа сцены&lt;/a&gt; OpenGL по умолчанию , изображения также могут поставляться в сжатых файлах текстуры. Контент должен быть простой 2D-текстурой в формате RGB (A). Поддерживаемые схемы сжатия ограничиваются только базовым драйвером OpenGL и графическим процессором. Поддерживаются следующие форматы файлов-контейнеров:</target>
        </trans-unit>
        <trans-unit id="64564ede097c86de33c3d219ff3f4d6b55c9c533" translate="yes" xml:space="preserve">
          <source>When the dialog needs to generate a set of preview pages, the &lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;paintRequested&lt;/a&gt;() signal will be emitted. You can use the exact same code for the actual printing as for having the preview generated, including calling &lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter::newPage&lt;/a&gt;() to start a new page in the preview. Connect a slot to the &lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;paintRequested&lt;/a&gt;() signal, where you draw onto the &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; object that is passed into the slot.</source>
          <target state="translated">Когда диалоговому окну необходимо сгенерировать набор страниц предварительного просмотра, будет &lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;выдан&lt;/a&gt; сигнал paintRequested (). Вы можете использовать тот же код для фактической печати, что и для создания предварительного просмотра, включая вызов &lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter :: newPage&lt;/a&gt; (), чтобы начать новую страницу в предварительном просмотре. Подключите слот к &lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;сигналу paintRequested&lt;/a&gt; (), где вы рисуете на объекте &lt;a href=&quot;qprinter&quot;&gt;QPrinter,&lt;/a&gt; который передается в слот.</target>
        </trans-unit>
        <trans-unit id="442b26fe36b5b6b28e8fee4c93f0f0f9179a4be0" translate="yes" xml:space="preserve">
          <source>When the disk cache is disabled, via &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt::AA_DisableShaderDiskCache&lt;/a&gt; for example, or the OpenGL context has no support for context binaries, calling this function is equivalent to &lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceCode&quot;&gt;addShaderFromSourceCode&lt;/a&gt;().</source>
          <target state="translated">Когда дисковый кеш отключен, например , через &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt :: AA_DisableShaderDiskCache&lt;/a&gt; , или контекст OpenGL не поддерживает двоичные файлы контекста, вызов этой функции эквивалентен &lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceCode&quot;&gt;addShaderFromSourceCode&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="9a274b9868a858f6451036974bc85cd45ebacc98" translate="yes" xml:space="preserve">
          <source>When the disk cache is disabled, via &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt::AA_DisableShaderDiskCache&lt;/a&gt; for example, or the OpenGL context has no support for context binaries, calling this function is equivalent to &lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceFile&quot;&gt;addShaderFromSourceFile&lt;/a&gt;().</source>
          <target state="translated">Когда кеш диска отключен, например , через &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt :: AA_DisableShaderDiskCache&lt;/a&gt; , или контекст OpenGL не поддерживает двоичные файлы контекста, вызов этой функции эквивалентен &lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceFile&quot;&gt;addShaderFromSourceFile&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="cfc128bc4fe84e02bab33b87cc2068b75786b6b9" translate="yes" xml:space="preserve">
          <source>When the dock widget lays out its contents it asks the style for these pixel metrics: &lt;code&gt;PM_DockWidgetSeparatorExtent&lt;/code&gt;, &lt;code&gt;PM_DockWidgetTitleBarButtonMargin&lt;/code&gt;, &lt;code&gt;PM_DockWidgetFrameWidth&lt;/code&gt;, and &lt;code&gt;PM_DockWidgetTitleMargin&lt;/code&gt;. It also calculates the bounding rectangles of the float and close buttons with &lt;code&gt;SE_DockWidgetCloseButton&lt;/code&gt; and &lt;code&gt;SE_DockWidgetFloatButton&lt;/code&gt;.</source>
          <target state="translated">Когда виджет док-станции выкладывает свое содержимое, он запрашивает стиль для этих показателей пикселей: &lt;code&gt;PM_DockWidgetSeparatorExtent&lt;/code&gt; , &lt;code&gt;PM_DockWidgetTitleBarButtonMargin&lt;/code&gt; , &lt;code&gt;PM_DockWidgetFrameWidth&lt;/code&gt; и &lt;code&gt;PM_DockWidgetTitleMargin&lt;/code&gt; . Он также вычисляет ограничивающие прямоугольники кнопок плавания и закрытия с помощью &lt;code&gt;SE_DockWidgetCloseButton&lt;/code&gt; и &lt;code&gt;SE_DockWidgetFloatButton&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc07829ed23956686aa2110b6aa13a3a31695d82" translate="yes" xml:space="preserve">
          <source>When the edit strategy is &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmit&lt;/a&gt;, deletion of rows from the database is delayed until &lt;a href=&quot;qsqltablemodel#submitAll&quot;&gt;submitAll&lt;/a&gt;() is called.</source>
          <target state="translated">Если используется стратегия редактирования &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmit&lt;/a&gt; , удаление строк из базы данных откладывается до &lt;a href=&quot;qsqltablemodel#submitAll&quot;&gt;вызова submitAll&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="69d60b285999f455929d7c354ec16df415cf791e" translate="yes" xml:space="preserve">
          <source>When the error occurs in code that uses the &lt;a href=&quot;qaxfactory#QAXCLASS&quot;&gt;QAXCLASS&lt;/a&gt;() or QAXFACTORY_DEFAULT() macro, the widget class had no constructor that can be used by the default factory. Either add a standard widget constructor or implement a custom factory that doesn't require one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce533133f051ef361f68d445640b0f45e1ae0bd" translate="yes" xml:space="preserve">
          <source>When the error occurs in code that uses the &lt;a href=&quot;qaxfactory#QAXFACTORY_DEFAULT&quot;&gt;QAXFACTORY_DEFAULT&lt;/a&gt;() macro, the widget class had no constructor that can be used by the default factory. Either add a standard widget constructor or implement a custom factory that doesn't require one.</source>
          <target state="translated">Когда ошибка возникает в коде, который использует &lt;a href=&quot;qaxfactory#QAXFACTORY_DEFAULT&quot;&gt;макрос QAXFACTORY_DEFAULT&lt;/a&gt; (), у класса виджета нет конструктора, который может использоваться фабрикой по умолчанию. Либо добавьте стандартный конструктор виджетов, либо реализуйте настраиваемую фабрику, которая не требует его.</target>
        </trans-unit>
        <trans-unit id="67528e55cc72382a76299d4a29a6d404185ca633" translate="yes" xml:space="preserve">
          <source>When the error occurs in code that uses the &lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt;() macro, the &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; subclass had no appropriate constructor. Provide a public class constructor like</source>
          <target state="translated">Когда ошибка возникает в коде, который использует &lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;макрос QAXFACTORY_EXPORT&lt;/a&gt; (), подкласс &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; не имеет подходящего конструктора. Предоставьте конструктор общедоступного класса, например</target>
        </trans-unit>
        <trans-unit id="667bcb82ac840306758fe028ef02a3142d64c33c" translate="yes" xml:space="preserve">
          <source>When the file was created (may not be not supported on UNIX).</source>
          <target state="translated">Когда файл был создан (может не поддерживаться на UNIX).</target>
        </trans-unit>
        <trans-unit id="b25b4b7cadd51d3809c6192d30e9736fd31ceee0" translate="yes" xml:space="preserve">
          <source>When the file was most recently accessed (e.g. read or written to).</source>
          <target state="translated">Когда файл был доступен в последний раз (например,прочитан или записан в).</target>
        </trans-unit>
        <trans-unit id="4c27bd30e3a44efb1b186d178c93f6ceaf40ce32" translate="yes" xml:space="preserve">
          <source>When the file was most recently modified.</source>
          <target state="translated">Когда файл был изменен совсем недавно.</target>
        </trans-unit>
        <trans-unit id="d5d340431973f92573daf9a19dcdb9fd00b81737" translate="yes" xml:space="preserve">
          <source>When the file's metadata was last changed.</source>
          <target state="translated">Когда метаданные файла были в последний раз изменены.</target>
        </trans-unit>
        <trans-unit id="0ed30361bc54f69e5900b60fbcec5e46b66fc62b" translate="yes" xml:space="preserve">
          <source>When the filter object's &lt;a href=&quot;qobject#eventFilter&quot;&gt;eventFilter()&lt;/a&gt; implementation is called, it can accept or reject the event, and allow or deny further processing of the event. If all the event filters allow further processing of an event (by each returning &lt;code&gt;false&lt;/code&gt;), the event is sent to the target object itself. If one of them stops processing (by returning &lt;code&gt;true&lt;/code&gt;), the target and any later event filters do not get to see the event at all.</source>
          <target state="translated">Когда &lt;a href=&quot;qobject#eventFilter&quot;&gt;вызывается&lt;/a&gt; реализация объекта фильтра eventFilter () , она может принять или отклонить событие, а также разрешить или запретить дальнейшую обработку события. Если все фильтры событий разрешают дальнейшую обработку события (каждый из которых возвращает &lt;code&gt;false&lt;/code&gt; ), событие отправляется самому целевому объекту. Если один из них прекращает обработку (возвращая &lt;code&gt;true&lt;/code&gt; ), целевой и любые последующие фильтры событий вообще не видят событие.</target>
        </trans-unit>
        <trans-unit id="837b081290388ef24310dab55793156db9eb9dfc" translate="yes" xml:space="preserve">
          <source>When the first touch point is detected, the destination widget is determined firstly by the location on screen and secondly by the propagation rules.</source>
          <target state="translated">При обнаружении первой точки касания виджет-получатель определяется,во-первых,местоположением на экране,а во-вторых,правилами распространения.</target>
        </trans-unit>
        <trans-unit id="da3ee5de937f78331baaaed7a12ec8f5b5ae3e7b" translate="yes" xml:space="preserve">
          <source>When the format is extended and a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ff0e9974e90a3bb46faadb679db78b2703c023" translate="yes" xml:space="preserve">
          <source>When the format is not explicitly set via this function, the format returned by &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat::defaultFormat&lt;/a&gt;() will be used. This means that when having multiple OpenGL widgets, individual calls to this function can be replaced by one single call to &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;() before creating the first widget.</source>
          <target state="translated">Если формат не задан явно с помощью этой функции, будет использоваться формат, возвращаемый &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat :: defaultFormat&lt;/a&gt; (). Это означает, что при наличии нескольких виджетов OpenGL отдельные вызовы этой функции могут быть заменены одним единственным вызовом &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat :: setDefaultFormat&lt;/a&gt; () перед созданием первого виджета.</target>
        </trans-unit>
        <trans-unit id="2beb1fd6e4f28222293604d7f4d897a896d350d1" translate="yes" xml:space="preserve">
          <source>When the format is not explicitly set via this function, the format returned by &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat::defaultFormat&lt;/a&gt;() will be used. This means that when having multiple contexts, individual calls to this function can be replaced by one single call to &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;() before creating the first context.</source>
          <target state="translated">Если формат не задан явно с помощью этой функции, будет использоваться формат, возвращаемый &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat :: defaultFormat&lt;/a&gt; (). Это означает, что при наличии нескольких контекстов отдельные вызовы этой функции могут быть заменены одним единственным вызовом &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat :: setDefaultFormat&lt;/a&gt; () перед созданием первого контекста.</target>
        </trans-unit>
        <trans-unit id="00713dadf93099ecb982ada3e77d69bdabc871f2" translate="yes" xml:space="preserve">
          <source>When the format is not explicitly set via this function, the format returned by &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat::defaultFormat&lt;/a&gt;() will be used. This means that when having multiple windows, individual calls to this function can be replaced by one single call to &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;() before creating the first window.</source>
          <target state="translated">Если формат не задан явно с помощью этой функции, будет использоваться формат, возвращаемый &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat :: defaultFormat&lt;/a&gt; (). Это означает, что при наличии нескольких окон отдельные вызовы этой функции могут быть заменены одним единственным вызовом &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat :: setDefaultFormat&lt;/a&gt; () перед созданием первого окна.</target>
        </trans-unit>
        <trans-unit id="25d8d569194c95628c8a9af91c9b0f5b8ee86128" translate="yes" xml:space="preserve">
          <source>When the given</source>
          <target state="translated">Когда дано</target>
        </trans-unit>
        <trans-unit id="a84c5e22d39ffceb346211bc14286a14c79f8784" translate="yes" xml:space="preserve">
          <source>When the horizontal alignment of a text item is not explicitly set, the text element is automatically aligned to the natural reading direction of the text. By default left-to-right text like English is aligned to the left side of the text area, and right-to-left text like Arabic is aligned to the right side of the text area. The alignment of a text element with empty text takes its alignment cue from &lt;a href=&quot;qinputmethod#inputDirection-prop&quot;&gt;QInputMethod::inputDirection&lt;/a&gt;(), which is based on the active system locale.</source>
          <target state="translated">Если горизонтальное выравнивание текстового элемента не задано явно, текстовый элемент автоматически выравнивается по естественному направлению чтения текста. По умолчанию текст с письмом слева направо, например английский, выравнивается по левой стороне текстовой области, а текст с письмом справа налево, например арабский, выравнивается по правой стороне текстовой области. Выравнивание текстового элемента с пустым текстом получает сигнал выравнивания от &lt;a href=&quot;qinputmethod#inputDirection-prop&quot;&gt;QInputMethod :: inputDirection&lt;/a&gt; (), который основан на активной языковой версии системы.</target>
        </trans-unit>
        <trans-unit id="2f163bb4526ffce4c5d0c97da01d544fc9ab7648" translate="yes" xml:space="preserve">
          <source>When the image is ready, &lt;a href=&quot;qml-qtquick-canvas#imageLoaded-signal&quot;&gt;imageLoaded&lt;/a&gt; will be emitted. The loaded image can be unloaded by the &lt;a href=&quot;qml-qtquick-canvas#unloadImage-method&quot;&gt;unloadImage()&lt;/a&gt; method.</source>
          <target state="translated">Когда изображение будет готово, будет &lt;a href=&quot;qml-qtquick-canvas#imageLoaded-signal&quot;&gt;запущено imageLoaded&lt;/a&gt; . Загруженное изображение можно выгрузить методом &lt;a href=&quot;qml-qtquick-canvas#unloadImage-method&quot;&gt;unloadImage ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4722dd5405336bb1dc515fbc7e7e1db0a5d91ef2" translate="yes" xml:space="preserve">
          <source>When the image is scaled, regions of the source image are scaled or tiled to create the displayed border image in the following way:</source>
          <target state="translated">При масштабировании изображения области исходного изображения масштабируются или чередуются для создания отображаемого изображения границы следующим образом:</target>
        </trans-unit>
        <trans-unit id="cb1a5c40c986de8b7e66b324c82e0775e3788bc6" translate="yes" xml:space="preserve">
          <source>When the image is used, the color table must be large enough to have entries for all the pixel/index values present in the image, otherwise the results are undefined.</source>
          <target state="translated">При использовании изображения таблица цветов должна быть достаточно большой,чтобы в ней содержались записи для всех значений пикселей/индексов,присутствующих на изображении,в противном случае результаты не будут определены.</target>
        </trans-unit>
        <trans-unit id="a62a0ab3afb30df54c7a307954a51b28f0879b31" translate="yes" xml:space="preserve">
          <source>When the indexing process has finished, the search engine can be used to search through the index for a given term using the search() function. When the search input is passed to the search engine, the &lt;a href=&quot;qhelpsearchengine#searchingStarted&quot;&gt;searchingStarted&lt;/a&gt;() signal is emitted. When the search finishes, the &lt;a href=&quot;qhelpsearchengine#searchingFinished&quot;&gt;searchingFinished&lt;/a&gt;() signal is emitted. The search process can be stopped by calling &lt;a href=&quot;qhelpsearchengine#cancelSearching&quot;&gt;cancelSearching&lt;/a&gt;().</source>
          <target state="translated">Когда процесс индексирования завершен, поисковая машина может использоваться для поиска в индексе заданного термина с помощью функции search (). Когда поисковый ввод передается в поисковую систему, &lt;a href=&quot;qhelpsearchengine#searchingStarted&quot;&gt;выдается&lt;/a&gt; сигнал searchStarted (). Когда поиск заканчивается, &lt;a href=&quot;qhelpsearchengine#searchingFinished&quot;&gt;выдается&lt;/a&gt; сигнал searchFinished (). Процесс поиска можно остановить, вызвав &lt;a href=&quot;qhelpsearchengine#cancelSearching&quot;&gt;cancelSearching&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="abed85d30a721e876a4399c7b26aa9eed3e46ead" translate="yes" xml:space="preserve">
          <source>When the input method requires the UI to update the contents of a selection list, it will emit the &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListChanged-signal&quot;&gt;InputMethod::selectionListChanged&lt;/a&gt; signal. Likewise, if the input method requires the UI to highlight an item in the list, it will emit the &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListActiveItemChanged-signal&quot;&gt;InputMethod::selectionListActiveItemChanged&lt;/a&gt; signal.</source>
          <target state="translated">Когда метод ввода требует, чтобы пользовательский интерфейс &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListChanged-signal&quot;&gt;обновил&lt;/a&gt; содержимое списка выбора, он испускает сигнал InputMethod :: selectionListChanged . Точно так же, если метод ввода требует, чтобы пользовательский интерфейс выделил элемент в списке, он испустит сигнал &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListActiveItemChanged-signal&quot;&gt;InputMethod :: selectionListActiveItemChanged&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af13632c6936ddc6476f8bec001c16d3ccdb1b88" translate="yes" xml:space="preserve">
          <source>When the interaction is completed we strongly recommend releasing the user interaction semaphore with a call to &lt;a href=&quot;qsessionmanager#release&quot;&gt;release&lt;/a&gt;(). This way, other applications may get the chance to interact with the user while your application is still busy saving data. (The semaphore is implicitly released when the application exits.)</source>
          <target state="translated">Когда взаимодействие завершено, мы настоятельно рекомендуем освободить семафор взаимодействия с пользователем с помощью вызова &lt;a href=&quot;qsessionmanager#release&quot;&gt;release&lt;/a&gt; (). Таким образом, другие приложения могут получить возможность взаимодействовать с пользователем, пока ваше приложение все еще сохраняет данные. (Семафор неявно освобождается при выходе из приложения.)</target>
        </trans-unit>
        <trans-unit id="a08dbc79fd5ced7fe929c3d064e1b645b21d39b2" translate="yes" xml:space="preserve">
          <source>When the labels are editable the user will be able to change the range of the axis conveniently by editing any of the labels. This feature is only supported for the &lt;a href=&quot;qvalueaxis&quot;&gt;QValueAxis&lt;/a&gt; and the &lt;a href=&quot;qdatetimeaxis&quot;&gt;QDateTimeAxis&lt;/a&gt;.</source>
          <target state="translated">Когда метки доступны для редактирования, пользователь сможет удобно изменять диапазон оси, редактируя любую из меток. Эта функция поддерживается только для &lt;a href=&quot;qvalueaxis&quot;&gt;QValueAxis&lt;/a&gt; и &lt;a href=&quot;qdatetimeaxis&quot;&gt;QDateTimeAxis&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="16aac338dd8507181525a913639f185cb93e3d46" translate="yes" xml:space="preserve">
          <source>When the layout direction is set on a widget, it will propagate to the widget's children, but not to a child that is a window and not to a child for which setLayoutDirection() has been explicitly called. Also, child widgets added</source>
          <target state="translated">При установке направления компоновки на виджет,он будет распространяться на дочерние элементы виджета,но не на дочерний элемент,который является окном,и не на дочерний элемент,для которого явно вызвана функция setLayoutDirection().Также добавлены дочерние виджеты</target>
        </trans-unit>
        <trans-unit id="757e208faf34bd91da1b625ef70871bbc740552e" translate="yes" xml:space="preserve">
          <source>When the layout's geometry changes, &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt; immediately rearranges all of its managed items by calling &lt;a href=&quot;qgraphicslayoutitem#setGeometry&quot;&gt;setGeometry&lt;/a&gt;() on each item. This rearrangement is called</source>
          <target state="translated">Когда геометрия макета изменяется, &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt; немедленно переупорядочивает все свои управляемые элементы, вызывая &lt;a href=&quot;qgraphicslayoutitem#setGeometry&quot;&gt;setGeometry&lt;/a&gt; () для каждого элемента. Эта перестановка называется</target>
        </trans-unit>
        <trans-unit id="14d52274c262e663bee4bb6936d376e01f9d9786" translate="yes" xml:space="preserve">
          <source>When the layout's geometry changes, QGraphicsLayout immediately rearranges all of its managed items by calling &lt;a href=&quot;qgraphicslayoutitem#setGeometry&quot;&gt;setGeometry&lt;/a&gt;() on each item. This rearrangement is called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4868cf3fc8227fd58f7cf326e3d937144f921d5" translate="yes" xml:space="preserve">
          <source>When the locale is not specified, the default system locale is used instead.</source>
          <target state="translated">Если локаль не указана,вместо нее используется системная локаль по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d8c8da609611d53dcc5b14869c74793f679093e3" translate="yes" xml:space="preserve">
          <source>When the machine is in state &lt;code&gt;s2&lt;/code&gt;, the machine will play the default animation for the property &lt;code&gt;fooBar&lt;/code&gt; since this property is assigned by &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">Когда машина находится в состоянии &lt;code&gt;s2&lt;/code&gt; , машина будет воспроизводить анимацию по умолчанию для свойства &lt;code&gt;fooBar&lt;/code&gt; , поскольку это свойство присвоено &lt;code&gt;s2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e08c3bd224be28ab8da0d15a3e80244ae34b5521" translate="yes" xml:space="preserve">
          <source>When the map is displayed, each possible geographic coordinate that is visible will map to some pixel X and Y coordinate on the screen. To perform conversions between these two, Map provides the &lt;a href=&quot;qml-qtlocation-map#toCoordinate-method&quot;&gt;toCoordinate&lt;/a&gt; and &lt;a href=&quot;qml-qtlocation-map#fromCoordinate-method&quot;&gt;fromCoordinate&lt;/a&gt; functions, which are of general utility.</source>
          <target state="translated">Когда карта отображается, каждая возможная географическая координата, которая видна, будет соответствовать некоторой координате X и Y пикселя на экране. Для выполнения преобразований между этими двумя функциями Map предоставляет функции &lt;a href=&quot;qml-qtlocation-map#toCoordinate-method&quot;&gt;toCoordinate&lt;/a&gt; и &lt;a href=&quot;qml-qtlocation-map#fromCoordinate-method&quot;&gt;fromCoordinate&lt;/a&gt; , которые имеют общую полезность.</target>
        </trans-unit>
        <trans-unit id="c5d7b44152d91a8b1270640c20696e9ece89a8be" translate="yes" xml:space="preserve">
          <source>When the mode changes, &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; emits &lt;a href=&quot;qsslsocket#modeChanged&quot;&gt;modeChanged&lt;/a&gt;()</source>
          <target state="translated">При изменении режима &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; испускает &lt;a href=&quot;qsslsocket#modeChanged&quot;&gt;modeChanged&lt;/a&gt; ()</target>
        </trans-unit>
        <trans-unit id="f34a87a12fe283ceded3dd1abbd77031338a6cd0" translate="yes" xml:space="preserve">
          <source>When the model has multiple roles, &lt;code&gt;textRole&lt;/code&gt; can be set to determine which role should be displayed.</source>
          <target state="translated">Если модель имеет несколько ролей, можно задать &lt;code&gt;textRole&lt;/code&gt; , чтобы определить, какая роль должна отображаться.</target>
        </trans-unit>
        <trans-unit id="da9a781aefd18e2834be4ea55a33a7e98b410511" translate="yes" xml:space="preserve">
          <source>When the model has multiple roles, textRole can be set to determine which role should be displayed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="422c5c92ca52eb6e2a6538c002cc9123999cfea0" translate="yes" xml:space="preserve">
          <source>When the mouse is pressed, the &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; changes to the</source>
          <target state="translated">При нажатии мыши &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;прямоугольник&lt;/a&gt; меняется на</target>
        </trans-unit>
        <trans-unit id="5657ede20e143f6d442db18b090e618d804d1de7" translate="yes" xml:space="preserve">
          <source>When the mouse moves over the item,</source>
          <target state="translated">При наведении курсора мыши на объект,</target>
        </trans-unit>
        <trans-unit id="91af59e60e5984086456c7ad2a2054d514962b50" translate="yes" xml:space="preserve">
          <source>When the number of commands on a stack exceedes the stack's undoLimit, commands are deleted from the bottom of the stack. Macro commands (commands with child commands) are treated as one command. The default value is 0, which means that there is no limit.</source>
          <target state="translated">Когда количество команд на стеке превышает количество отказов стека,команды удаляются из нижней части стека.Команды макросов (команды с дочерними командами)рассматриваются как одна команда.Значение по умолчанию равно 0,что означает отсутствие предела.</target>
        </trans-unit>
        <trans-unit id="001d63f0ced7bf39910f29efe7f6f5fd05b477ff" translate="yes" xml:space="preserve">
          <source>When the number of matches cannot be determined in advance, a common idiom is to use &lt;a href=&quot;qregexp#cap&quot;&gt;cap&lt;/a&gt;() in a loop. For example:</source>
          <target state="translated">Когда количество совпадений не может быть определено заранее, распространенной идиомой является использование &lt;a href=&quot;qregexp#cap&quot;&gt;cap&lt;/a&gt; () в цикле. Например:</target>
        </trans-unit>
        <trans-unit id="19d271264efc628bb86bca221e850d0c5cb77458" translate="yes" xml:space="preserve">
          <source>When the object supports multiple selections (e.g. in a word processor), this adds a new selection, otherwise it replaces the previous selection.</source>
          <target state="translated">Когда объект поддерживает множественные выделения (например,в текстовом процессоре),он добавляет новое выделение,в противном случае он заменяет предыдущее выделение.</target>
        </trans-unit>
        <trans-unit id="73cf6131f4a582c72bc9f9330edcb48af4fcc81f" translate="yes" xml:space="preserve">
          <source>When the page is inserted into a wizard using &lt;a href=&quot;qwizard#addPage&quot;&gt;QWizard::addPage&lt;/a&gt;() or &lt;a href=&quot;qwizard#setPage&quot;&gt;QWizard::setPage&lt;/a&gt;(), the parent is automatically set to be the wizard.</source>
          <target state="translated">Когда страница вставляется в мастер с помощью &lt;a href=&quot;qwizard#addPage&quot;&gt;QWizard :: addPage&lt;/a&gt; () или &lt;a href=&quot;qwizard#setPage&quot;&gt;QWizard :: setPage&lt;/a&gt; (), родительский элемент автоматически становится мастером.</target>
        </trans-unit>
        <trans-unit id="35fc6c728ad882d547072f431eb37b1425e9f468" translate="yes" xml:space="preserve">
          <source>When the paint event occurs, the update region has normally been erased, so you are painting on the widget's background.</source>
          <target state="translated">При возникновении события рисования область обновления обычно стирается,поэтому рисование выполняется на фоне виджета.</target>
        </trans-unit>
        <trans-unit id="f30c7c3f40f1a872547881cd7951c22cee36c1cd" translate="yes" xml:space="preserve">
          <source>When the parameter is set to &lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;DepthMode&lt;/a&gt;, then accessing it from the shader will access the depth component as a single float, as normal. But when the parameter is set to &lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;StencilMode&lt;/a&gt;, the shader will access the stencil component.</source>
          <target state="translated">Если для параметра задано значение &lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;DepthMode&lt;/a&gt; , то доступ к нему из шейдера будет обращаться к компоненту глубины как к одному веществу с плавающей запятой, как обычно. Но когда для параметра установлено значение &lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;StencilMode&lt;/a&gt; , шейдер будет обращаться к компоненту трафарета.</target>
        </trans-unit>
        <trans-unit id="2375fc19af6a76757eb823a66fb6127ba87e61c2" translate="yes" xml:space="preserve">
          <source>When the parser encounters an error, it signals the event by making &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;() return false and &lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt;() / &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt;() return an empty string. If it is necessary to show the user the reason why the URL failed to parse, the error condition can be obtained from &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; by calling &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;(). Note that this message is highly technical and may not make sense to end-users.</source>
          <target state="translated">Когда анализатор обнаруживает ошибку, он сигнализирует о событии, заставляя &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt; () возвращать false, а &lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt; () / &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt; () возвращать пустую строку. Если необходимо показать пользователю причину, по которой URL-адрес не удалось проанализировать, состояние ошибки можно получить из &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; , вызвав &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt; (). Обратите внимание, что это сообщение носит технический характер и может не иметь смысла для конечных пользователей.</target>
        </trans-unit>
        <trans-unit id="811d686f479044d2209c2819d361efa6d361ce38" translate="yes" xml:space="preserve">
          <source>When the parser encounters an error, it signals the event by making &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;() return false and &lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt;() / &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt;() return an empty string. If it is necessary to show the user the reason why the URL failed to parse, the error condition can be obtained from QUrl by calling &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;(). Note that this message is highly technical and may not make sense to end-users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ba901eeb2daca251dbecc6e227457e431d3835" translate="yes" xml:space="preserve">
          <source>When the player object is buffering; this property holds the percentage of the temporary buffer that is filled. The buffer will need to reach 100% filled before playback can start or resume, at which time &lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus&lt;/a&gt;() will return &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferedMedia&lt;/a&gt; or &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferingMedia&lt;/a&gt;. If the value is anything lower than &lt;code&gt;100&lt;/code&gt;, &lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus&lt;/a&gt;() will return &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;StalledMedia&lt;/a&gt;.</source>
          <target state="translated">Когда объект игрока буферизируется; это свойство содержит процент заполнения временного буфера. Буфер должен быть заполнен на 100%, прежде чем воспроизведение можно будет начать или возобновить, после чего &lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus&lt;/a&gt; () вернет &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferedMedia&lt;/a&gt; или &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferingMedia&lt;/a&gt; . Если значение меньше &lt;code&gt;100&lt;/code&gt; , &lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus&lt;/a&gt; () вернет &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;StalledMedia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da64dfb7cefdbeef317abcd7e43d7b305a5ee3ab" translate="yes" xml:space="preserve">
          <source>When the popup actually receives focus, &lt;a href=&quot;qml-qtquick-controls2-popup#activeFocus-prop&quot;&gt;activeFocus&lt;/a&gt; will be &lt;code&gt;true&lt;/code&gt;. For more information, see &lt;a href=&quot;qtquick-input-focus&quot;&gt;Keyboard Focus in Qt Quick&lt;/a&gt;.</source>
          <target state="translated">Когда всплывающее окно действительно получает фокус, &lt;a href=&quot;qml-qtquick-controls2-popup#activeFocus-prop&quot;&gt;activeFocus&lt;/a&gt; будет &lt;code&gt;true&lt;/code&gt; . Для получения дополнительной информации см. &lt;a href=&quot;qtquick-input-focus&quot;&gt;Фокус клавиатуры в Qt Quick&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6f2faeb8b71e0aaa953aece87da658ef327fd51" translate="yes" xml:space="preserve">
          <source>When the popup actually receives focus, activeFocus will be &lt;code&gt;true&lt;/code&gt;. For more information, see &lt;a href=&quot;qtquick-input-focus&quot;&gt;Keyboard Focus in Qt Quick&lt;/a&gt;.</source>
          <target state="translated">Когда всплывающее окно действительно получает фокус, activeFocus будет &lt;code&gt;true&lt;/code&gt; . Для получения дополнительной информации см. &lt;a href=&quot;qtquick-input-focus&quot;&gt;Фокус клавиатуры в Qt Quick&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1bac0637a72484b23805b1cfc6b209249217f5b" translate="yes" xml:space="preserve">
          <source>When the process exits, &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; reenters the &lt;a href=&quot;qprocess#ProcessState-enum&quot;&gt;NotRunning&lt;/a&gt; state (the initial state), and emits &lt;a href=&quot;qprocess#finished&quot;&gt;finished&lt;/a&gt;().</source>
          <target state="translated">Когда процесс завершается, &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; повторно &lt;a href=&quot;qprocess#ProcessState-enum&quot;&gt;входит в&lt;/a&gt; состояние NotRunning (начальное состояние) и выдает команду &lt;a href=&quot;qprocess#finished&quot;&gt;finished&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="166deb4e86216777686c8338ec5e1b04fbb74123" translate="yes" xml:space="preserve">
          <source>When the process exits, QProcess reenters the &lt;a href=&quot;qprocess#ProcessState-enum&quot;&gt;NotRunning&lt;/a&gt; state (the initial state), and emits &lt;a href=&quot;qprocess#finished&quot;&gt;finished&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48359f3ebe88aa74d829db24de3e755c6a235ddd" translate="yes" xml:space="preserve">
          <source>When the property is &lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt::LogicalMoveStyle&lt;/a&gt; (the default), within a LTR text block, increase cursor position when pressing left arrow key, decrease cursor position when pressing the right arrow key. If the text block is right to left, the opposite behavior applies.</source>
          <target state="translated">Если свойство - &lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt :: LogicalMoveStyle&lt;/a&gt; (по умолчанию), в текстовом блоке LTR увеличивайте положение курсора при нажатии клавиши со стрелкой влево, уменьшайте положение курсора при нажатии клавиши со стрелкой вправо. Если текстовый блок расположен справа налево, применяется противоположное поведение.</target>
        </trans-unit>
        <trans-unit id="8bce9d7a133b3737e2c5d22d038d7b3c4e7911f8" translate="yes" xml:space="preserve">
          <source>When the property is set to &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelection&lt;/a&gt;, the user will be unable to select dates, but they can still be selected programmatically. Note that the date that is selected when the property is set to &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelection&lt;/a&gt; will still be the selected date of the calendar.</source>
          <target state="translated">Если для свойства установлено значение &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelection&lt;/a&gt; , пользователь не сможет выбирать даты, но их можно выбрать программно. Обратите внимание, что дата, выбранная, когда для свойства установлено значение &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelection&lt;/a&gt; , по-прежнему будет выбранной датой календаря.</target>
        </trans-unit>
        <trans-unit id="1fdcbc355a573b53369d224635c5476baea07222" translate="yes" xml:space="preserve">
          <source>When the property is set to false, these controls are hidden.</source>
          <target state="translated">Когда свойство установлено в false,эти элементы управления скрыты.</target>
        </trans-unit>
        <trans-unit id="aa8094b9e2a50ed05d31d86aa20fac7cfb61c508" translate="yes" xml:space="preserve">
          <source>When the renderer reaches a leaf node of the framegraph, it collects together all of the state specified by the path from the leaf node to the root node. This defines the state used to render a section of the frame. If you are interested in the internals of Qt 3D, this collection of state is called a</source>
          <target state="translated">Когда рендер достигает узла листа фреймграфа,он собирает все состояние,заданное путём от узла листа к корневому узлу.Это определяет состояние,используемое для рендеринга участка кадра.Если вы заинтересованы во внутреннем устройстве Qt 3D,эта коллекция состояний называется</target>
        </trans-unit>
        <trans-unit id="db214d0296a6a87ece4578bc42783f851f457093" translate="yes" xml:space="preserve">
          <source>When the request is processed and a reply is available, it should be sent using the &lt;code&gt;QDBusMessage&lt;/code&gt; object that was obtained. In our example, the reply code could be something as follows:</source>
          <target state="translated">Когда запрос обработан и доступен ответ, он должен быть отправлен с использованием &lt;code&gt;QDBusMessage&lt;/code&gt; объекта QDBusMessage . В нашем примере код ответа может быть следующим:</target>
        </trans-unit>
        <trans-unit id="53d591cc65e5ee2ed7378bddbef5b69a1bcfde7b" translate="yes" xml:space="preserve">
          <source>When the results of an &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; are returned in a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt;, atomic values in the sequence are treated as instances of &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;. Suppose that instead of serializing the results of the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; as XML, we process the results programatically. Modify the standard Qt XML Patterns code sequence to call the overload of &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery::evaluateTo&lt;/a&gt;() that populates a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt; with the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; results:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351834125e0c92d0f208676bc4e74950d662675c" translate="yes" xml:space="preserve">
          <source>When the results of an XQuery are returned in a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt;, atomic values in the sequence are treated as instances of &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;. Suppose that instead of serializing the results of the XQuery as XML, we process the results programatically. Modify the standard Qt XML Patterns code sequence to call the overload of &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery::evaluateTo&lt;/a&gt;() that populates a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt; with the XQuery results:</source>
          <target state="translated">Когда результаты XQuery возвращаются в последовательности элементов &lt;a href=&quot;qxmlresultitems&quot;&gt;результата&lt;/a&gt; , атомарные значения в последовательности обрабатываются как экземпляры &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; . Предположим, что вместо сериализации результатов XQuery как XML мы обрабатываем результаты программно. Измените стандартную последовательность кода Qt XML Patterns, чтобы вызвать перегрузку &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery :: valuTo&lt;/a&gt; (), которая заполняет последовательность элементов &lt;a href=&quot;qxmlresultitems&quot;&gt;результатов результатами&lt;/a&gt; XQuery:</target>
        </trans-unit>
        <trans-unit id="763552f30b01b66449cf8883bed75293d360c6fc" translate="yes" xml:space="preserve">
          <source>When the return value is &lt;code&gt;false&lt;/code&gt;, vertex array object support is not available. This is not an error: on systems with OpenGL 2.x or OpenGL ES 2.0 vertex array objects may not be supported. The application is free to continue execution in this case, but it then has to be prepared to operate in a VAO-less manner too. This means that instead of merely calling &lt;a href=&quot;qopenglvertexarrayobject#bind&quot;&gt;bind&lt;/a&gt;(), the value of &lt;a href=&quot;qopenglvertexarrayobject#isCreated&quot;&gt;isCreated&lt;/a&gt;() must be checked and the vertex arrays has to be initialized in the traditional way when there is no vertex array object present.</source>
          <target state="translated">Когда возвращаемое значение &lt;code&gt;false&lt;/code&gt; , поддержка объекта массива вершин недоступна. Это не ошибка: в системах с OpenGL 2.x или OpenGL ES 2.0 объекты массива вершин могут не поддерживаться. В этом случае приложение может продолжить выполнение, но затем оно должно быть подготовлено к работе без VAO. Это означает, что вместо простого вызова &lt;a href=&quot;qopenglvertexarrayobject#bind&quot;&gt;bind&lt;/a&gt; () должно быть проверено значение &lt;a href=&quot;qopenglvertexarrayobject#isCreated&quot;&gt;isCreated&lt;/a&gt; (), а массивы вершин должны быть инициализированы традиционным способом, когда объект массива вершин отсутствует.</target>
        </trans-unit>
        <trans-unit id="446681578342ec9dac4cdce0d061b46969bca33b" translate="yes" xml:space="preserve">
          <source>When the run type is set to Manual, calling trigger will make the compute command be executed for the next</source>
          <target state="translated">Когда тип выполнения установлен в ручной режим,вызов триггера заставит вычислительную команду выполнить следующую команду</target>
        </trans-unit>
        <trans-unit id="cbc6fc235d0cf1450284a0b09b674e76a1fb4c28" translate="yes" xml:space="preserve">
          <source>When the sample count is greater than 1, &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; will create a multisample color buffer instead of simply targeting the swapchain's images. The rendering in the multisample buffer will get resolved into the non-multisample buffers at the end of each frame.</source>
          <target state="translated">Когда количество сэмплов больше 1, &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; создаст буфер мультисэмплового цвета вместо простого нацеливания на изображения в цепочке подкачки. Рендеринг в буфере мультисэмплов будет разрешен в буферы без мультисэмплов в конце каждого кадра.</target>
        </trans-unit>
        <trans-unit id="a0108434fca29b4ba915f772a93d81ad894fc73c" translate="yes" xml:space="preserve">
          <source>When the scene graph processes the request, it will call &lt;a href=&quot;qquickitem#updatePolish&quot;&gt;updatePolish&lt;/a&gt;() on this item.</source>
          <target state="translated">Когда граф сцены обрабатывает запрос, он вызывает &lt;a href=&quot;qquickitem#updatePolish&quot;&gt;updatePolish&lt;/a&gt; () для этого элемента.</target>
        </trans-unit>
        <trans-unit id="79ad0782b661b14989a03456b369b188f17379b0" translate="yes" xml:space="preserve">
          <source>When the scene is active, this functions returns the scene's current focus item, or &lt;code&gt;nullptr&lt;/code&gt; if no item currently has focus. When the scene is inactive, this functions returns the item that will gain input focus when the scene becomes active.</source>
          <target state="translated">Когда сцена активна, эта функция возвращает текущий элемент фокуса сцены или &lt;code&gt;nullptr&lt;/code&gt; , если ни один элемент в настоящее время не имеет фокуса. Когда сцена неактивна, эта функция возвращает элемент, который получит фокус ввода, когда сцена станет активной.</target>
        </trans-unit>
        <trans-unit id="9df9de9d839910e5f63e81af88c3113617106dce" translate="yes" xml:space="preserve">
          <source>When the scene is rendered, any item whose width or height, transformed to the target view, is smaller that minimumRenderSize(), will not be rendered. If an item is not rendered and it clips its children items they will also not be rendered. Set this value to speed up rendering of scenes with many objects rendered on a zoomed out view.</source>
          <target state="translated">При рендеринге сцены любой элемент,ширина или высота которого,преобразованный в целевой вид,меньше,чем minimumRenderSize(),не будет рендеринговаться.Если элемент не отрисовывается и он зажимает свои дочерние элементы,он также не будет отрисовываться.Установите это значение,чтобы ускорить отрисовку сцен с большим количеством объектов,отображаемых на увеличенном изображении.</target>
        </trans-unit>
        <trans-unit id="0a43ef95854a2f8ebe7bf8d74d52b1e7933022c7" translate="yes" xml:space="preserve">
          <source>When the script has been executed,</source>
          <target state="translated">Когда скрипт будет выполнен,</target>
        </trans-unit>
        <trans-unit id="d413663e989f70315f8c202cae18ed2f762ace07" translate="yes" xml:space="preserve">
          <source>When the scroll bars change value, we need to update the widget position, i.e., find the part of the widget that is to be drawn in the viewport:</source>
          <target state="translated">При изменении значения полос прокрутки необходимо обновить позицию виджета,т.е.найти ту часть виджета,которая будет отрисована на видовом экране:</target>
        </trans-unit>
        <trans-unit id="7e550de4fcd183b4278cd6cc624e2d0424a701cc" translate="yes" xml:space="preserve">
          <source>When the selected test users that you have added to your alpha or beta program purchase in-app products in your application, they will make actual purchases and will be charged for them. For testing purchases, you can register the e-mail addresses that should have testing access, under &lt;b&gt;Settings&lt;/b&gt; in the developer console. The users with these e-mail addresses can purchase your in-app products without being charged for the purchase, and the transaction is canceled automatically at a later stage.</source>
          <target state="translated">Когда выбранные тестовые пользователи, которых вы добавили в свою альфа- или бета-программу, покупают внутриигровые продукты в вашем приложении, они совершат фактические покупки и будут платить за них. Для тестирования покупок вы можете зарегистрировать адреса электронной почты, которые должны иметь тестовый доступ, в разделе &amp;laquo; &lt;b&gt;Настройки&amp;raquo;&lt;/b&gt; в консоли разработчика. Пользователи с этими адресами электронной почты могут покупать ваши продукты в приложении без взимания платы за покупку, и транзакция автоматически отменяется на более позднем этапе.</target>
        </trans-unit>
        <trans-unit id="afec543fcd1da24c4160336959d91fe3f583bac8" translate="yes" xml:space="preserve">
          <source>When the selection changes and the dialog is accepted, this signal is emitted with the (possibly empty) list of selected</source>
          <target state="translated">Когда выбор изменяется и диалоговое окно принимается,этот сигнал выдается с (возможно,пустым)списком выбранных</target>
        </trans-unit>
        <trans-unit id="904758544b0861950c3ab2beb21af5f0d9b36272" translate="yes" xml:space="preserve">
          <source>When the selection changes and the dialog is accepted, this signal is emitted with the (possibly empty) selected</source>
          <target state="translated">Когда выбор изменяется и диалоговое окно принимается,этот сигнал выдается с выбранным (возможно пустым)параметром</target>
        </trans-unit>
        <trans-unit id="e7de7d16009452344b6e4636a059a260b420895c" translate="yes" xml:space="preserve">
          <source>When the selection changes for local operations and the dialog is accepted, this signal is emitted with the (possibly empty) list of</source>
          <target state="translated">При изменении выбора для локальных операций и принятии диалога этот сигнал выдается с (возможно,пустым)списком</target>
        </trans-unit>
        <trans-unit id="f75edcab2adacd739be3bdebfa6bfa280edf2de0" translate="yes" xml:space="preserve">
          <source>When the selection changes for local operations and the dialog is accepted, this signal is emitted with the (possibly empty) selected</source>
          <target state="translated">При изменении выбора для локальных операций и принятии диалога этот сигнал выдается с выбранным (возможно пустым)значением</target>
        </trans-unit>
        <trans-unit id="5131d672b1bc3aac6ebdcf6c8b2ac57826b0e767" translate="yes" xml:space="preserve">
          <source>When the selection mode changes and the selected item is visible</source>
          <target state="translated">Когда изменяется режим выбора и отображается выбранный элемент</target>
        </trans-unit>
        <trans-unit id="31520c42359fb2cf1348100dd78b79ebb3e7ffdd" translate="yes" xml:space="preserve">
          <source>When the sensor is started with buffering option, values are collected from that moment onwards. There is no pre-existing buffer that can be utilized.</source>
          <target state="translated">При запуске датчика с опцией буферизации,начиная с этого момента,собираются значения.Предыдущий буфер не может быть использован.</target>
        </trans-unit>
        <trans-unit id="ce0fb53c6b17959f1dc8d1d19b6e99cbdbd76451" translate="yes" xml:space="preserve">
          <source>When the server receives the ClientHello message with a cookie, it generates a new cookie as described above. This new cookie is compared to the one found in the ClientHello message.</source>
          <target state="translated">Когда сервер получает сообщение ClientHello с куки-файлом,он генерирует новый куки-файл,как описано выше.Этот новый куки-файл сравнивается с куки-файлом,найденным в сообщении ClientHello.</target>
        </trans-unit>
        <trans-unit id="f10b8edd85c55e75835eb4536f6583dfa1033451" translate="yes" xml:space="preserve">
          <source>When the service that this method call is sent to is already running, the method call is sent to it. If the service is not running yet, the D-Bus daemon is requested to autostart the service that is assigned to this service name. This is handled by .service files that are placed in a directory known to the D-Bus server. These files then each contain a service name and the path to a program that should be executed when this service name is requested.</source>
          <target state="translated">Когда услуга,на которую отправляется этот вызов метода,уже запущена,вызов метода отправляется на нее.Если служба еще не запущена,демон D-Bus запрашивает автозапуск службы,которая назначена этому имени службы.Это обрабатывается файлами .service,которые помещаются в директорию,известную серверу D-Bus.Затем каждый из этих файлов содержит имя службы и путь к программе,которая должна быть запущена,когда запрашивается это имя службы.</target>
        </trans-unit>
        <trans-unit id="c0cd1279176cf81f0c6aca038bccf60c5d81a29f" translate="yes" xml:space="preserve">
          <source>When the shader program is used normally, the shader program's id will be created on demand.</source>
          <target state="translated">При нормальном использовании шейдерной программы,идентификатор шейдерной программы будет создан по требованию.</target>
        </trans-unit>
        <trans-unit id="a62f09dbef147b4bf1f669c8ce754ebe864f003f" translate="yes" xml:space="preserve">
          <source>When the signal associated with this signal transition is emitted the guard condition is evaluated. In the guard condition the arguments of the signal can be used as demonstrated in the example below.</source>
          <target state="translated">При подаче сигнала,связанного с этим переходом,оценивается состояние защиты.В защитном состоянии могут быть использованы аргументы сигнала,как показано в примере ниже.</target>
        </trans-unit>
        <trans-unit id="558725310a73c041dc3d4a5f9bb58e65f3b99606" translate="yes" xml:space="preserve">
          <source>When the signal is emitted, the &lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;sliderPosition&lt;/a&gt; has been adjusted according to the action, but the &lt;a href=&quot;qabstractslider#value-prop&quot;&gt;value&lt;/a&gt; has not yet been propagated (meaning the &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged&lt;/a&gt;() signal was not yet emitted), and the visual display has not been updated. In slots connected to this signal you can thus safely adjust any action by calling &lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;setSliderPosition&lt;/a&gt;() yourself, based on both the action and the slider's value.</source>
          <target state="translated">Когда сигнал испускается, &lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;sliderPosition&lt;/a&gt; был отрегулирован в соответствии с действием, но &lt;a href=&quot;qabstractslider#value-prop&quot;&gt;значение&lt;/a&gt; еще не было распространено (то &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;есть&lt;/a&gt; сигнал valueChanged () еще не был испущен), и визуальное отображение не было обновлено. Таким образом, в слотах, подключенных к этому сигналу, вы можете безопасно настраивать любое действие, вызывая &lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;setSliderPosition&lt;/a&gt; () самостоятельно, в зависимости от действия и значения ползунка.</target>
        </trans-unit>
        <trans-unit id="908f9032f0a18c7bfa32894d77bc808328603452" translate="yes" xml:space="preserve">
          <source>When the source and target areas' sizes do not match, the source contents are stretched to fit into the target area. By passing a &lt;a href=&quot;qt#AspectRatioMode-enum&quot;&gt;Qt::AspectRatioMode&lt;/a&gt; to the rendering function you are using, you can choose to maintain or ignore the aspect ratio of the scene when the contents are stretched.</source>
          <target state="translated">Если размеры исходной и целевой областей не совпадают, исходное содержимое растягивается, чтобы поместиться в целевую область. Передавая &lt;a href=&quot;qt#AspectRatioMode-enum&quot;&gt;Qt :: AspectRatioMode&lt;/a&gt; функции рендеринга вы используете, вы можете выбрать сохранять или игнорировать соотношение сторон сцены , когда содержимое растягиваются.</target>
        </trans-unit>
        <trans-unit id="8b00e9d3dd0cfb3eafd24644444bab1097364474" translate="yes" xml:space="preserve">
          <source>When the source is static, the &lt;a href=&quot;qml-qtgraphicaleffects-dropshadow#cached-prop&quot;&gt;cached&lt;/a&gt; property can be set to allocate another buffer to avoid performing the blur every time it is drawn.</source>
          <target state="translated">Когда источник является статическим, свойство &lt;a href=&quot;qml-qtgraphicaleffects-dropshadow#cached-prop&quot;&gt;cached&lt;/a&gt; может быть установлено для выделения другого буфера, чтобы избежать размытия при каждом его рисовании.</target>
        </trans-unit>
        <trans-unit id="3ad8f5ada47559d8d884af8a03a452189fd6075c" translate="yes" xml:space="preserve">
          <source>When the space key is pressed, adding an item to the model, the new item will fade in and increase in scale over 400 milliseconds as it is added to the view. Also, any item that is displaced by the addition of a new item will animate to its new position in the view over 400 milliseconds, as specified by the &lt;code&gt;displaced&lt;/code&gt; transition.</source>
          <target state="translated">Когда нажата клавиша пробела, добавляющая элемент в модель, новый элемент будет плавно проявляться и увеличиваться в масштабе более 400 миллисекунд по мере добавления к виду. Кроме того, любой элемент, который смещается при добавлении нового элемента, анимируется в его новое положение в представлении в течение 400 миллисекунд, как указано &lt;code&gt;displaced&lt;/code&gt; переходом.</target>
        </trans-unit>
        <trans-unit id="a9fca68b12abe757685e2f8e3f26bf8a64e1d4fe" translate="yes" xml:space="preserve">
          <source>When the space key is pressed, three items are moved from index 5 to index 1. For each moved item, the &lt;code&gt;moveTransition&lt;/code&gt; sequence presumably animates the item's color to &quot;yellow&quot;, then animates it to its final position, then changes the item color back to &quot;lightsteelblue&quot; using a &lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;ScriptAction&lt;/a&gt;. However, when run, the transition does not produce the intended result:</source>
          <target state="translated">Когда нажата клавиша пробела, три элемента перемещаются из индекса 5 в индекс 1. Для каждого перемещенного элемента последовательность &lt;code&gt;moveTransition&lt;/code&gt; предположительно анимирует цвет элемента до &amp;laquo;желтого&amp;raquo;, затем анимирует его в его конечное положение, а затем снова меняет цвет элемента. в &quot;Lightsteelblue&quot; с помощью &lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;ScriptAction&lt;/a&gt; . Однако при запуске переход не дает желаемого результата:</target>
        </trans-unit>
        <trans-unit id="aed377e3125e7efb3e464b02103995ebd5fa07a4" translate="yes" xml:space="preserve">
          <source>When the string is not already a valid URL, a best guess is performed, making various web related assumptions.</source>
          <target state="translated">Когда строка еще не является действительным URL-адресом,выполняется наилучшая догадка,делая различные предположения,связанные с сетью.</target>
        </trans-unit>
        <trans-unit id="8b456c366b0bedadf7f4c24ff98787915a0f574f" translate="yes" xml:space="preserve">
          <source>When the text changes the &lt;a href=&quot;qlineedit#textChanged&quot;&gt;textChanged&lt;/a&gt;() signal is emitted; when the text changes other than by calling &lt;a href=&quot;qlineedit#text-prop&quot;&gt;setText&lt;/a&gt;() the &lt;a href=&quot;qlineedit#textEdited&quot;&gt;textEdited&lt;/a&gt;() signal is emitted; when the cursor is moved the &lt;a href=&quot;qlineedit#cursorPositionChanged&quot;&gt;cursorPositionChanged&lt;/a&gt;() signal is emitted; and when the Return or Enter key is pressed the &lt;a href=&quot;qlineedit#returnPressed&quot;&gt;returnPressed&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">Когда текст изменяется, &lt;a href=&quot;qlineedit#textChanged&quot;&gt;выдается&lt;/a&gt; сигнал textChanged (); когда текст изменяется иначе, чем при вызове &lt;a href=&quot;qlineedit#text-prop&quot;&gt;setText&lt;/a&gt; (), &lt;a href=&quot;qlineedit#textEdited&quot;&gt;выдается&lt;/a&gt; сигнал textEdited (); при перемещении курсора &lt;a href=&quot;qlineedit#cursorPositionChanged&quot;&gt;излучается&lt;/a&gt; сигнал cursorPositionChanged (); и когда нажата клавиша Return или Enter, испускается сигнал &lt;a href=&quot;qlineedit#returnPressed&quot;&gt;returnPressed&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="76aa286a7763afdcffbd10ec6e5b9d39bd8e0eec" translate="yes" xml:space="preserve">
          <source>When the texture coordinate is even, only the fractional part is used. When odd, the texture coordinate is set to &lt;code&gt;1 - fractional part&lt;/code&gt;. This value has been introduced in Qt 5.10.</source>
          <target state="translated">Когда координата текстуры четная, используется только дробная часть. Если нечетное, координата текстуры устанавливается на &lt;code&gt;1 - fractional part&lt;/code&gt; . Это значение было введено в Qt 5.10.</target>
        </trans-unit>
        <trans-unit id="4630c4b073fe0b95c546ea9b15793119393a3a9b" translate="yes" xml:space="preserve">
          <source>When the thread is terminated, all threads waiting for the thread to finish will be woken up.</source>
          <target state="translated">Когда нить будет завершена,все нити,ожидающие окончания,будут пробуждены.</target>
        </trans-unit>
        <trans-unit id="87fd2e26c464b557c4a3c28bad0e013a2a60bdaf" translate="yes" xml:space="preserve">
          <source>When the timeline is disabled, all items will have their regular values. When the timeline is enabled, the values of items are determined by the current frame and the keyframes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8b9c7726d3aff7845aa848c6697f0885c506e1a" translate="yes" xml:space="preserve">
          <source>When the title bar is vertical, the &lt;a href=&quot;#vertical-ps&quot;&gt;:vertical&lt;/a&gt; pseudo class is set. In addition, depending on &lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;QDockWidget::DockWidgetFeature&lt;/a&gt;, the &lt;a href=&quot;#closable-ps&quot;&gt;:closable&lt;/a&gt;, &lt;a href=&quot;#floatable-ps&quot;&gt;:floatable&lt;/a&gt; and &lt;a href=&quot;#movable-ps&quot;&gt;:movable&lt;/a&gt; pseudo states are set.</source>
          <target state="translated">Когда строка заголовка вертикальна, устанавливается псевдокласс &lt;a href=&quot;#vertical-ps&quot;&gt;: vertical&lt;/a&gt; . Кроме того, в зависимости от &lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;QDockWidget :: DockWidgetFeature&lt;/a&gt; , то &lt;a href=&quot;#closable-ps&quot;&gt;: закрываемый&lt;/a&gt; , &lt;a href=&quot;#floatable-ps&quot;&gt;: плавучие&lt;/a&gt; и &lt;a href=&quot;#movable-ps&quot;&gt;: подвижные&lt;/a&gt; состояния псевдо установлены.</target>
        </trans-unit>
        <trans-unit id="dcbf714b2e65ae5994ea2abb0210ddd12a11925f" translate="yes" xml:space="preserve">
          <source>When the title bar is vertical, the &lt;a href=&quot;stylesheet-reference#vertical-ps&quot;&gt;:vertical&lt;/a&gt; pseudo class is set. In addition, depending on &lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;QDockWidget::DockWidgetFeature&lt;/a&gt;, the &lt;a href=&quot;stylesheet-reference#closable-ps&quot;&gt;:closable&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#floatable-ps&quot;&gt;:floatable&lt;/a&gt; and &lt;a href=&quot;stylesheet-reference#movable-ps&quot;&gt;:movable&lt;/a&gt; pseudo states are set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6a38dec8a46a3efde082aa9bb646234ab5665d" translate="yes" xml:space="preserve">
          <source>When the traceEnd method is called, the input method may begin processing of the data contained in the trace object. After processing the data, the input method should destroy the object. This also removes the trace rendered to the screen.</source>
          <target state="translated">При вызове метода traceEnd входной метод может начать обработку данных,содержащихся в объекте трассы.После обработки данных,метод ввода должен уничтожить объект.При этом также удаляется выводимая на экран трасса.</target>
        </trans-unit>
        <trans-unit id="5ed406ff23fcc29a091f1169edcf6e63e1f2b5ea" translate="yes" xml:space="preserve">
          <source>When the transition is initialized, the &lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction&lt;/a&gt;&lt;code&gt;target&lt;/code&gt; will be set to the respective &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt;.item for the transition and will later run with the correct item target as expected.</source>
          <target state="translated">Когда переход инициализируется, &lt;code&gt;target&lt;/code&gt; &lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction&lt;/a&gt; будет установлен на соответствующий &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;элемент&lt;/a&gt; ViewTransition. Для перехода и позже будет выполняться с правильной целью элемента, как ожидалось.</target>
        </trans-unit>
        <trans-unit id="a112026d8a84f01ac36a7325fb20f0691ad743ce" translate="yes" xml:space="preserve">
          <source>When the transition is initialized, the &lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction&lt;/a&gt;&lt;code&gt;target&lt;/code&gt; will be set to the respective ViewTransition.item for the transition and will later run with the correct item target as expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61999efc5174872ead16b86264178dba1fb54b01" translate="yes" xml:space="preserve">
          <source>When the transition starts, the &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; will search for a transition that matches the operation executed. There are three transitions to choose from: &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#pushTransition-prop&quot;&gt;pushTransition&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#popTransition-prop&quot;&gt;popTransition&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#replaceTransition-prop&quot;&gt;replaceTransition&lt;/a&gt;. Each implements how &lt;code&gt;enterItem&lt;/code&gt; should animate in, and &lt;code&gt;exitItem&lt;/code&gt; out. The transitions are collected inside a &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate&quot;&gt;StackViewDelegate&lt;/a&gt; object assigned to &lt;a href=&quot;qml-qtquick-controls-stackview#delegate-prop&quot;&gt;delegate&lt;/a&gt;. By default, popTransition and replaceTransition will be the same as pushTransition, unless you set them to something else.</source>
          <target state="translated">Когда переход начинается, &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; будет искать переход, соответствующий выполненной операции. На выбор предлагается три перехода: &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#pushTransition-prop&quot;&gt;pushTransition&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#popTransition-prop&quot;&gt;popTransition&lt;/a&gt; и &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#replaceTransition-prop&quot;&gt;replaceTransition&lt;/a&gt; . Каждый из них реализует, как &lt;code&gt;enterItem&lt;/code&gt; должен анимироваться, а &lt;code&gt;exitItem&lt;/code&gt; - выходить. &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate&quot;&gt;Переходы&lt;/a&gt; собираются внутри объекта StackViewDelegate, назначенного &lt;a href=&quot;qml-qtquick-controls-stackview#delegate-prop&quot;&gt;делегату&lt;/a&gt; . По умолчанию popTransition и replaceTransition будут такими же, как pushTransition, если вы не установите для них другое значение.</target>
        </trans-unit>
        <trans-unit id="b481fca32b65e43470c3c94e4e0c2377f104c54a" translate="yes" xml:space="preserve">
          <source>When the transition starts, the StackView will search for a transition that matches the operation executed. There are three transitions to choose from: &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#pushTransition-prop&quot;&gt;pushTransition&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#popTransition-prop&quot;&gt;popTransition&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#replaceTransition-prop&quot;&gt;replaceTransition&lt;/a&gt;. Each implements how &lt;code&gt;enterItem&lt;/code&gt; should animate in, and &lt;code&gt;exitItem&lt;/code&gt; out. The transitions are collected inside a &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate&quot;&gt;StackViewDelegate&lt;/a&gt; object assigned to &lt;a href=&quot;qml-qtquick-controls-stackview#delegate-prop&quot;&gt;delegate&lt;/a&gt;. By default, popTransition and replaceTransition will be the same as pushTransition, unless you set them to something else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b086c5ef03dd1208f5e9b3c1c02fa2b6600cb5" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;LineString&lt;/code&gt; the data ia a &lt;a href=&quot;qgeopath&quot;&gt;QGeoPath&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6627a2ffbe714cf5363a2179e7f88f8aa52c1d77" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;MultiLineString&lt;/code&gt;, the data is a List of LineStrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f684debed13b1e187fdab34246a351f68171025c" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;MultiPoint&lt;/code&gt;, the data is a List of Points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65efa0e33ec24ae86c53c350f1ee9d661694a7b1" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;MultiPolygon&lt;/code&gt;, the data is a List of Polygons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbc2b0b0072c28b487940a65dedc17930539d2ec" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;Point&lt;/code&gt;, the data is a &lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle&lt;/a&gt; with the point coordinates stored in the center property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23332dc4a0d7fb448b924e422877dc966cb8e77a" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;Polygon&lt;/code&gt;, the data is a &lt;a href=&quot;qgeopolygon&quot;&gt;QGeoPolygon&lt;/a&gt; (holes are supported).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e47c478e8b7cde10b9e2d57a87561d517265a6" translate="yes" xml:space="preserve">
          <source>When the underlying rendering API is OpenGL, this function should return a mask where each bit represents graphics states changed by the &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;() function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3151bd80e155cc711d1dfb4c28d12fa02d1b602b" translate="yes" xml:space="preserve">
          <source>When the update behavior is set to &lt;code&gt;NoPartialUpdate&lt;/code&gt;, there is no separate framebuffer object. In this case the returned value is the ID of the default framebuffer.</source>
          <target state="translated">Если для поведения обновления установлено значение &lt;code&gt;NoPartialUpdate&lt;/code&gt; , отдельный объект фреймбуфера отсутствует. В этом случае возвращаемое значение - это идентификатор буфера кадра по умолчанию.</target>
        </trans-unit>
        <trans-unit id="38a70a3f9388a6d25db9221a160c7eb74efac68f" translate="yes" xml:space="preserve">
          <source>When the update mode is set to &lt;a href=&quot;qopenglwindow#UpdateBehavior-enum&quot;&gt;NoPartialUpdate&lt;/a&gt;, there is no difference between this function and &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;(), performing rendering in either of them leads to the same result.</source>
          <target state="translated">Когда режим обновления установлен на &lt;a href=&quot;qopenglwindow#UpdateBehavior-enum&quot;&gt;NoPartialUpdate&lt;/a&gt; , нет никакой разницы между этой функцией и &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt; (), выполнение рендеринга в любом из них приводит к одинаковому результату.</target>
        </trans-unit>
        <trans-unit id="90a4d8b7976d6357d0d51104a651d5693a247b6e" translate="yes" xml:space="preserve">
          <source>When the update mode is set to &lt;code&gt;NoPartialUpdate&lt;/code&gt;, there is no difference between this function and &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;(), performing rendering in either of them leads to the same result.</source>
          <target state="translated">Когда режим обновления установлен на &lt;code&gt;NoPartialUpdate&lt;/code&gt; , нет никакой разницы между этой функцией и &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt; (), выполнение рендеринга в любом из них приводит к одинаковому результату.</target>
        </trans-unit>
        <trans-unit id="7fbf049a32dd0640f6dd43ed769625f8cee33a4d" translate="yes" xml:space="preserve">
          <source>When the user attempts to close a window, the &lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;closing&lt;/a&gt; signal will be emitted. You can force the window to stay open (for example to prompt the user to save changes) by writing an &lt;code&gt;onClosing&lt;/code&gt; handler and setting &lt;code&gt;close.accepted = false&lt;/code&gt;.</source>
          <target state="translated">Когда пользователь пытается закрыть окно, &lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;выдается&lt;/a&gt; сигнал закрытия . Вы можете заставить окно оставаться открытым (например, предлагать пользователю сохранить изменения), написав обработчик &lt;code&gt;onClosing&lt;/code&gt; и установив &lt;code&gt;close.accepted = false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f089242c4828bfa1c4990e6f2f452f8aa6f68fa8" translate="yes" xml:space="preserve">
          <source>When the user clicks anywhere within the rectangle, &lt;code&gt;sendMessage()&lt;/code&gt; is called, triggering the &lt;code&gt;WorkerScript.onMessage()&lt;/code&gt; handler in &lt;code&gt;script.mjs&lt;/code&gt;. This in turn sends a reply message that is then received by the &lt;code&gt;onMessage()&lt;/code&gt; handler of &lt;code&gt;myWorker&lt;/code&gt;.</source>
          <target state="translated">Когда пользователь щелкает в любом месте прямоугольника, &lt;code&gt;sendMessage()&lt;/code&gt; , запускающий обработчик &lt;code&gt;WorkerScript.onMessage()&lt;/code&gt; в &lt;code&gt;script.mjs&lt;/code&gt; . Это, в свою очередь, отправляет ответное сообщение, которое затем получает обработчик &lt;code&gt;onMessage()&lt;/code&gt; &lt;code&gt;myWorker&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e806fe43114f8c1140dcea68026addc98aa8292" translate="yes" xml:space="preserve">
          <source>When the user enters a new string in an editable combobox, the widget may or may not insert it, and it can insert it in several locations. The default policy is &lt;a href=&quot;qcombobox#InsertPolicy-enum&quot;&gt;InsertAtBottom&lt;/a&gt; but you can change this using &lt;a href=&quot;qcombobox#insertPolicy-prop&quot;&gt;setInsertPolicy&lt;/a&gt;().</source>
          <target state="translated">Когда пользователь вводит новую строку в редактируемом поле со списком, виджет может вставлять или не вставлять ее, и он может вставлять ее в нескольких местах. Политика по умолчанию - &lt;a href=&quot;qcombobox#InsertPolicy-enum&quot;&gt;InsertAtBottom,&lt;/a&gt; но вы можете изменить это с помощью &lt;a href=&quot;qcombobox#insertPolicy-prop&quot;&gt;setInsertPolicy&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="7a33c93bf7f01a0e67730291d39734d96a1a1c84" translate="yes" xml:space="preserve">
          <source>When the user has finished editing the value in the spin box, the view asks the delegate to store the edited value in the model by calling the &lt;a href=&quot;qabstractitemdelegate#setModelData&quot;&gt;setModelData()&lt;/a&gt; function.</source>
          <target state="translated">Когда пользователь закончил редактировать значение в счетчике, представление просит делегата сохранить отредактированное значение в модели, вызвав &lt;a href=&quot;qabstractitemdelegate#setModelData&quot;&gt;функцию setModelData ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92fa0779d8d3b6243f1940a69448d7de41b9ecd3" translate="yes" xml:space="preserve">
          <source>When the user presses or releases a key, the following occurs:</source>
          <target state="translated">Когда пользователь нажимает или отпускает клавишу,происходит следующее:</target>
        </trans-unit>
        <trans-unit id="0593af2ddbf4e80d0b0321de8e5024100fcd08c9" translate="yes" xml:space="preserve">
          <source>When the user presses the first key on a keyboard, an input context is created. This input context will contain a string of the typed characters.</source>
          <target state="translated">Когда пользователь нажимает первую клавишу на клавиатуре,создается контекст ввода.Этот контекст ввода будет содержать строку набранных символов.</target>
        </trans-unit>
        <trans-unit id="17b14a687e250bb8ebffd69d26cedf3fe0182667" translate="yes" xml:space="preserve">
          <source>When the user presses the shortcut key indicated by this label, the keyboard focus is transferred to the label's buddy widget.</source>
          <target state="translated">Когда пользователь нажимает клавишу быстрого доступа,указанную этой меткой,фокус клавиатуры переносится на виджет &quot;приятель&quot; метки.</target>
        </trans-unit>
        <trans-unit id="d8718161543f49d12ebfce2a24d45c7fc9cbd16e" translate="yes" xml:space="preserve">
          <source>When the user resizes the window, the size will move in steps of &lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;sizeIncrement&lt;/a&gt;().&lt;a href=&quot;qwindow#width-prop&quot;&gt;width&lt;/a&gt;() pixels horizontally and &lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;sizeIncrement&lt;/a&gt;().&lt;a href=&quot;qwindow#height-prop&quot;&gt;height&lt;/a&gt;() pixels vertically, with &lt;a href=&quot;qwindow#baseSize&quot;&gt;baseSize&lt;/a&gt;() as the basis.</source>
          <target state="translated">Когда пользователь изменяет размер окна, размер будет &lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;изменяться с&lt;/a&gt; шагом sizeIncrement (). &lt;a href=&quot;qwindow#width-prop&quot;&gt;width&lt;/a&gt; () пикселей по горизонтали и &lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;sizeIncrement&lt;/a&gt; (). &lt;a href=&quot;qwindow#height-prop&quot;&gt;height&lt;/a&gt; () пикселей по вертикали, &lt;a href=&quot;qwindow#baseSize&quot;&gt;взяв&lt;/a&gt; за основу baseSize ().</target>
        </trans-unit>
        <trans-unit id="9e453a57cc507da9b2902f79db75133ddc061ac8" translate="yes" xml:space="preserve">
          <source>When the user resizes the window, the size will move in steps of sizeIncrement().&lt;a href=&quot;qwidget#width-prop&quot;&gt;width&lt;/a&gt;() pixels horizontally and sizeIncrement.&lt;a href=&quot;qwidget#height-prop&quot;&gt;height&lt;/a&gt;() pixels vertically, with &lt;a href=&quot;qwidget#baseSize-prop&quot;&gt;baseSize&lt;/a&gt;() as the basis. Preferred widget sizes are for non-negative integers</source>
          <target state="translated">Когда пользователь изменяет размер окна, размер будет изменяться с шагом sizeIncrement (). &lt;a href=&quot;qwidget#width-prop&quot;&gt;width&lt;/a&gt; () пикселей по горизонтали и sizeIncrement. &lt;a href=&quot;qwidget#height-prop&quot;&gt;height&lt;/a&gt; () пикселей по вертикали, &lt;a href=&quot;qwidget#baseSize-prop&quot;&gt;взяв&lt;/a&gt; за основу baseSize (). Предпочтительные размеры виджетов указаны для неотрицательных целых чисел.</target>
        </trans-unit>
        <trans-unit id="e9e23684b39294a601601a344c7bf87e80ee521d" translate="yes" xml:space="preserve">
          <source>When the user selects a new font, the &lt;a href=&quot;qfontcombobox#currentFontChanged&quot;&gt;currentFontChanged&lt;/a&gt;() signal is emitted in addition to &lt;a href=&quot;qcombobox#currentIndexChanged&quot;&gt;currentIndexChanged&lt;/a&gt;().</source>
          <target state="translated">Когда пользователь выбирает новый шрифт, то &lt;a href=&quot;qfontcombobox#currentFontChanged&quot;&gt;currentFontChanged&lt;/a&gt; сигнал () испускается , в дополнение к &lt;a href=&quot;qcombobox#currentIndexChanged&quot;&gt;currentIndexChanged&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="4da46bc51fcc82534c06603bbbd59ebe7d50ebb4" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the list, the input method responds to the event in the &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListItemSelected-method&quot;&gt;InputMethod::selectionListItemSelected&lt;/a&gt; method callback.</source>
          <target state="translated">Когда пользователь выбирает элемент в списке, метод ввода реагирует на событие в &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListItemSelected-method&quot;&gt;обратном вызове&lt;/a&gt; метода InputMethod :: selectionListItemSelected .</target>
        </trans-unit>
        <trans-unit id="c109346817c0c000e5fe1e4e0a164874e2cf7eaf" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the usual way, the selection is cleared and the new item selected. However, if the user presses the Ctrl key when clicking on an item, the clicked item gets toggled and all other items are left untouched. If the user presses the Shift key while clicking on an item, all items between the current item and the clicked item are selected or unselected, depending on the state of the clicked item. Multiple items can be selected by dragging the mouse over them.</source>
          <target state="translated">Когда пользователь выбирает элемент обычным способом,выбор удаляется,а новый элемент выбирается.Однако,если пользователь нажимает клавишу Ctrl при нажатии на элемент,то нажатый элемент переключается,а все остальные элементы остаются нетронутыми.Если пользователь нажимает клавишу Shift при щелчке на элементе,то все элементы между текущим элементом и выбранным элементом выделяются или не выделяются,в зависимости от состояния выбранного элемента.Несколько элементов можно выделить,перетащив на них курсор мыши.</target>
        </trans-unit>
        <trans-unit id="239784d9cf52110a5610a0352def4b21651a1ec0" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the usual way, the selection is cleared and the new item selected. However, if the user presses the Shift key while clicking on an item, all items between the current item and the clicked item are selected or unselected, depending on the state of the clicked item.</source>
          <target state="translated">Когда пользователь выбирает элемент обычным способом,выбор удаляется,а новый элемент выбирается.Однако,если при нажатии на элемент пользователь нажимает клавишу Shift,все элементы между текущим элементом и выбранным элементом выделяются или не выделяются,в зависимости от состояния выбранного элемента.</target>
        </trans-unit>
        <trans-unit id="b63a60a0cef1fb52e61ed1b641072b5077221c1a" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the usual way, the selection status of that item is toggled and the other items are left alone. Multiple items can be toggled by dragging the mouse over them.</source>
          <target state="translated">Когда пользователь выбирает элемент обычным способом,статус выбора этого элемента переключается,а остальные элементы остаются одни.Несколько элементов можно переключить,перетащив на них курсор мыши.</target>
        </trans-unit>
        <trans-unit id="48e3c32ce598a7fbfd8868c52569756e58fdf828" translate="yes" xml:space="preserve">
          <source>When the user selects an item, any already-selected item becomes unselected. It is possible for the user to deselect the selected item by pressing the Ctrl key when clicking the selected item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432b100478d155eb5754fdf1b8519f514ff3bcfa" translate="yes" xml:space="preserve">
          <source>When the user selects an item, any already-selected item becomes unselected. It is possible for the user to deselect the selected item.</source>
          <target state="translated">Когда пользователь выбирает элемент,любой уже выбранный элемент становится невыделенным.Пользователь может снять выделение с выбранного элемента.</target>
        </trans-unit>
        <trans-unit id="40c8efdfbff08c7bc6b912d42d8681b4819162a6" translate="yes" xml:space="preserve">
          <source>When the user triggers a step whilst holding the &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt::ControlModifier&lt;/a&gt;, &lt;a href=&quot;qabstractspinbox&quot;&gt;QAbstractSpinBox&lt;/a&gt; steps by 10 instead of making a single step. This step modifier affects wheel events, key events and interaction with the spinbox buttons. Note that on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, Control corresponds to the Command key.</source>
          <target state="translated">Когда пользователь запускает шаг, удерживая &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt :: ControlModifier&lt;/a&gt; , &lt;a href=&quot;qabstractspinbox&quot;&gt;QAbstractSpinBox&lt;/a&gt; делает шаг на 10 вместо одного шага. Этот модификатор шага влияет на события колеса, ключевые события и взаимодействие с кнопками счетчика. Обратите внимание, что в &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; Control соответствует клавише Command.</target>
        </trans-unit>
        <trans-unit id="34d7335e57478339ba71faccb6f2bf5634476339" translate="yes" xml:space="preserve">
          <source>When the user triggers a step whilst holding the &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt::ControlModifier&lt;/a&gt;, QAbstractSpinBox steps by 10 instead of making a single step. This step modifier affects wheel events, key events and interaction with the spinbox buttons. Note that on macOS, Control corresponds to the Command key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de1fafb709edfc8e71149ea8ddc3fd104d090bd" translate="yes" xml:space="preserve">
          <source>When the user types the &lt;a href=&quot;qkeysequence&quot;&gt;key sequence&lt;/a&gt; for a given shortcut, the shortcut's &lt;a href=&quot;qshortcut#activated&quot;&gt;activated&lt;/a&gt;() signal is emitted. (In the case of ambiguity, the &lt;a href=&quot;qshortcut#activatedAmbiguously&quot;&gt;activatedAmbiguously&lt;/a&gt;() signal is emitted.) A shortcut is &quot;listened for&quot; by Qt's event loop when the shortcut's parent widget is receiving events.</source>
          <target state="translated">Когда пользователь набирает &lt;a href=&quot;qkeysequence&quot;&gt;последовательность клавиш&lt;/a&gt; для данного ярлыка, выдается сигнал &lt;a href=&quot;qshortcut#activated&quot;&gt;active&lt;/a&gt; () ярлыка . (В случае неоднозначности излучается сигнал &lt;a href=&quot;qshortcut#activatedAmbiguously&quot;&gt;activeAmbiguously&lt;/a&gt; ().) Ярлык &quot;прослушивается&quot; циклом событий Qt, когда родительский виджет ярлыка получает события.</target>
        </trans-unit>
        <trans-unit id="07467a76ec47313778f1640f3f2853d179a4c454" translate="yes" xml:space="preserve">
          <source>When the user uses the arrows to change the spin box's value the value will be incremented/decremented by the amount of the singleStep. The default value is 1. Setting a singleStep value of less than 0 does nothing.</source>
          <target state="translated">Когда пользователь использует стрелки для изменения значения спин-бокса,значение будет увеличено/уменьшено на величину singleStep.Значение по умолчанию равно 1.Установка значения singleStep меньше 0 ничего не делает.</target>
        </trans-unit>
        <trans-unit id="1a7fbae2e2cb0c5b805b7e0f23104cafdd5b43a3" translate="yes" xml:space="preserve">
          <source>When the user uses the arrows to change the spin box's value the value will be incremented/decremented by the amount of the singleStep. The default value is 1.0. Setting a singleStep value of less than 0 does nothing.</source>
          <target state="translated">Когда пользователь использует стрелки для изменения значения спин-бокса,значение будет увеличено/уменьшено на величину singleStep.Значение по умолчанию 1.0.Установка значения singleStep меньше 0 ничего не делает.</target>
        </trans-unit>
        <trans-unit id="55b72162369d6d7fefe6c5eeff0d064284c9c1e9" translate="yes" xml:space="preserve">
          <source>When the user wants to purchase a product, call &lt;a href=&quot;qinappproduct#purchase&quot;&gt;QInAppProduct::purchase&lt;/a&gt;() on the product. This launches a platform-specific, asynchronous process to purchase the product, for example by requesting the user's password and confirmation of the purchase. In most cases, you must make sure that the application UI is not accepting input while the purchase request is being processed, as this is not handled automatically on all platforms.</source>
          <target state="translated">Когда пользователь хочет приобрести продукт, вызовите &lt;a href=&quot;qinappproduct#purchase&quot;&gt;QInAppProduct :: Purchase&lt;/a&gt; () для продукта. Это запускает зависящий от платформы асинхронный процесс покупки продукта, например, путем запроса пароля пользователя и подтверждения покупки. В большинстве случаев необходимо убедиться, что пользовательский интерфейс приложения не принимает ввод во время обработки запроса на покупку, так как это не обрабатывается автоматически на всех платформах.</target>
        </trans-unit>
        <trans-unit id="53e007fcb539e15013065a7fcca5f31963711f7f" translate="yes" xml:space="preserve">
          <source>When the view changes, the &lt;code&gt;inputViewChanged&lt;/code&gt; signal is emitted.</source>
          <target state="translated">Когда представление изменяется, &lt;code&gt;inputViewChanged&lt;/code&gt; сигнал inputViewChanged .</target>
        </trans-unit>
        <trans-unit id="6bf292009c41ae3996b782ddaf7f2171babcb34d" translate="yes" xml:space="preserve">
          <source>When the view is initialized, the view will create all the necessary items for the view, then animate them to their correct positions within the view over one second.</source>
          <target state="translated">Когда вид инициализирован,в течение одной секунды вид создаст все необходимые элементы для вида,а затем анимирует их до нужного положения внутри вида.</target>
        </trans-unit>
        <trans-unit id="bf9267cdf13126ffe2807371579c3234aa2c025f" translate="yes" xml:space="preserve">
          <source>When the widget is embedded, its state (e.g., visible, enabled, geometry, size hints) is copied into the proxy widget. If the embedded widget is explicitly hidden or disabled, the proxy widget will become explicitly hidden or disabled after embedding is complete. The class documentation has a full overview over the shared state.</source>
          <target state="translated">При внедрении виджета его состояние (например,видимый,включенный,геометрия,подсказки размеров)копируется в прокси-виджет.Если встроенный виджет явно скрыт или отключен,то после завершения встраивания прокси-виджет становится явно скрытым или отключенным.Документация по классу имеет полный обзор общего состояния.</target>
        </trans-unit>
        <trans-unit id="0eed7c85c5152e46b5d87508ebba22a259d445d6" translate="yes" xml:space="preserve">
          <source>When the widget needs to generate a set of preview pages, a &lt;a href=&quot;qprintpreviewwidget#paintRequested&quot;&gt;paintRequested&lt;/a&gt;() signal will be emitted from the widget. Connect a slot to this signal, and draw onto the &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; passed in as a signal parameter. Call &lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter::newPage&lt;/a&gt;(), to start a new page in the preview.</source>
          <target state="translated">Когда виджету необходимо создать набор страниц предварительного просмотра, из &lt;a href=&quot;qprintpreviewwidget#paintRequested&quot;&gt;виджета&lt;/a&gt; будет выдан сигнал paintRequested (). Подключите слот к этому сигналу и нарисуйте на &lt;a href=&quot;qprinter&quot;&gt;QPrinter,&lt;/a&gt; переданный в качестве параметра сигнала. Вызовите &lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter :: newPage&lt;/a&gt; (), чтобы начать новую страницу в предварительном просмотре.</target>
        </trans-unit>
        <trans-unit id="17365a086c8d8f3707090a7d37af79afa83d7862" translate="yes" xml:space="preserve">
          <source>When the widget's window and the related OpenGL resources are not yet initialized, the return value is the format that has been set via &lt;a href=&quot;qopenglwidget#setFormat&quot;&gt;setFormat&lt;/a&gt;().</source>
          <target state="translated">Когда окно виджета и связанные с ним ресурсы OpenGL еще не инициализированы, возвращаемое значение - это формат, установленный с помощью &lt;a href=&quot;qopenglwidget#setFormat&quot;&gt;setFormat&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="43847dedad7e1417643232066e6b313499c2942c" translate="yes" xml:space="preserve">
          <source>When the widget-style font and palette propagation is enabled, font and palette changes made through Qt Style Sheets will behave as though the user had manually called the corresponding &lt;a href=&quot;qwidget#palette-prop&quot;&gt;QWidget::setPalette&lt;/a&gt;() and &lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget::setFont&lt;/a&gt;() methods on all of the QWidgets targeted by the style sheet. If this would have caused propagation in C++, it will cause propagation in style sheets and vice versa.</source>
          <target state="translated">Когда включено распространение шрифта и палитры в стиле виджета, изменения шрифта и палитры, сделанные с помощью таблиц стилей Qt, будут вести себя так, как если бы пользователь вручную вызвал соответствующие &lt;a href=&quot;qwidget#palette-prop&quot;&gt;методы QWidget :: setPalette&lt;/a&gt; () и &lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget :: setFont&lt;/a&gt; () для всех QWidgets, нацеленные на таблицу стилей. Если это вызвало бы распространение в C ++, это вызовет распространение в таблицах стилей и наоборот.</target>
        </trans-unit>
        <trans-unit id="d46c08525c4ed676f1a7ccbb248c7080204996de" translate="yes" xml:space="preserve">
          <source>When the window is made visible, the content is updated automatically. Further updates can be requested by calling &lt;a href=&quot;qwindow#requestUpdate&quot;&gt;QWindow::requestUpdate&lt;/a&gt;(). To render continuously, call &lt;a href=&quot;qwindow#requestUpdate&quot;&gt;requestUpdate&lt;/a&gt;() after &lt;a href=&quot;qvulkanwindow#frameReady&quot;&gt;frameReady&lt;/a&gt;().</source>
          <target state="translated">Когда окно становится видимым, содержимое обновляется автоматически. Дальнейшие обновления можно запросить, вызвав &lt;a href=&quot;qwindow#requestUpdate&quot;&gt;QWindow :: requestUpdate&lt;/a&gt; (). Для непрерывного рендеринга вызовите &lt;a href=&quot;qwindow#requestUpdate&quot;&gt;requestUpdate&lt;/a&gt; () после &lt;a href=&quot;qvulkanwindow#frameReady&quot;&gt;frameReady&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="d0885d46fa70f463e2de0a22a1a8f497582d4166" translate="yes" xml:space="preserve">
          <source>When the window is not exposed, it is shown by the application but it is still not showing in the windowing system, so the application should minimize rendering and other graphical activities.</source>
          <target state="translated">Когда окно не экспонируется,оно показывается приложением,но все равно не отображается в оконной системе,поэтому приложение должно минимизировать рендеринг и другие графические действия.</target>
        </trans-unit>
        <trans-unit id="298ff46be999c313b755a4569e2c0f50522cc6cd" translate="yes" xml:space="preserve">
          <source>When the window state changes, the widget receives a &lt;a href=&quot;qwidget#changeEvent&quot;&gt;changeEvent&lt;/a&gt;() of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::WindowStateChange&lt;/a&gt;.</source>
          <target state="translated">Когда состояние окна изменяется, виджет получает &lt;a href=&quot;qwidget#changeEvent&quot;&gt;changeEvent&lt;/a&gt; () типа &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: WindowStateChange&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4430665a811124c03a76c8e73574aa765dc47098" translate="yes" xml:space="preserve">
          <source>When there are too many tabs in a tab bar for its size, the tab bar can either choose to expand its size or to add buttons that allow you to scroll through the tabs.</source>
          <target state="translated">Когда в панели закладок слишком много вкладок для их размера,панель закладок может выбрать либо расширение размера,либо добавление кнопок,позволяющих прокручивать вкладки.</target>
        </trans-unit>
        <trans-unit id="328188d436a703678d89704707e3862740fee438" translate="yes" xml:space="preserve">
          <source>When these images are loaded by QML, it looks for a matching image provider and calls its &lt;a href=&quot;qquickimageprovider#requestImage&quot;&gt;requestImage&lt;/a&gt;() or &lt;a href=&quot;qquickimageprovider#requestPixmap&quot;&gt;requestPixmap&lt;/a&gt;() method (depending on its &lt;a href=&quot;qquickimageprovider#imageType&quot;&gt;imageType&lt;/a&gt;()) to load the image. The method is called with the &lt;code&gt;id&lt;/code&gt; parameter set to &quot;yellow&quot; for the first image, and &quot;red&quot; for the second.</source>
          <target state="translated">Когда эти изображения загружаются QML, он ищет подходящего поставщика изображений и вызывает его &lt;a href=&quot;qquickimageprovider#requestImage&quot;&gt;метод requestImage&lt;/a&gt; () или &lt;a href=&quot;qquickimageprovider#requestPixmap&quot;&gt;requestPixmap&lt;/a&gt; () (в зависимости от его &lt;a href=&quot;qquickimageprovider#imageType&quot;&gt;imageType&lt;/a&gt; ()) для загрузки изображения. Метод вызывается с параметром &lt;code&gt;id&lt;/code&gt; , установленным на &amp;laquo;желтый&amp;raquo; для первого изображения и &amp;laquo;красный&amp;raquo; для второго.</target>
        </trans-unit>
        <trans-unit id="280d1db6d231e9b9540bfc8acf026c5df8031216" translate="yes" xml:space="preserve">
          <source>When this argument is used, a second argument is required, which specifies the module whose classes are to be listed. QDoc generates a table containing those classes. Each class is listed with the text of its &lt;a href=&quot;11-qdoc-commands-specialcontent#brief-command&quot;&gt;\brief&lt;/a&gt; command.</source>
          <target state="translated">Когда используется этот аргумент, требуется второй аргумент, который указывает модуль, классы которого должны быть перечислены. QDoc генерирует таблицу, содержащую эти классы. Каждый класс указан вместе с текстом его команды &lt;a href=&quot;11-qdoc-commands-specialcontent#brief-command&quot;&gt;\ short&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed8f319625948db2e4a131ba28a779620a6396b0" translate="yes" xml:space="preserve">
          <source>When this attribute is set, the native on-screen virtual keyboard will not be shown automatically when a text input widget gains focus on a system without a physical keyboard. Currently supported on the Windows platform only. This value was added in 5.15</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278d7e1255bd96582c739bd15df2833e0be8a868" translate="yes" xml:space="preserve">
          <source>When this code is loaded by the engine, it creates an object tree with a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; object at the root; this object has a &lt;a href=&quot;qml-qtquick-gradient&quot;&gt;Gradient&lt;/a&gt; child object, which in turn has two &lt;a href=&quot;qml-qtquick-gradientstop&quot;&gt;GradientStop&lt;/a&gt; children.</source>
          <target state="translated">Когда этот код загружается движком, он создает дерево объектов с объектом &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; в корне; у этого объекта есть дочерний объект &lt;a href=&quot;qml-qtquick-gradient&quot;&gt;Gradient&lt;/a&gt; , который, в свою очередь, имеет два дочерних объекта &lt;a href=&quot;qml-qtquick-gradientstop&quot;&gt;GradientStop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bef518027d6e82c3441e9a6878947589c6671093" translate="yes" xml:space="preserve">
          <source>When this event occurs it is customary to show a &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; with a context menu, if this is relevant to the context.</source>
          <target state="translated">Когда происходит это событие, обычно отображается &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; с контекстным меню, если это имеет отношение к контексту.</target>
        </trans-unit>
        <trans-unit id="1c5aa92c276833ef89412fc07466f6fcff736ad0" translate="yes" xml:space="preserve">
          <source>When this feature is on (the default is off), clicking on a header section sorts the items according to that column. By clicking repeatedly, the user can alternate between ascending and descending order.</source>
          <target state="translated">Когда эта функция включена (по умолчанию она выключена),щелчок по секции заголовка сортирует элементы в соответствии с этим столбцом.Щелкая несколько раз,пользователь может чередовать порядок возрастания и убывания.</target>
        </trans-unit>
        <trans-unit id="5aafd154ba0fcb35eccabb15e1a7d96cc39747d6" translate="yes" xml:space="preserve">
          <source>When this function is called after the program has been linked, the program will need to be relinked for the change to take effect.</source>
          <target state="translated">Когда эта функция вызывается после связывания программы,для того,чтобы изменение вступило в силу,программу нужно будет перекомпоновать.</target>
        </trans-unit>
        <trans-unit id="c9186348bdc67fdf223b859066aa3c52ea35863b" translate="yes" xml:space="preserve">
          <source>When this function is called multiple times in quick succession with the same function as its first argument, that function will be called only once.</source>
          <target state="translated">Когда эта функция вызывается несколько раз подряд в быстрой последовательности с тем же самым аргументом,что и первый аргумент,то эта функция будет вызываться только один раз.</target>
        </trans-unit>
        <trans-unit id="398a779395d95b160c8ff7f5a1fe0f7602c5e153" translate="yes" xml:space="preserve">
          <source>When this function is called, the purchase process is initiated. At some point during the process, the &lt;a href=&quot;qinappstore#transactionReady&quot;&gt;QInAppStore::transactionReady&lt;/a&gt;() signal is emitted, and the slot registered earlier is called. In this function, you can save data about a successful purchase so that it survives across application runs. After verifying that the data has been stored, finalize the transaction. If the transaction fails, display information about the failure to the user and finalize the transaction.</source>
          <target state="translated">При вызове этой функции запускается процесс покупки. В какой-то момент во время процесса &lt;a href=&quot;qinappstore#transactionReady&quot;&gt;выдается&lt;/a&gt; сигнал QInAppStore :: transactionReady () и вызывается ранее зарегистрированный слот. В этой функции вы можете сохранить данные об успешной покупке, чтобы они сохранялись при запуске приложения. Убедившись, что данные были сохранены, завершите транзакцию. Если транзакция не удалась, отобразите информацию о сбое для пользователя и завершите транзакцию.</target>
        </trans-unit>
        <trans-unit id="0a8adea584e450f3c916a9833293ed806c718263" translate="yes" xml:space="preserve">
          <source>When this hint is set and it is applicable, the clip region will be generated from &lt;a href=&quot;qsgclipnode#clipRect&quot;&gt;clipRect&lt;/a&gt;() rather than &lt;a href=&quot;qsgbasicgeometrynode#geometry&quot;&gt;geometry&lt;/a&gt;().</source>
          <target state="translated">Когда эта подсказка установлена ​​и применима, область обрезки будет сгенерирована из &lt;a href=&quot;qsgclipnode#clipRect&quot;&gt;clipRect&lt;/a&gt; (), а не из &lt;a href=&quot;qsgbasicgeometrynode#geometry&quot;&gt;geometry&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="25c548388c50d22300a6331c81e8413c5cbc46fc" translate="yes" xml:space="preserve">
          <source>When this is enabled, qmake will process all libraries linked to by the application and find their meta-information. qmake will use this to determine the relevant linking information, specifically adding values to the application project file's list of &lt;a href=&quot;qmake-variable-reference#defines&quot;&gt;DEFINES&lt;/a&gt; as well as &lt;a href=&quot;qmake-variable-reference#libs&quot;&gt;LIBS&lt;/a&gt;. Once qmake has processed this file, it will then look through the newly introduced libraries in the &lt;code&gt;LIBS&lt;/code&gt; variable, and find their dependent .prl files, continuing until all libraries have been resolved. At this point, the Makefile is created as usual, and the libraries are linked explicitly against the application.</source>
          <target state="translated">Когда это включено, qmake будет обрабатывать все библиотеки, связанные с приложением, и находить их метаинформацию. qmake будет использовать это для определения соответствующей информации о связывании, в частности, добавляя значения в список файлов проекта приложения &lt;a href=&quot;qmake-variable-reference#defines&quot;&gt;DEFINES,&lt;/a&gt; а также &lt;a href=&quot;qmake-variable-reference#libs&quot;&gt;LIBS&lt;/a&gt; . После того, как qmake обработает этот файл, он затем просмотрит новые библиотеки в переменной &lt;code&gt;LIBS&lt;/code&gt; и найдет их зависимые файлы .prl, продолжая до тех пор, пока все библиотеки не будут разрешены. На этом этапе Makefile создается как обычно, а библиотеки явно связаны с приложением.</target>
        </trans-unit>
        <trans-unit id="e1c2654888290051c11e8d6edd467ee92c8e7a88" translate="yes" xml:space="preserve">
          <source>When this is repeated for each leaf node in the framegraph, the frame is complete and the renderer calls &lt;a href=&quot;qopenglcontext#swapBuffers&quot;&gt;QOpenGLContext::swapBuffers&lt;/a&gt;() to display the frame.</source>
          <target state="translated">Когда это повторяется для каждого конечного узла в графе фрейма, фрейм завершается, и средство визуализации вызывает &lt;a href=&quot;qopenglcontext#swapBuffers&quot;&gt;QOpenGLContext :: swapBuffers&lt;/a&gt; () для отображения фрейма.</target>
        </trans-unit>
        <trans-unit id="ec52fd20354c1402a9e5c8a902314529744bb69a" translate="yes" xml:space="preserve">
          <source>When this method is called it additionally sets either the &lt;a href=&quot;qml-qtquick-controls-textarea#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; or the &lt;a href=&quot;qml-qtquick-controls-textarea#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (whichever was at the previous cursor position) to the specified position. This allows you to easily extend and contract the selected text range.</source>
          <target state="translated">Когда этот метод вызывается, он дополнительно устанавливает &lt;a href=&quot;qml-qtquick-controls-textarea#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; или &lt;a href=&quot;qml-qtquick-controls-textarea#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (в зависимости от того, что было в предыдущей позиции курсора) в указанную позицию. Это позволяет легко расширять и сокращать выделенный текстовый диапазон.</target>
        </trans-unit>
        <trans-unit id="0b402258b559da375e5607dca734ac8dba2f14ee" translate="yes" xml:space="preserve">
          <source>When this method is called it additionally sets either the &lt;a href=&quot;qml-qtquick-textedit#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; or the &lt;a href=&quot;qml-qtquick-textedit#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (whichever was at the previous cursor position) to the specified position. This allows you to easily extend and contract the selected text range.</source>
          <target state="translated">Когда этот метод вызывается, он дополнительно устанавливает &lt;a href=&quot;qml-qtquick-textedit#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; или &lt;a href=&quot;qml-qtquick-textedit#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (в зависимости от того, что было в предыдущей позиции курсора) в указанную позицию. Это позволяет легко расширять и сокращать выделенный текстовый диапазон.</target>
        </trans-unit>
        <trans-unit id="81183ac8bcf1dd186d0806619cf0a4b7150e1d76" translate="yes" xml:space="preserve">
          <source>When this method is called it additionally sets either the &lt;a href=&quot;qml-qtquick-textinput#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; or the &lt;a href=&quot;qml-qtquick-textinput#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (whichever was at the previous cursor position) to the specified position. This allows you to easily extend and contract the selected text range.</source>
          <target state="translated">Когда этот метод вызывается, он дополнительно устанавливает &lt;a href=&quot;qml-qtquick-textinput#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; или &lt;a href=&quot;qml-qtquick-textinput#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (в зависимости от того, что было в предыдущей позиции курсора) в указанную позицию. Это позволяет легко расширять и сокращать выделенный текстовый диапазон.</target>
        </trans-unit>
        <trans-unit id="3be9f15b12fa7586e346464303593068b7d2ddce" translate="yes" xml:space="preserve">
          <source>When this method is called, or when the user tries to close the window by its title bar button, the &lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;closing&lt;/a&gt; signal will be emitted. If there is no handler, or the handler does not revoke permission to close, the window will subsequently close. If the &lt;a href=&quot;qguiapplication#quitOnLastWindowClosed-prop&quot;&gt;QGuiApplication::quitOnLastWindowClosed&lt;/a&gt; property is &lt;code&gt;true&lt;/code&gt;, and there are no other windows open, the application will quit.</source>
          <target state="translated">Когда этот метод вызывается, или когда пользователь пытается закрыть окно кнопкой его строки заголовка, будет &lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;выдан&lt;/a&gt; сигнал закрытия . Если обработчик отсутствует или обработчик не отзывает разрешение на закрытие, окно впоследствии закроется. Если &lt;a href=&quot;qguiapplication#quitOnLastWindowClosed-prop&quot;&gt;свойство QGuiApplication :: quitOnLastWindowClosed&lt;/a&gt; имеет значение &lt;code&gt;true&lt;/code&gt; и другие окна не открыты, приложение завершится.</target>
        </trans-unit>
        <trans-unit id="4ca058932c3f0b4bb0aeaff104b696065bebb8ff" translate="yes" xml:space="preserve">
          <source>When this option is enabled, qmake will process all libraries linked to by the application and find their meta-information (see &lt;a href=&quot;qmake-advanced-usage#libdepend&quot;&gt;Library Dependencies&lt;/a&gt; for more info).</source>
          <target state="translated">Когда эта опция включена, qmake будет обрабатывать все библиотеки, связанные с приложением, и находить их метаинформацию (см. &lt;a href=&quot;qmake-advanced-usage#libdepend&quot;&gt;Зависимости библиотек&lt;/a&gt; для получения дополнительной информации).</target>
        </trans-unit>
        <trans-unit id="e954b1e0533aa197768aa31122dd76fd088a3473" translate="yes" xml:space="preserve">
          <source>When this option is set, &lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine::naturalTextWidth&lt;/a&gt;() and &lt;a href=&quot;qtextline#naturalTextRect&quot;&gt;QTextLine::naturalTextRect&lt;/a&gt;() will return a value that includes the width of trailing spaces in the text; otherwise this width is excluded.</source>
          <target state="translated">Когда эта опция установлена, &lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine :: naturalTextWidth&lt;/a&gt; () и &lt;a href=&quot;qtextline#naturalTextRect&quot;&gt;QTextLine :: naturalTextRect&lt;/a&gt; () вернут значение, которое включает ширину конечных пробелов в тексте; в противном случае эта ширина исключается.</target>
        </trans-unit>
        <trans-unit id="7e4b2c0654bf40a5f19574c6810ff26dfd4d2ceb" translate="yes" xml:space="preserve">
          <source>When this option is set, &lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine::naturalTextWidth&lt;/a&gt;() and naturalTextRect() will return a value that includes the width of trailing spaces in the text; otherwise this width is excluded.</source>
          <target state="translated">Когда этот параметр установлен, &lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine :: naturalTextWidth&lt;/a&gt; () и naturalTextRect () возвращают значение, которое включает ширину конечных пробелов в тексте; в противном случае эта ширина исключается.</target>
        </trans-unit>
        <trans-unit id="f271981227ef20d87cc64f0259c4f19f522399df" translate="yes" xml:space="preserve">
          <source>When this property changes, a scrollable view should automatically scroll itself in such a way as to ensure that this region is visible; for example, it could try to position the upper-left corner near the upper-left of its own viewport, subject to the constraints of the scrollable area.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c42f5c456658d1e6cc7ae9de66d3b8a114c246a" translate="yes" xml:space="preserve">
          <source>When this property changes, the &lt;code&gt;topLevelChanged()&lt;/code&gt; signal is emitted.</source>
          <target state="translated">При изменении этого свойства &lt;code&gt;topLevelChanged()&lt;/code&gt; сигнал topLevelChanged () .</target>
        </trans-unit>
        <trans-unit id="2e8947f71029eebb8d494bf176ad2f080cf20f26" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;false&lt;/code&gt;, it's not possible to drag the dial across the from and to values.</source>
          <target state="translated">Когда это свойство имеет значение &lt;code&gt;false&lt;/code&gt; , невозможно перетащить шкалу через значения от и до.</target>
        </trans-unit>
        <trans-unit id="2cf377eb087a92958eeac23380aef05f26d062d5" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt; (the default), the next month, previous month, month selection, year selection controls are shown on top.</source>
          <target state="translated">Если это свойство &lt;code&gt;true&lt;/code&gt; (по умолчанию), следующий месяц, предыдущий месяц, выбор месяца, элементы управления выбором года отображаются вверху.</target>
        </trans-unit>
        <trans-unit id="e001d3612422e2e98bda1806f3de5d100dc0ffd9" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt; and the &lt;a href=&quot;qml-qtquick3d-model#tessellationMode-prop&quot;&gt;tessellationMode&lt;/a&gt; is not Model.NoTessellation, a wireframe is displayed to highlight the additional geometry created by the tessellation generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6308ea5aac847e02c97a8f794ffa729d592dd4" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt; object outside the frustum will be culled, meaning they will not be rendered. By default this property is set to &lt;code&gt;false&lt;/code&gt;, but for complex scene where a lot of the objects are outside the camera frustum it might be beneficial to enable frustum culling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c6d22c0bbc6a53d1f13528b30f888d0610b3d76" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt;, shadows can be cast onto this item. So the shadow map is applied to this model by the renderer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3ac6a5c511fb8757d09b3ced0b9ec19d6b694d" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt;, the geometry of this model is used when rendering to the shadow maps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5435f7b9bf2979fd82564870b5b12500055a6cde" translate="yes" xml:space="preserve">
          <source>When this property is enabled it scatters the edges of the ambient occlusion shadow bands to improve smoothness (at the risk of sometimes producing obvious patterned artifacts).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e970705b8c985988e06ca43a11e32d86795a38e" translate="yes" xml:space="preserve">
          <source>When this property is enabled more shortcuts are taken to approximate the light contributes of the light probe at the expense of quality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dac3a5e67061b28cd41b0e9edb5be2c4bdef12b" translate="yes" xml:space="preserve">
          <source>When this property is enabled temporal antialiasing will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd821d6a927b06c3741219adce2a495492f9002" translate="yes" xml:space="preserve">
          <source>When this property is enabled, the light will cast shadows. The default value is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100dd97a4fb38bb0a31c18fad05f76672fb1531a" translate="yes" xml:space="preserve">
          <source>When this property is enabled, the material will use vertex colors from the mesh. These will be multiplied by any other colors specified for the material.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf43a8d4ad0de35433838bc85feefa148dfa808b" translate="yes" xml:space="preserve">
          <source>When this property is set and the &lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;velocity&lt;/a&gt; value is greater than 0, the &lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;velocity&lt;/a&gt; limits the maximum speed.</source>
          <target state="translated">Когда это свойство установлено и значение &lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;скорости&lt;/a&gt; больше 0, &lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;скорость&lt;/a&gt; ограничивает максимальную скорость.</target>
        </trans-unit>
        <trans-unit id="bf92afa5571a2082abd019a22b3b5e076f89feca" translate="yes" xml:space="preserve">
          <source>When this property is set any current decoding is stopped, and any audio buffers are discarded.</source>
          <target state="translated">При установке этого свойства любое текущее декодирование прекращается,а любые аудио буферы отбрасываются.</target>
        </trans-unit>
        <trans-unit id="6f37ded37bad8b26d03755297e0d0d1d2d468416" translate="yes" xml:space="preserve">
          <source>When this property is set the tab widget frame is not rendered. This mode is useful for showing document-type pages where the page covers most of the tab widget area.</source>
          <target state="translated">При установке данного свойства рамка виджета вкладки не отображается.Этот режим полезен для отображения страниц документального типа,где страница охватывает большую часть области виджета вкладки.</target>
        </trans-unit>
        <trans-unit id="bb1f39d69438f440f90e503c95bb71197010e140" translate="yes" xml:space="preserve">
          <source>When this property is set to &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;SingleSelection&lt;/a&gt;, the user can select a date within the minimum and maximum allowed dates, using either the mouse or the keyboard.</source>
          <target state="translated">Если для этого свойства установлено значение &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;SingleSelection&lt;/a&gt; , пользователь может выбрать дату в пределах минимальной и максимальной разрешенных дат с помощью мыши или клавиатуры.</target>
        </trans-unit>
        <trans-unit id="4747a4a028b83a9e0e586a4b5157956a8881beee" translate="yes" xml:space="preserve">
          <source>When this property is set to &lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt::VisualMoveStyle&lt;/a&gt;, the line edit will use visual movement style. Pressing the left arrow key will always cause the cursor to move left, regardless of the text's writing direction. The same behavior applies to right arrow key.</source>
          <target state="translated">Когда для этого свойства установлено значение &lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt :: VisualMoveStyle&lt;/a&gt; , при редактировании строки будет использоваться стиль визуального перемещения. При нажатии клавиши со стрелкой влево курсор всегда перемещается влево, независимо от направления написания текста. Такое же поведение применяется к клавише со стрелкой вправо.</target>
        </trans-unit>
        <trans-unit id="6350e57b73a741c92757bc74c17a0770b6b20fee" translate="yes" xml:space="preserve">
          <source>When this property is set to &lt;code&gt;false&lt;/code&gt;, the Z-buffer is not used, the depth test is skipped, and all objects, including fully opaque ones, are rendered in one go sorted back to front.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0edc644e371fc7727ba54cb716093cdd57e0cd9c" translate="yes" xml:space="preserve">
          <source>When this property is set, the given folder will be treated as the root in the file system, so that you can only traverse subfolders within it.</source>
          <target state="translated">Когда это свойство установлено,данная папка будет считаться корневой в файловой системе,так что внутри нее можно будет пересекать только подпапки.</target>
        </trans-unit>
        <trans-unit id="b2d44a4363149f5868c0478951229cd0f684ca40" translate="yes" xml:space="preserve">
          <source>When this property is set, the specified opacity is also applied individually to child items. This may have an unintended effect in some circumstances. For example in the second set of rectangles below, the red rectangle has specified an opacity of 0.5, which affects the opacity of its blue child rectangle even though the child has not specified an opacity.</source>
          <target state="translated">Когда это свойство установлено,указанная непрозрачность также применяется индивидуально к дочерним элементам.В некоторых случаях это может привести к непреднамеренному эффекту.Например,во втором наборе прямоугольников ниже красный прямоугольник имеет указанную непрозрачность 0.5,что влияет на непрозрачность его синего дочернего прямоугольника,даже если дочерний прямоугольник не указал непрозрачность.</target>
        </trans-unit>
        <trans-unit id="1f016f4e737a52e8f462fcd37b82c141a90134d0" translate="yes" xml:space="preserve">
          <source>When this property is true, the Node (and its children) can be visible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f5748d3f3423c22760b03f83dc84f38b1f3b1f" translate="yes" xml:space="preserve">
          <source>When this propery is set to false text edit will accept only plain text input from the user. For example through clipboard or drag and drop.</source>
          <target state="translated">При установке этого параметра в значение false text edit от пользователя будет приниматься только обычный текст.Например,через буфер обмена или перетаскиванием.</target>
        </trans-unit>
        <trans-unit id="aec3729055d25b18cd030179a5d7fbd186ecaf3f" translate="yes" xml:space="preserve">
          <source>When this restore policy is set, the machine will automatically restore all properties. If it enters a state where a given property is not set, it will first search the hierarchy of ancestors to see if the property is defined there. If it is, the property will be restored to the value defined by the closest ancestor. If not, it will be restored to its initial value (i.e. the value of the property before any property assignments in states were executed.)</source>
          <target state="translated">Когда эта политика восстановления установлена,машина автоматически восстановит все свойства.Если она войдет в состояние,в котором данное свойство не установлено,она сначала проведет поиск по иерархии предков,чтобы посмотреть,определено ли там свойство.Если это так,то свойство будет восстановлено до значения,определенного ближайшим предком.В противном случае,свойство будет восстановлено до первоначального значения (т.е.до значения свойства до выполнения каких-либо присваиваний в состояниях).</target>
        </trans-unit>
        <trans-unit id="2cb4559c1cf0ab4e52e4f01892955e108435ae26" translate="yes" xml:space="preserve">
          <source>When this signal is emitted, the event loop has already stopped running. No more events will be processed in the thread, except for deferred deletion events. This signal can be connected to &lt;a href=&quot;qobject#deleteLater&quot;&gt;QObject::deleteLater&lt;/a&gt;(), to free objects in that thread.</source>
          <target state="translated">Когда этот сигнал испускается, цикл обработки событий уже остановился. Больше никаких событий в потоке обрабатываться не будет, за исключением отложенных событий удаления. Этот сигнал может быть подключен к &lt;a href=&quot;qobject#deleteLater&quot;&gt;QObject :: deleteLater&lt;/a&gt; (), чтобы освободить объекты в этом потоке.</target>
        </trans-unit>
        <trans-unit id="bc470d3a44b5fd1b983e2c2d38610b55df6e2808" translate="yes" xml:space="preserve">
          <source>When this signal is emitted, the socket may not be ready for a reconnect attempt. In that case, attempts to reconnect should be done from the event loop. For example, use a &lt;a href=&quot;qtimer#singleShot&quot;&gt;QTimer::singleShot&lt;/a&gt;() with 0 as the timeout.</source>
          <target state="translated">Когда издается этот сигнал, возможно, сокет не готов к повторной попытке подключения. В этом случае попытки повторного подключения должны выполняться из цикла событий. Например, используйте &lt;a href=&quot;qtimer#singleShot&quot;&gt;QTimer :: singleShot&lt;/a&gt; () с 0 в качестве тайм-аута.</target>
        </trans-unit>
        <trans-unit id="68f5a54216eb63b6271e28125c316438880cf091" translate="yes" xml:space="preserve">
          <source>When tr() is called, it looks up the translatable string using a &lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt; object. For translation to work, one or more of these must have been installed on the application object in the way described in &lt;a href=&quot;internationalization#enabling-translation&quot;&gt;Enabling Translation&lt;/a&gt;.</source>
          <target state="translated">Когда вызывается tr (), он ищет переводимую строку с помощью объекта &lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt; . Чтобы перевод работал, один или несколько из них должны быть установлены на объекте приложения, как описано в &lt;a href=&quot;internationalization#enabling-translation&quot;&gt;разделе &amp;laquo;Включение перевода&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9ebf77d443c0f3c1d237e7890cbd696ca28dded" translate="yes" xml:space="preserve">
          <source>When transforming a pixmap using the &lt;a href=&quot;qpixmap#transformed&quot;&gt;transformed&lt;/a&gt;() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. &lt;a href=&quot;qpixmap#transformed&quot;&gt;transformed&lt;/a&gt;() returns the smallest pixmap containing all transformed points of the original pixmap. This function returns the modified matrix, which maps points correctly from the original pixmap into the new pixmap.</source>
          <target state="translated">При преобразовании растрового изображения с использованием функции &lt;a href=&quot;qpixmap#transformed&quot;&gt;transformed&lt;/a&gt; () матрица преобразования внутренне корректируется для компенсации нежелательного перевода, то есть &lt;a href=&quot;qpixmap#transformed&quot;&gt;transformed&lt;/a&gt; () возвращает наименьшее растровое изображение, содержащее все преобразованные точки исходного растрового изображения. Эта функция возвращает модифицированную матрицу, которая правильно отображает точки из исходного растрового изображения в новое растровое изображение.</target>
        </trans-unit>
        <trans-unit id="e797276249bcc854a69b6e49354f4d62d00c23f8" translate="yes" xml:space="preserve">
          <source>When transforming an embedded widget, Graphics View makes sure that the widget is transformed resolution independently, allowing the fonts and style to stay crisp when zoomed in. (Note that the effect of resolution independence depends on the style.)</source>
          <target state="translated">При преобразовании встроенного виджета Graphics View обеспечивает независимое преобразование разрешения виджета,позволяя шрифтам и стилю оставаться четкими при увеличении.(Обратите внимание,что эффект независимости разрешения зависит от стиля).</target>
        </trans-unit>
        <trans-unit id="3aa1fd29b9548bcc37cb012b55271fdb19e2ee54" translate="yes" xml:space="preserve">
          <source>When transforming an image using the &lt;a href=&quot;qimage#transformed&quot;&gt;transformed&lt;/a&gt;() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. &lt;a href=&quot;qimage#transformed&quot;&gt;transformed&lt;/a&gt;() returns the smallest image containing all transformed points of the original image. This function returns the modified matrix, which maps points correctly from the original image into the new image.</source>
          <target state="translated">При преобразовании изображения с помощью функции &lt;a href=&quot;qimage#transformed&quot;&gt;transformed&lt;/a&gt; () матрица преобразования внутренне настраивается для компенсации нежелательного перевода, т.е. &lt;a href=&quot;qimage#transformed&quot;&gt;transformed&lt;/a&gt; () возвращает наименьшее изображение, содержащее все преобразованные точки исходного изображения. Эта функция возвращает модифицированную матрицу, которая правильно отображает точки исходного изображения на новое изображение.</target>
        </trans-unit>
        <trans-unit id="4d6a460eeff2d6a334a698745ed9d8d6a6ebeec9" translate="yes" xml:space="preserve">
          <source>When transforming an image using the transformed() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. transformed() returns the smallest image containing all transformed points of the original image. This function returns the modified matrix, which maps points correctly from the original image into the new image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7221d90a96209f3128795a80a97a531cead2f548" translate="yes" xml:space="preserve">
          <source>When transforming from clip to normalized space, a division by the w component of the vector components takes place. To prevent dividing by 0 if w equals to 0, it is set to 1.</source>
          <target state="translated">При преобразовании из клипа в нормализованное пространство происходит деление на w-компоненту векторных составляющих.Для предотвращения деления на 0,если w равно 0,оно устанавливается равным 1.</target>
        </trans-unit>
        <trans-unit id="fbec62568b02f257db0ec31fbe2b5f21cf0c220e" translate="yes" xml:space="preserve">
          <source>When transforming from clip to normalized space, a division by the w component on the vector components takes place. To prevent dividing by 0 if w equals to 0, it is set to 1.</source>
          <target state="translated">При преобразовании из клипа в нормализованное пространство происходит деление на w-компоненту на векторные компоненты.Для предотвращения деления на 0,если w равно 0,оно устанавливается равным 1.</target>
        </trans-unit>
        <trans-unit id="f520f592321df5d529bf39711026e14f01be91fb" translate="yes" xml:space="preserve">
          <source>When true, the menu contains a special tear-off item (often shown as a dashed line at the top of the menu) that creates a copy of the menu when it is triggered.</source>
          <target state="translated">В значении true меню содержит специальный отрывной элемент (часто отображаемый в виде пунктирной линии в верхней части меню),который создает копию меню при его срабатывании.</target>
        </trans-unit>
        <trans-unit id="a89b60404dcbc2f5c915acfe02c16712d4bb61d2" translate="yes" xml:space="preserve">
          <source>When two manuals are located in the same virtual folder, it is possible to refer to sections of the other manual using relative paths. The virtual folder tag is mandatory and the folder must not contain any '/'.</source>
          <target state="translated">Когда два руководства находятся в одной виртуальной папке,можно обратиться к разделам другого руководства,используя относительные пути.Тэг виртуальной папки является обязательным,и папка не должна содержать никаких '/'.</target>
        </trans-unit>
        <trans-unit id="611300300598b513a04acdc4158b65a1b90365bd" translate="yes" xml:space="preserve">
          <source>When two widgets are adjacent to each other in a horizontal layout, setting the horizontal stretch factor of the widget on the left to 2 and the factor of widget on the right to 1 will ensure that the widget on the left will always be twice the size of the one on the right.</source>
          <target state="translated">Когда два виджета соседствуют друг с другом в горизонтальном расположении,установка горизонтального коэффициента растяжения виджета слева на 2 и коэффициента растяжения виджета справа на 1 обеспечит,что виджет слева всегда будет в два раза больше,чем виджет справа.</target>
        </trans-unit>
        <trans-unit id="33931b591564c5ce659c5439a00ac167ba2235e2" translate="yes" xml:space="preserve">
          <source>When two widgets are adjacent to each other in a vertical layout, setting the vertical stretch factor of the widget on the top to 2 and the factor of widget on the bottom to 1 will ensure that the widget on the top will always be twice the size of the one on the bottom.</source>
          <target state="translated">Когда два виджета соседствуют друг с другом в вертикальном расположении,установка коэффициента вертикального растяжения виджета сверху на 2 и коэффициента растяжения виджета снизу на 1 гарантирует,что размер виджета сверху всегда будет в два раза больше,чем у виджета снизу.</target>
        </trans-unit>
        <trans-unit id="55c03842e144167485cbd5e8643bcbb80f6a7794" translate="yes" xml:space="preserve">
          <source>When unshared (or const version is called), this executes in &lt;a href=&quot;containers#constant-time&quot;&gt;constant time&lt;/a&gt;.</source>
          <target state="translated">Когда не используется общий доступ (или вызывается &lt;a href=&quot;containers#constant-time&quot;&gt;константная&lt;/a&gt; версия), это выполняется в постоянное время .</target>
        </trans-unit>
        <trans-unit id="bcc9e75ff489b96d3335be53af67c254b116188b" translate="yes" xml:space="preserve">
          <source>When unshared (or const version is called), this executes in &lt;a href=&quot;containers#logarithmic-time&quot;&gt;logarithmic time&lt;/a&gt;.</source>
          <target state="translated">Когда не используется общий доступ (или вызывается константная версия), это выполняется за &lt;a href=&quot;containers#logarithmic-time&quot;&gt;логарифмическое время&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="991f02e2c91e5a7647479f2f811f8738759e3c87" translate="yes" xml:space="preserve">
          <source>When updating the current time, &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; will emit &lt;a href=&quot;qtimeline#valueChanged&quot;&gt;valueChanged&lt;/a&gt;() if the current value changed, and &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;() if the frame changed.</source>
          <target state="translated">При обновлении текущего времени &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; будет &lt;a href=&quot;qtimeline#valueChanged&quot;&gt;генерировать valueChanged&lt;/a&gt; (), если текущее значение изменилось, и &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt; (), если изменился кадр.</target>
        </trans-unit>
        <trans-unit id="daf7b6e7fdbba2dfca1eadbe18a1d7de3b720e7b" translate="yes" xml:space="preserve">
          <source>When used as a context menu, the recommended way of opening the menu is to call &lt;a href=&quot;qml-qtquick-controls2-menu#popup-method&quot;&gt;popup()&lt;/a&gt;. Unless a position is explicitly specified, the menu is positioned at the mouse cursor on desktop platforms that have a mouse cursor available, and otherwise centered over its parent item.</source>
          <target state="translated">При использовании в качестве контекстного меню рекомендуемый способ открыть меню - вызвать &lt;a href=&quot;qml-qtquick-controls2-menu#popup-method&quot;&gt;popup ()&lt;/a&gt; . Если позиция не указана явно, меню располагается у курсора мыши на настольных платформах, на которых есть курсор мыши, и в противном случае центрируется над своим родительским элементом.</target>
        </trans-unit>
        <trans-unit id="e42ccc06c2943db340e29e9634bf18dbc9e13468" translate="yes" xml:space="preserve">
          <source>When used as a popup menu, it is easiest to specify the position by specifying the desired &lt;a href=&quot;qml-qtquick-controls2-popup#x-prop&quot;&gt;x&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-popup#y-prop&quot;&gt;y&lt;/a&gt; coordinates using the respective properties, and call &lt;a href=&quot;qml-qtquick-controls2-popup#open-method&quot;&gt;open()&lt;/a&gt; to open the menu.</source>
          <target state="translated">При использовании в качестве всплывающего меню проще всего указать позицию, указав желаемые координаты &lt;a href=&quot;qml-qtquick-controls2-popup#x-prop&quot;&gt;x&lt;/a&gt; и &lt;a href=&quot;qml-qtquick-controls2-popup#y-prop&quot;&gt;y&lt;/a&gt; с помощью соответствующих свойств, и вызвать &lt;a href=&quot;qml-qtquick-controls2-popup#open-method&quot;&gt;open (),&lt;/a&gt; чтобы открыть меню.</target>
        </trans-unit>
        <trans-unit id="51c1a4b96d0ac9fe7349345183028fcd340a1cf9" translate="yes" xml:space="preserve">
          <source>When used as a standalone application,</source>
          <target state="translated">При использовании в качестве автономного приложения,</target>
        </trans-unit>
        <trans-unit id="7c8523a9cdaa732605d1c3ca0c57e7327514b32b" translate="yes" xml:space="preserve">
          <source>When used as an interface type, &lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt; allows a single function to accept a wide variety of UTF-16 string data sources. One function accepting &lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt; thus replaces three function overloads (taking &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, &lt;a href=&quot;qstringref&quot;&gt;QStringRef&lt;/a&gt;, and &lt;code&gt;(const QChar*, int)&lt;/code&gt;), while at the same time enabling even more string data sources to be passed to the function, such as &lt;code&gt;u&quot;Hello World&quot;&lt;/code&gt;, a &lt;code&gt;char16_t&lt;/code&gt; string literal.</source>
          <target state="translated">При использовании в качестве типа интерфейса &lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt; позволяет одной функции принимать широкий спектр строковых источников данных UTF-16. &lt;a href=&quot;qstringview&quot;&gt;Таким&lt;/a&gt; образом, одна функция, принимающая QStringView, заменяет три перегрузки функции (принимая &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; , &lt;a href=&quot;qstringref&quot;&gt;QStringRef&lt;/a&gt; и &lt;code&gt;(const QChar*, int)&lt;/code&gt; ), в то же время позволяя передавать функции еще больше источников строковых данных, например &lt;code&gt;u&quot;Hello World&quot;&lt;/code&gt; , строковый литерал &lt;code&gt;char16_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d30f2719e4dfd488693920afd51d738514f58fc" translate="yes" xml:space="preserve">
          <source>When used as an interface type, QStringView allows a single function to accept a wide variety of UTF-16 string data sources. One function accepting QStringView thus replaces three function overloads (taking &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, &lt;a href=&quot;qstringref&quot;&gt;QStringRef&lt;/a&gt;, and &lt;code&gt;(const QChar*, int)&lt;/code&gt;), while at the same time enabling even more string data sources to be passed to the function, such as &lt;code&gt;u&quot;Hello World&quot;&lt;/code&gt;, a &lt;code&gt;char16_t&lt;/code&gt; string literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e868d59396f0fc788445bb00690275ea6245ac1" translate="yes" xml:space="preserve">
          <source>When used as flags, enumerators can be combined using the OR operator.</source>
          <target state="translated">При использовании в качестве флагов,перечисления можно комбинировать с помощью оператора &quot;ИЛИ&quot;.</target>
        </trans-unit>
        <trans-unit id="06c2c617a12597a994b108366e0d50cfb932d1fd" translate="yes" xml:space="preserve">
          <source>When used as part of a Transition, you can also target a specific &lt;a href=&quot;qml-qtquick-statechangescript&quot;&gt;StateChangeScript&lt;/a&gt; to run using the &lt;code&gt;scriptName&lt;/code&gt; property.</source>
          <target state="translated">При использовании в составе Transition вы также можете &lt;a href=&quot;qml-qtquick-statechangescript&quot;&gt;указать&lt;/a&gt; конкретный StateChangeScript для запуска с &lt;code&gt;scriptName&lt;/code&gt; свойства scriptName .</target>
        </trans-unit>
        <trans-unit id="59f0102a4ce38b4f2ee3e6dec5be09d72963e0c7" translate="yes" xml:space="preserve">
          <source>When used in a &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pauseanimation&quot;&gt;PauseAnimation&lt;/a&gt; is a step when nothing happens, for a specified duration.</source>
          <target state="translated">При использовании в &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-pauseanimation&quot;&gt;PauseAnimation&lt;/a&gt; является шагом , когда ничего не происходит, в течение определенного времени.</target>
        </trans-unit>
        <trans-unit id="32a85cc6f1a776a818b49cfac1cb9534a2a52415" translate="yes" xml:space="preserve">
          <source>When used in a &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt;, PauseAnimation is a step when nothing happens, for a specified duration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1ec54421dbb8796f81a74d96171dee0c22a448e" translate="yes" xml:space="preserve">
          <source>When used in a transition, a property animation is assumed to match</source>
          <target state="translated">При использовании в переходе предполагается,что анимация свойств соответствует</target>
        </trans-unit>
        <trans-unit id="c62896cbdfc7c3f4c1df9f239489204e6ebe788a" translate="yes" xml:space="preserve">
          <source>When used in a transition, if no target is specified, all &lt;a href=&quot;qml-qtquick-parentchange&quot;&gt;ParentChange&lt;/a&gt; occurrences are animated by the &lt;a href=&quot;qml-qtquick-parentanimation&quot;&gt;ParentAnimation&lt;/a&gt;.</source>
          <target state="translated">При использовании в переходе, если цель не указана, все вхождения &lt;a href=&quot;qml-qtquick-parentchange&quot;&gt;ParentChange&lt;/a&gt; анимируются &lt;a href=&quot;qml-qtquick-parentanimation&quot;&gt;объектом ParentAnimation&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="28b437395e782784d83371eebd653fd7c3c66b90" translate="yes" xml:space="preserve">
          <source>When used in a transition, the path can be specified without start or end points, for example:</source>
          <target state="translated">При использовании в переходе,путь может быть указан,например,без начальных или конечных точек:</target>
        </trans-unit>
        <trans-unit id="ad15b94076fc6d62e74b16ac21ba031bb2e8713a" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt;, the first column is not movable (since it contains the tree structure), by default. You can make it movable with &lt;a href=&quot;qheaderview#firstSectionMovable-prop&quot;&gt;setFirstSectionMovable&lt;/a&gt;(true).</source>
          <target state="translated">При использовании в сочетании с &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; первый столбец по умолчанию не перемещается (так как он содержит древовидную структуру). Вы можете сделать его подвижным с помощью &lt;a href=&quot;qheaderview#firstSectionMovable-prop&quot;&gt;setFirstSectionMovable&lt;/a&gt; (true).</target>
        </trans-unit>
        <trans-unit id="80921d8c37af7cbb33ff4de031ae482a77195e92" translate="yes" xml:space="preserve">
          <source>When used in conjunction with QTextureWrapMode::Repeat, textureScale provides a simple way to tile a texture across a surface. For example, a texture scale of &lt;code&gt;4.0&lt;/code&gt; would result in 16 (4x4) tiles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adf2789c382dae59470f104ac31491a01be4c17" translate="yes" xml:space="preserve">
          <source>When used in conjunction with WrapMode.Repeat, textureScale provides a simple way to tile a texture across a surface. For example, a texture scale of &lt;code&gt;4.0&lt;/code&gt; would result in 16 (4x4) tiles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="004dc51d90326bec6d46cfd29896a25f4617d992" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the &lt;a href=&quot;qml-qtquick-loader#source-prop&quot;&gt;source&lt;/a&gt; property, loading and compilation will also be performed in a background thread.</source>
          <target state="translated">При использовании в сочетании со свойством &lt;a href=&quot;qml-qtquick-loader#source-prop&quot;&gt;source&lt;/a&gt; загрузка и компиляция также будут выполняться в фоновом потоке.</target>
        </trans-unit>
        <trans-unit id="50af634dadcc9340640490a9af221cd3bbb07199" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the &lt;a href=&quot;qml-qtquick3d-loader3d#source-prop&quot;&gt;source&lt;/a&gt; property, loading and compilation will also be performed in a background thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5ebb2f8eef3c956f23605775c3ca22ba3215b5" translate="yes" xml:space="preserve">
          <source>When used with list models, the first item in the returned list is used for matching.</source>
          <target state="translated">При использовании со списком моделей,первый пункт в возвращаемом списке используется для сопоставления.</target>
        </trans-unit>
        <trans-unit id="2aa79e373766a60d20b2141aeac582a5a8df07d6" translate="yes" xml:space="preserve">
          <source>When user defines a new functor or generator, they need to implement the &lt;a href=&quot;qt3drender-qabstractfunctor#id&quot;&gt;QAbstractFunctor::id&lt;/a&gt;() method, which should be done using the &lt;code&gt;QT3D_FUNCTOR&lt;/code&gt; macro in the class definition.</source>
          <target state="translated">Когда пользователь определяет новый функтор или генератор, ему необходимо реализовать метод &lt;a href=&quot;qt3drender-qabstractfunctor#id&quot;&gt;QAbstractFunctor :: id&lt;/a&gt; (), что должно быть выполнено с использованием макроса &lt;code&gt;QT3D_FUNCTOR&lt;/code&gt; в определении класса.</target>
        </trans-unit>
        <trans-unit id="1426cfebd5b7719f33b6e2b9f2a97f042b4572ab" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; based widgets, you should enable the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AcceptTouchEvents&lt;/a&gt; attribute on the scroll area's &lt;a href=&quot;qabstractscrollarea#viewport&quot;&gt;viewport&lt;/a&gt;.</source>
          <target state="translated">При использовании виджетов на основе &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; вы должны включить атрибут &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_AcceptTouchEvents&lt;/a&gt; в области &lt;a href=&quot;qabstractscrollarea#viewport&quot;&gt;просмотра&lt;/a&gt; области прокрутки .</target>
        </trans-unit>
        <trans-unit id="575c3ca33cbc8c0e49967dd6868de7d0cd46c7ed" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt;, transferred exceptions will be thrown when calling the following functions:</source>
          <target state="translated">При использовании &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt; переданные исключения будут выброшены при вызове следующих функций:</target>
        </trans-unit>
        <trans-unit id="6d8f6cec0c5597c992eb3a8a60ec3ad82996acf4" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qml-qt3d-render-objectpicker&quot;&gt;ObjectPicker&lt;/a&gt; components, picking is triggered by mouse events.</source>
          <target state="translated">При использовании компонентов &lt;a href=&quot;qml-qt3d-render-objectpicker&quot;&gt;ObjectPicker&lt;/a&gt; выбор запускается событиями мыши.</target>
        </trans-unit>
        <trans-unit id="84a71d92671a35f5e7502b348babb72bc64cf8ed" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qml-qt3d-render-raycaster&quot;&gt;RayCaster&lt;/a&gt; or &lt;a href=&quot;qml-qt3d-render-screenraycaster&quot;&gt;ScreenRayCaster&lt;/a&gt; components, picking can be explicitly triggered by the application.</source>
          <target state="translated">При использовании &lt;a href=&quot;qml-qt3d-render-raycaster&quot;&gt;RayCaster&lt;/a&gt; или &lt;a href=&quot;qml-qt3d-render-screenraycaster&quot;&gt;ScreenRayCaster&lt;/a&gt; компонентов, сбор может быть явно вызван приложением.</target>
        </trans-unit>
        <trans-unit id="8b9d22db787646c3b272fef7eabbedc341942ce2" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; on a &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; (or a subclass of &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;), previously the &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; would be cleared by the &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; destructor. Now, the &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; is cleared by the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; destructor (since this is when &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; objects are cleared). Any QPointers tracking a widget will &lt;b&gt;NOT&lt;/b&gt; be cleared before the &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; destructor destroys the children for the widget being tracked.</source>
          <target state="translated">При использовании &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; в &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; (или подклассе &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; ) раньше &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; очищался деструктором &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; . Теперь &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; очищается деструктором &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; (поскольку именно тогда &lt;a href=&quot;qweakpointer&quot;&gt;очищаются&lt;/a&gt; объекты QWeakPointer ). Любые QPointers, отслеживающие виджет, &lt;b&gt;НЕ&lt;/b&gt; будут очищены до того, как деструктор &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; уничтожит дочерние элементы для отслеживаемого виджета .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
