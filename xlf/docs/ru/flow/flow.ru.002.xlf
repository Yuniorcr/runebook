<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="flow">
    <body>
      <group id="flow">
        <trans-unit id="83f2828960b3b5c2589074d8fb5ec48d203a2618" translate="yes" xml:space="preserve">
          <source>React stateless functional components do not have a backing instance and so &lt;code&gt;React.ElementRef&amp;lt;typeof Bar&amp;gt;&lt;/code&gt; (when &lt;code&gt;Bar&lt;/code&gt; is &lt;code&gt;function Bar() {}&lt;/code&gt;) will give you the undefined type.</source>
          <target state="translated">Функциональные компоненты React без сохранения состояния не имеют экземпляра поддержки, поэтому &lt;code&gt;React.ElementRef&amp;lt;typeof Bar&amp;gt;&lt;/code&gt; (когда &lt;code&gt;Bar&lt;/code&gt; является &lt;code&gt;function Bar() {}&lt;/code&gt; ) предоставит вам неопределенный тип.</target>
        </trans-unit>
        <trans-unit id="29ed07e15fc66a324459b85d24416800bceafaa3" translate="yes" xml:space="preserve">
          <source>React supports the notion of &lt;code&gt;defaultProps&lt;/code&gt; which you can think of as default function arguments. When you create an element and you did not include a prop with a default then React will substitute that prop with its corresponding value from &lt;code&gt;defaultProps&lt;/code&gt;. Flow supports this notion as well. To type default props add a &lt;code&gt;static defaultProps&lt;/code&gt; property to your class.</source>
          <target state="translated">React поддерживает понятие &lt;code&gt;defaultProps&lt;/code&gt; , которое вы можете рассматривать как аргументы функции по умолчанию. Когда вы создаете элемент и не включили опору со значением по умолчанию, React заменит эту опору соответствующим значением из &lt;code&gt;defaultProps&lt;/code&gt; . Flow также поддерживает эту идею. Чтобы ввести свойства по умолчанию, добавьте в класс &lt;code&gt;static defaultProps&lt;/code&gt; свойство defaultProps .</target>
        </trans-unit>
        <trans-unit id="70287cb5f65a904f3e064a37b30a5a631627d2e6" translate="yes" xml:space="preserve">
          <source>Read more about &lt;a href=&quot;variance&quot;&gt;property variance&lt;/a&gt;.</source>
          <target state="translated">Подробнее о &lt;a href=&quot;variance&quot;&gt;дисперсии свойств&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61910c412c7b58b226db5d6ed180b312f69dc750" translate="yes" xml:space="preserve">
          <source>Reassigning unsealed object properties</source>
          <target state="translated">Переприсвоение незапечатанных свойств объекта</target>
        </trans-unit>
        <trans-unit id="1bf2749de445e45162652ccf38c834bf918ba1b2" translate="yes" xml:space="preserve">
          <source>Reassigning variables</source>
          <target state="translated">Перераспределение переменных</target>
        </trans-unit>
        <trans-unit id="d6101a7583b060dcae14c84065094e42d98e9a54" translate="yes" xml:space="preserve">
          <source>Recall that the instance type of a function component is &lt;code&gt;void&lt;/code&gt;. Our example above wraps a component in a function, so the returned component has the instance type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Напомним, что тип экземпляра функционального компонента &lt;code&gt;void&lt;/code&gt; . В нашем примере выше компонент оборачивается в функцию, поэтому возвращаемый компонент имеет тип экземпляра &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dda31a027bfa36f4ca8585837d08aaa1912d41bf" translate="yes" xml:space="preserve">
          <source>Reducers</source>
          <target state="translated">Reducers</target>
        </trans-unit>
        <trans-unit id="1a5dd83d686967dbee491e598c66e203e42c8bea" translate="yes" xml:space="preserve">
          <source>Redux</source>
          <target state="translated">Redux</target>
        </trans-unit>
        <trans-unit id="7c12d3319cfff8593c41d6d684faf2f999524cf3" translate="yes" xml:space="preserve">
          <source>Redux state &lt;a href=&quot;http://redux.js.org/docs/introduction/ThreePrinciples.html#state-is-read-only&quot;&gt;is meant to be immutable&lt;/a&gt;: creating a new state object instead of changing properties on a single object.</source>
          <target state="translated">Состояние Redux &lt;a href=&quot;http://redux.js.org/docs/introduction/ThreePrinciples.html#state-is-read-only&quot;&gt;должно быть неизменным&lt;/a&gt; : создание нового объекта состояния вместо изменения свойств одного объекта.</target>
        </trans-unit>
        <trans-unit id="ed05f5c415303abb0d8305ee74bd6d2e8ce7eda3" translate="yes" xml:space="preserve">
          <source>Refinement Invalidations</source>
          <target state="translated">Изысканность Инвалиды</target>
        </trans-unit>
        <trans-unit id="43586e5f8885df744af66a163f9bd504927049f7" translate="yes" xml:space="preserve">
          <source>Refinement invalidation can also happen with &lt;a href=&quot;types/unions#toc-disjoint-unions&quot;&gt;disjoint unions&lt;/a&gt;. Any function call will invalidate any refinement.</source>
          <target state="translated">Аннулирование уточнения также может произойти с &lt;a href=&quot;types/unions#toc-disjoint-unions&quot;&gt;несвязанными союзами&lt;/a&gt; . Любой вызов функции аннулирует любое уточнение.</target>
        </trans-unit>
        <trans-unit id="a02ef029699599da7905088f0dc103f214ced944" translate="yes" xml:space="preserve">
          <source>Refinements are a frequently used aspect of many type systems. They are so ingrained in the way that we program and even the way that we think you might not even notice them.</source>
          <target state="translated">Усовершенствования являются часто используемым аспектом многих типов систем.Они настолько укоренились в том,как мы программируем,и даже в том,как мы думаем,что вы можете даже не заметить их.</target>
        </trans-unit>
        <trans-unit id="0b89cb145cee7a8457a6e4dd2a97e9f0caac7219" translate="yes" xml:space="preserve">
          <source>Refinements can also come in other forms other than testing for equality:</source>
          <target state="translated">Улучшения могут также проявляться и в других формах,помимо проверки на равенство:</target>
        </trans-unit>
        <trans-unit id="698e6391f48381c22849ea4013ae0a7dff98a9af" translate="yes" xml:space="preserve">
          <source>Refining Maybe types</source>
          <target state="translated">Рафинирование Может быть,виды</target>
        </trans-unit>
        <trans-unit id="9452f08c2e094961ce428c428ee0585501ce1d09" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;boolean&lt;/code&gt; and &lt;code&gt;Boolean&lt;/code&gt; are different types.</source>
          <target state="translated">Помните, что &lt;code&gt;boolean&lt;/code&gt; и &lt;code&gt;Boolean&lt;/code&gt; - разные типы.</target>
        </trans-unit>
        <trans-unit id="11f6d4fee5ab698ed0a3047ac64f1d9637774150" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;Number&lt;/code&gt; are different types.</source>
          <target state="translated">Помните, что &lt;code&gt;number&lt;/code&gt; и &lt;code&gt;Number&lt;/code&gt; - это разные типы.</target>
        </trans-unit>
        <trans-unit id="55b41046e32661a87f2a8fd34325d7734f4d4cd1" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are different types.</source>
          <target state="translated">Помните, что &lt;code&gt;string&lt;/code&gt; и &lt;code&gt;String&lt;/code&gt; - это разные типы.</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">Requirements</target>
        </trans-unit>
        <trans-unit id="3d6f80999c0c50a74e8acebc121f44bdbef82ae3" translate="yes" xml:space="preserve">
          <source>Requires Flow to be installed and available on your path.</source>
          <target state="translated">Требуется Поток,который будет установлен и доступен по вашему пути.</target>
        </trans-unit>
        <trans-unit id="33b4e56519b4614c59e8b72375bac3a885fdacaa" translate="yes" xml:space="preserve">
          <source>Requires JavaScript files to be marked with /* @flow */ at the top.</source>
          <target state="translated">Требуются JavaScript-файлы,которые должны быть помечены символом /*@flow */сверху.</target>
        </trans-unit>
        <trans-unit id="0a7c549205648d46b232d0e6177754a236939fcb" translate="yes" xml:space="preserve">
          <source>Requires projects containing JavaScript files to be initialised with flow init.</source>
          <target state="translated">Требуется инициализация проектов,содержащих JavaScript-файлы,с помощью flow init.</target>
        </trans-unit>
        <trans-unit id="3e884a460b4d82c0f0401e11f902d2d3991a0a50" translate="yes" xml:space="preserve">
          <source>Rest Parameters</source>
          <target state="translated">Параметры отдыха</target>
        </trans-unit>
        <trans-unit id="7af6341ba4a77c200422ad48589bc5fcb0b569c3" translate="yes" xml:space="preserve">
          <source>Return types ensure that every branch of your function returns the same type. This prevents you from accidentally not returning a value under certain conditions.</source>
          <target state="translated">Типы возврата гарантируют,что каждая ветвь вашей функции возвращает один и тот же тип.Это предотвращает случайное невозвращение значения при определенных условиях.</target>
        </trans-unit>
        <trans-unit id="686039dfdbe08da5125ed6c00f4c1399d48dfd9b" translate="yes" xml:space="preserve">
          <source>Right, the &lt;code&gt;isLeapYear&lt;/code&gt; call in &lt;code&gt;src/LookBeforeYouLeap.js&lt;/code&gt; will typecheck, since the &lt;code&gt;year&lt;/code&gt; parameter expects a &lt;code&gt;string&lt;/code&gt; in the declaration file.</source>
          <target state="translated">Правильно, &lt;code&gt;isLeapYear&lt;/code&gt; вызов в &lt;code&gt;src/LookBeforeYouLeap.js&lt;/code&gt; будет typecheck, так как &lt;code&gt;year&lt;/code&gt; параметр ожидает &lt;code&gt;string&lt;/code&gt; в файле декларации.</target>
        </trans-unit>
        <trans-unit id="67d0f5e7710e2e8d6a977594f3101bc9772e4d34" translate="yes" xml:space="preserve">
          <source>Run the Flow Background Process</source>
          <target state="translated">Запустить процесс фона потока</target>
        </trans-unit>
        <trans-unit id="61ba9e06d750a8c11a8c53dbe4b159704d49a040" translate="yes" xml:space="preserve">
          <source>Run this command at the top level of your project to create one, empty file called &lt;a href=&quot;https://flow.org/en/config/&quot;&gt;&lt;code&gt;.flowconfig&lt;/code&gt;&lt;/a&gt;. At its most basic level, &lt;code&gt;.flowconfig&lt;/code&gt; tells the Flow background process the root of where to begin checking Flow code for errors.</source>
          <target state="translated">Выполните эту команду на верхнем уровне вашего проекта, чтобы создать один пустой файл с именем &lt;a href=&quot;https://flow.org/en/config/&quot;&gt; &lt;code&gt;.flowconfig&lt;/code&gt; &lt;/a&gt; . На самом базовом уровне &lt;code&gt;.flowconfig&lt;/code&gt; сообщает фоновому процессу Flow корень, с которого следует начинать проверку кода потока на наличие ошибок.</target>
        </trans-unit>
        <trans-unit id="6e373532fbaa792fe51ef4bf5789af3104a5d987" translate="yes" xml:space="preserve">
          <source>Say you have the following directory structure, with your &lt;code&gt;.flowconfig&lt;/code&gt; in &lt;code&gt;mydir&lt;/code&gt;:</source>
          <target state="translated">Скажем, у вас есть следующая структура каталогов с вашим &lt;code&gt;.flowconfig&lt;/code&gt; в &lt;code&gt;mydir&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3bfb431a612a3027c31b75652ccf295595fa76b2" translate="yes" xml:space="preserve">
          <source>Sealed objects</source>
          <target state="translated">Герметичные предметы</target>
        </trans-unit>
        <trans-unit id="554e5e25f0d86fc7d48da5b753f3b192e04d6a22" translate="yes" xml:space="preserve">
          <source>Second example:</source>
          <target state="translated">Второй пример:</target>
        </trans-unit>
        <trans-unit id="863a42ae0f0b0630cfee6b7740c09c1edf767d9c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../utilities#toc-class&quot;&gt;here&lt;/a&gt; for details on &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt;, which allows you to refer to the type of the class in an annotation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5437018c74686a42995bf3c86f110c73dfb010d3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/facebook/flow/issues/5725&quot;&gt;this GitHub issue for the original motivation&lt;/a&gt;</source>
          <target state="translated">См. &lt;a href=&quot;https://github.com/facebook/flow/issues/5725&quot;&gt;Эту проблему GitHub, чтобы&lt;/a&gt; узнать исходную мотивацию</target>
        </trans-unit>
        <trans-unit id="e6fc3fca1eed93ff9d9a6c2799720ebdd64e3698" translate="yes" xml:space="preserve">
          <source>See also &lt;code&gt;[untyped]&lt;/code&gt;(untyped) for not typechecking files, and instead using &lt;code&gt;any&lt;/code&gt; for all contents.</source>
          <target state="translated">См. Также &lt;code&gt;[untyped]&lt;/code&gt; (нетипизированный) для файлов, не проверяющих типы, и вместо этого использования &lt;code&gt;any&lt;/code&gt; для всего содержимого.</target>
        </trans-unit>
        <trans-unit id="d10cc1add2564282fb8d240521737d52d850d2d5" translate="yes" xml:space="preserve">
          <source>See how we added &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;SomeOtherComponent&amp;gt;&lt;/code&gt; as children to &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt;? This is not allowed and &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; will throw an error. How do we make sure Flow does not allow this pattern?</source>
          <target state="translated">Видите, как мы добавили &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;SomeOtherComponent&amp;gt;&lt;/code&gt; в качестве дочерних к &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; ? Это недопустимо, и &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; выдаст ошибку. Как убедиться, что Flow не допускает такой шаблон?</target>
        </trans-unit>
        <trans-unit id="f741f4c166b4ccd4d41f13a13dece778f73df85a" translate="yes" xml:space="preserve">
          <source>Select &amp;lsquo;Flow for Sublime Text 2 and 3&amp;rsquo; to install</source>
          <target state="translated">Выберите &amp;laquo;Flow for Sublime Text 2 and 3&amp;raquo; для установки.</target>
        </trans-unit>
        <trans-unit id="e6b4c56f97df36a6ecd6ed02f0d6868208b5ab27" translate="yes" xml:space="preserve">
          <source>Select Package Control: Install Package</source>
          <target state="translated">Выберите Контроль пакетов:Установить пакет</target>
        </trans-unit>
        <trans-unit id="8d4e3440a48420d6cf0f3379e89fee66456a0ae3" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;automatic&lt;/code&gt; if you are using React&amp;rsquo;s automatic runtime in &lt;code&gt;@babel/plugin-transform-react-jsx&lt;/code&gt;. Otherwise, use &lt;code&gt;classic&lt;/code&gt;. &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx&quot;&gt;See the babel documentation&lt;/a&gt; for details about the transform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a51c55e03c6fe62b671bf2a091c73c068704caf" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;enable&lt;/code&gt; to indicate that Flow should support the &lt;code&gt;export * as&lt;/code&gt; syntax from &lt;a href=&quot;https://github.com/leebyron/ecmascript-more-export-from&quot;&gt;leebyron&amp;rsquo;s proposal&lt;/a&gt;.</source>
          <target state="translated">Установите это значение, &lt;code&gt;enable&lt;/code&gt; указать, что Flow должен поддерживать &lt;code&gt;export * as&lt;/code&gt; синтаксис из &lt;a href=&quot;https://github.com/leebyron/ecmascript-more-export-from&quot;&gt;предложения leebyron&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2f2f8212166435e1e26351a8d0075e389cfc197" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;enable&lt;/code&gt; to indicate that Flow should support the use of &lt;a href=&quot;https://github.com/tc39/proposal-nullish-coalescing&quot;&gt;nullish coalescing&lt;/a&gt; per the pending spec.</source>
          <target state="translated">Установите для этого параметра значение &lt;code&gt;enable&lt;/code&gt; , чтобы указать, что Flow должен поддерживать использование &lt;a href=&quot;https://github.com/tc39/proposal-nullish-coalescing&quot;&gt;нулевого объединения в&lt;/a&gt; соответствии с ожидающей спецификацией.</target>
        </trans-unit>
        <trans-unit id="5ffd0d476596e4beacfa43c710cc9eca05a02fef" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;enable&lt;/code&gt; to indicate that Flow should support the use of &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining&quot;&gt;optional chaining&lt;/a&gt; per the pending spec.</source>
          <target state="translated">Установите это значение, &lt;code&gt;enable&lt;/code&gt; указать, что Flow должен поддерживать использование &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining&quot;&gt;необязательной цепочки в&lt;/a&gt; соответствии с ожидаемой спецификацией.</target>
        </trans-unit>
        <trans-unit id="a791224e1e0c6173296867136f2701fa594c4db9" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should ignore decorators.</source>
          <target state="translated">Установите значение &lt;code&gt;ignore&lt;/code&gt; , чтобы указать, что Flow должен игнорировать декораторы.</target>
        </trans-unit>
        <trans-unit id="7252ab4a3a45b3b2cf1e24f49aebbbc8df2bea70" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; and Flow will no longer complain when you use &lt;code&gt;require()&lt;/code&gt; with something other than a string literal.</source>
          <target state="translated">Установите значение &lt;code&gt;true&lt;/code&gt; , и Flow больше не будет жаловаться, если вы используете &lt;code&gt;require()&lt;/code&gt; с чем-то, кроме строкового литерала.</target>
        </trans-unit>
        <trans-unit id="17b19723fab321f07b8d03e9886bc4fd290afff7" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; if you use a transpiler that adds &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; to the top of every module.</source>
          <target state="translated">Установите значение &lt;code&gt;true&lt;/code&gt; , если вы используете транспилятор, который добавляет &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; вверху каждого модуля.</target>
        </trans-unit>
        <trans-unit id="8f7810533f5b1afdbd99345ceeeb8bb80fe383b5" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to add emoji to the status messages that Flow outputs when it&amp;rsquo;s busy checking your project.</source>
          <target state="translated">Установите значение &lt;code&gt;true&lt;/code&gt; , чтобы добавлять смайлики в сообщения о состоянии, которые Flow выводит, когда проверяет ваш проект.</target>
        </trans-unit>
        <trans-unit id="0a9e20b6f9ef8f6259569858fa3254651f50988f" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to check all files, not just those with &lt;code&gt;@flow&lt;/code&gt;.</source>
          <target state="translated">Установите значение &lt;code&gt;true&lt;/code&gt; , чтобы проверять все файлы, а не только файлы с &lt;code&gt;@flow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2763696664697d56a9bd55ceed56c975dbfc607" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to check that array spread syntax is only used with arrays, not arbitrary iterables (such as &lt;code&gt;Map&lt;/code&gt; or &lt;code&gt;Set&lt;/code&gt;). This is useful if you transform your code with Babel in &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-spread#loose&quot;&gt;loose mode&lt;/a&gt; which makes this non-spec-compliant assumption at runtime.</source>
          <target state="translated">Установите для этого параметра значение &lt;code&gt;true&lt;/code&gt; , чтобы проверить, что синтаксис расширения массива используется только с массивами, а не с произвольными итерациями (такими как &lt;code&gt;Map&lt;/code&gt; или &lt;code&gt;Set&lt;/code&gt; ). Это полезно, если вы трансформируете свой код с помощью Babel в &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-spread#loose&quot;&gt;свободном режиме,&lt;/a&gt; что делает это предположение несовместимым со спецификациями во время выполнения.</target>
        </trans-unit>
        <trans-unit id="632e3852195a2720cf86c3695ec9f34205f83f66" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to have Flow treat underscore-prefixed class properties and methods as private. This should be used in conjunction with &lt;a href=&quot;https://github.com/facebook/jstransform/blob/master/visitors/es6-class-visitors.js&quot;&gt;&lt;code&gt;jstransform&lt;/code&gt;&amp;rsquo;s ES6 class transform&lt;/a&gt;, which enforces the same privacy at runtime.</source>
          <target state="translated">Установите значение &lt;code&gt;true&lt;/code&gt; , чтобы Flow обрабатывал свойства и методы класса с префиксом подчеркивания как частные. Это должно быть использовано в сочетании с &lt;a href=&quot;https://github.com/facebook/jstransform/blob/master/visitors/es6-class-visitors.js&quot;&gt; &lt;code&gt;jstransform&lt;/code&gt; &amp;laquo;s класса ES6 преобразования&lt;/a&gt; , который вводит в ту же частную жизнь во время выполнения.</target>
        </trans-unit>
        <trans-unit id="c35c47e5290b31d5376f35f006e7cd6e182798e4" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to indicate that Flow should interpret object types as exact by default. When this flag is &lt;code&gt;false&lt;/code&gt;, Flow has the following behavior:</source>
          <target state="translated">Установите значение &lt;code&gt;true&lt;/code&gt; , чтобы указать, что Flow по умолчанию должен интерпретировать типы объектов как точные. Когда этот флаг установлен в &lt;code&gt;false&lt;/code&gt; , Flow ведет себя следующим образом:</target>
        </trans-unit>
        <trans-unit id="0b6026d788e6990fc2b88f5d97a8a7e72d548d84" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;warn&lt;/code&gt; to indicate that Flow should give a warning on use of instance &lt;a href=&quot;https://github.com/tc39/proposal-class-public-fields&quot;&gt;class fields&lt;/a&gt; per the pending spec.</source>
          <target state="translated">Установите это &lt;code&gt;warn&lt;/code&gt; , чтобы указать , что поток должен дать предупреждение об использовании экземпляра &lt;a href=&quot;https://github.com/tc39/proposal-class-public-fields&quot;&gt;класса поле&lt;/a&gt; в надвигающейся спецификации.</target>
        </trans-unit>
        <trans-unit id="5a95e4b769085b845d2cd025dba547c259b83a10" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;warn&lt;/code&gt; to indicate that Flow should give a warning on use of static &lt;a href=&quot;https://github.com/tc39/proposal-class-public-fields&quot;&gt;class fields&lt;/a&gt; per the pending spec.</source>
          <target state="translated">Установите это &lt;code&gt;warn&lt;/code&gt; , чтобы указать , что поток должен дать предупреждение об использовании статических &lt;a href=&quot;https://github.com/tc39/proposal-class-public-fields&quot;&gt;полей класса&lt;/a&gt; в надвигающемся спецификации.</target>
        </trans-unit>
        <trans-unit id="3723576f1e23f9a6be80dfc2da353444ecba4fa5" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;lazy_mode&lt;/code&gt; in the &lt;code&gt;.flowconfig&lt;/code&gt; will cause new Flow servers for that root to use that lazy mode (or no lazy mode if set to &lt;code&gt;none&lt;/code&gt;). This option can be overridden from the CLI using the &lt;code&gt;--lazy-mode&lt;/code&gt; flag.</source>
          <target state="translated">Установка &lt;code&gt;lazy_mode&lt;/code&gt; в &lt;code&gt;.flowconfig&lt;/code&gt; заставит новые серверы Flow для этого корня использовать этот ленивый режим (или не использовать ленивый режим, если установлено значение &lt;code&gt;none&lt;/code&gt; ). Этот параметр можно переопределить из интерфейса командной строки с помощью &lt;code&gt;--lazy-mode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8742e5ede9ca0ab99281256cb0a8da2b2abf5c7" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;sketchy-null&lt;/code&gt; sets the level for all sketchy null checks, but there are more granular rules for particular types. These are:</source>
          <target state="translated">Установка &lt;code&gt;sketchy-null&lt;/code&gt; устанавливает уровень для всех отрывочных проверок на null, но для определенных типов существуют более детальные правила. Эти:</target>
        </trans-unit>
        <trans-unit id="4dbac04babde4f94fd1324574fc30f6647291c38" translate="yes" xml:space="preserve">
          <source>Setting this option to X means the table will support up to 2^X elements, which is 16*2^X bytes.</source>
          <target state="translated">Установка этого параметра в X означает,что таблица будет поддерживать до 2^X элементов,что составляет 16*2^X байт.</target>
        </trans-unit>
        <trans-unit id="6f8b6166467119123c34cb8d2a8307f8f72ae96e" translate="yes" xml:space="preserve">
          <source>Setting this to 1 will cause Flow to output some stats about the data that is serialized into and deserialized out of shared memory.</source>
          <target state="translated">Установка этого параметра в 1 приведет к тому,что Flow будет выдавать некоторую статистику о данных,которые сериализуются в общую память и десериализуются из нее.</target>
        </trans-unit>
        <trans-unit id="3907024420fe6565a297982966b2459dd6dc6639" translate="yes" xml:space="preserve">
          <source>Setting this to &lt;code&gt;true&lt;/code&gt; makes Flow commands include warnings in the error output. Warnings are hidden by default in the CLI to avoid console spew. (An IDE is a much better interface to show warnings.)</source>
          <target state="translated">Установка этого значения в &lt;code&gt;true&lt;/code&gt; заставляет команды Flow включать предупреждения в вывод ошибок. Предупреждения по умолчанию скрыты в интерфейсе командной строки, чтобы избежать выброса консоли. (IDE - гораздо лучший интерфейс для отображения предупреждений.)</target>
        </trans-unit>
        <trans-unit id="a78591e430fc75d428e63794ccb099ae8c20961b" translate="yes" xml:space="preserve">
          <source>Setting this to &lt;code&gt;true&lt;/code&gt; makes Flow treat all function parameters as const bindings. Reassigning a param is an error which lets Flow be less conservative with refinements.</source>
          <target state="translated">Установка этого значения в &lt;code&gt;true&lt;/code&gt; заставляет Flow обрабатывать все параметры функции как привязки const. Переназначение параметра - это ошибка, которая позволяет Flow быть менее консервативным в отношении уточнений.</target>
        </trans-unit>
        <trans-unit id="c2da3d4ed1af623cc4e8b8d52d8edb981c85d346" translate="yes" xml:space="preserve">
          <source>Setting up &amp;ldquo;boundaries&amp;rdquo; with your types means you can tell Flow your intent on top of the inference it already does.</source>
          <target state="translated">Установка &amp;laquo;границ&amp;raquo; с вашими типами означает, что вы можете сообщить Flow о своем намерении поверх уже сделанного вывода.</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="7133d91a35c40bcb71979c3896fc1deb038a8a20" translate="yes" xml:space="preserve">
          <source>Setup Flow with React</source>
          <target state="translated">Поток установки с реакцией</target>
        </trans-unit>
        <trans-unit id="7330bdb6aab9d47b6f4302ca23a0b1d1a997ea7d" translate="yes" xml:space="preserve">
          <source>Severity Levels and Meanings</source>
          <target state="translated">Уровни и значения тяжести</target>
        </trans-unit>
        <trans-unit id="9ef912b88879662392f8c53fad059d3c74586282" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#toc-react-componenttype&quot;&gt;&lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt;&lt;/a&gt; except it also includes JSX intrinsics (strings).</source>
          <target state="translated">Подобно &lt;a href=&quot;#toc-react-componenttype&quot;&gt; &lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; &lt;/a&gt; за исключением того, что он также включает встроенные функции JSX (строки).</target>
        </trans-unit>
        <trans-unit id="ad9df7675219090b45a68675090f8c88c2996d47" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;../utilities#toc-readonly&quot;&gt;&lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, it is the supertype of all arrays and all tuples and represents a read-only view of an array. It does not contain any methods that will allow an object of this type to be mutated (no &lt;code&gt;push()&lt;/code&gt;, &lt;code&gt;pop()&lt;/code&gt;, etc.).</source>
          <target state="translated">Подобно &lt;a href=&quot;../utilities#toc-readonly&quot;&gt; &lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , это супертип всех массивов и всех кортежей и представляет собой доступное только для чтения представление массива. Он не содержит никаких методов, которые позволили бы изменять объект этого типа (без &lt;code&gt;push()&lt;/code&gt; , &lt;code&gt;pop()&lt;/code&gt; и т. Д.).</target>
        </trans-unit>
        <trans-unit id="7e25832c7fbfc04c711346a40af98680a99ba4e4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;../variables#toc-reassigning-variables&quot;&gt;&lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; variables&lt;/a&gt; if you reassign a property of an unsealed object, by default Flow will give it the type of all possible assignments.</source>
          <target state="translated">Подобно &lt;a href=&quot;../variables#toc-reassigning-variables&quot;&gt;переменным &lt;/a&gt; &lt;code&gt;var&lt;/code&gt; и &lt;code&gt;let&lt;/code&gt; , если вы переназначаете свойство незапечатанного объекта, по умолчанию Flow предоставит ему тип всех возможных назначений.</target>
        </trans-unit>
        <trans-unit id="8ccc6ec56ed0f7579fe7c1219285baf1e414f25d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;const&lt;/code&gt;, Flow can either infer the type from the value you are assigning to it or you can provide it with a type:</source>
          <target state="translated">Подобно &lt;code&gt;const&lt;/code&gt; , Flow может либо определить тип из присвоенного ему значения, либо вы можете предоставить ему тип:</target>
        </trans-unit>
        <trans-unit id="31cdc6274e2048217641f19c7436522e7c83902e" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;mixed&lt;/code&gt;, generics have an &amp;ldquo;unknown&amp;rdquo; type. You&amp;rsquo;re not allowed to use a generic as if it were a specific type.</source>
          <target state="translated">Подобно &lt;code&gt;mixed&lt;/code&gt; типу дженерики имеют &amp;laquo;неизвестный&amp;raquo; тип. Вам не разрешено использовать общий тип, как если бы он был определенного типа.</target>
        </trans-unit>
        <trans-unit id="6f53a1bfd2499be63c34f7067d2986e44abdec95" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; can be re-assigned, there&amp;rsquo;s a few more rules you&amp;rsquo;ll need to know about.</source>
          <target state="translated">Поскольку &lt;code&gt;var&lt;/code&gt; и &lt;code&gt;let&lt;/code&gt; можно переназначить, вам нужно знать еще несколько правил.</target>
        </trans-unit>
        <trans-unit id="339082925233909f355d06179fa3b6b26ccf7865" translate="yes" xml:space="preserve">
          <source>Since Flow does not know the length of an array, an &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; type cannot be passed into a tuple.</source>
          <target state="translated">Поскольку Flow не знает длину массива, тип &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; нельзя передать в кортеж.</target>
        </trans-unit>
        <trans-unit id="decf7e18c6fe06fc86a8a5bc89a669829d507c85" translate="yes" xml:space="preserve">
          <source>Since a &lt;code&gt;const&lt;/code&gt; variable cannot be re-assigned at a later time it is fairly simple.</source>
          <target state="translated">Поскольку переменная &lt;code&gt;const&lt;/code&gt; не может быть повторно назначена позже, это довольно просто.</target>
        </trans-unit>
        <trans-unit id="8c614b00ece097ea225988eb96c38c1dc27bdcf2" translate="yes" xml:space="preserve">
          <source>Since the parameter &lt;code&gt;arr&lt;/code&gt; of the &lt;code&gt;someOperation&lt;/code&gt; function is typed as a mutable &lt;code&gt;Array&lt;/code&gt;, pushing a string into it would be possible inside that scope, which would then break the type contract of the outside &lt;code&gt;array&lt;/code&gt; variable. By annotating the parameter as &lt;code&gt;$ReadOnlyArray&lt;/code&gt; instead in this case, Flow can be sure this won&amp;rsquo;t happen and no errors will occur:</source>
          <target state="translated">Так как параметр &lt;code&gt;arr&lt;/code&gt; из &lt;code&gt;someOperation&lt;/code&gt; функции набираются как изменяемый &lt;code&gt;Array&lt;/code&gt; , толкая строку в это было бы возможно в том , что сфера, которая затем разорвать контракт типа из внешнего &lt;code&gt;array&lt;/code&gt; переменного. В этом случае, аннотируя параметр как &lt;code&gt;$ReadOnlyArray&lt;/code&gt; , Flow может быть уверен, что этого не произойдет и не возникнет никаких ошибок:</target>
        </trans-unit>
        <trans-unit id="a1785a5e0b243285a1963526da42f273c5dc42f7" translate="yes" xml:space="preserve">
          <source>So a single array child is left alone, but what happens if we have multiple children that are arrays?</source>
          <target state="translated">Значит,один ребенок массива остается один,но что будет,если у нас будет несколько детей,которые являются массивами?</target>
        </trans-unit>
        <trans-unit id="a70bd7a3ca7dbd388181ff69fc1a9d9059244ca3" translate="yes" xml:space="preserve">
          <source>So far, we support the following ways to specify supported versions</source>
          <target state="translated">На данный момент мы поддерживаем следующие способы указания поддерживаемых версий</target>
        </trans-unit>
        <trans-unit id="64c91e3d58f11315a8f98d01485d70281a6c3678" translate="yes" xml:space="preserve">
          <source>So if Flow sees this in the &lt;code&gt;.flowconfig&lt;/code&gt;:</source>
          <target state="translated">Итак, если Flow видит это в &lt;code&gt;.flowconfig&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9eb921ba09ace5711e414821fe52adee56f0c3ff" translate="yes" xml:space="preserve">
          <source>So if I write a function that expects the numbers 1 through 5, any subtype of that set will be acceptable.</source>
          <target state="translated">Поэтому,если я напишу функцию,которая ожидает числа с 1 по 5,то любой подтип этого множества будет приемлем.</target>
        </trans-unit>
        <trans-unit id="0e8b161db695089b318d824534a1f60ea4c81045" translate="yes" xml:space="preserve">
          <source>So if you have the following in your &lt;code&gt;.flowconfig&lt;/code&gt;:</source>
          <target state="translated">Итак, если в вашем &lt;code&gt;.flowconfig&lt;/code&gt; есть следующее :</target>
        </trans-unit>
        <trans-unit id="85f50aa3f8aa1b205c54f2530dfd25375a26cc15" translate="yes" xml:space="preserve">
          <source>So in the following example, &lt;code&gt;obj2&lt;/code&gt; is a &lt;em&gt;subtype&lt;/em&gt; of &lt;code&gt;obj1&lt;/code&gt;.</source>
          <target state="translated">Таким образом , в следующем примере, &lt;code&gt;obj2&lt;/code&gt; является &lt;em&gt;подтипом&lt;/em&gt; из &lt;code&gt;obj1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd21dd92e8bb38520c7aed585ce5c138a49e1e9e" translate="yes" xml:space="preserve">
          <source>So, for example, if you want to know more about how the autocomplete works, you can use this command:</source>
          <target state="translated">Так,например,если вы хотите узнать больше о том,как работает автозаполнение,вы можете воспользоваться этой командой:</target>
        </trans-unit>
        <trans-unit id="6a5040bb6c58acac2d87c681ffa0099ee5ad8294" translate="yes" xml:space="preserve">
          <source>Sometimes Flow is able to figure out (with certainty) the type of a property after reassignment. In that case, Flow will give it the known type.</source>
          <target state="translated">Иногда Flow может выяснить (с уверенностью)тип недвижимости после переназначения.В этом случае Flow присваивает ему известный тип.</target>
        </trans-unit>
        <trans-unit id="8cbd2e30f0fd2935872139edbe248c42b74f633b" translate="yes" xml:space="preserve">
          <source>Sometimes Flow is able to figure out (with certainty) the type of a variable after re-assignment. In that case, Flow will give it the known type.</source>
          <target state="translated">Иногда Flow способен вычислить (с уверенностью)тип переменной после переприсвоения.В этом случае Flow присваивает ей известный тип.</target>
        </trans-unit>
        <trans-unit id="190aedcaebf30683452cc18021384bd29eb893ec" translate="yes" xml:space="preserve">
          <source>Sometimes Flow&amp;rsquo;s inference will create types that are more permissive than you want them to be.</source>
          <target state="translated">Иногда логический вывод Flow создает типы, которые более снисходительны, чем вы хотите.</target>
        </trans-unit>
        <trans-unit id="bf2bc69b7d682ca6d088a661a2cccdb41226e95b" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to assert a type without using something like a function or a variable to do so. For this Flow supports an inline type cast expression syntax which can be used in a number of different ways.</source>
          <target state="translated">Иногда полезно утвердить тип,не используя для этого что-то вроде функции или переменной.Для этого Flow поддерживает синтаксис выражения,приводимого к строковому типу,который может быть использован несколькими различными способами.</target>
        </trans-unit>
        <trans-unit id="05acde073f433e3ebdb05840c280af6194f4f161" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to create a type which is &lt;strong&gt;&lt;em&gt;all of&lt;/em&gt;&lt;/strong&gt; a set of other types. For example, you might want to write a function which accepts an object which is the combination of other object types. For this, Flow supports &lt;strong&gt;intersection types&lt;/strong&gt;.</source>
          <target state="translated">Иногда бывает полезно создать тип, &lt;strong&gt;&lt;em&gt;состоящий из&lt;/em&gt;&lt;/strong&gt; набора других типов. Например, вы можете захотеть написать функцию, которая принимает объект, представляющий собой комбинацию других типов объектов. Для этого Flow поддерживает &lt;strong&gt;типы пересечений&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="508d0f1b6949c54ce48ed8515843765f74b1ff2c" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to disable this behavior and only allow a specific set of properties. For this, Flow supports &amp;ldquo;exact&amp;rdquo; object types.</source>
          <target state="translated">Иногда полезно отключить это поведение и разрешить только определенный набор свойств. Для этого Flow поддерживает &amp;laquo;точные&amp;raquo; типы объектов.</target>
        </trans-unit>
        <trans-unit id="7e197db0c5e7c34ea4bc888687f7a0d82f7f2217" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to make declarations inline, as part of the source of an implementation file.</source>
          <target state="translated">Иногда бывает полезно сделать объявления встроенными,как часть источника файла реализации.</target>
        </trans-unit>
        <trans-unit id="4b7f2e42ec427dfe19e7546bbfa4cb1df144aec0" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to write types that accept arbitrary functions, for those you should write &lt;code&gt;() =&amp;gt; mixed&lt;/code&gt; like this:</source>
          <target state="translated">Иногда бывает полезно написать типы, которые принимают произвольные функции, для которых вы должны написать &lt;code&gt;() =&amp;gt; mixed&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="0d699df94c70d270a74922c6dd7a75522ca1022c" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to write types that accept arbitrary objects, for those you should write &lt;code&gt;{}&lt;/code&gt; like this:</source>
          <target state="translated">Иногда бывает полезно написать типы, которые принимают произвольные объекты, для которых вы должны написать &lt;code&gt;{}&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="48c4be69fd7d7e116bfe9fff8287e72150b14b65" translate="yes" xml:space="preserve">
          <source>Sometimes it&amp;rsquo;s useful to create a type which is &lt;strong&gt;&lt;em&gt;one of&lt;/em&gt;&lt;/strong&gt; a set of other types. For example, you might want to write a function which accepts a set of primitive value types. For this Flow supports &lt;strong&gt;union types&lt;/strong&gt;.</source>
          <target state="translated">Иногда бывает полезно создать тип, который является &lt;strong&gt;&lt;em&gt;одним из&lt;/em&gt;&lt;/strong&gt; набора других типов. Например, вы можете захотеть написать функцию, которая принимает набор примитивных типов значений. Для этого Flow поддерживает &lt;strong&gt;типы объединения&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="56e08cb76776b6d22c74c00289b74deb8fcafaba" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to ignore all files inside a directory with the exception of a few. An optional prefix &amp;ldquo;!&amp;rdquo; which negates the pattern may help. With this, any matching file excluded by a previous pattern will become included again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="079287524f7de17d8166e352d620ee09cbcee756" translate="yes" xml:space="preserve">
          <source>Sometimes you only want a specific component as the children to your React component. This often happens when you are building a table component which needs specific column children components, or a tab bar which needs specific configuration for each tab. One such tab bar component that uses this pattern is React Native&amp;rsquo;s &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">Иногда вам нужен только определенный компонент в качестве дочерних для вашего компонента React. Это часто происходит, когда вы создаете компонент таблицы, которому требуются определенные дочерние компоненты столбца, или панель вкладок, которая требует определенной конфигурации для каждой вкладки. Одним из таких компонентов панели вкладок, который использует этот шаблон, является компонент &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; React Native .</target>
        </trans-unit>
        <trans-unit id="0ca3345128fc09227a3fc76aff4497f80cecc7db" translate="yes" xml:space="preserve">
          <source>Sometimes you want to enforce that your component will &lt;em&gt;only&lt;/em&gt; receive a single child. You could use &lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children.only&quot;&gt;&lt;code&gt;React.Children.only()&lt;/code&gt; function&lt;/a&gt; to enforce this constraint, but you could also enforce this in Flow. To do this you would not wrap the type for your children in &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. Like so:</source>
          <target state="translated">Иногда вы хотите, чтобы ваш компонент получал &lt;em&gt;только&lt;/em&gt; одного дочернего элемента . Вы можете использовать &lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children.only&quot;&gt; &lt;code&gt;React.Children.only()&lt;/code&gt; функцию&lt;/a&gt; для обеспечения соблюдения этого ограничения, но вы можете также применять это в потоке. Для этого вы не должны оборачивать тип для своих детей в &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; . Вот так:</target>
        </trans-unit>
        <trans-unit id="9c3a1440695c1cfe2882e899cdcec139639bb34e" translate="yes" xml:space="preserve">
          <source>Sometimes you want to enforce that your component will &lt;em&gt;only&lt;/em&gt; receive a single child. You could use &lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children.only&quot;&gt;&lt;code&gt;React.Children.only()&lt;/code&gt; function&lt;/a&gt; to enforce this constraint, but you could also enforce this in Flow. To do this, instead of wrapping the type for your children in &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, specify a single element argument, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0204e6779dafad940b69a188f3ba177a640b8f57" translate="yes" xml:space="preserve">
          <source>Sometimes you will want to move the condition from an &lt;code&gt;if&lt;/code&gt; statement into a function:</source>
          <target state="translated">Иногда вам может понадобиться переместить условие из оператора &lt;code&gt;if&lt;/code&gt; в функцию:</target>
        </trans-unit>
        <trans-unit id="e54a11047f43ee69df389e7749159027d890696d" translate="yes" xml:space="preserve">
          <source>Soundness and Completeness</source>
          <target state="translated">Звучность и полнота</target>
        </trans-unit>
        <trans-unit id="746df4e9e7a562d767f5e24a05664f4a720c7f81" translate="yes" xml:space="preserve">
          <source>Soundness is fine as long as Flow isn&amp;rsquo;t being too noisy and preventing you from being productive. Sometimes when soundness would get in your way too much, Flow will favor completeness instead. There&amp;rsquo;s only a handful of cases where Flow does this.</source>
          <target state="translated">Хорошая надежность, если Flow не слишком шумит и не мешает вам работать. Иногда, когда разумность слишком сильно мешает вам, Flow будет отдавать предпочтение полноте. Лишь в нескольких случаях это делает Flow.</target>
        </trans-unit>
        <trans-unit id="0490059ec84f1bbf6b567a4e9c26b3a680460a91" translate="yes" xml:space="preserve">
          <source>Specify a file extension to match, and a replacement module name, separated by a &lt;code&gt;-&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Укажите соответствующее расширение файла и имя заменяющего модуля, разделенные знаком &lt;code&gt;-&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c23f789b3f6c7eff8cfdc73ee793e9e6cd434ab2" translate="yes" xml:space="preserve">
          <source>Specify a regular expression to match against module names, and a replacement pattern, separated by a &lt;code&gt;-&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Задайте регулярное выражение для сопоставления с именами модулей и шаблон замены, разделенные знаком &lt;code&gt;-&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d2cb022bc3d26bd1407c4aa787d5e46e1ad4c3b" translate="yes" xml:space="preserve">
          <source>Speed</source>
          <target state="translated">Speed</target>
        </trans-unit>
        <trans-unit id="3b2886d5473db8f2728b89b52d94f9b866760285" translate="yes" xml:space="preserve">
          <source>Start the &lt;a href=&quot;#toc-run-the-flow-background-process&quot;&gt;Flow background process&lt;/a&gt; with &lt;code&gt;flow&lt;/code&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;#toc-run-the-flow-background-process&quot;&gt;фоновый процесс Flow&lt;/a&gt; с &lt;code&gt;flow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33040dda5793f74572e67f14abdfb073ecb04f28" translate="yes" xml:space="preserve">
          <source>Starting with Flow v0.23.0, you may use the &lt;code&gt;&amp;lt;PROJECT_ROOT&amp;gt;&lt;/code&gt; placeholder in your regular expressions. At runtime, Flow will treat the placeholder as if it were the absolute path to the project&amp;rsquo;s root directory. This is useful for writing regular expressions that are relative rather than absolute.</source>
          <target state="translated">Начиная с Flow v0.23.0, вы можете использовать заполнитель &lt;code&gt;&amp;lt;PROJECT_ROOT&amp;gt;&lt;/code&gt; в своих регулярных выражениях. Во время выполнения Flow будет рассматривать заполнитель, как если бы это был абсолютный путь к корневому каталогу проекта. Это полезно для написания относительных, а не абсолютных регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="62b1fce124c3fa807ff7f42885010e1fc39fe39d" translate="yes" xml:space="preserve">
          <source>Stateless Functional Components</source>
          <target state="translated">Функциональные компоненты без гражданства</target>
        </trans-unit>
        <trans-unit id="2f0b1209b659172e1b117e95bf918d52ef746c97" translate="yes" xml:space="preserve">
          <source>Statements manipulating &lt;code&gt;module.exports&lt;/code&gt; and the &lt;code&gt;exports&lt;/code&gt; alias may only appear as top-level statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab6b0ce50387fe5c38a665805e317164318c6cd" translate="yes" xml:space="preserve">
          <source>Strict Local</source>
          <target state="translated">Строго локальный</target>
        </trans-unit>
        <trans-unit id="984e1a2ea44698c9bc621d3cc2a46a2ebbfcffdb" translate="yes" xml:space="preserve">
          <source>Strictly enforced tuple length (arity)</source>
          <target state="translated">Строго регламентированная длина кортежа (живота)</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="b5c84f808b85754e46cef96360cc97ceca30a211" translate="yes" xml:space="preserve">
          <source>Strings are &lt;code&gt;&quot;foo&quot;&lt;/code&gt; values in JavaScript. The &lt;code&gt;string&lt;/code&gt; type in Flow accepts these values.</source>
          <target state="translated">Строки - это значения &lt;code&gt;&quot;foo&quot;&lt;/code&gt; в JavaScript. Тип &lt;code&gt;string&lt;/code&gt; в Flow принимает эти значения.</target>
        </trans-unit>
        <trans-unit id="371de9693f4209b3d6baabc8cf5aa9bd9123f714" translate="yes" xml:space="preserve">
          <source>Strings: like &lt;code&gt;&quot;foo&quot;&lt;/code&gt; or &lt;code&gt;&quot;bar&quot;&lt;/code&gt;</source>
          <target state="translated">Строки: например, &lt;code&gt;&quot;foo&quot;&lt;/code&gt; или &lt;code&gt;&quot;bar&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fad0aefa729b2e3f757e7d3a4090cd9f7990d889" translate="yes" xml:space="preserve">
          <source>Structural typing</source>
          <target state="translated">Структурная типизация</target>
        </trans-unit>
        <trans-unit id="9ce6ba148fe8d9ab4a1efa44f043d11727e7f6ee" translate="yes" xml:space="preserve">
          <source>Sublime Text</source>
          <target state="translated">Великолепный Текст</target>
        </trans-unit>
        <trans-unit id="d14ac23dd85e9a8386862e11638c030009ce4084" translate="yes" xml:space="preserve">
          <source>SublimeLinter-flow</source>
          <target state="translated">SublimeLinter-flow</target>
        </trans-unit>
        <trans-unit id="3f018ae5c81afd7ff03157c258e75546aee33dc2" translate="yes" xml:space="preserve">
          <source>Subsets &amp;amp; Subtypes</source>
          <target state="translated">Подмножества и подтипы</target>
        </trans-unit>
        <trans-unit id="6cdd77a39c406add3dd649d12b90f08405e31a63" translate="yes" xml:space="preserve">
          <source>Subtypes of complex types</source>
          <target state="translated">Подтипы сложных типов</target>
        </trans-unit>
        <trans-unit id="9d06116efdf07868027a1561d8d0339ecc6e6c45" translate="yes" xml:space="preserve">
          <source>Subtypes of functions</source>
          <target state="translated">Подтипы функций</target>
        </trans-unit>
        <trans-unit id="476bb4d588f74c233bb6c1ee03fd986be62e7cea" translate="yes" xml:space="preserve">
          <source>Subtypes of objects</source>
          <target state="translated">Подтипы объектов</target>
        </trans-unit>
        <trans-unit id="0be5fa8c6c74f697319a9589425f3a2612939e3d" translate="yes" xml:space="preserve">
          <source>Subtyping Constraints</source>
          <target state="translated">Подтипирование Ограничения</target>
        </trans-unit>
        <trans-unit id="f17dd2152e8dc1f949523edeb4f3e8b48630834f" translate="yes" xml:space="preserve">
          <source>Subtyping rules for functions are more complicated. So far, we&amp;rsquo;ve seen that &lt;code&gt;A&lt;/code&gt; is a subtype of &lt;code&gt;B&lt;/code&gt; if &lt;code&gt;B&lt;/code&gt; contains all possible values for &lt;code&gt;A&lt;/code&gt;. For functions, it&amp;rsquo;s not clear how this relationship would apply. To simplify things, you can think of a function type &lt;code&gt;A&lt;/code&gt; as being a subtype of a function type &lt;code&gt;B&lt;/code&gt; if functions of type &lt;code&gt;A&lt;/code&gt; can be used wherever a function of type &lt;code&gt;B&lt;/code&gt; is expected.</source>
          <target state="translated">Правила выделения подтипов для функций более сложные. До сих пор мы видели , что является подтипом &lt;code&gt;B&lt;/code&gt; , если &lt;code&gt;B&lt;/code&gt; содержит все возможные значения &lt;code&gt;A&lt;/code&gt; . Для функций неясно, как это отношение будет применяться. Чтобы упростить ситуацию, вы можете рассматривать функцию типа &lt;code&gt;A&lt;/code&gt; как подтип функции типа &lt;code&gt;B&lt;/code&gt; , если функции типа &lt;code&gt;A&lt;/code&gt; могут использоваться везде, где ожидается функция типа &lt;code&gt;B&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78102c720eccd1810b8e560681ce6685d79fff31" translate="yes" xml:space="preserve">
          <source>Suports vim 8 and neovim</source>
          <target state="translated">Супорты vim 8 и неовим</target>
        </trans-unit>
        <trans-unit id="3ea46343abafb30794aea626700e565b309f371e" translate="yes" xml:space="preserve">
          <source>Supplying Type Arguments to Callables</source>
          <target state="translated">Поставка типовых аргументов в Callables</target>
        </trans-unit>
        <trans-unit id="e4426aae8665ecf03f0c5957ef62701c977ed33b" translate="yes" xml:space="preserve">
          <source>Suppose for example that you want to associate a value to each suit of the previous example.</source>
          <target state="translated">Предположим,например,что вы хотите связать значение с каждой масти в предыдущем примере.</target>
        </trans-unit>
        <trans-unit id="4045032ea32b290b2df4209d32c0f98371142465" translate="yes" xml:space="preserve">
          <source>Suppressing one type of sketchy null check only suppresses that type, so, for example</source>
          <target state="translated">Подавление одного типа проверки эскизного нуля подавляет только этот тип,так что,например,</target>
        </trans-unit>
        <trans-unit id="22ad664e9eb98b75a73333b2b2395fc4b52e6fc9" translate="yes" xml:space="preserve">
          <source>Symbols</source>
          <target state="translated">Symbols</target>
        </trans-unit>
        <trans-unit id="5388b4e54e46d7ce88e2e324bb0464dd484b2048" translate="yes" xml:space="preserve">
          <source>Symbols (new in ECMAScript 2015)</source>
          <target state="translated">Символы (новое в ECMAScript 2015)</target>
        </trans-unit>
        <trans-unit id="b6410af0c2d3799d510fea0f3019deaa0a7626b1" translate="yes" xml:space="preserve">
          <source>Symbols are created with &lt;code&gt;Symbol()&lt;/code&gt; in JavaScript. Flow has basic support for symbols, using the &lt;code&gt;symbol&lt;/code&gt; type.</source>
          <target state="translated">Символы создаются с помощью &lt;code&gt;Symbol()&lt;/code&gt; в JavaScript. Flow имеет базовую поддержку символов, использующих тип &lt;code&gt;symbol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6251b774c7c6606be961a6810aa903791863a16" translate="yes" xml:space="preserve">
          <source>Syntax of functions</source>
          <target state="translated">Синтаксис функций</target>
        </trans-unit>
        <trans-unit id="38f70f0698cfc1eb1310e93dc39ca20595f7e95e" translate="yes" xml:space="preserve">
          <source>Syntax of generics</source>
          <target state="translated">Синтаксис дженериков</target>
        </trans-unit>
        <trans-unit id="bae14ee1fff7b2a05299ec56ecdba3f6a62d2c5f" translate="yes" xml:space="preserve">
          <source>Table of contents:</source>
          <target state="translated">Оглавление:</target>
        </trans-unit>
        <trans-unit id="47b04edd80b66ddca98050f09adbdab0598b38a9" translate="yes" xml:space="preserve">
          <source>Take note of the &lt;code&gt;typeof&lt;/code&gt;, it is required! &lt;code&gt;Foo&lt;/code&gt; without &lt;code&gt;typeof&lt;/code&gt; would be the type of an instance of &lt;code&gt;Foo&lt;/code&gt;. So: &lt;code&gt;(new Foo(): Foo)&lt;/code&gt;. We want the type &lt;em&gt;of&lt;/em&gt;&lt;code&gt;Foo&lt;/code&gt; not the type of an instance of &lt;code&gt;Foo&lt;/code&gt;. So: &lt;code&gt;(Foo: typeof Foo)&lt;/code&gt;. &lt;code&gt;Class&amp;lt;Foo&amp;gt;&lt;/code&gt; would also work here, but we prefer &lt;code&gt;typeof&lt;/code&gt; for consistency with stateless functional components.</source>
          <target state="translated">Обратите внимание на &lt;code&gt;typeof&lt;/code&gt; , это обязательно! &lt;code&gt;Foo&lt;/code&gt; без &lt;code&gt;typeof&lt;/code&gt; будет типом экземпляра &lt;code&gt;Foo&lt;/code&gt; . Итак: &lt;code&gt;(new Foo(): Foo)&lt;/code&gt; . Мы хотим , чтобы тип &lt;em&gt;из &lt;/em&gt; &lt;code&gt;Foo&lt;/code&gt; не тип экземпляра &lt;code&gt;Foo&lt;/code&gt; . Итак: &lt;code&gt;(Foo: typeof Foo)&lt;/code&gt; . &lt;code&gt;Class&amp;lt;Foo&amp;gt;&lt;/code&gt; также будет работать здесь, но мы предпочитаем &lt;code&gt;typeof&lt;/code&gt; для согласованности с функциональными компонентами без сохранения состояния.</target>
        </trans-unit>
        <trans-unit id="143158f8e0d23bcab4c6519c800370955610ba03" translate="yes" xml:space="preserve">
          <source>Tell Flow which directory to use as a temp directory. Can be overridden with the command line flag &lt;code&gt;--temp-dir&lt;/code&gt;.</source>
          <target state="translated">Сообщите Flow, какой каталог использовать в качестве временного каталога. Может быть изменено с помощью флага командной строки &lt;code&gt;--temp-dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a5ea6782ec2acdb66109615aa3170a3b9e5c7b0" translate="yes" xml:space="preserve">
          <source>The 3 largest parts of the shared memory are a dependency table, a hash table, and a heap. While the heap grows and shrinks, the two tables are allocated in full. This option lets you change the size of the hash table.</source>
          <target state="translated">Тремя самыми большими частями разделяемой памяти являются таблица зависимостей,хэш-таблица и куча.В то время как куча растет и сжимается,эти две таблицы распределяются полностью.Эта опция позволяет изменять размер хэш-таблицы.</target>
        </trans-unit>
        <trans-unit id="0934dcae4f0cd7ddb495aeab8057d00242e3e126" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.flowconfig&lt;/code&gt; consists of 7 sections:</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; состоит из 7 разделов:</target>
        </trans-unit>
        <trans-unit id="b2e7419e93c6bb39d11632417b0da8c56509fd33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.flowconfig&lt;/code&gt; uses a custom format that vaguely resembles INI files. We are not proud of our custom format and plan to support a better format in the future. &lt;a href=&quot;https://github.com/facebook/flow/issues/153&quot;&gt;GitHub issue #153&lt;/a&gt; tracks this.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; использует пользовательский формат , который отдаленно напоминает INI файлы. Мы не гордимся своим нестандартным форматом и планируем в будущем поддерживать формат лучше. &lt;a href=&quot;https://github.com/facebook/flow/issues/153&quot;&gt;Это&lt;/a&gt; отслеживается в выпуске № 153 GitHub .</target>
        </trans-unit>
        <trans-unit id="1aa5025da02d927676c9cd482376361a167bd517" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; in &lt;code&gt;?HTMLButtonElement&lt;/code&gt; is important. In the example above the first argument to &lt;code&gt;ref&lt;/code&gt; will be &lt;code&gt;HTMLButtonElement | null&lt;/code&gt; as React will &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element&quot;&gt;call your &lt;code&gt;ref&lt;/code&gt; callback with null&lt;/a&gt; when the component unmounts. Also, the &lt;code&gt;button&lt;/code&gt; property on &lt;code&gt;MyComponent&lt;/code&gt; will not be set until React has finished rendering. Until then your &lt;code&gt;button&lt;/code&gt; ref will be undefined. Protect yourself against these cases and use a &lt;code&gt;?&lt;/code&gt; (like in &lt;code&gt;?HTMLButtonElement&lt;/code&gt;) to protect yourself from bugs.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; в &lt;code&gt;?HTMLButtonElement&lt;/code&gt; важен. В приведенном выше примере первым аргументом для &lt;code&gt;ref&lt;/code&gt; будет &lt;code&gt;HTMLButtonElement | null&lt;/code&gt; , поскольку React вызовет &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element&quot;&gt;ваш обратный вызов &lt;code&gt;ref&lt;/code&gt; с null,&lt;/a&gt; когда компонент отключится. Кроме того &lt;code&gt;button&lt;/code&gt; свойство кнопки &lt;code&gt;MyComponent&lt;/code&gt; не будет установлено, пока React не завершит рендеринг. До тех пор ссылка на вашу &lt;code&gt;button&lt;/code&gt; будет неопределенной. Защитите себя от этих случаев и используйте &lt;code&gt;?&lt;/code&gt; (как в &lt;code&gt;?HTMLButtonElement&lt;/code&gt; ), чтобы защитить себя от ошибок.</target>
        </trans-unit>
        <trans-unit id="719a6a4c0e07c1dc9a47466bbab725e9662338ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; types that React provides and the DOM events they are related to are:</source>
          <target state="translated">&lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; типа, реагирующие обеспечивает и DOM события они связаны с являются:</target>
        </trans-unit>
        <trans-unit id="653be0e1cd193d42d4fa78964cd56de69b5da2cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[declarations]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to parse files matching the specified regular expressions in &lt;em&gt;declaration mode&lt;/em&gt;. In declaration mode the code is not typechecked. However, the signatures of functions, classes, etc are extracted and used by the typechecker when checking other code.</source>
          <target state="translated">Раздел &lt;code&gt;[declarations]&lt;/code&gt; в файле &lt;code&gt;.flowconfig&lt;/code&gt; сообщает Flow о необходимости синтаксического анализа файлов, соответствующих указанным регулярным выражениям, в &lt;em&gt;режиме объявления&lt;/em&gt; . В режиме объявления код не проверяется по типу. Однако сигнатуры функций, классов и т. Д. Извлекаются и используются средством проверки типов при проверке другого кода.</target>
        </trans-unit>
        <trans-unit id="df21474ae6954ba751628a9d46d6c9512fa40f07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[ignore]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to ignore files matching the specified regular expressions when type checking your code. By default, nothing is ignored.</source>
          <target state="translated">Раздел &lt;code&gt;[ignore]&lt;/code&gt; в файле &lt;code&gt;.flowconfig&lt;/code&gt; предписывает Flow игнорировать файлы, соответствующие указанным регулярным выражениям, при проверке типа вашего кода. По умолчанию ничего не игнорируется.</target>
        </trans-unit>
        <trans-unit id="89a1fffc651c11cf6e66838e0172e44593fd9d49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[include]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to include the specified files or directories. Including a directory recursively includes all the files under that directory. Symlinks are followed as long as they lead to a file or directory that is also included. Each line in the include section is a path to include. These paths can be relative to the root directory or absolute, and support both single and double star wildcards.</source>
          <target state="translated">Раздел &lt;code&gt;[include]&lt;/code&gt; в файле &lt;code&gt;.flowconfig&lt;/code&gt; указывает Flow включить указанные файлы или каталоги. Включение каталога рекурсивно включает все файлы в этом каталоге. Символические ссылки используются до тех пор, пока они ведут к файлу или каталогу, который также включен. Каждая строка в разделе включения - это путь для включения. Эти пути могут быть относительными к корневому каталогу или абсолютными и поддерживать подстановочные знаки как с одной, так и с двумя звездами.</target>
        </trans-unit>
        <trans-unit id="f33fef6875ad046a3f7a76b86437d56196d9c414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[libs]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to include the specified &lt;a href=&quot;https://flow.org/en/libdefs/&quot;&gt;library definitions&lt;/a&gt; when type checking your code. Multiple libraries can be specified. By default, the &lt;code&gt;flow-typed&lt;/code&gt; folder in your project root directory is included as a library directory. This default allows you to use &lt;a href=&quot;https://github.com/flowtype/flow-typed&quot;&gt;&lt;code&gt;flow-typed&lt;/code&gt;&lt;/a&gt; to install library definitions without additional configuration.</source>
          <target state="translated">Раздел &lt;code&gt;[libs]&lt;/code&gt; в файле &lt;code&gt;.flowconfig&lt;/code&gt; сообщает Flow о необходимости включения указанных &lt;a href=&quot;https://flow.org/en/libdefs/&quot;&gt;определений библиотеки&lt;/a&gt; при проверке типа вашего кода. Можно указать несколько библиотек. По умолчанию папка &lt;code&gt;flow-typed&lt;/code&gt; в корневом каталоге вашего проекта включается в качестве каталога библиотеки. Это значение по умолчанию позволяет использовать &lt;a href=&quot;https://github.com/flowtype/flow-typed&quot;&gt; &lt;code&gt;flow-typed&lt;/code&gt; &lt;/a&gt; для установки определений библиотек без дополнительной настройки.</target>
        </trans-unit>
        <trans-unit id="93975a8a26491b29c7786a7d20f47e387cfa3514" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[lints]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file can contain several key-value pairs of the form:</source>
          <target state="translated">Раздел &lt;code&gt;[lints]&lt;/code&gt; в файле &lt;code&gt;.flowconfig&lt;/code&gt; может содержать несколько пар ключ-значение в форме:</target>
        </trans-unit>
        <trans-unit id="263df81c3f42c9c4c0096bb79a58e2dee22d2326" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[options]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file can contain several key-value pairs of the form:</source>
          <target state="translated">Раздел &lt;code&gt;[options]&lt;/code&gt; в файле &lt;code&gt;.flowconfig&lt;/code&gt; может содержать несколько пар ключ-значение в форме:</target>
        </trans-unit>
        <trans-unit id="81ba04249ba83fffa732ce0d0760f8ad3472a183" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[untyped]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to not typecheck files matching the specified regular expressions and instead throw away types and treat modules as &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Раздел &lt;code&gt;[untyped]&lt;/code&gt; в файле &lt;code&gt;.flowconfig&lt;/code&gt; сообщает Flow не проверять типы файлов, соответствующих указанным регулярным выражениям, а вместо этого отбрасывать типы и рассматривать модули как &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="924f7192ca7f7c407e938ed0acd12668b4d33fbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; operator returns the Flow type of a given value to be used as a type.</source>
          <target state="translated">Оператор &lt;code&gt;typeof&lt;/code&gt; возвращает тип Flow данного значения, которое будет использоваться в качестве типа.</target>
        </trans-unit>
        <trans-unit id="67966e36f904c5d8958d761e6cb9127537aff7ef" translate="yes" xml:space="preserve">
          <source>The Asynchronous Lint Engine (ALE) plugin for Vim 8+ and NeoVim, &lt;a href=&quot;https://github.com/w0rp/ale&quot;&gt;vim-ale&lt;/a&gt;, is a generalized linting engine with support for Flow and many other tools.</source>
          <target state="translated">Плагин Asynchronous Lint Engine (ALE) для Vim 8+ и NeoVim, &lt;a href=&quot;https://github.com/w0rp/ale&quot;&gt;vim-ale&lt;/a&gt; , представляет собой обобщенный механизм линтинга с поддержкой Flow и многих других инструментов.</target>
        </trans-unit>
        <trans-unit id="5183c3b41bf0492de80698dc738a05d76568f6ad" translate="yes" xml:space="preserve">
          <source>The CLI tool also provides several other options and commands that allow you to control the server and build tools that integrate with Flow. For example, this is how the &lt;a href=&quot;https://nuclide.io/&quot;&gt;Nuclide&lt;/a&gt; editor integrates with Flow to provide autocompletion, type errors, etc. in its UI.</source>
          <target state="translated">Инструмент CLI также предоставляет несколько других опций и команд, которые позволяют вам управлять сервером и создавать инструменты, которые интегрируются с Flow. Например, вот так редактор &lt;a href=&quot;https://nuclide.io/&quot;&gt;Nuclide&lt;/a&gt; интегрируется с Flow, чтобы обеспечить автозаполнение, ошибки типа и т. Д. В своем пользовательском интерфейсе.</target>
        </trans-unit>
        <trans-unit id="0b12391516f21ae19dfcef64eb8647ae6924887e" translate="yes" xml:space="preserve">
          <source>The Flow background process monitors all Flow files. However, how does it know which files are Flow files and, thus, should be checked? Placing the following &lt;strong&gt;before any code&lt;/strong&gt; in a JavaScript file is the flag the process uses to answer that question.</source>
          <target state="translated">Фоновый процесс Flow контролирует все файлы Flow. Однако как узнать, какие файлы являются файлами Flow и, следовательно, должны быть проверены? Размещение следующего &lt;strong&gt;перед любым кодом&lt;/strong&gt; в файле JavaScript - это флаг, который процесс использует для ответа на этот вопрос.</target>
        </trans-unit>
        <trans-unit id="3ea8fcfb745f317d30dab0afe405550d9490a0f7" translate="yes" xml:space="preserve">
          <source>The Flow root must be within a &lt;a href=&quot;https://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt; repository.</source>
          <target state="translated">Корень Flow должен находиться в репозитории &lt;a href=&quot;https://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb9d9e2a123153d996537b64730290848876d71f" translate="yes" xml:space="preserve">
          <source>The IDE needs to integrate with &lt;code&gt;flow lsp&lt;/code&gt; to tell Flow which files are open.</source>
          <target state="translated">IDE необходимо интегрировать с &lt;code&gt;flow lsp&lt;/code&gt; чтобы сообщить Flow, какие файлы открыты.</target>
        </trans-unit>
        <trans-unit id="e36e3ea40dbe1430b59533dc1b80fc6036bba9ee" translate="yes" xml:space="preserve">
          <source>The JavaScript language is a bunch of object-oriented ideas and functional ideas mixed together. Developer&amp;rsquo;s usage of JavaScript tends to be mixed as well. Classes (or constructor functions) being the more object-oriented side and functions (as lambdas) and objects tend to be more on the functional side, developers use both simultaneously.</source>
          <target state="translated">Язык JavaScript - это совокупность объектно-ориентированных идей и функциональных идей, смешанных вместе. Использование JavaScript разработчиками также может быть неоднозначным. Классы (или функции-конструкторы) являются более объектно-ориентированной стороной, а функции (как лямбда-выражения) и объекты имеют тенденцию быть более функциональными, разработчики используют и то, и другое одновременно.</target>
        </trans-unit>
        <trans-unit id="7bd394e3f7c77eaabbe75ef337cf434e120de82b" translate="yes" xml:space="preserve">
          <source>The Trivial HOC</source>
          <target state="translated">Тривиальный HOC</target>
        </trans-unit>
        <trans-unit id="025b59ea409d457aec020e335d2f4bc894d68ede" translate="yes" xml:space="preserve">
          <source>The ability for a static type checker to be able to tell that the value inside the if statement must be &lt;code&gt;&quot;A&quot;&lt;/code&gt; is known as a refinement.</source>
          <target state="translated">Способность средства проверки статического типа определять, что значение внутри оператора if должно быть &lt;code&gt;&quot;A&quot;&lt;/code&gt; , называется уточнением.</target>
        </trans-unit>
        <trans-unit id="fec021ecaeba3a8ee38ad356d77c56a0bb6f13a4" translate="yes" xml:space="preserve">
          <source>The above code has a type error because Flow would also allow the call expression &lt;code&gt;method({ foo: 1, bar: 2 })&lt;/code&gt;, because &lt;code&gt;{foo:number,bar:number}&lt;/code&gt; is a subtype of &lt;code&gt;{bar:number}&lt;/code&gt;, one of the members of the parameter&amp;rsquo;s union type.</source>
          <target state="translated">В приведенном выше коде есть ошибка типа, потому что Flow также допускает &lt;code&gt;method({ foo: 1, bar: 2 })&lt;/code&gt; выражения вызова ({foo: 1, bar: 2}) , потому что &lt;code&gt;{foo:number,bar:number}&lt;/code&gt; является подтипом &lt;code&gt;{bar:number}&lt;/code&gt; , одним из члены типа объединения параметра.</target>
        </trans-unit>
        <trans-unit id="fe2ac4fdbea23fe269b2df48740a8fe5b6447c33" translate="yes" xml:space="preserve">
          <source>The advantage of the &lt;code&gt;$Exports&lt;/code&gt; syntax is that you can &lt;code&gt;export&lt;/code&gt; the type on the same line</source>
          <target state="translated">Преимущество синтаксиса &lt;code&gt;$Exports&lt;/code&gt; том, что вы можете &lt;code&gt;export&lt;/code&gt; тип в той же строке</target>
        </trans-unit>
        <trans-unit id="eba2348e4056127995e90c22bf6c18e156a3d1c5" translate="yes" xml:space="preserve">
          <source>The base type for Redux &lt;a href=&quot;http://redux.js.org/docs/basics/Actions.html&quot;&gt;actions&lt;/a&gt; is an object with a &lt;code&gt;type&lt;/code&gt; property.</source>
          <target state="translated">Базовым типом для &lt;a href=&quot;http://redux.js.org/docs/basics/Actions.html&quot;&gt;действий&lt;/a&gt; Redux является объект со свойством &lt;code&gt;type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8af3b40968bb4f75f70768133b814cdf17d5d2ec" translate="yes" xml:space="preserve">
          <source>The basic &lt;code&gt;flowlint&lt;/code&gt; comment takes a comma-delimited list of &lt;code&gt;rule:severity&lt;/code&gt; pairs and applies those settings for the rest of the source file until overridden. This has three primary purposes: applying settings over a block, applying settings over a file, and applying settings over part of a line.</source>
          <target state="translated">Основной комментарий &lt;code&gt;flowlint&lt;/code&gt; принимает разделенный запятыми список пар &lt;code&gt;rule:severity&lt;/code&gt; и применяет эти настройки для остальной части исходного файла до тех пор, пока не будет отменен. Это имеет три основные цели: применение настроек к блоку, применение настроек к файлу и применение настроек к части строки.</target>
        </trans-unit>
        <trans-unit id="f167409d5ec197b4871f95c5db2fcf7f6bbd5cd2" translate="yes" xml:space="preserve">
          <source>The body of these predicate functions need to be expressions (i.e. local variable declarations are not supported). But it&amp;rsquo;s possible to call other predicate functions inside a predicate function. For example:</source>
          <target state="translated">Тело этих функций предиката должно быть выражением (т. Е. Объявления локальных переменных не поддерживаются). Но можно вызывать другие функции предиката внутри функции предиката. Например:</target>
        </trans-unit>
        <trans-unit id="182510f68d230df9a3e633ed8ee2db47f5bc405d" translate="yes" xml:space="preserve">
          <source>The core benefit to Flow is its ability to quickly check your code for errors. Once you have enabled your project for Flow, you can start the process that allows Flow to check your code incrementally and with great speed.</source>
          <target state="translated">Основным преимуществом Flow является его способность быстро проверять код на наличие ошибок.Как только вы включили свой проект для Flow,вы можете начать процесс,который позволит Flow проверять ваш код постепенно и с большой скоростью.</target>
        </trans-unit>
        <trans-unit id="f7197940d208092be8c8d13b858faffa50044428" translate="yes" xml:space="preserve">
          <source>The decision of which direction to apply the subtyping rule on inputs and outputs is governed by variance, which is the topic of the next section.</source>
          <target state="translated">Решение о том,в каком направлении применять правило подтипирования вводимых и вы вводимых ресурсов и мероприятий,зависит от разницы,о которой идет речь в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="4ff505957015ad603cc74c9be6c56afdb90f26dc" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">По умолчанию это &lt;code&gt;node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="684bf3ea595241d58aa0cbec92715b88590f0f96" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Значение по умолчанию для &lt;code&gt;all&lt;/code&gt; - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcc51d57d4a016ea1192824513bdb37f918f5d3a" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;babel_loose_array_spread&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Значение по умолчанию для &lt;code&gt;babel_loose_array_spread&lt;/code&gt; - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3320966c1ed05d8e92be8263eb0872986cd5b9d" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;emoji&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">По умолчанию для &lt;code&gt;emoji&lt;/code&gt; установлено значение &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="108bf5699171bd14f4e61bce6c21f7bec782d0a5" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;types_first&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (as of version 0.134).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b4c401e7d77aa94ed0f3d78556a2ab12605661" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;/tmp/flow&lt;/code&gt;.</source>
          <target state="translated">Значение по умолчанию - &lt;code&gt;/tmp/flow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ab75823e9609a97fc3968cb003989422d1692ab" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;automatic&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d1dcc6b3a394539acf783a764b41f856bcb2ec9" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Значением по умолчанию является &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17a6f3086f6053ea99056f8787ec9e3c7714223a" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">Значение по умолчанию - &lt;code&gt;none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="385f9197e267dca024cc7c5ee266ab77c07dd86b" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;max_header_tokens&lt;/code&gt; is 10.</source>
          <target state="translated">Значение &lt;code&gt;max_header_tokens&lt;/code&gt; по умолчанию - 10.</target>
        </trans-unit>
        <trans-unit id="4afe27211cbc9af6d345271f3bd53dcd4c074b64" translate="yes" xml:space="preserve">
          <source>The default value of this option is &lt;code&gt;enable&lt;/code&gt;, which allows use of this proposed syntax.</source>
          <target state="translated">Значение по умолчанию для этой опции - &lt;code&gt;enable&lt;/code&gt; , что позволяет использовать предложенный синтаксис.</target>
        </trans-unit>
        <trans-unit id="07a26010ceb723197e0f6ed4ccf098b594327ee9" translate="yes" xml:space="preserve">
          <source>The default value of this option is &lt;code&gt;warn&lt;/code&gt;, which gives a warning on use since this proposal is still very early-stage.</source>
          <target state="translated">Значение по умолчанию для этой опции - &lt;code&gt;warn&lt;/code&gt; , что дает предупреждение при использовании, поскольку это предложение все еще находится на очень ранней стадии.</target>
        </trans-unit>
        <trans-unit id="4804a2b774fe8e16ad5ee7fbc61053dc05f70f20" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; is roughly:</source>
          <target state="translated">Определение &lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; примерно следующее:</target>
        </trans-unit>
        <trans-unit id="c3087bc731ef3517a427cf5c4e5203623cadca99" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.ElementType&lt;/code&gt; is roughly:</source>
          <target state="translated">Определение &lt;code&gt;React.ElementType&lt;/code&gt; примерно так:</target>
        </trans-unit>
        <trans-unit id="6e617c1ee84ca2ef49a14a0c500b7bf9f6b27172" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.Ref&amp;lt;typeof Component&amp;gt;&lt;/code&gt; is roughly:</source>
          <target state="translated">Определение &lt;code&gt;React.Ref&amp;lt;typeof Component&amp;gt;&lt;/code&gt; примерно следующее:</target>
        </trans-unit>
        <trans-unit id="f2c72eeedacf538eae7405dbd87fe7965700eed1" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.StatelessFunctionalComponent&amp;lt;Props&amp;gt;&lt;/code&gt; is roughly:</source>
          <target state="translated">Определение &lt;code&gt;React.StatelessFunctionalComponent&amp;lt;Props&amp;gt;&lt;/code&gt; примерно следующее:</target>
        </trans-unit>
        <trans-unit id="67931b95c973afece9e67ea2abaeb942c4811eaf" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;React.Node&lt;/code&gt; can be roughly approximated with a &lt;a href=&quot;#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Определение &lt;code&gt;React.Node&lt;/code&gt; можно приблизительно приблизительно представить с помощью &lt;a href=&quot;#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="65be16845f607fa6de2868121655dbf19d303167" translate="yes" xml:space="preserve">
          <source>The design decision in Flow around mixing nominal and structural typing was chosen based on how objects, functions, and classes are already used in JavaScript.</source>
          <target state="translated">Проектное решение в Flow вокруг смешивания номинального и структурного типов было выбрано исходя из того,как объекты,функции и классы уже используются в JavaScript.</target>
        </trans-unit>
        <trans-unit id="29d2d625710fa5cd0abd9e50046510b51fb847f2" translate="yes" xml:space="preserve">
          <source>The example above could not be accomplished without the &lt;code&gt;+&lt;/code&gt; variance sigil:</source>
          <target state="translated">Приведенный выше пример не мог бы быть выполнен без символа &lt;code&gt;+&lt;/code&gt; дисперсии:</target>
        </trans-unit>
        <trans-unit id="569e13c9d22dc97266745256891834efe9cb254b" translate="yes" xml:space="preserve">
          <source>The first time this is run, the &lt;a href=&quot;#toc-run-flow-background-process&quot;&gt;Flow background process&lt;/a&gt; will be spawned and all of your Flow files will be checked. Then, as you continue to iterate on your project, the background process will continuously monitor your code such that when you run &lt;code&gt;flow&lt;/code&gt; again, the updated result will be near instantaneous.</source>
          <target state="translated">При первом запуске будет запущен &lt;a href=&quot;#toc-run-flow-background-process&quot;&gt;фоновый процесс Flow&lt;/a&gt; , и все ваши файлы Flow будут проверены. Затем, когда вы продолжите итерацию в своем проекте, фоновый процесс будет постоянно отслеживать ваш код, так что, когда вы снова запустите &lt;code&gt;flow&lt;/code&gt; , обновленный результат будет почти мгновенным.</target>
        </trans-unit>
        <trans-unit id="f48e199f3e1c2873fac5e329e515e0affa5734d6" translate="yes" xml:space="preserve">
          <source>The fix here is to add types to the parameters of &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">Исправление здесь - добавить типы к параметрам &lt;code&gt;add&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="decaa6f4bcdc1dd98facfb522a07ee0290e90e6a" translate="yes" xml:space="preserve">
          <source>The flow command line tool is made to be easy-to-use for simple cases.</source>
          <target state="translated">Инструмент поточной командной строки сделан таким образом,чтобы быть простым в использовании для простых случаев.</target>
        </trans-unit>
        <trans-unit id="568d41ac14b4b2796ccd853ff99f7c7a730490f8" translate="yes" xml:space="preserve">
          <source>The following are functionally equivalent</source>
          <target state="translated">Следующее функционально эквивалентно</target>
        </trans-unit>
        <trans-unit id="10e5012640308970d1812cdfc15f495ee3f6ea82" translate="yes" xml:space="preserve">
          <source>The function argument allows &lt;code&gt;string&lt;/code&gt; values in its field, but in this case Flow prevents the original object from having a &lt;code&gt;number&lt;/code&gt; written to it. Within the body of the function you would be able to mutate the object so that the property &lt;code&gt;a&lt;/code&gt; would receive a &lt;code&gt;number&lt;/code&gt;, causing the type of the original object to no longer be accurate. You can fix this error by making the property covariant (read-only): &lt;code&gt;{+a:string|&amp;nbsp;number}&lt;/code&gt;. This prevents the function body from writing to the property, making it safe to pass more restricted types to the function.</source>
          <target state="translated">Аргумент функции допускает &lt;code&gt;string&lt;/code&gt; значения в своем поле, но в этом случае Flow предотвращает запись &lt;code&gt;number&lt;/code&gt; в исходный объект . В теле функции вы можете изменить объект так, чтобы свойство &lt;code&gt;a&lt;/code&gt; получило &lt;code&gt;number&lt;/code&gt; , в результате чего тип исходного объекта больше не будет точным. Вы можете исправить эту ошибку, сделав свойство ковариантным (только для чтения): &lt;code&gt;{+a:string|&amp;nbsp;number}&lt;/code&gt; . Это предотвращает запись тела функции в свойство, что позволяет безопасно передавать функции более ограниченные типы.</target>
        </trans-unit>
        <trans-unit id="2155dfc51f926d913a644cc3de06c804ab01b2ad" translate="yes" xml:space="preserve">
          <source>The function&amp;rsquo;s argument allows &lt;code&gt;string&lt;/code&gt; values in its array, but in this case Flow prevents the original array from receiving a &lt;code&gt;number&lt;/code&gt;. Inside the function, you would be able to push a &lt;code&gt;number&lt;/code&gt; to the argument array, causing the type of the original array to no longer be accurate. You can fix this error by changing the type of the argument to &lt;code&gt;$ReadOnlyArray&amp;lt;string |&amp;nbsp;number&amp;gt;&lt;/code&gt;. This prevents the function body from pushing anything to the array, allowing it to accept narrower types.</source>
          <target state="translated">Аргумент функции допускает &lt;code&gt;string&lt;/code&gt; значения в своем массиве, но в этом случае Flow предотвращает получение &lt;code&gt;number&lt;/code&gt; исходным массивом . Внутри функции вы сможете вставить &lt;code&gt;number&lt;/code&gt; в массив аргументов, в результате чего тип исходного массива больше не будет точным. Вы можете исправить эту ошибку, изменив тип аргумента на &lt;code&gt;$ReadOnlyArray&amp;lt;string |&amp;nbsp;number&amp;gt;&lt;/code&gt; . Это предотвращает отправку чего-либо телом функции в массив, позволяя ему принимать более узкие типы.</target>
        </trans-unit>
        <trans-unit id="63f89c1777909f20b429c72e0ff7ec4f5852765d" translate="yes" xml:space="preserve">
          <source>The function&amp;rsquo;s purpose is to run all the thunks and return an object made of values. What&amp;rsquo;s the return type of this function?</source>
          <target state="translated">Цель функции - запустить все преобразователи и вернуть объект, состоящий из значений. Какой тип возврата этой функции?</target>
        </trans-unit>
        <trans-unit id="c023f83d766bac37fd8c93749ac0588a01c18d3d" translate="yes" xml:space="preserve">
          <source>The great thing about Flow is that you can get near real-time feedback on the state of your code. At any point that you want to check for errors, just run:</source>
          <target state="translated">Самое замечательное в Flow-это то,что вы можете получать обратную связь практически в реальном времени о состоянии вашего кода.В любой момент,когда вы захотите проверить,нет ли ошибок,просто запустите:</target>
        </trans-unit>
        <trans-unit id="1d3a896ebf3c8fbb9102531fb367809a43a70216" translate="yes" xml:space="preserve">
          <source>The idea of using types to manage code evolution and growth in JavaScript (and related languages) is not new. In fact, several useful type systems have been built for JavaScript in recent years. However, type systems differ in their goals. On one end of the spectrum are permissive type systems that provide some degree of linting against likely errors, without regard for correctness. On the other end of the spectrum are restrictive type systems that can guarantee the correctness of static code optimizations, at the cost of interoperability. Another area that has not seen a lot of focus is the performance of type checking itself.</source>
          <target state="translated">Идея использования типов для управления эволюцией и ростом кода в JavaScript (и родственных языках)не нова.Фактически,за последние годы было построено несколько полезных систем типов для JavaScript.Тем не менее,системы типов отличаются друг от друга по своим целям.На одном конце спектра находятся системы разрешительных типов,которые обеспечивают некоторую степень защиты от возможных ошибок,без учета их корректности.На другом конце спектра находятся системы ограничительных типов,которые за счет интероперабельности могут гарантировать корректность статических оптимизаций кода.Другая область,которая не получила большого внимания,-это сама по себе производительность проверки типов.</target>
        </trans-unit>
        <trans-unit id="895222166e3067cff8bd88b8a774d6ab00fde9e2" translate="yes" xml:space="preserve">
          <source>The inferred type of the property becomes what you set it to.</source>
          <target state="translated">Предполагаемый тип свойства становится тем,к чему вы его устанавливаете.</target>
        </trans-unit>
        <trans-unit id="e551fea41cfe91f78e0d3bfde3174c0c4fa76ec7" translate="yes" xml:space="preserve">
          <source>The key to Flow&amp;rsquo;s speed is modularity: the ability to break the analysis into file-sized chunks that can be assembled later.</source>
          <target state="translated">Ключом к скорости Flow является модульность: способность разбивать анализ на фрагменты размером с файл, которые можно собрать позже.</target>
        </trans-unit>
        <trans-unit id="ef6ba2b0cdf8e98a8b5dce1cdbd0afc335063144" translate="yes" xml:space="preserve">
          <source>The keys are the same, but the values have a different type, namely the return type of each function. At a value level (the implementation of the function) we&amp;rsquo;re essentially mapping over the object to produce new values for the keys. How to express this at a type level?</source>
          <target state="translated">Ключи такие же, но значения имеют другой тип, а именно тип возвращаемого значения каждой функции. На уровне значений (реализация функции) мы, по сути, сопоставляем объект, чтобы создать новые значения для ключей. Как выразить это на уровне шрифта?</target>
        </trans-unit>
        <trans-unit id="92ccbfce1a4e920f5d1758fbdebfc31032b257d4" translate="yes" xml:space="preserve">
          <source>The length of the tuple is known as the &amp;ldquo;arity&amp;rdquo;. The length of a tuple is strictly enforced in Flow.</source>
          <target state="translated">Длина кортежа называется &amp;laquo;арностью&amp;raquo;. В Flow строго соблюдается длина кортежа.</target>
        </trans-unit>
        <trans-unit id="647cfb5d0aaa8b82192bbb83417ad5b3177c198f" translate="yes" xml:space="preserve">
          <source>The lint settings parser is fairly intelligent and will stop you if you write a redundant rule, a rule that gets completely overwritten, or an unused suppression. This should prevent most accidental misconfigurations of lint rules.</source>
          <target state="translated">Парсер lint settings достаточно умен и остановит вас,если вы напишете избыточное правило,правило,которое будет полностью перезаписано,или неиспользуемое подавление.Это должно предотвратить большинство случайных неправильных настроек lint правил.</target>
        </trans-unit>
        <trans-unit id="f02d9fd7d48002b88a676cb504a249985d85238a" translate="yes" xml:space="preserve">
          <source>The location of the &lt;code&gt;.flowconfig&lt;/code&gt; is significant. Flow treats the directory that contains the &lt;code&gt;.flowconfig&lt;/code&gt; as the &lt;em&gt;project root&lt;/em&gt;. By default Flow includes all the source code under the project root. The paths in the &lt;a href=&quot;include&quot;&gt;[include] section&lt;/a&gt; are relative to the project root. Some other configuration also lets you reference the project root via the macro &lt;code&gt;&amp;lt;PROJECT_ROOT&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Расположение &lt;code&gt;.flowconfig&lt;/code&gt; имеет большое значение. Flow рассматривает каталог, содержащий &lt;code&gt;.flowconfig&lt;/code&gt; как &lt;em&gt;корень проекта&lt;/em&gt; . По умолчанию Flow включает весь исходный код в корень проекта. Пути в разделе &lt;a href=&quot;include&quot;&gt;[include]&lt;/a&gt; указаны относительно корня проекта. Некоторые другие конфигурации также позволяют ссылаться на корень проекта через макрос &lt;code&gt;&amp;lt;PROJECT_ROOT&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88b94dfde96af7809cecaa352baf181b5eb93f8e" translate="yes" xml:space="preserve">
          <source>The main advantage to using &lt;code&gt;$ReadOnlyArray&lt;/code&gt; instead of &lt;code&gt;Array&lt;/code&gt; is that &lt;code&gt;$ReadOnlyArray&lt;/code&gt;&amp;rsquo;s type parameter is &lt;em&gt;covariant&lt;/em&gt; while &lt;code&gt;Array&lt;/code&gt;&amp;rsquo;s type parameter is &lt;em&gt;invariant&lt;/em&gt;. That means that &lt;code&gt;$ReadOnlyArray&amp;lt;number&amp;gt;&lt;/code&gt; is a subtype of &lt;code&gt;$ReadOnlyArray&amp;lt;number | string&amp;gt;&lt;/code&gt; while &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt; is NOT a subtype of &lt;code&gt;Array&amp;lt;number | string&amp;gt;&lt;/code&gt;. So it&amp;rsquo;s often useful to use &lt;code&gt;$ReadOnlyArray&lt;/code&gt; in type annotations for arrays of various types of elements. Take, for instance, the following scenario:</source>
          <target state="translated">Основное преимущество использования &lt;code&gt;$ReadOnlyArray&lt;/code&gt; вместо &lt;code&gt;Array&lt;/code&gt; заключается в том, что параметр типа &lt;code&gt;$ReadOnlyArray&lt;/code&gt; является &lt;em&gt;ковариантным, в&lt;/em&gt; то время как параметр типа &lt;code&gt;Array&lt;/code&gt; является &lt;em&gt;инвариантным&lt;/em&gt; . Это означает, что &lt;code&gt;$ReadOnlyArray&amp;lt;number&amp;gt;&lt;/code&gt; является подтипом &lt;code&gt;$ReadOnlyArray&amp;lt;number | string&amp;gt;&lt;/code&gt; а &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt; НЕ является подтипом &lt;code&gt;Array&amp;lt;number | string&amp;gt;&lt;/code&gt; . Поэтому часто бывает полезно использовать &lt;code&gt;$ReadOnlyArray&lt;/code&gt; в аннотациях типов для массивов различных типов элементов. Возьмем, например, следующий сценарий:</target>
        </trans-unit>
        <trans-unit id="641f626a5da92cffb82099b03123b4b7495ce303" translate="yes" xml:space="preserve">
          <source>The main difference with &lt;a href=&quot;#toc-diff&quot;&gt;&lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt;&lt;/a&gt;, is that &lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; aims to represent the true runtime rest operation, which implies that exact object types are treated differently in &lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt;. For example, &lt;code&gt;$Rest&amp;lt;{|n: number|}, {}&amp;gt;&lt;/code&gt; will result in &lt;code&gt;{|n?:number|}&lt;/code&gt; because an in-exact empty object may have an &lt;code&gt;n&lt;/code&gt; property, while &lt;code&gt;$Diff&amp;lt;{|n: number|}, {}&amp;gt;&lt;/code&gt; will result in &lt;code&gt;{|n:number|}&lt;/code&gt;.</source>
          <target state="translated">Основное отличие от &lt;a href=&quot;#toc-diff&quot;&gt; &lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt; &lt;/a&gt; состоит в том, что &lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; нацелен на представление истинной операции отдыха во время выполнения, что означает, что точные типы объектов обрабатываются по-разному в &lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; . Например, &lt;code&gt;$Rest&amp;lt;{|n: number|}, {}&amp;gt;&lt;/code&gt; приведет к &lt;code&gt;{|n?:number|}&lt;/code&gt; потому что неточно пустой объект может иметь свойство &lt;code&gt;n&lt;/code&gt; , а &lt;code&gt;$Diff&amp;lt;{|n: number|}, {}&amp;gt;&lt;/code&gt; приведет к &lt;code&gt;{|n:number|}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bbdc2ea29d0148a224653e3dc437fe724818563" translate="yes" xml:space="preserve">
          <source>The maximum number of workers the Flow server can start. By default, the server will use all available cores.</source>
          <target state="translated">Максимальное количество рабочих,которое может быть запущено сервером Flow.По умолчанию сервер будет использовать все доступные ядра.</target>
        </trans-unit>
        <trans-unit id="2288b72b1f95feec127ed704e5e991f5ea4c03bb" translate="yes" xml:space="preserve">
          <source>The module system to use to resolve &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt;. &lt;a href=&quot;https://github.com/facebook/node-haste&quot;&gt;Haste&lt;/a&gt; is used in React Native.</source>
          <target state="translated">Модульная система, используемая для разрешения &lt;code&gt;import&lt;/code&gt; и &lt;code&gt;require&lt;/code&gt; . &lt;a href=&quot;https://github.com/facebook/node-haste&quot;&gt;Ускорения&lt;/a&gt; используется в React Адаптивное.</target>
        </trans-unit>
        <trans-unit id="4ccdab5f7410661918848aa1e2e6bf4bba7ef93d" translate="yes" xml:space="preserve">
          <source>The most common case you&amp;rsquo;ll encounter is when exporting a function or React component. Flow requires you to annotate inputs. For instance, in this &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBTAHgB1gJwC6gMawB2AzngIYAmloAvKOXQHwOgDUoAjANxA&quot;&gt;example&lt;/a&gt;, flow will complain:</source>
          <target state="translated">Наиболее частый случай, с которым вы столкнетесь, - это экспорт функции или компонента React. Flow требует, чтобы вы аннотировали входные данные. Например, в этом &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBTAHgB1gJwC6gMawB2AzngIYAmloAvKOXQHwOgDUoAjANxA&quot;&gt;примере&lt;/a&gt; поток будет жаловаться:</target>
        </trans-unit>
        <trans-unit id="1d256527f1fd7c67fd36002480923ad5cedc2e90" translate="yes" xml:space="preserve">
          <source>The name specified in quotes after &lt;code&gt;declare module&lt;/code&gt; can be any string, but it should correspond to the same string you&amp;rsquo;d use to &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; the third-party module into your project. For defining modules that are accessed via a relative &lt;code&gt;require&lt;/code&gt;/&lt;code&gt;import&lt;/code&gt; path, please see the docs on the &lt;a href=&quot;https://flow.org/en/declarations&quot;&gt;&lt;code&gt;.flow&lt;/code&gt; files&lt;/a&gt;</source>
          <target state="translated">Имя, указанное в кавычках после &lt;code&gt;declare module&lt;/code&gt; может быть любой строкой, но оно должно соответствовать той же строке, которую вы использовали бы для &lt;code&gt;require&lt;/code&gt; или &lt;code&gt;import&lt;/code&gt; стороннего модуля в свой проект. Для определения модулей, которые доступны через родственник &lt;code&gt;require&lt;/code&gt; / &lt;code&gt;import&lt;/code&gt; пути, пожалуйста , смотрите документацию о &lt;a href=&quot;https://flow.org/en/declarations&quot;&gt; &lt;code&gt;.flow&lt;/code&gt; файлов&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fee97a1aa5d0e2a829b605bdbaea327f2fcfbd4f" translate="yes" xml:space="preserve">
          <source>The path to the log file (defaults to &lt;code&gt;/tmp/flow/&amp;lt;escaped root path&amp;gt;.log&lt;/code&gt;).</source>
          <target state="translated">Путь к файлу журнала (по умолчанию &lt;code&gt;/tmp/flow/&amp;lt;escaped root path&amp;gt;.log&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6028aa8c33369bd6d14f531cdbe045d2ca494cce" translate="yes" xml:space="preserve">
          <source>The plus sign indicates that the &lt;code&gt;who&lt;/code&gt; property is &amp;ldquo;covariant.&amp;rdquo; Using a covariant property allows us to use objects which have subtype-compatible values for that property. By default, object properties are invariant, which allow both reads and writes, but are more restrictive in the values they accept.</source>
          <target state="translated">Знак плюс указывает на то, что свойство &lt;code&gt;who&lt;/code&gt; является &amp;laquo;ковариантным&amp;raquo;. Использование ковариантного свойства позволяет нам использовать объекты, которые имеют для этого свойства значения, совместимые с подтипами. По умолчанию свойства объекта инвариантны, что позволяет выполнять как чтение, так и запись, но более ограничивают принимаемые ими значения.</target>
        </trans-unit>
        <trans-unit id="8b6e43a14a66d8e57ad3388723dad2315e2002cc" translate="yes" xml:space="preserve">
          <source>The primitive types appear in the language as either literal values.</source>
          <target state="translated">Примитивные типы появляются в языке в виде либо буквальных значений.</target>
        </trans-unit>
        <trans-unit id="fbcdf34cda6e03181b88966618eea724fde6c716" translate="yes" xml:space="preserve">
          <source>The project root directory (where your &lt;code&gt;.flowconfig&lt;/code&gt; lives) is automatically included.</source>
          <target state="translated">Корневой каталог проекта (где находится ваш &lt;code&gt;.flowconfig&lt;/code&gt; ) включается автоматически.</target>
        </trans-unit>
        <trans-unit id="2de246126745bc16c8eecf3d43ab6f8772098522" translate="yes" xml:space="preserve">
          <source>The purpose of this option is to help prepare a codebase for Flow types-first mode. See &lt;a href=&quot;#toc-seal-your-intermediate-results&quot;&gt;this section&lt;/a&gt; for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28bebee27e53966722fe139f706cf86a64136098" translate="yes" xml:space="preserve">
          <source>The reason for this is that we don&amp;rsquo;t know that &lt;code&gt;otherMethod()&lt;/code&gt; hasn&amp;rsquo;t done something to our value. Imagine the following scenario:</source>
          <target state="translated">Причина этого в том, что мы не знаем, что &lt;code&gt;otherMethod()&lt;/code&gt; ничего не сделал с нашим значением. Представьте себе следующий сценарий:</target>
        </trans-unit>
        <trans-unit id="dcdaec4a5e807c4478cc1b0eb9fd497d6c728c78" translate="yes" xml:space="preserve">
          <source>The ref function will take one and only argument which will be the element instance which is retrieved using &lt;a href=&quot;#toc-react-elementref&quot;&gt;&lt;code&gt;React.ElementRef&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt; or null since &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element&quot;&gt;React will pass null into a ref function when unmounting&lt;/a&gt;.</source>
          <target state="translated">Функция ref будет принимать один-единственный аргумент, который будет экземпляром элемента, который будет извлечен с помощью &lt;a href=&quot;#toc-react-elementref&quot;&gt; &lt;code&gt;React.ElementRef&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt; или null, поскольку &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element&quot;&gt;React передаст null в функцию ref при размонтировании&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ec9470d19e8edaa8b9faed31b8b1054cafb7447" translate="yes" xml:space="preserve">
          <source>The rule to remember with React children is that if you have no children then &lt;code&gt;props.children&lt;/code&gt; will not be set, if you have one single child then &lt;code&gt;props.children&lt;/code&gt; will be set to exactly that value, and if you have two or more children then &lt;code&gt;props.children&lt;/code&gt; will be a new array of those values.</source>
          <target state="translated">Правило, которое следует помнить с &lt;code&gt;props.children&lt;/code&gt; React, заключается в том, что если у вас нет детей, тогда props.children не будет установлен, если у вас есть один единственный дочерний &lt;code&gt;props.children&lt;/code&gt; тогда props.children будет установлен точно на это значение, а если у вас есть два или более детей, тогда &lt;code&gt;props.children&lt;/code&gt; будет новым массивом этих значений.</target>
        </trans-unit>
        <trans-unit id="fb6cae9d717814c0ee942c2f77703ca8ec47aca7" translate="yes" xml:space="preserve">
          <source>The second is when the left-hand-side could be nullish, but the short-circuiting behavior of &lt;code&gt;?.&lt;/code&gt; is sufficient to handle it anyway:</source>
          <target state="translated">Во-вторых, левая часть может быть нулевой, но короткое замыкание &lt;code&gt;?.&lt;/code&gt; в любом случае достаточно, чтобы справиться с этим:</target>
        </trans-unit>
        <trans-unit id="dd5b733400ddf864761d4b603d7eedbf4fe23de9" translate="yes" xml:space="preserve">
          <source>The solution here is to move the if check in the &lt;code&gt;forEach&lt;/code&gt;, or to assign the &lt;code&gt;age&lt;/code&gt; to an intermediate variable.</source>
          <target state="translated">Решение здесь - переместить флажок if в &lt;code&gt;forEach&lt;/code&gt; или присвоить &lt;code&gt;age&lt;/code&gt; промежуточной переменной.</target>
        </trans-unit>
        <trans-unit id="793214c4162efec809460a089d3515988a580153" translate="yes" xml:space="preserve">
          <source>The syntax of the block matches the syntax of object types and has all of the same features.</source>
          <target state="translated">Синтаксис блока соответствует синтаксису типов объектов и имеет все те же возможности.</target>
        </trans-unit>
        <trans-unit id="9cfb3fe3a8ca2679172f7460529c617ce30b2448" translate="yes" xml:space="preserve">
          <source>The type for &lt;code&gt;children&lt;/code&gt; is a function that takes in some object type and returns a &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; which is the type for any value that can be rendered by React. A &lt;code&gt;children&lt;/code&gt; function does not need to return &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt;. It could return any type, but in this case &lt;code&gt;react-router&lt;/code&gt; wants to render the result returned by the &lt;code&gt;children&lt;/code&gt; function.</source>
          <target state="translated">Тип для &lt;code&gt;children&lt;/code&gt; - это функция, которая принимает некоторый тип объекта и возвращает &lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; ,&lt;/a&gt; который является типом для любого значения, которое может быть отображено React. &lt;code&gt;children&lt;/code&gt; функция не должна возвращать &lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt; . Он может возвращать любой тип, но в этом случае &lt;code&gt;react-router&lt;/code&gt; хочет отобразить результат, возвращаемый &lt;code&gt;children&lt;/code&gt; функцией.</target>
        </trans-unit>
        <trans-unit id="e26f0c3b68e62adaf93121b472c68d0c8f76d159" translate="yes" xml:space="preserve">
          <source>The type of the &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;ref prop on React elements&lt;/a&gt;. &lt;code&gt;React.Ref&amp;lt;typeof Component&amp;gt;&lt;/code&gt; could be a string or a ref function.</source>
          <target state="translated">Тип &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;реквизита для элементов React&lt;/a&gt; . &lt;code&gt;React.Ref&amp;lt;typeof Component&amp;gt;&lt;/code&gt; может быть строкой или функцией ссылки.</target>
        </trans-unit>
        <trans-unit id="4218f62d2ad5c72e63a98ec879dc92c04a46ac00" translate="yes" xml:space="preserve">
          <source>The type of the key prop on React elements. It is a union of strings and numbers defined as:</source>
          <target state="translated">Тип ключевой опоры на реактивных элементах.Это объединение строк и чисел,определяемых как:</target>
        </trans-unit>
        <trans-unit id="67e5a93b06a1471f36d4271abfe153e052448938" translate="yes" xml:space="preserve">
          <source>The type of this function will be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d3cd96ca03492da9df4ce4513f536c1b74f86f6" translate="yes" xml:space="preserve">
          <source>The type-specific variants are useful for specifying that some types of sketchy null checks are acceptable while others should be errors/warnings. For example, if you want to allow boolean sketchy null checks (for the pattern of treating undefined optional booleans as false) but forbid other types of sketchy null checks, you can do so with this &lt;code&gt;.flowconfig&lt;/code&gt;&lt;code&gt;[lints]&lt;/code&gt; section:</source>
          <target state="translated">Варианты, зависящие от типа, полезны для указания того, что некоторые типы схематичных нулевых проверок допустимы, а другие должны быть ошибками / предупреждениями. Например, если вы хотите разрешить логические отрывочные проверки на null (для шаблона обработки неопределенных необязательных логических значений как false), но запретить другие типы отрывочных проверок на null, вы можете сделать это с помощью этого &lt;code&gt;.flowconfig&lt;/code&gt; &lt;code&gt;[lints]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6e42194738022b79f11b671ad7ae0139eab4cfde" translate="yes" xml:space="preserve">
          <source>The value itself can also be an expression:</source>
          <target state="translated">Само значение также может быть выражением:</target>
        </trans-unit>
        <trans-unit id="a9386266d754633b2348817655aa4135672d2a80" translate="yes" xml:space="preserve">
          <source>The workaround here might be to turn your object into an &lt;em&gt;unsealed object&lt;/em&gt;.</source>
          <target state="translated">Обходной путь здесь может заключаться в том, чтобы превратить ваш объект в &lt;em&gt;незапечатанный объект&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6ba1aa455c617f9487799c55083af5aee022c88f" translate="yes" xml:space="preserve">
          <source>Then Flow will instead look for the file extensions &lt;code&gt;.foo&lt;/code&gt; and &lt;code&gt;.bar&lt;/code&gt;.</source>
          <target state="translated">Тогда Flow будет искать файлы с расширениями &lt;code&gt;.foo&lt;/code&gt; и &lt;code&gt;.bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16315533799a2def071bace787cce1d7a9a11029" translate="yes" xml:space="preserve">
          <source>Then Flow will look in directories named &lt;code&gt;node_modules&lt;/code&gt; or &lt;code&gt;custom_node_modules&lt;/code&gt;.</source>
          <target state="translated">Затем Flow будет искать в каталогах с именами &lt;code&gt;node_modules&lt;/code&gt; или &lt;code&gt;custom_node_modules&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a695f40c07e9301bce62dd550ff93b6b48cf54b" translate="yes" xml:space="preserve">
          <source>Then add &lt;code&gt;flow&lt;/code&gt; to your Babel presets config.</source>
          <target state="translated">Затем добавьте &lt;code&gt;flow&lt;/code&gt; в конфигурацию пресетов Babel.</target>
        </trans-unit>
        <trans-unit id="bbfbb8a4c24c2122ec36dde61b7e1b8b853e31ea" translate="yes" xml:space="preserve">
          <source>Then to type a thunk action creator, add a return type of a &lt;code&gt;ThunkAction&lt;/code&gt; to your action creator.</source>
          <target state="translated">Затем, чтобы ввести создателя действия &lt;code&gt;ThunkAction&lt;/code&gt; , добавьте тип возврата ThunkAction в создатель действия.</target>
        </trans-unit>
        <trans-unit id="2d95f939b9b75dc6ef39e9b74bf9e89365c8618f" translate="yes" xml:space="preserve">
          <source>Then to type the action creator, just add a return type of the appropriate action.</source>
          <target state="translated">Затем,чтобы ввести создателя действия,просто добавьте обратный тип соответствующего действия.</target>
        </trans-unit>
        <trans-unit id="8d0d1639f463f57d4ca23faf1c9cada63360b1c0" translate="yes" xml:space="preserve">
          <source>Then when Flow checks the project in &lt;code&gt;/path/to/root&lt;/code&gt;, it will read and watch</source>
          <target state="translated">Затем, когда Flow проверяет проект в &lt;code&gt;/path/to/root&lt;/code&gt; , он будет читать и смотреть</target>
        </trans-unit>
        <trans-unit id="5d4c41383342278b4baf1bc8936c93b77b60516b" translate="yes" xml:space="preserve">
          <source>There are a number of different places where generic types appear in syntax.</source>
          <target state="translated">Существует множество различных мест,где в синтаксисе появляются общие типы.</target>
        </trans-unit>
        <trans-unit id="416eb69d14d7c0984bf388d12cfb15f4c4cb73f0" translate="yes" xml:space="preserve">
          <source>There are also more specific synthetic event types like &lt;code&gt;SyntheticKeyboardEvent&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;SyntheticMouseEvent&amp;lt;T&amp;gt;&lt;/code&gt;, or &lt;code&gt;SyntheticTouchEvent&amp;lt;T&amp;gt;&lt;/code&gt;. The &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; types all take a single type argument. The type of the HTML element the event handler was placed on.</source>
          <target state="translated">Существуют также более конкретные типы синтетических событий, такие как &lt;code&gt;SyntheticKeyboardEvent&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;SyntheticMouseEvent&amp;lt;T&amp;gt;&lt;/code&gt; или &lt;code&gt;SyntheticTouchEvent&amp;lt;T&amp;gt;&lt;/code&gt; . Все типы &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; принимают один аргумент типа. Тип HTML-элемента, на который был помещен обработчик события.</target>
        </trans-unit>
        <trans-unit id="1787b085e796793d008332b01f6a6da8bb5275b0" translate="yes" xml:space="preserve">
          <source>There are many different types in Flow, some of these types behave differently than others. These differences make sense for that particular type but not for others.</source>
          <target state="translated">В Flow существует много различных типов,некоторые из них ведут себя иначе,чем другие.Эти различия имеют смысл для данного конкретного типа,но не для других.</target>
        </trans-unit>
        <trans-unit id="bf3db35b680beed72ddb758d9747774831b6fb79" translate="yes" xml:space="preserve">
          <source>There are only a couple of scenarios where you might consider using &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">Есть только пара сценариев, в которых вы можете рассмотреть возможность использования &lt;code&gt;any&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6aaa00344637c45d30679cf3abd801a1db746b96" translate="yes" xml:space="preserve">
          <source>There are other cases where this happens, and they might be harder to understand. You&amp;rsquo;ll get an error like &lt;code&gt;Missing type annotation for U&lt;/code&gt; For instance, you wrote this &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiDGsB2BnALqAhgE4F4CeoAvKANoDkeNANKDQEY0C6iApgB4AOsArjRZcAcy7ouBAJYoAgkVIV8SkgDoAtnj4AKPBQB8+AJRA&quot;&gt;code&lt;/a&gt;:</source>
          <target state="translated">Есть и другие случаи, когда это происходит, и их труднее понять. Вы получите сообщение об ошибке типа &lt;code&gt;Missing type annotation for U&lt;/code&gt; Например, вы написали этот &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiDGsB2BnALqAhgE4F4CeoAvKANoDkeNANKDQEY0C6iApgB4AOsArjRZcAcy7ouBAJYoAgkVIV8SkgDoAtnj4AKPBQB8+AJRA&quot;&gt;код&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d4e04cbaf68e5bad49ef31cbab0ae229a010af35" translate="yes" xml:space="preserve">
          <source>There are some Babel plugins which will generate &lt;code&gt;PropTypes&lt;/code&gt; from Flow types such as &lt;a href=&quot;https://github.com/thejameskyle/babel-plugin-react-flow-props-to-prop-types&quot;&gt;&lt;code&gt;babel-plugin-react-flow-props-to-prop-types&lt;/code&gt;&lt;/a&gt; if you want both static and runtime checks.</source>
          <target state="translated">Есть несколько плагинов Babel, которые будут генерировать &lt;code&gt;PropTypes&lt;/code&gt; из типов Flow, таких как &lt;a href=&quot;https://github.com/thejameskyle/babel-plugin-react-flow-props-to-prop-types&quot;&gt; &lt;code&gt;babel-plugin-react-flow-props-to-prop-types&lt;/code&gt; ,&lt;/a&gt; если вам нужны как статические проверки, так и проверки во время выполнения.</target>
        </trans-unit>
        <trans-unit id="05f1bf8a574169e2b0cbcee1bdb8f70d3d1115e5" translate="yes" xml:space="preserve">
          <source>There are three forms of functions that each have their own slightly different syntax.</source>
          <target state="translated">Существует три формы функций,каждая из которых имеет свой немного отличающийся синтаксис.</target>
        </trans-unit>
        <trans-unit id="ee47d349aa7bd1ef38439d36fc72e0cdd36c9114" translate="yes" xml:space="preserve">
          <source>There are three ways which Flow can use to tell which files the user cares about.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e2987ad3c65445a4b5f525f040f6b2d00300b6c" translate="yes" xml:space="preserve">
          <source>There are two possible use cases, depending on whether an implementation file exists or not.</source>
          <target state="translated">Существует два возможных варианта использования,в зависимости от того,существует ли файл реализации или нет.</target>
        </trans-unit>
        <trans-unit id="bc6225a3f37590ec533fb885e85a5169bfedf04f" translate="yes" xml:space="preserve">
          <source>There are two potential reasons:</source>
          <target state="translated">Есть две потенциальные причины:</target>
        </trans-unit>
        <trans-unit id="fc65a65476288080ee29ba1be6fd72bb6d6711c0" translate="yes" xml:space="preserve">
          <source>There are two primary pieces of the syntax: type includes and type annotations.</source>
          <target state="translated">Существует два основных элемента синтаксиса:тип включает в себя и тип аннотации.</target>
        </trans-unit>
        <trans-unit id="dcd202d61a19f5fccfdf0c23e9bd5cbafd620669" translate="yes" xml:space="preserve">
          <source>There are two ways which Flow can use to tell which files the user cares about.</source>
          <target state="translated">Есть два способа,с помощью которых Flow может определить,о каких файлах пользователь заботится.</target>
        </trans-unit>
        <trans-unit id="fb5471e40283f41215cba92d35f5766a72606428" translate="yes" xml:space="preserve">
          <source>There is a little bit more to the definition of &lt;code&gt;React.StatelessFunctionalComponent&amp;lt;Props&amp;gt;&lt;/code&gt; for context and props.</source>
          <target state="translated">Есть немного больше об определении &lt;code&gt;React.StatelessFunctionalComponent&amp;lt;Props&amp;gt;&lt;/code&gt; для контекста и свойств.</target>
        </trans-unit>
        <trans-unit id="bb1108b33f08694a9173b9d3961f8db88797e3f6" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a special type of union in Flow known as a &amp;ldquo;disjoint union&amp;rdquo; which can be used in &lt;a href=&quot;https://flow.org/en/lang/refinements/&quot;&gt;refinements&lt;/a&gt;. These disjoint unions are made up of any number of object types which are each tagged by a single property.</source>
          <target state="translated">В Flow есть специальный тип объединения, известный как &amp;laquo;непересекающееся объединение&amp;raquo;, который можно использовать в &lt;a href=&quot;https://flow.org/en/lang/refinements/&quot;&gt;уточнениях&lt;/a&gt; . Эти непересекающиеся объединения состоят из любого количества типов объектов, каждый из которых помечен одним свойством.</target>
        </trans-unit>
        <trans-unit id="b519d9ef0909b18ff9e1aa56c6579a08789cbdf3" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a straightforward way to get around this. Store the value before calling another method and use the stored value instead. This way you can prevent the refinement from invalidating.</source>
          <target state="translated">Есть простой способ обойти это. Сохраните значение перед вызовом другого метода и используйте вместо него сохраненное значение. Таким образом вы можете предотвратить недействительность уточнения.</target>
        </trans-unit>
        <trans-unit id="5932b1e94eef91ff83b30936f3c0165f2887a0a9" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also a slightly shorter form of this syntax: &lt;code&gt;Type[]&lt;/code&gt;.</source>
          <target state="translated">Есть также несколько более короткая форма этого синтаксиса: &lt;code&gt;Type[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c33c60a371f4bbf35c4a6734c388e9cc2e847eac" translate="yes" xml:space="preserve">
          <source>These are &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp&quot;&gt;OCaml regular expressions&lt;/a&gt;.</source>
          <target state="translated">Это &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp&quot;&gt;регулярные выражения OCaml&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf1350e4fbb26ae0f7f95072f456f487f37767ce" translate="yes" xml:space="preserve">
          <source>These are &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp&quot;&gt;OCaml regular expressions&lt;/a&gt;. Use &lt;code&gt;\(&lt;/code&gt; and &lt;code&gt;\)&lt;/code&gt; (slashes required!) to create a capturing group, which you can refer to in the replacement pattern as &lt;code&gt;\1&lt;/code&gt; (up to &lt;code&gt;\9&lt;/code&gt;).</source>
          <target state="translated">Это &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp&quot;&gt;регулярные выражения OCaml&lt;/a&gt; . Используйте &lt;code&gt;\(&lt;/code&gt; и &lt;code&gt;\)&lt;/code&gt; (требуется косая черта!), Чтобы создать группу захвата, которую вы можете обозначать в шаблоне замены как &lt;code&gt;\1&lt;/code&gt; (до &lt;code&gt;\9&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="973bfa9d37cd36bbc104342639ed6decfd34c64c" translate="yes" xml:space="preserve">
          <source>These comments allow Flow to work in plain JavaScript files without any additional work.</source>
          <target state="translated">Эти комментарии позволяют Flow работать в простых JavaScript-файлах без дополнительной работы.</target>
        </trans-unit>
        <trans-unit id="d93265fc7d47ba2359b8e8723579e2877162a149" translate="yes" xml:space="preserve">
          <source>These regular expressions match against absolute paths. They probably should start with &lt;code&gt;.*&lt;/code&gt;</source>
          <target state="translated">Эти регулярные выражения соответствуют абсолютным путям. Вероятно, им стоит начать с &lt;code&gt;.*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e82167070fabc30781330eea12f26f96e5cc3459" translate="yes" xml:space="preserve">
          <source>These special files use the same &lt;code&gt;.js&lt;/code&gt; extension as normal JS code, but they are placed in a directory called &lt;code&gt;flow-typed&lt;/code&gt; in the root directory of your project. Placement in this directory tells Flow to interpret them as libdefs rather than normal JS files.</source>
          <target state="translated">Эти специальные файлы используют то же расширение &lt;code&gt;.js&lt;/code&gt; , что и обычный код JS, но они помещаются в каталог, называемый &lt;code&gt;flow-typed&lt;/code&gt; , в корневом каталоге вашего проекта. Размещение в этом каталоге указывает Flow интерпретировать их как файлы libdef, а не как обычные файлы JS.</target>
        </trans-unit>
        <trans-unit id="420387e05d0ef5c191c2b528df67882573697852" translate="yes" xml:space="preserve">
          <source>These three are the most common categories of types. They will make up the majority of the types you&amp;rsquo;ll be writing.</source>
          <target state="translated">Эти три самые распространенные категории типов. Они составят большинство типов, которые вы будете писать.</target>
        </trans-unit>
        <trans-unit id="521ca96243c563b5695a0817345b1aaac530fbea" translate="yes" xml:space="preserve">
          <source>These type aliases can be used anywhere a type can be used.</source>
          <target state="translated">Эти псевдонимы типа могут быть использованы в любом месте.</target>
        </trans-unit>
        <trans-unit id="03c735f166579e7b6a2b1df8b0b57996603576f1" translate="yes" xml:space="preserve">
          <source>These types are all exported as named type exports from the &lt;code&gt;react&lt;/code&gt; module. If you want to access them as members on the &lt;code&gt;React&lt;/code&gt; object (e.g. &lt;a href=&quot;#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#toc-react-statelessfunctionalcomponent&quot;&gt;&lt;code&gt;React.StatelessFunctionalComponent&lt;/code&gt;&lt;/a&gt;) and you are importing React as an ES module then you should import &lt;code&gt;React&lt;/code&gt; as a namespace:</source>
          <target state="translated">Все эти типы экспортируются как экспорт именованных типов из модуля &lt;code&gt;react&lt;/code&gt; . Если вы хотите получить к ним доступ как к членам объекта &lt;code&gt;React&lt;/code&gt; (например, &lt;a href=&quot;#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#toc-react-statelessfunctionalcomponent&quot;&gt; &lt;code&gt;React.StatelessFunctionalComponent&lt;/code&gt; &lt;/a&gt; ) и импортируете React как модуль ES, вам следует импортировать &lt;code&gt;React&lt;/code&gt; как пространство имен:</target>
        </trans-unit>
        <trans-unit id="38dbce068fe67847b4312ef7a49844b1a3730edb" translate="yes" xml:space="preserve">
          <source>These unknown types are less common, but are still useful at times.</source>
          <target state="translated">Эти неизвестные типы встречаются реже,но временами приносят пользу.</target>
        </trans-unit>
        <trans-unit id="630fbbe3db84f8cd1f22f033444bd46fd4f788d9" translate="yes" xml:space="preserve">
          <source>These values can be used in many different ways:</source>
          <target state="translated">Эти значения могут быть использованы различными способами:</target>
        </trans-unit>
        <trans-unit id="acee363f8ecdca8ebcbfe3c36617f3a858f460fa" translate="yes" xml:space="preserve">
          <source>These wrapper objects are rarely used.</source>
          <target state="translated">Эти оберточные объекты используются редко.</target>
        </trans-unit>
        <trans-unit id="0ecb01f38d4891f3ba605fe10abbc133a33eebcb" translate="yes" xml:space="preserve">
          <source>Things to keep in mind:</source>
          <target state="translated">Вещи,которые нужно иметь в виду:</target>
        </trans-unit>
        <trans-unit id="25df2f7528015bf66ff8cb5856b46ca9f89a989e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;[declarations]&lt;/code&gt; section will parse in declaration mode:</source>
          <target state="translated">Этот раздел &lt;code&gt;[declarations]&lt;/code&gt; будет проанализирован в режиме декларации:</target>
        </trans-unit>
        <trans-unit id="633b00a02de45953dce9e17ff82080b18f32ddce" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;[ignore]&lt;/code&gt; section will ignore:</source>
          <target state="translated">Этот раздел &lt;code&gt;[ignore]&lt;/code&gt; будет игнорировать:</target>
        </trans-unit>
        <trans-unit id="881b9060a283396b0ef0fc92c8d4d847c624170a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;[untyped]&lt;/code&gt; section will parse:</source>
          <target state="translated">Этот &lt;code&gt;[untyped]&lt;/code&gt; раздел будет анализировать:</target>
        </trans-unit>
        <trans-unit id="6523434d73a5cea939dbb47f88e915c46aa3c5df" translate="yes" xml:space="preserve">
          <source>This affects Linux only.</source>
          <target state="translated">Это касается только Linux.</target>
        </trans-unit>
        <trans-unit id="543aa46e91339d316364681d2b7a939cdad920b8" translate="yes" xml:space="preserve">
          <source>This allows you to pass a less specific type in place of that property.</source>
          <target state="translated">Это позволяет передать менее специфический тип вместо этого свойства.</target>
        </trans-unit>
        <trans-unit id="1766dd7d0a89406504a02b5ace1d77e4b69c5963" translate="yes" xml:space="preserve">
          <source>This allows you to pass a more specific type in place of that property.</source>
          <target state="translated">Это позволяет передать более конкретный тип вместо этого свойства.</target>
        </trans-unit>
        <trans-unit id="2bd174f439abda4ebf248fb0e156219e91c6b759" translate="yes" xml:space="preserve">
          <source>This can be especially useful for referring to the type of React props, or, even the entire &lt;code&gt;props&lt;/code&gt; type itself.</source>
          <target state="translated">Это может быть особенно полезно для ссылки типа Реагировать реквизит, или даже весь &lt;code&gt;props&lt;/code&gt; типа себя.</target>
        </trans-unit>
        <trans-unit id="7b5bf94cd27d17a08f16ee047fe0e258d2090c51" translate="yes" xml:space="preserve">
          <source>This case happens often when you use &lt;code&gt;array.map()&lt;/code&gt; such as in:</source>
          <target state="translated">Этот случай часто случается, когда вы используете &lt;code&gt;array.map()&lt;/code&gt; например:</target>
        </trans-unit>
        <trans-unit id="f0b87f03b6d241cb8b45f84bd4bf0506c5abe6b1" translate="yes" xml:space="preserve">
          <source>This command first starts a background process that will check all &lt;a href=&quot;#toc-prepare-your-code-for-flow&quot;&gt;Flow files&lt;/a&gt; for errors. The background process continues running, monitoring changes to your code and checking those changes incrementally for errors.</source>
          <target state="translated">Эта команда сначала запускает фоновый процесс, который проверяет все &lt;a href=&quot;#toc-prepare-your-code-for-flow&quot;&gt;файлы Flow на&lt;/a&gt; наличие ошибок. Фоновый процесс продолжает работать, отслеживая изменения в вашем коде и постепенно проверяя эти изменения на наличие ошибок.</target>
        </trans-unit>
        <trans-unit id="3d875274c3b689e4f7ad033af88961c28bd2f54a" translate="yes" xml:space="preserve">
          <source>This compiles to: &lt;code&gt;React.createElement(MyComponent, {}, '// some comment...', 42)&lt;/code&gt;. See how the comment is included in the element&amp;rsquo;s children? In this case &lt;code&gt;props.children&lt;/code&gt; would be &lt;code&gt;['// some comment...', 42]&lt;/code&gt; which includes the comment. To write comments in JSX use the following syntax:</source>
          <target state="translated">Это компилируется в: &lt;code&gt;React.createElement(MyComponent, {}, '// some comment...', 42)&lt;/code&gt; . Видите, как комментарий включается в дочерние элементы элемента? В этом случае &lt;code&gt;props.children&lt;/code&gt; будет &lt;code&gt;['// some comment...', 42]&lt;/code&gt; который включает комментарий. Для написания комментариев в JSX используйте следующий синтаксис:</target>
        </trans-unit>
        <trans-unit id="1981415185918a76b00cd452a5e0eb6fd87253c8" translate="yes" xml:space="preserve">
          <source>This compiles to: &lt;code&gt;React.createElement(MyComponent, {}, 42, '  ')&lt;/code&gt;. (With the spaces!) See how the spaces show up as part of the children? In this case &lt;code&gt;props.children&lt;/code&gt; would be &lt;code&gt;[42, '  ']&lt;/code&gt; and &lt;em&gt;not&lt;/em&gt; the number 42. However, the following is fine:</source>
          <target state="translated">Это компилируется в: &lt;code&gt;React.createElement(MyComponent, {}, 42, ' ')&lt;/code&gt; . (С пробелами!) Видите, как пробелы проявляются как часть детей? В этом случае &lt;code&gt;props.children&lt;/code&gt; будет &lt;code&gt;[42, ' ']&lt;/code&gt; а &lt;em&gt;не&lt;/em&gt; числом 42. Однако следующее нормально:</target>
        </trans-unit>
        <trans-unit id="734dbfe930904c1dff5464c3868a3c58b214bbf9" translate="yes" xml:space="preserve">
          <source>This flag is in the form of a normal JavaScript comment annotated with &lt;code&gt;@flow&lt;/code&gt;. The Flow background process gathers all the files with this flag and uses the type information available from all of these files to ensure consistency and error free programming.</source>
          <target state="translated">Этот флаг имеет форму обычного комментария JavaScript, &lt;code&gt;@flow&lt;/code&gt; . Фоновый процесс Flow собирает все файлы с этим флагом и использует информацию о типах, доступную из всех этих файлов, для обеспечения согласованности и безошибочного программирования.</target>
        </trans-unit>
        <trans-unit id="e8107dcd86e50a45fb0aff78e434d3e405ffe634" translate="yes" xml:space="preserve">
          <source>This follows the same rule that when you pass in a single child then &lt;code&gt;props.children&lt;/code&gt; will be &lt;em&gt;exactly&lt;/em&gt; that value. Even though &lt;code&gt;[1, 2]&lt;/code&gt; is an array it is a single value and so &lt;code&gt;props.children&lt;/code&gt; will be &lt;em&gt;exactly&lt;/em&gt; that value. That is to say &lt;code&gt;props.children&lt;/code&gt; will be the array &lt;code&gt;[1, 2]&lt;/code&gt; and not an array of arrays.</source>
          <target state="translated">Это следует тому же правилу, что при передаче одного дочернего &lt;code&gt;props.children&lt;/code&gt; будет &lt;em&gt;точно&lt;/em&gt; таким же значением. Несмотря на то, что &lt;code&gt;[1, 2]&lt;/code&gt; является массивом, это одно значение, поэтому &lt;code&gt;props.children&lt;/code&gt; будет &lt;em&gt;именно&lt;/em&gt; этим значением. То есть &lt;code&gt;props.children&lt;/code&gt; будет массивом &lt;code&gt;[1, 2]&lt;/code&gt; а не массивом массивов.</target>
        </trans-unit>
        <trans-unit id="d7ef0baedb6b23a6e6c0bc9c81182d27e5e3dc1d" translate="yes" xml:space="preserve">
          <source>This guide will teach you the syntax and semantics of all the different types you can have in Flow.</source>
          <target state="translated">Это руководство научит вас синтаксису и семантике всех различных типов,которые вы можете иметь в Flow.</target>
        </trans-unit>
        <trans-unit id="096c3c9fc415cf70866aa9adcd243f084dfc276d" translate="yes" xml:space="preserve">
          <source>This includes the code into the syntax that Flow sees.</source>
          <target state="translated">Это включает код в синтаксис,который видит Flow.</target>
        </trans-unit>
        <trans-unit id="d9fb28a17538a9106a3ad6a6bed152242ff6e4d8" translate="yes" xml:space="preserve">
          <source>This is Flow&amp;rsquo;s most abstract representation of a React component, and is most useful for writing HOCs and library definitions.</source>
          <target state="translated">Это наиболее абстрактное представление компонента React в Flow, которое наиболее полезно для написания HOC и определений библиотек.</target>
        </trans-unit>
        <trans-unit id="9af90c0ecae6766788f603b8275d9514e3979ca9" translate="yes" xml:space="preserve">
          <source>This is a basic template for what your HOCs might look like. At runtime, this HOC doesn&amp;rsquo;t do anything at all. Let&amp;rsquo;s take a look at some more complex examples.</source>
          <target state="translated">Это базовый шаблон того, как могут выглядеть ваши HOC. Во время выполнения этот HOC вообще ничего не делает. Давайте рассмотрим несколько более сложных примеров.</target>
        </trans-unit>
        <trans-unit id="c365f2918438c7a6e1888b46e0b930bd53745fff" translate="yes" xml:space="preserve">
          <source>This is a kind of subtyping commonly referred to as &amp;ldquo;width subtyping&amp;rdquo; because a type that is &amp;ldquo;wider&amp;rdquo; (i.e., has more properties) is a subtype of a narrower type.</source>
          <target state="translated">Это своего рода подтип, обычно называемый &amp;laquo;подтипом ширины&amp;raquo;, потому что тип, который &amp;laquo;шире&amp;raquo; (т. Е. Имеет больше свойств), является подтипом более узкого типа.</target>
        </trans-unit>
        <trans-unit id="75b065150ca9eda7d9b645bb02ec9b648bf937bd" translate="yes" xml:space="preserve">
          <source>This is a union of a class component or a stateless functional component. This is the type you want to use for functions that receive or return React components such as higher-order components or other utilities.</source>
          <target state="translated">Это объединение классового компонента или функционального компонента без гражданства.Это тип,который вы хотите использовать для функций,которые принимают или возвращают React компоненты,такие как компоненты более высокого порядка или другие утилиты.</target>
        </trans-unit>
        <trans-unit id="eb111ed813f5032a53f03d0b631da3f19b265167" translate="yes" xml:space="preserve">
          <source>This is also okay because if something is using &lt;code&gt;SubClass&lt;/code&gt; as if it were a &lt;code&gt;BaseClass&lt;/code&gt; they would still have access to the same interface as before because &lt;code&gt;SanFrancisco&lt;/code&gt; is just a &lt;code&gt;City&lt;/code&gt; with a little more information.</source>
          <target state="translated">Это также нормально, потому что если что-то использует &lt;code&gt;SubClass&lt;/code&gt; , как если бы это был &lt;code&gt;BaseClass&lt;/code&gt; , они все равно будут иметь доступ к тому же интерфейсу, что и раньше, потому что &lt;code&gt;SanFrancisco&lt;/code&gt; - это просто &lt;code&gt;City&lt;/code&gt; с немного дополнительной информацией.</target>
        </trans-unit>
        <trans-unit id="ed9084ae2d3a6d3909814247a0a9d2fe5955a81d" translate="yes" xml:space="preserve">
          <source>This is an error because objects are mutable. The value referenced by the &lt;code&gt;employee&lt;/code&gt; variable is the same as the value referenced by the &lt;code&gt;person&lt;/code&gt; variable.</source>
          <target state="translated">Это ошибка, потому что объекты изменяемы. Значение, на которое ссылается переменная &lt;code&gt;employee&lt;/code&gt; совпадает со значением, на которое ссылается переменная &lt;code&gt;person&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b9e89f0566afa9b997d9c3c388578a1bf739bfd" translate="yes" xml:space="preserve">
          <source>This is an error in Flow because if you are expecting a &lt;code&gt;SanFrancisco&lt;/code&gt; and you get a &lt;code&gt;City&lt;/code&gt; you could be using something that only exists on &lt;code&gt;SanFrancisco&lt;/code&gt; which would cause an error at runtime.</source>
          <target state="translated">Это ошибка в Flow, потому что, если вы ожидаете &lt;code&gt;SanFrancisco&lt;/code&gt; и получаете &lt;code&gt;City&lt;/code&gt; , вы можете использовать что-то, что существует только в &lt;code&gt;SanFrancisco&lt;/code&gt; , что может вызвать ошибку во время выполнения.</target>
        </trans-unit>
        <trans-unit id="56976d17f40e185b38c5c6efa84d2af088f0b974" translate="yes" xml:space="preserve">
          <source>This is because classes in Flow are &lt;a href=&quot;https://flow.org/en/lang/nominal-structural&quot;&gt;nominally typed&lt;/a&gt;.</source>
          <target state="translated">Это потому, что классы в Flow &lt;a href=&quot;https://flow.org/en/lang/nominal-structural&quot;&gt;номинально типизированы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="127badd88c854dba7d3f79ae45c90e45e0bab65a" translate="yes" xml:space="preserve">
          <source>This is because in Flow it is okay to pass an object value with more properties than the object type expects (because of width subtyping).</source>
          <target state="translated">Это происходит потому,что в Flow можно передать значение объекта с большим количеством свойств,чем ожидает тип объекта (из-за подтипирования ширины).</target>
        </trans-unit>
        <trans-unit id="a696e7fa8715b1a73c06f5c45c3a6a89c88aadac" translate="yes" xml:space="preserve">
          <source>This is different from the &lt;code&gt;[ignore]&lt;/code&gt; config section that causes matching files to be ignored by the module resolver, which inherently makes them un-typechecked, and also unresolvable by &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;. When ignored &lt;code&gt;[libs]&lt;/code&gt; must then be specified for each &lt;code&gt;import&lt;/code&gt; using &lt;code&gt;flow-typed&lt;/code&gt;, which may not always be desired.</source>
          <target state="translated">Это отличается от раздела конфигурации &lt;code&gt;[ignore]&lt;/code&gt; ,в котором совпадающие файлы игнорируются преобразователем модуля, что по своей сути делает их не проверяемыми по типу, а также неразрешимыми при &lt;code&gt;import&lt;/code&gt; или &lt;code&gt;require&lt;/code&gt; . В случае игнорирования &lt;code&gt;[libs]&lt;/code&gt; должны быть указаны для каждого &lt;code&gt;import&lt;/code&gt; с использованием &lt;code&gt;flow-typed&lt;/code&gt; , что не всегда может быть желательным.</target>
        </trans-unit>
        <trans-unit id="a3e3b48d7024605ecf73a60b4a059e305833ff81" translate="yes" xml:space="preserve">
          <source>This is extremely useful for expressing the return type of functions that manipulate objects values. You could use a similar approach (for instance) to provide the return type of bluebird&amp;rsquo;s &lt;a href=&quot;http://bluebirdjs.com/docs/api/promise.props.html&quot;&gt;&lt;code&gt;Promise.props&lt;/code&gt;&lt;/a&gt; function, which is like &lt;code&gt;Promise.all&lt;/code&gt; but takes an object as input.</source>
          <target state="translated">Это чрезвычайно полезно для выражения возвращаемого типа функций, которые манипулируют значениями объектов. Вы можете использовать аналогичный подход (например) для предоставления возвращаемого типа функции &lt;a href=&quot;http://bluebirdjs.com/docs/api/promise.props.html&quot;&gt; &lt;code&gt;Promise.props&lt;/code&gt; &lt;/a&gt; , которая похожа на &lt;code&gt;Promise.all&lt;/code&gt; , но принимает объект в качестве входных данных.</target>
        </trans-unit>
        <trans-unit id="60dfb0118bc43aa84388f7d66bc4c2be8af7089f" translate="yes" xml:space="preserve">
          <source>This is okay because if something else in your program is using &lt;code&gt;SubClass&lt;/code&gt; as if it were a &lt;code&gt;BaseClass&lt;/code&gt;, it would still be using a &lt;code&gt;City&lt;/code&gt; and wouldn&amp;rsquo;t cause any issues.</source>
          <target state="translated">Это нормально, потому что если что-то еще в вашей программе использует &lt;code&gt;SubClass&lt;/code&gt; , как если бы это был &lt;code&gt;BaseClass&lt;/code&gt; , он все равно будет использовать &lt;code&gt;City&lt;/code&gt; и не вызовет никаких проблем.</target>
        </trans-unit>
        <trans-unit id="def5148d9c559d37a047e98dc2513022553f61be" translate="yes" xml:space="preserve">
          <source>This is perfectly fine because if we pass in a more specific type we&amp;rsquo;ll still have all the information we need to be compatible with &lt;code&gt;Noun&lt;/code&gt;.</source>
          <target state="translated">Это прекрасно, потому что если мы передадим более конкретный тип, у нас все равно будет вся информация, необходимая для совместимости с &lt;code&gt;Noun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="424b976babef7901da66b2db61ee539c2a0be62a" translate="yes" xml:space="preserve">
          <source>This is the type of a React stateless functional component.</source>
          <target state="translated">Это тип функционального компонента &quot;Реакция без гражданства&quot;.</target>
        </trans-unit>
        <trans-unit id="b2b862b3fcdd9450bc624dc8b8cf55e1f701d1ad" translate="yes" xml:space="preserve">
          <source>This is unsafe and not recommended. But it&amp;rsquo;s sometimes useful when you are doing something with a value which is very difficult or impossible to type and want to make sure that the result has the desired type.</source>
          <target state="translated">Это небезопасно и не рекомендуется. Но иногда это полезно, когда вы делаете что-то со значением, которое очень сложно или невозможно ввести, и хотите убедиться, что результат имеет желаемый тип.</target>
        </trans-unit>
        <trans-unit id="35aa78e533f2578f7e162a36de338a1f47f6c0b2" translate="yes" xml:space="preserve">
          <source>This is useful when you need to use a read-only version of an object type you&amp;rsquo;ve already defined, without manually having to re-define and annotate each key as read-only. For example:</source>
          <target state="translated">Это полезно, когда вам нужно использовать версию объекта только для чтения, которую вы уже определили, без необходимости вручную переопределять и аннотировать каждый ключ как доступный только для чтения. Например:</target>
        </trans-unit>
        <trans-unit id="f4cb01bc5bdd818c1407e6cedc026d2b0b09c1ad" translate="yes" xml:space="preserve">
          <source>This is very handy, but sometimes you need to access the enum definition at runtime (i.e. at a value level).</source>
          <target state="translated">Это очень удобно,но иногда необходимо получить доступ к определению перечисления во время выполнения (т.е.на уровне значений).</target>
        </trans-unit>
        <trans-unit id="54f3db6a2015884e8473b3172c31c08a869daab0" translate="yes" xml:space="preserve">
          <source>This is where &lt;a href=&quot;../types#toc-react-config&quot;&gt;&lt;code&gt;React.Config&amp;lt;Props, DefaultProps&amp;gt;&lt;/code&gt;&lt;/a&gt; comes in handy! We can use the type for Props and DefaultProps to calculate the &lt;code&gt;Config&lt;/code&gt; type for our component.</source>
          <target state="translated">Вот где &lt;a href=&quot;../types#toc-react-config&quot;&gt; &lt;code&gt;React.Config&amp;lt;Props, DefaultProps&amp;gt;&lt;/code&gt; &lt;/a&gt; ! Мы можем использовать тип для Props и DefaultProps, чтобы вычислить тип &lt;code&gt;Config&lt;/code&gt; для нашего компонента.</target>
        </trans-unit>
        <trans-unit id="21ae5e6ce6468f7ff3f32ccfa0dd3f8fb2f7bcea" translate="yes" xml:space="preserve">
          <source>This is where &lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt; comes in handy.</source>
          <target state="translated">Вот где &lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee856278c549261688abdbd19d4ddec7e5efdc46" translate="yes" xml:space="preserve">
          <source>This lint setting is ignored when &lt;code&gt;exact_by_default&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Этот параметр lint игнорируется, если для параметра &lt;code&gt;exact_by_default&lt;/code&gt; установлено значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a70889c6b7d22baa7cf64ab4c9b4c3c93d6d9191" translate="yes" xml:space="preserve">
          <source>This makes Flow treat &lt;code&gt;require('image!foo.jpg')&lt;/code&gt; as if it were &lt;code&gt;require('ImageStub')&lt;/code&gt;.</source>
          <target state="translated">Это заставляет Flow обрабатывать &lt;code&gt;require('image!foo.jpg')&lt;/code&gt; как если бы это было &lt;code&gt;require('ImageStub')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e23feb9278c999088a311838ae5b7031bb5b5bf1" translate="yes" xml:space="preserve">
          <source>This makes it clear to the reader that &lt;code&gt;bar&lt;/code&gt; is not a potentially nullish property.</source>
          <target state="translated">Это дает понять читателю, что &lt;code&gt;bar&lt;/code&gt; не является потенциально нулевым свойством.</target>
        </trans-unit>
        <trans-unit id="76437fdbf44079b1c571bd4124ab2ff68199ec3a" translate="yes" xml:space="preserve">
          <source>This means that a shorter tuple can&amp;rsquo;t be used in place of a longer one.</source>
          <target state="translated">Это означает, что более короткий кортеж нельзя использовать вместо более длинного.</target>
        </trans-unit>
        <trans-unit id="ebff5f8c600e3fd9834aa943d918c1bfbd8d2dbe" translate="yes" xml:space="preserve">
          <source>This means that reads from unsealed objects with no matching writes are never checked. This is an unsafe behavior of Flow which may be improved in the future.</source>
          <target state="translated">Это означает,что чтение с незапечатанных объектов без совпадающих записей никогда не проверяется.Это небезопасное поведение Flow,которое может быть улучшено в будущем.</target>
        </trans-unit>
        <trans-unit id="3bf9058b929ae73030823387d719318f0032a9fd" translate="yes" xml:space="preserve">
          <source>This means that the following 2 types are equivalent:</source>
          <target state="translated">Это означает,что следующие 2 типа эквивалентны:</target>
        </trans-unit>
        <trans-unit id="6784af09c850d7330fc9ffa9c72f9fa8a86cc84a" translate="yes" xml:space="preserve">
          <source>This often means figuring out if the value you are passing in is a subtype of the value you are expecting.</source>
          <target state="translated">Это часто означает выяснение,является ли передаваемое вами значение подтипом ожидаемого значения.</target>
        </trans-unit>
        <trans-unit id="2cd8bc2873ab259581a052bdf16376541801c36c" translate="yes" xml:space="preserve">
          <source>This option configures the maximum possible size for the shared heap. You should most likely not need to configure this, as it doesn&amp;rsquo;t really affect how much RSS Flow uses. However, if you are working on a massive codebase you might see the following error after init: &amp;ldquo;Heap init size is too close to max heap size; GC will never get triggered!&amp;rdquo; In this case, you may need to increase the size of the heap.</source>
          <target state="translated">Этот параметр настраивает максимально возможный размер общей кучи. Скорее всего, вам не нужно настраивать это, поскольку на самом деле это не влияет на использование RSS-потока. Однако, если вы работаете с массивной кодовой базой, вы можете увидеть следующую ошибку после инициализации: &amp;laquo;Размер инициализации кучи слишком близок к максимальному размеру кучи; Сборщик мусора никогда не сработает! &amp;raquo; В этом случае вам может потребоваться увеличить размер кучи.</target>
        </trans-unit>
        <trans-unit id="b218d95c59f706fc5a5e4f4c250e3a7ed23a95c4" translate="yes" xml:space="preserve">
          <source>This option is set to &lt;code&gt;true&lt;/code&gt; by default, since it is implied by &lt;a href=&quot;#toc-types-first-boolean&quot;&gt;&lt;code&gt;types_first&lt;/code&gt;&lt;/a&gt;, but the option is useful on its own when upgrading a project from classic mode to types-first mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9586cb7b0444ddcbaf378ece59924e71eed799e4" translate="yes" xml:space="preserve">
          <source>This option lets you alias &lt;code&gt;any&lt;/code&gt; with a given string. This is useful for explaining why you&amp;rsquo;re using &lt;code&gt;any&lt;/code&gt;. For example, let&amp;rsquo;s say you sometimes want to sometimes use &lt;code&gt;any&lt;/code&gt; to suppress an error and sometimes to mark a TODO. Your code might look like</source>
          <target state="translated">Эта опция позволяет вам использовать псевдоним &lt;code&gt;any&lt;/code&gt; с данной строкой. Это полезно для объяснения , почему вы используете &lt;code&gt;any&lt;/code&gt; . Например, предположим, что иногда вы хотите иногда использовать &lt;code&gt;any&lt;/code&gt; чтобы подавить ошибку, а иногда и пометить TODO. Ваш код может выглядеть так</target>
        </trans-unit>
        <trans-unit id="36407b4a8671f76cf48e67ecd38443356cf43c1d" translate="yes" xml:space="preserve">
          <source>This pattern is also not limited to function children. You could also pass in arbitrary object or class types.</source>
          <target state="translated">Эта модель также не ограничивается функциями детей.Можно также передавать произвольные типы объектов или классов.</target>
        </trans-unit>
        <trans-unit id="8daebbe8ae6fc42b982d8e4fe22459a7a10cd94c" translate="yes" xml:space="preserve">
          <source>This represents any node that can be rendered in a React application. &lt;code&gt;React.Node&lt;/code&gt; can be null, a boolean, a number, a string, a React element, or an array of any of those types recursively.</source>
          <target state="translated">Он представляет любой узел, который может быть отображен в приложении React. &lt;code&gt;React.Node&lt;/code&gt; может быть нулевым, логическим, числом, строкой, элементом React или массивом любого из этих типов рекурсивно.</target>
        </trans-unit>
        <trans-unit id="752249d3acac833c3c21ce430f38863e1937ed27" translate="yes" xml:space="preserve">
          <source>This syntax is also available in a &lt;code&gt;flow-include&lt;/code&gt; form.</source>
          <target state="translated">Этот синтаксис также доступен в форме &lt;code&gt;flow-include&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b31f92efc0a4da4dd28fb6304800cf7cd7fbb9c" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;PI&lt;/code&gt; global variable &amp;ndash; which, in this case, is a &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">Это сообщает Flow, что любой код в проекте может ссылаться на глобальную переменную &lt;code&gt;PI&lt;/code&gt; , которая в данном случае является &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f16bca30984be4eadbc92268c71095b6f69d5a4" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;URL&lt;/code&gt; global class. Note that this class definition does not have any implementation details &amp;ndash; it exclusively defines the interface of the class.</source>
          <target state="translated">Это сообщает Flow, что любой код в проекте может ссылаться на глобальный класс &lt;code&gt;URL&lt;/code&gt; . Обратите внимание, что это определение класса не содержит каких-либо деталей реализации - оно определяет исключительно интерфейс класса.</target>
        </trans-unit>
        <trans-unit id="fe10f9e40b8844cde008f22e6f7e27a41dd5807d" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;UserID&lt;/code&gt; global type &amp;ndash; which, in this case, is just an alias for &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">Это сообщает Flow, что любой код в проекте может ссылаться на глобальный тип &lt;code&gt;UserID&lt;/code&gt; , который в данном случае является просто псевдонимом для &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b06e9eb45a05735715e1d1b65c57610ee02c78b2" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;foo&lt;/code&gt; global function, and that the function takes one argument (a &lt;code&gt;number&lt;/code&gt;) and it returns a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Это сообщает Flow, что любой код в проекте может ссылаться на глобальную функцию &lt;code&gt;foo&lt;/code&gt; , и что функция принимает один аргумент ( &lt;code&gt;number&lt;/code&gt; ) и возвращает &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6bab6dcb6b25f93bc93c3ef139cb0898176b837" translate="yes" xml:space="preserve">
          <source>This utility has been deprecated and should be avoided. See &lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-deprecated-type&quot;&gt;here&lt;/a&gt; for details.</source>
          <target state="translated">Эта утилита устарела, и ее следует избегать. Подробности смотрите &lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-deprecated-type&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b74c252b0eeaacbb897eb419ddf06e190d869384" translate="yes" xml:space="preserve">
          <source>This utility has been deprecated and should be avoided. See &lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-deprecated-utility&quot;&gt;here&lt;/a&gt; for details.</source>
          <target state="translated">Эта утилита устарела, и ее следует избегать. Подробности смотрите &lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-deprecated-utility&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cabd9148684b1aa762ff2b690b8f720e71dd5acb" translate="yes" xml:space="preserve">
          <source>This way you avoid duplicating the properties that happen to have a default value.</source>
          <target state="translated">Таким образом,вы избегаете дублирования свойств,которые случайно имеют значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="22fe37b0969c2ab3810a8157bfb87e3e61565f27" translate="yes" xml:space="preserve">
          <source>This way you can keep the behavior of generics while only allowing certain types to be used.</source>
          <target state="translated">Таким образом,вы можете сохранить поведение дженериков,позволяя использовать только определенные типы.</target>
        </trans-unit>
        <trans-unit id="d06c742de148aa21dfa2ce9950e849bcb9ab4c64" translate="yes" xml:space="preserve">
          <source>This will give you information about everything that flow can do. Running this command should print something like this:</source>
          <target state="translated">Это даст вам информацию обо всем,что может сделать поток.Выполнение этой команды должно напечатать что-то подобное:</target>
        </trans-unit>
        <trans-unit id="c5358194d5e312667901904699178d180ad0d876" translate="yes" xml:space="preserve">
          <source>This would be the same as including a type annotation inside an include comment.</source>
          <target state="translated">Это будет то же самое,что включить типовую аннотацию в комментарий.</target>
        </trans-unit>
        <trans-unit id="80babb7d0ff0eda4573ad401ec556fbf50e83b89" translate="yes" xml:space="preserve">
          <source>To add a type for state to your React class component then create a new object type, in the example below we name it &lt;code&gt;State&lt;/code&gt;, and pass it as the second type argument to &lt;code&gt;React.Component&lt;/code&gt;.</source>
          <target state="translated">Чтобы добавить тип для состояния в компонент класса React, затем создайте новый тип объекта, в приведенном ниже примере мы назовем его &lt;code&gt;State&lt;/code&gt; и передадим его как второй аргумент типа в &lt;code&gt;React.Component&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46cc112d13261a13154b6cfac4e2d48bf5063881" translate="yes" xml:space="preserve">
          <source>To create an array type you can use &lt;code&gt;Array&amp;lt;Type&amp;gt;&lt;/code&gt; type where &lt;code&gt;Type&lt;/code&gt; is the type of elements in the array. For example, to create a type for an array of numbers you use &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Чтобы создать тип массива, вы можете использовать &lt;code&gt;Array&amp;lt;Type&amp;gt;&lt;/code&gt; где &lt;code&gt;Type&lt;/code&gt; - это тип элементов в массиве. Например, чтобы создать тип для массива чисел, вы используете &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8dd0d93865b9bfacde3e4affb1eb92fd379b6bf0" translate="yes" xml:space="preserve">
          <source>To declare a global class that should be accessible throughout your project, use the &lt;code&gt;declare class&lt;/code&gt; syntax in a libdef file:</source>
          <target state="translated">Чтобы объявить глобальный класс, который должен быть доступен в вашем проекте, используйте синтаксис &lt;code&gt;declare class&lt;/code&gt; в файле libdef:</target>
        </trans-unit>
        <trans-unit id="2c05553bc81af5c0b4f02184bd805aba0fa865c0" translate="yes" xml:space="preserve">
          <source>To declare a global function that should be accessible throughout your project, use the &lt;code&gt;declare function&lt;/code&gt; syntax in a libdef file:</source>
          <target state="translated">Чтобы объявить глобальную функцию, которая должна быть доступна во всем вашем проекте, используйте синтаксис &lt;code&gt;declare function&lt;/code&gt; в файле libdef:</target>
        </trans-unit>
        <trans-unit id="3d8d4cb10458061c2bc75c04590a96a2ed068bd5" translate="yes" xml:space="preserve">
          <source>To declare a global type that should be accessible throughout your project, use the &lt;code&gt;declare type&lt;/code&gt; syntax in a libdef file:</source>
          <target state="translated">Чтобы объявить глобальный тип, который должен быть доступен во всем проекте, используйте синтаксис &lt;code&gt;declare type&lt;/code&gt; в файле libdef:</target>
        </trans-unit>
        <trans-unit id="d38d878e01cad40728f252774b0c25def7d4cb78" translate="yes" xml:space="preserve">
          <source>To declare a global variable that should be accessible throughout your project, use the &lt;code&gt;declare var&lt;/code&gt; syntax in a libdef file:</source>
          <target state="translated">Чтобы объявить глобальную переменную, которая должна быть доступна в вашем проекте, используйте синтаксис &lt;code&gt;declare var&lt;/code&gt; в файле libdef:</target>
        </trans-unit>
        <trans-unit id="f1875d662019d803a3d158d296ddb77c1752c55d" translate="yes" xml:space="preserve">
          <source>To explicitly specify the type of a context value, pass a type parameter to &lt;code&gt;createContext&lt;/code&gt;:</source>
          <target state="translated">Чтобы явно указать тип значения контекста, передайте параметр типа в &lt;code&gt;createContext&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dc65e5d43387ac143a42fd49169c9f382ad9e6e7" translate="yes" xml:space="preserve">
          <source>To find out more about the CLI just type:</source>
          <target state="translated">Чтобы узнать больше о CLI просто напечатайте:</target>
        </trans-unit>
        <trans-unit id="d062574c0bbb40aba96339ff0dbe5323fbfe73f8" translate="yes" xml:space="preserve">
          <source>To get a sense of when and why the different kinds of variance matters, let&amp;rsquo;s talk about methods of subclasses and how they get type checked.</source>
          <target state="translated">Чтобы понять, когда и почему важны различные виды отклонений, давайте поговорим о методах подклассов и о том, как они проверяют тип.</target>
        </trans-unit>
        <trans-unit id="e8ca9700f4d5ea2116113c0a357e597df59a1d6a" translate="yes" xml:space="preserve">
          <source>To remove a prop from the config, we can take a component that includes the prop and return a component that does not. It&amp;rsquo;s best to construct these types using object type spread.</source>
          <target state="translated">Чтобы удалить опору из конфигурации, мы можем взять компонент, который включает опору, и вернуть компонент, которого нет. Эти типы лучше всего строить, используя разброс типов объектов.</target>
        </trans-unit>
        <trans-unit id="8da5a47f9a8fbbb9d2efd234b56f09b304fb7f98" translate="yes" xml:space="preserve">
          <source>To see how you can annotate exported React components, check out our docs on &lt;a href=&quot;https://flow.org/en/react/hoc/#toc-exporting-wrapped-components&quot;&gt;HOCs&lt;/a&gt;.</source>
          <target state="translated">Чтобы узнать, как можно аннотировать экспортированные компоненты React, ознакомьтесь с нашей документацией по &lt;a href=&quot;https://flow.org/en/react/hoc/#toc-exporting-wrapped-components&quot;&gt;HOC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="38d849d799ad5dab7240320680d5c36bc5f7e6a7" translate="yes" xml:space="preserve">
          <source>To start a Flow server in Filesystem lazy mode, you run</source>
          <target state="translated">Чтобы запустить сервер Flow в ленивом режиме Файловой системы,вы запускаете</target>
        </trans-unit>
        <trans-unit id="2cf8bbf7b6d19d0001e46d5b57c96b778d96ae37" translate="yes" xml:space="preserve">
          <source>To start a Flow server in IDE lazy mode, you run</source>
          <target state="translated">Для запуска сервера Flow в ленивом режиме IDE,вы запускаете</target>
        </trans-unit>
        <trans-unit id="6e9bdac3d6d4ba3e13640e1b5c7a6fd976aa5a44" translate="yes" xml:space="preserve">
          <source>To start a Flow server in Watchman lazy mode, you run</source>
          <target state="translated">Чтобы запустить сервер Flow в ленивом режиме Watchman,вы запускаете</target>
        </trans-unit>
        <trans-unit id="3978fe345012186156eab3faa3a6473c8b81612a" translate="yes" xml:space="preserve">
          <source>To start, we can define a SubClass that extends our BaseClass. Here you can see that the value and the return type are both City just like in BaseClass:</source>
          <target state="translated">Для начала мы можем определить подкласс,который расширяет наш BaseClass.Здесь видно,что и значение,и тип возврата-это Город,как и в BaseClass:</target>
        </trans-unit>
        <trans-unit id="8cfed2a3a8f7e86b967cf2cb173010c65146aff8" translate="yes" xml:space="preserve">
          <source>To stop the background process, run &lt;code&gt;flow stop&lt;/code&gt;.</source>
          <target state="translated">Чтобы остановить фоновый процесс, запустите &lt;code&gt;flow stop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="338950985d59d6b6ee99128178aad62509b70476" translate="yes" xml:space="preserve">
          <source>To type event handlers you may use the &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; types like this:</source>
          <target state="translated">Для ввода обработчиков событий вы можете использовать типы &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="624f97de4950b92b803c5cac29be65a9f2a26ac4" translate="yes" xml:space="preserve">
          <source>Triggers when a &lt;code&gt;number&lt;/code&gt; is used in a manner which may lead to unexpected results if the value is falsy. Currently, this lint triggers if a &lt;code&gt;number&lt;/code&gt; appears in:</source>
          <target state="translated">Срабатывает, когда &lt;code&gt;number&lt;/code&gt; используется таким образом, который может привести к неожиданным результатам, если значение ложное. В настоящее время этот пух срабатывает, если &lt;code&gt;number&lt;/code&gt; появляется в:</target>
        </trans-unit>
        <trans-unit id="8244aa53a1217dc629b3a687638e12f7a3825a89" translate="yes" xml:space="preserve">
          <source>Triggers when a dynamic type (usually &lt;code&gt;any&lt;/code&gt;) appears in a position exported from a file. Note that this is a very noisy lint, and can be triggered even when exporting types that are defined in our library definitions to include &lt;code&gt;any&lt;/code&gt; types. For this reason we recommend turning it on on a per-file or even per-line basis using &lt;a href=&quot;../flowlint-comments#toc-flowlint&quot;&gt;flowlint comments&lt;/a&gt; rather than for your whole repository in the &lt;code&gt;.flowconfig&lt;/code&gt;.</source>
          <target state="translated">Срабатывает, когда динамический тип (обычно &lt;code&gt;any&lt;/code&gt; ) появляется в позиции, экспортированной из файла. Обратите внимание, что это очень шумный линт, и он может срабатывать даже при экспорте типов, определенных в определениях нашей библиотеки, для включения &lt;code&gt;any&lt;/code&gt; типов. По этой причине мы рекомендуем включать его для каждого файла или даже для каждой строки, используя &lt;a href=&quot;../flowlint-comments#toc-flowlint&quot;&gt;комментарии flowlint,&lt;/a&gt; а не для всего репозитория в &lt;code&gt;.flowconfig&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47ddc8ed6cfa00004f5b18730edf70132171135b" translate="yes" xml:space="preserve">
          <source>Triggers when you do an existence check on a value that can be either null/undefined or falsey.</source>
          <target state="translated">Триггеры,когда вы делаете проверку существования значения,которое может быть либо нулевым/неопределенным,либо ложным.</target>
        </trans-unit>
        <trans-unit id="4ce10e302a6e69d26761a0ef32f11a1014584bb6" translate="yes" xml:space="preserve">
          <source>Triggers when you import a type from an untyped file. Importing a type from an untyped file results in an &lt;code&gt;any&lt;/code&gt; alias, which is typically not the intended behavior. Enabling this lint brings extra attention to this case and can help improve Flow coverage of typed files by limiting the spread of implicit &lt;code&gt;any&lt;/code&gt; types.</source>
          <target state="translated">Срабатывает при импорте типа из нетипизированного файла. Импорт типа из нетипизированного файла приводит к &lt;code&gt;any&lt;/code&gt; псевдониму, что обычно не является предполагаемым поведением. Включение этого lint привлекает дополнительное внимание к этому случаю и может помочь улучшить покрытие Flow типизированных файлов за счет ограничения распространения неявных &lt;code&gt;any&lt;/code&gt; типов.</target>
        </trans-unit>
        <trans-unit id="40e312343bc5d66e00ad8f9190f3b8d256cb21f3" translate="yes" xml:space="preserve">
          <source>Triggers when you import from an untyped file. Importing from an untyped file results in those imports being typed as &lt;code&gt;any&lt;/code&gt;, which is unsafe.</source>
          <target state="translated">Срабатывает при импорте из нетипизированного файла. Импорт из нетипизированного файла приводит к тому, что этот импорт печатается как &lt;code&gt;any&lt;/code&gt; , что небезопасно.</target>
        </trans-unit>
        <trans-unit id="39095841a2d5b46ef9de672a2165376705e39be2" translate="yes" xml:space="preserve">
          <source>Triggers when you use &lt;code&gt;?.&lt;/code&gt; where it isn&amp;rsquo;t needed. This comes in two main flavors. The first is when the left-hand-side cannot be nullish:</source>
          <target state="translated">Триггеры при использовании &lt;code&gt;?.&lt;/code&gt; там, где это не нужно. Он бывает двух основных видов. Первый - когда левая часть не может быть нулевой:</target>
        </trans-unit>
        <trans-unit id="7a041463679a6c0a8cd599df21a504646bc4568e" translate="yes" xml:space="preserve">
          <source>Triggers when you use &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;Object&lt;/code&gt;, or &lt;code&gt;Function&lt;/code&gt; as type annotations. These types are unsafe.</source>
          <target state="translated">Триггеры, когда вы используете &lt;code&gt;any&lt;/code&gt; , &lt;code&gt;Object&lt;/code&gt; или &lt;code&gt;Function&lt;/code&gt; в качестве аннотации типов. Эти типы небезопасны.</target>
        </trans-unit>
        <trans-unit id="19e0b14f57c0eae8e32ecfbe46dbafa0b69613db" translate="yes" xml:space="preserve">
          <source>Triggers when you use &lt;code&gt;invariant&lt;/code&gt; to check a condition which we know must be truthy based on the available type information. This is quite conservative: for example, if all we know about the condition is that it is a &lt;code&gt;boolean&lt;/code&gt;, then the lint will not fire even if the condition must be &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="translated">Триггеры, когда вы используете &lt;code&gt;invariant&lt;/code&gt; для проверки условия, которое, как мы знаем, должно быть истинным на основании доступной информации о типе. Это довольно консервативно: например, если все, что мы знаем об условии, это то, что оно является &lt;code&gt;boolean&lt;/code&gt; , то линт не сработает, даже если условие должно быть &lt;code&gt;true&lt;/code&gt; во время выполнения.</target>
        </trans-unit>
        <trans-unit id="88f0c0e34ae8ddb6395ee1c9617fdf1fcbad8760" translate="yes" xml:space="preserve">
          <source>Triggers when you use getters or setters. Getters and setters can have side effects and are unsafe.</source>
          <target state="translated">Триггеры,когда вы используете геттеры или сеттеры.Геттеры и сеттеры могут иметь побочные эффекты и небезопасны.</target>
        </trans-unit>
        <trans-unit id="ffe944ad5706f41a9277209e96a262e3b635f27d" translate="yes" xml:space="preserve">
          <source>Triggers when you use object type syntax without explicitly specifying exactness or inexactness.</source>
          <target state="translated">Триггеры,когда вы используете синтаксис типа объекта без явного указания точности или неточности.</target>
        </trans-unit>
        <trans-unit id="53aef4ae56fa920050fd71a2e06d45055d43a802" translate="yes" xml:space="preserve">
          <source>Triggers when you use the &lt;code&gt;$Supertype&lt;/code&gt; or &lt;code&gt;$Subtype&lt;/code&gt; utility types, as these types are unsafe and equivalent to &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Триггеры , когда вы используете в &lt;code&gt;$Supertype&lt;/code&gt; или &lt;code&gt;$Subtype&lt;/code&gt; типы полезности, так как эти виды являются небезопасными и приравненных к &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d53a0bb8e4d9ee63e0c2e172befa01db4dc5e57" translate="yes" xml:space="preserve">
          <source>Triggers when you use the &lt;code&gt;*&lt;/code&gt; (existential) type, as this type is unsafe and usually just equivalent to &lt;code&gt;any&lt;/code&gt;. The effect of &lt;code&gt;*&lt;/code&gt; can generally be achieved by simply not providing a type annotation.</source>
          <target state="translated">Триггеры, когда вы используете тип &lt;code&gt;*&lt;/code&gt; (экзистенциальный), поскольку этот тип небезопасен и обычно эквивалентен &lt;code&gt;any&lt;/code&gt; . Эффект &lt;code&gt;*&lt;/code&gt; обычно может быть достигнут, просто не предоставляя аннотацию типа.</target>
        </trans-unit>
        <trans-unit id="3cddc0a96f7b4bc576c5197edc188b6a0fc13138" translate="yes" xml:space="preserve">
          <source>Trying to access an index that does not exist results in an index-out-of-bounds error.</source>
          <target state="translated">Попытка получить доступ к отсутствующему индексу приводит к ошибке индекса.</target>
        </trans-unit>
        <trans-unit id="cded0e3b203109683ae6b9ee54b86c57e5dee4ad" translate="yes" xml:space="preserve">
          <source>Trying to combine these two separate types into a single one will only cause us trouble.</source>
          <target state="translated">Попытка объединить эти два отдельных типа в один только доставит нам хлопот.</target>
        </trans-unit>
        <trans-unit id="8f2a5e4b9220f04b1f591d617289494ede815765" translate="yes" xml:space="preserve">
          <source>Tuple Types</source>
          <target state="translated">Типы кортежей</target>
        </trans-unit>
        <trans-unit id="61fc0a89e720d49271749ab98f1e68ad73b11567" translate="yes" xml:space="preserve">
          <source>Tuples are a sort of list but with a limited set of items. In JavaScript, tuples are created using arrays.</source>
          <target state="translated">Кортежи-это своего рода список,но с ограниченным набором элементов.В JavaScript кортежи создаются с помощью массивов.</target>
        </trans-unit>
        <trans-unit id="73e71c95d22953ac62aab7556972e23a84de8572" translate="yes" xml:space="preserve">
          <source>Tuples don&amp;rsquo;t match array types</source>
          <target state="translated">Кортежи не соответствуют типам массивов</target>
        </trans-unit>
        <trans-unit id="8228214d660934e2f3e63e0eebd31592280771e2" translate="yes" xml:space="preserve">
          <source>Tuples only match tuples with same length</source>
          <target state="translated">Кортежи только совпадают с кортежами той же длины.</target>
        </trans-unit>
        <trans-unit id="ebd8267f01d325be2d1360510829d925406c4930" translate="yes" xml:space="preserve">
          <source>Type &amp;lsquo;Flow&amp;rsquo; to find &amp;lsquo;Flow for Sublime Text 2 and 3&amp;rsquo;</source>
          <target state="translated">Введите &quot;Flow&quot;, чтобы найти &quot;Flow for Sublime Text 2 and 3&quot;.</target>
        </trans-unit>
        <trans-unit id="706d45898c47974656ad0920b31f4684a46f295c" translate="yes" xml:space="preserve">
          <source>Type Alias Generics</source>
          <target state="translated">Дженерики типа псевдонимов</target>
        </trans-unit>
        <trans-unit id="967c606ccee3e18535dabb6a9b4bb749abac062f" translate="yes" xml:space="preserve">
          <source>Type Alias Syntax</source>
          <target state="translated">Синтаксис типа псевдонимов</target>
        </trans-unit>
        <trans-unit id="353ce315d4b89d72fbf39db84d79fda4b261f3b6" translate="yes" xml:space="preserve">
          <source>Type Aliases</source>
          <target state="translated">псевдонимы типа</target>
        </trans-unit>
        <trans-unit id="22d158ab75d63715d420bc5e58daab5d8357398c" translate="yes" xml:space="preserve">
          <source>Type Annotations</source>
          <target state="translated">Введите аннотации</target>
        </trans-unit>
        <trans-unit id="77177e460aea3473402f5aaa44a506ee91144641" translate="yes" xml:space="preserve">
          <source>Type Assertions</source>
          <target state="translated">Типовые заявления</target>
        </trans-unit>
        <trans-unit id="679d10a7debbdc2089b71c9b81e4e219e305c114" translate="yes" xml:space="preserve">
          <source>Type Cast Expression Syntax</source>
          <target state="translated">Синтаксис выражений литого типа</target>
        </trans-unit>
        <trans-unit id="7f7ae61fc4d52305e688b8380ee480f65e186212" translate="yes" xml:space="preserve">
          <source>Type Casting</source>
          <target state="translated">Типовое литьё</target>
        </trans-unit>
        <trans-unit id="622cca8db4f4ef9c127d2e4b8f7ee4a1c6c56924" translate="yes" xml:space="preserve">
          <source>Type Casting Expressions</source>
          <target state="translated">Выражения типа литья</target>
        </trans-unit>
        <trans-unit id="242837be86dac228098509d8b1d22d367cdf4559" translate="yes" xml:space="preserve">
          <source>Type Casting through any</source>
          <target state="translated">Литье по любому типу</target>
        </trans-unit>
        <trans-unit id="5ad392a89ee608a47c6212c75337d50433a48220" translate="yes" xml:space="preserve">
          <source>Type Reference</source>
          <target state="translated">Типовая Ссылка</target>
        </trans-unit>
        <trans-unit id="ce57a9b5c9b93e38d173ed05c80dc328e2cdfdfc" translate="yes" xml:space="preserve">
          <source>Type Refinements</source>
          <target state="translated">Усовершенствования типа</target>
        </trans-unit>
        <trans-unit id="7433446286e8e2d16c8a5d667b180309a3d0c3b1" translate="yes" xml:space="preserve">
          <source>Type System</source>
          <target state="translated">Система типов</target>
        </trans-unit>
        <trans-unit id="472d5c5df27f757dd28ba1d382ee583d4a9c6081" translate="yes" xml:space="preserve">
          <source>Type Variance</source>
          <target state="translated">Тип Вариант</target>
        </trans-unit>
        <trans-unit id="7081fc7a1f2c1115eff37592f8d91d2655e0035b" translate="yes" xml:space="preserve">
          <source>Type alias generics are &lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;parameterized&lt;/a&gt;. When you use a type alias you need to pass parameters for each of its generics.</source>
          <target state="translated">Общие псевдонимы типа &lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;параметризованы&lt;/a&gt; . Когда вы используете псевдоним типа, вам необходимо передать параметры для каждого из его обобщений.</target>
        </trans-unit>
        <trans-unit id="ed6584609a640d5af10378fda6649aaa9963a745" translate="yes" xml:space="preserve">
          <source>Type aliases are created using the keyword &lt;code&gt;type&lt;/code&gt; followed by its name, an equals sign &lt;code&gt;=&lt;/code&gt;, and a type definition.</source>
          <target state="translated">Псевдонимы типов создаются с использованием ключевого слова &lt;code&gt;type&lt;/code&gt; , за которым следует его имя, знак равенства &lt;code&gt;=&lt;/code&gt; и определение типа.</target>
        </trans-unit>
        <trans-unit id="f5e43ef93cfc8bf99af97c7220813d7732015c36" translate="yes" xml:space="preserve">
          <source>Type aliases can also have their own &lt;a href=&quot;../generics&quot;&gt;generics&lt;/a&gt;.</source>
          <target state="translated">Псевдонимы типа также могут иметь свои собственные &lt;a href=&quot;../generics&quot;&gt;обобщения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="094f893f7105ba5dce34064ff2a962e9a5dea0a2" translate="yes" xml:space="preserve">
          <source>Type aliases with generics</source>
          <target state="translated">Псевдонимы типа с дженериками</target>
        </trans-unit>
        <trans-unit id="856da198c41cb55e6e7b7e17d220f7f074929070" translate="yes" xml:space="preserve">
          <source>Type cast expressions can appear anywhere an expression can appear.</source>
          <target state="translated">Выражения типа могут появляться в любом месте,где может появиться какое-либо выражение.</target>
        </trans-unit>
        <trans-unit id="52a7383784e25f833d11d59af803f7d6f5fb1c80" translate="yes" xml:space="preserve">
          <source>Type checking through type assertions</source>
          <target state="translated">Проверка типа через утверждения типа</target>
        </trans-unit>
        <trans-unit id="b0b25b95faf957cfa80952cbe05fe4b40c3ff732" translate="yes" xml:space="preserve">
          <source>Typeof Types</source>
          <target state="translated">Типы типа</target>
        </trans-unit>
        <trans-unit id="e96900534c313f15c2044eb007fe55d438980bfc" translate="yes" xml:space="preserve">
          <source>Types &amp;amp; Expressions</source>
          <target state="translated">Типы и выражения</target>
        </trans-unit>
        <trans-unit id="c71bc629994455a4ae2c2c56b3468d4335892413" translate="yes" xml:space="preserve">
          <source>Types for literal values are lowercase.</source>
          <target state="translated">Типы буквенных значений-строчные.</target>
        </trans-unit>
        <trans-unit id="580c5ee4989e8d41e98c7cbde35a3b6779ea36bd" translate="yes" xml:space="preserve">
          <source>Types for the wrapper objects are capitalized (the same as their constructor).</source>
          <target state="translated">Типы оберточных объектов капитализируются (так же,как и их конструктор).</target>
        </trans-unit>
        <trans-unit id="7b4e1425babb83699dcc06797b8fc4bf14a2ecce" translate="yes" xml:space="preserve">
          <source>Typing Redux action creators</source>
          <target state="translated">Типизация создателей действия Redux</target>
        </trans-unit>
        <trans-unit id="5dfff1352be5ea6c7148bf3b4ca1615b03fabc81" translate="yes" xml:space="preserve">
          <source>Typing Redux actions</source>
          <target state="translated">Типизация действий Редукс</target>
        </trans-unit>
        <trans-unit id="6ac33fe488507408b1948fb67be46790295ab295" translate="yes" xml:space="preserve">
          <source>Typing Redux reducers</source>
          <target state="translated">Редукторы Typing Redux</target>
        </trans-unit>
        <trans-unit id="1133cd18fcd897fc2f5bb525485b9229e6071672" translate="yes" xml:space="preserve">
          <source>Typing Redux state</source>
          <target state="translated">Типичное состояние Редукса</target>
        </trans-unit>
        <trans-unit id="0640a2bc7ae817374f47547199fbe5f3a1a3b619" translate="yes" xml:space="preserve">
          <source>Typing Redux state immutability</source>
          <target state="translated">Типизация состояния неизменности Redux</target>
        </trans-unit>
        <trans-unit id="5122ba530622fd5f4a0332eb09fb6325c4305df1" translate="yes" xml:space="preserve">
          <source>Typing Redux thunk actions</source>
          <target state="translated">Типизация Redux Thunk действия</target>
        </trans-unit>
        <trans-unit id="8f00b09a4880f70aa5139aa250a7d8b335930e96" translate="yes" xml:space="preserve">
          <source>Typing function children or other exotic children types.</source>
          <target state="translated">Типизация функций детей или других экзотических типов детей.</target>
        </trans-unit>
        <trans-unit id="ee1f5ee4decdbb0b21342950c2b6f1f39fa45f3a" translate="yes" xml:space="preserve">
          <source>Typing your &lt;a href=&quot;http://redux.js.org/docs/introduction/ThreePrinciples.html#single-source-of-truth&quot;&gt;state&lt;/a&gt; object, works the same as typing any other object in Flow.</source>
          <target state="translated">Ввод объекта &lt;a href=&quot;http://redux.js.org/docs/introduction/ThreePrinciples.html#single-source-of-truth&quot;&gt;состояния&lt;/a&gt; работает так же, как ввод любого другого объекта в Flow.</target>
        </trans-unit>
        <trans-unit id="eaeff57d46868fd923495803e50c88004276ec83" translate="yes" xml:space="preserve">
          <source>Typings HOCs can be complicated. While you can follow the &lt;a href=&quot;react/hoc&quot;&gt;docs about it&lt;/a&gt;, sometimes it can be easier to type the returned component.</source>
          <target state="translated">Типы HOC могут быть сложными. Хотя вы можете следить за &lt;a href=&quot;react/hoc&quot;&gt;документами об этом&lt;/a&gt; , иногда бывает проще ввести возвращаемый компонент.</target>
        </trans-unit>
        <trans-unit id="28e0451237256965294e54fd3ed734d927e133c0" translate="yes" xml:space="preserve">
          <source>Under the hood, Flow relies on a high-throughput low-latency systems infrastructure that enables distribution of tasks among parallel workers, and communication of results in parallel via shared memory. Combined with an architecture where the analysis of a codebase is updated automatically in the background on file system changes, Flow delivers near-instantaneous feedback as the developer edits and rebases code, even in a large repository.</source>
          <target state="translated">Под капотом Flow опирается на высокопроизводительную низколатенсивную системную инфраструктуру,которая позволяет распределять задачи между параллельными работниками и передавать результаты параллельно через общую память.В сочетании с архитектурой,в которой анализ кодовой базы автоматически обновляется в фоновом режиме при изменении файловой системы,Flow обеспечивает практически мгновенную обратную связь по мере того,как разработчик редактирует и пересматривает код даже в большом репозитории.</target>
        </trans-unit>
        <trans-unit id="667d6f69fc6e6557c1fd07a997502ffbb6fea4b6" translate="yes" xml:space="preserve">
          <source>Understanding the logic behind generics might be useful, but what you really need to know to make your typings valid is that you need to help Flow to understand the type of &lt;code&gt;genericArray&lt;/code&gt;.</source>
          <target state="translated">Понимание логики, лежащей в основе универсальных шаблонов, может быть полезно, но что вам действительно нужно знать, чтобы сделать вашу типизацию действительной, так это то, что вам нужно помочь Flow понять тип &lt;code&gt;genericArray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="468ccd5bcf72e4958742b43ae3e09374a05c2b83" translate="yes" xml:space="preserve">
          <source>Union Types</source>
          <target state="translated">Союзные Типы</target>
        </trans-unit>
        <trans-unit id="5997dfe0e231fc3d5039a0ce77e27fc997c50e93" translate="yes" xml:space="preserve">
          <source>Union type syntax</source>
          <target state="translated">Синтаксис союзного типа</target>
        </trans-unit>
        <trans-unit id="5772a5be68b2acc1748e16bd31117c9dcf779b80" translate="yes" xml:space="preserve">
          <source>Union types are any number of types which are joined by a vertical bar &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">Типы объединения - это любое количество типов, которые соединяются вертикальной чертой &lt;code&gt;|&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="c4fcae8ac4735463f8391bdf76cd83a6272aa90b" translate="yes" xml:space="preserve">
          <source>Union types requires one in, but all out</source>
          <target state="translated">Типы союзов требуют один вход,но все выходы</target>
        </trans-unit>
        <trans-unit id="40ebabc3d3f621503bd72ccc4402a11bbf25a8ef" translate="yes" xml:space="preserve">
          <source>Unions &amp;amp; Refinements</source>
          <target state="translated">Союзы и уточнения</target>
        </trans-unit>
        <trans-unit id="38ed70ea0b1d89e63badbd5bea1ce73346a2e36d" translate="yes" xml:space="preserve">
          <source>Unknown property lookup on unsealed objects is unsafe</source>
          <target state="translated">Неизвестный поиск имущества на незапечатанных объектах небезопасен</target>
        </trans-unit>
        <trans-unit id="703d1ae54d78dc2791b520eb4ed986a6d9a34e11" translate="yes" xml:space="preserve">
          <source>Unless the objects somehow conflict with one another there is no way to distinguish them.</source>
          <target state="translated">Если объекты каким-то образом не конфликтуют друг с другом,их невозможно отличить.</target>
        </trans-unit>
        <trans-unit id="ef3248cdccf6c3a032dec37be3fbfe52ccc8052c" translate="yes" xml:space="preserve">
          <source>Unlike many other languages, JavaScript only has one type of number. These values may appear as &lt;code&gt;42&lt;/code&gt; or &lt;code&gt;3.14&lt;/code&gt;. JavaScript also considers &lt;code&gt;Infinity&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; to be numbers. The &lt;code&gt;number&lt;/code&gt; type captures everything JavaScript considers a number.</source>
          <target state="translated">В отличие от многих других языков, в JavaScript есть только один тип числа. Эти значения могут отображаться как &lt;code&gt;42&lt;/code&gt; или &lt;code&gt;3.14&lt;/code&gt; . JavaScript также считает &lt;code&gt;Infinity&lt;/code&gt; и &lt;code&gt;NaN&lt;/code&gt; числами. Тип &lt;code&gt;number&lt;/code&gt; отражает все, что JavaScript считает числом.</target>
        </trans-unit>
        <trans-unit id="3af13bbea775e8595b01bcfbe26e08a735507b74" translate="yes" xml:space="preserve">
          <source>Unlike regular object types, it is not valid to pass an object with &amp;ldquo;extra&amp;rdquo; properties to an exact object type.</source>
          <target state="translated">В отличие от обычных типов объектов, нельзя передавать объект с &amp;laquo;дополнительными&amp;raquo; свойствами конкретному типу объекта.</target>
        </trans-unit>
        <trans-unit id="07ef2b2dcd96f0dd48fe2da326d94f53363ed4ce" translate="yes" xml:space="preserve">
          <source>Unsealed objects</source>
          <target state="translated">Незапечатанные предметы</target>
        </trans-unit>
        <trans-unit id="25c6b6f53e08c0606a31166d8b9a877dcfc420f6" translate="yes" xml:space="preserve">
          <source>Unsealed objects allow new properties to be written at any time. Flow ensures that reads are compatible with writes, but does not ensure that writes happen before reads (in the order of execution).</source>
          <target state="translated">Незапечатанные объекты позволяют записывать новые свойства в любое время.Поток обеспечивает совместимость чтения с записью,но не гарантирует,что запись произойдет до чтения (в порядке выполнения).</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="a37aa700a25d2f5c26f5844b90cdc3158398c792" translate="yes" xml:space="preserve">
          <source>Used in conjuction with &lt;a href=&quot;https://flow.org/en/strict/&quot;&gt;Flow Strict&lt;/a&gt;. Triggers when importing a non &lt;code&gt;@flow strict&lt;/code&gt; module. When enabled, dependencies of a &lt;code&gt;@flow strict&lt;/code&gt; module must also be &lt;code&gt;@flow strict&lt;/code&gt;.</source>
          <target state="translated">Используется вместе с &lt;a href=&quot;https://flow.org/en/strict/&quot;&gt;Flow Strict&lt;/a&gt; . Триггеры при импорте модуля, отличного от &lt;code&gt;@flow strict&lt;/code&gt; . Если этот параметр включен, зависимости модуля &lt;code&gt;@flow strict&lt;/code&gt; также должны быть &lt;code&gt;@flow strict&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37435b49f34aed7ea4a10106bbcc3330cbcab593" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;React.Node&lt;/code&gt; but without some primitive types like strings.</source>
          <target state="translated">Использование &lt;code&gt;React.Node&lt;/code&gt; , но без некоторых примитивных типов, таких как строки.</target>
        </trans-unit>
        <trans-unit id="a55e66a75946c4c072cc420e4c3ed94f6780a7c2" translate="yes" xml:space="preserve">
          <source>Using Default Props</source>
          <target state="translated">Использование реквизитов по умолчанию</target>
        </trans-unit>
        <trans-unit id="08b120d1bbe1cac9b101fd75ecc8814d5b08ec58" translate="yes" xml:space="preserve">
          <source>Using Default Props for Functional Components</source>
          <target state="translated">Использование реквизитов по умолчанию для функциональных компонентов</target>
        </trans-unit>
        <trans-unit id="3c58620d569e6a2825f19e911cd8c7f8b356ab31" translate="yes" xml:space="preserve">
          <source>Using Filesystem Lazy Mode</source>
          <target state="translated">Использование Ленивого режима файловой системы</target>
        </trans-unit>
        <trans-unit id="0eca84f8818d70549fd226298ab6a5af63ae5ddc" translate="yes" xml:space="preserve">
          <source>Using Flow you can use Maybe types for these values. Maybe types work with any other type by simply prefixing it with a question mark &lt;code&gt;?&lt;/code&gt; such as &lt;code&gt;?number&lt;/code&gt; as a sort of modifier.</source>
          <target state="translated">Используя Flow, вы можете использовать типы Maybe для этих значений. Может быть, типы работают с любым другим типом, просто ставя перед ним вопросительный знак &lt;code&gt;?&lt;/code&gt; например &lt;code&gt;?number&lt;/code&gt; как своего рода модификатор.</target>
        </trans-unit>
        <trans-unit id="ba7902faac97670dd0cee466cfc7b1872b6191c6" translate="yes" xml:space="preserve">
          <source>Using IDE Lazy Mode</source>
          <target state="translated">Использование IDE Lazy Mode</target>
        </trans-unit>
        <trans-unit id="dcb8b5c22a81a676bc4f6e0097672681d67ad964" translate="yes" xml:space="preserve">
          <source>Using Watchman Lazy Mode</source>
          <target state="translated">Использование режима &quot;Ленивый Человек-Часовник</target>
        </trans-unit>
        <trans-unit id="4acbbdc6b766f0f60a0b004c91a169d2b83a940e" translate="yes" xml:space="preserve">
          <source>Using disjoint unions, Flow will be able to understand your reducers much better.</source>
          <target state="translated">Используя разобщенные союзы,компания Flow сможет гораздо лучше понять ваши редукторы.</target>
        </trans-unit>
        <trans-unit id="e6ba24474eb6d1b00633e337c8dace730b98eb30" translate="yes" xml:space="preserve">
          <source>Using exact object types lets Flow know that no extra properties will exist at runtime, which allows &lt;a href=&quot;../refinements&quot;&gt;refinements&lt;/a&gt; to get more specific.</source>
          <target state="translated">Использование точных типов объектов позволяет Flow знать, что во время выполнения не будет никаких дополнительных свойств, что позволяет &lt;a href=&quot;../refinements&quot;&gt;уточнять&lt;/a&gt; детализацию.</target>
        </trans-unit>
        <trans-unit id="10ade4f79788cce4dea297a9d609f90e95de4261" translate="yes" xml:space="preserve">
          <source>Using inference, these types are often optional:</source>
          <target state="translated">При использовании умозаключений эти типы часто являются необязательными:</target>
        </trans-unit>
        <trans-unit id="638d500275968b8c62e284497de3a8262dc86007" translate="yes" xml:space="preserve">
          <source>Using intersection types, it is possible to create types which are impossible to create at runtime. Intersection types will allow you to combine any set of types, even ones that conflict with one another.</source>
          <target state="translated">Используя типы пересечений,можно создавать типы,которые невозможно создать во время исполнения.Типы пересечения позволят комбинировать любые наборы типов,даже конфликтующие друг с другом.</target>
        </trans-unit>
        <trans-unit id="b8ada9fc6bb8dffff0336dfb6dc98c7dc0b143de" translate="yes" xml:space="preserve">
          <source>Using the above definition we can declare a function &lt;code&gt;fn&lt;/code&gt; that has the following behavior:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86509a1d00de10c9136938cbdfb1d9850e246f6e" translate="yes" xml:space="preserve">
          <source>Using the command &lt;code&gt;flow&lt;/code&gt; will type-check your current directory if the &lt;code&gt;.flowconfig&lt;/code&gt; file is present. A flow server will automatically be started if needed.</source>
          <target state="translated">Используя &lt;code&gt;flow&lt;/code&gt; команд, вы проверите текущий каталог на &lt;code&gt;.flowconfig&lt;/code&gt; файла .flowconfig . При необходимости автоматически запустится потоковый сервер.</target>
        </trans-unit>
        <trans-unit id="b4fce26a90d1ee7b21142442ea9f330e4afede8c" translate="yes" xml:space="preserve">
          <source>Using these with &lt;a href=&quot;../unions&quot;&gt;union types&lt;/a&gt; is powerful:</source>
          <target state="translated">Использование их с &lt;a href=&quot;../unions&quot;&gt;типами объединения&lt;/a&gt; - это мощный инструмент:</target>
        </trans-unit>
        <trans-unit id="58f37430c61b5ea396ac215dd6bf35547ff8b510" translate="yes" xml:space="preserve">
          <source>Using type cast expressions</source>
          <target state="translated">Использование выражений,основанных на типовом касте</target>
        </trans-unit>
        <trans-unit id="4e74c3c3dbc90177ee7906987795cb4e37db9635" translate="yes" xml:space="preserve">
          <source>Using type cast expressions you can assert that values are certain types.</source>
          <target state="translated">С помощью выражений приведения типов можно утверждать,что значения являются определенными типами.</target>
        </trans-unit>
        <trans-unit id="aba045b792a727f53d493f5cc2d4bbe68e26bbc6" translate="yes" xml:space="preserve">
          <source>Utility Types</source>
          <target state="translated">Типы полезности</target>
        </trans-unit>
        <trans-unit id="d981987c61afbbc64d7655e2b4cdb6bf5b85cbce" translate="yes" xml:space="preserve">
          <source>Variable Types</source>
          <target state="translated">Переменные Типы</target>
        </trans-unit>
        <trans-unit id="3c555fe12c9dd11facd9128e236d5c42157a806e" translate="yes" xml:space="preserve">
          <source>Variance Sigils</source>
          <target state="translated">Знаки различия</target>
        </trans-unit>
        <trans-unit id="12e8ee8b0b460ae1489f8fa70aa448077ad5be60" translate="yes" xml:space="preserve">
          <source>Variance in Classes</source>
          <target state="translated">Вариации в классах</target>
        </trans-unit>
        <trans-unit id="661548cc8ae30e106f079ae71da4e22fdee3f0a3" translate="yes" xml:space="preserve">
          <source>Variance is a topic that comes up fairly often in type systems and can be a bit confusing the first time you hear it. Let&amp;rsquo;s walk through each form of variance.</source>
          <target state="translated">Дисперсия - это тема, которая довольно часто возникает в системах типов и может немного сбить с толку, когда вы впервые ее услышите. Давайте рассмотрим каждую форму дисперсии.</target>
        </trans-unit>
        <trans-unit id="4f27c48fa3564f7410e0121a7646d154ac051a32" translate="yes" xml:space="preserve">
          <source>Variance sigils allow you to be more specific about how you intend to use your generics, giving Flow the power to do more precise type checking. For example, you may want this relationship to hold:</source>
          <target state="translated">Знаки вариации позволяют более точно определить,как вы собираетесь использовать ваши генераторы,что дает Flow возможность более точно проверять тип.Например,вы можете захотеть,чтобы эти отношения были сохранены:</target>
        </trans-unit>
        <trans-unit id="a78ad277616170813560c5fab7aabae8ac9cfb23" translate="yes" xml:space="preserve">
          <source>Vim</source>
          <target state="translated">Vim</target>
        </trans-unit>
        <trans-unit id="afbd00670e2a500077ed926aedfb070c71244c15" translate="yes" xml:space="preserve">
          <source>VimPlug</source>
          <target state="translated">VimPlug</target>
        </trans-unit>
        <trans-unit id="423f1f3d80c4d824ca917e13649a5c584a13ec87" translate="yes" xml:space="preserve">
          <source>Visual Studio Code</source>
          <target state="translated">Visual Studio Code</target>
        </trans-unit>
        <trans-unit id="b8fd2f3a8255adad646ca5327eba0b8786744dbe" translate="yes" xml:space="preserve">
          <source>Warnings aren&amp;rsquo;t shown on the CLI by default, to avoid spew. CLI warnings can be enabled by passing the &amp;ndash;include-warnings flag to the Flow server or the Flow client, or by setting &amp;ldquo;include_warnings=true&amp;rdquo; in the &lt;code&gt;.flowconfig&lt;/code&gt;. This is good for smaller projects that want to see all project warnings at once.</source>
          <target state="translated">Предупреждения не отображаются в интерфейсе командной строки по умолчанию, чтобы избежать извержения. Предупреждения CLI можно включить, передав флаг &amp;ndash;include-warnings серверу Flow или клиенту Flow, или установив include_warnings = true в &lt;code&gt;.flowconfig&lt;/code&gt; . Это хорошо для небольших проектов, которые хотят видеть все предупреждения проекта сразу.</target>
        </trans-unit>
        <trans-unit id="fe8d40071f5a559a669afec325304551bb16aba4" translate="yes" xml:space="preserve">
          <source>Warnings don&amp;rsquo;t affect the exit code of Flow. If Flow finds warnings but no errors, it still returns 0.</source>
          <target state="translated">Предупреждения не влияют на код выхода Flow. Если Flow находит предупреждения, но не обнаруживает ошибок, он все равно возвращает 0.</target>
        </trans-unit>
        <trans-unit id="81f9219fd8a874b03e97d8fac13dedd6210a919b" translate="yes" xml:space="preserve">
          <source>Warnings have special &lt;a href=&quot;ide-integration&quot;&gt;IDE Integration&lt;/a&gt;.</source>
          <target state="translated">Предупреждения имеют специальную &lt;a href=&quot;ide-integration&quot;&gt;интеграцию с IDE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb2debe559facf651a601f9c7527b8296d8b9624" translate="yes" xml:space="preserve">
          <source>Watchman lazy mode has a few additional requirements.</source>
          <target state="translated">Ленивый режим сторожа имеет несколько дополнительных требований.</target>
        </trans-unit>
        <trans-unit id="78080fc13eb28909de716d744a8a47810b22cd61" translate="yes" xml:space="preserve">
          <source>We also need &lt;code&gt;typeof&lt;/code&gt; for &lt;code&gt;Bar&lt;/code&gt; because &lt;code&gt;Bar&lt;/code&gt; is a value. So we want to get the type &lt;em&gt;of&lt;/em&gt; the value &lt;code&gt;Bar&lt;/code&gt;. &lt;code&gt;(Bar: Bar)&lt;/code&gt; is an error because &lt;code&gt;Bar&lt;/code&gt; cannot be used as a type, so the following is correct: &lt;code&gt;(Bar: typeof Bar)&lt;/code&gt;.</source>
          <target state="translated">Нам также нужен &lt;code&gt;typeof&lt;/code&gt; для &lt;code&gt;Bar&lt;/code&gt; , потому что &lt;code&gt;Bar&lt;/code&gt; - это значение. Поэтому мы хотим , чтобы получить тип &lt;em&gt;из&lt;/em&gt; значения &lt;code&gt;Bar&lt;/code&gt; . &lt;code&gt;(Bar: Bar)&lt;/code&gt; является ошибкой, потому что &lt;code&gt;Bar&lt;/code&gt; не может использоваться как тип, поэтому верно следующее: &lt;code&gt;(Bar: typeof Bar)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="565a855b54dc5d4e5feb1c24229c3c37a0aa82ca" translate="yes" xml:space="preserve">
          <source>We can try to express both of these objects in a single object type. However, we&amp;rsquo;ll quickly run into issues where we know a property exists based on the success property but Flow does not.</source>
          <target state="translated">Мы можем попытаться выразить оба этих объекта в одном типе объекта. Однако мы быстро столкнемся с проблемами, когда мы знаем, что свойство существует на основе свойства успеха, а Flow - нет.</target>
        </trans-unit>
        <trans-unit id="fb681ad5a4120e328dc7b7df6b9ecb5757df66ef" translate="yes" xml:space="preserve">
          <source>We can use this type alias to make sure reducers work correctly.</source>
          <target state="translated">Мы можем использовать этот тип псевдонима,чтобы убедиться,что редукторы работают правильно.</target>
        </trans-unit>
        <trans-unit id="0eb5411b6ed2d064b0d0e833606639f58a6b2b5f" translate="yes" xml:space="preserve">
          <source>We get this error message because &lt;code&gt;React.AbstractComponent&amp;lt;Config&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t set the &lt;code&gt;Instance&lt;/code&gt; type parameter, so it is automatically set to &lt;code&gt;mixed&lt;/code&gt;. If we wanted to preserve the instance type of the component, we can use &lt;a href=&quot;https://reactjs.org/docs/forwarding-refs.html&quot;&gt;&lt;code&gt;React.forwardRef&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Мы получаем это сообщение об ошибке, потому что &lt;code&gt;React.AbstractComponent&amp;lt;Config&amp;gt;&lt;/code&gt; не устанавливает параметр типа &lt;code&gt;Instance&lt;/code&gt; , поэтому он автоматически устанавливается на &lt;code&gt;mixed&lt;/code&gt; . Если мы хотим сохранить тип экземпляра компонента, мы можем использовать &lt;a href=&quot;https://reactjs.org/docs/forwarding-refs.html&quot;&gt; &lt;code&gt;React.forwardRef&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="14c408c67aca29a7fa863fd2f5d381f5c8273e88" translate="yes" xml:space="preserve">
          <source>We recommend you enable all your desired rules from the beginning, then adopt Flow Strict file-by-file. This works better than enabling a single rule, adding &lt;code&gt;@flow strict&lt;/code&gt; to many files, and then adding more rules to the config.</source>
          <target state="translated">Мы рекомендуем вам включить все желаемые правила с самого начала, а затем применять Flow Strict файл за файлом. Это работает лучше, чем включение одного правила, добавление &lt;code&gt;@flow strict&lt;/code&gt; ко многим файлам, а затем добавление дополнительных правил в конфигурацию.</target>
        </trans-unit>
        <trans-unit id="34abdcf44b0093985cf9e1d46481109cab9f85f9" translate="yes" xml:space="preserve">
          <source>We removed our dependency on &lt;code&gt;prop-types&lt;/code&gt; and added a Flow object type named &lt;code&gt;Props&lt;/code&gt; with the same shape as the prop types but using Flow&amp;rsquo;s static type syntax. Then we passed our new &lt;code&gt;Props&lt;/code&gt; type into &lt;code&gt;React.Component&lt;/code&gt; as a type argument.</source>
          <target state="translated">Мы удалили нашу зависимость от &lt;code&gt;prop-types&lt;/code&gt; и добавили тип объекта Flow с именем &lt;code&gt;Props&lt;/code&gt; с той же формой, что и типы опор, но с использованием синтаксиса статического типа Flow. Затем мы прошли наш новый &lt;code&gt;Props&lt;/code&gt; типа в &lt;code&gt;React.Component&lt;/code&gt; в качестве аргумента типа.</target>
        </trans-unit>
        <trans-unit id="fdbcb95f6a23f42e50318e1968770b634c1e41d0" translate="yes" xml:space="preserve">
          <source>We set the type of props to &lt;code&gt;React.ChildrenArray&amp;lt;React.Element&amp;lt;typeof TabBarIOSItem&amp;gt;&amp;gt;&lt;/code&gt; which will guarantee that &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; must only have children that are &lt;code&gt;TabBarIOS.Item&lt;/code&gt; React elements.</source>
          <target state="translated">Мы устанавливаем тип &lt;code&gt;React.ChildrenArray&amp;lt;React.Element&amp;lt;typeof TabBarIOSItem&amp;gt;&amp;gt;&lt;/code&gt; что гарантирует, что &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; должен иметь только &lt;code&gt;TabBarIOS.Item&lt;/code&gt; элементы, которые являются элементами TabBarIOS.Item React.</target>
        </trans-unit>
        <trans-unit id="91fdfa76ed94bd3897d04cec5f4134f4e7bc035e" translate="yes" xml:space="preserve">
          <source>We will refer to all the types in the following reference as if we imported them with:</source>
          <target state="translated">Мы будем ссылаться на все типы в следующей ссылке,как если бы мы импортировали их с:</target>
        </trans-unit>
        <trans-unit id="d0deed72cfe69559a9e7c7724e402ecb7a9ed446" translate="yes" xml:space="preserve">
          <source>We would have a lot of trouble trying to write specific types for this function since it could be anything.</source>
          <target state="translated">Нам было бы очень сложно пытаться написать конкретные типы для этой функции,так как это может быть что угодно.</target>
        </trans-unit>
        <trans-unit id="54c34be58b1366378d47ad4ba8a861a9a07fe8d5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll quickly set up our &lt;code&gt;BaseClass&lt;/code&gt; which will define just one method that accepts an input value with the type &lt;code&gt;City&lt;/code&gt; and an returned output also with the type &lt;code&gt;City&lt;/code&gt;.</source>
          <target state="translated">Мы быстро &lt;code&gt;BaseClass&lt;/code&gt; наш BaseClass, который определит только один метод, который принимает входное значение с типом &lt;code&gt;City&lt;/code&gt; и возвращаемый результат также с типом &lt;code&gt;City&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f20c7e2164e3a5acb3717c0236d43d3267a9c8ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use these classes to write a method that has each kind of variance.</source>
          <target state="translated">Мы будем использовать эти классы для написания метода, который имеет каждый вид дисперсии.</target>
        </trans-unit>
        <trans-unit id="04c0bd1c623d23997ff99f3caa7042e13039a782" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve demonstrated both nominal and structure typing of classes, but there are also other complex types like objects and functions which can also be either nominal or structural. Even further, they can be different within the same type system (most of the languages listed before has features of both).</source>
          <target state="translated">Мы продемонстрировали как номинальную, так и структурную типизацию классов, но есть и другие сложные типы, такие как объекты и функции, которые также могут быть номинальными или структурными. Более того, они могут быть разными в рамках одной и той же системы типов (большинство языков, перечисленных ранее, имеют особенности обоих).</target>
        </trans-unit>
        <trans-unit id="c5b6d6d89517eff4ce180cea4ab387ae48e094cb" translate="yes" xml:space="preserve">
          <source>WebStorm</source>
          <target state="translated">WebStorm</target>
        </trans-unit>
        <trans-unit id="d40a79cfe25e4cc102f0a57e8b44e1c01d37bcbb" translate="yes" xml:space="preserve">
          <source>WebStorm 2016.3</source>
          <target state="translated">Вебсторм 2016.3</target>
        </trans-unit>
        <trans-unit id="6c3e64366f1d6fbef0a5c75ba4449cc79038d05d" translate="yes" xml:space="preserve">
          <source>WebStorm 2017.1</source>
          <target state="translated">Вебсторм 2017.1</target>
        </trans-unit>
        <trans-unit id="8f14c5dae174ee34d208589e220dbdb169f943d4" translate="yes" xml:space="preserve">
          <source>Webstorm installation instructions can be found here:</source>
          <target state="translated">Инструкции по установке Webstorm можно найти здесь:</target>
        </trans-unit>
        <trans-unit id="44f3ba4fbbef59c08df191dcbed16fa19c8defe9" translate="yes" xml:space="preserve">
          <source>What do you think will happen?</source>
          <target state="translated">Как ты думаешь,что случится?</target>
        </trans-unit>
        <trans-unit id="4b5eba71e139ed73ff2a0e9b6ced493bb2e4087c" translate="yes" xml:space="preserve">
          <source>What happens when you have a single child?</source>
          <target state="translated">Что происходит,когда у тебя один ребенок?</target>
        </trans-unit>
        <trans-unit id="6966f9bf72c264264a3efaf8dc5ecfa61beb1bb2" translate="yes" xml:space="preserve">
          <source>What happens when you have multiple children?</source>
          <target state="translated">Что происходит,когда у тебя несколько детей?</target>
        </trans-unit>
        <trans-unit id="12b550ae1d285f33798a42afbb386fd6afdc67f5" translate="yes" xml:space="preserve">
          <source>What is a subtype?</source>
          <target state="translated">Что такое подтип?</target>
        </trans-unit>
        <trans-unit id="ac4ecfb3127c03f684e91c1f130988581c874a06" translate="yes" xml:space="preserve">
          <source>What makes Flow fast?</source>
          <target state="translated">Что делает Flow быстрым?</target>
        </trans-unit>
        <trans-unit id="db33814c5657c00a949fba0af9d59dbafa3fcb1a" translate="yes" xml:space="preserve">
          <source>What makes Flow precise?</source>
          <target state="translated">Что делает Flow точным?</target>
        </trans-unit>
        <trans-unit id="0fd65380fb716403292b7d92faef2766c527f8ab" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s Ahead</source>
          <target state="translated">Что впереди</target>
        </trans-unit>
        <trans-unit id="c5e189be8dd7a5933934ab2b958e415933a6e5ad" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s a &amp;ldquo;Library Definition&amp;rdquo;?</source>
          <target state="translated">Что такое &amp;laquo;определение библиотеки&amp;raquo;?</target>
        </trans-unit>
        <trans-unit id="40731c621de61ed4b398992215b3e1a3b5986f84" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s a Declaration File?</source>
          <target state="translated">Что такое файл декларации?</target>
        </trans-unit>
        <trans-unit id="b9efc85fa229daf00790235bc1d272e8bf51c10c" translate="yes" xml:space="preserve">
          <source>When an object type has an indexer property, property accesses are assumed to have the annotated type, even if the object does not have a value in that slot at runtime. It is the programmer&amp;rsquo;s responsibility to ensure the access is safe, as with arrays.</source>
          <target state="translated">Когда тип объекта имеет свойство индексатора, предполагается, что доступ к свойствам имеет аннотированный тип, даже если объект не имеет значения в этом слоте во время выполнения. Как и в случае с массивами, ответственность за безопасность доступа лежит на программисте.</target>
        </trans-unit>
        <trans-unit id="f8b96e1aead97a6dccb4198de5ff7a26c459a398" translate="yes" xml:space="preserve">
          <source>When are subtypes used?</source>
          <target state="translated">Когда используются подтипы?</target>
        </trans-unit>
        <trans-unit id="1f4a3bdc8dfbb9e08a8423a54448b12d02bbd84f" translate="yes" xml:space="preserve">
          <source>When calling our function that accepts a union type we must pass in &lt;strong&gt;&lt;em&gt;one of those types&lt;/em&gt;&lt;/strong&gt;. But inside of our function we are required to handle &lt;strong&gt;&lt;em&gt;all of the possible types&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">При вызове нашей функции, которая принимает тип объединения, мы должны передать &lt;strong&gt;&lt;em&gt;один из этих типов&lt;/em&gt;&lt;/strong&gt; . Но внутри нашей функции мы должны обрабатывать &lt;strong&gt;&lt;em&gt;все возможные типы&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="302b36e230abf6c143e3b19fe2499d796c35aef9" translate="yes" xml:space="preserve">
          <source>When comparing a function type with a function it must have the same structure in order to be considered valid.</source>
          <target state="translated">При сравнении типа функции с функцией она должна иметь одинаковую структуру,чтобы считаться действительной.</target>
        </trans-unit>
        <trans-unit id="64ef3ae0ab9bcb0e4ab1d4e8a1404fcbb0a3607c" translate="yes" xml:space="preserve">
          <source>When comparing an object type with an object it must have the same structure in order to be considered valid.</source>
          <target state="translated">При сравнении типа объекта с объектом он должен иметь одинаковую структуру,чтобы считаться действительным.</target>
        </trans-unit>
        <trans-unit id="8396399d85dff5129d383218ce52eac55a623a9e" translate="yes" xml:space="preserve">
          <source>When importing an opaque type alias, it behaves like a &lt;a href=&quot;https://flow.org/en/lang/nominal-structural/#toc-nominal-typing&quot;&gt;nominal type&lt;/a&gt;, hiding its underlying type.</source>
          <target state="translated">При импорте псевдонима непрозрачного типа он ведет себя как &lt;a href=&quot;https://flow.org/en/lang/nominal-structural/#toc-nominal-typing&quot;&gt;номинальный тип&lt;/a&gt; , скрывая свой базовый тип.</target>
        </trans-unit>
        <trans-unit id="d2485de3e0573347cabc863911d04dfca31e158c" translate="yes" xml:space="preserve">
          <source>When in the same file the alias is defined, opaque type aliases behave exactly as regular &lt;a href=&quot;../aliases&quot;&gt;type aliases&lt;/a&gt; do.</source>
          <target state="translated">Когда в том же файле определен псевдоним, псевдонимы непрозрачного типа ведут себя точно так же, как &lt;a href=&quot;../aliases&quot;&gt;псевдонимы&lt;/a&gt; обычного типа .</target>
        </trans-unit>
        <trans-unit id="fcb175c445847655877f1db30e472a996195f098" translate="yes" xml:space="preserve">
          <source>When setting a new value inside a tuple, the new value must match the type at that index.</source>
          <target state="translated">При установке нового значения внутри кортежа новое значение должно соответствовать типу в этом индексе.</target>
        </trans-unit>
        <trans-unit id="7517a9e192b4a198ec7b3f51067f670add7135eb" translate="yes" xml:space="preserve">
          <source>When someone writes a class, they are declaring a &lt;em&gt;thing&lt;/em&gt;. This thing might have the same structure as something else but they still serve different purposes. Imagine two component classes that both have &lt;code&gt;render()&lt;/code&gt; methods, these components could still have totally different purposes, but in a structural type system they&amp;rsquo;d be considered exactly the same.</source>
          <target state="translated">Когда кто-то пишет класс, он объявляет &lt;em&gt;вещь&lt;/em&gt; . Эта вещь может иметь ту же структуру, что и что-то еще, но они все равно служат другим целям. Представьте себе два класса компонентов, оба из которых имеют методы &lt;code&gt;render()&lt;/code&gt; , эти компоненты могут иметь совершенно разные цели, но в системе структурных типов они будут считаться совершенно одинаковыми.</target>
        </trans-unit>
        <trans-unit id="95d1e8cda45984711f6710361a85006d8bcb3ff6" translate="yes" xml:space="preserve">
          <source>When the request fails, we&amp;rsquo;ll get back an object with &lt;code&gt;success&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; and an &lt;code&gt;error&lt;/code&gt; property describing the error.</source>
          <target state="translated">В случае сбоя запроса мы вернем объект с &lt;code&gt;success&lt;/code&gt; установлено значение &lt;code&gt;false&lt;/code&gt; , и свойство &lt;code&gt;error&lt;/code&gt; , описывающее ошибку.</target>
        </trans-unit>
        <trans-unit id="b94abdda8ce69397406ef44dd82ee02693dedecd" translate="yes" xml:space="preserve">
          <source>When this flag is &lt;code&gt;true&lt;/code&gt;, Flow has the following behavior:</source>
          <target state="translated">Когда этот флаг установлен в &lt;code&gt;true&lt;/code&gt; , Flow ведет себя следующим образом:</target>
        </trans-unit>
        <trans-unit id="1be3aebbba7f2ab96d8a1da1d160dd3a2c2cfa21" translate="yes" xml:space="preserve">
          <source>When using a generic type for a value, Flow will track the value and make sure that you aren&amp;rsquo;t replacing it with something else.</source>
          <target state="translated">При использовании универсального типа для значения Flow будет отслеживать значение и следить за тем, чтобы вы не заменяли его чем-то другим.</target>
        </trans-unit>
        <trans-unit id="967200160ca1f6e61c2f31daca12d9063b3bdc5b" translate="yes" xml:space="preserve">
          <source>When using this syntax, you are not required to give it a type annotation. But you still can if you need to.</source>
          <target state="translated">При использовании этого синтаксиса не требуется давать ему типовую аннотацию.Но вы все равно можете,если понадобится.</target>
        </trans-unit>
        <trans-unit id="5028ae04135e00456a2a9a3d217b11e267ea9467" translate="yes" xml:space="preserve">
          <source>When you add a subtyping constraint to an opaque type alias, we allow the opaque type to be used as the super type when outside of the defining file.</source>
          <target state="translated">Когда вы добавляете ограничение на подтипирование к псевдониму непрозрачного типа,мы разрешаем использовать непрозрачный тип в качестве супертипа,когда он находится вне определяющего файла.</target>
        </trans-unit>
        <trans-unit id="7f4548b3e8ef7180dc3aa259a4fafbe13e9785c6" translate="yes" xml:space="preserve">
          <source>When you are certain your code works and for some reason Flow is unable to type check it correctly. There are a (decreasing) number of idioms in JavaScript that Flow is unable to statically type.</source>
          <target state="translated">Когда вы уверены,что ваш код работает и по каким-то причинам Flow не может корректно его напечатать,проверьте его.В JavaScript есть (уменьшающееся)количество идиом,которые Flow не может статически набрать.</target>
        </trans-unit>
        <trans-unit id="0640e9c67a5446e2d096da264d95ec5c0854ffcf" translate="yes" xml:space="preserve">
          <source>When you are declaring a new variable, you may optionally declare its type.</source>
          <target state="translated">Когда вы объявляете новую переменную,вы можете объявить ее тип.</target>
        </trans-unit>
        <trans-unit id="7d4a50c3c1cd36ed94156b1a9f3ca046b8801870" translate="yes" xml:space="preserve">
          <source>When you are getting a value from a tuple at a specific index, it will return the type at that index.</source>
          <target state="translated">Когда вы получаете значение от кортежа по определенному индексу,он возвращает тип по этому индексу.</target>
        </trans-unit>
        <trans-unit id="01a3af0d6ce8b90608026581625e6d89d89308d5" translate="yes" xml:space="preserve">
          <source>When you are in the process of converting existing code to using Flow types and you are currently blocked on having the code type checked (maybe other code needs to be converted first).</source>
          <target state="translated">Когда вы находитесь в процессе преобразования существующего кода к использованию типов Flow,и вы в настоящее время заблокированы на проведение проверки типа кода (возможно,сначала необходимо преобразовать другой код).</target>
        </trans-unit>
        <trans-unit id="e1e90957894730cc07cfd478f29c1f4e5b53f0ac" translate="yes" xml:space="preserve">
          <source>When you create an intersection of object types, you merge all of their properties together.</source>
          <target state="translated">При создании пересечения типов объектов происходит объединение всех их свойств.</target>
        </trans-unit>
        <trans-unit id="e5b45384d6cd9faea2b667285789acfc51eefb58" translate="yes" xml:space="preserve">
          <source>When you create an object with its properties, you create a &lt;em&gt;sealed&lt;/em&gt; object type in Flow. These sealed objects will know all of the properties you declared them with and the types of their values.</source>
          <target state="translated">Когда вы создаете объект с его свойствами, вы создаете тип &lt;em&gt;запечатанного&lt;/em&gt; объекта в Flow. Эти запечатанные объекты будут знать все свойства, с которыми вы их объявили, и типы их значений.</target>
        </trans-unit>
        <trans-unit id="a41115243f1e2d1d0a4ea4f2efbfe55245e33a0c" translate="yes" xml:space="preserve">
          <source>When you create an object without any properties, you create an &lt;em&gt;unsealed&lt;/em&gt; object type in Flow. These unsealed objects will not know all of their properties and will allow you to add new ones.</source>
          <target state="translated">Когда вы создаете объект без каких-либо свойств, вы создаете &lt;em&gt;незапечатанный&lt;/em&gt; тип объекта в Flow. Эти незапечатанные объекты не будут знать всех своих свойств и позволят вам добавлять новые.</target>
        </trans-unit>
        <trans-unit id="2796a6c82e1741b853aad01a67eda238fc96c9eb" translate="yes" xml:space="preserve">
          <source>When you create an opaque type alias with a subtyping constraint, the type in the type position must be a subtype of the type in the super type position.</source>
          <target state="translated">Когда вы создаете псевдоним непрозрачного типа с ограничением по подтипу,тип в позиции типа должен быть подтипом типа в позиции супертипа.</target>
        </trans-unit>
        <trans-unit id="49218e622c26dc57b5c913ea8900e0123789162a" translate="yes" xml:space="preserve">
          <source>When you do not provide a type, the inferred type will do one of two things if you re-assign it.</source>
          <target state="translated">Когда вы не указываете тип,предполагаемый тип сделает одну из двух вещей,если вы повторно его назначите.</target>
        </trans-unit>
        <trans-unit id="dad7818449b82b15d065d9c37e04d1727c40f683" translate="yes" xml:space="preserve">
          <source>When you have a value which is a union type it&amp;rsquo;s often useful to break it apart and handle each individual type separately. With union types in Flow you can &amp;ldquo;refine&amp;rdquo; the value down to a single type.</source>
          <target state="translated">Когда у вас есть значение, которое является типом объединения, часто бывает полезно разбить его на части и обрабатывать каждый отдельный тип отдельно. С помощью типов объединения в Flow вы можете &amp;laquo;уточнить&amp;raquo; значение до одного типа.</target>
        </trans-unit>
        <trans-unit id="bb229dc9cf4f41267624f023e36cd675a57c24d6" translate="yes" xml:space="preserve">
          <source>When you have a value with the type &lt;code&gt;any&lt;/code&gt;, you can cause Flow to infer &lt;code&gt;any&lt;/code&gt; for the results of all of the operations you perform.</source>
          <target state="translated">Когда у вас есть значение с типом &lt;code&gt;any&lt;/code&gt; , вы можете заставить Flow вывести &lt;code&gt;any&lt;/code&gt; для результатов всех выполняемых вами операций.</target>
        </trans-unit>
        <trans-unit id="4eeac5c8af6e744b935a9344a38a377561163682" translate="yes" xml:space="preserve">
          <source>When you have complicated types that you want to reuse in multiple places, you can alias them in Flow using a &lt;strong&gt;type alias&lt;/strong&gt;.</source>
          <target state="translated">Если у вас есть сложные типы, которые вы хотите повторно использовать в нескольких местах, вы можете присвоить им псевдоним в Flow, используя &lt;strong&gt;псевдоним типа&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d25839cb54cf8d678ab4f10e96c01f04e2a7fa3e" translate="yes" xml:space="preserve">
          <source>When you have properties that overlap by having the same name, Flow follows the same strategy as with overloaded functions: it will return the type of the first property that matches this name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ca6b3bbee47f3932b78bb3624b2a8e13ee5660b" translate="yes" xml:space="preserve">
          <source>When you have two classes with the same structure, they still are not considered equivalent because Flow uses nominal typing for classes.</source>
          <target state="translated">Когда у вас есть два класса с одинаковой структурой,они все равно не считаются эквивалентными,потому что Flow использует номинальную типизацию для классов.</target>
        </trans-unit>
        <trans-unit id="10b1b571956caaa58b630e76dcdcbd496c248766" translate="yes" xml:space="preserve">
          <source>When you provide a type, you will be able to re-assign the value, but it must always be of a compatible type.</source>
          <target state="translated">Когда вы указываете тип,вы сможете переприсвоить значение,но оно всегда должно быть совместимого типа.</target>
        </trans-unit>
        <trans-unit id="73cb2287de1c6f15cf8167e43a3d3d87043228a3" translate="yes" xml:space="preserve">
          <source>When you retrieve an element from an array there is always a possibility that it is &lt;code&gt;undefined&lt;/code&gt;. You could have either accessed an index which is out of the bounds of the array, or the element could not exist because it is a &amp;ldquo;sparse array&amp;rdquo;.</source>
          <target state="translated">Когда вы извлекаете элемент из массива, всегда есть вероятность, что он не &lt;code&gt;undefined&lt;/code&gt; . Вы могли либо получить доступ к индексу, выходящему за пределы массива, либо элемент не мог существовать, потому что это &amp;laquo;разреженный массив&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="996a2595f6a66f040b899960922e9f1e015492aa" translate="yes" xml:space="preserve">
          <source>When you run your code, a single expression will only be run with a limited set of values. But still Flow checks &lt;em&gt;every&lt;/em&gt; possible value. In this way Flow is checking too many things or &lt;em&gt;over-approximating&lt;/em&gt; what will be valid code.</source>
          <target state="translated">Когда вы запускаете свой код, одно выражение будет выполняться только с ограниченным набором значений. Но все же Flow проверяет &lt;em&gt;все&lt;/em&gt; возможные значения. Таким образом, Flow проверяет слишком много вещей или &lt;em&gt;переоценивает&lt;/em&gt; то, что будет правильным кодом.</target>
        </trans-unit>
        <trans-unit id="cfdf2c27394909eba3b1ac9709368e9e60c92c6c" translate="yes" xml:space="preserve">
          <source>When you strip the types all that is left is the value.</source>
          <target state="translated">Когда вы удаляете типы,все,что осталось,это значение.</target>
        </trans-unit>
        <trans-unit id="16d02930754982f643818365c9eb65e4b4b501a2" translate="yes" xml:space="preserve">
          <source>When you try to use a value of a &lt;code&gt;mixed&lt;/code&gt; type you must first figure out what the actual type is or you&amp;rsquo;ll end up with an error.</source>
          <target state="translated">Когда вы пытаетесь использовать значение &lt;code&gt;mixed&lt;/code&gt; типа, вы должны сначала выяснить, что это за тип, иначе вы получите ошибку.</target>
        </trans-unit>
        <trans-unit id="5a280997d975deface44a674ffdcce743182e95b" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;typeof&lt;/code&gt;, you&amp;rsquo;re inserting another type with all of its behaviors. This can make &lt;code&gt;typeof&lt;/code&gt; seem inconsistent where it is not.</source>
          <target state="translated">Когда вы используете &lt;code&gt;typeof&lt;/code&gt; , вы вставляете другой тип со всем его поведением. Это может сделать &lt;code&gt;typeof&lt;/code&gt; непоследовательным там, где это не так.</target>
        </trans-unit>
        <trans-unit id="d77557c593fb829bce95fc59df4b1a3be746ce8b" translate="yes" xml:space="preserve">
          <source>When you use the name of your class in an annotation, it means an &lt;em&gt;instance&lt;/em&gt; of your class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06a3b2f1c8635c3489f18114c859485b4887b6c9" translate="yes" xml:space="preserve">
          <source>When you use this function, Flow knows exactly what is going on.</source>
          <target state="translated">Когда вы используете эту функцию,Flow точно знает,что происходит.</target>
        </trans-unit>
        <trans-unit id="b433fb4be7e2c12ca3f57f9ed0a23cad0b0d75ad" translate="yes" xml:space="preserve">
          <source>When you write a type cast expression, the result of that expression is the value with the provided type. If you hold onto the resulting value, it will have the new type.</source>
          <target state="translated">Когда вы пишете выражение приведения типа,результатом этого выражения является значение с указанным типом.Если удержать полученное значение,то оно будет иметь новый тип.</target>
        </trans-unit>
        <trans-unit id="f5f053b01bbe2e5493eb03b59a33406b2934f8f5" translate="yes" xml:space="preserve">
          <source>Whenever you want to use a class field in Flow you must first give it an annotation.</source>
          <target state="translated">Всякий раз,когда вы хотите использовать поле класса в Flow,вы должны сначала дать ему аннотацию.</target>
        </trans-unit>
        <trans-unit id="007c9142c650370d910eaa325adeac0c9f34bd33" translate="yes" xml:space="preserve">
          <source>Where to put the &lt;code&gt;.flowconfig&lt;/code&gt;</source>
          <target state="translated">Куда положить &lt;code&gt;.flowconfig&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9cd9b92722317ed472575adad6561c4aaa8a0c9" translate="yes" xml:space="preserve">
          <source>Which also applies to nested types within objects.</source>
          <target state="translated">Что также относится к вложенным типам внутри объектов.</target>
        </trans-unit>
        <trans-unit id="5d77dcbc51b2f3900b8512f7fcc4c2e9f1910a53" translate="yes" xml:space="preserve">
          <source>Which then gets used as its own type.</source>
          <target state="translated">Который затем используется как свой собственный тип.</target>
        </trans-unit>
        <trans-unit id="8a80fced10ab4b19389a445b9f4af05de4c583bb" translate="yes" xml:space="preserve">
          <source>Which would ignore any file or directory under the directory named &lt;code&gt;__tests__/&lt;/code&gt; within the project root. However, unlike the previous example&amp;rsquo;s &lt;code&gt;.*/__tests__/.*&lt;/code&gt;, it would NOT ignore files or directories under other directories named &lt;code&gt;__tests__/&lt;/code&gt;, like &lt;code&gt;src/__tests__/&lt;/code&gt;.</source>
          <target state="translated">Что будет игнорировать любой файл или каталог в каталоге с именем &lt;code&gt;__tests__/&lt;/code&gt; в корне проекта. Однако, в отличие от &lt;code&gt;.*/__tests__/.*&lt;/code&gt; предыдущего примера , он НЕ будет игнорировать файлы или каталоги в других каталогах с именем &lt;code&gt;__tests__/&lt;/code&gt; , например &lt;code&gt;src/__tests__/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c59a762c09f756bb3fe009f558e38099bc0a51a6" translate="yes" xml:space="preserve">
          <source>Which would parse in declaration mode any file or directory under the directory named &lt;code&gt;third_party/&lt;/code&gt; within the project root. However, unlike the previous example&amp;rsquo;s &lt;code&gt;.*/third_party/.*&lt;/code&gt;, it would NOT parse files or directories under directories named &lt;code&gt;third_party/&lt;/code&gt;, like &lt;code&gt;src/third_party/&lt;/code&gt;.</source>
          <target state="translated">Которая будет анализировать в режиме объявления любой файл или каталог в каталоге с именем &lt;code&gt;third_party/&lt;/code&gt; в корне проекта. Однако, в отличие от &lt;code&gt;.*/third_party/.*&lt;/code&gt; из предыдущего примера , он НЕ будет анализировать файлы или каталоги в каталогах с именем &lt;code&gt;third_party/&lt;/code&gt; , например &lt;code&gt;src/third_party/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bbea4304dd73554152ad23aedd562115dbd9129" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;all&lt;/code&gt; isn&amp;rsquo;t technically a lint rule, it&amp;rsquo;s worth mentioning here. &lt;code&gt;all&lt;/code&gt; sets the default level for lint rules that don&amp;rsquo;t have a level set explicitly. &lt;code&gt;all&lt;/code&gt; can only occur as the first entry in a &lt;code&gt;.flowconfig&lt;/code&gt; or as the first rule in a &lt;code&gt;--lints&lt;/code&gt; flag. It&amp;rsquo;s not allowed in comments at all because it would have different semantics than would be expected.</source>
          <target state="translated">Хотя &lt;code&gt;all&lt;/code&gt; это не технически правило пуха, стоит упомянуть здесь. &lt;code&gt;all&lt;/code&gt; устанавливает уровень по умолчанию для правил lint, для которых явно не установлен уровень. &lt;code&gt;all&lt;/code&gt; может встречаться только как первая запись в &lt;code&gt;.flowconfig&lt;/code&gt; или как первое правило в флаге &lt;code&gt;--lints&lt;/code&gt; . Это вообще не разрешено в комментариях, потому что это будет иметь другую семантику, чем можно было бы ожидать.</target>
        </trans-unit>
        <trans-unit id="52ea1ea47df53d1cf736a6d4890e67395ca8b9c4" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I pass &lt;code&gt;{a:string}&lt;/code&gt; to a function that takes &lt;code&gt;{a:string|&amp;nbsp;number}&lt;/code&gt;</source>
          <target state="translated">Почему я не могу передать &lt;code&gt;{a:string}&lt;/code&gt; функции, которая принимает &lt;code&gt;{a:string|&amp;nbsp;number}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe6cefc353f86770ed15c2136f41c2eff2427e68" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I pass an &lt;code&gt;Array&amp;lt;string&amp;gt;&lt;/code&gt; to a function that takes an &lt;code&gt;Array&amp;lt;string |&amp;nbsp;number&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Почему я не могу передать &lt;code&gt;Array&amp;lt;string&amp;gt;&lt;/code&gt; функции, которая принимает &lt;code&gt;Array&amp;lt;string |&amp;nbsp;number&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96c5c443e0f5b7e99e95365f6c4edd88369864cd" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I refine a union of objects?</source>
          <target state="translated">Почему я не могу улучшить объединение объектов?</target>
        </trans-unit>
        <trans-unit id="6e3de66a2c90224644ba944e2aa7479606459060" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I use a function in my if-clause to check the type of a property?</source>
          <target state="translated">Почему я не могу использовать функцию в предложении if для проверки типа свойства?</target>
        </trans-unit>
        <trans-unit id="30ff0da03e55358af58809fea89afe7aa72356c6" translate="yes" xml:space="preserve">
          <source>Width Subtyping</source>
          <target state="translated">Ширина субтипирование</target>
        </trans-unit>
        <trans-unit id="c4a257d9d182ebc37abf03c9319df6d8959cf5db" translate="yes" xml:space="preserve">
          <source>With Flow build step, using flow-bin</source>
          <target state="translated">С Flow build step,с использованием flow-bin</target>
        </trans-unit>
        <trans-unit id="2995c53166bcc91b45280d17fe04fd71848fc06d" translate="yes" xml:space="preserve">
          <source>With exact object types, we cannot have additional properties, so the objects conflict with one another and we are able to distinguish which is which.</source>
          <target state="translated">При точных типах объектов мы не можем иметь дополнительных свойств,поэтому объекты конфликтуют друг с другом,и мы можем различать,какой из них какой.</target>
        </trans-unit>
        <trans-unit id="c6943265cff3d8a72357d6db4963743033fc9d4b" translate="yes" xml:space="preserve">
          <source>With modularity, we can aggressively parallelize our analysis. Furthermore, when files change, we can incrementally analyze only those files that depend on the changed files. Together, these choices have helped scale the analysis to millions of lines of code.</source>
          <target state="translated">Благодаря модульности мы можем агрессивно распараллелить наш анализ.Более того,при изменении файлов мы можем инкрементально анализировать только те файлы,которые зависят от измененных файлов.Вместе эти варианты помогли масштабировать анализ до миллионов строк кода.</target>
        </trans-unit>
        <trans-unit id="3574433dfccbc2cdc3e7d09b6a827e56cbb69b39" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;method&lt;/code&gt;, we know that &lt;code&gt;obj&lt;/code&gt; has at least a property &lt;code&gt;foo&lt;/code&gt; and the property access expression &lt;code&gt;obj.foo&lt;/code&gt; will have type &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Внутри &lt;code&gt;method&lt;/code&gt; мы знаем, что &lt;code&gt;obj&lt;/code&gt; имеет как минимум свойство &lt;code&gt;foo&lt;/code&gt; , а выражение доступа к свойству &lt;code&gt;obj.foo&lt;/code&gt; будет иметь тип &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f4fbc91308a94a65821208a1c024c9c0775a04d" translate="yes" xml:space="preserve">
          <source>Within the -lints flag and the flowconfig, rules lower down override rules higher up, allowing you to write things like</source>
          <target state="translated">Внутри флага -lints и flowconfig,правила переопределения вниз,правила переопределения вверх,что позволяет писать такие вещи как</target>
        </trans-unit>
        <trans-unit id="c37d919a96ee4ea89b463c060f82bc0a6e402a8f" translate="yes" xml:space="preserve">
          <source>Within the Defining File</source>
          <target state="translated">В пределах Определяющего Файла</target>
        </trans-unit>
        <trans-unit id="d68dc31f474400f6b50bf4dad60cd35f6668b0b3" translate="yes" xml:space="preserve">
          <source>Within the body of a &lt;code&gt;declare module&lt;/code&gt; block, you can specify the set of exports for that module. However, before we start talking about exports we have to talk about the two kinds of modules that Flow supports: CommonJS and ES modules.</source>
          <target state="translated">В теле блока &lt;code&gt;declare module&lt;/code&gt; вы можете указать набор экспортов для этого модуля. Однако, прежде чем мы начнем говорить об экспорте, мы должны поговорить о двух типах модулей, которые поддерживает Flow: CommonJS и ES-модулях.</target>
        </trans-unit>
        <trans-unit id="a3933bb581c579641e65e780ba1a7fc018cbb1e5" translate="yes" xml:space="preserve">
          <source>Write Flow Code</source>
          <target state="translated">Написать код потока</target>
        </trans-unit>
        <trans-unit id="0d42dc7f273412358b6af025e21835f6b2b59f3c" translate="yes" xml:space="preserve">
          <source>You are destructuring the object. When destructuring, Flow loses track of object properties.</source>
          <target state="translated">Вы уничтожаете объект.При уничтожении Flow теряет контроль над свойствами объекта.</target>
        </trans-unit>
        <trans-unit id="5a1fd67e5d3bc9809749035f19782f6067817cf6" translate="yes" xml:space="preserve">
          <source>You are not allowed to do the following when using &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">При использовании &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; вам не разрешается делать следующее :</target>
        </trans-unit>
        <trans-unit id="cb97175b80248d75078c2d56240c55e682afdb8b" translate="yes" xml:space="preserve">
          <source>You are using inexact objects.</source>
          <target state="translated">Вы используете неточные объекты.</target>
        </trans-unit>
        <trans-unit id="545f113ee57613cf761d4e16a9296f0dddf18ea1" translate="yes" xml:space="preserve">
          <source>You can add methods to interfaces following the same syntax as object methods.</source>
          <target state="translated">Вы можете добавлять методы к интерфейсам,следуя тому же синтаксису,что и объектные методы.</target>
        </trans-unit>
        <trans-unit id="f13b654915322571d79f9d2209ebb3f541cb4c01" translate="yes" xml:space="preserve">
          <source>You can add properties to interfaces following the same syntax as object properties.</source>
          <target state="translated">Вы можете добавлять свойства к интерфейсам,следуя тому же синтаксису,что и свойства объектов.</target>
        </trans-unit>
        <trans-unit id="0ff142ce9ee3fec9b4cc52b1ba40b05d9245d3f7" translate="yes" xml:space="preserve">
          <source>You can add support for Flow in Emacs by using &lt;a href=&quot;https://github.com/flowtype/flow-for-emacs&quot;&gt;flow-for-emacs&lt;/a&gt;</source>
          <target state="translated">Вы можете добавить поддержку Flow в Emacs, используя &lt;a href=&quot;https://github.com/flowtype/flow-for-emacs&quot;&gt;flow-for-emacs&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f60bece6a43fa1f4f89bb550305ddcf7599cfe4f" translate="yes" xml:space="preserve">
          <source>You can add this to your &lt;code&gt;package.json&lt;/code&gt; scripts easily.</source>
          <target state="translated">Вы можете легко добавить это в свои скрипты &lt;code&gt;package.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c722675694802907c5488d3f01827234fdbd4367" translate="yes" xml:space="preserve">
          <source>You can also add type annotations for rest parameters using the same syntax but with an &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">Вы также можете добавить аннотации типов для остальных параметров, используя тот же синтаксис, но с &lt;code&gt;Array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e71d63fcbe7402ef7a02851894adf81dac971541" translate="yes" xml:space="preserve">
          <source>You can also adopt Flow incrementally and easily remove it at anytime, so you can try Flow out on any codebase and see how you like it.</source>
          <target state="translated">Вы также можете принять Flow постепенно и легко удалить его в любое время,так что вы можете попробовать Flow out на любой кодовой базе и посмотреть,как вам это нравится.</target>
        </trans-unit>
        <trans-unit id="699187814f44354c9d5904df70d1d9ddacb546d5" translate="yes" xml:space="preserve">
          <source>You can also create arrays and add values to them later on:</source>
          <target state="translated">Вы также можете создавать массивы и добавлять в них значения позже:</target>
        </trans-unit>
        <trans-unit id="c646f56329a9cb5b56e87a03fe5b8a2719eb6c74" translate="yes" xml:space="preserve">
          <source>You can also declare opaque type aliases in &lt;a href=&quot;../libdefs&quot;&gt;libdefs&lt;/a&gt;. There, you omit the underlying type, but may still optionally include a super type.</source>
          <target state="translated">Вы также можете объявить псевдонимы непрозрачного типа в &lt;a href=&quot;../libdefs&quot;&gt;libdefs&lt;/a&gt; . Здесь вы опускаете базовый тип, но при желании можете включать супертип.</target>
        </trans-unit>
        <trans-unit id="cdd17629705a4d950906c4a4641c7cec10003dd5" translate="yes" xml:space="preserve">
          <source>You can also give generic classes type arguments directly in the &lt;code&gt;new&lt;/code&gt; expression:</source>
          <target state="translated">Вы также можете указать аргументы типа универсальных классов непосредственно в &lt;code&gt;new&lt;/code&gt; выражении:</target>
        </trans-unit>
        <trans-unit id="b0940d878e3d44c8bd9c7d98cbd45fecf2f71a13" translate="yes" xml:space="preserve">
          <source>You can also have optional parameters by adding a question mark &lt;code&gt;?&lt;/code&gt; after the name of the parameter and before the colon &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">Вы также можете указать дополнительные параметры, добавив знак вопроса &lt;code&gt;?&lt;/code&gt; после того, как имя параметра и перед двоеточием &lt;code&gt;:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cbe3e05438e8030d576dbde48b1eceb1121d9a3" translate="yes" xml:space="preserve">
          <source>You can also nest calls to &lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt;, which is useful when you need to access the types inside nested structures:</source>
          <target state="translated">Вы также можете вкладывать вызовы в &lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt; , что полезно, когда вам нужно получить доступ к типам внутри вложенных структур:</target>
        </trans-unit>
        <trans-unit id="815ff0c60624ac9094cf1c49f665f71a3473e58d" translate="yes" xml:space="preserve">
          <source>You can also provide defaults for parameterized generics just like parameters of a function.</source>
          <target state="translated">Вы также можете предоставить значения по умолчанию для параметризованных генераторов,как и для параметров функции.</target>
        </trans-unit>
        <trans-unit id="719a9a50e459a2a6ce7e2c56e63ed6b525dc0279" translate="yes" xml:space="preserve">
          <source>You can also specify the subtyping behavior of a generic via variance sigils. By default, generics behave invariantly, but you may add a &lt;code&gt;+&lt;/code&gt; to their declaration to make them behave covariantly, or a &lt;code&gt;-&lt;/code&gt; to their declaration to make them behave contravariantly. See &lt;a href=&quot;https://flow.org/en/lang/variance&quot;&gt;our docs on variance&lt;/a&gt; for a more information on variance in Flow.</source>
          <target state="translated">Вы также можете указать поведение универсального подтипа с помощью сигилов отклонения. По умолчанию дженерики ведут себя инвариантно, но вы можете добавить к их объявлению знак &lt;code&gt;+&lt;/code&gt; , чтобы они вели себя ковариантно, или знак &lt;code&gt;-&lt;/code&gt; к их объявлению, чтобы они вели себя контравариантно. См. &lt;a href=&quot;https://flow.org/en/lang/variance&quot;&gt;Нашу документацию по дисперсии&lt;/a&gt; для получения дополнительной информации о дисперсии в Flow.</target>
        </trans-unit>
        <trans-unit id="f9363b7818b6e43e3422f3ad1d7ee6efa7ab8e46" translate="yes" xml:space="preserve">
          <source>You can also type &lt;code&gt;flow&lt;/code&gt; to accomplish the same effect as &lt;code&gt;status&lt;/code&gt; is the default flag to the &lt;code&gt;flow&lt;/code&gt; binary.</source>
          <target state="translated">Вы также можете ввести &lt;code&gt;flow&lt;/code&gt; для достижения того же эффекта, что и &lt;code&gt;status&lt;/code&gt; флага по умолчанию для двоичного &lt;code&gt;flow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b68e51da33b5e539af5dbf6e3dcc5a59c33fe6c7" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;implements&lt;/code&gt; to tell Flow that you want the class to match an interface. This prevents you from making incompatible changes when editing the class.</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;implements&lt;/code&gt; чтобы сообщить Flow, что вы хотите, чтобы класс соответствовал интерфейсу. Это предотвращает внесение несовместимых изменений при редактировании класса.</target>
        </trans-unit>
        <trans-unit id="e3a1292b81cf7cdb77a98439b57cf0147e0f8f3b" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;implements&lt;/code&gt; with multiple interfaces.</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;implements&lt;/code&gt; с несколькими интерфейсами.</target>
        </trans-unit>
        <trans-unit id="48dd13ac8774ad647e286bd9947352ec269d5800" translate="yes" xml:space="preserve">
          <source>You can also use named type imports in either an ES module environment or a CommonJS environment:</source>
          <target state="translated">Вы также можете использовать импорт именованного типа либо в модульной среде ES,либо в среде CommonJS:</target>
        </trans-unit>
        <trans-unit id="7a88daebe91d272da9a7e038c3583dda16175e43" translate="yes" xml:space="preserve">
          <source>You can also use the form &lt;code&gt;/* @flow */&lt;/code&gt; for the flag as well.</source>
          <target state="translated">Вы также можете использовать форму &lt;code&gt;/* @flow */&lt;/code&gt; для флага.</target>
        </trans-unit>
        <trans-unit id="01c4697a441a0d2aa3c1b9f07e0ceb2ffc32acec" translate="yes" xml:space="preserve">
          <source>You can also validate that you have handled every single type of action by using the &lt;code&gt;empty&lt;/code&gt; type in your &lt;code&gt;default&lt;/code&gt; case.</source>
          <target state="translated">Вы также можете проверить, обработали ли вы каждый отдельный тип действия, используя &lt;code&gt;empty&lt;/code&gt; тип в вашем случае по &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d608633d54b23080262b0d07f6cb7d3dc534564" translate="yes" xml:space="preserve">
          <source>You can benefit from having Flow run as you develop by integrating into your editor.</source>
          <target state="translated">Вы можете извлечь выгоду из запуска Flow в процессе разработки,интегрировав его в свой редактор.</target>
        </trans-unit>
        <trans-unit id="2dcc931397145e4c230e84b33d5d8a5720c03798" translate="yes" xml:space="preserve">
          <source>You can create &lt;a href=&quot;../objects#toc-objects-as-maps&quot;&gt;&amp;ldquo;indexer properties&amp;rdquo;&lt;/a&gt; the same way as with objects.</source>
          <target state="translated">Вы можете создавать &lt;a href=&quot;../objects#toc-objects-as-maps&quot;&gt;&amp;laquo;свойства индексатора&amp;raquo; так&lt;/a&gt; же, как и с объектами.</target>
        </trans-unit>
        <trans-unit id="b7946b65fbac98e9648cd5f68e306b48534b1a74" translate="yes" xml:space="preserve">
          <source>You can do that by adding an explicit type argument:</source>
          <target state="translated">Вы можете сделать это,добавив явный аргумент типа:</target>
        </trans-unit>
        <trans-unit id="d7fff0a703433e91168cd9bf5a21b4d5e3872e70" translate="yes" xml:space="preserve">
          <source>You can enable stronger safety guarantees in Flow (such as banning &lt;code&gt;any&lt;/code&gt;/&lt;code&gt;Object&lt;/code&gt;/&lt;code&gt;Function&lt;/code&gt; types and requiring all dependencies to be typed) by adding &lt;strong&gt;&lt;code&gt;@flow strict&lt;/code&gt;&lt;/strong&gt; to your files.</source>
          <target state="translated">Вы можете включить более строгие гарантии безопасности в Flow (например, запретить &lt;code&gt;any&lt;/code&gt; типы / &lt;code&gt;Object&lt;/code&gt; / &lt;code&gt;Function&lt;/code&gt; и требовать &lt;strong&gt; &lt;code&gt;@flow strict&lt;/code&gt; &lt;/strong&gt; всех зависимостей), добавив &lt;strong&gt;@flow strict&lt;/strong&gt; к вашим файлам.</target>
        </trans-unit>
        <trans-unit id="eaa5fe932d239a06fd9575f03866b957b8981092" translate="yes" xml:space="preserve">
          <source>You can enforce this in Flow by making every property effectively &amp;ldquo;read-only&amp;rdquo; using &amp;ldquo;covariant&amp;rdquo; properties throughout your state object.</source>
          <target state="translated">Вы можете обеспечить это в Flow, сделав каждое свойство &amp;laquo;доступным только для чтения&amp;raquo;, используя &amp;laquo;ковариантные&amp;raquo; свойства во всем объекте состояния.</target>
        </trans-unit>
        <trans-unit id="ba6431d84c3e47b98b215406e4d6e813fefabd22" translate="yes" xml:space="preserve">
          <source>You can even nest lookups:</source>
          <target state="translated">Ты даже можешь искать гнезда:</target>
        </trans-unit>
        <trans-unit id="4ccb58e74c71e2de2b124e20c360c5995e2ecd92" translate="yes" xml:space="preserve">
          <source>You can expand this even further and keep refining possibilities away:</source>
          <target state="translated">Вы можете расширить это еще больше и продолжать совершенствовать возможности:</target>
        </trans-unit>
        <trans-unit id="f2afe0e2209309fcca1d0d4c82e4b42131180ea4" translate="yes" xml:space="preserve">
          <source>You can fix this by making &lt;code&gt;truthy&lt;/code&gt; a &lt;em&gt;predicate function&lt;/em&gt;, by using the &lt;code&gt;%checks&lt;/code&gt; annotation like so:</source>
          <target state="translated">Вы можете исправить это, сделав &lt;code&gt;truthy&lt;/code&gt; функцию &lt;em&gt;предиката&lt;/em&gt; , используя аннотацию &lt;code&gt;%checks&lt;/code&gt; например:</target>
        </trans-unit>
        <trans-unit id="1300bdbd711a74807a169ed243bc8221cc1ddb60" translate="yes" xml:space="preserve">
          <source>You can force Flow to treat one or more files as focused from the CLI.</source>
          <target state="translated">Вы можете заставить Flow обрабатывать один или несколько файлов как сфокусированные из CLI.</target>
        </trans-unit>
        <trans-unit id="235ba8a2cc1e9c6fd298a395322859ee23a447be" translate="yes" xml:space="preserve">
          <source>You can get around this by storing your checked values in local variables:</source>
          <target state="translated">Вы можете обойти это,сохранив ваши проверенные значения в локальных переменных:</target>
        </trans-unit>
        <trans-unit id="64fd44f437add0d9e133a8562afc12f273306434" translate="yes" xml:space="preserve">
          <source>You can give callable entities type arguments for their generics directly in the call:</source>
          <target state="translated">Вы можете задать аргументы вызываемых сущностей для их генериков непосредственно в вызове:</target>
        </trans-unit>
        <trans-unit id="8ade9cad1bbc6b49fbea6fdd6de913340f01abe2" translate="yes" xml:space="preserve">
          <source>You can have as many of these generics as you need in the type parameter list, naming them whatever you want:</source>
          <target state="translated">Вы можете иметь столько дженериков,сколько вам нужно,в списке параметров типа,называя их как вам угодно:</target>
        </trans-unit>
        <trans-unit id="5cf2172f11dbbcc47d7a009c576faeb7aa356654" translate="yes" xml:space="preserve">
          <source>You can make a property contravariant by adding a minus symbol - in front of the property name.</source>
          <target state="translated">Вы можете сделать противопоставление свойства,добавив символ минус-перед названием свойства.</target>
        </trans-unit>
        <trans-unit id="1bdca1788706e2fc8e4a9c9a6e2d01cd32f92dcf" translate="yes" xml:space="preserve">
          <source>You can make a property covariant by adding a plus symbol &lt;code&gt;+&lt;/code&gt; in front of the property name.</source>
          <target state="translated">Вы можете сделать свойство ковариантным, добавив знак плюса &lt;code&gt;+&lt;/code&gt; перед именем свойства.</target>
        </trans-unit>
        <trans-unit id="b010851670e4ca7a130bea951f459af8dca6a36b" translate="yes" xml:space="preserve">
          <source>You can optionally add a subtyping constraint to an opaque type alias by adding a colon &lt;code&gt;:&lt;/code&gt; and a type after the name.</source>
          <target state="translated">При желании вы можете добавить ограничение подтипа к псевдониму непрозрачного типа, добавив двоеточие &lt;code&gt;:&lt;/code&gt; и тип после имени.</target>
        </trans-unit>
        <trans-unit id="fd2496b164e62d7e0f41690b9f5e9552b1b451b8" translate="yes" xml:space="preserve">
          <source>You can pass as many arguments as you want into a rest parameter.</source>
          <target state="translated">Вы можете передать столько аргументов,сколько захотите,в параметр &quot;Остаток&quot;.</target>
        </trans-unit>
        <trans-unit id="e6bd5c0ce38f5afd67d2acbbfbe61b90c3c48db4" translate="yes" xml:space="preserve">
          <source>You can put any type within &lt;code&gt;Array&amp;lt;Type&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Вы можете поместить любой тип в &lt;code&gt;Array&amp;lt;Type&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="732207deaac1dc0f323e2c9b02fc147f8f812da1" translate="yes" xml:space="preserve">
          <source>You can simplify the two checks against &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; using a single &lt;code&gt;!= null&lt;/code&gt; check which will do both.</source>
          <target state="translated">Вы можете упростить две проверки на &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; , используя одну проверку &lt;code&gt;!= null&lt;/code&gt; которая сделает и то, и другое.</target>
        </trans-unit>
        <trans-unit id="9afabef0657e245fef1b9b2930123308edd5afac" translate="yes" xml:space="preserve">
          <source>You can specify in the &lt;code&gt;.flowconfig&lt;/code&gt; which version of Flow you expect to use. You do this with the &lt;code&gt;[version]&lt;/code&gt; section. If this section is omitted or left blank, then any version is allowed. If a version is specified and not matched, then Flow will immediately error and exit.</source>
          <target state="translated">Вы можете указать в &lt;code&gt;.flowconfig&lt;/code&gt; , какую версию Flow вы планируете использовать. Вы делаете это с помощью раздела &lt;code&gt;[version]&lt;/code&gt; . Если этот раздел опущен или оставлен пустым, допустима любая версия. Если версия указана и не соответствует, Flow немедленно выдаст ошибку и завершит работу.</target>
        </trans-unit>
        <trans-unit id="e03b894ceec87547a288939cd8aaf30ae007c81b" translate="yes" xml:space="preserve">
          <source>You can start to compare two objects by their keys. If one object contains all the keys of another object, then it may be a subtype.</source>
          <target state="translated">Вы можете начать сравнивать два объекта по их клавишам.Если один объект содержит все ключи другого объекта,то это может быть подтип.</target>
        </trans-unit>
        <trans-unit id="d28e07b9c51e5ffadf873da6f7a3f54bbf76f2f9" translate="yes" xml:space="preserve">
          <source>You can then, further dig into particular COMMANDs by adding the &lt;code&gt;--help&lt;/code&gt; flag.</source>
          <target state="translated">Затем вы можете более подробно изучить конкретные КОМАНДЫ, добавив флаг &lt;code&gt;--help&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd1e8c4360056b71335ea367a6b3e679639d25f3" translate="yes" xml:space="preserve">
          <source>You can think of this like passing arguments to a function, only the return value is a type that you can use.</source>
          <target state="translated">Об этом можно подумать,как о передаче аргументов в функцию,только возвращаемое значение является типом,который можно использовать.</target>
        </trans-unit>
        <trans-unit id="77a6915e052949d36dbc7c36f8a0ffc2fd6eea09" translate="yes" xml:space="preserve">
          <source>You can update your code to the more readable:</source>
          <target state="translated">Вы можете обновить свой код до более читабельного:</target>
        </trans-unit>
        <trans-unit id="ebd1cddf8c517151cd84a6cfd9b8b49383f2e6c4" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;typeof x === &quot;symbol&quot;&lt;/code&gt; to refine to a symbol.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;typeof x === &quot;symbol&quot;&lt;/code&gt; для уточнения до символа.</target>
        </trans-unit>
        <trans-unit id="b81520be069e0fa0c9db8cbcabf710cfccf37e42" translate="yes" xml:space="preserve">
          <source>You can use any value with &lt;code&gt;typeof&lt;/code&gt;:</source>
          <target state="translated">Вы можете использовать любое значение с &lt;code&gt;typeof&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5eb1e9ebfd9c95be03ab9be04d025560b3074e1c" translate="yes" xml:space="preserve">
          <source>You can use generics in the same places you&amp;rsquo;d add any other type in a class (property types and method parameter/return types).</source>
          <target state="translated">Вы можете использовать универсальные шаблоны в тех же местах, где вы добавляете любой другой тип в класс (типы свойств и типы параметров / возвращаемых значений метода).</target>
        </trans-unit>
        <trans-unit id="f4aa0e86d6f17a2f8d19918819c102cbd6c3820e" translate="yes" xml:space="preserve">
          <source>You can use generics in the same places you&amp;rsquo;d add any other type in a function (parameter or return types).</source>
          <target state="translated">Вы можете использовать дженерики в тех же местах, где вы добавляете любой другой тип в функцию (параметры или возвращаемые типы).</target>
        </trans-unit>
        <trans-unit id="8de2ccca92b2b43ac3dc44c63b7e55c6b432c76a" translate="yes" xml:space="preserve">
          <source>You can use generics in the same places you&amp;rsquo;d add any other type in a function type (parameter or return types).</source>
          <target state="translated">Вы можете использовать универсальные шаблоны в тех же местах, где вы добавляете любой другой тип в тип функции (тип параметра или возвращаемый тип).</target>
        </trans-unit>
        <trans-unit id="2d107b2ef0635398f316220ce167c042b23a92d8" translate="yes" xml:space="preserve">
          <source>You can use primitive values for these types:</source>
          <target state="translated">Для этих типов можно использовать примитивные значения:</target>
        </trans-unit>
        <trans-unit id="1997334cf38d8070cc18855e7eb4a51b9f7aa599" translate="yes" xml:space="preserve">
          <source>You can use this in combination with &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; to get static props:</source>
          <target state="translated">Вы можете использовать это в сочетании с &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; для получения статических свойств:</target>
        </trans-unit>
        <trans-unit id="b38b57891c6a590d35857959678efd3a7cbc9edf" translate="yes" xml:space="preserve">
          <source>You cannot use &lt;code&gt;Array.prototype&lt;/code&gt; methods that mutate the tuple, only ones that do not.</source>
          <target state="translated">Вы не можете использовать методы &lt;code&gt;Array.prototype&lt;/code&gt; , которые изменяют кортеж, только те, которые этого не делают.</target>
        </trans-unit>
        <trans-unit id="34cdb6dbd42effcc5eee6814751e14333d7ad7b4" translate="yes" xml:space="preserve">
          <source>You could also flip it around, and check to make sure that the value has a type of &lt;code&gt;number&lt;/code&gt; before using it.</source>
          <target state="translated">Вы также можете перевернуть его и убедиться, что значение имеет тип &lt;code&gt;number&lt;/code&gt; прежде чем использовать его.</target>
        </trans-unit>
        <trans-unit id="d54fcc4baacde621798558cd944fe72a2272653e" translate="yes" xml:space="preserve">
          <source>You could continue this process until &lt;code&gt;any&lt;/code&gt; has leaked all over your code.</source>
          <target state="translated">Вы можете продолжать этот процесс до тех пор, пока &lt;code&gt;any&lt;/code&gt; утечка не протечет по всему вашему коду.</target>
        </trans-unit>
        <trans-unit id="a5ccb2330f2aef610502456380da1cc91e063a81" translate="yes" xml:space="preserve">
          <source>You could do</source>
          <target state="translated">Ты можешь сделать</target>
        </trans-unit>
        <trans-unit id="a96c3e789576bc7f92cd0b34129750d6ad259391" translate="yes" xml:space="preserve">
          <source>You could refine the type, but the generic will still allow any type to be passed in.</source>
          <target state="translated">Вы можете уточнить тип,но дженерик все равно позволит передать любой тип.</target>
        </trans-unit>
        <trans-unit id="2ce625c160012e98036189d91961fd70764c6f12" translate="yes" xml:space="preserve">
          <source>You could then use the resulting value in another operation, such as adding it as if it were a number and the result will also be &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Затем вы можете использовать полученное значение в другой операции, например, сложить его, как если бы это было число, и результат также будет &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d0c0f6b4e6d2338d922e76b590f2d36d1904032" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to annotate the return type of either your &lt;code&gt;render()&lt;/code&gt; method or a stateless functional component. However, if you want to annotate the return type then &lt;code&gt;React.Node&lt;/code&gt; is the generic to use.</source>
          <target state="translated">Вам не нужно аннотировать возвращаемый тип метода &lt;code&gt;render()&lt;/code&gt; или функционального компонента без состояния. Однако, если вы хотите аннотировать возвращаемый тип, используйте &lt;code&gt;React.Node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f9c2c80449347f7166dc305529f30c45a9e9eed" translate="yes" xml:space="preserve">
          <source>You may also add a leading ampersand which is useful when breaking intersection types onto multiple lines.</source>
          <target state="translated">Также можно добавить ведущий амперсанд,который полезен при разбивке типов пересечений на несколько линий.</target>
        </trans-unit>
        <trans-unit id="2fa909f29db190474cf723005ff4008d9b7598e9" translate="yes" xml:space="preserve">
          <source>You may also add a leading vertical bar which is useful when breaking union types onto multiple lines.</source>
          <target state="translated">Вы также можете добавить опережающую вертикальную планку,которая полезна при разрыве типов соединений на несколько линий.</target>
        </trans-unit>
        <trans-unit id="4b9fdbe0651aa0dcc77f656e366ff86ea773ba26" translate="yes" xml:space="preserve">
          <source>You may also optionally leave out the parameter names.</source>
          <target state="translated">По желанию можно также пропустить имена параметров.</target>
        </trans-unit>
        <trans-unit id="8369235f7cc951c26ca572a5f0d1089b25b9b0f4" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax (i.e. Flow will not use this syntax to indicate the presence of a property on instances of the class).</source>
          <target state="translated">Вы также можете установить для него значение &lt;code&gt;ignore&lt;/code&gt; , чтобы указать, что Flow должен просто игнорировать синтаксис (т.е. Flow не будет использовать этот синтаксис для указания наличия свойства в экземплярах класса).</target>
        </trans-unit>
        <trans-unit id="12abc47c0cac769438a2a10d53130bb5088f3b42" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax (i.e. Flow will not use this syntax to indicate the presence of a static property on the class).</source>
          <target state="translated">Вы также можете установить для него значение &lt;code&gt;ignore&lt;/code&gt; , чтобы указать, что Flow должен просто игнорировать синтаксис (т.е. Flow не будет использовать этот синтаксис для указания наличия статического свойства в классе).</target>
        </trans-unit>
        <trans-unit id="bfbbefdd992a4649126e811e71f05644039bb6d5" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax.</source>
          <target state="translated">Вы также можете установить значение &lt;code&gt;ignore&lt;/code&gt; , чтобы указать, что Flow должен просто игнорировать синтаксис.</target>
        </trans-unit>
        <trans-unit id="43a0ac12f9014a2da637bcb44bcbb4fbf90a6924" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax. The default value of this option is &lt;code&gt;warn&lt;/code&gt;, which gives a warning on use since this proposal is still very early-stage.</source>
          <target state="translated">Вы также можете установить значение &lt;code&gt;ignore&lt;/code&gt; , чтобы указать, что Flow должен просто игнорировать синтаксис. Значение по умолчанию для этой опции - &lt;code&gt;warn&lt;/code&gt; , что дает предупреждение при использовании, поскольку это предложение все еще находится на очень ранней стадии.</target>
        </trans-unit>
        <trans-unit id="aa76b5b2c71934a0d36af87656f7165b00582a43" translate="yes" xml:space="preserve">
          <source>You may also wish to install a popular SublimeLinter plugin for Flow like &lt;a href=&quot;https://packagecontrol.io/packages/SublimeLinter-flow&quot;&gt;SublimeLinter-flow&lt;/a&gt;.</source>
          <target state="translated">Вы также можете установить популярный плагин SublimeLinter для Flow, например &lt;a href=&quot;https://packagecontrol.io/packages/SublimeLinter-flow&quot;&gt;SublimeLinter-flow&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd52a5c29c3e64a83bb0f62e994bfb74ab453fe3" translate="yes" xml:space="preserve">
          <source>You might use these functions types for something like a callback.</source>
          <target state="translated">Вы можете использовать эти типы функций для чего-то вроде обратного вызова.</target>
        </trans-unit>
        <trans-unit id="2ed4bf60715e28afa28e2fa5a72f5002c15618be" translate="yes" xml:space="preserve">
          <source>You must always include the brackets &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; when using the type (just like parentheses for a function call).</source>
          <target state="translated">Вы всегда должны включать скобки &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; при использовании типа (точно так же, как круглые скобки для вызова функции).</target>
        </trans-unit>
        <trans-unit id="99f73949e10ba9c21b14d2d45c52b596aa157461" translate="yes" xml:space="preserve">
          <source>You must be explicit and convert other types into strings. You can do this by using the String method or using another method for stringifying values.</source>
          <target state="translated">Вы должны быть откровенны и преобразовывать другие типы в строки.Это можно сделать с помощью метода String или другого метода для строковки значений.</target>
        </trans-unit>
        <trans-unit id="01b16b93eebbf6cd3d2d130c4da4b067de2c5876" translate="yes" xml:space="preserve">
          <source>You should represent these values with &lt;code&gt;mixed&lt;/code&gt;.</source>
          <target state="translated">Эти значения следует представлять &lt;code&gt;mixed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e73e4c01718490bcf4d4cc882d49967190833cfe" translate="yes" xml:space="preserve">
          <source>You will have access to all of the values that React exports, but you will &lt;strong&gt;not&lt;/strong&gt; have access to the types documented below! This is because Flow will not add types to a default export since the default export could be any value (like a number). Flow will add exported named types to an ES namespace object which you can get with &lt;code&gt;import * as React from 'react'&lt;/code&gt; since Flow knows if you export a value with the same name as an exported type.</source>
          <target state="translated">У вас будет доступ ко всем значениям, которые экспортирует React, но у вас &lt;strong&gt;не&lt;/strong&gt; будет доступа к типам, задокументированным ниже! Это связано с тем, что Flow не будет добавлять типы к экспорту по умолчанию, поскольку экспортом по умолчанию может быть любое значение (например, число). Flow добавит экспортированные именованные типы в объект пространства имен ES, который вы можете получить с помощью &lt;code&gt;import * as React from 'react'&lt;/code&gt; поскольку Flow знает, экспортируете ли вы значение с тем же именем, что и экспортируемый тип.</target>
        </trans-unit>
        <trans-unit id="3c23f9cce0d3c2c8df25b9ff8cf278ae227f7bad" translate="yes" xml:space="preserve">
          <source>You write classes the same way you would without Flow, but then you can use the name of the class as a type.</source>
          <target state="translated">Вы пишете классы так же,как и без Flow,но тогда вы можете использовать имя класса как тип.</target>
        </trans-unit>
        <trans-unit id="654c5e74e5e546451d0e1429c2931cddd203538d" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll notice that if we do not handle each possible type of our value, Flow will give us an error.</source>
          <target state="translated">Вы заметите, что если мы не обработаем каждый возможный тип нашего значения, Flow выдаст нам ошибку.</target>
        </trans-unit>
        <trans-unit id="75e6e89e1f9c5b889605448ec75232836809ed76" translate="yes" xml:space="preserve">
          <source>[declarations]</source>
          <target state="translated">[declarations]</target>
        </trans-unit>
        <trans-unit id="8efeedea6584d5d0f6aa150fe286ea3d383ef4a5" translate="yes" xml:space="preserve">
          <source>[ignore]</source>
          <target state="translated">[ignore]</target>
        </trans-unit>
        <trans-unit id="6c51495394c6e6372e62ee5ec85bb9eaef21cce5" translate="yes" xml:space="preserve">
          <source>[include]</source>
          <target state="translated">[include]</target>
        </trans-unit>
        <trans-unit id="7afbe53dfddbe7c93f7de3dd43aba3228ee7b934" translate="yes" xml:space="preserve">
          <source>[libs]</source>
          <target state="translated">[libs]</target>
        </trans-unit>
        <trans-unit id="0a5387e3c9cf9ab97fc0bf23e3269594e185c36d" translate="yes" xml:space="preserve">
          <source>[lints]</source>
          <target state="translated">[lints]</target>
        </trans-unit>
        <trans-unit id="83f3a6281fb9adf03bf77c91402ae0e931ccb966" translate="yes" xml:space="preserve">
          <source>[options]</source>
          <target state="translated">[options]</target>
        </trans-unit>
        <trans-unit id="5342d8199f9eb9d08f90a284e8dd1dc7804a74f9" translate="yes" xml:space="preserve">
          <source>[untyped]</source>
          <target state="translated">[untyped]</target>
        </trans-unit>
        <trans-unit id="82269fe5787de6e7ec27fcc12d83c2cbb09336c3" translate="yes" xml:space="preserve">
          <source>[version]</source>
          <target state="translated">[version]</target>
        </trans-unit>
        <trans-unit id="a1024232bfedfebb6aacd740ffd636d6f41a840a" translate="yes" xml:space="preserve">
          <source>and now</source>
          <target state="translated">и сейчас</target>
        </trans-unit>
        <trans-unit id="48e7db6313c704fbd26e0ba32bef954b2e977a24" translate="yes" xml:space="preserve">
          <source>and spread that into the &lt;code&gt;Props&lt;/code&gt; type:</source>
          <target state="translated">и разложите это на тип &lt;code&gt;Props&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2cc9aa7176523739af8846ebf98bde04cafdfc07" translate="yes" xml:space="preserve">
          <source>and suppose that &lt;code&gt;src/Misc.js&lt;/code&gt; has an incompatible implementation of &lt;code&gt;isLeapYear&lt;/code&gt;:</source>
          <target state="translated">и предположим, что &lt;code&gt;src/Misc.js&lt;/code&gt; имеет несовместимую реализацию &lt;code&gt;isLeapYear&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ec2d7bdbbbacb178e39b0b7c79bfc355baf6b95f" translate="yes" xml:space="preserve">
          <source>and suppress the error. If there is no error on the next line (the suppression is unnecessary), an &amp;ldquo;Unused suppression&amp;rdquo; warning will be shown instead.</source>
          <target state="translated">и подавите ошибку. Если в следующей строке нет ошибки (подавление не требуется), вместо этого будет показано предупреждение &amp;laquo;Неиспользованное подавление&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a9745abbdcf92eab56732a7d35f17f430c1336bf" translate="yes" xml:space="preserve">
          <source>and then it comes across a &lt;code&gt;package.json&lt;/code&gt; with</source>
          <target state="translated">а затем он встречает &lt;code&gt;package.json&lt;/code&gt; с</target>
        </trans-unit>
        <trans-unit id="0768098259f562a18299b5c17e4ddd6a8b9d9b5b" translate="yes" xml:space="preserve">
          <source>and you try to use Flow v0.21.0, then Flow will immediately error with the message</source>
          <target state="translated">и вы пытаетесь использовать Flow v0.21.0,тогда Flow сразу же выдаст ошибку с сообщением</target>
        </trans-unit>
        <trans-unit id="fca2dbc7b2ac4e20f39f9f3ef522d55252c79cbb" translate="yes" xml:space="preserve">
          <source>broken: &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAb2IAuUADsRqMZSwAaUGPVade0AF8A3D36DRYgEwzYc0IpVF1JHFmQaAc0Mab19-AMsbRBpYDR9hcQl3UAAKdFkSdQdpDIBKdwA+UAAeABNkADdQYAKbGLi8B0dktIys8Wc8wpLyqpqo+viAYSYWpURQUBJKaEo6bH0J0AA6VfTXEkQLdRVp2fmsdV8RSkNV5eyXNwtQAB9lKZm5nGx1SCJoabPVpquyC3y8gKSz2z2woAA-CVsspzus5DcaqB1MUmrC1hlEbUgA&quot;&gt;https://flow.org/try&lt;/a&gt;</source>
          <target state="translated">сломано: &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAb2IAuUADsRqMZSwAaUGPVade0AF8A3D36DRYgEwzYc0IpVF1JHFmQaAc0Mab19-AMsbRBpYDR9hcQl3UAAKdFkSdQdpDIBKdwA+UAAeABNkADdQYAKbGLi8B0dktIys8Wc8wpLyqpqo+viAYSYWpURQUBJKaEo6bH0J0AA6VfTXEkQLdRVp2fmsdV8RSkNV5eyXNwtQAB9lKZm5nGx1SCJoabPVpquyC3y8gKSz2z2woAA-CVsspzus5DcaqB1MUmrC1hlEbUgA&quot;&gt;https://flow.org/try&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="774e51ee6ebca6e8cb9d7f4d3fe9750f2b9256ae" translate="yes" xml:space="preserve">
          <source>but this doesn&amp;rsquo;t feel very DRY, as we had to explicitly define the suit names twice.</source>
          <target state="translated">но это не кажется очень СУХИМ, так как нам пришлось явно определять имена костюмов дважды.</target>
        </trans-unit>
        <trans-unit id="6e45777a3dd462c6a840e9e356a7099b6982bc19" translate="yes" xml:space="preserve">
          <source>but with &lt;code&gt;$ReadOnlyArray&lt;/code&gt; you can achieve what you were looking for:</source>
          <target state="translated">но с &lt;code&gt;$ReadOnlyArray&lt;/code&gt; вы можете добиться того, что искали:</target>
        </trans-unit>
        <trans-unit id="46438caefd12a0fd432aedcd449aa37d123fa4c1" translate="yes" xml:space="preserve">
          <source>but with a covariant property you can achieve what you were looking for:</source>
          <target state="translated">но с ковариантной недвижимостью вы можете достичь того,что искали:</target>
        </trans-unit>
        <trans-unit id="ccd55bda6574570ee546195840fdf67842826f24" translate="yes" xml:space="preserve">
          <source>coc.nvim-neovim</source>
          <target state="translated">coc.nvim-neovim</target>
        </trans-unit>
        <trans-unit id="eca0bd3451749c34200b52876c4df81d84e1e7cd" translate="yes" xml:space="preserve">
          <source>doesn&amp;rsquo;t report a warning.</source>
          <target state="translated">не сообщает о предупреждении.</target>
        </trans-unit>
        <trans-unit id="ecb70bca541e08251da88aa6114a01ea186dc721" translate="yes" xml:space="preserve">
          <source>fixed: &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAbwA+xAFygAdiNRjKWADSgxmnXoOgVAXwDcPfoNFiATDNhzQi1RtAkcWMhaAObGNJr+gSFWdtw0sFr+wuISXqAAFOiyJJrO0tkAlF4AfKAAPAAmyABuoMDF9vGJeM4uaZnZueJuhSXlVbX19ohNSQDCTO1ZHjnKaiSU0JR02JoBIpTGAHQ7ee6eNlZzfovLOKugkETQC9u73ftkNkXypUqIoKDIkBnTclsLJYrLBFd6fT5LPBKQFnbB3LbsfzWNJ-Ej2cGgdg4ERYLTlPLKHYIyhIuoND6gZGLBbKCkQyhQmHA+GInDIxSo9HgrE4vFlVqEnas5FDCnWRDWIA&quot;&gt;https://flow.org/try&lt;/a&gt;</source>
          <target state="translated">исправлено: &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAbwA+xAFygAdiNRjKWADSgxmnXoOgVAXwDcPfoNFiATDNhzQi1RtAkcWMhaAObGNJr+gSFWdtw0sFr+wuISXqAAFOiyJJrO0tkAlF4AfKAAPAAmyABuoMDF9vGJeM4uaZnZueJuhSXlVbX19ohNSQDCTO1ZHjnKaiSU0JR02JoBIpTGAHQ7ee6eNlZzfovLOKugkETQC9u73ftkNkXypUqIoKDIkBnTclsLJYrLBFd6fT5LPBKQFnbB3LbsfzWNJ-Ej2cGgdg4ERYLTlPLKHYIyhIuoND6gZGLBbKCkQyhQmHA+GInDIxSo9HgrE4vFlVqEnas5FDCnWRDWIA&quot;&gt;https://flow.org/try&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="406a50ab8f418267ad4cb79f7ec8af3c757e5d1a" translate="yes" xml:space="preserve">
          <source>flow-for-emacs</source>
          <target state="translated">flow-for-emacs</target>
        </trans-unit>
        <trans-unit id="b31ed27db0f3f06537ccbd7e0612af0839145d27" translate="yes" xml:space="preserve">
          <source>flow-remove-types</source>
          <target state="translated">flow-remove-types</target>
        </trans-unit>
        <trans-unit id="bb6bd705fa5bbecd686c0aa80112ee7f1ec636a5" translate="yes" xml:space="preserve">
          <source>flowlint</source>
          <target state="translated">flowlint</target>
        </trans-unit>
        <trans-unit id="1ae5604c6b19edcfc16e8a0c46ddf12d0f3961dd" translate="yes" xml:space="preserve">
          <source>flowlint-line</source>
          <target state="translated">flowlint-line</target>
        </trans-unit>
        <trans-unit id="d424129af5ff1e8c17f038e5baf6afdeaa7378ab" translate="yes" xml:space="preserve">
          <source>flowlint-next-line</source>
          <target state="translated">flowlint-next-line</target>
        </trans-unit>
        <trans-unit id="9523c342f10c383dc3724202de645481a80652c5" translate="yes" xml:space="preserve">
          <source>if you want control at an even finer level than you get from the line-based comments.</source>
          <target state="translated">если вам нужен контроль на еще более тонком уровне,чем вы получаете от линейных комментариев.</target>
        </trans-unit>
        <trans-unit id="ec606816757167e05f48d162279dba3e8be72530" translate="yes" xml:space="preserve">
          <source>is an alias for React.AbstractComponent&amp;lt;Config, any&amp;gt;, which represents a component with config type Config and any instance type.</source>
          <target state="translated">- это псевдоним для React.AbstractComponent &amp;lt;Config, any&amp;gt;, который представляет компонент с типом конфигурации Config и любым типом экземпляра.</target>
        </trans-unit>
        <trans-unit id="e56b448d5548cfe9ad70cc70da30a02c7890ea87" translate="yes" xml:space="preserve">
          <source>or by annotating the exported constant (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBjWA7AzgF1AQwE764CeoAvKANoDku1ANKNQEbUC6iApgB4AOs+HKkw4A5pzSd8AS2QBBQiQBcoBUWIAebDLSiAfOTyLiAOgC2uXgApc5A7gCUQA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">или аннотируя экспортированную константу ( &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBjWA7AzgF1AQwE764CeoAvKANoDku1ANKNQEbUC6iApgB4AOs+HKkw4A5pzSd8AS2QBBQiQBcoBUWIAebDLSiAfOTyLiAOgC2uXgApc5A7gCUQA&quot;&gt;https://flow.org/try&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="7a4bfa85ec41023a2a32b1cdf3f48b7562fdb4a7" translate="yes" xml:space="preserve">
          <source>ref functions</source>
          <target state="translated">функции ссылки</target>
        </trans-unit>
        <trans-unit id="2193165c31d2f4f8af241c9a8931a8b36a67d5d4" translate="yes" xml:space="preserve">
          <source>returns a number, when we pass in the value &lt;code&gt;&quot;number&quot;&lt;/code&gt;, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac03e5cf9b7ed34c910a9d7e41d6ef0b28bee9d4" translate="yes" xml:space="preserve">
          <source>returns a string, when we pass in the value &lt;code&gt;&quot;string&quot;&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f484f97d66326080e8ca936a1ad359ef6b4abc" translate="yes" xml:space="preserve">
          <source>returns any possible type (&lt;code&gt;mixed&lt;/code&gt;), when we pass in any other string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="293bf85b0e8555f44772dd43c5b8cdf5ff5c89b9" translate="yes" xml:space="preserve">
          <source>the left-hand side of an &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; expression.</source>
          <target state="translated">левая часть выражения &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1470003cc6f898cdf238607c6ab34328b293da93" translate="yes" xml:space="preserve">
          <source>vim-flow</source>
          <target state="translated">vim-flow</target>
        </trans-unit>
        <trans-unit id="2ad74a5e0937034a00b7730362af6b184bbbc385" translate="yes" xml:space="preserve">
          <source>vscode-flow-ide</source>
          <target state="translated">vscode-flow-ide</target>
        </trans-unit>
        <trans-unit id="0cbdfb85ff349a0802c41f318988e156dfbc0529" translate="yes" xml:space="preserve">
          <source>where as you would otherwise need to export an alias in the &lt;code&gt;import typeof&lt;/code&gt; case</source>
          <target state="translated">где в противном случае вам нужно будет экспортировать псевдоним в &lt;code&gt;import typeof&lt;/code&gt; случае</target>
        </trans-unit>
        <trans-unit id="bd186b6002ab463466be199db517792bf8202dbe" translate="yes" xml:space="preserve">
          <source>will match a comment like this:</source>
          <target state="translated">будет соответствовать такому комментарию:</target>
        </trans-unit>
        <trans-unit id="f9a9d8b1f4f99fe8e77aee03fea19f8d5c42d401" translate="yes" xml:space="preserve">
          <source>will only report export related errors in files under &lt;code&gt;dirA&lt;/code&gt; and &lt;code&gt;dirB&lt;/code&gt;. This option requires &lt;code&gt;well_formed_exports&lt;/code&gt; to be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba826f3eaa4834a5baad670fcedb5ee1f1e012b" translate="yes" xml:space="preserve">
          <source>would still have a sketchy-null-number warning on line 3.</source>
          <target state="translated">все еще будет иметь схематическое предупреждение с нулевым номером на третьей линии.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
