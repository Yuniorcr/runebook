<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="c">
    <body>
      <group id="c">
        <trans-unit id="46bf7c32b091bac31f177b6538a857bc4f99a593" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt; other&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; other&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="537b1d1edf82aeba0b417c8ba71838968c5a62b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isalnum&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isalnum&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f9eb092cbcfe95bdcd0259dd8a630d5021ccbbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isalpha&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isalpha&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9ce04988731330541a991eb5e7d06dccb14ef08" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isblank&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isblank&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a1eaa994d3269906b2a47c32a8e547fa6acd48b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iscntrl&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iscntrl&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6c38fada3181e93f98fd6a5cc64d639bb008f4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isdigit&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isdigit&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ee2ff1dcd24794fdc2eeb658a043d3eddab9f4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isgraph&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isgraph&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc805695234d5269f3894979b9d4d5055e0e4e03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;islower&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;islower&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d368a53b3e50cbe2b60f751d23c615e71f69a2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isprint&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isprint&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="edf5be6051afddc9d51019cf62964a443b980d31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;ispunct&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;ispunct&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0dab79137a8c3f41f95cb2fdba1f4f613fc1cba2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2547b4f8a0a99767af9245458421d60678dfee26" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isupper&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isupper&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92651ef970d99cc14c98cd615af602f9a84c504b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswalnum&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswalnum&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="a9721c714438e2959a6b2dd93edc8f3f8d158f25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswalpha&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswalpha&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="63cf242f16b8eed04f50e80e12b7fe53c7b60e96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswblank&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswblank&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="ef1646ab343b83d122b0efbf0b1327ad179544ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswcntrl&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswcntrl&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="57132c82e4d7dd23822d5e2b00c1360c20c46cad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswdigit&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswdigit&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="eaaeeeb6bf702b4f78258a052af4452dc2690218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswgraph&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswgraph&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="eef504bf43cd6c27be30cb125fbc497a56a78de2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswlower&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswlower&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="de60e8e30084fb3e157dd6de773b4737e7169d88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswprint&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswprint&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="4615b2011e8d972dea535045f94bc13827ee65bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswpunct&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswpunct&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="c5fdebcc026d6a68db49f4b74165ce7f0d912453" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswspace&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswspace&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="20e51610dd3a8beabcd2f164c21da31478eafe74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswupper&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswupper&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="375e0bd774ab74de342f79f6cb82415b12d14f35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswxdigit&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswxdigit&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="d84d8f51eeb0c0fa8768438cbf4a31a1157bc640" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isxdigit&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isxdigit&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="81c351228e8e2cb7718bc5af2c6012b6ddb15f26" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;-t2&lt;br/&gt;&lt;/sup&gt;d</source>
          <target state="translated">&lt;sup&gt;-t2&lt;br/&gt;&lt;/sup&gt;d</target>
        </trans-unit>
        <trans-unit id="06084185252914fb80c48390ac42871dd29d6c0a" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;-t&lt;/sup&gt; d</source>
          <target state="translated">&lt;sup&gt;-т&lt;/sup&gt; д</target>
        </trans-unit>
        <trans-unit id="ecb9d9cc5013291f759497f08cec925224751c83" translate="yes" xml:space="preserve">
          <source>=arg.</source>
          <target state="translated">=arg.</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="2e3f231a0c0c357ef29a27a75e01c5f0f830c0dc" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of an object may provide its initial value through the process known as</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;Декларация&lt;/a&gt; объекта может обеспечить его начальное значение посредством процесса , известного как</target>
        </trans-unit>
        <trans-unit id="9f3a3af6eca5ee659c499270442d0bea16af329c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;statements#Labels&quot;&gt;label (and only a label)&lt;/a&gt; declared inside a function is in scope everywhere in that function, in all nested blocks, before and after its own declaration. Note: a label is declared implicitly, by using an otherwise unused identifier before the colon character before any statement.</source>
          <target state="translated">&lt;a href=&quot;statements#Labels&quot;&gt;Ярлык (и только метка)&lt;/a&gt; , объявленный внутри функции в области видимости везде в этой функции, во всех вложенных блоках, до и после его собственного заявления. Примечание: метка объявляется неявно, с использованием неиспользуемого идентификатора перед символом двоеточия перед любым оператором.</target>
        </trans-unit>
        <trans-unit id="603d648e12123df5062789b6c9b530a246514f04" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;##&lt;/code&gt; operator between any two successive identifiers in the replacement-list runs parameter replacement on the two identifiers and then concatenates the result. This operation is called &quot;concatenation&quot; or &quot;token pasting&quot;. Only tokens that form a valid token together may be pasted: identifiers that form a longer identifier, digits that form a number, or operators &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;=&lt;/code&gt; that form a &lt;code&gt;+=&lt;/code&gt;. A comment cannot be created by pasting &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; because comments are removed from text before macro substitution is considered. If the result of concatenation is not a valid token, the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;##&lt;/code&gt; оператор между любыми двумя последовательными идентификаторами в замещающей списке выполняется замена параметров на двух идентификаторов , а затем присоединяет результат. Эта операция называется &amp;laquo;конкатенация&amp;raquo; или &amp;laquo;вставка токена&amp;raquo;. Только токены, которые вместе образуют действительный токен, могут быть вставлены: идентификаторы, которые образуют более длинный идентификатор, цифры, которые образуют число, или операторы &lt;code&gt;+&lt;/code&gt; и &lt;code&gt;=&lt;/code&gt; , которые образуют &lt;code&gt;+=&lt;/code&gt; . Комментарий не может быть создан путем вставки &lt;code&gt;/&lt;/code&gt; и &lt;code&gt;*&lt;/code&gt; , потому что комментарии удаляются из текста до рассмотрения подстановки макроса. Если результат объединения не является допустимым токеном, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="f47fde5c22af25ab0ffba150ed15a83e7199e428" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;do-while&lt;/code&gt; statement causes the statement (also called</source>
          <target state="translated">&lt;code&gt;do-while&lt;/code&gt; оператор вызывает оператор (называемый также</target>
        </trans-unit>
        <trans-unit id="3f288f6fc591d96442bb174583cfa9db05dbe91d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; statement causes the statement (also called</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; оператор вызывает оператор (называемый также</target>
        </trans-unit>
        <trans-unit id="b3f6ff76b0a886129453c93b5f0c76da0cfdd30b" translate="yes" xml:space="preserve">
          <source>A C program is a sequence of text files (typically header and source files) that contain &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;. They undergo &lt;a href=&quot;translation_phases&quot;&gt;translation&lt;/a&gt; to become an executable program, which is executed when the OS calls its &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt; (unless it is itself the OS or another</source>
          <target state="translated">Программа AC представляет собой последовательность текстовых файлов (обычно заголовочных и исходных файлов), которые содержат &lt;a href=&quot;declarations&quot;&gt;объявления&lt;/a&gt; . Они &lt;a href=&quot;translation_phases&quot;&gt;преобразуются&lt;/a&gt; в исполняемую программу, которая выполняется, когда ОС вызывает свою &lt;a href=&quot;main_function&quot;&gt;основную функцию&lt;/a&gt; (если она сама не является ОС или другой</target>
        </trans-unit>
        <trans-unit id="8feba51dfd70e75bb34dad80e127aae9226924af" translate="yes" xml:space="preserve">
          <source>A C++-style comment may appear within a C-style comment; this is a mechanism for excluding a small block of source code:</source>
          <target state="translated">Комментарий в стиле Си++может появиться внутри комментария в стиле Си;это механизм исключения небольшого блока исходного кода:</target>
        </trans-unit>
        <trans-unit id="361abe056c46779921476d60896b385658ec3cd3" translate="yes" xml:space="preserve">
          <source>A C-style comment may appear within a C++-style comment:</source>
          <target state="translated">Комментарий в стиле C может появиться внутри комментария в стиле C++:</target>
        </trans-unit>
        <trans-unit id="c38d4f0fff6ac9b2c2295060922485f792b04682" translate="yes" xml:space="preserve">
          <source>A bit field declaration is a &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; member declaration which uses the following &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;:</source>
          <target state="translated">Объявление битового поля - это объявление &lt;a href=&quot;struct&quot;&gt;структуры&lt;/a&gt; или члена &lt;a href=&quot;union&quot;&gt;объединения, в&lt;/a&gt; котором используется следующий &lt;a href=&quot;declarations&quot;&gt;декларатор&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ecea6dbeee94545ded8e32b6cbfdc17fbe02cdaf" translate="yes" xml:space="preserve">
          <source>A block scope restrict-qualified pointer makes an aliasing assertion that is limited to its block. It allows local assertions that apply only to important blocks, such as tight loops. It also makes it possible to convert a function that takes restrict-qualified pointers into a macro:</source>
          <target state="translated">Ограниченный по масштабу указатель блока делает псевдонимы,которые ограничиваются его блоком.Он позволяет использовать локальные утверждения,которые применимы только к важным блокам,например,к узким петлям.Она также позволяет преобразовать функцию,которая принимает ограниченно-квалифицированные указатели в макрос:</target>
        </trans-unit>
        <trans-unit id="e25a945c48cf6f76f2a11977d7e5d96d55161783" translate="yes" xml:space="preserve">
          <source>A break statement cannot be used to break out of multiple nested loops. The &lt;a href=&quot;goto&quot;&gt;goto statement&lt;/a&gt; may be used for this purpose.</source>
          <target state="translated">Оператор break нельзя использовать для выхода из нескольких вложенных циклов. Оператор &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; может использоваться для этой цели.</target>
        </trans-unit>
        <trans-unit id="a7a8603933603ca5102eeb32e317c1c1d5b2f58d" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;free&lt;/code&gt; that deallocates a region of memory</source>
          <target state="translated">Призыв к &lt;code&gt;free&lt;/code&gt; , освобождающий область памяти</target>
        </trans-unit>
        <trans-unit id="8c457728c5c90222ee97d0a5a9c7631536f84aa6" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;tss_create&lt;/code&gt; from within a thread-specific storage destructor results in undefined behavior.</source>
          <target state="translated">Вызов &lt;code&gt;tss_create&lt;/code&gt; из деструктора хранилища для конкретного потока приводит к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="fcaf9a5650cbd2811245352e71e1d893dc23de9d" translate="yes" xml:space="preserve">
          <source>A cast of a non-volatile value to a volatile type has no effect. To access a non-volatile object using volatile semantics, its address must be cast to a pointer-to-volatile and then the access must be made through that pointer.</source>
          <target state="translated">Отбрасывание энергонезависимого значения на летучий тип не оказывает никакого эффекта.Для доступа к энергонезависимому объекту с помощью летучей семантики его адрес должен быть приведен к указателю на энергонезависимый объект,после чего доступ должен быть осуществлен через этот указатель.</target>
        </trans-unit>
        <trans-unit id="266435bc7e1c5eddbff33669084fc6a3cc68bc0f" translate="yes" xml:space="preserve">
          <source>A collection of operators that do not fit into any of the other major categories.</source>
          <target state="translated">Набор операторов,которые не подходят ни к одной из других основных категорий.</target>
        </trans-unit>
        <trans-unit id="a0e39b90a6cb653ffa38cbd92a158bb59c3fe2b6" translate="yes" xml:space="preserve">
          <source>A common error is setting the buffer of stdin or stdout to an array whose lifetime ends before the program terminates:</source>
          <target state="translated">Частой ошибкой является установка буфера stdin или stdout в массив,время жизни которого заканчивается до завершения работы программы:</target>
        </trans-unit>
        <trans-unit id="043e96d2c063cdcc5eb90afe38b71a1e2aa56a23" translate="yes" xml:space="preserve">
          <source>A common implementation-defined form of main is &lt;code&gt;int main(int argc, char *argv[], char *envp[])&lt;/code&gt;, where a third argument, of type &lt;code&gt;char*[]&lt;/code&gt;, points at &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;an array of pointers to the host environment variables&lt;/a&gt;.</source>
          <target state="translated">Распространенной формой main, определяемой реализацией, является &lt;code&gt;int main(int argc, char *argv[], char *envp[])&lt;/code&gt; , где третий аргумент типа &lt;code&gt;char*[]&lt;/code&gt; указывает на &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;массив указателей на среду хоста. переменные&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cfa9c8d2b42454344333fc69a8715babdf4fa1d7" translate="yes" xml:space="preserve">
          <source>A compiler that defines &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; is not required to support imaginary numbers. POSIX recommends checking if the macro &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; is defined to identify imaginary number support.</source>
          <target state="translated">Компилятор, который определяет &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; , не обязан поддерживать мнимые числа. POSIX рекомендует проверить, определен ли макрос &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; для идентификации поддержки мнимых чисел.</target>
        </trans-unit>
        <trans-unit id="081399ac6b5e4a28bc7390d1cdebdd865a0f239c" translate="yes" xml:space="preserve">
          <source>A compiler that defines &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; is not required to support imaginary numbers. POSIX recommends checking if the macro &lt;code&gt;_Imaginary_I&lt;/code&gt; is defined to identify imaginary number support.</source>
          <target state="translated">Компилятор, который определяет &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; , не обязан поддерживать мнимые числа. POSIX рекомендует проверить, определен ли макрос &lt;code&gt;_Imaginary_I&lt;/code&gt; для идентификации поддержки мнимых чисел.</target>
        </trans-unit>
        <trans-unit id="e7d53908cdda0d9e9b4f6a93e7e463f1fefd5fad" translate="yes" xml:space="preserve">
          <source>A compiler that defines &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; is recommended, but not required to support imaginary numbers. POSIX recommends checking if the macro &lt;code&gt;&lt;a href=&quot;../numeric/complex/imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; is defined to identify imaginary number support.</source>
          <target state="translated">Рекомендуется компилятор, который определяет &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; , но не обязателен для поддержки мнимых чисел. POSIX рекомендует проверить, определен ли макрос &lt;code&gt;&lt;a href=&quot;../numeric/complex/imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; для идентификации поддержки мнимых чисел.</target>
        </trans-unit>
        <trans-unit id="4402e6f9ef027c378a2aa72fb2a92313d0d247bd" translate="yes" xml:space="preserve">
          <source>A compiler that defines &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; is recommended, but not required to support imaginary numbers. POSIX recommends checking if the macro &lt;code&gt;&lt;a href=&quot;complex/imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; is defined to identify imaginary number support.</source>
          <target state="translated">Рекомендуется компилятор, который определяет &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; , но не обязателен для поддержки мнимых чисел. POSIX рекомендует проверить, определен ли макрос &lt;code&gt;&lt;a href=&quot;complex/imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; для идентификации поддержки мнимых чисел.</target>
        </trans-unit>
        <trans-unit id="ea77b12b7e2407a17d07af2cbebb15373a1a510a" translate="yes" xml:space="preserve">
          <source>A complex number composed of &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;imag&lt;/code&gt; as the real and imaginary parts.</source>
          <target state="translated">Комплексное число состоит из &lt;code&gt;real&lt;/code&gt; и &lt;code&gt;imag&lt;/code&gt; как действительные и мнимые части.</target>
        </trans-unit>
        <trans-unit id="e64cb23c6cd4a39b1bb7384aaf3e5f0fc40dfca2" translate="yes" xml:space="preserve">
          <source>A complex or imaginary number is a zero if both components are positive or negative zeroes.</source>
          <target state="translated">Комплексное или воображаемое число-это ноль,если обе составляющие являются положительными или отрицательными нулями.</target>
        </trans-unit>
        <trans-unit id="dce1f09c28a8705473a0f7651c9a4b9f78234952" translate="yes" xml:space="preserve">
          <source>A complex or imaginary number is finite if both components are neither infinities nor NaNs.</source>
          <target state="translated">Комплексное или воображаемое число является конечным,если обе компоненты не являются ни бесконечными,ни NaNs.</target>
        </trans-unit>
        <trans-unit id="652b9c238709c7d35d2b6d1f52d70d79d08c5684" translate="yes" xml:space="preserve">
          <source>A complex or imaginary number is infinite if one of its components is infinite, even if the other component is NaN.</source>
          <target state="translated">Комплексное или воображаемое число бесконечно,если одна из его компонент бесконечна,даже если другая-NaN.</target>
        </trans-unit>
        <trans-unit id="dfd35d143007cd2afa97becb2a970fcb61fba85f" translate="yes" xml:space="preserve">
          <source>A composite type can be constructed from two types that are compatible; it is a type that is compatible with both of the two types and satisfies the following conditions:</source>
          <target state="translated">Композитный тип может быть сконструирован из двух совместимых типов;это тип,совместимый с обоими типами и удовлетворяющий следующим условиям:</target>
        </trans-unit>
        <trans-unit id="7840d5c37ff1db5e5e182c7d433c55ae950c092a" translate="yes" xml:space="preserve">
          <source>A compound statement, or</source>
          <target state="translated">Комплексное заявление,или</target>
        </trans-unit>
        <trans-unit id="fd3c6deaad4f149d8821441e3aeb7cf41936bcd5" translate="yes" xml:space="preserve">
          <source>A copy of the returned string along with the category used in this call to &lt;code&gt;setlocale&lt;/code&gt; may be used later in the program to restore the locale back to the state at the end of this call.</source>
          <target state="translated">Копия возвращенной строки вместе с категорией, используемой в этом вызове &lt;code&gt;setlocale&lt;/code&gt; , может быть использована позже в программе для восстановления локали обратно в состояние в конце этого вызова.</target>
        </trans-unit>
        <trans-unit id="80b81ef2621bd9443a4bf04efe123ee3d6ed6faf" translate="yes" xml:space="preserve">
          <source>A declaration cannot introduce an identifier if another declaration for the same identifier in the same &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; appears earlier, except that.</source>
          <target state="translated">Объявление не может вводить идентификатор, если ранее появилось другое объявление для того же идентификатора в той же &lt;a href=&quot;scope&quot;&gt;области видимости&lt;/a&gt; , за исключением этого.</target>
        </trans-unit>
        <trans-unit id="3c1639813cef172042dde9fb318ca556d46fc2fb" translate="yes" xml:space="preserve">
          <source>A declaration of the following form.</source>
          <target state="translated">Заявление в следующей форме.</target>
        </trans-unit>
        <trans-unit id="a960e4e1d8427b6d3fda100fb6c241d0a214d14b" translate="yes" xml:space="preserve">
          <source>A designator causes the following initializer to initialize of the array element described by the designator. Initialization then continues forward in order, beginning with the next element after the one described by the designator.</source>
          <target state="translated">Обозначение вызывает инициализацию описываемого обозначением элемента массива следующим инициализатором.Затем инициализация продолжается по порядку,начиная со следующего элемента после описанного обозначением.</target>
        </trans-unit>
        <trans-unit id="4da5ccc11d8af999bc9357c8da2a60aea20aab2d" translate="yes" xml:space="preserve">
          <source>A designator causes the following initializer to initialize the struct member described by the designator. Initialization then continues forward in order of declaration, beginning with the next element declared after the one described by the designator.</source>
          <target state="translated">Обозначение заставляет следующий инициализатор инициализировать описанный обозначением член структуры.Затем инициализация продолжается в порядке декларирования,начиная со следующего элемента,объявленного после описанного обозначением.</target>
        </trans-unit>
        <trans-unit id="089c028655f5931200be1bc3ff6ad58ddd4abdfd" translate="yes" xml:space="preserve">
          <source>A domain error or range error may occur if &lt;code&gt;arg&lt;/code&gt; is zero, infinite, or NaN.</source>
          <target state="translated">Ошибка домена или ошибки диапазона может возникнуть, если &lt;code&gt;arg&lt;/code&gt; равен нулю, бесконечен или равен NaN.</target>
        </trans-unit>
        <trans-unit id="0004144516b9e50c31b57af7a9296890e6e2c03c" translate="yes" xml:space="preserve">
          <source>A file-scope restrict-qualified pointer has to point into a single array object for the duration of the program. That array object may not be referenced both through the restricted pointer and through either its declared name (if it has one) or another restricted pointer.</source>
          <target state="translated">Ограниченный указатель файлового пространства должен указывать на один объект массива на время работы программы.На этот объект массива нельзя ссылаться как по ограниченному указателю,так и по его объявленному имени (если он имеет тот или иной ограничитель)или по другому ограниченному указателю.</target>
        </trans-unit>
        <trans-unit id="976825cd6143668bd0fe398a656fa05a307069b2" translate="yes" xml:space="preserve">
          <source>A finite value of any real floating type can be implicitly converted to any integer type. Except where covered by boolean conversion above, the rules are:</source>
          <target state="translated">Конечное значение любого вещественного плавающего типа может быть неявно приведено к любому целому типу.За исключением случаев,когда выше приведено булевое преобразование,правила таковы:</target>
        </trans-unit>
        <trans-unit id="0ed079bc5d103eb53c8e9924fed905c90fdd8aab" translate="yes" xml:space="preserve">
          <source>A floating constant is a &lt;a href=&quot;value_category&quot;&gt;non-lvalue&lt;/a&gt; expression having the form:</source>
          <target state="translated">Плавающая константа - это &lt;a href=&quot;value_category&quot;&gt;ненулевое&lt;/a&gt; выражение, имеющее форму:</target>
        </trans-unit>
        <trans-unit id="377954a1c6c62bc023f38ea913ffa855f5cdcee9" translate="yes" xml:space="preserve">
          <source>A function call expression where expression consists entirely of an identifier and that identifier is undeclared acts as though the identifier is declared as.</source>
          <target state="translated">Выражение вызова функции,в котором выражение полностью состоит из идентификатора,и этот идентификатор является необъявленным,действует так,как будто идентификатор объявлен как.</target>
        </trans-unit>
        <trans-unit id="602a406df52d4cd1f2b9ef189b37d9f3edc65dbd" translate="yes" xml:space="preserve">
          <source>A function declaration introduces an &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; that designates a function and, optionally, specifies the types of the function parameters (the</source>
          <target state="translated">Объявление функции вводит &lt;a href=&quot;identifier&quot;&gt;идентификатор,&lt;/a&gt; который обозначает функцию и, необязательно, указывает типы параметров функции (</target>
        </trans-unit>
        <trans-unit id="ec213a1d70975b73f03ef6fb6555f8cf9ab8d93a" translate="yes" xml:space="preserve">
          <source>A function definition associates the function body (a sequence of declarations and statements) with the function name and parameter list. Unlike &lt;a href=&quot;function_declaration&quot;&gt;function declaration&lt;/a&gt;, function definitions are allowed at file scope only (there are no nested functions).</source>
          <target state="translated">Определение функции связывает тело функции (последовательность объявлений и операторов) с именем функции и списком параметров. В отличие от &lt;a href=&quot;function_declaration&quot;&gt;объявления&lt;/a&gt; функций, определения функций допускаются только в области видимости файла (нет вложенных функций).</target>
        </trans-unit>
        <trans-unit id="3703acc891d3a7d6dbd5125eb673a5d5f0dab4f4" translate="yes" xml:space="preserve">
          <source>A function designator (the identifier introduced by a &lt;a href=&quot;function_declaration&quot;&gt;function declaration&lt;/a&gt;) is an expression of function type. When used in any context other than the address-of operator, &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;, and &lt;a href=&quot;alignof&quot;&gt;_Alignof&lt;/a&gt; (the last two generate compile errors when applied to functions), the function designator is always converted to a non-lvalue pointer to function. Note that the function-call operator is defined for pointers to functions and not for function designators themselves.</source>
          <target state="translated">Обозначение функции (идентификатор, введенный объявлением &lt;a href=&quot;function_declaration&quot;&gt;функции&lt;/a&gt; ) является выражением типа функции. При использовании в любом контексте, кроме оператора address-of, &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt; и &lt;a href=&quot;alignof&quot;&gt;_Alignof&lt;/a&gt; (последние два генерируют ошибки компиляции при применении к функциям), указатель функции всегда преобразуется в указатель на функцию без значения. Обратите внимание, что оператор вызова функции определен для указателей на функции, а не для самих указателей функций.</target>
        </trans-unit>
        <trans-unit id="2865a2d6eb5df117f629cdfeaf9bd05dfbbfb70e" translate="yes" xml:space="preserve">
          <source>A function is a C language construct that associates a &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt; (the function body) with an &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; (the function name). Every C program begins execution from the &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt;, which either terminates, or invokes other, user-defined or library functions.</source>
          <target state="translated">Функция - это конструкция языка C, которая связывает &lt;a href=&quot;statements#Compound_statements&quot;&gt;составной оператор&lt;/a&gt; (тело функции) с &lt;a href=&quot;identifier&quot;&gt;идентификатором&lt;/a&gt; (именем функции). Каждая программа на C начинает выполнение с &lt;a href=&quot;main_function&quot;&gt;главной функции&lt;/a&gt; , которая либо завершает, либо вызывает другие пользовательские или библиотечные функции.</target>
        </trans-unit>
        <trans-unit id="8751c52383848fc3922df72d6d9844aebc4d6beb" translate="yes" xml:space="preserve">
          <source>A label is an identifier followed by a colon (:) and a statement. Labels are the only identifiers that have</source>
          <target state="translated">Метка-это идентификатор,за которым следует двоеточие (:)и утверждение.Метки-это единственные идентификаторы,которые имеют</target>
        </trans-unit>
        <trans-unit id="970388d0171fba77b4f60c1b13ea5429bb78c066" translate="yes" xml:space="preserve">
          <source>A load operation with this memory order performs a</source>
          <target state="translated">Операция загрузки с этим порядком памяти выполняет</target>
        </trans-unit>
        <trans-unit id="04adb94f807f9fc41a4b16df95c597991972fc35" translate="yes" xml:space="preserve">
          <source>A load operation with this memory order performs an</source>
          <target state="translated">Операция загрузки с этим порядком памяти выполняет</target>
        </trans-unit>
        <trans-unit id="3b21ef2a1cadb419bb1ba1c86579963e83c28347" translate="yes" xml:space="preserve">
          <source>A load operation with this memory order performs the</source>
          <target state="translated">Операция загрузки с этим порядком памяти выполняет</target>
        </trans-unit>
        <trans-unit id="1abbd3840931ab83b239511b97b8e829d4c22039" translate="yes" xml:space="preserve">
          <source>A member of a const-qualified structure or union type acquires the qualification of the type it belongs to (both when accessed using the &lt;code&gt;.&lt;/code&gt; operator or the &lt;code&gt;-&amp;gt;&lt;/code&gt; operator).</source>
          <target state="translated">Член константный-квалифицирован структуры или объединения типа приобретает квалификацию типа он принадлежит (как при доступе с помощью &lt;code&gt;.&lt;/code&gt; Оператора или &lt;code&gt;-&amp;gt;&lt;/code&gt; оператора).</target>
        </trans-unit>
        <trans-unit id="264b98c249a9fc7f51bdfe1129cff98f9c148f21" translate="yes" xml:space="preserve">
          <source>A member of a volatile-qualified structure or union type acquires the qualification of the type it belongs to (both when accessed using the &lt;code&gt;.&lt;/code&gt; operator or the &lt;code&gt;-&amp;gt;&lt;/code&gt; operator):</source>
          <target state="translated">Член летучего квалифицированных структуры или объединения типа приобретает квалификацию типа он принадлежит (как при доступе с помощью &lt;code&gt;.&lt;/code&gt; Оператора или &lt;code&gt;-&amp;gt;&lt;/code&gt; оператор):</target>
        </trans-unit>
        <trans-unit id="01857fa2944d04e325044693ba2bf63f5a8cbfe2" translate="yes" xml:space="preserve">
          <source>A multibyte character string is layout-compatible with &lt;a href=&quot;byte&quot;&gt;null-terminated byte string&lt;/a&gt; (NTBS), that is, can be stored, copied, and examined using the same facilities, except for calculating the number of characters. If the correct locale is in effect, I/O functions also handle multibyte strings. Multibyte strings can be converted to and from wide strings using the following locale-dependent conversion functions:</source>
          <target state="translated">Многобайтовая символьная строка совместима с макетом с &lt;a href=&quot;byte&quot;&gt;байтовой строкой&lt;/a&gt; с нулевым символом в конце (NTBS), то есть может храниться, копироваться и проверяться с использованием тех же средств, за исключением вычисления количества символов. Если действует правильный языковой стандарт, функции ввода / вывода также обрабатывают многобайтовые строки. Многобайтовые строки можно преобразовывать в широкие строки и из них, используя следующие зависящие от локали функции преобразования:</target>
        </trans-unit>
        <trans-unit id="c2f7608097bdd67a3d19cac0cace329c7258c084" translate="yes" xml:space="preserve">
          <source>A negative value of &lt;code&gt;time-&amp;gt;tm_isdst&lt;/code&gt; causes &lt;code&gt;mktime&lt;/code&gt; to attempt to determine if Daylight Saving Time was in effect in the specified time.</source>
          <target state="translated">Отрицательное значение &lt;code&gt;time-&amp;gt;tm_isdst&lt;/code&gt; заставляет &lt;code&gt;mktime&lt;/code&gt; попытаться определить, действовало ли летнее время в указанное время.</target>
        </trans-unit>
        <trans-unit id="d9811e282e7ba765c54d3daa670df15207f42b43" translate="yes" xml:space="preserve">
          <source>A newly opened stream has no orientation. The first call to &lt;code&gt;fwide&lt;/code&gt; or to any I/O function establishes the orientation: a wide I/O function makes the stream wide-oriented, a narrow I/O function makes the stream narrow-oriented. Once set, the orientation can only be changed with &lt;code&gt;&lt;a href=&quot;io/freopen&quot;&gt;freopen&lt;/a&gt;&lt;/code&gt;. Narrow I/O functions cannot be called on a wide-oriented stream; wide I/O functions cannot be called on a narrow-oriented stream. Wide I/O functions convert between wide and multibyte characters as if by calling &lt;code&gt;&lt;a href=&quot;string/multibyte/mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;string/multibyte/wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt;. Unlike the multibyte character strings that are valid in a program, multibyte character sequences in the file may contain embedded nulls and do not have to begin or end in the initial shift state.</source>
          <target state="translated">Вновь открытый поток не имеет ориентации. Первый вызов функции &lt;code&gt;fwide&lt;/code&gt; или любой функции ввода / вывода устанавливает ориентацию: широкая функция ввода / вывода делает поток широко ориентированным, а узкая функция ввода / вывода - узким направлением потока. После установки ориентация может быть изменена только с помощью &lt;code&gt;&lt;a href=&quot;io/freopen&quot;&gt;freopen&lt;/a&gt;&lt;/code&gt; . Узкие функции ввода / вывода не могут быть вызваны в широко ориентированном потоке; широкие функции ввода / вывода нельзя вызывать в узко ориентированном потоке. Широкие функции ввода / вывода преобразуются между широкими и многобайтовыми символами, как если бы они &lt;code&gt;&lt;a href=&quot;string/multibyte/mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;string/multibyte/wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt; . В отличие от многобайтовых символьных строк, допустимых в программе, многобайтовые символьные последовательности в файле могут содержать встроенные нули и не должны начинаться или заканчиваться в начальном состоянии сдвига.</target>
        </trans-unit>
        <trans-unit id="f93966d91f05c405ffd7170387e12fc185074d8c" translate="yes" xml:space="preserve">
          <source>A non-static inline function cannot define a non-const function-local static and cannot refer to a file-scope static.</source>
          <target state="translated">Нестатическая встроенная функция не может определить неконстантную статическую функцию и не может ссылаться на статическую файловую область.</target>
        </trans-unit>
        <trans-unit id="98bb6fdcc52028ba6a8a94a78329f5f014ffb21e" translate="yes" xml:space="preserve">
          <source>A null pointer constant may be &lt;a href=&quot;../language/conversion#Pointer_conversions&quot;&gt;converted&lt;/a&gt; to any pointer type; such conversion results in the null pointer value of that type.</source>
          <target state="translated">Константа нулевого указателя может быть &lt;a href=&quot;../language/conversion#Pointer_conversions&quot;&gt;преобразована&lt;/a&gt; в любой тип указателя; такое преобразование приводит к нулевому значению указателя этого типа.</target>
        </trans-unit>
        <trans-unit id="406f28c4d8ce54f26f886b6cecc24c77951f4ac6" translate="yes" xml:space="preserve">
          <source>A null-terminated byte string (NTBS) is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character). Each byte in a byte string encodes one character of some character set. For example, the character array &lt;code&gt;{'\x63','\x61','\x74','\0'&lt;/code&gt;} is an NTBS holding the string &lt;code&gt;&quot;cat&quot;&lt;/code&gt; in ASCII encoding.</source>
          <target state="translated">Строка байтов с нулевым символом в конце (NTBS) представляет собой последовательность ненулевых байтов, за которыми следует байт со значением ноль (завершающий нулевой символ). Каждый байт в строке байтов кодирует один символ некоторого набора символов. Например, массив символов &lt;code&gt;{'\x63','\x61','\x74','\0'&lt;/code&gt; } является NTBS, содержащим строку &lt;code&gt;&quot;cat&quot;&lt;/code&gt; в кодировке ASCII.</target>
        </trans-unit>
        <trans-unit id="3b3fe15454343ce4cbfa8b2d64edd72623154c83" translate="yes" xml:space="preserve">
          <source>A null-terminated multibyte string (NTMBS), or &quot;multibyte string&quot;, is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character).</source>
          <target state="translated">Нулевая многобайтная строка (NTMBS),или &quot;многобайтная строка&quot;,представляет собой последовательность ненулевых байтов,за которыми следует байт со значением нуля (оканчивающийся нулевой символ).</target>
        </trans-unit>
        <trans-unit id="0ff0edea7748873d38d10264d61ada446ff85e77" translate="yes" xml:space="preserve">
          <source>A null-terminated wide string is a sequence of valid wide characters, ending with a null-character.</source>
          <target state="translated">Нуль-терминированная широкая строка-это последовательность допустимых широких символов,заканчивающаяся нуль-символом.</target>
        </trans-unit>
        <trans-unit id="cd957d3196cf2aa0f452a3d6985d383e4ba9d369" translate="yes" xml:space="preserve">
          <source>A pointer to &lt;code&gt;void&lt;/code&gt; can be implicitly converted to and from any pointer to object type with the following semantics:</source>
          <target state="translated">Указатель на &lt;code&gt;void&lt;/code&gt; может быть неявно преобразован в любой указатель на тип объекта и из него со следующей семантикой:</target>
        </trans-unit>
        <trans-unit id="de2d527f4dc091dd493b9a8f9868ef42f64eef36" translate="yes" xml:space="preserve">
          <source>A pointer to a non-volatile type can be implicitly converted to a pointer to the volatile-qualified version of the same or &lt;a href=&quot;compatible_type&quot;&gt;compatible type&lt;/a&gt;. The reverse conversion can be performed with a cast expression.</source>
          <target state="translated">Указатель на энергонезависимый тип может быть неявно преобразован в указатель на квалифицируемую версию того же или &lt;a href=&quot;compatible_type&quot;&gt;совместимого типа&lt;/a&gt; . Обратное преобразование может быть выполнено с помощью выражения приведения.</target>
        </trans-unit>
        <trans-unit id="8c1876354dd24b2af7bddabb8049a8d468d3ce0c" translate="yes" xml:space="preserve">
          <source>A pointer to a union can be cast to a pointer to each of its members (if a union has bit field members, the pointer to a union can be cast to the pointer to the bit field's underlying type). Likewise, a pointer to any member of a union can be cast to a pointer to the enclosing union.</source>
          <target state="translated">Указатель на объединение может быть брошен в указатель на каждого из его членов (если в объединении есть члены битового поля,то указатель на объединение может быть брошен в указатель на тип,лежащий в основе битового поля).Аналогичным образом,указатель на любого члена союза может быть брошен на указатель на союз в ограждении.</target>
        </trans-unit>
        <trans-unit id="268a4e779dda486b15b5e5f3b72d38b0d1eaba3e" translate="yes" xml:space="preserve">
          <source>A pointer to an non-const type can be implicitly converted to a pointer to const-qualified version of the same or &lt;a href=&quot;compatible_type&quot;&gt;compatible type&lt;/a&gt;. The reverse conversion can be performed with a cast expression.</source>
          <target state="translated">Указатель на неконстантный тип может быть неявно преобразован в указатель на константную версию того же или &lt;a href=&quot;compatible_type&quot;&gt;совместимого типа&lt;/a&gt; . Обратное преобразование может быть выполнено с помощью выражения приведения.</target>
        </trans-unit>
        <trans-unit id="82585af59f0bb594a7902f0e32b95152542a8077" translate="yes" xml:space="preserve">
          <source>A pointer to an object (or one past the object) whose lifetime ended has indeterminate value.</source>
          <target state="translated">Указатель на объект (или на объект,прошедший через него),время жизни которого закончилось,имеет неопределенное значение.</target>
        </trans-unit>
        <trans-unit id="bf50860af56aa1252b085a89c9df0b2ec34aa52c" translate="yes" xml:space="preserve">
          <source>A pointer to an unqualified type may be implicitly converted to the pointer to qualified version of that type (in other words, &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;, &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;, and &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt; qualifiers can be added. The original pointer and the result compare equal.</source>
          <target state="translated">Указатель на неквалифицированный тип может быть неявно преобразован в указатель на квалифицированную версию этого типа (другими словами, могут быть добавлены квалификаторы &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; , &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; и &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt; . Исходный указатель и результат сравнения равны.</target>
        </trans-unit>
        <trans-unit id="a75bb699e6da13526f0dc68a72d5b021bc5756cb" translate="yes" xml:space="preserve">
          <source>A pointer to function can be initialized with an address of a function. Because of the &lt;a href=&quot;conversion&quot;&gt;function-to-pointer&lt;/a&gt; conversion, the address-of operator is optional:</source>
          <target state="translated">Указатель на функцию можно инициализировать с помощью адреса функции. Из &lt;a href=&quot;conversion&quot;&gt;-за&lt;/a&gt; преобразования функции в указатель оператор address-of является необязательным:</target>
        </trans-unit>
        <trans-unit id="9a672c3a635d605d46cb900dc367b14fe6337810" translate="yes" xml:space="preserve">
          <source>A pointer to function can be used on the left-hand side of the &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call operator&lt;/a&gt;; this invokes the pointed-to function:</source>
          <target state="translated">Указатель на функцию можно использовать в левой части &lt;a href=&quot;operator_other#Function_call&quot;&gt;оператора вызова функции&lt;/a&gt; ; это вызывает указанную функцию:</target>
        </trans-unit>
        <trans-unit id="bbc12ed44a0708299938681bbc78649632564ce2" translate="yes" xml:space="preserve">
          <source>A pointer to object can be initialized with the result of the &lt;a href=&quot;operator_member_access&quot;&gt;address-of operator&lt;/a&gt; applied to an expression of object type (which may be incomplete):</source>
          <target state="translated">Указатель на объект может быть инициализирован с помощью результата &lt;a href=&quot;operator_member_access&quot;&gt;оператора address-of,&lt;/a&gt; примененного к выражению типа объекта (которое может быть неполным):</target>
        </trans-unit>
        <trans-unit id="e75b4fd545bf145657eb8864911b4552c5e00b3f" translate="yes" xml:space="preserve">
          <source>A pointer to the previously-installed runtime constraints handler. (note: this pointer is never a null pointer because calling &lt;code&gt;set_constraint_handler_s(&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;)&lt;/code&gt; sets up the system default handler).</source>
          <target state="translated">Указатель на ранее установленный обработчик ограничений времени выполнения. (примечание: этот указатель никогда не является нулевым указателем, потому что вызов &lt;code&gt;set_constraint_handler_s(&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;)&lt;/code&gt; устанавливает системный обработчик по умолчанию).</target>
        </trans-unit>
        <trans-unit id="1e0960972641b3c0a03c6a7b75123a8d844b3797" translate="yes" xml:space="preserve">
          <source>A pointer to this function can be passed to &lt;a href=&quot;set_constraint_handler_s&quot;&gt;set_constraint_handler_s&lt;/a&gt; to establish a runtime constraints violation handler that does nothing.  As with all bounds-checked functions, &lt;code&gt;ignore_handler_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Указатель на эту функцию можно передать в &lt;a href=&quot;set_constraint_handler_s&quot;&gt;set_constraint_handler_s,&lt;/a&gt; чтобы установить обработчик нарушения ограничений времени выполнения, который ничего не делает. Как и для всех функций с &lt;code&gt;ignore_handler_s&lt;/code&gt; границ, ignore_handler_s гарантированно будет доступен, только если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы &lt;code&gt;1&lt;/code&gt; перед включением &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93cf80347c7d11084a2a6667157a9584d0768c8f" translate="yes" xml:space="preserve">
          <source>A pointer to this function can be passed to &lt;a href=&quot;set_constraint_handler_s&quot;&gt;set_constraint_handler_s&lt;/a&gt; to establish a runtime constraints violation handler.  As with all bounds-checked functions, &lt;code&gt;abort_handler_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Указатель на эту функцию можно передать в &lt;a href=&quot;set_constraint_handler_s&quot;&gt;set_constraint_handler_s,&lt;/a&gt; чтобы установить обработчик нарушения ограничений времени выполнения. Как и во всех проверенных границами функциях, &lt;code&gt;abort_handler_s&lt;/code&gt; гарантированно будет доступен только в том случае, если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы &lt;code&gt;1&lt;/code&gt; перед включением &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc6f29c561783d3fd50e7713005eb570a71543db" translate="yes" xml:space="preserve">
          <source>A post-C11 defect report DR 427 changes the semantics of preparing function parameters when calling a function with a prototype from assignment to initialization from their corresponding arguments, in order to allow parameters of const-qualified type (which are</source>
          <target state="translated">Сообщение о дефекте после С11 DR 427 изменяет семантику подготовки параметров функции при вызове функции с прототипом от присваивания к инициализации из их соответствующих аргументов,чтобы разрешить параметры конст-квалифицированного типа (а именно</target>
        </trans-unit>
        <trans-unit id="306aa42e0fc0f9009433757fb90b670651e295cb" translate="yes" xml:space="preserve">
          <source>A previous call to &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; that deallocates a region of memory</source>
          <target state="translated">Предыдущий вызов &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; , который освобождает область памяти</target>
        </trans-unit>
        <trans-unit id="13ef2ca779cb61f44381f5a039956356e16db10c" translate="yes" xml:space="preserve">
          <source>A previous call to &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;realloc&lt;/code&gt; that deallocates a region of memory</source>
          <target state="translated">Предыдущий вызов &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;realloc&lt;/code&gt; , который освобождает область памяти</target>
        </trans-unit>
        <trans-unit id="369395da987013876caff2dc1e6f3dc1c78f2dfd" translate="yes" xml:space="preserve">
          <source>A program may undefine and perhaps then redefine the &lt;code&gt;complex&lt;/code&gt; macro.</source>
          <target state="translated">Программа может отменить определение и, возможно, затем переопределить &lt;code&gt;complex&lt;/code&gt; макрос.</target>
        </trans-unit>
        <trans-unit id="dfbb31de52784bd58fab9c555b2dcef326c6957c" translate="yes" xml:space="preserve">
          <source>A program may undefine and perhaps then redefine the macro &lt;code&gt;I&lt;/code&gt;.</source>
          <target state="translated">Программа может и , возможно , неопределенную затем переопределить макрос &lt;code&gt;I&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="673ac82817b0262ffc8e60c6ab8111db0abf125a" translate="yes" xml:space="preserve">
          <source>A program may undefine and perhaps then redefine the macros &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Программа может отменить определение и, возможно, затем переопределить макросы &lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4493cdd2ed11153441d87177f02ce56356d9390" translate="yes" xml:space="preserve">
          <source>A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its cond_expression, iteration_expression or loop_statement. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where cond_expression is omitted or is a constant expression; &lt;code&gt;for(;;)&lt;/code&gt; is always an endless loop.</source>
          <target state="translated">Программа с бесконечным циклом имеет неопределенное поведение, если цикл не имеет наблюдаемого поведения (ввод-вывод, энергозависимый доступ, атомарный или операция синхронизации) в какой-либо части своего cond_expression, iteration_expression или loop_statement. Это позволяет компиляторам оптимизировать все ненаблюдаемые циклы, не доказывая, что они завершаются. Единственными исключениями являются циклы, в которых cond_expression опущено или является константным выражением; &lt;code&gt;for(;;)&lt;/code&gt; всегда бесконечный цикл.</target>
        </trans-unit>
        <trans-unit id="d4dba07d0b12ec49c823d74b635737a662d716b7" translate="yes" xml:space="preserve">
          <source>A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its statement or expression. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where expression is a constant expression; &lt;code&gt;do {...} while(true);&lt;/code&gt; is always an endless loop.</source>
          <target state="translated">Программа с бесконечным циклом имеет неопределенное поведение, если цикл не имеет наблюдаемого поведения (ввод-вывод, произвольный доступ, атомарный или операция синхронизации) в какой-либо части своего оператора или выражения. Это позволяет компиляторам оптимизировать все ненаблюдаемые циклы, не доказывая, что они завершаются. Единственными исключениями являются циклы, где выражение является константным выражением; &lt;code&gt;do {...} while(true);&lt;/code&gt; это всегда бесконечный цикл.</target>
        </trans-unit>
        <trans-unit id="d9fe083c28287027ff137fe873714315c88575d5" translate="yes" xml:space="preserve">
          <source>A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its statement or expression. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where expression is a constant expression; &lt;code&gt;while(true)&lt;/code&gt; is always an endless loop.</source>
          <target state="translated">Программа с бесконечным циклом имеет неопределенное поведение, если цикл не имеет наблюдаемого поведения (ввод-вывод, произвольный доступ, атомарный или операция синхронизации) в какой-либо части своего оператора или выражения. Это позволяет компиляторам оптимизировать все ненаблюдаемые циклы, не доказывая, что они завершаются. Единственными исключениями являются циклы, где выражение является константным выражением; &lt;code&gt;while(true)&lt;/code&gt; всегда бесконечный цикл.</target>
        </trans-unit>
        <trans-unit id="a987fe5116d16dac6c986d15e44866f1f2950023" translate="yes" xml:space="preserve">
          <source>A read-modify-write operation with this memory order is both an</source>
          <target state="translated">Операция чтения-модификации-записи с этим порядком памяти является одновременно и</target>
        </trans-unit>
        <trans-unit id="78127daba885f04d8c232a3a0e396aee55e69e02" translate="yes" xml:space="preserve">
          <source>A store operation with this memory order performs the</source>
          <target state="translated">Операция хранения с этим порядком памяти выполняет</target>
        </trans-unit>
        <trans-unit id="e387542d0812c72e59ffd89517785f1df0b879db" translate="yes" xml:space="preserve">
          <source>A string literal is not necessarily a string; if a string literal has embedded null characters, it represents an array which contains more than one string:</source>
          <target state="translated">Строковый литерал не обязательно является строкой;если в строковый литерал встроены нулевые символы,то он представляет собой массив,содержащий более одной строки:</target>
        </trans-unit>
        <trans-unit id="b83731486e3b698aa10bc6f537bc54d6e1c7fe80" translate="yes" xml:space="preserve">
          <source>A struct is a type consisting of a sequence of members whose storage is allocated in an ordered sequence (as opposed to union, which is a type consisting of a sequence of members whose storage overlaps).</source>
          <target state="translated">Структура-это тип,состоящий из последовательности членов,хранение которых распределено в упорядоченной последовательности (в отличие от объединения,которое является типом,состоящим из последовательности членов,хранение которых пересекается).</target>
        </trans-unit>
        <trans-unit id="62857b5de9b7091adab212bbe55a64fe6f96c3d8" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; clears the end of file status flag &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;feof&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Успешный вызов &lt;code&gt;ungetc&lt;/code&gt; очищает конец статус файла флаг &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;feof&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f18b9828e8cbe5f820c7f00f14018c93e63c261" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; on a binary stream decrements the stream position indicator by one (the behavior is indeterminate if the stream position indicator was zero).</source>
          <target state="translated">Успешный вызов &lt;code&gt;ungetc&lt;/code&gt; в двоичном потоке уменьшает индикатор положения потока на единицу (поведение не определено, если индикатор положения потока был равен нулю).</target>
        </trans-unit>
        <trans-unit id="ca4337b8d12737a6a022afbf7eb03368caa77b5b" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; on a text stream modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back characters are retrieved with a read operation, the stream position indicator is equal to its value before &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">Успешный вызов &lt;code&gt;ungetc&lt;/code&gt; в текстовом потоке изменяет указатель положения потока неопределенным образом, но гарантирует, что после того, как все задние символы будут получены с помощью операции чтения, указатель положения потока будет равен его значению перед &lt;code&gt;ungetc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac874b9b5964dc5760d3a6f5c96e7d5268fa82e0" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetwc&lt;/code&gt; clears the end of file status flag &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;feof&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Успешный вызов &lt;code&gt;ungetwc&lt;/code&gt; очищает конец статус файла флаг &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;feof&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96bde972d314cd8969488c09d04edcb68d3e8cec" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetwc&lt;/code&gt; on a stream (whether text or binary) modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back wide characters are retrieved with a read operation, the stream position indicator is equal to its value before &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="translated">Успешный вызов &lt;code&gt;ungetwc&lt;/code&gt; в потоке (текстовом или двоичном) изменяет индикатор положения потока неопределенным образом, но гарантирует, что после того, как все задние широкие символы будут получены с помощью операции чтения, индикатор положения потока будет равен его значению перед &lt;code&gt;ungetwc&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="ae28ba5e02f8f525383bb9b4fdd4379afafef790" translate="yes" xml:space="preserve">
          <source>A tentative definition with internal linkage must have complete type.</source>
          <target state="translated">Ориентировочное определение с внутренней связью должно иметь полный тип.</target>
        </trans-unit>
        <trans-unit id="734b0e8555885421cd88b9f937f8a5a91f954a94" translate="yes" xml:space="preserve">
          <source>A thread of execution is a flow of control within a program that begins with the invocation of a top-level function by &lt;code&gt;&lt;a href=&quot;../thread/thrd_create&quot;&gt;thrd_create&lt;/a&gt;&lt;/code&gt; or other means.</source>
          <target state="translated">Поток выполнения - это поток управления в программе, который начинается с вызова функции верхнего уровня с помощью &lt;code&gt;&lt;a href=&quot;../thread/thrd_create&quot;&gt;thrd_create&lt;/a&gt;&lt;/code&gt; или другими средствами.</target>
        </trans-unit>
        <trans-unit id="83494c42dbcc847aa1ff217c1fe7f8283385dd00" translate="yes" xml:space="preserve">
          <source>A type may have to be named in context other than the &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;. In these situations,</source>
          <target state="translated">Тип может быть назван в контексте, отличном от &lt;a href=&quot;declarations&quot;&gt;объявления&lt;/a&gt; . В этих ситуациях</target>
        </trans-unit>
        <trans-unit id="89da242d1eea5250f1f3146f1bc7040bd1b23fbb" translate="yes" xml:space="preserve">
          <source>A type name may introduce a new type:</source>
          <target state="translated">Имя типа может ввести новый тип:</target>
        </trans-unit>
        <trans-unit id="0ded4b2c0ade545ee92678f87004b8c5310458e0" translate="yes" xml:space="preserve">
          <source>A typedef for a VLA can only appear at block scope. The length of the array is evaluated each time the flow of control passes over the typedef declaration, as opposed to the declaration of the array itself:</source>
          <target state="translated">Типедef для VLA может появляться только в области видимости блока.Длина массива вычисляется каждый раз,когда поток управления проходит через объявление typedef,в отличие от объявления самого массива:</target>
        </trans-unit>
        <trans-unit id="ea6b56408c3f67fe3e4cd9bb8c98bda8cd2227a2" translate="yes" xml:space="preserve">
          <source>A typical cause of failure for &lt;code&gt;puts&lt;/code&gt; is running out of space on the file system, when stdout is redirected to a file.</source>
          <target state="translated">Типичная причина сбоя для &lt;code&gt;puts&lt;/code&gt; - это нехватка места в файловой системе, когда stdout перенаправляется в файл.</target>
        </trans-unit>
        <trans-unit id="6f0adfae1100114c8248488bd9e46306cf3169dd" translate="yes" xml:space="preserve">
          <source>A union is a type consisting of a sequence of members whose storage overlaps (as opposed to struct, which is a type consisting of a sequence of members whose storage is allocated in an ordered sequence). The value of at most one of the members can be stored in a union at any one time.</source>
          <target state="translated">Профсоюз-это тип,состоящий из последовательности членов,хранение которых накладывается друг на друга (в отличие от структуры,которая представляет собой тип,состоящий из последовательности членов,хранение которых распределяется в упорядоченной последовательности).Значение максимум одного из членов может храниться в профсоюзе в любой момент времени.</target>
        </trans-unit>
        <trans-unit id="b72fa34edde9b7a760e2ca9a63cea91e1b555145" translate="yes" xml:space="preserve">
          <source>A universal character name in a narrow string literal or a 16-bit string literal may map to more than one character, e.g. &lt;code&gt;\U0001f34c&lt;/code&gt; is 4 &lt;code&gt;char&lt;/code&gt; code units in UTF-8 (&lt;code&gt;\xF0\x9F\x8D\x8C&lt;/code&gt;) and 2 &lt;code&gt;char16_t&lt;/code&gt; code units in UTF-16 (&lt;code&gt;\uD83C\uDF4C&lt;/code&gt;).</source>
          <target state="translated">Универсальное имя символа в узком строкового литерала или 16-битным строковый литерал может отображать более одного символа, например , &lt;code&gt;\U0001f34c&lt;/code&gt; является 4 - &lt;code&gt;char&lt;/code&gt; кода единицы в UTF-8 ( &lt;code&gt;\xF0\x9F\x8D\x8C&lt;/code&gt; ) и 2 &lt;code&gt;char16_t&lt;/code&gt; кода единицы в UTF-16 ( &lt;code&gt;\uD83C\uDF4C&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="15de7dbea993ba11f5f4400e4c3b5596b766e0df" translate="yes" xml:space="preserve">
          <source>A valid C program must not depend on whether the inline version or the external version of a function is called.</source>
          <target state="translated">Действительная программа на языке Си не должна зависеть от того,будет ли вызвана встроенная или внешняя версия функции.</target>
        </trans-unit>
        <trans-unit id="d626b3d232c881f5c4b8b1ea2e9f96008808e88d" translate="yes" xml:space="preserve">
          <source>A value of any complex type can be implicitly converted to any imaginary type.</source>
          <target state="translated">Значение любого сложного типа может быть неявно преобразовано в любой воображаемый тип.</target>
        </trans-unit>
        <trans-unit id="5c88d24cc4ec994d46157d83290ad8af83a11e69" translate="yes" xml:space="preserve">
          <source>A value of any complex type can be implicitly converted to any other complex type. The real part and the imaginary part individually follow the conversion rules for the real floating types.</source>
          <target state="translated">Значение любого комплексного типа может быть неявно преобразовано в любое другое комплексное значение.Реальная часть и воображаемая часть по отдельности следуют правилам приведения для реальных плавающих типов.</target>
        </trans-unit>
        <trans-unit id="045b19c719d2ce31e6c3fc2dbb610a034ab82f27" translate="yes" xml:space="preserve">
          <source>A value of any complex type can be implicitly converted to any real floating type.</source>
          <target state="translated">Значение любого сложного типа может быть неявно приведено к любому реальному плавающему типу.</target>
        </trans-unit>
        <trans-unit id="523b4bcf3df5def7bdb173f6da2f1c669d5ffd10" translate="yes" xml:space="preserve">
          <source>A value of any imaginary type can be implicitly converted to any complex type.</source>
          <target state="translated">Значение любого воображаемого типа может быть неявно преобразовано в любой сложный тип.</target>
        </trans-unit>
        <trans-unit id="a4bba57f46ad248ddc356b6653b3a832c38ef932" translate="yes" xml:space="preserve">
          <source>A value of any imaginary type can be implicitly converted to any other imaginary type. The imaginary part follows the conversion rules for the real floating types.</source>
          <target state="translated">Значение любого воображаемого типа может быть неявно преобразовано в любое другое воображаемое.Воображаемая часть следует правилам приведения для реальных плавающих типов.</target>
        </trans-unit>
        <trans-unit id="3eeda2e376d925bd595e8ae9c46012cbc5e846d4" translate="yes" xml:space="preserve">
          <source>A value of any imaginary type can be implicitly converted to any real type (integer or floating-point). The result is always a positive (or unsigned) zero, except when the target type is _Bool, in which case boolean conversion rules apply.</source>
          <target state="translated">Значение любого воображаемого типа может быть неявно приведено к любому вещественному типу (целому или с плавающей точкой).Результатом всегда будет положительный (или беззнаковый)ноль,за исключением случая,когда целевым типом является _Bool,в этом случае применяются правила булевого приведения.</target>
        </trans-unit>
        <trans-unit id="b1043e27727b5859c73d6368abb56140d9c8c4df" translate="yes" xml:space="preserve">
          <source>A value of any integer type can be implicitly converted to any other integer type. Except where covered by promotions and boolean conversions above, the rules are:</source>
          <target state="translated">Значение любого целочисленного типа может быть неявно приведено к любому другому целочисленному типу.За исключением случаев,когда вышеперечисленные промо-акции и булевые преобразования являются правилами:</target>
        </trans-unit>
        <trans-unit id="d48506c225a6b698b81ca8310a86f4f65be3e2ca" translate="yes" xml:space="preserve">
          <source>A value of any integer type can be implicitly converted to any real floating type.</source>
          <target state="translated">Значение любого целочисленного типа может быть неявно приведено к любому вещественному плавающему типу.</target>
        </trans-unit>
        <trans-unit id="026d85487a9bfd120f0733b4a332d6f7183d4b83" translate="yes" xml:space="preserve">
          <source>A value of any real floating type can be implicitly converted to any complex type.</source>
          <target state="translated">Значение любого реального плавающего типа может быть неявно приведено к любому сложному типу.</target>
        </trans-unit>
        <trans-unit id="1850c152b30508607de5e5ce9465d153d7482b90" translate="yes" xml:space="preserve">
          <source>A value of any real floating type can be implicitly converted to any other real floating type.</source>
          <target state="translated">Значение любого вещественного плавающего типа может быть неявно приведено к любому другому вещественному плавающему типу.</target>
        </trans-unit>
        <trans-unit id="4ddbeeb9abdb8bf97e248ee8a8c3ed50c8646e45" translate="yes" xml:space="preserve">
          <source>A value of any real type can be implicitly converted to any imaginary type. The result is always a positive imaginary zero.</source>
          <target state="translated">Значение любого вещественного типа может быть неявно приведено к любому воображаемому типу.Результатом всегда будет положительный воображаемый ноль.</target>
        </trans-unit>
        <trans-unit id="542b0b974643a87f82bdfb9069328ad0a228dd34" translate="yes" xml:space="preserve">
          <source>A value of any scalar type can be implicitly converted to _Bool. The values that compare equal to zero are converted to &lt;code&gt;​0​&lt;/code&gt;, all other values are converted to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Значение любого скалярного типа может быть неявно преобразовано в _Bool. Значения , которые сравнивают равны нулю, преобразуются в &lt;code&gt;​0​&lt;/code&gt; , все остальные значения преобразуются в &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa3584dfc017c837cf1f146d7c3bfa22f920a495" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;void (*)(int)&lt;/code&gt;. When returned by &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;signal&lt;/a&gt;&lt;/code&gt;, indicates that an error has occurred.</source>
          <target state="translated">Значение типа &lt;code&gt;void (*)(int)&lt;/code&gt; . При возврате по &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;signal&lt;/a&gt;&lt;/code&gt; указывает, что произошла ошибка.</target>
        </trans-unit>
        <trans-unit id="e43f5b4e5dab83ce22f20cdda8ca8c5befbdfb54" translate="yes" xml:space="preserve">
          <source>A well-known example of the same identifier being used across two name spaces is the identifier &lt;code&gt;stat&lt;/code&gt; from the POSIX header &lt;code&gt;sys/stat.h&lt;/code&gt;. It &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/&quot;&gt;names a function&lt;/a&gt; when used as an ordinary identifier and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;indicates a struct&lt;/a&gt; when used as a tag.</source>
          <target state="translated">Хорошо известный пример того же идентификатора используется в двух пространств имен является идентификатором &lt;code&gt;stat&lt;/code&gt; от POSIX заголовка &lt;code&gt;sys/stat.h&lt;/code&gt; . При использовании в качестве обычного идентификатора она &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/&quot;&gt;называет функцию&lt;/a&gt; и &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;указывает на структуру&lt;/a&gt; при использовании в качестве тега.</target>
        </trans-unit>
        <trans-unit id="47e9ca7eeeecd01f720a4c3ebefa8b5b579f496b" translate="yes" xml:space="preserve">
          <source>A.1.2.1 Expressions</source>
          <target state="translated">A.1.2.1 Выражения</target>
        </trans-unit>
        <trans-unit id="9fa96a046c7129ab706b3906b3b75c43d0b3b41e" translate="yes" xml:space="preserve">
          <source>A.2.1 Expressions</source>
          <target state="translated">A.2.1 Выражения</target>
        </trans-unit>
        <trans-unit id="187459c12cbce645deb52d74f3d6152a7a9a17fc" translate="yes" xml:space="preserve">
          <source>ASCII Chart</source>
          <target state="translated">ASCII-график</target>
        </trans-unit>
        <trans-unit id="6b85275355e86325dde0c35693852c2d7820c750" translate="yes" xml:space="preserve">
          <source>ASCII chart</source>
          <target state="translated">ASCII-график</target>
        </trans-unit>
        <trans-unit id="6ff2c765d8c7f7f1624b70244d10913facb7ae0b" translate="yes" xml:space="preserve">
          <source>ASCII values</source>
          <target state="translated">ASCII-значения</target>
        </trans-unit>
        <trans-unit id="741d25da837c7eedcbdbd90d0d949bbad6187038" translate="yes" xml:space="preserve">
          <source>ATOMIC_*_LOCK_FREE</source>
          <target state="translated">ATOMIC_*_LOCK_FREE</target>
        </trans-unit>
        <trans-unit id="1120084929ffa752eeda2469d9c594dc3612e485" translate="yes" xml:space="preserve">
          <source>ATOMIC_BOOL_LOCK_FREEATOMIC_CHAR_LOCK_FREEATOMIC_CHAR16_T_LOCK_FREEATOMIC_CHAR32_T_LOCK_FREEATOMIC_WCHAR_T_LOCK_FREEATOMIC_SHORT_LOCK_FREEATOMIC_INT_LOCK_FREEATOMIC_LONG_LOCK_FREEATOMIC_LLONG_LOCK_FREEATOMIC_POINTER_LOCK_FREE</source>
          <target state="translated">ATOMIC_BOOL_LOCK_FREEATOMIC_CHAR_LOCK_FREEATOMIC_CHAR16_T_LOCK_FREEATOMIC_CHAR32_T_LOCK_FREEATOMIC_WCHAR_T_LOCK_FREEATOMIC_SHORT_LOCK_FREEATOMIC_INT_LOCK_FREEATOMIC_LONG_LOCK_FREEATOMIC_LLONG_LOCK_FREEATOMIC_POINTER_LOCK_FREE</target>
        </trans-unit>
        <trans-unit id="63e21a0c9c10fbf518b0166eb437a67f1ed962cd" translate="yes" xml:space="preserve">
          <source>ATOMIC_FLAG_INIT</source>
          <target state="translated">ATOMIC_FLAG_INIT</target>
        </trans-unit>
        <trans-unit id="0b0620452fea1cd6ef04952a1260146f273e310f" translate="yes" xml:space="preserve">
          <source>ATOMIC_VAR_INIT</source>
          <target state="translated">ATOMIC_VAR_INIT</target>
        </trans-unit>
        <trans-unit id="9de67dfb6d06413cdc219824a0f3f88445b9f32c" translate="yes" xml:space="preserve">
          <source>Access out of bounds</source>
          <target state="translated">Доступ вне пределов</target>
        </trans-unit>
        <trans-unit id="1632238dd01e0d2949d4e0ad89257742628b773a" translate="yes" xml:space="preserve">
          <source>Access to pointer passed to realloc</source>
          <target state="translated">Доступ к указателю,переданному realloc</target>
        </trans-unit>
        <trans-unit id="c14ddd2129de76c2ada1aa7e78baf410f83de4be" translate="yes" xml:space="preserve">
          <source>Accessing a member of an atomic struct/union is undefined behavior.</source>
          <target state="translated">Доступ к члену атомной структуры/союза является неопределенным поведением.</target>
        </trans-unit>
        <trans-unit id="f576e8c8e33a749329570e7a77b007df382e969e" translate="yes" xml:space="preserve">
          <source>Accessing an object outside of its lifetime is undefined behavior.</source>
          <target state="translated">Доступ к объекту вне времени его жизни является неопределенным поведением.</target>
        </trans-unit>
        <trans-unit id="b720069db01e986b09ea45ae4ab2aa8008f5f98c" translate="yes" xml:space="preserve">
          <source>Accessing the variadic arguments from the function body uses the following library facilities:</source>
          <target state="translated">Доступ к вариадическим аргументам из тела функции использует следующие библиотечные средства:</target>
        </trans-unit>
        <trans-unit id="894e0d0ca601136dd7488a48cc4e246850d2e574" translate="yes" xml:space="preserve">
          <source>Action if file</source>
          <target state="translated">Действие,если файл</target>
        </trans-unit>
        <trans-unit id="48911a7386b2baa20a76ef9e342562ca04e9c341" translate="yes" xml:space="preserve">
          <source>Addition and subtraction</source>
          <target state="translated">Добавление и вычитание</target>
        </trans-unit>
        <trans-unit id="283ec445be98c579864590d0e92c5442ed90be08" translate="yes" xml:space="preserve">
          <source>Additional basic types and convenience macros</source>
          <target state="translated">Дополнительные основные виды и удобные макросы</target>
        </trans-unit>
        <trans-unit id="c33da322e780907896acfdbb397c70d360f6b9ec" translate="yes" xml:space="preserve">
          <source>Additional implementation-defined types may be acceptable. It is also implementation-defined whether a bit field may have &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt; type.(since C11) The number of bits in a bit field (width) sets the limit to the range of values it can hold:</source>
          <target state="translated">Дополнительные типы, определенные реализацией, могут быть приемлемыми. Также определяется реализацией, может ли битовое поле иметь &lt;a href=&quot;atomic&quot;&gt;атомарный&lt;/a&gt; тип. (Начиная с C11) Количество битов в битовом поле (ширина) устанавливает ограничение на диапазон значений, которые оно может содержать:</target>
        </trans-unit>
        <trans-unit id="0d1029ad60405084db977e479c06f25f269c8a36" translate="yes" xml:space="preserve">
          <source>Additional macro constants, with names that begin with &lt;code&gt;LC_&lt;/code&gt; followed by at least one uppercase letter, may be defined in &lt;code&gt;locale.h&lt;/code&gt;. For example, the POSIX specification requires LC_MESSAGES (which controls, among other things, &lt;code&gt;&lt;a href=&quot;../io/perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;strerror&lt;/a&gt;&lt;/code&gt;), ISO/IEC 30112:2014 (&lt;a href=&quot;http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf&quot;&gt;2014 draft&lt;/a&gt;) additionally defines LC_IDENTIFICATION, LC_XLITERATE, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_PAPER, LC_MEASUREMENT, and LC_KEYBOARD, which are supported by the GNU C library (except for LC_XLITERATE).</source>
          <target state="translated">Дополнительные макро-константы, имена которых начинаются с &lt;code&gt;LC_&lt;/code&gt; , за которым следует хотя бы одна заглавная буква, могут быть определены в &lt;code&gt;locale.h&lt;/code&gt; . Например, спецификация POSIX требует LC_MESSAGES (который контролирует, помимо прочего, &lt;code&gt;&lt;a href=&quot;../io/perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;strerror&lt;/a&gt;&lt;/code&gt; ), ISO / IEC 30112: 2014 ( &lt;a href=&quot;http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf&quot;&gt;2014 проект&lt;/a&gt; ) дополнительно определяет LC_IDENTIFICATION, LC_XLITERATE, lc_name, LC_ADDRESS, LC_TELEPHONE, LC_PAPER, LC_MEASUREMENT и LC_KEYBOARD, которые поддерживаются библиотекой GNU C (за исключением LC_XLITERATE).</target>
        </trans-unit>
        <trans-unit id="764a28584542378b58ffc1460c2f5cd3c32d60ca" translate="yes" xml:space="preserve">
          <source>Additional macros that begin with &lt;code&gt;FE_&lt;/code&gt; followed by uppercase letters, and have the type &lt;code&gt;const fenv_t*&lt;/code&gt;, may be supported by an implementation.</source>
          <target state="translated">Дополнительные макросы, которые начинаются с &lt;code&gt;FE_&lt;/code&gt; , за которыми следуют заглавные буквы и имеют тип &lt;code&gt;const fenv_t*&lt;/code&gt; , могут поддерживаться реализацией.</target>
        </trans-unit>
        <trans-unit id="ef3d826dd03b81e684d86b842e89e92269929ee7" translate="yes" xml:space="preserve">
          <source>Additional numeric formats may be accepted by the currently installed C &lt;code&gt;&lt;a href=&quot;../../locale/setlocale&quot;&gt;locale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Дополнительные числовые форматы могут быть приняты в настоящее время установлена C &lt;code&gt;&lt;a href=&quot;../../locale/setlocale&quot;&gt;locale&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8146529cfa6fa203e23e61b37cbdf2d37d4634b" translate="yes" xml:space="preserve">
          <source>Additional rounding modes may be supported by an implementation.</source>
          <target state="translated">Дополнительные режимы округления могут быть поддержаны реализацией.</target>
        </trans-unit>
        <trans-unit id="bb9fec43e4640236adc94f7a637b3f0160e148fc" translate="yes" xml:space="preserve">
          <source>Additionally, for every parameter of &lt;a href=&quot;array&quot;&gt;array type&lt;/a&gt; that uses the keyword &lt;code&gt;static&lt;/code&gt; between &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;, the argument expression must designate a pointer to the element of an array with at least that many elements as specified in the size expression of the parameter.</source>
          <target state="translated">Кроме того, для каждого параметра типа &lt;a href=&quot;array&quot;&gt;массива,&lt;/a&gt; который использует ключевое слово &lt;code&gt;static&lt;/code&gt; между &lt;code&gt;[&lt;/code&gt; и &lt;code&gt;]&lt;/code&gt; , выражение аргумента должно обозначать указатель на элемент массива, по крайней мере, с таким количеством элементов, как указано в выражении размера параметра.</target>
        </trans-unit>
        <trans-unit id="76be74594d0a3f6f1c23004ef8fbefa453574daa" translate="yes" xml:space="preserve">
          <source>Additive operators</source>
          <target state="translated">Добавочные операторы</target>
        </trans-unit>
        <trans-unit id="576276822a153883d3d9699e768d5b4ee811a461" translate="yes" xml:space="preserve">
          <source>Address of</source>
          <target state="translated">адрес</target>
        </trans-unit>
        <trans-unit id="9377e4719dc070a5dfa0119a44583c6b5ae07578" translate="yes" xml:space="preserve">
          <source>Address-of</source>
          <target state="translated">Address-of</target>
        </trans-unit>
        <trans-unit id="458e4498a6e12a40a95f335b3f81898cfd748b12" translate="yes" xml:space="preserve">
          <source>Adjacent &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; are concatenated.</source>
          <target state="translated">Смежные &lt;a href=&quot;string_literal&quot;&gt;строковые литералы&lt;/a&gt; объединяются.</target>
        </trans-unit>
        <trans-unit id="1fb3e0e585b7b35a447a3da6d3ae0da5248da92b" translate="yes" xml:space="preserve">
          <source>After encountering the &lt;code&gt;#error&lt;/code&gt; directive, an implementation displays the diagnostic message error_message and renders the program ill-formed (the compilation stops).</source>
          <target state="translated">После обнаружения директивы &lt;code&gt;#error&lt;/code&gt; реализация отображает диагностическое сообщение error_message и визуализирует программу неправильно (компиляция останавливается).</target>
        </trans-unit>
        <trans-unit id="37697aac1a5eff809b30503e048e426d91ee09c0" translate="yes" xml:space="preserve">
          <source>After seeking to a non-end position in a wide stream, the next call to any output function may render the remainder of the file undefined, e.g. by outputting a multibyte sequence of a different length.</source>
          <target state="translated">После поиска незавершенной позиции в широком потоке,следующий вызов любой выходной функции может сделать оставшуюся часть файла неопределенной,например,путем вывода многобайтовой последовательности различной длины.</target>
        </trans-unit>
        <trans-unit id="8942a31efdd7fa2a68a933b01b212ddbca06e0f0" translate="yes" xml:space="preserve">
          <source>After this statement the control is transferred to the statement or declaration immediately following the enclosing loop or switch, as if by &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;.</source>
          <target state="translated">После этого оператора управление передается оператору или объявлению, непосредственно следующему за замкнутым циклом или переключателем, как если бы это происходило с помощью &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="67e15eb99dc0e473c962d6a494d00e048e9f6fc6" translate="yes" xml:space="preserve">
          <source>Algorithms</source>
          <target state="translated">Algorithms</target>
        </trans-unit>
        <trans-unit id="d72f31b2f308ee63f6def08b39a4b92ac993f430" translate="yes" xml:space="preserve">
          <source>Alignas specifier only needs to appear on the &lt;a href=&quot;declarations#Definitions&quot;&gt;definition&lt;/a&gt; of an object, but if any declaration uses alignas, it must specify the same alignment as the alignas on the definition. The behavior is undefined if different translation units specify different alignments for the same object.</source>
          <target state="translated">Спецификатор Alignas должен присутствовать только в &lt;a href=&quot;declarations#Definitions&quot;&gt;определении&lt;/a&gt; объекта, но если какое-либо объявление использует alignas, он должен указывать такое же выравнивание, что и alignas в определении. Поведение не определено, если разные единицы перевода задают разные выравнивания для одного и того же объекта.</target>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="translated">Alignment</target>
        </trans-unit>
        <trans-unit id="998eaf2c199d6e6c5ec4ea687761747f4ea20894" translate="yes" xml:space="preserve">
          <source>Alignment of the allocation unit that holds a bit field</source>
          <target state="translated">Выравнивание блока распределения,удерживающего битовое поле</target>
        </trans-unit>
        <trans-unit id="6a874fb4ad2b87c17e904b10d9366720c6d119fa" translate="yes" xml:space="preserve">
          <source>Alignment requirement(C11)</source>
          <target state="translated">Требование к выравниванию(C11)</target>
        </trans-unit>
        <trans-unit id="60417779e7300dcc151a6eb620dfb95350289093" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;value_category&quot;&gt;value categories&lt;/a&gt;, including function designators and void expressions, are allowed as expressions in a generic selection, and if selected, the generic selection itself has the same value category.</source>
          <target state="translated">Все &lt;a href=&quot;value_category&quot;&gt;категории значений&lt;/a&gt; , включая обозначения функций и пустые выражения, допускаются как выражения в универсальном выборе, и если этот параметр выбран, сам универсальный выбор имеет ту же категорию значений.</target>
        </trans-unit>
        <trans-unit id="4f9ee5d352b4270a148f5665caeb9006b6fbb7b5" translate="yes" xml:space="preserve">
          <source>All array elements that are not initialized explicitly are &lt;a href=&quot;initialization&quot;&gt;initialized implicitly&lt;/a&gt; the same way as objects that have static storage duration.</source>
          <target state="translated">Все элементы массива, которые не инициализированы явно, &lt;a href=&quot;initialization&quot;&gt;инициализируются неявно так&lt;/a&gt; же, как объекты, которые имеют статическую продолжительность хранения.</target>
        </trans-unit>
        <trans-unit id="4c15cf3f5d785f05b074208b892da42654f696fb" translate="yes" xml:space="preserve">
          <source>All comments are removed from the program at &lt;a href=&quot;language/translation_phases&quot;&gt;translation phase 3&lt;/a&gt; by replacing each comment with a single whitespace character.</source>
          <target state="translated">Все комментарии удаляются из программы на &lt;a href=&quot;language/translation_phases&quot;&gt;этапе перевода 3&lt;/a&gt; , заменяя каждый комментарий одним пробелом.</target>
        </trans-unit>
        <trans-unit id="a33a0daa0c6f810f1da4bed7e4f886f7a3fa028a" translate="yes" xml:space="preserve">
          <source>All conversion specifiers other than &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; consume and discard all leading whitespace characters (determined as if by calling &lt;a href=&quot;../string/byte/isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt;) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</source>
          <target state="translated">Все спецификаторы преобразования, кроме &lt;code&gt;[&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; и &lt;code&gt;n&lt;/code&gt; , потребляют и отбрасывают все &lt;a href=&quot;../string/byte/isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt; пробельные символы (определяемые как при вызове isspace ) перед попыткой анализа ввода. Эти использованные символы не учитываются при указании максимальной ширины поля.</target>
        </trans-unit>
        <trans-unit id="e7cb57b66d2139c6b332fa6e8e17ae9b77fdde8b" translate="yes" xml:space="preserve">
          <source>All conversion specifiers other than &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; consume and discard all leading whitespace characters (determined as if by calling &lt;a href=&quot;../string/wide/iswspace&quot;&gt;&lt;code&gt;iswspace&lt;/code&gt;&lt;/a&gt;) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</source>
          <target state="translated">Все спецификаторы преобразования, кроме &lt;code&gt;[&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; и &lt;code&gt;n&lt;/code&gt; , потребляют и отбрасывают все &lt;a href=&quot;../string/wide/iswspace&quot;&gt; &lt;code&gt;iswspace&lt;/code&gt; &lt;/a&gt; пробельные символы (определяемые как при вызове iswspace ) перед попыткой анализа ввода. Эти использованные символы не учитываются при указании максимальной ширины поля.</target>
        </trans-unit>
        <trans-unit id="170e9e40346b4676af2c9543c1315fbdba1de3af" translate="yes" xml:space="preserve">
          <source>All members that are not initialized explicitly are &lt;a href=&quot;initialization#Implicit_initialization&quot;&gt;initialized implicitly&lt;/a&gt; the same way as objects that have static storage duration.</source>
          <target state="translated">Все члены, которые не инициализированы явно, &lt;a href=&quot;initialization#Implicit_initialization&quot;&gt;инициализируются неявно так&lt;/a&gt; же, как объекты, которые имеют статическую продолжительность хранения.</target>
        </trans-unit>
        <trans-unit id="237d36367069e4b8c7a44d2afc03a5597429cd9e" translate="yes" xml:space="preserve">
          <source>All other identifiers are available, with no fear of unexpected collisions when moving programs from one compiler and library to another.</source>
          <target state="translated">Все остальные идентификаторы доступны,не опасаясь неожиданных столкновений при переносе программ из одного компилятора и библиотеки в другой.</target>
        </trans-unit>
        <trans-unit id="1fbacfcbc3bb83e6594a5426d07a776d016ded8e" translate="yes" xml:space="preserve">
          <source>All these functions invoke &lt;code&gt;va_arg&lt;/code&gt; at least once, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions do not invoke &lt;code&gt;va_end&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="translated">Все эти функции вызывают &lt;code&gt;va_arg&lt;/code&gt; хотя бы один раз, значение &lt;code&gt;arg&lt;/code&gt; после возврата не определено. Эти функции не вызывают &lt;code&gt;va_end&lt;/code&gt; , и это должно быть сделано вызывающей стороной.</target>
        </trans-unit>
        <trans-unit id="11b370485f04e9782b3074994340dd54b2c413b7" translate="yes" xml:space="preserve">
          <source>All these functions invoke &lt;code&gt;va_arg&lt;/code&gt; at least once, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions to not invoke &lt;code&gt;va_end&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="translated">Все эти функции вызывают &lt;code&gt;va_arg&lt;/code&gt; хотя бы один раз, значение &lt;code&gt;arg&lt;/code&gt; после возврата не определено. Эти функции не вызывают &lt;code&gt;va_end&lt;/code&gt; , и это должно быть сделано вызывающей стороной.</target>
        </trans-unit>
        <trans-unit id="35959593fb331ed044f2bd60520abb9932e2098b" translate="yes" xml:space="preserve">
          <source>All these functions may invoke &lt;code&gt;va_arg&lt;/code&gt;, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions to not invoke &lt;code&gt;va_end&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="translated">Все эти функции могут вызывать &lt;code&gt;va_arg&lt;/code&gt; , значение &lt;code&gt;arg&lt;/code&gt; не определено после возврата. Эти функции не вызывают &lt;code&gt;va_end&lt;/code&gt; , и это должно быть сделано вызывающей стороной.</target>
        </trans-unit>
        <trans-unit id="b0490d0cb63a327b1645f25c31bcc6482c7608ed" translate="yes" xml:space="preserve">
          <source>All these macro constants (except &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt;) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions. Each macro is only defined if it is supported.</source>
          <target state="translated">Все эти макро константы (кроме &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt; ) расширяются до целочисленных константных выражений, которые имеют различные степени 2, которые однозначно идентифицируют все поддерживаемые исключения с плавающей точкой. Каждый макрос определяется только в том случае, если он поддерживается.</target>
        </trans-unit>
        <trans-unit id="4b26e5fb8ce8c48af69f0f82512b4e4d3a9cb87e" translate="yes" xml:space="preserve">
          <source>All thread-specific storage values (see &lt;code&gt;&lt;a href=&quot;tss_create&quot;&gt;tss_create&lt;/a&gt;&lt;/code&gt;) are initialized to &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Все специфичные для потока значения хранилища (см. &lt;code&gt;&lt;a href=&quot;tss_create&quot;&gt;tss_create&lt;/a&gt;&lt;/code&gt; ) инициализируются в &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb8fdb32122bd65cf5d7c325d5377fe22c226fe9" translate="yes" xml:space="preserve">
          <source>All undefined behavior not listed as critical is bounded, including</source>
          <target state="translated">Все неопределённое поведение,не указанное в качестве критического,ограничено,в том числе</target>
        </trans-unit>
        <trans-unit id="7b8e5641e2d8cbf1a2bdfdaf4f5a52ae7c538b20" translate="yes" xml:space="preserve">
          <source>Allocate &lt;code&gt;size&lt;/code&gt; bytes of uninitialized storage whose alignment is specified by &lt;code&gt;alignment&lt;/code&gt;. The &lt;code&gt;size&lt;/code&gt; parameter must be an integral multiple of &lt;code&gt;alignment&lt;/code&gt;.</source>
          <target state="translated">Выделите байты &lt;code&gt;size&lt;/code&gt; неинициализированного хранилища, выравнивание которого определяется &lt;code&gt;alignment&lt;/code&gt; . Параметр &lt;code&gt;size&lt;/code&gt; должен быть целым кратным &lt;code&gt;alignment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="575bf26e9df794dbd1383b334ef663788e920b7e" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;size&lt;/code&gt; bytes of uninitialized storage.</source>
          <target state="translated">Выделяет байты &lt;code&gt;size&lt;/code&gt; неинициализированного хранилища.</target>
        </trans-unit>
        <trans-unit id="eaf6e4d87daf82411e96d7b40d5b5e9337ffd24d" translate="yes" xml:space="preserve">
          <source>Allocates memory for an array of &lt;code&gt;num&lt;/code&gt; objects of size &lt;code&gt;size&lt;/code&gt; and initializes all bytes in the allocated storage to zero.</source>
          <target state="translated">Выделяет память для массива &lt;code&gt;num&lt;/code&gt; объектов размера &lt;code&gt;size&lt;/code&gt; и инициализирует все байты в выделенном хранилище нулю.</target>
        </trans-unit>
        <trans-unit id="dfab2da001a1d62544447fa5f9f2ca3eaeb8861b" translate="yes" xml:space="preserve">
          <source>Allows values of floating type to be used directly in expressions.</source>
          <target state="translated">Позволяет использовать значения плавающего типа непосредственно в выражениях.</target>
        </trans-unit>
        <trans-unit id="ccb54e9be1a4c6bc9837fefd7cc02f1997a12f3c" translate="yes" xml:space="preserve">
          <source>Allows values of integer type to be used in expressions directly.</source>
          <target state="translated">Позволяет напрямую использовать в выражениях значения целочисленного типа.</target>
        </trans-unit>
        <trans-unit id="c630eed84e53f9bda6e9f3acef1d7440aafcdd63" translate="yes" xml:space="preserve">
          <source>Also, each name that begins with a double underscore __ or an underscore followed by an uppercase letter is reserved: see &lt;a href=&quot;language/identifier#Reserved_identifiers&quot;&gt;identifier&lt;/a&gt; for details.</source>
          <target state="translated">Кроме того, каждое имя, которое начинается с двойного подчеркивания __ или подчеркивания, за которым следует заглавная буква, зарезервировано: подробности см. В &lt;a href=&quot;language/identifier#Reserved_identifiers&quot;&gt;идентификаторе&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d26d9b99ae9e352859532e801512a8d171f666b" translate="yes" xml:space="preserve">
          <source>Also, in C89, functions returning &lt;code&gt;int&lt;/code&gt; may be implicitly declared by the &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call operator&lt;/a&gt; and function parameters of type &lt;code&gt;int&lt;/code&gt; do not have to be declared when using old-style &lt;a href=&quot;function_definition&quot;&gt;function definitions&lt;/a&gt;.</source>
          <target state="translated">Кроме того, в C89 функции, возвращающие &lt;code&gt;int&lt;/code&gt; , могут быть неявно объявлены &lt;a href=&quot;operator_other#Function_call&quot;&gt;оператором вызова&lt;/a&gt; функции, и параметры функции типа &lt;code&gt;int&lt;/code&gt; не должны объявляться при использовании &lt;a href=&quot;function_definition&quot;&gt;определений функций&lt;/a&gt; старого стиля .</target>
        </trans-unit>
        <trans-unit id="3b74e96e489cf616e54374e5e92ff3290101f441" translate="yes" xml:space="preserve">
          <source>Alternative</source>
          <target state="translated">Alternative</target>
        </trans-unit>
        <trans-unit id="3c2e302cecd8e724ebefc4430def999e1f422931" translate="yes" xml:space="preserve">
          <source>Alternative operator spellings</source>
          <target state="translated">Альтернативные орфографии оператора</target>
        </trans-unit>
        <trans-unit id="29b586a7316da5dd137563369a7689b456379b04" translate="yes" xml:space="preserve">
          <source>Alternative operators and tokens</source>
          <target state="translated">Альтернативные операторы и жетоны</target>
        </trans-unit>
        <trans-unit id="4169be2060a4f8c4d585658039b95f12303e8c2e" translate="yes" xml:space="preserve">
          <source>Alternative tokens(C95)</source>
          <target state="translated">Альтернативные жетоны(C95)</target>
        </trans-unit>
        <trans-unit id="a40e532bb9001ffd6cd51359a18af099b40b59fc" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;pow&lt;/code&gt; cannot be used to obtain a root of a negative number, &lt;code&gt;&lt;a href=&quot;cbrt&quot;&gt;cbrt&lt;/a&gt;&lt;/code&gt; is provided for the common case where &lt;code&gt;exponent&lt;/code&gt; is 1/3.</source>
          <target state="translated">Хотя &lt;code&gt;pow&lt;/code&gt; не может быть использован для получения корня отрицательного числа, &lt;code&gt;&lt;a href=&quot;cbrt&quot;&gt;cbrt&lt;/a&gt;&lt;/code&gt; предоставляется для общего случая, когда &lt;code&gt;exponent&lt;/code&gt; равен 1/3.</target>
        </trans-unit>
        <trans-unit id="2d8e94ab087764ac5aa30f64f41b3a370e564193" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;scalbn&lt;/code&gt; and &lt;code&gt;scalbln&lt;/code&gt; are specified to perform the operation efficiently, on many implementations they are less efficient than multiplication or division by a power of two using arithmetic operators.</source>
          <target state="translated">Хотя &lt;code&gt;scalbn&lt;/code&gt; и &lt;code&gt;scalbln&lt;/code&gt; определены для эффективного выполнения операции, во многих реализациях они менее эффективны, чем умножение или деление на степень два с использованием арифметических операторов.</target>
        </trans-unit>
        <trans-unit id="0137da8668a196cbd69268350977f203b3e7ba1a" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;strcat_s&lt;/code&gt; prohibits truncation due to potential security risks, it's possible to truncate a string using bounds-checked &lt;code&gt;&lt;a href=&quot;strncat&quot;&gt;strncat_s&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Хотя &lt;code&gt;strcat_s&lt;/code&gt; запрещает усечение из-за потенциальных угроз безопасности, вместо этого можно &lt;code&gt;&lt;a href=&quot;strncat&quot;&gt;strncat_s&lt;/a&gt;&lt;/code&gt; строку, используя вместо этого проверенный границами strncat_s .</target>
        </trans-unit>
        <trans-unit id="01379ffb327aca2e2965c17285601b164531b9d3" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;strcpy_s&lt;/code&gt; prohibits truncation due to potential security risks, it's possible to truncate a string using bounds-checked &lt;code&gt;&lt;a href=&quot;strncpy&quot;&gt;strncpy_s&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Хотя &lt;code&gt;strcpy_s&lt;/code&gt; запрещает усечение из-за потенциальных угроз безопасности, вместо этого можно &lt;code&gt;&lt;a href=&quot;strncpy&quot;&gt;strncpy_s&lt;/a&gt;&lt;/code&gt; строку, используя вместо этого проверенный границами strncpy_s .</target>
        </trans-unit>
        <trans-unit id="c5b70b90ff2e7a517d78bb25ef1bb2546d9ba464" translate="yes" xml:space="preserve">
          <source>Although a zero-initialized &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; always represents the initial conversion state, there may be other values of &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; that also represent the initial conversion state.</source>
          <target state="translated">Хотя инициализированный &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; всегда представляет начальное состояние преобразования, могут быть и другие значения &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; , которые также представляют начальное состояние преобразования.</target>
        </trans-unit>
        <trans-unit id="521f97be29caaa78fcaf410bee9ae92c160ecbf8" translate="yes" xml:space="preserve">
          <source>Although any non-initialized subobjects are initialized implicitly, implicit initialization of a subobject never overrides explicit initialization of the same subobject if it appeared earlier in the initializer list:</source>
          <target state="translated">Хотя любые неинициализированные подобъекты инициализируются неявно,неявная инициализация подобъекта никогда не отменяет явной инициализации того же подобъекта,если он появился ранее в списке инициализаторов:</target>
        </trans-unit>
        <trans-unit id="9f867aad644439954e9498b489992312dc0bfdc5" translate="yes" xml:space="preserve">
          <source>Although any pointer to object &lt;a href=&quot;cast&quot;&gt;can be cast&lt;/a&gt; to pointer to object of a different type, dereferencing a pointer to the type different from the declared type of the object is almost always undefined behavior. See &lt;a href=&quot;object#Strict_aliasing&quot;&gt;strict aliasing&lt;/a&gt; for details.</source>
          <target state="translated">Хотя любой указатель на объект &lt;a href=&quot;cast&quot;&gt;может быть приведен&lt;/a&gt; к указателю на объект другого типа, разыменование указателя на тип, отличный от объявленного типа объекта, почти всегда является неопределенным поведением. Смотрите &lt;a href=&quot;object#Strict_aliasing&quot;&gt;строгий псевдоним&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="782db2506e8b16f17d55cc92953bb6895f994beb" translate="yes" xml:space="preserve">
          <source>Although arrays are not assignable, an array wrapped in a struct is assignable to another object of the same (or compatible) struct type.</source>
          <target state="translated">Хотя массивы не присваиваются,массив,обернутый в структуру,присваивается другому объекту того же (или совместимого)типа структуры.</target>
        </trans-unit>
        <trans-unit id="430fe03afb1283d4323b38c44acf81ba027f8497" translate="yes" xml:space="preserve">
          <source>Although function call is only defined for pointers to functions, it works with function designators due to the &lt;a href=&quot;conversion#Function_to_pointer_conversion&quot;&gt;function-to-pointer implicit conversion&lt;/a&gt;.</source>
          <target state="translated">Хотя вызов функции определен только для указателей на функции, он работает с указателями функций из &lt;a href=&quot;conversion#Function_to_pointer_conversion&quot;&gt;-за неявного преобразования функции в указатель&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f95c1167e4e765bd871f83860e20dc43744490fd" translate="yes" xml:space="preserve">
          <source>Although most implementations do not allow trap representations, padding bits, or multiple representations for integer types, there are exceptions; for example a value of an integer type on Itanium &lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20040119-00/?p=41003&quot;&gt;may be a trap representation&lt;/a&gt;.</source>
          <target state="translated">Хотя в большинстве реализаций не допускаются представления ловушек, биты заполнения или множественные представления для целочисленных типов, существуют исключения; например, значение целочисленного типа на Itanium &lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20040119-00/?p=41003&quot;&gt;может быть представлением ловушки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee0f85d5b5f4455a1b40b55fabe7b08d4d7be13b" translate="yes" xml:space="preserve">
          <source>Although not defined by the C standard, this is almost always an integral value holding the number of seconds (not counting leap seconds) since 00:00, Jan 1 1970 UTC, corresponding to &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt; POSIX time&lt;/a&gt;.</source>
          <target state="translated">Хотя это и не определено стандартом C, это почти всегда интегральное значение, содержащее количество секунд (не считая високосных секунд) с 00:00 1 января 1970 года по UTC, соответствующее &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt;времени POSIX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a46ea2cf03738e87c00f27d14c8aeeab6336c94e" translate="yes" xml:space="preserve">
          <source>Although old-style (prototype-less) &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt; allow the subsequent function calls to use any number of arguments, they are not allowed to be variadic (as of C89). The definition of such function must specify a fixed number of parameters and cannot use the &lt;code&gt;stdarg.h&lt;/code&gt; macros.</source>
          <target state="translated">Хотя &lt;a href=&quot;function_declaration&quot;&gt;объявления функций&lt;/a&gt; старого стиля (без прототипов) позволяют последующим вызовам функций использовать любое количество аргументов, они не могут быть переменными (начиная с C89). Определение такой функции должно указывать фиксированное количество параметров и не может использовать макросы &lt;code&gt;stdarg.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="183d193e98a51645be957397dbe1157096e4898e" translate="yes" xml:space="preserve">
          <source>Although signed integer overflow in any arithmetic operator is undefined behavior, overflowing a signed integer type in an integer conversion is merely unspecified behavior.</source>
          <target state="translated">Хотя переполнение знакового целого в любом арифметическом операторе является неопределенным поведением,переполнение знакового целого типа в целочисленном приведении является просто неуточненным поведением.</target>
        </trans-unit>
        <trans-unit id="c610559acf57d5e13360168218d35087e3133418" translate="yes" xml:space="preserve">
          <source>Although the C standard names the inverse hyperbolics with &quot;complex arc hyperbolic sine&quot; etc., the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct names are &quot;complex inverse hyperbolic sine&quot; etc. Some authors use &quot;complex area hyperbolic sine&quot; etc.</source>
          <target state="translated">Хотя стандарт С называет обратные гиперболики с &quot;сложным дуговым гиперболическим синусом&quot; и т.д.,обратные функции гиперболических функций являются областными функциями.Их аргументом является область гиперболического сектора,а не дуга.Правильные названия-&quot;сложный обратный гиперболический синус&quot; и т.д.Некоторые авторы используют &quot;сложный обратный гиперболический синус&quot; и т.д.</target>
        </trans-unit>
        <trans-unit id="53eb2f193d1ece133e78496ed9e6ccf150600d5c" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;arc hyperbolic cosine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic cosine&quot; (used by POSIX) or &quot;area hyperbolic cosine&quot;.</source>
          <target state="translated">Хотя в стандарте С эта функция называется &quot;дуговой гиперболический косинус&quot;,обратные функции гиперболических функций являются функциями области.Их аргументом является область гиперболического сектора,а не дуга.Правильное название-&quot;обратный гиперболический косинус&quot; (используется POSIX)или &quot;пространственный гиперболический косинус&quot;.</target>
        </trans-unit>
        <trans-unit id="9cc69d890735ff86a139ac61024682374f6710b3" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;arc hyperbolic sine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic sine&quot; (used by POSIX) or &quot;area hyperbolic sine&quot;.</source>
          <target state="translated">Хотя в стандарте С эта функция называется &quot;дуговой гиперболический синус&quot;,обратные функции гиперболических функций являются функциями области.Их аргументом является область гиперболического сектора,а не дуга.Правильное название-&quot;обратный гиперболический синус&quot; (используется POSIX)или &quot;пространственный гиперболический синус&quot;.</target>
        </trans-unit>
        <trans-unit id="1c9639606a887095dbb5eeca1ccea8904ebf0979" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;arc hyperbolic tangent&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic tangent&quot; (used by POSIX) or &quot;area hyperbolic tangent&quot;.</source>
          <target state="translated">Хотя в стандарте C эта функция называется &quot;дуговой гиперболический тангенс&quot;,обратные функции гиперболических функций являются областными функциями.Их аргументом является область гиперболического сектора,а не дуга.Правильное название-&quot;обратный гиперболический тангенс&quot; (используется POSIX)или &quot;областной гиперболический тангенс&quot;.</target>
        </trans-unit>
        <trans-unit id="a42f4b1a642341cb7f5490a130fadc09495ae219" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;complex arc hyperbolic cosine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic cosine&quot;, and, less common, &quot;complex area hyperbolic cosine&quot;.</source>
          <target state="translated">Хотя в стандарте С эта функция называется &quot;сложным дуговым гиперболическим косинусом&quot;,обратные функции гиперболических функций являются функциями области.Их аргументом является область гиперболического сектора,а не дуга.Правильное название-&quot;сложный обратный гиперболический косинус&quot; и,реже,&quot;сложный пространственный гиперболический косинус&quot;.</target>
        </trans-unit>
        <trans-unit id="627b752f245ff7b1c7740db9d2b8d3d303af20f5" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;complex arc hyperbolic sine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic sine&quot;, and, less common, &quot;complex area hyperbolic sine&quot;.</source>
          <target state="translated">Хотя в стандарте С эта функция называется &quot;сложным дуговым гиперболическим синусом&quot;,обратные функции гиперболических функций являются функциями области.Их аргументом является область гиперболического сектора,а не дуга.Правильное название-&quot;сложный обратный гиперболический синус&quot;,и,реже,&quot;сложный областной гиперболический синус&quot;.</target>
        </trans-unit>
        <trans-unit id="36d2388b219b1a45a5fcef0d0ad2e1d71bd9c5f1" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;complex arc hyperbolic tangent&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic tangent&quot;, and, less common, &quot;complex area hyperbolic tangent&quot;.</source>
          <target state="translated">Хотя в стандарте C эта функция называется &quot;сложный дуговой гиперболический тангенс&quot;,обратные функции гиперболических функций являются областными функциями.Их аргументом является область гиперболического сектора,а не дуга.Правильное название-&quot;сложный обратный гиперболический тангенс&quot;,и,реже,&quot;сложный областной гиперболический тангенс&quot;.</target>
        </trans-unit>
        <trans-unit id="e55c4c08037504cff68121796bbc9e46b8ee6db3" translate="yes" xml:space="preserve">
          <source>Although the names generated by &lt;code&gt;tmpnam&lt;/code&gt; are difficult to guess, it is possible that a file with that name is created by another process between the moment &lt;code&gt;tmpnam&lt;/code&gt; returns and the moment this program attempts to use the returned name to create a file. The standard function &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;tmpfile&lt;/a&gt;&lt;/code&gt; and the POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; do not have this problem (creating a unique directory using only the standard C library still requires the use of &lt;code&gt;tmpnam&lt;/code&gt;).</source>
          <target state="translated">Хотя имена, сгенерированные &lt;code&gt;tmpnam&lt;/code&gt; , трудно угадать, возможно, что файл с таким именем будет создан другим процессом между моментом, когда &lt;code&gt;tmpnam&lt;/code&gt; вернется, и моментом, когда эта программа пытается использовать возвращенное имя для создания файла. Стандартная функция &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;tmpfile&lt;/a&gt;&lt;/code&gt; и функция POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; не имеют этой проблемы (создание уникального каталога с использованием только стандартной библиотеки C по-прежнему требует использования &lt;code&gt;tmpnam&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a8a747e33a10c6fa21c941b73f1438fc704b6283" translate="yes" xml:space="preserve">
          <source>Although the return type is &lt;code&gt;char*&lt;/code&gt;, modifying the pointed-to characters is undefined behavior.</source>
          <target state="translated">Хотя тип возвращаемого значения - &lt;code&gt;char*&lt;/code&gt; , изменение указанных символов является неопределенным поведением.</target>
        </trans-unit>
        <trans-unit id="5d77d3b4837e50c32db090517b15b7c3f0e6e611" translate="yes" xml:space="preserve">
          <source>Although the standard specification is ambiguous in the case where &lt;code&gt;count==1&lt;/code&gt;, common implementations read no characters, store zero in &lt;code&gt;str[0]&lt;/code&gt;, and report success (return &lt;code&gt;str&lt;/code&gt;).</source>
          <target state="translated">Хотя стандартная спецификация неоднозначна в случае, когда &lt;code&gt;count==1&lt;/code&gt; , обычные реализации не читают символов, сохраняют ноль в &lt;code&gt;str[0]&lt;/code&gt; и сообщают об успешном выполнении (return &lt;code&gt;str&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="643daeb4adeff0fcce44a0450dc2ccf13dec660b" translate="yes" xml:space="preserve">
          <source>Although the syntax of a compound literal is similar to a &lt;a href=&quot;cast&quot;&gt;cast&lt;/a&gt;, the important distinction is that a cast is a non-lvalue expression while a compound literal is an lvalue.</source>
          <target state="translated">Хотя синтаксис составного литерала похож на &lt;a href=&quot;cast&quot;&gt;приведение&lt;/a&gt; , важное различие заключается в том, что приведение является выражением, не имеющим значения, в то время как составной литерал является значением l.</target>
        </trans-unit>
        <trans-unit id="524b5a64840b79d1a2de79e908e1ff895523c4a5" translate="yes" xml:space="preserve">
          <source>Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for &lt;code&gt;strncat_s&lt;/code&gt;, it is possible to get the truncating behavior by specifying &lt;code&gt;count&lt;/code&gt; equal to the size of the destination array minus one: it will copy the first &lt;code&gt;count&lt;/code&gt; bytes and append the null terminator as always: &lt;code&gt;strncat_s(dst, sizeof dst, src, (sizeof dst)-strnlen_s(dst, sizeof dst)-1);&lt;/code&gt;</source>
          <target state="translated">Хотя усечение для соответствия целевому буферу представляет собой угрозу безопасности и, следовательно, нарушение ограничений времени выполнения для &lt;code&gt;strncat_s&lt;/code&gt; , можно получить усечающее поведение, указав &lt;code&gt;count&lt;/code&gt; равное размеру целевого массива минус один: он скопирует первые байты &lt;code&gt;count&lt;/code&gt; и добавьте нулевой терминатор как всегда: &lt;code&gt;strncat_s(dst, sizeof dst, src, (sizeof dst)-strnlen_s(dst, sizeof dst)-1);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="31058475f488e9122376b4823fdbfa19cec13f95" translate="yes" xml:space="preserve">
          <source>Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for &lt;code&gt;strncpy_s&lt;/code&gt;, it is possible to get the truncating behavior by specifying &lt;code&gt;count&lt;/code&gt; equal to the size of the destination array minus one: it will copy the first &lt;code&gt;count&lt;/code&gt; bytes and append the null terminator as always: &lt;code&gt;strncpy_s(dst, sizeof dst, src, (sizeof dst)-1);&lt;/code&gt;</source>
          <target state="translated">Хотя усечение для соответствия целевому буферу представляет собой угрозу безопасности и, следовательно, нарушение ограничений времени выполнения для &lt;code&gt;strncpy_s&lt;/code&gt; , можно получить усечающее поведение, указав &lt;code&gt;count&lt;/code&gt; равное размеру целевого массива минус один: он скопирует первые байты &lt;code&gt;count&lt;/code&gt; и добавьте нулевой терминатор как всегда: &lt;code&gt;strncpy_s(dst, sizeof dst, src, (sizeof dst)-1);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed3455470f39d87a62eebd7b7029aa61541270b7" translate="yes" xml:space="preserve">
          <source>Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for &lt;code&gt;wcsncat_s&lt;/code&gt;, it is possible to get the truncating behavior by specifying &lt;code&gt;count&lt;/code&gt; equal to the size of the destination array minus one: it will copy the first &lt;code&gt;count&lt;/code&gt; wide characters and append the null terminator as always: &lt;code&gt;wcsncat_s(dst, sizeof dst/sizeof *dst, src, (sizeof dst/sizeof *dst)-wcsnlen_s(dst, sizeof dst/sizeof *dst)-1);&lt;/code&gt;</source>
          <target state="translated">Хотя усечение до размера целевого буфера представляет собой угрозу безопасности и, следовательно, нарушение ограничений времени выполнения для &lt;code&gt;wcsncat_s&lt;/code&gt; , можно получить усечающее поведение, указав &lt;code&gt;count&lt;/code&gt; равное размеру целевого массива минус один: он скопирует первое &lt;code&gt;count&lt;/code&gt; широких символов и добавьте нулевой терминатор как всегда: &lt;code&gt;wcsncat_s(dst, sizeof dst/sizeof *dst, src, (sizeof dst/sizeof *dst)-wcsnlen_s(dst, sizeof dst/sizeof *dst)-1);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="91cbd8326b7ebc58c195548dc89d276533889261" translate="yes" xml:space="preserve">
          <source>Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for &lt;code&gt;wcsncpy_s&lt;/code&gt;, it is possible to get the truncating behavior by specifying &lt;code&gt;count&lt;/code&gt; equal to the size of the destination array minus one: it will copy the first &lt;code&gt;count&lt;/code&gt; wide characters and append the null wide terminator as always: &lt;code&gt;wcsncpy_s(dst, sizeof dst / sizeof *dst, src, (sizeof dst / sizeof *dst)-1);&lt;/code&gt;</source>
          <target state="translated">Хотя усечение до размера целевого буфера представляет собой угрозу безопасности и, следовательно, нарушение ограничений времени выполнения для &lt;code&gt;wcsncpy_s&lt;/code&gt; , можно получить усечающее поведение, указав &lt;code&gt;count&lt;/code&gt; равное размеру целевого массива минус один: оно скопирует первое &lt;code&gt;count&lt;/code&gt; широких символов и добавьте терминатор нулевой ширины как всегда: &lt;code&gt;wcsncpy_s(dst, sizeof dst / sizeof *dst, src, (sizeof dst / sizeof *dst)-1);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="e95121f45a467fe30f9e9b9421b8414b5dc9b5a8" translate="yes" xml:space="preserve">
          <source>An exception to the above rule is the &lt;code&gt;fabs&lt;/code&gt; macro (see the table below).</source>
          <target state="translated">Исключением из вышеприведенного правила является макрос &lt;code&gt;fabs&lt;/code&gt; (см. Таблицу ниже).</target>
        </trans-unit>
        <trans-unit id="34f74cee143d788f51fcc25acc797aea92c197b8" translate="yes" xml:space="preserve">
          <source>An expression followed by a semicolon is a statement.</source>
          <target state="translated">Выражение,за которым следует точка с запятой,является заявлением.</target>
        </trans-unit>
        <trans-unit id="c5756e59953f27f7802c2879dfb5bf8b2ef537aa" translate="yes" xml:space="preserve">
          <source>An expression is a sequence of</source>
          <target state="translated">Выражение представляет собой последовательность</target>
        </trans-unit>
        <trans-unit id="8582e3c88de4617441467faab5ff600afdf1bfb6" translate="yes" xml:space="preserve">
          <source>An expression statement without an expression is called a</source>
          <target state="translated">Выражение без выражения называется</target>
        </trans-unit>
        <trans-unit id="e88ff614d33ada21febd8f65027f3a4ddd6534c8" translate="yes" xml:space="preserve">
          <source>An incomplete type is an object type that lacks sufficient information to determine the size of the objects of that type. An incomplete type may be completed at some point in the translation unit.</source>
          <target state="translated">Незавершенный тип-это тип объекта,который не имеет достаточной информации для определения размера объектов этого типа.Незавершенный тип может быть завершен в какой-то момент в переводческом отделе.</target>
        </trans-unit>
        <trans-unit id="922cdb3f2c9cb3526b3e2d10c81d2dfe51f98e18" translate="yes" xml:space="preserve">
          <source>An integer constant expression is an expression that consists only of.</source>
          <target state="translated">Целочисленная константа-это выражение,состоящее только из.</target>
        </trans-unit>
        <trans-unit id="f10b2455ca40601e84b6c671226ded817e8d0567" translate="yes" xml:space="preserve">
          <source>An integer constant is a &lt;a href=&quot;value_category&quot;&gt;non-lvalue&lt;/a&gt; expression of the form.</source>
          <target state="translated">Целочисленная константа является &lt;a href=&quot;value_category&quot;&gt;ненулевым&lt;/a&gt; выражением формы.</target>
        </trans-unit>
        <trans-unit id="4fbb0b241c865dd210a0103cf5d2af8c3a3e8a71" translate="yes" xml:space="preserve">
          <source>An integer greater than zero if the stream is wide-oriented after this call, less than zero if the stream is byte-oriented after this call, and zero if the stream has no orientation.</source>
          <target state="translated">Целое число больше нуля,если поток после этого вызова широко ориентирован,меньше нуля,если поток после этого вызова ориентирован на байты,и ноль,если поток не имеет ориентации.</target>
        </trans-unit>
        <trans-unit id="22296b3029f90df1ec990b3a781242c55d5beaa6" translate="yes" xml:space="preserve">
          <source>An integer type which can be accessed as an atomic entity even in the presence of asynchronous interrupts made by signals.</source>
          <target state="translated">Целый тип,к которому можно получить доступ как к атомарной сущности даже при наличии асинхронных прерываний по сигналам.</target>
        </trans-unit>
        <trans-unit id="509428cacc9180cadada492e5a97d331536c77bb" translate="yes" xml:space="preserve">
          <source>An object whose identifier is declared with the storage-class specifier &lt;code&gt;_Thread_local&lt;/code&gt;(since C11) has thread storage duration. Its lifetime is the entire execution of the thread for which it is created, and its stored value is initialized when the thread is started. There is a distinct object per thread, and use of the declared name in an expression refers to the object associated with the thread evaluating the expression. The result of attempting to indirectly access an object with thread storage duration from a thread other than the one with which the object is associated is implementation-defined.</source>
          <target state="translated">Объект, идентификатор которого объявлен со спецификатором класса хранения &lt;code&gt;_Thread_local&lt;/code&gt; (начиная с C11), имеет длительность хранения потока. Его время жизни - это полное выполнение потока, для которого он создан, и его сохраненное значение инициализируется при запуске потока. В каждом потоке имеется отдельный объект, и использование объявленного имени в выражении относится к объекту, связанному с потоком, оценивающим выражение. Результат попытки косвенного доступа к объекту с продолжительностью хранения потока из потока, отличного от того, с которым связан объект, определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="ca6829296f71df282c1b4376c48afbb797f79121" translate="yes" xml:space="preserve">
          <source>An object whose identifier is declared without the storage-class specifier &lt;code&gt;_Thread_local&lt;/code&gt;, and either with external or internal &lt;a href=&quot;storage_duration#Linkage&quot;&gt;linkage&lt;/a&gt; or with the storage-class specifier &lt;code&gt;static&lt;/code&gt;, has static storage duration. Its lifetime is the entire execution of the program and its stored value is initialized only once, prior to program startup.</source>
          <target state="translated">Объект, идентификатор которого объявлен без спецификатора класса хранения &lt;code&gt;_Thread_local&lt;/code&gt; , а также с внешней или внутренней &lt;a href=&quot;storage_duration#Linkage&quot;&gt;связью&lt;/a&gt; или со &lt;code&gt;static&lt;/code&gt; спецификатором класса хранения , имеет статическую продолжительность хранения. Его время жизни - это полное выполнение программы, а его сохраненное значение инициализируется только один раз, до запуска программы.</target>
        </trans-unit>
        <trans-unit id="ac3869f4a5a82462e5b3c6903ccb04495bd9eeec" translate="yes" xml:space="preserve">
          <source>An object, in C, is region of &lt;a href=&quot;memory_model&quot;&gt;data storage&lt;/a&gt; in the execution environment, the contents of which can represent</source>
          <target state="translated">Объект в С - это область &lt;a href=&quot;memory_model&quot;&gt;хранения данных&lt;/a&gt; в среде исполнения, содержимое которой может представлять</target>
        </trans-unit>
        <trans-unit id="78ade4e82af0b35312ea1cf340af57aa22d18fa0" translate="yes" xml:space="preserve">
          <source>An unsuffixed floating constant has type &lt;code&gt;double&lt;/code&gt;. If suffix is the letter &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;F&lt;/code&gt;, the floating constant has type &lt;code&gt;float&lt;/code&gt;. If suffix is the letter &lt;code&gt;l&lt;/code&gt; or &lt;code&gt;L&lt;/code&gt;, the floating constant has type &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="translated">Нефиксированная плавающая константа имеет тип &lt;code&gt;double&lt;/code&gt; . Если суффиксом является буква &lt;code&gt;f&lt;/code&gt; или &lt;code&gt;F&lt;/code&gt; , плавающая константа имеет тип &lt;code&gt;float&lt;/code&gt; . Если суффиксом является буква &lt;code&gt;l&lt;/code&gt; или &lt;code&gt;L&lt;/code&gt; , плавающая константа имеет тип &lt;code&gt;long double&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6af0fd01a43835edcca93cfea6189ce121e3b7bc" translate="yes" xml:space="preserve">
          <source>Analyzability</source>
          <target state="translated">Analyzability</target>
        </trans-unit>
        <trans-unit id="1224aba20bea722a32d03ea6e039ef1fe32002ee" translate="yes" xml:space="preserve">
          <source>Analyzability extension permits, as a form of implementation-defined behavior, for the &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;runtime constraint handler&lt;/a&gt; to be invoked when a trap occurs.</source>
          <target state="translated">Расширение анализируемости позволяет в качестве формы поведения, определяемого реализацией, вызывать &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;обработчик ограничений времени выполнения&lt;/a&gt; при возникновении прерывания.</target>
        </trans-unit>
        <trans-unit id="88fad02460e9c399ee6de569a0dbe485d36f0c20" translate="yes" xml:space="preserve">
          <source>Annex G (informative) IEC 60559-compatible complex arithmetic (p: 467-480)</source>
          <target state="translated">Приложение G (информативное)МЭК 60559-совместимая комплексная арифметика (стр.467-480)</target>
        </trans-unit>
        <trans-unit id="363c4a1ac12e80d5822b10c88a28ccf2c8e5db57" translate="yes" xml:space="preserve">
          <source>Annex G (normative) IEC 60559-compatible complex arithmetic (p: 532-545)</source>
          <target state="translated">Приложение G (нормативное)МЭК 60559-совместимая комплексная арифметика (стр.532-545)</target>
        </trans-unit>
        <trans-unit id="b05eeba32030c7db8c4ce96b39a5db85c6475ff5" translate="yes" xml:space="preserve">
          <source>Annex L Analyzability (p: 652-653)</source>
          <target state="translated">Анализируемость приложения L (стр.652-653)</target>
        </trans-unit>
        <trans-unit id="899d67ebfae429b08b8eebcf8e8c9e086747304a" translate="yes" xml:space="preserve">
          <source>Another way to test if a floating-point value is NaN is to compare it with itself: &lt;code&gt;bool is_nan(double x) { return x != x; }&lt;/code&gt;</source>
          <target state="translated">Другой способ проверить, является ли значение с плавающей точкой NaN, состоит в сравнении его с самим собой: &lt;code&gt;bool is_nan(double x) { return x != x; }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ce38c932d44d15a1b772dcde23f9e877b670097" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; of &lt;a href=&quot;array&quot;&gt;array type&lt;/a&gt;, when used in any context other than.</source>
          <target state="translated">Любое &lt;a href=&quot;value_category&quot;&gt;выражение lvalue&lt;/a&gt; типа &lt;a href=&quot;array&quot;&gt;массива&lt;/a&gt; , когда используется в любом контексте, кроме.</target>
        </trans-unit>
        <trans-unit id="3ada2b7aff782859a1770ce5c125b8fc47b51105" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; of any non-array type, when used in any context other than.</source>
          <target state="translated">Любое &lt;a href=&quot;value_category&quot;&gt;выражение lvalue&lt;/a&gt; любого типа, не являющегося массивом, при использовании в любом контексте, кроме.</target>
        </trans-unit>
        <trans-unit id="b32b22200862e7a1d98c59831163dac931baf00f" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; of array type, when used in any context other than.</source>
          <target state="translated">Любое &lt;a href=&quot;value_category&quot;&gt;выражение lvalue&lt;/a&gt; типа массива, когда используется в любом контексте, кроме.</target>
        </trans-unit>
        <trans-unit id="f119a4c0c577a8422656ad60e3f009df6812696f" translate="yes" xml:space="preserve">
          <source>Any attempt to modify an object whose type is const-qualified results in undefined behavior.</source>
          <target state="translated">Любая попытка модифицировать объект,тип которого является конст-квалифицированным,приводит к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="866f91766b87953ad8edd681c9682a8e938a7503" translate="yes" xml:space="preserve">
          <source>Any attempt to modify an object with temporary lifetime results in undefined behavior.</source>
          <target state="translated">Любая попытка изменить объект с временным временем жизни приводит к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="8749d31d9b04cec89cefa681f64da614302dca60" translate="yes" xml:space="preserve">
          <source>Any attempt to read or write to an object whose type is volatile-qualified through a non-volatile lvalue results in undefined behavior:</source>
          <target state="translated">Любая попытка прочитать или записать на объект,тип которого является волатильным,через энергонезависимое значение l приводит к неопределенному поведению:</target>
        </trans-unit>
        <trans-unit id="6de4873dedcbff8007c22dcc38d613721f09e7f5" translate="yes" xml:space="preserve">
          <source>Any declaration with internal linkage that appears in a header file results in a separate and distinct object in each translation unit that includes that file.</source>
          <target state="translated">Любое объявление с внутренней связью,которое появляется в заголовочном файле,приводит к появлению отдельного и отличного объекта в каждой единице перевода,которая включает этот файл.</target>
        </trans-unit>
        <trans-unit id="bd4ac1ef0bc8d5c87b738bd4653ebf9c1c653d80" translate="yes" xml:space="preserve">
          <source>Any expression in parentheses is also classified as a primary expression: this guarantees that the parentheses have higher precedence than any operator.</source>
          <target state="translated">Любое выражение в круглых скобках также классифицируется как первичное:это гарантирует,что круглые скобки имеют больший приоритет,чем любой оператор.</target>
        </trans-unit>
        <trans-unit id="dfcadc42c0ec036402e088068ff0c3bc13ca677e" translate="yes" xml:space="preserve">
          <source>Any function designator expression, when used in any context other than.</source>
          <target state="translated">Любое выражение обозначения функции,когда оно используется в любом контексте,кроме...</target>
        </trans-unit>
        <trans-unit id="4a02555a36d9834685af7a35630f001d24e0aeb2" translate="yes" xml:space="preserve">
          <source>Any function with internal linkage may be declared &lt;code&gt;static inline&lt;/code&gt; with no other restrictions.</source>
          <target state="translated">Любая функция с внутренней связью может быть объявлена &lt;code&gt;static inline&lt;/code&gt; без каких-либо других ограничений.</target>
        </trans-unit>
        <trans-unit id="f085377b18d48b26df1584fd15c220308ad01b5c" translate="yes" xml:space="preserve">
          <source>Any integer &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; with value &lt;code&gt;​0​&lt;/code&gt; as well as integer pointer expression with value zero cast to the type &lt;code&gt;void*&lt;/code&gt; can be implicitly converted to any pointer type (both pointer to object and pointer to function). The result is the null pointer value of its type, guaranteed to compare unequal to any non-null pointer value of that type. This integer or void* expression is known as</source>
          <target state="translated">Любое целое &lt;a href=&quot;constant_expression&quot;&gt;выражение постоянная&lt;/a&gt; со значением &lt;code&gt;​0​&lt;/code&gt; , а также выражение целочисленного указателя с нулевым значением приведения к типу &lt;code&gt;void*&lt;/code&gt; может быть неявно преобразуются в любой тип указателя (как указатель на объект и указатель на функцию). Результатом является значение нулевого указателя его типа, гарантированно сопоставляемое с любым ненулевым значением указателя этого типа. Это целочисленное или пустое * выражение известно как</target>
        </trans-unit>
        <trans-unit id="f6aa9cfe41886fda825befd70140c82f188e05c0" translate="yes" xml:space="preserve">
          <source>Any integer can be cast to any pointer type. Except for the null pointer constants such as &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; (which &lt;a href=&quot;conversion&quot;&gt;doesn't need a cast&lt;/a&gt;), the result is implementation-defined, may not be correctly aligned, may not point to an object of the referenced type, and may be a &lt;a href=&quot;object&quot;&gt;trap representation&lt;/a&gt;.</source>
          <target state="translated">Любое целое число может быть приведено к любому типу указателя. За исключением констант нулевого указателя, таких как &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; (которые &lt;a href=&quot;conversion&quot;&gt;не нуждаются в приведении&lt;/a&gt; ), результат определяется реализацией, может не корректно выравниваться, может не указывать на объект ссылочного типа и может представлять представление &lt;a href=&quot;object&quot;&gt;ловушки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d27e4acb04a2d9fbbd446c13740539aaa280d88f" translate="yes" xml:space="preserve">
          <source>Any other access to the object with no declared type, the effective type is the type of the lvalue used for the access.</source>
          <target state="translated">Любой другой доступ к объекту без объявленного типа,действительный тип-это тип l-значения,используемого для доступа.</target>
        </trans-unit>
        <trans-unit id="1fce6ca708ece38a43d4cfdb4978f4ad32568af6" translate="yes" xml:space="preserve">
          <source>Any pointer to function can be cast to a pointer to any other function type. If the resulting pointer is converted back to the original type, it compares equal to the original value. If the converted pointer is used to make a function call, the behavior is undefined (unless the function types are &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt;)</source>
          <target state="translated">Любой указатель на функцию может быть приведен к указателю на любой другой тип функции. Если полученный указатель преобразуется обратно в исходный тип, он сравнивается равным исходному значению. Если преобразованный указатель используется для вызова функции, поведение не определено (если типы функций не &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;совместимы&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="b5144273b9cff24a19477ce9d36d363c89d3f02e" translate="yes" xml:space="preserve">
          <source>Any pointer to object can be cast to any other pointer to object. If the value is not correctly aligned for the target type, the behavior is undefined. Otherwise, if the value is converted back to the original type, it compares equal to the original value. If a pointer to object is cast to pointer to any character type, the result points at the lowest byte of the object and may be incremented up to sizeof the target type (in other words, can be used to examine &lt;a href=&quot;object&quot;&gt;object representation&lt;/a&gt; or to make a copy via &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;memmove&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Любой указатель на объект может быть приведен к любому другому указателю на объект. Если значение неправильно выровнено для целевого типа, поведение не определено. В противном случае, если значение преобразуется обратно в исходный тип, оно сравнивается равным исходному значению. Если указатель на объект приводится к указателю на любой тип символа, результат указывает на младший байт объекта и может увеличиваться до размера целевого типа (другими словами, может использоваться для проверки &lt;a href=&quot;object&quot;&gt;представления объекта&lt;/a&gt; или для создания скопировать через &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;memmove&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="53b27419880a23d059eebd1b3c848f2b6b494f5f" translate="yes" xml:space="preserve">
          <source>Any pointer type can be cast to any integer type. The result is implementation-defined, even for null pointer values (they do not necessarily result in the value zero). If the result cannot be represented in the target type, the behavior is undefined (unsigned integers do not implement modulo arithmetic on a cast from pointer)</source>
          <target state="translated">Любой тип указателя может быть приведен к любому целочисленному типу.Результат является реализационным,даже для нулевых значений указателей (они не обязательно приводят к нулевому значению).Если результат не может быть представлен в целевом типе,поведение является неопределенным (беззнаковые целые числа не реализуют модульную арифметику при приведении от указателя).</target>
        </trans-unit>
        <trans-unit id="52919eaf1eb62c0854fdd694ccfd8a6c2a0705b3" translate="yes" xml:space="preserve">
          <source>Any preprocessing tokens (macro constants or expressions) are permitted as arguments to &lt;code&gt;#line&lt;/code&gt; as long as they expand to a valid decimal integer optionally following a valid character string.</source>
          <target state="translated">Любые токены предварительной обработки (макро константы или выражения) допускаются в качестве аргументов &lt;code&gt;#line&lt;/code&gt; , если они расширяются до действительного десятичного целого числа, необязательно следующего за допустимой символьной строкой.</target>
        </trans-unit>
        <trans-unit id="9f4fa7ee728ee63a75e7d354408e9febd14b9e02" translate="yes" xml:space="preserve">
          <source>Any statement (but not a declaration) may be preceded by any number of</source>
          <target state="translated">Любому заявлению (но не заявлению)может предшествовать любое количество</target>
        </trans-unit>
        <trans-unit id="594a9e7004e035507b2faafb30d5238be37f382a" translate="yes" xml:space="preserve">
          <source>Any statement can be</source>
          <target state="translated">Любое заявление может быть</target>
        </trans-unit>
        <trans-unit id="9d8ddff307f484a3b8ee7169c75629627b1b6b4a" translate="yes" xml:space="preserve">
          <source>Any thread can potentially access any object in the program (objects with automatic and thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; may still be accessed by another thread through a pointer).</source>
          <target state="translated">Любой поток может потенциально получить доступ к любому объекту в программе (объекты с автоматическим и локальным &lt;a href=&quot;storage_duration&quot;&gt;хранением&lt;/a&gt; потока могут все еще быть доступны другому потоку через указатель).</target>
        </trans-unit>
        <trans-unit id="1ecdb25ac5e949980efec1665ec8ea0a080e3051" translate="yes" xml:space="preserve">
          <source>Appears in the &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; syntax as one of the type specifiers to modify the &lt;a href=&quot;object#Alignment&quot;&gt;alignment requirement&lt;/a&gt; of the object being declared.</source>
          <target state="translated">Появляется в синтаксисе &lt;a href=&quot;declarations&quot;&gt;объявления&lt;/a&gt; как один из спецификаторов типа для изменения &lt;a href=&quot;object#Alignment&quot;&gt;требования выравнивания&lt;/a&gt; объявляемого объекта.</target>
        </trans-unit>
        <trans-unit id="8469bf011f6ccd77c6945c6cf345649aa9cff6e9" translate="yes" xml:space="preserve">
          <source>Appears only within the statement of a loop body (&lt;a href=&quot;while&quot;&gt;while&lt;/a&gt;, &lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;, &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;) or within the statement of a &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt;.</source>
          <target state="translated">Появляется только внутри оператора тела цикла ( &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; , &lt;a href=&quot;do&quot;&gt;do&lt;/a&gt; , &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; ) или внутри оператора &lt;a href=&quot;switch&quot;&gt;переключателя&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f41b36bd2867522723d540cbaf10ea09210fdf2" translate="yes" xml:space="preserve">
          <source>Append to a file</source>
          <target state="translated">Добавить в файл</target>
        </trans-unit>
        <trans-unit id="10adbbd3a7c36a43cb9fa85a79d28613edb0183c" translate="yes" xml:space="preserve">
          <source>Application code:</source>
          <target state="translated">Код приложения:</target>
        </trans-unit>
        <trans-unit id="4da3e84107ea6402ad05595526acce55c364845f" translate="yes" xml:space="preserve">
          <source>Approximate</source>
          <target state="translated">Approximate</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="def2bf62b424e602e225d5df7086bbc94649ceb1" translate="yes" xml:space="preserve">
          <source>Argument type</source>
          <target state="translated">Тип аргумента</target>
        </trans-unit>
        <trans-unit id="7dfad58bef64485ffe28abdf14805afc5997a006" translate="yes" xml:space="preserve">
          <source>Arithmetic addition and subtraction</source>
          <target state="translated">арифметическое сложение и вычитание</target>
        </trans-unit>
        <trans-unit id="86e9c4d92306ef176b1e643c9083d4f239172d17" translate="yes" xml:space="preserve">
          <source>Arithmetic constant expressions of floating-point types that are not used in static initializers are always evaluated as-if during run-time and are affected by the &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;current rounding&lt;/a&gt; (if &lt;a href=&quot;../preprocessor/impl&quot;&gt;FENV_ACCESS&lt;/a&gt; is on) and report errors as specified in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">Выражения арифметических констант типов с плавающей точкой, которые не используются в статических инициализаторах, всегда оцениваются как-бы во время выполнения и зависят от &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;текущего округления&lt;/a&gt; (если &lt;a href=&quot;../preprocessor/impl&quot;&gt;включено FENV_ACCESS&lt;/a&gt; ) и сообщают об ошибках, как указано в &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d077356b7b5076ff62409f2fbd19527762e29c71" translate="yes" xml:space="preserve">
          <source>Arithmetic operators</source>
          <target state="translated">арифметические операторы</target>
        </trans-unit>
        <trans-unit id="fcb531b953dd45da5064b2d52a06c231157ccecd" translate="yes" xml:space="preserve">
          <source>Arithmetic operators apply standard mathematical operations to their operands.</source>
          <target state="translated">Арифметические операторы применяют стандартные математические операции к своим операндам.</target>
        </trans-unit>
        <trans-unit id="3a96c27ea8acc41f84ccf2e2e957611cc9d4cd07" translate="yes" xml:space="preserve">
          <source>Arithmetic types</source>
          <target state="translated">арифметические типы</target>
        </trans-unit>
        <trans-unit id="8de00b1bedff8647aff0425d6be471519b1d3a5a" translate="yes" xml:space="preserve">
          <source>Arithmetic(until C11)Real(since C11) type capable of representing the processor time used by a process. It has implementation-defined range and precision.</source>
          <target state="translated">Арифметика(до C11)Real(начиная с C11),способная представлять процессорное время,используемое процессом.Он имеет диапазон реализации и точность.</target>
        </trans-unit>
        <trans-unit id="ba5ba905dbea6b631aa488beea4ac4accbaf54e2" translate="yes" xml:space="preserve">
          <source>Arithmetic(until C11)Real(since C11) type capable of representing times.</source>
          <target state="translated">Арифметика(до C11)Real(начиная с C11)тип,способный отображать времена.</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="3fb125cc9e54d7ed417b90f1b586cad673b24cc3" translate="yes" xml:space="preserve">
          <source>Array declaration</source>
          <target state="translated">Массивная декларация</target>
        </trans-unit>
        <trans-unit id="9c4ba2b7b1b1387eaf59bf743fda8372525a2456" translate="yes" xml:space="preserve">
          <source>Array designators may be nested; the bracketed constant expression for nested arrays follows the bracketed constant expression for the outer array:</source>
          <target state="translated">Обозначения массивов могут быть вложенными;выражение константы в скобках для вложенных массивов следует за выражением константы в скобках для внешнего массива:</target>
        </trans-unit>
        <trans-unit id="26c32b01062e2317d553f15f1ba72bc158531ca8" translate="yes" xml:space="preserve">
          <source>Array initialization</source>
          <target state="translated">Инициализация массива</target>
        </trans-unit>
        <trans-unit id="bfd2acbfa3c1379c40dc654a37044a389ab75f2a" translate="yes" xml:space="preserve">
          <source>Array is a type consisting of a contiguously allocated nonempty sequence of objects with a particular</source>
          <target state="translated">Массив-это тип,состоящий из смежно выделенной непустой последовательности объектов с определенной</target>
        </trans-unit>
        <trans-unit id="d09c1ccc6ebe2f642530d449ea6ccaeedb110eac" translate="yes" xml:space="preserve">
          <source>Array subscripting</source>
          <target state="translated">Подписка на массив</target>
        </trans-unit>
        <trans-unit id="66b8cc3bf902fd9199bad14788d8e22184391a03" translate="yes" xml:space="preserve">
          <source>Array to pointer conversion</source>
          <target state="translated">Преобразование массива в указатель</target>
        </trans-unit>
        <trans-unit id="6a7e5d35200e14f310ad5bf8188982d14b575993" translate="yes" xml:space="preserve">
          <source>Arrays of constant known size</source>
          <target state="translated">Массивы постоянного известного размера</target>
        </trans-unit>
        <trans-unit id="8adb4effb7772ea8daa524a9b231c7b9d3f96d17" translate="yes" xml:space="preserve">
          <source>Arrays of constant known size can use &lt;a href=&quot;array_initialization&quot;&gt;array initializers&lt;/a&gt; to provide their initial values:</source>
          <target state="translated">Массивы с постоянным известным размером могут использовать &lt;a href=&quot;array_initialization&quot;&gt;инициализаторы массива&lt;/a&gt; для предоставления своих начальных значений:</target>
        </trans-unit>
        <trans-unit id="c16aa1d8479c8c45ec23435b290a59e102e675bf" translate="yes" xml:space="preserve">
          <source>Arrays of known size and arrays of unknown size may be initialized, but not VLAs.(since C99).</source>
          <target state="translated">Массивы известного размера и массивы неизвестного размера могут быть инициализированы,но не VLA (начиная с C99).</target>
        </trans-unit>
        <trans-unit id="b3b90eb627e1832afbdc43f763aa56429f97f87e" translate="yes" xml:space="preserve">
          <source>Arrays of unknown size</source>
          <target state="translated">Массивы неизвестного размера</target>
        </trans-unit>
        <trans-unit id="52d93df12c32edd74ceb73ae81bde3e78921ac55" translate="yes" xml:space="preserve">
          <source>As a special case, expressions of type &lt;code&gt;void&lt;/code&gt; are assumed to be non-lvalue object expressions that yield a value which has no representation and requires no storage.</source>
          <target state="translated">В особом случае выражения типа &lt;code&gt;void&lt;/code&gt; предполагаются как ненулевые объектные выражения, которые дают значение, которое не имеет представления и не требует хранения.</target>
        </trans-unit>
        <trans-unit id="44cd20de173d4164462fd0aaa64643a2d830c5e9" translate="yes" xml:space="preserve">
          <source>As a special case, the scope of a &lt;a href=&quot;compatible_type&quot;&gt;type name&lt;/a&gt; that is not a declaration of an identifier is considered to begin just after the place within the type name where the identifier would appear were it not omitted.</source>
          <target state="translated">В особом случае считается , что область имени &lt;a href=&quot;compatible_type&quot;&gt;типа,&lt;/a&gt; которая не является объявлением идентификатора, начинается сразу после того места в имени типа, где должен появиться идентификатор, если бы оно не было опущено.</target>
        </trans-unit>
        <trans-unit id="8798ee2306ff028fd41c00f00bf32102a67a4ded" translate="yes" xml:space="preserve">
          <source>As all bounds-checked functions, &lt;code&gt;wcstok_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">Как и все проверенные границы функции, &lt;code&gt;wcstok_s&lt;/code&gt; гарантированно будет доступен, только если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы &lt;code&gt;1&lt;/code&gt; перед включением &lt;code&gt;wchar.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70096e3d69911704a0669dccced895bd18198eb0" translate="yes" xml:space="preserve">
          <source>As all bounds-checked functions, &lt;code&gt;wscanf_s&lt;/code&gt;, &lt;code&gt;fwscanf_s&lt;/code&gt;, and &lt;code&gt;swscanf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Как и все проверенные границы функции, &lt;code&gt;wscanf_s&lt;/code&gt; , &lt;code&gt;fwscanf_s&lt;/code&gt; и &lt;code&gt;swscanf_s&lt;/code&gt; гарантированно будут доступны, только если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы &lt;code&gt;1&lt;/code&gt; перед включением &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a59d494eef6850f05e5c90b41b98a771ff1630a" translate="yes" xml:space="preserve">
          <source>As always, the result of a floating-point operator may have greater range and precision than is indicated by its type (see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Как всегда, результат оператора с плавающей точкой может иметь больший диапазон и точность, чем указано его типом (см. &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="49ef5aefbc07c5fe187539b0875fc885f8b4e782" translate="yes" xml:space="preserve">
          <source>As an example of the &quot;supported by the implementation&quot; requirement, POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt; accepts any &lt;code&gt;alignment&lt;/code&gt; that is a power of two and a multiple of &lt;code&gt;sizeof(void *)&lt;/code&gt;, and POSIX-based implementations of &lt;code&gt;aligned_alloc&lt;/code&gt; inherit this requirements.</source>
          <target state="translated">В качестве примера требования &amp;laquo;поддерживается реализацией&amp;raquo;, функция POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt; принимает любое &lt;code&gt;alignment&lt;/code&gt; которое является степенью двойки и кратным &lt;code&gt;sizeof(void *)&lt;/code&gt; , и основанные на POSIX реализации &lt;code&gt;aligned_alloc&lt;/code&gt; наследуют эти требования.</target>
        </trans-unit>
        <trans-unit id="99f5ca70997618b72580ada00f15b0f1727adfd5" translate="yes" xml:space="preserve">
          <source>As corrected by the post-C11 DR 468, &lt;code&gt;strncpy_s&lt;/code&gt;, unlike &lt;code&gt;&lt;a href=&quot;strcpy&quot;&gt;strcpy_s&lt;/a&gt;&lt;/code&gt;, is only allowed to clobber the remainder of the destination array if an error occurs.</source>
          <target state="translated">В соответствии с исправлением DR 468 после C11, &lt;code&gt;strncpy_s&lt;/code&gt; , в отличие от &lt;code&gt;&lt;a href=&quot;strcpy&quot;&gt;strcpy_s&lt;/a&gt;&lt;/code&gt; , может допускать сгущение оставшейся части массива назначения только в случае возникновения ошибки.</target>
        </trans-unit>
        <trans-unit id="e771c5a735f9e7c913c11ab6dfc5e9daf44f9f28" translate="yes" xml:space="preserve">
          <source>As initially published, C11 does not allow alignas specifiers in structure and union members; this was corrected by DR 444.</source>
          <target state="translated">Как было первоначально опубликовано,C11 не разрешает использовать спецификаторы alignas в структуре и членах профсоюза;это было исправлено в DR 444.</target>
        </trans-unit>
        <trans-unit id="0f24a8d064b195b6edf9eee27733591a5c27bd20" translate="yes" xml:space="preserve">
          <source>As specified in &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; may be (but isn't required to be on non-IEEE floating-point platforms) raised by &lt;code&gt;rint&lt;/code&gt; when rounding a non-integer finite value.</source>
          <target state="translated">Как указано в &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; может (но не обязательно для платформ с плавающей точкой не-IEEE) &lt;code&gt;rint&lt;/code&gt; помощью rint при округлении нецелого конечного значения.</target>
        </trans-unit>
        <trans-unit id="a33a2a6a1dbc72097e5ee50f7c236b5234435165" translate="yes" xml:space="preserve">
          <source>As well as the prefix form:</source>
          <target state="translated">Так же как и форма с префиксом:</target>
        </trans-unit>
        <trans-unit id="cf5967493a41546d32b0ca92f03818e35ddbf753" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt;, if the return type would be cvr-qualified, it is adjusted to its unqualified version for the purpose of constructing the function type.</source>
          <target state="translated">Как и в случае &lt;a href=&quot;function_declaration&quot;&gt;объявлений функций&lt;/a&gt; , если возвращаемый тип будет квалифицированным с помощью cvr, он будет адаптирован к его неквалифицированной версии с целью создания типа функции.</target>
        </trans-unit>
        <trans-unit id="3a13d3a1b158eacc4ae78930d86fe860ceec91a1" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt;, the return type of the function, determined by the type specifier in specifiers-and-qualifiers and possibly modified by the declarator as usual in &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;, must be a complete non-array object type or the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Как и в случае &lt;a href=&quot;function_declaration&quot;&gt;объявлений функций&lt;/a&gt; , возвращаемый тип функции, определяемый спецификатором типа в спецификаторах-спецификаторах и, возможно, изменяемый декларатором, как обычно в &lt;a href=&quot;declarations&quot;&gt;объявлениях&lt;/a&gt; , должен быть полным типом объекта, не являющимся массивом, или типом &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="931b6f6952da18dd1c23c7c06b62eafdf4a75919" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt;, the types of the parameters are adjusted from functions to pointers and from arrays to pointers for the purpose of constructing the function type and the top-level cvr-qualifiers of all parameter types are ignored for the purpose of determining &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible function type&lt;/a&gt;.</source>
          <target state="translated">Как и в случае &lt;a href=&quot;function_declaration&quot;&gt;объявлений функций&lt;/a&gt; , типы параметров настраиваются от функций до указателей и от массивов до указателей с целью создания типа функции, а квалификаторы cvr верхнего уровня всех типов параметров игнорируются с целью определения &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;совместимой функции. тип&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79ccd71b90196278405a314330eeaa2631ba1185" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, a declaration that introduced an enumerated type and one or more enumeration constants may also declare one or more objects of that type or type derived from it.</source>
          <target state="translated">Как и в случае со &lt;a href=&quot;struct&quot;&gt;структурой&lt;/a&gt; или &lt;a href=&quot;union&quot;&gt;объединением&lt;/a&gt; , объявление, которое ввело перечислимый тип и одну или несколько констант перечисления, может также объявить один или несколько объектов этого типа или производного от него типа.</target>
        </trans-unit>
        <trans-unit id="437ed49708f86a6f35c86cdb9207ea49adcc2e2c" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;asctime_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;time.h&lt;/code&gt;.</source>
          <target state="translated">Как и со всеми контролем границ функций, &lt;code&gt;asctime_s&lt;/code&gt; гарантируется только будет доступна , если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определяется реализацией , и если пользователь Определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; к целой константы 1 перед включением &lt;code&gt;time.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7466d344d3f71775f4c9996f0aefd336b865cd97" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;bsearch_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="translated">Как и во всех проверенных границами функциях, &lt;code&gt;bsearch_s&lt;/code&gt; гарантированно будет доступен, только если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;stdlib.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fc791ea25b5ba32faad862e9c23a50a7c997e69" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;ctime_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;time.h&lt;/code&gt;.</source>
          <target state="translated">Как и со всеми контролем границ функций, &lt;code&gt;ctime_s&lt;/code&gt; гарантируется только будет доступна , если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определяется реализацией , и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; к целочисленной константы 1 перед включением &lt;code&gt;time.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68c3240515eb99689624b2605905ba8bc7986315" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;fopen_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">Как и для всех функций с &lt;code&gt;fopen_s&lt;/code&gt; границ, fopen_s гарантированно будет доступен, только если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;stdio.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a2b6b4c82c23c016f116aa791f39d37f445e46a" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;freopen_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">Как и для всех функций с &lt;code&gt;freopen_s&lt;/code&gt; границ, freopen_s гарантированно будет доступен, только если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;stdio.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36d2edb3de2b41575170995e94495de51af70c2c" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;getenv_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="translated">Как и во всех проверенных границами функциях, &lt;code&gt;getenv_s&lt;/code&gt; гарантированно будет доступен, только если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;stdlib.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91dfec9c8791e4208d084cc59b7b36777275f675" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;gets_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">Как и для всех функций с &lt;code&gt;gets_s&lt;/code&gt; границ, gets_s гарантированно будет доступен, только если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;stdio.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b587147fa6c4a23c653092469c541f0564737fd7" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;gmtime_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;time.h&lt;/code&gt;.</source>
          <target state="translated">Как и со всеми контролем границ функций, &lt;code&gt;gmtime_s&lt;/code&gt; гарантируется только будет доступна , если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определяется реализацией , и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; к целочисленной константы 1 перед включением &lt;code&gt;time.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a3089753e59df348badd488426b5efcd28f163e" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;localtime_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;time.h&lt;/code&gt;.</source>
          <target state="translated">Как и со всеми контролем границ функций, &lt;code&gt;localtime_s&lt;/code&gt; гарантируется только будет доступна , если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определяется реализацией , и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; к целочисленной константы 1 перед включением &lt;code&gt;time.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ddab0b0f139e7b59eefb4230266da1ed9d87056" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;mbsrtowcs_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">Как и во всех проверенных границами функциях, &lt;code&gt;mbsrtowcs_s&lt;/code&gt; гарантированно будет доступна только в том случае, если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;wchar.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37428501d369894f1c0e8fe3487182869130402b" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;mbstowcs_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="translated">Как и во всех проверенных границами функциях, &lt;code&gt;mbstowcs_s&lt;/code&gt; гарантированно будет доступен только в том случае, если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;stdlib.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="484ec756538b4c4710eb92aa17bd6c656a7c5da9" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;printf_s&lt;/code&gt; , &lt;code&gt;fprintf_s&lt;/code&gt;, &lt;code&gt;sprintf_s&lt;/code&gt;, and &lt;code&gt;snprintf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">Как и во всех проверенных границами функциях &lt;code&gt;printf_s&lt;/code&gt; , &lt;code&gt;fprintf_s&lt;/code&gt; , &lt;code&gt;sprintf_s&lt;/code&gt; и &lt;code&gt;snprintf_s&lt;/code&gt; гарантированно будут доступны только в том случае, если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;stdio.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abea34893c8e6d78d3a467d161201fce0dcd31ca" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;qsort_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="translated">Как и для всех функций с &lt;code&gt;qsort_s&lt;/code&gt; границ, qsort_s гарантированно будет доступен только в том случае, если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;stdlib.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfaac44b328f0d9ecaecc16c135720ab79c8b975" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;scanf_s&lt;/code&gt; , &lt;code&gt;fscanf_s&lt;/code&gt;, and &lt;code&gt;sscanf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">Как и во всех проверенных границами функциях, &lt;code&gt;scanf_s&lt;/code&gt; , &lt;code&gt;fscanf_s&lt;/code&gt; и &lt;code&gt;sscanf_s&lt;/code&gt; гарантированно будут доступны, только если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;stdio.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7a73a8def345c13bbf6d30289221e860585c258" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;tmpnam_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">Как и во всех проверенных границами функциях, &lt;code&gt;tmpnam_s&lt;/code&gt; гарантированно будет доступна только в том случае, если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;stdio.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="918e04c9c4c5035b488768dc881c956dc6d6fce9" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;vprintf_s&lt;/code&gt; , &lt;code&gt;vfprintf_s&lt;/code&gt;, &lt;code&gt;vsprintf_s&lt;/code&gt;, and &lt;code&gt;vsnprintf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">Как и для всех функций с &lt;code&gt;vprintf_s&lt;/code&gt; границ, vprintf_s , &lt;code&gt;vfprintf_s&lt;/code&gt; , &lt;code&gt;vsprintf_s&lt;/code&gt; и &lt;code&gt;vsnprintf_s&lt;/code&gt; гарантированно будут доступны только в том случае, если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;stdio.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="073801d18c716edf19a5d56736c3e0cfe5310c1a" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;vscanf_s&lt;/code&gt; , &lt;code&gt;vfscanf_s&lt;/code&gt;, and &lt;code&gt;vsscanf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">Как и во всех проверенных границами функциях, &lt;code&gt;vscanf_s&lt;/code&gt; , &lt;code&gt;vfscanf_s&lt;/code&gt; и &lt;code&gt;vsscanf_s&lt;/code&gt; гарантированно будут доступны, только если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;stdio.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="859462c768d6d2e1180f63c1e98789651af7d933" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;vwscanf_s&lt;/code&gt; , &lt;code&gt;vfwscanf_s&lt;/code&gt;, and &lt;code&gt;vswscanf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">Как и во всех проверенных границами функциях, &lt;code&gt;vwscanf_s&lt;/code&gt; , &lt;code&gt;vfwscanf_s&lt;/code&gt; и &lt;code&gt;vswscanf_s&lt;/code&gt; гарантированно будут доступны только в том случае, если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;stdio.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4160e65b4073508722290e386b7ac737418adee" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcrtomb_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">Как и во всех проверенных границами функциях, &lt;code&gt;wcrtomb_s&lt;/code&gt; гарантированно будет доступен только в том случае, если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;wchar.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8852dd0c727422973b312a38cfafc412436b854a" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcscat_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">Как и во всех проверенных границами функциях, &lt;code&gt;wcscat_s&lt;/code&gt; гарантированно будет доступен, только если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;wchar.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94da776eb17b12e2e76b744201263fafce234bf0" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcscpy_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">Как и во всех проверенных границами функциях, &lt;code&gt;wcscpy_s&lt;/code&gt; гарантированно будет доступен, только если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;wchar.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="602e2723ae28915ea4b6c0d0d485677759ec2846" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcsncat_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">Как и во всех проверенных границами функциях, &lt;code&gt;wcsncat_s&lt;/code&gt; гарантированно будет доступен, только если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;wchar.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb04e05d2e03a1529216895dcf8b417f85fadc7d" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcsncpy_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">Как и во всех проверенных границами функциях, &lt;code&gt;wcsncpy_s&lt;/code&gt; гарантированно будет доступен, только если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;wchar.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59166256df368db6ea11d9dcca1c76c58f684e8f" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcsrtombs_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">Как и для всех функций с &lt;code&gt;wcsrtombs_s&lt;/code&gt; границ, wcsrtombs_s гарантированно будет доступен только в том случае, если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы &lt;code&gt;1&lt;/code&gt; перед включением &lt;code&gt;wchar.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10f1e3f209cb87b74ba077e0b12ebc217f85756f" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcstombs_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="translated">Как и во всех проверенных границами функциях, &lt;code&gt;wcstombs_s&lt;/code&gt; гарантированно будет доступен, только если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;stdlib.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="197a0ff717c052db762139e2134727533937a435" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wctomb_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="translated">Как и для всех функций с &lt;code&gt;wctomb_s&lt;/code&gt; границ, wctomb_s гарантированно будет доступен только в том случае, если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;stdlib.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8de73d3e3aed35fe5e7155d1d6d37204911c0756" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wmemcpy_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">Как и во всех проверенных границами функциях, &lt;code&gt;wmemcpy_s&lt;/code&gt; гарантированно будет доступна только в том случае, если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы 1 перед включением &lt;code&gt;wchar.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78f5af5ac1a7ed15c5c5e17dc8795818a3aa33e2" translate="yes" xml:space="preserve">
          <source>As with all floating-point expressions, the expression &lt;code&gt;(x*y) + z&lt;/code&gt; may be compiled as a fused mutiply-add unless the &lt;a href=&quot;../../preprocessor/impl&quot;&gt;#pragma&lt;/a&gt;&lt;code&gt;STDC FP_CONTRACT&lt;/code&gt; is off.</source>
          <target state="translated">Как и для всех выражений с плавающей запятой, выражение &lt;code&gt;(x*y) + z&lt;/code&gt; может быть скомпилировано как объединенное добавление mutiply, если только &lt;a href=&quot;../../preprocessor/impl&quot;&gt;#pragma &lt;/a&gt; &lt;code&gt;STDC FP_CONTRACT&lt;/code&gt; выключено.</target>
        </trans-unit>
        <trans-unit id="325da3015b4ad8b300bd2748d36c41a38bb66f31" translate="yes" xml:space="preserve">
          <source>As with all other &lt;a href=&quot;initialization&quot;&gt;initialization&lt;/a&gt;, every expression in the initializer list must be a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; when initializing aggregates of static or thread-local(since C11)&lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;:</source>
          <target state="translated">Как и при любой другой &lt;a href=&quot;initialization&quot;&gt;инициализации&lt;/a&gt; , каждое выражение в списке инициализатора должно быть &lt;a href=&quot;constant_expression&quot;&gt;константным выражением&lt;/a&gt; при инициализации агрегатов статического или локального по потоку (начиная с C11) &lt;a href=&quot;storage_duration&quot;&gt;срока хранения&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c4829062a1808034ce1d2399df876ce3ea658359" translate="yes" xml:space="preserve">
          <source>As with all other &lt;a href=&quot;initialization&quot;&gt;initialization&lt;/a&gt;, every expression in the initializer list must be a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; when initializing arrays of static or thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;:</source>
          <target state="translated">Как и при любой другой &lt;a href=&quot;initialization&quot;&gt;инициализации&lt;/a&gt; , каждое выражение в списке инициализатора должно быть &lt;a href=&quot;constant_expression&quot;&gt;константным выражением&lt;/a&gt; при инициализации массивов статической или локальной потоковой &lt;a href=&quot;storage_duration&quot;&gt;памяти&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3d74ed1ea6e40942992fbfb06d0ee0b9763fc886" translate="yes" xml:space="preserve">
          <source>As with all other initializations, expression must be a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; when initializing objects of static or thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;.</source>
          <target state="translated">Как и во всех других инициализациях, выражение должно быть &lt;a href=&quot;constant_expression&quot;&gt;выражение постоянная&lt;/a&gt; при инициализации объектов статического или локального поток &lt;a href=&quot;storage_duration&quot;&gt;продолжительности хранения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e555bf0a6d0cba4d524cadbdf2533b3abff34b33" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the do-while statement establishes &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;: any identifier introduced in the expression goes out of scope after the statement.</source>
          <target state="translated">Как и во всех других операторах выбора и итерации, оператор do-while устанавливает &lt;a href=&quot;scope&quot;&gt;область видимости блока&lt;/a&gt; : любой идентификатор, введенный в выражение, выходит из области видимости после оператора.</target>
        </trans-unit>
        <trans-unit id="f545ee7b22d4db083dbeb46229553bde0b39d74f" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the entire if-statement has its own block scope:</source>
          <target state="translated">Как и во всех других заявлениях о выборе и итерациях,все if-выражения имеют свой собственный блок-объект:</target>
        </trans-unit>
        <trans-unit id="e7bfa427f06539b7b10237b67a6680af8d74b410" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the for statement establishes &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;: any identifier introduced in the init_clause, cond_expression, or iteration_expression goes out of scope after the loop_statement.</source>
          <target state="translated">Как и во всех других операторах выбора и итерации, оператор for устанавливает &lt;a href=&quot;scope&quot;&gt;область действия блока&lt;/a&gt; : любой идентификатор, введенный в init_clause, cond_expression или iteration_expression, выходит из области действия после loop_statement.</target>
        </trans-unit>
        <trans-unit id="7c3290e5179ae7df55fad67d5932bc9569640162" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the switch statement establishes &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;: any identifier introduced in the expression goes out of scope after the statement.</source>
          <target state="translated">Как и во всех других операторах выбора и итерации, оператор switch устанавливает &lt;a href=&quot;scope&quot;&gt;область видимости блока&lt;/a&gt; : любой идентификатор, введенный в выражение, выходит из области видимости после оператора.</target>
        </trans-unit>
        <trans-unit id="bf1b641a79fe3bd85fdc3087658eae1ee87d7b5c" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the while statement establishes &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;: any identifier introduced in the expression goes out of scope after the statement.</source>
          <target state="translated">Как и во всех других операторах выбора и итерации, оператор while устанавливает &lt;a href=&quot;scope&quot;&gt;область видимости блока&lt;/a&gt; : любой идентификатор, введенный в выражение, выходит из области видимости после оператора.</target>
        </trans-unit>
        <trans-unit id="a3219f037624b3a59d32f19972411fe565f772da" translate="yes" xml:space="preserve">
          <source>As with any &lt;a href=&quot;../fenv&quot;&gt;floating-point environment&lt;/a&gt; functionality, rounding is only guaranteed if &lt;code&gt;#pragma STDC FENV_ACCESS ON&lt;/code&gt; is set.</source>
          <target state="translated">Как и для любой функциональности &lt;a href=&quot;../fenv&quot;&gt;среды&lt;/a&gt; с плавающей запятой , округление гарантируется только в том случае, если установлен параметр &lt;code&gt;#pragma STDC FENV_ACCESS ON&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c92fb474ab2bb51f893b5f74babbd3f0c831976" translate="yes" xml:space="preserve">
          <source>As with any pure imaginary number support in C, this macro is only defined if the imaginary numbers are supported.</source>
          <target state="translated">Как и в случае с поддержкой чистого мнимого числа в C,этот макрос определяется только в том случае,если поддерживаются мнимые числа.</target>
        </trans-unit>
        <trans-unit id="79bc029ba48a0820eb9af6de0ebd1ea7e6ea9789" translate="yes" xml:space="preserve">
          <source>As-if rule</source>
          <target state="translated">правило As-if</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="18d0c3fe9dc939e8b90006e867d3849538ad2f89" translate="yes" xml:space="preserve">
          <source>Assignment also returns the same value as what was stored in &lt;code&gt;lhs&lt;/code&gt; (so that expressions such as &lt;code&gt;a = b = c&lt;/code&gt; are possible). The &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; of the assignment operator is non-lvalue (so that expressions such as &lt;code&gt;(a=b)=c&lt;/code&gt; are invalid).</source>
          <target state="translated">Присвоение также возвращает то же значение, которое было сохранено в &lt;code&gt;lhs&lt;/code&gt; (так что возможны такие выражения, как &lt;code&gt;a = b = c&lt;/code&gt; ). &lt;a href=&quot;value_category&quot;&gt;Значение категории&lt;/a&gt; оператора присваивания не является именующее (так что выражения , такие как &lt;code&gt;(a=b)=c&lt;/code&gt; , являются недействительными).</target>
        </trans-unit>
        <trans-unit id="a5b50d74ba4665e5019dfafa81c1cee577573309" translate="yes" xml:space="preserve">
          <source>Assignment and compound assignment operators are binary operators that modify the variable to their left using the value to their right.</source>
          <target state="translated">Операторы присваивания и составные операторы присваивания-это двоичные операторы,которые изменяют переменную слева от нее,используя значение справа от нее.</target>
        </trans-unit>
        <trans-unit id="fc3a7306a4dbd9aaf7c8e7df511d8c165f52fd3d" translate="yes" xml:space="preserve">
          <source>Assignment by bitwise AND, XOR, and OR</source>
          <target state="translated">Назначение по битвам И,XOR и ИЛИ</target>
        </trans-unit>
        <trans-unit id="e5c86c40b5df7019866344018e45e57f50e118be" translate="yes" xml:space="preserve">
          <source>Assignment by bitwise left shift and right shift</source>
          <target state="translated">Назначение по битовому левому и правому смещению</target>
        </trans-unit>
        <trans-unit id="bea5586663c5a711fbc4d3e72c59f91bc6283914" translate="yes" xml:space="preserve">
          <source>Assignment by product, quotient, and remainder</source>
          <target state="translated">Назначение по продукту,количеству и остатку.</target>
        </trans-unit>
        <trans-unit id="bc417bc1271d1dd6a46931fd1dfa61093c858524" translate="yes" xml:space="preserve">
          <source>Assignment by sum and difference</source>
          <target state="translated">Присвоение по сумме и разнице</target>
        </trans-unit>
        <trans-unit id="171497ff060aefbcfe056d741c42de9e42533588" translate="yes" xml:space="preserve">
          <source>Assignment from one restricted pointer to another is undefined behavior, except when assigning from a pointer to an object in some outer block to a pointer in some inner block (including using a restricted pointer argument when calling a function with a restricted pointer parameter) or when returning from a function (and otherwise when the block of the from-pointer ended):</source>
          <target state="translated">Присвоение от одного ограниченного указателя к другому является неопределенным поведением,за исключением случаев,когда присвоение от указателя на объект в некотором внешнем блоке к указателю в некотором внутреннем блоке (в том числе использование аргумента ограниченного указателя при вызове функции с параметром ограниченного указателя)или при возвращении из функции (и в обратном случае,когда блок указателя from закончился):</target>
        </trans-unit>
        <trans-unit id="aa098245c1ec6b3b4a9cec4ec49f68bc2b3dc905" translate="yes" xml:space="preserve">
          <source>Assignment operators</source>
          <target state="translated">Назначивающие операторы</target>
        </trans-unit>
        <trans-unit id="83ac53a63cca418f24852c024f95f35335391074" translate="yes" xml:space="preserve">
          <source>Assignment operators' left operands must be unary (level-2 non-cast) expressions. This rule grammatically forbids some expressions that would be semantically invalid anyway. Many compilers ignore this rule and detect the invalidity semantically. For example, &lt;code&gt;e = a &amp;lt; d ? a++ : a = d&lt;/code&gt; is an expression that cannot be parsed because of this rule. However, many compilers ignore this rule and parse it as &lt;code&gt;e = ( ((a &amp;lt; d) ? (a++) : a) = d )&lt;/code&gt;, and then give an error because it is semantically invalid.</source>
          <target state="translated">Левые операнды операторов присваивания должны быть унарными (не приведенными к уровню 2) выражениями. Это правило грамматически запрещает некоторые выражения, которые в любом случае были бы семантически недействительными. Многие компиляторы игнорируют это правило и семантически обнаруживают недействительность. Например, &lt;code&gt;e = a &amp;lt; d ? a++ : a = d&lt;/code&gt; - это выражение, которое не может быть проанализировано из-за этого правила. Однако многие компиляторы игнорируют это правило и анализируют его как &lt;code&gt;e = ( ((a &amp;lt; d) ? (a++) : a) = d )&lt;/code&gt; , а затем выдают ошибку, поскольку оно семантически недопустимо.</target>
        </trans-unit>
        <trans-unit id="77dd21d24ad4cb9c785289515583c49d1df5693e" translate="yes" xml:space="preserve">
          <source>Assignment performs &lt;a href=&quot;conversion&quot;&gt;implicit conversion&lt;/a&gt; from the value of rhs to the type of rhs and then replaces the value in the object designated by lhs with the converted value of rhs.</source>
          <target state="translated">Присвоение выполняет &lt;a href=&quot;conversion&quot;&gt;неявное преобразование&lt;/a&gt; значения rhs в тип rhs, а затем заменяет значение в объекте, обозначенном lhs, на преобразованное значение rhs.</target>
        </trans-unit>
        <trans-unit id="269f718e42738bd37518148d39e5b7196b62a1ed" translate="yes" xml:space="preserve">
          <source>Assignment strips extra range and precision from floating-point expressions (see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Присвоение лишает дополнительного диапазона и точности из выражений с плавающей точкой (см. &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="f4d8655658394fa66d40386dc42cf98fdf4372dd" translate="yes" xml:space="preserve">
          <source>Associativity specification is redundant for unary operators and is only shown for completeness: unary prefix operators always associate right-to-left (&lt;code&gt;sizeof ++*p&lt;/code&gt; is &lt;code&gt;sizeof(++(*p))&lt;/code&gt;) and unary postfix operators always associate left-to-right (&lt;code&gt;a[1][2]++&lt;/code&gt; is &lt;code&gt;((a[1])[2])++&lt;/code&gt;). Note that the associativity is meaningful for member access operators, even though they are grouped with unary postfix operators: &lt;code&gt;a.b++&lt;/code&gt; is parsed &lt;code&gt;(a.b)++&lt;/code&gt; and not &lt;code&gt;a.(b++)&lt;/code&gt;.</source>
          <target state="translated">Спецификация ассоциативности избыточна для унарных операторов и показана только для полноты: унарные префиксные операторы всегда ассоциируются справа налево ( &lt;code&gt;sizeof ++*p&lt;/code&gt; - &lt;code&gt;sizeof(++(*p))&lt;/code&gt; ), а унарные постфиксные операторы всегда ассоциируются слева -право ( &lt;code&gt;a[1][2]++&lt;/code&gt; is &lt;code&gt;((a[1])[2])++&lt;/code&gt; ). Обратите внимание, что ассоциативность имеет смысл для операторов доступа к элементам, даже если они сгруппированы с унарными постфиксными операторами: &lt;code&gt;a.b++&lt;/code&gt; анализируется &lt;code&gt;(a.b)++&lt;/code&gt; а не &lt;code&gt;a.(b++)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4154e96428077efddaaf47a2b96af21e7a346bb0" translate="yes" xml:space="preserve">
          <source>At the &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call&lt;/a&gt;, each argument that is a part of the variable argument list undergoes special implicit conversions known as &lt;a href=&quot;conversion#Default_argument_promotions&quot;&gt;default argument promotions&lt;/a&gt;.</source>
          <target state="translated">При &lt;a href=&quot;operator_other#Function_call&quot;&gt;вызове функции&lt;/a&gt; каждый аргумент, являющийся частью списка переменных аргументов, претерпевает специальные неявные преобразования, известные как &lt;a href=&quot;conversion#Default_argument_promotions&quot;&gt;продвижение аргументов по умолчанию&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a4ba3822726fee4dc63d69beec4022ac36809bf" translate="yes" xml:space="preserve">
          <source>At the point of lookup, the name space of an identifier is determined by the manner in which it is used:</source>
          <target state="translated">В момент поиска пространство имен идентификатора определяется способом его использования:</target>
        </trans-unit>
        <trans-unit id="78f6940e1dbc39015dcd262184b3438c2502859e" translate="yes" xml:space="preserve">
          <source>At the top level of a &lt;a href=&quot;translation_phases&quot;&gt;translation unit&lt;/a&gt; (that is, a source file with all the #includes after the preprocessor), every C program is a sequence of &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;, which declare functions and objects with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;. These declarations are known as</source>
          <target state="translated">На верхнем уровне &lt;a href=&quot;translation_phases&quot;&gt;модуля перевода&lt;/a&gt; (то есть исходного файла со всеми символами #include после препроцессора) каждая программа на C представляет собой последовательность &lt;a href=&quot;declarations&quot;&gt;объявлений&lt;/a&gt; , которые объявляют функции и объекты с &lt;a href=&quot;storage_duration&quot;&gt;внешней связью&lt;/a&gt; . Эти декларации известны как</target>
        </trans-unit>
        <trans-unit id="fb34ad6782840b3609292d56d50524837de11852" translate="yes" xml:space="preserve">
          <source>Atomic operations</source>
          <target state="translated">Атомные операции</target>
        </trans-unit>
        <trans-unit id="ec45a74e461d6d1f9a6d6860119c9137a6fed5b2" translate="yes" xml:space="preserve">
          <source>Atomic operations library</source>
          <target state="translated">Библиотека атомных операций</target>
        </trans-unit>
        <trans-unit id="ac1cfc02a52dba8b178a48b4597760d28fb77ccd" translate="yes" xml:space="preserve">
          <source>Atomic operations tagged &lt;code&gt;memory_order_relaxed&lt;/code&gt; are not synchronization operations; they do not impose an order among concurrent memory accesses. They only guarantee atomicity and modification order consistency.</source>
          <target state="translated">Атомарные операции, помеченные &lt;code&gt;memory_order_relaxed&lt;/code&gt; , не являются операциями синхронизации; они не навязывают порядок между одновременными обращениями к памяти. Они только гарантируют атомарность и согласованность порядка модификации.</target>
        </trans-unit>
        <trans-unit id="4f6d4f2c68a571824e3f43d98c75cbda9d541c52" translate="yes" xml:space="preserve">
          <source>Atomic operations tagged &lt;code&gt;memory_order_seq_cst&lt;/code&gt; not only order memory the same way as release/acquire ordering (everything that</source>
          <target state="translated">Атомарные операции, помеченные &lt;code&gt;memory_order_seq_cst&lt;/code&gt; , не только упорядочивают память так же, как упорядочение освобождения / получения (все, что</target>
        </trans-unit>
        <trans-unit id="e93772d4bf7c4f3b7583aab6a0265189369c6fdd" translate="yes" xml:space="preserve">
          <source>Atomic properties are only meaningful for &lt;a href=&quot;value_category&quot;&gt;lvalue expressions&lt;/a&gt;. Lvalue-to-rvalue conversion (which models a memory read from an atomic location to a CPU register) strips atomicity along with other qualifiers.</source>
          <target state="translated">Атомарные свойства имеют смысл только для &lt;a href=&quot;value_category&quot;&gt;выражений lvalue&lt;/a&gt; . Преобразование Lvalue в rvalue (которое моделирует память, считываемую из атомарного местоположения в регистр ЦП) очищает атомарность вместе с другими квалификаторами.</target>
        </trans-unit>
        <trans-unit id="6bd53298c2672a3d3501c1b3d668970f3f55e051" translate="yes" xml:space="preserve">
          <source>Atomic types</source>
          <target state="translated">Атомные типы</target>
        </trans-unit>
        <trans-unit id="389fbb07de335e1a903a5217f5d069d302e09807" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;atomic_flag&lt;/code&gt; pointed to by &lt;code&gt;obj&lt;/code&gt; to clear (&lt;code&gt;false&lt;/code&gt;). The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно изменяет состояние &lt;code&gt;atomic_flag&lt;/code&gt; указывает &lt;code&gt;obj&lt;/code&gt; , чтобы очистить ( &lt;code&gt;false&lt;/code&gt; ). Первая версия упорядочивает обращения к памяти в соответствии с &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; , вторая версия упорядочивает обращения к памяти в соответствии с &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3718979e2b9ad32f9d807868c9664bc02a4706d" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;atomic_flag&lt;/code&gt; pointed to by &lt;code&gt;obj&lt;/code&gt; to set (&lt;code&gt;true&lt;/code&gt;) and returns the previous value. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно изменяет состояние &lt;code&gt;atomic_flag&lt;/code&gt; , на которое указывает &lt;code&gt;obj&lt;/code&gt; для set ( &lt;code&gt;true&lt;/code&gt; ), и возвращает предыдущее значение. Первая версия упорядочивает обращения к памяти в соответствии с &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; , вторая версия упорядочивает обращения к памяти в соответствии с &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="685cd023c278ffbba93acf26685c796a80ffd6b1" translate="yes" xml:space="preserve">
          <source>Atomically compares the contents of memory pointed to by &lt;code&gt;obj&lt;/code&gt; with the contents of memory pointed to by &lt;code&gt;expected&lt;/code&gt;, and if those are bitwise equal, replaces the former with &lt;code&gt;desired&lt;/code&gt; (performs read-modify-write operation). Otherwise, loads the actual contents of memory pointed to by &lt;code&gt;obj&lt;/code&gt; into &lt;code&gt;*expected&lt;/code&gt; (performs load operation).</source>
          <target state="translated">Атомно сравнивает содержимое памяти, на которое указывает &lt;code&gt;obj&lt;/code&gt; , с содержимым памяти, на которое указывает &lt;code&gt;expected&lt;/code&gt; , и, если они поразрядно равны, заменяет первое на &lt;code&gt;desired&lt;/code&gt; (выполняет операцию чтения-изменения-записи). В противном случае загружает фактическое содержимое памяти, на которое указывает &lt;code&gt;obj&lt;/code&gt; , в &lt;code&gt;*expected&lt;/code&gt; (выполняет операцию загрузки).</target>
        </trans-unit>
        <trans-unit id="df0174a476c2f8736237beae3e21b905656296c6" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the atomic variable pointed to by &lt;code&gt;obj&lt;/code&gt;. The operation is atomic read operation.</source>
          <target state="translated">Атомно загружает и возвращает текущее значение атомарной переменной, на которую указывает &lt;code&gt;obj&lt;/code&gt; . Операция атомарного чтения.</target>
        </trans-unit>
        <trans-unit id="4dc9ad67c097c1b7227ead6a0ab401fe229b6c4e" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value of the atomic variable pointed to by &lt;code&gt;obj&lt;/code&gt; with &lt;code&gt;desired&lt;/code&gt;. The operation is atomic write operation.</source>
          <target state="translated">Атомно заменяет значение атомарной переменной, на которую указывает &lt;code&gt;obj&lt;/code&gt; , на &lt;code&gt;desired&lt;/code&gt; . Операция является атомарной операцией записи.</target>
        </trans-unit>
        <trans-unit id="e9a886ccb54785d3678b91318357ed8aa2ecb513" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with &lt;code&gt;desired&lt;/code&gt; and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет значение, указанное в &lt;code&gt;obj&lt;/code&gt; , на &lt;code&gt;desired&lt;/code&gt; и возвращает значение &lt;code&gt;obj&lt;/code&gt; , сохраненное ранее. Операция является операцией чтения-изменения-записи. Первая версия упорядочивает обращения к памяти в соответствии с &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; , вторая версия упорядочивает обращения к памяти в соответствии с &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d0a6f30b29e80519fc1b75f03c103695e80bc2f" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of addition of &lt;code&gt;arg&lt;/code&gt; to the old value of &lt;code&gt;obj&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет значение, указанное в &lt;code&gt;obj&lt;/code&gt; , результатом добавления &lt;code&gt;arg&lt;/code&gt; к старому значению &lt;code&gt;obj&lt;/code&gt; и возвращает значение &lt;code&gt;obj&lt;/code&gt; , сохраненное ранее. Операция является операцией чтения-изменения-записи. Первая версия упорядочивает обращения к памяти в соответствии с &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; , вторая версия упорядочивает обращения к памяти в соответствии с &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="720b64c8705ff9f12adca3f0ac1074a4d0557da4" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise AND between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет значение, указанное в &lt;code&gt;obj&lt;/code&gt; , на результат побитового И между старым значением &lt;code&gt;obj&lt;/code&gt; и &lt;code&gt;arg&lt;/code&gt; и возвращает значение &lt;code&gt;obj&lt;/code&gt; , сохраненное ранее. Операция является операцией чтения-изменения-записи. Первая версия упорядочивает обращения к памяти в соответствии с &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; , вторая версия упорядочивает обращения к памяти в соответствии с &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="783b0416c25a72626756ad2801575cf30aa6b7c4" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise OR between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет значение, указанное в &lt;code&gt;obj&lt;/code&gt; , на результат побитового ИЛИ между старым значением &lt;code&gt;obj&lt;/code&gt; и &lt;code&gt;arg&lt;/code&gt; и возвращает значение &lt;code&gt;obj&lt;/code&gt; , сохраненное ранее. Операция является операцией чтения-изменения-записи. Первая версия упорядочивает обращения к памяти в соответствии с &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; , вторая версия упорядочивает обращения к памяти в соответствии с &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdda98d653801da68179d56534d72790cd58233c" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise XOR between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет значение, указанное в &lt;code&gt;obj&lt;/code&gt; , результатом побитового XOR между старым значением &lt;code&gt;obj&lt;/code&gt; и &lt;code&gt;arg&lt;/code&gt; и возвращает значение &lt;code&gt;obj&lt;/code&gt; , сохраненное ранее. Операция является операцией чтения-изменения-записи. Первая версия упорядочивает обращения к памяти в соответствии с &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; , вторая версия упорядочивает обращения к памяти в соответствии с &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7460f1e114e6e22f0145a7afeb4678b75fefd6c5" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of subtraction of &lt;code&gt;arg&lt;/code&gt; from the old value of &lt;code&gt;obj&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет значение, на которое указывает &lt;code&gt;obj&lt;/code&gt; , результатом вычитания &lt;code&gt;arg&lt;/code&gt; из старого значения &lt;code&gt;obj&lt;/code&gt; , и возвращает значение &lt;code&gt;obj&lt;/code&gt; , сохраненное ранее. Операция является операцией чтения-изменения-записи. Первая версия упорядочивает обращения к памяти в соответствии с &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; , вторая версия упорядочивает обращения к памяти в соответствии с &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a07f5da57143cfac7db707b777023caeb735d1c3" translate="yes" xml:space="preserve">
          <source>Atomically unlocks the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt; and blocks on the condition variable pointed to by &lt;code&gt;cond&lt;/code&gt; until the thread is signalled by &lt;code&gt;&lt;a href=&quot;cnd_signal&quot;&gt;cnd_signal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;cnd_broadcast&quot;&gt;cnd_broadcast&lt;/a&gt;&lt;/code&gt;, or until a spurious wake-up occurs. The mutex is locked again before the function returns.</source>
          <target state="translated">Атомно разблокирует мьютекс, на который указывает &lt;code&gt;mutex&lt;/code&gt; и блокирует переменную условия, на которую указывает &lt;code&gt;cond&lt;/code&gt; , до тех пор, пока поток не &lt;code&gt;&lt;a href=&quot;cnd_signal&quot;&gt;cnd_signal&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;cnd_broadcast&quot;&gt;cnd_broadcast&lt;/a&gt;&lt;/code&gt; , или пока не произойдет ложное пробуждение. Мьютекс снова блокируется перед возвратом функции.</target>
        </trans-unit>
        <trans-unit id="ddabf926a852b8875d5dc026bfa320aee942ddb7" translate="yes" xml:space="preserve">
          <source>Atomically unlocks the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt; and blocks on the condition variable pointed to by &lt;code&gt;cond&lt;/code&gt; until the thread is signalled by &lt;code&gt;&lt;a href=&quot;cnd_signal&quot;&gt;cnd_signal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;cnd_broadcast&quot;&gt;cnd_broadcast&lt;/a&gt;&lt;/code&gt;, or until the &lt;code&gt;TIME_UTC&lt;/code&gt; based time point pointed to by &lt;code&gt;time_point&lt;/code&gt; has been reached, or until a spurious wake-up occurs. The mutex is locked again before the function returns.</source>
          <target state="translated">Атомно разблокирует мьютекс указывает &lt;code&gt;mutex&lt;/code&gt; и блоков на условной переменной , на которую указывает &lt;code&gt;cond&lt;/code&gt; , пока поток не сигнализируется &lt;code&gt;&lt;a href=&quot;cnd_signal&quot;&gt;cnd_signal&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;cnd_broadcast&quot;&gt;cnd_broadcast&lt;/a&gt;&lt;/code&gt; , или до тех пор , &lt;code&gt;TIME_UTC&lt;/code&gt; на основе момент времени не указывает &lt;code&gt;time_point&lt;/code&gt; было достигнуто, или до поддельный пробуждения происходит. Мьютекс снова блокируется перед возвратом функции.</target>
        </trans-unit>
        <trans-unit id="baca3810d2cde4b7e1025b84062248c5223beff5" translate="yes" xml:space="preserve">
          <source>Attempts to clear the floating-point exceptions that are listed in the bitmask argument &lt;code&gt;excepts&lt;/code&gt;, which is a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;.</source>
          <target state="translated">Попытки очистить исключения с плавающей точкой, которые перечислены в битовой аргумент &lt;code&gt;excepts&lt;/code&gt; , который является побитовым ИЛИ с &lt;a href=&quot;fe_exceptions&quot;&gt;плавающей точкой макросов исключения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80ba342b8785a08804a333bbfedec341d6d1c9c0" translate="yes" xml:space="preserve">
          <source>Attempts to raise all floating point exceptions listed in &lt;code&gt;excepts&lt;/code&gt; (a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;). If one of the exceptions is &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt;, this function may additionally raise &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;. The order in which the exceptions are raised is unspecified, except that &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; are always raised before &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Попытки вызвать все исключения с плавающей запятой, перечисленные в &lt;code&gt;excepts&lt;/code&gt; (побитовое ИЛИ &lt;a href=&quot;fe_exceptions&quot;&gt;макросов исключений&lt;/a&gt; с плавающей запятой ). Если одним из исключений является &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; , эта функция может дополнительно повысить &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; . Порядок, в котором вызываются исключения, не определен, за исключением того, что &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; всегда &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; до FE_INEXACT .</target>
        </trans-unit>
        <trans-unit id="fc28f53619db61ee68c4c2b6467d93002c47863a" translate="yes" xml:space="preserve">
          <source>B and A appears before Y in the Single Total Order</source>
          <target state="translated">Б и А появляются перед Y в едином общем порядке.</target>
        </trans-unit>
        <trans-unit id="403422f66cba2adadb0da593596292864fb30e29" translate="yes" xml:space="preserve">
          <source>B within thread 1 and C is</source>
          <target state="translated">B в пределах резьбы 1 и C</target>
        </trans-unit>
        <trans-unit id="4e54499211164f4b65d4e8324b3d4ca2593386d6" translate="yes" xml:space="preserve">
          <source>B, and X appears before Y in the Single Total Order, then B observes either:</source>
          <target state="translated">B,и X появляется перед Y в Едином Всего Ордене,затем B тоже наблюдает:</target>
        </trans-unit>
        <trans-unit id="45e5662cbbb3c35284b81863cd8050953ac79093" translate="yes" xml:space="preserve">
          <source>B, and X appears before Y in the Single Total Order.</source>
          <target state="translated">B,и X появляется перед Y в Едином общем порядке.</target>
        </trans-unit>
        <trans-unit id="b23fad0d216b95f70509ee04aeb30c3631070eb7" translate="yes" xml:space="preserve">
          <source>B, then B observes one of the following:</source>
          <target state="translated">Б,затем Б наблюдает одно из следующего:</target>
        </trans-unit>
        <trans-unit id="b5eb64aad8ea6fe11cd7f656c010af32479eca9f" translate="yes" xml:space="preserve">
          <source>B.2 Complex &amp;lt;complex.h&amp;gt; (p: 419-420)</source>
          <target state="translated">B.2 Комплекс &amp;lt;complex.h&amp;gt; (стр: 419-420)</target>
        </trans-unit>
        <trans-unit id="24529c2b713b938df14dfb7e1f8995742508e674" translate="yes" xml:space="preserve">
          <source>B.2 Complex &amp;lt;complex.h&amp;gt; (p: 475-477)</source>
          <target state="translated">B.2 Комплекс &amp;lt;complex.h&amp;gt; (стр: 475-477)</target>
        </trans-unit>
        <trans-unit id="6909406a48bd13f476c9416147defba89909eee5" translate="yes" xml:space="preserve">
          <source>BUFSIZ</source>
          <target state="translated">BUFSIZ</target>
        </trans-unit>
        <trans-unit id="e4e7ae591b0abd861a75d3fa39a7cab907d2a5c8" translate="yes" xml:space="preserve">
          <source>Basic concepts</source>
          <target state="translated">Основные концепции</target>
        </trans-unit>
        <trans-unit id="beb8cd5e0f8e7a06f8d36dc83c4364f7f79078fa" translate="yes" xml:space="preserve">
          <source>Basic operations</source>
          <target state="translated">Основные операции</target>
        </trans-unit>
        <trans-unit id="3fc431b29bb2c2516db706b2f480a558166eba6d" translate="yes" xml:space="preserve">
          <source>Basic types</source>
          <target state="translated">Основные типы</target>
        </trans-unit>
        <trans-unit id="72e7594e1a0833654a97aa88a5c1fd93e77d5daa" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatibility of function types&lt;/a&gt; ignores top-level qualifiers of the function parameters, pointers to functions whose parameters only differ in their top-level qualifiers are interchangeable:</source>
          <target state="translated">Поскольку &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;совместимость типов функций&lt;/a&gt; игнорирует квалификаторы верхнего уровня параметров функции, указатели на функции, параметры которых отличаются только в своих квалификаторах верхнего уровня, являются взаимозаменяемыми:</target>
        </trans-unit>
        <trans-unit id="a4b1b6fcc1d9042bd28e210a0d53c1bd7a9ab8da" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;, &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;, &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt;, and &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt; qualifiers have effect on &lt;a href=&quot;value_category&quot;&gt;lvalues only&lt;/a&gt;, a cast to a cvr-qualified or atomic type is exactly equivalent to the cast to the corresponding unqualified type.</source>
          <target state="translated">Поскольку квалификаторы &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; , &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; , &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt; и &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt; влияют &lt;a href=&quot;value_category&quot;&gt;только&lt;/a&gt; на lvalue , приведение к cvr-квалифицированному или атомарному типу точно эквивалентно приведению к соответствующему неквалифицированному типу.</target>
        </trans-unit>
        <trans-unit id="09d7dc408004444ec94c2fabf4134d0cd224a49d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;setlocale&lt;/code&gt; modifies global state which affects execution of locale-dependent functions, it is undefined behavior to call it from one thread, while another thread is executing any of the following functions: &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;fprintf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isprint&quot;&gt;isprint&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswdigit&quot;&gt;iswdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;localeconv&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/tolower&quot;&gt;tolower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/fscanf&quot;&gt;fscanf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/ispunct&quot;&gt;ispunct&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswgraph&quot;&gt;iswgraph&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mblen&quot;&gt;mblen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/toupper&quot;&gt;toupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isalnum&quot;&gt;isalnum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isspace&quot;&gt;isspace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswlower&quot;&gt;iswlower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstowcs&quot;&gt;mbstowcs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/towlower&quot;&gt;towlower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isalpha&quot;&gt;isalpha&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isupper&quot;&gt;isupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswprint&quot;&gt;iswprint&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/towupper&quot;&gt;towupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isblank&quot;&gt;isblank&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswalnum&quot;&gt;iswalnum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswpunct&quot;&gt;iswpunct&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;setlocale&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/iscntrl&quot;&gt;iscntrl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswalpha&quot;&gt;iswalpha&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswspace&quot;&gt;iswspace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strcoll&quot;&gt;strcoll&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcstof&quot;&gt;wcstod&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isdigit&quot;&gt;isdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswblank&quot;&gt;iswblank&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswupper&quot;&gt;iswupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;strerror&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcstombs&quot;&gt;wcstombs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isgraph&quot;&gt;isgraph&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswcntrl&quot;&gt;iswcntrl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswxdigit&quot;&gt;iswxdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcsxfrm&quot;&gt;wcsxfrm&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/islower&quot;&gt;islower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswctype&quot;&gt;iswctype&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isxdigit&quot;&gt;isxdigit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Поскольку &lt;code&gt;setlocale&lt;/code&gt; изменяет глобальное состояние, которое влияет на выполнение зависящих от локали функций, вызывать его из одного потока не определено, тогда как другой поток выполняет любую из следующих функций: &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;fprintf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/isprint&quot;&gt;isprint&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswdigit&quot;&gt;iswdigit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;localeconv&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/tolower&quot;&gt;tolower&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../io/fscanf&quot;&gt;fscanf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/ispunct&quot;&gt;ispunct&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswgraph&quot;&gt;iswgraph&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/multibyte/mblen&quot;&gt;mblen&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/toupper&quot;&gt;toupper&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/isalnum&quot;&gt;isalnum&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/isspace&quot;&gt;isspace&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswlower&quot;&gt;iswlower&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstowcs&quot;&gt;mbstowcs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/towlower&quot;&gt;towlower&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/isalpha&quot;&gt;isalpha&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/isupper&quot;&gt;isupper&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswprint&quot;&gt;iswprint&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/towupper&quot;&gt;towupper&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/isblank&quot;&gt;isblank&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswalnum&quot;&gt;iswalnum&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswpunct&quot;&gt;iswpunct&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;setlocale&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/iscntrl&quot;&gt;iscntrl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswalpha&quot;&gt;iswalpha&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswspace&quot;&gt;iswspace&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/strcoll&quot;&gt;strcoll&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/wcstof&quot;&gt;wcstod&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/isdigit&quot;&gt;isdigit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswblank&quot;&gt;iswblank&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswupper&quot;&gt;iswupper&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;strerror&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcstombs&quot;&gt;wcstombs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/isgraph&quot;&gt;isgraph&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswcntrl&quot;&gt;iswcntrl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswxdigit&quot;&gt;iswxdigit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/wcsxfrm&quot;&gt;wcsxfrm&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/islower&quot;&gt;islower&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswctype&quot;&gt;iswctype&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/isxdigit&quot;&gt;isxdigit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="677c92c867af65c403f0e0b4ec228f7d426c2613" translate="yes" xml:space="preserve">
          <source>Because a struct declaration does not establish &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;, nested types, enumerations and enumerators introduced by declarations within struct-declaration-list are visible in the surrounding scope where the struct is defined.</source>
          <target state="translated">Поскольку объявление структуры не устанавливает &lt;a href=&quot;scope&quot;&gt;область видимости&lt;/a&gt; , вложенные типы, перечисления и перечислители, представленные объявлениями в списке структуры объявления, видны в окружающей области, где определена структура.</target>
        </trans-unit>
        <trans-unit id="80a31a1dd2f3b7679f827332e33a29fac7702466" translate="yes" xml:space="preserve">
          <source>Because bit fields do not necessarily begin at the beginning of a byte, address of a bit field cannot be taken. Pointers to bit fields are not possible. Bit fields cannot be used with &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;and &lt;a href=&quot;alignas&quot;&gt;alignas&lt;/a&gt;(since C11).</source>
          <target state="translated">Поскольку битовые поля не обязательно начинаются в начале байта, адрес битового поля не может быть взят. Указатели на битовые поля невозможны. Битовые поля нельзя использовать с &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt; и &lt;a href=&quot;alignas&quot;&gt;alignas&lt;/a&gt; (начиная с C11).</target>
        </trans-unit>
        <trans-unit id="b5ebf1a72c58aab22e302945eaa39d0cb80ef7c4" translate="yes" xml:space="preserve">
          <source>Because comments &lt;a href=&quot;language/translation_phases&quot;&gt;are removed&lt;/a&gt; before the preprocessor stage, a macro cannot be used to form a comment and an unterminated C-style comment doesn't spill over from an #include'd file.</source>
          <target state="translated">Поскольку комментарии &lt;a href=&quot;language/translation_phases&quot;&gt;удаляются&lt;/a&gt; до стадии препроцессора, макрос не может быть использован для формирования комментария, и из файла # include'd не выводится не определенный комментарий в стиле C.</target>
        </trans-unit>
        <trans-unit id="1e0e557c9045c92f011c14de73fcb46d729716ba" translate="yes" xml:space="preserve">
          <source>Because compound literals are unnamed, a compound literal cannot reference itself (a named struct can include a pointer to itself).</source>
          <target state="translated">Поскольку составные литералы безымянны,составной литерал не может ссылаться на себя (названная структура может включать в себя указатель на себя).</target>
        </trans-unit>
        <trans-unit id="d0f24847824ec8fc762ee7f7da8ed9ef3192123c" translate="yes" xml:space="preserve">
          <source>Because correct C programs are free of undefined behavior, compilers may produce unexpected results when a program that actually has UB is compiled with optimization enabled:</source>
          <target state="translated">Поскольку корректные программы на Си свободны от неопределённого поведения,компиляторы могут выдавать неожиданные результаты,когда программа,в которой на самом деле есть UB,компилируется с включённой оптимизацией:</target>
        </trans-unit>
        <trans-unit id="75a3b82067fe04c5e544992bcd1de5079a905d52" translate="yes" xml:space="preserve">
          <source>Because declarations are not statements, a label before a declaration must use a null statement (a semicolon immediately after the colon). Same applies to a label before the end of a block.</source>
          <target state="translated">Поскольку декларации не являются заявлениями,в метке перед декларацией должно использоваться нулевое заявление (точка с запятой сразу после двоеточия).То же самое относится и к метке до конца блока.</target>
        </trans-unit>
        <trans-unit id="1c99db21460e6186678ebd629bae9336a41554f4" translate="yes" xml:space="preserve">
          <source>Because in C, any &lt;a href=&quot;arithmetic_types&quot;&gt;complex value&lt;/a&gt; with at least one infinite part as an infinity even if its other part is a NaN, the usual arithmetic rules do not apply to complex-complex division. Other combinations of floating operands follow the following table:</source>
          <target state="translated">Поскольку в C любое &lt;a href=&quot;arithmetic_types&quot;&gt;комплексное значение,&lt;/a&gt; по крайней мере с одной бесконечной частью в виде бесконечности, даже если его другая часть является NaN, обычные арифметические правила не применяются к делению комплекс-комплекс. Другие комбинации плавающих операндов следуют следующей таблице:</target>
        </trans-unit>
        <trans-unit id="c3eb0806ea4c877ddbfd4e6e05950c4f3566ab2f" translate="yes" xml:space="preserve">
          <source>Because in C, any &lt;a href=&quot;arithmetic_types&quot;&gt;complex value&lt;/a&gt; with at least one infinite part as an infinity even if its other part is a NaN, the usual arithmetic rules do not apply to complex-complex multiplication. Other combinations of floating operands follow the following table:</source>
          <target state="translated">Поскольку в C любое &lt;a href=&quot;arithmetic_types&quot;&gt;комплексное значение,&lt;/a&gt; по крайней мере с одной бесконечной частью в виде бесконечности, даже если его другая часть является NaN, обычные арифметические правила не применяются к умножению сложного на сложное. Другие комбинации плавающих операндов следуют следующей таблице:</target>
        </trans-unit>
        <trans-unit id="224dd2f76f1fe545b11d30d1241dfab1984d9c00" translate="yes" xml:space="preserve">
          <source>Because members of incomplete type are not allowed, and a struct type is not complete until the end of the definition, a struct cannot have a member of its own type. A pointer to its own type is allowed, and is commonly used to implement nodes in linked lists or trees.</source>
          <target state="translated">Поскольку члены неполного типа не допускаются,а тип структуры не является полным до конца определения,структура не может иметь члена своего собственного типа.Допускается указатель на собственный тип,который обычно используется для реализации узлов в связанных списках или деревьях.</target>
        </trans-unit>
        <trans-unit id="bad967f19eac295089f2fac67901872b755b210a" translate="yes" xml:space="preserve">
          <source>Because most conversion specifiers first consume all consecutive whitespace, code such as.</source>
          <target state="translated">Потому что большинство спецификаторов преобразования сначала потребляют все последовательные пробельные символы,например,код.</target>
        </trans-unit>
        <trans-unit id="39db9801ee2b85598d8ae1a1a46079d1e8fc3c5a" translate="yes" xml:space="preserve">
          <source>Because of the &lt;a href=&quot;array&quot;&gt;array-to-pointer&lt;/a&gt; implicit conversion, pointer to the first element of an array can be initialized with an expression of array type:</source>
          <target state="translated">Из &lt;a href=&quot;array&quot;&gt;-за&lt;/a&gt; неявного преобразования массива в указатель указатель на первый элемент массива может быть инициализирован выражением типа массива:</target>
        </trans-unit>
        <trans-unit id="0ef3d7a594c0b241d8f8e7bcd0f19c06711e02ca" translate="yes" xml:space="preserve">
          <source>Because of the lvalue conversions, &lt;code&gt;&quot;abc&quot;&lt;/code&gt; matches &lt;code&gt;char*&lt;/code&gt; and not &lt;code&gt;char[4]&lt;/code&gt; and &lt;code&gt;(int const){0}&lt;/code&gt; matches &lt;code&gt;int&lt;/code&gt;, and not &lt;code&gt;const int&lt;/code&gt;. This was specified by the C17 DR 481 (which applies retroactively to C11).</source>
          <target state="translated">Из-за преобразования lvalue &lt;code&gt;&quot;abc&quot;&lt;/code&gt; соответствует &lt;code&gt;char*&lt;/code&gt; а не &lt;code&gt;char[4]&lt;/code&gt; а &lt;code&gt;(int const){0}&lt;/code&gt; соответствует &lt;code&gt;int&lt;/code&gt; , а не &lt;code&gt;const int&lt;/code&gt; . Это было указано в C17 DR 481 (который имеет обратную силу для C11).</target>
        </trans-unit>
        <trans-unit id="921ed4a61ba3faaabd04a1761190de01805d8c37" translate="yes" xml:space="preserve">
          <source>Because of the rules that apply to conversions as if by assignment, &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; and &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; qualifiers on the declared type are ignored when determining which type to convert the expression to.</source>
          <target state="translated">Из-за правил, которые применяются к преобразованиям, как будто по присваиванию, &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; и &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; квалификаторы в объявленном типе игнорируются при определении, к какому типу преобразовать выражение.</target>
        </trans-unit>
        <trans-unit id="e4778b72ab7bad66e8f08db4718675bdd369485f" translate="yes" xml:space="preserve">
          <source>Because of the side-effects involved, increment and decrement operators must be used with care to avoid undefined behavior due to violations of &lt;a href=&quot;eval_order&quot;&gt;sequencing rules&lt;/a&gt;.</source>
          <target state="translated">Из-за связанных с этим побочных эффектов операторы увеличения и уменьшения должны использоваться с осторожностью, чтобы избежать неопределенного поведения из-за нарушений &lt;a href=&quot;eval_order&quot;&gt;правил последовательности&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7dd28ff65248ebaad3755cb5b7e5ed66cc093d74" translate="yes" xml:space="preserve">
          <source>Because pointer comparison works with pointers to void, the macro &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; may be defined as &lt;code&gt;(void*)0&lt;/code&gt; in C, although that would be invalid in C++ where void pointers do not implicitly convert to typed pointers.</source>
          <target state="translated">Поскольку сравнение указателей работает с указателями на void, макрос &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; может быть определен как &lt;code&gt;(void*)0&lt;/code&gt; в C, хотя это недопустимо в C ++, где указатели void неявным образом не преобразуются в типизированные указатели.</target>
        </trans-unit>
        <trans-unit id="61e9e83dfb4480f034d0715c389293dc26f2bd68" translate="yes" xml:space="preserve">
          <source>Because trigraphs are processed early, a comment such as &lt;code&gt;// Will the next line be executed?????/&lt;/code&gt; will effectively comment out the following line, and the string literal such as &lt;code&gt;&quot;What's going on??!&quot;&lt;/code&gt; is parsed as &lt;code&gt;&quot;What's going on|&quot;&lt;/code&gt;.</source>
          <target state="translated">Поскольку триграфы обрабатываются рано, комментарий, такой как &lt;code&gt;// Will the next line be executed?????/&lt;/code&gt; , фактически закомментирует следующую строку, а строковый литерал, такой как &lt;code&gt;&quot;What's going on??!&quot;&lt;/code&gt; анализируется как &lt;code&gt;&quot;What's going on|&quot;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="b3a49bfbe489269815a0377a9238ed94b4143cdf" translate="yes" xml:space="preserve">
          <source>Before C99, floating-point exceptions were not specified, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EDOM&lt;/a&gt;&lt;/code&gt; was required for any domain error, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; was required for overflows and implementation-defined for underflows.</source>
          <target state="translated">До C99 исключения с плавающей запятой не указывались, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EDOM&lt;/a&gt;&lt;/code&gt; требовался при любой доменной ошибке, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; требовался при переполнении и определялся реализацией при переполнении.</target>
        </trans-unit>
        <trans-unit id="9b5450db704d0d2728817fd478cd80ea4e486aaf" translate="yes" xml:space="preserve">
          <source>Behaves as follows:</source>
          <target state="translated">Ведет себя следующим образом:</target>
        </trans-unit>
        <trans-unit id="bc3469b596bd7c770cc8387fa1d5a39905eb53ce" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;abort&lt;/code&gt; and &lt;code&gt;raise&lt;/code&gt;, POSIX specifies that &lt;code&gt;kill&lt;/code&gt;, &lt;code&gt;pthread_kill&lt;/code&gt;, and &lt;code&gt;sigqueue&lt;/code&gt; generate synchronous signals.</source>
          <target state="translated">Помимо &lt;code&gt;abort&lt;/code&gt; и &lt;code&gt;raise&lt;/code&gt; POSIX указывает, что &lt;code&gt;kill&lt;/code&gt; , &lt;code&gt;pthread_kill&lt;/code&gt; и &lt;code&gt;sigqueue&lt;/code&gt; генерируют синхронные сигналы.</target>
        </trans-unit>
        <trans-unit id="eabc9a356af19096008509b653054fc8a10ae1b7" translate="yes" xml:space="preserve">
          <source>Besides commenting out, other mechanisms used for source code exclusion are:</source>
          <target state="translated">Помимо комментариев,для исключения исходного кода используются и другие механизмы:</target>
        </trans-unit>
        <trans-unit id="55b4de0c95564ebdd3f273d704de6fbc4cc33b7a" translate="yes" xml:space="preserve">
          <source>Besides establishing new parse state and position, a call to this function undoes the effects of &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt; and clears the end-of-file state, if it is set.</source>
          <target state="translated">Помимо установления нового состояния и позиции анализа, вызов этой функции отменяет эффекты &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt; и очищает состояние конца файла, если оно установлено.</target>
        </trans-unit>
        <trans-unit id="93b85166ca8a42b63bd840ea2f796b2c221ddb71" translate="yes" xml:space="preserve">
          <source>Besides infinity handling, complex division is not allowed to overflow intermediate results, except when &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC CX_LIMITED_RANGE&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;ON&lt;/code&gt;, in which case the value may be calculated as if by (x+iy)/(u+iv) = [(xu+yv)+i(yu-xv)]/(u2</source>
          <target state="translated">Помимо бесконечной обработки, сложное деление не может переполнять промежуточные результаты, за исключением случаев, когда для &lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC CX_LIMITED_RANGE&lt;/code&gt; &lt;/a&gt; установлено значение &lt;code&gt;ON&lt;/code&gt; , и в этом случае значение может быть вычислено, как если бы (x + iy) / (u + iv) = [( Xu + уу) + I (ю-XV)] / (и2</target>
        </trans-unit>
        <trans-unit id="e3c4ad2940bc363a4f3c8811d9bf42503eadc813" translate="yes" xml:space="preserve">
          <source>Besides infinity handling, complex multiplication is not allowed to overflow intermediate results, except when &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC CX_LIMITED_RANGE&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;ON&lt;/code&gt;, in which case the value may be calculated as if by (x+iy)&amp;times;(u+iv) = (xu-yv)+i(yu+xv), as the programmer assumes the responsibility of limiting the range of the operands and dealing with the infinities.</source>
          <target state="translated">Помимо бесконечной обработки, сложное умножение не может переполнять промежуточные результаты, за исключением случаев, когда для &lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC CX_LIMITED_RANGE&lt;/code&gt; &lt;/a&gt; установлено значение &lt;code&gt;ON&lt;/code&gt; , и в этом случае значение может быть вычислено, как если бы (x + iy) &amp;times; (u + iv) = (xu -yv) + i (yu + xv), так как программист берет на себя ответственность за ограничение диапазона операндов и работу с бесконечностями.</target>
        </trans-unit>
        <trans-unit id="94e54a4d4ecea696ecc0d61df156f5a02b183b99" translate="yes" xml:space="preserve">
          <source>Besides the minimal bit counts, the C Standard guarantees that  &lt;code&gt;1 == sizeof(char) &amp;lt;= sizeof(short) &amp;lt;= sizeof(int) &amp;lt;= sizeof(long) &amp;lt;= sizeof(long long)&lt;/code&gt;.</source>
          <target state="translated">Помимо минимального количества битов, стандарт C гарантирует, что &lt;code&gt;1 == sizeof(char) &amp;lt;= sizeof(short) &amp;lt;= sizeof(int) &amp;lt;= sizeof(long) &amp;lt;= sizeof(long long)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f9b2ba53360a3d77f0974e715c014901e8f2e24" translate="yes" xml:space="preserve">
          <source>Besides the system-specific information necessary to access the device (e.g. a POSIX file descriptor), each stream object holds the following:</source>
          <target state="translated">Помимо системной информации,необходимой для доступа к устройству (например,файловый дескриптор POSIX),в каждом потоковом объекте хранится следующая информация:</target>
        </trans-unit>
        <trans-unit id="c460d3f926dfc813742e2a51770def855d27f159" translate="yes" xml:space="preserve">
          <source>Binary and text modes</source>
          <target state="translated">Двоичный и текстовый режимы</target>
        </trans-unit>
        <trans-unit id="b045376f837c7f5b36378c8f4a5c40a869f8ef92" translate="yes" xml:space="preserve">
          <source>Bit fields</source>
          <target state="translated">битовые поля</target>
        </trans-unit>
        <trans-unit id="f0ec1f622a02737f146bdf2f91db5413c9e7432c" translate="yes" xml:space="preserve">
          <source>Bit fields can have only one of four types (possibly &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; or &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; qualified):</source>
          <target state="translated">Битовые поля могут иметь только один из четырех типов (возможно, &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; или &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb0e5521fb64d3242c180ccb874fe7d8cabed01" translate="yes" xml:space="preserve">
          <source>Bitwise OR (inclusive or)</source>
          <target state="translated">ИЛИ (включительно или)</target>
        </trans-unit>
        <trans-unit id="306fd7520aac5bd6625750560fd55f52696ffa54" translate="yes" xml:space="preserve">
          <source>Bitwise OR of the floating-point exception macros that are both included in &lt;code&gt;excepts&lt;/code&gt; and correspond to floating-point exceptions currently set.</source>
          <target state="translated">Побитовое ИЛИ макросов исключений с плавающей точкой, которые включены в &lt;code&gt;excepts&lt;/code&gt; и соответствуют установленным в данный момент исключениям с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="8d05bc7de5edbe8f8035db15389ae0302c380410" translate="yes" xml:space="preserve">
          <source>Bitwise XOR (exclusive or)</source>
          <target state="translated">Битвайс XOR (эксклюзивный или)</target>
        </trans-unit>
        <trans-unit id="fabd2c95e5b0d98f2f600ccc655473c06c0c3640" translate="yes" xml:space="preserve">
          <source>Bitwise left shift and right shift</source>
          <target state="translated">Битовая смена влево и вправо</target>
        </trans-unit>
        <trans-unit id="8ff25d34bc5859088f94cfed2068dfc1ae2009f5" translate="yes" xml:space="preserve">
          <source>Bitwise logic</source>
          <target state="translated">битовая логика</target>
        </trans-unit>
        <trans-unit id="e681513340338ab189ae37b3a82732813788fc1e" translate="yes" xml:space="preserve">
          <source>Block scope</source>
          <target state="translated">Блочный прицел</target>
        </trans-unit>
        <trans-unit id="fd7d7dbe313bf74de7d4c75ebe6415d2612deaec" translate="yes" xml:space="preserve">
          <source>Block-scope variables have &lt;a href=&quot;storage_duration&quot;&gt;no linkage&lt;/a&gt; and &lt;a href=&quot;storage_duration&quot;&gt;automatic storage duration&lt;/a&gt; by default. Note that storage duration for non-VLA local variables begins when the block is entered, but until the declaration is seen, the variable is not in scope and cannot be accessed.</source>
          <target state="translated">Переменные области видимости по умолчанию &lt;a href=&quot;storage_duration&quot;&gt;не&lt;/a&gt; имеют никакой связи и &lt;a href=&quot;storage_duration&quot;&gt;автоматического хранения&lt;/a&gt; . Обратите внимание, что срок хранения локальных переменных, не относящихся к VLA, начинается, когда вводится блок, но до тех пор, пока объявление не будет просмотрено, переменная не находится в области видимости и недоступна.</target>
        </trans-unit>
        <trans-unit id="60cac622b229066c1c92084b1e1084cffd5fba0c" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt; is locked or until the &lt;code&gt;TIME_UTC&lt;/code&gt; based time point pointed to by &lt;code&gt;time_point&lt;/code&gt; has been reached.</source>
          <target state="translated">Блокирует текущий поток до тех пор, пока мьютекс, на который указывает &lt;code&gt;mutex&lt;/code&gt; будет заблокирован или пока не будет &lt;code&gt;TIME_UTC&lt;/code&gt; момент времени на основе TIME_UTC, на который указывает &lt;code&gt;time_point&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66bacdd3e696d27ee3c9031e8264d87687cb2c86" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt; is locked.</source>
          <target state="translated">Блокирует текущий поток, пока мьютекс, на который указывает &lt;code&gt;mutex&lt;/code&gt; будет заблокирован.</target>
        </trans-unit>
        <trans-unit id="f10a288344857812105308b56f4f2cba321e7a11" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until the thread identified by &lt;code&gt;thr&lt;/code&gt; finishes execution.</source>
          <target state="translated">Блокирует текущий поток, пока поток, определенный &lt;code&gt;thr&lt;/code&gt; ,не завершит выполнение.</target>
        </trans-unit>
        <trans-unit id="6e00d4fd15cea4053d3d66470eca6ff8a4eb81f0" translate="yes" xml:space="preserve">
          <source>Blocks the execution of the current thread for</source>
          <target state="translated">Блокирует выполнение текущего потока для</target>
        </trans-unit>
        <trans-unit id="c40226a362762d0bc6ce1da464fd4cab15481c00" translate="yes" xml:space="preserve">
          <source>Boolean and pointer expressions are often used as loop controlling expressions. The boolean value &lt;code&gt;false&lt;/code&gt; and the null pointer value of any pointer type compare equal to zero.</source>
          <target state="translated">Булевы выражения и указатели часто используются как выражения управления циклами. Логическое значение &lt;code&gt;false&lt;/code&gt; и нулевое значение указателя любого типа указателя сравниваются равными нулю.</target>
        </trans-unit>
        <trans-unit id="0764deddbcf93612e5cc2cfe340f015993c796ea" translate="yes" xml:space="preserve">
          <source>Boolean conversion</source>
          <target state="translated">булевское преобразование</target>
        </trans-unit>
        <trans-unit id="49f29c844f200eead7503c6d10737135d242ba2b" translate="yes" xml:space="preserve">
          <source>Boolean type</source>
          <target state="translated">булевский тип</target>
        </trans-unit>
        <trans-unit id="89e600a56a479c724d49fe8d5ef9759ca18de8f7" translate="yes" xml:space="preserve">
          <source>Boolean type support library</source>
          <target state="translated">библиотека поддержки булевых типов</target>
        </trans-unit>
        <trans-unit id="e7015f95fbaa798e33d1af7e54e15189c43d90fc" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; and the value zero indicate successful program execution status (see &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;), although it is not required that &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; equals zero.</source>
          <target state="translated">И &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; , и нулевое значение указывают на статус успешного выполнения программы (см. &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; ), хотя необязательно, чтобы &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; равнялся нулю.</target>
        </trans-unit>
        <trans-unit id="5406302f58397cc6547f5253fa2bd90d63f7aaf4" translate="yes" xml:space="preserve">
          <source>Both unary plus and unary minus first apply &lt;a href=&quot;conversion&quot;&gt;integral promotions&lt;/a&gt; to their operand, and then.</source>
          <target state="translated">И унарный плюс, и унарный минус сначала применяют &lt;a href=&quot;conversion&quot;&gt;интегральные продвижения&lt;/a&gt; к своему операнду, а затем.</target>
        </trans-unit>
        <trans-unit id="f61c46711ac1d50bd575498533838ae1e8abac1d" translate="yes" xml:space="preserve">
          <source>Both versions return a value of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обе версии возвращают значение типа &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97a1527874168667ead2b1d8d5b5b282f24fe01a" translate="yes" xml:space="preserve">
          <source>Bounded UB is undefined behavior that cannot perform an illegal memory write, although it may trap and may produce or store indeterminate values.</source>
          <target state="translated">Bounded UB-это неопределенное поведение,которое не может выполнить незаконную запись в память,хотя оно может поймать в ловушку и привести к появлению или сохранению неопределенных значений.</target>
        </trans-unit>
        <trans-unit id="79873d72bb63ec6416a942c808c710c67586e841" translate="yes" xml:space="preserve">
          <source>Bounded undefined behavior</source>
          <target state="translated">Граничное неопределённое поведение</target>
        </trans-unit>
        <trans-unit id="4f10d11dd9987b9a9fd4e790ba2d77d5cde0dc75" translate="yes" xml:space="preserve">
          <source>Bounded undefined behavior disables certain optimizations: compilation with analyzability enabled preserves source-code causality, which &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=c/language/as_if&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;may be violated&lt;/a&gt; by undefined behavior otherwise.</source>
          <target state="translated">Ограниченное неопределенное поведение отключает определенные оптимизации: компиляция с включенной анализируемостью сохраняет причинность исходного кода, которая в противном случае &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=c/language/as_if&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;может быть нарушена&lt;/a&gt; неопределенным поведением.</target>
        </trans-unit>
        <trans-unit id="008db50859187c03368a21b5b9915c65cb9f1ec8" translate="yes" xml:space="preserve">
          <source>Bounds checking</source>
          <target state="translated">Проверка границ</target>
        </trans-unit>
        <trans-unit id="400d9c7e5fe4086bae3b1862358d354ae9938c57" translate="yes" xml:space="preserve">
          <source>Built-in &lt;a href=&quot;operator_incdec&quot;&gt;increment and decrement operators&lt;/a&gt; and &lt;a href=&quot;operator_assignment&quot;&gt;compound assignment&lt;/a&gt; are read-modify-write atomic operations with total sequentially consistent ordering (as if using &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;). If less strict synchronization semantics are desired, the &lt;a href=&quot;../atomic&quot;&gt;standard library functions&lt;/a&gt; may be used instead.</source>
          <target state="translated">Встроенные &lt;a href=&quot;operator_incdec&quot;&gt;операторы инкремента и декремента&lt;/a&gt; и &lt;a href=&quot;operator_assignment&quot;&gt;составное присваивание&lt;/a&gt; являются атомарными операциями чтения-изменения-записи с полным последовательным последовательным упорядочением (как при использовании &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; ). Если требуется менее строгая семантика синхронизации, вместо &lt;a href=&quot;../atomic&quot;&gt;нее&lt;/a&gt; могут использоваться стандартные библиотечные функции .</target>
        </trans-unit>
        <trans-unit id="f96307b93964d75b23f02f58a7c3a35fcfb5fa45" translate="yes" xml:space="preserve">
          <source>By definition, the subscript operator &lt;code&gt;E1[E2]&lt;/code&gt; is exactly identical to &lt;code&gt;*((E1)+(E2))&lt;/code&gt;. If pointer-expression is an array expression, it undergoes &lt;a href=&quot;conversion&quot;&gt;lvalue-to-rvalue conversion&lt;/a&gt; and becomes a pointer to the first element of the array.</source>
          <target state="translated">По определению индексный оператор &lt;code&gt;E1[E2]&lt;/code&gt; в точности идентичен &lt;code&gt;*((E1)+(E2))&lt;/code&gt; . Если указатель-выражение является выражением массива, он подвергается &lt;a href=&quot;conversion&quot;&gt;преобразованию lvalue-в-значение&lt;/a&gt; и становится указателем на первый элемент массива.</target>
        </trans-unit>
        <trans-unit id="7803ee252527503b67d1eeb0deb252622746cebd" translate="yes" xml:space="preserve">
          <source>Byte</source>
          <target state="translated">Byte</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="c58c36c53f42fd7c600c76110fd52d5783cea7d0" translate="yes" xml:space="preserve">
          <source>C Operator Precedence</source>
          <target state="translated">Приоритет оператора</target>
        </trans-unit>
        <trans-unit id="eb6caef1589eb4b1a6590767aba0af5ac987e71a" translate="yes" xml:space="preserve">
          <source>C Programming Language</source>
          <target state="translated">Язык программирования C</target>
        </trans-unit>
        <trans-unit id="c94ec5437a5532816a0317782c7e7642602f22e2" translate="yes" xml:space="preserve">
          <source>C adopted the</source>
          <target state="translated">C приняла</target>
        </trans-unit>
        <trans-unit id="5ca10313f99c78244c06862b7b8b7d340b4225b4" translate="yes" xml:space="preserve">
          <source>C also treats multiple infinities so as to preserve directional information where possible, despite the inherent limitations of the Cartesian representation:</source>
          <target state="translated">C также обрабатывает множественные бесконечности,чтобы по возможности сохранить направленную информацию,несмотря на присущие картезианскому представлению ограничения:</target>
        </trans-unit>
        <trans-unit id="3ba06175a7b6689b39e35ea5131adbda2127a365" translate="yes" xml:space="preserve">
          <source>C has four kinds of scopes:</source>
          <target state="translated">C имеет четыре вида диапазона:</target>
        </trans-unit>
        <trans-unit id="fba12a9f5cc269fdeb5b6fbe79b42205d52cb74c" translate="yes" xml:space="preserve">
          <source>C has three types for representing real floating-point values:</source>
          <target state="translated">C имеет три типа для представления реальных значений с плавающей точкой:</target>
        </trans-unit>
        <trans-unit id="5206547c9adf534ccbc26e9a7e7f81e1243117db" translate="yes" xml:space="preserve">
          <source>C keywords</source>
          <target state="translated">C-ключевые слова</target>
        </trans-unit>
        <trans-unit id="d3aabd7f1f341fa399600a1b2214223083e8c94a" translate="yes" xml:space="preserve">
          <source>C keywords: _Alignas (since C11)</source>
          <target state="translated">Ключевые слова на C:_Alignas (начиная с C11)</target>
        </trans-unit>
        <trans-unit id="944615bbeed64b2d9fae2675cefd548984ef900c" translate="yes" xml:space="preserve">
          <source>C keywords: _Alignof (since C11)</source>
          <target state="translated">Ключевые слова на C:_Alignof (начиная с C11)</target>
        </trans-unit>
        <trans-unit id="84b2eb329e4d92e0a4d384006f50861ce715cae6" translate="yes" xml:space="preserve">
          <source>C keywords: _Atomic</source>
          <target state="translated">Ключевые слова на C:Атом.</target>
        </trans-unit>
        <trans-unit id="8a05296f252eb2181406137c31f219059b31c674" translate="yes" xml:space="preserve">
          <source>C keywords: _Bool</source>
          <target state="translated">Ключевые слова на C:Булл.</target>
        </trans-unit>
        <trans-unit id="1e0909bfead1f9cc1a889db650a2c563f189037c" translate="yes" xml:space="preserve">
          <source>C keywords: _Complex</source>
          <target state="translated">Ключевые слова на C:_Комплекс</target>
        </trans-unit>
        <trans-unit id="b56eb0a972eae24c452dd3dcde43c102fa3f07b4" translate="yes" xml:space="preserve">
          <source>C keywords: _Generic</source>
          <target state="translated">Ключевые слова на C:генерический</target>
        </trans-unit>
        <trans-unit id="9ba2ce8143036dcefc339b168b7b9fdbf87a205e" translate="yes" xml:space="preserve">
          <source>C keywords: _Imaginary</source>
          <target state="translated">Ключевые слова на C:Воображаемый</target>
        </trans-unit>
        <trans-unit id="c11f113e7aff3dde192c1e959a04c03b4117ed2d" translate="yes" xml:space="preserve">
          <source>C keywords: _Noreturn (since C11)</source>
          <target state="translated">Ключевые слова на C:_Noreturn (с C11)</target>
        </trans-unit>
        <trans-unit id="8155ee80a4c48fc49f561116f5e6c2e3aa9d145d" translate="yes" xml:space="preserve">
          <source>C keywords: _Static_assert</source>
          <target state="translated">Ключевые слова на C:_Static_assert</target>
        </trans-unit>
        <trans-unit id="aa7ef9b71b6ab728b88e72b4e10aa644b34019fe" translate="yes" xml:space="preserve">
          <source>C keywords: _Thread_local (since C11)</source>
          <target state="translated">Ключевые слова на C:_Thread_local (с C11)</target>
        </trans-unit>
        <trans-unit id="49dc63ea16b8f8707b9b0e51cbd56a1d901d7ac4" translate="yes" xml:space="preserve">
          <source>C keywords: auto</source>
          <target state="translated">Ключевые слова на C:auto</target>
        </trans-unit>
        <trans-unit id="6de6b71cc705dbd2d56a38c0c394178db20754eb" translate="yes" xml:space="preserve">
          <source>C keywords: break</source>
          <target state="translated">C ключевые слова:перерыв</target>
        </trans-unit>
        <trans-unit id="fb048e1990277a1b5c4c58f92576121302524116" translate="yes" xml:space="preserve">
          <source>C keywords: case</source>
          <target state="translated">Ключевые слова на языке Си:регистр</target>
        </trans-unit>
        <trans-unit id="6f8e3ab600fea3b9d2310e503fc9d7066ff7e26b" translate="yes" xml:space="preserve">
          <source>C keywords: char</source>
          <target state="translated">Ключевые слова на языке Си:char</target>
        </trans-unit>
        <trans-unit id="4b30efaadabace2d9f3caf304fb5da46109165d9" translate="yes" xml:space="preserve">
          <source>C keywords: const</source>
          <target state="translated">Ключевые слова на языке C:const</target>
        </trans-unit>
        <trans-unit id="838724dbf3de5ca09bb9955c0ee37433b11370c3" translate="yes" xml:space="preserve">
          <source>C keywords: continue</source>
          <target state="translated">Ключевые слова на C:продолжить</target>
        </trans-unit>
        <trans-unit id="f798b0c0f90f69264c05dbb4746eb22431241a29" translate="yes" xml:space="preserve">
          <source>C keywords: default</source>
          <target state="translated">Ключевые слова на языке C:по умолчанию</target>
        </trans-unit>
        <trans-unit id="c3d42e0deed9be4fc77cafc32457174fa359ea25" translate="yes" xml:space="preserve">
          <source>C keywords: do</source>
          <target state="translated">Ключевые слова на языке Си:сделать</target>
        </trans-unit>
        <trans-unit id="a9d0b771025dc99314e2f0637bddf7cbf7602aac" translate="yes" xml:space="preserve">
          <source>C keywords: double</source>
          <target state="translated">Ключевые слова на языке Си:двойной</target>
        </trans-unit>
        <trans-unit id="3a6a0ba8f0aed6dd0bdbf1e28ba0cd8d4c096062" translate="yes" xml:space="preserve">
          <source>C keywords: else</source>
          <target state="translated">Ключевые слова на языке Си:другое</target>
        </trans-unit>
        <trans-unit id="0d59e8885a30cf2c404b067251a56a9686c4680a" translate="yes" xml:space="preserve">
          <source>C keywords: enum</source>
          <target state="translated">C ключевые слова:перечисление</target>
        </trans-unit>
        <trans-unit id="7312b6a2fe886db62c316f52372b66d28c823610" translate="yes" xml:space="preserve">
          <source>C keywords: extern</source>
          <target state="translated">Ключевые слова на языке C:extern</target>
        </trans-unit>
        <trans-unit id="bc94431cf882574a779c0aec755a45a2f7b530c7" translate="yes" xml:space="preserve">
          <source>C keywords: float</source>
          <target state="translated">Ключевые слова на языке Си:поплавок</target>
        </trans-unit>
        <trans-unit id="6fc96909e96bd7935bb3a7616bd5d016d59c942f" translate="yes" xml:space="preserve">
          <source>C keywords: for</source>
          <target state="translated">C ключевые слова:для</target>
        </trans-unit>
        <trans-unit id="ff6a74f8e86fbd66745ead6b6ba3ebe93f43ac4b" translate="yes" xml:space="preserve">
          <source>C keywords: fortran</source>
          <target state="translated">C ключевые слова:fortran</target>
        </trans-unit>
        <trans-unit id="c574828ab89e283f89de7b5bc3bbf68c09a59fb5" translate="yes" xml:space="preserve">
          <source>C keywords: goto</source>
          <target state="translated">C ключевые слова:goto</target>
        </trans-unit>
        <trans-unit id="62c420a3462399a2cdf4f878f761c8b8c278f61a" translate="yes" xml:space="preserve">
          <source>C keywords: if</source>
          <target state="translated">Ключевые слова на языке C:если</target>
        </trans-unit>
        <trans-unit id="a97f823dd318fa21c2e97fe8be7e1dc7baed6dc0" translate="yes" xml:space="preserve">
          <source>C keywords: inline (since C99)</source>
          <target state="translated">Ключевые слова на языке C:inline (начиная с C99)</target>
        </trans-unit>
        <trans-unit id="8df78b5fefdedc92ad106a538884aa77670d7509" translate="yes" xml:space="preserve">
          <source>C keywords: int</source>
          <target state="translated">Ключевые слова на языке Си:int</target>
        </trans-unit>
        <trans-unit id="4767637f37a0721fc583dd82533e0558b32fb5b6" translate="yes" xml:space="preserve">
          <source>C keywords: long</source>
          <target state="translated">Ключевые слова на букву C:длинный</target>
        </trans-unit>
        <trans-unit id="4572d75f6a5ebfe96ce22c33079dc976094359ee" translate="yes" xml:space="preserve">
          <source>C keywords: register</source>
          <target state="translated">C ключевые слова:регистр</target>
        </trans-unit>
        <trans-unit id="79764e4605e47e7f696421a4847119c754498c27" translate="yes" xml:space="preserve">
          <source>C keywords: restrict</source>
          <target state="translated">C ключевые слова:ограничить</target>
        </trans-unit>
        <trans-unit id="b36253fa50e39d05465466d0a6c51414fdedd520" translate="yes" xml:space="preserve">
          <source>C keywords: return</source>
          <target state="translated">Ключевые слова на языке C:возврат</target>
        </trans-unit>
        <trans-unit id="117fc03fbbb1cd95e26ffade247dccfa551447f3" translate="yes" xml:space="preserve">
          <source>C keywords: short</source>
          <target state="translated">C ключевые слова:короткий</target>
        </trans-unit>
        <trans-unit id="4b9aae1b69e8290c6dcab6888c6d586ef3ea3599" translate="yes" xml:space="preserve">
          <source>C keywords: signed</source>
          <target state="translated">Ключевые слова на C:подписано</target>
        </trans-unit>
        <trans-unit id="f2bb9a6bd3b2fbdbf5168937c43676fb31e1477d" translate="yes" xml:space="preserve">
          <source>C keywords: sizeof</source>
          <target state="translated">Ключевые слова на букву C:размер</target>
        </trans-unit>
        <trans-unit id="8880827f2b81e7d64ed4a6fc04f86f9143bbd556" translate="yes" xml:space="preserve">
          <source>C keywords: static</source>
          <target state="translated">Ключевые слова на языке Си:статический</target>
        </trans-unit>
        <trans-unit id="9d9e13c529fbaad7b136eeb51c9b93b5db4d574c" translate="yes" xml:space="preserve">
          <source>C keywords: struct</source>
          <target state="translated">Ключевые слова на языке C:структура</target>
        </trans-unit>
        <trans-unit id="dafb3dc8cd252155d1d8f47dca6de15d26cd2a22" translate="yes" xml:space="preserve">
          <source>C keywords: switch</source>
          <target state="translated">Ключевые слова на языке C:switch</target>
        </trans-unit>
        <trans-unit id="087358aba6a590b2ab90404b3247ed15247ce47f" translate="yes" xml:space="preserve">
          <source>C keywords: typedef</source>
          <target state="translated">C ключевые слова:typedef</target>
        </trans-unit>
        <trans-unit id="1e04d799c3d9b84d0ec0266cbc6e1aa14a3ba94d" translate="yes" xml:space="preserve">
          <source>C keywords: union</source>
          <target state="translated">Ключевые слова на букву C:объединение</target>
        </trans-unit>
        <trans-unit id="fb99b9e2646fbf1e9d1fbfa9d08bfe0a806de934" translate="yes" xml:space="preserve">
          <source>C keywords: unsigned</source>
          <target state="translated">C ключевые слова:неподписанный</target>
        </trans-unit>
        <trans-unit id="195c0ae7f588efea965831acf345c1c17ac39c63" translate="yes" xml:space="preserve">
          <source>C keywords: void</source>
          <target state="translated">Ключевые слова на языке C:пустой</target>
        </trans-unit>
        <trans-unit id="8e4da6553c62486c5c52bbab3dee8e34b64fee5d" translate="yes" xml:space="preserve">
          <source>C keywords: volatile</source>
          <target state="translated">Ключевые слова на языке Си:волатильный</target>
        </trans-unit>
        <trans-unit id="b6c53e021f376fc8c0be266bf6434bd53837c1ce" translate="yes" xml:space="preserve">
          <source>C keywords: while</source>
          <target state="translated">Ключевые слова на языке C:в то время как</target>
        </trans-unit>
        <trans-unit id="91b79becc58238099e37212d187dd35b169ba357" translate="yes" xml:space="preserve">
          <source>C language</source>
          <target state="translated">язык C</target>
        </trans-unit>
        <trans-unit id="f247a737aad973565e0ba61f676327ab62c8b7fc" translate="yes" xml:space="preserve">
          <source>C memory management library</source>
          <target state="translated">библиотека управления памятью на C</target>
        </trans-unit>
        <trans-unit id="f546b4aa9a28fb61a154855a5ca4c09f150dc10e" translate="yes" xml:space="preserve">
          <source>C programs create, destroy, access, and manipulate objects.</source>
          <target state="translated">Программы на C создают,уничтожают,получают доступ и манипулируют объектами.</target>
        </trans-unit>
        <trans-unit id="577cba1265a06af20d2b556740cf4e6f66296754" translate="yes" xml:space="preserve">
          <source>C source code may be written in any 8-bit character set that includes the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_646&quot;&gt;ISO 646:1983&lt;/a&gt; invariant character set, even non-ASCII ones. However, several C operators and punctuators require characters that are outside of the ISO 646 codeset: &lt;code&gt;{, }, [, ], #, \, ^, |, ~&lt;/code&gt;. To be able to use character encodings where some or all of these symbols do not exist (such as the German &lt;a href=&quot;http://de.wikipedia.org/wiki/DIN_66003&quot;&gt;DIN 66003&lt;/a&gt;), there are two possibilities: alternative spellings of operators that use these characters or special combinations of two or three ISO 646 compatible characters that are interpreted as if they were a single non-ISO 646 character.</source>
          <target state="translated">Исходный код C может быть записан в любом 8-битном наборе символов, который включает набор символов инварианта &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_646&quot;&gt;ISO 646: 1983&lt;/a&gt; , даже не в ASCII. Однако некоторым операторам C и пунктуаторам требуются символы, которые находятся за пределами кодового набора ISO 646: &lt;code&gt;{, }, [, ], #, \, ^, |, ~&lt;/code&gt; . Чтобы иметь возможность использовать кодировки символов, когда некоторые или все эти символы не существуют (например, немецкий &lt;a href=&quot;http://de.wikipedia.org/wiki/DIN_66003&quot;&gt;DIN 66003&lt;/a&gt; ), существует две возможности: альтернативное написание операторов, использующих эти символы, или специальные комбинации из двух или трех символов, совместимых с ISO 646 которые интерпретируются так, как если бы они были одним символом, отличным от ISO 646.</target>
        </trans-unit>
        <trans-unit id="d88a29df1d30dee79bf5cbde0b208d4dfe6c6510" translate="yes" xml:space="preserve">
          <source>C standard</source>
          <target state="translated">C стандарт</target>
        </trans-unit>
        <trans-unit id="79c384f1ba053ea6a78d8c958d790e56d9052ca1" translate="yes" xml:space="preserve">
          <source>C string holding the name of the desired category</source>
          <target state="translated">C строка,содержащая имя нужной категории</target>
        </trans-unit>
        <trans-unit id="437c617752c611b36293355138fcbc5720307f88" translate="yes" xml:space="preserve">
          <source>C string holding the name of the desired mapping.</source>
          <target state="translated">C строка,содержащая имя нужного отображения.</target>
        </trans-unit>
        <trans-unit id="2426cb4ee79941311c0b2e401e3e16727f45af56" translate="yes" xml:space="preserve">
          <source>C supports two different forms of function definitions:</source>
          <target state="translated">C поддерживает две различные формы определения функций:</target>
        </trans-unit>
        <trans-unit id="ed49d634ae356d7361bc64d793e6736fa4d6bcfc" translate="yes" xml:space="preserve">
          <source>C++ imposes additional limitations on the &lt;code&gt;goto&lt;/code&gt; statement, but allows labels before declarations (which are statements in C++).</source>
          <target state="translated">C ++ накладывает дополнительные ограничения на &lt;code&gt;goto&lt;/code&gt; , но допускает метки перед объявлениями (которые являются операторами в C ++).</target>
        </trans-unit>
        <trans-unit id="27007198c75e9f26b239199b91632e30ae50d365" translate="yes" xml:space="preserve">
          <source>C++ pragmas in Visual Studio 2010</source>
          <target state="translated">C++прагмы в Visual Studio 2010</target>
        </trans-unit>
        <trans-unit id="59267432adf8c9336c020edab8c6d1687c5a8555" translate="yes" xml:space="preserve">
          <source>C++-style</source>
          <target state="translated">C++-style</target>
        </trans-unit>
        <trans-unit id="3c67bb4ebdd2ba43c17681cb6c05aab34159eee9" translate="yes" xml:space="preserve">
          <source>C++-style comments are usually used to comment single lines of text or code; however, they can be placed together to form multi-line comments. To insert text as a C++-style comment, simply precede the text with &lt;code&gt;//&lt;/code&gt; and follow the text with the new line character. C++-style comments tell the compiler to ignore all content between &lt;code&gt;//&lt;/code&gt; and a new line.</source>
          <target state="translated">Комментарии в стиле C ++ обычно используются для комментирования отдельных строк текста или кода; однако, они могут быть размещены вместе, чтобы сформировать многострочные комментарии. Чтобы вставить текст как комментарий в стиле C ++, просто предшествуйте тексту &lt;code&gt;//&lt;/code&gt; и следуйте за текстом с символом новой строки. Комментарии в стиле C ++ говорят компилятору игнорировать весь контент между &lt;code&gt;//&lt;/code&gt; и новой строкой.</target>
        </trans-unit>
        <trans-unit id="bd39761895022d52ef2184edffb0689497519cb3" translate="yes" xml:space="preserve">
          <source>C-style</source>
          <target state="translated">C-style</target>
        </trans-unit>
        <trans-unit id="0b9b1d01ffcd7c91aa5db3dfba413b80ea8d1087" translate="yes" xml:space="preserve">
          <source>C-style comments are usually used to comment large blocks of text or small fragments of code; however, they can be used to comment single lines. To insert text as a C-style comment, simply surround the text with &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt;. C-style comments tell the compiler to ignore all content between &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt;. Although it is not part of the C standard, &lt;code&gt;/**&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt; are often used to indicate documentation blocks; this is legal because the second asterisk is simply treated as part of the comment.</source>
          <target state="translated">Комментарии в стиле C обычно используются для комментирования больших блоков текста или небольших фрагментов кода; однако их можно использовать для комментирования отдельных строк. Чтобы вставить текст как комментарий в стиле C, просто окружите текст с помощью &lt;code&gt;/*&lt;/code&gt; и &lt;code&gt;*/&lt;/code&gt; . Комментарии в стиле C говорят компилятору игнорировать весь контент между &lt;code&gt;/*&lt;/code&gt; и &lt;code&gt;*/&lt;/code&gt; . Хотя это не является частью стандарта C, &lt;code&gt;/**&lt;/code&gt; и &lt;code&gt;*/&lt;/code&gt; часто используются для обозначения блоков документации; это законно, потому что вторая звездочка просто рассматривается как часть комментария.</target>
        </trans-unit>
        <trans-unit id="261d0f1299c6d923d77533902d4aaab0184c41c8" translate="yes" xml:space="preserve">
          <source>C11 standard (ISO/IEC 9899:2011):</source>
          <target state="translated">Стандарт C11 (ISO/IEC 9899:2011):</target>
        </trans-unit>
        <trans-unit id="9cd19e0c483895b4c4dca1dfee6e5ff438628642" translate="yes" xml:space="preserve">
          <source>C11, as published, specified that this function is per-object, not per-type. This was corrected by DR 465.</source>
          <target state="translated">В C11,как было опубликовано,указано,что эта функция относится к каждому объекту,а не к типу.Это было исправлено в DR 465.</target>
        </trans-unit>
        <trans-unit id="dc6cecb4527f2e14095c486e78d7793077fa54f6" translate="yes" xml:space="preserve">
          <source>C17 standard (ISO/IEC 9899:2018):</source>
          <target state="translated">Стандарт С17 (ISO/IEC 9899:2018):</target>
        </trans-unit>
        <trans-unit id="65819a01f96020ce9b84e3f226d24b0b43cc98ec" translate="yes" xml:space="preserve">
          <source>C89/C90 standard (ISO/IEC 9899:1990):</source>
          <target state="translated">Стандарт C89/C90 (ISO/IEC 9899:1990):</target>
        </trans-unit>
        <trans-unit id="4950e31032ac031befcea4756381cc9748081edb" translate="yes" xml:space="preserve">
          <source>C99 standard (ISO/IEC 9899:1999):</source>
          <target state="translated">Стандарт С99 (ISO/IEC 9899:1999):</target>
        </trans-unit>
        <trans-unit id="24fc58ea2f98cd20a27008421ec7f7e3dfc35435" translate="yes" xml:space="preserve">
          <source>CHAR_BIT</source>
          <target state="translated">CHAR_BIT</target>
        </trans-unit>
        <trans-unit id="725f72738449b33d5ed2db35158ace2f646b043c" translate="yes" xml:space="preserve">
          <source>CHAR_MAX</source>
          <target state="translated">CHAR_MAX</target>
        </trans-unit>
        <trans-unit id="b30c9342a5465cef0a56934460b3bfa4e2e74c49" translate="yes" xml:space="preserve">
          <source>CHAR_MIN</source>
          <target state="translated">CHAR_MIN</target>
        </trans-unit>
        <trans-unit id="789b032a45d264e7a02138bff69b47aacb370fca" translate="yes" xml:space="preserve">
          <source>CLOCKS_PER_SEC</source>
          <target state="translated">CLOCKS_PER_SEC</target>
        </trans-unit>
        <trans-unit id="d03fa4788d162e10e0a9157c0182737d266d25dd" translate="yes" xml:space="preserve">
          <source>CMPLXCMPLXFCMPLXL</source>
          <target state="translated">CMPLXCMPLXFCMPLXL</target>
        </trans-unit>
        <trans-unit id="33cd69fa90839e408dab31b3614bbcdf87603f0c" translate="yes" xml:space="preserve">
          <source>CMPLXF, CMPLX, CMPLXL</source>
          <target state="translated">СМПЛХФ,СМПЛХ,СМПЛХЛЬ</target>
        </trans-unit>
        <trans-unit id="b31dcd4d9874928426f6c96cb8a45435ad4f4f43" translate="yes" xml:space="preserve">
          <source>CMPLXL</source>
          <target state="translated">CMPLXL</target>
        </trans-unit>
        <trans-unit id="77ea7aa743c8ae5ceebe6476bf7df6ad49a72839" translate="yes" xml:space="preserve">
          <source>Call once</source>
          <target state="translated">Позвонить один раз</target>
        </trans-unit>
        <trans-unit id="4880a798b93c1b0de51af512420e2ef8cc83ab95" translate="yes" xml:space="preserve">
          <source>Call to a function with a prototype</source>
          <target state="translated">Вызов функции с прототипом</target>
        </trans-unit>
        <trans-unit id="3901637e234ca0b63b4410c0ce6911729acd8c78" translate="yes" xml:space="preserve">
          <source>Call to a function without a prototype</source>
          <target state="translated">Вызов функции без прототипа</target>
        </trans-unit>
        <trans-unit id="f514aa0539c8746a97d9256b1f83110e75de13e4" translate="yes" xml:space="preserve">
          <source>Call, Comma, Ternary</source>
          <target state="translated">Звони,Комма,Тернари</target>
        </trans-unit>
        <trans-unit id="ddde78f62d1b14d42265185475cdd0f871ebd9eb" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;snprintf&lt;/code&gt; with zero &lt;code&gt;bufsz&lt;/code&gt; and null pointer for &lt;code&gt;buffer&lt;/code&gt; is useful to determine the necessary buffer size to contain the output:</source>
          <target state="translated">Вызов &lt;code&gt;snprintf&lt;/code&gt; с нулевым &lt;code&gt;bufsz&lt;/code&gt; и нулевым указателем для &lt;code&gt;buffer&lt;/code&gt; полезен для определения размера буфера, необходимого для вывода:</target>
        </trans-unit>
        <trans-unit id="1590423ec88dccd74976d9c0b4a15cd539e5de0f" translate="yes" xml:space="preserve">
          <source>Calling the function from several threads does not induce a data race. The implementation shall support the registration of at least &lt;code&gt;32&lt;/code&gt; functions.</source>
          <target state="translated">Вызов функции из нескольких потоков не вызывает гонки данных. Реализация должна поддерживать регистрацию как минимум &lt;code&gt;32&lt;/code&gt; функций.</target>
        </trans-unit>
        <trans-unit id="69c9c5c35564ca07b6ae1737d8a6eff19ce6279f" translate="yes" xml:space="preserve">
          <source>Calls the host environment's command processor with the parameter &lt;code&gt;command&lt;/code&gt;. Returns an implementation-defined value (usually the value that the invoked program returns).</source>
          <target state="translated">Вызывает командный процессор среды хоста с параметром &lt;code&gt;command&lt;/code&gt; . Возвращает значение, определенное реализацией (обычно значение, которое возвращает вызванная программа).</target>
        </trans-unit>
        <trans-unit id="ca09c54bff74a82bae543ebe259f7452ee8c5293" translate="yes" xml:space="preserve">
          <source>Capabilities</source>
          <target state="translated">Capabilities</target>
        </trans-unit>
        <trans-unit id="6ccd1e19a995de897833876a1022c105f3fdec2a" translate="yes" xml:space="preserve">
          <source>Care must be taken when comparing floating-point values for equality, because the results of many operations cannot be represented exactly and must be rounded. In practice, floating-point numbers are usually compared allowing for the difference of one or more units of the last place.</source>
          <target state="translated">При сравнении значений с плавающей запятой для равенства необходимо соблюдать осторожность,так как результаты многих операций не могут быть точно представлены и должны быть округлены.На практике при сравнении чисел с плавающей точкой,как правило,учитывается разность одной или нескольких единиц последнего места.</target>
        </trans-unit>
        <trans-unit id="74473f63620ac45f2911b86a7f11c6501a7660cd" translate="yes" xml:space="preserve">
          <source>Cast and assignment strip away any extraneous range and precision: this models the action of storing a value from an extended-precision FPU register into a standard-sized memory location.</source>
          <target state="translated">Отливка и присвоение полосы прочь от любого постороннего диапазона и точности:это моделирует действие хранения значения из расширенного регистра FPU с высокой точностью в ячейку памяти стандартного размера.</target>
        </trans-unit>
        <trans-unit id="97ba68fc56a3efba444f7c6353ffce14d1fabcb2" translate="yes" xml:space="preserve">
          <source>Cast operator</source>
          <target state="translated">литейный оператор</target>
        </trans-unit>
        <trans-unit id="97fa7d1aa53dee3582d247166c0630bb95546ab9" translate="yes" xml:space="preserve">
          <source>Cast operators</source>
          <target state="translated">Литейные операторы</target>
        </trans-unit>
        <trans-unit id="65d75a1f3269b2efa27b067212f26c8863bd9bf8" translate="yes" xml:space="preserve">
          <source>Categorizes floating point value &lt;code&gt;arg&lt;/code&gt; into the following categories: zero, subnormal, normal, infinite, NAN, or implementation-defined category. The macro returns an integral value.</source>
          <target state="translated">Классифицирует значение &lt;code&gt;arg&lt;/code&gt; с плавающей точкой на следующие категории: ноль, субнормальное, нормальное, бесконечное, NAN или категория, определяемая реализацией. Макрос возвращает целое значение.</target>
        </trans-unit>
        <trans-unit id="1e425fda009fc1318071c020b813ea73240be6c9" translate="yes" xml:space="preserve">
          <source>Causes abnormal program termination unless &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGABRT&lt;/a&gt;&lt;/code&gt; is being caught by a signal handler passed to signal and the handler does not return.</source>
          <target state="translated">Вызывает ненормальное завершение программы, если обработчик сигнала не перехватывает &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGABRT&lt;/a&gt;&lt;/code&gt; и обработчик не возвращается.</target>
        </trans-unit>
        <trans-unit id="a5fc98a179eaefefc7383473561adf59469b047c" translate="yes" xml:space="preserve">
          <source>Causes normal program termination to occur without completely cleaning the resources.</source>
          <target state="translated">Причиняет нормальное завершение программы без полной очистки ресурсов.</target>
        </trans-unit>
        <trans-unit id="03d84237d77c18a1ea9454f00c0d5a2c4def6e6a" translate="yes" xml:space="preserve">
          <source>Causes normal program termination to occur.</source>
          <target state="translated">Причиняет нормальное завершение программы.</target>
        </trans-unit>
        <trans-unit id="405fa0979a11ab8b89968a0b69245a9c1cfe58b8" translate="yes" xml:space="preserve">
          <source>Causes the enclosing &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; or &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loop or &lt;a href=&quot;switch&quot;&gt; switch statement&lt;/a&gt; to terminate.</source>
          <target state="translated">Вызывает завершение цикла &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; , &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; или &lt;a href=&quot;do&quot;&gt;do-&lt;/a&gt; while или &lt;a href=&quot;switch&quot;&gt;оператора switch&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aac02b11ecaab94b12608001eae57b3a907465aa" translate="yes" xml:space="preserve">
          <source>Causes the remaining portion of the enclosing &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; or &lt;a href=&quot;do&quot;&gt; do-while&lt;/a&gt; loop body to be skipped.</source>
          <target state="translated">Причины оставшейся части ограждающего &lt;a href=&quot;for&quot;&gt;для&lt;/a&gt; , в &lt;a href=&quot;while&quot;&gt;то время&lt;/a&gt; или &lt;a href=&quot;do&quot;&gt;делать-то время как&lt;/a&gt; тело цикла будет пропущено.</target>
        </trans-unit>
        <trans-unit id="580812cfd060f7d050c66b73bd05ae797afde816" translate="yes" xml:space="preserve">
          <source>Certain &lt;a href=&quot;operator_arithmetic&quot;&gt;addition, subtraction&lt;/a&gt;, &lt;a href=&quot;operator_assignment&quot;&gt;compound assignment&lt;/a&gt;, &lt;a href=&quot;operator_incdec&quot;&gt;increment, and decrement&lt;/a&gt; operators are defined for pointers to elements of arrays.</source>
          <target state="translated">Определенные операторы &lt;a href=&quot;operator_arithmetic&quot;&gt;сложения, вычитания&lt;/a&gt; , &lt;a href=&quot;operator_assignment&quot;&gt;сложного присваивания&lt;/a&gt; , &lt;a href=&quot;operator_incdec&quot;&gt;увеличения и уменьшения&lt;/a&gt; определены для указателей на элементы массивов.</target>
        </trans-unit>
        <trans-unit id="f422128bf228bfdfc5c9bb732010edf878de2dd7" translate="yes" xml:space="preserve">
          <source>Certain words in a C program have special meaning, they are &lt;a href=&quot;../keyword&quot;&gt;keywords&lt;/a&gt;. Others can be used as &lt;a href=&quot;identifier&quot;&gt;identifiers&lt;/a&gt;, which may be used to identify &lt;a href=&quot;object&quot;&gt;objects&lt;/a&gt;, &lt;a href=&quot;functions&quot;&gt;functions&lt;/a&gt;, &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt;, &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, or &lt;a href=&quot;enum&quot;&gt;enumeration&lt;/a&gt; tags, their members, &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; names, &lt;a href=&quot;statements#Labels&quot;&gt;labels&lt;/a&gt;, or &lt;a href=&quot;../preprocessor/replace&quot;&gt;macros&lt;/a&gt;.</source>
          <target state="translated">Определенные слова в программе на C имеют особое значение, они являются &lt;a href=&quot;../keyword&quot;&gt;ключевыми словами&lt;/a&gt; . Другие могут использоваться в качестве &lt;a href=&quot;identifier&quot;&gt;идентификаторов&lt;/a&gt; , которые могут использоваться для идентификации &lt;a href=&quot;object&quot;&gt;объектов&lt;/a&gt; , &lt;a href=&quot;functions&quot;&gt;функций&lt;/a&gt; , тегов &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; , &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; или &lt;a href=&quot;enum&quot;&gt;enumeration&lt;/a&gt; , их членов, имен &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; , &lt;a href=&quot;statements#Labels&quot;&gt;меток&lt;/a&gt; или &lt;a href=&quot;../preprocessor/replace&quot;&gt;макросов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3614333e503e3f84b18d0f8a9ccba18b5aa755e" translate="yes" xml:space="preserve">
          <source>Changes the current line number and file name in the preprocessor.</source>
          <target state="translated">Изменяет номер текущей строки и имя файла в препроцессоре.</target>
        </trans-unit>
        <trans-unit id="bcd3bc7bc25f117f48576a1067f3eab87dc09962" translate="yes" xml:space="preserve">
          <source>Changes the filename of a file. The file is identified by character string pointed to by &lt;code&gt;old_filename&lt;/code&gt;. The new filename is identified by character string pointed to by &lt;code&gt;new_filename&lt;/code&gt;.</source>
          <target state="translated">Изменяет имя файла файла. Файл идентифицируется символьной строкой, на которую указывает &lt;code&gt;old_filename&lt;/code&gt; . Новое имя файла идентифицируется символьной строкой, на которую указывает &lt;code&gt;new_filename&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f1702f311546e930d8f583ff60c5b7dafb56f91" translate="yes" xml:space="preserve">
          <source>Changes the the buffering mode of the given file stream &lt;code&gt;stream&lt;/code&gt; as indicated by the argument &lt;code&gt;mode&lt;/code&gt;. In addition,</source>
          <target state="translated">Изменяет режим буферизации данного потока файлового &lt;code&gt;stream&lt;/code&gt; как указано в &lt;code&gt;mode&lt;/code&gt; аргумента . К тому же,</target>
        </trans-unit>
        <trans-unit id="6512adfeb2b6b71a8085a0b4569a9025105f6ea1" translate="yes" xml:space="preserve">
          <source>Character array manipulation</source>
          <target state="translated">Манипуляция с массивом символов</target>
        </trans-unit>
        <trans-unit id="11a965778572465b297760373bc0ab9a5fe50dd4" translate="yes" xml:space="preserve">
          <source>Character classification</source>
          <target state="translated">Классификация символов</target>
        </trans-unit>
        <trans-unit id="fb797cfcfb3f8dadf93dcc6665528c24781954df" translate="yes" xml:space="preserve">
          <source>Character constants</source>
          <target state="translated">Константы характера</target>
        </trans-unit>
        <trans-unit id="34a7ab398acc718f6548cdc2f8cf73c1cb95496f" translate="yes" xml:space="preserve">
          <source>Character constants, when evaluated in &lt;code&gt;#if&lt;/code&gt;-expressions, may be interpreted in the source character set, the execution character set, or some other implementation-defined character set.</source>
          <target state="translated">Символьные константы, когда они вычисляются в # &lt;code&gt;#if&lt;/code&gt; выражениях, могут интерпретироваться в исходном наборе символов, наборе символов выполнения или некотором другом наборе символов, определяемом реализацией.</target>
        </trans-unit>
        <trans-unit id="71abf6f6cdd425368811b306d03c5406b82396a5" translate="yes" xml:space="preserve">
          <source>Character manipulation</source>
          <target state="translated">Манипулирование персонажами</target>
        </trans-unit>
        <trans-unit id="ce6ddaa694e2a7b4942fbc87cf18e8f64d26f9b2" translate="yes" xml:space="preserve">
          <source>Character types</source>
          <target state="translated">Типы символов</target>
        </trans-unit>
        <trans-unit id="7583a23f352a0114e03ecd5b421ac82f127e76d4" translate="yes" xml:space="preserve">
          <source>Checks if the end of the given file stream has been reached.</source>
          <target state="translated">Проверяет,достигнут ли конец данного потока файлов.</target>
        </trans-unit>
        <trans-unit id="a80411bf63939bb5325e4f8c8df73adae4f03bdc" translate="yes" xml:space="preserve">
          <source>Checks if the given character can be printed, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;), or space, or any character classified as printable by the current C locale.</source>
          <target state="translated">Проверяет, может ли данный символ быть напечатан, то есть это либо число ( &lt;code&gt;0123456789&lt;/code&gt; ), либо заглавная буква ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), строчная буква ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ), символ пунктуации ( &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; ), либо пробел, либо любой символ, классифицируемый как печатаемый текущим языковым стандартом C.</target>
        </trans-unit>
        <trans-unit id="5cd50516db04d878a383e0474cbd44271fb0cbcd" translate="yes" xml:space="preserve">
          <source>Checks if the given character has a graphical representation, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), or a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;), or any graphical character specific to the current C locale.</source>
          <target state="translated">Проверяет, имеет ли данный символ графическое представление, т. Е. Является ли оно числом ( &lt;code&gt;0123456789&lt;/code&gt; ), заглавной буквой ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), строчной буквой ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ) или знаком пунктуации ( &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; ) или любой графический символ, относящийся к текущей локали Си.</target>
        </trans-unit>
        <trans-unit id="a9eb05afb3b38c63c5335df9e7e4ec728a94a143" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a blank character in the current C locale. In the default C locale, only space (&lt;code&gt;0x20&lt;/code&gt;) and horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) are classified as blank.</source>
          <target state="translated">Проверяет, является ли данный символ пустым символом в текущей локали языка C. В языковом стандарте C по умолчанию только пробел ( &lt;code&gt;0x20&lt;/code&gt; ) и горизонтальная вкладка ( &lt;code&gt;0x09&lt;/code&gt; ) классифицируются как пустые.</target>
        </trans-unit>
        <trans-unit id="33fe2d2ab596854468dce386087d212e312337e6" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a control character, i.e. codes &lt;code&gt;0x00-0x1F&lt;/code&gt; and &lt;code&gt;0x7F&lt;/code&gt;.</source>
          <target state="translated">Проверяет, является ли данный символ управляющим, то есть коды &lt;code&gt;0x00-0x1F&lt;/code&gt; и &lt;code&gt;0x7F&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b81bc3069e91e958c3b48b56b856e7a064d982cb" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a hexadecimal numeric character (&lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt;) or is classified as a hexadecimal character.</source>
          <target state="translated">Проверяет, является ли данный символ шестнадцатеричным числовым символом ( &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt; ) или классифицирован как шестнадцатеричный символ.</target>
        </trans-unit>
        <trans-unit id="5ca278746bc9e114b2661e67e9d27426ef8645a2" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a numeric character (&lt;code&gt;0123456789&lt;/code&gt;).</source>
          <target state="translated">Проверяет, является ли данный символ числовым ( &lt;code&gt;0123456789&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="837e27bbd4c4f9b720edba791bc0a1c76ee5a46e" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a punctuation character in the current C locale. The default C locale classifies the characters &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; as punctuation.</source>
          <target state="translated">Проверяет, является ли данный символ символом пунктуации в текущей локали языка C. Локаль C по умолчанию классифицирует символы &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; Как знаки пунктуации.</target>
        </trans-unit>
        <trans-unit id="175dc8fef53c9b8998a48bfa272af43d8ca70a35" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a whitespace character, i.e. either space (&lt;code&gt;0x20&lt;/code&gt;), form feed (&lt;code&gt;0x0c&lt;/code&gt;), line feed (&lt;code&gt;0x0a&lt;/code&gt;), carriage return (&lt;code&gt;0x0d&lt;/code&gt;), horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) or vertical tab (&lt;code&gt;0x0b&lt;/code&gt;).</source>
          <target state="translated">Проверяет, является ли данный символ пробельным символом, то есть либо пробел ( &lt;code&gt;0x20&lt;/code&gt; ), перевод формы ( &lt;code&gt;0x0c&lt;/code&gt; ), перевод строки ( &lt;code&gt;0x0a&lt;/code&gt; ), возврат каретки ( &lt;code&gt;0x0d&lt;/code&gt; ), горизонтальная табуляция ( &lt;code&gt;0x09&lt;/code&gt; ) или вертикальная табуляция ( &lt;code&gt;0x0b&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="707e4e9ff428a06747d7018e5e02fddc801826d0" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an alphabetic character, i.e. either an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), or a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;).</source>
          <target state="translated">Проверяет, является ли данный символ буквенным символом, то есть либо заглавной буквой ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), либо строчной буквой ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8460053f4f6257cbef25ff160120cc6c7e959e75" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an alphanumeric character as classified by the current C locale. In the default locale, the following characters are alphanumeric:</source>
          <target state="translated">Проверяет,является ли данный символ буквенно-цифровым,классифицированным по текущей локали C.В локали по умолчанию следующие символы являются буквенно-цифровыми:</target>
        </trans-unit>
        <trans-unit id="72a25eda93d278cea5691863e59bd4331e5ca8e4" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an uppercase character according to the current C locale. In the default &quot;C&quot; locale, &lt;code&gt;isupper&lt;/code&gt; returns true only for the uppercase letters (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;).</source>
          <target state="translated">Проверяет, является ли данный символ прописным в соответствии с текущей локалью языка C. В локали &quot;C&quot; по умолчанию &lt;code&gt;isupper&lt;/code&gt; возвращает true только для заглавных букв ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9fe61f7d08ea23e640364b8edb24f7095af3e4b6" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a lowercase character according to the current C locale. In the default &quot;C&quot; locale, &lt;code&gt;islower&lt;/code&gt; returns true only for the lowercase letters (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;).</source>
          <target state="translated">Проверяет, классифицирован ли данный символ как строчный в соответствии с текущей локалью языка C. В локали &quot;C&quot; по умолчанию &lt;code&gt;islower&lt;/code&gt; возвращает true только для строчных букв ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="86e15e5f001ace8d5ed732d67f679b17b8027345" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character can be printed, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;), space or any printable character specific to the current C locale.</source>
          <target state="translated">Проверяет, можно ли печатать данный широкий символ, т. Е. Является ли оно числом ( &lt;code&gt;0123456789&lt;/code&gt; ), заглавной буквой ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), строчной буквой ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ), знаком пунктуации ( &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; ), пробел или любой печатаемый специфический характер для текущей локали C.</target>
        </trans-unit>
        <trans-unit id="6ddf1d4606203515c454d3cbf72c353c2b7a5550" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt;.</source>
          <target state="translated">Проверяет, соответствует ли данный широкий символ (если он сужен) шестнадцатеричному числовому символу, то есть одному из &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d54601d6790c54f44a419455b6b691579d6df40d" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters 0123456789.</source>
          <target state="translated">Проверяет,соответствует ли данный широкий символ (если он сужен)одному из десяти знаков после запятой 0123456789.</target>
        </trans-unit>
        <trans-unit id="901c321d30a4b9e0c1bb0f4ce4f0b7f3fc5086ff" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character has a graphical representation, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;) or any graphical character specific to the current C locale.</source>
          <target state="translated">Проверяет, имеет ли данный широкий символ графическое представление, т. Е. Является ли оно числом ( &lt;code&gt;0123456789&lt;/code&gt; ), заглавной буквой ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), строчной буквой ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ), знаком пунктуации ( &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; ) или любой графический символ, относящийся к текущей локали Си.</target>
        </trans-unit>
        <trans-unit id="69347e858d3166f00f30fe95f9dd5f5ae37bc816" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a control character, i.e. codes &lt;code&gt;0x00-0x1F&lt;/code&gt; and &lt;code&gt;0x7F&lt;/code&gt; and any control characters specific to the current locale.</source>
          <target state="translated">Проверяет, является ли данный широкий символ управляющим символом, то есть кодами &lt;code&gt;0x00-0x1F&lt;/code&gt; и &lt;code&gt;0x7F&lt;/code&gt; , а также какими-либо управляющими символами, характерными для текущей локали.</target>
        </trans-unit>
        <trans-unit id="f75e93760224f49060fa9daae484b93562cec26c" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a lowercase letter, i.e. one of &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; or any lowercase letter specific to the current locale.</source>
          <target state="translated">Проверяет, является ли данный широкий символ строчной буквой, т. &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; или любой строчной буквой, характерной для текущей локали.</target>
        </trans-unit>
        <trans-unit id="d3bc1df8c65e55dc36b4066a3cfbf00b5eb6d139" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a punctuation character, i.e. it is one of &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; or any punctuation character specific to the current locale.</source>
          <target state="translated">Проверяет, является ли данный широкий символ символом пунктуации, т. Е. Является ли он одним из &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; Или любым другим символ пунктуации, специфичный для текущей локали.</target>
        </trans-unit>
        <trans-unit id="298e43db40ce5c6ddedf760c6d9d06385fec714f" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a whitespace character, i.e. either space (&lt;code&gt;0x20&lt;/code&gt;), form feed (&lt;code&gt;0x0c&lt;/code&gt;), line feed (&lt;code&gt;0x0a&lt;/code&gt;), carriage return (&lt;code&gt;0x0d&lt;/code&gt;), horizontal tab (&lt;code&gt;0x09&lt;/code&gt;), vertical tab (&lt;code&gt;0x0b&lt;/code&gt;) or any whitespace character specific to the current locale.</source>
          <target state="translated">Проверяет, является ли данный широкий символ пробельным символом, то есть пробел ( &lt;code&gt;0x20&lt;/code&gt; ), перевод формы ( &lt;code&gt;0x0c&lt;/code&gt; ), перевод строки ( &lt;code&gt;0x0a&lt;/code&gt; ), возврат каретки ( &lt;code&gt;0x0d&lt;/code&gt; ), горизонтальная табуляция ( &lt;code&gt;0x09&lt;/code&gt; ), вертикальная табуляция ( &lt;code&gt;0x0b&lt;/code&gt; ) или любые пробелы характерный для текущей локали.</target>
        </trans-unit>
        <trans-unit id="ecee395d873139c5f79bbced8e5ab2094298ef99" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an alphabetic character, i.e. either an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;) or any alphabetic character specific to the current locale.</source>
          <target state="translated">Проверяет, является ли данный широкий символ буквенным символом, то есть либо заглавной буквой ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), строчной буквой ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ), либо любым буквенным символом, характерным для текущей локали.</target>
        </trans-unit>
        <trans-unit id="5467527cb982943f926960fa171baeacafcc85de" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an alphanumeric character, i.e. either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;) or any alphanumeric character specific to the current locale.</source>
          <target state="translated">Проверяет, является ли данный широкий символ буквенно-цифровым символом, т. &lt;code&gt;0123456789&lt;/code&gt; ( 0123456789 ), заглавной буквой ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), строчной буквой ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ) или любым буквенно-цифровым символом, характерным для текущей локали.</target>
        </trans-unit>
        <trans-unit id="43c33322c3d3cfbcbf8bd68f060fd927a3eb782d" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an uppercase letter, i.e. one of &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; or any uppercase letter specific to the current locale.</source>
          <target state="translated">Проверяет, является ли данный широкий символ заглавной буквой, то есть &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; или любой заглавной буквой, характерной для текущей локали.</target>
        </trans-unit>
        <trans-unit id="1541b6076382859c29bdb454303ad0411f5bf188" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (&lt;code&gt;0x20&lt;/code&gt;) and horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) are blank characters.</source>
          <target state="translated">Проверяет, классифицируется ли данный широкий символ как пустой символ (то есть символ пробела, используемый для разделения слов в предложении) в текущей локали языка C. В локали C по умолчанию только пробел ( &lt;code&gt;0x20&lt;/code&gt; ) и горизонтальная табуляция ( &lt;code&gt;0x09&lt;/code&gt; ) являются пустыми символами.</target>
        </trans-unit>
        <trans-unit id="25148b32afeb099d72b04e72e49e95c2dd911646" translate="yes" xml:space="preserve">
          <source>Checks if the identifier was defined using &lt;a href=&quot;replace&quot;&gt;&lt;code&gt; #define&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">Проверяет, был ли идентификатор определен с помощью директивы &lt;a href=&quot;replace&quot;&gt; &lt;code&gt; #define&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="587976447f530aa6d25584b121ecdd151dbddd88" translate="yes" xml:space="preserve">
          <source>Checks the given stream for errors.</source>
          <target state="translated">Проверяет данный поток на наличие ошибок.</target>
        </trans-unit>
        <trans-unit id="2941dd6b2ef28d38e387c7f18e6f1d84f133699d" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; refer to the same thread.</source>
          <target state="translated">Проверяет, относятся ли &lt;code&gt;lhs&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; к одному и тому же потоку.</target>
        </trans-unit>
        <trans-unit id="34eb3f9df1785987205174d978835deeb45e94ad" translate="yes" xml:space="preserve">
          <source>Choose clang to observe the output shown.</source>
          <target state="translated">Выберите кланг,чтобы наблюдать за показанным выходом.</target>
        </trans-unit>
        <trans-unit id="94c2a3189e7f7885455350c4c7a8df2d0d6ad1d1" translate="yes" xml:space="preserve">
          <source>Classification</source>
          <target state="translated">Classification</target>
        </trans-unit>
        <trans-unit id="86c73ff296a69ebbcae03a6a87d277af954ca095" translate="yes" xml:space="preserve">
          <source>Classification and comparison</source>
          <target state="translated">Классификация и сравнение</target>
        </trans-unit>
        <trans-unit id="678a1418d0dca4dfa7d114655cc6c809563626e4" translate="yes" xml:space="preserve">
          <source>Classifies the wide character &lt;code&gt;wc&lt;/code&gt; using the current C locale's LC_CTYPE category identified by &lt;code&gt;desc&lt;/code&gt;.</source>
          <target state="translated">Классифицирует широкий символ &lt;code&gt;wc&lt;/code&gt; , используя категорию LC_CTYPE текущей локали C, обозначенную &lt;code&gt;desc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f846d9e8e5a959a36bfa1fbc2c8184ff034cead" translate="yes" xml:space="preserve">
          <source>Closes the given file stream. Any unwritten buffered data are flushed to the OS. Any unread buffered data are discarded.</source>
          <target state="translated">Закрывает данный поток файлов.Любые неписанные буферные данные прошиваются в операционную систему.Любые непрочитанные буферные данные отбрасываются.</target>
        </trans-unit>
        <trans-unit id="60ce571e9fd40583067484c63f2febcaa5424e29" translate="yes" xml:space="preserve">
          <source>Collation order is the dictionary order: the position of the letter in the national alphabet (its</source>
          <target state="translated">Порядок словарного перевода-порядок словарного перевода:положение буквы в национальном алфавите (его</target>
        </trans-unit>
        <trans-unit id="9f9c3302a6454b216eade45c792066892cae6eab" translate="yes" xml:space="preserve">
          <source>Colloquially known as</source>
          <target state="translated">в разговорной речи известный как</target>
        </trans-unit>
        <trans-unit id="b9ee3deaae2695cf53cbcebec20aed5fb9b594e3" translate="yes" xml:space="preserve">
          <source>Comma</source>
          <target state="translated">Comma</target>
        </trans-unit>
        <trans-unit id="b506b24efb6525b0ee356cf0162e2de834afe47c" translate="yes" xml:space="preserve">
          <source>Comma operator</source>
          <target state="translated">Оператор связи</target>
        </trans-unit>
        <trans-unit id="f9d837147551d84676f75bd72ce6ad24312cb2bd" translate="yes" xml:space="preserve">
          <source>Comma operator is not allowed in &lt;a href=&quot;constant_expression&quot;&gt;constant expressions&lt;/a&gt;, regardless of whether it's on the top level or not.</source>
          <target state="translated">Запятая не допускается в &lt;a href=&quot;constant_expression&quot;&gt;константных выражениях&lt;/a&gt; , независимо от того, находится ли он на верхнем уровне или нет.</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="77dc6eb02cb1c62d942bb34b9b074bf78c09d78f" translate="yes" xml:space="preserve">
          <source>Comments serve as a sort of in-code documentation. When inserted into a program, they are effectively ignored by the compiler; they are solely intended to be used as notes by the humans that read source code.</source>
          <target state="translated">Комментарии служат своего рода кодовой документацией.При вставке в программу они фактически игнорируются компилятором;они предназначены исключительно для использования в качестве заметок людьми,читающими исходный код.</target>
        </trans-unit>
        <trans-unit id="3058ce23e65f21dc5cbd24c26f57bcb910e0857c" translate="yes" xml:space="preserve">
          <source>Common macro definitions</source>
          <target state="translated">Общие макроопределения</target>
        </trans-unit>
        <trans-unit id="300b7ca7537f6f7e544d83703decea74261de072" translate="yes" xml:space="preserve">
          <source>Common mathematical functions</source>
          <target state="translated">Общие математические функции</target>
        </trans-unit>
        <trans-unit id="d05b85b9373c028c966baf6f72eacf6afdf95cd7" translate="yes" xml:space="preserve">
          <source>Common mathematics functions</source>
          <target state="translated">Общие математические функции</target>
        </trans-unit>
        <trans-unit id="044d38e8939c8f6fc027ea1c90729d6aca7109d3" translate="yes" xml:space="preserve">
          <source>Common operators</source>
          <target state="translated">Общие операторы</target>
        </trans-unit>
        <trans-unit id="ed62bc28035976769130c4128738e35c18c296a6" translate="yes" xml:space="preserve">
          <source>Communicating with the environment</source>
          <target state="translated">Общение с окружающей средой</target>
        </trans-unit>
        <trans-unit id="35e8aa2bb22045b3aaa2abc8b9c19086e5217942" translate="yes" xml:space="preserve">
          <source>Compares at most &lt;code&gt;count&lt;/code&gt; characters of two possibly null-terminated arrays. The comparison is done lexicographically.</source>
          <target state="translated">Сравнивает самое большее &lt;code&gt;count&lt;/code&gt; символов двух возможно нулевых массивов. Сравнение сделано лексикографически.</target>
        </trans-unit>
        <trans-unit id="0727eb4b9d940361cfe3eeafe56df0bb6ceff1b1" translate="yes" xml:space="preserve">
          <source>Compares at most &lt;code&gt;count&lt;/code&gt; wide characters of two null-terminated wide strings. The comparison is done lexicographically.</source>
          <target state="translated">Сравнивает не больше &lt;code&gt;count&lt;/code&gt; широкие символы двух завершающих нуль широких строк. Сравнение сделано лексикографически.</target>
        </trans-unit>
        <trans-unit id="a146ec971b1d93c0eca122d627ff96be93cae780" translate="yes" xml:space="preserve">
          <source>Compares different floating-point decomposition functions.</source>
          <target state="translated">Сравнивает различные функции разложения с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="505981e95799fb74b00a3bcd6545a539962db24a" translate="yes" xml:space="preserve">
          <source>Compares the first &lt;code&gt;count&lt;/code&gt; characters of the objects pointed to by &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. The comparison is done lexicographically.</source>
          <target state="translated">Сравнивает первые &lt;code&gt;count&lt;/code&gt; символов объектов, на которые указывают &lt;code&gt;lhs&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; . Сравнение сделано лексикографически.</target>
        </trans-unit>
        <trans-unit id="8081695a2902e2182377570f6d2fb36eb8232444" translate="yes" xml:space="preserve">
          <source>Compares the first &lt;code&gt;count&lt;/code&gt; wide characters of the wide character (or compatible integer type) arrays pointed to by &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. The comparison is done lexicographically.</source>
          <target state="translated">Сравнивает первые &lt;code&gt;count&lt;/code&gt; широких символов массивов широких символов (или совместимых целочисленных типов), на которые указывают &lt;code&gt;lhs&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; . Сравнение сделано лексикографически.</target>
        </trans-unit>
        <trans-unit id="0e00c63c41d94e64efbb2ed0a1eb306b8443cef2" translate="yes" xml:space="preserve">
          <source>Compares two null-terminated byte strings according to the current locale as defined by the &lt;code&gt;&lt;a href=&quot;../../locale/lc_categories&quot;&gt;LC_COLLATE&lt;/a&gt;&lt;/code&gt; category.</source>
          <target state="translated">Сравнивает две байтовые строки с нулевым символом в &lt;code&gt;&lt;a href=&quot;../../locale/lc_categories&quot;&gt;LC_COLLATE&lt;/a&gt;&lt;/code&gt; соответствии с текущей локалью, определенной категорией LC_COLLATE .</target>
        </trans-unit>
        <trans-unit id="3d96fd82bc5cfecc84e4ec5ba54d1dce1db99f1b" translate="yes" xml:space="preserve">
          <source>Compares two null-terminated byte strings lexicographically.</source>
          <target state="translated">Сравнивает лексикографически две строки нулевых байтов.</target>
        </trans-unit>
        <trans-unit id="15950bd77b78269b905c3c5c5ba78145e13631f4" translate="yes" xml:space="preserve">
          <source>Compares two null-terminated wide strings according to the collation order defined by the &lt;code&gt;&lt;a href=&quot;../../locale/lc_categories&quot;&gt;LC_COLLATE&lt;/a&gt;&lt;/code&gt; category of the currently installed locale.</source>
          <target state="translated">Сравнивает две широкие строки с нулевым символом в &lt;code&gt;&lt;a href=&quot;../../locale/lc_categories&quot;&gt;LC_COLLATE&lt;/a&gt;&lt;/code&gt; соответствии с порядком сортировки, определенным категорией LC_COLLATE текущей установленной локали.</target>
        </trans-unit>
        <trans-unit id="425c0ed5bb7057b86419e94b1e93f2ea4b7b2de1" translate="yes" xml:space="preserve">
          <source>Compares two null-terminated wide strings lexicographically.</source>
          <target state="translated">Лексикографически сравнивает две нуль-терминированные широкие строки.</target>
        </trans-unit>
        <trans-unit id="9461d4c9f916ad7df5538225ed552fb6e7e3284b" translate="yes" xml:space="preserve">
          <source>Comparison operators</source>
          <target state="translated">Операторы сравнения</target>
        </trans-unit>
        <trans-unit id="181e8d4d8e85dc949aeb0b7a2e7684136d886553" translate="yes" xml:space="preserve">
          <source>Comparison operators are binary operators that test a condition and return &lt;b&gt;1&lt;/b&gt; if that condition is logically &lt;b&gt;true&lt;/b&gt; and &lt;b&gt;0&lt;/b&gt; if that condition is &lt;b&gt;false&lt;/b&gt;.</source>
          <target state="translated">Операторы сравнения - это бинарные операторы, которые проверяют условие и возвращают &lt;b&gt;1,&lt;/b&gt; если это условие логически &lt;b&gt;верно,&lt;/b&gt; и &lt;b&gt;0,&lt;/b&gt; если это условие &lt;b&gt;ложно&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="580eefdb317ca1980517ce814ac757d8de1a082e" translate="yes" xml:space="preserve">
          <source>Compatible types</source>
          <target state="translated">Совместимые типы</target>
        </trans-unit>
        <trans-unit id="6e5b2b0dca46a4ad21f4296d9b1bc8179a4d98ec" translate="yes" xml:space="preserve">
          <source>Compilation takes place: the tokens are syntactically and semantically analyzed and translated as a translation unit.</source>
          <target state="translated">Компиляция происходит:лексемы синтаксически и семантически анализируются и переводятся как единица перевода.</target>
        </trans-unit>
        <trans-unit id="3b17b76f2f8c8bd9e9381ee9ce3fb90ff874e220" translate="yes" xml:space="preserve">
          <source>Complex and imaginary addition and subtraction are defined as follows (note the result type is imaginary if both operands are imaginary and complex if one operand is real and the other imaginary, as specified by the usual arithmetic conversions):</source>
          <target state="translated">Сложные и мнимые сложения и вычитания определяются следующим образом (обратите внимание,что тип результата является мнимым,если оба операнда являются мнимыми,и сложным,если один операнд является реальным,а другой мнимым,как указано в обычных арифметических превращениях):</target>
        </trans-unit>
        <trans-unit id="44dd33fc6270732559d77c0f49e48c52d2052437" translate="yes" xml:space="preserve">
          <source>Complex floating types</source>
          <target state="translated">Сложные плавающие типы</target>
        </trans-unit>
        <trans-unit id="9abb4134e20e54cbe39b6d903f1af3c82407a19d" translate="yes" xml:space="preserve">
          <source>Complex floating types model the mathematical &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;complex numbers&lt;/a&gt;, that is the numbers that can be written as a sum of a real number and a real number multiplied by the imaginary unit: a + bi.</source>
          <target state="translated">Сложные плавающие типы моделируют математические &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;комплексные числа&lt;/a&gt; , то есть числа, которые можно записать в виде суммы действительного числа и действительного числа, умноженного на мнимую единицу: a + bi.</target>
        </trans-unit>
        <trans-unit id="4dbbf2b2a08a0bd32712455c3831413cb3be33b6" translate="yes" xml:space="preserve">
          <source>Complex function</source>
          <target state="translated">Комплексная функция</target>
        </trans-unit>
        <trans-unit id="588968aece6ec2967902b0c8debd814af1beab35" translate="yes" xml:space="preserve">
          <source>Complex number arithmetic</source>
          <target state="translated">Сложная арифметика чисел</target>
        </trans-unit>
        <trans-unit id="c33f3e884f8ee47e82b79abb3d7ac7ecc6d16cf0" translate="yes" xml:space="preserve">
          <source>Complex numbers may be used with &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; + - * and /, possibly mixed with imaginary and real numbers. There are many mathematical functions defined for complex numbers in &lt;a href=&quot;../numeric/complex&quot;&gt;complex.h&lt;/a&gt;. Both built-in operators and library functions may raise floating-point exceptions and set &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; as described in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;&lt;code&gt;math_errhandling&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Комплексные числа могут использоваться с &lt;a href=&quot;operator_arithmetic&quot;&gt;арифметическими операторами&lt;/a&gt; + - * и /, возможно смешанными с мнимыми и действительными числами. Есть много математических функций, определенных для комплексных чисел в &lt;a href=&quot;../numeric/complex&quot;&gt;complex.h&lt;/a&gt; . Как встроенные операторы, так и библиотечные функции могут вызывать исключения с плавающей точкой и устанавливать &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; , как описано в &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt; &lt;code&gt;math_errhandling&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="986de770a77674f7fac27990f9489f0625e4e838" translate="yes" xml:space="preserve">
          <source>Complex type conversions</source>
          <target state="translated">Сложные преобразования типа</target>
        </trans-unit>
        <trans-unit id="c03daa5c814cb456a3684f1ad69e17b36c0d48db" translate="yes" xml:space="preserve">
          <source>Complex-imaginary conversions</source>
          <target state="translated">Сложно-воображаемые преобразования</target>
        </trans-unit>
        <trans-unit id="5881b1c904d7b7259dd04943175ea48e1e428f2b" translate="yes" xml:space="preserve">
          <source>Complex-only functions</source>
          <target state="translated">Комплексные функции</target>
        </trans-unit>
        <trans-unit id="c2380af577316c38820427372c14161206c8131e" translate="yes" xml:space="preserve">
          <source>Complex/real type-generic macros</source>
          <target state="translated">Сложные/реальные типы-генерические макросы</target>
        </trans-unit>
        <trans-unit id="537187710d8643593965aef2a7a923121f09907a" translate="yes" xml:space="preserve">
          <source>Composite types</source>
          <target state="translated">Типы композитов</target>
        </trans-unit>
        <trans-unit id="f1378b286398f88adfddc67ea372070620098f37" translate="yes" xml:space="preserve">
          <source>Compound assignment</source>
          <target state="translated">Назначение составных частей</target>
        </trans-unit>
        <trans-unit id="1f90e942ffc2b35ee9b3e4218cfd0172a5f1958a" translate="yes" xml:space="preserve">
          <source>Compound literal(C99)</source>
          <target state="translated">Составной буквенный(C99)</target>
        </trans-unit>
        <trans-unit id="9d48e2cbfc2e7a620861605b5a2d55bac9d2711b" translate="yes" xml:space="preserve">
          <source>Compound literals of const-qualified character or wide character array types may share storage with &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt;.</source>
          <target state="translated">Составные литералы символов с &lt;a href=&quot;string_literal&quot;&gt;константными&lt;/a&gt; символами или массивов широких символов могут совместно использовать хранилище со строковыми литералами .</target>
        </trans-unit>
        <trans-unit id="557ac2424c5366dd0727ffe7e7cd646b1ea065fd" translate="yes" xml:space="preserve">
          <source>Compound statements</source>
          <target state="translated">Составные отчёты</target>
        </trans-unit>
        <trans-unit id="181b2c5fdb89e27a6008d489d216495b9acd968b" translate="yes" xml:space="preserve">
          <source>Computes both the quotient and the remainder of the division of the numerator &lt;code&gt;x&lt;/code&gt; by the denominator &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Вычисляет как частное, так и остаток деления числителя &lt;code&gt;x&lt;/code&gt; на знаменатель &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9444ce94d568a16c9c8dae23ae1d2d6125ac8fc" translate="yes" xml:space="preserve">
          <source>Computes difference between two calendar times as &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; objects (&lt;code&gt;time_end - time_beg&lt;/code&gt;) in seconds. If &lt;code&gt;time_end&lt;/code&gt; refers to time point before &lt;code&gt;time_beg&lt;/code&gt; then the result is negative.</source>
          <target state="translated">Вычисляет разницу между двумя календарными временами как объекты &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;time_end - time_beg&lt;/code&gt; ) в секундах. Если &lt;code&gt;time_end&lt;/code&gt; ссылается на момент времени до &lt;code&gt;time_beg&lt;/code&gt; , то результат отрицательный.</target>
        </trans-unit>
        <trans-unit id="509eb0b7cc06400c9a23de5f72ecc0de165b85e5" translate="yes" xml:space="preserve">
          <source>Computes quotient and remainder simultaneously. The quotient is the algebraic quotient with any fractional part discarded (truncated towards zero). The remainder is such that &lt;code&gt;quot * y + rem == x&lt;/code&gt;.</source>
          <target state="translated">Вычисляет частное и остаток одновременно. Частное является алгебраическим частным с любой отброшенной дробной частью (усеченной до нуля). Остаток таков, что &lt;code&gt;quot * y + rem == x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fada816f8d77fb81d9ff5b692bd2596860aa718e" translate="yes" xml:space="preserve">
          <source>Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type.</source>
          <target state="translated">Вычисляет абсолютное значение целого числа.Поведение не определено,если результат не может быть представлен типом возврата.</target>
        </trans-unit>
        <trans-unit id="dca8bdeece135120987218c0e8c574bf0369c8f5" translate="yes" xml:space="preserve">
          <source>Computes the quotient (the result of the expression &lt;code&gt;x/y&lt;/code&gt;) and remainder (the result of the expression &lt;code&gt;x%y&lt;/code&gt;) simultaneously.</source>
          <target state="translated">Вычисляет частное (результат выражения &lt;code&gt;x/y&lt;/code&gt; ) и остаток (результат выражения &lt;code&gt;x%y&lt;/code&gt; ) одновременно.</target>
        </trans-unit>
        <trans-unit id="2f4979324e03e4571b1d7eba701226670c2ee2da" translate="yes" xml:space="preserve">
          <source>Condition</source>
          <target state="translated">Condition</target>
        </trans-unit>
        <trans-unit id="c9310d3b540cdb7701ecb54cf6be827f8499b99f" translate="yes" xml:space="preserve">
          <source>Condition variables</source>
          <target state="translated">Переменные условий</target>
        </trans-unit>
        <trans-unit id="6df92750a0f9ea5c7e0fdf367810b34c51dfc8b0" translate="yes" xml:space="preserve">
          <source>Conditional evaluation</source>
          <target state="translated">условная оценка</target>
        </trans-unit>
        <trans-unit id="ae382767cc8004ef63f077e5c30b8fcc609af876" translate="yes" xml:space="preserve">
          <source>Conditional inclusion</source>
          <target state="translated">Условное включение</target>
        </trans-unit>
        <trans-unit id="86d8c4f438a64027d9c179cbd6cac7228180ae16" translate="yes" xml:space="preserve">
          <source>Conditional operator</source>
          <target state="translated">Условный оператор</target>
        </trans-unit>
        <trans-unit id="f0e3da472ae92d2102d21d061ce57f244b5a5c0e" translate="yes" xml:space="preserve">
          <source>Conditional operator has right-to-left associativity, which allows chaining.</source>
          <target state="translated">Условный оператор имеет ассоциативность справа налево,что позволяет цепочки.</target>
        </trans-unit>
        <trans-unit id="a5c5b712f5b77396fc4520f5a9049d95172e4471" translate="yes" xml:space="preserve">
          <source>Conditionally compiled macro that compares its argument to zero</source>
          <target state="translated">Условно скомпилированный макрос,который сравнивает свой аргумент с нулем.</target>
        </trans-unit>
        <trans-unit id="1ce1caed837c07a48f6a88d0ea42bd39f49a6272" translate="yes" xml:space="preserve">
          <source>Conditionally executes code.</source>
          <target state="translated">Условно выполняет код.</target>
        </trans-unit>
        <trans-unit id="5829addbd65734c4f2d8dad3852c632235ce06d4" translate="yes" xml:space="preserve">
          <source>Configures the handler to be called by all &lt;a href=&quot;../error#Bounds_checking&quot;&gt;bounds-checked functions&lt;/a&gt; on a runtime constraint violation or restores the default handler (if &lt;code&gt;handler&lt;/code&gt; is a null pointer).</source>
          <target state="translated">Настраивает обработчик для вызова всеми &lt;a href=&quot;../error#Bounds_checking&quot;&gt;проверенными границами функций&lt;/a&gt; при нарушении ограничения времени выполнения или восстанавливает обработчик по умолчанию (если &lt;code&gt;handler&lt;/code&gt; является нулевым указателем).</target>
        </trans-unit>
        <trans-unit id="24dbea7a3dbb1c93c581fc08dcbaae936c7b5b98" translate="yes" xml:space="preserve">
          <source>Conformance</source>
          <target state="translated">Conformance</target>
        </trans-unit>
        <trans-unit id="733fd2b4c4e1bca4c7d0e3c2e1c341bcd1d34269" translate="yes" xml:space="preserve">
          <source>Constant</source>
          <target state="translated">Constant</target>
        </trans-unit>
        <trans-unit id="01f3d0f48081336b622122d8a98fa589e08cae6c" translate="yes" xml:space="preserve">
          <source>Constant expressions</source>
          <target state="translated">Постоянные выражения</target>
        </trans-unit>
        <trans-unit id="b1b91cf185f43f995ea5e1bbd7b583d233b1e42c" translate="yes" xml:space="preserve">
          <source>Constant values of certain types may be embedded in the source code of a C program using specialized expressions known as literals (for lvalue expressions) and constants (for non-lvalue expressions).</source>
          <target state="translated">Постоянные значения определенных типов могут быть встроены в исходный код программы на языке Си с использованием специализированных выражений,известных как литералы (для выражений значений)и константы (для не-значимых выражений).</target>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="translated">Constants</target>
        </trans-unit>
        <trans-unit id="87c4159a742ed8e414ffd5bae72f84a5d574be41" translate="yes" xml:space="preserve">
          <source>Constants and literals</source>
          <target state="translated">Константы и буквы</target>
        </trans-unit>
        <trans-unit id="625f65880cedb4712e1d5945dc325c138ae5abe2" translate="yes" xml:space="preserve">
          <source>Constructs a value of type &lt;code&gt;wctrans_t&lt;/code&gt; that describes a LC_CTYPE category of wide character mapping. It may be one of the standard mappings, or a locale-specific mapping, such as &lt;code&gt;&quot;tojhira&quot;&lt;/code&gt; or &lt;code&gt;&quot;tojkana&quot;&lt;/code&gt;.</source>
          <target state="translated">Создает значение типа &lt;code&gt;wctrans_t&lt;/code&gt; , которое описывает категорию LC_CTYPE отображения широких символов. Это может быть одно из стандартных сопоставлений или сопоставление для конкретной локали, такое как &lt;code&gt;&quot;tojhira&quot;&lt;/code&gt; или &lt;code&gt;&quot;tojkana&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccc1814324121e43fbfd9c7fd0178bbe7dcfb1f9" translate="yes" xml:space="preserve">
          <source>Constructs a value of type &lt;code&gt;wctype_t&lt;/code&gt; that describes a LC_CTYPE category of wide character classification. It may be one of the standard classification categories, or a locale-specific category, such as &lt;code&gt;&quot;jkanji&quot;&lt;/code&gt;.</source>
          <target state="translated">Создает значение типа &lt;code&gt;wctype_t&lt;/code&gt; , которое описывает категорию LC_CTYPE классификации широких символов. Это может быть одна из стандартных классификационных категорий или специфичная для локали категория, такая как &lt;code&gt;&quot;jkanji&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0c8168c0cfbada2990dd2ad8b3fe0fafbfb373f" translate="yes" xml:space="preserve">
          <source>Constructs an unnamed object of specified character array type in-place, used when a character string needs to be embedded in source code.</source>
          <target state="translated">Конструирует безымянный объект указанного типа символьного массива на месте,используемый,когда символьная строка должна быть встроена в исходный код.</target>
        </trans-unit>
        <trans-unit id="7144d435c6f6eed65fdfb01892ed2517b9a5f780" translate="yes" xml:space="preserve">
          <source>Constructs an unnamed object of specified type in-place, used when a variable of array, struct, or union type would be needed only once.</source>
          <target state="translated">Конструирует безымянный объект указанного типа на месте,используемый,когда переменная типа массив,структура или объединение нужны только один раз.</target>
        </trans-unit>
        <trans-unit id="94ba0441a632d1d40b442b189f4d839da4c6f833" translate="yes" xml:space="preserve">
          <source>Convenience macro which can be used to specify that an object has &lt;a href=&quot;../language/storage_duration&quot;&gt;thread-local storage duration&lt;/a&gt;.</source>
          <target state="translated">Удобный макрос, который можно использовать для указания того, что объект имеет &lt;a href=&quot;../language/storage_duration&quot;&gt;локальную продолжительность потока&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9151f8433f795cb0f0b5b6743aeb7de77ec49f00" translate="yes" xml:space="preserve">
          <source>Conversion</source>
          <target state="translated">Conversion</target>
        </trans-unit>
        <trans-unit id="c984c12517b0136cf8b6803f48a375cfb48f60b5" translate="yes" xml:space="preserve">
          <source>Conversion as if by assignment</source>
          <target state="translated">Преобразование как по назначению</target>
        </trans-unit>
        <trans-unit id="5980eba8f0b4f2f1cc9d2b0ed71af9f29a9903b9" translate="yes" xml:space="preserve">
          <source>Conversion of a value of any type to any &lt;a href=&quot;types#Compatible_types&quot;&gt;compatible type&lt;/a&gt; is always a no-op and does not change the representation.</source>
          <target state="translated">Преобразование значения любого типа в любой &lt;a href=&quot;types#Compatible_types&quot;&gt;совместимый тип&lt;/a&gt; всегда не допускается и не меняет представление.</target>
        </trans-unit>
        <trans-unit id="b08eaadf77cfdba7944ddcaf69eee5a983b74af3" translate="yes" xml:space="preserve">
          <source>Conversions</source>
          <target state="translated">Conversions</target>
        </trans-unit>
        <trans-unit id="78181f4b075c67c1b93d70dd04f6600b3ede87c6" translate="yes" xml:space="preserve">
          <source>Conversions between pointers and integers (except from pointer to _Bool and from integer constant expression with the value zero to pointer), between pointers to objects (except where either to or from is a pointer to void) and conversions between pointers to functions (except when the functions have compatible types) are never implicit and require a &lt;a href=&quot;cast&quot;&gt;cast operator&lt;/a&gt;.</source>
          <target state="translated">Преобразования между указателями и целыми числами (за исключением указателя на _Bool и из целочисленного константного выражения со значением от нуля до указателя), между указателями на объекты (за исключением случаев, когда указатель на void или от него является указателем на пустоту) и преобразования между указателями на функции (кроме случаев, когда функции имеют совместимые типы) никогда не являются неявными и требуют &lt;a href=&quot;cast&quot;&gt;оператора приведения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82a308da2fa6926a6b6c6dd2f205fd8788bcad75" translate="yes" xml:space="preserve">
          <source>Conversions take place in the following situations:</source>
          <target state="translated">Преобразование происходит в следующих ситуациях:</target>
        </trans-unit>
        <trans-unit id="b33060b95c6156e56397175f292d4d45c6d6b5b4" translate="yes" xml:space="preserve">
          <source>Conversions to numeric formats</source>
          <target state="translated">Преобразование в числовые форматы</target>
        </trans-unit>
        <trans-unit id="69cac274e6b28bb335c35746d6cf8b2fc73bbb4f" translate="yes" xml:space="preserve">
          <source>Converts a multibyte character whose first byte is pointed to by &lt;code&gt;s&lt;/code&gt; to a wide character, written to &lt;code&gt;*pwc&lt;/code&gt; if &lt;code&gt;pwc&lt;/code&gt; is not null.</source>
          <target state="translated">Преобразует многобайтовый символ, первый байт которого указан символом &lt;code&gt;s&lt;/code&gt; , в широкий символ, записываемый в &lt;code&gt;*pwc&lt;/code&gt; , если &lt;code&gt;pwc&lt;/code&gt; не равен нулю.</target>
        </trans-unit>
        <trans-unit id="f7e9a446c5b84278a0ced9cb286227ee420c1a0a" translate="yes" xml:space="preserve">
          <source>Converts a narrow multibyte character to its wide character representation.</source>
          <target state="translated">Преобразовывает узкий многобайтовый символ в его широкое представление.</target>
        </trans-unit>
        <trans-unit id="7438601c837acb2baa4f7b08761be638767a0fb4" translate="yes" xml:space="preserve">
          <source>Converts a single code point from its narrow multibyte character representation to its variable-length 16-bit wide character representation (typically, UTF-16).</source>
          <target state="translated">Преобразовывает единственную точку кода из узкого многобайтового символьного представления в 16-битовое символьное представление переменной длины (обычно UTF-16).</target>
        </trans-unit>
        <trans-unit id="0ffd99b88e90d43a9dbbf14daf8d8252d500de2c" translate="yes" xml:space="preserve">
          <source>Converts a single code point from its narrow multibyte character representation to its variable-length 32-bit wide character representation (but typically, UTF-32).</source>
          <target state="translated">Преобразовывает единственную точку кода из узкого многобайтового символьного представления в 32-битовое символьное представление переменной длины (но,как правило,UTF-32).</target>
        </trans-unit>
        <trans-unit id="cb96eb234a6e56a369a809859f2f3dd01677ca1d" translate="yes" xml:space="preserve">
          <source>Converts a single code point from its variable-length 16-bit wide character representation (typically, UTF-16) to its narrow multibyte character representation.</source>
          <target state="translated">Преобразовывает единственную точку кода из 16-разрядного символьного представления переменной длины (обычно UTF-16)в узкое многобайтовое символьное представление.</target>
        </trans-unit>
        <trans-unit id="d96f0b90ea4f0c064b3c16639100cb4890c75aa0" translate="yes" xml:space="preserve">
          <source>Converts a single code point from its variable-length 32-bit wide character representation (but typically, UTF-32) to its narrow multibyte character representation.</source>
          <target state="translated">Преобразовывает единственную точку кода из ее 32-битного символьного представления переменной длины (но,как правило,UTF-32)в узкое многобайтовое символьное представление.</target>
        </trans-unit>
        <trans-unit id="712188da508186849026fb3c8bd4c53083239bd2" translate="yes" xml:space="preserve">
          <source>Converts a wide character to its narrow multibyte representation.</source>
          <target state="translated">Преобразует широкий символ в его узкое многобайтовое представление.</target>
        </trans-unit>
        <trans-unit id="20aba8933b1ce3e51b50d19af2bb5cd6151f383b" translate="yes" xml:space="preserve">
          <source>Converts the date and time information from a given calendar time &lt;code&gt;time&lt;/code&gt; to a null-terminated multibyte character string &lt;code&gt;str&lt;/code&gt; according to format string &lt;code&gt;format&lt;/code&gt;. Up to &lt;code&gt;count&lt;/code&gt; bytes are written.</source>
          <target state="translated">Преобразует информацию о дате и времени от заданного календарного времени &lt;code&gt;time&lt;/code&gt; на многобайтовой символьной строку с завершающим нулем &lt;code&gt;str&lt;/code&gt; соответствии с форматом строка &lt;code&gt;format&lt;/code&gt; . До &lt;code&gt;count&lt;/code&gt; байтов написано.</target>
        </trans-unit>
        <trans-unit id="84c9055ae6194fffb1394c02ee65a491c7f3c9ac" translate="yes" xml:space="preserve">
          <source>Converts the date and time information from a given calendar time &lt;code&gt;time&lt;/code&gt; to a null-terminated wide character string &lt;code&gt;str&lt;/code&gt; according to format string &lt;code&gt;format&lt;/code&gt;. Up to &lt;code&gt;count&lt;/code&gt; bytes are written.</source>
          <target state="translated">Преобразует информацию о дате и времени от заданного календарного времени &lt;code&gt;time&lt;/code&gt; для широкой символьной строки с завершающим нулем &lt;code&gt;str&lt;/code&gt; соответствии с форматом строка &lt;code&gt;format&lt;/code&gt; . До &lt;code&gt;count&lt;/code&gt; байтов написано.</target>
        </trans-unit>
        <trans-unit id="519b80c3038fd902484f3879ce4d6e40b47a488a" translate="yes" xml:space="preserve">
          <source>Converts the given character to lowercase according to the character conversion rules defined by the currently installed C locale.</source>
          <target state="translated">Преобразовывает данный символ в нижний регистр в соответствии с правилами преобразования символов,определенными текущей установленной локалью C.</target>
        </trans-unit>
        <trans-unit id="f569145b51d5c5bd1a8f3f9cda6c230ee4a033fa" translate="yes" xml:space="preserve">
          <source>Converts the given character to uppercase according to the character conversion rules defined by the currently installed C locale.</source>
          <target state="translated">Преобразовывает данный символ в верхний регистр в соответствии с правилами преобразования символов,определенными текущей установленной локалью C.</target>
        </trans-unit>
        <trans-unit id="4e2c2190b4ebc6c640c23909d4015a7b7c92b75c" translate="yes" xml:space="preserve">
          <source>Converts the given wide character to lowercase, if possible.</source>
          <target state="translated">По возможности преобразует данный широкий символ в нижний регистр.</target>
        </trans-unit>
        <trans-unit id="9a302cdd09a562f6faf8a71da6652ad5c7071026" translate="yes" xml:space="preserve">
          <source>Converts the given wide character to uppercase, if possible.</source>
          <target state="translated">По возможности преобразует данный широкий символ в заглавный.</target>
        </trans-unit>
        <trans-unit id="379c410318b1052040824f4b78e1f453a2e061b8" translate="yes" xml:space="preserve">
          <source>Converts the implementation-defined character string &lt;code&gt;arg&lt;/code&gt; into the corresponding quiet NaN value, as if by calling &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtof&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtold&lt;/a&gt;&lt;/code&gt;, respectively, as follows:</source>
          <target state="translated">Преобразует определенную реализацией символьную строку &lt;code&gt;arg&lt;/code&gt; в соответствующее тихое значение NaN, как если бы, соответственно, вызывая &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtof&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtold&lt;/a&gt;&lt;/code&gt; , следующим образом:</target>
        </trans-unit>
        <trans-unit id="d3125c64cd58a8e8c4a1e00a8a7f5cca65c1f3db" translate="yes" xml:space="preserve">
          <source>Copies the wide character &lt;code&gt;ch&lt;/code&gt; into each of the first &lt;code&gt;count&lt;/code&gt; wide characters of the wide character array (or integer array of compatible type) pointed to by &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">Копирует широкий символ &lt;code&gt;ch&lt;/code&gt; в каждый из первых широких символов &lt;code&gt;count&lt;/code&gt; массива широких символов (или целочисленного массива совместимого типа), на который указывает &lt;code&gt;dest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1a972dceff401c8f705084b99291771aca6d4f0" translate="yes" xml:space="preserve">
          <source>Corresponding bit fields must have the same widths.</source>
          <target state="translated">Соответствующие битовые поля должны иметь одинаковую ширину.</target>
        </trans-unit>
        <trans-unit id="c7655b56c64b8e8974eef2a42e2f7caf3220ca70" translate="yes" xml:space="preserve">
          <source>Corresponding members must be declared in the same order (structures only)</source>
          <target state="translated">Члены-корреспонденты должны быть объявлены в том же порядке (только структуры).</target>
        </trans-unit>
        <trans-unit id="6ee0a78dc7e88cdbfe34cb24cb35cc308d3ce55a" translate="yes" xml:space="preserve">
          <source>Create a file for read/write</source>
          <target state="translated">Создать файл для чтения/записи</target>
        </trans-unit>
        <trans-unit id="3f00954c254e5e03c34d4c5d0355138a84dcbd5e" translate="yes" xml:space="preserve">
          <source>Create a file for writing</source>
          <target state="translated">Создать файл для записи</target>
        </trans-unit>
        <trans-unit id="d7fab829ef004b63b0ae817164eec26b76e27830" translate="yes" xml:space="preserve">
          <source>Creates a new mutex object with &lt;code&gt;type&lt;/code&gt;. The object pointed to by &lt;code&gt;mutex&lt;/code&gt; is set to an identifier of the newly created mutex.</source>
          <target state="translated">Создает новый объект мьютекса с &lt;code&gt;type&lt;/code&gt; . Объект, на который указывает &lt;code&gt;mutex&lt;/code&gt; , устанавливается как идентификатор вновь созданного мьютекса.</target>
        </trans-unit>
        <trans-unit id="9b06bf69a45cd02d25cf20b979aa35310bf22a78" translate="yes" xml:space="preserve">
          <source>Creates a new thread executing the function &lt;code&gt;func&lt;/code&gt;. The function is invoked as &lt;code&gt;func(arg)&lt;/code&gt;.</source>
          <target state="translated">Создает новый поток, выполняющий функцию &lt;code&gt;func&lt;/code&gt; . Функция вызывается как &lt;code&gt;func(arg)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="571e4e2856d60889cd6291a7b577569ac1fb4093" translate="yes" xml:space="preserve">
          <source>Creates new thread-specific storage key and stores it in the object pointed to by &lt;code&gt;tss_key&lt;/code&gt;. Although the same key value may be used by different threads, the values bound to the key by &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt; are maintained on a per-thread basis and persist for the life of the calling thread.</source>
          <target state="translated">Создает новый специфичный для потока ключ хранения и сохраняет его в объекте, указанном параметром &lt;code&gt;tss_key&lt;/code&gt; . Хотя одно и то же значение ключа может использоваться разными потоками, значения, связанные с ключом с помощью &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt; , сохраняются для каждого потока и сохраняются в течение всего срока жизни вызывающего потока.</target>
        </trans-unit>
        <trans-unit id="b3301d9d8a5f4cade27f8ed51c3e2eb33faf2bb3" translate="yes" xml:space="preserve">
          <source>Critical UB is undefined behavior that might perform a memory write or a volatile memory read out of bounds of any object. A program that has critical undefined behavior may be susceptible to security exploits.</source>
          <target state="translated">Критический UB-это неопределенное поведение,которое может привести к записи в память или к нестабильному объему памяти,считываемой за пределами любого объекта.Программа с критическим неопределенным поведением может быть восприимчива к эксплойтам безопасности.</target>
        </trans-unit>
        <trans-unit id="48d3d0e79fd065ba50641549dc0f31bdbbbabe14" translate="yes" xml:space="preserve">
          <source>Critical undefined behavior</source>
          <target state="translated">Критическое неопределённое поведение</target>
        </trans-unit>
        <trans-unit id="cde75a84c505736a639dce4f3db8eb94d6550d9e" translate="yes" xml:space="preserve">
          <source>Current calendar time encoded as &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; object on success, &lt;code&gt;(&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;)(-1)&lt;/code&gt; on error. If &lt;code&gt;arg&lt;/code&gt; is not a null pointer, the return value is also stored in the object pointed to by &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">Текущее календарное время, закодированное как объект &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; в случае успеха, &lt;code&gt;(&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;)(-1)&lt;/code&gt; в случае ошибки. Если &lt;code&gt;arg&lt;/code&gt; не является нулевым указателем, возвращаемое значение также сохраняется в объекте, на который указывает &lt;code&gt;arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1a550d08342a0a1a6248c5f115bf82d6658049a" translate="yes" xml:space="preserve">
          <source>D within thread 2, nothing prevents D from appearing before A in the modification order of y, and B from appearing before C in the modification order of x. The side-effect of D on y could be visible to the load A in thread 1 while the side effect of B on x could be visible to the load C in thread 2. In particular, this may occur if D is completed before C in thread 2, either due to compiler reordering or at runtime.</source>
          <target state="translated">D внутри резьбы 2 ничто не мешает D появляться перед A в порядке модификации y,а B перед C в порядке модификации x.Побочный эффект D на y может быть виден нагрузке A в резьбе 1,в то время как побочный эффект B на x может быть виден нагрузке C в резьбе 2.В частности,это может произойти,если D будет завершена перед C в потоке 2,либо из-за переупорядочивания компилятора,либо во время выполнения.</target>
        </trans-unit>
        <trans-unit id="12130df9add30c0ad6c8facc749f7941f22cb5a0" translate="yes" xml:space="preserve">
          <source>DECIMAL_DIG</source>
          <target state="translated">DECIMAL_DIG</target>
        </trans-unit>
        <trans-unit id="2d1df1e76038d57ea00e3dd0686a5e2fe8b90691" translate="yes" xml:space="preserve">
          <source>Data models</source>
          <target state="translated">Модели данных</target>
        </trans-unit>
        <trans-unit id="cedc7364b9c54060c8937af16ca1f7f300c926d1" translate="yes" xml:space="preserve">
          <source>Data read in from a text stream is guaranteed to compare equal to the data that were earlier written out to that stream only if all of the following is true:</source>
          <target state="translated">Данные,прочитанные из текстового потока,гарантированно сравниваются с данными,которые были ранее записаны в этот поток только в том случае,если все нижеследующее верно:</target>
        </trans-unit>
        <trans-unit id="07c9c3a5e0d97aef72f69b7e5ba94a6765f2a6d3" translate="yes" xml:space="preserve">
          <source>Date and time</source>
          <target state="translated">Дата и время</target>
        </trans-unit>
        <trans-unit id="5b0b556cd60211a5522983788620b6746c7543cf" translate="yes" xml:space="preserve">
          <source>Date and time utilities</source>
          <target state="translated">Дата и время коммунальные услуги</target>
        </trans-unit>
        <trans-unit id="a2dfedeffd1ead187411349e305b1fe627303452" translate="yes" xml:space="preserve">
          <source>Day of the week</source>
          <target state="translated">День недели</target>
        </trans-unit>
        <trans-unit id="1efe459545896a080ea552260e3ba2caa4f8d75e" translate="yes" xml:space="preserve">
          <source>Day of the year/month</source>
          <target state="translated">День года/месяц</target>
        </trans-unit>
        <trans-unit id="8fa7848b2be3ca4b1659ed978010f39a06d41489" translate="yes" xml:space="preserve">
          <source>Daylight Saving Time flag. The value is positive if DST is in effect, zero if not and negative if no information is available</source>
          <target state="translated">Флаг летнего времени.Значение положительное,если DST действует,нулевое,если нет,и отрицательное,если информация недоступна.</target>
        </trans-unit>
        <trans-unit id="d3e6f22a4ad377eca5934960c8545c3f833b1707" translate="yes" xml:space="preserve">
          <source>Deallocates the space previously allocated by &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;calloc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;aligned_alloc&lt;/code&gt;,(since C11) or &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Распределяет пространство, ранее выделенное с помощью &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;calloc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;aligned_alloc&lt;/code&gt; , (начиная с C11) или &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9b846963186dedc9a34aab11fab9a0a092e2d1b" translate="yes" xml:space="preserve">
          <source>Declarations</source>
          <target state="translated">Declarations</target>
        </trans-unit>
        <trans-unit id="749ccabedd0701c0c9714d9c1cdd4f12526e6e72" translate="yes" xml:space="preserve">
          <source>Declarations may appear in any scope. Each declaration ends with a semicolon (just like &lt;a href=&quot;statements&quot;&gt;a statement&lt;/a&gt;) and consists of two distinct parts:</source>
          <target state="translated">Объявления могут появляться в любом объеме. Каждое объявление заканчивается точкой с запятой (точно так же как &lt;a href=&quot;statements&quot;&gt;утверждение&lt;/a&gt; ) и состоит из двух отдельных частей:</target>
        </trans-unit>
        <trans-unit id="498a79c2f403d3ef0ef459653265dbe039de60f8" translate="yes" xml:space="preserve">
          <source>Declarations of any variably-modified types may appear only at &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt; or function prototype scope and cannot be members of structs or unions. Although &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt; can only have automatic &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;, a VM type such as a pointer to a VLA may be static. There are other restrictions on the use of VM types, see &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;, &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt;. &lt;code&gt;&lt;a href=&quot;../program/longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Объявления любых изменяемых типов могут появляться только в области &lt;a href=&quot;scope&quot;&gt;блока&lt;/a&gt; или в области прототипа функции и не могут быть членами структур или объединений. Хотя &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt; может иметь только автоматическую &lt;a href=&quot;storage_duration&quot;&gt;продолжительность хранения&lt;/a&gt; , тип виртуальной машины, такой как указатель на VLA, может быть статическим. Существуют и другие ограничения на использование типов виртуальных машин, см. &lt;a href=&quot;goto&quot;&gt;Goto&lt;/a&gt; , &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt; . &lt;code&gt;&lt;a href=&quot;../program/longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65fb5fdee4b95dce48f2a6be467d4b66c9cfaed7" translate="yes" xml:space="preserve">
          <source>Declarations of objects &lt;a href=&quot;storage_duration&quot;&gt;with linkage&lt;/a&gt; (external or internal) can be repeated:</source>
          <target state="translated">Объявления объектов &lt;a href=&quot;storage_duration&quot;&gt;со связью&lt;/a&gt; (внешней или внутренней) могут повторяться:</target>
        </trans-unit>
        <trans-unit id="50dd433317470a03afe915a58adaf99026617f03" translate="yes" xml:space="preserve">
          <source>Declarations with external linkage are commonly made available in header files so that all translation units that &lt;a href=&quot;../preprocessor/include&quot;&gt;#include&lt;/a&gt; the file may refer to the same identifier that are defined elsewhere.</source>
          <target state="translated">Объявления с внешней связью обычно делаются доступными в заголовочных файлах, так что все единицы перевода, которые &lt;a href=&quot;../preprocessor/include&quot;&gt;#include&lt;/a&gt; в файл, могут ссылаться на тот же идентификатор, который определен в другом месте.</target>
        </trans-unit>
        <trans-unit id="2487e41670058d63f8493da3e66e37364b0bb53c" translate="yes" xml:space="preserve">
          <source>Declarators</source>
          <target state="translated">Declarators</target>
        </trans-unit>
        <trans-unit id="a438543b4e82bf4692dd52fa11185961f695d7cf" translate="yes" xml:space="preserve">
          <source>Declares a member with explicit width, in bits. Adjacent bit field members may be packed to share and straddle the individual bytes.</source>
          <target state="translated">Объявляет члена с явной шириной,в битах.Соседние члены битового поля могут быть упакованы для совместного использования и обвязки отдельных байтов.</target>
        </trans-unit>
        <trans-unit id="b76d52d6a4f58b1756dbf7dc7ed7c25dc32036e0" translate="yes" xml:space="preserve">
          <source>Declares an &lt;a href=&quot;https://en.wikipedia.org/wiki/inline_function&quot;&gt;inline function&lt;/a&gt;.</source>
          <target state="translated">Объявляет &lt;a href=&quot;https://en.wikipedia.org/wiki/inline_function&quot;&gt;встроенную функцию&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="479af35b0f110787bdde80cea52483776eb082c3" translate="yes" xml:space="preserve">
          <source>Default &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;rounding direction&lt;/a&gt; and &lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;precision&lt;/a&gt; are in effect when the floating constants are converted into internal representations, and &lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;floating-point exceptions&lt;/a&gt; are not raised even if &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt;&lt;/a&gt; is in effect (for execution-time conversion of character strings, &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt; can be used). Note that this differs from &lt;a href=&quot;constant_expression&quot;&gt;arithmetic constant expressions&lt;/a&gt; of floating type.</source>
          <target state="translated">&lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;Направление&lt;/a&gt; и &lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;точность &lt;/a&gt;округления по умолчанию действуют, когда плавающие константы преобразуются во внутренние представления, а &lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;исключения с плавающей точкой&lt;/a&gt; не &lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt; &lt;/a&gt; даже если действует #pragma STDC FENV_ACCESS (для преобразования строки символов во время выполнения может использоваться &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt; ) , Обратите внимание, что это отличается от &lt;a href=&quot;constant_expression&quot;&gt;арифметических константных выражений&lt;/a&gt; плавающего типа.</target>
        </trans-unit>
        <trans-unit id="21463b49a73f80192975053d7c51b6766c28139a" translate="yes" xml:space="preserve">
          <source>Default argument promotions</source>
          <target state="translated">Промо-акции с аргументами по умолчанию</target>
        </trans-unit>
        <trans-unit id="d51786c7e25b0e6dca93c44db2e6620c91b5706f" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53b12cc0a64e5997f555f4552d8c0f5a1798ae66" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="90f2a795c1a351609a312fd95460d08cf184bd87" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b76614d13fbb267406c567200d837b24b3fde09b" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80bf26c3624bf6ce9697ecba933de914daf63a5a" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd9bc4c7f48e74e44b5198fbf6ade033d2ef3214" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9c7c1c3d49935948c03fc2e9d9fd5cb0acf7b6e" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5df25381e8feefe92fdd8b28465b19ae2f4972c" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ad2bbe9040c61764f1bfc89807c753f787521d0" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="acbd16aaad15089951f12b998aa7ea0853e93e93" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7025b36c2c07b19a8d8e66c935fb4f80ce6c1685" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="705fca3e55ebf8cbefec135f8a856278153e2ce5" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ecd6850fd735cc0f8846abbf1075afdf10ec94f2" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53031c947e0190bfa35551ccad1808f03a3dc551" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="245dc9819128f99f4333f72f1e35680c85852dbb" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e2f62efdddd63721d81b871af155dbbf79a1a53" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2bd2583ed48877fab6813145157134c03b0da7df" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b70a61b2efac85d947d63495a0dbd17f5e7eb999" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b92b8bfeac671700e767b6a63a2a1467e903324" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f4d9d59d3d7d5aef5cc1ea4c46ea799408a374d" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="521fccfa0e87c453cf2e8f167e2684f7ed7209d0" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f5fa73f7f3a4335015f1f23a0732c950803d482b" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bbdc0981bd66c81cf104210dcd830723ba381c4" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="555423c73974a949e00ecd09ae4522ff177b6ba3" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4048cff46ea43962575dde93962f1b588433080f" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6dfcc0c8bd903cf2bdcde1e66a702128ff94fbfa" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;uchar.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;uchar.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ecb0715cadd781ce84b451ce8e4acdd4dc7d0232" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb6e4f42471d8124c8cf9d17dd195e977e3849ff" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Определено в заголовке &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab42660565c96e634b99d6325eb1b11da87c3efc" translate="yes" xml:space="preserve">
          <source>Defines the semantics of computer memory storage for the purpose of the C abstract machine.</source>
          <target state="translated">Определяет семантику хранения памяти компьютера для целей абстрактной машины С.</target>
        </trans-unit>
        <trans-unit id="bf1be2b7ad07bae2fe92475d10173eb638774def" translate="yes" xml:space="preserve">
          <source>Definition</source>
          <target state="translated">Definition</target>
        </trans-unit>
        <trans-unit id="15225baac48fc3d689cb2b0f74b936eff4339ff7" translate="yes" xml:space="preserve">
          <source>Definitions</source>
          <target state="translated">Definitions</target>
        </trans-unit>
        <trans-unit id="b9f352ac1857e844fd93783413696f5ee3b91411" translate="yes" xml:space="preserve">
          <source>Definitions of functions include sequences of &lt;a href=&quot;statements&quot;&gt;statements&lt;/a&gt; and &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;, some of which include &lt;a href=&quot;expressions&quot;&gt;expressions&lt;/a&gt;, which specify the computations to be performed by the program.</source>
          <target state="translated">Определения функций включают в себя последовательности &lt;a href=&quot;statements&quot;&gt;операторов&lt;/a&gt; и &lt;a href=&quot;declarations&quot;&gt;объявлений&lt;/a&gt; , некоторые из которых включают &lt;a href=&quot;expressions&quot;&gt;выражения&lt;/a&gt; , которые определяют вычисления, которые должны выполняться программой.</target>
        </trans-unit>
        <trans-unit id="d5c2f3b1691c162974666c6b32fe851f22334bf1" translate="yes" xml:space="preserve">
          <source>Deletes the file identified by character string pointed to by &lt;code&gt;fname&lt;/code&gt;.</source>
          <target state="translated">Удаляет файл, идентифицируемый символьной строкой, на которую указывает &lt;code&gt;fname&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6821f0c7515e1af2b09d1caee8e7ee8be55d23ff" translate="yes" xml:space="preserve">
          <source>Demonstrates how to inform a program about where to find its input and where to write its results. Invocation: ./a.out indatafile outdatafile.</source>
          <target state="translated">Демонстрирует,как проинформировать программу о том,где найти ее данные и где записать ее результаты.Приглашение:./a.out indatafile outdatafile.</target>
        </trans-unit>
        <trans-unit id="107363e042b2a4793f67270f98d3c7305ba956f9" translate="yes" xml:space="preserve">
          <source>Demonstrates the use of isalnum() with different locales (OS-specific).</source>
          <target state="translated">Демонстрирует использование isalnum()с различными локалями (специфичными для ОС).</target>
        </trans-unit>
        <trans-unit id="8bec99b36261ae64217d042ec118a2c264d9ce33" translate="yes" xml:space="preserve">
          <source>Demonstrates the use of isalpha() with different locales (OS-specific).</source>
          <target state="translated">Демонстрирует использование isalpha()с различными локалями (специфичными для ОС).</target>
        </trans-unit>
        <trans-unit id="7b2ffabd65a5c6d55404aee122640dc7ff1e1395" translate="yes" xml:space="preserve">
          <source>Depending on the computer architecture, a &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte&quot;&gt;byte&lt;/a&gt; may consist of 8 or more bits, the exact number provided as &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В зависимости от архитектуры компьютера &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte&quot;&gt;байт&lt;/a&gt; может состоять из 8 или более битов, точное число &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt; как CHAR_BIT .</target>
        </trans-unit>
        <trans-unit id="dec3b6d46e827cc481476ff03cd71af78767baf0" translate="yes" xml:space="preserve">
          <source>Dereference</source>
          <target state="translated">Dereference</target>
        </trans-unit>
        <trans-unit id="b61f3c0aeb3cddcd6eafde1041344977a1b7e38d" translate="yes" xml:space="preserve">
          <source>Dereferencing a function pointer yields the function designator for the pointed-to function:</source>
          <target state="translated">При разыменовании указателя функции появляется обозначение функции для функции,на которую указывает указатель:</target>
        </trans-unit>
        <trans-unit id="443e0815b33ce17780b995cb60837ff3ec40c823" translate="yes" xml:space="preserve">
          <source>Dereferencing a null pointer, a pointer to an object outside of its lifetime (a dangling pointer), a misaligned pointer, or a pointer with indeterminate value is undefined behavior, except when the dereference operator is nullified by applying the address-of operator to its result, as in &lt;code&gt;&amp;amp;*E&lt;/code&gt;.</source>
          <target state="translated">Разыменование нулевого указателя, указателя на объект за пределами его времени жизни (висячий указатель), неверно выровненного указателя или указателя с неопределенным значением является неопределенным поведением, за исключением случаев, когда оператор разыменования обнуляется путем применения оператора address-of к его результат, как и в &lt;code&gt;&amp;amp;*E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="d6ebeef73eef6a80573532642182d125a4f29dce" translate="yes" xml:space="preserve">
          <source>Despite being specified &quot;as if&quot; a temporary buffer is used, actual implementations of this function do not incur the overhead or double copying or extra memory. A common approach (glibc and bsd libc) is to copy bytes forwards from the beginning of the buffer if the destination starts before the source, and backwards from the end otherwise, with a fall back to the more efficient &lt;code&gt;&lt;a href=&quot;memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; when there is no overlap at all.</source>
          <target state="translated">Несмотря на то, что указано, что &amp;laquo;как будто&amp;raquo; используется временный буфер, фактические реализации этой функции не требуют накладных расходов, двойного копирования или дополнительной памяти. Общий подход (glibc и bsd libc) состоит в том, чтобы копировать байты вперед от начала буфера, если место назначения начинается перед источником, и назад от конца в противном случае, с возвратом к более эффективному &lt;code&gt;&lt;a href=&quot;memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; , когда нет перекрытия в все.</target>
        </trans-unit>
        <trans-unit id="c5fec379b7553188ac34cec8b46773b82ab3ed04" translate="yes" xml:space="preserve">
          <source>Despite disallowing undue overflow, complex division may raise spurious floating-point exceptions (otherwise it is prohibitively difficult to implement non-overflowing versions).</source>
          <target state="translated">Несмотря на запрещение переполнения,сложное деление может привести к появлению поддельных исключений с плавающей запятой (в противном случае реализовать непереполненные версии запретительно сложно).</target>
        </trans-unit>
        <trans-unit id="15633e8db8c39a0171fc7ddfc24df220b416124e" translate="yes" xml:space="preserve">
          <source>Despite disallowing undue overflow, complex multiplication may raise spurious floating-point exceptions (otherwise it is prohibitively difficult to implement non-overflowing versions).</source>
          <target state="translated">Несмотря на запрещение переполнения,сложное умножение может привести к поддельным исключениям с плавающей точкой (в противном случае реализовать непереполнение невозможно).</target>
        </trans-unit>
        <trans-unit id="855ca2056b63174a0ddd49fc8dda9ca42caba924" translate="yes" xml:space="preserve">
          <source>Despite the name, neither C nor POSIX standards require this function to be implemented using &lt;a href=&quot;https://en.wikipedia.org/wiki/Quicksort&quot;&gt;quicksort&lt;/a&gt; or make any complexity or stability guarantees.</source>
          <target state="translated">Несмотря на название, ни стандарты C, ни стандарты POSIX не требуют, чтобы эта функция была реализована с использованием &lt;a href=&quot;https://en.wikipedia.org/wiki/Quicksort&quot;&gt;быстрой сортировки,&lt;/a&gt; или не давали никаких гарантий сложности или стабильности.</target>
        </trans-unit>
        <trans-unit id="b78d139cdf486e1acc85058934b061d098dfdcab" translate="yes" xml:space="preserve">
          <source>Despite the name, neither C nor POSIX standards require this function to be implemented using binary search or make any complexity guarantees.</source>
          <target state="translated">Несмотря на название,ни стандарты C,ни стандарты POSIX не требуют,чтобы эта функция реализовывалась с помощью бинарного поиска,и не дают никаких гарантий сложности.</target>
        </trans-unit>
        <trans-unit id="e759a1fb34e3f73a71f0a598c5a332119a8f59d1" translate="yes" xml:space="preserve">
          <source>Destroys the condition variable pointed to by &lt;code&gt;cond&lt;/code&gt;.</source>
          <target state="translated">Уничтожает переменную условия, на которую указывает &lt;code&gt;cond&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30db72753f6da400421d2bf7435f8d3d3aff73f5" translate="yes" xml:space="preserve">
          <source>Destroys the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt;.</source>
          <target state="translated">Уничтожает мьютекс, на который указывает &lt;code&gt;mutex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d86774c24e1a6900373ea2ea0eabca1cef9aefb" translate="yes" xml:space="preserve">
          <source>Destroys the thread-specific storage identified by &lt;code&gt;tss_id&lt;/code&gt;.</source>
          <target state="translated">Уничтожает специфичное для потока хранилище, идентифицированное &lt;code&gt;tss_id&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8ac19debfbe59f4081df2e1735171ca5f3762c9" translate="yes" xml:space="preserve">
          <source>Detaches the thread identified by &lt;code&gt;thr&lt;/code&gt; from the current environment. The resources held by the thread will be freed automatically once the thread exits.</source>
          <target state="translated">Отсоединяет поток, определенный &lt;code&gt;thr&lt;/code&gt; , от текущей среды. Ресурсы, удерживаемые потоком, будут автоматически освобождены после выхода из потока.</target>
        </trans-unit>
        <trans-unit id="c3457bc8babb6145a4d1a3fb89cd5528841f3468" translate="yes" xml:space="preserve">
          <source>Determines if the atomic operations on all objects of the type &lt;code&gt;A&lt;/code&gt; (the type of the object pointed to by &lt;code&gt;obj&lt;/code&gt;) are lock-free. In any given program execution, the result of calling &lt;code&gt;atomic_is_lock_free&lt;/code&gt; is the same for all pointers of the same type.</source>
          <target state="translated">Определяет, являются ли атомарные операции над всеми объектами типа &lt;code&gt;A&lt;/code&gt; (тип объекта, на который указывает &lt;code&gt;obj&lt;/code&gt; ) свободными от блокировки. При любом выполнении программы результат вызова &lt;code&gt;atomic_is_lock_free&lt;/code&gt; одинаков для всех указателей одного типа.</target>
        </trans-unit>
        <trans-unit id="42961033930dd9b0cb31b3f60a0b7da407759c76" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is greater than or equal to the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="translated">Определяет, является ли число &lt;code&gt;x&lt;/code&gt; с плавающей запятой большим или равным числу &lt;code&gt;y&lt;/code&gt; с плавающей запятой , без установки исключений с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="06ba39a9361411a3c82420f68b56c98e752e8285" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is greater than the floating-point number (&lt;code&gt;y&lt;/code&gt;), without setting floating-point exceptions.</source>
          <target state="translated">Определяет, больше ли число с плавающей запятой &lt;code&gt;x&lt;/code&gt; , чем число с плавающей запятой ( &lt;code&gt;y&lt;/code&gt; ), без установки исключений с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="8f2c82d270fa552f3d9599b39ceefe0ab66e42be" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is less than or equal to the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="translated">Определяет, меньше ли число с плавающей запятой &lt;code&gt;x&lt;/code&gt; или равно числу &lt;code&gt;y&lt;/code&gt; с плавающей запятой , без установки исключений с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="61cc741f2ceb8f899fe8f8a8102fd65dfe1cdb1b" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is less than or greater than the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="translated">Определяет, является ли число с плавающей запятой &lt;code&gt;x&lt;/code&gt; меньше или больше числа с плавающей запятой &lt;code&gt;y&lt;/code&gt; , без установки исключений с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="cc4f23eed57a50e680bbd714ba24c1ae9b04715c" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is less than the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="translated">Определяет, меньше ли число с плавающей запятой &lt;code&gt;x&lt;/code&gt; , чем число с плавающей запятой &lt;code&gt;y&lt;/code&gt; , без установки исключений с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="12a023deb0e25da717685baee738b5001df78e3a" translate="yes" xml:space="preserve">
          <source>Determines if the floating point numbers &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are unordered, that is, one or both are NaN and thus cannot be meaningfully compared with each other.</source>
          <target state="translated">Определяет, являются ли числа с плавающей запятой &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; неупорядоченными, то есть одно или оба являются NaN и, таким образом, не могут быть осмысленно сопоставлены друг с другом.</target>
        </trans-unit>
        <trans-unit id="1673883c418a37012138fdc6e721d284c1d37177" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN. The macro returns an integral value.</source>
          <target state="translated">Определяет, имеет ли данное число с плавающей точкой &lt;code&gt;arg&lt;/code&gt; конечное значение, т.е. оно является нормальным, субнормальным или нулевым, но не бесконечным или NaN. Макрос возвращает целое значение.</target>
        </trans-unit>
        <trans-unit id="f01a2032ba2b4ae13adc4724b8eac8696393ffb1" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is a not-a-number (NaN) value. The macro returns an integral value.</source>
          <target state="translated">Определяет, является ли данное число с плавающей запятой &lt;code&gt;arg&lt;/code&gt; значением,отличным от числа (NaN). Макрос возвращает целое значение.</target>
        </trans-unit>
        <trans-unit id="7ab9c686b97ad7bf5476551370095e04426a01d8" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is negative. The macro returns an integral value.</source>
          <target state="translated">Определяет, является ли данное число с плавающей точкой &lt;code&gt;arg&lt;/code&gt; отрицательным. Макрос возвращает целое значение.</target>
        </trans-unit>
        <trans-unit id="c71330c3e714777dd145b0fec831b8fa8ff04aa4" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is normal, i.e. is neither zero, subnormal, infinite, nor &lt;code&gt;NaN&lt;/code&gt;. The macro returns an integral value.</source>
          <target state="translated">Определяет, является ли данное число с плавающей точкой &lt;code&gt;arg&lt;/code&gt; нормальным, то есть не является ли оно нулевым, субнормальным, бесконечным или &lt;code&gt;NaN&lt;/code&gt; . Макрос возвращает целое значение.</target>
        </trans-unit>
        <trans-unit id="42bececa62b5cdaaf1bea284ccc4761215f18797" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is positive or negative infinity. The macro returns an integral value.</source>
          <target state="translated">Определяет, является ли данное число с плавающей запятой &lt;code&gt;arg&lt;/code&gt; положительной или отрицательной бесконечностью. Макрос возвращает целое значение.</target>
        </trans-unit>
        <trans-unit id="d9abcfdbe740f7564155ea43385bb7b128ce45b2" translate="yes" xml:space="preserve">
          <source>Determines the size, in bytes, of the multibyte character whose first byte is pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Определяет размер в байтах многобайтового символа, первый байт которого указан &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4507028cacf93c00d5ae52796f91e29ec21b8e82" translate="yes" xml:space="preserve">
          <source>Determines the size, in bytes, of the representation of a multibyte character.</source>
          <target state="translated">Определяет размер в байтах представления многобайтного символа.</target>
        </trans-unit>
        <trans-unit id="c69c802d70e0e3f6788cfc1779895445bfc77a31" translate="yes" xml:space="preserve">
          <source>Determines which of the specified subset of the floating point exceptions are currently set. The argument &lt;code&gt;excepts&lt;/code&gt; is a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;.</source>
          <target state="translated">Определяет, какое из указанного подмножества исключений с плавающей запятой установлено в данный момент. Аргумент &lt;code&gt;excepts&lt;/code&gt; является побитовым ИЛИ &lt;a href=&quot;fe_exceptions&quot;&gt;макросов исключений&lt;/a&gt; с плавающей точкой .</target>
        </trans-unit>
        <trans-unit id="0d3a3771d727fe204d2df32971206ca839fb6ce3" translate="yes" xml:space="preserve">
          <source>Difference between two times in seconds.</source>
          <target state="translated">Разница между двумя разами в секундах.</target>
        </trans-unit>
        <trans-unit id="6170f244847af7dbbce945574fb4f39ec9c7c16b" translate="yes" xml:space="preserve">
          <source>Different implementations return different non-negative numbers: some return the last character written, some return the number of characters written (or INT_MAX if the string was longer than that), some simply return a non-negative constant such as zero.</source>
          <target state="translated">Различные реализации возвращают разные неотрицательные числа:некоторые возвращают последний записанный символ,некоторые возвращают количество записанных символов (или INT_MAX,если строка была длиннее этой),некоторые просто возвращают неотрицательную константу,такую как ноль.</target>
        </trans-unit>
        <trans-unit id="d3663230bcd568fa0f0bc0c99c9ad42d7948fb50" translate="yes" xml:space="preserve">
          <source>Different implementations return different non-negative numbers: some return the last character written, some return the number of characters written (or INT_MAX if the string was longer than that), some simply return a non-negative constant.</source>
          <target state="translated">Различные реализации возвращают разные неотрицательные числа:некоторые возвращают последний записанный символ,некоторые возвращают количество записанных символов (или INT_MAX,если строка была длиннее этой),некоторые просто возвращают неотрицательную константу.</target>
        </trans-unit>
        <trans-unit id="4cec1e48ed8268246c17cdf0e9f5b5116725afd5" translate="yes" xml:space="preserve">
          <source>Different threads of execution are always allowed to access (read and modify) different</source>
          <target state="translated">Различным потокам исполнения всегда разрешается доступ (читать и изменять)к разным</target>
        </trans-unit>
        <trans-unit id="f347c23fb94afe99ca29d2298bd820db7bf1c6f2" translate="yes" xml:space="preserve">
          <source>Direct input/output</source>
          <target state="translated">Прямой ввод/вывод</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="2df36c679013c753c1824914229ac0e9ed0ef85a" translate="yes" xml:space="preserve">
          <source>Discards any whitespace characters (as identified by calling &lt;code&gt;isspace()&lt;/code&gt;) until the first non-whitespace character is found, then takes as many characters as possible to form a valid</source>
          <target state="translated">Отбрасывает все пробельные символы (как определено вызовом &lt;code&gt;isspace()&lt;/code&gt; ) до тех пор, пока не будет найден первый непробельный символ, а затем принимает максимально возможное количество символов для формирования правильного</target>
        </trans-unit>
        <trans-unit id="3f47e884dde353c0a64ae183f652592cd28d42e5" translate="yes" xml:space="preserve">
          <source>Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. The valid integer value consists of the following parts:</source>
          <target state="translated">Отбрасывает любые символы пробела до тех пор,пока не будет найден первый символ без пробела,затем берет как можно больше символов для формирования действительного целочисленного представления числа и преобразует их в целое значение.Действительное целое значение состоит из следующих частей:</target>
        </trans-unit>
        <trans-unit id="2b95cdc5966f0cb8891c7e9e0d564b397089da15" translate="yes" xml:space="preserve">
          <source>Dividing 0.0 by 0.0 gives NaN and &lt;code&gt;&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Деление 0.0 на 0.0 дает NaN и &lt;code&gt;&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="b155ca10158e241e3d1fad0c3aba4fd35761c88e" translate="yes" xml:space="preserve">
          <source>Dividing a non-zero number by &amp;plusmn;0.0 gives the correctly-signed infinity and &lt;code&gt;&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Разделив ненулевое число на &amp;plusmn; 0.0, вы &lt;code&gt;&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; правильно подписанную бесконечность, и FE_DIVBYZERO будет увеличено</target>
        </trans-unit>
        <trans-unit id="bbbec44416269797757a1579d0b1247911acd066" translate="yes" xml:space="preserve">
          <source>Division</source>
          <target state="translated">Division</target>
        </trans-unit>
        <trans-unit id="26c986c0b2a8c981af75cc9b323e96898b596d78" translate="yes" xml:space="preserve">
          <source>Domain error</source>
          <target state="translated">Доменная ошибка</target>
        </trans-unit>
        <trans-unit id="683ae4a82c0162283d391c1cde234ae848eeb039" translate="yes" xml:space="preserve">
          <source>Domain error may occur if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero.</source>
          <target state="translated">Ошибка домена может возникнуть, если &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; оба равны нулю.</target>
        </trans-unit>
        <trans-unit id="209a993b5d06ebc1189ef12bc6140d9643c1f5b5" translate="yes" xml:space="preserve">
          <source>Domain error may occur if &lt;code&gt;y&lt;/code&gt; is zero.</source>
          <target state="translated">Ошибка домена может возникнуть, если &lt;code&gt;y&lt;/code&gt; равен нулю.</target>
        </trans-unit>
        <trans-unit id="f953ae32bdac16ba6277a0e47315c5bfadd7dae5" translate="yes" xml:space="preserve">
          <source>Domain error occurs if &lt;code&gt;arg&lt;/code&gt; is less than -1.</source>
          <target state="translated">Ошибка домена возникает, если &lt;code&gt;arg&lt;/code&gt; меньше -1.</target>
        </trans-unit>
        <trans-unit id="1b2c79d3977fa1e82c68257e4ee3be3430c9d49f" translate="yes" xml:space="preserve">
          <source>Domain error occurs if &lt;code&gt;arg&lt;/code&gt; is less than zero.</source>
          <target state="translated">Ошибка домена возникает, если &lt;code&gt;arg&lt;/code&gt; меньше нуля.</target>
        </trans-unit>
        <trans-unit id="206bd3375d61b90cec57754711bf77b10e8308ff" translate="yes" xml:space="preserve">
          <source>Domain error occurs if &lt;code&gt;arg&lt;/code&gt; is outside the range &lt;code&gt;[-1.0; 1.0]&lt;/code&gt;.</source>
          <target state="translated">Ошибка домена возникает, если &lt;code&gt;arg&lt;/code&gt; находится вне диапазона &lt;code&gt;[-1.0; 1.0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30b1970ca78476223062c512a821c8789e06506b" translate="yes" xml:space="preserve">
          <source>Domain or range error may occur if &lt;code&gt;arg&lt;/code&gt; is zero.</source>
          <target state="translated">Ошибка домена или диапазона может возникнуть, если &lt;code&gt;arg&lt;/code&gt; равен нулю.</target>
        </trans-unit>
        <trans-unit id="b1ca39980d3cc90251635580f9d046def1437b32" translate="yes" xml:space="preserve">
          <source>Due to &lt;a href=&quot;translation_phases#maximal_munch&quot;&gt;maximal munch&lt;/a&gt;, hexadecimal integer constants ending in &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt;, when followed by the operators &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, must be separated from the operator with whitespace or parentheses in the source:</source>
          <target state="translated">Из-за &lt;a href=&quot;translation_phases#maximal_munch&quot;&gt;максимального значения munch&lt;/a&gt; шестнадцатеричные целочисленные константы, оканчивающиеся на &lt;code&gt;e&lt;/code&gt; и &lt;code&gt;E&lt;/code&gt; , за которыми следуют операторы &lt;code&gt;+&lt;/code&gt; или &lt;code&gt;-&lt;/code&gt; , должны отделяться от оператора пробелами или круглыми скобками в источнике:</target>
        </trans-unit>
        <trans-unit id="fbad71c32e999acfe150dcd28476b81eeb49a324" translate="yes" xml:space="preserve">
          <source>Due to its infinite intermediate precision, &lt;code&gt;fma&lt;/code&gt; is a common building block of other correctly-rounded mathematical operations, such as &lt;code&gt;&lt;a href=&quot;sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt; or even the division (where not provided by the CPU, e.g. Itanium).</source>
          <target state="translated">Из-за своей бесконечной промежуточной точности &lt;code&gt;fma&lt;/code&gt; является обычным строительным блоком других правильно округленных математических операций, таких как &lt;code&gt;&lt;a href=&quot;sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt; или даже деление (если это не предусмотрено процессором, например, Itanium).</target>
        </trans-unit>
        <trans-unit id="a8edf7aed52e22273ca006dc7586e6c5a889a81c" translate="yes" xml:space="preserve">
          <source>Due to the alignment requirements, the number of allocated bytes is not necessarily equal to &lt;code&gt;num*size&lt;/code&gt;.</source>
          <target state="translated">Из-за требований выравнивания количество выделенных байтов не обязательно равно &lt;code&gt;num*size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ada3669ea0e73f0cca2ed0c6e2ffff046545a5e" translate="yes" xml:space="preserve">
          <source>Due to the definition of the &lt;a href=&quot;operator_arithmetic&quot;&gt;addition between a pointer and an integer&lt;/a&gt;, the result is the element of the array with the index equal to the result of integer-expression (or, if pointer-expression was pointing at ith element of some array, the index of the result is i plus the result of integer-expression).</source>
          <target state="translated">Из-за определения &lt;a href=&quot;operator_arithmetic&quot;&gt;сложения между указателем и целым числом&lt;/a&gt; , результатом является элемент массива с индексом, равным результату целочисленного выражения (или, если указатель-выражение указывал на i-й элемент некоторого массива, индекс результата - это я плюс результат целочисленного выражения).</target>
        </trans-unit>
        <trans-unit id="6ca450ab66cc4bceeefc245e894ea6b43911af90" translate="yes" xml:space="preserve">
          <source>During each execution of a block in which a restricted pointer &lt;code&gt;P&lt;/code&gt; is declared (typically each execution of a function body in which &lt;code&gt;P&lt;/code&gt; is a function parameter), if some object that is accessible through &lt;code&gt;P&lt;/code&gt; (directly or indirectly) is modified, by any means, then all accesses to that object (both reads and writes) in that block must occur through &lt;code&gt;P&lt;/code&gt; (directly or indirectly), otherwise the behavior is undefined:</source>
          <target state="translated">Во время каждого выполнения блока, в котором объявляется ограниченный указатель &lt;code&gt;P&lt;/code&gt; (обычно при каждом выполнении тела функции, в котором &lt;code&gt;P&lt;/code&gt; является параметром функции), если какой-либо объект, доступный через &lt;code&gt;P&lt;/code&gt; (прямо или косвенно), изменяется любым способом , тогда все обращения к этому объекту (как чтение, так и запись) в этом блоке должны происходить через &lt;code&gt;P&lt;/code&gt; (прямо или косвенно), в противном случае поведение не определено:</target>
        </trans-unit>
        <trans-unit id="07293fea74c54774179ebe1157890c6ede5445d9" translate="yes" xml:space="preserve">
          <source>During program startup, the equivalent of &lt;code&gt;setlocale(&lt;a href=&quot;lc_categories&quot;&gt;LC_ALL&lt;/a&gt;, &quot;C&quot;);&lt;/code&gt; is executed before any user code is run.</source>
          <target state="translated">Во время запуска программы эквивалент &lt;code&gt;setlocale(&lt;a href=&quot;lc_categories&quot;&gt;LC_ALL&lt;/a&gt;, &quot;C&quot;);&lt;/code&gt; выполняется до запуска любого пользовательского кода.</target>
        </trans-unit>
        <trans-unit id="27eaec4864e4b466246e5081a68f0b07f10aafac" translate="yes" xml:space="preserve">
          <source>Dynamic memory management</source>
          <target state="translated">Управление динамической памятью</target>
        </trans-unit>
        <trans-unit id="7c3cba5cfb875c54a838f8fb7c062f2ab636df56" translate="yes" xml:space="preserve">
          <source>E2BIG, EACCES, ..., EXDEV</source>
          <target state="translated">E2BIG,EACCES,...,EXDEV</target>
        </trans-unit>
        <trans-unit id="4a50ae31fdb1876dd49f36fd10696a265ad4f349" translate="yes" xml:space="preserve">
          <source>EDOM</source>
          <target state="translated">EDOM</target>
        </trans-unit>
        <trans-unit id="bafb9dc439b47e39a5166a169171eda5a0ccd069" translate="yes" xml:space="preserve">
          <source>EILSEQ</source>
          <target state="translated">EILSEQ</target>
        </trans-unit>
        <trans-unit id="cda4aab5bcbd0ed38717196ad5a3684cd59490a3" translate="yes" xml:space="preserve">
          <source>EOF</source>
          <target state="translated">EOF</target>
        </trans-unit>
        <trans-unit id="027a5d6bd60d44a140b125f5e6c684b7bb796a30" translate="yes" xml:space="preserve">
          <source>ERANGE</source>
          <target state="translated">ERANGE</target>
        </trans-unit>
        <trans-unit id="c1f146ea81ae03fae7db256856fdde169c5d5e44" translate="yes" xml:space="preserve">
          <source>EXIT_SUCCESS</source>
          <target state="translated">EXIT_SUCCESS</target>
        </trans-unit>
        <trans-unit id="5c2b8a61f8fe437d39117db5b2fb0b332818fd1a" translate="yes" xml:space="preserve">
          <source>EXIT_SUCCESS, EXIT_FAILURE</source>
          <target state="translated">EXIT_SUCCESS,EXIT_FAILURE</target>
        </trans-unit>
        <trans-unit id="69fa19d78ab53209ccdb3bf9ac261f7db68a9cbc" translate="yes" xml:space="preserve">
          <source>EXIT_SUCCESSEXIT_FAILURE</source>
          <target state="translated">EXIT_SUCCESSEXIT_FAILURE</target>
        </trans-unit>
        <trans-unit id="c354b3028bd8c5a1179ea67b0fa0ac0c52287a14" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; in C (an operator with its arguments, a function call, a constant, a variable name, etc) is characterized by two independent properties: a &lt;a href=&quot;compatible_type#Type&quot;&gt;type&lt;/a&gt; and a &lt;a href=&quot;expressions#General&quot;&gt;value category&lt;/a&gt;.</source>
          <target state="translated">Каждое &lt;a href=&quot;expressions&quot;&gt;выражение&lt;/a&gt; в C (оператор с его аргументами, вызов функции, константа, имя переменной и т. Д.) Характеризуется двумя независимыми свойствами: &lt;a href=&quot;compatible_type#Type&quot;&gt;типом&lt;/a&gt; и &lt;a href=&quot;expressions#General&quot;&gt;категорией значений&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f85f8ed086a86eb382bf3f36ce72b1f255a1a54" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; that appears in a C program is</source>
          <target state="translated">Каждый &lt;a href=&quot;identifier&quot;&gt;идентификатор,&lt;/a&gt; который появляется в программе на C,</target>
        </trans-unit>
        <trans-unit id="034551eb33d55611bebf58f023be8399816d5832" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operation B that loads from atomic variable M, observes one of the following:</source>
          <target state="translated">Каждая операция &lt;code&gt;memory_order_seq_cst&lt;/code&gt; B, которая загружается из атомарной переменной M, выполняет одно из следующих действий:</target>
        </trans-unit>
        <trans-unit id="50ed6669658b1fc844a09041da527dd57c316058" translate="yes" xml:space="preserve">
          <source>Each argument of integer type undergoes</source>
          <target state="translated">Каждый аргумент целочисленного типа проходит</target>
        </trans-unit>
        <trans-unit id="9ebf5b751176ac260f746f693298237e7da46d0e" translate="yes" xml:space="preserve">
          <source>Each atomic object has its own associated</source>
          <target state="translated">Каждый атомный объект имеет свой собственный ассоциированный</target>
        </trans-unit>
        <trans-unit id="df6cd15388cf4a32a59a55dc9d5c90813f45174a" translate="yes" xml:space="preserve">
          <source>Each call to &lt;code&gt;mblen&lt;/code&gt; updates the internal global conversion state (a static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt;, only known to this function). If the multibyte encoding uses shift states, care must be taken to avoid backtracking or multiple scans. In any case, multiple threads should not call &lt;code&gt;mblen&lt;/code&gt; without synchronization: &lt;code&gt;&lt;a href=&quot;mbrlen&quot;&gt;mbrlen&lt;/a&gt;&lt;/code&gt; may be used instead.</source>
          <target state="translated">Каждый вызов &lt;code&gt;mblen&lt;/code&gt; обновляет внутреннее глобальное состояние преобразования (статический объект типа &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; , известный только этой функции). Если в многобайтовом кодировании используются сдвиговые состояния, следует позаботиться о том, чтобы избежать обратного отслеживания или многократного сканирования. В любом случае несколько потоков не должны вызывать &lt;code&gt;mblen&lt;/code&gt; без синхронизации: &lt;code&gt;&lt;a href=&quot;mbrlen&quot;&gt;mbrlen&lt;/a&gt;&lt;/code&gt; можно использовать mbrlen .</target>
        </trans-unit>
        <trans-unit id="73d303af5fb3c8b993bba7231f1a0f5f58ccb4f1" translate="yes" xml:space="preserve">
          <source>Each call to &lt;code&gt;mbtowc&lt;/code&gt; updates the internal global conversion state (a static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt;, known only to this function). If the multibyte encoding uses shift states, care must be taken to avoid backtracking or multiple scans. In any case, multiple threads should not call &lt;code&gt;mbtowc&lt;/code&gt; without synchronization: &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; may be used instead.</source>
          <target state="translated">Каждый вызов &lt;code&gt;mbtowc&lt;/code&gt; обновляет внутреннее глобальное состояние преобразования (статический объект типа &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; , известный только этой функции). Если в многобайтовом кодировании используются сдвиговые состояния, следует позаботиться о том, чтобы избежать обратного отслеживания или многократного сканирования. В любом случае, несколько потоков не должны вызывать &lt;code&gt;mbtowc&lt;/code&gt; без синхронизации: &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; можно использовать mbrtowc .</target>
        </trans-unit>
        <trans-unit id="3a26487bbc956d044f713cce85b0df2b15bb37d5" translate="yes" xml:space="preserve">
          <source>Each call to &lt;code&gt;strtok&lt;/code&gt; modifies a static variable: is not thread safe.</source>
          <target state="translated">Каждый вызов &lt;code&gt;strtok&lt;/code&gt; изменяет статическую переменную: не является потокобезопасным.</target>
        </trans-unit>
        <trans-unit id="dbb07f43c006809f998028ea3a3213eba702b907" translate="yes" xml:space="preserve">
          <source>Each call to &lt;code&gt;wctomb&lt;/code&gt; updates the internal global conversion state (a static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt;, known only to this function). If the multibyte encoding uses shift states, this function is not reentrant. In any case, multiple threads should not call &lt;code&gt;wctomb&lt;/code&gt; without synchronization: &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;wctomb_s&lt;/code&gt; may be used instead.</source>
          <target state="translated">Каждый вызов &lt;code&gt;wctomb&lt;/code&gt; обновляет внутреннее глобальное состояние преобразования (статический объект типа &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; , известный только этой функции). Если в многобайтовом кодировании используются сдвиговые состояния, эта функция не реентерабельна. В любом случае, несколько потоков не должны вызывать &lt;code&gt;wctomb&lt;/code&gt; без синхронизации: &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt; &lt;code&gt;wctomb_s&lt;/code&gt; можно использовать wcrtomb или wctomb_s .</target>
        </trans-unit>
        <trans-unit id="10c116fe99e7e4c63d5874a29e18cc77b07208ef" translate="yes" xml:space="preserve">
          <source>Each character is converted as if by a call to &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt;, except that the mbtowc conversion state is unaffected. The conversion stops if:</source>
          <target state="translated">Каждый символ конвертируется как бы при вызове &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt; , за исключением того, что состояние преобразования mbtowc не изменяется. Преобразование останавливается, если:</target>
        </trans-unit>
        <trans-unit id="8fdcfb8ea34567f6c07db16c3fdb8c247a630ac9" translate="yes" xml:space="preserve">
          <source>Each character is converted as if by a call to &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt;. The conversion stops if:</source>
          <target state="translated">Каждый персонаж конвертируется, как будто при вызове &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt; . Преобразование останавливается, если:</target>
        </trans-unit>
        <trans-unit id="b6a6b4bfe71a06eb1a9c2dcd04975303c04aa0c0" translate="yes" xml:space="preserve">
          <source>Each character is converted as if by a call to &lt;code&gt;&lt;a href=&quot;wctomb&quot;&gt;wctomb&lt;/a&gt;&lt;/code&gt;, except that the wctomb's conversion state is unaffected. The conversion stops if:</source>
          <target state="translated">Каждый символ конвертируется как бы при вызове &lt;code&gt;&lt;a href=&quot;wctomb&quot;&gt;wctomb&lt;/a&gt;&lt;/code&gt; , за исключением того, что состояние преобразования wctomb не изменяется. Преобразование останавливается, если:</target>
        </trans-unit>
        <trans-unit id="139407327b9bb5d3c3d7c2958d54f12ce1b02006" translate="yes" xml:space="preserve">
          <source>Each character stored in the string may occupy more than one byte. The encoding used to represent characters in a multibyte character string is locale-specific: it may be UTF-8, GB18030, EUC-JP, Shift-JIS, etc. For example, the char array &lt;code&gt;{'\xe4','\xbd','\xa0','\xe5','\xa5','\xbd','\0'&lt;/code&gt;} is an NTMBS holding the string &lt;code&gt;&quot;你好&quot;&lt;/code&gt; in UTF-8 multibyte encoding: the first three bytes encode the character 你, the next three bytes encode the character 好. The same string encoded in GB18030 is the char array &lt;code&gt;{'\xc4', '\xe3', '\xba', '\xc3', '\0'&lt;/code&gt;}, where each of the two characters is encoded as a two-byte sequence.</source>
          <target state="translated">Каждый символ, хранящийся в строке, может занимать более одного байта. Кодировка, используемая для представления символов в многобайтовой символьной строке, зависит от конкретной локали: это может быть UTF-8, GB18030, EUC-JP, Shift-JIS и т. Д. Например, массив char &lt;code&gt;{'\xe4','\xbd','\xa0','\xe5','\xa5','\xbd','\0'&lt;/code&gt; } - это NTMBS, содержащая строку &lt;code&gt;&quot;你好&quot;&lt;/code&gt; в многобайтовой кодировке UTF-8: первые три байта кодируют символ 你, следующие три байта кодируют символ 好. Та же самая строка, закодированная в GB18030, является массивом символов &lt;code&gt;{'\xc4', '\xe3', '\xba', '\xc3', '\0'&lt;/code&gt; }, где каждый из двух символов закодирован как двухбайтовый последовательность.</target>
        </trans-unit>
        <trans-unit id="68890a6b98ff2345efa51a151d230b6d6d04308c" translate="yes" xml:space="preserve">
          <source>Each complex type has the same &lt;a href=&quot;object&quot;&gt;object representation&lt;/a&gt; and &lt;a href=&quot;object&quot;&gt;alignment requirements&lt;/a&gt; as an &lt;a href=&quot;array&quot;&gt;array&lt;/a&gt; of two elements of the corresponding real type (&lt;code&gt;float&lt;/code&gt; for &lt;code&gt;float &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt; for &lt;code&gt;double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt; for &lt;code&gt;long double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;). The first element of the array holds the real part, and the second element of the array holds the imaginary component.</source>
          <target state="translated">Каждый комплекс типа имеет то же &lt;a href=&quot;object&quot;&gt;представление объекта&lt;/a&gt; и &lt;a href=&quot;object&quot;&gt;требование к выравниванию&lt;/a&gt; как &lt;a href=&quot;array&quot;&gt;массив&lt;/a&gt; из двух элементов соответствующего реального типа ( &lt;code&gt;float&lt;/code&gt; для &lt;code&gt;float &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; для &lt;code&gt;double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;long double&lt;/code&gt; за &lt;code&gt;long double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; ). Первый элемент массива содержит действительную часть, а второй элемент массива содержит мнимый компонент.</target>
        </trans-unit>
        <trans-unit id="137efba0894a7ebae4cd21d84f7d4f31559eb6c4" translate="yes" xml:space="preserve">
          <source>Each compound literal creates only a single object in its scope:</source>
          <target state="translated">Каждый составной литерал создает только один объект в своей области действия:</target>
        </trans-unit>
        <trans-unit id="a9df8d8eee431c451d6fc1af48d35c03f7433a26" translate="yes" xml:space="preserve">
          <source>Each compound statement introduces its own &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;.</source>
          <target state="translated">Каждый составной оператор вводит свою собственную &lt;a href=&quot;scope&quot;&gt;область блока&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9b8fc8e52076ec7b7c61bffc9ddc3474662c826" translate="yes" xml:space="preserve">
          <source>Each declarator is one of the following:</source>
          <target state="translated">Каждый декларатор является одним из следующих:</target>
        </trans-unit>
        <trans-unit id="79a901de123f9c94830f0127ef29a5f9dcf4d060" translate="yes" xml:space="preserve">
          <source>Each enumerated type is &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt; with one of: &lt;code&gt;char&lt;/code&gt;, a signed integer type, or an unsigned integer type. It is implementation-defined which type is compatible with any given enumerated type, but whatever it is, it must be capable of representing all enumerator values of that enumeration.</source>
          <target state="translated">Каждый перечисляемый тип &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;совместим&lt;/a&gt; с одним из следующих типов: &lt;code&gt;char&lt;/code&gt; , целочисленный тип со знаком или целочисленный тип без знака. Это определяется реализацией, какой тип совместим с любым заданным перечисляемым типом, но каким бы он ни был, он должен быть способен представлять все значения перечислителя этого перечисления.</target>
        </trans-unit>
        <trans-unit id="e20b07c2f013df7b88017bc74253d151a6997995" translate="yes" xml:space="preserve">
          <source>Each enumerator that appears in the body of an enumeration specifier becomes an &lt;a href=&quot;constant_expression&quot;&gt;integer constant&lt;/a&gt; with type &lt;code&gt;int&lt;/code&gt; in the enclosing scope and can be used whenever integer constants are required (e.g. as a case label or as a non-VLA array size).</source>
          <target state="translated">Каждый перечислитель, который появляется в теле спецификатора перечисления, становится &lt;a href=&quot;constant_expression&quot;&gt;целочисленной константой&lt;/a&gt; с типом &lt;code&gt;int&lt;/code&gt; во входящей области и может использоваться всякий раз, когда требуются целочисленные константы (например, в качестве метки регистра или размера массива не-VLA).</target>
        </trans-unit>
        <trans-unit id="b14993a86ee9276479d81f8deeff73026cd0493b" translate="yes" xml:space="preserve">
          <source>Each identifier (other than macro) is only valid within a part of the program called its &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; and belongs to one of four kinds of &lt;a href=&quot;name_space&quot;&gt;name spaces&lt;/a&gt;. Some identifiers have &lt;a href=&quot;storage_duration&quot;&gt;linkage&lt;/a&gt; which makes them refer to the same entities when they appear in different scopes or translation units.</source>
          <target state="translated">Каждый идентификатор (кроме макроса) действителен только в той части программы, которая называется его &lt;a href=&quot;scope&quot;&gt;областью действия,&lt;/a&gt; и относится к одному из четырех видов &lt;a href=&quot;name_space&quot;&gt;пространств имен&lt;/a&gt; . Некоторые идентификаторы имеют &lt;a href=&quot;storage_duration&quot;&gt;связь,&lt;/a&gt; которая заставляет их ссылаться на одни и те же объекты, когда они появляются в разных областях или единицах перевода.</target>
        </trans-unit>
        <trans-unit id="ad4634fb5579a12854af07426a363d2ae6653fef" translate="yes" xml:space="preserve">
          <source>Each individual type in the C &lt;a href=&quot;compatible_type&quot;&gt;type system&lt;/a&gt; has several</source>
          <target state="translated">Каждый отдельный тип в системе &lt;a href=&quot;compatible_type&quot;&gt;типов&lt;/a&gt; C имеет несколько</target>
        </trans-unit>
        <trans-unit id="b778434a270ebe1a3642fbd59833ce5e585f867f" translate="yes" xml:space="preserve">
          <source>Each member is allocated as if it were the only member of the union, which is why &lt;code&gt;s.c&lt;/code&gt; in the example above aliases the first byte of &lt;code&gt;s.s[0]&lt;/code&gt;.</source>
          <target state="translated">Каждый член выделяется так, как если бы он был единственным членом объединения, поэтому &lt;code&gt;s.c&lt;/code&gt; в приведенном выше примере псевдоним первого байта &lt;code&gt;s.s[0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b6ef3be237b3fe7d1168941fc3d1dec86cd9c78" translate="yes" xml:space="preserve">
          <source>Each object type imposes its alignment requirement on every object of that type. The strictest (largest) fundamental alignment of any type is the alignment of &lt;code&gt;&lt;a href=&quot;../types/max_align_t&quot;&gt;max_align_t&lt;/a&gt;&lt;/code&gt;. The weakest (smallest) alignment is the alignment of the types &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, and &lt;code&gt;unsigned char&lt;/code&gt;, and equals 1.</source>
          <target state="translated">Каждый тип объекта накладывает свое требование выравнивания на каждый объект этого типа. Самым строгим (самым большим) фундаментальным выравниванием любого типа является выравнивание &lt;code&gt;&lt;a href=&quot;../types/max_align_t&quot;&gt;max_align_t&lt;/a&gt;&lt;/code&gt; . Самым слабым (наименьшим) выравниванием является выравнивание типов &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;signed char&lt;/code&gt; и &lt;code&gt;unsigned char&lt;/code&gt; , равное 1.</target>
        </trans-unit>
        <trans-unit id="3bce51722d6b62312c671c879d5a6de1f802d8fe" translate="yes" xml:space="preserve">
          <source>Each of &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#elif&lt;/code&gt;, &lt;code&gt;#else&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt; and &lt;code&gt;#ifndef&lt;/code&gt; directives control a code block until the first &lt;code&gt;#elif&lt;/code&gt;, &lt;code&gt;#else&lt;/code&gt;, &lt;code&gt;#endif&lt;/code&gt; directive not belonging to any inner conditional preprocessing blocks.</source>
          <target state="translated">Каждый из &lt;code&gt;#if&lt;/code&gt; , &lt;code&gt;#elif&lt;/code&gt; , &lt;code&gt;#else&lt;/code&gt; , &lt;code&gt;#ifdef&lt;/code&gt; и &lt;code&gt;#ifndef&lt;/code&gt; директивы не контролирует блок кода до первого &lt;code&gt;#elif&lt;/code&gt; , &lt;code&gt;#else&lt;/code&gt; , &lt;code&gt;#endif&lt;/code&gt; директивы , не принадлежащая к каким - либо внутренним условным блокам предварительной обработки.</target>
        </trans-unit>
        <trans-unit id="13255e60126e8e8da26f8a162427af0c4a34405d" translate="yes" xml:space="preserve">
          <source>Each of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of &lt;code&gt;&lt;a href=&quot;setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Каждая из приведенных выше макроконстант расширяется до целочисленных константных выражений с различными значениями, которые подходят для использования в качестве первого аргумента &lt;code&gt;&lt;a href=&quot;setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47dec134a6d556ab62aff5d62d028d693acc8498" translate="yes" xml:space="preserve">
          <source>Each of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program.</source>
          <target state="translated">Каждая из вышеперечисленных макроконстант расширяется до целочисленного константного выражения с различными значениями,которые представляют собой различные сигналы,посылаемые программе.</target>
        </trans-unit>
        <trans-unit id="f6863b3780b12fcd68451d2943aa34bb1600f54a" translate="yes" xml:space="preserve">
          <source>Each of the macros defined in &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; expands to an integer constant expression with type &lt;code&gt;int&lt;/code&gt; and with a unique positive value. The following constants are defined by ISO C. The implementation may define more, as long as they begin with &lt;code&gt;'E'&lt;/code&gt; followed by digits or uppercase letters.</source>
          <target state="translated">Каждый из макросов, определенных в &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; , расширяется до целочисленного константного выражения с типом &lt;code&gt;int&lt;/code&gt; и уникальным положительным значением. Следующие константы определены ISO C. Реализация может определять больше, если они начинаются с &lt;code&gt;'E'&lt;/code&gt; за которым следуют цифры или заглавные буквы.</target>
        </trans-unit>
        <trans-unit id="72f1807990ff12b536de30461fba27cc15d7e01f" translate="yes" xml:space="preserve">
          <source>Each of the three imaginary types has the same &lt;a href=&quot;object&quot;&gt;object representation&lt;/a&gt; and &lt;a href=&quot;object&quot;&gt;alignment requirement&lt;/a&gt; as its</source>
          <target state="translated">Каждый из трех воображаемых типов имеет то же самое &lt;a href=&quot;object&quot;&gt;представление объекта&lt;/a&gt; и &lt;a href=&quot;object&quot;&gt;требование выравнивания,&lt;/a&gt; что и его</target>
        </trans-unit>
        <trans-unit id="0edc9c873627a243af8d00da93f274ccae0173ff" translate="yes" xml:space="preserve">
          <source>Each of these macro constants expands to a nonnegative integer constant expression, which can be used with &lt;code&gt;&lt;a href=&quot;feround&quot;&gt;fesetround&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;feround&quot;&gt;fegetround&lt;/a&gt;&lt;/code&gt; to indicate one of the supported floating-point rounding modes. The implementation may define additional rounding mode constants in &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;, which should all begin with &lt;code&gt;FE_&lt;/code&gt; followed by at least one uppercase letter. Each macro is only defined if it is supported.</source>
          <target state="translated">Каждая из этих макроконстант расширяется до неотрицательного целочисленного константного выражения, которое можно использовать с &lt;code&gt;&lt;a href=&quot;feround&quot;&gt;fesetround&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;feround&quot;&gt;fegetround&lt;/a&gt;&lt;/code&gt; для указания одного из поддерживаемых режимов округления с плавающей запятой. Реализация может определять дополнительные константы режима округления в &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt; , которые должны начинаться с &lt;code&gt;FE_&lt;/code&gt; , за которым следует хотя бы одна заглавная буква. Каждый макрос определяется только в том случае, если он поддерживается.</target>
        </trans-unit>
        <trans-unit id="c91547b3a6ee45d95762b25dda3cd9d3dac5ed28" translate="yes" xml:space="preserve">
          <source>Each of these macros expands to an expression that evaluates to the value of the specified complex type, with the real part having the value of &lt;code&gt;real&lt;/code&gt; (converted to the specified argument type) and the imaginary part having the value of &lt;code&gt;imag&lt;/code&gt; (converted to the specified argument type).</source>
          <target state="translated">Каждый из этих макросов раскрывается в выражение, которое оценивается как значение указанного комплексного типа, причем действительная часть имеет значение &lt;code&gt;real&lt;/code&gt; (преобразованное в указанный тип аргумента), а мнимая часть имеет значение &lt;code&gt;imag&lt;/code&gt; (преобразованное в указанный тип аргумента).</target>
        </trans-unit>
        <trans-unit id="daa18891fe69c786653bbe8101a0ff0d31ff1a44" translate="yes" xml:space="preserve">
          <source>Each parameter in a parameter-list is a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; that introduced a single variable, with the following additional properties:</source>
          <target state="translated">Каждый параметр в списке параметров является &lt;a href=&quot;declarations&quot;&gt;объявлением,&lt;/a&gt; которое вводит одну переменную со следующими дополнительными свойствами:</target>
        </trans-unit>
        <trans-unit id="7b2f6db2798b2b2d64fe6857e20c316d195be57c" translate="yes" xml:space="preserve">
          <source>Each time &lt;code&gt;rand()&lt;/code&gt; is seeded with the same &lt;code&gt;seed&lt;/code&gt;, it must produce the same sequence of values.</source>
          <target state="translated">Каждый раз, когда &lt;code&gt;rand()&lt;/code&gt; высевается с одним и тем же &lt;code&gt;seed&lt;/code&gt; , он должен генерировать одинаковую последовательность значений.</target>
        </trans-unit>
        <trans-unit id="8c7893661e60dbd1dacc8ed252ed6eaf9b8c2f87" translate="yes" xml:space="preserve">
          <source>Each time the flow of control passes over the declaration, expression is evaluated (and it must always evaluate to a value greater than zero), and the array is allocated (correspondingly, &lt;a href=&quot;lifetime&quot;&gt;lifetime&lt;/a&gt; of a VLA ends when the declaration goes out of scope). The size of each VLA instance does not change during its lifetime, but on another pass over the same code, it may be allocated with a different size.</source>
          <target state="translated">Каждый раз, когда поток управления проходит через объявление, выражение оценивается (и оно всегда должно иметь значение, превышающее ноль), и массив выделяется (соответственно, &lt;a href=&quot;lifetime&quot;&gt;время жизни&lt;/a&gt; VLA заканчивается, когда объявление выходит из области видимости). Размер каждого экземпляра VLA не изменяется в течение срока его службы, но при повторном проходе по тому же коду он может быть выделен с другим размером.</target>
        </trans-unit>
        <trans-unit id="9d2d2ec1c54af1bd7f51aa9bb54b8cab4a5b8234" translate="yes" xml:space="preserve">
          <source>Each translation unit may have zero or one external definition of every identifier with &lt;a href=&quot;storage_duration&quot;&gt;internal linkage&lt;/a&gt; (a &lt;code&gt;static&lt;/code&gt; global).</source>
          <target state="translated">Каждая единица перевода может иметь ноль или одно внешнее определение каждого идентификатора с &lt;a href=&quot;storage_duration&quot;&gt;внутренней связью&lt;/a&gt; ( &lt;code&gt;static&lt;/code&gt; глобальное).</target>
        </trans-unit>
        <trans-unit id="720b5dbc53190f0e13902f7885ccaf43bb9991de" translate="yes" xml:space="preserve">
          <source>Effect</source>
          <target state="translated">Effect</target>
        </trans-unit>
        <trans-unit id="e462a3162644e49e48fa52678a61c2c86777646c" translate="yes" xml:space="preserve">
          <source>Effective type</source>
          <target state="translated">Эффективный тип</target>
        </trans-unit>
        <trans-unit id="7e8faa87b0aa2cac770e9abb0f6c2733e6104d24" translate="yes" xml:space="preserve">
          <source>Empty declarators are prohibited; a declaration must be a &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; declaration or (since C11) have at least one declarator or declare at least one struct/union/enum tag, or introduce at least one enumeration constant.</source>
          <target state="translated">Пустые деклараторы запрещены; объявление должно быть объявлением &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; или (начиная с C11) иметь хотя бы одного декларатора или объявлять хотя бы один тег struct / union / enum, либо вводить хотя бы одну константу перечисления.</target>
        </trans-unit>
        <trans-unit id="8354d856832ccb717132df4747df0b697bdada66" translate="yes" xml:space="preserve">
          <source>Entering the scope of a non-variably modified variable is permitted:</source>
          <target state="translated">Допускается ввод диапазона неизменяемой переменной:</target>
        </trans-unit>
        <trans-unit id="cce45ab49aa862f3c61dbc001925b96425c01c53" translate="yes" xml:space="preserve">
          <source>Enumerated type is declared using the following</source>
          <target state="translated">Перечисленный тип объявляется следующим образом</target>
        </trans-unit>
        <trans-unit id="b85c029cc85bf41632bef2658cfd560e45013841" translate="yes" xml:space="preserve">
          <source>Enumerated types are integer types, and as such can be used anywhere other integer types can, including in &lt;a href=&quot;conversion&quot;&gt;implicit conversions&lt;/a&gt; and &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt;.</source>
          <target state="translated">Перечислимые типы являются целочисленными типами и, как таковые, могут использоваться везде, где могут использоваться другие целочисленные типы, включая &lt;a href=&quot;conversion&quot;&gt;неявные преобразования&lt;/a&gt; и &lt;a href=&quot;operator_arithmetic&quot;&gt;арифметические операторы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="413e9110db4f37157b581483ed8d7133f5021d89" translate="yes" xml:space="preserve">
          <source>Enumerations</source>
          <target state="translated">Enumerations</target>
        </trans-unit>
        <trans-unit id="f88783e04a87a739f9d3e33a3937c9a19a386846" translate="yes" xml:space="preserve">
          <source>Enumerations permit the declaration of named constants in a more convenient and structured fashion than does &lt;code&gt;#define&lt;/code&gt;; they are visible in the debugger, obey scope rules, and participate in the type system.</source>
          <target state="translated">Перечисления допускают объявление именованных констант более удобным и структурированным способом, чем &lt;code&gt;#define&lt;/code&gt; ; они видны в отладчике, подчиняются правилам области и участвуют в системе типов.</target>
        </trans-unit>
        <trans-unit id="2a6aa35f8013684cff4ad26bb51395662e2921e2" translate="yes" xml:space="preserve">
          <source>Equality operators</source>
          <target state="translated">Операторы равенства</target>
        </trans-unit>
        <trans-unit id="1f55cac8623bcd3e718c002528aa20c26ca69289" translate="yes" xml:space="preserve">
          <source>Equivalent</source>
          <target state="translated">Equivalent</target>
        </trans-unit>
        <trans-unit id="c0c4f8d56bcbf00282cc105e43dd3c5e2278f8e5" translate="yes" xml:space="preserve">
          <source>Equivalent of</source>
          <target state="translated">Эквивалент</target>
        </trans-unit>
        <trans-unit id="0d5a1140e6675b099ff86f62e1a9eab77af23453" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;getc&lt;/a&gt;(&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">Эквивалент &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;getc&lt;/a&gt;(&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4437d42fc6fd03749f5eff27c4e2e72ba49870e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;fmax&quot;&gt;fmax&lt;/a&gt;(x-y, 0)&lt;/code&gt; except for the NaN handling requirements.</source>
          <target state="translated">Эквивалентен &lt;code&gt;&lt;a href=&quot;fmax&quot;&gt;fmax&lt;/a&gt;(x-y, 0)&lt;/code&gt; за исключением требований к обработке NaN.</target>
        </trans-unit>
        <trans-unit id="04012d0d49a9a54dad1dc682a3e125bd8fa3f90a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;putc&lt;/a&gt;(ch, &lt;a href=&quot;../io&quot;&gt;stdout&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">Эквивалент &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;putc&lt;/a&gt;(ch, &lt;a href=&quot;../io&quot;&gt;stdout&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3afb8f001e247060377e8e5e40c5712afc040c31" translate="yes" xml:space="preserve">
          <source>Equivalent type</source>
          <target state="translated">Эквивалентный тип</target>
        </trans-unit>
        <trans-unit id="9fc37eb09ee0018dcccc12a37a104dbad90d4bbf" translate="yes" xml:space="preserve">
          <source>Error and gamma functions</source>
          <target state="translated">Функции ошибок и гамма-функции</target>
        </trans-unit>
        <trans-unit id="5343729b1e8d28fc4392758181e1915608251253" translate="yes" xml:space="preserve">
          <source>Error directive</source>
          <target state="translated">директива об ошибке</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">обработка ошибок</target>
        </trans-unit>
        <trans-unit id="f9c4c6711618f251c4a454ba58410243568d56b8" translate="yes" xml:space="preserve">
          <source>Error handling and special values</source>
          <target state="translated">Обработка ошибок и специальные значения</target>
        </trans-unit>
        <trans-unit id="a70dcd4b1cc80d9067639e0fc5853ef1c8bcd9a3" translate="yes" xml:space="preserve">
          <source>Error numbers</source>
          <target state="translated">Ошибочные номера</target>
        </trans-unit>
        <trans-unit id="9b7991b8ea4ab2716507d16d0d5014effed9479c" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the function is implemented as &lt;code&gt;&lt;a href=&quot;../math/atan2&quot;&gt;atan2&lt;/a&gt;(&lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z), &lt;a href=&quot;creal&quot;&gt;creal&lt;/a&gt;(z))&lt;/code&gt;.</source>
          <target state="translated">Ошибки и особые случаи обрабатываются так, как будто функция реализована как &lt;code&gt;&lt;a href=&quot;../math/atan2&quot;&gt;atan2&lt;/a&gt;(&lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z), &lt;a href=&quot;creal&quot;&gt;creal&lt;/a&gt;(z))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29f3fbec0914aad4f195e9f22c13389761f4eda3" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the function is implemented as &lt;code&gt;&lt;a href=&quot;../math/hypot&quot;&gt;hypot&lt;/a&gt;(&lt;a href=&quot;creal&quot;&gt;creal&lt;/a&gt;(z), &lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z))&lt;/code&gt;.</source>
          <target state="translated">Ошибки и особые случаи обрабатываются как если функция реализована как &lt;code&gt;&lt;a href=&quot;../math/hypot&quot;&gt;hypot&lt;/a&gt;(&lt;a href=&quot;creal&quot;&gt;creal&lt;/a&gt;(z), &lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f8ce90616fde10146b8dfeb4286e7484aadd29d" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;-I * &lt;a href=&quot;casinh&quot;&gt;casinh&lt;/a&gt;(I*z)&lt;/code&gt;.</source>
          <target state="translated">Ошибки и особые случаи обрабатываются так, как будто операция выполняется с помощью &lt;code&gt;-I * &lt;a href=&quot;casinh&quot;&gt;casinh&lt;/a&gt;(I*z)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2ad0fbbd2e9144d24b0206f35348f9eb15a8311" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;-I * &lt;a href=&quot;catanh&quot;&gt;catanh&lt;/a&gt;(I*z)&lt;/code&gt;.</source>
          <target state="translated">Ошибки и особые случаи обрабатываются так, как будто операция реализована с помощью &lt;code&gt;-I * &lt;a href=&quot;catanh&quot;&gt;catanh&lt;/a&gt;(I*z)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6535634d0df324c4614ac7796d64c3f99bbff78e" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;-I * &lt;a href=&quot;csinh&quot;&gt;csinh&lt;/a&gt;(I*z)&lt;/code&gt;.</source>
          <target state="translated">Ошибки и особые случаи обрабатываются так, как будто операция реализована с помощью &lt;code&gt;-I * &lt;a href=&quot;csinh&quot;&gt;csinh&lt;/a&gt;(I*z)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48bd51bf26820b80bd7f413a44a3c11a3b8a5518" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;-i * &lt;a href=&quot;ctanh&quot;&gt;ctanh&lt;/a&gt;(i*z)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the imaginary unit.</source>
          <target state="translated">Ошибки и особые случаи обрабатываются так, как будто операция реализуется с помощью &lt;code&gt;-i * &lt;a href=&quot;ctanh&quot;&gt;ctanh&lt;/a&gt;(i*z)&lt;/code&gt; , где &lt;code&gt;i&lt;/code&gt; - мнимая единица.</target>
        </trans-unit>
        <trans-unit id="ddccf748db358f35c8fb537b8295656e86fda50d" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;&lt;a href=&quot;ccosh&quot;&gt;ccosh&lt;/a&gt;(I*z)&lt;/code&gt;.</source>
          <target state="translated">Ошибки и особые случаи обрабатываются так, как будто операция выполняется &lt;code&gt;&lt;a href=&quot;ccosh&quot;&gt;ccosh&lt;/a&gt;(I*z)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="015370df3b3d878085ca7e1b0df922c105e8a2f7" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;&lt;a href=&quot;cexp&quot;&gt;cexp&lt;/a&gt;(y*&lt;a href=&quot;clog&quot;&gt;clog&lt;/a&gt;(x))&lt;/code&gt;, except that the implementation is allowed to treat special cases more carefully.</source>
          <target state="translated">Ошибки и особые случаи обрабатываются так, как будто операция реализована с помощью &lt;code&gt;&lt;a href=&quot;cexp&quot;&gt;cexp&lt;/a&gt;(y*&lt;a href=&quot;clog&quot;&gt;clog&lt;/a&gt;(x))&lt;/code&gt; , за исключением того, что реализация позволяет обрабатывать особые случаи более осторожно.</target>
        </trans-unit>
        <trans-unit id="5664fd51a61bce212813ac45ba91c49cd919c4bb" translate="yes" xml:space="preserve">
          <source>Errors are reported as specified in &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">Ошибки сообщаются как указано в &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7331ffbc406cc972b5f70c046e3dc2cb4171b6f9" translate="yes" xml:space="preserve">
          <source>Errors are reported consistent with &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">Об ошибках сообщается в соответствии с &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4cfe1f435f06beaae8e7d7c6d43e5dddbe640bb" translate="yes" xml:space="preserve">
          <source>Escape</source>
          <target state="translated">Escape</target>
        </trans-unit>
        <trans-unit id="aa094bf265d4ea86b5f894d7a380cedfb2baed9e" translate="yes" xml:space="preserve">
          <source>Escape sequences</source>
          <target state="translated">Побеговые последовательности</target>
        </trans-unit>
        <trans-unit id="85839c11b208637a83e2015db29c3b0304d083b7" translate="yes" xml:space="preserve">
          <source>Escape sequences are used to represent certain special characters within &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; and &lt;a href=&quot;character_constant&quot;&gt;character constants&lt;/a&gt;.</source>
          <target state="translated">Escape-последовательности используются для представления определенных специальных символов внутри &lt;a href=&quot;string_literal&quot;&gt;строковых литералов&lt;/a&gt; и &lt;a href=&quot;character_constant&quot;&gt;символьных констант&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="47781613c9e738b50e8ae9c4be68dba24be3e79d" translate="yes" xml:space="preserve">
          <source>Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by &lt;code&gt;order&lt;/code&gt;, between a thread and a signal handler executed on the same thread. This is equivalent to &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;atomic_thread_fence&lt;/a&gt;&lt;/code&gt;, except no CPU instructions for memory ordering are issued. Only reordering of the instructions by the compiler is suppressed as &lt;code&gt;order&lt;/code&gt; instructs. For example, a fence with release semantics prevents reads or writes from being moved past subsequent writes and a fence with acquire semantics prevents reads or writes from being moved ahead of preceding reads.</source>
          <target state="translated">Устанавливает порядок синхронизации памяти неатомарного и расслабленного атомарного доступа, как указано в &lt;code&gt;order&lt;/code&gt; , между потоком и обработчиком сигнала, выполняемым в одном потоке. Это эквивалентно &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;atomic_thread_fence&lt;/a&gt;&lt;/code&gt; , за исключением того, что не выдаются инструкции процессора для упорядочения памяти. Только переупорядочивание инструкций компилятором подавляется в &lt;code&gt;order&lt;/code&gt; указаниями порядка . Например, ограничитель с семантикой выпуска предотвращает перемещение операций чтения или записи после последующих записей, а ограничитель с семантикой получения предотвращает перемещение операций чтения или записи перед предшествующими операциями чтения.</target>
        </trans-unit>
        <trans-unit id="048318643abdfe7a81cc91065c11083e88436879" translate="yes" xml:space="preserve">
          <source>Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by &lt;code&gt;order&lt;/code&gt;, without an associated atomic operation. For example, all non-atomic and relaxed atomic stores that happen before a &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_release&lt;/a&gt;&lt;/code&gt; fence in thread A will be synchronized with non-atomic and relaxed atomic loads from the same locations made in thread B after an &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_acquire&lt;/a&gt;&lt;/code&gt; fence.</source>
          <target state="translated">Устанавливает порядок синхронизации памяти неатомарного и расслабленного атомного доступа в соответствии с инструкциями по &lt;code&gt;order&lt;/code&gt; , без связанной атомарной операции. Например, все &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_release&lt;/a&gt;&lt;/code&gt; и расслабленные атомарные хранилища, которые происходят перед забором памяти memory_order_release в потоке A, будут синхронизированы с неатомарными и расслабленными атомарными нагрузками из тех же местоположений, которые сделаны в потоке B после забора &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_acquire&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da7594d31984baf99a077013f0aee618827920d2" translate="yes" xml:space="preserve">
          <source>Evaluation order and sequencing</source>
          <target state="translated">Порядок и последовательность оценки</target>
        </trans-unit>
        <trans-unit id="88a2bca2793ae8a8d628ac99dc40807e8857f907" translate="yes" xml:space="preserve">
          <source>Evaluations</source>
          <target state="translated">Evaluations</target>
        </trans-unit>
        <trans-unit id="36ee6d82a71221af57f6cb7a03ba7685ffbfddc0" translate="yes" xml:space="preserve">
          <source>Even if the struct is declared at file scope, when the identifier used to access the struct has block scope, the aliasing assertions in the struct also have block scope; the aliasing assertions are only in effect within a block execution or a function call, depending on how the object of this struct type was created:</source>
          <target state="translated">Даже если структура объявлена в файловой области видимости,когда идентификатор,используемый для доступа к структуре,имеет блочную область видимости,псевдонимы в структуре также имеют блочную область видимости;псевдонимы действуют только в пределах выполнения блока или вызова функции,в зависимости от того,как был создан объект этого типа структуры:</target>
        </trans-unit>
        <trans-unit id="4d9633b8291e518788e5b04c3307f8044e23b7cb" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;%c&lt;/code&gt; expects &lt;code&gt;int&lt;/code&gt; argument, it is safe to pass a &lt;code&gt;char&lt;/code&gt; because of the integer promotion that takes place when a variadic function is called.</source>
          <target state="translated">Несмотря на то, что &lt;code&gt;%c&lt;/code&gt; ожидает аргумент &lt;code&gt;int&lt;/code&gt; , безопасно передавать &lt;code&gt;char&lt;/code&gt; из-за целочисленного преобразования, которое происходит при вызове функции с переменным числом аргументов.</target>
        </trans-unit>
        <trans-unit id="5b93cdea25ae5893703b1e0c9f4bb48b32e72ce3" translate="yes" xml:space="preserve">
          <source>Even though the number of bits in the object representation of &lt;code&gt;_Bool&lt;/code&gt; is at least &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt;, the width of the bit field of type &lt;code&gt;_Bool&lt;/code&gt; cannot be greater than 1.</source>
          <target state="translated">Несмотря на то, что число битов в объектном представлении &lt;code&gt;_Bool&lt;/code&gt; не меньше &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt; , ширина поля битов типа &lt;code&gt;_Bool&lt;/code&gt; не может быть больше 1.</target>
        </trans-unit>
        <trans-unit id="10fd3c8aba749cc32d306face2dcaddfb71e36f1" translate="yes" xml:space="preserve">
          <source>Even though there is no specific limit on the length of identifiers, early compilers had limits on the number of significant initial characters in identifiers and the linkers imposed stricter limits on the names with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;. C requires that at least the following limits are supported by any standard-compliant implementation:</source>
          <target state="translated">Несмотря на то, что нет конкретного ограничения на длину идентификаторов, ранние компиляторы имели ограничения на количество значимых начальных символов в идентификаторах, а компоновщики налагали более строгие ограничения на имена с &lt;a href=&quot;storage_duration&quot;&gt;внешней связью&lt;/a&gt; . C требует, чтобы по крайней мере следующие ограничения поддерживались любой стандартной реализацией:</target>
        </trans-unit>
        <trans-unit id="34f56d64ef5c3ff1c58a58a3f028aec046f7ad01" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;conversion&quot;&gt;implicit conversion as if by assignment&lt;/a&gt; is allowed.</source>
          <target state="translated">Каждое &lt;a href=&quot;conversion&quot;&gt;неявное преобразование, как будто по присваиванию&lt;/a&gt; , разрешено.</target>
        </trans-unit>
        <trans-unit id="0552d54ca99d47b5775e0a8174d152fba75dddd0" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;object&quot;&gt;object&lt;/a&gt; has a property called</source>
          <target state="translated">Каждый &lt;a href=&quot;object&quot;&gt;объект&lt;/a&gt; имеет свойство с именем</target>
        </trans-unit>
        <trans-unit id="79fb7987aac6f001bd1913612f374a0a305f404f" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;object&quot;&gt;object&lt;/a&gt; in C exists, has a constant address, retains its last-stored value (except when the value is indeterminate), and, for VLA, retains its size(since C99) over a portion of program execution known as this object's</source>
          <target state="translated">Каждый &lt;a href=&quot;object&quot;&gt;объект&lt;/a&gt; в C существует, имеет постоянный адрес, сохраняет свое последнее сохраненное значение (кроме случаев, когда значение не определено), а для VLA сохраняет свой размер (начиная с C99) в течение части выполнения программы, известной как этот объект.</target>
        </trans-unit>
        <trans-unit id="d8cff106094b582cf23eb28cf52ff54b75ae2920" translate="yes" xml:space="preserve">
          <source>Every C program coded to run in a hosted execution environment contains the definition (not the prototype) of a function called &lt;code&gt;main&lt;/code&gt;, which is the designated start of the program.</source>
          <target state="translated">Каждая программа на C, написанная для запуска в размещенной среде выполнения, содержит определение (а не прототип) функции с именем &lt;code&gt;main&lt;/code&gt; , которая является назначенным началом программы.</target>
        </trans-unit>
        <trans-unit id="cae676f55ead9bfd321ee42d49211710fc97d787" translate="yes" xml:space="preserve">
          <source>Every access (both read and write) made through an lvalue expression of volatile-qualified type is considered an observable side effect for the purpose of optimization and is evaluated strictly according to the rules of the abstract machine (that is, all writes are completed at some time before the next sequence point). This means that within a single thread of execution, a volatile access cannot be optimized out or reordered relative to another visible side effect that is separated by a &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt; from the volatile access.</source>
          <target state="translated">Каждый доступ (как чтение, так и запись), сделанный через выражение lvalue типа volatile-квалифицированного, считается наблюдаемым побочным эффектом с целью оптимизации и оценивается строго в соответствии с правилами абстрактной машины (то есть все записи завершаются в некоторое время до следующей точки последовательности). Это означает, что в пределах одного потока выполнения энергозависимый доступ не может быть оптимизирован или переупорядочен относительно другого видимого побочного эффекта, который отделен &lt;a href=&quot;eval_order&quot;&gt;точкой последовательности&lt;/a&gt; от энергозависимого доступа.</target>
        </trans-unit>
        <trans-unit id="df1932660c52d52e2e26dcedc3c43bd56fad8d39" translate="yes" xml:space="preserve">
          <source>Every complete &lt;a href=&quot;types#Type_groups&quot;&gt;object type&lt;/a&gt; has a property called</source>
          <target state="translated">Каждый полный &lt;a href=&quot;types#Type_groups&quot;&gt;тип объекта&lt;/a&gt; имеет свойство с именем</target>
        </trans-unit>
        <trans-unit id="e8fde6683e1cba2eec62200fcab6dfb05315c256" translate="yes" xml:space="preserve">
          <source>Every declaration of an &lt;a href=&quot;enum&quot;&gt;enum&lt;/a&gt; or a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; is a definition.</source>
          <target state="translated">Каждая декларация на &lt;a href=&quot;enum&quot;&gt;перечислении&lt;/a&gt; или &lt;a href=&quot;typedef&quot;&gt;ЬурейеМ&lt;/a&gt; является определением.</target>
        </trans-unit>
        <trans-unit id="b050826ffcdfc3e1e44f6fc0d20279eecea1e997" translate="yes" xml:space="preserve">
          <source>Every expression belongs to one of three value categories: lvalue, non-lvalue object (rvalue), and function designator.</source>
          <target state="translated">Каждое выражение принадлежит одной из трех категорий значений:lvalue,non-lvalue object (rvalue),и обозначение функции.</target>
        </trans-unit>
        <trans-unit id="5d22a5219034805f8cbb9d13ebb2c2aa525868ea" translate="yes" xml:space="preserve">
          <source>Every expression in the initializer list must be a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; when initializing aggregates of any storage duration.</source>
          <target state="translated">Каждое выражение в списке инициализатора должно быть &lt;a href=&quot;constant_expression&quot;&gt;постоянным выражением&lt;/a&gt; при инициализации агрегатов любой продолжительности хранения.</target>
        </trans-unit>
        <trans-unit id="8061fc72228b0f11d8e5fe2acd66cf7973c92c06" translate="yes" xml:space="preserve">
          <source>Every identifier other than macro name or macro parameter name has &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;, belongs to a &lt;a href=&quot;name_space&quot;&gt;name space&lt;/a&gt;, and may have &lt;a href=&quot;storage_duration&quot;&gt;linkage&lt;/a&gt;. The same identifier can denote different entities at different points in the program, or may denote different entities at the same point if the entities are in different name spaces.</source>
          <target state="translated">Каждый идентификатор, кроме имени макроса или имени параметра макроса, имеет &lt;a href=&quot;scope&quot;&gt;область видимости&lt;/a&gt; , принадлежит &lt;a href=&quot;name_space&quot;&gt;пространству имен&lt;/a&gt; и может иметь &lt;a href=&quot;storage_duration&quot;&gt;связь&lt;/a&gt; . Один и тот же идентификатор может обозначать разные объекты в разных точках программы или может обозначать разные объекты в одной и той же точке, если объекты находятся в разных пространствах имен.</target>
        </trans-unit>
        <trans-unit id="28bf02b780b942d327d4765f8dca30714c80b2c2" translate="yes" xml:space="preserve">
          <source>Every object has an</source>
          <target state="translated">Каждый объект имеет</target>
        </trans-unit>
        <trans-unit id="2cb5903e11e24e79124c7b84f8abc476a4f4997a" translate="yes" xml:space="preserve">
          <source>Every object has.</source>
          <target state="translated">У каждого объекта есть.</target>
        </trans-unit>
        <trans-unit id="0cae74747ce921ce4dc2761826efeaa22990fc6f" translate="yes" xml:space="preserve">
          <source>Exact</source>
          <target state="translated">Exact</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="0846421fa4d44dac1b26a7842a49c3943013e9ff" translate="yes" xml:space="preserve">
          <source>Except for &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;, objects are composed of contiguous sequences of one or more bytes, each consisting of &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt; bits, and can be copied with &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; into an object of type &lt;code&gt;unsigned char[n]&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the size of the object. The contents of the resulting array are known as</source>
          <target state="translated">За исключением &lt;a href=&quot;bit_field&quot;&gt;битовых полей&lt;/a&gt; , объекты состоят из смежных последовательностей из одного или нескольких байтов, каждый из которых состоит из битов &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt; , и могут быть скопированы с помощью &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; в объект типа &lt;code&gt;unsigned char[n]&lt;/code&gt; , где &lt;code&gt;n&lt;/code&gt; - размер объекта. Содержимое полученного массива известно как</target>
        </trans-unit>
        <trans-unit id="a4c65a0cba6faa6401c55873ee72909d9d343ce9" translate="yes" xml:space="preserve">
          <source>Except if the type of expression is a &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt;, (since C99)expression is not evaluated and the &lt;code&gt;sizeof&lt;/code&gt; operator may be used in an integer &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt;.</source>
          <target state="translated">За исключением случаев, когда типом выражения является &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt; , (с C99) выражение не оценивается, и оператор &lt;code&gt;sizeof&lt;/code&gt; может использоваться в &lt;a href=&quot;constant_expression&quot;&gt;выражении&lt;/a&gt; с целочисленной константой .</target>
        </trans-unit>
        <trans-unit id="c82c4955ac4c657fe3c1c1a33c42f14589789f17" translate="yes" xml:space="preserve">
          <source>Except the redundant parentheses around the identifier are meaningful in a type-name and represent &quot;function with no parameter specification&quot;:</source>
          <target state="translated">За исключением лишних круглых скобок вокруг идентификатора,которые имеют смысл в имени типа и представляют собой &quot;функцию без указания параметров&quot;:</target>
        </trans-unit>
        <trans-unit id="c39d3a34e7546d37d567982f43f1e3ec730f1f22" translate="yes" xml:space="preserve">
          <source>Except within a &lt;a href=&quot;language/character_constant&quot;&gt;character constant&lt;/a&gt;, a &lt;a href=&quot;language/string_literal&quot;&gt;string literal&lt;/a&gt;, or a comment, the characters &lt;code&gt;/*&lt;/code&gt; introduce a comment. The contents of such a comment are examined only to identify multibyte characters and to find the characters &lt;code&gt;*/&lt;/code&gt; that terminate the comment. C-style comments cannot be nested.</source>
          <target state="translated">За исключением &lt;a href=&quot;language/character_constant&quot;&gt;символьной константы&lt;/a&gt; , &lt;a href=&quot;language/string_literal&quot;&gt;строкового литерала&lt;/a&gt; или комментария, символы &lt;code&gt;/*&lt;/code&gt; вводят комментарий. Содержимое такого комментария проверяется только для идентификации многобайтовых символов и для поиска символов &lt;code&gt;*/&lt;/code&gt; , которые заканчивают комментарий. Комментарии в стиле C не могут быть вложенными.</target>
        </trans-unit>
        <trans-unit id="bddc2538ec8959f0494f56c6df15dc6c8b6728c6" translate="yes" xml:space="preserve">
          <source>Except within a &lt;a href=&quot;language/character_constant&quot;&gt;character constant&lt;/a&gt;, a &lt;a href=&quot;language/string_literal&quot;&gt;string literal&lt;/a&gt;, or a comment, the characters &lt;code&gt;//&lt;/code&gt; introduce a comment that includes all multibyte characters up to, but not including, the next new-line character. The contents of such a comment are examined only to identify multibyte characters and to find the new-line character that terminates the comment. C++-style comments can be nested:</source>
          <target state="translated">За исключением &lt;a href=&quot;language/character_constant&quot;&gt;символьной константы&lt;/a&gt; , &lt;a href=&quot;language/string_literal&quot;&gt;строкового литерала&lt;/a&gt; или комментария, символы &lt;code&gt;//&lt;/code&gt; вводят комментарий, который включает все многобайтовые символы вплоть до следующего символа новой строки, но не включает его. Содержимое такого комментария проверяется только для определения многобайтовых символов и для поиска символа новой строки, который завершает комментарий. Комментарии в стиле C ++ могут быть вложенными:</target>
        </trans-unit>
        <trans-unit id="3f8a730b7e50f87ea67dec5244562816a07b3aaa" translate="yes" xml:space="preserve">
          <source>Executes a loop.</source>
          <target state="translated">Выполняет петлю.</target>
        </trans-unit>
        <trans-unit id="2134926c41a5af01a113605847abc27742273c7e" translate="yes" xml:space="preserve">
          <source>Executes a statement repeatedly until the value of condition becomes false. The test takes place after each iteration.</source>
          <target state="translated">Выполняет операцию повторно до тех пор,пока значение условия не станет ложным.Тест происходит после каждой итерации.</target>
        </trans-unit>
        <trans-unit id="11f93f9b195c7cd21096794e98c03a7027da2f79" translate="yes" xml:space="preserve">
          <source>Executes a statement repeatedly, until the value of expression becomes equal to zero. The test takes place before each iteration.</source>
          <target state="translated">Выполняет операцию несколько раз,пока значение выражения не станет равным нулю.Тест происходит перед каждой итерацией.</target>
        </trans-unit>
        <trans-unit id="85e7dec4537bfae2058cca4e9884515a8b83fb5b" translate="yes" xml:space="preserve">
          <source>Executes code according to the value of an integral argument.</source>
          <target state="translated">Выполняет код в соответствии со значением интегрального аргумента.</target>
        </trans-unit>
        <trans-unit id="27cfa9eee3e7ceef3b1e500e47b1e1610a8c97f4" translate="yes" xml:space="preserve">
          <source>Executing the &lt;code&gt;return&lt;/code&gt; statement in a &lt;a href=&quot;_noreturn&quot;&gt;no-return function&lt;/a&gt; is undefined behavior.</source>
          <target state="translated">Выполнение &lt;code&gt;return&lt;/code&gt; заявление в &lt;a href=&quot;_noreturn&quot;&gt;функции нет обратного&lt;/a&gt; не определено поведение.</target>
        </trans-unit>
        <trans-unit id="28c764ed1d6222630406c5783a2aaab97f66bd88" translate="yes" xml:space="preserve">
          <source>Expanded value</source>
          <target state="translated">Расширенное значение</target>
        </trans-unit>
        <trans-unit id="2c1bd25ffde3db50385bd1702ced6f7b127db28b" translate="yes" xml:space="preserve">
          <source>Expands to</source>
          <target state="translated">Расширяется до</target>
        </trans-unit>
        <trans-unit id="8faacdf8b7af79664977eafc89be9750aba9f6d1" translate="yes" xml:space="preserve">
          <source>Expands to &lt;a href=&quot;../language/constant_expression&quot;&gt;preprocessor constant expressions&lt;/a&gt; that evaluate to either &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, or &lt;code&gt;2&lt;/code&gt; which indicate the lock-free property of the corresponding &lt;a href=&quot;../atomic&quot;&gt;atomic types&lt;/a&gt; (both signed and unsigned).</source>
          <target state="translated">Расширяется до &lt;a href=&quot;../language/constant_expression&quot;&gt;константных выражений препроцессора,&lt;/a&gt; которые оцениваются в &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; или &lt;code&gt;2&lt;/code&gt; , что указывает на свойство без блокировки соответствующих &lt;a href=&quot;../atomic&quot;&gt;атомарных типов&lt;/a&gt; (как со знаком, так и без знака).</target>
        </trans-unit>
        <trans-unit id="4945de103990c828d28d11116d17a1455abd773d" translate="yes" xml:space="preserve">
          <source>Expands to a positive integral &lt;a href=&quot;../language/constant_expression&quot;&gt;constant expression&lt;/a&gt; defining the maximum number of times a destructor for thread-local storage pointer will be called by &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Расширяется до положительного целочисленного &lt;a href=&quot;../language/constant_expression&quot;&gt;константного выражения,&lt;/a&gt; определяющего максимальное количество раз, которое деструктор для локального указателя памяти потока будет вызываться &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ac04c5b090acc87427f403a76810b032235784c" translate="yes" xml:space="preserve">
          <source>Expands to an expression (not necessarily a compile-time constant) of type &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;clock_t&lt;/a&gt;&lt;/code&gt; equal to the number of clock ticks per second, as returned by &lt;code&gt;&lt;a href=&quot;clock&quot;&gt;clock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Расширяется до выражения (необязательно константы времени компиляции) типа &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;clock_t&lt;/a&gt;&lt;/code&gt; , равного количеству тактов в секунду, возвращаемому &lt;code&gt;&lt;a href=&quot;clock&quot;&gt;clock()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63f947b1d73753094d1ae7232094c3d68be133d1" translate="yes" xml:space="preserve">
          <source>Expands to an expression that can be used to initialize &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;atomic_flag&lt;/a&gt;&lt;/code&gt; type. The value &lt;code&gt;atomic_flag&lt;/code&gt; that is not initialized using this macro is undefined.</source>
          <target state="translated">Расширяется до выражения, которое можно использовать для инициализации типа &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;atomic_flag&lt;/a&gt;&lt;/code&gt; . Значение &lt;code&gt;atomic_flag&lt;/code&gt; , которое не инициализировано с помощью этого макроса, не определено.</target>
        </trans-unit>
        <trans-unit id="6e54e6049cc9eea669bc3e5a4c9bc5a1dfc7508f" translate="yes" xml:space="preserve">
          <source>Expands to an expression that can be used to initialize an atomic variable of the same type as &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Расширяется до выражения, которое можно использовать для инициализации атомарной переменной того же типа, что и &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8db16a62cd0eecafad46f2d6c4cb160336ba4375" translate="yes" xml:space="preserve">
          <source>Expands to an integer constant expression equal to the maximum value returned by the function &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt;. This value is implementation dependent. It's guaranteed that this value is at least &lt;code&gt;32767&lt;/code&gt;.</source>
          <target state="translated">Расширяется до целочисленного константного выражения, равного максимальному значению, возвращаемому функцией &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; . Это значение зависит от реализации. Гарантируется, что это значение не менее &lt;code&gt;32767&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b74a3f6f88cbf8779ab38cebe0c4e5a1aa35bcc5" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;double&lt;/code&gt; expression that indicates overflow, not necessarily representable as a &lt;code&gt;float&lt;/code&gt;</source>
          <target state="translated">Расширяется до положительного &lt;code&gt;double&lt;/code&gt; выражения, которое указывает на переполнение, не обязательно представляемое как число с &lt;code&gt;float&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f5ccabdc1716ee0f1f6ba421bfe7a3cb18e19e27" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;float&lt;/code&gt; expression that indicates overflow</source>
          <target state="translated">Расширяется до положительного выражения с &lt;code&gt;float&lt;/code&gt; которое указывает на переполнение</target>
        </trans-unit>
        <trans-unit id="1517f254032c8417e8afa57de1c3cc258d11f6c4" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;long double&lt;/code&gt; expression that indicates overflow, not necessarily representable as a &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;</source>
          <target state="translated">Расширяется до положительного &lt;code&gt;long double&lt;/code&gt; выражения, которое указывает на переполнение, не обязательно представляемое как число с &lt;code&gt;float&lt;/code&gt; или &lt;code&gt;double&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="9871eb9d9db410b188224356bf06656bc0125776" translate="yes" xml:space="preserve">
          <source>Explicit initialization</source>
          <target state="translated">Явная инициализация</target>
        </trans-unit>
        <trans-unit id="dd8bfe3fdab8ac97b580b2a4aef0404f178b5ac1" translate="yes" xml:space="preserve">
          <source>Exponential functions</source>
          <target state="translated">Экспоненциальные функции</target>
        </trans-unit>
        <trans-unit id="af1ce2aaa5c978ee528dbd127a42e4189e15865d" translate="yes" xml:space="preserve">
          <source>Expression evaluation may produce a result (e.g., evaluation of &lt;code&gt;2+2&lt;/code&gt; produces the result &lt;code&gt;4&lt;/code&gt;), may generate side-effects (e.g. evaluation of &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;printf&lt;/a&gt;(&quot;%d&quot;,4)&lt;/code&gt; sends the character &lt;code&gt;'4'&lt;/code&gt; to the standard output stream), and may designate objects or functions.</source>
          <target state="translated">Оценка выражения может давать результат (например, оценка &lt;code&gt;2+2&lt;/code&gt; дает результат &lt;code&gt;4&lt;/code&gt; ), может генерировать побочные эффекты (например, оценка &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;printf&lt;/a&gt;(&quot;%d&quot;,4)&lt;/code&gt; отправляет символ &lt;code&gt;'4'&lt;/code&gt; в стандартный поток вывода) и может обозначать объекты или функции.</target>
        </trans-unit>
        <trans-unit id="0a7a6ba0d7d2af3106edf9d912c2fc5a47512f54" translate="yes" xml:space="preserve">
          <source>Expression statements</source>
          <target state="translated">Заявления о выражении мнений</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="f353e8f82ea2aa488317fc7d8263ec638f8988ee" translate="yes" xml:space="preserve">
          <source>Expressions that are used in the &lt;a href=&quot;initialization&quot;&gt;initializers&lt;/a&gt; of objects with static and thread_local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; must be expressions that may be one of the following.</source>
          <target state="translated">Выражения, которые используются в &lt;a href=&quot;initialization&quot;&gt;инициализаторах&lt;/a&gt; объектов со статической и продолжительностью &lt;a href=&quot;storage_duration&quot;&gt;хранения&lt;/a&gt; thread_local, должны быть выражениями, которые могут быть одним из следующих.</target>
        </trans-unit>
        <trans-unit id="73a249c29d63b610061072ac728997168ac1fe92" translate="yes" xml:space="preserve">
          <source>Extended multibyte and wide character utilities</source>
          <target state="translated">Расширенные многобайтовые и широкоформатные утилиты</target>
        </trans-unit>
        <trans-unit id="29449f104db7b7f4060421a59f2c8652fcaf7414" translate="yes" xml:space="preserve">
          <source>External and tentative definitions</source>
          <target state="translated">Внешние и предварительные определения</target>
        </trans-unit>
        <trans-unit id="f92e601eb8d663033dca3851ad6f1616d1966aa7" translate="yes" xml:space="preserve">
          <source>External links</source>
          <target state="translated">Внешние ссылки</target>
        </trans-unit>
        <trans-unit id="77c407388266a4e5e937fe92a0ce467e4d5cf334" translate="yes" xml:space="preserve">
          <source>F.10.1.1 The acos functions (p: 518)</source>
          <target state="translated">F.10.1.1 Активные функции (стр.518)</target>
        </trans-unit>
        <trans-unit id="cad3287a73936ba75ca64c1f05a0a540c8022d26" translate="yes" xml:space="preserve">
          <source>F.10.1.2 The asin functions (p: 518)</source>
          <target state="translated">F.10.1.2 Асинхронные функции (стр.518)</target>
        </trans-unit>
        <trans-unit id="9ef85f92ec5474ff35787d85c82c58bf7b470d4a" translate="yes" xml:space="preserve">
          <source>F.10.1.3 The atan functions (p: 519)</source>
          <target state="translated">F.10.1.3 Функции атана (стр.519)</target>
        </trans-unit>
        <trans-unit id="61654a10c29f6924e433f111ed48191ac88a2ce3" translate="yes" xml:space="preserve">
          <source>F.10.1.4 The atan2 functions (p: 519)</source>
          <target state="translated">F.10.1.4 Функции атана2 (стр.519)</target>
        </trans-unit>
        <trans-unit id="6b87bded088091f390f6ffad328a772e7e512e59" translate="yes" xml:space="preserve">
          <source>F.10.1.5 The cos functions (p: 519)</source>
          <target state="translated">F.10.1.5 Космические функции (стр.519)</target>
        </trans-unit>
        <trans-unit id="d91aaea4c9d5123a333ed526b7019e6fe8161791" translate="yes" xml:space="preserve">
          <source>F.10.1.6 The sin functions (p: 519)</source>
          <target state="translated">F.10.1.6 Функции греха (стр.519)</target>
        </trans-unit>
        <trans-unit id="037480d4008aac1c2ced1847c0d6506eaff99f02" translate="yes" xml:space="preserve">
          <source>F.10.1.7 The tan functions (p: 519)</source>
          <target state="translated">F.10.1.7 Функции загара (стр.519)</target>
        </trans-unit>
        <trans-unit id="39ece3e4b919950cc9aef1f79b7ea2b485b2f749" translate="yes" xml:space="preserve">
          <source>F.10.10.1 The fma functions (p: 530)</source>
          <target state="translated">F.10.10.1 Функции fma (стр.530)</target>
        </trans-unit>
        <trans-unit id="d4f406e24acff82500d3f53854f757aefe80a88b" translate="yes" xml:space="preserve">
          <source>F.10.11 Comparison macros (p: 531)</source>
          <target state="translated">F.10.11 Макросы сравнения (стр.531)</target>
        </trans-unit>
        <trans-unit id="9b3f0ad6a5d5f3bdc88332446b21be594cf5b850" translate="yes" xml:space="preserve">
          <source>F.10.2.1 The acosh functions (p: 520)</source>
          <target state="translated">F.10.2.1 Акош-функции (стр.520)</target>
        </trans-unit>
        <trans-unit id="e8a5915d0ff8e75d37c89114700efa34fcb3655c" translate="yes" xml:space="preserve">
          <source>F.10.2.2 The asinh functions (p: 520)</source>
          <target state="translated">F.10.2.2 Функции асинх (стр.520)</target>
        </trans-unit>
        <trans-unit id="38d01d22054b31ca110c70ecab03b46da04ddbde" translate="yes" xml:space="preserve">
          <source>F.10.2.3 The atanh functions (p: 520)</source>
          <target state="translated">F.10.2.3 Функции атана (стр.520)</target>
        </trans-unit>
        <trans-unit id="6d1dcd9f7c26773cd7824edef93f2bc153fcedd1" translate="yes" xml:space="preserve">
          <source>F.10.2.4 The cosh functions (p: 520)</source>
          <target state="translated">F.10.2.4 Космические функции (стр.520)</target>
        </trans-unit>
        <trans-unit id="958c262e658f94cec62537f399da067e4b2a3687" translate="yes" xml:space="preserve">
          <source>F.10.2.5 The sinh functions (p: 520)</source>
          <target state="translated">F.10.2.5 Функции синуса (стр.520)</target>
        </trans-unit>
        <trans-unit id="89846dc268c67d448208698d5fb48751a4fa3ee7" translate="yes" xml:space="preserve">
          <source>F.10.2.6 The tanh functions (p: 520)</source>
          <target state="translated">F.10.2.6 Функции танца (стр.520)</target>
        </trans-unit>
        <trans-unit id="087ba78251d8a6578f4172770ba9fb671bdc2930" translate="yes" xml:space="preserve">
          <source>F.10.3.1 The exp functions (p: 520)</source>
          <target state="translated">F.10.3.1 Эксплуатационные функции (стр.520)</target>
        </trans-unit>
        <trans-unit id="d2f1b4b78961c78fd097a3f2e3d5c95ac97b0697" translate="yes" xml:space="preserve">
          <source>F.10.3.10 The log2 functions (p: 522)</source>
          <target state="translated">F.10.3.10 Функции журнала2 (стр.522)</target>
        </trans-unit>
        <trans-unit id="794d0f6de81eceae99a02eae8075568628225b13" translate="yes" xml:space="preserve">
          <source>F.10.3.11 The logb functions (p: 522)</source>
          <target state="translated">F.10.3.11 Функции журнала (стр.522)</target>
        </trans-unit>
        <trans-unit id="359790e2c483d46f6d5fa87180647464c9ffd494" translate="yes" xml:space="preserve">
          <source>F.10.3.12 The modf functions (p: 523)</source>
          <target state="translated">F.10.3.12 Модовые функции (стр.523)</target>
        </trans-unit>
        <trans-unit id="26231b94cbb9b4ccc5abf2b75e7483700a200573" translate="yes" xml:space="preserve">
          <source>F.10.3.13 The scalbn functions (p: 523)</source>
          <target state="translated">F.10.3.13 Функции скальбна (стр.523)</target>
        </trans-unit>
        <trans-unit id="c4c4e3a6535940d3ad6a58b578ff6b3f648cea5c" translate="yes" xml:space="preserve">
          <source>F.10.3.2 The exp2 functions (p: 521)</source>
          <target state="translated">F.10.3.2 Функции Exp2 (стр.521)</target>
        </trans-unit>
        <trans-unit id="2ea743c028232e6944fba4cc2a23ead42a73967b" translate="yes" xml:space="preserve">
          <source>F.10.3.3 The expm1 functions (p: 521)</source>
          <target state="translated">F.10.3.3 Функции экспм1 (стр.521)</target>
        </trans-unit>
        <trans-unit id="8b40b0a0ad12eacc6381e986766eb2e5616397d0" translate="yes" xml:space="preserve">
          <source>F.10.3.4 The frexp functions (p: 521)</source>
          <target state="translated">F.10.3.4 Функции фрекс (стр.521)</target>
        </trans-unit>
        <trans-unit id="a0911a9469e43f63891c8efa1bec7f36ad8c8abc" translate="yes" xml:space="preserve">
          <source>F.10.3.5 The ilogb functions (p: 521)</source>
          <target state="translated">F.10.3.5 Функции подвздошной кости (стр.521)</target>
        </trans-unit>
        <trans-unit id="75a2fa7eb5b40194e1e37e5ef123f250b756926a" translate="yes" xml:space="preserve">
          <source>F.10.3.6 The ldexp functions (p: 522)</source>
          <target state="translated">F.10.3.6 Функции ледекса (стр.522)</target>
        </trans-unit>
        <trans-unit id="6f56427ef5bda97f9bd0f1abdca0f2d6c6ff57e8" translate="yes" xml:space="preserve">
          <source>F.10.3.7 The log functions (p: 522)</source>
          <target state="translated">F.10.3.7 Функции журнала (стр.522)</target>
        </trans-unit>
        <trans-unit id="f594a7472fd58a9aac605b75beccc17bd59b8dd5" translate="yes" xml:space="preserve">
          <source>F.10.3.8 The log10 functions (p: 522)</source>
          <target state="translated">F.10.3.8 Функции log10 (стр.522)</target>
        </trans-unit>
        <trans-unit id="a48a20da2597afea4f32bc8128a961f30186bb43" translate="yes" xml:space="preserve">
          <source>F.10.3.9 The log1p functions (p: 522)</source>
          <target state="translated">F.10.3.9 Функции log1p (стр.522)</target>
        </trans-unit>
        <trans-unit id="7e9241bf052c178aa5d7679b82aa2fb1f5f3429f" translate="yes" xml:space="preserve">
          <source>F.10.4.1 The cbrt functions (p: 524)</source>
          <target state="translated">F.10.4.1 Функции cbrt (стр.524)</target>
        </trans-unit>
        <trans-unit id="17febc2a8e0db50799bb968259ec83e250637ecf" translate="yes" xml:space="preserve">
          <source>F.10.4.3 The hypot functions (p: 524)</source>
          <target state="translated">F.10.4.3 Функции гипотезы (стр.524)</target>
        </trans-unit>
        <trans-unit id="625f08597fe348094478d4ebb805e20b1dc18589" translate="yes" xml:space="preserve">
          <source>F.10.4.4 The pow functions (p: 524-525)</source>
          <target state="translated">F.10.4.4 Питание функции (стр.524-525)</target>
        </trans-unit>
        <trans-unit id="25725da8bd22d2591488c89637aeec539180512b" translate="yes" xml:space="preserve">
          <source>F.10.4.5 The sqrt functions (p: 525)</source>
          <target state="translated">F.10.4.5 Функции площадки (стр.525)</target>
        </trans-unit>
        <trans-unit id="16f4c89fcc73a73762071c025286f4c826a965e3" translate="yes" xml:space="preserve">
          <source>F.10.5.1 The erf functions (p: 525)</source>
          <target state="translated">F.10.5.1 Функции erf (стр.525)</target>
        </trans-unit>
        <trans-unit id="206fe7eceb3eeb950c8c0e350ab59cd90863fff1" translate="yes" xml:space="preserve">
          <source>F.10.5.2 The erfc functions (p: 525)</source>
          <target state="translated">F.10.5.2 Функции erfc (стр.525)</target>
        </trans-unit>
        <trans-unit id="6d9ef222b026d1552a6e019e7cec89f1462b487f" translate="yes" xml:space="preserve">
          <source>F.10.5.3 The lgamma functions (p: 525)</source>
          <target state="translated">F.10.5.3 Игамма-функции (стр.525)</target>
        </trans-unit>
        <trans-unit id="f246fcb4689fd18925ec623bbfcc71a41b0465c4" translate="yes" xml:space="preserve">
          <source>F.10.5.4 The tgamma functions (p: 525)</source>
          <target state="translated">F.10.5.4 Тгамма-функции (стр.525)</target>
        </trans-unit>
        <trans-unit id="cb2de2da7dae0b99044effe02f5a47bdaadc48af" translate="yes" xml:space="preserve">
          <source>F.10.6.1 The ceil functions (p: 526)</source>
          <target state="translated">F.10.6.1 Функции потолка (стр.526)</target>
        </trans-unit>
        <trans-unit id="1b33b3f7cf068beaaa2da5d9ab8c39148105a3cc" translate="yes" xml:space="preserve">
          <source>F.10.6.2 The floor functions (p: 526)</source>
          <target state="translated">F.10.6.2 Функции пола (стр.526)</target>
        </trans-unit>
        <trans-unit id="f6ebb7d3b865f6734b8512e6179d7dfe39d6858d" translate="yes" xml:space="preserve">
          <source>F.10.6.3 The nearbyint functions (p: 526)</source>
          <target state="translated">F.10.6.3 Функции поблизости (стр.526)</target>
        </trans-unit>
        <trans-unit id="a84cc296df6994a9fdc52ad5813543f24f3c6cd9" translate="yes" xml:space="preserve">
          <source>F.10.6.4 The rint functions (p: 527)</source>
          <target state="translated">F.10.6.4 Функции корзины (стр.527)</target>
        </trans-unit>
        <trans-unit id="bbda21a32e5ae8a6c9aee9e4c77675635cf84fd8" translate="yes" xml:space="preserve">
          <source>F.10.6.5 The lrint and llrint functions (p: 527)</source>
          <target state="translated">F.10.6.5 Функции печатной машинки и лотка (стр.527)</target>
        </trans-unit>
        <trans-unit id="ec0b999019838cb54ccf2817d9714997b4e40445" translate="yes" xml:space="preserve">
          <source>F.10.6.6 The round functions (p: 527)</source>
          <target state="translated">F.10.6.6 Круглые функции (стр.527)</target>
        </trans-unit>
        <trans-unit id="cb4356e2e5fad9450ac5558563f98452412688f4" translate="yes" xml:space="preserve">
          <source>F.10.6.7 The lround and llround functions (p: 528)</source>
          <target state="translated">F.10.6.7 Функции закругления и закругления (стр.528)</target>
        </trans-unit>
        <trans-unit id="01904666c0e217576f27c19883b11b927df7f8fa" translate="yes" xml:space="preserve">
          <source>F.10.6.8 The trunc functions (p: 528)</source>
          <target state="translated">F.10.6.8 Функции усечения (стр.528)</target>
        </trans-unit>
        <trans-unit id="1c86765d3b2ed0d1a6859351ba51e178fa90edb1" translate="yes" xml:space="preserve">
          <source>F.10.7.1 The fmod functions (p: 528)</source>
          <target state="translated">F.10.7.1 Функции fmod (стр.528)</target>
        </trans-unit>
        <trans-unit id="8b9ef85d99a342671dcbe04d0342fa3a3e7392f4" translate="yes" xml:space="preserve">
          <source>F.10.7.2 The remainder functions (p: 529)</source>
          <target state="translated">F.10.7.2 Остальные функции (стр.529)</target>
        </trans-unit>
        <trans-unit id="ce8ff4da2761f2d7b47d2ff2b92c122baa53063b" translate="yes" xml:space="preserve">
          <source>F.10.7.3 The remquo functions (p: 529)</source>
          <target state="translated">F.10.7.3 Функции ремкво (стр.529)</target>
        </trans-unit>
        <trans-unit id="dc2ed702cd3c1689dcef0d15c6b317b413615b93" translate="yes" xml:space="preserve">
          <source>F.10.8.1 The copysign functions (p: 529)</source>
          <target state="translated">F.10.8.1 Функции копирования (стр.529)</target>
        </trans-unit>
        <trans-unit id="26f00db7b895801e69e888537ca6f5e8e8b77760" translate="yes" xml:space="preserve">
          <source>F.10.8.3 The nextafter functions (p: 529)</source>
          <target state="translated">F.10.8.3 Взаимосвязанные функции (стр.529)</target>
        </trans-unit>
        <trans-unit id="2bd999c6b7635b98e319b1879c7049aacf6a11d7" translate="yes" xml:space="preserve">
          <source>F.10.8.4 The nexttoward functions (p: 529)</source>
          <target state="translated">F.10.8.4 Следующие функции (стр.529)</target>
        </trans-unit>
        <trans-unit id="0558fce2fc34a89230abb55717a1367a84816fb5" translate="yes" xml:space="preserve">
          <source>F.10.9.1 The fdim functions (p: 530)</source>
          <target state="translated">F.10.9.1 Функции fdim (стр.530)</target>
        </trans-unit>
        <trans-unit id="de085a98998c76d2bcfef17bda25b20084cc5503" translate="yes" xml:space="preserve">
          <source>F.10.9.2 The fmax functions (p: 530)</source>
          <target state="translated">F.10.9.2 fmax-функции (стр.530)</target>
        </trans-unit>
        <trans-unit id="9827db1f0b98a7b434030aa176982366a942c2df" translate="yes" xml:space="preserve">
          <source>F.10.9.3 The fmin functions (p: 530)</source>
          <target state="translated">F.10.9.3 Функции fmin (стр.530)</target>
        </trans-unit>
        <trans-unit id="283438cc0f8a76e650782eb735336732fb8b236a" translate="yes" xml:space="preserve">
          <source>F.10/11/13 NAN (p: 518)</source>
          <target state="translated">F.10/11/13 НАН (стр.518)</target>
        </trans-unit>
        <trans-unit id="1be467d83b43dca68a5e634b5535ba14ab6b74a8" translate="yes" xml:space="preserve">
          <source>F.10/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 517)</source>
          <target state="translated">F.10/2 HUGE_VAL,HUGE_VALF,HUGE_VALL (p:517)</target>
        </trans-unit>
        <trans-unit id="28cf2cca0ce08a9451ab3c5d8742e0e21020ea37" translate="yes" xml:space="preserve">
          <source>F.10/4 MATH_ERREXCEPT, math_errhandling (p: 517)</source>
          <target state="translated">F.10/4 MATH_ERREXCEPT,math_errrhandling (стр.517)</target>
        </trans-unit>
        <trans-unit id="603370297957bfb90d8d437aad808f55b97ea754" translate="yes" xml:space="preserve">
          <source>F.9.1.1 The acos functions (p: 455)</source>
          <target state="translated">F.9.1.1 Функции воздушных судов (стр.455)</target>
        </trans-unit>
        <trans-unit id="b0809cf0780a08bb1111998f12d6c4d23aeb9e53" translate="yes" xml:space="preserve">
          <source>F.9.1.2 The asin functions (p: 456)</source>
          <target state="translated">F.9.1.2 Асинхронные функции (стр.456)</target>
        </trans-unit>
        <trans-unit id="a551d81f71a5f9939ce28f69ef0a1e3ca5957298" translate="yes" xml:space="preserve">
          <source>F.9.1.3 The atan functions (p: 456)</source>
          <target state="translated">F.9.1.3 Функции атана (стр.456)</target>
        </trans-unit>
        <trans-unit id="5238a56c052eff99e24c4b6896aa6038f4f427e0" translate="yes" xml:space="preserve">
          <source>F.9.1.4 The atan2 functions (p: 456)</source>
          <target state="translated">F.9.1.4 Функции атана2 (стр.456)</target>
        </trans-unit>
        <trans-unit id="50d63741a36f7483fb2868bf6f151a6b40fd8286" translate="yes" xml:space="preserve">
          <source>F.9.1.5 The cos functions (p: 456)</source>
          <target state="translated">F.9.1.5 Космические функции (стр.456)</target>
        </trans-unit>
        <trans-unit id="637d47c6b863cea5d6635ae1deb6280868ac9ca7" translate="yes" xml:space="preserve">
          <source>F.9.1.6 The sin functions (p: 456)</source>
          <target state="translated">F.9.1.6 Функции греха (стр.456)</target>
        </trans-unit>
        <trans-unit id="861f518e82a65029e3454ffded115bac6bb7868b" translate="yes" xml:space="preserve">
          <source>F.9.1.7 The tan functions (p: 457)</source>
          <target state="translated">F.9.1.7 Функции загара (стр.457)</target>
        </trans-unit>
        <trans-unit id="34bd0de5e368ca614c44962d98536185314635dd" translate="yes" xml:space="preserve">
          <source>F.9.10.1 The fma functions (p: 466)</source>
          <target state="translated">F.9.10.1 Функции fma (стр.466)</target>
        </trans-unit>
        <trans-unit id="f13a5ba17e8846600a005f346f831f5817808357" translate="yes" xml:space="preserve">
          <source>F.9.2.1 The acosh functions (p: 457)</source>
          <target state="translated">F.9.2.1 Акош-функции (стр.457)</target>
        </trans-unit>
        <trans-unit id="1b6f759c08ea790315523a28fc714222e7c34567" translate="yes" xml:space="preserve">
          <source>F.9.2.2 The asinh functions (p: 457)</source>
          <target state="translated">F.9.2.2 Функции асинх (стр.457)</target>
        </trans-unit>
        <trans-unit id="4b776e7f758a71948a8453b4b483c8754328eb1c" translate="yes" xml:space="preserve">
          <source>F.9.2.3 The atanh functions (p: 457)</source>
          <target state="translated">F.9.2.3 Функции атана (стр.457)</target>
        </trans-unit>
        <trans-unit id="6f5e1e5c0e484db0cde4b49868660cf187a8d29a" translate="yes" xml:space="preserve">
          <source>F.9.2.4 The cosh functions (p: 457)</source>
          <target state="translated">F.9.2.4 Космические функции (стр.457)</target>
        </trans-unit>
        <trans-unit id="56312c5c16e0e6e01fd49d38e774bc27c65e72b5" translate="yes" xml:space="preserve">
          <source>F.9.2.5 The sinh functions (p: 457)</source>
          <target state="translated">F.9.2.5 Функции синуса (стр.457)</target>
        </trans-unit>
        <trans-unit id="cb1c2ccbe39e702fed325ed172fd0cff4dbb043c" translate="yes" xml:space="preserve">
          <source>F.9.2.6 The tanh functions (p: 457)</source>
          <target state="translated">F.9.2.6 Функции танца (стр.457)</target>
        </trans-unit>
        <trans-unit id="e645ed3f9b116cd9c05fd565a57b8ab2fc11dfa7" translate="yes" xml:space="preserve">
          <source>F.9.3.1 The exp functions (p: 458)</source>
          <target state="translated">F.9.3.1 Эксплуатационные функции (стр.458)</target>
        </trans-unit>
        <trans-unit id="adefde4f7eb6e1e3299903930c6f911c23307960" translate="yes" xml:space="preserve">
          <source>F.9.3.10 The log2 functions (p: 459)</source>
          <target state="translated">F.9.3.10 Функции журнала2 (стр.459)</target>
        </trans-unit>
        <trans-unit id="e7fc20f76d9f84afe8f473215f95a262986b2742" translate="yes" xml:space="preserve">
          <source>F.9.3.11 The logb functions (p: 459)</source>
          <target state="translated">F.9.3.11 Функции журнала (стр.459)</target>
        </trans-unit>
        <trans-unit id="80e34eb7bbcfaf7246bc2bd46cf60a81f73e8751" translate="yes" xml:space="preserve">
          <source>F.9.3.12 The modf functions (p: 460)</source>
          <target state="translated">F.9.3.12 Модовые функции (стр.460)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
