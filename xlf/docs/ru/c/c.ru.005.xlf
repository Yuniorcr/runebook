<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="c">
    <body>
      <group id="c">
        <trans-unit id="30b4e85b5e57a5e2350b1dc089bac21b6bb3bef1" translate="yes" xml:space="preserve">
          <source>F.9.3.13 The scalbn functions (p: 460)</source>
          <target state="translated">F.9.3.13 Функции скальбна (стр.460)</target>
        </trans-unit>
        <trans-unit id="823c8200c7b53ce2ccd8c3288a0a3a49fad5c22c" translate="yes" xml:space="preserve">
          <source>F.9.3.2 The exp2 functions (p: 458)</source>
          <target state="translated">F.9.3.2 Функции Exp2 (стр.458)</target>
        </trans-unit>
        <trans-unit id="5d366ad2627dd4333d06e173d585adb24b52f19a" translate="yes" xml:space="preserve">
          <source>F.9.3.3 The expm1 functions (p: 458)</source>
          <target state="translated">F.9.3.3 Функции Expm1 (стр.458)</target>
        </trans-unit>
        <trans-unit id="9993bc3ba1519eec52259e286419159d469fe90d" translate="yes" xml:space="preserve">
          <source>F.9.3.4 The frexp functions (p: 458)</source>
          <target state="translated">F.9.3.4 Функции фрекс (стр.458)</target>
        </trans-unit>
        <trans-unit id="b9e61e62cb68745b75b0ed3ce171a6a9e5162df8" translate="yes" xml:space="preserve">
          <source>F.9.3.5 The ilogb functions (p: 458)</source>
          <target state="translated">F.9.3.5 Функции подвздошной кости (стр.458)</target>
        </trans-unit>
        <trans-unit id="d4726c76fee2a471a2931693701495170c5d8163" translate="yes" xml:space="preserve">
          <source>F.9.3.6 The ldexp functions (p: 459)</source>
          <target state="translated">F.9.3.6 Функции ледекса (стр.459)</target>
        </trans-unit>
        <trans-unit id="6092518ebd2f95991e460724ebab3f88acec5168" translate="yes" xml:space="preserve">
          <source>F.9.3.7 The log functions (p: 459)</source>
          <target state="translated">F.9.3.7 Функции журнала (стр.459)</target>
        </trans-unit>
        <trans-unit id="2c0b8c3a7302a2e8487ec23c4264320fa6a1efbe" translate="yes" xml:space="preserve">
          <source>F.9.3.8 The log10 functions (p: 459)</source>
          <target state="translated">F.9.3.8 Функции log10 (стр.459)</target>
        </trans-unit>
        <trans-unit id="18b53619814f88666c327ab91b69281ea797e78f" translate="yes" xml:space="preserve">
          <source>F.9.3.9 The log1p functions (p: 459)</source>
          <target state="translated">F.9.3.9 Функции log1p (стр.459)</target>
        </trans-unit>
        <trans-unit id="dbd538d32f5d9018cd3832c0cbc80455793a7355" translate="yes" xml:space="preserve">
          <source>F.9.4.1 The cbrt functions (p: 460)</source>
          <target state="translated">F.9.4.1 Функции cbrt (стр.460)</target>
        </trans-unit>
        <trans-unit id="c0cc25736dc89057cfdb7af63fd9fd70852b7e3f" translate="yes" xml:space="preserve">
          <source>F.9.4.3 The hypot functions (p: 461)</source>
          <target state="translated">F.9.4.3 Функции гипотезы (стр.461)</target>
        </trans-unit>
        <trans-unit id="9972873a11b4a3f3db9e100bb220f6102dbac9da" translate="yes" xml:space="preserve">
          <source>F.9.4.4 The pow functions (p: 461)</source>
          <target state="translated">F.9.4.4 Питание функции (стр.461)</target>
        </trans-unit>
        <trans-unit id="38a093976c4b1a21fdfcc5a1efbc81ca4cf9fcd1" translate="yes" xml:space="preserve">
          <source>F.9.4.5 The sqrt functions (p: 462)</source>
          <target state="translated">F.9.4.5 Функции площадки (стр.462)</target>
        </trans-unit>
        <trans-unit id="b1c90503cb107f559d8240f46591b669f6510753" translate="yes" xml:space="preserve">
          <source>F.9.5.1 The erf functions (p: 462)</source>
          <target state="translated">F.9.5.1 Функции erf (стр.462)</target>
        </trans-unit>
        <trans-unit id="d2df3873ca6b99a5a39094498e253092b49188f4" translate="yes" xml:space="preserve">
          <source>F.9.5.2 The erfc functions (p: 462)</source>
          <target state="translated">F.9.5.2 Функции erfc (стр.462)</target>
        </trans-unit>
        <trans-unit id="8cea05cad5774c2508871da587382f5db7d720a3" translate="yes" xml:space="preserve">
          <source>F.9.5.3 The lgamma functions (p: 462)</source>
          <target state="translated">F.9.5.3 Игамма-функции (стр.462)</target>
        </trans-unit>
        <trans-unit id="0b0a22ab47007053f34baaa081ba36dae847052b" translate="yes" xml:space="preserve">
          <source>F.9.5.4 The tgamma functions (p: 462)</source>
          <target state="translated">F.9.5.4 Тгамма-функции (стр.462)</target>
        </trans-unit>
        <trans-unit id="934d552354a34e2b8673e4eb4339546c60ae6dd8" translate="yes" xml:space="preserve">
          <source>F.9.6.1 The ceil functions (p: 462-463)</source>
          <target state="translated">F.9.6.1 Функции потолка (стр.462-463)</target>
        </trans-unit>
        <trans-unit id="e5b93daaadda04a0163cf636e455a8bd1dff63ae" translate="yes" xml:space="preserve">
          <source>F.9.6.2 The floor functions (p: 463)</source>
          <target state="translated">F.9.6.2 Функции пола (стр.463)</target>
        </trans-unit>
        <trans-unit id="57ffbbecbe61484e26935ad7f144629bd00f8d53" translate="yes" xml:space="preserve">
          <source>F.9.6.3 The nearbyint functions (p: 463)</source>
          <target state="translated">F.9.6.3 Функции поблизости (стр.463)</target>
        </trans-unit>
        <trans-unit id="34e0626ef8f9a6bbac018a9e206f3071affd5bc0" translate="yes" xml:space="preserve">
          <source>F.9.6.4 The rint functions (p: 463)</source>
          <target state="translated">F.9.6.4 Функции корзины (стр.463)</target>
        </trans-unit>
        <trans-unit id="c2e2f1d0870aa390943575793ec108e425c96385" translate="yes" xml:space="preserve">
          <source>F.9.6.5 The lrint and llrint functions (p: 463)</source>
          <target state="translated">F.9.6.5 Функции печатающего устройства и оттиска (стр.463)</target>
        </trans-unit>
        <trans-unit id="0342b704124b697670da2d3c1f79734dea851992" translate="yes" xml:space="preserve">
          <source>F.9.6.6 The round functions (p: 464)</source>
          <target state="translated">F.9.6.6 Круглые функции (стр.464)</target>
        </trans-unit>
        <trans-unit id="7cb6f5767de3d5739b9c33a7634dcdfe44990115" translate="yes" xml:space="preserve">
          <source>F.9.6.7 The lround and llround functions (p: 464)</source>
          <target state="translated">F.9.6.7 Функции закругления и закругления (стр.464)</target>
        </trans-unit>
        <trans-unit id="9c3fd1541169517fa1d4961b9344e08aa532fa7e" translate="yes" xml:space="preserve">
          <source>F.9.6.8 The trunc functions (p: 464)</source>
          <target state="translated">F.9.6.8 Функции усечения (стр.464)</target>
        </trans-unit>
        <trans-unit id="064b3111988ac7df6eecb785faed345d9297dfab" translate="yes" xml:space="preserve">
          <source>F.9.7.1 The fmod functions (p: 465)</source>
          <target state="translated">F.9.7.1 Функции fmod (стр.465)</target>
        </trans-unit>
        <trans-unit id="cc9103dded7338c4021b51c548c533e322ab900e" translate="yes" xml:space="preserve">
          <source>F.9.7.2 The remainder functions (p: 465)</source>
          <target state="translated">F.9.7.2 Остальные функции (стр.465)</target>
        </trans-unit>
        <trans-unit id="39bef4f56a96498b3da50bdb7c35031638849d6f" translate="yes" xml:space="preserve">
          <source>F.9.7.3 The remquo functions (p: 465)</source>
          <target state="translated">F.9.7.3 Функции ремкво (стр.465)</target>
        </trans-unit>
        <trans-unit id="e56cc91507b7efd53ba57b94c982642c7f60363e" translate="yes" xml:space="preserve">
          <source>F.9.8.1 The copysign functions (p: 465)</source>
          <target state="translated">F.9.8.1 Функции копирования (стр.465)</target>
        </trans-unit>
        <trans-unit id="ef3323270c431d43becee3540920bfc7eeedaff7" translate="yes" xml:space="preserve">
          <source>F.9.8.3 The nextafter functions (p: 466)</source>
          <target state="translated">F.9.8.3 Взаимосвязанные функции (стр.466)</target>
        </trans-unit>
        <trans-unit id="0631e56775b8a532eaeb5137b6f22ed4997abbe6" translate="yes" xml:space="preserve">
          <source>F.9.8.4 The nexttoward functions (p: 466)</source>
          <target state="translated">F.9.8.4 Следующие функции (стр.466)</target>
        </trans-unit>
        <trans-unit id="1ddb4e2e3c5c7d60866cef35561923279073eee3" translate="yes" xml:space="preserve">
          <source>F.9.9.1 The fdim functions (p: 466)</source>
          <target state="translated">F.9.9.1 Функции fdim (стр.466)</target>
        </trans-unit>
        <trans-unit id="c525d7d0c4839cf25cbfd016306a740d2d9d279e" translate="yes" xml:space="preserve">
          <source>F.9.9.2 The fmax functions (p: 466)</source>
          <target state="translated">F.9.9.2 fmax-функции (стр.466)</target>
        </trans-unit>
        <trans-unit id="fc6bba334be6df0602bebd86ae84aeb7c0f91030" translate="yes" xml:space="preserve">
          <source>F.9.9.3 The fmin functions (p: 466)</source>
          <target state="translated">F.9.9.3 Функции fmin (стр.466)</target>
        </trans-unit>
        <trans-unit id="95554e5d8706eb3f7b6807f8f074535fb13990c9" translate="yes" xml:space="preserve">
          <source>F.9/11/13 NAN (p: 455)</source>
          <target state="translated">F.9/11/13 NAN (стр.455)</target>
        </trans-unit>
        <trans-unit id="58e99712449f37bee19b236a76781708e1c1501e" translate="yes" xml:space="preserve">
          <source>F.9/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 454)</source>
          <target state="translated">F.9/2 HUGE_VAL,HUGE_VALF,HUGE_VALL (p:454)</target>
        </trans-unit>
        <trans-unit id="29ea08511bd74c4f3ae31a09c3ec12f4f35a942e" translate="yes" xml:space="preserve">
          <source>F.9/4 MATH_ERREXCEPT, math_errhandling&amp;gt; (p: 454)</source>
          <target state="translated">F.9 / 4 MATH_ERREXCEPT, math_errhandling&amp;gt; (стр: 454)</target>
        </trans-unit>
        <trans-unit id="c061bc777cddf822c848be8c51b3f6a8a14f19f4" translate="yes" xml:space="preserve">
          <source>FE_ALL_EXCEPTFE_DIVBYZEROFE_INEXACTFE_INVALIDFE_OVERFLOWFE_UNDERFLOW</source>
          <target state="translated">FE_ALL_EXCEPTFE_DIVBYZEROFE_INEXACTFE_INVALIDFE_OVERFLOWFE_UNDERFLOW</target>
        </trans-unit>
        <trans-unit id="b1c364462df93e13ffc864f5e34d434d3e0896f1" translate="yes" xml:space="preserve">
          <source>FE_DFL_ENV</source>
          <target state="translated">FE_DFL_ENV</target>
        </trans-unit>
        <trans-unit id="afc46bada59e52921ca04acfa3e557f4d34949db" translate="yes" xml:space="preserve">
          <source>FE_DOWNWARDFE_TONEARESTFE_TOWARDZEROFE_UPWARD</source>
          <target state="translated">FE_DOWNWARDFE_TONEARESTFE_TOWARDZEROFE_UPWARD</target>
        </trans-unit>
        <trans-unit id="f17f59f8bb1aa4aa1c2a8be48c8b3cc395132a95" translate="yes" xml:space="preserve">
          <source>FE_UNDERFLOW</source>
          <target state="translated">FE_UNDERFLOW</target>
        </trans-unit>
        <trans-unit id="5fc0e01507a5cabdda26a6538ed27cbe059c94c7" translate="yes" xml:space="preserve">
          <source>FE_UPWARD</source>
          <target state="translated">FE_UPWARD</target>
        </trans-unit>
        <trans-unit id="6c8821a037c125e39dc3cb69a201a2174bd7c0f8" translate="yes" xml:space="preserve">
          <source>FILENAME_MAX</source>
          <target state="translated">FILENAME_MAX</target>
        </trans-unit>
        <trans-unit id="0d4216abe2ddd91a8caf8ec8f946faac3d09cdb4" translate="yes" xml:space="preserve">
          <source>FInally, the &lt;code&gt;thrd_exit&lt;/code&gt; function terminates execution of the calling thread and sets its result code to &lt;code&gt;res&lt;/code&gt;.</source>
          <target state="translated">Наконец, функция &lt;code&gt;thrd_exit&lt;/code&gt; завершает выполнение вызывающего потока и устанавливает его код результата в &lt;code&gt;res&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec0e6a828868888b35d7b88c45bc8ec8ded65b4c" translate="yes" xml:space="preserve">
          <source>FLT_DECIMAL_DIGDBL_DECIMAL_DIGLDBL_DECIMAL_DIG</source>
          <target state="translated">FLT_DECIMAL_DIGDBL_DECIMAL_DIGLDBL_DECIMAL_DIG</target>
        </trans-unit>
        <trans-unit id="7afcf0013539d05e408bc6855b9ff9c33961ba4a" translate="yes" xml:space="preserve">
          <source>FLT_DIGDBL_DIGLDBL_DIG</source>
          <target state="translated">FLT_DIGDBL_DIGLDBL_DIG</target>
        </trans-unit>
        <trans-unit id="fb4b82dd7a09ae0e4cd4ec26fae3ace2a1f492b3" translate="yes" xml:space="preserve">
          <source>FLT_EPSILONDBL_EPSILONLDBL_EPSILON</source>
          <target state="translated">FLT_EPSILONDBL_EPSILONLDBL_EPSILON</target>
        </trans-unit>
        <trans-unit id="19a80ddd685588eb2c01ceaa6c67ca15a9d3cd90" translate="yes" xml:space="preserve">
          <source>FLT_EVAL_METHOD</source>
          <target state="translated">FLT_EVAL_METHOD</target>
        </trans-unit>
        <trans-unit id="27b085fe54adba08fa4a2911aa54c2928531a994" translate="yes" xml:space="preserve">
          <source>FLT_HAS_SUBNORMDBL_HAS_SUBNORMLDBL_HAS_SUBNORM</source>
          <target state="translated">FLT_HAS_SUBNORMDBL_HAS_SUBNORMLDBL_HAS_SUBNORM</target>
        </trans-unit>
        <trans-unit id="d23e1d93b48a70a6b3008660a10922fc69e91714" translate="yes" xml:space="preserve">
          <source>FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG</source>
          <target state="translated">FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG</target>
        </trans-unit>
        <trans-unit id="14a1a55c6769f2d618f216dd4e1926c937963a81" translate="yes" xml:space="preserve">
          <source>FLT_MAXDBL_MAXLDBL_MAX</source>
          <target state="translated">FLT_MAXDBL_MAXLDBL_MAX</target>
        </trans-unit>
        <trans-unit id="1a43181bc7c68633c0d3a314ceb823229a88ee19" translate="yes" xml:space="preserve">
          <source>FLT_MAX_10_EXPDBL_MAX_10_EXPLDBL_MAX_10_EXP</source>
          <target state="translated">FLT_MAX_10_EXPDBL_MAX_10_EXPLDBL_MAX_10_EXP</target>
        </trans-unit>
        <trans-unit id="ed2d991f061e360c893c5a713ef996b38ebffdc9" translate="yes" xml:space="preserve">
          <source>FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP</source>
          <target state="translated">FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP</target>
        </trans-unit>
        <trans-unit id="24b8072d7962d75d2c508ff42b7b1b1555e6bb66" translate="yes" xml:space="preserve">
          <source>FLT_MINDBL_MINLDBL_MIN</source>
          <target state="translated">FLT_MINDBL_MINLDBL_MIN</target>
        </trans-unit>
        <trans-unit id="6869500f7b0f9c2b39432ab1b4dcf3e3690ba2a4" translate="yes" xml:space="preserve">
          <source>FLT_MIN_10_EXPDBL_MIN_10_EXPLDBL_MIN_10_EXP</source>
          <target state="translated">FLT_MIN_10_EXPDBL_MIN_10_EXPLDBL_MIN_10_EXP</target>
        </trans-unit>
        <trans-unit id="d64b48614536e2d9f3fd84e0b2d0f3339ef6dae1" translate="yes" xml:space="preserve">
          <source>FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP</source>
          <target state="translated">FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP</target>
        </trans-unit>
        <trans-unit id="3d8d38284d7c48984126ae4544c8465c506ee097" translate="yes" xml:space="preserve">
          <source>FLT_RADIX</source>
          <target state="translated">FLT_RADIX</target>
        </trans-unit>
        <trans-unit id="234dca4e2a0e92e5608ec0464e330e76723ea1d3" translate="yes" xml:space="preserve">
          <source>FLT_ROUNDS</source>
          <target state="translated">FLT_ROUNDS</target>
        </trans-unit>
        <trans-unit id="7e6cd06ba47da57a942743f790919ca173fb6d20" translate="yes" xml:space="preserve">
          <source>FLT_TRUE_MINDBL_TRUE_MINLDBL_TRUE_MIN</source>
          <target state="translated">FLT_TRUE_MINDBL_TRUE_MINLDBL_TRUE_MIN</target>
        </trans-unit>
        <trans-unit id="60945a4b9de8b69d4d5468fc065e520c99d43f40" translate="yes" xml:space="preserve">
          <source>FOPEN_MAX</source>
          <target state="translated">FOPEN_MAX</target>
        </trans-unit>
        <trans-unit id="a5566821049b545a4daaafb3ffc216f6475d4a02" translate="yes" xml:space="preserve">
          <source>FP_FAST_FMAFFP_FAST_FMAFP_FAST_FMAL</source>
          <target state="translated">FP_FAST_FMAFFP_FAST_FMAFP_FAST_FMAL</target>
        </trans-unit>
        <trans-unit id="7813d7fff2e30597969481d9be57e5c18202cb8d" translate="yes" xml:space="preserve">
          <source>FP_ILOGB0FP_ILOGBNAN</source>
          <target state="translated">FP_ILOGB0FP_ILOGBNAN</target>
        </trans-unit>
        <trans-unit id="052dbc6bd1e79a500f50639c055da0a0bddfcda6" translate="yes" xml:space="preserve">
          <source>FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN</source>
          <target state="translated">FP_NORMAL,FP_SUBNORMAL,FP_ZERO,FP_INFINITE,FP_NAN</target>
        </trans-unit>
        <trans-unit id="4b390f17b3415cc66503253a8e943ae6869cbbbb" translate="yes" xml:space="preserve">
          <source>FP_NORMALFP_SUBNORMALFP_ZEROFP_INFINITEFP_NAN</source>
          <target state="translated">FP_NORMALFP_SUBNORMALFP_ZEROFP_INFINITEFP_NAN</target>
        </trans-unit>
        <trans-unit id="13ad13aaa89439dd8522b85f083a14ec539c93e9" translate="yes" xml:space="preserve">
          <source>FP_ZERO</source>
          <target state="translated">FP_ZERO</target>
        </trans-unit>
        <trans-unit id="a1369155ac8ee1937c5466bde76ab0bbbcbba45c" translate="yes" xml:space="preserve">
          <source>File access</source>
          <target state="translated">Доступ к файлам</target>
        </trans-unit>
        <trans-unit id="d794a847bb4e5ceadb9c12ac7ab0786d739025aa" translate="yes" xml:space="preserve">
          <source>File access mode flag &lt;code&gt;&quot;b&quot;&lt;/code&gt; can optionally be specified to open a file in binary mode. This flag has no effect on POSIX systems, but on Windows it disables special handling of &lt;code&gt;'\n'&lt;/code&gt; and &lt;code&gt;'\x1A'&lt;/code&gt;.</source>
          <target state="translated">При желании можно указать флаг режима доступа к файлу &lt;code&gt;&quot;b&quot;&lt;/code&gt; чтобы открыть файл в двоичном режиме. Этот флаг не влияет на системы POSIX, но в Windows он отключает специальную обработку &lt;code&gt;'\n'&lt;/code&gt; и &lt;code&gt;'\x1A'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6849f814ac623848f85944a7a942fbf7e9bcb81e" translate="yes" xml:space="preserve">
          <source>File access mode flag &lt;code&gt;&quot;x&quot;&lt;/code&gt; can optionally be appended to &quot;w&quot; or &quot;w+&quot; specifiers. This flag forces the function to fail if the file exists, instead of overwriting it. (C11)</source>
          <target state="translated">Флаг режима доступа к файлу &lt;code&gt;&quot;x&quot;&lt;/code&gt; может быть добавлен к спецификаторам &amp;laquo;w&amp;raquo; или &amp;laquo;w +&amp;raquo;. Этот флаг вызывает сбой функции, если файл существует, вместо перезаписи. (С11)</target>
        </trans-unit>
        <trans-unit id="f30e2ebee0e504d4fec6132b2058150d91b77510" translate="yes" xml:space="preserve">
          <source>File input/output</source>
          <target state="translated">Ввод/вывод файлов</target>
        </trans-unit>
        <trans-unit id="d853d71d751d53b2d709b880a89265afee92eb91" translate="yes" xml:space="preserve">
          <source>File position indicator on success or &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; if failure occurs.</source>
          <target state="translated">Индикатор положения файла в случае успеха или &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; в случае сбоя.</target>
        </trans-unit>
        <trans-unit id="a494399ad447f56f41d7522c5db08562d3c24708" translate="yes" xml:space="preserve">
          <source>File positioning</source>
          <target state="translated">Позиционирование файла</target>
        </trans-unit>
        <trans-unit id="36cd96e05c782cee5791cf21bde1893978c5c077" translate="yes" xml:space="preserve">
          <source>File scope</source>
          <target state="translated">Файловые метлы</target>
        </trans-unit>
        <trans-unit id="3a9cdc70afa5e782250a989c51574a43f1d0f25b" translate="yes" xml:space="preserve">
          <source>File scope restricted pointers are useful in providing access to dynamically allocated global arrays; the restrict semantics make it possible to optimize references through this pointer as effectively as references to a static array through its declared name:</source>
          <target state="translated">Указатели с ограниченной сферой действия файлов полезны для обеспечения доступа к динамически выделяемым глобальным массивам;семантика ограничений позволяет оптимизировать ссылки через этот указатель так же эффективно,как и ссылки на статический массив через его объявленное имя:</target>
        </trans-unit>
        <trans-unit id="dc8284a593a8a291982c4c67910dd38a5e502924" translate="yes" xml:space="preserve">
          <source>File-scope identifiers have &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt; and &lt;a href=&quot;storage_duration&quot;&gt;static storage duration&lt;/a&gt; by default.</source>
          <target state="translated">По умолчанию идентификаторы области файла имеют &lt;a href=&quot;storage_duration&quot;&gt;внешнюю связь&lt;/a&gt; и &lt;a href=&quot;storage_duration&quot;&gt;статическую продолжительность хранения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fae255f2995d1f907f01cf7594e8462316da5be7" translate="yes" xml:space="preserve">
          <source>Filename and line information</source>
          <target state="translated">Имя файла и информация о строке</target>
        </trans-unit>
        <trans-unit id="a02ae1c73392d3f6a41d7039bf6f66883821f319" translate="yes" xml:space="preserve">
          <source>Finds the first character in wide string pointed to by &lt;code&gt;dest&lt;/code&gt;, that is also in wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Находит первый символ в широкой строке, на которую указывает &lt;code&gt;dest&lt;/code&gt; , то есть также в широкой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6fd83627e8c7b32c0144a6c435a8efcc4874610" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of &lt;code&gt;ch&lt;/code&gt; (after conversion to &lt;code&gt;char&lt;/code&gt; as if by &lt;code&gt;(char)ch&lt;/code&gt;) in the null-terminated byte string pointed to by &lt;code&gt;str&lt;/code&gt; (each character interpreted as &lt;code&gt;unsigned char&lt;/code&gt;). The terminating null character is considered to be a part of the string and can be found when searching for &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">Находит первое вхождение &lt;code&gt;ch&lt;/code&gt; (после преобразования в &lt;code&gt;char&lt;/code&gt; , как будто с помощью &lt;code&gt;(char)ch&lt;/code&gt; ) в байтовой строке с нулевым символом в конце, на которую указывает &lt;code&gt;str&lt;/code&gt; (каждый символ интерпретируется как &lt;code&gt;unsigned char&lt;/code&gt; ). Завершающий нулевой символ считается частью строки и может быть найден при поиске &lt;code&gt;'\0'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="156983c4936a90f64d8bde0b4e792911d718b0b0" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of &lt;code&gt;ch&lt;/code&gt; (after conversion to &lt;code&gt;unsigned char&lt;/code&gt; as if by &lt;code&gt;(unsigned char)ch&lt;/code&gt;) in the initial &lt;code&gt;count&lt;/code&gt; characters (each interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) of the object pointed to by &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">Находит первое вхождение &lt;code&gt;ch&lt;/code&gt; (после преобразования в &lt;code&gt;unsigned char&lt;/code&gt; , как будто с помощью &lt;code&gt;(unsigned char)ch&lt;/code&gt; ) в символах начального &lt;code&gt;count&lt;/code&gt; (каждый интерпретируется как &lt;code&gt;unsigned char&lt;/code&gt; ) объекта, на который указывает &lt;code&gt;ptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f073bd8d629a1976216a0fa2bb49ebd6dc19c4b" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the null-terminated byte string pointed to by &lt;code&gt;substr&lt;/code&gt; in the null-terminated byte string pointed to by &lt;code&gt;str&lt;/code&gt;. The terminating null characters are not compared.</source>
          <target state="translated">Находит первое вхождение строки байтов с нулевым символом в конце, на которую указывает &lt;code&gt;substr&lt;/code&gt; , в строке байтов с нулевым символом в конце, на которую указывает &lt;code&gt;str&lt;/code&gt; . Завершающие нулевые символы не сравниваются.</target>
        </trans-unit>
        <trans-unit id="9388d73210fb9a6adcc18de249cc87e2da6d4106" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the wide character &lt;code&gt;ch&lt;/code&gt; in the wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Находит первое вхождение широкого символа &lt;code&gt;ch&lt;/code&gt; в широкой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60954d9dde97ea95b47805de626af5f9bb89a11c" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the wide string &lt;code&gt;src&lt;/code&gt; in the wide string pointed to by &lt;code&gt;dest&lt;/code&gt;. The terminating null characters are not compared.</source>
          <target state="translated">Находит первое вхождение широкой строки &lt;code&gt;src&lt;/code&gt; в широкой строке, на которую указывает &lt;code&gt;dest&lt;/code&gt; . Завершающие нулевые символы не сравниваются.</target>
        </trans-unit>
        <trans-unit id="4df137c6700e2d26ec6d629f5fa312ab93f754d7" translate="yes" xml:space="preserve">
          <source>Finds the last occurrence of &lt;code&gt;ch&lt;/code&gt; (after conversion to &lt;code&gt;char&lt;/code&gt; as if by &lt;code&gt;(char)ch&lt;/code&gt;) in the null-terminated byte string pointed to by &lt;code&gt;str&lt;/code&gt; (each character interpreted as &lt;code&gt;unsigned char&lt;/code&gt;). The terminating null character is considered to be a part of the string and can be found if searching for &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">Находит последнее вхождение &lt;code&gt;char&lt;/code&gt; &lt;code&gt;ch&lt;/code&gt; (после преобразования в тип char, как будто с помощью &lt;code&gt;(char)ch&lt;/code&gt; ) в байтовой строке с нулевым символом в конце, на которую указывает &lt;code&gt;str&lt;/code&gt; (каждый символ интерпретируется как &lt;code&gt;unsigned char&lt;/code&gt; ). Завершающий нулевой символ считается частью строки и может быть найден при поиске &lt;code&gt;'\0'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abb2c2feff5f0426d0ef85cddeeca9860311e3e9" translate="yes" xml:space="preserve">
          <source>Finds the last occurrence of the wide character &lt;code&gt;ch&lt;/code&gt; in the wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Находит последнее вхождение широкого символа &lt;code&gt;ch&lt;/code&gt; в широкой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd043634a6f2aac8236e977d8fdb5f1580bfb40c" translate="yes" xml:space="preserve">
          <source>First, &lt;a href=&quot;conversion&quot;&gt;integer promotions&lt;/a&gt; are performed, individually, on each operand (Note: this is unlike other binary arithmetic operators, which all perform usual arithmetic conversions). The type of the result is the type of lhs after promotion.</source>
          <target state="translated">Во-первых, &lt;a href=&quot;conversion&quot;&gt;целочисленные&lt;/a&gt; преобразования выполняются индивидуально для каждого операнда (Примечание: это не похоже на другие двоичные арифметические операторы, которые все выполняют обычные арифметические преобразования). Тип результата - это тип lhs после повышения.</target>
        </trans-unit>
        <trans-unit id="010a9580b64f6a29762d659e4b63ee2c420030ea" translate="yes" xml:space="preserve">
          <source>First, at &lt;a href=&quot;translation_phases&quot;&gt;translation phase 6&lt;/a&gt; (after macro expansion), the adjacent string literals (that is, string literals separated by whitespace only) are concatenated.</source>
          <target state="translated">Во-первых, на &lt;a href=&quot;translation_phases&quot;&gt;этапе 6 трансляции&lt;/a&gt; (после раскрытия макроса) смежные строковые литералы (то есть строковые литералы, разделенные только пробелами) объединяются.</target>
        </trans-unit>
        <trans-unit id="e3c3d2f054364788d43e5a8d2b30730a8de2382a" translate="yes" xml:space="preserve">
          <source>First, for every thread-specific storage key which was created with a non-null destructor and for which the associated value is non-null (see &lt;code&gt;&lt;a href=&quot;tss_create&quot;&gt;tss_create&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;thrd_exit&lt;/code&gt; sets the value associated with the key to &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; and then invokes the destructor with the previous value of the key. The order in which the destructors are invoked is unspecified.</source>
          <target state="translated">Во-первых, для каждого специфичного для потока ключа хранилища, который был создан с ненулевым деструктором и для которого ассоциированное значение не равно нулю (см. &lt;code&gt;&lt;a href=&quot;tss_create&quot;&gt;tss_create&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;thrd_exit&lt;/code&gt; устанавливает значение, связанное с ключом, в &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , а затем вызывает деструктор с предыдущее значение ключа. Порядок, в котором вызываются деструкторы, не определен.</target>
        </trans-unit>
        <trans-unit id="24650e9936b440df3b35e77cd0d75063b1ba7c02" translate="yes" xml:space="preserve">
          <source>First, operators &amp;amp;, ^, and | perform &lt;a href=&quot;conversion#Usual_arithmetic_conversions&quot;&gt;usual arithmetic conversions&lt;/a&gt; on both operands and the operator ~ performs &lt;a href=&quot;conversion#Integer_promotions&quot;&gt;integer promotions&lt;/a&gt; on its only operand.</source>
          <target state="translated">Во-первых, операторы &amp;amp;, ^ и | выполнять &lt;a href=&quot;conversion#Usual_arithmetic_conversions&quot;&gt;обычные арифметические преобразования&lt;/a&gt; для обоих операндов, а оператор ~ выполняет &lt;a href=&quot;conversion#Integer_promotions&quot;&gt;целочисленные &lt;/a&gt;преобразования для своего единственного операнда.</target>
        </trans-unit>
        <trans-unit id="e3892a9441dac662eadf3bbde79b34566a2a5b8a" translate="yes" xml:space="preserve">
          <source>First, remembers the currently raised floating-point exceptions, then restores the floating-point environment from the object pointed to by &lt;code&gt;envp&lt;/code&gt; (similar to &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;fesetenv&lt;/a&gt;&lt;/code&gt;), then raises the floating-point exceptions that were saved.</source>
          <target state="translated">Сначала запоминает &lt;code&gt;envp&lt;/code&gt; исключения с плавающей запятой, затем восстанавливает среду с плавающей запятой из объекта, на который указывает envp (аналогично &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;fesetenv&lt;/a&gt;&lt;/code&gt; ), затем поднимает исключения с плавающей запятой, которые были сохранены.</target>
        </trans-unit>
        <trans-unit id="5af17ffdb58456bdb2dce4da5ffca99076cb7ee3" translate="yes" xml:space="preserve">
          <source>First, saves the current floating-point environment to the object pointed to by &lt;code&gt;envp&lt;/code&gt; (similar to &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;fegetenv&lt;/a&gt;&lt;/code&gt;), then clears all floating-point status flags, and then installs the non-stop mode: future floating-point exceptions will not interrupt execution (will not trap), until the floating-point environment is restored by &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;feupdateenv&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;fesetenv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Сначала сохраняет текущую среду с плавающей запятой в объекте, на который указывает &lt;code&gt;envp&lt;/code&gt; (аналогично &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;fegetenv&lt;/a&gt;&lt;/code&gt; ), затем очищает все флаги состояния с плавающей запятой и затем устанавливает режим без остановок: будущие исключения с плавающей запятой не будут прерывать выполнение ( не будет ловушкой), пока среда с плавающей точкой не будет восстановлена ​​с помощью &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;feupdateenv&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;fesetenv&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a0d1a196542aeb51294a3761ccccdf5a2185f41" translate="yes" xml:space="preserve">
          <source>First, the left operand, lhs, is evaluated and its result value is discarded.</source>
          <target state="translated">Сначала оценивается левый операнд,lhs,и отбрасывается значение его результата.</target>
        </trans-unit>
        <trans-unit id="7f7c8db9e6faaf3d94c8b437cf0d16523b93fd3b" translate="yes" xml:space="preserve">
          <source>First, the type of controlling-expression undergoes &lt;a href=&quot;conversion#Lvalue_conversions&quot;&gt;lvalue conversions&lt;/a&gt;. The conversion is performed in type domain only: it discards the top-level cvr-qualifiers and atomicity and applies array-to-pointer/function-to-pointer transformations to the type of the controlling expression, without initiating any side-effects or calculating any values.</source>
          <target state="translated">Во-первых, тип управляющего выражения подвергается &lt;a href=&quot;conversion#Lvalue_conversions&quot;&gt;преобразованию lvalue&lt;/a&gt; . Преобразование выполняется только в домене типов: оно отбрасывает квалификаторы cvr верхнего уровня и атомарность и применяет преобразования массив-указатель / функция-указатель к типу управляющего выражения без каких-либо побочных эффектов или вычисления любые значения.</target>
        </trans-unit>
        <trans-unit id="27e98ae5f197207336755cc33861b5d103faad58" translate="yes" xml:space="preserve">
          <source>Fixed width integer types</source>
          <target state="translated">Исправлена ширина целых типов</target>
        </trans-unit>
        <trans-unit id="76a08caa99c505ae8032d07c4012057a86cf1d36" translate="yes" xml:space="preserve">
          <source>Fixed width integer types (since C99)</source>
          <target state="translated">Исправлена ширина целых типов (начиная с C99)</target>
        </trans-unit>
        <trans-unit id="840ee99ab9aff1bac4213d391ce03692c895404a" translate="yes" xml:space="preserve">
          <source>Fixed-width integer types</source>
          <target state="translated">Целые числа фиксированной ширины</target>
        </trans-unit>
        <trans-unit id="663059496ccabb871dffdce9e54cfe1c54e105ee" translate="yes" xml:space="preserve">
          <source>Floating constants</source>
          <target state="translated">Плавающие константы</target>
        </trans-unit>
        <trans-unit id="5679c54758fee21d770fd6c545d0c43032628157" translate="yes" xml:space="preserve">
          <source>Floating point value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">Значение с плавающей запятой, соответствующее содержимому &lt;code&gt;str&lt;/code&gt; в случае успеха. Если преобразованное значение выходит за пределы диапазона соответствующего возвращаемого типа, возникает ошибка диапазона и &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; . Если преобразование не может быть выполнено, &lt;code&gt;​0​&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="cc58d2a49355b39280fe2f52213175ca7b8fd25a" translate="yes" xml:space="preserve">
          <source>Floating-point constant expressions</source>
          <target state="translated">Выражения констант с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="187a207ab4dc1668e42fee15564f93f815a577ae" translate="yes" xml:space="preserve">
          <source>Floating-point constants may convert to more range and precision than is indicated by their type, if indicated by &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;. For example, the constant &lt;code&gt;0.1f&lt;/code&gt; may act as if it were &lt;code&gt;0.1L&lt;/code&gt; in an expression.</source>
          <target state="translated">Константы с плавающей точкой могут преобразовываться в больший диапазон и точность, чем указано их типом, если указано &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; . Например, константа &lt;code&gt;0.1f&lt;/code&gt; может действовать так, как если бы она была &lt;code&gt;0.1L&lt;/code&gt; в выражении.</target>
        </trans-unit>
        <trans-unit id="fe4d2e99025a6ead51e9b2e632c32efaa3c94a25" translate="yes" xml:space="preserve">
          <source>Floating-point contraction</source>
          <target state="translated">Сокращение в плавающей точке</target>
        </trans-unit>
        <trans-unit id="037c72279324a50181c71503f07e7e0083f1c23d" translate="yes" xml:space="preserve">
          <source>Floating-point environment</source>
          <target state="translated">Среда с плавающей запятой</target>
        </trans-unit>
        <trans-unit id="ac15e30a03ce45c5cd8e83acd0b5ab29417f912b" translate="yes" xml:space="preserve">
          <source>Floating-point expressions may also be</source>
          <target state="translated">Выражения с плавающей точкой также могут быть</target>
        </trans-unit>
        <trans-unit id="c833758c552d43ff6fc0b2c2a0891b29187adbbf" translate="yes" xml:space="preserve">
          <source>Floating-point expressions may have greater range and precision than indicated by their types, see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;. &lt;a href=&quot;operator_assignment&quot;&gt;Assignment&lt;/a&gt;, &lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;, and &lt;a href=&quot;cast&quot;&gt;cast&lt;/a&gt; force the range and precision to the one associated with the declared type.</source>
          <target state="translated">Выражения с плавающей точкой могут иметь больший диапазон и точность, чем указано их типами, см. &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; . &lt;a href=&quot;operator_assignment&quot;&gt;Присвоение&lt;/a&gt; , &lt;a href=&quot;return&quot;&gt;возврат&lt;/a&gt; и &lt;a href=&quot;cast&quot;&gt;приведение&lt;/a&gt; приводят к тому, что диапазон и точность соответствуют значению, связанному с объявленным типом.</target>
        </trans-unit>
        <trans-unit id="2b332b36c83932ce6597945ab99c760510235ccb" translate="yes" xml:space="preserve">
          <source>Floating-point expressions may raise exceptions and report errors as specified in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;</source>
          <target state="translated">Выражения с плавающей точкой могут вызывать исключения и сообщать об ошибках, как указано в &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab903d16590f471723cce0610a9cdcd6209bde69" translate="yes" xml:space="preserve">
          <source>Floating-point manipulation functions</source>
          <target state="translated">Функции манипуляции с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="9e9ec2743b8311d312a967d346f2be786a835e07" translate="yes" xml:space="preserve">
          <source>Floating-point types may support special values:</source>
          <target state="translated">Типы с плавающей точкой могут поддерживать специальные значения:</target>
        </trans-unit>
        <trans-unit id="06aab856bd9476c0b4dbb7ee054ad78329c4c1ec" translate="yes" xml:space="preserve">
          <source>Floating-point value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">Значение с плавающей точкой, соответствующее содержимому &lt;code&gt;str&lt;/code&gt; в случае успеха. Если преобразованное значение выходит за пределы диапазона соответствующего возвращаемого типа, возникает ошибка диапазона и &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; . Если преобразование не может быть выполнено, &lt;code&gt;​0​&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="a6d068410c3d5d5e1e66f214a4705f1da0744b99" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loop, it acts as:</source>
          <target state="translated">Для цикла &lt;a href=&quot;do&quot;&gt;do-&lt;/a&gt; while он действует как:</target>
        </trans-unit>
        <trans-unit id="0a82766f871cb4b85056c582e325e120d94af630" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; loop, it acts as:</source>
          <target state="translated">Для цикла &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; он действует как:</target>
        </trans-unit>
        <trans-unit id="25aa007ea092cdda566de6d64234cfa5cc3924d2" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;struct&quot;&gt;structs&lt;/a&gt; and &lt;a href=&quot;union&quot;&gt;unions&lt;/a&gt;, declarations that specify the list of members are definitions:</source>
          <target state="translated">Для &lt;a href=&quot;struct&quot;&gt;структур&lt;/a&gt; и &lt;a href=&quot;union&quot;&gt;объединений&lt;/a&gt; объявления, которые определяют список членов, являются определениями:</target>
        </trans-unit>
        <trans-unit id="67db5ac16c817d0aad978db1daa9912c166fac6a" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop, it acts as.</source>
          <target state="translated">В &lt;a href=&quot;while&quot;&gt;то время как&lt;/a&gt; петли, он действует как.</target>
        </trans-unit>
        <trans-unit id="10084651562c27997fbdae459a7c23083c2c8a43" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;lrint&lt;/code&gt; and &lt;code&gt;llrint&lt;/code&gt; functions:</source>
          <target state="translated">Для &lt;code&gt;lrint&lt;/code&gt; и &lt;code&gt;llrint&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a21e404fbb1009207c801f3014228685c0a1839d" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;lround&lt;/code&gt; and &lt;code&gt;llround&lt;/code&gt; families of functions:</source>
          <target state="translated">Для семейства функций &lt;code&gt;lround&lt;/code&gt; и &lt;code&gt;llround&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ab727ef011ac32b32b71004213c9062e03c40ca6" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow happens if &lt;code&gt;0 &amp;lt; x &amp;lt; 1/DBL_MAX&lt;/code&gt; or if &lt;code&gt;x &amp;gt; 171.7&lt;/code&gt;.</source>
          <target state="translated">Для IEEE-совместимого типа &lt;code&gt;double&lt;/code&gt; переполнение происходит, если &lt;code&gt;0 &amp;lt; x &amp;lt; 1/DBL_MAX&lt;/code&gt; или если &lt;code&gt;x &amp;gt; 171.7&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="308485408ad23c9a6a581efd5af8112d70a5819e" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow is guaranteed if 709.8 &amp;lt; arg, and underflow is guaranteed if arg &amp;lt; -708.4.</source>
          <target state="translated">Для IEEE-совместимого типа &lt;code&gt;double&lt;/code&gt; переполнение гарантируется, если 709,8 &amp;lt;arg, и недостаточное переполнение гарантируется, если arg &amp;lt;-708.4.</target>
        </trans-unit>
        <trans-unit id="9ebd607b970e88332eac8b1adf8c8066c0dd8e42" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow is guaranteed if 709.8 &amp;lt; arg.</source>
          <target state="translated">Для IEEE-совместимого типа &lt;code&gt;double&lt;/code&gt; переполнение гарантируется, если 709.8 &amp;lt;arg.</target>
        </trans-unit>
        <trans-unit id="c4e888a145f1992272e7918f8fc284c6a7e06ad4" translate="yes" xml:space="preserve">
          <source>For a</source>
          <target state="translated">Для</target>
        </trans-unit>
        <trans-unit id="5961fe12a3117fa1b2454e762062290b637aa259" translate="yes" xml:space="preserve">
          <source>For a pair of atomic modifications of M called A and B, B occurs after A in M's modification order if.</source>
          <target state="translated">Для пары атомных модификаций М,называемых A и B,B происходит после A в порядке модификации М,если.</target>
        </trans-unit>
        <trans-unit id="7e336f737f267c22ea911366e2522a1b5935e0af" translate="yes" xml:space="preserve">
          <source>For a pair of atomic operations on M called A and B, where A writes and B reads M's value, if there are two &lt;code&gt;memory_order_seq_cst&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;atomic_thread_fence&lt;/a&gt;&lt;/code&gt;s X and Y, and if A is</source>
          <target state="translated">Для пары атомарных операций над M, называемых A и B, где A записывает, а B считывает значение M, если есть два &lt;code&gt;memory_order_seq_cst&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;atomic_thread_fence&lt;/a&gt;&lt;/code&gt; s X и Y, и если A является</target>
        </trans-unit>
        <trans-unit id="1d3977eef880647bc052245b337d4dbacc336a33" translate="yes" xml:space="preserve">
          <source>For all complex number functions that do not have real counterparts, a type-generic macro &lt;code&gt;cXXX&lt;/code&gt; exists, which calls either of the variants of a complex function:</source>
          <target state="translated">Для всех функций комплексных чисел, которые не имеют реальных аналогов, существует типовой макрос &lt;code&gt;cXXX&lt;/code&gt; , который вызывает любой из вариантов комплексной функции:</target>
        </trans-unit>
        <trans-unit id="6730f4960c4b4de31dd3c96b5509a3c383272937" translate="yes" xml:space="preserve">
          <source>For all functions that do not have complex counterparts, with the exception of &lt;code&gt;modf&lt;/code&gt;, a type-generic macro &lt;code&gt;XXX&lt;/code&gt; exists, which calls either of the variants of a real function:</source>
          <target state="translated">Для всех функций, которые не имеют сложных аналогов, за исключением &lt;code&gt;modf&lt;/code&gt; , существует типовой макрос &lt;code&gt;XXX&lt;/code&gt; , который вызывает любой из вариантов реальной функции:</target>
        </trans-unit>
        <trans-unit id="04997ae64209c733be2a01335fce8eadf79cc061" translate="yes" xml:space="preserve">
          <source>For all functions that have both real and complex counterparts, a type-generic macro &lt;code&gt;XXX&lt;/code&gt; exists, which calls either of:</source>
          <target state="translated">Для всех функций, которые имеют как действительные, так и сложные аналоги, существует типовой макрос &lt;code&gt;XXX&lt;/code&gt; , который вызывает одно из:</target>
        </trans-unit>
        <trans-unit id="55501a14e5efa2511e7fc929d66bd9f716e4906e" translate="yes" xml:space="preserve">
          <source>For an identifier with internal or external &lt;a href=&quot;storage_duration&quot;&gt;linkage&lt;/a&gt; declared in a scope in which a prior declaration of that identifier is visible, if the prior declaration specifies internal or external linkage, the type of the identifier at the later declaration becomes the composite type.</source>
          <target state="translated">Для идентификатора с внутренней или внешней &lt;a href=&quot;storage_duration&quot;&gt;связью,&lt;/a&gt; объявленной в области видимости, в которой видно предыдущее объявление этого идентификатора, если в предыдущем объявлении указана внутренняя или внешняя связь, тип идентификатора в последующем объявлении становится составным типом.</target>
        </trans-unit>
        <trans-unit id="b64b2293698ec3d176c65a39c39ccccae3114de3" translate="yes" xml:space="preserve">
          <source>For any complex variable &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;z == &lt;a href=&quot;creal&quot;&gt;creal&lt;/a&gt;(z) + I*cimag(z)&lt;/code&gt;.</source>
          <target state="translated">Для любого комплексного переменного &lt;code&gt;z&lt;/code&gt; , &lt;code&gt;z == &lt;a href=&quot;creal&quot;&gt;creal&lt;/a&gt;(z) + I*cimag(z)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a924e7dda6f158c58b3ecd7cd7208221fc267986" translate="yes" xml:space="preserve">
          <source>For any complex variable &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;z == creal(z) + I*&lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z)&lt;/code&gt;.</source>
          <target state="translated">Для любого комплексного переменного &lt;code&gt;z&lt;/code&gt; , &lt;code&gt;z == creal(z) + I*&lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a543b26c60ebb052f7bcd4171fdf90efeeb5fc1c" translate="yes" xml:space="preserve">
          <source>For any struct or union declared with a storage-class specifier, the storage duration (but not linkage) applies to their members, recursively.</source>
          <target state="translated">Для любой структуры или объединения,объявленного со спецификатором класса хранилища,продолжительность хранения (но не привязки)применяется к их членам,рекурсивно.</target>
        </trans-unit>
        <trans-unit id="587d19dece0a5e657eee4b9c6dab7110d60627cf" translate="yes" xml:space="preserve">
          <source>For any z, acos(z) = &amp;pi; - acos(-z).</source>
          <target state="translated">Для любого z acos (z) = &amp;pi; - acos (-z).</target>
        </trans-unit>
        <trans-unit id="21aee1213fe266997611327508955de0364192e9" translate="yes" xml:space="preserve">
          <source>For any z, atanh(z) =</source>
          <target state="translated">Для любого z,atanh(z)=</target>
        </trans-unit>
        <trans-unit id="688d572612ce95b5162d08e797cd89fdb4d407c3" translate="yes" xml:space="preserve">
          <source>For char arrays shorter than &lt;code&gt;&lt;a href=&quot;limits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ptrdiff_t&lt;/code&gt; acts as the signed counterpart of &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt;: it can store the size of the array of any type and is, on most platforms, synonymous with &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;intptr_t&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Для символьных массивов короче &lt;code&gt;&lt;a href=&quot;limits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;ptrdiff_t&lt;/code&gt; выступает в качестве подписанного контрагента &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt; : он может хранить размер массива любого типа и на большинстве платформ, синоним &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;intptr_t&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="42dd9f0ffdcfcdcd8c3a5d50abb1358aac15a314" translate="yes" xml:space="preserve">
          <source>For decimal floating constants, the exponent part is optional. If it is omitted, the period is not optional, and either the whole-number or the fraction must be present.</source>
          <target state="translated">Для десятичных плавающих констант экспонентная часть является необязательной.Если она опущена,то период не является необязательным,и либо целое число,либо дробь должны присутствовать.</target>
        </trans-unit>
        <trans-unit id="4f184cc4c10f89fe313321f740ea02baedf5fc6c" translate="yes" xml:space="preserve">
          <source>For each &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;, the initializer, if not omitted, may be one of the following:</source>
          <target state="translated">Для каждого &lt;a href=&quot;declarations&quot;&gt;декларатора&lt;/a&gt; инициализатор, если не опущен, может быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="bfeeb8ceed62e73a2f3bd0d30fa50cfae0463352" translate="yes" xml:space="preserve">
          <source>For each macro, the parameters whose corresponding real type in the unsuffixed math.h function is &lt;code&gt;double&lt;/code&gt; are known as</source>
          <target state="translated">Для каждого макроса параметры, чей соответствующий действительный тип в функции math.h без суффикса равен &lt;code&gt;double&lt;/code&gt; , известны как</target>
        </trans-unit>
        <trans-unit id="d6a1bb30012f8a1244f1eb8a6420656d9d6e09c6" translate="yes" xml:space="preserve">
          <source>For every conversion specifier other than &lt;code&gt;n&lt;/code&gt;, the longest sequence of input characters which does not exceed any speciﬁed ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.</source>
          <target state="translated">Для каждого спецификатора преобразования, отличного от &lt;code&gt;n&lt;/code&gt; , самая длинная последовательность входных символов, которая не превышает какой-либо заданной ширины поля и которая либо является именно тем, что ожидает спецификатор преобразования, либо является префиксом последовательности, которую он ожидал, - это то, что потребляется из потока. Первый символ, если он есть, после этой использованной последовательности остается непрочитанным. Если использованная последовательность имеет нулевую длину или если использованная последовательность не может быть преобразована, как указано выше, сбой сопоставления происходит, если только конец файла, ошибка кодирования или ошибка чтения не предотвратили ввод из потока, и в этом случае он является Ошибка входа.</target>
        </trans-unit>
        <trans-unit id="83d7a4b53e554acfb54c7ee5d69c5549aa81f75b" translate="yes" xml:space="preserve">
          <source>For every type listed above several qualified versions of its type may exist, corresponding to the combinations of one, two, or all three of the &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;, &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;, and &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt; qualifiers (where allowed by the qualifier's semantics).</source>
          <target state="translated">Для каждого перечисленного выше типа может существовать несколько квалифицированных версий его типа, соответствующих комбинациям одного, двух или всех трех квалификаторов &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; , &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; и &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt; (где это разрешено семантикой классификатора).</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="9d4b3358e1df9f2bea37a27eaa5e14ffa2bc6778" translate="yes" xml:space="preserve">
          <source>For example, with &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; initially zero,</source>
          <target state="translated">Например, с &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; изначально ноль,</target>
        </trans-unit>
        <trans-unit id="3af091a84c4312052c5526d63f3a9497407d3111" translate="yes" xml:space="preserve">
          <source>For functions, a declaration that includes the function body is a &lt;a href=&quot;function_definition&quot;&gt;function definition&lt;/a&gt;:</source>
          <target state="translated">Для функций объявление, которое включает тело функции, является &lt;a href=&quot;function_definition&quot;&gt;определением функции&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="75995ccba23b0db3ef2d567077ba1d25c7f8d7cd" translate="yes" xml:space="preserve">
          <source>For hexadecimal floating constants, the exponent is not optional to avoid ambiguity resulting from an f suffix being mistaken as a hexadecimal digit.</source>
          <target state="translated">Для шестнадцатеричных плавающих констант экспонент не является необязательным,чтобы избежать двусмысленности,возникающей из-за того,что суффикс f ошибочно принимается за шестнадцатеричную цифру.</target>
        </trans-unit>
        <trans-unit id="ec3905377a1c94d495d985035e68f7411ea9980d" translate="yes" xml:space="preserve">
          <source>For input streams (and for update streams on which the last operation was input), the behavior is undefined.</source>
          <target state="translated">Для потоков ввода (и для потоков обновления,для которых была введена последняя операция)поведение не определено.</target>
        </trans-unit>
        <trans-unit id="3263d60841f8b602b9cc58bd2747c0e72fde62e4" translate="yes" xml:space="preserve">
          <source>For integer &lt;code&gt;arg&lt;/code&gt;, the binary logarithm can be interpreted as the zero-based index of the most significant 1 bit in the input.</source>
          <target state="translated">Для целочисленного &lt;code&gt;arg&lt;/code&gt; двоичный логарифм можно интерпретировать как индекс, начинающийся с нуля, наиболее значимого 1 бита на входе.</target>
        </trans-unit>
        <trans-unit id="560ed07ef6832b220e08d54f59f5d6efc3edfa88" translate="yes" xml:space="preserve">
          <source>For integer atomic types, the compound assignment &lt;code&gt;@=&lt;/code&gt; is equivalent to:</source>
          <target state="translated">Для целочисленных атомарных типов составное присваивание &lt;code&gt;@=&lt;/code&gt; эквивалентно:</target>
        </trans-unit>
        <trans-unit id="536dc8c314b296f6f261eb306e04e8cffb32d705" translate="yes" xml:space="preserve">
          <source>For most &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;cproj(z)==z&lt;/code&gt;, but all complex infinities, even the numbers where one component is infinite and the other is NaN, become positive real infinity, &lt;code&gt;INFINITY+0.0*I&lt;/code&gt; or &lt;code&gt;INFINITY-0.0*I&lt;/code&gt;. The sign of the imaginary (zero) component is the sign of &lt;code&gt;&lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z)&lt;/code&gt;.</source>
          <target state="translated">Для большинства &lt;code&gt;z&lt;/code&gt; , &lt;code&gt;cproj(z)==z&lt;/code&gt; , но все комплексных бесконечностей, даже чисел , где один компонент является бесконечным , а другим является NaN, становятся положительной в реальной бесконечности, &lt;code&gt;INFINITY+0.0*I&lt;/code&gt; или &lt;code&gt;INFINITY-0.0*I&lt;/code&gt; . Знак мнимой (нулевой) составляющей является знаком &lt;code&gt;&lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69a061f40ae84751c0047ebb6b42628283ef685f" translate="yes" xml:space="preserve">
          <source>For objects, a declaration that allocates storage (&lt;a href=&quot;storage_duration&quot;&gt;automatic or static&lt;/a&gt;, but not extern) is a definition, while a declaration that does not allocate storage (&lt;a href=&quot;extern&quot;&gt;external declaration&lt;/a&gt;) is not.</source>
          <target state="translated">Для объектов объявление, которое выделяет хранилище ( &lt;a href=&quot;storage_duration&quot;&gt;автоматическое или статическое&lt;/a&gt; , но не внешнее), является определением, в то время как объявление, которое не выделяет хранилище ( &lt;a href=&quot;extern&quot;&gt;внешнее объявление&lt;/a&gt; ), не является определением.</target>
        </trans-unit>
        <trans-unit id="8f63d9afe770e3006ba3c31bb680ec6934c94657" translate="yes" xml:space="preserve">
          <source>For output streams (and for update streams on which the last operation was output), writes any unwritten data from the &lt;code&gt;stream&lt;/code&gt;'s buffer to the associated output device.</source>
          <target state="translated">Для выходных потоков (и для потоков обновления, для которых была выведена последняя операция), записывает любые неписанные данные из буфера &lt;code&gt;stream&lt;/code&gt; в соответствующее устройство вывода.</target>
        </trans-unit>
        <trans-unit id="68c6725395fe6fb1de1c0a20e8316ae564ff30cb" translate="yes" xml:space="preserve">
          <source>For relational = and &amp;ne; respectively</source>
          <target state="translated">Для реляционных = и &amp;ne; соответственно</target>
        </trans-unit>
        <trans-unit id="ef442ef93a7d1fa17196f13ed58dd573c463f6d6" translate="yes" xml:space="preserve">
          <source>For relational operators &amp;gt; and &amp;ge; respectively</source>
          <target state="translated">Для реляционных операторов&amp;gt; и &amp;ge; соответственно</target>
        </trans-unit>
        <trans-unit id="0b60290890a2917bb2e0cc3c4c8b8aa425f9bd30" translate="yes" xml:space="preserve">
          <source>For relational operators &amp;lt; and &amp;le; respectively</source>
          <target state="translated">Для реляционных операторов &amp;lt;и &amp;le; соответственно</target>
        </trans-unit>
        <trans-unit id="879eb9efaaa4654c8cf8c35b00408e67b8bf1832" translate="yes" xml:space="preserve">
          <source>For signed integer types, arithmetic is defined to use two&amp;rsquo;s complement representation. There are no undefined results. For pointer types, the result may be an undefined address, but the operations otherwise have no undefined behavior.</source>
          <target state="translated">Для целочисленных типов со знаком арифметика определяется с использованием представления дополнения до двух. Там нет неопределенных результатов. Для типов указателей результат может быть неопределенным адресом, но в противном случае операции не имеют неопределенного поведения.</target>
        </trans-unit>
        <trans-unit id="80e4c346fe02c1a18878d7d91ddce96980e8a1f4" translate="yes" xml:space="preserve">
          <source>For text streams, the only valid values of &lt;code&gt;offset&lt;/code&gt; are &lt;code&gt;​0​&lt;/code&gt; (applicable to any &lt;code&gt;origin&lt;/code&gt;) and a value returned by an earlier call to &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;ftell&lt;/a&gt;&lt;/code&gt; (only applicable to &lt;code&gt;SEEK_SET&lt;/code&gt;).</source>
          <target state="translated">Для текстовых потоков, то только действительные значения &lt;code&gt;offset&lt;/code&gt; являются &lt;code&gt;​0​&lt;/code&gt; (применимо к любому &lt;code&gt;origin&lt;/code&gt; ) и возвращаемое значение более раннему вызовом &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;ftell&lt;/a&gt;&lt;/code&gt; (применимо только к &lt;code&gt;SEEK_SET&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6c8bc61f784489c1be269b98b2a834b94911c08f" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;A&lt;/code&gt; conversion style</source>
          <target state="translated">Для стиля преобразования &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2ae91f5c3692945d40532e2d71ac0a4386bf89f" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;E&lt;/code&gt; conversion style</source>
          <target state="translated">Для стиля преобразования &lt;code&gt;E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebb3f8b2a8fff5b3415e1098f326b2c10a1d27f2" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;G&lt;/code&gt; conversion style conversion with style &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;F&lt;/code&gt; will be performed.</source>
          <target state="translated">Для &lt;code&gt;G&lt;/code&gt; преобразования стиля преобразования в стиле &lt;code&gt;E&lt;/code&gt; или &lt;code&gt;F&lt;/code&gt; будет выполняться.</target>
        </trans-unit>
        <trans-unit id="5a1ff43b4f3925bee54ad2942ba18ef8a4606c5a" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;X&lt;/code&gt; conversion letters &lt;code&gt;ABCDEF&lt;/code&gt; are used.</source>
          <target state="translated">Для преобразования &lt;code&gt;X&lt;/code&gt; используются буквы &lt;code&gt;ABCDEF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57890cceddb7efc24f01d52d8cf7f7dcc8bbc9c7" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;a&lt;/code&gt; conversion style</source>
          <target state="translated">Для &lt;code&gt;a&lt;/code&gt; стиля преобразования</target>
        </trans-unit>
        <trans-unit id="41f7d301edd4649ecc9cc5e4ae27295bc06e8657" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;e&lt;/code&gt; conversion style</source>
          <target state="translated">Для стиля преобразования &lt;code&gt;e&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a793f4315aaf80e04799e8d39a2f905e34a3d0ea" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;g&lt;/code&gt; conversion style conversion with style &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;f&lt;/code&gt; will be performed.</source>
          <target state="translated">Для &lt;code&gt;g&lt;/code&gt; преобразования преобразования стиля со стилем &lt;code&gt;e&lt;/code&gt; или &lt;code&gt;f&lt;/code&gt; будет.</target>
        </trans-unit>
        <trans-unit id="807d09a568c3d3ab555b52969a3cc98de7806c36" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;x&lt;/code&gt; conversion letters &lt;code&gt;abcdef&lt;/code&gt; are used.</source>
          <target state="translated">Для преобразования &lt;code&gt;x&lt;/code&gt; используются буквы &lt;code&gt;abcdef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="964c75b68c3b67fa44944f427366e59ff71c8628" translate="yes" xml:space="preserve">
          <source>For the IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, if |arg| &amp;gt; 710.5, then &lt;code&gt;cosh(arg)&lt;/code&gt; overflows.</source>
          <target state="translated">Для IEEE-совместимого типа &lt;code&gt;double&lt;/code&gt; , если | arg | &amp;gt; 710,5, то переполнение &lt;code&gt;cosh(arg)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc98bc92461ef84f63213928d7e0dd4bec2a4ac3" translate="yes" xml:space="preserve">
          <source>For the IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, underflow is guaranteed if &lt;code&gt;arg&lt;/code&gt; &amp;gt; 26.55.</source>
          <target state="translated">Для &lt;code&gt;double&lt;/code&gt; типа, совместимого с IEEE , недопустимость гарантируется, если &lt;code&gt;arg&lt;/code&gt; &amp;gt; 26.55.</target>
        </trans-unit>
        <trans-unit id="0a1e05ff972bb1fabc13e5a58a87f80191cc1553" translate="yes" xml:space="preserve">
          <source>For the objects of type char, signed char, and unsigned char, every bit of the object representation is required to participate in the value representation and each possible bit pattern represents a distinct value (no padding, trap bits, or multiple representations allowed).</source>
          <target state="translated">Для объектов типа char,signed char и unsigned char для участия в представлении значения требуется каждый бит объектного представления,а каждый возможный битовый паттерн представляет отдельное значение (не допускается подкладка,бит-ловушка или несколько представлений).</target>
        </trans-unit>
        <trans-unit id="73df8e10bbeffa07fc22138e0b70d965b3e4a35b" translate="yes" xml:space="preserve">
          <source>For the objects that are declared with automatic, static, and thread storage duration, lifetime equals their &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; (note the difference between non-VLA and VLA automatic storage duration).</source>
          <target state="translated">Для объектов, которые объявлены с автоматическим, статическим и длительным хранением потоков, время жизни равно &lt;a href=&quot;storage_duration&quot;&gt;продолжительности&lt;/a&gt; их хранения (обратите внимание на разницу между длительностью автоматического хранения без VLA и VLA).</target>
        </trans-unit>
        <trans-unit id="cc128730b3badfe5698c4b1f3a2f185e2ed4fea5" translate="yes" xml:space="preserve">
          <source>For the objects with allocated storage duration, the lifetime begins when the allocation function returns (including the return from &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;) and ends when the &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; or deallocation function is called. Note that since allocated objects have no &lt;a href=&quot;object&quot;&gt;declared type&lt;/a&gt;, the type of the lvalue expression first used to access this object becomes its &lt;a href=&quot;object&quot;&gt;effective type&lt;/a&gt;.</source>
          <target state="translated">Для объектов с выделенной продолжительностью хранения время жизни начинается, когда функция выделения возвращается (включая возврат из &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; ), и заканчивается, когда вызывается функция &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; или освобождения. Обратите внимание, что, поскольку выделенные объекты не имеют &lt;a href=&quot;object&quot;&gt;объявленного типа&lt;/a&gt; , тип выражения lvalue, впервые использованного для доступа к этому объекту, становится его &lt;a href=&quot;object&quot;&gt;эффективным типом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85282601413e96349836f3981d64d53720f214c0" translate="yes" xml:space="preserve">
          <source>For the purpose of pointer arithmetic, a pointer to an object that is not an element of any array is treated as a pointer to the first element of an array of size 1.</source>
          <target state="translated">Для целей арифметики с указателями,указатель на объект,не являющийся элементом какого-либо массива,рассматривается как указатель на первый элемент массива размера 1.</target>
        </trans-unit>
        <trans-unit id="e385562c47760adbc54c3ba96ba6ba291ce3d32e" translate="yes" xml:space="preserve">
          <source>For unsigned lhs and for signed lhs with nonnegative values, the value of &lt;code&gt;LHS &amp;gt;&amp;gt; RHS&lt;/code&gt; is the integer part of LHS / 2RHS</source>
          <target state="translated">Для неподписанных lhs и для подписанных lhs с неотрицательными значениями значение &lt;code&gt;LHS &amp;gt;&amp;gt; RHS&lt;/code&gt; является целочисленной частью LHS / 2RHS.</target>
        </trans-unit>
        <trans-unit id="b78e8d26fc84b75eb18e29ba68eb6707882c4aea" translate="yes" xml:space="preserve">
          <source>For unsigned lhs, the value of &lt;code&gt;LHS &amp;lt;&amp;lt; RHS&lt;/code&gt; is the value of LHS * 2RHS</source>
          <target state="translated">Для неподписанных lhs значение &lt;code&gt;LHS &amp;lt;&amp;lt; RHS&lt;/code&gt; является значением LHS * 2RHS</target>
        </trans-unit>
        <trans-unit id="bccf9c84234fd9e53ce6ea6772d91da3ac9147fd" translate="yes" xml:space="preserve">
          <source>For use of bytes to representation values of other fundamental types (including big-endian and little-endian memory layouts), see &lt;a href=&quot;object#Object_representation&quot;&gt;object representation&lt;/a&gt;.</source>
          <target state="translated">Для использования байтов для представления значений других фундаментальных типов (включая макеты памяти с прямым порядком байтов и с прямым порядком байтов), см. &lt;a href=&quot;object#Object_representation&quot;&gt;Представление объекта&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3bfb55cdc85542de2eeac7c01ac22e44b5143662" translate="yes" xml:space="preserve">
          <source>Formally,</source>
          <target state="translated">Formally,</target>
        </trans-unit>
        <trans-unit id="3e6350defe07d4e2839cc6eb5191b1da5190bee4" translate="yes" xml:space="preserve">
          <source>Formally, the unbiased exponent is the integral part of log</source>
          <target state="translated">Формально непредвзятый экспонент является неотъемлемой частью бревна.</target>
        </trans-unit>
        <trans-unit id="91dd56eddc735a099ddc37f2c2b8d705630baadf" translate="yes" xml:space="preserve">
          <source>Formally, the unbiased exponent is the signed integral part of log</source>
          <target state="translated">Формально непредвзятым экспонентом является подписанная неотъемлемая часть бревна.</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="375f5594c659e5ff8bd611de411cc215c9d6fb94" translate="yes" xml:space="preserve">
          <source>Format constants for the &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;fprintf&lt;/a&gt;&lt;/code&gt; family of functions</source>
          <target state="translated">Форматные константы для семейства функций &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;fprintf&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46ffb8548d52b3ad3fbe1f297d1fca34ee39282c" translate="yes" xml:space="preserve">
          <source>Format constants for the &lt;code&gt;&lt;a href=&quot;../io/fscanf&quot;&gt;fscanf&lt;/a&gt;&lt;/code&gt; family of functions</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../io/fscanf&quot;&gt;fscanf&lt;/a&gt;&lt;/code&gt; константы для семейства функций fscanf</target>
        </trans-unit>
        <trans-unit id="a28652e2e23cf314a85ef17df4e8261414955885" translate="yes" xml:space="preserve">
          <source>Format conversion of integer types</source>
          <target state="translated">Форматное преобразование целочисленных типов</target>
        </trans-unit>
        <trans-unit id="6b8afd05c64332502d3616cc67779e98de2c7168" translate="yes" xml:space="preserve">
          <source>Format conversions</source>
          <target state="translated">Преобразование форматов</target>
        </trans-unit>
        <trans-unit id="7175d023e27abe317865a491022a09c5f080a380" translate="yes" xml:space="preserve">
          <source>Format macro constants</source>
          <target state="translated">Макроконстанты формата</target>
        </trans-unit>
        <trans-unit id="ee59b03a5ff5c727bd5ce0a27fd2bc91e970bc1f" translate="yes" xml:space="preserve">
          <source>Formatted input/output</source>
          <target state="translated">Форматированный ввод/вывод</target>
        </trans-unit>
        <trans-unit id="82ea89ab75987595e45620e5e795108b1b6e0406" translate="yes" xml:space="preserve">
          <source>Forward declaration</source>
          <target state="translated">Форвардное заявление</target>
        </trans-unit>
        <trans-unit id="1f91dbf7a513677af10fb3592a515c7e6904306f" translate="yes" xml:space="preserve">
          <source>Full type name</source>
          <target state="translated">Полное имя типа</target>
        </trans-unit>
        <trans-unit id="f14045db7fd843c69383648cf94f75fb3d176a15" translate="yes" xml:space="preserve">
          <source>Function call</source>
          <target state="translated">Вызов функции</target>
        </trans-unit>
        <trans-unit id="c89b9bb41c4c13c872e30f5eb0bb250a5c580801" translate="yes" xml:space="preserve">
          <source>Function declaration</source>
          <target state="translated">Декларация функций</target>
        </trans-unit>
        <trans-unit id="301ffb948f7d729015635b11db6553b40624b34f" translate="yes" xml:space="preserve">
          <source>Function declarations</source>
          <target state="translated">Функциональные декларации</target>
        </trans-unit>
        <trans-unit id="e6bcd818ad8d35fa4ac158274d99b7201a135a1f" translate="yes" xml:space="preserve">
          <source>Function declarations at block scope can use &lt;code&gt;extern&lt;/code&gt; or none at all. Function declarations at file scope can use &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">Объявления функций в области видимости блока могут использовать &lt;code&gt;extern&lt;/code&gt; или вообще не использовать. Объявления функций в области видимости файлов могут использовать &lt;code&gt;extern&lt;/code&gt; или &lt;code&gt;static&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e44d37020289cf4e22446e56d29f9f3a5cb0dd6" translate="yes" xml:space="preserve">
          <source>Function declarators can be combined with other declarators as long as they can share their type specifiers and qualifiers.</source>
          <target state="translated">Функциональные деклараторы можно комбинировать с другими деклараторами до тех пор,пока они могут разделять свои спецификаторы типа и классификаторы.</target>
        </trans-unit>
        <trans-unit id="b5f8af75bc5ad30466ed317152a310aba07e877e" translate="yes" xml:space="preserve">
          <source>Function definition</source>
          <target state="translated">Определение функций</target>
        </trans-unit>
        <trans-unit id="b6845f6242d31b642f35208f093f8e9aba102be9" translate="yes" xml:space="preserve">
          <source>Function definitions</source>
          <target state="translated">Определения функций</target>
        </trans-unit>
        <trans-unit id="0004b660206eedce99e85c5907656101eed2ba97" translate="yes" xml:space="preserve">
          <source>Function designator expression</source>
          <target state="translated">Выражение обозначения функции</target>
        </trans-unit>
        <trans-unit id="56247e3ce0cb2812a9cd7b40705c577d342f4d79" translate="yes" xml:space="preserve">
          <source>Function discards any whitespace characters (as determined by &lt;code&gt;std::&lt;a href=&quot;isspace&quot;&gt;isspace&lt;/a&gt;()&lt;/code&gt;) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</source>
          <target state="translated">Функция отбрасывает любые пробельные символы (как определено &lt;code&gt;std::&lt;a href=&quot;isspace&quot;&gt;isspace&lt;/a&gt;()&lt;/code&gt; ) до тех пор, пока не будет найден первый непробельный символ. Затем требуется как можно больше символов, чтобы сформировать правильное представление с плавающей запятой и преобразовать их в значение с плавающей запятой. Допустимое значение с плавающей запятой может быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="6ac61bae440a3f41b35363be03410015a24d97cd" translate="yes" xml:space="preserve">
          <source>Function discards any whitespace characters (as determined by &lt;code&gt;std::&lt;a href=&quot;iswspace&quot;&gt;iswspace&lt;/a&gt;()&lt;/code&gt;) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</source>
          <target state="translated">Функция отбрасывает любые пробельные символы (как определено &lt;code&gt;std::&lt;a href=&quot;iswspace&quot;&gt;iswspace&lt;/a&gt;()&lt;/code&gt; ) до тех пор, пока не будет найден первый непробельный символ. Затем требуется как можно больше символов, чтобы сформировать правильное представление с плавающей запятой и преобразовать их в значение с плавающей запятой. Допустимое значение с плавающей запятой может быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="60be48a55b3f6bfe81f126777640e7116a702836" translate="yes" xml:space="preserve">
          <source>Function macros for minimum-width integer constants</source>
          <target state="translated">Функциональные макросы для целочисленных констант минимальной ширины</target>
        </trans-unit>
        <trans-unit id="8611a2a8a66243d802deec0150be8ab29d36d93c" translate="yes" xml:space="preserve">
          <source>Function names, type names, and enumeration constants that begin with either &lt;code&gt;cnd_&lt;/code&gt;, &lt;code&gt;mtx_&lt;/code&gt;, &lt;code&gt;thrd_&lt;/code&gt;, or &lt;code&gt;tss_&lt;/code&gt;, and a lowercase letter may be added to the declarations in the &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt; header in future revisions of the C standard, and portable programs should not use those identifiers.</source>
          <target state="translated">Имена функций, имена типов и константы перечисления, начинающиеся с &lt;code&gt;cnd_&lt;/code&gt; , &lt;code&gt;mtx_&lt;/code&gt; , &lt;code&gt;thrd_&lt;/code&gt; или &lt;code&gt;tss_&lt;/code&gt; , а также строчные буквы могут быть добавлены в объявления в заголовке &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt; в будущих версиях стандарта C и переносимы программы не должны использовать эти идентификаторы.</target>
        </trans-unit>
        <trans-unit id="5d302435048821cd6e2c77c400cdc613a006798f" translate="yes" xml:space="preserve">
          <source>Function parameter</source>
          <target state="translated">Параметр функции</target>
        </trans-unit>
        <trans-unit id="897bc01f0c788bf99ba1e506b918d0c6dc003db3" translate="yes" xml:space="preserve">
          <source>Function parameters cannot use any storage-class specifiers other than &lt;code&gt;register&lt;/code&gt;. Note that &lt;code&gt;static&lt;/code&gt; has special meaning in function parameters of array type.</source>
          <target state="translated">Параметры функции не могут использовать никаких спецификаторов класса хранения, кроме &lt;code&gt;register&lt;/code&gt; . Обратите внимание, что &lt;code&gt;static&lt;/code&gt; имеет особое значение в параметрах функции типа array.</target>
        </trans-unit>
        <trans-unit id="65b1ee7db3df5d96f4d481571269021a7e58f345" translate="yes" xml:space="preserve">
          <source>Function prototype scope</source>
          <target state="translated">Область применения прототипа функции</target>
        </trans-unit>
        <trans-unit id="14644346bcc70a878c3eb265226005a7304bec16" translate="yes" xml:space="preserve">
          <source>Function scope</source>
          <target state="translated">Объём функций</target>
        </trans-unit>
        <trans-unit id="cc0c3a9a39538ad721a8a34b1652f79fa1c98697" translate="yes" xml:space="preserve">
          <source>Function to pointer conversion</source>
          <target state="translated">Преобразование функции в указатель</target>
        </trans-unit>
        <trans-unit id="2e3030f5a7f048cef8382d50828336e71bb753d2" translate="yes" xml:space="preserve">
          <source>Function-like macros</source>
          <target state="translated">Функциональные макросы</target>
        </trans-unit>
        <trans-unit id="1db43149fb17967937b95803eca5c9dd022b9456" translate="yes" xml:space="preserve">
          <source>Function-like macros replace each occurrence of a defined identifier with replacement-list, additionally taking a number of arguments, which then replace corresponding occurrences of any of the parameters in the replacement-list.</source>
          <target state="translated">Функциональноподобные макросы заменяют каждое появление определенного идентификатора на заменяющий список,дополнительно принимая ряд аргументов,которые затем заменяют соответствующие вхождения любого из параметров в заменяющем списке.</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="b739266e3c6aeb113a3693680f16c996224db99c" translate="yes" xml:space="preserve">
          <source>Functions may accept zero or more</source>
          <target state="translated">Функции могут принимать ноль и более</target>
        </trans-unit>
        <trans-unit id="1788789dd164ce9b4d0f6beaa43826240bc2b04a" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;at_quick_exit()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;atexit()&lt;/a&gt;&lt;/code&gt; are not called. Whether open streams with unwritten buffered data are flushed, open streams are closed, or temporary files are removed is implementation-defined.</source>
          <target state="translated">Функции, переданные в &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;at_quick_exit()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;atexit()&lt;/a&gt;&lt;/code&gt; , не вызываются. Сбрасываются ли открытые потоки с неписанными буферизованными данными, закрытые потоки или удаляются временные файлы, определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="093b58a5c37c2b165378562c2473a310e08a10ac" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;at_quick_exit&lt;/a&gt;&lt;/code&gt; are called in reverse order of their registration. After calling the registered functions, calls &lt;code&gt;&lt;a href=&quot;_exit&quot;&gt;_Exit&lt;/a&gt;(exit_code)&lt;/code&gt;.</source>
          <target state="translated">Функции, переданные в &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;at_quick_exit&lt;/a&gt;&lt;/code&gt; , вызываются в обратном порядке их регистрации. После вызова зарегистрированных функций вызывается &lt;code&gt;&lt;a href=&quot;_exit&quot;&gt;_Exit&lt;/a&gt;(exit_code)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6eaa62088da9f4aaace239ef18473787adba2624" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;atexit()&lt;/a&gt;&lt;/code&gt; are not called. Whether open resources such as files are closed is implementation defined. An implementation defined status is returned to the host environment that indicates unsuccessful execution.</source>
          <target state="translated">Функции, переданные в &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;atexit()&lt;/a&gt;&lt;/code&gt; , не вызываются. Закрыты ли открытые ресурсы, такие как файлы, определяется реализацией. Статус, определенный реализацией, возвращается в хост-среду, что указывает на неудачное выполнение.</target>
        </trans-unit>
        <trans-unit id="c38cb46c4c3dc86adeece732ff02d4d810f5334b" translate="yes" xml:space="preserve">
          <source>Functions that ignore unused arguments, such as &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, must be called with a prototype in scope (the prototype of such functions necessarily uses the &lt;a href=&quot;variadic&quot;&gt;trailing ellipsis&lt;/a&gt; parameter) to avoid invoking undefined behavior.</source>
          <target state="translated">Функции, которые игнорируют неиспользуемые аргументы, такие как &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , должны вызываться с прототипом в области видимости (в прототипе таких функций обязательно используется параметр &lt;a href=&quot;variadic&quot;&gt;конечного многоточия&lt;/a&gt; ), чтобы избежать вызова неопределенного поведения.</target>
        </trans-unit>
        <trans-unit id="987a9735f7910a78415404d390c2c2321b297df5" translate="yes" xml:space="preserve">
          <source>Functions to determine the type contained in character data</source>
          <target state="translated">Функции определения типа,содержащегося в символьных данных</target>
        </trans-unit>
        <trans-unit id="56333d40b9d13a5dd6765448f63eb5888129f41c" translate="yes" xml:space="preserve">
          <source>Functions to determine the type contained in wide character data</source>
          <target state="translated">Функции определения типа,содержащегося в широкоформатных данных</target>
        </trans-unit>
        <trans-unit id="f9ccc0fa4eefc3fc4fbd603adf877686e0fcb107" translate="yes" xml:space="preserve">
          <source>Fundamental types defined by the language</source>
          <target state="translated">Фундаментальные типы,определяемые языком</target>
        </trans-unit>
        <trans-unit id="b40e0801f27d530d95fd36fa896a9bc2b6b5bae8" translate="yes" xml:space="preserve">
          <source>G.1/1 __STDC_IEC_559_COMPLEX__ (p: 467)</source>
          <target state="translated">G.1/1 __STDC_IEC_559_COMPLEX__(стр.467)</target>
        </trans-unit>
        <trans-unit id="26bf5fe88c328fbc6e45a59d6ad8c3338b8f81d3" translate="yes" xml:space="preserve">
          <source>G.1/1 __STDC_IEC_559_COMPLEX__ (p: 532)</source>
          <target state="translated">G.1/1 __STDC_IEC_559_COMPLEX__(стр.532)</target>
        </trans-unit>
        <trans-unit id="95c12bcd2220cd7ce08b8f2049d3ec8c11b89bc0" translate="yes" xml:space="preserve">
          <source>G.5 Common extensions</source>
          <target state="translated">G.5 Общие расширения</target>
        </trans-unit>
        <trans-unit id="6cfe6dbfae9b4bae4ad5072108c7d017fc8beae5" translate="yes" xml:space="preserve">
          <source>G.6.1.1 The cacos functions (p: 474)</source>
          <target state="translated">G.6.1.1 Функции какоса (стр.474)</target>
        </trans-unit>
        <trans-unit id="28cd3a62fe8f1c7d66de5b67bae415419d002420" translate="yes" xml:space="preserve">
          <source>G.6.1.1 The cacos functions (p: 539)</source>
          <target state="translated">G.6.1.1 Функции какоса (стр.539)</target>
        </trans-unit>
        <trans-unit id="0d6828ca5fb97ca1d1f2d7c68567b2a005ebd2dc" translate="yes" xml:space="preserve">
          <source>G.6.2.1 The cacosh functions (p: 474-475)</source>
          <target state="translated">G.6.2.1 Функции какоша (стр.474-475)</target>
        </trans-unit>
        <trans-unit id="5563291e3a61ef1c53c5a28c3172a343b28df495" translate="yes" xml:space="preserve">
          <source>G.6.2.1 The cacosh functions (p: 539-540)</source>
          <target state="translated">G.6.2.1 Функции какоша (стр.539-540)</target>
        </trans-unit>
        <trans-unit id="15c4239db1623508b82ef247489b388de1f145aa" translate="yes" xml:space="preserve">
          <source>G.6.2.2 The casinh functions (p: 475)</source>
          <target state="translated">G.6.2.2 Функции казино (стр.475)</target>
        </trans-unit>
        <trans-unit id="d95db88fd7fa78e9816bf9ac2e9ac27bc72cdaef" translate="yes" xml:space="preserve">
          <source>G.6.2.2 The casinh functions (p: 540)</source>
          <target state="translated">G.6.2.2 Функции казино (стр.540)</target>
        </trans-unit>
        <trans-unit id="d126febe0f09e9c82a643bf277ca8d4fe4e04945" translate="yes" xml:space="preserve">
          <source>G.6.2.3 The catanh functions (p: 475-476)</source>
          <target state="translated">G.6.2.3 Функции катанга (стр.475-476)</target>
        </trans-unit>
        <trans-unit id="e9df4d1c541d6a2988fd893d1e22aa72d9155e65" translate="yes" xml:space="preserve">
          <source>G.6.2.3 The catanh functions (p: 540-541)</source>
          <target state="translated">G.6.2.3 Функции катанга (стр.540-541)</target>
        </trans-unit>
        <trans-unit id="151135301ba799fb81ac54ff917a64f55b3d87b2" translate="yes" xml:space="preserve">
          <source>G.6.2.4 The ccosh functions (p: 476)</source>
          <target state="translated">G.6.2.4 Функции ккоша (стр.476)</target>
        </trans-unit>
        <trans-unit id="efb2b4b5712cfe1e5839fb21e5627757b0aab87b" translate="yes" xml:space="preserve">
          <source>G.6.2.4 The ccosh functions (p: 541)</source>
          <target state="translated">G.6.2.4 Функции ккоша (стр.541)</target>
        </trans-unit>
        <trans-unit id="694daeb728fce58d77bf0d8e64905eea2b21ad5f" translate="yes" xml:space="preserve">
          <source>G.6.2.5 The csinh functions (p: 476-477)</source>
          <target state="translated">G.6.2.5 Функции ксинх (стр.476-477)</target>
        </trans-unit>
        <trans-unit id="59eab894944e803c504dd7168fa4266717e78383" translate="yes" xml:space="preserve">
          <source>G.6.2.5 The csinh functions (p: 541-542)</source>
          <target state="translated">G.6.2.5 Функции ксинх (стр.541-542)</target>
        </trans-unit>
        <trans-unit id="f2df7c85c1d43e348f139a6b045dc1d5b8012c06" translate="yes" xml:space="preserve">
          <source>G.6.2.6 The ctanh functions (p: 477)</source>
          <target state="translated">G.6.2.6 Функции цтаня (стр.477)</target>
        </trans-unit>
        <trans-unit id="d9eb1944f14793485c1748feed122919547f89b9" translate="yes" xml:space="preserve">
          <source>G.6.2.6 The ctanh functions (p: 542)</source>
          <target state="translated">G.6.2.6 Функции цтанхауса (стр.542)</target>
        </trans-unit>
        <trans-unit id="11bf1336a1baab07ae8854d62d4f99e7b6ec203d" translate="yes" xml:space="preserve">
          <source>G.6.3.1 The cexp functions (p: 478)</source>
          <target state="translated">G.6.3.1 Функции cexp (стр.478)</target>
        </trans-unit>
        <trans-unit id="e149ca4beb9e25b6bda49409bda5f10206e086b7" translate="yes" xml:space="preserve">
          <source>G.6.3.1 The cexp functions (p: 543)</source>
          <target state="translated">G.6.3.1 Функции cexp (стр.543)</target>
        </trans-unit>
        <trans-unit id="e9c93804224051a50630d62c4ed8220690a9bfa6" translate="yes" xml:space="preserve">
          <source>G.6.3.2 The clog functions (p: 478-479)</source>
          <target state="translated">G.6.3.2 Функции засорения (стр.478-479)</target>
        </trans-unit>
        <trans-unit id="b973293eede2ecb3bd41d6f371cc4d1697571cd1" translate="yes" xml:space="preserve">
          <source>G.6.3.2 The clog functions (p: 543-544)</source>
          <target state="translated">G.6.3.2 Функции засорения (стр.543-544)</target>
        </trans-unit>
        <trans-unit id="c92214d3d5a8fbcf280afad86e034a21ce259174" translate="yes" xml:space="preserve">
          <source>G.6.4.1 The cpow functions (p: 479)</source>
          <target state="translated">G.6.4.1 Функции коровы (стр.479)</target>
        </trans-unit>
        <trans-unit id="de2003697457272aa833f7982055194cc6b7115f" translate="yes" xml:space="preserve">
          <source>G.6.4.1 The cpow functions (p: 544)</source>
          <target state="translated">G.6.4.1 Функции коровы (стр.544)</target>
        </trans-unit>
        <trans-unit id="e40ff81ce8c3267d1bf703062d6a64cc98b1f38c" translate="yes" xml:space="preserve">
          <source>G.6.4.2 The csqrt functions (p: 479)</source>
          <target state="translated">G.6.4.2 Функции csqrt (стр.479)</target>
        </trans-unit>
        <trans-unit id="05f7734e308beb0fedfb7893ef3fa7e54af7b545" translate="yes" xml:space="preserve">
          <source>G.6.4.2 The csqrt functions (p: 544)</source>
          <target state="translated">G.6.4.2 Функции csqrt (стр.544)</target>
        </trans-unit>
        <trans-unit id="c20fd542256174a6393b0316152fcef6e7b39622" translate="yes" xml:space="preserve">
          <source>G.6/1 I (p: 472)</source>
          <target state="translated">G.6/1 I (p:472)</target>
        </trans-unit>
        <trans-unit id="e76143abbf8e87829cf91c7d518a52e7300d298b" translate="yes" xml:space="preserve">
          <source>G.6/1 I (p: 537)</source>
          <target state="translated">G.6/1 I (p:537)</target>
        </trans-unit>
        <trans-unit id="a2e6820b346f1cb99f63ee321c682a377db511b9" translate="yes" xml:space="preserve">
          <source>G.6/1 _Imaginary_I (p: 472)</source>
          <target state="translated">G.6/1 _Imaginary_I (p:472)</target>
        </trans-unit>
        <trans-unit id="0ccf37492c7533141e934c40b558afd151233311" translate="yes" xml:space="preserve">
          <source>G.6/1 _Imaginary_I (p: 537)</source>
          <target state="translated">G.6/1 _Imaginary_I (p:537)</target>
        </trans-unit>
        <trans-unit id="208724c83318d0110acbd3f15de4edddbcd6efdf" translate="yes" xml:space="preserve">
          <source>G.6/1 imaginary (p: 472)</source>
          <target state="translated">G.6/1 воображаемый (стр.472)</target>
        </trans-unit>
        <trans-unit id="cf45a995bfaea360a6835fd54d30380487b0f7e5" translate="yes" xml:space="preserve">
          <source>G.6/1 imaginary (p: 537)</source>
          <target state="translated">G.6/1 воображаемый (стр.537)</target>
        </trans-unit>
        <trans-unit id="50662b8108e397a8cf830e58874d9ce4fe937eaf" translate="yes" xml:space="preserve">
          <source>G.7 Type-generic math &amp;lt;tgmath.h&amp;gt; (p: 480)</source>
          <target state="translated">G.7 Типовая математика &amp;lt;tgmath.h&amp;gt; (стр: 480)</target>
        </trans-unit>
        <trans-unit id="4f44e0122fc6c4e13b2e4136b84f00a56924a452" translate="yes" xml:space="preserve">
          <source>G.7 Type-generic math &amp;lt;tgmath.h&amp;gt; (p: 545)</source>
          <target state="translated">G.7 Типовая математика &amp;lt;tgmath.h&amp;gt; (стр: 545)</target>
        </trans-unit>
        <trans-unit id="ac2bfb22c6d1b00526db5c04d7d3f16f7a772c12" translate="yes" xml:space="preserve">
          <source>GCC provides a non-portable extension that allows imaginary constants to be specified with the suffix &lt;code&gt;i&lt;/code&gt; on integer literals: &lt;code&gt;1.0fi&lt;/code&gt;, &lt;code&gt;1.0i&lt;/code&gt;, and &lt;code&gt;1.0li&lt;/code&gt; are imaginary units in GNU C. A similar approach is part of standard C++ as of C++14 (&lt;code&gt;1.0if&lt;/code&gt;, &lt;code&gt;1.0i&lt;/code&gt;, and &lt;code&gt;1.0il&lt;/code&gt; are the imaginary units in C++).</source>
          <target state="translated">GCC предоставляет &lt;code&gt;1.0fi&lt;/code&gt; расширение, которое позволяет указывать мнимые константы с суффиксом &lt;code&gt;i&lt;/code&gt; для целочисленных литералов: 1.0fi , &lt;code&gt;1.0i&lt;/code&gt; и &lt;code&gt;1.0li&lt;/code&gt; являются мнимыми единицами в GNU C. Подобный подход является частью стандарта C ++ для C + +14 ( &lt;code&gt;1.0if&lt;/code&gt; , &lt;code&gt;1.0i&lt;/code&gt; и &lt;code&gt;1.0il&lt;/code&gt; - мнимые единицы в C ++).</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="10dd377e783f3967d6438e53ce8a2f7f5022cc8a" translate="yes" xml:space="preserve">
          <source>General utilities: &lt;a href=&quot;memory&quot;&gt;memory management&lt;/a&gt;, &lt;a href=&quot;program&quot;&gt;program utilities&lt;/a&gt;, &lt;a href=&quot;string&quot;&gt;string conversions&lt;/a&gt;, &lt;a href=&quot;numeric/random&quot;&gt;random numbers&lt;/a&gt;</source>
          <target state="translated">Общие утилиты: &lt;a href=&quot;memory&quot;&gt;управление памятью&lt;/a&gt; , &lt;a href=&quot;program&quot;&gt;программные утилиты&lt;/a&gt; , &lt;a href=&quot;string&quot;&gt;преобразования строк&lt;/a&gt; , &lt;a href=&quot;numeric/random&quot;&gt;случайные числа&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e408e1f43fa73d535c56f0c1a60024c29bed6a6f" translate="yes" xml:space="preserve">
          <source>Generally speaking, the pseudo-random number generator should only be seeded once, before any calls to &lt;code&gt;rand()&lt;/code&gt;, and the start of the program. It should not be repeatedly seeded, or reseeded every time you wish to generate a new batch of pseudo-random numbers.</source>
          <target state="translated">Вообще говоря, генератор псевдослучайных чисел должен быть засеян только один раз, перед любыми вызовами &lt;code&gt;rand()&lt;/code&gt; и запуском программы. Он не должен быть повторно посеян или повторно заполнен каждый раз, когда вы хотите сгенерировать новую партию псевдослучайных чисел.</target>
        </trans-unit>
        <trans-unit id="12eb72d3243c15b2d7666b7ae7d45ad3f7dad95a" translate="yes" xml:space="preserve">
          <source>Generic selection</source>
          <target state="translated">Общий отбор</target>
        </trans-unit>
        <trans-unit id="f4f8b78ea64ed83627d292f81c40574ae35f827f" translate="yes" xml:space="preserve">
          <source>Generic selection is similar to overloading in C++ (where one of several functions is chosen at compile time based on the types of the arguments), except that it makes the selection between arbitrary expressions.</source>
          <target state="translated">Общий выбор подобен перегрузке в Си++(где одна из нескольких функций выбирается во время компиляции на основе типов аргументов),за исключением того,что он делает выбор между произвольными выражениями.</target>
        </trans-unit>
        <trans-unit id="f82dd9e5af6da2aa72552c81bdb59e03bf15b8e1" translate="yes" xml:space="preserve">
          <source>Given an object with</source>
          <target state="translated">Учитывая объект с</target>
        </trans-unit>
        <trans-unit id="c10602e998b8cfe65e56c43becd8d2b538c79d91" translate="yes" xml:space="preserve">
          <source>HP aCC compiler pragmas</source>
          <target state="translated">прагмы компилятора HP aCC</target>
        </trans-unit>
        <trans-unit id="498203d3437361cd8d2965b93c0eb3f8af84971a" translate="yes" xml:space="preserve">
          <source>HUGE_VALF, HUGE_VAL, HUGE_VALL</source>
          <target state="translated">HUGE_VALF,HUGE_VAL,HUGE_VALL</target>
        </trans-unit>
        <trans-unit id="0ff054331f849fe26ab715fa596bf0d6c1b9b49c" translate="yes" xml:space="preserve">
          <source>HUGE_VALFHUGE_VALHUGE_VALL</source>
          <target state="translated">HUGE_VALFHUGE_VALHUGE_VALL</target>
        </trans-unit>
        <trans-unit id="b38181b2101d3ec22f60111fb7da75e6dc9d72e8" translate="yes" xml:space="preserve">
          <source>HUGE_VALL</source>
          <target state="translated">HUGE_VALL</target>
        </trans-unit>
        <trans-unit id="f786495fe9ea368b774d5544cbb82c7ec30035c0" translate="yes" xml:space="preserve">
          <source>Header name preprocessing tokens are only formed within a &lt;code&gt;#include&lt;/code&gt; directive and in implementation-defined locations within a &lt;code&gt;#pragma&lt;/code&gt; directive.</source>
          <target state="translated">Токены предварительной обработки имени заголовка формируются только в директиве &lt;code&gt;#include&lt;/code&gt; и в определенных местах реализации в директиве &lt;code&gt;#pragma&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8559345b43a025d30613b072a1f7f0d697cc5027" translate="yes" xml:space="preserve">
          <source>Hexadecimal escape sequences have no length limit and terminate at the first character that is not a valid hexadecimal digit. If the value represented by a single hexadecimal escape sequence does not fit the range of values represented by the character type used in this string literal or character constant (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, or &lt;code&gt;wchar_t&lt;/code&gt;), the result is unspecified.</source>
          <target state="translated">Шестнадцатеричные escape-последовательности не имеют ограничения по длине и оканчиваются на первый символ, который не является допустимой шестнадцатеричной цифрой. Если значение, представленное одной шестнадцатеричной escape-последовательностью, не соответствует диапазону значений, представленных символьным типом, используемым в этом строковом литерале или символьной константе ( &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;char16_t&lt;/code&gt; , &lt;code&gt;char32_t&lt;/code&gt; или &lt;code&gt;wchar_t&lt;/code&gt; ), результат не указан.</target>
        </trans-unit>
        <trans-unit id="a9323be5c110b5aa5f2d228930349fa184bfe2fd" translate="yes" xml:space="preserve">
          <source>History of C</source>
          <target state="translated">История города С</target>
        </trans-unit>
        <trans-unit id="96e08c08807a48c02c8a25b2e222a3aa87859604" translate="yes" xml:space="preserve">
          <source>Hour, minute, second</source>
          <target state="translated">Час,минута,секунда</target>
        </trans-unit>
        <trans-unit id="f15adf7bfe70ef5a75b3b7c3331bdfc66a4acaf1" translate="yes" xml:space="preserve">
          <source>However, when an initializer begins with a left open brace, its</source>
          <target state="translated">Однако,когда инициализатор начинается с левой открытой скобки,его</target>
        </trans-unit>
        <trans-unit id="dff18122d5fc3679e0217a5ccca9f25c585e46ac" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="translated">Гиперболический косинус представляет собой целую функцию в комплексной плоскости и не имеет ответвлений. Он периодичен относительно мнимой компоненты, с периодом 2&amp;pi;i.</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">гиперболические функции</target>
        </trans-unit>
        <trans-unit id="a05dc25b96449633c73f65c5aa0e18f13e31788b" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="translated">Гиперболический синус является целой функцией в комплексной плоскости и не имеет ответвлений. Он периодичен относительно мнимой компоненты, с периодом 2&amp;pi;i.</target>
        </trans-unit>
        <trans-unit id="413dc47c587aa42c078941a669410916c5e97bcf" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent is an analytical function on the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period &amp;pi;i, and has poles of the first order along the imaginary line, at coordinates (0, &amp;pi;(1/2 + n)). However no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.</source>
          <target state="translated">Гиперболический тангенс является аналитической функцией на комплексной плоскости и не имеет разрезов ветвей. Он периодичен относительно мнимой компоненты с периодом &amp;pi;i и имеет полюсы первого порядка вдоль мнимой линии в координатах (0, &amp;pi; (1/2 + n)). Однако никакое общее представление с плавающей точкой не может точно представить &amp;pi; / 2, поэтому нет значения аргумента, для которого возникает ошибка полюса.</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="b35c4b7a4582b768650003b92551d670cc72067a" translate="yes" xml:space="preserve">
          <source>I/O streams are objects of type &lt;code&gt;FILE&lt;/code&gt; that can only be accessed and manipulated through pointers of type &lt;code&gt;FILE*&lt;/code&gt; (Note: while it may be possible to create a local object of type &lt;code&gt;FILE&lt;/code&gt; by dereferencing and copying a valid &lt;code&gt;FILE*&lt;/code&gt;, using the address of such copy in the I/O functions is undefined behavior). Each stream is associated with an external physical device (file, standard input stream, printer, serial port, etc).</source>
          <target state="translated">Потоки ввода / вывода - это объекты типа &lt;code&gt;FILE&lt;/code&gt; , доступ к которым можно получить и манипулировать только через указатели типа &lt;code&gt;FILE*&lt;/code&gt; (Примечание: хотя возможно создание локального объекта типа &lt;code&gt;FILE&lt;/code&gt; путем разыменования и копирования действительного &lt;code&gt;FILE*&lt;/code&gt; с использованием адреса такой копии в функциях ввода / вывода является неопределенным поведением). Каждый поток связан с внешним физическим устройством (файл, стандартный поток ввода, принтер, последовательный порт и т. Д.).</target>
        </trans-unit>
        <trans-unit id="c237a26303d9ce6c44278fc659b5347852badd06" translate="yes" xml:space="preserve">
          <source>I/O streams can be used for both unformatted and formatted input and output. They are locale-sensitive and may perform wide/multibyte conversions as necessary. All streams access the same locale object: the one most recently installed with &lt;code&gt;&lt;a href=&quot;locale/setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Потоки ввода / вывода могут использоваться как для неформатированного, так и для форматированного ввода и вывода. Они чувствительны к локали и могут при необходимости выполнять широкое / многобайтовое преобразование. Все потоки обращаются к одному и тому же объекту локали: последний установлен с помощью &lt;code&gt;&lt;a href=&quot;locale/setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03c599d26b9f4c8b751cead1f324b345be4d7ceb" translate="yes" xml:space="preserve">
          <source>IEC 60559 recommends that &lt;code&gt;from&lt;/code&gt; is returned whenever &lt;code&gt;from==to&lt;/code&gt;. These functions return &lt;code&gt;to&lt;/code&gt; instead, which makes the behavior around zero consistent: &lt;code&gt;nextafter(-0.0, +0.0)&lt;/code&gt; returns &lt;code&gt;+0.0&lt;/code&gt; and &lt;code&gt;nextafter(+0.0, -0.0)&lt;/code&gt; returns &lt;code&gt;&amp;ndash;0.0&lt;/code&gt;.</source>
          <target state="translated">IEC 60559 рекомендует &lt;code&gt;from&lt;/code&gt; возвращается всякий раз , когда &lt;code&gt;from==to&lt;/code&gt; . Эти функции возвращают &lt;code&gt;to&lt;/code&gt; вместо этого, что делает поведение вокруг нулевого последовательный: &lt;code&gt;nextafter(-0.0, +0.0)&lt;/code&gt; возвращает &lt;code&gt;+0.0&lt;/code&gt; и &lt;code&gt;nextafter(+0.0, -0.0)&lt;/code&gt; возвращает &lt;code&gt;&amp;ndash;0.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d95a8939f16c4020223847e17e36720cebf2bb9" translate="yes" xml:space="preserve">
          <source>IEEE-754</source>
          <target state="translated">IEEE-754</target>
        </trans-unit>
        <trans-unit id="42d5d0fd7522f477e6c48c8cc234d0d9ab04dea9" translate="yes" xml:space="preserve">
          <source>ILP32</source>
          <target state="translated">ILP32</target>
        </trans-unit>
        <trans-unit id="bb6e7841dba2c83d7f4685d9f749f0a969927ab9" translate="yes" xml:space="preserve">
          <source>INFINITY</source>
          <target state="translated">INFINITY</target>
        </trans-unit>
        <trans-unit id="0c47ba7d876463299943e6f3c404bf80428ff851" translate="yes" xml:space="preserve">
          <source>INT8_CINT16_CINT32_CINT64_C</source>
          <target state="translated">INT8_CINT16_CINT32_CINT64_C</target>
        </trans-unit>
        <trans-unit id="9ea288f9428eb0424cc8044a5b63c8eac0420d9a" translate="yes" xml:space="preserve">
          <source>INT8_MAXINT16_MAXINT32_MAXINT64_MAX</source>
          <target state="translated">INT8_MAXINT16_MAXINT32_MAXINT64_MAX</target>
        </trans-unit>
        <trans-unit id="bc5a628cd596773389eaaf98a83bf94ceac150f9" translate="yes" xml:space="preserve">
          <source>INT8_MININT16_MININT32_MININT64_MIN</source>
          <target state="translated">INT8_MININT16_MININT32_MININT64_MIN</target>
        </trans-unit>
        <trans-unit id="f9102afc9b1d8d90bfec23471f9597ad0cf050e9" translate="yes" xml:space="preserve">
          <source>INTMAX_C</source>
          <target state="translated">INTMAX_C</target>
        </trans-unit>
        <trans-unit id="aefed58e7c3b20f7462bf747350723518bd7f3f5" translate="yes" xml:space="preserve">
          <source>INTMAX_MAX</source>
          <target state="translated">INTMAX_MAX</target>
        </trans-unit>
        <trans-unit id="a349d125102eeb5388d505c737ca6ccb840fc470" translate="yes" xml:space="preserve">
          <source>INTMAX_MIN</source>
          <target state="translated">INTMAX_MIN</target>
        </trans-unit>
        <trans-unit id="a8b82d9c693483b9795a47d286279f7fe077830a" translate="yes" xml:space="preserve">
          <source>INTPTR_MAX</source>
          <target state="translated">INTPTR_MAX</target>
        </trans-unit>
        <trans-unit id="ea1e73a8ba1358e9d441c380ac5a64aadd6313f9" translate="yes" xml:space="preserve">
          <source>INTPTR_MIN</source>
          <target state="translated">INTPTR_MIN</target>
        </trans-unit>
        <trans-unit id="cb3002d9d4b8d1bb4ad6b3fb3f8ee0eb1cd9e1b9" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</source>
          <target state="translated">INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</target>
        </trans-unit>
        <trans-unit id="5c002bd42be6d97da6ee9fd6a8de846f49b7760c" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</source>
          <target state="translated">INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</target>
        </trans-unit>
        <trans-unit id="81b4c2799073b036b71feb59eff38c668d0be8e4" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</source>
          <target state="translated">INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</target>
        </trans-unit>
        <trans-unit id="303ab3b780f2f436597e803172a659d338cb695a" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</source>
          <target state="translated">INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</target>
        </trans-unit>
        <trans-unit id="b7d04a533ba2785a0158159ad98ad6ef6b754b06" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX control characters as Unicode characters U+0000..U+001F, U+007F..U+009F, U+2028, and U+2029 (Unicode classes Cc, Zl, and Zp).</source>
          <target state="translated">ISO 30112 определяет управляющие символы POSIX как символы Юникода U+0000...U+001F,U+007F...U+009F,U+2028 и U+2029 (классы Юникода Cc,Zl и Zp).</target>
        </trans-unit>
        <trans-unit id="fff375c325eb5a33dd2e39fc8434af17d533adb3" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX space characters as Unicode characters U+0009..U+000D, U+0020, U+1680, U+180E, U+2000..U+2006, U+2008..U+200A, U+2028, U+2029, U+205F, and U+3000.</source>
          <target state="translated">ISO 30112 определяет пробельные символы POSIX как символы Юникода U+0009...U+000D,U+0020,U+1680,U+180E,U+2000...U+2006,U+2008...U+200A,U+2028,U+2029,U+205F и U+3000.</target>
        </trans-unit>
        <trans-unit id="06b6ace8ca3f18249e8ba4ea9090c0f34564ce1c" translate="yes" xml:space="preserve">
          <source>Identifier</source>
          <target state="translated">Identifier</target>
        </trans-unit>
        <trans-unit id="5df5db83d291a84e8693ec1784228be5a9d8a9a4" translate="yes" xml:space="preserve">
          <source>Identifiers a, b, f, and g have file scope.</source>
          <target state="translated">Идентификаторы a,b,f и g имеют область действия файла.</target>
        </trans-unit>
        <trans-unit id="2672ebe977d252cfae360252c5fb4f4f69527b64" translate="yes" xml:space="preserve">
          <source>Identifiers can denote the following types of entities:</source>
          <target state="translated">Идентификаторы могут обозначать следующие типы сущностей:</target>
        </trans-unit>
        <trans-unit id="a53835700ea021acf4e404661a96971fd56c8741" translate="yes" xml:space="preserve">
          <source>Identifiers for thread states and errors.</source>
          <target state="translated">Идентификаторы состояния потоков и ошибок.</target>
        </trans-unit>
        <trans-unit id="012e30d5ff7b0eca7096ca0ef0422f1cf1ad5ef5" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;ON&lt;/code&gt;, all floating-point arithmetic operators obey the current floating-point &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;rounding direction&lt;/a&gt; and report floating-point arithmetic errors as specified in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;&lt;code&gt;math_errhandling&lt;/code&gt;&lt;/a&gt; unless part of a &lt;a href=&quot;initialization&quot;&gt;static initializer&lt;/a&gt; (in which case floating-point exceptions are not raised and the rounding mode is to nearest).</source>
          <target state="translated">Если для параметра &lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt; &lt;/a&gt; задано значение &lt;code&gt;ON&lt;/code&gt; , все арифметические операторы с плавающей запятой подчиняются текущему &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;направлению округления с&lt;/a&gt; плавающей запятой и сообщают об арифметических ошибках с плавающей запятой, как указано в &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt; &lt;code&gt;math_errhandling&lt;/code&gt; ,&lt;/a&gt; кроме случаев, когда используется &lt;a href=&quot;initialization&quot;&gt;статический инициализатор&lt;/a&gt; (в этом случае исключения с плавающей запятой являются не поднят и режим округления до ближайшего).</target>
        </trans-unit>
        <trans-unit id="e0287f0c686ba01cad63a0be3dc59fccc6064694" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; is 2 (or a power of 2), the returned value is exact, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; равен 2 (или степени 2), возвращаемое значение является точным, &lt;a href=&quot;../fenv/fe_round&quot;&gt;текущий режим округления&lt;/a&gt; игнорируется</target>
        </trans-unit>
        <trans-unit id="31d86a702dd47847a66399b1dc80f0da0b7cfa5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; is not the appropriate buffer size, &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;&lt;/code&gt; can be used to change it.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; не подходит для размера буфера, для его &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;&lt;/code&gt; можно использовать setvbuf .</target>
        </trans-unit>
        <trans-unit id="89b79b5672025a2dcd4c160d18058bb72dde7976" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NDEBUG&lt;/code&gt; is defined as a macro name at the point in the source code where &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt; is included, then &lt;code&gt;assert&lt;/code&gt; does nothing.</source>
          <target state="translated">Если &lt;code&gt;NDEBUG&lt;/code&gt; определен как имя макроса в той точке исходного кода, в &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt; включен &amp;lt;assert.h&amp;gt; , тогда &lt;code&gt;assert&lt;/code&gt; ничего не делает.</target>
        </trans-unit>
        <trans-unit id="fb4be0b9f283d05e7e78bb3a582406ff9af784e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NDEBUG&lt;/code&gt; is not defined, then &lt;code&gt;assert&lt;/code&gt; checks if its argument (which must have scalar type) compares equal to zero. If it does, &lt;code&gt;assert&lt;/code&gt; outputs implementation-specific diagnostic information on the standard error output and calls &lt;code&gt;&lt;a href=&quot;../program/abort&quot;&gt;abort&lt;/a&gt;()&lt;/code&gt;. The diagnostic information is required to include the text of &lt;code&gt;expression&lt;/code&gt;, as well as the values of the &lt;a href=&quot;../preprocessor/replace&quot;&gt;standard macros&lt;/a&gt;&lt;code&gt;__FILE__&lt;/code&gt;, &lt;code&gt;__LINE__&lt;/code&gt;, and the &lt;a href=&quot;../language/function_definition&quot;&gt;predefined variable&lt;/a&gt;&lt;code&gt;__func__&lt;/code&gt;.(since C99).</source>
          <target state="translated">Если &lt;code&gt;NDEBUG&lt;/code&gt; не определен, тогда &lt;code&gt;assert&lt;/code&gt; проверяет, совпадает ли его аргумент (который должен иметь скалярный тип) с нулем. Если это так, &lt;code&gt;assert&lt;/code&gt; выводит специфическую для реализации диагностическую информацию о стандартном выводе ошибки и вызывает &lt;code&gt;&lt;a href=&quot;../program/abort&quot;&gt;abort&lt;/a&gt;()&lt;/code&gt; . Диагностическая информация должна включать текст &lt;code&gt;expression&lt;/code&gt; , а также значения &lt;a href=&quot;../preprocessor/replace&quot;&gt;стандартных макросов &lt;/a&gt; &lt;code&gt;__FILE__&lt;/code&gt; , &lt;code&gt;__LINE__&lt;/code&gt; и &lt;a href=&quot;../language/function_definition&quot;&gt;предопределенную переменную &lt;/a&gt; &lt;code&gt;__func__&lt;/code&gt; . ( Начиная с C99).</target>
        </trans-unit>
        <trans-unit id="a3db10378a1cc105c0a22a4f2c0f99f5d34c39bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, &amp;plusmn;0 is returned, and &amp;plusmn;&amp;infin; is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен &amp;plusmn; &amp;infin;, возвращается &amp;plusmn; 0, и &amp;plusmn; &amp;infin; сохраняется в &lt;code&gt;*iptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39035be25eaa7a5daa7ee9badf8db195c8f6f1c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, +&amp;infin; is returned</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен &amp;plusmn; &amp;infin;, + &amp;infin; возвращается</target>
        </trans-unit>
        <trans-unit id="dc64028dd5e1343ad289a2a638ecad4eabe7dfc5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен &amp;plusmn; &amp;infin;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается и возвращается значение, определенное реализацией</target>
        </trans-unit>
        <trans-unit id="b2c40c9472f7e29a79351555cd2feb2e0f4bf69b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, and an unspecified value is stored in &lt;code&gt;*&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен &amp;plusmn; &amp;infin;, он возвращается, и неопределенное значение сохраняется в &lt;code&gt;*&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2926296a9d3ae122af29b30e2bff2458387535b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, unmodified</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен &amp;plusmn; &amp;infin;, он возвращается без изменений</target>
        </trans-unit>
        <trans-unit id="dcb585953813ddfd53495aac0adc0c6028656a9c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, &amp;plusmn;&amp;infin;, or NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равно &amp;plusmn; 0, &amp;plusmn; &amp;infin; или NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается.</target>
        </trans-unit>
        <trans-unit id="52141cb14b3833d9514aee0d11bc6396482017af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, &amp;plusmn;0 is returned, and &amp;plusmn;0 is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен &amp;plusmn; 0, возвращается &amp;plusmn; 0, а значение &amp;plusmn; 0 сохраняется в &lt;code&gt;*iptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97a7ce4796bb66aaa2d696b735ad8ca62a0d506b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен &amp;plusmn; 0, возвращается -&amp;infin; и значение &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; повышается.</target>
        </trans-unit>
        <trans-unit id="4c925fdb14d37c5af0412f43389d6420fcbebc31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен &amp;plusmn; 0, он возвращается без изменений</target>
        </trans-unit>
        <trans-unit id="5dc17fdaf08e8797e56099a677398b82af4d0180" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified, and &lt;code&gt;0&lt;/code&gt; is stored in &lt;code&gt;*&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен &amp;plusmn; 0, он возвращается без изменений, а &lt;code&gt;0&lt;/code&gt; сохраняется в &lt;code&gt;*&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f109ac78880a8e0fd5ca3edc07d2d1bf947af61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается, и возвращается значение, определенное реализацией</target>
        </trans-unit>
        <trans-unit id="40f86add69087dfb700cacff3b1846927488c73a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен NaN, NaN возвращается</target>
        </trans-unit>
        <trans-unit id="ae52bceff3b02f7b3ee9b3972972ded1fb86990a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned, and NaN is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен NaN, возвращается NaN, а NaN сохраняется в &lt;code&gt;*iptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1cb41b693b54309d8cd057ea727f5c2a44b70a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned, and an unspecified value is stored in &lt;code&gt;*&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен NaN, возвращается NaN, а неопределенное значение сохраняется в &lt;code&gt;*&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b0e2c569c27377f09ed2aa7f3f01ddd8ab82ed0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен NaN, NaN возвращается.</target>
        </trans-unit>
        <trans-unit id="b47b8c75e53c96b45595a288fa682cfb71c94c2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a NaN, &lt;code&gt;FP_ILOGBNAN&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; является NaN, возвращается &lt;code&gt;FP_ILOGBNAN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85329a9a82100a9c1a2cd29c7eed89e508e44736" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a natural number, &lt;code&gt;lgamma(arg)&lt;/code&gt; is the logarithm of the factorial of &lt;code&gt;arg-1&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; - натуральное число, &lt;code&gt;lgamma(arg)&lt;/code&gt; - логарифм факториала &lt;code&gt;arg-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbec8bd424bd1d802c57ea8f26b821ec16976114" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a natural number, &lt;code&gt;tgamma(arg)&lt;/code&gt; is the factorial of &lt;code&gt;arg-1&lt;/code&gt;. Many implementations calculate the exact integer-domain factorial if the argument is a sufficiently small integer.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; натуральное число, &lt;code&gt;tgamma(arg)&lt;/code&gt; - факториал &lt;code&gt;arg-1&lt;/code&gt; . Многие реализации вычисляют точный факториал целочисленной области, если аргумент является достаточно маленьким целым числом.</target>
        </trans-unit>
        <trans-unit id="b16a546b06c9d95257ded195bd4035d23e04e06b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is infinite, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; бесконечно, возвращается &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e168df92098d4104c20f40ff2c56e9cb3e43970" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is not a floating-point number, the behavior is unspecified.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; не является числом с плавающей точкой, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="32ff62b6889ca3482df7c46498edc6f6674221b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is not zero, infinite, or NaN, the value returned is exactly equivalent to &lt;code&gt;(int)&lt;a href=&quot;logb&quot;&gt;logb&lt;/a&gt;(arg)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; не ноль, бесконечность или NaN, возвращаемое значение точно эквивалентно &lt;code&gt;(int)&lt;a href=&quot;logb&quot;&gt;logb&lt;/a&gt;(arg)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="210d2992bbf2bb7d542ddc01b1a18747c781302a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero or is an integer less than zero, a pole error may occur.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равно нулю или целое число меньше нуля, может возникнуть ошибка полюса.</target>
        </trans-unit>
        <trans-unit id="05dafa4d596b7b6f157f2afaee02072f8d977259" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero or is an integer less than zero, a pole error or a domain error may occur.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равно нулю или целое число меньше нуля, может возникнуть ошибка полюса или ошибка домена.</target>
        </trans-unit>
        <trans-unit id="c39db051a1df2187c97bcf9b3a8feca13bc7aae3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero, &lt;code&gt;FP_ILOGB0&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен нулю, возвращается &lt;code&gt;FP_ILOGB0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4481c06a081e138b96375d6a39a2024c3db3720a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero, returns zero and stores zero in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен нулю, возвращает ноль и сохраняет ноль в &lt;code&gt;*exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc2ce27f23e51347316eec1df499f96102e63b30" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is &lt;code&gt;TIME_UTC&lt;/code&gt;, then.</source>
          <target state="translated">Если &lt;code&gt;base&lt;/code&gt; является &lt;code&gt;TIME_UTC&lt;/code&gt; , то.</target>
        </trans-unit>
        <trans-unit id="88b08a2ca4f793bfaeabfcb3e0137c1037ec815c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is finite and negative and &lt;code&gt;exponent&lt;/code&gt; is finite and non-integer, a domain error occurs and a range error may occur.</source>
          <target state="translated">Если &lt;code&gt;base&lt;/code&gt; является конечным и отрицательным, а &lt;code&gt;exponent&lt;/code&gt; конечным и нецелым, возникает ошибка домена и ошибка диапазона.</target>
        </trans-unit>
        <trans-unit id="bc0d6604e049ef0469b7407b8700ef87f4c2b1cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is zero and &lt;code&gt;exponent&lt;/code&gt; is negative, a domain error or a pole error may occur.</source>
          <target state="translated">Если &lt;code&gt;base&lt;/code&gt; равно нулю, а &lt;code&gt;exponent&lt;/code&gt; отрицателен, может возникнуть ошибка домена или ошибка полюса.</target>
        </trans-unit>
        <trans-unit id="fe1f81b4cf62dfd261b43cdf1631e95df10c22e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is zero and &lt;code&gt;exponent&lt;/code&gt; is zero, a domain error may occur.</source>
          <target state="translated">Если &lt;code&gt;base&lt;/code&gt; равно нулю, а &lt;code&gt;exponent&lt;/code&gt; равен нулю, может возникнуть ошибка домена.</target>
        </trans-unit>
        <trans-unit id="701f5d02367a24c659b0e907a89da5f3ee588ad7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is a null pointer, resizes the internal buffer to &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;buffer&lt;/code&gt; является нулевым указателем, &lt;code&gt;size&lt;/code&gt; внутреннего буфера изменяется до размера .</target>
        </trans-unit>
        <trans-unit id="a41f3aeda56216d76a85bf549142c566dd8345e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is not a null pointer, instructs the stream to use the user-provided buffer of size &lt;code&gt;size&lt;/code&gt; beginning at &lt;code&gt;buffer&lt;/code&gt;. The stream must be closed (with &lt;code&gt;&lt;a href=&quot;fclose&quot;&gt;fclose&lt;/a&gt;&lt;/code&gt;) before the &lt;a href=&quot;../language/lifetime&quot;&gt;lifetime&lt;/a&gt; of the array pointed to by &lt;code&gt;buffer&lt;/code&gt; ends. The contents of the array after a successful call to &lt;code&gt;setvbuf&lt;/code&gt; are indeterminate and any attempt to use it is undefined behavior.</source>
          <target state="translated">Если &lt;code&gt;buffer&lt;/code&gt; не является нулевым указателем, указывает потоку использовать предоставленный пользователем буфер с размером &lt;code&gt;size&lt;/code&gt; начиная с &lt;code&gt;buffer&lt;/code&gt; . Поток должен быть закрыт (с помощью &lt;code&gt;&lt;a href=&quot;fclose&quot;&gt;fclose&lt;/a&gt;&lt;/code&gt; ) до окончания &lt;a href=&quot;../language/lifetime&quot;&gt;срока&lt;/a&gt; действия массива, на который указывает &lt;code&gt;buffer&lt;/code&gt; . Содержимое массива после успешного вызова &lt;code&gt;setvbuf&lt;/code&gt; является неопределенным, и любая попытка использовать его является неопределенным поведением.</target>
        </trans-unit>
        <trans-unit id="8933681edb25a289169d034aa0994de4b7ca1688" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is not null, equivalent to &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;(stream, buffer, &lt;a href=&quot;../io&quot;&gt;_IOFBF&lt;/a&gt;, &lt;a href=&quot;../io&quot;&gt;BUFSIZ&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;buffer&lt;/code&gt; не нулевой, эквивалентно &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;(stream, buffer, &lt;a href=&quot;../io&quot;&gt;_IOFBF&lt;/a&gt;, &lt;a href=&quot;../io&quot;&gt;BUFSIZ&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bace9448279b193681afb8262a65ef1da2317ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is null, equivalent to &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;(stream, &lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;, &lt;a href=&quot;../io&quot;&gt;_IONBF&lt;/a&gt;, 0)&lt;/code&gt;, which turns off buffering.</source>
          <target state="translated">Если значение &lt;code&gt;buffer&lt;/code&gt; равно нулю, эквивалентно &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;(stream, &lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;, &lt;a href=&quot;../io&quot;&gt;_IONBF&lt;/a&gt;, 0)&lt;/code&gt; , который отключает буферизацию.</target>
        </trans-unit>
        <trans-unit id="4dd6d32ffac07b48320fad08007c3cbc378f1ccf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c16&lt;/code&gt; is not the final code unit in a 16-bit representation of a wide character, it does not write to the array pointed to by &lt;code&gt;s&lt;/code&gt;, only &lt;code&gt;*ps&lt;/code&gt; is updated.</source>
          <target state="translated">Если &lt;code&gt;c16&lt;/code&gt; не является конечной единицей кода в 16-битном представлении широкого символа, он не записывает в массив, на который указывает &lt;code&gt;s&lt;/code&gt; , обновляется только &lt;code&gt;*ps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cd0616388c6486a36bee07efdbd316f0b1b2c96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c16&lt;/code&gt; is the null wide character &lt;code&gt;u'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">Если &lt;code&gt;c16&lt;/code&gt; является широким нулевым символом &lt;code&gt;u'\0'&lt;/code&gt; , сохраняется нулевой байт, которому предшествует любая последовательность сдвигов, необходимая для восстановления начального состояния сдвига, а параметр состояния преобразования &lt;code&gt;*ps&lt;/code&gt; обновляется для представления начального состояния сдвига.</target>
        </trans-unit>
        <trans-unit id="cee38660c6cd74cd32407f813278c336fe952e78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c32&lt;/code&gt; is the null wide character &lt;code&gt;U'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">Если &lt;code&gt;c32&lt;/code&gt; является широким нулевым символом &lt;code&gt;U'\0'&lt;/code&gt; , сохраняется нулевой байт, которому предшествует любая последовательность сдвигов, необходимая для восстановления начального состояния сдвига, а параметр &lt;code&gt;*ps&lt;/code&gt; состояния преобразования обновляется для представления начального состояния сдвига.</target>
        </trans-unit>
        <trans-unit id="b61b6f5b84317e677153362beb836a78c61619c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; does not equal &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, pushes the character &lt;code&gt;ch&lt;/code&gt; (reinterpreted as &lt;code&gt;unsigned char&lt;/code&gt;) into the input buffer associated with the stream &lt;code&gt;stream&lt;/code&gt; in such a manner that subsequent read operation from &lt;code&gt;stream&lt;/code&gt; will retrieve that character. The external device associated with the stream is not modified.</source>
          <target state="translated">Если &lt;code&gt;ch&lt;/code&gt; не равен &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; , вставляет символ &lt;code&gt;ch&lt;/code&gt; (повторно интерпретированный как &lt;code&gt;unsigned char&lt;/code&gt; ) во входной буфер, связанный с потоком &lt;code&gt;stream&lt;/code&gt; таким образом, что последующая операция чтения из &lt;code&gt;stream&lt;/code&gt; извлечет этот символ. Внешнее устройство, связанное с потоком, не изменяется.</target>
        </trans-unit>
        <trans-unit id="a57c34ec42bd9be0ad89adc1a923520e0077144a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; does not equal &lt;code&gt;WEOF&lt;/code&gt;, pushes the wide character &lt;code&gt;ch&lt;/code&gt; into the input buffer associated with the stream &lt;code&gt;stream&lt;/code&gt; in such a manner that subsequent read operation from &lt;code&gt;stream&lt;/code&gt; will retrieve that wide character. The external device associated with the stream is not modified.</source>
          <target state="translated">Если &lt;code&gt;ch&lt;/code&gt; не равен &lt;code&gt;WEOF&lt;/code&gt; , вставляет широкий символ &lt;code&gt;ch&lt;/code&gt; во входной буфер, связанный с потоком &lt;code&gt;stream&lt;/code&gt; таким образом, что последующая операция чтения из &lt;code&gt;stream&lt;/code&gt; будет извлекать этот широкий символ. Внешнее устройство, связанное с потоком, не изменяется.</target>
        </trans-unit>
        <trans-unit id="c14f42bfaf455713c73850a9b738e4d8564279fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, the operation fails and the stream is not affected.</source>
          <target state="translated">Если &lt;code&gt;ch&lt;/code&gt; равно &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; , операция завершается неудачно и поток не затрагивается.</target>
        </trans-unit>
        <trans-unit id="6a114914a7e8a31a9eee7e4f7ac5bc1b503807f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; equals &lt;code&gt;WEOF&lt;/code&gt;, the operation fails and the stream is not affected.</source>
          <target state="translated">Если &lt;code&gt;ch&lt;/code&gt; равно &lt;code&gt;WEOF&lt;/code&gt; , операция завершается ошибкой и поток не затрагивается.</target>
        </trans-unit>
        <trans-unit id="4b6ed2df20ac94130f4229b9b625f3c25374a619" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;comp&lt;/code&gt; indicates two elements as equivalent, their order in the resulting sorted array is unspecified.</source>
          <target state="translated">Если &lt;code&gt;comp&lt;/code&gt; указывает два элемента как эквивалентные, их порядок в результирующем отсортированном массиве не указан.</target>
        </trans-unit>
        <trans-unit id="18daaf9d57908b8b11d5a5ce74779de8f547638e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is &lt;code&gt;​0​&lt;/code&gt;, then &lt;code&gt;dest&lt;/code&gt; is allowed to be a null pointer.</source>
          <target state="translated">Если &lt;code&gt;count&lt;/code&gt; является &lt;code&gt;​0​&lt;/code&gt; , то &lt;code&gt;dest&lt;/code&gt; разрешено быть указателем NULL.</target>
        </trans-unit>
        <trans-unit id="7c4f638ff595d6b56790ce243921af64efe6390b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is reached before the entire array &lt;code&gt;src&lt;/code&gt; was copied, the resulting character array is not null-terminated.</source>
          <target state="translated">Если &lt;code&gt;count&lt;/code&gt; достигнуто до того, как весь массив &lt;code&gt;src&lt;/code&gt; был скопирован, результирующий массив символов не заканчивается нулем.</target>
        </trans-unit>
        <trans-unit id="3896321b9a85e601977b36e1c20e47272d800cfd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is reached before the entire string &lt;code&gt;src&lt;/code&gt; was copied, the resulting wide character array is not null-terminated.</source>
          <target state="translated">Если &lt;code&gt;count&lt;/code&gt; достигнуто до того, как была скопирована вся строка &lt;code&gt;src&lt;/code&gt; , результирующий массив широких символов не заканчивается нулем.</target>
        </trans-unit>
        <trans-unit id="3f2e6aaeeb8e09e4e7d2914ab4ee68da289d48f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, the function does nothing.</source>
          <target state="translated">Если &lt;code&gt;count&lt;/code&gt; равен нулю, функция ничего не делает.</target>
        </trans-unit>
        <trans-unit id="7ad8eda07b3297819cd8064cc3589079cc052fd8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, the function returns a null pointer.</source>
          <target state="translated">Если &lt;code&gt;count&lt;/code&gt; равен нулю, функция возвращает нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="0a5b5a3d18a2f383eebd17f1e0c87ef7de0762b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;destructor&lt;/code&gt; is not a null pointer, then also associates the destructor which is called when the storage is released by &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt; (but not by &lt;code&gt;&lt;a href=&quot;tss_delete&quot;&gt;tss_delete&lt;/a&gt;&lt;/code&gt; and not at program termination by &lt;code&gt;&lt;a href=&quot;../program/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Если &lt;code&gt;destructor&lt;/code&gt; не является нулевым указателем, то также связывает деструктор, который вызывается, когда память освобождается &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt; (но не &lt;code&gt;&lt;a href=&quot;tss_delete&quot;&gt;tss_delete&lt;/a&gt;&lt;/code&gt; и не при завершении программы при &lt;code&gt;&lt;a href=&quot;../program/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="007bad278d6b4bc6d719829636a93a4a9c5a31b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt;, an implementation-defined status indicating successful termination is returned to the host environment. If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt;, an implementation-defined status, indicating</source>
          <target state="translated">Если &lt;code&gt;exit_code&lt;/code&gt; равен &lt;code&gt;0&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt; , определенный статус реализации, указывающий на успешное завершение, возвращается в хост-среду. Если &lt;code&gt;exit_code&lt;/code&gt; - &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt; , статус, определенный реализацией, указывающий</target>
        </trans-unit>
        <trans-unit id="dd356ac95b78ee8d3316f54756261230b7ae7603" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exp&lt;/code&gt; is 0, then &lt;code&gt;arg&lt;/code&gt; is returned, unmodified</source>
          <target state="translated">Если &lt;code&gt;exp&lt;/code&gt; равен 0, то &lt;code&gt;arg&lt;/code&gt; возвращается без изменений</target>
        </trans-unit>
        <trans-unit id="aa8dc7735d619a4734d97c476943c7b150c788b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;goto&lt;/code&gt; leaves the scope of a VLA, it is deallocated (and may be reallocated if its initialization is executed again):</source>
          <target state="translated">Если &lt;code&gt;goto&lt;/code&gt; покидает область действия VLA, он освобождается (и может быть перераспределен, если его инициализация выполняется снова):</target>
        </trans-unit>
        <trans-unit id="7f139378ae3c47e672c41f256a64675e51a89c67" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ignore_handler_s&lt;/code&gt; is used as a the runtime constraints handler, the violations may be detected by examining the results of the bounds-checked function calls, which may be different for different functions (non-zero &lt;code&gt;errno_t&lt;/code&gt;, null character written to the first byte of the output string, etc).</source>
          <target state="translated">Если &lt;code&gt;ignore_handler_s&lt;/code&gt; используется в качестве обработчика ограничений времени выполнения, нарушения могут быть обнаружены путем изучения результатов вызовов функций с проверкой границ, которые могут различаться для разных функций (ненулевой &lt;code&gt;errno_t&lt;/code&gt; , нулевой символ, записанный в первый байт выходная строка и т. д.).</target>
        </trans-unit>
        <trans-unit id="8220b5231500449270383f2d363e2887e1748889" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;int&lt;/code&gt; can represent the entire range of values of the original type (or the range of values of the original bit field), the value is converted to type &lt;code&gt;int&lt;/code&gt;. Otherwise the value is converted to &lt;code&gt;unsigned int&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;int&lt;/code&gt; может представлять весь диапазон значений исходного типа (или диапазон значений исходного битового поля), значение преобразуется в тип &lt;code&gt;int&lt;/code&gt; . В противном случае значение преобразуется в &lt;code&gt;unsigned int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d1622661fe017f321ee25a4e9cf6aa32ff070ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;islower&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, it is guaranteed that &lt;code&gt;&lt;a href=&quot;iscntrl&quot;&gt;iscntrl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;isdigit&quot;&gt;isdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ispunct&quot;&gt;ispunct&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;isspace&quot;&gt;isspace&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;false&lt;/code&gt; for the same character in the same C locale.</source>
          <target state="translated">Если &lt;code&gt;islower&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , это гарантирует , что &lt;code&gt;&lt;a href=&quot;iscntrl&quot;&gt;iscntrl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;isdigit&quot;&gt;isdigit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ispunct&quot;&gt;ispunct&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;isspace&quot;&gt;isspace&lt;/a&gt;&lt;/code&gt; возвращение &lt;code&gt;false&lt;/code&gt; для того же символа в том же C локали.</target>
        </trans-unit>
        <trans-unit id="228f41e20ec18c0190146297fd816d5d17c54d3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isupper&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, it is guaranteed that &lt;code&gt;&lt;a href=&quot;iscntrl&quot;&gt;iscntrl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;isdigit&quot;&gt;isdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ispunct&quot;&gt;ispunct&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;isspace&quot;&gt;isspace&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;false&lt;/code&gt; for the same character in the same C locale.</source>
          <target state="translated">Если &lt;code&gt;isupper&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , это гарантирует , что &lt;code&gt;&lt;a href=&quot;iscntrl&quot;&gt;iscntrl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;isdigit&quot;&gt;isdigit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ispunct&quot;&gt;ispunct&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;isspace&quot;&gt;isspace&lt;/a&gt;&lt;/code&gt; возвращение &lt;code&gt;false&lt;/code&gt; для того же символа в том же C локали.</target>
        </trans-unit>
        <trans-unit id="d629e4399641b9530158823e61e45ef4cbd7a6cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mode &amp;gt; 0&lt;/code&gt;, attempts to make &lt;code&gt;stream&lt;/code&gt; wide-oriented. If &lt;code&gt;mode &amp;lt; 0&lt;/code&gt;, attempts to make &lt;code&gt;stream&lt;/code&gt; byte-oriented. If &lt;code&gt;mode==0&lt;/code&gt;, only queries the current orientation of the stream.</source>
          <target state="translated">Если &lt;code&gt;mode &amp;gt; 0&lt;/code&gt; , попытка сделать &lt;code&gt;stream&lt;/code&gt; широко ориентированным. Если &lt;code&gt;mode &amp;lt; 0&lt;/code&gt; , пытается сделать &lt;code&gt;stream&lt;/code&gt; ориентированным на байты. Если &lt;code&gt;mode==0&lt;/code&gt; , запрашивает только текущую ориентацию потока.</target>
        </trans-unit>
        <trans-unit id="bf95be7cd7ebf5692c3135c92a75c10543f6e749" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_filename&lt;/code&gt; exists, the behavior is implementation-defined.</source>
          <target state="translated">Если &lt;code&gt;new_filename&lt;/code&gt; существует, поведение определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="1b3b81128b53cdb9103f95cb1f65dbf81829d30a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned (in which case the old memory block may or may not be freed), or some non-null pointer may be returned that may not be used to access storage).</source>
          <target state="translated">Если &lt;code&gt;new_size&lt;/code&gt; равен нулю, поведение определяется реализацией (нулевой указатель может быть возвращен (в этом случае старый блок памяти может или не может быть освобожден), или может быть возвращен некоторый ненулевой указатель, который может не использоваться для доступа к хранилищу) ,</target>
        </trans-unit>
        <trans-unit id="c2592ff70a55671e630f52a0701fe807ca7a4a63" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parmN&lt;/code&gt; is declared with &lt;code&gt;register&lt;/code&gt; storage class specifier, with an array type, with a function type, or with a type not compatible with the type that results from default argument promotions, the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;parmN&lt;/code&gt; объявлено со спецификатором класса хранилища &lt;code&gt;register&lt;/code&gt; , с типом массива, с типом функции или с типом, несовместимым с типом, который является результатом продвижения аргумента по умолчанию, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="44d20c46f9c198ea9c123c08f055544cf1af5b22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ps&lt;/code&gt; is not a null pointer, the &lt;code&gt;mbsinit&lt;/code&gt; function determines whether the pointed-to &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; object describes the initial conversion state.</source>
          <target state="translated">Если &lt;code&gt;ps&lt;/code&gt; не является нулевым указателем, функция &lt;code&gt;mbsinit&lt;/code&gt; определяет, описывает &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; объект - указатель mbstate_t начальное состояние преобразования.</target>
        </trans-unit>
        <trans-unit id="3e4c54f508180ce2bca52d72bedefa0048c957d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ptr&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the behavior is the same as calling &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;(&lt;code&gt;new_size&lt;/code&gt;).</source>
          <target state="translated">Если &lt;code&gt;ptr&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , поведение аналогично вызову &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;new_size&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="75ce63992e734876e2a939cc380b004ef361f5a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the function does nothing.</source>
          <target state="translated">Если &lt;code&gt;ptr&lt;/code&gt; - нулевой указатель, функция ничего не делает.</target>
        </trans-unit>
        <trans-unit id="775fd3976f21369f6410f6f3d50cc92d417bb684" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rand()&lt;/code&gt; is used before any calls to &lt;code&gt;srand()&lt;/code&gt;, &lt;code&gt;rand()&lt;/code&gt; behaves as if it was seeded with &lt;code&gt;srand(1)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;rand()&lt;/code&gt; используется перед любыми вызовами &lt;code&gt;srand()&lt;/code&gt; , &lt;code&gt;rand()&lt;/code&gt; ведет себя так, как если бы он был &lt;code&gt;srand(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16def2206ddfe3e5010ae4e26c38ffb1e3b7ca4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;res&lt;/code&gt; is not a null pointer, the result code of the thread is put to the location pointed to by &lt;code&gt;res&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;res&lt;/code&gt; не является нулевым указателем, результирующий код потока помещается в местоположение, на которое указывает &lt;code&gt;res&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1972341d22f77196bc1af118f58697bce937d0f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets its internal conversion state to represent the initial shift state and returns &lt;code&gt;​0​&lt;/code&gt; if the current multibyte encoding is not state-dependent (does not use shift sequences) or a non-zero value if the current multibyte encoding is state-dependent (uses shift sequences).</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; является указателем NULL, сбрасывает его внутреннее состояние преобразования для представления исходного состояния сдвига и возвращает &lt;code&gt;​0​&lt;/code&gt; , если текущая кодировка многобайтовой не зависящее от состояния (не использует сдвиг последовательностей) или значение , отличные от нуля , если ток многобайтового кодирование зависит от состояния (использует сдвиговые последовательности).</target>
        </trans-unit>
        <trans-unit id="8491ba73b16514468214be4e5a74445c09461000" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets the global conversion state and determined whether shift sequences are used.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; является нулевым указателем, сбрасывает состояние глобального преобразования и определяет, используются ли последовательности сдвига.</target>
        </trans-unit>
        <trans-unit id="c39632bb99f5cb18b879a3b49462f93b75999d15" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets the global conversion state and determines whether shift sequences are used.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; является нулевым указателем, сбрасывает состояние глобального преобразования и определяет, используются ли последовательности сдвига.</target>
        </trans-unit>
        <trans-unit id="22997fcdc6a5389460254717d711c2bcf3fcf982" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;c16rtomb(buf, u'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; является нулевым указателем, вызов эквивалентен &lt;code&gt;c16rtomb(buf, u'\0', ps)&lt;/code&gt; для некоторого внутреннего буфера &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b392d0883d44d42834c77d825af0cdb02a8bba76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;c32rtomb(buf, U'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; является нулевым указателем, вызов эквивалентен &lt;code&gt;c32rtomb(buf, U'\0', ps)&lt;/code&gt; для некоторого внутреннего буфера &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9936b790fa012acb444bd08bba8ed35bc9704d67" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;wcrtomb(buf, L'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; является нулевым указателем, вызов эквивалентен &lt;code&gt;wcrtomb(buf, L'\0', ps)&lt;/code&gt; для некоторого внутреннего буфера &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="581dbdb5a92a86f454eccb897e8676bace822faa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc16&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;mbrtoc16(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; является нулевым указателем, значения &lt;code&gt;n&lt;/code&gt; и &lt;code&gt;pc16&lt;/code&gt; игнорируются, и вызов эквивалентен &lt;code&gt;mbrtoc16(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3107e31c74f5584cf473c16caa6df8b08a9926d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc32&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;mbrtoc32(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; - пустой указатель, значения &lt;code&gt;n&lt;/code&gt; и &lt;code&gt;pc32&lt;/code&gt; игнорируются, и вызов эквивалентен &lt;code&gt;mbrtoc32(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eebec10c747613d7bb1cfc16cb61d08d39558b92" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pwc&lt;/code&gt; are ignored and call is equivalent to &lt;code&gt;mbrtowc(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; - нулевой указатель, значения &lt;code&gt;n&lt;/code&gt; и &lt;code&gt;pwc&lt;/code&gt; игнорируются, а вызов эквивалентен &lt;code&gt;mbrtowc(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c87ab8512786d6dbdf059aba7190daa196aa4acb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, this function resets the global conversion state and determines whether shift sequences are used.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; является нулевым указателем, эта функция сбрасывает состояние глобального преобразования и определяет, используются ли последовательности сдвига.</target>
        </trans-unit>
        <trans-unit id="387220b12d5b9da678e75cc38f39c0d62fd87341" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer and &lt;code&gt;c16&lt;/code&gt; is the last 16-bit code unit in a valid variable-length encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; не является нулевым указателем, а &lt;code&gt;c16&lt;/code&gt; является последней 16-битной кодовой единицей в допустимом кодировании с переменной длиной кодовой точки, функция определяет число байтов, необходимое для хранения многобайтового символьного представления этой кодовой точки (включая любые сдвиг последовательностей и с учетом текущего состояния многобайтового преобразования &lt;code&gt;*ps&lt;/code&gt; ) и сохраняет представление многобайтовых символов в массиве символов, на первый элемент которого указывает &lt;code&gt;s&lt;/code&gt; , при необходимости обновляя &lt;code&gt;*ps&lt;/code&gt; . В большинстве &lt;code&gt;MB_CUR_MAX&lt;/code&gt; байт можно записать с помощью этой функции.</target>
        </trans-unit>
        <trans-unit id="16a04e8a10e56b364fb1a793bc4d4d83c9dcfc50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding 16-bit wide character and stores it in &lt;code&gt;*pc16&lt;/code&gt; (if &lt;code&gt;pc16&lt;/code&gt; is not null).</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; не является нулевым указателем, проверяет не более &lt;code&gt;n&lt;/code&gt; байтов многобайтовой символьной строки, начиная с байта, на который указывает &lt;code&gt;s&lt;/code&gt; , чтобы определить количество байтов, необходимое для завершения следующего многобайтового символа (включая любые последовательности сдвига, и принимая во внимание текущее состояние многобайтового преобразования &lt;code&gt;*ps&lt;/code&gt; ). Если функция определяет, что следующий многобайтовый символ в &lt;code&gt;s&lt;/code&gt; является полным и допустимым, преобразует его в соответствующий 16-разрядный широкий символ и сохраняет его в &lt;code&gt;*pc16&lt;/code&gt; (если &lt;code&gt;pc16&lt;/code&gt; не равен нулю).</target>
        </trans-unit>
        <trans-unit id="b0aea06044e65d8d79268c25c358b2052ee0b773" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding 32-bit wide character and stores it in &lt;code&gt;*pc32&lt;/code&gt; (if &lt;code&gt;pc32&lt;/code&gt; is not null).</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; не является нулевым указателем, проверяет не более &lt;code&gt;n&lt;/code&gt; байтов многобайтовой символьной строки, начиная с байта, на который указывает &lt;code&gt;s&lt;/code&gt; , чтобы определить количество байтов, необходимое для завершения следующего многобайтового символа (включая любые последовательности сдвига, и принимая во внимание текущее состояние многобайтового преобразования &lt;code&gt;*ps&lt;/code&gt; ). Если функция определяет, что следующий многобайтовый символ в &lt;code&gt;s&lt;/code&gt; является полным и допустимым, преобразует его в соответствующий 32-разрядный широкий символ и сохраняет его в &lt;code&gt;*pc32&lt;/code&gt; (если &lt;code&gt;pc32&lt;/code&gt; не равен нулю).</target>
        </trans-unit>
        <trans-unit id="00b1537658058f473db5bc680537ac6616352ddf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding wide character and stores it in &lt;code&gt;*pwc&lt;/code&gt; (if &lt;code&gt;pwc&lt;/code&gt; is not null).</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; не является нулевым указателем, проверяет не более &lt;code&gt;n&lt;/code&gt; байтов многобайтовой символьной строки, начиная с байта, на который указывает &lt;code&gt;s&lt;/code&gt; , чтобы определить количество байтов, необходимое для завершения следующего многобайтового символа (включая любые последовательности сдвига, и принимая во внимание текущее состояние многобайтового преобразования &lt;code&gt;*ps&lt;/code&gt; ). Если функция определяет, что следующий многобайтовый символ в &lt;code&gt;s&lt;/code&gt; является полным и допустимым, преобразует его в соответствующий широкий символ и сохраняет его в &lt;code&gt;*pwc&lt;/code&gt; (если &lt;code&gt;pwc&lt;/code&gt; не равен нулю).</target>
        </trans-unit>
        <trans-unit id="6f4c68687ec93f7e26b9a23cfefd0d3cb05dc64c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, returns the number of bytes that are contained in the multibyte character or &lt;code&gt;-1&lt;/code&gt; if the first bytes pointed to by &lt;code&gt;s&lt;/code&gt; do not form a valid multibyte character or &lt;code&gt;​0​&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; is pointing at the null charcter &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; не является указателем NULL, возвращает количество байтов, которые содержатся в многобайтовый или &lt;code&gt;-1&lt;/code&gt; , если первый байт указывает &lt;code&gt;s&lt;/code&gt; не образуют допустимый символ многобайтовую или &lt;code&gt;​0​&lt;/code&gt; , если &lt;code&gt;s&lt;/code&gt; указывает на нулевой charcter &lt;code&gt;'\0'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d6df3a6410ecce9d2acc8ffd84bf56f540ac991" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of &lt;code&gt;c32&lt;/code&gt; (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; не является нулевым указателем, функция определяет количество байтов, необходимое для хранения многобайтового символьного представления &lt;code&gt;c32&lt;/code&gt; (включая любые последовательности сдвига и с учетом текущего состояния многобайтового преобразования &lt;code&gt;*ps&lt;/code&gt; ), и сохраняет многобайтовое символьное представление в массив символов, на первый элемент которого указывает &lt;code&gt;s&lt;/code&gt; , при необходимости обновляя &lt;code&gt;*ps&lt;/code&gt; . В большинстве &lt;code&gt;MB_CUR_MAX&lt;/code&gt; байт можно записать с помощью этой функции.</target>
        </trans-unit>
        <trans-unit id="2906f9cd10055ce52ea5a2e8f571a7dfc437ffba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;set_constraint_handler_s&lt;/code&gt; is never called, the default handler is implementation-defined: it may be &lt;code&gt;abort_handler_s&lt;/code&gt;, &lt;code&gt;ignore_handler_s&lt;/code&gt;, or some other implementation-defined handler.</source>
          <target state="translated">Если &lt;code&gt;set_constraint_handler_s&lt;/code&gt; никогда не вызывается, обработчик по умолчанию определяется реализацией: это может быть &lt;code&gt;abort_handler_s&lt;/code&gt; , &lt;code&gt;ignore_handler_s&lt;/code&gt; или какой-либо другой определяемый реализацией обработчик.</target>
        </trans-unit>
        <trans-unit id="97df7a8676e7983f9c071569882f22876fa4078d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;set_constraint_handler_s&lt;/code&gt; is never called, the default handler is implementation-defined: it may be &lt;code&gt;abort_handler_s&lt;/code&gt;, &lt;code&gt;ignore_handler_s&lt;/code&gt;, or some other implementation-defined handler.  As with all bounds-checked functions, &lt;code&gt;set_constraint_handler_s&lt;/code&gt; and &lt;code&gt;constraint_handler_t&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;set_constraint_handler_s&lt;/code&gt; никогда не вызывается, обработчик по умолчанию определяется реализацией: это может быть &lt;code&gt;abort_handler_s&lt;/code&gt; , &lt;code&gt;ignore_handler_s&lt;/code&gt; или какой-либо другой определяемый реализацией обработчик. Как и во всех проверенных границами функциях, &lt;code&gt;set_constraint_handler_s&lt;/code&gt; и &lt;code&gt;constraint_handler_t&lt;/code&gt; гарантированно будут доступны, только если &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; определен реализацией и если пользователь определяет &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; для целочисленной константы &lt;code&gt;1&lt;/code&gt; перед включением &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7823afdead8eb41af529747e83ce1e0afbe2e6fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setjmp&lt;/code&gt; appears in any other context, the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;setjmp&lt;/code&gt; появляется в любом другом контексте, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="5a6ee964cf02ec47b4f466324fac4fa5368b4c54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage).</source>
          <target state="translated">Если &lt;code&gt;size&lt;/code&gt; равен нулю, поведение определяется реализацией (может быть возвращен нулевой указатель или может быть возвращен некоторый ненулевой указатель, который не может использоваться для доступа к хранилищу).</target>
        </trans-unit>
        <trans-unit id="1fe40c255f79e2b4f905649c83c54e72b4fe88db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage, but has to be passed to &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Если &lt;code&gt;size&lt;/code&gt; равен нулю, поведение определяется реализацией (может быть возвращен нулевой указатель или может быть возвращен некоторый ненулевой указатель, который не может быть использован для доступа к хранилищу, но должен быть передан в &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fece348a8ee3d70f7e3352f3e69bf03a082365cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; is zero, &lt;code&gt;fread&lt;/code&gt; returns zero and performs no other action.</source>
          <target state="translated">Если &lt;code&gt;size&lt;/code&gt; или &lt;code&gt;count&lt;/code&gt; равен нулю, &lt;code&gt;fread&lt;/code&gt; возвращает ноль и не выполняет никаких других действий.</target>
        </trans-unit>
        <trans-unit id="a444353fd5b9d3848488fa96c9629f1e576c66a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; is zero, &lt;code&gt;fwrite&lt;/code&gt; returns zero and performs no other action.</source>
          <target state="translated">Если &lt;code&gt;size&lt;/code&gt; или &lt;code&gt;count&lt;/code&gt; равен нулю, &lt;code&gt;fwrite&lt;/code&gt; возвращает ноль и не выполняет никаких других действий.</target>
        </trans-unit>
        <trans-unit id="a9e1e400de47a1ed0b5cd2d6e227768319577ed9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt; overlap, the behavior is undefined</source>
          <target state="translated">Если &lt;code&gt;src&lt;/code&gt; и &lt;code&gt;dst&lt;/code&gt; перекрываются, поведение не определено</target>
        </trans-unit>
        <trans-unit id="d273f0263e60be8e604763a8afeb86df4bc79e3d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt; overlap, the behavior is unspecified.</source>
          <target state="translated">Если &lt;code&gt;src&lt;/code&gt; и &lt;code&gt;dst&lt;/code&gt; перекрываются, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="919d8cd3a8b53f2e18bf07280d97eede84dc299d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as the first call to &lt;code&gt;strtok&lt;/code&gt; for this particular string. The function searches for the first character which is</source>
          <target state="translated">Если &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , вызов обрабатывается как первый вызов &lt;code&gt;strtok&lt;/code&gt; для этой конкретной строки. Функция ищет первый символ, который</target>
        </trans-unit>
        <trans-unit id="452491e0b2ce1dbe11298bd37bb75407d3d3ddf8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as the first call to &lt;code&gt;wcstok&lt;/code&gt; for this particular wide string. The function searches for the first wide character which is</source>
          <target state="translated">Если &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , вызов обрабатывается как первый вызов &lt;code&gt;wcstok&lt;/code&gt; для этой конкретной широкой строки. Функция ищет первый широкий символ, который</target>
        </trans-unit>
        <trans-unit id="95b4b4bb5cc3b17be9977eef6a95107d1dfe2f33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as a subsequent call to &lt;code&gt;wcstok&lt;/code&gt;: the function continues from where it left in the previous invocation with the same &lt;code&gt;*ptr&lt;/code&gt;. The behavior is the same as if the pointer to the wide character that follows the last detected token is passed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , вызов обрабатывается как последующий вызов &lt;code&gt;wcstok&lt;/code&gt; : функция продолжается с того места, где она ушла в предыдущем вызове, с тем же &lt;code&gt;*ptr&lt;/code&gt; . Поведение такое же, как если бы указатель на широкий символ, который следует за последним обнаруженным токеном, передается как &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66ec70311bf6aedd6bdb60bbe9f819c870804830" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as a subsequent calls to &lt;code&gt;strtok&lt;/code&gt;: the function continues from where it left in previous invocation. The behavior is the same as if the previously stored pointer is passed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , вызов обрабатывается как последующие вызовы &lt;code&gt;strtok&lt;/code&gt; : функция продолжается с того места, где она ушла в предыдущем вызове. Поведение такое же, как если бы ранее сохраненный указатель был передан как &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4dee41190e5faa1ca923bd889668d6289ee307f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stream&lt;/code&gt; is a null pointer, all open output streams are flushed, including the ones manipulated within library packages or otherwise not directly accessible to the program.</source>
          <target state="translated">Если &lt;code&gt;stream&lt;/code&gt; является нулевым указателем, все открытые выходные потоки сбрасываются, включая те, которые манипулируются в пакетах библиотеки или иным образом не доступны напрямую программе.</target>
        </trans-unit>
        <trans-unit id="eaa4ac73f07ef7f30a93d67313ff9cb94c76ac34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tss_delete&lt;/code&gt; is called while another thread is executing destructors for &lt;code&gt;tss_id&lt;/code&gt;, it's unspecified whether this changes the number of invocations to the associated destructor.</source>
          <target state="translated">Если &lt;code&gt;tss_delete&lt;/code&gt; вызывается в то время, когда другой поток выполняет деструкторы для &lt;code&gt;tss_id&lt;/code&gt; , не определено, изменяет ли это количество вызовов на связанный деструктор.</target>
        </trans-unit>
        <trans-unit id="399122524172ec8fa3e995c00fbab797727aa863" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tss_delete&lt;/code&gt; is called while the calling thread is executing destructors, then the destructor associated with &lt;code&gt;tss_id&lt;/code&gt; will not be executed again on this thread.</source>
          <target state="translated">Если &lt;code&gt;tss_delete&lt;/code&gt; вызывается, когда вызывающий поток выполняет деструкторы, то деструктор, связанный с &lt;code&gt;tss_id&lt;/code&gt; , больше не будет выполняться в этом потоке.</target>
        </trans-unit>
        <trans-unit id="2c8bc9e007e9eab3e896a3aaff472ee164636be8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ungetc&lt;/code&gt; is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful &lt;code&gt;ungetc&lt;/code&gt; were performed, read operations retrieve the pushed-back characters in reverse order of &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;ungetc&lt;/code&gt; вызывается более одного раза без промежуточного чтения или изменения положения, это может привести к сбою (другими словами, буфер с откатом размера 1 гарантирован, но любой больший буфер определяется реализацией). Если было выполнено несколько успешных &lt;code&gt;ungetc&lt;/code&gt; , операции чтения извлекают символы возврата в обратном порядке &lt;code&gt;ungetc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b93c880a13d41dd5f02146648e0bcdb941ad4432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ungetwc&lt;/code&gt; is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful &lt;code&gt;ungetwc&lt;/code&gt; were performed, read operations retrieve the pushed-back wide characters in reverse order of &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;ungetwc&lt;/code&gt; вызывается более одного раза без промежуточного чтения или изменения положения, это может привести к сбою (другими словами, буфер с откатом размера 1 гарантирован, но любой больший буфер определяется реализацией). Если было выполнено несколько успешных &lt;code&gt;ungetwc&lt;/code&gt; , операции чтения извлекают задние широкие символы в обратном порядке &lt;code&gt;ungetwc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75a090849c6c030efd853b2c4e1bec200144bf8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;va_arg&lt;/code&gt; is called when there are no more arguments in &lt;code&gt;ap&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;va_arg&lt;/code&gt; вызывается, когда в &lt;code&gt;ap&lt;/code&gt; больше нет аргументов , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="4a2e019de572732991114a4b9ac83594fefd4e00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;wc&lt;/code&gt; is the null character, the null byte is written to &lt;code&gt;s&lt;/code&gt;, preceded by any shift sequences necessary to restore the initial shift state.</source>
          <target state="translated">Если &lt;code&gt;wc&lt;/code&gt; является нулевым символом, нулевой байт записывается в &lt;code&gt;s&lt;/code&gt; , которому предшествуют любые последовательности сдвигов, необходимые для восстановления начального состояния сдвига.</target>
        </trans-unit>
        <trans-unit id="9292e4a3413eb133a7f76bc6e4fe74a238c5b8bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero, domain error</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; равны нулю, ошибка домена</target>
        </trans-unit>
        <trans-unit id="8a5e321969b66fbefa9cdd24eacf386b98fffc2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero, range error does not occur either</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; оба равны нулю, ошибка диапазона также не возникает</target>
        </trans-unit>
        <trans-unit id="1a0e37c7feac7db699e4130a50b199ceedd910f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin; and &lt;code&gt;y&lt;/code&gt; is not NaN, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; есть &amp;plusmn; &amp;infin; и &lt;code&gt;y&lt;/code&gt; не NaN, NaN , возвращается и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; поднимается</target>
        </trans-unit>
        <trans-unit id="0d517d0ca1b88b420f9a711836c289f554f6f27a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0 and &lt;code&gt;y&lt;/code&gt; is not zero, &amp;plusmn;0 is returned</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен &amp;plusmn; 0, а &lt;code&gt;y&lt;/code&gt; не равен нулю, возвращается &amp;plusmn; 0</target>
        </trans-unit>
        <trans-unit id="f41dcbd3d46c8769c4b2fb80c374a0e5c0d62c23" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is negative, &lt;code&gt;-&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;&amp;plusmn;0&lt;/code&gt; а &lt;code&gt;y&lt;/code&gt; отрицательно, возвращается &lt;code&gt;-&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6968a9e1c046845040fc68d63a376b5e6b8b85a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is positive, &lt;code&gt;+&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;&amp;plusmn;0&lt;/code&gt; а &lt;code&gt;y&lt;/code&gt; положительно, возвращается &lt;code&gt;+&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="742021246f19681537f6e140bb629b64b21e4348" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and negative, &lt;code&gt;-0&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;+&amp;infin;&lt;/code&gt; , а &lt;code&gt;y&lt;/code&gt; конечен и отрицателен, возвращается &lt;code&gt;-0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="854f55847c1c8f45111c844b75fe0c4c049cc744" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and positive, &lt;code&gt;+0&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;+&amp;infin;&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; конечен и положителен, возвращается &lt;code&gt;+0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70312266975b00e8f11c41c1477d3626e83ccaa9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and negative, &lt;code&gt;-&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;-&amp;infin;&lt;/code&gt; , а &lt;code&gt;y&lt;/code&gt; конечен и отрицателен, возвращается &lt;code&gt;-&amp;pi;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="adfdc77216731e53faa0611a28dda473ddae36f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and positive, &lt;code&gt;+&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;-&amp;infin;&lt;/code&gt; , а &lt;code&gt;y&lt;/code&gt; конечен и положителен, возвращается &lt;code&gt;+&amp;pi;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="86712aaf103771c2d7819baa87af27b031d94ae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, then NaN with the sign of &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен NaN, то возвращается NaN со знаком &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e48634bd82e2df6f62aec245642cb59777238384" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &amp;plusmn;&amp;infin; and &lt;code&gt;x&lt;/code&gt; is finite, &lt;code&gt;x&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равен &amp;plusmn; &amp;infin; и &lt;code&gt;x&lt;/code&gt; конечно, &lt;code&gt;x&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="a2ddc1042c63e353212b7799d89a1b092aed734a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &amp;plusmn;0 and &lt;code&gt;x&lt;/code&gt; is not NaN, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равен &amp;plusmn; 0 и &lt;code&gt;x&lt;/code&gt; не является NaN, NaN возвращается и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="1c4d4232381ec31f82701b3b12b902639c119342" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations.</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равно -0, результат будет только отрицательным, если реализация последовательно поддерживает нулевой знак в арифметических операциях.</target>
        </trans-unit>
        <trans-unit id="bb77d357b03480982a5cb3af7fe4d1a54b4629b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;plusmn;&amp;pi;/4&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равно &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; а &lt;code&gt;x&lt;/code&gt; равно &lt;code&gt;+&amp;infin;&lt;/code&gt; , возвращается &lt;code&gt;&amp;plusmn;&amp;pi;/4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c32d4c116dec5e5a3f5f016622351bfcdbb1d9a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;plusmn;3&amp;pi;/4&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равен &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; а &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;-&amp;infin;&lt;/code&gt; , возвращается &lt;code&gt;&amp;plusmn;3&amp;pi;/4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2d2be60f0f9dee6ef4e60532e876177666a7509" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is finite, &lt;code&gt;&amp;plusmn;&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равен &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; конечно, возвращается &lt;code&gt;&amp;plusmn;&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04ca9c751f9bab309085f696c5ce7e061eb53bf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is negative or &lt;code&gt;-0&lt;/code&gt;, &lt;code&gt;&amp;plusmn;&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равно &lt;code&gt;&amp;plusmn;0&lt;/code&gt; а &lt;code&gt;x&lt;/code&gt; отрицательно или &lt;code&gt;-0&lt;/code&gt; , возвращается &lt;code&gt;&amp;plusmn;&amp;pi;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c2e024aa12ac316eec5865ba0f65ada4018df50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is positive or &lt;code&gt;+0&lt;/code&gt;, &lt;code&gt;&amp;plusmn;0&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равно &lt;code&gt;&amp;plusmn;0&lt;/code&gt; а &lt;code&gt;x&lt;/code&gt; положительно или &lt;code&gt;+0&lt;/code&gt; , возвращается &lt;code&gt;&amp;plusmn;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db8ff25a6b35fd58c6e2ad1d8257aa1fdbbc1afa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, but the domain error does not occur, zero is returned.</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равно нулю, но ошибка домена не возникает, возвращается ноль.</target>
        </trans-unit>
        <trans-unit id="934c80b3e977f6c9efabb47ff6836e6a1d4145a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, pole error does not occur</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равен нулю, ошибка полюса не возникает</target>
        </trans-unit>
        <trans-unit id="d5af0b5b04311e67b5c965ddebdd4dcbe743ea19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, the value stored in &lt;code&gt;*quo&lt;/code&gt; is unspecified.</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равно нулю, значение, хранящееся в &lt;code&gt;*quo&lt;/code&gt; , не указано.</target>
        </trans-unit>
        <trans-unit id="625acef687f1e557bbb80eaf5f5e753fb2ddb33d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; , результат равен &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e776bd162170c11d73af44ef8772342340ecd190" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;NaN&amp;plusmn;&amp;infin;i&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; , результат равен &lt;code&gt;NaN&amp;plusmn;&amp;infin;i&lt;/code&gt; (знак мнимой части не определен)</target>
        </trans-unit>
        <trans-unit id="9d3e426e20516e7376a050aee0403fe0d2b10ec1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt;, the result is &lt;code&gt;&amp;pi;/2-0i&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt; , результат равен &lt;code&gt;&amp;pi;/2-0i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f825bdeaf14c7f605beb396872b9bf8796ebfd9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt;, the result is &lt;code&gt;+0+0i&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt; , результат равен &lt;code&gt;+0+0i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6b60f1baa934eced059da43d7d291e2febe8bd6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt;, the result is &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt; , результат равен &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59a945b0d7d5f0cbeadecb2c1a035dcb5ca27324" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt;, the result is &lt;code&gt;1+0i&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt; , результат равен &lt;code&gt;1+0i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="999d915d02ed97295faafb81922e3c2b06d67050" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0+NaNi&lt;/code&gt;, the result is &lt;code&gt;&amp;pi;/2+NaNi&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;&amp;plusmn;0+NaNi&lt;/code&gt; , результат равен &lt;code&gt;&amp;pi;/2+NaNi&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c56b753fbf612891e276ecb3035b809c59bf33a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;pi;/4-&amp;infin;i&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt; , результат равен &lt;code&gt;&amp;pi;/4-&amp;infin;i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="deb39fe3ef692828d5403bc4bf6425bc5dff8537" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; (the sign of the real part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt; , результат равен &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; (знак действительной части не определен) и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="1cd5723428b77280491731f17b9a43dcf568e7ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised (the sign of the real part is unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt; , результат равен &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается (знак действительной части не указан)</target>
        </trans-unit>
        <trans-unit id="af6cc33ffa514f0fb416ba084c782fa9d65fe603" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+&amp;pi;i/4&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt; , результат равен &lt;code&gt;+&amp;infin;+&amp;pi;i/4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdd17d4f5bc34ca9a9f286bf72b81e05e7ec8b82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+i&amp;pi;/4&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt; , результат равен &lt;code&gt;+&amp;infin;+i&amp;pi;/4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58b7336602437e7b3e1e2fd464b50015fba38ed0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt; , результат равен &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9fb5e54ed45d0a2da9d34fcf5eebc061ed69ef3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;1&amp;plusmn;0i&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt; , результат равен &lt;code&gt;1&amp;plusmn;0i&lt;/code&gt; (знак мнимой части не определен)</target>
        </trans-unit>
        <trans-unit id="bbc9947aa4794f3a678fa9974f0b8face529b478" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+0i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+0i&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+0i&lt;/code&gt; , результат равен &lt;code&gt;+&amp;infin;+0i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57d2b3b7c507184bec2b467227a5ef3e66fb09dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+NaN&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+NaN&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+NaN&lt;/code&gt; , результат равен &lt;code&gt;+&amp;infin;+NaN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="074653f1bcfd78e2c6b8261d6288ce30b3f409ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt; , результат равен &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; (знак действительной части не указан )</target>
        </trans-unit>
        <trans-unit id="36a15e9914952a3e127c1857dfb1656f43e91982" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt; , результат равен &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b8208a3b53853e24adab139e12b16bb55e09c49" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;+0+NaNi&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt; , результат равен &lt;code&gt;+0+NaNi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7d8ce12350273a97cbf0883260795a1b23dea52" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;1&amp;plusmn;0i&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt; , результат равен &lt;code&gt;1&amp;plusmn;0i&lt;/code&gt; (знак мнимой части не определен)</target>
        </trans-unit>
        <trans-unit id="d4e8cef24833eac8da6eb2c3e75a7fe324ade08a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any finite non-zero y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (для любого конечного ненулевого y), результат равен &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9bdf7c1f65251420ffa8f16429794ca31be5b14e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any finite nonzero y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (для любого конечного ненулевого y), результат равен &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7910e66fb37842a583e14d09b105ade30be68803" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;+&amp;infin;+0i&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (для любого конечного положительного y), результат равен &lt;code&gt;+&amp;infin;+0i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6768e1ec6df6a95e6a4c726fc892acad121e7985" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (для любого конечного положительного y), результат равен &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f62e4cdc201996da16b1502058a6c1e9023d551" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;1+0i&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (для любого конечного положительного y), результат равен &lt;code&gt;1+0i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0ce2d0c3f9d0861e47b4abf10a45e3583833a5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;+&amp;infin;+0i&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (для любого положительного конечного y), результат равен &lt;code&gt;+&amp;infin;+0i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="832b62b259002df797cd0148545bc70005eba32b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (для любого положительного конечного y), результат равен &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20a620da3de056d824da46c1301b06a1653505bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+0i)&lt;/code&gt; for finite positive y</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; , результат равен &lt;code&gt;+&amp;infin;+0i)&lt;/code&gt; для конечного положительного значения y</target>
        </trans-unit>
        <trans-unit id="796b4ff0d96367997b18b6f7414bc04e2ed54548" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;0+NaNi&lt;/code&gt; (the sign of the real part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+0+&amp;infin;i&lt;/code&gt; , результат равен &lt;code&gt;&amp;plusmn;0+NaNi&lt;/code&gt; (знак действительной части не определен) и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="5309daa1a2a52ddd69bab7388c31c22811693301" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;NaN&amp;plusmn;0i&lt;/code&gt; (the sign of the imaginary part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+0+&amp;infin;i&lt;/code&gt; , результат равен &lt;code&gt;NaN&amp;plusmn;0i&lt;/code&gt; (знак мнимой части не определен) и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="5377d46789b608eb83cab1fd971c8e1fdc08ef07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+0i&lt;/code&gt;, the result is &lt;code&gt;+0+0i&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+0+0i&lt;/code&gt; , результат равен &lt;code&gt;+0+0i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9921811f368934b33ab588a74bfc469573b9542" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+0i&lt;/code&gt;, the result is &lt;code&gt;-&amp;infin;+0i&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+0+0i&lt;/code&gt; , результат равен &lt;code&gt;-&amp;infin;+0i&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="30d6b4e4a6916b3f5bf139a7a8056a1e67f1365b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+0i&lt;/code&gt;, the result is &lt;code&gt;1+0i&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; есть &lt;code&gt;+0+0i&lt;/code&gt; , результат равен &lt;code&gt;1+0i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a93099e5fafc600b431649dde73f501ee2c62f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+NaNi&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;0+NaNi&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+0+NaNi&lt;/code&gt; , результат равен &lt;code&gt;&amp;plusmn;0+NaNi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="babb8188b54877f4defa5fdcad7f2801cb860adf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+NaNi&lt;/code&gt;, the result is &lt;code&gt;+0+NaNi&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+0+NaNi&lt;/code&gt; , результат равен &lt;code&gt;+0+NaNi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05f532d9487bdac748e6ace19ea8e53c7305f1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+NaNi&lt;/code&gt;, the result is &lt;code&gt;NaN&amp;plusmn;0i&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+0+NaNi&lt;/code&gt; , результат равен &lt;code&gt;NaN&amp;plusmn;0i&lt;/code&gt; (знак мнимой части не определен)</target>
        </trans-unit>
        <trans-unit id="cf4db554760a0604e00615063e66764d7bf313aa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+1+0i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+0i&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+1+0i&lt;/code&gt; , результат равен &lt;code&gt;+&amp;infin;+0i&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="38d56aaf8eaff18904a766fcf455f56b6ddac179" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+x+&amp;infin;i&lt;/code&gt; (for any finite x), the result is &lt;code&gt;+&amp;infin;+i&amp;pi;/2&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;+x+&amp;infin;i&lt;/code&gt; (для любого конечного x), результат равен &lt;code&gt;+&amp;infin;+i&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89bbfd524374559a9938d77e51791857f87d786c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+x+NaNi&lt;/code&gt; (for non-zero finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;+x+NaNi&lt;/code&gt; (для конечного x, отличного от нуля), результатом является &lt;code&gt;NaN+NaNi&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен.</target>
        </trans-unit>
        <trans-unit id="f1aede927aad834a1785eca9ec8164efbce2fd01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;0&amp;plusmn;0i&lt;/code&gt; (signs are unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt; , результат равен &lt;code&gt;&amp;plusmn;0&amp;plusmn;0i&lt;/code&gt; (знаки не указаны)</target>
        </trans-unit>
        <trans-unit id="11925823f1f8e4ae67f97e30d8d10beacc784a6a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+3&amp;pi;i/4&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt; , результат равен &lt;code&gt;+&amp;infin;+3&amp;pi;i/4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5629437abcfb214e3e73d687e87c0bbfd484294d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+3i&amp;pi;/4&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt; , результат равен &lt;code&gt;+&amp;infin;+3i&amp;pi;/4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b23078b80b2d0a20adc1047ee85085ec345a4c08" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;3&amp;pi;/4-&amp;infin;i&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt; , результат равен &lt;code&gt;3&amp;pi;/4-&amp;infin;i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0916960961bb0b2dad526b5d8175c9cde4d8b004" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;0&amp;plusmn;0i&lt;/code&gt; (signs are unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;-&amp;infin;+NaNi&lt;/code&gt; , результат равен &lt;code&gt;&amp;plusmn;0&amp;plusmn;0i&lt;/code&gt; (знаки не указаны)</target>
        </trans-unit>
        <trans-unit id="d23cff457c96232415905ac78b0b18a88e49ee49" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;NaN&amp;plusmn;&amp;infin;i&lt;/code&gt; (sign of imaginary part unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;-&amp;infin;+NaNi&lt;/code&gt; , результат равен &lt;code&gt;NaN&amp;plusmn;&amp;infin;i&lt;/code&gt; (знак мнимой части не указан )</target>
        </trans-unit>
        <trans-unit id="588e8fab7757a98088b599ad32219a88f43e15b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;+&amp;infin;+&amp;pi;i&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (для любого конечного положительного значения y), результат равен &lt;code&gt;+&amp;infin;+&amp;pi;i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed0586d452079c8db876de069dd932b883bdbc41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (for any finite y), the result is &lt;code&gt;+0cis(y)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (для любого конечного y), результат равен &lt;code&gt;+0cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="97bb419bd6dda05c2487d6ebabe98e61e56454e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;&amp;pi;-&amp;infin;i&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (для любого положительного конечного y), результат равен &lt;code&gt;&amp;pi;-&amp;infin;i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73be861cb7403dc831de7a0eb3583bbe00513c7d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;+&amp;infin;+i&amp;pi;&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (для любого положительного конечного y), результат равен &lt;code&gt;+&amp;infin;+i&amp;pi;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e9a39eb36afdfaf9c77e1b226686fcfff50f0ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;+0-&amp;infin;i&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (для любого положительного конечного y), результат равен &lt;code&gt;+0-&amp;infin;i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="851d57b9d8335c6dfc8e20c92f1e808393d81024" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+yi&lt;/code&gt;, the result is &lt;code&gt;+0+&amp;infin;i&lt;/code&gt; for finite positive y</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; , результат равен &lt;code&gt;+0+&amp;infin;i&lt;/code&gt; для конечного положительного значения y</target>
        </trans-unit>
        <trans-unit id="e0896ff44ed61681eeb9cda5e2db468c4dcb7345" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-0+0i&lt;/code&gt;, the result is &lt;code&gt;-&amp;infin;+&amp;pi;i&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;-0+0i&lt;/code&gt; , результат равен &lt;code&gt;-&amp;infin;+&amp;pi;i&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="da9605b8e9e71096e7d152ca980d6f5c93bba805" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;0+NaNi&lt;/code&gt;, the result is &lt;code&gt;NaN&amp;plusmn;i&amp;pi;/2&lt;/code&gt;, where the sign of the imaginary part is unspecified</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;0+NaNi&lt;/code&gt; , результат равен &lt;code&gt;NaN&amp;plusmn;i&amp;pi;/2&lt;/code&gt; , где знак мнимой части не определен</target>
        </trans-unit>
        <trans-unit id="98b8e6ca75c33aacc22f25140d2d52982edd58fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt; , результат равен &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; (знак действительной части не указан )</target>
        </trans-unit>
        <trans-unit id="04e920d0768c071b159f8cf0ccb4766fc1f81e20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;0+i&amp;pi;/2&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt; , результат равен &lt;code&gt;&amp;plusmn;0+i&amp;pi;/2&lt;/code&gt; (знак действительной части не указан)</target>
        </trans-unit>
        <trans-unit id="638dd3af4879e274f2753dd13affb32f54d0c427" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt; , результат равен &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="daba330e5a0bc591c3819affe8ac2668be2332bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;NaN-&amp;infin;i&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt; , результат равен &lt;code&gt;NaN-&amp;infin;i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="93fd1cf9bded1c643f4be838021974ff52d04574" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+0i&lt;/code&gt;, the result is &lt;code&gt;NaN&amp;plusmn;0i&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;NaN+0i&lt;/code&gt; , результат равен &lt;code&gt;NaN&amp;plusmn;0i&lt;/code&gt; (знак мнимой части не определен)</target>
        </trans-unit>
        <trans-unit id="be162870b1adbbfcdab4d44246254add068c4d3d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+0i&lt;/code&gt;, the result is &lt;code&gt;NaN+0i&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;NaN+0i&lt;/code&gt; , результат равен &lt;code&gt;NaN+0i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed140ac051f22ec49ba422cfe0adb820c792ce97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+NaNi&lt;/code&gt;, the result is &lt;code&gt;NaN+NaNi&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;NaN+NaNi&lt;/code&gt; , результат равен &lt;code&gt;NaN+NaNi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0832a5cb369dc40bbf17d380253648fec2eafd26" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt; (for any finite non-zero y), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;NaN+yi&lt;/code&gt; (для любого конечного ненулевого y), результатом является &lt;code&gt;NaN+NaNi&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен</target>
        </trans-unit>
        <trans-unit id="237a9a25ce4abe535bbf2f26c139e1578e0f57db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt; (for any finite nonzero y), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;NaN+yi&lt;/code&gt; (для любого конечного ненулевого y), результат равен &lt;code&gt;NaN+NaNi&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен</target>
        </trans-unit>
        <trans-unit id="9bd4c1293771f3563ff364c43498200c3c13cb97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt; (for any finite y), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;NaN+yi&lt;/code&gt; (для любого конечного y), результат равен &lt;code&gt;NaN+NaNi&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен</target>
        </trans-unit>
        <trans-unit id="543c12f39bc3f311b75307271197b544025035ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt; (for any finite y), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;NaN+yi&lt;/code&gt; (для любого конечного y), результатом является &lt;code&gt;NaN+NaNi&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен.</target>
        </trans-unit>
        <trans-unit id="d493aac97dda0447051a4e0d2c6f5ec9e2060421" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt; (for any non-zero y), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;NaN+yi&lt;/code&gt; (для любого отличного от нуля y), результатом является &lt;code&gt;NaN+NaNi&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен</target>
        </trans-unit>
        <trans-unit id="fc20f772fb2e9b1f8a5f485718315fa6f70c07b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt; (for any nonzero y), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;NaN+yi&lt;/code&gt; (для любого &lt;code&gt;NaN+NaNi&lt;/code&gt; от нуля y), результатом является NaN + NaNi, и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен</target>
        </trans-unit>
        <trans-unit id="7d3bec2c00936b0677791908a2e4bac6c5da3a16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt;, the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;NaN+yi&lt;/code&gt; , результат равен &lt;code&gt;NaN+NaNi&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен</target>
        </trans-unit>
        <trans-unit id="a37c90aa215aa60d649f207f9c5229f362419dc3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any finite non-zero x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; является &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (для любого конечных ненулевого х), то результат будет &lt;code&gt;NaN+NaNi&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; поднимаются</target>
        </trans-unit>
        <trans-unit id="1bb3d1a016313313a6b48c627b3a72353646af38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any finite positive x), the result is &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (для любого конечного положительного x), результат равен &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b73c524a1f7cdc97af1ed115b7f7b4545582b048" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any finite x), the result is &lt;code&gt;&amp;pi;/2-&amp;infin;i&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (для любого конечного x), результат равен &lt;code&gt;&amp;pi;/2-&amp;infin;i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="387a32ebb5732e31a734be8cc4d5825b907d56f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any finite x), the result is &lt;code&gt;+&amp;infin;+&amp;pi;i/2&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (для любого конечного x), результат равен &lt;code&gt;+&amp;infin;+&amp;pi;i/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e21f01f7c3c4ba8563c2060a845c0a391233d504" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (для любого конечного x), результат равен &lt;code&gt;NaN+NaNi&lt;/code&gt; и значение &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается.</target>
        </trans-unit>
        <trans-unit id="656ce31f57bb568a13e9ac94e493eeccd6c0fa10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;+&amp;infin;+&amp;pi;/2&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (для любого положительного конечного x), результат равен &lt;code&gt;+&amp;infin;+&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b18b6f6cea921f44fce092288d49e81492a7d80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (для любого положительного конечного x), результат равен &lt;code&gt;NaN+NaNi&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="460b063ec1b13ac13ca6654ed1024e7cd0950fc4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;ctanh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (для любого &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;ctanh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; конечного x), результат равен &lt;code&gt;NaN+NaNi&lt;/code&gt; и значение &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="63489bf316b1d8539e0fca94a25ca124b0a8a98c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt; even if x is NaN</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;x+&amp;infin;i&lt;/code&gt; , результат равен &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt; , даже если x равен NaN</target>
        </trans-unit>
        <trans-unit id="f69761b498632a762c370417fd0122db567041cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaN&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;ctanh#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;x+NaN&lt;/code&gt; (для любого &lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;ctanh#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; конечного x), результат равен &lt;code&gt;NaN+NaNi&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен</target>
        </trans-unit>
        <trans-unit id="54c6ea5aaa627daf3c1ae805242b58ce8d207848" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt; (for any finite non-zero x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;x+NaNi&lt;/code&gt; (для любого конечного ненулевого x), результат равен &lt;code&gt;NaN+NaNi&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен</target>
        </trans-unit>
        <trans-unit id="b93caab68fa73ccda5d1b17498c4229840dbee54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt; (for any finite nonzero x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;x+NaNi&lt;/code&gt; (для любого конечного ненулевого x), результат равен &lt;code&gt;NaN+NaNi&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен</target>
        </trans-unit>
        <trans-unit id="2f565c2557a5ee30de01f8e30a13b63363ded1dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt; (for any finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;x+NaNi&lt;/code&gt; (для любого конечного x), результат равен &lt;code&gt;NaN+NaNi&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен</target>
        </trans-unit>
        <trans-unit id="5dfecd44688d670800ff223095156659b894fc93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt; (for any finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;x+NaNi&lt;/code&gt; (для любого конечного x), результатом является &lt;code&gt;NaN+NaNi&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен.</target>
        </trans-unit>
        <trans-unit id="73d6ef277884ef031696f2e39fb8437e61e455ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt; (for any nonzero finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;x+NaNi&lt;/code&gt; (для любого ненулевого конечного x), результатом является &lt;code&gt;NaN+NaNi&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен.</target>
        </trans-unit>
        <trans-unit id="06474f38558e726376291b2fee6434dae49fb720" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;x+NaNi&lt;/code&gt; (для любого положительного конечного x), результат равен &lt;code&gt;NaN+NaNi&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен</target>
        </trans-unit>
        <trans-unit id="f5b921b4a4b89a2b78c2d734ce1603b4cd5809c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt;, the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; (unless x is &amp;plusmn;&amp;infin;) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;x+NaNi&lt;/code&gt; , результат равен &lt;code&gt;NaN+NaNi&lt;/code&gt; (если x не равен &amp;plusmn; &amp;infin;), и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен</target>
        </trans-unit>
        <trans-unit id="494c7fa954556372ffde67c8fcd8b5c440f15d85" translate="yes" xml:space="preserve">
          <source>If A is not sequenced before B and B is not sequenced before A, then two possibilities exist:</source>
          <target state="translated">Если A не секвенирована перед B,а B не секвенирована перед A,то существует два варианта:</target>
        </trans-unit>
        <trans-unit id="e909e2416c8dd4d8004abde79eee57ee706ae1a0" translate="yes" xml:space="preserve">
          <source>If A is not sequenced before B and B is sequenced before A, then evaluation of B will be complete before evaluation of A begins.</source>
          <target state="translated">Если A не будет последовательным перед B,а B будет последовательным перед A,то оценка B будет завершена до начала оценки A.</target>
        </trans-unit>
        <trans-unit id="5b3dcdb9c0e0e848fd114ab741ff0ec9dafbada5" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; uses &lt;code&gt;typedef&lt;/code&gt; as storage-class specifier, every declarator in it defines an identifier as an alias to the type specified. Since only one storage-class specifier is permitted in a declaration, typedef declaration cannot be &lt;a href=&quot;storage_duration&quot;&gt;static or extern&lt;/a&gt;.</source>
          <target state="translated">Если &lt;a href=&quot;declarations&quot;&gt;объявление&lt;/a&gt; использует &lt;code&gt;typedef&lt;/code&gt; в качестве спецификатора класса хранения, каждый декларатор в нем определяет идентификатор как псевдоним указанного типа. Поскольку в объявлении разрешен только один спецификатор класса хранения, объявление typedef не может быть &lt;a href=&quot;storage_duration&quot;&gt;статическим или внешним&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="28f44931b69cf3f9c6318eccefe0feba2cd026ec" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sequence_point&quot;&gt;&lt;i&gt;sequence point&lt;/i&gt;&lt;/a&gt; is present between the subexpressions E1 and E2, then both value computation and side effects of E1 are</source>
          <target state="translated">Если между подвыражениями E1 и E2 присутствует &lt;a href=&quot;https://en.wikipedia.org/wiki/Sequence_point&quot;&gt;&lt;i&gt;точка последовательности&lt;/i&gt;&lt;/a&gt; , то как вычисление значения, так и побочные эффекты E1</target>
        </trans-unit>
        <trans-unit id="54d68e95d2eaee0fc5d16e87451670896b8f13a1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;va_list&lt;/code&gt; instance is created, passed to another function, and used via &lt;code&gt;va_arg&lt;/code&gt; in that function, then any subsequent use in the calling function should be preceded by a call to &lt;code&gt;va_end&lt;/code&gt;.</source>
          <target state="translated">Если экземпляр &lt;code&gt;va_list&lt;/code&gt; создается, передается другой функции и используется через &lt;code&gt;va_arg&lt;/code&gt; в этой функции, то любому последующему использованию в вызывающей функции должен предшествовать вызов &lt;code&gt;va_end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41728f960e83107e165631fae30f77c98f34499a" translate="yes" xml:space="preserve">
          <source>If a VLA or another identifier with variably-modified type has a &lt;code&gt;case:&lt;/code&gt; or a &lt;code&gt;default:&lt;/code&gt; label within its scope, the entire switch statement must be in its scope (in other words, a VLA must be declared either before the entire switch or after the last label):</source>
          <target state="translated">Если VLA или другой идентификатор с изменяемым типом имеет в своем контексте метку &lt;code&gt;case:&lt;/code&gt; или &lt;code&gt;default:&lt;/code&gt; label, весь оператор switch должен находиться в его области (другими словами, VLA должен быть объявлен либо до всего коммутатора, либо после него. последний ярлык):</target>
        </trans-unit>
        <trans-unit id="a62eb301fbc04938195faede31c45cafa349ad46" translate="yes" xml:space="preserve">
          <source>If a conversion specification is invalid, the behavior is undefined.</source>
          <target state="translated">Если спецификация преобразования недействительна,поведение не определено.</target>
        </trans-unit>
        <trans-unit id="5790fe10d0a55b84da0323b97076fc148d33b344" translate="yes" xml:space="preserve">
          <source>If a data race occurs, the behavior of the program is undefined.  (in particular, &lt;code&gt;&lt;a href=&quot;../thread/mtx_unlock&quot;&gt;mtx_unlock&lt;/a&gt;&lt;/code&gt; is.</source>
          <target state="translated">Если происходит гонка данных, поведение программы не определено. (в частности, &lt;code&gt;&lt;a href=&quot;../thread/mtx_unlock&quot;&gt;mtx_unlock&lt;/a&gt;&lt;/code&gt; есть.</target>
        </trans-unit>
        <trans-unit id="3b53fae349713df5efc757fb7b33531c67e72c29" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value (NaN where supported) is returned.</source>
          <target state="translated">При возникновении ошибки домена возвращается значение,определяемое реализацией (NaN,где поддерживается).</target>
        </trans-unit>
        <trans-unit id="daaa304029da34d0537dff7e88f32d7146eac438" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value is returned (NaN where supported).</source>
          <target state="translated">При возникновении ошибки домена возвращается значение,определяемое реализацией (NaN,где поддерживается).</target>
        </trans-unit>
        <trans-unit id="8a2b2a5d22410f7c139500bf2d1ad8bd3daffb21" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value is returned.</source>
          <target state="translated">При возникновении ошибки домена возвращается значение,определяемое реализацией.</target>
        </trans-unit>
        <trans-unit id="2882768bd45c3b2d9f2505ac60769f87322f2c3b" translate="yes" xml:space="preserve">
          <source>If a function declaration appears outside of any function, the identifier it introduces has &lt;a href=&quot;scope&quot;&gt;file scope&lt;/a&gt; and &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;, unless &lt;code&gt;static&lt;/code&gt; is used or an earlier static declaration is visible. If the declaration occurs inside another function, the identifier has block scope (and also either internal or external linkage).</source>
          <target state="translated">Если объявление функции появляется вне какой-либо функции, вводимый ею идентификатор имеет &lt;a href=&quot;scope&quot;&gt;область действия файла&lt;/a&gt; и &lt;a href=&quot;storage_duration&quot;&gt;внешнюю связь&lt;/a&gt; , если только не используется &lt;code&gt;static&lt;/code&gt; или не видно более раннее статическое объявление. Если объявление происходит внутри другой функции, идентификатор имеет область видимости блока (а также внутреннюю или внешнюю связь).</target>
        </trans-unit>
        <trans-unit id="1f3d7d32f7511db7ae1b5863171bfef6106dcf6d" translate="yes" xml:space="preserve">
          <source>If a function is declared &lt;code&gt;inline&lt;/code&gt; in some translation units, it does not need to be declared inline everywhere: at most one translation unit may also provide a regular, non-inline non-static function, or a function declared &lt;code&gt;extern inline&lt;/code&gt;. This one translation unit is said to provide the</source>
          <target state="translated">Если функция объявляется &lt;code&gt;inline&lt;/code&gt; в некоторых единицах перевода, ее не нужно везде объявлять встроенной: самое большее одна единица перевода может также предоставить обычную нестандартную нестатическую функцию или функцию, объявленную &lt;code&gt;extern inline&lt;/code&gt; . Считается, что эта единица перевода обеспечивает</target>
        </trans-unit>
        <trans-unit id="55e8d6db1875ea64570ead516bceb34179f77c5b" translate="yes" xml:space="preserve">
          <source>If a non-static function is declared &lt;code&gt;inline&lt;/code&gt;, then it must be defined in the same translation unit. The inline definition that does not use &lt;code&gt;extern&lt;/code&gt; is not externally visible and does not prevent other translation units from defining the same function. This makes the &lt;code&gt;inline&lt;/code&gt; keyword an alternative to &lt;code&gt;static&lt;/code&gt; for defining functions inside header files, which may be included in multiple translation units of the same program.</source>
          <target state="translated">Если нестатическая функция объявлена &lt;code&gt;inline&lt;/code&gt; , то она должна быть определена в той же единице перевода. Встроенное определение, которое не использует &lt;code&gt;extern&lt;/code&gt; , не видимо снаружи и не мешает другим единицам перевода определять ту же функцию. Это делает ключевое слово &lt;code&gt;inline&lt;/code&gt; альтернативным &lt;code&gt;static&lt;/code&gt; для определения функций внутри заголовочных файлов, которые могут быть включены в несколько модулей перевода одной и той же программы.</target>
        </trans-unit>
        <trans-unit id="6a2baf22c2e3d7ee45e7b76a25868e011a385fd4" translate="yes" xml:space="preserve">
          <source>If a pointer to object is converted to a pointer to void and back, its value compares equal to the original pointer.</source>
          <target state="translated">Если указатель на объект преобразовывается в указатель на пустоту и обратно,то его значение сравнивается с исходным указателем.</target>
        </trans-unit>
        <trans-unit id="95fa4aab00b2248a193df0012ce51bbbfdcb0a2a" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned (with the correct sign).</source>
          <target state="translated">Если возникает ошибка полюса, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; или &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; (с правильным знаком).</target>
        </trans-unit>
        <trans-unit id="88c1375fb3e07154fab82fd39487a150f20a7acc" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">Если возникает ошибка полюса, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; или &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83547df0814e730591b9f631b39a107992bddaca" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;+HUGE_VAL&lt;/code&gt;, &lt;code&gt;+HUGE_VALF&lt;/code&gt;, or &lt;code&gt;+HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">Если возникает ошибка полюса, &lt;code&gt;+HUGE_VAL&lt;/code&gt; , &lt;code&gt;+HUGE_VALF&lt;/code&gt; или &lt;code&gt;+HUGE_VALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55c8a2c8fff5d682aefd99723282ecf86b260cc3" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;-HUGE_VAL&lt;/code&gt;, &lt;code&gt;-HUGE_VALF&lt;/code&gt;, or &lt;code&gt;-HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">Если возникает ошибка полюса, возвращается &lt;code&gt;-HUGE_VAL&lt;/code&gt; , &lt;code&gt;-HUGE_VALF&lt;/code&gt; или &lt;code&gt;-HUGE_VALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1aad32c287435bd724b2b2cd991a06c95727932d" translate="yes" xml:space="preserve">
          <source>If a pole error or a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">Если возникает ошибка полюса или ошибка диапазона из-за переполнения, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; или &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c9db649e4e6e4c38883de06799ee045378481d1" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned (with the same sign as &lt;code&gt;from&lt;/code&gt;).</source>
          <target state="translated">Если возникает ошибка диапазона из-за переполнения, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; или &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; (с тем же знаком, что и &lt;code&gt;from&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9842b2827c672e6e4b846cc1f4ef41186aaaf5f3" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">Если возникает ошибка диапазона из-за переполнения, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; или &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e1bf2f0df7137552a9579d23123773adeb14193" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;+HUGE_VAL&lt;/code&gt;, &lt;code&gt;+HUGE_VALF&lt;/code&gt;, or &lt;code&gt;+HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">Если возникает ошибка диапазона из-за переполнения, &lt;code&gt;+HUGE_VAL&lt;/code&gt; , &lt;code&gt;+HUGE_VALF&lt;/code&gt; или &lt;code&gt;+HUGE_VALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55d9e5e2db658de793b6612e1c8dc0adb82837dc" translate="yes" xml:space="preserve">
          <source>If a range error due to underflow occurs, the correct result (after rounding) is returned.</source>
          <target state="translated">При ошибке диапазона из-за недопотока возвращается правильный результат (после округления).</target>
        </trans-unit>
        <trans-unit id="144f2afda2da10823b65a9e4c24a0b3bb37c9913" translate="yes" xml:space="preserve">
          <source>If a range error due to underflow occurs, the correct value (after rounding) is returned.</source>
          <target state="translated">При ошибке диапазона из-за недопотока возвращается правильное значение (после округления).</target>
        </trans-unit>
        <trans-unit id="949156f77460641cf432a3cc1721f1ed036f3731" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result (after rounding) is returned.</source>
          <target state="translated">При ошибке диапазона из-за недопотока возвращается правильный результат (после округления).</target>
        </trans-unit>
        <trans-unit id="bea570ee8fcad0dd93ebf596f86eddc89718e8ce" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result is returned if subnormals are supported.</source>
          <target state="translated">Если из-за недопотока возникает ошибка диапазона,возвращается правильный результат,если поддерживаются субнормальные значения.</target>
        </trans-unit>
        <trans-unit id="4771fa50f8d7229b07b35621538a1aac36cd67a9" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result is returned.</source>
          <target state="translated">При ошибке диапазона из-за недопотока возвращается правильный результат.</target>
        </trans-unit>
        <trans-unit id="1ce932a742aa1c52c8241cbf55e0ac1bce6e8b12" translate="yes" xml:space="preserve">
          <source>If a read or write error occurs, the error indicator (&lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;ferror&lt;/a&gt;&lt;/code&gt;) for the stream is set.</source>
          <target state="translated">Если происходит ошибка чтения или записи, устанавливается индикатор ошибки ( &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;ferror&lt;/a&gt;&lt;/code&gt; ) для потока.</target>
        </trans-unit>
        <trans-unit id="324e8a46a69b9f9f1395e3fb9228dc24af457e88" translate="yes" xml:space="preserve">
          <source>If a read or write error occurs, the error indicator for the stream (&lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;ferror&lt;/a&gt;&lt;/code&gt;) is set and the file position is unaffected.</source>
          <target state="translated">Если происходит ошибка чтения или записи, устанавливается индикатор ошибки для потока ( &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;ferror&lt;/a&gt;&lt;/code&gt; ) и положение файла не изменяется.</target>
        </trans-unit>
        <trans-unit id="6f0552ab1ad9171053eb62c701cf4a288607a3e9" translate="yes" xml:space="preserve">
          <source>If a struct defines at least one named member, it is allowed to additionally declare its last member with incomplete array type. When an element of the flexible array member is accessed (in an expression that uses operator &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;-&amp;gt;&lt;/code&gt; with the flexible array member's name as the right-hand-side operand), then the struct behaves as if the array member had the longest size fitting in the memory allocated for this object. If no additional storage was allocated, it behaves as if an array with 1 element, except that the behavior is undefined if that element is accessed or a pointer one past that element is produced. Initialization, &lt;code&gt;sizeof&lt;/code&gt;, and the assignment operator ignore the flexible array member. Structures with flexible array members (or unions who have a recursive-possibly structure member with flexible array member) cannot appear as array elements or as members of other structures.</source>
          <target state="translated">Если структура определяет хотя бы один именованный член, ей разрешается дополнительно объявить свой последний член с неполным типом массива. При обращении к элементу элемента гибкого массива (в выражении, которое использует оператор &lt;code&gt;.&lt;/code&gt; Или &lt;code&gt;-&amp;gt;&lt;/code&gt; с именем элемента гибкого массива в качестве правого операнда), тогда структура ведет себя так, как если бы элемент массива имел самый длинный размер вписывается в память, выделенную для этого объекта. Если никакое дополнительное хранилище не было выделено, оно ведет себя как массив с 1 элементом, за исключением того, что поведение не определено, если к этому элементу обращаются или создается указатель на один после этого элемента. Инициализация, &lt;code&gt;sizeof&lt;/code&gt; и оператор присваивания игнорирует член гибкого массива. Структуры с гибкими элементами массива (или объединениями, которые имеют рекурсивно-возможно структурный элемент с гибким элементом массива) не могут отображаться как элементы массива или как элементы других структур.</target>
        </trans-unit>
        <trans-unit id="eed39e59199bcc4446f53b7637371743e6a55284" translate="yes" xml:space="preserve">
          <source>If a valid hex digit follows a hex escape in a string literal, it would fail to compile as an invalid escape sequence, but string concatenation can be used as a workaround:</source>
          <target state="translated">Если действительная шестнадцатеричная цифра следует за шестнадцатеричным экранированием в строковом литерале,она не будет скомпилирована как некорректная экранирующая последовательность,но конкатенация строк может быть использована в качестве обходного пути:</target>
        </trans-unit>
        <trans-unit id="a4f25c0ec9b3244cc6b75eca052c2b903d4a3faa" translate="yes" xml:space="preserve">
          <source>If a width specifier is used, matches exactly</source>
          <target state="translated">Если используется спецификатор ширины,то он точно соответствует</target>
        </trans-unit>
        <trans-unit id="5226fd58b879032cf6f8d13e08547a5ed7497ff7" translate="yes" xml:space="preserve">
          <source>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type with &lt;a href=&quot;../language/object#Alignment&quot;&gt;fundamental alignment&lt;/a&gt;.</source>
          <target state="translated">Если распределение выполнено успешно, возвращает указатель на младший (первый) байт в выделенном блоке памяти, который соответствующим образом выровнен для любого типа объекта с &lt;a href=&quot;../language/object#Alignment&quot;&gt;фундаментальным выравниванием&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10b291b7c1e1eda28b0d49719b46140dae50f0df" translate="yes" xml:space="preserve">
          <source>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type.</source>
          <target state="translated">Если выделение прошло успешно,возвращает указатель на младший (первый)байт в блоке выделенной памяти,который подходит для выравнивания для любого типа объектов.</target>
        </trans-unit>
        <trans-unit id="55b167df42e8335a72f97731fb365e554992c1c1" translate="yes" xml:space="preserve">
          <source>If an array is so large (greater than &lt;code&gt;&lt;a href=&quot;limits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; elements, but less than &lt;code&gt;&lt;a href=&quot;limits&quot;&gt;SIZE_MAX&lt;/a&gt;&lt;/code&gt; bytes), that the difference between two pointers may not be representable as &lt;code&gt;ptrdiff_t&lt;/code&gt;, the result of subtracting two such pointers is undefined.</source>
          <target state="translated">Если массив настолько большой (больше, чем элементы &lt;code&gt;&lt;a href=&quot;limits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; , но меньше, чем байты &lt;code&gt;&lt;a href=&quot;limits&quot;&gt;SIZE_MAX&lt;/a&gt;&lt;/code&gt; ), что различие между двумя указателями может не быть представлено как &lt;code&gt;ptrdiff_t&lt;/code&gt; , результат вычитания двух таких указателей не определен.</target>
        </trans-unit>
        <trans-unit id="9beeb85ee5a960fd0d5fcc0adf11aa6910156337" translate="yes" xml:space="preserve">
          <source>If an array type is declared with a &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;, &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;, &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt;(since C99), or &lt;a href=&quot;atomic&quot;&gt;_Atomic&lt;/a&gt;(since C11) qualifier (which is possible through the use of &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;), the array type is not qualified, but its element type is:</source>
          <target state="translated">Если тип массива объявлен с квалификатором &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; , &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; , &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt; (начиная с C99) или &lt;a href=&quot;atomic&quot;&gt;_Atomic&lt;/a&gt; (начиная с C11) (что возможно благодаря использованию &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; ), тип массива не определен, но его тип элемента:</target>
        </trans-unit>
        <trans-unit id="efcc6d70fe043c8b98938e05a3396705b54776f5" translate="yes" xml:space="preserve">
          <source>If an array type is declared with the const type qualifier (through the use of &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;), the array type is not const-qualified, but its element type is. If a function type is declared with the const type qualifier (through the use of &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;), the behavior is undefined.</source>
          <target state="translated">Если тип массива объявлен с квалификатором типа const (с помощью &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; ), тип массива не является константным, но его тип элемента равен. Если тип функции объявлен с квалификатором типа const (с помощью &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; ), поведение не определено.</target>
        </trans-unit>
        <trans-unit id="55e10804f659caae0ae85fbc681a3dc12898bf81" translate="yes" xml:space="preserve">
          <source>If an array type is declared with the restrict type qualifier (through the use of &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;), the array type is not restrict-qualified, but its element type is:</source>
          <target state="translated">Если тип массива объявлен с ограничителем типа restrict (с помощью &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; ), тип массива не ограничен ограничением, но его тип элемента:</target>
        </trans-unit>
        <trans-unit id="05be40a7233aa73625c4b48d04ab3ca25d2b7f9f" translate="yes" xml:space="preserve">
          <source>If an array type is declared with the volatile type qualifier (through the use of &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;), the array type is not volatile-qualified, but its element type is. If a function type is declared with the volatile type qualified (through the use of &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;), the behavior is undefined.</source>
          <target state="translated">Если тип массива объявлен с квалификатором volatile типа (с помощью &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; ), тип массива не определен volatile, но его тип элемента равен. Если тип функции объявлен с квалифицированным типом volatile (с помощью &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; ), поведение не определено.</target>
        </trans-unit>
        <trans-unit id="940fbe62d35554fccc76640b50d6adbc0079900c" translate="yes" xml:space="preserve">
          <source>If an atomic store in thread A is tagged &lt;code&gt;memory_order_release&lt;/code&gt; and an atomic load in thread B from the same variable is tagged &lt;code&gt;memory_order_acquire&lt;/code&gt;, all memory writes (non-atomic and relaxed atomic) that</source>
          <target state="translated">Если &lt;code&gt;memory_order_release&lt;/code&gt; хранилище в потоке A помечено memory_order_release, а атомарная загрузка в потоке B из той же переменной помечена &lt;code&gt;memory_order_acquire&lt;/code&gt; , все записи в память ( неатомарные и релаксированные атомарные), которые</target>
        </trans-unit>
        <trans-unit id="cf29cb2a4f015597bd5e89b82f0e88a7976c2e6a" translate="yes" xml:space="preserve">
          <source>If an atomic store in thread A is tagged &lt;code&gt;memory_order_release&lt;/code&gt; and an atomic load in thread B from the same variable is tagged &lt;code&gt;memory_order_consume&lt;/code&gt;, all memory writes (non-atomic and relaxed atomic) that are</source>
          <target state="translated">Если атомарное хранилище в потоке A помечено &lt;code&gt;memory_order_release&lt;/code&gt; , а атомарная загрузка в потоке B из той же переменной помечена &lt;code&gt;memory_order_consume&lt;/code&gt; , все записи в память (не атомарные и релаксированные атомарные), которые</target>
        </trans-unit>
        <trans-unit id="2795e8b6307a4d1e54bc6184732434401b4ea962" translate="yes" xml:space="preserve">
          <source>If an encoding error occurred, additionally sets &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;EILSEQ&lt;/code&gt;.</source>
          <target state="translated">Если произошла ошибка кодирования, дополнительно устанавливает &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;EILSEQ&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6911b84a61e5b6d4a44d583d9d016bd32e93add2" translate="yes" xml:space="preserve">
          <source>If an error occurs, the resulting value of the file position indicator for the stream is indeterminate. If a partial element is read, its value is indeterminate.</source>
          <target state="translated">При возникновении ошибки результирующее значение индикатора положения файла для потока является неопределенным.При считывании частичного элемента его значение является неопределенным.</target>
        </trans-unit>
        <trans-unit id="fc208d62518be5c688131bdd43fff494483d3612" translate="yes" xml:space="preserve">
          <source>If an expression evaluates to a value that is not representable by its type, it cannot be used as a constant expression.</source>
          <target state="translated">Если выражение вычисляется до значения,не представляемого по типу,оно не может быть использовано в качестве константного выражения.</target>
        </trans-unit>
        <trans-unit id="19ed04f0c056df4f3d246b0a488a18fc4f9a7010" translate="yes" xml:space="preserve">
          <source>If an identifier with external linkage is used in any expression other than a non-VLA(since C99), &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;, or &lt;a href=&quot;alignof&quot;&gt;alignof&lt;/a&gt;(since C11), there must be one and only one external definition for that identifier somewhere in the entire program.</source>
          <target state="translated">Если идентификатор с внешней связью используется в любом выражении, кроме не-VLA (начиная с C99), &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt; или &lt;a href=&quot;alignof&quot;&gt;alignof&lt;/a&gt; (начиная с C11), должно быть одно и только одно внешнее определение для этого идентификатора где-то во всей программе.</target>
        </trans-unit>
        <trans-unit id="61c715d29fbc4afeba0153113b895f922bbc534a" translate="yes" xml:space="preserve">
          <source>If an identifier with internal linkage is used in any expression other than a non-VLA(since C99), &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;, or &lt;a href=&quot;alignof&quot;&gt;alignof&lt;/a&gt;(since C11), there must be one and only one external definition for that identifier in the translation unit.</source>
          <target state="translated">Если идентификатор с внутренней связью используется в любом выражении, отличном от VLA (начиная с C99), &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt; или &lt;a href=&quot;alignof&quot;&gt;alignof&lt;/a&gt; (начиная с C11), для этого идентификатора в единице перевода должно быть одно и только одно внешнее определение.</target>
        </trans-unit>
        <trans-unit id="b7f9754da6fc6b81f29f5b6d3b428b27d61fc3ed" translate="yes" xml:space="preserve">
          <source>If an indeterminate value is used as an argument to any standard library call, the behavior is undefined. Otherwise, the result of any expression involving indeterminate values is an indeterminate value (e.g. &lt;code&gt;int n;&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; may not compare equal to itself and it may appear to change its value on subsequent reads).</source>
          <target state="translated">Если неопределенное значение используется в качестве аргумента для любого стандартного библиотечного вызова, поведение не определено. В противном случае, результат любого выражения с участием неопределенных значений является неопределенным значением (например , &lt;code&gt;int n;&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; может не сравнить равным себе и может показаться , чтобы изменить его значение на последующее чтение).</target>
        </trans-unit>
        <trans-unit id="2595c0e9c8f0a0375a7da8475c597d0f3be5bd12" translate="yes" xml:space="preserve">
          <source>If an initializer is not provided:</source>
          <target state="translated">Если инициализатор не предусмотрен:</target>
        </trans-unit>
        <trans-unit id="12e7ba75c8d971362a518ba45e96ae10c7050f8c" translate="yes" xml:space="preserve">
          <source>If an initializer is provided, see.</source>
          <target state="translated">Если предусмотрен инициализатор,см.</target>
        </trans-unit>
        <trans-unit id="737ef6d3c730778e5c94a6b40c35f5020e3cd40a" translate="yes" xml:space="preserve">
          <source>If an lvalue expression is used in any context other than &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;, &lt;a href=&quot;alignof&quot;&gt;_Alignof&lt;/a&gt;, or the operators listed above, non-array lvalues of any complete type undergo &lt;a href=&quot;conversion&quot;&gt;lvalue conversion&lt;/a&gt;, which models the memory load of the value of the object from its location. Similarly, array lvalues undergo &lt;a href=&quot;conversion&quot;&gt;array-to-pointer conversion&lt;/a&gt; when used in any context other than &lt;code&gt;sizeof&lt;/code&gt;, &lt;code&gt;_Alignof&lt;/code&gt;, address-of operator, or array initialization from a string literal.</source>
          <target state="translated">Если выражение lvalue используется в каком-либо контексте, кроме &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt; , &lt;a href=&quot;alignof&quot;&gt;_Alignof&lt;/a&gt; или вышеперечисленных операторов, не-массив lvalue любого полного типа подвергается &lt;a href=&quot;conversion&quot;&gt;преобразованию lvalue&lt;/a&gt; , которое моделирует загрузку в память значения объекта из его местоположения. Точно так же значения l массива подвергаются преобразованию &lt;a href=&quot;conversion&quot;&gt;массива в указатель&lt;/a&gt; при использовании в любом контексте, кроме &lt;code&gt;sizeof&lt;/code&gt; , &lt;code&gt;_Alignof&lt;/code&gt; , оператора address-of или инициализации массива из строкового литерала.</target>
        </trans-unit>
        <trans-unit id="5d8c9bcb6d816c1a8ecd0a37069f05536bd2ec31" translate="yes" xml:space="preserve">
          <source>If an object representation does not represent any value of the object type, it is known as</source>
          <target state="translated">Если объектное представление не представляет какого-либо значения типа объекта,то оно известно как</target>
        </trans-unit>
        <trans-unit id="c820dc8c26d3db1ef814640861c6f3807e6c1ba5" translate="yes" xml:space="preserve">
          <source>If an object's alignment is made stricter (larger) than &lt;code&gt;&lt;a href=&quot;../types/max_align_t&quot;&gt;max_align_t&lt;/a&gt;&lt;/code&gt; using &lt;a href=&quot;alignas&quot;&gt;alignas&lt;/a&gt;, it has</source>
          <target state="translated">Если выравнивание объекта делается более строгим (большим), чем &lt;code&gt;&lt;a href=&quot;../types/max_align_t&quot;&gt;max_align_t&lt;/a&gt;&lt;/code&gt; с использованием &lt;a href=&quot;alignas&quot;&gt;alignas&lt;/a&gt; , оно имеет</target>
        </trans-unit>
        <trans-unit id="acd0f2effed8427de550d8d6b990c3718b9b3c16" translate="yes" xml:space="preserve">
          <source>If any of the arguments for the generic parameters is &lt;code&gt;long double&lt;/code&gt;, then the &lt;code&gt;long double&lt;/code&gt; variant is called. Otherwise, if any of the arguments for the generic parameters is &lt;code&gt;double&lt;/code&gt;, then the &lt;code&gt;double&lt;/code&gt; variant is called. Otherwise, &lt;code&gt;float&lt;/code&gt; variant is called.</source>
          <target state="translated">Если какой-либо из аргументов для общих параметров является &lt;code&gt;long double&lt;/code&gt; , то вызывается &lt;code&gt;long double&lt;/code&gt; вариант. В противном случае, если какой-либо из аргументов для общих параметров является &lt;code&gt;double&lt;/code&gt; , тогда вызывается &lt;code&gt;double&lt;/code&gt; вариант. В противном случае, &lt;code&gt;float&lt;/code&gt; вариант называется.</target>
        </trans-unit>
        <trans-unit id="562e239709bc35b2b379032b89448978ab95efc0" translate="yes" xml:space="preserve">
          <source>If any of the arguments for the generic parameters is &lt;code&gt;long double&lt;/code&gt;, then the &lt;code&gt;long double&lt;/code&gt; variant is called. Otherwise, if any of the parameters is &lt;code&gt;double&lt;/code&gt; or integer, then the &lt;code&gt;double&lt;/code&gt; variant is called. Otherwise, &lt;code&gt;float&lt;/code&gt; variant is called.</source>
          <target state="translated">Если какой-либо из аргументов для общих параметров является &lt;code&gt;long double&lt;/code&gt; , то вызывается &lt;code&gt;long double&lt;/code&gt; вариант. В противном случае, если какой-либо из параметров является &lt;code&gt;double&lt;/code&gt; или целым, вызывается &lt;code&gt;double&lt;/code&gt; вариант. В противном случае, &lt;code&gt;float&lt;/code&gt; вариант называется.</target>
        </trans-unit>
        <trans-unit id="ec78132e6099d16c4819b148849342ed77f805bd" translate="yes" xml:space="preserve">
          <source>If any of the arguments for the generic parameters is complex, then the complex function is called, otherwise the real function is called.</source>
          <target state="translated">Если любой из аргументов для общих параметров является сложным,то вызывается сложная функция,в противном случае вызывается реальная функция.</target>
        </trans-unit>
        <trans-unit id="79b55232ba96a3bd42fd8dd7103363973985e2a1" translate="yes" xml:space="preserve">
          <source>If any of the arguments for the generic parameters is imaginary, the behavior is specified on each function reference page individually (in particular, sin, cos, tag, cosh, sinh, tanh, asin, atan, asinh, and atanh call</source>
          <target state="translated">Если любой из аргументов для общих параметров является воображаемым,поведение указывается на каждой странице ссылок на функцию индивидуально (в частности,sin,cos,tag,cosh,sinh,tanh,asin,atanh,asinh и atanh call</target>
        </trans-unit>
        <trans-unit id="7f56fd154648f3d8467222c29490c068976fd45a" translate="yes" xml:space="preserve">
          <source>If any of the arguments for the generic parameters is real, complex, or imaginary, then the appropriate complex function is called.</source>
          <target state="translated">Если любой из аргументов для общих параметров является реальным,сложным или воображаемым,то вызывается соответствующая комплексная функция.</target>
        </trans-unit>
        <trans-unit id="9059699e445e938e899ba841bbdc2815187e8516" translate="yes" xml:space="preserve">
          <source>If any part of a declarator is a &lt;a href=&quot;array&quot;&gt;VLA array&lt;/a&gt; declarator, the entire declarator's type is known as &quot;variably-modified type&quot;. Types defined from variably-modified types are also variably modified (VM).</source>
          <target state="translated">Если какая-либо часть декларатора является декларатором &lt;a href=&quot;array&quot;&gt;массива VLA&lt;/a&gt; , весь тип декларатора известен как &amp;laquo;изменяемый тип&amp;raquo;. Типы, определенные из переменных типов, также могут быть изменены (VM).</target>
        </trans-unit>
        <trans-unit id="41cd76f0d575b7b9cd5e0fd684bb28b73c4dd854" translate="yes" xml:space="preserve">
          <source>If any subobject is explicitly initialized twice (which may happen when designators are used), the initializer that appears later in the list is the one used (the earlier initializer may not be evaluated):</source>
          <target state="translated">Если какой-либо подобъект инициализируется дважды (что может произойти при использовании обозначений),то используется инициализатор,который появится позже в списке (более ранний инициализатор может не вычисляться):</target>
        </trans-unit>
        <trans-unit id="08759afad939001ce25641ffda80dd6d474e5c10" translate="yes" xml:space="preserve">
          <source>If arg is NaN, NaN is returned</source>
          <target state="translated">Если аргумент-NaN,то NaN возвращается.</target>
        </trans-unit>
        <trans-unit id="9d7eda972ce3fcd7bac7edeebd6987d2d5448884" translate="yes" xml:space="preserve">
          <source>If both operands have &lt;a href=&quot;arithmetic_types&quot;&gt;arithmetic types&lt;/a&gt;, then.</source>
          <target state="translated">Если оба операнда имеют &lt;a href=&quot;arithmetic_types&quot;&gt;арифметические типы&lt;/a&gt; , то.</target>
        </trans-unit>
        <trans-unit id="65568841562f35d225fc26d418379905f6cfe94d" translate="yes" xml:space="preserve">
          <source>If both the converted value and the precision are &lt;code&gt;​0​&lt;/code&gt; the conversion results in no characters.</source>
          <target state="translated">Если оба преобразованное значение и точность являются &lt;code&gt;​0​&lt;/code&gt; результаты преобразования в каких - либо символов.</target>
        </trans-unit>
        <trans-unit id="aa56eddeecaa652e74ddca2ef43579a7b00a26ad" translate="yes" xml:space="preserve">
          <source>If both the remainder and the quotient can be represented as objects of the corresponding type (int, long, long long, imaxdiv_t, respectively), returns both as an object of type &lt;code&gt;div_t&lt;/code&gt;, &lt;code&gt;ldiv_t&lt;/code&gt;, &lt;code&gt;lldiv_t&lt;/code&gt;, &lt;code&gt;imaxdiv_t&lt;/code&gt; defined as follows:</source>
          <target state="translated">Если и остаток, и частное могут быть представлены как объекты соответствующего типа (int, long, long long, imaxdiv_t соответственно), возвращает оба как объект типа &lt;code&gt;div_t&lt;/code&gt; , &lt;code&gt;ldiv_t&lt;/code&gt; , &lt;code&gt;lldiv_t&lt;/code&gt; , &lt;code&gt;imaxdiv_t&lt;/code&gt; , определенный следующим образом:</target>
        </trans-unit>
        <trans-unit id="504c354c4217916940c16491f303887d6d786f1c" translate="yes" xml:space="preserve">
          <source>If both types are array types, the following rules are applied:</source>
          <target state="translated">Если оба типа являются типами массивов,то применяются следующие правила:</target>
        </trans-unit>
        <trans-unit id="9300681f14311ef1308fff428de5207f181878fe" translate="yes" xml:space="preserve">
          <source>If both types are function types with parameter type lists, the type of each parameter in the composite parameter type list is the composite type of the corresponding parameters.</source>
          <target state="translated">Если оба типа являются типами функций со списками типов параметров,то тип каждого параметра в сводном списке типов параметров является составным типом соответствующих параметров.</target>
        </trans-unit>
        <trans-unit id="0a9f1e1eed77a46edb55388fc632deb4ed555ebd" translate="yes" xml:space="preserve">
          <source>If command is a null pointer, checks if the host environment has a command processor and returns a nonzero value if and only if the command processor exists.</source>
          <target state="translated">Если команда является нулевым указателем,проверяет,есть ли в среде хоста командный процессор,и возвращает ненулевое значение,если и только если командный процессор существует.</target>
        </trans-unit>
        <trans-unit id="28cefa0e9741f616b6f6233c4b91926613432287" translate="yes" xml:space="preserve">
          <source>If control over &lt;code&gt;&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is needed in floating-to-integer conversions, &lt;code&gt;&lt;a href=&quot;../numeric/math/rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../numeric/math/nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt; may be used.</source>
          <target state="translated">Если контроль над &lt;code&gt;&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; необходим в преобразованиях с плавающей запятой в целочисленные, может использоваться &lt;code&gt;&lt;a href=&quot;../numeric/math/rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../numeric/math/nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="192b44dddfe8a0edbf403637b9dc082e8fcbccab" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;x&lt;/code&gt; is NaN or &lt;code&gt;y&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен NaN или &lt;code&gt;y&lt;/code&gt; равен NaN, возвращается NaN</target>
        </trans-unit>
        <trans-unit id="5798cb4e0bd7a6d21c2a60a89c9c101a7f709c34" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; или &lt;code&gt;y&lt;/code&gt; равен NaN, возвращается NaN</target>
        </trans-unit>
        <trans-unit id="b1b8d9bd67fa1ccf8414b0062f383f3be7b83851" translate="yes" xml:space="preserve">
          <source>If either argument is NaN, NaN is returned</source>
          <target state="translated">Если любой из аргументов-NaN,возвращается NaN.</target>
        </trans-unit>
        <trans-unit id="4facc3a3dde5ddbefb08336856d6b20eb05ed6dc" translate="yes" xml:space="preserve">
          <source>If either the remainder or the quotient cannot be represented, the behavior is undefined.</source>
          <target state="translated">Если ни остаток,ни коэффициент не могут быть представлены,поведение не определено.</target>
        </trans-unit>
        <trans-unit id="fdb29cf682870c157ecc255b61896ebcf0dd8877" translate="yes" xml:space="preserve">
          <source>If enumerator is followed by = constant-expression, its value is the value of that constant expression. If enumerator is not followed by = constant-expression, its value is the value one greater than the value of the previous enumerator in the same enumeration. The value of the first enumerator (if it does not use = constant-expression) is zero.</source>
          <target state="translated">Если за числителем следует=константное выражение,то его значение является значением этого константного выражения.Если за указателем не следует выражение=константа,то его значением является значение на единицу больше,чем значение предыдущего указателя в том же перечислении.Значение первого перечисления (если он не использует=константное выражение)равно нулю.</target>
        </trans-unit>
        <trans-unit id="c1a30ffdb8b054f4f5efa04e804183bab7b8f87d" translate="yes" xml:space="preserve">
          <source>If evaluation A is sequenced before evaluation B, then evaluation of A will be complete before evaluation of B begins.</source>
          <target state="translated">Если оценка A выполняется последовательно перед оценкой B,то оценка A будет завершена до начала оценки B.</target>
        </trans-unit>
        <trans-unit id="360528c544120ebe32f7b7cd67e035fb9e4b4a51" translate="yes" xml:space="preserve">
          <source>If expression compares not equal to the integer zero, statement_true is executed.</source>
          <target state="translated">Если выражение сравнивается не с целым нулем,то выполняется оператор statement_true.</target>
        </trans-unit>
        <trans-unit id="fbb388918567059a7ef91b0bac2e600518001881" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a value that doesn't match any of the &lt;code&gt;case:&lt;/code&gt; labels, and the &lt;code&gt;default:&lt;/code&gt; label is not present, none of the switch body is executed.</source>
          <target state="translated">Если выражение оценивается как значение, которое не соответствует ни одному из &lt;code&gt;case:&lt;/code&gt; метки, а значение &lt;code&gt;default:&lt;/code&gt; метка отсутствует, тело переключателя не выполняется.</target>
        </trans-unit>
        <trans-unit id="aa83991d8493cfe779ea779356df33a31e5bb405" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a value that doesn't match any of the &lt;code&gt;case:&lt;/code&gt; labels, and the &lt;code&gt;default:&lt;/code&gt; label is present, control is transferred to the statement labeled with the &lt;code&gt;default:&lt;/code&gt; label.</source>
          <target state="translated">Если выражение оценивается как значение, которое не соответствует ни одному из &lt;code&gt;case:&lt;/code&gt; label, и присутствует &lt;code&gt;default:&lt;/code&gt; label, управление передается в оператор, помеченный &lt;code&gt;default:&lt;/code&gt; label.</target>
        </trans-unit>
        <trans-unit id="6faa6fc85532e8604df80b963c664490b88079fd" translate="yes" xml:space="preserve">
          <source>If expression evaluates to the value that is equal to the value of one of constant_expressions after conversion to the promoted type of expression, then control is transferred to the statement that is labeled with that constant_expression.</source>
          <target state="translated">Если после приведения к раскрученному типу выражения выражение вычисляется до значения,равного значению одного из выражений константы_выражения,то управление передается оператору,помеченному этим выражением константы_выражения.</target>
        </trans-unit>
        <trans-unit id="334783c8d779e32d80f5e33d41aa548e3861ef1e" translate="yes" xml:space="preserve">
          <source>If expression evaluates to zero, this specifier has no effect.</source>
          <target state="translated">Если выражение вычисляется до нуля,то этот спецификатор не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="812257c713ec48ffa717a1e22cfeb0579763c024" translate="yes" xml:space="preserve">
          <source>If expression in an array declarator is an &lt;a href=&quot;constant_expression#Integer_constant_expression&quot;&gt;integer constant expression&lt;/a&gt; with a value greater than zero and the element type is a type with a known constant size (that is, elements are not VLA)(since C99), then the declarator declares an array of constant known size:</source>
          <target state="translated">Если выражение в объявителе массива представляет собой &lt;a href=&quot;constant_expression#Integer_constant_expression&quot;&gt;целочисленное константное выражение&lt;/a&gt; со значением больше нуля, а тип элемента - это тип с известным постоянным размером (то есть элементы не являются VLA) (начиная с C99), тогда декларатор объявляет массив постоянный известный размер:</target>
        </trans-unit>
        <trans-unit id="8ba6da87ee9a243a839b16d19baf884836288808" translate="yes" xml:space="preserve">
          <source>If expression in an array declarator is omitted, it declares an array of unknown size. Except in function parameter lists (where such arrays are transformed to pointers) and when an &lt;a href=&quot;array_initialization&quot;&gt;initializer&lt;/a&gt; is available, such type is an &lt;a href=&quot;compatible_type#Incomplete_types&quot;&gt;incomplete type&lt;/a&gt; (note that VLA of unspecified size, declared with &lt;code&gt;*&lt;/code&gt; as the size, is a complete type)(since C99):</source>
          <target state="translated">Если выражение в объявителе массива опущено, оно объявляет массив неизвестного размера. За исключением списков параметров функции (где такие массивы преобразуются в указатели) и когда доступен &lt;a href=&quot;array_initialization&quot;&gt;инициализатор&lt;/a&gt; , такой тип является &lt;a href=&quot;compatible_type#Incomplete_types&quot;&gt;неполным типом&lt;/a&gt; (обратите внимание, что VLA неопределенного размера, объявленный с &lt;code&gt;*&lt;/code&gt; в качестве размера, является полным типом) (начиная с C99 ):</target>
        </trans-unit>
        <trans-unit id="fdf07733d3563d8385b8f445a3649648c5f3b8c5" translate="yes" xml:space="preserve">
          <source>If expression is not an &lt;a href=&quot;constant_expression#Integer_constant_expression&quot;&gt;integer constant expression&lt;/a&gt;, the declarator is for an array of variable size.</source>
          <target state="translated">Если выражение не является &lt;a href=&quot;constant_expression#Integer_constant_expression&quot;&gt;целочисленным константным выражением&lt;/a&gt; , декларатор предназначен для массива переменного размера.</target>
        </trans-unit>
        <trans-unit id="e2a210c65a0f6c3811043fd43a33ea0aeafeba4c" translate="yes" xml:space="preserve">
          <source>If it is an expression, it is evaluated once, before the first evaluation of cond_expression and its result is discarded.</source>
          <target state="translated">Если это выражение,то оно вычисляется один раз,до первой оценки выражения cond_expression,и его результат отбрасывается.</target>
        </trans-unit>
        <trans-unit id="a1527a6f74ffff1d191859da84a0b12635390d9d" translate="yes" xml:space="preserve">
          <source>If lhs and rhs are expressions of any &lt;a href=&quot;types&quot;&gt;real type&lt;/a&gt;, then.</source>
          <target state="translated">Если lhs и rhs являются выражениями любого &lt;a href=&quot;types&quot;&gt;реального типа&lt;/a&gt; , то.</target>
        </trans-unit>
        <trans-unit id="dab84ea7417a8449e8e53aefe0bfd270462902ff" translate="yes" xml:space="preserve">
          <source>If lhs and rhs are expressions of pointer type, they must be both pointers to objects of &lt;a href=&quot;types#Compatible_types&quot;&gt;compatible types&lt;/a&gt;, except that qualifications of the pointed-to objects are ignored.</source>
          <target state="translated">Если lhs и rhs являются выражениями типа указателя, они должны быть оба указателями на объекты &lt;a href=&quot;types#Compatible_types&quot;&gt;совместимых типов&lt;/a&gt; , за исключением того, что квалификации указанных объектов игнорируются.</target>
        </trans-unit>
        <trans-unit id="7bb0fe233a8db1c5731305199a741e53a04ba01b" translate="yes" xml:space="preserve">
          <source>If lhs has &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt; type, the operation behaves as a single atomic read-modify-write operation with memory order &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если lhs имеет &lt;a href=&quot;atomic&quot;&gt;атомарный&lt;/a&gt; тип, операция ведет себя как отдельная атомарная операция чтения-изменения-записи с порядком памяти &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc7031518acd1f816f49dabf6745ea7fa65d3428" translate="yes" xml:space="preserve">
          <source>If lineno is 0 or greater than 32767(until C99)2147483647(since C99), the behavior is undefined.</source>
          <target state="translated">Если lineno 0 или больше 32767(до C99)2147483647(после C99),поведение не определено.</target>
        </trans-unit>
        <trans-unit id="edd868dcc474e443c25a49132bd6419f1abf7cca" translate="yes" xml:space="preserve">
          <source>If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">Если преобразование не может быть выполнено, &lt;code&gt;​0​&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="530f889d2ad8b60ee918f8e2702b7883b29fb175" translate="yes" xml:space="preserve">
          <source>If no errors occur earg</source>
          <target state="translated">Если ошибки не случаются,уши</target>
        </trans-unit>
        <trans-unit id="a4b69264dcfdc184105c0c5fcdc54a8a79767399" translate="yes" xml:space="preserve">
          <source>If no errors occur ln(1+arg) is returned.</source>
          <target state="translated">При отсутствии ошибок возвращается ln(1+arg).</target>
        </trans-unit>
        <trans-unit id="f3037fe820d838daa891fb3539a8329f215061a7" translate="yes" xml:space="preserve">
          <source>If no errors occur,</source>
          <target state="translated">Если ошибок не происходит,</target>
        </trans-unit>
        <trans-unit id="602f32de7c64c4861f4c15f4a272e41e4cf03cae" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;arg&lt;/code&gt; multiplied by 2 to the power of &lt;code&gt;exp&lt;/code&gt; (arg&amp;times;2exp</source>
          <target state="translated">Если ошибок нет, &lt;code&gt;arg&lt;/code&gt; умножается на 2 до степени &lt;code&gt;exp&lt;/code&gt; (arg &amp;times; 2exp</target>
        </trans-unit>
        <trans-unit id="fd6ab22732d33f90243d40ac0149ac1bffd11661" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;arg&lt;/code&gt; multiplied by &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; to the power of &lt;code&gt;exp&lt;/code&gt; (arg&amp;times;FLT_RADIXexp</source>
          <target state="translated">Если ошибок нет, &lt;code&gt;arg&lt;/code&gt; умножается на &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; до степени &lt;code&gt;exp&lt;/code&gt; (arg &amp;times; FLT_RADIXexp</target>
        </trans-unit>
        <trans-unit id="05313ea76fba59eae28768bcd1ded7d73640a2b9" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;base&lt;/code&gt; raised to the power of &lt;code&gt;exponent&lt;/code&gt; (baseexponent</source>
          <target state="translated">Если ошибок не возникает, &lt;code&gt;base&lt;/code&gt; возводится в степень &lt;code&gt;exponent&lt;/code&gt; (baseexponent</target>
        </trans-unit>
        <trans-unit id="43e9fba55e5f456a3880c2a5f09b14d52ee81371" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc cosine of &lt;code&gt;z&lt;/code&gt; is returned, in the range [0 ; &amp;infin;) along the real axis and in the range [&amp;minus;</source>
          <target state="translated">Если ошибок не возникает, возвращается сложный арккосинус &lt;code&gt;z&lt;/code&gt; в диапазоне [0; &amp;infin;) вдоль вещественной оси и в диапазоне [-</target>
        </trans-unit>
        <trans-unit id="3ba083c7eab3d055b75951c25f225f73acff4188" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc sine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip unbounded along the imaginary axis and in the interval [&amp;minus;&amp;pi;/2; +&amp;pi;/2] along the real axis.</source>
          <target state="translated">Если ошибок не возникает, возвращается сложный синус &lt;code&gt;z&lt;/code&gt; в диапазоне полосы, неограниченной вдоль мнимой оси, и в интервале [&amp;minus;&amp;pi; / 2; + &amp;pi; / 2] вдоль вещественной оси.</target>
        </trans-unit>
        <trans-unit id="e58f6c458633d11255df6ec72e17d6e0e307082c" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc tangent of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip unbounded along the imaginary axis and in the interval [&amp;minus;&amp;pi;/2; +&amp;pi;/2] along the real axis.</source>
          <target state="translated">Если ошибок не возникает, возвращается комплексный арктангенс &lt;code&gt;z&lt;/code&gt; в области полосы, неограниченной вдоль мнимой оси, и в интервале [&amp;minus;&amp;pi; / 2; + &amp;pi; / 2] вдоль вещественной оси.</target>
        </trans-unit>
        <trans-unit id="50a8713f4c4c617bedaa7a390ea195b3329dac1c" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic cosine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается сложный гиперболический косинус &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8e6619163d1ca9fedc0a2bfd79d4c047fbeb277" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic sine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается сложный гиперболический синус &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0204a9004641a330efb33cc1c10a2eb5fe8c95c2" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic tangent of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается комплексный гиперболический тангенс &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6bbf046061401d16d535bc081cfe13e7549ef1e" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the absolute value (norm, magnitude) of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">Если ошибок не возникает, возвращает абсолютное значение (норма, величина) &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7f248bc9527b22f78b886ecb63cf4c8a2bd9c60" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the fractional part of &lt;code&gt;x&lt;/code&gt; with the same sign as &lt;code&gt;x&lt;/code&gt;. The integral part is put into the value pointed to by &lt;code&gt;iptr&lt;/code&gt;.</source>
          <target state="translated">Если ошибок не возникает, возвращает дробную часть &lt;code&gt;x&lt;/code&gt; с тем же знаком, что и &lt;code&gt;x&lt;/code&gt; . Неотъемлемой частью является значение, на которое указывает &lt;code&gt;iptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcbbfc79f2b5b688deb79fcd4d7c358c461e6459" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the phase angle of &lt;code&gt;z&lt;/code&gt; in the interval [&amp;minus;&amp;pi;; &amp;pi;].</source>
          <target state="translated">Если ошибок не возникает, возвращает фазовый угол &lt;code&gt;z&lt;/code&gt; в интервале [&amp;minus;&amp;pi;; &amp;pi;].</target>
        </trans-unit>
        <trans-unit id="af3231d18a9dbafc82193c163f7f7ec4e37b28f7" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the square root of &lt;code&gt;z&lt;/code&gt;, in the range of the right half-plane, including the imaginary axis ([0; +&amp;infin;) along the real axis and (&amp;minus;&amp;infin;; +&amp;infin;) along the imaginary axis.).</source>
          <target state="translated">Если ошибок не возникает, возвращает квадратный корень из &lt;code&gt;z&lt;/code&gt; в диапазоне правой полуплоскости, включая мнимую ось ([0; + &amp;infin;) вдоль действительной оси и (&amp;minus;&amp;infin;; + &amp;infin;) вдоль мнимой оси. ).</target>
        </trans-unit>
        <trans-unit id="ee22b5df48ca25af069416a0b6aead9e8cfe0766" translate="yes" xml:space="preserve">
          <source>If no errors occur, square root of &lt;code&gt;arg&lt;/code&gt; (&amp;radic;arg), is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается квадратный корень из &lt;code&gt;arg&lt;/code&gt; (&amp;radic;arg).</target>
        </trans-unit>
        <trans-unit id="9a9c8867b079f9f036564e75c55c95fbeddad36f" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc cosine of &lt;code&gt;arg&lt;/code&gt; (arccos(arg)) in the range [0 ; &amp;pi;], is returned.</source>
          <target state="translated">Если ошибок не возникает, арккосинус &lt;code&gt;arg&lt;/code&gt; (arccos (arg)) в диапазоне [0; &amp;pi;], возвращается.</target>
        </trans-unit>
        <trans-unit id="039d32b1f2e5bfee4ca5736c63a4206e5274388e" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc sine of &lt;code&gt;arg&lt;/code&gt; (arcsin(arg)) in the range [-</source>
          <target state="translated">Если ошибок не возникает, дуга синуса &lt;code&gt;arg&lt;/code&gt; (arcsin (arg)) в диапазоне [-</target>
        </trans-unit>
        <trans-unit id="b32613c8b978beac62c696ce2bd93a54bd237edb" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc tangent of &lt;code&gt;arg&lt;/code&gt; (arctan(arg)) in the range [-</source>
          <target state="translated">Если ошибок не возникает, арктангенс &lt;code&gt;arg&lt;/code&gt; (arctan (arg)) находится в диапазоне [-</target>
        </trans-unit>
        <trans-unit id="c938da3a42fe0590b15c6f8539ff408d3a3b97dd" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc tangent of &lt;code&gt;y/x&lt;/code&gt; (arctan(</source>
          <target state="translated">Если ошибок не возникает, арктангенс &lt;code&gt;y/x&lt;/code&gt; (arctan (</target>
        </trans-unit>
        <trans-unit id="9d5986c54dce11e1cd1599414757016de12c5f01" translate="yes" xml:space="preserve">
          <source>If no errors occur, the base-</source>
          <target state="translated">Если ошибок не возникает,то база -</target>
        </trans-unit>
        <trans-unit id="be331ea28ae7c2d7b9acf97860d316fce4b87723" translate="yes" xml:space="preserve">
          <source>If no errors occur, the common (base-</source>
          <target state="translated">Если ошибок не возникает,то общая (базовая -</target>
        </trans-unit>
        <trans-unit id="05909577ff3329b64c179e57f5f18c51d7427016" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic sine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip mathematically unbounded along the real axis and in the interval [&amp;minus;i&amp;pi;/2; +i&amp;pi;/2] along the imaginary axis.</source>
          <target state="translated">Если ошибок не возникает, возвращается комплексный дуговой гиперболический синус &lt;code&gt;z&lt;/code&gt; в области полосы, математически неограниченной вдоль вещественной оси и в интервале [&amp;minus;i&amp;pi; / 2; + i&amp;pi; / 2] вдоль мнимой оси.</target>
        </trans-unit>
        <trans-unit id="5e1faa126d0291e9222a13afce04bd8eb0c0cbd7" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic tangent of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a half-strip mathematically unbounded along the real axis and in the interval [&amp;minus;i&amp;pi;/2; +i&amp;pi;/2] along the imaginary axis.</source>
          <target state="translated">Если ошибок не возникает, возвращается комплексная дуговая гиперболическая касательная &lt;code&gt;z&lt;/code&gt; , в диапазоне полуполосы, математически неограниченной вдоль вещественной оси и в интервале [&amp;minus;i&amp;pi; / 2; + i&amp;pi; / 2] вдоль мнимой оси.</target>
        </trans-unit>
        <trans-unit id="b951e541cea44c28eafdd9c54b7c32c1392530f6" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex cosine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается сложный косинус &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0170daad51b40b50ab797fcf5f22cc95ede3feb" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex natural logarithm of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip in the interval [&amp;minus;i&amp;pi;, +i&amp;pi;] along the imaginary axis and mathematically unbounded along the real axis.</source>
          <target state="translated">Если ошибок не возникает, возвращается комплексный натуральный логарифм &lt;code&gt;z&lt;/code&gt; в области полосы в интервале [&amp;minus;i&amp;pi;, + i&amp;pi;] вдоль мнимой оси и математически неограниченной вдоль вещественной оси.</target>
        </trans-unit>
        <trans-unit id="e80a11cce80b4f8332e379e29bcd184e31b6ff47" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex power xy</source>
          <target state="translated">Если ошибки не возникнут,то сложная мощность xy</target>
        </trans-unit>
        <trans-unit id="5a78d2dc104a241c9b7f8248a90bd60175e723dc" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex sine of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">Если ошибок не возникает, сложный синус &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f171b9589d9359bfb44bdfa881b4ee93ea77d0c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex tangent of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается комплексный тангенс &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35bd7abdcb7f0220128fd880299baf801952dc19" translate="yes" xml:space="preserve">
          <source>If no errors occur, the cosine of &lt;code&gt;arg&lt;/code&gt; (cos(arg)) in the range [-1 ; +1], is returned.</source>
          <target state="translated">Если ошибок не возникает, косинус &lt;code&gt;arg&lt;/code&gt; (cos (arg)) в диапазоне [-1; +1], возвращается.</target>
        </trans-unit>
        <trans-unit id="ff16f514ad4d462d31d6524ed4ea84f4f6bcb390" translate="yes" xml:space="preserve">
          <source>If no errors occur, the cubic root of &lt;code&gt;arg&lt;/code&gt; (3&amp;radic;arg), is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается кубический корень &lt;code&gt;arg&lt;/code&gt; (3&amp;radic;arg).</target>
        </trans-unit>
        <trans-unit id="1e33cd84b874596d38519b6f05a2e60c9accef6b" translate="yes" xml:space="preserve">
          <source>If no errors occur, the floating point value with the magnitude of &lt;code&gt;x&lt;/code&gt; and the sign of &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается значение с плавающей запятой с величиной &lt;code&gt;x&lt;/code&gt; и знаком &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29635dc5075be505f22d8b338419ce3b116238e5" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt; (cosh(arg), or</source>
          <target state="translated">Если ошибок не возникает, то гиперболический косинус &lt;code&gt;arg&lt;/code&gt; (cosh (arg) или</target>
        </trans-unit>
        <trans-unit id="084419061d5d22eb194084f72eb3bc99faee2d80" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic sine of &lt;code&gt;arg&lt;/code&gt; (sinh(arg), or</source>
          <target state="translated">Если ошибок не возникает, то гиперболический синус &lt;code&gt;arg&lt;/code&gt; (sinh (arg) или</target>
        </trans-unit>
        <trans-unit id="fde1a5cab1da9385208df6463481d983b8d198b8" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt; (tanh(arg), or</source>
          <target state="translated">Если ошибок не возникает, используется гиперболический тангенс &lt;code&gt;arg&lt;/code&gt; (tanh (arg) или</target>
        </trans-unit>
        <trans-unit id="146d272bae4916411520863aa03f483db24f1cd9" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hypotenuse of a right-angled triangle, &amp;radic;x2</source>
          <target state="translated">Если ошибок нет, то гипотенуза прямоугольного треугольника &amp;radic;x2</target>
        </trans-unit>
        <trans-unit id="3870fee396c73bbc1aab8cee4f9a85c1179be025" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt; (cosh-1</source>
          <target state="translated">Если ошибок не возникает, обратный гиперболический косинус &lt;code&gt;arg&lt;/code&gt; (cosh-1</target>
        </trans-unit>
        <trans-unit id="c5db26fbae61f4e34cf5287ffaa5a9d47e53259d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic sine of &lt;code&gt;arg&lt;/code&gt; (sinh-1</source>
          <target state="translated">Если ошибок не возникает, обратный гиперболический синус &lt;code&gt;arg&lt;/code&gt; (sinh-1</target>
        </trans-unit>
        <trans-unit id="f93099d7063e1d7a83038ac66c3c5233ba5f6ece" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt; (tanh-1</source>
          <target state="translated">Если ошибок не возникает, обратный гиперболический тангенс &lt;code&gt;arg&lt;/code&gt; (tanh-1</target>
        </trans-unit>
        <trans-unit id="d4744dace8417a9d2afa9a3795c780e70495855c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the largest integer value not greater than &lt;code&gt;arg&lt;/code&gt;, that is &amp;lfloor;arg&amp;rfloor;, is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается наибольшее целочисленное значение, не превышающее &lt;code&gt;arg&lt;/code&gt; , то есть &amp;laquo;arg&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="3007ffc0d3f619ed4878713babc6bf385e75ed5b" translate="yes" xml:space="preserve">
          <source>If no errors occur, the natural (base-</source>
          <target state="translated">Если ошибки не возникают,то естественные (базовые -</target>
        </trans-unit>
        <trans-unit id="f127780bac10fbde3e943c6286123dc5c825a17d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value not greater in magnitude than &lt;code&gt;arg&lt;/code&gt; (in other words, &lt;code&gt;arg&lt;/code&gt; rounded towards zero), is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается ближайшее целочисленное значение, не большее по величине, чем &lt;code&gt;arg&lt;/code&gt; (другими словами, &lt;code&gt;arg&lt;/code&gt; , округленное до нуля).</target>
        </trans-unit>
        <trans-unit id="f769b27b09219929833064428bef0734a24648aa" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value to &lt;code&gt;arg&lt;/code&gt;, according to the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;, is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается ближайшее целочисленное значение &lt;code&gt;arg&lt;/code&gt; в соответствии с &lt;a href=&quot;../fenv/fe_round&quot;&gt;текущим режимом округления&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a0256d4c5a80036d6bc9fdb716345ed55c66ea11" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value to &lt;code&gt;arg&lt;/code&gt;, rounding halfway cases away from zero, is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается ближайшее целочисленное значение к &lt;code&gt;arg&lt;/code&gt; , округляющее половину случаев до нуля.</target>
        </trans-unit>
        <trans-unit id="695de1cc17da5f42bb05163df84a4d86f843cb06" translate="yes" xml:space="preserve">
          <source>If no errors occur, the next representable value of &lt;code&gt;from&lt;/code&gt; in the direction of &lt;code&gt;to&lt;/code&gt;. is returned. If &lt;code&gt;from&lt;/code&gt; equals &lt;code&gt;to&lt;/code&gt;, then &lt;code&gt;to&lt;/code&gt; is returned, converted to the type of the function.</source>
          <target state="translated">Если ошибок не возникает, следующее представимое значение &lt;code&gt;from&lt;/code&gt; в направлении &lt;code&gt;to&lt;/code&gt; . возвращается Если &lt;code&gt;from&lt;/code&gt; равных &lt;code&gt;to&lt;/code&gt; , а затем &lt;code&gt;to&lt;/code&gt; возвращается, преобразуется в тип функции.</target>
        </trans-unit>
        <trans-unit id="d0a7b391baa86594c7d0448266a28acb2668a4e8" translate="yes" xml:space="preserve">
          <source>If no errors occur, the sine of &lt;code&gt;arg&lt;/code&gt; (sin(arg)) in the range [-1 ; +1], is returned.</source>
          <target state="translated">Если ошибок не возникает, синус &lt;code&gt;arg&lt;/code&gt; (sin (arg)) в диапазоне [-1; +1], возвращается.</target>
        </trans-unit>
        <trans-unit id="3fa7223cf61583336068c9d91991b4f9bedf8c7c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the smallest integer value not less than &lt;code&gt;arg&lt;/code&gt;, that is &amp;lceil;arg&amp;rceil;, is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается наименьшее целочисленное значение не менее &lt;code&gt;arg&lt;/code&gt; , то есть &amp;laquo;arg&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="941693082c1c679c39e6797e593c1a748bca9744" translate="yes" xml:space="preserve">
          <source>If no errors occur, the tangent of &lt;code&gt;arg&lt;/code&gt; (tan(arg)) is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается тангенс &lt;code&gt;arg&lt;/code&gt; (tan (arg)).</target>
        </trans-unit>
        <trans-unit id="8e15bc85bb52009c88f5c69e56b9a2471d950454" translate="yes" xml:space="preserve">
          <source>If no errors occur, the unbiased exponent of &lt;code&gt;arg&lt;/code&gt; is returned as a signed floating-point value.</source>
          <target state="translated">Если ошибок не возникает, несмещенный показатель &lt;code&gt;arg&lt;/code&gt; возвращается как подписанное значение с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="026d1df8b0b132c32fe387fe762cb8d1ea884358" translate="yes" xml:space="preserve">
          <source>If no errors occur, the unbiased exponent of &lt;code&gt;arg&lt;/code&gt; is returned as a signed int value.</source>
          <target state="translated">Если ошибок не возникает, несмещенный показатель &lt;code&gt;arg&lt;/code&gt; возвращается как значение типа int со знаком.</target>
        </trans-unit>
        <trans-unit id="4ea26e0ca3f1790b6251b6744a4aeb9155a7a728" translate="yes" xml:space="preserve">
          <source>If no errors occur, the value of the gamma function of &lt;code&gt;arg&lt;/code&gt;, that is &amp;int;&amp;infin;</source>
          <target state="translated">Если ошибок не возникает, значение гамма-функции &lt;code&gt;arg&lt;/code&gt; , то есть &amp;int;&amp;infin;</target>
        </trans-unit>
        <trans-unit id="17f4ff9a3637589c23bfc0b873e96c8630ea5296" translate="yes" xml:space="preserve">
          <source>If no errors occur, the value of the logarithm of the gamma function of &lt;code&gt;arg&lt;/code&gt;, that is log</source>
          <target state="translated">Если ошибок не возникает, значение логарифма гамма-функции &lt;code&gt;arg&lt;/code&gt; , то есть log</target>
        </trans-unit>
        <trans-unit id="7f29a8300bf4d8be194d411485092bca1cff89a5" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complementary error function of &lt;code&gt;arg&lt;/code&gt;, that is</source>
          <target state="translated">Если ошибок не возникает, значение дополнительной функции ошибок &lt;code&gt;arg&lt;/code&gt; , то есть</target>
        </trans-unit>
        <trans-unit id="0658bf24f8b1dde223e35183fc409335d58b1a45" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the error function of &lt;code&gt;arg&lt;/code&gt;, that is</source>
          <target state="translated">Если ошибок не возникает, значение функции ошибок &lt;code&gt;arg&lt;/code&gt; , то есть</target>
        </trans-unit>
        <trans-unit id="f33a26f2411f41973ee89bb92c9912299b6bf3fb" translate="yes" xml:space="preserve">
          <source>If no side effects are produced by an expression and the compiler can determine that the value is not used, the expression &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=c/language/as-if&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;may not be evaluated&lt;/a&gt;.</source>
          <target state="translated">Если выражение не вызывает побочных эффектов и компилятор может определить, что значение не используется, выражение &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=c/language/as-if&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;может не оцениваться&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="24607f8eda85840327155f9c5dd479383c4c0709" translate="yes" xml:space="preserve">
          <source>If no storage-class specifier is provided, the defaults are:</source>
          <target state="translated">Если спецификатор класса хранения не указан,то по умолчанию:</target>
        </trans-unit>
        <trans-unit id="a4dfeb978fa33ed93ba2c224367f2086d951f30e" translate="yes" xml:space="preserve">
          <source>If no such character was found, &lt;code&gt;str&lt;/code&gt; has only one token, and future calls to &lt;code&gt;strtok&lt;/code&gt; will return a null pointer</source>
          <target state="translated">Если такой символ не был найден, &lt;code&gt;str&lt;/code&gt; имеет только один токен, и будущие вызовы &lt;code&gt;strtok&lt;/code&gt; вернут нулевой указатель</target>
        </trans-unit>
        <trans-unit id="e0e3f85b21f0603ccfad7c7630e2e6165f6efad1" translate="yes" xml:space="preserve">
          <source>If no such character was found, there are no tokens in &lt;code&gt;str&lt;/code&gt; at all, and the function returns a null pointer.</source>
          <target state="translated">Если такого символа не найдено, токенов в &lt;code&gt;str&lt;/code&gt; нет вообще, и функция возвращает нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="1a104ff8f617c8217bce63f3debd82c29c77289d" translate="yes" xml:space="preserve">
          <source>If no such wide character was found, &lt;code&gt;str&lt;/code&gt; has only one token, and future calls to &lt;code&gt;wcstok&lt;/code&gt; will return a null pointer</source>
          <target state="translated">Если такой широкий символ не был найден, &lt;code&gt;str&lt;/code&gt; имеет только один токен, и будущие вызовы &lt;code&gt;wcstok&lt;/code&gt; вернут нулевой указатель</target>
        </trans-unit>
        <trans-unit id="d9fb4aef6036de9d69cd4d033e352d979c405074" translate="yes" xml:space="preserve">
          <source>If no such wide character was found, there are no tokens in &lt;code&gt;str&lt;/code&gt; at all, and the function returns a null pointer.</source>
          <target state="translated">Если такой широкий символ не был найден, в &lt;code&gt;str&lt;/code&gt; нет никаких токенов , и функция возвращает нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="e40d2715cf1b46b20775d0bb380629a3585cd758" translate="yes" xml:space="preserve">
          <source>If none of the type-names are compatible with the type of the controlling-expression, and the &lt;code&gt;default&lt;/code&gt; association is provided, then the type, value, and value category of the generic selection are the type, value, and value category of the expression after the &lt;code&gt;default&amp;nbsp;:&lt;/code&gt; label.</source>
          <target state="translated">Если ни одно из имен типов не совместимо с типом управляющего выражения и предусмотрена ассоциация по &lt;code&gt;default&lt;/code&gt; , то типом, значением и категорией значения универсального выбора являются тип, значение и категория значения выражения после &lt;code&gt;default&amp;nbsp;:&lt;/code&gt; по умолчанию: метка.</target>
        </trans-unit>
        <trans-unit id="c9c017ecb96c59470d6de6c8da38e2d13318a236" translate="yes" xml:space="preserve">
          <source>If one literal is unprefixed, the resulting string literal has the width/encoding specified by the prefixed literal. If the two string literals have different encoding prefixes, concatenation is implementation-defined.</source>
          <target state="translated">Если один литерал не зафиксирован,то результирующий строковый литерал имеет ширину/кодировку,заданную префиксным литералом.Если два строковых литерала имеют разные префиксы кодировки,то конкатенация определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="5394cec101ec494404d07198530eec4ab37c59ad" translate="yes" xml:space="preserve">
          <source>If one of the two arguments is NaN, the value of the other argument is returned</source>
          <target state="translated">Если один из двух аргументов является NaN,возвращается значение другого аргумента</target>
        </trans-unit>
        <trans-unit id="deb9997a39b957e2b1d0f67225814173635bd3be" translate="yes" xml:space="preserve">
          <source>If one type is an array of known constant size, the composite type is an array of that size.</source>
          <target state="translated">Если один тип является массивом известного постоянного размера,то составной тип является массивом этого размера.</target>
        </trans-unit>
        <trans-unit id="ff00bc804bf5de0ca28e5fa9b87c6ef3300ee482" translate="yes" xml:space="preserve">
          <source>If only one type is a function type with a parameter type list (a function prototype), the composite type is a function prototype with the parameter type list.</source>
          <target state="translated">Если только один тип является типом функции со списком типов параметров (прототипом функции),то составной тип является прототипом функции со списком типов параметров.</target>
        </trans-unit>
        <trans-unit id="9ddc5ecaabd07bdd4041442caa75864db6c6d691" translate="yes" xml:space="preserve">
          <source>If overflow occurs, the behavior is undefined.</source>
          <target state="translated">Если произойдет переполнение,поведение будет неопределенным.</target>
        </trans-unit>
        <trans-unit id="90421d9a10ca2ecc53b3233d830634266328f1bb" translate="yes" xml:space="preserve">
          <source>If pointer-expression is a pointer to function, the result of the dereference operator is a function designator for that function.</source>
          <target state="translated">Если выражение указателя является указателем на функцию,то результатом оператора разыменования является обозначение функции для этой функции.</target>
        </trans-unit>
        <trans-unit id="fabe0dc46a4e415f07e60b3d1fe73b90609b5485" translate="yes" xml:space="preserve">
          <source>If pointer-expression is a pointer to object, the result is an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; that designates the pointed-to object.</source>
          <target state="translated">Если указатель-выражение является указателем на объект, результатом является &lt;a href=&quot;value_category&quot;&gt;выражение lvalue,&lt;/a&gt; которое обозначает объект, на который указывает указатель.</target>
        </trans-unit>
        <trans-unit id="cd3c561c327326fa9c43dffa8ca731c59ab3fba8" translate="yes" xml:space="preserve">
          <source>If qualifiers are present, they qualify the pointer type to which the array parameter type is transformed:</source>
          <target state="translated">Если присутствуют классификаторы,то они определяют тип указателя,к которому преобразуется тип параметра массива:</target>
        </trans-unit>
        <trans-unit id="086dd4d618100274bfcb461ebcb6308c19d4ae3c" translate="yes" xml:space="preserve">
          <source>If rhs and lhs overlap in memory (e.g. they are members of the same union), the behavior is undefined unless the overlap is exact and the types are &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt;.</source>
          <target state="translated">Если rhs и lhs перекрываются в памяти (например, они являются членами одного и того же объединения), поведение не определено, если перекрытие не является точным и типы не &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;совместимы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c28f503fd3f5fe3462baacb1c7312e58c942c2f" translate="yes" xml:space="preserve">
          <source>If some atomic is store-released and several other threads perform read-modify-write operations on that atomic, a &quot;release sequence&quot; is formed: all threads that perform the read-modify-writes to the same atomic synchronize with the first thread and each other even if they have no &lt;code&gt;memory_order_release&lt;/code&gt; semantics. This makes single producer - multiple consumers situations possible without imposing unnecessary synchronization between individual consumer threads.</source>
          <target state="translated">Если какое-то атомарное хранилище освобождается из хранилища, а несколько других потоков выполняют операции чтения-изменения-записи на этом атомном элементе, формируется &amp;laquo;последовательность выпуска&amp;raquo;: все потоки, которые выполняют чтение-модификацию-запись в один и тот же атомарный элемент, синхронизируются с первым потоком и друг друга, даже если у них нет семантики &lt;code&gt;memory_order_release&lt;/code&gt; . Это делает возможными ситуации с одним производителем и несколькими потребителями без наложения ненужной синхронизации между отдельными потоками потребителей.</target>
        </trans-unit>
        <trans-unit id="e82df7dfa926848bf252cb2decabe5aa7f78e1a2" translate="yes" xml:space="preserve">
          <source>If statement_true is entered through a &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;, statement_false is not executed.</source>
          <target state="translated">Если Statement_true вводится через &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; , Statement_false не выполняется.</target>
        </trans-unit>
        <trans-unit id="834b8d6940f6e20e10043e602b81088e525449aa" translate="yes" xml:space="preserve">
          <source>If successful, an integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; is returned.</source>
          <target state="translated">В случае успеха возвращается целочисленное значение, соответствующее содержимому &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5632ad995e8027aefc150ef8436b23c84c4578ae" translate="yes" xml:space="preserve">
          <source>If successful, returns the IEEE floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined above.</source>
          <target state="translated">В случае успеха возвращает остаток IEEE с плавающей запятой от деления &lt;code&gt;x/y&lt;/code&gt; , как определено выше.</target>
        </trans-unit>
        <trans-unit id="7ba7ac810951fe3d89eb854fd7520e591880a573" translate="yes" xml:space="preserve">
          <source>If successful, returns the absolute value of &lt;code&gt;arg&lt;/code&gt; (&lt;code&gt;|arg|&lt;/code&gt;). The value returned is exact and does not depend on any rounding modes.</source>
          <target state="translated">В случае успеха возвращает абсолютное значение &lt;code&gt;arg&lt;/code&gt; ( &lt;code&gt;|arg|&lt;/code&gt; ). Возвращаемое значение является точным и не зависит от каких-либо режимов округления.</target>
        </trans-unit>
        <trans-unit id="a595b23fd21a8f04c669747846486d0e27d71af0" translate="yes" xml:space="preserve">
          <source>If successful, returns the floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined above.</source>
          <target state="translated">В случае успеха возвращает остаток с плавающей точкой от деления &lt;code&gt;x/y&lt;/code&gt; , как определено выше.</target>
        </trans-unit>
        <trans-unit id="dbd29a9c437f2e9ad0ed1aab2d3cb7e1e77881c8" translate="yes" xml:space="preserve">
          <source>If successful, returns the floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;remainder&lt;/a&gt;&lt;/code&gt;, and stores, in &lt;code&gt;*quo&lt;/code&gt;, the sign and at least three of the least significant bits of &lt;code&gt;x/y&lt;/code&gt; (formally, stores a value whose sign is the sign of &lt;code&gt;x/y&lt;/code&gt; and whose magnitude is congruent modulo 2n</source>
          <target state="translated">В случае успеха возвращает остаток с плавающей запятой от деления &lt;code&gt;x/y&lt;/code&gt; , как определено в &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;remainder&lt;/a&gt;&lt;/code&gt; , и сохраняет в &lt;code&gt;*quo&lt;/code&gt; знак и, по крайней мере, три из младших значащих битов &lt;code&gt;x/y&lt;/code&gt; (формально, хранит значение, знак которого является знаком &lt;code&gt;x/y&lt;/code&gt; и величина которого конгруэнтна по модулю 2n</target>
        </trans-unit>
        <trans-unit id="ea98bbdcb76a97fab4ef9d6ca9c32eecbe479081" translate="yes" xml:space="preserve">
          <source>If successful, returns the larger of two floating point values. The value returned is exact and does not depend on any rounding modes.</source>
          <target state="translated">В случае успеха возвращает большее из двух значений с плавающей точкой.Возвращаемое значение является точным и не зависит от режимов округления.</target>
        </trans-unit>
        <trans-unit id="9423b4432f6a645ec2473ed82b459b6686deb60f" translate="yes" xml:space="preserve">
          <source>If successful, returns the positive difference between x and y.</source>
          <target state="translated">В случае успеха возвращает положительную разницу между х и у.</target>
        </trans-unit>
        <trans-unit id="46138f9b406992b59d0f9492f2e64a28cf85480b" translate="yes" xml:space="preserve">
          <source>If successful, returns the smaller of two floating point values. The value returned is exact and does not depend on any rounding modes.</source>
          <target state="translated">В случае успеха возвращает меньшее из двух значений с плавающей точкой.Возвращаемое значение является точным и не зависит от режимов округления.</target>
        </trans-unit>
        <trans-unit id="5ca1e3a726f6c442c2b326f76a16b023bb9441ee" translate="yes" xml:space="preserve">
          <source>If successful, returns the value of &lt;code&gt;(x*y) + z&lt;/code&gt; as if calculated to infinite precision and rounded once to fit the result type (or, alternatively, calculated as a single ternary floating-point operation).</source>
          <target state="translated">В случае успеха возвращает значение &lt;code&gt;(x*y) + z&lt;/code&gt; как если бы оно было рассчитано с бесконечной точностью и округлено один раз для соответствия типу результата (или, альтернативно, рассчитано как одна троичная операция с плавающей запятой).</target>
        </trans-unit>
        <trans-unit id="950601c730121915fb8df6b19b5705a6edc03c0a" translate="yes" xml:space="preserve">
          <source>If successful, the object pointed to by &lt;code&gt;thr&lt;/code&gt; is set to the identifier of the new thread.</source>
          <target state="translated">В случае успеха объект, на который указывает &lt;code&gt;thr&lt;/code&gt; , устанавливается на идентификатор нового потока.</target>
        </trans-unit>
        <trans-unit id="18c5e1768b43942789912ab8899675cb0c8b4274" translate="yes" xml:space="preserve">
          <source>If such character was found, it is</source>
          <target state="translated">Если такой персонаж и был найден,то это</target>
        </trans-unit>
        <trans-unit id="3d422a20479abe70ce78b9c52445ed1bd990bbc6" translate="yes" xml:space="preserve">
          <source>If such character was found, it is the</source>
          <target state="translated">Если такой персонаж и был найден,то это</target>
        </trans-unit>
        <trans-unit id="781a8af57a4e00c05cd18f270856d6e17bfee700" translate="yes" xml:space="preserve">
          <source>If such wide character was found, it is</source>
          <target state="translated">Если такой широкий характер и был найден,то это</target>
        </trans-unit>
        <trans-unit id="cc7116ca6f31d674f4a72c2589a0d09f652f8823" translate="yes" xml:space="preserve">
          <source>If such wide character was found, it is the</source>
          <target state="translated">Если такой широкий характер и был найден,то это -</target>
        </trans-unit>
        <trans-unit id="a8d2bb8f6756f60946f65b57441b2965955c0d87" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;struct tm&lt;/a&gt;&lt;/code&gt; object was obtained from POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html&quot;&gt;strptime&lt;/a&gt; or equivalent function, the value of &lt;code&gt;tm_isdst&lt;/code&gt; is indeterminate, and needs to be set explicitly before calling &lt;code&gt;mktime&lt;/code&gt;.</source>
          <target state="translated">Если объект &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;struct tm&lt;/a&gt;&lt;/code&gt; был получен из POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html&quot;&gt;strptime&lt;/a&gt; или эквивалентной функции, значение &lt;code&gt;tm_isdst&lt;/code&gt; является неопределенным и должно быть задано явно перед вызовом &lt;code&gt;mktime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aba2a61809646633728f0c300cb4a04fd0fdd0e8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;nptr&lt;/code&gt; is empty or does not have the expected form, no conversion is performed, and (if &lt;code&gt;enptr&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;) the value of &lt;code&gt;nptr&lt;/code&gt; is stored in the object pointed to by &lt;code&gt;endptr&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;nptr&lt;/code&gt; пуст или не имеет ожидаемой формы, преобразование не выполняется, и (если &lt;code&gt;enptr&lt;/code&gt; не &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; ) значение &lt;code&gt;nptr&lt;/code&gt; сохраняется в объекте, на который указывает &lt;code&gt;endptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1881ec1b9072afac208ff470251f98ed10178f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;str&lt;/code&gt; is empty or does not have the expected form, no conversion is performed, and (if &lt;code&gt;str_end&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;) the value of &lt;code&gt;str&lt;/code&gt; is stored in the object pointed to by &lt;code&gt;str_end&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;str&lt;/code&gt; пуст или не имеет ожидаемой формы, преобразование не выполняется, и (если &lt;code&gt;str_end&lt;/code&gt; не равен &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; ) значение &lt;code&gt;str&lt;/code&gt; сохраняется в объекте, на который указывает &lt;code&gt;str_end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ee4a33ed19255d1a25cca13eefd41adeef44b2e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is open in binary mode, the new position is exactly &lt;code&gt;offset&lt;/code&gt; bytes measured from the beginning of the file if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt;, from the current file position if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_CUR&lt;/a&gt;&lt;/code&gt;, and from the end of the file if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt;. Binary streams are not required to support &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt;, in particular if additional null bytes are output.</source>
          <target state="translated">Если &lt;code&gt;stream&lt;/code&gt; открыт в двоичном режиме, новая позиция - это точно &lt;code&gt;offset&lt;/code&gt; байты, измеренные от начала файла, если &lt;code&gt;origin&lt;/code&gt; - &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt; , от текущей позиции файла, если &lt;code&gt;origin&lt;/code&gt; - &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_CUR&lt;/a&gt;&lt;/code&gt; , и от конца файла, если &lt;code&gt;origin&lt;/code&gt; - &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt; . Двоичные потоки не обязаны поддерживать &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt; , в частности, если выводятся дополнительные нулевые байты.</target>
        </trans-unit>
        <trans-unit id="6116bff33763f686cb5185e7645c348dd0166f73" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is open in text mode, the only supported values for &lt;code&gt;offset&lt;/code&gt; are zero (which works with any &lt;code&gt;origin&lt;/code&gt;) and a value returned by an earlier call to &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;ftell&lt;/a&gt;&lt;/code&gt; on a stream associated with the same file (which only works with &lt;code&gt;origin&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Если &lt;code&gt;stream&lt;/code&gt; открыт в текстовом режиме, поддерживается только значение &lt;code&gt;offset&lt;/code&gt; равно нуль (который работает с любым &lt;code&gt;origin&lt;/code&gt; ) и значение , возвращенное предыдущим вызовом &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;ftell&lt;/a&gt;&lt;/code&gt; на потоке , связанный с тем же файлом (который работает только с &lt;code&gt;origin&lt;/code&gt; из &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9c9015050df160ef6325c9f3da2b730ab6368bcf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is wide-oriented, the restrictions of both text and binary streams apply (result of &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;ftell&lt;/a&gt;&lt;/code&gt; is allowed with SEEK_SET and zero offset is allowed from SEEK_SET and SEEK_CUR, but not SEEK_END).</source>
          <target state="translated">Если &lt;code&gt;stream&lt;/code&gt; широко ориентирован, применяются ограничения как текстового, так и двоичного потоков (результат &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;ftell&lt;/a&gt;&lt;/code&gt; допускается с помощью SEEK_SET и смещение нуля допускается из SEEK_SET и SEEK_CUR, но не SEEK_END).</target>
        </trans-unit>
        <trans-unit id="2619199639dd0dfe77e10f7ea0d17382af754c82" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, &amp;plusmn;1 is returned</source>
          <target state="translated">Если аргумент равен &amp;plusmn; &amp;infin;, возвращается &amp;plusmn; 1</target>
        </trans-unit>
        <trans-unit id="a9eeedbf12ee3261a62193ec2f7bf409d740fd6e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, +&amp;infin; is returned</source>
          <target state="translated">Если аргумент равен &amp;plusmn; &amp;infin;, + &amp;infin; возвращается</target>
        </trans-unit>
        <trans-unit id="bc0e32230b86eab8904c3236eac37ff6f8e3e5b9" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, +&amp;infin; is returned.</source>
          <target state="translated">Если аргумент равен &amp;plusmn; &amp;infin;, возвращается + &amp;infin;.</target>
        </trans-unit>
        <trans-unit id="70915638207ef43ec09152008a5ac4da1c3e101e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, &amp;plusmn;&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если аргумент &amp;plusmn; 0, &amp;plusmn; &amp;infin; возвращается и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; поднимается</target>
        </trans-unit>
        <trans-unit id="4bcd3cf56514ebcbadf81a91fe745d514dda05b5" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, &amp;plusmn;0 is returned</source>
          <target state="translated">Если аргумент равен &amp;plusmn; 0, возвращается &amp;plusmn; 0</target>
        </trans-unit>
        <trans-unit id="79c9397babcc1b0c97ddd36d4f6dacccb4dbab7b" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, +&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если аргумент равен &amp;plusmn; 0, + &amp;infin; возвращается и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="97d561db29f01535350a0e816707f41c9ebbceeb" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, +0 is returned</source>
          <target state="translated">Если аргумент равен &amp;plusmn; 0, возвращается +0</target>
        </trans-unit>
        <trans-unit id="310b79d192c0fa5a1ce6ca3877e2deb499d9d5f3" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Если аргумент равен &amp;plusmn; 0, возвращается -&amp;infin; и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e20d184a4efd311faacd5da72518930f348cac5a" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, 1 is returned</source>
          <target state="translated">Если аргумент равен &amp;plusmn; 0, возвращается 1</target>
        </trans-unit>
        <trans-unit id="d3f53d74b0dca3908c99b1e364989b3591808e1e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, it is returned unmodified</source>
          <target state="translated">Если аргумент равен &amp;plusmn; 0, он возвращается без изменений</target>
        </trans-unit>
        <trans-unit id="ccd73690fa7a557641f2fe90d1fb0da76c7573ad" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="translated">Если аргумент равен &amp;plusmn; 0, он возвращается без изменений</target>
        </trans-unit>
        <trans-unit id="666ec3240c22502f1099c8da74484f25ff980d70" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;1, a pole error occurs.</source>
          <target state="translated">Если аргумент равен &amp;plusmn; 1, возникает ошибка полюса.</target>
        </trans-unit>
        <trans-unit id="16671d13b546303a8dbbbb41028ae78cbf067eb9" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin; or &amp;plusmn;0, it is returned, unmodified.</source>
          <target state="translated">Если аргумент равен + &amp;infin; или &amp;plusmn; 0, он возвращается без изменений.</target>
        </trans-unit>
        <trans-unit id="54b0607c64e592ab2e8d7944a7583de099ef78bc" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;infin; is returned</source>
          <target state="translated">Если аргумент + &amp;infin;, + &amp;infin; возвращается</target>
        </trans-unit>
        <trans-unit id="aa21d5b0bb57bf219f506cda16da2521284b89b4" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;infin; is returned.</source>
          <target state="translated">Если аргумент + &amp;infin;, возвращается + &amp;infin;.</target>
        </trans-unit>
        <trans-unit id="540557a8bd62a5b0f36f5bd102aec659ebb950db" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;pi;/2 is returned</source>
          <target state="translated">Если аргумент + &amp;infin;, возвращается + &amp;pi; / 2</target>
        </trans-unit>
        <trans-unit id="7199243658fb47291089c2b185fa5cf8110be042" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +0 is returned</source>
          <target state="translated">Если аргумент равен + &amp;infin;, возвращается +0</target>
        </trans-unit>
        <trans-unit id="f4be25ee19a8f2e9c79ffae1bfa98e41cff590c7" translate="yes" xml:space="preserve">
          <source>If the argument is +1, the value &lt;code&gt;+0&lt;/code&gt; is returned.</source>
          <target state="translated">Если аргумент равен +1, возвращается значение &lt;code&gt;+0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09765a27421db439d2ceef1decf36c6c5400ca31" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, +0 is returned</source>
          <target state="translated">Если аргумент -&amp;infin;, возвращается +0</target>
        </trans-unit>
        <trans-unit id="ab67da2ac08a598b0aeee9a84a5ea4203889b128" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, -&amp;pi;/2 is returned</source>
          <target state="translated">Если аргумент -&amp;infin;, возвращается -&amp;pi; / 2</target>
        </trans-unit>
        <trans-unit id="c52a07d7a9cd046aa4f61618e846c887cf3ca1d0" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, -1 is returned</source>
          <target state="translated">Если аргумент -&amp;infin;, -1 возвращается</target>
        </trans-unit>
        <trans-unit id="3cb7272c20346f5eded435e9a2ce5990a13f544b" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, 2 is returned</source>
          <target state="translated">Если аргумент -&amp;infin;, возвращается 2</target>
        </trans-unit>
        <trans-unit id="7b59bb47bb4f9b237288770872fa9592f179ad22" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если аргумент -&amp;infin;, NaN возвращается и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="2728e75a63954aabe83e882896db0bf09fd9c3f9" translate="yes" xml:space="preserve">
          <source>If the argument is -1, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Если аргумент равен -1, возвращается -&amp;infin; и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dad9f0dbcbb32af831ea87c9b1abd3643a5b7b20" translate="yes" xml:space="preserve">
          <source>If the argument is 1, +0 is returned</source>
          <target state="translated">Если аргумент равен 1,то возвращается +0.</target>
        </trans-unit>
        <trans-unit id="290ee1b584ad39adb2720da091bea3742f568b9f" translate="yes" xml:space="preserve">
          <source>If the argument is 2, +0 is returned</source>
          <target state="translated">Если аргумент 2,то возвращается +0.</target>
        </trans-unit>
        <trans-unit id="9f6074320a813a4e58ce3f8235a3e40354fe9d12" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, NaN is returned</source>
          <target state="translated">Если аргумент NaN,возвращается NaN.</target>
        </trans-unit>
        <trans-unit id="f630be49c2abd923603f430a83802a576f8d8a5b" translate="yes" xml:space="preserve">
          <source>If the argument is a negative integer, +&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если аргумент является отрицательным целым числом, + &amp;infin; , возвращается и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; поднимается</target>
        </trans-unit>
        <trans-unit id="d3cb5a23f7100fda931d00bdcf1949dd71d061ad" translate="yes" xml:space="preserve">
          <source>If the argument is a negative integer, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если аргумент является отрицательным числом, то возвращается значение NaN и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; поднимается</target>
        </trans-unit>
        <trans-unit id="20646ae3669e13c85917f45de5026134f970fd91" translate="yes" xml:space="preserve">
          <source>If the argument is less than -0, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and NaN is returned.</source>
          <target state="translated">Если аргумент меньше -0, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается и NaN возвращается.</target>
        </trans-unit>
        <trans-unit id="d60f1479d7ad633bb20dc263baae8366ce50fe47" translate="yes" xml:space="preserve">
          <source>If the argument is less than -1, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Если аргумент меньше -1, возвращается NaN и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82e61b5e3d8efb3126389ca46e457ed7c53253b6" translate="yes" xml:space="preserve">
          <source>If the argument is less than 1, a domain error occurs.</source>
          <target state="translated">Если аргумент меньше 1,то происходит ошибка домена.</target>
        </trans-unit>
        <trans-unit id="8ca2273cafe3374e2295b541c384fca2773d84f3" translate="yes" xml:space="preserve">
          <source>If the argument is negative, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Если аргумент отрицательный, возвращается NaN и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ce877c1c558f9ec930d2aac72c101f35a2f7812" translate="yes" xml:space="preserve">
          <source>If the argument is not on the interval [-1, +1], a range error occurs.</source>
          <target state="translated">Если аргумент не находится на интервале [-1,+1],то возникает ошибка диапазона.</target>
        </trans-unit>
        <trans-unit id="2199aba2bc9bf0df1d73b9c3777d78213c53216a" translate="yes" xml:space="preserve">
          <source>If the array contains several elements that &lt;code&gt;comp&lt;/code&gt; would indicate as equal to the element searched for, then it is unspecified which element the function will return as the result.</source>
          <target state="translated">Если массив содержит несколько элементов, которые &lt;code&gt;comp&lt;/code&gt; будет указывать как равные искомому элементу, то неизвестно, какой элемент функция возвратит в результате.</target>
        </trans-unit>
        <trans-unit id="e7a938d361647e59fdfb270dd850072137c9ecac" translate="yes" xml:space="preserve">
          <source>If the array was declared &lt;a href=&quot;storage_duration&quot;&gt;register&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">Если массив был объявлен как &lt;a href=&quot;storage_duration&quot;&gt;регистр&lt;/a&gt; , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="c828d39720091190e6dcd291852f42239651509b" translate="yes" xml:space="preserve">
          <source>If the array was declared &lt;a href=&quot;storage_duration&quot;&gt;register&lt;/a&gt;, the behavior of the program that attempts such conversion is undefined.</source>
          <target state="translated">Если массив был объявлен как &lt;a href=&quot;storage_duration&quot;&gt;регистр&lt;/a&gt; , поведение программы, которая пытается такое преобразование, не определено.</target>
        </trans-unit>
        <trans-unit id="6074bc08a4061ed8b2bf04b357ba914834dcf0c1" translate="yes" xml:space="preserve">
          <source>If the comma operator has to be used in such context, it must be parenthesized:</source>
          <target state="translated">Если оператор запятая должен использоваться в таком контексте,то он должен быть заключен в круглые скобки:</target>
        </trans-unit>
        <trans-unit id="36aec2ae635c40cb65f7125374328a3bd9489d46" translate="yes" xml:space="preserve">
          <source>If the compiler defines the macro constant &lt;code&gt;__STDC_NO_VLA__&lt;/code&gt; to integer constant &lt;code&gt;1&lt;/code&gt;, then VLA and VM types are not supported.</source>
          <target state="translated">Если компилятор определяет макро константу &lt;code&gt;__STDC_NO_VLA__&lt;/code&gt; для целочисленной константы &lt;code&gt;1&lt;/code&gt; , то типы VLA и VM не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="0102b5739cc3bf6169af43e213ce8f4a4202795a" translate="yes" xml:space="preserve">
          <source>If the compiler performs function inlining, it replaces a call of that function with its body, avoiding the overhead of a function call (placing data on stack and retrieving the result), which may result in a larger executable as the code for the function has to be repeated multiple times. The result is similar to &lt;a href=&quot;../preprocessor/replace&quot;&gt;function-like macros&lt;/a&gt;, except that identifiers and macros used in the function refer to the definitions visible at the point of definition, not at the point of call.</source>
          <target state="translated">Если компилятор выполняет встраивание функции, он заменяет вызов этой функции своим телом, избегая накладных расходов на вызов функции (размещение данных в стеке и получение результата), что может привести к увеличению размера исполняемого файла, поскольку код для функции имеет повторяться несколько раз. Результат похож на &lt;a href=&quot;../preprocessor/replace&quot;&gt;функционально-подобные макросы&lt;/a&gt; , за исключением того, что идентификаторы и макросы, используемые в функции, относятся к определениям, видимым в точке определения, а не в точке вызова.</target>
        </trans-unit>
        <trans-unit id="d89aa9b9998e409f83a89bb9d2cdac3e91f09898" translate="yes" xml:space="preserve">
          <source>If the compiler supports analyzability, any language or library construct whose behavior is undefined is further classified between</source>
          <target state="translated">Если компилятор поддерживает анализируемость,то любой язык или библиотечная конструкция,поведение которой не определено,далее классифицируется между</target>
        </trans-unit>
        <trans-unit id="59ee7a8220ba62d01c495a46ec65cf3fc585bffb" translate="yes" xml:space="preserve">
          <source>If the conversion to &lt;code&gt;time_t&lt;/code&gt; is successful, the &lt;code&gt;time&lt;/code&gt; object is modified. All fields of &lt;code&gt;time&lt;/code&gt; are updated to fit their proper ranges. &lt;code&gt;time-&amp;gt;tm_wday&lt;/code&gt; and &lt;code&gt;time-&amp;gt;tm_yday&lt;/code&gt; are recalculated using information available in other fields.</source>
          <target state="translated">Если преобразование в &lt;code&gt;time_t&lt;/code&gt; прошло успешно, объект &lt;code&gt;time&lt;/code&gt; изменяется. Все поля &lt;code&gt;time&lt;/code&gt; обновляются, чтобы соответствовать их нужным диапазонам. &lt;code&gt;time-&amp;gt;tm_wday&lt;/code&gt; и &lt;code&gt;time-&amp;gt;tm_yday&lt;/code&gt; пересчитываются с использованием информации, доступной в других полях.</target>
        </trans-unit>
        <trans-unit id="6192b4cbcd6b133ff7698ce09fce768219ba252e" translate="yes" xml:space="preserve">
          <source>If the converted value falls out of range of corresponding return type, a range error occurs (setting &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;​0​&lt;/code&gt; is returned, as appropriate.</source>
          <target state="translated">Если преобразованное значение выпадает из диапазона соответствующих возвращаемого типа, возникает ошибка диапазона (настройка &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; к &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; ) и &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;​0​&lt;/code&gt; возвращается, в зависимости от обстоятельств.</target>
        </trans-unit>
        <trans-unit id="63ccc0cb218c965f911fab62a19044ef04c5af35" translate="yes" xml:space="preserve">
          <source>If the converted value falls out of range of corresponding return type, a range error occurs (setting &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если преобразованное значение выходит за пределы диапазона соответствующего возвращаемого типа, возникает ошибка диапазона (установка &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; на &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; ) и &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca46624d6b0c110c8fee9d6430d211ff036c4ba4" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Если правильный результат больше &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; или меньше &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается.</target>
        </trans-unit>
        <trans-unit id="0c7f3d1a2ebc058a3464f5e25a82d02e716648fa" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, a domain error or a range error may occur.</source>
          <target state="translated">Если правильный результат больше чем &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; или меньше чем &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; , может произойти ошибка домена или ошибка диапазона.</target>
        </trans-unit>
        <trans-unit id="191fa266d736718757385767dd6a59cc886d46d0" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, the return value is unspecified and a domain error or range error may occur.</source>
          <target state="translated">Если правильный результат больше, чем &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; или меньше, чем &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; , возвращаемое значение не указано и может возникнуть ошибка домена или ошибки диапазона.</target>
        </trans-unit>
        <trans-unit id="5a6cae9283a2623af917462111836ee3e70aa764" translate="yes" xml:space="preserve">
          <source>If the current rounding mode is &lt;code&gt;&lt;a href=&quot;../fenv/fe_round&quot;&gt;FE_TONEAREST&lt;/a&gt;&lt;/code&gt;, this function rounds to even in halfway cases (like &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt;, but unlike &lt;code&gt;&lt;a href=&quot;round&quot;&gt;round&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Если текущим режимом округления является &lt;code&gt;&lt;a href=&quot;../fenv/fe_round&quot;&gt;FE_TONEAREST&lt;/a&gt;&lt;/code&gt; , эта функция округляется даже до половины &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt; (например, rint , но в отличие от &lt;code&gt;&lt;a href=&quot;round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e2333eb5beb6ae4621087ed67aea4b57771b1571" translate="yes" xml:space="preserve">
          <source>If the current rounding mode is...</source>
          <target state="translated">Если текущий режим округления...</target>
        </trans-unit>
        <trans-unit id="97a0aa7f8fe1a9bd6dbbecffec65b2ca11d005be" translate="yes" xml:space="preserve">
          <source>If the declarator or type specifier that declares the identifier appears outside of any block or list of parameters, the identifier has file scope, which terminates at the end of the translation unit.</source>
          <target state="translated">Если декларатор или спецификатор типа,объявляющий идентификатор,появляется вне какого-либо блока или списка параметров,то идентификатор имеет область действия файла,которая заканчивается в конце блока перевода.</target>
        </trans-unit>
        <trans-unit id="253bb460db1572bc8ca06ca717632f07e694bb79" translate="yes" xml:space="preserve">
          <source>If the elements of an array are arrays, structs, or unions, the corresponding initializers in the brace-enclosed list of initializers are any initializers that are valid for those members, except that their braces may be omitted as follows:</source>
          <target state="translated">Если элементами массива являются массивы,структуры или объединения,то соответствующими инициализаторами в списке инициализаторов,заключенном в скобки,являются любые инициализаторы,действительные для этих членов,за исключением того,что их скобки могут быть опущены следующим образом:</target>
        </trans-unit>
        <trans-unit id="cc06f1d466f19d96e2bb2f450cc3e5f9c16ffbc6" translate="yes" xml:space="preserve">
          <source>If the environment macro &lt;code&gt;__STDC_ISO_10646__&lt;/code&gt; is defined, the values of type &lt;code&gt;wchar_t&lt;/code&gt; are the same as the short identifiers of the characters in the Unicode required set (typically UTF-32 encoding); otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.</source>
          <target state="translated">Если определен макрос среды &lt;code&gt;__STDC_ISO_10646__&lt;/code&gt; , значения типа &lt;code&gt;wchar_t&lt;/code&gt; совпадают с короткими идентификаторами символов в требуемом наборе Unicode (обычно кодировка UTF-32); в противном случае это определяется реализацией. В любом случае многобайтовая кодировка символов, используемая этой функцией, указывается текущей активной локалью C.</target>
        </trans-unit>
        <trans-unit id="1127060a7a07a58c7bb8e11a04aa886b4480ab05" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be continued at the end of the loop body, &lt;a href=&quot;continue&quot;&gt; continue statement&lt;/a&gt; can be used as a shortcut.</source>
          <target state="translated">Если выполнение цикла необходимо продолжить в конце тела цикла, &lt;a href=&quot;continue&quot;&gt;оператор continue&lt;/a&gt; может использоваться в качестве ярлыка.</target>
        </trans-unit>
        <trans-unit id="3ee3147a9a7672459eeee8081c98eac6e3e82425" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be terminated at some point, &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used as a terminating statement.</source>
          <target state="translated">Если выполнение цикла необходимо прекратить в какой-то момент, &lt;a href=&quot;break&quot;&gt;оператор break&lt;/a&gt; можно использовать как оператор завершения.</target>
        </trans-unit>
        <trans-unit id="94e3914e819b4e9c6f38a7c7d3a8f66bfec35d72" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be terminated at some point, &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used as terminating statement.</source>
          <target state="translated">Если выполнение цикла необходимо прекратить в какой-то момент, &lt;a href=&quot;break&quot;&gt;оператор break&lt;/a&gt; можно использовать как оператор завершения.</target>
        </trans-unit>
        <trans-unit id="82682fec524d889a1cf2cfe1b3e0b122ffe26584" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be terminated at some point, a &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used anywhere within the loop_statement.</source>
          <target state="translated">Если выполнение цикла необходимо прекратить в какой-то момент, оператор &lt;a href=&quot;break&quot;&gt;break&lt;/a&gt; можно использовать где угодно в пределах loop_statement.</target>
        </trans-unit>
        <trans-unit id="8bb904e3ab541e5036d8b9cca126affda663bc33" translate="yes" xml:space="preserve">
          <source>If the exponent is present and fractional part is not used, the decimal separator may be omitted:</source>
          <target state="translated">Если экспонент присутствует и дробная часть не используется,десятичный разделитель может быть опущен:</target>
        </trans-unit>
        <trans-unit id="a165ff8440c9b7e05a409264009f6217873d188b" translate="yes" xml:space="preserve">
          <source>If the external definition exists in the program, the address of the function is always the address of the external function, but when this address is used to make a function call, it's unspecified whether the</source>
          <target state="translated">Если в программе существует внешнее определение,то адрес функции всегда является адресом внешней функции,но когда этот адрес используется для вызова функции,то неуказано,является ли</target>
        </trans-unit>
        <trans-unit id="a2b1b61632e47d98b991cfabb43ddaa1fc1c9b3b" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by end of file condition, additionally sets the</source>
          <target state="translated">Если сбой был вызван состоянием конца файла,дополнительно установите параметр</target>
        </trans-unit>
        <trans-unit id="90c9cca36bdb9f6f7d9748c18430b538e7979538" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by end-of-file condition, additionally sets the</source>
          <target state="translated">Если неисправность вызвана состоянием конца файла,дополнительно установите параметр</target>
        </trans-unit>
        <trans-unit id="994d9bf8337b9cacbb5385430d81add1cb5bd997" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by some other error, sets the</source>
          <target state="translated">Если сбой был вызван какой-либо другой ошибкой,установите параметр</target>
        </trans-unit>
        <trans-unit id="830435d4a1387d881331880059f8a2aaf6456533" translate="yes" xml:space="preserve">
          <source>If the file is currently open by this or another process, the behavior of this function is implementation-defined (in particular, POSIX systems unlink the file name although the file system space is not reclaimed until the last running process closes the file; Windows does not allow the file to be deleted).</source>
          <target state="translated">Если файл в данный момент открыт тем или иным процессом,поведение этой функции определяется реализацией (в частности,POSIX-системы не связывают имя файла,хотя пространство файловой системы не восстанавливается до тех пор,пока последний запущенный процесс не закроет файл;Windows не позволяет удалить файл).</target>
        </trans-unit>
        <trans-unit id="6020291574132d5834e014d6c7f58d404fb0a67b" translate="yes" xml:space="preserve">
          <source>If the first character of the set is &lt;code&gt;^&lt;/code&gt;, then all characters not in the set are matched. If the set begins with &lt;code&gt;]&lt;/code&gt; or &lt;code&gt;^]&lt;/code&gt; then the &lt;code&gt;]&lt;/code&gt; character is also included into the set. It is implementation-defined whether the character &lt;code&gt;-&lt;/code&gt; in the non-initial position in the scanset may be indicating a range, as in &lt;code&gt;[0-9]&lt;/code&gt;. If width specifier is used, matches only up to</source>
          <target state="translated">Если первый символ набора - &lt;code&gt;^&lt;/code&gt; , то все символы, не входящие в набор, сопоставляются. Если набор начинается с &lt;code&gt;]&lt;/code&gt; или &lt;code&gt;^]&lt;/code&gt; , то символ &lt;code&gt;]&lt;/code&gt; также включается в набор. Определяется реализацией, может ли символ &lt;code&gt;-&lt;/code&gt; в не начальной позиции в наборе сканирования указывать диапазон, как в &lt;code&gt;[0-9]&lt;/code&gt; . Если используется спецификатор ширины, соответствует только до</target>
        </trans-unit>
        <trans-unit id="d64e081a56bac75f7eaed846b2b99e805513c5d7" translate="yes" xml:space="preserve">
          <source>If the function that called &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; has exited (whether by return or by a different &lt;code&gt;longjmp&lt;/code&gt; higher up the stack), the behavior is undefined. In other words, only long jumps up the call stack are allowed.</source>
          <target state="translated">Если функция, &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; , вышла (либо с помощью return, либо с помощью другого &lt;code&gt;longjmp&lt;/code&gt; выше по стеку), поведение не определено. Другими словами, разрешены только длинные прыжки вверх по стеку вызовов.</target>
        </trans-unit>
        <trans-unit id="1269621bdc65581d6c1d260b7209ad814afbd640" translate="yes" xml:space="preserve">
          <source>If the host environment cannot supply both lowercase and uppercase letters, the command line arguments are converted to lowercase.</source>
          <target state="translated">Если хост-среда не может поставлять как строчные,так и прописные буквы,аргументы командной строки преобразуются в строчные.</target>
        </trans-unit>
        <trans-unit id="1d83c11796c2c1e3f318ffcc89e81bbd5f8b11e8" translate="yes" xml:space="preserve">
          <source>If the implementation does not support floating-point infinities, the macro &lt;code&gt;INFINITY&lt;/code&gt; expands to a positive value that is guaranteed to overflow a &lt;code&gt;float&lt;/code&gt; at compile time, and the use of this macro generates a compiler warning.</source>
          <target state="translated">Если реализация не поддерживает бесконечности с плавающей точкой, макрос &lt;code&gt;INFINITY&lt;/code&gt; расширяется до положительного значения, которое гарантированно переполняет число с &lt;code&gt;float&lt;/code&gt; во время компиляции, и использование этого макроса генерирует предупреждение компилятора.</target>
        </trans-unit>
        <trans-unit id="19ffe219703efe6527e00547f4a8cca5d22a9042" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),</source>
          <target state="translated">Если реализация поддерживает арифметику с плавающей запятой IEEE (IEC 60559),</target>
        </trans-unit>
        <trans-unit id="699c67e4aaf9791f00393d5529c1c7e718fbd3d8" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),   For the &lt;code&gt;rint&lt;/code&gt; function:</source>
          <target state="translated">Если реализация поддерживает арифметику IEEE с плавающей точкой (IEC 60559), для функции &lt;code&gt;rint&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fe61740055acdc39bc5f3b3cf183ae13ff9c59a6" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),   For the &lt;code&gt;round&lt;/code&gt;, &lt;code&gt;roundf&lt;/code&gt;, and &lt;code&gt;roundl&lt;/code&gt; function:</source>
          <target state="translated">Если реализация поддерживает арифметику IEEE с плавающей точкой (IEC 60559), для функции &lt;code&gt;round&lt;/code&gt; , &lt;code&gt;roundf&lt;/code&gt; и &lt;code&gt;roundl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c7685e11635ec992c012cd0e03140bd9ce1479a3" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559), &lt;code&gt;math_errhandling &amp;amp; MATH_ERREXCEPT&lt;/code&gt; is required to be non-zero.</source>
          <target state="translated">Если реализация поддерживает арифметику с плавающей точкой IEEE (IEC 60559), &lt;code&gt;math_errhandling &amp;amp; MATH_ERREXCEPT&lt;/code&gt; должно быть ненулевым.</target>
        </trans-unit>
        <trans-unit id="452d571ea8f52d84cf9e46de2bbbf6be56c3970a" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic,</source>
          <target state="translated">Если реализация поддерживает арифметику с плавающей запятой IEEE,</target>
        </trans-unit>
        <trans-unit id="7392bc849012f8a7b52172fc01358b19f1c644b0" translate="yes" xml:space="preserve">
          <source>If the implementation supports floating-point infinities, the macro &lt;code&gt;INFINITY&lt;/code&gt; expands to constant expression of type &lt;code&gt;float&lt;/code&gt; which evaluates to positive or unsigned infinity.</source>
          <target state="translated">Если реализация поддерживает бесконечность с плавающей точкой, макрос &lt;code&gt;INFINITY&lt;/code&gt; расширяется до константного выражения типа &lt;code&gt;float&lt;/code&gt; , которое оценивается как положительная или беззнаковая бесконечность.</target>
        </trans-unit>
        <trans-unit id="d6346069140ef89aa4a40fbb67316690947509e3" translate="yes" xml:space="preserve">
          <source>If the input has been parsed into preprocessing tokens up to a given character, the next preprocessing token is generally taken to be the longest sequence of characters that could constitute a preprocessing token, even if that would cause subsequent analysis to fail. This is commonly known as</source>
          <target state="translated">Если вход был разобран на маркеры препроцессирования до заданного символа,то следующей маркерой препроцессирования обычно считается самая длинная последовательность символов,которая может составлять маркер препроцессирования,даже если это приведет к тому,что последующий анализ окажется неудачным.Это широко известно как</target>
        </trans-unit>
        <trans-unit id="1b0cfd9b08932b3884431c92475183560f1d46ce" translate="yes" xml:space="preserve">
          <source>If the last thread in the program is terminated with &lt;code&gt;thrd_exit&lt;/code&gt;, the entire program terminates as if by calling &lt;code&gt;&lt;a href=&quot;../program/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../program/exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt; as the argument (so the functions registered by &lt;code&gt;&lt;a href=&quot;../program/atexit&quot;&gt;atexit&lt;/a&gt;&lt;/code&gt; are executed in the context of that last thread).</source>
          <target state="translated">Если последний поток в программе завершается с помощью &lt;code&gt;thrd_exit&lt;/code&gt; , вся программа завершается, как если бы она вызывала команду &lt;code&gt;&lt;a href=&quot;../program/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; с &lt;code&gt;&lt;a href=&quot;../program/exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt; в качестве аргумента (поэтому функции, зарегистрированные &lt;code&gt;&lt;a href=&quot;../program/atexit&quot;&gt;atexit&lt;/a&gt;&lt;/code&gt; , выполняются в контексте этого последнего потока).</target>
        </trans-unit>
        <trans-unit id="f0092ff30ced4b5b7eeebddab8461805c98ccc03" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; or &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; qualified, the result is also qualified. If the left operand is &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">Если левый операнд &lt;a href=&quot;const&quot;&gt;сопзЬ&lt;/a&gt; или &lt;a href=&quot;volatile&quot;&gt;неустойчивыми&lt;/a&gt; квалифицирован, результат также квалифицирован. Если левый операнд &lt;a href=&quot;atomic&quot;&gt;атомарный&lt;/a&gt; , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="fc3d85ef243667631214a89b35ad48243e455197" translate="yes" xml:space="preserve">
          <source>If the length specifier &lt;code&gt;l&lt;/code&gt; is not used, the conversion specifiers &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, and &lt;code&gt;[&lt;/code&gt; perform wide-to-multibyte character conversion as if by calling &lt;a href=&quot;../string/multibyte/wcrtomb&quot;&gt;&lt;code&gt;wcrtomb()&lt;/code&gt;&lt;/a&gt; with an &lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt;&lt;code&gt;mbstate_t&lt;/code&gt;&lt;/a&gt; object initialized to zero before the first character is converted.</source>
          <target state="translated">Если спецификатор длины &lt;code&gt;l&lt;/code&gt; не используется, спецификаторы преобразования &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;s&lt;/code&gt; и &lt;code&gt;[&lt;/code&gt; выполняют преобразование широких в многобайтовые символы, как если бы они &lt;a href=&quot;../string/multibyte/wcrtomb&quot;&gt; &lt;code&gt;wcrtomb()&lt;/code&gt; &lt;/a&gt; с объектом &lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt; &lt;code&gt;mbstate_t&lt;/code&gt; ,&lt;/a&gt; инициализированным в ноль перед преобразованием первого символа.</target>
        </trans-unit>
        <trans-unit id="eca68afe6b8894fe105ba600b6be6acbcaded6f7" translate="yes" xml:space="preserve">
          <source>If the lvalue designates an object of automatic storage duration whose address was never taken and if that object was uninitialized (not declared with an initializer and no assignment to it has been performed prior to use), the behavior is undefined.</source>
          <target state="translated">Если значение l обозначает объект автоматического хранения длительности,адрес которого никогда не был взят,и если этот объект был неинициализирован (не объявлен с инициализатором и не было выполнено его присвоение до использования),то поведение не определено.</target>
        </trans-unit>
        <trans-unit id="f6c5c610adf8c7fe59ee2c1e9abdf35cbc323127" translate="yes" xml:space="preserve">
          <source>If the lvalue has incomplete type, the behavior is undefined.</source>
          <target state="translated">Если значение l имеет неполный тип,поведение не определено.</target>
        </trans-unit>
        <trans-unit id="01cf236a859f8973431548739aa1a2bd6773cac2" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;__STDC_UTF_16__&lt;/code&gt; is defined, the 16-bit encoding used by this function is UTF-16; otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.</source>
          <target state="translated">Если макрос &lt;code&gt;__STDC_UTF_16__&lt;/code&gt; определен, 16-битное кодирование, используемое этой функцией, является UTF-16; в противном случае это определяется реализацией. В любом случае многобайтовая кодировка символов, используемая этой функцией, указывается текущей активной локалью C.</target>
        </trans-unit>
        <trans-unit id="9aa2e0435d88c88dcdb4fbdbb133c8a127f19150" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;__STDC_UTF_32__&lt;/code&gt; is defined, the 32-bit encoding used by this function is UTF-32; otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.</source>
          <target state="translated">Если макрос &lt;code&gt;__STDC_UTF_32__&lt;/code&gt; определен, 32-битное кодирование, используемое этой функцией, является UTF-32; в противном случае это определяется реализацией. В любом случае многобайтовая кодировка символов, используемая этой функцией, указывается текущей активной локалью C.</target>
        </trans-unit>
        <trans-unit id="651db3f0d9f9ede3dcfc008c0798405a073761da" translate="yes" xml:space="preserve">
          <source>If the macro constant &lt;code&gt;__STDC_NO_ATOMICS__&lt;/code&gt;(C11) is defined by the compiler, the header &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt;, the keyword &lt;code&gt;_Atomic&lt;/code&gt;, and all of the names listed here are not provided.</source>
          <target state="translated">Если макрос-константа &lt;code&gt;__STDC_NO_ATOMICS__&lt;/code&gt; (C11) определена компилятором, заголовок &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt; , ключевое слово &lt;code&gt;_Atomic&lt;/code&gt; и все перечисленные здесь имена не предоставлены.</target>
        </trans-unit>
        <trans-unit id="549a81d60d09906925c9492d7b11e76f4c974fe0" translate="yes" xml:space="preserve">
          <source>If the macro constant &lt;code&gt;__STDC_NO_ATOMICS__&lt;/code&gt;(C11) is defined by the compiler, the keyword &lt;code&gt;_Atomic&lt;/code&gt; as well as the header &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt;, is not provided.</source>
          <target state="translated">Если макрос-константа &lt;code&gt;__STDC_NO_ATOMICS__&lt;/code&gt; (C11) определена компилятором, ключевое слово &lt;code&gt;_Atomic&lt;/code&gt; , а также заголовок &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt; не предоставляются.</target>
        </trans-unit>
        <trans-unit id="54c6fb244ea5ef05e85ae5bec7afb39dca30e410" translate="yes" xml:space="preserve">
          <source>If the macro constant &lt;code&gt;__STDC_NO_COMPLEX__&lt;/code&gt; is defined by the implementation, the complex types, the header &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; and all of the names listed here are not provided.</source>
          <target state="translated">Если макрос-константа &lt;code&gt;__STDC_NO_COMPLEX__&lt;/code&gt; определяется реализацией, сложные типы, заголовок &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; и все перечисленные здесь имена не предоставляются.</target>
        </trans-unit>
        <trans-unit id="f3b81b34a2269058d8e0301809518279ee9143b0" translate="yes" xml:space="preserve">
          <source>If the macro constant &lt;code&gt;__STDC_NO_COMPLEX__&lt;/code&gt;(C11) is defined by the implementation, the complex types (as well as the library header &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;) are not provided.</source>
          <target state="translated">Если макрос-константа &lt;code&gt;__STDC_NO_COMPLEX__&lt;/code&gt; (C11) определяется реализацией, сложные типы (а также заголовок библиотеки &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; ) не предоставляются.</target>
        </trans-unit>
        <trans-unit id="1231e4ddd7fa2aa6ee9ba3a4d709933bfbf0374c" translate="yes" xml:space="preserve">
          <source>If the macro constant &lt;code&gt;__STDC_NO_THREADS__&lt;/code&gt;(C11) is defined by the compiler, the header &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt; and all of the names listed here are not provided.</source>
          <target state="translated">Если макрос-константа &lt;code&gt;__STDC_NO_THREADS__&lt;/code&gt; (C11) определена компилятором, заголовок &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt; и все перечисленные здесь имена не предоставляются.</target>
        </trans-unit>
        <trans-unit id="51f37b450edb52b954b68e62d69c5c0202f834d2" translate="yes" xml:space="preserve">
          <source>If the main function executes a &lt;code&gt;return&lt;/code&gt; that specifies no value or, which is the same, reaches the terminating &lt;code&gt;}&lt;/code&gt; without executing a &lt;code&gt;return&lt;/code&gt;, the termination status returned to the host environment is undefined.</source>
          <target state="translated">Если основная функция выполняет &lt;code&gt;return&lt;/code&gt; который не указывает никакого значения или, что то же самое, достигает завершения &lt;code&gt;}&lt;/code&gt; без выполнения &lt;code&gt;return&lt;/code&gt; , состояние завершения, возвращаемое в среду хоста, не определено.</target>
        </trans-unit>
        <trans-unit id="9dd09fa95e725157b1639c229069abbb48976b07" translate="yes" xml:space="preserve">
          <source>If the member used to access the contents of a union is not the same as the member last used to store a value, the object representation of the value that was stored is reinterpreted as an object representation of the new type (this is known as</source>
          <target state="translated">Если член,использовавшийся для доступа к содержимому объединения,не является тем же членом,который в последний раз использовался для хранения значения,то объектное представление значения,которое было сохранено,переосмысляется как объектное представление нового типа (это известно как</target>
        </trans-unit>
        <trans-unit id="8b562f8affe8bf1ade0fe85a6dfe88e871afc3d0" translate="yes" xml:space="preserve">
          <source>If the members of the struct or union are arrays, structs, or unions, the corresponding initializers in the brace-enclosed list of initializers are any initializers that are valid for those members, except that their braces may be omitted as follows:</source>
          <target state="translated">Если членами структуры или союза являются массивы,структуры или союзы,то соответствующими инициализаторами в прилагаемом к скобкам списке инициализаторов являются любые инициализаторы,которые действительны для этих членов,за исключением того,что их скобки могут быть опущены следующим образом:</target>
        </trans-unit>
        <trans-unit id="df9b6d81c45a06a726423ecec58eacc4756ca95f" translate="yes" xml:space="preserve">
          <source>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic&quot;&gt;unary minus&lt;/a&gt; in the result type, which applies unsigned integer wraparound rules.</source>
          <target state="translated">Если знак минус был частью входной последовательности, числовое значение, вычисленное из последовательности цифр, отменяется, как если бы оно было &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic&quot;&gt;одинарным минусом&lt;/a&gt; в типе результата, который применяет правила целочисленного округления без знака.</target>
        </trans-unit>
        <trans-unit id="4d8c026dab9455903edcd7b942a6e7d2b308ef69" translate="yes" xml:space="preserve">
          <source>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic&quot;&gt;unary minus&lt;/a&gt; in the result type.</source>
          <target state="translated">Если знак минус был частью входной последовательности, числовое значение, вычисленное из последовательности цифр, сводится как бы к &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic&quot;&gt;унарному минусу&lt;/a&gt; в типе результата.</target>
        </trans-unit>
        <trans-unit id="312e4e4f74f5b82f6bd25b87461c9b4fbde989e6" translate="yes" xml:space="preserve">
          <source>If the multibyte character in &lt;code&gt;*s&lt;/code&gt; corresponds to a multi-char16_t sequence (e.g. a surrogate pair in UTF-16), then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next call to &lt;code&gt;mbrtoc16&lt;/code&gt; will write out the additional char16_t, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="translated">Если многобайтовый символ в &lt;code&gt;*s&lt;/code&gt; соответствует последовательности multi-char16_t (например, суррогатная пара в UTF-16), то после первого вызова этой функции &lt;code&gt;*ps&lt;/code&gt; обновляется таким образом, что следующий вызов &lt;code&gt;mbrtoc16&lt;/code&gt; будет записывать из дополнительного char16_t без учета &lt;code&gt;*s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcb6afe2a5acb943ad2fdd6f475921c6ce71ebf8" translate="yes" xml:space="preserve">
          <source>If the multibyte character in &lt;code&gt;*s&lt;/code&gt; corresponds to a multi-char32_t sequence (not possible with UTF-32), then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next calls to &lt;code&gt;mbrtoc32&lt;/code&gt; will write out the additional char32_t, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="translated">Если многобайтовый символ в &lt;code&gt;*s&lt;/code&gt; соответствует последовательности multi-char32_t (это невозможно с UTF-32), то после первого вызова этой функции &lt;code&gt;*ps&lt;/code&gt; обновляется таким образом, что при следующих вызовах &lt;code&gt;mbrtoc32&lt;/code&gt; будут записаны дополнительный char32_t, без учета &lt;code&gt;*s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="304955bf3a45b6b20b8586f86759d6a1a4e81f15" translate="yes" xml:space="preserve">
          <source>If the nested initializer begins with an opening brace, the entire nested initializer up to its closing brace initializes the corresponding array element:</source>
          <target state="translated">Если вложенный инициализатор начинается с открывающейся скобки,то весь вложенный инициализатор до закрывающей скобки инициализирует соответствующий элемент массива:</target>
        </trans-unit>
        <trans-unit id="933c4fa6a66cfd77beaa3fe517c80ce5e0abfbb6" translate="yes" xml:space="preserve">
          <source>If the nested initializer begins with an opening brace, the entire nested initializer up to its closing brace initializes the corresponding member object. Each left opening brace establishes a new</source>
          <target state="translated">Если вложенный инициализатор начинается с открывающейся скобки,то весь вложенный инициализатор до закрывающей скобки инициализирует соответствующий объект-член.Каждая левая открывающаяся скобка устанавливает новый</target>
        </trans-unit>
        <trans-unit id="151921afc39167d8205cd587ad8ad524dd37f8ab" translate="yes" xml:space="preserve">
          <source>If the nested initializer does not begin with an opening brace, only enough initializers from the list are taken to account for the elements or members of the member array, struct or union; any remaining initializers are left to initialize the next struct member:</source>
          <target state="translated">Если вложенный инициализатор не начинается со стартовой скобки,то учитывается только достаточное количество инициализаторов из списка для элементов или членов массива-члена,структуры или объединения;остальные инициализаторы остаются для инициализации следующего члена структуры:</target>
        </trans-unit>
        <trans-unit id="1d36da4c4053cda43da536fac84e436ea42130de" translate="yes" xml:space="preserve">
          <source>If the nested initializer does not begin with an opening brace, only enough initializers from the list are taken to account for the elements or members of the sub-array, struct or union; any remaining initializers are left to initialize the next array element:</source>
          <target state="translated">Если вложенный инициализатор не начинается со стартовой скобки,то учитывается только достаточное количество инициализаторов из списка для элементов или членов подмассива,структуры или объединения;остальные инициализаторы остаются для инициализации следующего элемента массива:</target>
        </trans-unit>
        <trans-unit id="80732b9a6ea0bd32db8b85caa6c27f1714c901e0" translate="yes" xml:space="preserve">
          <source>If the object is never modified, it may be aliased and accessed through different restrict-qualified pointers (note that if the objects pointed to by aliased restrict-qualified pointers are, in turn, pointers, this aliasing can inhibit optimization).</source>
          <target state="translated">Если объект никогда не модифицируется,он может быть помещен под псевдонимом и доступ к нему может осуществляться через различные ограничительные указатели (обратите внимание,что если объекты,на которые указывают ограничительные указатели под псевдонимом,являются,в свою очередь,указателями,то такое наложение псевдонима может препятствовать оптимизации).</target>
        </trans-unit>
        <trans-unit id="e99470df4e3d3e9a6241b3fc568484134bda99cc" translate="yes" xml:space="preserve">
          <source>If the object was created by a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;, the declared type of that object is the object's</source>
          <target state="translated">Если объект был создан &lt;a href=&quot;declarations&quot;&gt;объявлением&lt;/a&gt; , объявленный тип этого объекта является</target>
        </trans-unit>
        <trans-unit id="21dde2db6c5eec120e8008d864b1ea6006fc747f" translate="yes" xml:space="preserve">
          <source>If the object was created by an &lt;a href=&quot;../memory&quot;&gt;allocation function&lt;/a&gt; (including &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;), it has no declared type. Such object acquires an effective type as follows:</source>
          <target state="translated">Если объект был создан &lt;a href=&quot;../memory&quot;&gt;функцией размещения&lt;/a&gt; (включая &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; ), он не имеет объявленного типа. Такой объект приобретает эффективный вид следующим образом:</target>
        </trans-unit>
        <trans-unit id="07637ee8af1e302a0a5a769400ebcb2f44a92f13" translate="yes" xml:space="preserve">
          <source>If the operand is an array index expression, no action is taken other than the array-to-pointer conversion and the addition, so &amp;amp;a[N] is valid for an array of size N (obtaining a pointer one past the end is okay, dereferencing it is not, but dereference cancels out in this expression).</source>
          <target state="translated">Если операнд является выражением индекса массива, никакие действия не предпринимаются, кроме преобразования массива в указатель и сложения, поэтому &amp;amp; a [N] действителен для массива размера N (получение указателя за концом нормально, разыменование это не так, но разыменование отменяется в этом выражении).</target>
        </trans-unit>
        <trans-unit id="880e10035a2f45d57c976bf239aeb18adfa8e76c" translate="yes" xml:space="preserve">
          <source>If the operand is the dereference operator, no action is taken (so it's okay to apply &amp;amp;* to a null pointer), except that the result is not an lvalue.</source>
          <target state="translated">Если операндом является оператор разыменования, никакие действия не предпринимаются (поэтому можно применять &amp;amp; * к нулевому указателю), за исключением того, что результат не является lvalue.</target>
        </trans-unit>
        <trans-unit id="b113388f82173776cc247c5cef46e3268d0b48fb" translate="yes" xml:space="preserve">
          <source>If the orientation of the stream has already been decided (by executing output or by an earlier call to fwide), this function does nothing.</source>
          <target state="translated">Если ориентация потока уже определена (путем выполнения вывода или более раннего вызова fwide),эта функция ничего не делает.</target>
        </trans-unit>
        <trans-unit id="d599043942f481f6b0419f90b76a322525485e59" translate="yes" xml:space="preserve">
          <source>If the pointer &lt;code&gt;P1&lt;/code&gt; points at an element of an array with index &lt;code&gt;I&lt;/code&gt; (or one past the end) and &lt;code&gt;P2&lt;/code&gt; points at an element of the same array with index &lt;code&gt;J&lt;/code&gt; (or one past the end), then</source>
          <target state="translated">Если указатель &lt;code&gt;P1&lt;/code&gt; указывает на элемент массива с индексом &lt;code&gt;I&lt;/code&gt; (или один после конца) и &lt;code&gt;P2&lt;/code&gt; указывает на элемент того же массива с индексом &lt;code&gt;J&lt;/code&gt; (или один после конца), то</target>
        </trans-unit>
        <trans-unit id="cdb9c5ce8b4b941a74dbd485a5daa17a5fa7a8b0" translate="yes" xml:space="preserve">
          <source>If the pointer &lt;code&gt;P&lt;/code&gt; points at an element of an array with index &lt;code&gt;I&lt;/code&gt;, then</source>
          <target state="translated">Если указатель &lt;code&gt;P&lt;/code&gt; указывает на элемент массива с индексом &lt;code&gt;I&lt;/code&gt; , то</target>
        </trans-unit>
        <trans-unit id="6c7b266d1b59c8d3597834929777fbdb4b7e7282" translate="yes" xml:space="preserve">
          <source>If the quotient &lt;code&gt;a/b&lt;/code&gt; is not representable in the result type, the behavior of both &lt;code&gt;a/b&lt;/code&gt; and &lt;code&gt;a%b&lt;/code&gt; is undefined (that means &lt;code&gt;INT_MIN%-1&lt;/code&gt; is undefined on 2's complement systems).</source>
          <target state="translated">Если частное &lt;code&gt;a/b&lt;/code&gt; не представимо в типе результата, поведение &lt;code&gt;a/b&lt;/code&gt; и &lt;code&gt;a%b&lt;/code&gt; не определено (это означает, что &lt;code&gt;INT_MIN%-1&lt;/code&gt; не определен в системах дополнения 2).</target>
        </trans-unit>
        <trans-unit id="7ffc31d0b868412a85aac63a2d15275575b7998d" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;lrint&lt;/code&gt; or &lt;code&gt;llrint&lt;/code&gt; is outside the range representable by the return type, a domain error or a range error may occur.</source>
          <target state="translated">Если результат &lt;code&gt;lrint&lt;/code&gt; или &lt;code&gt;llrint&lt;/code&gt; находится за пределами диапазона, представляемого типом возвращаемого значения, может произойти ошибка домена или ошибка диапазона.</target>
        </trans-unit>
        <trans-unit id="622ba0546ebe6337384487d2c74de396ef013e92" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;lround&lt;/code&gt; or &lt;code&gt;llround&lt;/code&gt; is outside the range representable by the return type, a domain error or a range error may occur.</source>
          <target state="translated">Если результат &lt;code&gt;lround&lt;/code&gt; или &lt;code&gt;llround&lt;/code&gt; находится вне диапазона, представляемого типом возвращаемого значения, может произойти ошибка домена или ошибка диапазона.</target>
        </trans-unit>
        <trans-unit id="8eeeae32aeed1e098fc91dd8bd921c86fb200e23" translate="yes" xml:space="preserve">
          <source>If the result of the rounding is outside the range of the return type, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">Если результат округления находится за пределами диапазона возвращаемого типа, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается и возвращается значение, определенное реализацией</target>
        </trans-unit>
        <trans-unit id="028eee91596148e2d553d9c0585e4796bc1e1860" translate="yes" xml:space="preserve">
          <source>If the resulting value can be represented by the target type, that value is used</source>
          <target state="translated">Если результирующее значение может быть представлено типом цели,то используется это значение</target>
        </trans-unit>
        <trans-unit id="e979bc95923b9d4b1835c4ad27806c96fcb36b2c" translate="yes" xml:space="preserve">
          <source>If the return statement is used, the return value is used as the argument to the implicit call to &lt;code&gt;&lt;a href=&quot;../program/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; (see below for details). The values zero and &lt;code&gt;&lt;a href=&quot;../program/exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt; indicate successful termination, the value &lt;code&gt;&lt;a href=&quot;../program/exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt; indicates unsuccessful termination.</source>
          <target state="translated">Если используется оператор return, возвращаемое значение используется в качестве аргумента неявного вызова метода &lt;code&gt;&lt;a href=&quot;../program/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; (подробности см. Ниже). Значения ноль и &lt;code&gt;&lt;a href=&quot;../program/exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt; указывают на успешное завершение, значение &lt;code&gt;&lt;a href=&quot;../program/exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt; указывает на неудачное завершение.</target>
        </trans-unit>
        <trans-unit id="e166793b1a3e247cb1aa8707ba705ca2a49e53a0" translate="yes" xml:space="preserve">
          <source>If the return type is a real floating type, the result may be represented in &lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;greater range and precision&lt;/a&gt; than implied by the new type.</source>
          <target state="translated">Если возвращаемый тип является реальным плавающим типом, результат может быть представлен в &lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;большем диапазоне и точности,&lt;/a&gt; чем подразумевается новым типом.</target>
        </trans-unit>
        <trans-unit id="dc834aece2679899b19365c0e96b6a9287c774b2" translate="yes" xml:space="preserve">
          <source>If the return type of the main function is not &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt; with &lt;code&gt;int&lt;/code&gt; (e.g. &lt;code&gt;void main(void)&lt;/code&gt;), the value returned to the host environment is unspecified. If the returned type is compatible with int and control reaches the terminating &lt;code&gt;}&lt;/code&gt;, the value returned to the environment is the same as if executing &lt;code&gt;return 0;&lt;/code&gt;</source>
          <target state="translated">Если возвращаемый тип функции main не &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;совместим&lt;/a&gt; с &lt;code&gt;int&lt;/code&gt; (например, &lt;code&gt;void main(void)&lt;/code&gt; ), значение, возвращаемое в хост-среду, не указывается. Если возвращаемый тип совместим с int, и управление достигает конца &lt;code&gt;}&lt;/code&gt; , значение, возвращаемое в среду, совпадает с выполнением &lt;code&gt;return 0;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55096951d03276844009d4ac6ef2f86a40234649" translate="yes" xml:space="preserve">
          <source>If the returned value is &lt;code&gt;0&lt;/code&gt;, it will have the same sign as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Если возвращаемое значение равно &lt;code&gt;0&lt;/code&gt; , оно будет иметь тот же знак, что и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c0d5f1db5857afe2a215a274d4b5151e584e7b1" translate="yes" xml:space="preserve">
          <source>If the same identifier appears with both internal and external linkage in the same translation unit, the behavior is undefined. This is possible when &lt;a href=&quot;extern&quot;&gt;tentative definitions&lt;/a&gt; are used.</source>
          <target state="translated">Если один и тот же идентификатор отображается как с внутренней, так и с внешней связью в одной и той же единице перевода, поведение не определено. Это возможно при использовании &lt;a href=&quot;extern&quot;&gt;предварительных определений&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a404b81bd183a04af684a1dd83adbe457b397df0" translate="yes" xml:space="preserve">
          <source>If the second operand is zero, the behavior is undefined, except that if the IEEE floating-point arithmetic is supported, and the floating-point division is taking place, then.</source>
          <target state="translated">Если второй операнд равен нулю,поведение не определено,за исключением того,что если поддерживается арифметика IEEE с плавающей точкой,и происходит деление с плавающей точкой,то.</target>
        </trans-unit>
        <trans-unit id="87cda6e927c8b4be84e09f295f15129ed6308632" translate="yes" xml:space="preserve">
          <source>If the second operand is zero, the behavior is undefined.</source>
          <target state="translated">Если второй операнд равен нулю,поведение не определено.</target>
        </trans-unit>
        <trans-unit id="bfc275cb73a90eef9664528239ab4998157ab970" translate="yes" xml:space="preserve">
          <source>If the signal handler is called NOT as a result of &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;abort&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;raise&lt;/a&gt;&lt;/code&gt; (in other words, the signal handler is</source>
          <target state="translated">Если обработчик сигнала вызывается НЕ в результате &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;abort&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;raise&lt;/a&gt;&lt;/code&gt; (другими словами, обработчик сигнала</target>
        </trans-unit>
        <trans-unit id="88071f1c5c0e1b4839dab6e032d8012686be4323" translate="yes" xml:space="preserve">
          <source>If the signal handler is called as a result of &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;abort&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;raise&lt;/a&gt;&lt;/code&gt;, the behavior is undefined if the signal handler calls &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;raise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если обработчик сигнала вызывается в результате &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;abort&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;raise&lt;/a&gt;&lt;/code&gt; , поведение не определено, если обработчик сигнала вызывает &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;raise&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da5426c0f7f65abd2bcb02b6bd8cb6318ab19838" translate="yes" xml:space="preserve">
          <source>If the significand begins with the character sequence &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;, the floating constant is a</source>
          <target state="translated">Если значение и начинается с последовательности символов &lt;code&gt;0x&lt;/code&gt; или &lt;code&gt;0X&lt;/code&gt; , плавающая константа</target>
        </trans-unit>
        <trans-unit id="a7d0de34374ff61db0aaf9670764de6bb336cc95" translate="yes" xml:space="preserve">
          <source>If the size expression of a VLA has side effects, they are guaranteed to be produced except when it is a part of a sizeof expression whose result doesn't depend on it:</source>
          <target state="translated">Если выражение размера VLA имеет побочные эффекты,то они гарантированно будут получены,за исключением тех случаев,когда оно является частью выражения размера,результат которого не зависит от него:</target>
        </trans-unit>
        <trans-unit id="f5d5fbe264df8096d3f2dc04126bdd49bd7491ca" translate="yes" xml:space="preserve">
          <source>If the size is &lt;code&gt;*&lt;/code&gt;, the declaration is for a VLA of unspecified size. Such declaration may only appear in a function prototype scope, and declares an array of a complete type. In fact, all VLA declarators in function prototype scope are treated as if expression were replaced by &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">Если размер равен &lt;code&gt;*&lt;/code&gt; , объявление предназначено для VLA неопределенного размера. Такое объявление может появляться только в области действия прототипа функции и объявляет массив полного типа. Фактически, все деклараторы VLA в области действия прототипа функции обрабатываются так, как если бы выражение было заменено на &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5177cdc4e2a0570675a3bb78ff34b15988072e1" translate="yes" xml:space="preserve">
          <source>If the size of the array is known, it may be one less than the size of the string literal, in which case the terminating null character is ignored:</source>
          <target state="translated">Если размер массива известен,то он может быть на единицу меньше размера строкового литерала,в этом случае завершающий нулевой символ игнорируется:</target>
        </trans-unit>
        <trans-unit id="721f1a0ff5ac2a85a4aec48dc758c5efa06cf129" translate="yes" xml:space="preserve">
          <source>If the stream is open in binary mode, the value obtained by this function is the number of bytes from the beginning of the file.</source>
          <target state="translated">Если поток открыт в двоичном режиме,то значение,получаемое этой функцией,представляет собой количество байт от начала файла.</target>
        </trans-unit>
        <trans-unit id="fcf8e63ecc85a80b64f92483949ed9fe9401f63f" translate="yes" xml:space="preserve">
          <source>If the stream is open in text mode, the value returned by this function is unspecified and is only meaningful as the input to &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если поток открыт в текстовом режиме, значение, возвращаемое этой функцией, не определено и имеет смысл только как входные данные для &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b376b7c229a7bc07ebacea949f846a78b0d1782c" translate="yes" xml:space="preserve">
          <source>If the strings overlap, the behavior is undefined.</source>
          <target state="translated">Если строки перекрываются,поведение не определено.</target>
        </trans-unit>
        <trans-unit id="3737cc31b2abcb3a56ec3dc6ed19f293aa85246e" translate="yes" xml:space="preserve">
          <source>If the type is &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt; with the type-name of one of the associations, then the type, value, and &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; of the generic selection are the type, value, and value category of the expression that appears after the colon for that type-name.</source>
          <target state="translated">Если тип &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;совместим&lt;/a&gt; с именем типа одной из ассоциаций, то типом, значением и &lt;a href=&quot;value_category&quot;&gt;категорией&lt;/a&gt; значения универсального выбора являются тип, значение и категория значения выражения, которое появляется после двоеточия для этого типа. название.</target>
        </trans-unit>
        <trans-unit id="1bc5654858ffa7d0d01ecee82edcb9b073576512" translate="yes" xml:space="preserve">
          <source>If the type of expression is a &lt;a href=&quot;array&quot;&gt;variable-length array&lt;/a&gt; type, expression is evaluated and the size of the array it evaluates to is calculated at run time.</source>
          <target state="translated">Если тип выражения является типом &lt;a href=&quot;array&quot;&gt;массива переменной длины&lt;/a&gt; , выражение вычисляется, а размер массива, который он оценивает, вычисляется во время выполнения.</target>
        </trans-unit>
        <trans-unit id="12f6e191f6df5a1a3c1898e9217cac07ed6c3fc9" translate="yes" xml:space="preserve">
          <source>If the type of the expression is different from the return type of the function, its value is &lt;a href=&quot;conversion&quot;&gt;converted&lt;/a&gt; as if by assignment to an object whose type is the return type of the function, except that overlap between object representations is permitted:</source>
          <target state="translated">Если тип выражения отличается от возвращаемого типа функции, его значение &lt;a href=&quot;conversion&quot;&gt;преобразуется,&lt;/a&gt; как если бы оно присваивалось объекту, тип которого является возвращаемым типом функции, за исключением того, что допускается перекрытие представлений объекта:</target>
        </trans-unit>
        <trans-unit id="51577fdf94f044af450cebe5474487f90f5669ab" translate="yes" xml:space="preserve">
          <source>If the type of the next argument in &lt;code&gt;ap&lt;/code&gt; (after promotions) is not compatible with &lt;code&gt;T&lt;/code&gt;, the behavior is undefined, unless:</source>
          <target state="translated">Если тип следующего аргумента в &lt;code&gt;ap&lt;/code&gt; (после продвижения) не совместим с &lt;code&gt;T&lt;/code&gt; , поведение не определено, если только:</target>
        </trans-unit>
        <trans-unit id="6bd916ae26104ecdafe1a0e5b920d8734a873e18" translate="yes" xml:space="preserve">
          <source>If the type pointed to by the left operand is &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; or &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; qualified, the result is also qualified. If the type pointed to by the left operand is &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">Если тип, на который указывает левый операнд, является &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; или &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; , результат также будет квалифицирован. Если тип, на который указывает левый операнд, является &lt;a href=&quot;atomic&quot;&gt;атомарным&lt;/a&gt; , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="4e5a8e1c4de47df9c049e89509b9c8c93ba2202d" translate="yes" xml:space="preserve">
          <source>If the types after promotion are the same, that type is the common type</source>
          <target state="translated">Если типы после раскрутки одинаковы,то этот тип является общим типом</target>
        </trans-unit>
        <trans-unit id="9c7f76fec0807385297b756f7fec7a2af0fab97f" translate="yes" xml:space="preserve">
          <source>If the user defined function returns when handling &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGFPE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGILL&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGSEGV&lt;/a&gt;&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Если пользовательская функция возвращается при обработке &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGFPE&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGILL&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGSEGV&lt;/a&gt;&lt;/code&gt; , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="a38ca87a09a320d9b2a80a0bbdbced081dc9f136" translate="yes" xml:space="preserve">
          <source>If the user-defined signal handling strategy is not set using &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;signal()&lt;/a&gt;&lt;/code&gt; yet, it is implementation-defined whether the signal will be ignored or default handler will be invoked.</source>
          <target state="translated">Если определяемая пользователем стратегия обработки сигналов еще не установлена ​​с помощью &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;signal()&lt;/a&gt;&lt;/code&gt; , то определяется реализацией, будет ли сигнал игнорироваться или будет вызываться обработчик по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ec13f6251a6825cdac88c61231a28276817e1093" translate="yes" xml:space="preserve">
          <source>If the value can be represented by the target type exactly, it is unchanged</source>
          <target state="translated">Если значение может быть точно представлено типом цели,то оно не изменяется.</target>
        </trans-unit>
        <trans-unit id="95ab164f16af6b727b63cdf344a7e218377e5641" translate="yes" xml:space="preserve">
          <source>If the value of base is &lt;code&gt;​0​&lt;/code&gt;, the numeric base is auto-detected: if the prefix is &lt;code&gt;0&lt;/code&gt;, the base is octal, if the prefix is &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;, the base is hexadecimal, otherwise the base is decimal.</source>
          <target state="translated">Если значение основания составляет &lt;code&gt;​0​&lt;/code&gt; , цифровая база определяется автоматически: если префикс &lt;code&gt;0&lt;/code&gt; , базовая восьмеричный, если префикс &lt;code&gt;0x&lt;/code&gt; или &lt;code&gt;0X&lt;/code&gt; , основание представляет собой шестнадцатеричное, в противном случае основание представляет собой десятичное.</target>
        </trans-unit>
        <trans-unit id="7334be53a3a6aead6e653493f846debd16efe6cb" translate="yes" xml:space="preserve">
          <source>If the value of the integer constant is too big to fit in any of the types allowed by suffix/base combination and the compiler supports extended integer types (such as &lt;code&gt;__int128&lt;/code&gt;), the constant may be given the extended integer type; otherwise, the program is ill-formed.</source>
          <target state="translated">Если значение целочисленной константы слишком велико, чтобы поместиться в любой из типов, разрешенных комбинацией суффикс / основание, и компилятор поддерживает расширенные целочисленные типы (такие как &lt;code&gt;__int128&lt;/code&gt; ), константе может быть присвоен расширенный целочисленный тип; в противном случае программа некорректна.</target>
        </trans-unit>
        <trans-unit id="e8c33ee241a255a63ad79ee3a3348d39830a7425" translate="yes" xml:space="preserve">
          <source>If the value to be stored in &lt;code&gt;*exp&lt;/code&gt; is outside the range of &lt;code&gt;int&lt;/code&gt;, the behavior is unspecified.</source>
          <target state="translated">Если значение, которое будет сохранено в &lt;code&gt;*exp&lt;/code&gt; , выходит за пределы диапазона &lt;code&gt;int&lt;/code&gt; , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="eb75958a443f6e86954852258d39617127eed64b" translate="yes" xml:space="preserve">
          <source>If the wide character produced is the null character, the conversion state &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">Если полученный широкий символ является нулевым символом, состояние преобразования &lt;code&gt;*ps&lt;/code&gt; представляет начальное состояние сдвига.</target>
        </trans-unit>
        <trans-unit id="24382f133af9ec92a179262afb80b489903f3a55" translate="yes" xml:space="preserve">
          <source>If the wide character produced is the null character, the conversion state stored in &lt;code&gt;*ps&lt;/code&gt; is the initial shift state.</source>
          <target state="translated">Если полученный широкий символ является нулевым символом, состояние преобразования, сохраненное в &lt;code&gt;*ps&lt;/code&gt; , является исходным состоянием сдвига.</target>
        </trans-unit>
        <trans-unit id="ed6eb838a4bf569f0ac9d8a6b0442beca067eff8" translate="yes" xml:space="preserve">
          <source>If there are no definitions in the same translation unit, then the tentative definition acts as an actual definition with the initializer &lt;code&gt;= 0&lt;/code&gt; (or, for array, structure, and union types, &lt;code&gt;= {0}&lt;/code&gt;).</source>
          <target state="translated">Если в одной и той же единице перевода нет определений, то предварительное определение действует как фактическое определение с инициализатором &lt;code&gt;= 0&lt;/code&gt; (или для типов массива, структуры и объединения &lt;code&gt;= {0}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5ad5bb4cb8a4c8fd94ac2c60706e21c574d83a99" translate="yes" xml:space="preserve">
          <source>If there are threads waiting on &lt;code&gt;cond&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Если есть потоки, ожидающие на &lt;code&gt;cond&lt;/code&gt; , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="88ca6553aa1a0106ab7a752d78d47abe8b72c1f7" translate="yes" xml:space="preserve">
          <source>If there are threads waiting on &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Если на &lt;code&gt;mutex&lt;/code&gt; ожидают потоки , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="61d2beb5e2bdfe94bb416348038a9626b5e9e8b4" translate="yes" xml:space="preserve">
          <source>If there is no corresponding call to &lt;code&gt;va_start&lt;/code&gt; or &lt;code&gt;va_copy&lt;/code&gt;, or if &lt;code&gt;va_end&lt;/code&gt; is not called before a function that calls &lt;code&gt;va_start&lt;/code&gt; or &lt;code&gt;va_copy&lt;/code&gt; returns, the behavior is undefined.</source>
          <target state="translated">Если нет соответствующего вызова &lt;code&gt;va_start&lt;/code&gt; или &lt;code&gt;va_copy&lt;/code&gt; , или если &lt;code&gt;va_end&lt;/code&gt; не вызывается до того, как функция, которая вызывает &lt;code&gt;va_start&lt;/code&gt; или &lt;code&gt;va_copy&lt;/code&gt; , возвращает поведение, оно не определено.</target>
        </trans-unit>
        <trans-unit id="08e7e744ae0e0c5037802c6defe497d81baa4ef8" translate="yes" xml:space="preserve">
          <source>If there is not enough memory, the old memory block is not freed and null pointer is returned.</source>
          <target state="translated">Если памяти недостаточно,старый блок памяти не освобождается и возвращается нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="ee7516e91d5c31a3de2564cfd0a851bd2bacc6e3" translate="yes" xml:space="preserve">
          <source>If there was a &lt;code&gt;memory_order_seq_cst&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;atomic_thread_fence&lt;/a&gt;&lt;/code&gt; operation X</source>
          <target state="translated">Если была операция &lt;code&gt;memory_order_seq_cst&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;atomic_thread_fence&lt;/a&gt;&lt;/code&gt; X</target>
        </trans-unit>
        <trans-unit id="841f871b77e90b3c2ebee1d6abab2424892ee08b" translate="yes" xml:space="preserve">
          <source>If two declarations refer to the same object or function and do not use compatible types, the behavior of the program is undefined.</source>
          <target state="translated">Если две декларации относятся к одному и тому же объекту или функции и не используют совместимые типы,поведение программы является неопределенным.</target>
        </trans-unit>
        <trans-unit id="223e129549fa6e80a770c99896328737e1358c03" translate="yes" xml:space="preserve">
          <source>If two different entities named by the same identifier are in scope at the same time, and they belong to the same &lt;a href=&quot;name_space&quot;&gt;name space&lt;/a&gt;, the scopes are nested (no other form of scope overlap is allowed), and the declaration that appears in the inner scope hides the declaration that appears in the outer scope:</source>
          <target state="translated">Если две разные сущности, названные одним и тем же идентификатором, находятся в области действия одновременно, и они принадлежат одному и тому же &lt;a href=&quot;name_space&quot;&gt;пространству имен&lt;/a&gt; , области являются вложенными (никакая другая форма перекрытия области действия не допускается), и объявление, которое появляется во внутренней области действия скрывает объявление, которое появляется во внешней области видимости:</target>
        </trans-unit>
        <trans-unit id="9555605dc10e8d1cfa1ba2ec453aef90da3623dc" translate="yes" xml:space="preserve">
          <source>If two objects have the same object representation, they compare equal (except if they are floating-point NaNs). The opposite is not true: two objects that compare equal may have different object representations because not every bit of the object representation needs to participate in the value. Such bits may be used for padding to satisfy alignment requirement, for parity checks, to indicate trap representations, etc.</source>
          <target state="translated">Если два объекта имеют одно и то же объектное представление,то они сравнивают равные (за исключением случаев,когда они являются NaN с плавающей точкой).Обратное не верно:два объекта,сравнивающие равные,могут иметь разное объектное представление,потому что не каждый бит объектного представления должен участвовать в значении.Такие биты могут быть использованы для подкладки,чтобы удовлетворить требование выравнивания,для проверки четности,для обозначения ловушек представления и т.д.</target>
        </trans-unit>
        <trans-unit id="98ae7c89c9a1f0579125868580a2c5d0580d1b22" translate="yes" xml:space="preserve">
          <source>If type is a &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt; type and changing the value of its size expression would not affect the result of sizeof, it is unspecified whether or not the size expression is evaluated.</source>
          <target state="translated">Если тип является типом &lt;a href=&quot;array&quot;&gt;VLA,&lt;/a&gt; и изменение значения его выражения размера не повлияет на результат sizeof, не определено, оценивается ли выражение размера.</target>
        </trans-unit>
        <trans-unit id="daf8fb6ff7350d1f9d6d831812256477f230a799" translate="yes" xml:space="preserve">
          <source>If type is a &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt; type, its size expression is not evaluated.</source>
          <target state="translated">Если тип является типом &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt; , его выражение размера не оценивается.</target>
        </trans-unit>
        <trans-unit id="45544c60e34e062c2ebe20cb821c8b11c8086f96" translate="yes" xml:space="preserve">
          <source>If type-name is &lt;code&gt;void&lt;/code&gt;, then expression is evaluated for its side-effects and its returned value is discarded, same as when expression is used on its own, as an &lt;a href=&quot;statements#Expression_statements&quot;&gt;expression statement&lt;/a&gt;.</source>
          <target state="translated">Если type-name равно &lt;code&gt;void&lt;/code&gt; , тогда выражение оценивается на предмет его побочных эффектов, а возвращаемое значение отбрасывается, так же как и когда выражение используется само по себе, как &lt;a href=&quot;statements#Expression_statements&quot;&gt;выражение выражения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f66ab74451a3db452059ec3845f07a89e06bbf3" translate="yes" xml:space="preserve">
          <source>If wc is the null wide character &lt;code&gt;L'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">Если wc является широким нулевым символом &lt;code&gt;L'\0'&lt;/code&gt; , сохраняется нулевой байт, которому предшествует любая последовательность сдвигов, необходимая для восстановления начального состояния сдвига, а параметр &lt;code&gt;*ps&lt;/code&gt; состояния преобразования обновляется для представления начального состояния сдвига.</target>
        </trans-unit>
        <trans-unit id="5d7984b921742f401d05ed8114115076c505fbda" translate="yes" xml:space="preserve">
          <source>If when &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; was called, a &lt;a href=&quot;../language/array&quot;&gt;VLA&lt;/a&gt; or another &lt;a href=&quot;../language/declarations&quot;&gt;variably-modified type&lt;/a&gt; variable was in scope and control left that scope, &lt;code&gt;longjmp&lt;/code&gt; to that &lt;code&gt;setjmp&lt;/code&gt; invokes undefined behavior even if control remained within the function.</source>
          <target state="translated">Если при вызове &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../language/array&quot;&gt; VLA&lt;/a&gt; или другая &lt;a href=&quot;../language/declarations&quot;&gt;переменно-измененная&lt;/a&gt; переменная типа находились в области видимости, и управление оставляло эту область видимости, &lt;code&gt;longjmp&lt;/code&gt; для этого &lt;code&gt;setjmp&lt;/code&gt; вызывает неопределенное поведение, даже если управление оставалось внутри функции.</target>
        </trans-unit>
        <trans-unit id="32c015539aa6def36ac45f02ee69383d444c9a17" translate="yes" xml:space="preserve">
          <source>If width specifier is used, matches up to</source>
          <target state="translated">Если используется спецификатор ширины,то соответствует до</target>
        </trans-unit>
        <trans-unit id="80643aeb5f10297c8773a32774b36761e19c9f6e" translate="yes" xml:space="preserve">
          <source>If x is zero and y is infinite or if x is infinite and y is zero, and z is a NaN, then NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если x равен нулю и y бесконечен или если x бесконечен и y равен нулю, а z является NaN, то возвращается NaN, и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен</target>
        </trans-unit>
        <trans-unit id="217b0f1a492e46dd9c7d22b89fac1d204972e19f" translate="yes" xml:space="preserve">
          <source>If x is zero and y is infinite or if x is infinite and y is zero, and z is not a NaN, then NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если х равен нулю , а у бесконечен или , если х бесконечно и у равна нулю, а г не является NaN, то NaN , возвращается и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; поднимается</target>
        </trans-unit>
        <trans-unit id="46f35d1f1e835536b48c1d1451cead305f826b6a" translate="yes" xml:space="preserve">
          <source>If x or y are NaN, NaN is returned</source>
          <target state="translated">Если x или y-NaN,NaN возвращается.</target>
        </trans-unit>
        <trans-unit id="448389c4ec48e9adff6b8542b1d7d5e0005baf1b" translate="yes" xml:space="preserve">
          <source>If x*y is an exact infinity and z is an infinity with the opposite sign, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если х * у является точной бесконечностью и г представляет собой бесконечность с противоположным знаком, NaN возвращается и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; поднимается</target>
        </trans-unit>
        <trans-unit id="dee1d062b9bd3ef2ac4463366425592d8bf6079d" translate="yes" xml:space="preserve">
          <source>If z is NaN, and x*y aren't 0*Inf or Inf*0, then NaN is returned (without FE_INVALID)</source>
          <target state="translated">Если z-NaN,а x*y-не 0*Inf или Inf*0,то возвращается NaN (без FE_INVALID)</target>
        </trans-unit>
        <trans-unit id="fede8b50b6882e5d3ce2a02e4778a6b33e6bfd1e" translate="yes" xml:space="preserve">
          <source>If |arg| &amp;gt; 1, a domain error occurs and NaN is returned.</source>
          <target state="translated">Если | arg | &amp;gt; 1, возникает ошибка домена и возвращается NaN.</target>
        </trans-unit>
        <trans-unit id="24d2b4c0d32e555ffdf12e4f24627c557a463748" translate="yes" xml:space="preserve">
          <source>If, after copying the terminating null character from &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; is not reached, additional null characters are written to &lt;code&gt;dest&lt;/code&gt; until the total of &lt;code&gt;count&lt;/code&gt; characters have been written.</source>
          <target state="translated">Если после копирования завершающего нулевого символа из &lt;code&gt;src&lt;/code&gt; , &lt;code&gt;count&lt;/code&gt; не будет достигнуто, дополнительные символы нуль не записываются &lt;code&gt;dest&lt;/code&gt; до тех пор , в общей сложности &lt;code&gt;count&lt;/code&gt; символов были написаны.</target>
        </trans-unit>
        <trans-unit id="d6321b986a2eb461234e0b8b628d35dcf35b6aeb" translate="yes" xml:space="preserve">
          <source>If, after copying the terminating null wide character from &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; is not reached, additional null wide characters are written to &lt;code&gt;dest&lt;/code&gt; until the total of &lt;code&gt;count&lt;/code&gt; characters have been written.</source>
          <target state="translated">Если после копирования завершающих нулевого символа из &lt;code&gt;src&lt;/code&gt; , &lt;code&gt;count&lt;/code&gt; не будет достигнут, дополнительные нулевые широкие символы не записываются в &lt;code&gt;dest&lt;/code&gt; , пока сумма &lt;code&gt;count&lt;/code&gt; символов были написана.</target>
        </trans-unit>
        <trans-unit id="80a00e268ece0e7d2466a182844868cebe8b45a3" translate="yes" xml:space="preserve">
          <source>If, after this, there remain keys with both non-null destructors and values (e.g. if a destructor executed &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt;), the process is repeated up to &lt;code&gt;&lt;a href=&quot;tss_dtor_iterations&quot;&gt;TSS_DTOR_ITERATIONS&lt;/a&gt;&lt;/code&gt; times.</source>
          <target state="translated">Если после этого остаются ключи с ненулевыми деструкторами и значениями (например, если деструктор выполнил &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt; ), процесс повторяется до времени &lt;code&gt;&lt;a href=&quot;tss_dtor_iterations&quot;&gt;TSS_DTOR_ITERATIONS&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e769494ea641bd01735c8978b12dae80bc631fc2" translate="yes" xml:space="preserve">
          <source>Illegal byte sequence</source>
          <target state="translated">Незаконная последовательность байтов</target>
        </trans-unit>
        <trans-unit id="cbd90c1ef775b6befeb73f8b124d85864e006bb9" translate="yes" xml:space="preserve">
          <source>Imaginary floating types</source>
          <target state="translated">Воображаемые плавающие типы</target>
        </trans-unit>
        <trans-unit id="1d30ec43fa429c9d0766e648d3f7f8e3ad1d4ed4" translate="yes" xml:space="preserve">
          <source>Imaginary floating types model the mathematical &lt;a href=&quot;https://en.wikipedia.org/wiki/Imaginary_number&quot;&gt;imaginary numbers&lt;/a&gt;, that is numbers that can be written as a real number multiplied by the imaginary unit: bi The three imaginary types are.</source>
          <target state="translated">Воображаемые плавающие типы моделируют математические &lt;a href=&quot;https://en.wikipedia.org/wiki/Imaginary_number&quot;&gt;мнимые числа&lt;/a&gt; , то есть числа, которые можно записать как действительное число, умноженное на мнимую единицу: bi Три мнимых типа - это.</target>
        </trans-unit>
        <trans-unit id="b1d3e8b209c294bf41ce4e3c74295f5bddf2df6e" translate="yes" xml:space="preserve">
          <source>Imaginary numbers are supported if &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; is defined.</source>
          <target state="translated">Мнимые числа поддерживаются, если определено &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ac24adafbd8260df30bab34514422a754478f65" translate="yes" xml:space="preserve">
          <source>Imaginary numbers may be used with &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; + - * and /, possibly mixed with complex and real numbers. There are many mathematical functions defined for imaginary numbers in &lt;a href=&quot;../numeric/complex&quot;&gt;complex.h&lt;/a&gt;. Both built-in operators and library functions may raise floating-point exceptions and set &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; as described in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;&lt;code&gt;math_errhandling&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Мнимые числа могут использоваться с &lt;a href=&quot;operator_arithmetic&quot;&gt;арифметическими операторами&lt;/a&gt; + - * и /, возможно, смешанными с комплексными и действительными числами. Есть много математических функций, определенных для мнимых чисел в &lt;a href=&quot;../numeric/complex&quot;&gt;complex.h&lt;/a&gt; . Как встроенные операторы, так и библиотечные функции могут вызывать исключения с плавающей точкой и устанавливать &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; , как описано в &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt; &lt;code&gt;math_errhandling&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="071df3b35cc3962c55cc856d63ca45738b9079cf" translate="yes" xml:space="preserve">
          <source>Imaginary type conversions</source>
          <target state="translated">Преобразование воображаемого типа</target>
        </trans-unit>
        <trans-unit id="c1671e6d41c5fac09c8aefb864f138445a7d1a21" translate="yes" xml:space="preserve">
          <source>Imaginary types also simplify implementations; multiplication of an imaginary by a complex can be implemented straightforwardly with two multiplications if the imaginary types are supported, instead of four multiplications and two additions.</source>
          <target state="translated">Воображаемые типы также упрощают реализацию;умножение воображаемого комплекса на комплекс может быть реализовано просто с помощью двух умножений,если поддерживаются воображаемые типы,вместо четырех умножений и двух сложений.</target>
        </trans-unit>
        <trans-unit id="1bec87acbedb55cac0fd8887b67c78afe18b54a1" translate="yes" xml:space="preserve">
          <source>Implementation defined behavior control</source>
          <target state="translated">Внедрение контроля определенного поведения</target>
        </trans-unit>
        <trans-unit id="dd1e3f977c02056ea472998c02c487e2316720f9" translate="yes" xml:space="preserve">
          <source>Implementation defined behavior is controlled by &lt;code&gt;#pragma&lt;/code&gt; directive.</source>
          <target state="translated">Поведение, определяемое реализацией, контролируется директивой &lt;code&gt;#pragma&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="667c8eda998c1c080db13b731500db6f8a8c9f3c" translate="yes" xml:space="preserve">
          <source>Implementation-defined value. If &lt;code&gt;command&lt;/code&gt; is a null pointer, returns a nonzero value if and only if the command processor exists.</source>
          <target state="translated">Значение, определяемое реализацией. Если &lt;code&gt;command&lt;/code&gt; является нулевым указателем, возвращает ненулевое значение тогда и только тогда, когда существует командный процессор.</target>
        </trans-unit>
        <trans-unit id="45a8270c1f150f433969e0be81b809f633b9a469" translate="yes" xml:space="preserve">
          <source>Implementations usually guarantee precision of less than 1 ulp (units in the last place): &lt;a href=&quot;http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/ieee754/dbl-64/e_hypot.c&quot;&gt;GNU&lt;/a&gt;, &lt;a href=&quot;http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/e_hypot.c?rev=1.13.4.2;content-type=text%2Fplain&quot;&gt;BSD&lt;/a&gt;, &lt;a href=&quot;http://www.open64.net/doc/d5/d3f/hypot_8c-source.html&quot;&gt;Open64&lt;/a&gt;.</source>
          <target state="translated">Реализации обычно гарантируют точность менее 1 ulp (единицы на последнем месте): &lt;a href=&quot;http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/ieee754/dbl-64/e_hypot.c&quot;&gt;GNU&lt;/a&gt; , &lt;a href=&quot;http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/e_hypot.c?rev=1.13.4.2;content-type=text%2Fplain&quot;&gt;BSD&lt;/a&gt; , &lt;a href=&quot;http://www.open64.net/doc/d5/d3f/hypot_8c-source.html&quot;&gt;Open64&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f38913e8ddeb1738019c4e8b2862059b04b95a9" translate="yes" xml:space="preserve">
          <source>Implicit conversion semantics</source>
          <target state="translated">Семантика неявного преобразования</target>
        </trans-unit>
        <trans-unit id="4f8e035635a982fad59fd7e5400a816066289eb5" translate="yes" xml:space="preserve">
          <source>Implicit conversion, whether</source>
          <target state="translated">Неявное преобразование,будь то</target>
        </trans-unit>
        <trans-unit id="a454cb8b77503090cbd9a357441f356bcc77421b" translate="yes" xml:space="preserve">
          <source>Implicit conversions</source>
          <target state="translated">Неявные преобразования</target>
        </trans-unit>
        <trans-unit id="bfcc4d9c93f1e4e027da44f6460a88f24fa14bab" translate="yes" xml:space="preserve">
          <source>Implicit initialization</source>
          <target state="translated">Неявная инициализация</target>
        </trans-unit>
        <trans-unit id="27328a2eb2f15815a68b1653d19575045b8cf992" translate="yes" xml:space="preserve">
          <source>In 2's complement systems, the absolute value of the most-negative value is out of range, e.g. for 32-bit 2's complement type int, INT_MIN is -2147483648, but the would-be result 2147483648 is greater than INT_MAX, which is 2147483647.</source>
          <target state="translated">В системах комплемента 2 абсолютное значение самой отрицательной величины находится вне диапазона,например,для 32-битного 2-го типа комплемента int,INT_MIN равен -2147483648,а потенциальный результат 2147483648 больше INT_MAX,то есть 2147483647.</target>
        </trans-unit>
        <trans-unit id="00e7a8610b1ed817d9eb7670aae30608024360a9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;scalar_initialization&quot;&gt;scalar initialization&lt;/a&gt;, the value of the initializer expression is converted to the unqualified type of the object being initialized</source>
          <target state="translated">При &lt;a href=&quot;scalar_initialization&quot;&gt;скалярной инициализации&lt;/a&gt; значение выражения инициализатора преобразуется в неквалифицированный тип инициализируемого объекта.</target>
        </trans-unit>
        <trans-unit id="07197e53e1c1900f95e26e0b0ed8484511ced3aa" translate="yes" xml:space="preserve">
          <source>In C++, assignment operators are lvalue expressions, not so in C.</source>
          <target state="translated">В Си++операторами присваивания являются выражения lvalue,в Си-нет.</target>
        </trans-unit>
        <trans-unit id="6e1eee7ba9e6a0e28c2ac33889b5015519c15749" translate="yes" xml:space="preserve">
          <source>In C++, ordinary character constants have type &lt;code&gt;char&lt;/code&gt;, rather than &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">В C ++ обычные символьные константы имеют тип &lt;code&gt;char&lt;/code&gt; , а не &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f90570f1ba0f2c22b611733a6dce8d3bfd3291e7" translate="yes" xml:space="preserve">
          <source>In C++, the &lt;code&gt;alignas&lt;/code&gt; specifier may also be applied to the declarations of class/struct/union types and enumerations. This is not supported in C, but the alignment of a struct type can be controlled by using alignas in a member declaration (as of DR 444).</source>
          <target state="translated">В C ++ &lt;code&gt;alignas&lt;/code&gt; также может применяться к объявлениям типов / перечислений класса / структуры / объединения. Это не поддерживается в C, но выравнивание типа структуры можно контролировать с помощью alignas в объявлении члена (с DR 444).</target>
        </trans-unit>
        <trans-unit id="16b073c98afd277d979d0d1b7c6ad0620c603d70" translate="yes" xml:space="preserve">
          <source>In C++, the conditional operator has the same precedence as assignment operators, and prefix &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; and assignment operators don't have the restrictions about their operands.</source>
          <target state="translated">В C ++ условный оператор имеет тот же приоритет, что и операторы присваивания, а префикс &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;--&lt;/code&gt; и операторы присваивания не имеют ограничений относительно своих операндов.</target>
        </trans-unit>
        <trans-unit id="be29bb247378721617bd09a6c37e9883befb6d2c" translate="yes" xml:space="preserve">
          <source>In C++, unary operator + can also be used with other built-in types such as arrays and functions, not so in C.</source>
          <target state="translated">В C++унарный оператор+может использоваться и с другими встроенными типами,такими как массивы и функции,но не в C.</target>
        </trans-unit>
        <trans-unit id="888861ed244a4e6c1b00d2e50051a54c4e1bec80" translate="yes" xml:space="preserve">
          <source>In C, the braced list of an initializer cannot be empty. C++ allows empty list:</source>
          <target state="translated">В C прикрепленный список инициализатора не может быть пустым.С++позволяет использовать пустой список:</target>
        </trans-unit>
        <trans-unit id="753a99a5b8f4f54ed3b2aae026243d00a9149dad" translate="yes" xml:space="preserve">
          <source>In C, the braced list of initializers cannot be empty (note that C++ allows empty lists, and also note that a &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; in C cannot be empty):</source>
          <target state="translated">В C список инициализаторов в скобках не может быть пустым (обратите внимание, что C ++ допускает пустые списки, а также обратите внимание, что &lt;a href=&quot;struct&quot;&gt;структура&lt;/a&gt; в C не может быть пустой):</target>
        </trans-unit>
        <trans-unit id="4df80b3a143adc8cece1ace5ccec2ef9426cb010" translate="yes" xml:space="preserve">
          <source>In C11 as published, unlike &lt;code&gt;&lt;a href=&quot;mbrtoc16&quot;&gt;mbrtoc16&lt;/a&gt;&lt;/code&gt;, which converts variable-width multibyte (such as UTF-8) to variable-width 16-bit (such as UTF-16) encoding, this function can only convert single-unit 16-bit encoding, meaning it cannot convert UTF-16 to UTF-8 despite that being the original intent of this function. This was corrected by the post-C11 defect report &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/WG14/www/docs/summary.htm#dr_488&quot;&gt;DR488&lt;/a&gt;.</source>
          <target state="translated">В опубликованном C11, в отличие от &lt;code&gt;&lt;a href=&quot;mbrtoc16&quot;&gt;mbrtoc16&lt;/a&gt;&lt;/code&gt; , который преобразует многобайтовую (например, UTF-8) переменную ширину в 16-битное (например, UTF-16) кодирование с переменной шириной, эта функция может преобразовывать только 16-битное кодирование одной единицы, это означает, что он не может конвертировать UTF-16 в UTF-8, несмотря на то, что это было первоначальным намерением этой функции. Это было исправлено в отчете о &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/WG14/www/docs/summary.htm#dr_488&quot;&gt;дефектах&lt;/a&gt; после С11 DR488 .</target>
        </trans-unit>
        <trans-unit id="bfa2fd46abee60000979a7c0d0195215fe83ddb7" translate="yes" xml:space="preserve">
          <source>In C89, declarations within any &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt; (block scope) must appear in the beginning of the block, before any &lt;a href=&quot;statements&quot;&gt;statements&lt;/a&gt;.</source>
          <target state="translated">В C89 объявления в любом &lt;a href=&quot;statements#Compound_statements&quot;&gt;составном операторе&lt;/a&gt; (область видимости блока) должны появляться в начале блока перед любыми &lt;a href=&quot;statements&quot;&gt;операторами&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5afc6f0bbafec1d95aa424d9ab7eafe8f8a41cd" translate="yes" xml:space="preserve">
          <source>In C89, specifiers-and-qualifiers was optional, and if omitted, the return type of the function defaulted to &lt;code&gt;int&lt;/code&gt; (possibly amended by the declarator).</source>
          <target state="translated">В C89 спецификаторы-и-квалификаторы были необязательными, и, если они опущены, тип возвращаемого значения функции по умолчанию равен &lt;code&gt;int&lt;/code&gt; (возможно, изменен декларатором).</target>
        </trans-unit>
        <trans-unit id="c59c494dc7b28d6f1ae3f3e1fba28d7c33f040e5" translate="yes" xml:space="preserve">
          <source>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:</source>
          <target state="translated">В IS0 8601 неделя начинается с понедельника и первая неделя года должна соответствовать следующим требованиям:</target>
        </trans-unit>
        <trans-unit id="1b5f53a8b39a3373273d1bd5448850b45c7282a2" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;operator_other&quot;&gt;function-call expression&lt;/a&gt;, to a function that has a prototype, the value of each argument expression is converted to the type of the unqualified declared types of the corresponding parameter</source>
          <target state="translated">В &lt;a href=&quot;operator_other&quot;&gt;выражении вызова функции&lt;/a&gt; для функции, имеющей прототип, значение каждого выражения аргумента преобразуется в тип неквалифицированных объявленных типов соответствующего параметра.</target>
        </trans-unit>
        <trans-unit id="e543016c2da1dbc421ea862e63a18dfd16a6409d" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call expression&lt;/a&gt; when the call is made to.</source>
          <target state="translated">В &lt;a href=&quot;operator_other#Function_call&quot;&gt;выражении вызова функции&lt;/a&gt; при вызове.</target>
        </trans-unit>
        <trans-unit id="b3db14f2b46d8b0aa95c66919fa6a6c2e01549c3" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;return&quot;&gt;return statement&lt;/a&gt;, the value of the operand of &lt;code&gt;return&lt;/code&gt; is converted to an object having the return type of the function</source>
          <target state="translated">В операторе &lt;a href=&quot;return&quot;&gt;возврата&lt;/a&gt; значение операнда &lt;code&gt;return&lt;/code&gt; преобразуется в объект, имеющий тип возврата функции</target>
        </trans-unit>
        <trans-unit id="f1afbd501ff06c0957f44b840912fccdb54dcc9f" translate="yes" xml:space="preserve">
          <source>In a C program, the declarations referring to the same object or function in</source>
          <target state="translated">В программе на языке Си декларации,относящиеся к одному и тому же объекту или функции в</target>
        </trans-unit>
        <trans-unit id="dcb8b0b9734c917ca0765e9a7a94eaa46af9b402" translate="yes" xml:space="preserve">
          <source>In a function declaration, the keyword &lt;code&gt;const&lt;/code&gt; may appear inside the square brackets that are used to declare an array type of a function parameter. It qualifies the pointer type to which the array type is transformed.</source>
          <target state="translated">В объявлении функции ключевое слово &lt;code&gt;const&lt;/code&gt; может появляться в квадратных скобках, которые используются для объявления типа массива параметра функции. Он определяет тип указателя, в который преобразуется тип массива.</target>
        </trans-unit>
        <trans-unit id="9b54013284053a729eab7abaa9d5a083da83f62f" translate="yes" xml:space="preserve">
          <source>In a function declaration, the keyword &lt;code&gt;restrict&lt;/code&gt; may appear inside the square brackets that are used to declare an array type of a function parameter. It qualifies the pointer type to which the array type is transformed:</source>
          <target state="translated">В объявлении функции ключевое слово &lt;code&gt;restrict&lt;/code&gt; может появляться в квадратных скобках, которые используются для объявления типа массива параметра функции. Он определяет тип указателя, в который преобразуется тип массива:</target>
        </trans-unit>
        <trans-unit id="91f77fb9039b1b47cdb217206e779839523dbb48" translate="yes" xml:space="preserve">
          <source>In a function declaration, the keyword &lt;code&gt;volatile&lt;/code&gt; may appear inside the square brackets that are used to declare an array type of a function parameter. It qualifies the pointer type to which the array type is transformed.</source>
          <target state="translated">В объявлении функции ключевое слово &lt;code&gt;volatile&lt;/code&gt; может появляться в квадратных скобках, которые используются для объявления типа массива параметра функции. Он определяет тип указателя, в который преобразуется тип массива.</target>
        </trans-unit>
        <trans-unit id="661f71b2988adf25d44185c62a4b846d68c48b5c" translate="yes" xml:space="preserve">
          <source>In addition to changing the file position indicator, &lt;code&gt;fseek&lt;/code&gt; undoes the effects of &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt; and clears the end-of-file status, if applicable.</source>
          <target state="translated">Помимо изменения индикатора положения файла, &lt;code&gt;fseek&lt;/code&gt; отменяет эффекты &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt; и очищает состояние конца файла, если это применимо.</target>
        </trans-unit>
        <trans-unit id="b35dbcc1e0f0f5cd4a002df2770d4491982f6eca" translate="yes" xml:space="preserve">
          <source>In addition to the complex types, the three imaginary types may be supported: &lt;code&gt;double _Imaginary&lt;/code&gt;, &lt;code&gt;float _Imaginary&lt;/code&gt;, and &lt;code&gt;long double _Imaginary&lt;/code&gt; (see &lt;a href=&quot;../keyword/_imaginary&quot;&gt;_Imaginary&lt;/a&gt;). When the header &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; is included, the three imaginary types are also accessible as &lt;code&gt;double imaginary&lt;/code&gt;, &lt;code&gt;float imaginary&lt;/code&gt;, and &lt;code&gt;long double imaginary&lt;/code&gt;.</source>
          <target state="translated">В дополнение к сложным типам могут поддерживаться три мнимых типа: &lt;code&gt;double _Imaginary&lt;/code&gt; , &lt;code&gt;float _Imaginary&lt;/code&gt; и &lt;code&gt;long double _Imaginary&lt;/code&gt; (см. &lt;a href=&quot;../keyword/_imaginary&quot;&gt;_Imaginary&lt;/a&gt; ). Когда включен заголовок &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; , три мнимых типа также доступны как &lt;code&gt;double imaginary&lt;/code&gt; , &lt;code&gt;float imaginary&lt;/code&gt; и &lt;code&gt;long double imaginary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96d044a1b0cd5e52efeec3c718c75e91fa8170ae" translate="yes" xml:space="preserve">
          <source>In addition to the implicit conversions, the following conversions are allowed:</source>
          <target state="translated">В дополнение к неявным конверсиям допускаются следующие конверсии:</target>
        </trans-unit>
        <trans-unit id="55f680af8a4672d6d70c077e3b55562b152fd0d3" translate="yes" xml:space="preserve">
          <source>In addition, old-style definition didn't require a declaration for every parameter in declaration-list. Any parameter whose declaration was missing had type &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">Кроме того, определение старого стиля не требует объявления для каждого параметра в объявлении-списке. Любой параметр, объявление которого отсутствовало, имел тип &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33a1d90854c6b62d20682a431d3deb3e352e1570" translate="yes" xml:space="preserve">
          <source>In addition, volatile accesses are not atomic (concurrent read and write is a &lt;a href=&quot;../language/memory_model&quot;&gt;data race&lt;/a&gt;) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access).</source>
          <target state="translated">Кроме того, энергозависимые обращения не являются атомарными (одновременное чтение и запись - это &lt;a href=&quot;../language/memory_model&quot;&gt;гонка данных&lt;/a&gt; ) и не упорядочивают память (доступ к энергонезависимой памяти может свободно переупорядочиваться вокруг энергозависимого доступа).</target>
        </trans-unit>
        <trans-unit id="e58e6d192ec64176fdc1379f81dba51aa0d986c8" translate="yes" xml:space="preserve">
          <source>In all other cases, the result is exact (&lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised) and &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">Во всех остальных случаях результат является точным ( &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; никогда не поднимается), а &lt;a href=&quot;../fenv/fe_round&quot;&gt;текущий режим округления&lt;/a&gt; игнорируется.</target>
        </trans-unit>
        <trans-unit id="2caa1bc25941d7d072a18d3a94ff53e51be29ee7" translate="yes" xml:space="preserve">
          <source>In any case (both when executing an implicit conversion and in the same-type cast), if expression and type-name are floating types and expression is represented with greater range and precision than its type indicates (see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;, the range and precision are stripped off to match the target type.</source>
          <target state="translated">В любом случае (как при выполнении неявного преобразования, так и при приведении того же типа), если выражение и имя-типа являются плавающими типами, а выражение представлено с большим диапазоном и точностью, чем указывает его тип (см. &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; , диапазон и точность раздели, чтобы соответствовать целевому типу.</target>
        </trans-unit>
        <trans-unit id="922077a331c0fe9a078f343032d119067ea97aa1" translate="yes" xml:space="preserve">
          <source>In any case, &lt;code&gt;gets_s&lt;/code&gt; first finishes reading and discarding the characters from &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; until new-line character, end-of-file condition, or read error before calling the constraint handler.</source>
          <target state="translated">В любом случае, &lt;code&gt;gets_s&lt;/code&gt; сначала заканчивает чтение и отбрасывание символов от &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; до символа новой строки, условия конца файла или ошибки чтения перед вызовом обработчика ограничения.</target>
        </trans-unit>
        <trans-unit id="c1fd722202cbcd28513d3d1f6696d6cc82e484b7" translate="yes" xml:space="preserve">
          <source>In any case, the behavior is undefined if rhs is negative or is greater or equal the number of bits in the promoted lhs.</source>
          <target state="translated">В любом случае,поведение не определено,если rhs отрицательный или больше или равно количеству битов в выдвинутых lhs.</target>
        </trans-unit>
        <trans-unit id="d317d4e7fe2ec42ae19ec71757d499c2504a3bd1" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;&lt;a href=&quot;fmod&quot;&gt;fmod()&lt;/a&gt;&lt;/code&gt;, the returned value is not guaranteed to have the same sign as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;fmod&quot;&gt;fmod()&lt;/a&gt;&lt;/code&gt; , возвращаемое значение не обязательно имеет тот же знак, что и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7448c71f37984dda228a612a7fe2cff9d0abde9" translate="yes" xml:space="preserve">
          <source>In each &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call&lt;/a&gt; to a function where a parameter of array type uses the keyword &lt;code&gt;static&lt;/code&gt; between &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;, the value of the actual parameter must be a valid pointer to the first element of an array with at least as many elements as specified by expression:</source>
          <target state="translated">При каждом &lt;a href=&quot;operator_other#Function_call&quot;&gt;вызове&lt;/a&gt; функции, в которой параметр типа массива использует ключевое слово &lt;code&gt;static&lt;/code&gt; между &lt;code&gt;[&lt;/code&gt; и &lt;code&gt;]&lt;/code&gt; , значение фактического параметра должно быть действительным указателем на первый элемент массива, по крайней мере, с таким количеством элементов, как указано выражением :</target>
        </trans-unit>
        <trans-unit id="9c2dc65fa3365dda17e8625d8d61e8a47bb9b9f7" translate="yes" xml:space="preserve">
          <source>In function parameter lists, additional syntax elements are allowed within the array declarators: the keyword &lt;code&gt;static&lt;/code&gt; and qualifiers, which may appear in any order before the size expression (they may also appear even when the size expression is omitted).</source>
          <target state="translated">В списках параметров функции в объявителях массива разрешены дополнительные элементы синтаксиса: ключевое слово &lt;code&gt;static&lt;/code&gt; и квалификаторы, которые могут появляться в любом порядке перед выражением размера (они могут также появляться, даже если выражение размера опущено).</target>
        </trans-unit>
        <trans-unit id="db2370d3e7ba69273bdb62a10e047b42c0843bf1" translate="yes" xml:space="preserve">
          <source>In function-like macros, a &lt;code&gt;#&lt;/code&gt; operator before an identifier in the replacement-list runs the identifier through parameter replacement and encloses the result in quotes, effectively creating a string literal. In addition, the preprocessor adds backslashes to escape the quotes surrounding embedded string literals, if any, and doubles the backslashes within the string as necessary. All leading and trailing whitespace is removed, and any sequence of whitespace in the middle of the text (but not inside embedded string literals) is collapsed to a single space. This operation is called &quot;stringification&quot;. If the result of stringification is not a valid string literal, the behavior is undefined.</source>
          <target state="translated">В функционально-подобных макросах оператор &lt;code&gt;#&lt;/code&gt; перед идентификатором в списке замены выполняет идентификатор посредством замены параметра и заключает результат в кавычки, эффективно создавая строковый литерал. Кроме того, препроцессор добавляет обратную косую черту, чтобы избежать кавычек, окружающих встроенные строковые литералы, если таковые имеются, и удваивает обратную косую черту в строке при необходимости. Все начальные и конечные пробелы удаляются, и любая последовательность пробелов в середине текста (но не внутри встроенных строковых литералов) сворачивается в один пробел. Эта операция называется &amp;laquo;stringification&amp;raquo;. Если результат строкового преобразования не является допустимым строковым литералом, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="0dfc6aa82ba3fea48c1670a0af39cb7ef3825072" translate="yes" xml:space="preserve">
          <source>In general, it is best to explicitly annotate all non-aliasing pointers in a function's prototype with &lt;code&gt;restrict&lt;/code&gt;.</source>
          <target state="translated">В общем, лучше явно аннотировать все сглаживающие указатели в прототипе функции с помощью &lt;code&gt;restrict&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62ceb0117e9441fc64ed53290699d0b67f04e8ec" translate="yes" xml:space="preserve">
          <source>In locales other than &lt;code&gt;&quot;C&quot;&lt;/code&gt;, an alphabetic character is a character for which &lt;code&gt;&lt;a href=&quot;isupper&quot;&gt;isupper()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;islower&quot;&gt;islower()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; or any other character considered alphabetic by the locale. In any case, &lt;code&gt;&lt;a href=&quot;iscntrl&quot;&gt;iscntrl()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;isdigit&quot;&gt;isdigit()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ispunct&quot;&gt;ispunct()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;isspace&quot;&gt;isspace()&lt;/a&gt;&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; for this character.</source>
          <target state="translated">В локалях, отличных от &lt;code&gt;&quot;C&quot;&lt;/code&gt; , алфавитный символ - это символ, для которого &lt;code&gt;&lt;a href=&quot;isupper&quot;&gt;isupper()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;islower&quot;&gt;islower()&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , или любой другой символ, который локаль считает алфавитным. В любом случае &lt;code&gt;&lt;a href=&quot;iscntrl&quot;&gt;iscntrl()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;isdigit&quot;&gt;isdigit()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ispunct&quot;&gt;ispunct()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;isspace&quot;&gt;isspace()&lt;/a&gt;&lt;/code&gt; вернут &lt;code&gt;false&lt;/code&gt; для этого символа.</target>
        </trans-unit>
        <trans-unit id="21197e17c12cb14335ae7b60ed08fcc011dd80c7" translate="yes" xml:space="preserve">
          <source>In most implementations, &lt;code&gt;mbstowcs&lt;/code&gt; updates a global static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; as it processes through the string, and cannot be called simultaneously by two threads, &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;mbsrtowcs&lt;/a&gt;&lt;/code&gt; should be used in such cases.</source>
          <target state="translated">В большинстве реализаций &lt;code&gt;mbstowcs&lt;/code&gt; обновляет глобальный статический объект типа &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; , поскольку он обрабатывает строку и не может быть вызван одновременно двумя потоками, в таких случаях следует использовать &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;mbsrtowcs&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa210a80b121c6a39599abbc8fbfc9c320d9bc24" translate="yes" xml:space="preserve">
          <source>In most implementations, &lt;code&gt;wcstombs&lt;/code&gt; updates a global static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; as it processes through the string, and cannot be called simultaneously by two threads, &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;wcsrtombs&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;wcstombs_s&lt;/code&gt; should be used in such cases.</source>
          <target state="translated">В большинстве реализаций &lt;code&gt;wcstombs&lt;/code&gt; обновляет глобальный статический объект типа &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; , поскольку он обрабатывает строку, и его нельзя вызывать одновременно двумя потоками, в таких случаях следует использовать &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;wcsrtombs&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;wcstombs_s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cfb207d137efe07d54c5a87d7de6e2d7e3aeedc" translate="yes" xml:space="preserve">
          <source>In order to satisfy alignment requirements of all members of a struct, padding may be inserted after some of its members.</source>
          <target state="translated">Для удовлетворения требований по выравниванию всех членов структуры,после некоторых ее членов может быть вставлена подкладка.</target>
        </trans-unit>
        <trans-unit id="9475e6740d71cf18882ad4ded3421afd3ec16ba4" translate="yes" xml:space="preserve">
          <source>In order to support the one-infinity model of complex number arithmetic, C regards any complex value with at least one infinite part as an infinity even if its other part is a NaN, guarantees that all operators and functions honor basic properties of inifinities and provides &lt;code&gt;&lt;a href=&quot;../numeric/complex/cproj&quot;&gt;cproj&lt;/a&gt;&lt;/code&gt; to map all infinities to the canonical one (see &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; for the exact rules).</source>
          <target state="translated">Чтобы поддержать модель арифметики комплексных чисел с одной бесконечностью, C рассматривает любое комплексное значение, по крайней мере, с одной бесконечной частью, как бесконечность, даже если его другая часть является NaN, гарантирует, что все операторы и функции удовлетворяют базовым свойствам бесконечностей и обеспечивает &lt;code&gt;&lt;a href=&quot;../numeric/complex/cproj&quot;&gt;cproj&lt;/a&gt;&lt;/code&gt; для отображения всех бесконечностей в каноническую ( точные правила см. в &lt;a href=&quot;operator_arithmetic&quot;&gt;арифметических операторах&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="76e64f99329b8a6a167edfe1e65c3955c2a72145" translate="yes" xml:space="preserve">
          <source>In some multibyte encodings, any given multibyte character sequence may represent different characters depending on the previous byte sequences, known as &quot;shift sequences&quot;. Such encodings are known as state-dependent: knowledge of the current shift state is required to interpret each character. An NTMBS is only valid if it begins and ends in the initial shift state: if a shift sequence was used, the corresponding unshift sequence has to be present before the terminating null character. Examples of such encodings are BOCU-1 and &lt;a href=&quot;http://www.unicode.org/reports/tr6&quot;&gt;SCSU&lt;/a&gt;.</source>
          <target state="translated">В некоторых многобайтовых кодировках любая заданная многобайтовая последовательность символов может представлять разные символы в зависимости от предыдущих последовательностей байтов, известных как &amp;laquo;последовательности сдвига&amp;raquo;. Такие кодировки известны как зависящие от состояния: знание текущего состояния сдвига требуется для интерпретации каждого символа. NTMBS действительна только в том случае, если она начинается и заканчивается в исходном состоянии сдвига: если использовалась последовательность сдвигов, соответствующая последовательность несмещений должна присутствовать перед завершающим нулевым символом. Примерами таких кодировок являются BOCU-1 и &lt;a href=&quot;http://www.unicode.org/reports/tr6&quot;&gt;SCSU&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="923c56b33566854301ad01db35301650d917bde7" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;declarations&quot;&gt;declaration grammar&lt;/a&gt; of a function declaration, the</source>
          <target state="translated">В &lt;a href=&quot;declarations&quot;&gt;грамматике&lt;/a&gt; объявления объявления функции</target>
        </trans-unit>
        <trans-unit id="8c6915549e0ea7f2ed3d86650796bfe49408367b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;declarations&quot;&gt;declaration grammar&lt;/a&gt; of a pointer declaration, the</source>
          <target state="translated">В &lt;a href=&quot;declarations&quot;&gt;грамматике&lt;/a&gt; объявления объявления указателя</target>
        </trans-unit>
        <trans-unit id="5208b652452c725f5ac915c0c967fc1e2b74e39b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;declarations&quot;&gt;declaration grammar&lt;/a&gt; of an array declaration, the</source>
          <target state="translated">В &lt;a href=&quot;declarations&quot;&gt;грамматике&lt;/a&gt; объявления объявления массива</target>
        </trans-unit>
        <trans-unit id="113533a0b69ca7bb102b7ddcf07a25f608ef6a71" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;operator_assignment&quot;&gt;assignment&lt;/a&gt; operator, the value of the right-hand operand is converted to the unqualified type of the left-hand operand.</source>
          <target state="translated">В операторе &lt;a href=&quot;operator_assignment&quot;&gt;присваивания&lt;/a&gt; значение правого операнда преобразуется в неквалифицированный тип левого операнда.</target>
        </trans-unit>
        <trans-unit id="f26b71cad718a75aa0f6d4d4ddf1273333394594" translate="yes" xml:space="preserve">
          <source>In the C++ programming language, the width of a bit field can exceed the width of the underlying type.</source>
          <target state="translated">В языке программирования C++ширина битового поля может превышать ширину подстилающего типа.</target>
        </trans-unit>
        <trans-unit id="975e4fe6f239aebda10cf0cf1e080b0c6fa23395" translate="yes" xml:space="preserve">
          <source>In the case the file is not found, the program is ill-formed.</source>
          <target state="translated">В случае если файл не найден,программа плохо сформирована.</target>
        </trans-unit>
        <trans-unit id="c2371f6402972bc45972f3f09d5d022fcbd00df0" translate="yes" xml:space="preserve">
          <source>In the default &quot;C&quot; locale, the following lowercase letters &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; are replaced with respective uppercase letters &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;.</source>
          <target state="translated">В локали &quot;C&quot; по умолчанию следующие строчные буквы &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; заменяются соответствующими заглавными буквами &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f82450bef11bed620bb59a03e863ef7afabcdad8" translate="yes" xml:space="preserve">
          <source>In the default &quot;C&quot; locale, the following uppercase letters &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; are replaced with respective lowercase letters &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;.</source>
          <target state="translated">В локали &amp;laquo;C&amp;raquo; по умолчанию следующие заглавные буквы &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; заменяются соответствующими строчными буквами &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69d5da7e7c8f4ddf2ba06176a0324f7f725a9426" translate="yes" xml:space="preserve">
          <source>In the following contexts, the comma operator cannot appear at the top level of an expression because the comma has a different meaning:</source>
          <target state="translated">В следующих контекстах оператор запятая не может появляться на верхнем уровне выражения,так как запятая имеет другое значение:</target>
        </trans-unit>
        <trans-unit id="dc33863a538f837ccafd624f0573864c0519ef07" translate="yes" xml:space="preserve">
          <source>In the following example, the compiler may infer that there is no aliasing of modified objects, and so optimize the loop aggressively. Upon entry to f, the restricted pointer a must provide exclusive access to its associated array. In particular, within f neither b nor c may point into the array associated with a, because neither is assigned a pointer value based on a. For b, this is evident from the const-qualifier in its declaration, but for c, an inspection of the body of f is required:</source>
          <target state="translated">В следующем примере компилятор может сделать вывод,что нет псевдонима измененных объектов,и таким образом агрессивно оптимизировать цикл.При входе в f ограничительный указатель a должен предоставлять эксклюзивный доступ к связанному с ним массиву.В частности,внутри f ни b,ни c не могут указывать на массив,связанный с a,так как ни одному указателю не присваивается значение,основанное на a.Для b это видно из конст-квалификатора в его объявлении,а для c требуется проверка тела f:</target>
        </trans-unit>
        <trans-unit id="d658bebea04040340fda6a99bf9ac52ca6b05755" translate="yes" xml:space="preserve">
          <source>In the form (2), if expression compares equal to the integer zero, statement_false is executed.</source>
          <target state="translated">В форме (2),если выражение сравнивается с целым нулем,выполняется оператор statement_false.</target>
        </trans-unit>
        <trans-unit id="044aceb384f674b4556f403f792d0db3bee99f91" translate="yes" xml:space="preserve">
          <source>In this example there is a system call of the unix command &lt;b&gt;date +%A&lt;/b&gt;:</source>
          <target state="translated">В этом примере есть системный вызов &lt;b&gt;даты&lt;/b&gt; команды unix &lt;b&gt;+% A&lt;/b&gt; :</target>
        </trans-unit>
        <trans-unit id="e0d690c603a9d7a62cca51dfee4caa9018dac758" translate="yes" xml:space="preserve">
          <source>In typical usage, &lt;code&gt;count&lt;/code&gt; is the number of elements in the destination array.</source>
          <target state="translated">В типичном использовании &lt;code&gt;count&lt;/code&gt; - это количество элементов в массиве назначения.</target>
        </trans-unit>
        <trans-unit id="666e665b91e221551332cdb922f39d26d34652a4" translate="yes" xml:space="preserve">
          <source>In typical usage, input stream processing stops on any error; &lt;code&gt;feof&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;ferror&lt;/a&gt;&lt;/code&gt; are then used to distinguish between different error conditions.</source>
          <target state="translated">При обычном использовании обработка входного потока останавливается при любой ошибке; Затем используются &lt;code&gt;feof&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;ferror&lt;/a&gt;&lt;/code&gt; , чтобы различать различные условия ошибки.</target>
        </trans-unit>
        <trans-unit id="c7499c4ef48e0f11187d8d33c914d276969727d9" translate="yes" xml:space="preserve">
          <source>In update mode ('+'), both input and output may be performed, but output cannot be followed by input without an intervening call to &lt;code&gt;&lt;a href=&quot;fflush&quot;&gt;fflush&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;fsetpos&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;rewind&lt;/a&gt;&lt;/code&gt;, and input cannot be followed by output without an intervening call to &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;fsetpos&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;rewind&lt;/a&gt;&lt;/code&gt;, unless the input operation encountered end of file. In update mode, implementations are permitted to use binary mode even when text mode is specified.</source>
          <target state="translated">В режиме обновления ( &amp;laquo;+&amp;raquo;), вход и выход могут быть выполнены, но выход не может сопровождаться входом без промежуточного вызова &lt;code&gt;&lt;a href=&quot;fflush&quot;&gt;fflush&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;fsetpos&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;rewind&lt;/a&gt;&lt;/code&gt; , а вход не может сопровождаться выходом без промежуточного вызова &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;fsetpos&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;rewind&lt;/a&gt;&lt;/code&gt; , если операция ввода не встречается конец файла. В режиме обновления реализациям разрешено использовать двоичный режим, даже если указан текстовый режим.</target>
        </trans-unit>
        <trans-unit id="8705867aeef60bcf6e033673dc025bf70ea7c829" translate="yes" xml:space="preserve">
          <source>Includes January 4</source>
          <target state="translated">Включает 4 января</target>
        </trans-unit>
        <trans-unit id="363fb406f419e21cfcda27deb409f2bd35c7c245" translate="yes" xml:space="preserve">
          <source>Includes another source file into the current source file at the line immediately after the directive.</source>
          <target state="translated">Включает другой исходный файл в текущий исходный файл в строке сразу после директивы.</target>
        </trans-unit>
        <trans-unit id="1e25648908297ca3a4ff1a029bba15e376074f7a" translate="yes" xml:space="preserve">
          <source>Includes first Thursday of the year</source>
          <target state="translated">Включает первый четверг года.</target>
        </trans-unit>
        <trans-unit id="d416e56359c061d5140399f02320d85b725a461e" translate="yes" xml:space="preserve">
          <source>Includes source file, identified by filename, into the current source file at the line immediately after the directive.</source>
          <target state="translated">Включает исходный файл,идентифицируемый по имени файла,в текущий исходный файл в строке непосредственно после директивы.</target>
        </trans-unit>
        <trans-unit id="49c0d7b0937da9c9ff367feeb084c4412b31121a" translate="yes" xml:space="preserve">
          <source>Incomplete types</source>
          <target state="translated">Незавершенные типы</target>
        </trans-unit>
        <trans-unit id="a9f510244f4c40d947308a6a3b552dcfe82f8745" translate="yes" xml:space="preserve">
          <source>Increment and Decrement</source>
          <target state="translated">Инкремент и декремент</target>
        </trans-unit>
        <trans-unit id="5bc342f191d90350a10c27aa563d30c6fa0efd4e" translate="yes" xml:space="preserve">
          <source>Increment and decrement are not defined for complex types.</source>
          <target state="translated">Инкремент и декремент не определены для сложных типов.</target>
        </trans-unit>
        <trans-unit id="d451f27858a586b045ef8704174c2c47a9677b6d" translate="yes" xml:space="preserve">
          <source>Increment and decrement are not defined for imaginary types  &lt;a href=&quot;conversion&quot;&gt;Implicit conversions&lt;/a&gt; are defined between imaginary types and other arithmetic types.</source>
          <target state="translated">Увеличение и уменьшение не определены для мнимых типов. &lt;a href=&quot;conversion&quot;&gt;Неявные преобразования&lt;/a&gt; определяются между мнимыми типами и другими арифметическими типами.</target>
        </trans-unit>
        <trans-unit id="4cab5961dc19e11a59ed503482594c2617dde8e5" translate="yes" xml:space="preserve">
          <source>Increment operators initiate the side-effect of adding the value &lt;code&gt;1&lt;/code&gt; of appropriate type to the operand. Decrement operators initiate the side-effect of subtracting the value &lt;code&gt;1&lt;/code&gt; of appropriate type from the operand. As with any other side-effects, these operations complete at or before the next &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt;. &lt;code&gt;int a = 1; int b = a++; // stores 1+a (which is 2) to a // returns the value of a (which is 1) // After this line, b == 1 and a == 2 a = 1; int c = ++a; // stores 1+a (which is 2) to a // returns 1+a (which is 2) // after this line, c == 2 and a == 2&lt;/code&gt;.</source>
          <target state="translated">Операторы инкремента инициируют побочный эффект добавления значения &lt;code&gt;1&lt;/code&gt; соответствующего типа к операнду. Операторы декремента инициируют побочный эффект вычитания значения &lt;code&gt;1&lt;/code&gt; соответствующего типа из операнда. Как и с любыми другими побочными эффектами, эти операции завершаются в или перед следующей &lt;a href=&quot;eval_order&quot;&gt;точкой последовательности&lt;/a&gt; . &lt;code&gt;int a = 1; int b = a++; // stores 1+a (which is 2) to a // returns the value of a (which is 1) // After this line, b == 1 and a == 2 a = 1; int c = ++a; // stores 1+a (which is 2) to a // returns 1+a (which is 2) // after this line, c == 2 and a == 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f17d70be0f16733c0dc8c67eabfb624d43b60216" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators</source>
          <target state="translated">Операторы инкремента/декремента</target>
        </trans-unit>
        <trans-unit id="40b0713cd16ef48a40d29fc9dad27332939e997e" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators are not defined for complex or imaginary types: the usual definition of adding/subtracting the real number 1 would have no effect on imaginary types, and making it add/subtract &lt;code&gt;i&lt;/code&gt; for imaginaries but &lt;code&gt;1&lt;/code&gt; for complex numbers would have made it handle &lt;code&gt;0+yi&lt;/code&gt; different from &lt;code&gt;yi&lt;/code&gt;.</source>
          <target state="translated">Операторы инкремента / декремента не определены для сложных или мнимых типов: обычное определение сложения / вычитания действительного числа 1 не будет влиять на мнимые типы, а его добавление / вычитание &lt;code&gt;i&lt;/code&gt; для мнимых типов, но &lt;code&gt;1&lt;/code&gt; для комплексных чисел сделало бы это обрабатывать &lt;code&gt;0+yi&lt;/code&gt; отличается от &lt;code&gt;yi&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56e7713f236304a71ab92bc24bb388cf6138cc73" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators are unary operators that increment/decrement the value of a variable by 1.</source>
          <target state="translated">Операторы инкремента/декремента-это одинарные операторы,которые увеличивают/уменьшают значение переменной на 1.</target>
        </trans-unit>
        <trans-unit id="1df30318ddb5ee41156f6bf21f1a90f429ea6a75" translate="yes" xml:space="preserve">
          <source>Indirection (dereference)</source>
          <target state="translated">Введение в заблуждение (умалчивание)</target>
        </trans-unit>
        <trans-unit id="b5f6e97cd4faf7045970097d59a8c5be90de03ff" translate="yes" xml:space="preserve">
          <source>Inexact result</source>
          <target state="translated">Неточный результат</target>
        </trans-unit>
        <trans-unit id="98df9b88a5e801dd458f9dea0b5eb524b074282a" translate="yes" xml:space="preserve">
          <source>Infinite loop without side-effects</source>
          <target state="translated">Бесконечный цикл без побочных эффектов</target>
        </trans-unit>
        <trans-unit id="f3b3d9c9386379e588661aaa74e30dea9732f4b8" translate="yes" xml:space="preserve">
          <source>Informs the compiler that the dependency tree started by an &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_consume&lt;/a&gt;&lt;/code&gt; atomic load operation does not extend past the return value of &lt;code&gt;kill_dependency&lt;/code&gt;; that is, the argument does not carry a dependency into the return value.</source>
          <target state="translated">Информирует компилятор о том, что дерево зависимостей, запущенное &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_consume&lt;/a&gt;&lt;/code&gt; атомарной загрузки memory_order_consume , не выходит за пределы возвращаемого значения &lt;code&gt;kill_dependency&lt;/code&gt; ; то есть аргумент не несет зависимости в возвращаемое значение.</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="bda194cf9cabbb80afe8fa11968d57f4d61e8056" translate="yes" xml:space="preserve">
          <source>Initialization from brace-enclosed lists</source>
          <target state="translated">Инициализация из прилагаемых к скобкам списков</target>
        </trans-unit>
        <trans-unit id="809dbf840669bbee858fa37fe2063537d8ea1dc8" translate="yes" xml:space="preserve">
          <source>Initialization from strings</source>
          <target state="translated">Инициализация из строк</target>
        </trans-unit>
        <trans-unit id="49fb3cd233b01d2f3fca6d231ff8868b279e8d64" translate="yes" xml:space="preserve">
          <source>Initialization to all bits zero does not guarantee that a floating-point or a pointer would be initialized to 0.0 and the null pointer value, respectively (although that is true on all common platforms).</source>
          <target state="translated">Инициализация на все биты нуля не гарантирует,что плавающая точка или указатель будут инициализированы на 0.0 и значение нулевого указателя соответственно (хотя это верно на всех распространенных платформах).</target>
        </trans-unit>
        <trans-unit id="dcd64bec39ad6d832e7fd656dfbaa3b5fb1da8e8" translate="yes" xml:space="preserve">
          <source>Initializers cannot be used in declarations of objects of incomplete type, VLAs, and block-scope objects with linkage.</source>
          <target state="translated">Инициализаторы не могут использоваться в объявлениях объектов неполного типа,VLA и объектов блочного масштаба с привязкой.</target>
        </trans-unit>
        <trans-unit id="af07b8353132a535b78017dad8822a72315ba75e" translate="yes" xml:space="preserve">
          <source>Initializes new condition variable. The object pointed to by &lt;code&gt;cond&lt;/code&gt; will be set to value that identifies the condition variable.</source>
          <target state="translated">Инициализирует новую переменную условия. Для объекта, на который указывает &lt;code&gt;cond&lt;/code&gt; , будет установлено значение, определяющее переменную условия.</target>
        </trans-unit>
        <trans-unit id="a8d332dbed9d2af60e29bd52e5cde6a80c7ad53b" translate="yes" xml:space="preserve">
          <source>Initializes the default-constructed atomic object &lt;code&gt;obj&lt;/code&gt; with the value &lt;code&gt;desired&lt;/code&gt;. The function is not atomic: concurrent access from another thread, even through an atomic operation, is a data race.</source>
          <target state="translated">Инициализирует построенный по умолчанию атомарный объект &lt;code&gt;obj&lt;/code&gt; с &lt;code&gt;desired&lt;/code&gt; значением . Функция не атомарна: параллельный доступ из другого потока, даже через атомарную операцию, является гонкой данных.</target>
        </trans-unit>
        <trans-unit id="7bb9ce0cdba5a821d492b917cf5fb720a0f90bd9" translate="yes" xml:space="preserve">
          <source>Inline assembly</source>
          <target state="translated">интернет-монтаж</target>
        </trans-unit>
        <trans-unit id="249f397392db7fe682a1d1ecc1a52c8e40ceb983" translate="yes" xml:space="preserve">
          <source>Input/output</source>
          <target state="translated">Input/output</target>
        </trans-unit>
        <trans-unit id="3b91932c5604be98b02beecc9f3294548420aed4" translate="yes" xml:space="preserve">
          <source>Integer arithmetic in &lt;code&gt;#if&lt;/code&gt;-expressions is performed using the semantics of &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt; for signed types and &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;uintmax_t&lt;/a&gt;&lt;/code&gt; for unsigned types.</source>
          <target state="translated">Целочисленная арифметика в # &lt;code&gt;#if&lt;/code&gt; выражениях выполняется с использованием семантики &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt; для типов со &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;uintmax_t&lt;/a&gt;&lt;/code&gt; и uintmax_t для типов без знака.</target>
        </trans-unit>
        <trans-unit id="00fca0cb45c563b4aca1c728dcaf7bb27ee388bc" translate="yes" xml:space="preserve">
          <source>Integer constant expression</source>
          <target state="translated">Целочисленное постоянное выражение</target>
        </trans-unit>
        <trans-unit id="bac8890b103516222490d7d9d18bdba5cbf90f36" translate="yes" xml:space="preserve">
          <source>Integer constant expressions are evaluated at compile time. The following contexts require expressions that are known as</source>
          <target state="translated">Целочисленные константные выражения вычисляются во время компиляции.Для следующих контекстов требуются выражения,известные как</target>
        </trans-unit>
        <trans-unit id="0d17a9e0dc1e0be7fcf770a93ca094014147b164" translate="yes" xml:space="preserve">
          <source>Integer constants</source>
          <target state="translated">Целочисленные константы</target>
        </trans-unit>
        <trans-unit id="eb8a7869f4f02b2ddb556d447ca9969842e11b2b" translate="yes" xml:space="preserve">
          <source>Integer constants may be used in &lt;a href=&quot;constant_expression&quot;&gt;integer constant expressions&lt;/a&gt;.</source>
          <target state="translated">Целочисленные константы могут использоваться в &lt;a href=&quot;constant_expression&quot;&gt;выражениях целочисленных констант&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f01db8c35bcc24ed074568092a7ec4baacf74ca" translate="yes" xml:space="preserve">
          <source>Integer conversions</source>
          <target state="translated">Интегральные преобразования</target>
        </trans-unit>
        <trans-unit id="566c223f31851f66caf3368111c90cc6e99a86cf" translate="yes" xml:space="preserve">
          <source>Integer promotion is the implicit conversion of a value of any integer type with</source>
          <target state="translated">Содействие целочисленному-это неявное приведение значения любого целочисленного типа к</target>
        </trans-unit>
        <trans-unit id="b32622daf07fbe0a8ed0fe3f161a8d872f055bce" translate="yes" xml:space="preserve">
          <source>Integer promotions</source>
          <target state="translated">Интегрированные акции</target>
        </trans-unit>
        <trans-unit id="14fa9d849ba5cc455c138e12e0153e7279624dff" translate="yes" xml:space="preserve">
          <source>Integer promotions preserve the value, including the sign:</source>
          <target state="translated">Целые акции сохраняют свою ценность,в том числе и знак:</target>
        </trans-unit>
        <trans-unit id="4d364bae64d134436bc38477b2370e7d602b048e" translate="yes" xml:space="preserve">
          <source>Integer to pointer implicit &lt;a href=&quot;conversion&quot;&gt;conversion&lt;/a&gt;.</source>
          <target state="translated">Целое число для неявного &lt;a href=&quot;conversion&quot;&gt;преобразования&lt;/a&gt; указателя .</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">Целочисленные типы</target>
        </trans-unit>
        <trans-unit id="6c8b2db07fe3fe6b10f79300cc2e4c847fac9fa0" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs (&lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;ERANGE&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">Целочисленное значение, соответствующее содержимому &lt;code&gt;str&lt;/code&gt; в случае успеха. Если преобразованное значение выходит за пределы диапазона соответствующего возвращаемого типа, возникает ошибка диапазона (для &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; установлено &lt;code&gt;ERANGE&lt;/code&gt; ) и &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULONG_MAX&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; . Если преобразование не может быть выполнено, &lt;code&gt;​0​&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="52e4539e8037f8f852f5856d00606b776679d442" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;​0​&lt;/code&gt; is returned, as appropriate. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">Целочисленное значение, соответствующее содержимому &lt;code&gt;str&lt;/code&gt; в случае успеха. Если преобразованное значение выпадает из диапазона соответствующих возвращаемого типа, диапазон ошибки возникают и &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt; , или &lt;code&gt;​0​&lt;/code&gt; , возвращаются, в зависимости от обстоятельств. Если преобразование не может быть выполнено, &lt;code&gt;​0​&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="037211edd9f543a6e3e5973c9289bff663b3846a" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">Целочисленное значение, соответствующее содержимому &lt;code&gt;str&lt;/code&gt; в случае успеха. Если преобразованное значение выходит за пределы диапазона соответствующего возвращаемого типа, возникает ошибка диапазона и &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; . Если преобразование не может быть выполнено, &lt;code&gt;​0​&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="30a62fa780cc981f83f6721bd337ae1c720db4eb" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">Целочисленное значение, соответствующее содержимому &lt;code&gt;str&lt;/code&gt; в случае успеха. Если преобразованное значение выходит за пределы диапазона соответствующего возвращаемого типа, возникает ошибка диапазона и &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULONG_MAX&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; . Если преобразование не может быть выполнено, &lt;code&gt;​0​&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="21098bb738833ee0f4f792151a59d559da8ec6b0" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, the return value is undefined. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">Целочисленное значение, соответствующее содержимому &lt;code&gt;str&lt;/code&gt; в случае успеха. Если преобразованное значение выпадает из диапазона соответствующего возвращаемого типа, возвращаемое значение не определено. Если преобразование не может быть выполнено, &lt;code&gt;​0​&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="94bb86dba8d80a53634463b836c1b46d98acd2a7" translate="yes" xml:space="preserve">
          <source>Intel C++ compiler pragmas</source>
          <target state="translated">Прагмы компилятора Intel C++</target>
        </trans-unit>
        <trans-unit id="9dac1e92729539ac11d8cad38e7bddd13ef84d39" translate="yes" xml:space="preserve">
          <source>Internally, the character is converted to &lt;code&gt;unsigned char&lt;/code&gt; just before being written.</source>
          <target state="translated">Внутренне, символ преобразуется в &lt;code&gt;unsigned char&lt;/code&gt; непосредственно перед написанием.</target>
        </trans-unit>
        <trans-unit id="4000ac517f025eca6a922c089403bb09186f8d96" translate="yes" xml:space="preserve">
          <source>International monetary numeric formatting parameters</source>
          <target state="translated">Международные параметры денежно-кредитного числового форматирования</target>
        </trans-unit>
        <trans-unit id="bc48cbadb6a84efbed23317d93156122ffd8c740" translate="yes" xml:space="preserve">
          <source>Interprets a floating point value in a wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует значение с плавающей запятой в широкой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd73986f45b4bdd6cb8af7f9c50d2ce721e60cf8" translate="yes" xml:space="preserve">
          <source>Interprets a floating-point value in a byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует значение с плавающей точкой в ​​байтовой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a608036eb59f94001912ca3733a0c15c944b183" translate="yes" xml:space="preserve">
          <source>Interprets an integer value in a byte string pointed to by &lt;code&gt;nptr&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует целочисленное значение в байтовой строке, на которую указывает &lt;code&gt;nptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="566cf8ed0ac571b4f2aa3ca75d488875487baeb4" translate="yes" xml:space="preserve">
          <source>Interprets an integer value in a byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует целочисленное значение в байтовой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc2bd5d023e90da3e1640fc0f66845e22f6c8508" translate="yes" xml:space="preserve">
          <source>Interprets an integer value in a wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует целочисленное значение в широкой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="042a224facaad3cdf57ba7458290bd20ddbab9ab" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in a byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует целое число без знака в байтовой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65b433c8b60cb3b8c5443581467dc0f6ae5b6523" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in a wide string pointed to by &lt;code&gt;nptr&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует целочисленное значение без знака в широкой строке, на которую указывает &lt;code&gt;nptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="148c33b3cec53bcad46f4795046e389f68465431" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in a wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует целочисленное значение без знака в широкой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86c96ba7411037b346432868bfdb3e867290952c" translate="yes" xml:space="preserve">
          <source>Invalid scalar</source>
          <target state="translated">недействительный скаляр</target>
        </trans-unit>
        <trans-unit id="bccd99d2661a6df322f59fa784d4f94059ba4e6f" translate="yes" xml:space="preserve">
          <source>Inverse cosine (or arc cosine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventially placed at the line segments (-&amp;infin;,-1) and (1,&amp;infin;) of the real axis.  The mathematical definition of the principal value of arc cosine is acos z =</source>
          <target state="translated">Обратный косинус (или арккосинус) является многозначной функцией и требует среза ветвей на комплексной плоскости. Отрезок ветки обычно размещают на отрезках (-&amp;infin;, -1) и (1, &amp;infin;) действительной оси. Математическое определение главного значения арккосинуса: acos z =</target>
        </trans-unit>
        <trans-unit id="92db73712a1ea6cdea29021a66a4e0d10b6b003b" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic cosine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segment (-&amp;infin;,+1) of the real axis.</source>
          <target state="translated">Обратный гиперболический косинус является многозначной функцией и требует разреза ветвей на комплексной плоскости. Отрезок ветки традиционно размещают на отрезке (-&amp;infin;, + 1) действительной оси.</target>
        </trans-unit>
        <trans-unit id="3ff0648a78636309b1cc12a67a5c7841a27e8966" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic sine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-</source>
          <target state="translated">Обратный гиперболический синус является многозначной функцией и требует среза ветки на комплексной плоскости.Отрезок ветви условно располагается на отрезках линии (-</target>
        </trans-unit>
        <trans-unit id="60cf8f72dc186c6f4b4743734e8e8ed4cb1bd30a" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic tangent is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segmentd (-&amp;infin;,-1] and [+1,+&amp;infin;) of the real axis.  The mathematical definition of the principal value of the inverse hyperbolic tangent is atanh z =</source>
          <target state="translated">Обратный гиперболический тангенс является многозначной функцией и требует разреза ветвей на комплексной плоскости. Отрезок ветки обычно размещают на отрезке прямой (-&amp;infin;, -1] и [+ 1, + &amp;infin;) действительной оси. Математическое определение главной величины обратной гиперболической касательной имеет вид atanh z =</target>
        </trans-unit>
        <trans-unit id="ff28b3449f26b28c2a2ed73fffb64ba03b0e2959" translate="yes" xml:space="preserve">
          <source>Inverse sine (or arc sine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-&amp;infin;,-1) and (1,&amp;infin;) of the real axis.</source>
          <target state="translated">Обратный синус (или дуговой синус) - это многозначная функция, для которой требуется срез ответвления на комплексной плоскости. Отрезок ветки обычно размещают на отрезках (-&amp;infin;, -1) и (1, &amp;infin;) действительной оси.</target>
        </trans-unit>
        <trans-unit id="8a394149a1f48f15fcf530168253dbecfeb4322f" translate="yes" xml:space="preserve">
          <source>Inverse tangent (or arc tangent) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-&amp;infin;i,-i) and (+i,+&amp;infin;i) of the imaginary axis.  The mathematical definition of the principal value of inverse tangent is atan z = -</source>
          <target state="translated">Обратная касательная (или арктангенс) является многозначной функцией и требует разрезания ветвей на комплексной плоскости. Отрезок ветки обычно размещают на отрезках (-&amp;infin;i, -i) и (+ i, + &amp;infin;i) мнимой оси. Математическое определение главной величины обратной касательной: atan z = -</target>
        </trans-unit>
        <trans-unit id="9d2f6d91d5420dae435a1c0f90119203f0e61055" translate="yes" xml:space="preserve">
          <source>It is common practice to inject struct/union/enum names into the name space of the ordinary identifiers using a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; declaration:</source>
          <target state="translated">Обычной практикой является внедрение имен struct / union / enum в пространство имен обычных идентификаторов с помощью объявления &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7405702ee0f652067444964a064505a6d91ce3db" translate="yes" xml:space="preserve">
          <source>It is implementation-defined if raw (not escaped) Unicode characters are allowed in identifiers:</source>
          <target state="translated">Реализация определяется,если в идентификаторах разрешены необработанные (не экранированные)символы Юникода:</target>
        </trans-unit>
        <trans-unit id="e89c6edc67ab990f4dbf2f94411a54a2785ae48a" translate="yes" xml:space="preserve">
          <source>It is legal to pass a pointer to a &lt;code&gt;va_list&lt;/code&gt; object to another function and then use that object after the function returns.</source>
          <target state="translated">Разрешается передавать указатель на объект &lt;code&gt;va_list&lt;/code&gt; другой функции, а затем использовать этот объект после возврата из функции.</target>
        </trans-unit>
        <trans-unit id="7926a28072d957347e3960952bdef8d080b0e6ed" translate="yes" xml:space="preserve">
          <source>It is neither required nor forbidden for identical string literals to refer to the same location in memory. Moreover, overlapping string literals or string literals that are substrings of other string literals may be combined.</source>
          <target state="translated">Для одинаковых строковых литералов не требуется и не запрещается ссылаться на одно и то же место в памяти.Более того,можно комбинировать перекрывающиеся строковые литералы или строковые литералы,являющиеся подстроками других строковых литералов.</target>
        </trans-unit>
        <trans-unit id="9123df49710433ab83af6575b94f8d3abd5f45a3" translate="yes" xml:space="preserve">
          <source>It is possible to enter the body of a loop using &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;. In this case, init_clause and cond_expression are not executed.</source>
          <target state="translated">Можно ввести тело цикла, используя &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; . В этом случае init_clause и cond_expression не выполняются.</target>
        </trans-unit>
        <trans-unit id="08e37acb4a8f5bf8f0ffdb9adceda2446f63dbb9" translate="yes" xml:space="preserve">
          <source>It is possible to indicate to a function that accesses objects through pointers that those pointers do not alias. See &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt; for details.</source>
          <target state="translated">Для функции, которая обращается к объектам через указатели, можно указать, что эти указатели не являются псевдонимами. Смотрите &lt;a href=&quot;restrict&quot;&gt;ограничения&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="6e55a74fe870b5dea0eb9ccaa43f967ab9bc4994" translate="yes" xml:space="preserve">
          <source>It's an error to provide more initializers than elements when initializing an array of known size (except when initializing character arrays from string literals).</source>
          <target state="translated">Ошибкой является предоставление большего количества инициализаторов,чем элементов при инициализации массива известного размера (за исключением инициализации символьных массивов из строковых литералов).</target>
        </trans-unit>
        <trans-unit id="cbb15437c0942623655a62fecca4d13fffedba42" translate="yes" xml:space="preserve">
          <source>It's an error to provide more initializers than members.</source>
          <target state="translated">Это ошибка-предоставить больше инициализаторов,чем членов.</target>
        </trans-unit>
        <trans-unit id="eaad30c6c7239ee4988afc79198142d6357df99b" translate="yes" xml:space="preserve">
          <source>Iteration statements</source>
          <target state="translated">итерационные заявления</target>
        </trans-unit>
        <trans-unit id="61862142943cd7265805fbc767319ff613c724a6" translate="yes" xml:space="preserve">
          <source>J.5 Common extensions (p: 511-513)</source>
          <target state="translated">J.5 Общие удлинители (стр.511-513)</target>
        </trans-unit>
        <trans-unit id="a9953eaba16e228c2e6d58120372e40175bf2ca4" translate="yes" xml:space="preserve">
          <source>J.5 Common extensions (p: 579-581)</source>
          <target state="translated">J.5 Общие расширения (стр.579-581)</target>
        </trans-unit>
        <trans-unit id="bdfb777e0387993e2e3d113ac36512201456491d" translate="yes" xml:space="preserve">
          <source>Jump statements</source>
          <target state="translated">Прыжковые заявления</target>
        </trans-unit>
        <trans-unit id="dab4841e25b37627c71f4a9a4019a02fa5866eef" translate="yes" xml:space="preserve">
          <source>Jumping across threads (if the function that called &lt;code&gt;setjmp&lt;/code&gt; was executed by another thread) is also undefined behavior.</source>
          <target state="translated">Перепрыгивание через потоки (если функция, &lt;code&gt;setjmp&lt;/code&gt; была выполнена другим потоком), также является неопределенным поведением.</target>
        </trans-unit>
        <trans-unit id="0cb0c0046b3f02e116b5c2149dc3ab7668bc12b6" translate="yes" xml:space="preserve">
          <source>K.3.1.2 Reserved identifiers (p: 584)</source>
          <target state="translated">K.3.1.2 Зарезервированные идентификаторы (стр.584)</target>
        </trans-unit>
        <trans-unit id="6864fef737e995e1d1cd295e0023b9e2ebe3a4c4" translate="yes" xml:space="preserve">
          <source>K.3.1.3 Use of errno (p: 584)</source>
          <target state="translated">K.3.1.3 Использование errno (стр.584)</target>
        </trans-unit>
        <trans-unit id="27a66ec6494371162942d093a56fa8a2e184d943" translate="yes" xml:space="preserve">
          <source>K.3.2 Errors &amp;lt;errno.h&amp;gt; (p: 585)</source>
          <target state="translated">K.3.2 Ошибки &amp;lt;errno.h&amp;gt; (стр: 585)</target>
        </trans-unit>
        <trans-unit id="708d246a6ea637ca582a2667b7221a12320e5a98" translate="yes" xml:space="preserve">
          <source>K.3.2/2 errno_t (p: 585)</source>
          <target state="translated">K.3.2/2 errno_t (стр.585)</target>
        </trans-unit>
        <trans-unit id="6e58be13bd900d0cee367c094a9ec614488caeee" translate="yes" xml:space="preserve">
          <source>K.3.3 Common definitions &amp;lt;stddef.h&amp;gt; (p: 585)</source>
          <target state="translated">K.3.3 Общие определения &amp;lt;stddef.h&amp;gt; (стр: 585)</target>
        </trans-unit>
        <trans-unit id="f138276c2fee1981c3ae61a15d64e3a9856c9815" translate="yes" xml:space="preserve">
          <source>K.3.3/2 rsize_t (p: 585)</source>
          <target state="translated">K.3.3/2 rsize_t (стр.585)</target>
        </trans-unit>
        <trans-unit id="b4c50e76ee617672247b3a8d01a8c4ec472aa6f7" translate="yes" xml:space="preserve">
          <source>K.3.4/2 RSIZE_MAX (p: 585)</source>
          <target state="translated">K.3.4/2 RSIZE_MAX (стр.585)</target>
        </trans-unit>
        <trans-unit id="6a80d328f4964ca1bf3e74f6f2ccc8b333f67c7e" translate="yes" xml:space="preserve">
          <source>K.3.5 Input/output &amp;lt;stdio.h&amp;gt; (p: 586-603)</source>
          <target state="translated">K.3.5 Ввод / вывод &amp;lt;stdio.h&amp;gt; (стр: 586-603)</target>
        </trans-unit>
        <trans-unit id="369c2239cc2d2c85678b66dc84de6c39138dad3f" translate="yes" xml:space="preserve">
          <source>K.3.5.1.1 The tmpfile_s function (p: 586-587)</source>
          <target state="translated">K.3.5.1.1 Функция tmpfile_s (p:586-587)</target>
        </trans-unit>
        <trans-unit id="50d2ab4ca7b8cc8a1730d227f9641def28a24680" translate="yes" xml:space="preserve">
          <source>K.3.5.1.2 The tmpnam_s function (p: 587-588)</source>
          <target state="translated">K.3.5.1.2 Функция tmpnam_s (стр.587-588)</target>
        </trans-unit>
        <trans-unit id="5a485d9c7022335c9e640bfc39b6d728070f42cd" translate="yes" xml:space="preserve">
          <source>K.3.5.2.1 The fopen_s function (p: 588-590)</source>
          <target state="translated">K.3.5.2.1 Функция fopen_s (стр.588-590)</target>
        </trans-unit>
        <trans-unit id="ab2a574649a5da149b2aad34fd3642efffe3e957" translate="yes" xml:space="preserve">
          <source>K.3.5.2.2 The freopen_s function (p: 590)</source>
          <target state="translated">K.3.5.2.2 Функция freopen_s (стр.590)</target>
        </trans-unit>
        <trans-unit id="9150e311f698b9b2d0020a5314030a25443c9953" translate="yes" xml:space="preserve">
          <source>K.3.5.3.1 The fprintf_s function (p: 591)</source>
          <target state="translated">K.3.5.3.1 Функция fprintf_s (p:591)</target>
        </trans-unit>
        <trans-unit id="23d19bd7432258b33166d9a55544eb85969c4f0b" translate="yes" xml:space="preserve">
          <source>K.3.5.3.10 The vprintf_s function (p: 598-599)</source>
          <target state="translated">K.3.5.3.10 Функция vprintf_s (стр.598-599)</target>
        </trans-unit>
        <trans-unit id="d9041652eb11ab1a0d7ccbc42db6d18962320c4d" translate="yes" xml:space="preserve">
          <source>K.3.5.3.11 The vscanf_s function (p: 599)</source>
          <target state="translated">K.3.5.3.11 Функция vscanf_s (стр.599)</target>
        </trans-unit>
        <trans-unit id="b661ee960e7f0fae6141e96c9cc1b4fd57185d64" translate="yes" xml:space="preserve">
          <source>K.3.5.3.12 The vsnprintf_s function (p: 600)</source>
          <target state="translated">K.3.5.3.12 Функция vsnprintf_s (p:600)</target>
        </trans-unit>
        <trans-unit id="f9a1acd40ff4721c31e464bdc74e240db45f114e" translate="yes" xml:space="preserve">
          <source>K.3.5.3.13 The vsprintf_s function (p: 601)</source>
          <target state="translated">K.3.5.3.13 Функция vsprintf_s (стр.601)</target>
        </trans-unit>
        <trans-unit id="013f52d5fe2e678b389f07e69c114c6413950586" translate="yes" xml:space="preserve">
          <source>K.3.5.3.14 The vsscanf_s function (p: 602)</source>
          <target state="translated">K.3.5.3.14 Функция vsscanf_s (p:602)</target>
        </trans-unit>
        <trans-unit id="684c3b4d0155dab92ccb5157d61e57be7187e268" translate="yes" xml:space="preserve">
          <source>K.3.5.3.2 The fscanf_s function (p: 592-593)</source>
          <target state="translated">K.3.5.3.2 Функция fscanf_s (стр.592-593)</target>
        </trans-unit>
        <trans-unit id="85e026b41cb6fb14b9397ba5d5c295a20b084a8c" translate="yes" xml:space="preserve">
          <source>K.3.5.3.3 The printf_s function (p: 593-594)</source>
          <target state="translated">K.3.5.3.3 Функция printf_s (стр.593-594)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
