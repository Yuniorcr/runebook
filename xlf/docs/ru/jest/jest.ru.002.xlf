<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="jest">
    <body>
      <group id="jest">
        <trans-unit id="79f5b225cffab11e22dc40b6f05abef1d33d1561" translate="yes" xml:space="preserve">
          <source>Modes</source>
          <target state="translated">Modes</target>
        </trans-unit>
        <trans-unit id="009c795e3111448694cc3dc957f4b70c8f03b727" translate="yes" xml:space="preserve">
          <source>Module that identifies the primitive type of any JavaScript value. Exports a function that returns a string with the type of the value passed as argument.</source>
          <target state="translated">Модуль,который идентифицирует примитивный тип любого значения JavaScript.Экспортирует функцию,которая возвращает строку с типом значения,переданного в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="6dc759ef821892268cbe7edeb6bcf5abc7a031f8" translate="yes" xml:space="preserve">
          <source>Module used for parallelization of tasks. Exports a class &lt;code&gt;JestWorker&lt;/code&gt; that takes the path of Node.js module and lets you call the module's exported methods as if they were class methods, returning a promise that resolves when the specified method finishes its execution in a forked process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be53179917b8757ad3b5f547e48374b67d70e70" translate="yes" xml:space="preserve">
          <source>Module used for parallelization of tasks. Exports a class &lt;code&gt;Worker&lt;/code&gt; that takes the path of Node.js module and lets you call the module's exported methods as if they were class methods, returning a promise that resolves when the specified method finishes its execution in a forked process.</source>
          <target state="translated">Модуль, используемый для распараллеливания задач. Экспортирует класс &lt;code&gt;Worker&lt;/code&gt; , который принимает путь к модулю Node.js и позволяет вызывать экспортированные методы модуля, как если бы они были методами класса, возвращая обещание, которое разрешается, когда указанный метод завершает свое выполнение в разветвленном процессе.</target>
        </trans-unit>
        <trans-unit id="5123a0149608b8f62ab410c929a918587d7bbf79" translate="yes" xml:space="preserve">
          <source>Modules that are mapped to an alias are unmocked by default, regardless of whether automocking is enabled or not.</source>
          <target state="translated">Модули,привязанные к псевдониму,по умолчанию разблокированы,независимо от того,включена ли функция автосопровождения или нет.</target>
        </trans-unit>
        <trans-unit id="400881ff44dd95e53d5b70de2d221304a209dd8b" translate="yes" xml:space="preserve">
          <source>Modules that are mocked with &lt;code&gt;jest.mock&lt;/code&gt; are mocked only for the file that calls &lt;code&gt;jest.mock&lt;/code&gt;. Another file that imports the module will get the original implementation even if it runs after the test file that mocks the module.</source>
          <target state="translated">Модули, которые &lt;code&gt;jest.mock&lt;/code&gt; с помощью jest.mock, имитируются только для файла, который вызывает &lt;code&gt;jest.mock&lt;/code&gt; . Другой файл, который импортирует модуль, получит исходную реализацию, даже если он будет запущен после тестового файла, имитирующего модуль.</target>
        </trans-unit>
        <trans-unit id="bb101179b6d768145f738342dfe298b98e4b70e0" translate="yes" xml:space="preserve">
          <source>More Resources</source>
          <target state="translated">Больше ресурсов</target>
        </trans-unit>
        <trans-unit id="2028778347f5faaf24a3510ff5fbd1a91da38244" translate="yes" xml:space="preserve">
          <source>More about serializers API can be found &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/pretty-format/README.md#serialize&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7a524aa43cd2033804e07ac0567266d5069451" translate="yes" xml:space="preserve">
          <source>More information can be found at &lt;a href=&quot;https://github.com/skovhus/jest-codemods&quot;&gt;https://github.com/skovhus/jest-codemods&lt;/a&gt;.</source>
          <target state="translated">Более подробную информацию можно найти на &lt;a href=&quot;https://github.com/skovhus/jest-codemods&quot;&gt;https://github.com/skovhus/jest-codemods&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fde45e0d5214ab7d193c97e2773574aa18d36ca8" translate="yes" xml:space="preserve">
          <source>More information on Node debugging can be found &lt;a href=&quot;https://nodejs.org/api/debugger.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Более подробную информацию об отладке узлов можно найти &lt;a href=&quot;https://nodejs.org/api/debugger.html&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25a40503253892e6560d8d5c69a4720093cc2ba6" translate="yes" xml:space="preserve">
          <source>More information on how snapshot testing works and why we built it can be found on the &lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html&quot;&gt;release blog post&lt;/a&gt;. We recommend reading &lt;a href=&quot;http://benmccormick.org/2016/09/19/testing-with-jest-snapshots-first-impressions/&quot;&gt;this blog post&lt;/a&gt; to get a good sense of when you should use snapshot testing. We also recommend watching this &lt;a href=&quot;https://egghead.io/lessons/javascript-use-jest-s-snapshot-testing-feature?pl=testing-javascript-with-jest-a36c4074&quot;&gt;egghead video&lt;/a&gt; on Snapshot Testing with Jest.</source>
          <target state="translated">Более подробную информацию о том, как работает тестирование снимков и почему мы его создали, можно найти в &lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html&quot;&gt;публикации блога&lt;/a&gt; о выпуске . Мы рекомендуем прочитать &lt;a href=&quot;http://benmccormick.org/2016/09/19/testing-with-jest-snapshots-first-impressions/&quot;&gt;этот пост&lt;/a&gt; в блоге, чтобы понять, когда следует использовать тестирование снимков. Мы также рекомендуем посмотреть это &lt;a href=&quot;https://egghead.io/lessons/javascript-use-jest-s-snapshot-testing-feature?pl=testing-javascript-with-jest-a36c4074&quot;&gt;умное видео&lt;/a&gt; о тестировании снимков с помощью Jest.</target>
        </trans-unit>
        <trans-unit id="5f58721cb66c8644aaf7f808a07bb173fa203cd2" translate="yes" xml:space="preserve">
          <source>Most commonly this is being caused by conflicting Promise implementations. Consider replacing the global promise implementation with your own, for example &lt;code&gt;global.Promise = jest.requireActual('promise');&lt;/code&gt; and/or consolidate the used Promise libraries to a single one.</source>
          <target state="translated">Чаще всего это вызвано конфликтующими реализациями Promise. Рассмотрите возможность замены реализации глобального обещания своей собственной, например &lt;code&gt;global.Promise = jest.requireActual('promise');&lt;/code&gt; и / или объединить использованные библиотеки Promise в одну.</target>
        </trans-unit>
        <trans-unit id="d5fa9ec15923cf5a4447d89705061f4895a3a460" translate="yes" xml:space="preserve">
          <source>Most likely your glob patterns are not matching any files. Refer to the &lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;micromatch&lt;/a&gt; documentation to ensure your globs are compatible.</source>
          <target state="translated">Скорее всего, ваши шаблоны глобуса не соответствуют никаким файлам. Обратитесь к документации по &lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;микроматчу,&lt;/a&gt; чтобы убедиться, что ваши шарики совместимы.</target>
        </trans-unit>
        <trans-unit id="e06083df81e4470b804ff5d773dde170c25982a4" translate="yes" xml:space="preserve">
          <source>Most of the differences are explained in &lt;a href=&quot;https://nodejs.org/api/esm.html#esm_differences_between_es_modules_and_commonjs&quot;&gt;Node's documentation&lt;/a&gt;, but in addition to the things mentioned there, Jest injects a special variable into all executed files - the &lt;a href=&quot;jest-object&quot;&gt;&lt;code&gt;jest&lt;/code&gt; object&lt;/a&gt;. To access this object in ESM, you need to import it from the &lt;code&gt;@jest/globals&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70aff9a2e6d1a508cc94211f970a06aadb07a7f" translate="yes" xml:space="preserve">
          <source>Most real-world examples actually involve getting ahold of a mock function on a dependent component and configuring that, but the technique is the same. In these cases, try to avoid the temptation to implement logic inside of any function that's not directly being tested.</source>
          <target state="translated">Большинство реальных примеров на самом деле включают в себя получение информации о функции имитации зависимого компонента и ее настройку,но методика та же самая.В этих случаях постарайтесь избежать искушения реализовать логику внутри любой функции,которая не тестируется напрямую.</target>
        </trans-unit>
        <trans-unit id="1743857a25bf614f38c27b820f8398e3eb15e127" translate="yes" xml:space="preserve">
          <source>Most ways of comparing numbers have matcher equivalents.</source>
          <target state="translated">Большинство способов сравнения чисел имеют матчевые эквиваленты.</target>
        </trans-unit>
        <trans-unit id="07d9d7323ef86fe85fd1d7687235aac297bdcdee" translate="yes" xml:space="preserve">
          <source>Next, let's configure Jest to gracefully handle asset files such as stylesheets and images. Usually, these files aren't particularly useful in tests so we can safely mock them out. However, if you are using CSS Modules then it's better to mock a proxy for your className lookups.</source>
          <target state="translated">Далее,давайте настроим Jest на изящную работу с файлами активов,такими как таблицы стилей и изображения.Обычно эти файлы не особенно полезны в тестах,поэтому мы можем смело их высмеивать.Однако,если вы используете CSS модули,то лучше высмеять прокси для поиска className.</target>
        </trans-unit>
        <trans-unit id="0cd213a32f05bcc17b41830bc252640d32af3383" translate="yes" xml:space="preserve">
          <source>No default</source>
          <target state="translated">Не соблюдается по умолчанию</target>
        </trans-unit>
        <trans-unit id="069541cf8be1f0d43b5c179ab178c1af971111c3" translate="yes" xml:space="preserve">
          <source>No, as of Jest 20, snapshots in Jest are not automatically written when Jest is run in a CI system without explicitly passing &lt;code&gt;--updateSnapshot&lt;/code&gt;. It is expected that all snapshots are part of the code that is run on CI and since new snapshots automatically pass, they should not pass a test run on a CI system. It is recommended to always commit all snapshots and to keep them in version control.</source>
          <target state="translated">Нет, начиная с Jest 20, моментальные снимки в Jest не записываются автоматически при запуске Jest в системе CI без явной передачи &lt;code&gt;--updateSnapshot&lt;/code&gt; . Ожидается, что все моментальные снимки являются частью кода, который запускается в CI, и поскольку новые моментальные снимки проходят автоматически, они не должны проходить тестовый запуск в CI-системе. Рекомендуется всегда фиксировать все снимки и держать их под контролем версий.</target>
        </trans-unit>
        <trans-unit id="2c8a846eddb8681ebf180cd4b3a87cddb1fe5a15" translate="yes" xml:space="preserve">
          <source>None of these forms is particularly superior to the others, and you can mix and match them across a codebase or even in a single file. It just depends on which style you feel makes your tests simpler.</source>
          <target state="translated">Ни одна из этих форм не особенно превосходит другие,и вы можете смешивать и сопоставлять их по кодовой базе или даже в одном файле.Это зависит только от того,какой стиль вы чувствуете,делает ваши тесты проще.</target>
        </trans-unit>
        <trans-unit id="593dc274bf37fc96d1260b84eb4792e03219586d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;column&lt;/code&gt; is 0-indexed while &lt;code&gt;line&lt;/code&gt; is not.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;column&lt;/code&gt; имеет индекс 0, а &lt;code&gt;line&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="92f6cb372e87dfa7e7a0186add10026144aaa046" translate="yes" xml:space="preserve">
          <source>Note that due to its experimental nature there are many bugs and missing features in Jest's implementation, both known and unknown. You should check out the &lt;a href=&quot;https://github.com/facebook/jest/issues/9430&quot;&gt;tracking issue&lt;/a&gt; and the &lt;a href=&quot;https://github.com/facebook/jest/labels/ES%20Modules&quot;&gt;label&lt;/a&gt; on the issue tracker for the latest status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fbb94ab3f435207f3668ea824069ffb13ba8524" translate="yes" xml:space="preserve">
          <source>Note that the mock can't be an arrow function because calling &lt;code&gt;new&lt;/code&gt; on an arrow function is not allowed in JavaScript. So this won't work:</source>
          <target state="translated">Обратите внимание, что макет не может быть стрелочной функцией, потому что вызов &lt;code&gt;new&lt;/code&gt; для стрелочной функции не разрешен в JavaScript. Так что это не сработает:</target>
        </trans-unit>
        <trans-unit id="35e09d6f70cb52a597a44fb09de97ecc2bafcf55" translate="yes" xml:space="preserve">
          <source>Note that the top-level &lt;code&gt;beforeEach&lt;/code&gt; is executed before the &lt;code&gt;beforeEach&lt;/code&gt; inside the &lt;code&gt;describe&lt;/code&gt; block. It may help to illustrate the order of execution of all hooks.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;beforeEach&lt;/code&gt; верхнего уровня выполняется перед &lt;code&gt;beforeEach&lt;/code&gt; внутри блока &lt;code&gt;describe&lt;/code&gt; . Это может помочь проиллюстрировать порядок выполнения всех хуков.</target>
        </trans-unit>
        <trans-unit id="dab00f8f32e989ec35b0b0ca3de5a6325b1623eb" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;v8&lt;/code&gt; is considered experimental. This uses V8's builtin code coverage rather than one based on Babel. It is not as well tested, and it has also improved in the last few releases of Node. Using the latest versions of node (v14 at the time of this writing) will yield better results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5317a3a7e7d23a56315a8874c449817c31ad8a0c" translate="yes" xml:space="preserve">
          <source>Note that, if you specify a global reference value (like an object or array) here, and some code mutates that value in the midst of running a test, that mutation will &lt;em&gt;not&lt;/em&gt; be persisted across test runs for other test files. In addition the &lt;code&gt;globals&lt;/code&gt; object must be json-serializable, so it can't be used to specify global functions. For that you should use &lt;code&gt;setupFiles&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание: если вы укажете здесь значение глобальной ссылки (например, объект или массив), и какой-то код изменяет это значение в процессе выполнения теста, эта мутация &lt;em&gt;не&lt;/em&gt; будет сохраняться при выполнении тестов для других тестовых файлов. Кроме того, объект &lt;code&gt;globals&lt;/code&gt; должен быть json-сериализуемым, поэтому его нельзя использовать для указания глобальных функций. Для этого вы должны использовать &lt;code&gt;setupFiles&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b104c13194e34da09ed53bf72fc268a0c3110ad" translate="yes" xml:space="preserve">
          <source>Note that, if you specify a global reference value (like an object or array) here, and some code mutates that value in the midst of running a test, that mutation will &lt;em&gt;not&lt;/em&gt; be persisted across test runs for other test files. In addition, the &lt;code&gt;globals&lt;/code&gt; object must be json-serializable, so it can't be used to specify global functions. For that, you should use &lt;code&gt;setupFiles&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc786612e42a25f8f3750696a48a69840f36cd3" translate="yes" xml:space="preserve">
          <source>Note that, since you are still testing promises, the test is still asynchronous. Hence, you will need to &lt;a href=&quot;asynchronous#promises&quot;&gt;tell Jest to wait&lt;/a&gt; by returning the unwrapped assertion.</source>
          <target state="translated">Обратите внимание, что, поскольку вы все еще тестируете обещания, тест по-прежнему асинхронный. Следовательно, вам нужно будет &lt;a href=&quot;asynchronous#promises&quot;&gt;указать Jest подождать&lt;/a&gt; , вернув развернутое утверждение.</target>
        </trans-unit>
        <trans-unit id="9794622b767437b0ecae517257f9db04f7adf32d" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; is a special token that gets replaced by Jest with the root of your project. Most of the time this will be the folder where your &lt;code&gt;package.json&lt;/code&gt; is located unless you specify a custom &lt;code&gt;rootDir&lt;/code&gt; option in your configuration.</source>
          <target state="translated">Примечание. &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; - это специальный токен, который Jest заменяет корнем вашего проекта. В большинстве случаев это будет папка, в которой находится ваш &lt;code&gt;package.json&lt;/code&gt; , если вы не укажете пользовательский параметр &lt;code&gt;rootDir&lt;/code&gt; в своей конфигурации.</target>
        </trans-unit>
        <trans-unit id="628dafac3ccff711682a19552f96e64d7e9e0c0e" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;.toEqual&lt;/code&gt; won't perform a &lt;em&gt;deep equality&lt;/em&gt; check for two errors. Only the &lt;code&gt;message&lt;/code&gt; property of an Error is considered for equality. It is recommended to use the &lt;code&gt;.toThrow&lt;/code&gt; matcher for testing against errors.</source>
          <target state="translated">Примечание. &lt;code&gt;.toEqual&lt;/code&gt; не выполняет &lt;em&gt;глубокую&lt;/em&gt; проверку &lt;em&gt;равенства&lt;/em&gt; для двух ошибок. Только свойство &lt;code&gt;message&lt;/code&gt; ошибки рассматривается для равенства. Рекомендуется использовать сопоставитель &lt;code&gt;.toThrow&lt;/code&gt; для проверки на наличие ошибок.</target>
        </trans-unit>
        <trans-unit id="7613acf3a264c0259c7e5490495960bb2558a069" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;babel-jest&lt;/code&gt; is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the &lt;code&gt;transform&lt;/code&gt; configuration option:</source>
          <target state="translated">Примечание: &lt;code&gt;babel-jest&lt;/code&gt; устанавливается автоматически при установке Jest и автоматически преобразует файлы, если в вашем проекте существует конфигурация babel. Чтобы избежать такого поведения, вы можете явно сбросить параметр конфигурации &lt;code&gt;transform&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d063b0b7dc564c8180bc1b9d7afb5ca825c92c4b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;test.concurrent&lt;/code&gt; is considered experimental - see &lt;a href=&quot;https://github.com/facebook/jest/labels/Area%3A%20Concurrent&quot;&gt;here&lt;/a&gt; for details on missing features and other issues</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1bf41dd30024dc8f6a9cf73cdb3281441a7c127" translate="yes" xml:space="preserve">
          <source>Note: For more complex webpack configurations, you may also want to investigate projects such as: &lt;a href=&quot;https://github.com/istarkov/babel-plugin-webpack-loaders&quot;&gt;babel-plugin-webpack-loaders&lt;/a&gt;.</source>
          <target state="translated">Примечание. Для более сложных конфигураций веб-пакетов вы также можете изучить такие проекты, как: &lt;a href=&quot;https://github.com/istarkov/babel-plugin-webpack-loaders&quot;&gt;babel-plugin-webpack-loaders&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e5ee4f891332fe29d99fc8b7113be07b4978e5d9" translate="yes" xml:space="preserve">
          <source>Note: If a &lt;strong&gt;promise is returned&lt;/strong&gt; from &lt;code&gt;test&lt;/code&gt;, Jest will wait for the promise to resolve before letting the test complete. Jest will also wait if you &lt;strong&gt;provide an argument to the test function&lt;/strong&gt;, usually called &lt;code&gt;done&lt;/code&gt;. This could be handy when you want to test callbacks. See how to test async code &lt;a href=&quot;asynchronous#callbacks&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Примечание. Если &lt;strong&gt;обещание возвращается&lt;/strong&gt; из &lt;code&gt;test&lt;/code&gt; , Jest будет ждать выполнения обещания, прежде чем позволить тесту завершиться. Jest также будет ждать, если вы &lt;strong&gt;предоставите аргумент тестовой функции&lt;/strong&gt; , обычно называемой &lt;code&gt;done&lt;/code&gt; . Это может быть удобно, если вы хотите протестировать обратные вызовы. Посмотрите, как протестировать асинхронный код &lt;a href=&quot;asynchronous#callbacks&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2c9e685037a098f7ab5cab7e553edaf0c09711f" translate="yes" xml:space="preserve">
          <source>Note: In order to mock properly, Jest needs &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; to be in the same scope as the &lt;code&gt;require/import&lt;/code&gt; statement.</source>
          <target state="translated">Примечание. Для правильной &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; Jest необходимо, чтобы jest.mock ('moduleName') находился в той же области видимости, что и оператор &lt;code&gt;require/import&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fc7ec9481edc4a64cc4cee9fd0a5b4e7d421cf5" translate="yes" xml:space="preserve">
          <source>Note: Jest caches files to speed up test execution. If you updated .babelrc and Jest is still not working, try running Jest with &lt;code&gt;--no-cache&lt;/code&gt;.</source>
          <target state="translated">Примечание. Jest кэширует файлы для ускорения выполнения теста. Если вы обновили .babelrc, а Jest все еще не работает, попробуйте запустить Jest с &lt;code&gt;--no-cache&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18499d47a5d29c4202e6b0823b51b2cc1f3a7091" translate="yes" xml:space="preserve">
          <source>Note: Jest documentation uses &lt;code&gt;yarn&lt;/code&gt; commands, but &lt;code&gt;npm&lt;/code&gt; will also work. You can compare &lt;code&gt;yarn&lt;/code&gt; and &lt;code&gt;npm&lt;/code&gt; commands in the &lt;a href=&quot;https://yarnpkg.com/en/docs/migrating-from-npm#toc-cli-commands-comparison&quot;&gt;yarn docs, here&lt;/a&gt;.</source>
          <target state="translated">Примечание: Шутка документация использует &lt;code&gt;yarn&lt;/code&gt; команды, но &lt;code&gt;npm&lt;/code&gt; также будет работать. Вы можете сравнить &lt;code&gt;yarn&lt;/code&gt; и &lt;code&gt;npm&lt;/code&gt; команду в &lt;a href=&quot;https://yarnpkg.com/en/docs/migrating-from-npm#toc-cli-commands-comparison&quot;&gt;Документах пряжи, здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cff4d7445c3ba40f87a1439f00a6eba64d370e9" translate="yes" xml:space="preserve">
          <source>Note: The snapshot is directly scoped to the data you render &amp;ndash; in our example it's &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component with page prop passed to it. This implies that even if any other file has missing props (Say, &lt;code&gt;App.js&lt;/code&gt;) in the &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component, it will still pass the test as the test doesn't know the usage of &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component and it's scoped only to the &lt;code&gt;Link.react.js&lt;/code&gt;. Also, Rendering the same component with different props in other snapshot tests will not affect the first one, as the tests don't know about each other.</source>
          <target state="translated">Примечание. Область действия снимка напрямую связана с отображаемыми вами данными - в нашем примере это компонент &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; с переданной ему опорой страницы. Это означает, что даже если в каком-либо другом файле отсутствуют реквизиты (скажем, &lt;code&gt;App.js&lt;/code&gt; ) в компоненте &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; , он все равно пройдет тест, поскольку тест не знает об использовании компонента &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; и его область действия только для &lt;code&gt;Link.react.js&lt;/code&gt; . Кроме того, рендеринг одного и того же компонента с разными реквизитами в других тестах моментальных снимков не повлияет на первый, поскольку тесты не знают друг о друге.</target>
        </trans-unit>
        <trans-unit id="6496fae13ef766903ec9c79181224c2df30885e8" translate="yes" xml:space="preserve">
          <source>Note: The snapshot is directly scoped to the data you render &amp;ndash; in our example the &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component with &lt;code&gt;page&lt;/code&gt; prop passed to it. This implies that even if any other file has missing props (Say, &lt;code&gt;App.js&lt;/code&gt;) in the &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component, it will still pass the test as the test doesn't know the usage of &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component and it's scoped only to the &lt;code&gt;Link.react.js&lt;/code&gt;. Also, Rendering the same component with different props in other snapshot tests will not affect the first one, as the tests don't know about each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="866607a189359968f5ff8b001676f89035486e7b" translate="yes" xml:space="preserve">
          <source>Note: This function is not available when using modern fake timers implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d58fe2211cffb9e77307ff7a8d198bd500bab696" translate="yes" xml:space="preserve">
          <source>Note: This function is only available when using modern fake timers implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a20c17aceb39b181c11f8ff4c0ad0c423d32862" translate="yes" xml:space="preserve">
          <source>Note: Use &lt;code&gt;maxConcurrency&lt;/code&gt; in configuration to prevents Jest from executing more than the specified amount of tests at the same time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f87616f2342dfb53f7c81b06d94dec773c92c7" translate="yes" xml:space="preserve">
          <source>Note: You must wrap the code in a function, otherwise the error will not be caught and the assertion will fail.</source>
          <target state="translated">Примечание:код необходимо обернуть в функцию,иначе ошибка не будет поймана,и утверждение будет неудачным.</target>
        </trans-unit>
        <trans-unit id="6eb20dc9b8a75cec38d02e8f54a09a224da2b36c" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;--runInBand&lt;/code&gt; cli option makes sure Jest runs test in the same process rather than spawning processes for individual tests. Normally Jest parallelizes test runs across processes but it is hard to debug many processes at the same time.</source>
          <target state="translated">Примечание. &lt;code&gt;--runInBand&lt;/code&gt; гарантирует, что Jest запускает тест в одном процессе, а не порождает процессы для отдельных тестов. Обычно Jest распараллеливает выполнение тестов между процессами, но отлаживать несколько процессов одновременно сложно.</target>
        </trans-unit>
        <trans-unit id="96194ed3517159111cf9532affab238e70f5eef6" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;--runInBand&lt;/code&gt; cli option makes sure Jest runs the test in the same process rather than spawning processes for individual tests. Normally Jest parallelizes test runs across processes but it is hard to debug many processes at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4023ed8bfb6fa137e2322c83d2fb6a7bdccaa7cc" translate="yes" xml:space="preserve">
          <source>Note: the defaultResolver passed as an option is the Jest default resolver which might be useful when you write your custom one. It takes the same arguments as your custom one, e.g. &lt;code&gt;(request, options)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a5108cffe44c788bf001c5788a68bdfb2e0028" translate="yes" xml:space="preserve">
          <source>Note: the defaultResolver passed as options is the jest default resolver which might be useful when you write your custom one. It takes the same arguments as your custom one, e.g. (request, options).</source>
          <target state="translated">Замечание:переданный в качестве опции резольвер по умолчаниюResolver является шуточным резольвером по умолчанию,который может быть полезен,когда вы пишете свой пользовательский.Он принимает те же аргументы,что и пользовательский,например (запрос,опции).</target>
        </trans-unit>
        <trans-unit id="08a800e5165f53b98f96928e40e168f030f156c8" translate="yes" xml:space="preserve">
          <source>Note: the function that throws an exception needs to be invoked within a wrapping function otherwise the &lt;code&gt;toThrow&lt;/code&gt; assertion will fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63519bb0bd54e1b894cccdf4f3af7852ef618bb7" translate="yes" xml:space="preserve">
          <source>Note: the nth argument must be positive integer starting from 1.</source>
          <target state="translated">Замечание:n-й аргумент должен быть положительным целым числом,начиная с 1.</target>
        </trans-unit>
        <trans-unit id="dc782aff0e671f43d928b262fb2a1ad60df35d44" translate="yes" xml:space="preserve">
          <source>Notice that Proxy is enabled in Node 6 by default. If you are not on Node 6 yet, make sure you invoke Jest using &lt;code&gt;node --harmony_proxies node_modules/.bin/jest&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что прокси включен в узле 6 по умолчанию. Если вы еще не используете узел 6, убедитесь, что вы вызываете Jest с помощью &lt;code&gt;node --harmony_proxies node_modules/.bin/jest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97d92ee85a42081babf70348e9395eeb01e66cc8" translate="yes" xml:space="preserve">
          <source>Now imagine an implementation of &lt;code&gt;request.js&lt;/code&gt; that goes to the network and fetches some user data:</source>
          <target state="translated">Теперь представьте реализацию &lt;code&gt;request.js&lt;/code&gt; , которая идет в сеть и извлекает некоторые пользовательские данные:</target>
        </trans-unit>
        <trans-unit id="bb60cb13af7d9fd41f600f4cb00d4bff107937d6" translate="yes" xml:space="preserve">
          <source>Now let's use React's test renderer and Jest's snapshot feature to interact with the component and capture the rendered output and create a snapshot file:</source>
          <target state="translated">Теперь давайте используем тестовый рендерер React и функцию Jest'snapshot для взаимодействия с компонентом,захвата отрисованного результата и создания файла снимка:</target>
        </trans-unit>
        <trans-unit id="7ce0f103deaf5dc6dbc56bf66214617663420f57" translate="yes" xml:space="preserve">
          <source>Now let's write a test for our async functionality.</source>
          <target state="translated">Теперь давайте напишем тест на нашу асинхронную функциональность.</target>
        </trans-unit>
        <trans-unit id="4759fbb62123d73c1226706f0f4d34666a8582b0" translate="yes" xml:space="preserve">
          <source>Now that Jest knows how to process our files, we need to tell it how to &lt;em&gt;find&lt;/em&gt; them. For webpack's &lt;code&gt;modulesDirectories&lt;/code&gt;, and &lt;code&gt;extensions&lt;/code&gt; options there are direct analogs in Jest's &lt;code&gt;moduleDirectories&lt;/code&gt; and &lt;code&gt;moduleFileExtensions&lt;/code&gt; options.</source>
          <target state="translated">Теперь, когда Jest знает, как обрабатывать наши файлы, нам нужно указать ему, как их &lt;em&gt;найти&lt;/em&gt; . Для параметров &lt;code&gt;modulesDirectories&lt;/code&gt; и &lt;code&gt;extensions&lt;/code&gt; webpack есть прямые аналоги в параметрах Jest &lt;code&gt;moduleDirectories&lt;/code&gt; и &lt;code&gt;moduleFileExtensions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5a5de53298548d7d54ae3ca8e892f7df5aa2243" translate="yes" xml:space="preserve">
          <source>Now we write our test. Note that we need to explicitly tell that we want to mock the &lt;code&gt;fs&lt;/code&gt; module because it&amp;rsquo;s a core Node module:</source>
          <target state="translated">Теперь пишем наш тест. Обратите внимание, что нам нужно явно указать, что мы хотим &lt;code&gt;fs&lt;/code&gt; модуль fs, потому что это основной модуль Node:</target>
        </trans-unit>
        <trans-unit id="46a5c027241fe1614d4396220914efc2314503e5" translate="yes" xml:space="preserve">
          <source>Now, every time the snapshot test case runs, &lt;code&gt;Date.now()&lt;/code&gt; will return &lt;code&gt;1482363367071&lt;/code&gt; consistently. This will result in the same snapshot being generated for this component regardless of when the test is run.</source>
          <target state="translated">Теперь при каждом &lt;code&gt;Date.now()&lt;/code&gt; тестового примера моментального снимка Date.now () будет последовательно возвращать &lt;code&gt;1482363367071&lt;/code&gt; . В результате для этого компонента будет создан один и тот же моментальный снимок независимо от того, когда запускается тест.</target>
        </trans-unit>
        <trans-unit id="f5e6490929905f7bc8af5ccef9bf48f8668b1460" translate="yes" xml:space="preserve">
          <source>Now, in order to test this method without actually hitting the API (and thus creating slow and fragile tests), we can use the &lt;code&gt;jest.mock(...)&lt;/code&gt; function to automatically mock the axios module.</source>
          <target state="translated">Теперь, чтобы протестировать этот метод, не затрагивая API (и тем самым создавая медленные и ненадежные тесты), мы можем использовать &lt;code&gt;jest.mock(...)&lt;/code&gt; для автоматической имитации модуля axios.</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="8d3eb6284bfb714ab8ca96c009bf8ad9c4fc7252" translate="yes" xml:space="preserve">
          <source>Object types are checked to be equal. e.g. A class instance with fields &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; will not equal a literal object with fields &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Проверяется соответствие типов объектов. например, экземпляр класса с полями &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; не будет равняться буквальному объекту с полями &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2176a8ab6b1e30ac16f60c568568a437d540248" translate="yes" xml:space="preserve">
          <source>Often there are fields in the object you want to snapshot which are generated (like IDs and Dates). If you try to snapshot these objects, they will force the snapshot to fail on every run:</source>
          <target state="translated">Часто в объекте,который вы хотите снять,есть поля,которые генерируются (например,IDs и Dates).Если вы попытаетесь сделать снимки этих объектов,они будут заставлять снимки делать неудачные снимки при каждом запуске:</target>
        </trans-unit>
        <trans-unit id="6ffecdf0087875891dd611103daecc4d8bcf8763" translate="yes" xml:space="preserve">
          <source>Often this is useful when you want to clean up a mock's usage data between two assertions.</source>
          <target state="translated">Часто это полезно,когда вы хотите очистить данные об использовании имитатора между двумя утверждениями.</target>
        </trans-unit>
        <trans-unit id="79cd3f6e68b0a9656087292d49bbeda556ae6d96" translate="yes" xml:space="preserve">
          <source>Often while writing tests you have some setup work that needs to happen before tests run, and you have some finishing work that needs to happen after tests run. Jest provides helper functions to handle this.</source>
          <target state="translated">Часто во время написания тестов у вас есть определенная работа по настройке,которая должна быть выполнена до запуска тестов,и у вас есть определенная работа по завершению,которая должна быть выполнена после запуска тестов.Шут предоставляет функции помощника,чтобы справиться с этим.</target>
        </trans-unit>
        <trans-unit id="4f3d546a97573ddf0fe581d729e6b000ed006545" translate="yes" xml:space="preserve">
          <source>Oftentimes, you'll want to set this to &lt;code&gt;'src'&lt;/code&gt; or &lt;code&gt;'lib'&lt;/code&gt;, corresponding to where in your repository the code is stored.</source>
          <target state="translated">Часто вам нужно установить для него значение &lt;code&gt;'src'&lt;/code&gt; или &lt;code&gt;'lib'&lt;/code&gt; , в зависимости от того, где в вашем репозитории хранится код.</target>
        </trans-unit>
        <trans-unit id="c12f3f3ee865af90cac56dabeb84091b38861136" translate="yes" xml:space="preserve">
          <source>On occasion there are times where the automatically generated mock the module system would normally provide you isn't adequate enough for your testing needs. Normally under those circumstances you should write a &lt;a href=&quot;manual-mocks&quot;&gt;manual mock&lt;/a&gt; that is more adequate for the module in question. However, on extremely rare occasions, even a manual mock isn't suitable for your purposes and you need to build the mock yourself inside your test.</source>
          <target state="translated">Иногда бывают случаи, когда автоматически сгенерированный макет, который обычно предоставляет модульная система, недостаточно для ваших нужд тестирования. Обычно при таких обстоятельствах вы должны написать &lt;a href=&quot;manual-mocks&quot;&gt;вручную макет,&lt;/a&gt; который больше подходит для рассматриваемого модуля. Однако в очень редких случаях даже ручной макет не подходит для ваших целей, и вам нужно создать макет самостоятельно внутри своего теста.</target>
        </trans-unit>
        <trans-unit id="ccd4436c2d3d88fb5477ef92425da0b5c05ebca6" translate="yes" xml:space="preserve">
          <source>On occasion, there are times where the automatically generated mock the module system would normally provide you isn't adequate enough for your testing needs. Normally under those circumstances you should write a &lt;a href=&quot;manual-mocks&quot;&gt;manual mock&lt;/a&gt; that is more adequate for the module in question. However, on extremely rare occasions, even a manual mock isn't suitable for your purposes and you need to build the mock yourself inside your test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1833be118eff717aa421c7c29043719c42065791" translate="yes" xml:space="preserve">
          <source>Once we mock the module we can provide a &lt;code&gt;mockResolvedValue&lt;/code&gt; for &lt;code&gt;.get&lt;/code&gt; that returns the data we want our test to assert against. In effect, we are saying that we want &lt;code&gt;axios.get('/users.json')&lt;/code&gt; to return a fake response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef0b229d34fbb64b6540632318f3fdbaa2280e6" translate="yes" xml:space="preserve">
          <source>Once we mock the module we can provide a &lt;code&gt;mockResolvedValue&lt;/code&gt; for &lt;code&gt;.get&lt;/code&gt; that returns the data we want our test to assert against. In effect, we are saying that we want axios.get('/users.json') to return a fake response.</source>
          <target state="translated">Как только мы &lt;code&gt;mockResolvedValue&lt;/code&gt; модуль, мы можем предоставить mockResolvedValue для &lt;code&gt;.get&lt;/code&gt; , который возвращает данные, которые мы хотим, чтобы наш тест утверждал. По сути, мы говорим, что хотим, чтобы axios.get ('/ users.json') возвращал поддельный ответ.</target>
        </trans-unit>
        <trans-unit id="e0fd8cdd8b9b5a8885d7339d6a566088a20fe3d5" translate="yes" xml:space="preserve">
          <source>Once you enter Interactive Snapshot Mode, Jest will step you through the failed snapshots one test at a time and give you the opportunity to review the failed output.</source>
          <target state="translated">Как только вы войдете в интерактивный режим снимков,Jest проведет вас через неудачные снимки по одному тесту за раз и даст вам возможность просмотреть неудачный вывод.</target>
        </trans-unit>
        <trans-unit id="7ffee35fa0cdfd66f92f9f207350deb369bb338b" translate="yes" xml:space="preserve">
          <source>Once you're finished, Jest will give you a summary before returning back to watch mode:</source>
          <target state="translated">Как только вы закончите,&quot;Шут&quot; даст вам сводку перед возвращением в режим просмотра:</target>
        </trans-unit>
        <trans-unit id="04e3f29cab1cd3970d5e34742e1c9209c2a454b6" translate="yes" xml:space="preserve">
          <source>Once you've learned about the matchers that are available, a good next step is to check out how Jest lets you &lt;a href=&quot;asynchronous&quot;&gt;test asynchronous code&lt;/a&gt;.</source>
          <target state="translated">После того, как вы узнали о доступных сопоставителях, следующим хорошим шагом будет проверить, как Jest позволяет &lt;a href=&quot;asynchronous&quot;&gt;тестировать асинхронный код&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="911829cb001fba297a8440e3959d077dc4ad2675" translate="yes" xml:space="preserve">
          <source>One example when this is useful is when you want to mock a module differently within the same file:</source>
          <target state="translated">Один из примеров,когда это полезно,это когда вы хотите подшутить над модулем по-другому в одном и том же файле:</target>
        </trans-unit>
        <trans-unit id="44d433b060d5be5e5cb29585b03e7a39cbe16040" translate="yes" xml:space="preserve">
          <source>One of the files matching the &lt;code&gt;./src/reducers/**/*.js&lt;/code&gt; glob has less than 90% statement coverage.</source>
          <target state="translated">Один из файлов, соответствующих &lt;code&gt;./src/reducers/**/*.js&lt;/code&gt; имеет менее 90% покрытия операторов.</target>
        </trans-unit>
        <trans-unit id="33de0273fb385ef534431d972ca028ab9fae9e00" translate="yes" xml:space="preserve">
          <source>One or more subsequent rows of data supplied as template literal expressions using &lt;code&gt;${value}&lt;/code&gt; syntax.</source>
          <target state="translated">Одна или несколько последующих строк данных, представленных в виде шаблонных литеральных выражений с использованием синтаксиса &lt;code&gt;${value}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfce43d345326fcdf5172027f076645beb3b6bbb" translate="yes" xml:space="preserve">
          <source>One such situation can arise if we intentionally change the address the Link component in our example is pointing to.</source>
          <target state="translated">Одна из таких ситуаций может возникнуть,если мы намеренно изменим адрес,на который указывает компонент Link в нашем примере.</target>
        </trans-unit>
        <trans-unit id="8c3971f2be369ec67c710b4572f1ea126ad557a5" translate="yes" xml:space="preserve">
          <source>One-Time Setup</source>
          <target state="translated">Одноразовая настройка</target>
        </trans-unit>
        <trans-unit id="883b26a66c75d25a769cffa672f3388d833b2cc4" translate="yes" xml:space="preserve">
          <source>Only the &quot;it is raining&quot; test will run in that test file, since it is run with &lt;code&gt;test.only&lt;/code&gt;.</source>
          <target state="translated">В этом тестовом файле будет запускаться только тест &amp;laquo;идет дождь&amp;raquo;, так как он запускается только с &lt;code&gt;test.only&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00991593a9f4d31e6c4dd6dbb447ea1e1f468c00" translate="yes" xml:space="preserve">
          <source>Only the &quot;it is raining&quot; test will run, since the other test is run with &lt;code&gt;test.skip&lt;/code&gt;.</source>
          <target state="translated">Будет запущен только тест &quot;идет дождь&quot;, поскольку другой тест запускается с помощью &lt;code&gt;test.skip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="749db9a1ae125917392d1a5146e4c6d00c14a9d3" translate="yes" xml:space="preserve">
          <source>Optionally, you can provide &lt;code&gt;steps&lt;/code&gt;, so it will run &lt;code&gt;steps&lt;/code&gt; amount of next timeouts/intervals.</source>
          <target state="translated">При желании вы можете указать &lt;code&gt;steps&lt;/code&gt; , поэтому он будет выполнять количество &lt;code&gt;steps&lt;/code&gt; следующих тайм-аутов / интервалов.</target>
        </trans-unit>
        <trans-unit id="920bdedd844899cd5664de8cfd74adb5d459a38e" translate="yes" xml:space="preserve">
          <source>Optionally, you can provide a &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) for specifying how long to wait before aborting. &lt;em&gt;Note: The default timeout is 5 seconds.&lt;/em&gt;</source>
          <target state="translated">При желании вы можете указать &lt;code&gt;timeout&lt;/code&gt; (в миллисекундах), чтобы указать, как долго ждать перед прерыванием. &lt;em&gt;Примечание. Тайм-аут по умолчанию составляет 5 секунд.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4bf57bdba6d591e8cfd0266e8b8c0a594cbd7d55" translate="yes" xml:space="preserve">
          <source>Optionally, you can provide a &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) for specifying how long to wait for each row before aborting. &lt;em&gt;Note: The default timeout is 5 seconds.&lt;/em&gt;</source>
          <target state="translated">При желании вы можете указать &lt;code&gt;timeout&lt;/code&gt; (в миллисекундах), чтобы указать, как долго ждать каждой строки перед прерыванием. &lt;em&gt;Примечание. Тайм-аут по умолчанию составляет 5 секунд.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="5c52bc127f7b5826340dcf7c16bf51e0c271179b" translate="yes" xml:space="preserve">
          <source>Or &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;&lt;code&gt;npm&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Или &lt;a href=&quot;https://www.npmjs.com/&quot;&gt; &lt;code&gt;npm&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d89d40959e0d933e8af9e53128924505cd140e00" translate="yes" xml:space="preserve">
          <source>Or &lt;a href=&quot;https://www.npmjs.com/package/jest&quot;&gt;&lt;code&gt;npm&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371316f168eab595bc4ea7391514a4fa0fe1808f" translate="yes" xml:space="preserve">
          <source>Or if you'd like to create your own manual mock, you can do something like this:</source>
          <target state="translated">Или,если вы хотите создать свою собственную ручную насмешку,вы можете сделать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="5e431292d05ab6b8e395a562d7c86a6ac7fe933b" translate="yes" xml:space="preserve">
          <source>Or through JavaScript:</source>
          <target state="translated">Или через JavaScript:</target>
        </trans-unit>
        <trans-unit id="6885f402c4ee1de5eff12b5e007bf6c788da9b3e" translate="yes" xml:space="preserve">
          <source>Or through TypeScript (if &lt;code&gt;ts-node&lt;/code&gt; is installed):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a0778a7a6879004009864ebf95b81c7e7732d5" translate="yes" xml:space="preserve">
          <source>Order of execution of describe and test blocks</source>
          <target state="translated">Порядок выполнения блоков описания и тестирования</target>
        </trans-unit>
        <trans-unit id="489864adf35b7b6f389f08017e013d2e99fa910a" translate="yes" xml:space="preserve">
          <source>Otherwise, please see our &lt;a href=&quot;getting-started#using-typescript&quot;&gt;Getting Started&lt;/a&gt; guide for to get setup with TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9a3dd308dd30f061fa22d50cb21bc2220dcf9c9" translate="yes" xml:space="preserve">
          <source>Our mocked class will need to provide any member functions (&lt;code&gt;playSoundFile&lt;/code&gt; in the example) that will be called during our tests, or else we'll get an error for calling a function that doesn't exist. But we'll probably want to also spy on calls to those methods, to ensure that they were called with the expected parameters.</source>
          <target state="translated">Наш фиктивный класс должен будет предоставить любые функции-члены ( &lt;code&gt;playSoundFile&lt;/code&gt; в примере), которые будут вызываться во время наших тестов, иначе мы получим ошибку при вызове функции, которая не существует. Но мы, вероятно, захотим также следить за вызовами этих методов, чтобы убедиться, что они вызываются с ожидаемыми параметрами.</target>
        </trans-unit>
        <trans-unit id="bfc5a5b4ca8f80ee77043098ef9ffc04d559ec8c" translate="yes" xml:space="preserve">
          <source>Place a &lt;code&gt;debugger;&lt;/code&gt; statement in any of your tests, and then, in your project's directory, run:</source>
          <target state="translated">Установите &lt;code&gt;debugger;&lt;/code&gt; в любом из ваших тестов, а затем в каталоге вашего проекта запустите:</target>
        </trans-unit>
        <trans-unit id="2d313b13f95b5bdfa47176161df9d9aac0aea191" translate="yes" xml:space="preserve">
          <source>Please keep in mind that the resulting configuration must be JSON-serializable.</source>
          <target state="translated">Пожалуйста,имейте в виду,что результирующая конфигурация должна быть JSON-сериализуемой.</target>
        </trans-unit>
        <trans-unit id="af206380956fb62af6fa59d92f109cd9641063d0" translate="yes" xml:space="preserve">
          <source>Please note that if you use arrow functions in your classes, they will &lt;em&gt;not&lt;/em&gt; be part of the mock. The reason for that is that arrow functions are not present on the object's prototype, they are merely properties holding a reference to a function.</source>
          <target state="translated">Обратите внимание, что если вы используете в своих классах стрелочные функции, они &lt;em&gt;не&lt;/em&gt; будут частью макета. Причина в том, что стрелочные функции отсутствуют в прототипе объекта, они являются просто свойствами, содержащими ссылку на функцию.</target>
        </trans-unit>
        <trans-unit id="a1e1312206132e72928ab543d2089ca56fc8c1f3" translate="yes" xml:space="preserve">
          <source>Please note that we currently don't support &lt;code&gt;jest.mock&lt;/code&gt; in a clean way in ESM, but that is something we intend to add proper support for in the future. Follow &lt;a href=&quot;https://github.com/facebook/jest/issues/10025&quot;&gt;this issue&lt;/a&gt; for updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c438f6772aa6520819506e7fbe99852dd87fd5" translate="yes" xml:space="preserve">
          <source>Plugins can be customized via your Jest configuration.</source>
          <target state="translated">Плагины можно настроить через конфигурацию Jest.</target>
        </trans-unit>
        <trans-unit id="93e78b672f965eb7c8293baebd2be38d992a6655" translate="yes" xml:space="preserve">
          <source>Preset configuration</source>
          <target state="translated">Предустановленная конфигурация</target>
        </trans-unit>
        <trans-unit id="bfb26311747a6131c77f1e75e89e1da90925579c" translate="yes" xml:space="preserve">
          <source>Presets may also be relative filesystem paths.</source>
          <target state="translated">Предустановки также могут быть относительными путями файловой системы.</target>
        </trans-unit>
        <trans-unit id="86d670142d92672ef1ecead31bfb2615a86fbfe5" translate="yes" xml:space="preserve">
          <source>Presets may also be relative to filesystem paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33521f1e271c7d1369654933da9149112fe4281c" translate="yes" xml:space="preserve">
          <source>Prevent tests from printing messages through the console.</source>
          <target state="translated">Предотвратите печать сообщений через консоль.</target>
        </trans-unit>
        <trans-unit id="0507f30be4f8c196c99ce7be2cba62397164f331" translate="yes" xml:space="preserve">
          <source>Prevents Jest from executing more than the specified amount of tests at the same time. Only affects tests that use &lt;code&gt;test.concurrent&lt;/code&gt;.</source>
          <target state="translated">Предотвращает выполнение Jest большего количества тестов одновременно. Влияет только на тесты, использующие &lt;code&gt;test.concurrent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7719ba43ff57b175fbd95f647e624ca1e3e38f9d" translate="yes" xml:space="preserve">
          <source>Print debugging info about your Jest config.</source>
          <target state="translated">Распечатайте отладочную информацию о конфигурации Jest.</target>
        </trans-unit>
        <trans-unit id="169d23ffa6beb8bf0a8b932fddc3a716b615997f" translate="yes" xml:space="preserve">
          <source>Print your Jest config and then exits.</source>
          <target state="translated">Распечатайте конфигурацию Jest,а затем выйдите из нее.</target>
        </trans-unit>
        <trans-unit id="a45ae5d1d90ee0d31bb43f56d9dee1beb6b5a14a" translate="yes" xml:space="preserve">
          <source>Prints the test results in JSON. This mode will send all other test output and user messages to stderr.</source>
          <target state="translated">Печатает результаты теста в JSON.В этом режиме все остальные результаты теста и пользовательские сообщения будут отправлены в stderr.</target>
        </trans-unit>
        <trans-unit id="b1d472e424c03ff52490d1edc8a0e23f95babb92" translate="yes" xml:space="preserve">
          <source>Promises</source>
          <target state="translated">Promises</target>
        </trans-unit>
        <trans-unit id="d3f60bcc6f5c4f59593f0501aca5c6e1a0e647d3" translate="yes" xml:space="preserve">
          <source>Property Matchers</source>
          <target state="translated">Имущественные матчи</target>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="b305ac456a0fe1de47f68c0f2dcb4be5edf55137" translate="yes" xml:space="preserve">
          <source>React 16 triggers these warnings due to how it checks element types, and the mocked module fails these checks. Your options are:</source>
          <target state="translated">Реакция 16 запускает эти предупреждения из-за того,как он проверяет типы элементов,и высмеянный модуль не справляется с этими проверками.Ваши варианты таковы:</target>
        </trans-unit>
        <trans-unit id="695d1116170755340f94ec3beb1f24f668859e58" translate="yes" xml:space="preserve">
          <source>Recommended config names:</source>
          <target state="translated">Рекомендуемые имена конфигураций:</target>
        </trans-unit>
        <trans-unit id="1a5dd83d686967dbee491e598c66e203e42c8bea" translate="yes" xml:space="preserve">
          <source>Redux</source>
          <target state="translated">Redux</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="84641ce3545468aef6d9992e246ecc28023bd7fa" translate="yes" xml:space="preserve">
          <source>Removes any pending timers from the timer system.</source>
          <target state="translated">Удаляет все отложенные таймеры из системы таймеров.</target>
        </trans-unit>
        <trans-unit id="571be88936b979291213a8fc1300d3eb34583940" translate="yes" xml:space="preserve">
          <source>Render as a custom element. DOM &quot;custom elements&quot; aren't checked for anything and shouldn't fire warnings. They are lowercase and have a dash in the name.</source>
          <target state="translated">Рендер как пользовательский элемент.DOM &quot;пользовательские элементы&quot; ни на что не проверяются и не должны выдавать предупреждения.Они строчные и имеют тире в названии.</target>
        </trans-unit>
        <trans-unit id="456b6bb3ce6f2e6632c5f1e8d9ca1d06e7f178b9" translate="yes" xml:space="preserve">
          <source>Render as text. This way you won't see the props passed to the mock component in the snapshot, but it's straightforward:</source>
          <target state="translated">Отправьте сообщение.Таким образом,вы не увидите,что реквизит передается на инсценированный компонент на снимке,но это просто:</target>
        </trans-unit>
        <trans-unit id="1e70132872e75d10f3ccbb11c8b73d9f202669fd" translate="yes" xml:space="preserve">
          <source>Rendered snapshot:</source>
          <target state="translated">Снимок на память:</target>
        </trans-unit>
        <trans-unit id="3cd1c22168650ecd82a31a115bed21a42399c269" translate="yes" xml:space="preserve">
          <source>Repeating Setup For Many Tests</source>
          <target state="translated">Повторная настройка для многих тестов</target>
        </trans-unit>
        <trans-unit id="5add9c1dfb47ec8100a0659f89d63ed952ac6c86" translate="yes" xml:space="preserve">
          <source>Replacing the mock using &lt;a href=&quot;mock-function-api#mockfnmockimplementationfn&quot;&gt;&lt;code&gt;mockImplementation()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mock-function-api#mockfnmockimplementationoncefn&quot;&gt;&lt;code&gt;mockImplementationOnce()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Замена макета с помощью &lt;a href=&quot;mock-function-api#mockfnmockimplementationfn&quot;&gt; &lt;code&gt;mockImplementation()&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;mock-function-api#mockfnmockimplementationoncefn&quot;&gt; &lt;code&gt;mockImplementationOnce()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19baff0fd9598875b3df0c02954246d178653887" translate="yes" xml:space="preserve">
          <source>Resets all information stored in the &lt;a href=&quot;#mockfnmockcalls&quot;&gt;&lt;code&gt;mockFn.mock.calls&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#mockfnmockinstances&quot;&gt;&lt;code&gt;mockFn.mock.instances&lt;/code&gt;&lt;/a&gt; arrays.</source>
          <target state="translated">Сбрасывает всю информацию, хранящуюся в &lt;a href=&quot;#mockfnmockcalls&quot;&gt; &lt;code&gt;mockFn.mock.calls&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#mockfnmockinstances&quot;&gt; &lt;code&gt;mockFn.mock.instances&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c4baf164f97d04496389992c7c5da13fbb245ae" translate="yes" xml:space="preserve">
          <source>Resets the module registry - the cache of all required modules. This is useful to isolate modules where local state might conflict between tests.</source>
          <target state="translated">Сбрасывает реестр модулей-кэш всех необходимых модулей.Это полезно для изоляции модулей,где локальное состояние может конфликтовать между тестами.</target>
        </trans-unit>
        <trans-unit id="4ee7cc0bddf7c5a4ef8549ea7c38c8d601b2255d" translate="yes" xml:space="preserve">
          <source>Resets the state of all mocks. Equivalent to calling &lt;a href=&quot;mock-function-api#mockfnmockreset&quot;&gt;&lt;code&gt;.mockReset()&lt;/code&gt;&lt;/a&gt; on every mocked function.</source>
          <target state="translated">Сбрасывает состояние всех моков. Эквивалентно вызову &lt;a href=&quot;mock-function-api#mockfnmockreset&quot;&gt; &lt;code&gt;.mockReset()&lt;/code&gt; &lt;/a&gt; для каждой имитируемой функции.</target>
        </trans-unit>
        <trans-unit id="46554c07d0e0360541685d38d9047e14f0a0601e" translate="yes" xml:space="preserve">
          <source>Respect Browserify's &lt;a href=&quot;https://github.com/substack/browserify-handbook#browser-field&quot;&gt;&lt;code&gt;&quot;browser&quot;&lt;/code&gt; field&lt;/a&gt; in &lt;code&gt;package.json&lt;/code&gt; when resolving modules. Some modules export different versions based on whether they are operating in Node or a browser.</source>
          <target state="translated">Уважайте Browserify в &lt;a href=&quot;https://github.com/substack/browserify-handbook#browser-field&quot;&gt; &lt;code&gt;&quot;browser&quot;&lt;/code&gt; поле&lt;/a&gt; в &lt;code&gt;package.json&lt;/code&gt; при решении модулей. Некоторые модули экспортируют разные версии в зависимости от того, работают ли они в Node или в браузере.</target>
        </trans-unit>
        <trans-unit id="27aceef5796ab8d68aed06c602f37330d5a900d4" translate="yes" xml:space="preserve">
          <source>Restores all mocks back to their original value. Equivalent to calling &lt;a href=&quot;mock-function-api#mockfnmockrestore&quot;&gt;&lt;code&gt;.mockRestore()&lt;/code&gt;&lt;/a&gt; on every mocked function. Beware that &lt;code&gt;jest.restoreAllMocks()&lt;/code&gt; only works when the mock was created with &lt;code&gt;jest.spyOn&lt;/code&gt;; other mocks will require you to manually restore them.</source>
          <target state="translated">Восстанавливает все моки до их первоначального значения. Эквивалентно вызову &lt;a href=&quot;mock-function-api#mockfnmockrestore&quot;&gt; &lt;code&gt;.mockRestore()&lt;/code&gt; &lt;/a&gt; для каждой имитируемой функции. Помните, что &lt;code&gt;jest.restoreAllMocks()&lt;/code&gt; работает только тогда, когда макет был создан с помощью &lt;code&gt;jest.spyOn&lt;/code&gt; ; другие макеты потребуют от вас восстановления вручную.</target>
        </trans-unit>
        <trans-unit id="8ddb9b055cad613e29453fa554de9f36c7d6c8dd" translate="yes" xml:space="preserve">
          <source>Retry with &lt;a href=&quot;cli#--cache&quot;&gt;&lt;code&gt;--no-cache&lt;/code&gt;&lt;/a&gt;. Jest caches transformed module files to speed up test execution. If you are using your own custom transformer, consider adding a &lt;code&gt;getCacheKey&lt;/code&gt; function to it: &lt;a href=&quot;https://github.com/facebook/relay/blob/58cf36c73769690f0bbf90562707eadb062b029d/scripts/jest/preprocessor.js#L56-L61&quot;&gt;getCacheKey in Relay&lt;/a&gt;.</source>
          <target state="translated">Повторите попытку с &lt;a href=&quot;cli#--cache&quot;&gt; &lt;code&gt;--no-cache&lt;/code&gt; &lt;/a&gt; . Jest кэширует преобразованные файлы модулей для ускорения выполнения теста. Если вы используете свой собственный преобразователь, рассмотрите возможность добавления к &lt;code&gt;getCacheKey&lt;/code&gt; функции &lt;a href=&quot;https://github.com/facebook/relay/blob/58cf36c73769690f0bbf90562707eadb062b029d/scripts/jest/preprocessor.js#L56-L61&quot;&gt;getCacheKey&lt;/a&gt; : getCacheKey в Relay .</target>
        </trans-unit>
        <trans-unit id="156ec26504d2692465a0d8ff00489f7b36d9fa41" translate="yes" xml:space="preserve">
          <source>Returns a boolean (or &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; for handling asynchronous operations) to specify if a test should be run or not.</source>
          <target state="translated">Возвращает логическое значение (или &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; для обработки асинхронных операций), чтобы указать, следует ли запускать тест или нет.</target>
        </trans-unit>
        <trans-unit id="5d66ba4a66cb6cf526e2e08e5bcc4265e970107d" translate="yes" xml:space="preserve">
          <source>Returns a mock module instead of the actual module, bypassing all checks on whether the module should be required normally or not.</source>
          <target state="translated">Возвращает макет модуля вместо фактического модуля,обходя все проверки на то,должен ли модуль быть нужен нормально или нет.</target>
        </trans-unit>
        <trans-unit id="9da978b2f0e20c11e4aa75b10631e43a25e02ab4" translate="yes" xml:space="preserve">
          <source>Returns a new, unused &lt;a href=&quot;mock-function-api&quot;&gt;mock function&lt;/a&gt;. Optionally takes a mock implementation.</source>
          <target state="translated">Возвращает новую неиспользуемую &lt;a href=&quot;mock-function-api&quot;&gt;фиктивную функцию&lt;/a&gt; . При желании можно использовать фиктивную реализацию.</target>
        </trans-unit>
        <trans-unit id="a1acf18173b267510a46851d55a523216adab36c" translate="yes" xml:space="preserve">
          <source>Returns the &lt;code&gt;jest&lt;/code&gt; object for chaining.</source>
          <target state="translated">Возвращает объект- &lt;code&gt;jest&lt;/code&gt; для связывания.</target>
        </trans-unit>
        <trans-unit id="d08519e49635fb031179ab7f05284949daef9383" translate="yes" xml:space="preserve">
          <source>Returns the actual module instead of a mock, bypassing all checks on whether the module should receive a mock implementation or not.</source>
          <target state="translated">Возвращает фактический модуль вместо имитации,минуя все проверки на то,должен ли модуль получить имитационную реализацию или нет.</target>
        </trans-unit>
        <trans-unit id="2add96bbc9e9900cf433a5f2ebe6d67cb4660cf1" translate="yes" xml:space="preserve">
          <source>Returns the mock name string set by calling &lt;code&gt;mockFn.mockName(value)&lt;/code&gt;.</source>
          <target state="translated">Возвращает строку псевдонима, установленную вызовом &lt;code&gt;mockFn.mockName(value)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd9336539157509732381e95d2e9b2f4ceef9877" translate="yes" xml:space="preserve">
          <source>Returns the number of fake timers still left to run.</source>
          <target state="translated">Возвращает количество поддельных таймеров,которые еще осталось запустить.</target>
        </trans-unit>
        <trans-unit id="b1b392607deaf29a7e81453e069b7c07a32a6b18" translate="yes" xml:space="preserve">
          <source>Run</source>
          <target state="translated">Run</target>
        </trans-unit>
        <trans-unit id="641d1b198a65bb1bd4728078175e361d73f060b6" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;yarn test&lt;/code&gt; to run tests with Jest.</source>
          <target state="translated">Запустите &lt;code&gt;yarn test&lt;/code&gt; чтобы запустить тесты с Jest.</target>
        </trans-unit>
        <trans-unit id="7306d688c7598b3d294777df07da99e3d93d653c" translate="yes" xml:space="preserve">
          <source>Run All Timers</source>
          <target state="translated">Бегите все таймеры</target>
        </trans-unit>
        <trans-unit id="30ad8b68bab570303d35cefd0d73cf6056dbfc2d" translate="yes" xml:space="preserve">
          <source>Run Pending Timers</source>
          <target state="translated">Запускайте отложенные таймеры</target>
        </trans-unit>
        <trans-unit id="c89b3947b20f77096b75ca74d8fccf7526f1872b" translate="yes" xml:space="preserve">
          <source>Run all tests (default):</source>
          <target state="translated">Запустите все тесты (по умолчанию):</target>
        </trans-unit>
        <trans-unit id="02b363bdd7980fccab5552af0568d148195655d4" translate="yes" xml:space="preserve">
          <source>Run all tests affected by file changes in the last commit made. Behaves similarly to &lt;code&gt;--onlyChanged&lt;/code&gt;.</source>
          <target state="translated">Запустите все тесты, на которые повлияли изменения файлов в последней сделанной фиксации. Действует аналогично &lt;code&gt;--onlyChanged&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52304e948d18e9a280f733e321f8b5e058bbed9d" translate="yes" xml:space="preserve">
          <source>Run only the tests of the specified projects. Jest uses the attribute &lt;code&gt;displayName&lt;/code&gt; in the configuration to identify each project. If you use this option, you should provide a &lt;code&gt;displayName&lt;/code&gt; to all your projects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbcaa420e9fe3c70be68c6d8ee7d82ab5720e907" translate="yes" xml:space="preserve">
          <source>Run only the tests that were specified with a pattern or filename:</source>
          <target state="translated">Запускайте только те те тесты,которые были указаны с шаблоном или именем файла:</target>
        </trans-unit>
        <trans-unit id="92d791c05598e8218af4368bc378173046cea720" translate="yes" xml:space="preserve">
          <source>Run only the tests that were specified with their exact paths.</source>
          <target state="translated">Выполняйте только те те тесты,которые были указаны с их точными путями.</target>
        </trans-unit>
        <trans-unit id="23686a3a58e4a1259f35510a9d0252c4f6745f24" translate="yes" xml:space="preserve">
          <source>Run tests from one or more projects, found in the specified paths; also takes path globs. This option is the CLI equivalent of the &lt;a href=&quot;configuration#projects-arraystring--projectconfig&quot;&gt;&lt;code&gt;projects&lt;/code&gt;&lt;/a&gt; configuration option. Note that if configuration files are found in the specified paths, &lt;em&gt;all&lt;/em&gt; projects specified within those configuration files will be run.</source>
          <target state="translated">Запускать тесты из одного или нескольких проектов, найденных по указанным путям; также принимает шары пути. Этот параметр является эквивалентом параметра конфигурации &lt;a href=&quot;configuration#projects-arraystring--projectconfig&quot;&gt; &lt;code&gt;projects&lt;/code&gt; &lt;/a&gt; в интерфейсе командной строки . Обратите внимание: если файлы конфигурации находятся по указанным путям, &lt;em&gt;все&lt;/em&gt; проекты, указанные в этих файлах конфигурации, будут запущены.</target>
        </trans-unit>
        <trans-unit id="f9ddd0d105f6204c8e90c3adf874ea7bc2b26987" translate="yes" xml:space="preserve">
          <source>Run tests related to &lt;code&gt;path/to/fileA.js&lt;/code&gt; and &lt;code&gt;path/to/fileB.js&lt;/code&gt;:</source>
          <target state="translated">Запустите тесты, связанные с &lt;code&gt;path/to/fileA.js&lt;/code&gt; и &lt;code&gt;path/to/fileB.js&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2de5d0d69fc805a58b350e937e2690429d2970e2" translate="yes" xml:space="preserve">
          <source>Run tests related to changed files based on hg/git (uncommitted files):</source>
          <target state="translated">Запустите тесты,связанные с измененными файлами на основе hg/git (нефиксированные файлы):</target>
        </trans-unit>
        <trans-unit id="a44ae954d1ab8ef98e8adfe8b4785726ef8e4670" translate="yes" xml:space="preserve">
          <source>Run tests that match this spec name (match against the name in &lt;code&gt;describe&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt;, basically).</source>
          <target state="translated">Запустите тесты, которые соответствуют этому имени спецификации (в основном, сопоставить с именем в &lt;code&gt;describe&lt;/code&gt; или &lt;code&gt;test&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3250ade6678b3bc2a1ae0933ebec438d66c4c65a" translate="yes" xml:space="preserve">
          <source>Run tests with specified reporters. &lt;a href=&quot;configuration#reporters-arraymodulename--modulename-options&quot;&gt;Reporter options&lt;/a&gt; are not available via CLI. Example with multiple reporters:</source>
          <target state="translated">Запускайте тесты с указанными репортерами. &lt;a href=&quot;configuration#reporters-arraymodulename--modulename-options&quot;&gt;Параметры репортера&lt;/a&gt; недоступны через интерфейс командной строки. Пример с несколькими репортерами:</target>
        </trans-unit>
        <trans-unit id="1e9d71147bb217981f158928624c5b13a6be2ead" translate="yes" xml:space="preserve">
          <source>Run watch mode:</source>
          <target state="translated">Запустите режим наблюдения:</target>
        </trans-unit>
        <trans-unit id="6317e775f03f11757290b5bce78a11c48721ccd6" translate="yes" xml:space="preserve">
          <source>Running from command line</source>
          <target state="translated">Запуск из командной строки</target>
        </trans-unit>
        <trans-unit id="3d642ff91fd7ebdca37f4b2895153e438af4b378" translate="yes" xml:space="preserve">
          <source>Running from the command line</source>
          <target state="translated">Запуск из командной строки</target>
        </trans-unit>
        <trans-unit id="437a88c377620b15b1bd26b6489ffe7cf9e58772" translate="yes" xml:space="preserve">
          <source>Runs a function after all the tests in this file have completed. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.</source>
          <target state="translated">Запускает функцию после завершения всех тестов в этом файле.Если функция возвращает обещание или является генератором,Jest ждет решения этого обещания,прежде чем продолжить.</target>
        </trans-unit>
        <trans-unit id="50450676d930383c48d2ec3efefa163347c39da6" translate="yes" xml:space="preserve">
          <source>Runs a function after each one of the tests in this file completes. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.</source>
          <target state="translated">Запускает функцию после завершения каждого из тестов в этом файле.Если функция возвращает обещание или является генератором,Jest ждет решения этого обещания,прежде чем продолжить.</target>
        </trans-unit>
        <trans-unit id="44b753442cff11f6ed337230a6a654b466728c0d" translate="yes" xml:space="preserve">
          <source>Runs a function before any of the tests in this file run. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running tests.</source>
          <target state="translated">Запускает функцию перед запуском любого из тестов в этом файле.Если функция возвращает обещание или является генератором,то перед запуском тестов Jest ждет решения этого обещания.</target>
        </trans-unit>
        <trans-unit id="57284652d7931aab5ea782fa00d26cf2b4c59502" translate="yes" xml:space="preserve">
          <source>Runs a function before each of the tests in this file runs. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running the test.</source>
          <target state="translated">Запускает функцию перед запуском каждого из тестов в этом файле.Если функция возвращает обещание или является генератором,то перед запуском теста Jest ждет решения этого обещания.</target>
        </trans-unit>
        <trans-unit id="8886a35ac5b619bcc55c828058cdaa29e97376a1" translate="yes" xml:space="preserve">
          <source>Runs failed tests n-times until they pass or until the max number of retries is exhausted. This only works with &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt;jest-circus&lt;/a&gt;!</source>
          <target state="translated">Выполняет неудачные тесты n раз, пока они не пройдут или пока не будет исчерпано максимальное количество попыток. Это работает только с &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt;цирком-шуткой&lt;/a&gt; !</target>
        </trans-unit>
        <trans-unit id="b2614c8f6a2b7cb20f551e055799e18e1ea7d981" translate="yes" xml:space="preserve">
          <source>Runs tests related to the changes since the provided branch or commit hash. If the current branch has diverged from the given branch, then only changes made locally will be tested. Behaves similarly to &lt;code&gt;--onlyChanged&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2884236a5a7d1409f769ed84cceee98770e2aba" translate="yes" xml:space="preserve">
          <source>Runs tests related to the changes since the provided branch. If the current branch has diverged from the given branch, then only changes made locally will be tested. Behaves similarly to &lt;code&gt;--onlyChanged&lt;/code&gt;.</source>
          <target state="translated">Выполняет тесты, связанные с изменениями, произошедшими с предоставленной ветки. Если текущая ветвь отличается от данной ветки, то будут проверяться только локальные изменения. Действует аналогично &lt;code&gt;--onlyChanged&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdee9094809cabf1a25af1ca3211f475ddc04a54" translate="yes" xml:space="preserve">
          <source>Runs tests related to the current changes and the changes made in the last commit. Behaves similarly to &lt;code&gt;--onlyChanged&lt;/code&gt;.</source>
          <target state="translated">Запускает тесты, связанные с текущими изменениями и изменениями, внесенными в последний коммит. Действует аналогично &lt;code&gt;--onlyChanged&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea13653cdec671f745362f34fcd64c3406b64c75" translate="yes" xml:space="preserve">
          <source>Scoped modules can be mocked by creating a file in a directory structure that matches the name of the scoped module. For example, to mock a scoped module called &lt;code&gt;@scope/project-name&lt;/code&gt;, create a file at &lt;code&gt;__mocks__/@scope/project-name.js&lt;/code&gt;, creating the &lt;code&gt;@scope/&lt;/code&gt; directory accordingly.</source>
          <target state="translated">Модули с заданной областью можно смоделировать, создав файл в структуре каталогов, которая соответствует имени модуля с заданной областью. Например, чтобы смоделировать модуль с областью видимости с именем &lt;code&gt;@scope/project-name&lt;/code&gt; , создайте файл в &lt;code&gt;__mocks__/@scope/project-name.js&lt;/code&gt; , создав каталог &lt;code&gt;@scope/&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="cbc636498e1c269635cd060804fe4bc4c5cc9f77" translate="yes" xml:space="preserve">
          <source>Scoping</source>
          <target state="translated">Scoping</target>
        </trans-unit>
        <trans-unit id="211a5b2321ab26457503f06cb4dc7556791fc7d0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;configuration#snapshotserializers-arraystring&quot;&gt;configuring Jest&lt;/a&gt; for more information.</source>
          <target state="translated">См. Дополнительную информацию в разделе &amp;laquo; &lt;a href=&quot;configuration#snapshotserializers-arraystring&quot;&gt;Настройка Jest&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="efddd22422ff36c5396f782f1486c33090e561a7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB.html#createTable-property&quot;&gt;Create Table API&lt;/a&gt;</source>
          <target state="translated">См. Раздел &lt;a href=&quot;https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB.html#createTable-property&quot;&gt;Create Table API&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f34a9c66618a8a38e77218fa386d8ca82390118e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/shelfio/jest-dynamodb&quot;&gt;documentation&lt;/a&gt; for details.</source>
          <target state="translated">Подробности смотрите в &lt;a href=&quot;https://github.com/shelfio/jest-dynamodb&quot;&gt;документации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d0f8c5b32a609f4f0cc5792e1d82420240d67f10" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/shelfio/jest-mongodb&quot;&gt;documentation&lt;/a&gt; for details (configuring MongoDB version, etc).</source>
          <target state="translated">Подробности см. В &lt;a href=&quot;https://github.com/shelfio/jest-mongodb&quot;&gt;документации&lt;/a&gt; (настройка версии MongoDB и т. Д.).</target>
        </trans-unit>
        <trans-unit id="85e1678b6936236b6f910c2ee40e764fd5fd5efb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/smooth-code/jest-puppeteer&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">См. &lt;a href=&quot;https://github.com/smooth-code/jest-puppeteer&quot;&gt;Документацию&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac033bc12bf7544e09b943fc85a55ee0e0eb5bb2" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jestjs.io/help.html&quot;&gt;Help&lt;/a&gt;.</source>
          <target state="translated">См. &lt;a href=&quot;https://jestjs.io/help.html&quot;&gt;Справку&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4bd8f6623cb0bd7f5cbd56dab7f5f02bfe1b459a" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;automock&lt;/code&gt; section of &lt;a href=&quot;configuration#automock-boolean&quot;&gt;configuration&lt;/a&gt; for more information</source>
          <target state="translated">См &lt;code&gt;automock&lt;/code&gt; раздел &lt;a href=&quot;configuration#automock-boolean&quot;&gt;конфигурации&lt;/a&gt; для получения дополнительной информации</target>
        </trans-unit>
        <trans-unit id="b6f206289cb851ace292e1546d209054802eb0c9" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#testregex-string--arraystring&quot;&gt;&lt;code&gt;testRegex&lt;/code&gt; [string | array&amp;lt;string&amp;gt;]&lt;/a&gt;, but note that you cannot specify both options.</source>
          <target state="translated">См. Также &lt;a href=&quot;#testregex-string--arraystring&quot;&gt; &lt;code&gt;testRegex&lt;/code&gt; [строка | array &amp;lt;string&amp;gt;]&lt;/a&gt; , но учтите, что вы не можете указать обе опции.</target>
        </trans-unit>
        <trans-unit id="94efbf6a114ebb2635afd14dc7211a7f961c8a16" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;micromatch&lt;/a&gt; package for details of the patterns you can specify.</source>
          <target state="translated">Подробную информацию о шаблонах, которые вы можете указать, смотрите в пакете &lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;micromatch&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="532a50a063dc36d0a8534a18dcaf4a0125d0cb62" translate="yes" xml:space="preserve">
          <source>Set the current system time used by fake timers. Simulates a user changing the system clock while your program is running. It affects the current time but it does not in itself cause e.g. timers to fire; they will fire exactly as they would have done without the call to &lt;code&gt;jest.setSystemTime()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615ea98380b0e9ec8f2989a621cea9a7e764e463" translate="yes" xml:space="preserve">
          <source>Set the default timeout interval for tests and before/after hooks in milliseconds.</source>
          <target state="translated">Установите интервал по умолчанию для тестов и до/после крючков в миллисекундах.</target>
        </trans-unit>
        <trans-unit id="7ef9a41019d98dcd7087734f625109563be77315" translate="yes" xml:space="preserve">
          <source>Set the default timeout interval for tests and before/after hooks in milliseconds. This only affects the test file from which this function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2acda40898a579d06db8797d3cdaca2b2ddebd7e" translate="yes" xml:space="preserve">
          <source>Set to &lt;code&gt;'test'&lt;/code&gt; if it's not already set to something else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c094b57443ef1dac1663cfc0d2869275b9ac2e1" translate="yes" xml:space="preserve">
          <source>Sets the path to the &lt;a href=&quot;https://prettier.io/&quot;&gt;&lt;code&gt;prettier&lt;/code&gt;&lt;/a&gt; node module used to update inline snapshots.</source>
          <target state="translated">Устанавливает путь к модулю более &lt;a href=&quot;https://prettier.io/&quot;&gt; &lt;code&gt;prettier&lt;/code&gt; &lt;/a&gt; узла, используемому для обновления встроенных снимков.</target>
        </trans-unit>
        <trans-unit id="03632ef1c76d8a3790f3ba38329aa3105012b7ef" translate="yes" xml:space="preserve">
          <source>Setting this value to &lt;code&gt;fake&lt;/code&gt; allows the use of fake timers for functions such as &lt;code&gt;setTimeout&lt;/code&gt;. Fake timers are useful when a piece of code sets a long timeout that we don't want to wait for in a test.</source>
          <target state="translated">Установка этого значения на &lt;code&gt;fake&lt;/code&gt; позволяет использовать поддельные таймеры для таких функций, как &lt;code&gt;setTimeout&lt;/code&gt; . Поддельные таймеры полезны, когда фрагмент кода устанавливает длительный тайм-аут, которого мы не хотим ждать в тесте.</target>
        </trans-unit>
        <trans-unit id="ef5d59a2f86331bc4671ba4a54ae325b17ae045f" translate="yes" xml:space="preserve">
          <source>Setting this value to &lt;code&gt;legacy&lt;/code&gt; or &lt;code&gt;fake&lt;/code&gt; allows the use of fake timers for functions such as &lt;code&gt;setTimeout&lt;/code&gt;. Fake timers are useful when a piece of code sets a long timeout that we don't want to wait for in a test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="5f07ec3fe4ba8082e43fef02f2b4d5d1a2a1d466" translate="yes" xml:space="preserve">
          <source>Setup and Teardown</source>
          <target state="translated">Установка и Teardown</target>
        </trans-unit>
        <trans-unit id="24b1a600607b12b94694aa1cdc63d96c8b7a540d" translate="yes" xml:space="preserve">
          <source>Setup with Create React App</source>
          <target state="translated">Настройка с помощью Create React App</target>
        </trans-unit>
        <trans-unit id="9e9d9e60fd56a1f1ea8ea643530acaeb4d062997" translate="yes" xml:space="preserve">
          <source>Setup without Create React App</source>
          <target state="translated">Установка без создания реактивного приложения</target>
        </trans-unit>
        <trans-unit id="822b3a2435ec58cb5bc9376be9ad2eeac55edc92" translate="yes" xml:space="preserve">
          <source>Should snapshot files be committed?</source>
          <target state="translated">Должны ли быть сделаны снимки?</target>
        </trans-unit>
        <trans-unit id="492eafbaea4c259f43100935024f5e3a182f7170" translate="yes" xml:space="preserve">
          <source>Should your plugin attempt to overwrite a reserved key, Jest will error out with a descriptive message, something like:</source>
          <target state="translated">Если Ваш плагин попытается перезаписать зарезервированный ключ,Jest выдаст ошибку с описательным сообщением,что-то вроде того:</target>
        </trans-unit>
        <trans-unit id="bd51fd0dd8cd830d4a42fc531c55cdfccd2ac812" translate="yes" xml:space="preserve">
          <source>Show the help information, similar to this page.</source>
          <target state="translated">Покажите справочную информацию,аналогичную этой странице.</target>
        </trans-unit>
        <trans-unit id="fb22048fa6d1f11cbc46a0377600ca142853ad0a" translate="yes" xml:space="preserve">
          <source>Similarly webpack's &lt;code&gt;resolve.root&lt;/code&gt; option functions like setting the &lt;code&gt;NODE_PATH&lt;/code&gt; env variable, which you can set, or make use of the &lt;code&gt;modulePaths&lt;/code&gt; option.</source>
          <target state="translated">Точно так же параметр resolve.root в &lt;code&gt;resolve.root&lt;/code&gt; работает, как установка &lt;code&gt;NODE_PATH&lt;/code&gt; env NODE_PATH , которую вы можете установить, или использовать параметр &lt;code&gt;modulePaths&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7adebe990936d6de8e229a12d896004b38f87428" translate="yes" xml:space="preserve">
          <source>Similarly, webpack's &lt;code&gt;resolve.root&lt;/code&gt; option functions like setting the &lt;code&gt;NODE_PATH&lt;/code&gt; env variable, which you can set, or make use of the &lt;code&gt;modulePaths&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b6800d4211e291c95387e4b2e79446e622a4f0" translate="yes" xml:space="preserve">
          <source>Since Jest 22.1.0+, the &lt;code&gt;jest.spyOn&lt;/code&gt; method takes an optional third argument of &lt;code&gt;accessType&lt;/code&gt; that can be either &lt;code&gt;'get'&lt;/code&gt; or &lt;code&gt;'set'&lt;/code&gt;, which proves to be useful when you want to spy on a getter or a setter, respectively.</source>
          <target state="translated">Начиная с Jest 22.1.0+, метод &lt;code&gt;jest.spyOn&lt;/code&gt; принимает необязательный третий аргумент &lt;code&gt;accessType&lt;/code&gt; , который может быть либо &lt;code&gt;'get'&lt;/code&gt; , либо &lt;code&gt;'set'&lt;/code&gt; , что оказывается полезным, когда вы хотите шпионить за геттером или сеттером соответственно.</target>
        </trans-unit>
        <trans-unit id="4f8bae34a73e1f4213cb283f5a11b822ba4dc217" translate="yes" xml:space="preserve">
          <source>Since the later describes exactly what's expected in the output, it's more clear to see when it's wrong:</source>
          <target state="translated">Поскольку в последнем описано,что именно ожидается на выходе,более понятно,когда это неправильно:</target>
        </trans-unit>
        <trans-unit id="b9678530810438e60dd8aa3f6aa12c28ea2f3f1c" translate="yes" xml:space="preserve">
          <source>Since we just updated our component to point to a different address, it's reasonable to expect changes in the snapshot for this component. Our snapshot test case is failing because the snapshot for our updated component no longer matches the snapshot artifact for this test case.</source>
          <target state="translated">Так как мы только что обновили наш компонент,чтобы указать на другой адрес,разумно ожидать изменений в снимке для этого компонента.Наш тест снимка не работает,потому что снимки для нашего обновленного компонента больше не совпадают с артефактом снимка для данного тестового случая.</target>
        </trans-unit>
        <trans-unit id="540cf57482add7abae948ebe3f5722e703011e20" translate="yes" xml:space="preserve">
          <source>Since we'd like our tests to avoid actually hitting the disk (that's pretty slow and fragile), we create a manual mock for the &lt;code&gt;fs&lt;/code&gt; module by extending an automatic mock. Our manual mock will implement custom versions of the &lt;code&gt;fs&lt;/code&gt; APIs that we can build on for our tests:</source>
          <target state="translated">Поскольку мы хотим, чтобы наши тесты не касались диска (это довольно медленно и хрупко), мы создаем ручной макет для модуля &lt;code&gt;fs&lt;/code&gt; , расширяя автоматический макет. Наш ручной макет реализует пользовательские версии API-интерфейсов &lt;code&gt;fs&lt;/code&gt; , которые мы можем использовать для наших тестов:</target>
        </trans-unit>
        <trans-unit id="66842e9da141137fe7352a0a53d93d8d95043a5c" translate="yes" xml:space="preserve">
          <source>Snapshot Test</source>
          <target state="translated">Моментальный тест</target>
        </trans-unit>
        <trans-unit id="cdf5126870db570bc7f1db0845f8a4e0d4d3ae76" translate="yes" xml:space="preserve">
          <source>Snapshot Testing</source>
          <target state="translated">Тестирование снимков</target>
        </trans-unit>
        <trans-unit id="89df76fc07cdab1a593d1520d1e485a89eaa0758" translate="yes" xml:space="preserve">
          <source>Snapshot Testing with Jest</source>
          <target state="translated">Тестирование снимков с помощью шута</target>
        </trans-unit>
        <trans-unit id="133546ab2de371a152f49c68a57605cf66823f74" translate="yes" xml:space="preserve">
          <source>Snapshot Testing with Mocks, Enzyme and React 16</source>
          <target state="translated">Тестирование снимков с помощью насмешек,фермента и реакции 16.</target>
        </trans-unit>
        <trans-unit id="5a16d1671f06c1b79f4ca90da446bf86ec30018f" translate="yes" xml:space="preserve">
          <source>Snapshot files must always represent the current state of the modules they are covering. Therefore, if you are merging two branches and encounter a conflict in the snapshot files, you can either resolve the conflict manually or update the snapshot file by running Jest and inspecting the result.</source>
          <target state="translated">Файлы снимков всегда должны представлять текущее состояние модулей,которые они покрывают.Поэтому,если вы сливаете две ветки и сталкиваетесь с конфликтом в файлах снимков,вы можете либо разрешить конфликт вручную,либо обновить файл снимка,запустив Jest и проверив результат.</target>
        </trans-unit>
        <trans-unit id="e2f67f68de52f1c63bdae4635f588faaa8a269e7" translate="yes" xml:space="preserve">
          <source>Snapshot testing and visual regression testing are two distinct ways of testing UIs, and they serve different purposes. Visual regression testing tools take screenshots of web pages and compare the resulting images pixel by pixel. With Snapshot testing values are serialized, stored within text files, and compared using a diff algorithm. There are different trade-offs to consider and we listed the reasons why snapshot testing was built in the &lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html#why-snapshot-testing&quot;&gt;Jest blog&lt;/a&gt;.</source>
          <target state="translated">Моментальное тестирование и визуальное регрессионное тестирование - это два разных способа тестирования пользовательского интерфейса, которые служат разным целям. Инструменты визуального регрессионного тестирования делают скриншоты веб-страниц и сравнивают полученные изображения попиксельно. При тестировании снимков значения сериализуются, сохраняются в текстовых файлах и сравниваются с использованием алгоритма сравнения. Необходимо учитывать различные компромиссы, и мы перечислили причины, по которым тестирование снимков было построено в &lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html#why-snapshot-testing&quot;&gt;блоге Jest&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="67c5ace60d5fc8adf8135b3fa0469ad4f55990c3" translate="yes" xml:space="preserve">
          <source>Snapshot testing is only one of more than 20 assertions that ship with Jest. The aim of snapshot testing is not to replace existing unit tests, but to provide additional value and make testing painless. In some scenarios, snapshot testing can potentially remove the need for unit testing for a particular set of functionalities (e.g. React components), but they can work together as well.</source>
          <target state="translated">Тестирование снимков-это только одно из более чем 20 утверждений,что корабль со шутом.Целью тестирования снимков является не замена существующих модульных тестов,а обеспечение дополнительной ценности и безболезненность тестирования.В некоторых сценариях,мгновенное тестирование потенциально может устранить необходимость в юнит-тестировании для определенного набора функций (например,реакция компонентов),но они также могут работать вместе.</target>
        </trans-unit>
        <trans-unit id="d78cced32db30f3bf1c92f37bcc6a46c7cbbb0b3" translate="yes" xml:space="preserve">
          <source>Snapshot tests are a very useful tool whenever you want to make sure your UI does not change unexpectedly.</source>
          <target state="translated">Моментальные тесты-очень полезный инструмент,когда вы хотите убедиться,что ваш пользовательский интерфейс не изменится внезапно.</target>
        </trans-unit>
        <trans-unit id="46a65a578f3ba45c38c2f4b67393d191767bfc07" translate="yes" xml:space="preserve">
          <source>Snapshots are a fantastic tool for identifying unexpected interface changes within your application &amp;ndash; whether that interface is an API response, UI, logs, or error messages. As with any testing strategy, there are some best-practices you should be aware of, and guidelines you should follow, in order to use them effectively.</source>
          <target state="translated">Моментальные снимки - отличный инструмент для выявления неожиданных изменений интерфейса в вашем приложении, будь то ответ API, пользовательский интерфейс, журналы или сообщения об ошибках. Как и в случае с любой стратегией тестирования, есть некоторые передовые методы, о которых вам следует знать, и рекомендации, которым вы должны следовать, чтобы использовать их эффективно.</target>
        </trans-unit>
        <trans-unit id="c478e2f51e8e2add8d79e6f37e7ed46eb64562f2" translate="yes" xml:space="preserve">
          <source>Sometimes it happens (especially in React Native or TypeScript projects) that 3rd party modules are published as untranspiled. Since all files inside &lt;code&gt;node_modules&lt;/code&gt; are not transformed by default, Jest will not understand the code in these modules, resulting in syntax errors. To overcome this, you may use &lt;code&gt;transformIgnorePatterns&lt;/code&gt; to allow transpiling such modules. You'll find a good example of this use case in &lt;a href=&quot;tutorial-react-native#transformignorepatterns-customization&quot;&gt;React Native Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f682ce988a8d01605c894c6eb3963ca0cc76e8b" translate="yes" xml:space="preserve">
          <source>Sometimes it happens (especially in React Native or TypeScript projects) that 3rd party modules are published as untranspiled. Since all files inside &lt;code&gt;node_modules&lt;/code&gt; are not transformed by default, Jest will not understand the code in these modules, resulting in syntax errors. To overcome this, you may use &lt;code&gt;transformIgnorePatterns&lt;/code&gt; to whitelist such modules. You'll find a good example of this use case in &lt;a href=&quot;tutorial-react-native#transformignorepatterns-customization&quot;&gt;React Native Guide&lt;/a&gt;.</source>
          <target state="translated">Иногда бывает (особенно в проектах React Native или TypeScript), что сторонние модули публикуются как нетранспортированные. Поскольку все файлы внутри &lt;code&gt;node_modules&lt;/code&gt; по умолчанию не преобразуются, Jest не понимает код в этих модулях, что приводит к синтаксическим ошибкам. Чтобы преодолеть это, вы можете использовать &lt;code&gt;transformIgnorePatterns&lt;/code&gt; для внесения таких модулей в белый список. Вы найдете хороший пример этого &lt;a href=&quot;tutorial-react-native#transformignorepatterns-customization&quot;&gt;варианта&lt;/a&gt; использования в React Native Guide .</target>
        </trans-unit>
        <trans-unit id="e2b30ccb8fda73d533a0e969bafd118c24c88742" translate="yes" xml:space="preserve">
          <source>Sometimes you need to provide a more complex manual mock. For example if you'd like to forward the prop types or static fields of a native component to a mock, you can return a different React component from a mock through this helper from jest-react-native:</source>
          <target state="translated">Иногда нужно предоставить более сложную ручную насмешку.Например,если вы хотите переслать типы реквизитов или статические поля родного компонента в имитацию,вы можете вернуть другой компонент React из имитации через этот помощник от jest-react-native:</target>
        </trans-unit>
        <trans-unit id="695c0e7e9d729e27f87cadca0070a18d74fc0abb" translate="yes" xml:space="preserve">
          <source>Sort test path alphabetically.</source>
          <target state="translated">Сортируйте тестовый путь в алфавитном порядке.</target>
        </trans-unit>
        <trans-unit id="e68b54695ab9a614c999727da57981ffa8733914" translate="yes" xml:space="preserve">
          <source>Specifies notification mode. Requires &lt;code&gt;notify: true&lt;/code&gt;.</source>
          <target state="translated">Задает режим уведомления. Требуется &lt;code&gt;notify: true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3484b5172e046d75121af3f84a8f20757a6f1353" translate="yes" xml:space="preserve">
          <source>Specify preset in your Jest configuration:</source>
          <target state="translated">Укажите предустановку в конфигурации &quot;Шут&quot;:</target>
        </trans-unit>
        <trans-unit id="072147ce4032ecb883aadc972685fb5dc5cab93b" translate="yes" xml:space="preserve">
          <source>Spying on methods of our class</source>
          <target state="translated">Шпионить за методами нашего класса</target>
        </trans-unit>
        <trans-unit id="3e66bbc94f94d5c9febbf71967e8a53cc9c379f0" translate="yes" xml:space="preserve">
          <source>Spying on the constructor</source>
          <target state="translated">Шпионаж за конструктором</target>
        </trans-unit>
        <trans-unit id="024a38d0b03fcbf63acc93daff4e631c67675d3b" translate="yes" xml:space="preserve">
          <source>Starting from react-native version 0.38, a Jest setup is included by default when running &lt;code&gt;react-native init&lt;/code&gt;. The following configuration should be automatically added to your package.json file:</source>
          <target state="translated">Начиная с response-native версии 0.38, установка Jest включена по умолчанию при запуске &lt;code&gt;react-native init&lt;/code&gt; . Следующая конфигурация должна быть автоматически добавлена ​​в ваш файл package.json:</target>
        </trans-unit>
        <trans-unit id="1991c5175326e4c289d97fffe85eadf0791dd3bd" translate="yes" xml:space="preserve">
          <source>Static ES6 module imports are hoisted to the top of the file, so instead we have to import them dynamically using &lt;code&gt;import()&lt;/code&gt;.</source>
          <target state="translated">Статический импорт модуля ES6 поднимается в верхнюю часть файла, поэтому вместо этого мы должны импортировать их динамически, используя &lt;code&gt;import()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28f738d61989d25363252d6dd69c2b75719b7de9" translate="yes" xml:space="preserve">
          <source>Still unresolved?</source>
          <target state="translated">До сих пор не решены?</target>
        </trans-unit>
        <trans-unit id="6c6f5518d1fa80f650e491adb2e489a09a7f982c" translate="yes" xml:space="preserve">
          <source>Still, there are cases where it's useful to go beyond the ability to specify return values and full-on replace the implementation of a mock function. This can be done with &lt;code&gt;jest.fn&lt;/code&gt; or the &lt;code&gt;mockImplementationOnce&lt;/code&gt; method on mock functions.</source>
          <target state="translated">Тем не менее, есть случаи, когда полезно выйти за рамки возможности указывать возвращаемые значения и полностью заменить реализацию фиктивной функции. Это можно сделать с помощью &lt;code&gt;jest.fn&lt;/code&gt; или метода &lt;code&gt;mockImplementationOnce&lt;/code&gt; для имитационных функций.</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="bcc358b3aaafb093f4a2baf42f0160bfb2bfd061" translate="yes" xml:space="preserve">
          <source>Suppose we have a class that fetches users from our API. The class uses &lt;a href=&quot;https://github.com/axios/axios&quot;&gt;axios&lt;/a&gt; to call the API then returns the &lt;code&gt;data&lt;/code&gt; attribute which contains all the users:</source>
          <target state="translated">Предположим, у нас есть класс, который выбирает пользователей из нашего API. Класс использует &lt;a href=&quot;https://github.com/axios/axios&quot;&gt;axios&lt;/a&gt; для вызова API, а затем возвращает атрибут &lt;code&gt;data&lt;/code&gt; содержащий всех пользователей:</target>
        </trans-unit>
        <trans-unit id="3a4bc60f3a09d9eb5a73886f79212b0e558b15ec" translate="yes" xml:space="preserve">
          <source>Syntactic sugar function for:</source>
          <target state="translated">Синтаксическая функция сахара для:</target>
        </trans-unit>
        <trans-unit id="ae135cb4bf99d2d69cbac3f5fd417c5399be204b" translate="yes" xml:space="preserve">
          <source>Test environment options that will be passed to the &lt;code&gt;testEnvironment&lt;/code&gt;. The relevant options depend on the environment. For example you can override options given to &lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom&lt;/a&gt; such as &lt;code&gt;{userAgent: &quot;Agent/007&quot;}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;testEnvironment&lt;/code&gt; тестовой среды, которые будут переданы в testEnvironment . Соответствующие варианты зависят от окружающей среды. Например, вы можете переопределить параметры, данные &lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom,&lt;/a&gt; такие как &lt;code&gt;{userAgent: &quot;Agent/007&quot;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c29c26bd3478b20af1cf0e7c6178529d8355ed9c" translate="yes" xml:space="preserve">
          <source>Test environment options that will be passed to the &lt;code&gt;testEnvironment&lt;/code&gt;. The relevant options depend on the environment. For example, you can override options given to &lt;a href=&quot;https://github.com/jsdom/jsdom&quot;&gt;jsdom&lt;/a&gt; such as &lt;code&gt;{userAgent: &quot;Agent/007&quot;}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55666a28ff3618a6bc88a5a3086460692f20399" translate="yes" xml:space="preserve">
          <source>Test files are normally ignored from collecting code coverage. With this option, you can overwrite this behavior and include otherwise ignored files in code coverage.</source>
          <target state="translated">Тестовые файлы обычно игнорируются при сборе покрытия кода.С помощью этой опции Вы можете перезаписать такое поведение и включить в покрытие кода игнорируемые файлы.</target>
        </trans-unit>
        <trans-unit id="32a2b6bfc1cb248afcfe7c96a42e9a946326cac4" translate="yes" xml:space="preserve">
          <source>Test files run inside a &lt;a href=&quot;https://nodejs.org/api/vm.html&quot;&gt;vm&lt;/a&gt;, which slows calls to global context properties (e.g. &lt;code&gt;Math&lt;/code&gt;). With this option you can specify extra properties to be defined inside the vm for faster lookups.</source>
          <target state="translated">Тестовые файлы запускаются внутри &lt;a href=&quot;https://nodejs.org/api/vm.html&quot;&gt;виртуальной машины&lt;/a&gt; , что замедляет вызовы глобальных свойств контекста (например, &lt;code&gt;Math&lt;/code&gt; ). С помощью этой опции вы можете указать дополнительные свойства, которые будут определены внутри виртуальной машины для более быстрого поиска.</target>
        </trans-unit>
        <trans-unit id="da102bd566881f332f6aa321d898e870666704cb" translate="yes" xml:space="preserve">
          <source>Testing Asynchronous Code</source>
          <target state="translated">Тестирование асинхронного кода</target>
        </trans-unit>
        <trans-unit id="b4b91ec445494c8e5c6d2ecedd86aa56ac5179b5" translate="yes" xml:space="preserve">
          <source>Testing React Apps</source>
          <target state="translated">Тестирование реактивных приложений</target>
        </trans-unit>
        <trans-unit id="5987105ad86879109c74631bcc686434d71992ae" translate="yes" xml:space="preserve">
          <source>Testing React Native Apps</source>
          <target state="translated">Тестирование реактивных аборигенных приложений</target>
        </trans-unit>
        <trans-unit id="225fc2b10e9a9ea9b701c17da2b76bad93c7b747" translate="yes" xml:space="preserve">
          <source>Testing Web Frameworks</source>
          <target state="translated">Тестирование веб-фреймворков</target>
        </trans-unit>
        <trans-unit id="b228c0a462e4fbc62499ce73feb2a8eb75c4bd39" translate="yes" xml:space="preserve">
          <source>Tests are Extremely Slow on Docker and/or Continuous Integration (CI) server.</source>
          <target state="translated">Тесты являются чрезвычайно медленными на сервере Docker и/или сервере непрерывной интеграции (CI).</target>
        </trans-unit>
        <trans-unit id="c2d1541959da20e20096a585a0538d9010954c98" translate="yes" xml:space="preserve">
          <source>Tests are Failing and You Don't Know Why</source>
          <target state="translated">Тесты провалились,и ты не знаешь,почему...</target>
        </trans-unit>
        <trans-unit id="3c8e525d4231c4190be70b1ad66cd616c6e2aa0f" translate="yes" xml:space="preserve">
          <source>Tests must be defined synchronously for Jest to be able to collect your tests.</source>
          <target state="translated">Тесты должны быть определены синхронно,чтобы Шут смог собрать ваши тесты.</target>
        </trans-unit>
        <trans-unit id="ba7f8377fd3129e903838676530e75e431a41733" translate="yes" xml:space="preserve">
          <source>That module can also contain a &lt;code&gt;getCacheKey&lt;/code&gt; function to generate a cache key to determine if the logic has changed and any cached artifacts relying on it should be discarded.</source>
          <target state="translated">Этот модуль также может содержать функцию &lt;code&gt;getCacheKey&lt;/code&gt; для генерации ключа кеша, чтобы определить, изменилась ли логика, и следует ли отбросить любые кешированные артефакты, на которые она основана.</target>
        </trans-unit>
        <trans-unit id="11a78e492a9e9e7ac361c24117bfb5e811bddb35" translate="yes" xml:space="preserve">
          <source>That's all there is to it! You can even update the snapshots with &lt;code&gt;--updateSnapshot&lt;/code&gt; or using the &lt;code&gt;u&lt;/code&gt; key in &lt;code&gt;--watch&lt;/code&gt; mode.</source>
          <target state="translated">Вот и все! Вы даже можете обновить снимки с помощью &lt;code&gt;--updateSnapshot&lt;/code&gt; или используя клавишу &lt;code&gt;u&lt;/code&gt; в режиме &lt;code&gt;--watch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa64459e4e03b6885bddfefb159ed4eb86b6825b" translate="yes" xml:space="preserve">
          <source>That's it! webpack is a complex and flexible tool, so you may have to make some adjustments to handle your specific application's needs. Luckily for most projects, Jest should be more than flexible enough to handle your webpack config.</source>
          <target state="translated">Вот и все! webpack-это сложный и гибкий инструмент,поэтому вам,возможно,придется внести некоторые коррективы,чтобы справиться с потребностями вашего конкретного приложения.К счастью для большинства проектов,Jest должен быть более чем достаточно гибким,чтобы справиться с конфигурацией вебпакета.</target>
        </trans-unit>
        <trans-unit id="7c3361ad0e93e6bc1e1c3de2667211b364b378cd" translate="yes" xml:space="preserve">
          <source>The 4 ways to create an ES6 class mock</source>
          <target state="translated">4 способа создать насмешку над классом ES6.</target>
        </trans-unit>
        <trans-unit id="95c25a4fa34143b1216d44b01d41f9f29688f727" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#clearmocks-boolean&quot;&gt;&lt;code&gt;clearMocks&lt;/code&gt;&lt;/a&gt; configuration option is available to clear mocks automatically between tests.</source>
          <target state="translated">&lt;a href=&quot;configuration#clearmocks-boolean&quot;&gt; &lt;code&gt;clearMocks&lt;/code&gt; &lt;/a&gt; вариант конфигурации доступен для очистки издевается автоматически между тестами.</target>
        </trans-unit>
        <trans-unit id="06c017e6536e5d9f6110e8d0080ca094a5e9ea11" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#modulenamemapper-objectstring-string&quot;&gt;&lt;code&gt;moduleNameMapper&lt;/code&gt;&lt;/a&gt; can be used to map a module path to a different module. By default the preset maps all images to an image stub module but if a module cannot be found this configuration option can help:</source>
          <target state="translated">&lt;a href=&quot;configuration#modulenamemapper-objectstring-string&quot;&gt; &lt;code&gt;moduleNameMapper&lt;/code&gt; &lt;/a&gt; может быть использован для отображения пути модуля к другому модулю. По умолчанию предустановка отображает все изображения в модуль-заглушку изображения, но если модуль не может быть найден, этот параметр конфигурации может помочь:</target>
        </trans-unit>
        <trans-unit id="f7bf3050b5718b4b2d1e33abd9a62cda9462e096" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#modulenamemapper-objectstring-string--arraystring&quot;&gt;&lt;code&gt;moduleNameMapper&lt;/code&gt;&lt;/a&gt; can be used to map a module path to a different module. By default the preset maps all images to an image stub module but if a module cannot be found this configuration option can help:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d9df38ccbce3dc2ed35e993bc8900c35030ec6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#restoremocks-boolean&quot;&gt;&lt;code&gt;restoreMocks&lt;/code&gt;&lt;/a&gt; configuration option is available to restore mocks automatically between tests.</source>
          <target state="translated">&lt;a href=&quot;configuration#restoremocks-boolean&quot;&gt; &lt;code&gt;restoreMocks&lt;/code&gt; &lt;/a&gt; параметр конфигурации доступен для восстановления издевается автоматически между тестами.</target>
        </trans-unit>
        <trans-unit id="de8e5c7bbe65466e0240efdae7e25dee3a9f754c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#transformignorepatterns-arraystring&quot;&gt;&lt;code&gt;transformIgnorePatterns&lt;/code&gt;&lt;/a&gt; option can be used to specify which files shall be transformed by Babel. Many react-native npm modules unfortunately don't pre-compile their source code before publishing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1fd9f27ef141c8e346e850781739fd26da2e8bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#transformignorepatterns-arraystring&quot;&gt;&lt;code&gt;transformIgnorePatterns&lt;/code&gt;&lt;/a&gt; option can be used to whitelist or blacklist files from being transformed with Babel. Many react-native npm modules unfortunately don't pre-compile their source code before publishing.</source>
          <target state="translated">Параметр &lt;a href=&quot;configuration#transformignorepatterns-arraystring&quot;&gt; &lt;code&gt;transformIgnorePatterns&lt;/code&gt; &lt;/a&gt; можно использовать для внесения файлов в белый или черный список, которые не должны быть преобразованы с помощью Babel. Многие модули npm, поддерживающие реакцию, к сожалению, не компилируют исходный код перед публикацией.</target>
        </trans-unit>
        <trans-unit id="5fcd870eb6449696a26dbe9a35105b1b3f0eb6a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;./src/api/very-important-module.js&lt;/code&gt; file has less than 100% coverage.</source>
          <target state="translated">&lt;code&gt;./src/api/very-important-module.js&lt;/code&gt; файл имеет покрытие менее 100%.</target>
        </trans-unit>
        <trans-unit id="a4b1bdae91ac8b4ba9e5526619539ee09ec8ff0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;./src/components&lt;/code&gt; directory has less than 40% branch or statement coverage.</source>
          <target state="translated">&lt;code&gt;./src/components&lt;/code&gt; каталог имеет менее 40% отрасли или заявление покрытия.</target>
        </trans-unit>
        <trans-unit id="afcc7bfb1a0f92aed03ab154b1ea46d01fb61f0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expect.assertions(2)&lt;/code&gt; call ensures that both callbacks actually get called.</source>
          <target state="translated">В &lt;code&gt;expect.assertions(2)&lt;/code&gt; гарантирует , что оба вызова функции обратного вызова на самом деле вызываются.</target>
        </trans-unit>
        <trans-unit id="8801cb3154dc90b6dabeb0f8d6adc04b7c96a994" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expect.hasAssertions()&lt;/code&gt; call ensures that the &lt;code&gt;prepareState&lt;/code&gt; callback actually gets called.</source>
          <target state="translated">В &lt;code&gt;expect.hasAssertions()&lt;/code&gt; гарантирует , что вызов &lt;code&gt;prepareState&lt;/code&gt; обратного вызова на самом деле вызывается.</target>
        </trans-unit>
        <trans-unit id="6c3326411c984dac96e58b8dd16be60c0de3724a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expect&lt;/code&gt; function is used every time you want to test a value. You will rarely call &lt;code&gt;expect&lt;/code&gt; by itself. Instead, you will use &lt;code&gt;expect&lt;/code&gt; along with a &quot;matcher&quot; function to assert something about a value.</source>
          <target state="translated">Функция &lt;code&gt;expect&lt;/code&gt; используется каждый раз, когда вы хотите проверить значение. Вы редко будете вызывать &lt;code&gt;expect&lt;/code&gt; само по себе. Вместо этого вы будете использовать &lt;code&gt;expect&lt;/code&gt; вместе с функцией &amp;laquo;сопоставления&amp;raquo;, чтобы что-то утверждать о значении.</target>
        </trans-unit>
        <trans-unit id="6594bb5f273e5a4f7094c361061889db4f707818" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract&lt;/code&gt; function should return an iterable (&lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, etc.) with the dependencies found in the code.</source>
          <target state="translated">Функция &lt;code&gt;extract&lt;/code&gt; должна возвращать итерацию ( &lt;code&gt;Array&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; и т. Д.) С зависимостями, найденными в коде.</target>
        </trans-unit>
        <trans-unit id="5539a986bbbbf8c351471c1981c9549b0ae07121" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jest&lt;/code&gt; command line runner has a number of useful options. You can run &lt;code&gt;jest --help&lt;/code&gt; to view all available options. Many of the options shown below can also be used together to run tests exactly the way you want. Every one of Jest's &lt;a href=&quot;configuration&quot;&gt;Configuration&lt;/a&gt; options can also be specified through the CLI.</source>
          <target state="translated">Средство &lt;code&gt;jest&lt;/code&gt; командной строки jest имеет ряд полезных опций. Вы можете запустить &lt;code&gt;jest --help&lt;/code&gt; , чтобы просмотреть все доступные параметры. Многие из показанных ниже параметров также можно использовать вместе для выполнения тестов именно так, как вы хотите. Каждый из параметров &lt;a href=&quot;configuration&quot;&gt;конфигурации&lt;/a&gt; Jest также можно указать через интерфейс командной строки.</target>
        </trans-unit>
        <trans-unit id="8cb0dc4d98327301d27ed47332b5824609aeec5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jest&lt;/code&gt; object is automatically in scope within every test file. The methods in the &lt;code&gt;jest&lt;/code&gt; object help create mocks and let you control Jest's overall behavior.</source>
          <target state="translated">Объект &lt;code&gt;jest&lt;/code&gt; автоматически попадает в область видимости каждого тестового файла. Методы в объекте &lt;code&gt;jest&lt;/code&gt; помогают создавать макеты и позволяют контролировать общее поведение Jest.</target>
        </trans-unit>
        <trans-unit id="71d9b4d1b6d2fe2af134fea43560b4e2597cb34d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jest&lt;/code&gt; object is automatically in scope within every test file. The methods in the &lt;code&gt;jest&lt;/code&gt; object help create mocks and let you control Jest's overall behavior. It can also be imported explicitly by via &lt;code&gt;import {jest} from '@jest/globals'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b8cc683ede161fc025b891451a1f71de3a0d36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mockImplementation&lt;/code&gt; method is useful when you need to define the default implementation of a mock function that is created from another module:</source>
          <target state="translated">Метод &lt;code&gt;mockImplementation&lt;/code&gt; полезен, когда вам нужно определить реализацию по умолчанию фиктивной функции, которая создается из другого модуля:</target>
        </trans-unit>
        <trans-unit id="f414ca5debc72d67a32f4e6f4214b85eb7903c2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; property contains the value that was thrown or returned. &lt;code&gt;value&lt;/code&gt; is undefined when &lt;code&gt;type === 'incomplete'&lt;/code&gt;.</source>
          <target state="translated">Свойство &lt;code&gt;value&lt;/code&gt; содержит значение, которое было выброшено или возвращено. &lt;code&gt;value&lt;/code&gt; не определено, если &lt;code&gt;type === 'incomplete'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60ae20badadde4a0ac472d6382213bf5645d769e" translate="yes" xml:space="preserve">
          <source>The Chrome Developer Tools will be displayed, and a breakpoint will be set at the first line of the Jest CLI script (this is done to give you time to open the developer tools and to prevent Jest from executing before you have time to do so). Click the button that looks like a &quot;play&quot; button in the upper right hand side of the screen to continue execution. When Jest executes the test that contains the &lt;code&gt;debugger&lt;/code&gt; statement, execution will pause and you can examine the current scope and call stack.</source>
          <target state="translated">Отобразятся инструменты разработчика Chrome, и точка останова будет установлена ​​в первой строке сценария Jest CLI (это сделано, чтобы дать вам время открыть инструменты разработчика и предотвратить выполнение Jest до того, как у вас будет время для этого) , Нажмите кнопку, которая выглядит как кнопка &amp;laquo;воспроизведения&amp;raquo; в верхнем правом углу экрана, чтобы продолжить выполнение. Когда Jest выполняет тест, содержащий оператор &lt;code&gt;debugger&lt;/code&gt; , выполнение приостанавливается, и вы можете проверить текущую область видимости и стек вызовов.</target>
        </trans-unit>
        <trans-unit id="cdefcc002eddfb7f6c28f9c7a1871357f57fe794" translate="yes" xml:space="preserve">
          <source>The Jest Object</source>
          <target state="translated">Объект шутки</target>
        </trans-unit>
        <trans-unit id="af5336b9f0d6a51b49389a0b7ed3fd6e4c3872c6" translate="yes" xml:space="preserve">
          <source>The Jest preset built into &lt;code&gt;react-native&lt;/code&gt; comes with a few default mocks that are applied on a react-native repository. However some react-native components or third party components rely on native code to be rendered. In such cases, Jest's manual mocking system can help to mock out the underlying implementation.</source>
          <target state="translated">Предустановка Jest, встроенная в &lt;code&gt;react-native&lt;/code&gt; , поставляется с несколькими макетами по умолчанию, которые применяются в репозитории с react-native. Однако некоторые компоненты, поддерживающие реакцию, или компоненты сторонних производителей для рендеринга полагаются на собственный код. В таких случаях ручная система имитации Jest может помочь имитировать базовую реализацию.</target>
        </trans-unit>
        <trans-unit id="e84d67c7006e50386362acd2af1cef9b46290e6c" translate="yes" xml:space="preserve">
          <source>The Jest preset built into &lt;code&gt;react-native&lt;/code&gt; comes with a few default mocks that are applied on a react-native repository. However, some react-native components or third party components rely on native code to be rendered. In such cases, Jest's manual mocking system can help to mock out the underlying implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2453c12b4a4f24fbc05ce1e4c46073678639c15d" translate="yes" xml:space="preserve">
          <source>The Jest watch plugin system provides a way to hook into specific parts of Jest and to define watch mode menu prompts that execute code on key press. Combined, these features allow you to develop interactive experiences custom for your workflow.</source>
          <target state="translated">Система плагинов для часов &quot;Шут&quot; позволяет подключаться к определенным частям &quot;Шутки&quot; и определять меню режима часов,предлагая выполнить код при нажатии клавиши.Комбинированные,эти функции позволяют вам разработать интерактивный опыт в соответствии с вашим рабочим процессом.</target>
        </trans-unit>
        <trans-unit id="9caca20f4fce1e72a9edd33743ac65377cd25c74" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;expect&lt;/code&gt; should be the value that your code produces, and any argument to the matcher should be the correct value. If you mix them up, your tests will still work, but the error messages on failing tests will look strange.</source>
          <target state="translated">Аргумент &lt;code&gt;expect&lt;/code&gt; должен быть значением , которое производит ваш код, и любой аргумент согласовани должен быть правильным значением. Если вы их перепутаете, ваши тесты все равно будут работать, но сообщения об ошибках при неудачных тестах будут выглядеть странно.</target>
        </trans-unit>
        <trans-unit id="8cc68f24cef4585983c9f185a90ee734f90aa8ae" translate="yes" xml:space="preserve">
          <source>The class may optionally expose a &lt;code&gt;handleTestEvent&lt;/code&gt; method to bind to events fired by &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt;&lt;code&gt;jest-circus&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Класс может дополнительно предоставить метод &lt;code&gt;handleTestEvent&lt;/code&gt; для привязки к событиям, запускаемым &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt; &lt;code&gt;jest-circus&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="421f185691a20ea0fadf51a0d254c03ed3247afa" translate="yes" xml:space="preserve">
          <source>The class may optionally expose an asynchronous &lt;code&gt;handleTestEvent&lt;/code&gt; method to bind to events fired by &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt;&lt;code&gt;jest-circus&lt;/code&gt;&lt;/a&gt;. Normally, &lt;code&gt;jest-circus&lt;/code&gt; test runner would pause until a promise returned from &lt;code&gt;handleTestEvent&lt;/code&gt; gets fulfilled, &lt;strong&gt;except for the next events&lt;/strong&gt;: &lt;code&gt;start_describe_definition&lt;/code&gt;, &lt;code&gt;finish_describe_definition&lt;/code&gt;, &lt;code&gt;add_hook&lt;/code&gt;, &lt;code&gt;add_test&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt; (for the up-to-date list you can look at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-types/src/Circus.ts&quot;&gt;SyncEvent type in the types definitions&lt;/a&gt;). That is caused by backward compatibility reasons and &lt;code&gt;process.on('unhandledRejection', callback)&lt;/code&gt; signature, but that usually should not be a problem for most of the use cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505efbd4b63a11e029fe3900fcf34d5ab8217315" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/async&quot;&gt;examples/async&lt;/a&gt;.</source>
          <target state="translated">Код этого примера доступен по адресу &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/async&quot;&gt;examples / async&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61f42c40ba4012116e65e0172c4574798fdcc3a1" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/enzyme&quot;&gt;examples/enzyme&lt;/a&gt;.</source>
          <target state="translated">Код этого примера доступен по адресу &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/enzyme&quot;&gt;examples / ferme&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e772aeae1e1e3865bc4cf9718bec60261ce607b" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/jquery&quot;&gt;examples/jquery&lt;/a&gt;.</source>
          <target state="translated">Код этого примера доступен по адресу &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/jquery&quot;&gt;examples / jquery&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e7eb572425bcca3655b70ad564fc1692cbc457f" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/manual-mocks&quot;&gt;examples/manual-mocks&lt;/a&gt;.</source>
          <target state="translated">Код этого примера доступен по &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/manual-mocks&quot;&gt;ссылке examples / manual-mocks&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d0665793600a54f70d63deadff14baccb32f7bff" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/react-native&quot;&gt;examples/react-native&lt;/a&gt;.</source>
          <target state="translated">Код этого примера доступен по адресу &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/react-native&quot;&gt;examples / react-native&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9347a0f5e3be6b1f8c7f0c4795c7b215bb18ebd4" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/react-testing-library&quot;&gt;examples/react-testing-library&lt;/a&gt;.</source>
          <target state="translated">Код этого примера доступен по адресу &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/react-testing-library&quot;&gt;examples / react-testing-library&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b032ec230190e1c4fc446fee9c02430a5dbbd77b" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/snapshot&quot;&gt;examples/snapshot&lt;/a&gt;.</source>
          <target state="translated">Код этого примера доступен по адресу &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/snapshot&quot;&gt;examples / snapshot&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc4f949fe92e0d8c8e3b3a03859bac8aa481d502" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/timer&quot;&gt;examples/timer&lt;/a&gt;.</source>
          <target state="translated">Код этого примера доступен по адресу &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/timer&quot;&gt;examples / timer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f12a555ea8e1761a86877b27341850cacd56ac73" translate="yes" xml:space="preserve">
          <source>The community around Jest is working hard to make the testing experience even greater.</source>
          <target state="translated">Сообщество,окружающее &quot;Шут&quot;,прилагает все усилия,чтобы сделать тестирование еще более успешным.</target>
        </trans-unit>
        <trans-unit id="7585ea7c7f78a15b022764598b8197c90e7876b0" translate="yes" xml:space="preserve">
          <source>The directory where Jest should output its coverage files.</source>
          <target state="translated">Каталог,в котором Jest должен выводить свои файлы покрытия.</target>
        </trans-unit>
        <trans-unit id="376f21d7672ef7ba555cd8e4de07656368d480d0" translate="yes" xml:space="preserve">
          <source>The directory where Jest should store its cached dependency information.</source>
          <target state="translated">Каталог,в котором Jest должен хранить кэшированную информацию о зависимостях.</target>
        </trans-unit>
        <trans-unit id="b455adf26e8057d7ba70aa7e64159f9222cf09e6" translate="yes" xml:space="preserve">
          <source>The easiest way to debug Jest tests in &lt;a href=&quot;https://www.jetbrains.com/webstorm/&quot;&gt;WebStorm&lt;/a&gt; is using &lt;code&gt;Jest run/debug configuration&lt;/code&gt;. It will launch tests and automatically attach debugger.</source>
          <target state="translated">Самый простой способ отладки тестов Jest в &lt;a href=&quot;https://www.jetbrains.com/webstorm/&quot;&gt;WebStorm&lt;/a&gt; - использовать &lt;code&gt;Jest run/debug configuration&lt;/code&gt; . Он запустит тесты и автоматически подключит отладчик.</target>
        </trans-unit>
        <trans-unit id="9c5fa79dfce65458f929b1ce12610301e9cf3865" translate="yes" xml:space="preserve">
          <source>The example mock shown here uses &lt;a href=&quot;jest-object#jestcreatemockfrommodulemodulename&quot;&gt;&lt;code&gt;jest.createMockFromModule&lt;/code&gt;&lt;/a&gt; to generate an automatic mock, and overrides its default behavior. This is the recommended approach, but is completely optional. If you do not want to use the automatic mock at all, you can export your own functions from the mock file. One downside to fully manual mocks is that they're manual &amp;ndash; meaning you have to manually update them any time the module they are mocking changes. Because of this, it's best to use or extend the automatic mock when it works for your needs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecbe9621df2404d5fbb33e2600044e0b27c47481" translate="yes" xml:space="preserve">
          <source>The example mock shown here uses &lt;a href=&quot;jest-object#jestgenmockfrommodulemodulename&quot;&gt;&lt;code&gt;jest.genMockFromModule&lt;/code&gt;&lt;/a&gt; to generate an automatic mock, and overrides its default behavior. This is the recommended approach, but is completely optional. If you do not want to use the automatic mock at all, you can export your own functions from the mock file. One downside to fully manual mocks is that they're manual &amp;ndash; meaning you have to manually update them any time the module they are mocking changes. Because of this, it's best to use or extend the automatic mock when it works for your needs.</source>
          <target state="translated">В показанном здесь примере макета используется &lt;a href=&quot;jest-object#jestgenmockfrommodulemodulename&quot;&gt; &lt;code&gt;jest.genMockFromModule&lt;/code&gt; &lt;/a&gt; для создания автоматического макета и переопределяется его поведение по умолчанию. Это рекомендуемый подход, но он не является обязательным. Если вы вообще не хотите использовать автоматический макет, вы можете экспортировать свои собственные функции из файла макета. Одним из недостатков полностью ручных макетов является то, что они ручные, то есть вам придется вручную обновлять их каждый раз, когда модуль, в котором они имитируют, изменяет. Из-за этого лучше использовать или расширять автоматический макет, когда он работает для ваших нужд.</target>
        </trans-unit>
        <trans-unit id="2508586aa35287e8b27df6e110475235bd694e90" translate="yes" xml:space="preserve">
          <source>The exit code Jest returns on test failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a4a43d898d3af6802055c9164972d36548014d" translate="yes" xml:space="preserve">
          <source>The first argument is the test name; the second argument is a function that contains the expectations to test. The third argument (optional) is &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) for specifying how long to wait before aborting. &lt;em&gt;Note: The default timeout is 5 seconds.&lt;/em&gt;</source>
          <target state="translated">Первый аргумент - это название теста; второй аргумент - это функция, которая содержит ожидания для проверки. Третий аргумент (необязательный) - это &lt;code&gt;timeout&lt;/code&gt; (в миллисекундах) для указания, сколько времени ждать перед прерыванием. &lt;em&gt;Примечание. Тайм-аут по умолчанию составляет 5 секунд.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2bbf7bf0829c4a7923096dc1c283c4faad2abdf7" translate="yes" xml:space="preserve">
          <source>The first argument is the test name; the second argument is an asynchronous function that contains the expectations to test. The third argument (optional) is &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) for specifying how long to wait before aborting. &lt;em&gt;Note: The default timeout is 5 seconds.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6838de5b16cb59f34f7a719f1e8d3453345e067e" translate="yes" xml:space="preserve">
          <source>The first time this test is run, Jest creates a &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/__tests__/__snapshots__/link.react.test.js.snap&quot;&gt;snapshot file&lt;/a&gt; that looks like this:</source>
          <target state="translated">При первом запуске этого теста Jest создает &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/__tests__/__snapshots__/link.react.test.js.snap&quot;&gt;файл моментального снимка,&lt;/a&gt; который выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="1492463266cc80f52fcf093c60f36ae239754aca" translate="yes" xml:space="preserve">
          <source>The following example contains a &lt;code&gt;houseForSale&lt;/code&gt; object with nested properties. We are using &lt;code&gt;toHaveProperty&lt;/code&gt; to check for the existence and values of various properties in the object.</source>
          <target state="translated">В следующем примере содержится объект &lt;code&gt;houseForSale&lt;/code&gt; с вложенными свойствами. Мы используем &lt;code&gt;toHaveProperty&lt;/code&gt; для проверки существования и значений различных свойств в объекте.</target>
        </trans-unit>
        <trans-unit id="6b2cf0dc88bf9d13b702ff5e6f3622ae5afb3db3" translate="yes" xml:space="preserve">
          <source>The following examples will assume you have an understanding of how &lt;a href=&quot;es6-class-mocks&quot;&gt;Jest mock classes work with JavaScript&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30789d18cf6d3429a995f05a497818957e194817" translate="yes" xml:space="preserve">
          <source>The following examples will assume you have an understanding of how &lt;a href=&quot;mock-functions&quot;&gt;Jest mock functions work with JavaScript&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f734d3eeaab81fca3e29f3523738b60fc7cd77" translate="yes" xml:space="preserve">
          <source>The following is a visualization of the default regex:</source>
          <target state="translated">Ниже приведена визуализация регекса по умолчанию:</target>
        </trans-unit>
        <trans-unit id="47cef9c94451278775edf865a9789b6d6b64cf3f" translate="yes" xml:space="preserve">
          <source>The following keys for built-in functionality &lt;strong&gt;can be overwritten&lt;/strong&gt; :</source>
          <target state="translated">Следующие клавиши для встроенных функций &lt;strong&gt;могут быть перезаписаны&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="d021e17efe498d997940dd70ef8fa277b5a2e9cd" translate="yes" xml:space="preserve">
          <source>The function being tested adds an event listener on the &lt;code&gt;#button&lt;/code&gt; DOM element, so we need to set up our DOM correctly for the test. Jest ships with &lt;code&gt;jsdom&lt;/code&gt; which simulates a DOM environment as if you were in the browser. This means that every DOM API that we call can be observed in the same way it would be observed in a browser!</source>
          <target state="translated">Тестируемая функция добавляет прослушиватель событий к &lt;code&gt;#button&lt;/code&gt; DOM #button , поэтому нам нужно правильно настроить нашу DOM для теста. Jest поставляется с &lt;code&gt;jsdom&lt;/code&gt; , который имитирует среду DOM, как если бы вы были в браузере. Это означает, что за каждым вызываемым нами DOM API можно наблюдать так же, как и в браузере!</target>
        </trans-unit>
        <trans-unit id="6596e95c4d26bf49becdf01cb51e6fc651959a04" translate="yes" xml:space="preserve">
          <source>The function should either return a path to the module that should be resolved or throw an error if the module can't be found.</source>
          <target state="translated">Функция должна либо вернуть путь к модулю,который должен быть разрешен,либо бросить ошибку,если модуль не может быть найден.</target>
        </trans-unit>
        <trans-unit id="aab58f520069315bb0a84d63dee876237963ccad" translate="yes" xml:space="preserve">
          <source>The glob patterns Jest uses to detect test files. By default it looks for &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.jsx&lt;/code&gt;, &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files inside of &lt;code&gt;__tests__&lt;/code&gt; folders, as well as any files with a suffix of &lt;code&gt;.test&lt;/code&gt; or &lt;code&gt;.spec&lt;/code&gt; (e.g. &lt;code&gt;Component.test.js&lt;/code&gt; or &lt;code&gt;Component.spec.js&lt;/code&gt;). It will also find files called &lt;code&gt;test.js&lt;/code&gt; or &lt;code&gt;spec.js&lt;/code&gt;.</source>
          <target state="translated">Шаблоны глобусов, которые Jest использует для обнаружения тестовых файлов. По умолчанию он ищет файлы &lt;code&gt;.js&lt;/code&gt; , &lt;code&gt;.jsx&lt;/code&gt; , &lt;code&gt;.ts&lt;/code&gt; и &lt;code&gt;.tsx&lt;/code&gt; внутри папок &lt;code&gt;__tests__&lt;/code&gt; , а также любые файлы с суффиксом &lt;code&gt;.test&lt;/code&gt; или &lt;code&gt;.spec&lt;/code&gt; (например, &lt;code&gt;Component.test.js&lt;/code&gt; или &lt;code&gt;Component.spec.js&lt;/code&gt; ) , Он также будет искать файлы , называемые &lt;code&gt;test.js&lt;/code&gt; или &lt;code&gt;spec.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1723fc61e3e4203902e2769fce84e0f47e6816e8" translate="yes" xml:space="preserve">
          <source>The goal is to make it easy to review snapshots in pull requests, and fight against the habit of regenerating snapshots when test suites fail instead of examining the root causes of their failure.</source>
          <target state="translated">Цель заключается в том,чтобы упростить просмотр моментальных снимков в запросах на подтягивание и бороться с привычкой регенерировать моментальные снимки,когда тестовые наборы терпят неудачу,вместо того,чтобы исследовать первопричины их неудач.</target>
        </trans-unit>
        <trans-unit id="2689ebeac189b738f558285371fec779e8a24bfd" translate="yes" xml:space="preserve">
          <source>The jest-community org maintains an &lt;a href=&quot;https://github.com/jest-community/awesome-jest&quot;&gt;awesome-jest&lt;/a&gt; list of great projects and resources related to Jest, this includes all projects not just the ones in the jest-community org.</source>
          <target state="translated">Организация jest-community поддерживает &lt;a href=&quot;https://github.com/jest-community/awesome-jest&quot;&gt;потрясающий&lt;/a&gt; список замечательных проектов и ресурсов, связанных с Jest, он включает все проекты, а не только те, что находятся в организации jest-community.</target>
        </trans-unit>
        <trans-unit id="327140711518544eb69d91ed359d0f86086c942f" translate="yes" xml:space="preserve">
          <source>The manual mock equivalent of this would be:</source>
          <target state="translated">Ручной инсценировочный эквивалент:</target>
        </trans-unit>
        <trans-unit id="968ed8d3094b9f92af942c92765f9081682130bf" translate="yes" xml:space="preserve">
          <source>The module factory function passed to &lt;code&gt;jest.mock(path, moduleFactory)&lt;/code&gt; can be a HOF that returns a function*. This will allow calling &lt;code&gt;new&lt;/code&gt; on the mock. Again, this allows you to inject different behavior for testing, but does not provide a way to spy on calls.</source>
          <target state="translated">Функция фабрики модуля, переданная в &lt;code&gt;jest.mock(path, moduleFactory)&lt;/code&gt; может быть HOF, которая возвращает функцию *. Это позволит на макете вызывать &lt;code&gt;new&lt;/code&gt; . Опять же, это позволяет вам ввести другое поведение для тестирования, но не дает возможности отслеживать звонки.</target>
        </trans-unit>
        <trans-unit id="4376614c6f08aa0261023a608b95c6492b8e9525" translate="yes" xml:space="preserve">
          <source>The most common asynchronous pattern is callbacks.</source>
          <target state="translated">Наиболее распространенная асинхронная схема-обратные вызовы.</target>
        </trans-unit>
        <trans-unit id="0274127a2409aa50ab0b03082620b24a366d505d" translate="yes" xml:space="preserve">
          <source>The most common use of this API is for specifying the module a given test intends to be testing (and thus doesn't want automatically mocked).</source>
          <target state="translated">Самым распространенным использованием данного API является указание модуля,который данный тест собирается тестировать (а значит,не хочет автоматически высмеивать).</target>
        </trans-unit>
        <trans-unit id="6cba2620d821c40d1a35b89d6a989fe10a704a0f" translate="yes" xml:space="preserve">
          <source>The most useful ones are &lt;code&gt;matcherHint&lt;/code&gt;, &lt;code&gt;printExpected&lt;/code&gt; and &lt;code&gt;printReceived&lt;/code&gt; to format the error messages nicely. For example, take a look at the implementation for the &lt;code&gt;toBe&lt;/code&gt; matcher:</source>
          <target state="translated">Наиболее полезными из них являются &lt;code&gt;matcherHint&lt;/code&gt; , &lt;code&gt;printExpected&lt;/code&gt; и &lt;code&gt;printReceived&lt;/code&gt; для удобного форматирования сообщений об ошибках. Например, посмотрите на реализацию &lt;code&gt;toBe&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e952463962a1b689236ab9f6e17c97ccd482a4f3" translate="yes" xml:space="preserve">
          <source>The native timer functions (i.e., &lt;code&gt;setTimeout&lt;/code&gt;, &lt;code&gt;setInterval&lt;/code&gt;, &lt;code&gt;clearTimeout&lt;/code&gt;, &lt;code&gt;clearInterval&lt;/code&gt;) are less than ideal for a testing environment since they depend on real time to elapse. Jest can swap out timers with functions that allow you to control the passage of time. &lt;a href=&quot;https://www.youtube.com/watch?v=QZoJ2Pt27BY&quot;&gt;Great Scott!&lt;/a&gt;</source>
          <target state="translated">Встроенные функции таймера (например, &lt;code&gt;setTimeout&lt;/code&gt; , &lt;code&gt;setInterval&lt;/code&gt; , &lt;code&gt;clearTimeout&lt;/code&gt; , &lt;code&gt;clearInterval&lt;/code&gt; ) менее чем идеальны для среды тестирования, поскольку они зависят от истечения реального времени. Jest может заменять таймеры функциями, позволяющими контролировать течение времени. &lt;a href=&quot;https://www.youtube.com/watch?v=QZoJ2Pt27BY&quot;&gt;Великий Скотт!&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0c7bd0e4ffc67ba49a20c3a2e181946f66fdd8b6" translate="yes" xml:space="preserve">
          <source>The next time you run Jest, &lt;code&gt;tree&lt;/code&gt; will be evaluated, and a snapshot will be written as an argument to &lt;code&gt;toMatchInlineSnapshot&lt;/code&gt;:</source>
          <target state="translated">В следующий раз, когда вы запустите Jest, &lt;code&gt;tree&lt;/code&gt; будет оценено, и снимок будет записан в качестве аргумента &lt;code&gt;toMatchInlineSnapshot&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5b848fe1137b4b9b68da4deb8ef3d11d697c37f6" translate="yes" xml:space="preserve">
          <source>The next time you run the tests, the rendered output will be compared to the previously created snapshot. The snapshot should be committed along code changes. When a snapshot test fails, you need to inspect whether it is an intended or unintended change. If the change is expected you can invoke Jest with &lt;code&gt;jest -u&lt;/code&gt; to overwrite the existing snapshot.</source>
          <target state="translated">В следующий раз, когда вы запустите тесты, визуализированный результат будет сравнен с ранее созданным снимком. Снимок должен быть зафиксирован вместе с изменениями кода. Когда тест снимка не проходит, вам необходимо проверить, является ли это намеренным или непреднамеренным изменением. Если изменение ожидается, вы можете вызвать Jest с помощью &lt;code&gt;jest -u&lt;/code&gt; , чтобы перезаписать существующий снимок.</target>
        </trans-unit>
        <trans-unit id="c0aa57bf091fdb92d54cdb2b0d3bc7f67e93ff89" translate="yes" xml:space="preserve">
          <source>The next time you run the tests, the rendered output will be compared to the previously created snapshot. The snapshot should be committed along with code changes. When a snapshot test fails, you need to inspect whether it is an intended or unintended change. If the change is expected you can invoke Jest with &lt;code&gt;jest -u&lt;/code&gt; to overwrite the existing snapshot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d0785b2c19153a1443fb7a2b373d5989af5d74" translate="yes" xml:space="preserve">
          <source>The number of seconds after which a test is considered as slow and reported as such in the results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a31eaed7b5b436b050c922084e63b820147d0c79" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;numDigits&lt;/code&gt; argument has default value &lt;code&gt;2&lt;/code&gt; which means the criterion is &lt;code&gt;Math.abs(expected - received) &amp;lt; 0.005&lt;/code&gt; (that is, &lt;code&gt;10 ** -2 / 2&lt;/code&gt;).</source>
          <target state="translated">Необязательный аргумент &lt;code&gt;numDigits&lt;/code&gt; имеет значение по умолчанию &lt;code&gt;2&lt;/code&gt; , что означает, что критерием является &lt;code&gt;Math.abs(expected - received) &amp;lt; 0.005&lt;/code&gt; (то есть &lt;code&gt;10 ** -2 / 2&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="64715c706a809e691edcf14fa2f1881885671388" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;numDigits&lt;/code&gt; argument limits the number of digits to check &lt;strong&gt;after&lt;/strong&gt; the decimal point. For the default value &lt;code&gt;2&lt;/code&gt;, the test criterion is &lt;code&gt;Math.abs(expected - received) &amp;lt; 0.005&lt;/code&gt; (that is, &lt;code&gt;10 ** -2 / 2&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb0899f14809b1bdd6ebd980d7e7260be1575887" translate="yes" xml:space="preserve">
          <source>The order in which the mappings are defined matters. Patterns are checked one by one until one fits. The most specific rule should be listed first.</source>
          <target state="translated">Порядок,в котором определяются отображения,имеет значение.Шаблоны проверяются один за другим до тех пор,пока они не будут соответствовать друг другу.Наиболее конкретное правило должно быть перечислено первым.</target>
        </trans-unit>
        <trans-unit id="5b6e6db2c1f69ef0831d7bfa5c2ddb80fbc9eeba" translate="yes" xml:space="preserve">
          <source>The order in which the mappings are defined matters. Patterns are checked one by one until one fits. The most specific rule should be listed first. This is true for arrays of module names as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c5b04e8fcaf70465aadc92771f5000507ea04a5" translate="yes" xml:space="preserve">
          <source>The path to a module that can resolve test&amp;lt;-&amp;gt;snapshot path. This config option lets you customize where Jest stores snapshot files on disk.</source>
          <target state="translated">Путь к модулю, который может разрешить test &amp;lt;-&amp;gt; путь к моментальному снимку. Эта опция конфигурации позволяет вам настроить, где Jest хранит файлы моментальных снимков на диске.</target>
        </trans-unit>
        <trans-unit id="af95718edc02b7821b4e9e81772f5338985c3a20" translate="yes" xml:space="preserve">
          <source>The path to a module that runs some code to configure or set up the testing framework before each test. Beware that files imported by the setup script will not be mocked during testing.</source>
          <target state="translated">Путь к модулю,который запускает некоторый код для настройки или настройки фреймворка тестирования перед каждым тестом.Остерегайтесь,что файлы,импортированные скриптом установки,не будут высмеиваться во время тестирования.</target>
        </trans-unit>
        <trans-unit id="4431569135edde52cd7dc8cd910c15a768e3e1b1" translate="yes" xml:space="preserve">
          <source>The pattern or patterns Jest uses to detect test files. By default it looks for &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.jsx&lt;/code&gt;, &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files inside of &lt;code&gt;__tests__&lt;/code&gt; folders, as well as any files with a suffix of &lt;code&gt;.test&lt;/code&gt; or &lt;code&gt;.spec&lt;/code&gt; (e.g. &lt;code&gt;Component.test.js&lt;/code&gt; or &lt;code&gt;Component.spec.js&lt;/code&gt;). It will also find files called &lt;code&gt;test.js&lt;/code&gt; or &lt;code&gt;spec.js&lt;/code&gt;. See also &lt;a href=&quot;#testmatch-arraystring&quot;&gt;&lt;code&gt;testMatch&lt;/code&gt; [array&amp;lt;string&amp;gt;]&lt;/a&gt;, but note that you cannot specify both options.</source>
          <target state="translated">Шаблон или шаблоны, которые Jest использует для обнаружения тестовых файлов. По умолчанию он ищет файлы &lt;code&gt;.js&lt;/code&gt; , &lt;code&gt;.jsx&lt;/code&gt; , &lt;code&gt;.ts&lt;/code&gt; и &lt;code&gt;.tsx&lt;/code&gt; внутри папок &lt;code&gt;__tests__&lt;/code&gt; , а также любые файлы с суффиксом &lt;code&gt;.test&lt;/code&gt; или &lt;code&gt;.spec&lt;/code&gt; (например, &lt;code&gt;Component.test.js&lt;/code&gt; или &lt;code&gt;Component.spec.js&lt;/code&gt; ) , Он также будет искать файлы , называемые &lt;code&gt;test.js&lt;/code&gt; или &lt;code&gt;spec.js&lt;/code&gt; . См. Также &lt;a href=&quot;#testmatch-arraystring&quot;&gt; &lt;code&gt;testMatch&lt;/code&gt; [array &amp;lt;string&amp;gt;]&lt;/a&gt; , но учтите, что вы не можете указать обе опции.</target>
        </trans-unit>
        <trans-unit id="ac24fd9dddf51302b5efc36ff27838314425a460" translate="yes" xml:space="preserve">
          <source>The preset sets up the environment and is very opinionated and based on what we found to be useful at Facebook. All of the configuration options can be overwritten just as they can be customized when no preset is used.</source>
          <target state="translated">Заданная настройка настраивает среду,и она является очень своеобразной и основывается на том,что мы нашли полезным на Facebook.Все опции конфигурации могут быть перезаписаны так же,как их можно настроить,когда ни одна из предустановок не используется.</target>
        </trans-unit>
        <trans-unit id="ac31d1cab716f57b4c0ab81a14ecb8cc6af7f1f3" translate="yes" xml:space="preserve">
          <source>The problem is that the test will complete as soon as &lt;code&gt;fetchData&lt;/code&gt; completes, before ever calling the callback.</source>
          <target state="translated">Проблема в том, что тест завершится, как только &lt;code&gt;fetchData&lt;/code&gt; завершится, прежде чем вызовет обратный вызов.</target>
        </trans-unit>
        <trans-unit id="9c9c92c829ae1b54b1e9c5e404efb1cc15d27456" translate="yes" xml:space="preserve">
          <source>The projects feature can also be used to run multiple configurations or multiple &lt;a href=&quot;#runner-string&quot;&gt;runners&lt;/a&gt;. For this purpose you can pass an array of configuration objects. For example, to run both tests and ESLint (via &lt;a href=&quot;https://github.com/jest-community/jest-runner-eslint&quot;&gt;jest-runner-eslint&lt;/a&gt;) in the same invocation of Jest:</source>
          <target state="translated">Функцию проектов также можно использовать для запуска нескольких конфигураций или нескольких &lt;a href=&quot;#runner-string&quot;&gt;исполнителей&lt;/a&gt; . Для этого вы можете передать массив объектов конфигурации. Например, чтобы запустить оба теста и ESLint (через &lt;a href=&quot;https://github.com/jest-community/jest-runner-eslint&quot;&gt;jest-runner-eslint&lt;/a&gt; ) при одном вызове Jest:</target>
        </trans-unit>
        <trans-unit id="891a6640064d264d47e092465eed82ba702c8606" translate="yes" xml:space="preserve">
          <source>The projects feature can also be used to run multiple configurations or multiple &lt;a href=&quot;#runner-string&quot;&gt;runners&lt;/a&gt;. For this purpose, you can pass an array of configuration objects. For example, to run both tests and ESLint (via &lt;a href=&quot;https://github.com/jest-community/jest-runner-eslint&quot;&gt;jest-runner-eslint&lt;/a&gt;) in the same invocation of Jest:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d777c2e867accda0c769689ff6458c1a1f2898ad" translate="yes" xml:space="preserve">
          <source>The root directory that Jest should scan for tests and modules within. If you put your Jest config inside your &lt;code&gt;package.json&lt;/code&gt; and want the root directory to be the root of your repo, the value for this config param will default to the directory of the &lt;code&gt;package.json&lt;/code&gt;.</source>
          <target state="translated">Корневой каталог, в котором Jest должен сканировать тесты и модули. Если вы поместите свою конфигурацию Jest в свой &lt;code&gt;package.json&lt;/code&gt; и хотите, чтобы корневой каталог был корнем вашего репо, значением этого параметра конфигурации по умолчанию будет каталог &lt;code&gt;package.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a722fbdccf79dd6f0ade849e2e9aba5e205e8984" translate="yes" xml:space="preserve">
          <source>The second argument can be used to specify an explicit module factory that is being run instead of using Jest's automocking feature:</source>
          <target state="translated">Второй аргумент может быть использован для указания явного завода модуля,который запускается вместо использования функции автоматизации Jest:</target>
        </trans-unit>
        <trans-unit id="ea2159726c801a056456ea23b7ba004e04675c0c" translate="yes" xml:space="preserve">
          <source>The simplest way to test a value is with exact equality.</source>
          <target state="translated">Самый простой способ проверить значение-точное равенство.</target>
        </trans-unit>
        <trans-unit id="89fdf05ff2117139335a3d62f43a887b7ae92045" translate="yes" xml:space="preserve">
          <source>The snapshot artifact should be committed alongside code changes, and reviewed as part of your code review process. Jest uses &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/pretty-format&quot;&gt;pretty-format&lt;/a&gt; to make snapshots human-readable during code review. On subsequent test runs Jest will compare the rendered output with the previous snapshot. If they match, the test will pass. If they don't match, either the test runner found a bug in your code (in this case, it's &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; component) that should be fixed, or the implementation has changed and the snapshot needs to be updated.</source>
          <target state="translated">Артефакт моментального снимка должен фиксироваться вместе с изменениями кода и проверяться как часть процесса проверки кода. Jest использует &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/pretty-format&quot;&gt;красивый формат,&lt;/a&gt; чтобы сделать снимки удобочитаемыми во время проверки кода. При последующих запусках теста Jest сравнит визуализированный результат с предыдущим снимком. Если они совпадают, тест пройдёт. Если они не совпадают, либо средство выполнения тестов обнаружило ошибку в вашем коде (в данном случае это компонент &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; ), который необходимо исправить, либо реализация изменилась и снимок необходимо обновить.</target>
        </trans-unit>
        <trans-unit id="1a331b33d493c1f842342392e5e84852aa3f9212" translate="yes" xml:space="preserve">
          <source>The snapshot artifact should be committed alongside code changes, and reviewed as part of your code review process. Jest uses &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/pretty-format&quot;&gt;pretty-format&lt;/a&gt; to make snapshots human-readable during code review. On subsequent test runs, Jest will compare the rendered output with the previous snapshot. If they match, the test will pass. If they don't match, either the test runner found a bug in your code (in the &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; component in this case) that should be fixed, or the implementation has changed and the snapshot needs to be updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451807d753aa7848105f4c86ff05582eb86d15a2" translate="yes" xml:space="preserve">
          <source>The test environment that will be used for testing. The default environment in Jest is a browser-like environment through &lt;a href=&quot;https://github.com/jsdom/jsdom&quot;&gt;jsdom&lt;/a&gt;. If you are building a node service, you can use the &lt;code&gt;node&lt;/code&gt; option to use a node-like environment instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93bd3296b403f0c79b1219e068c720003979038e" translate="yes" xml:space="preserve">
          <source>The test environment that will be used for testing. The default environment in Jest is a browser-like environment through &lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom&lt;/a&gt;. If you are building a node service, you can use the &lt;code&gt;node&lt;/code&gt; option to use a node-like environment instead.</source>
          <target state="translated">Тестовая среда, которая будет использоваться для тестирования. Среда по умолчанию в Jest - это среда, &lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;подобная&lt;/a&gt; браузеру, через jsdom . Если вы создаете службу узла, вы можете использовать параметр &lt;code&gt;node&lt;/code&gt; чтобы вместо этого использовать среду, подобную узлу.</target>
        </trans-unit>
        <trans-unit id="83a5c50498cba1f5866a682bd859dafc3028b89d" translate="yes" xml:space="preserve">
          <source>The test environment used for all tests. This can point to any file or node module. Examples: &lt;code&gt;jsdom&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt; or &lt;code&gt;path/to/my-environment.js&lt;/code&gt;.</source>
          <target state="translated">Тестовая среда, используемая для всех тестов. Это может указывать на любой файл или узел узла. Примеры: &lt;code&gt;jsdom&lt;/code&gt; , &lt;code&gt;node&lt;/code&gt; или &lt;code&gt;path/to/my-environment.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d4908fe8da50856a80634fb387ecf713015308b" translate="yes" xml:space="preserve">
          <source>The test for this function will look this way:</source>
          <target state="translated">Тест для этой функции будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="73d8c22714027dd5317a0ccf3a9114cb6f10cf4c" translate="yes" xml:space="preserve">
          <source>The test runner module must export a function with the following signature:</source>
          <target state="translated">Тестовый блок должен экспортировать функцию со следующей подписью:</target>
        </trans-unit>
        <trans-unit id="29baec25ad18f1066c1ae3baa55f05cb1bcb3277" translate="yes" xml:space="preserve">
          <source>The third argument can be used to create virtual mocks &amp;ndash; mocks of modules that don't exist anywhere in the system:</source>
          <target state="translated">Третий аргумент можно использовать для создания виртуальных моков - имитов модулей, которых нет нигде в системе:</target>
        </trans-unit>
        <trans-unit id="06b3722bc66e669d036905e4f6b2a5bdde949a1d" translate="yes" xml:space="preserve">
          <source>The transform script was changed or Babel was updated and the changes aren't being recognized by Jest?</source>
          <target state="translated">Сценарий преобразования был изменен или Вавилон был обновлен,а изменения не распознаются Шутом?</target>
        </trans-unit>
        <trans-unit id="ca9dbda065b378b7864401a6ebb986bd5f6ee7e2" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;.rejects&lt;/code&gt; helper works like the &lt;code&gt;.resolves&lt;/code&gt; helper. If the promise is fulfilled, the test will automatically fail.</source>
          <target state="translated">В &lt;code&gt;.rejects&lt;/code&gt; помощник работает как &lt;code&gt;.resolves&lt;/code&gt; помощника. Если обещание выполнено, тест автоматически завершится неудачно.</target>
        </trans-unit>
        <trans-unit id="5b03b539d200edd998532b7ea7db20e6e130b6ab" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;.rejects&lt;/code&gt; helper works like the &lt;code&gt;.resolves&lt;/code&gt; helper. If the promise is fulfilled, the test will automatically fail. &lt;code&gt;expect.assertions(number)&lt;/code&gt; is not required but recommended to verify that a certain number of &lt;a href=&quot;expect#expectassertionsnumber&quot;&gt;assertions&lt;/a&gt; are called during a test. It is otherwise easy to forget to &lt;code&gt;return&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; the &lt;code&gt;.resolves&lt;/code&gt; assertions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb453830c3d6aec96f0b7405572bb292c7ef9964" translate="yes" xml:space="preserve">
          <source>Then add &lt;code&gt;@babel/preset-typescript&lt;/code&gt; to the list of presets in your &lt;code&gt;babel.config.js&lt;/code&gt;.</source>
          <target state="translated">Затем добавьте &lt;code&gt;@babel/preset-typescript&lt;/code&gt; в список пресетов в вашем &lt;code&gt;babel.config.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70a1108a97f09cf114548ba44e232397dc6dda32" translate="yes" xml:space="preserve">
          <source>Then all your className lookups on the styles object will be returned as-is (e.g., &lt;code&gt;styles.foobar === 'foobar'&lt;/code&gt;). This is pretty handy for React &lt;a href=&quot;snapshot-testing&quot;&gt;Snapshot Testing&lt;/a&gt;.</source>
          <target state="translated">Тогда все ваши поисковые запросы className для объекта стилей будут возвращены как есть (например, &lt;code&gt;styles.foobar === 'foobar'&lt;/code&gt; ). Это очень удобно для &lt;a href=&quot;snapshot-testing&quot;&gt;тестирования моментальных снимков&lt;/a&gt; React .</target>
        </trans-unit>
        <trans-unit id="7fd2e2b8e86105641b83aa873750ac3f07a7e6d6" translate="yes" xml:space="preserve">
          <source>Then attach VS Code's debugger using the following &lt;code&gt;launch.json&lt;/code&gt; config:</source>
          <target state="translated">Затем подключите отладчик VS Code, используя следующую конфигурацию &lt;code&gt;launch.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e2ebdb0fca325019ed94f96f98ebfc6dc5ffe770" translate="yes" xml:space="preserve">
          <source>Then we need a custom Test Environment for puppeteer</source>
          <target state="translated">Тогда нам нужна пользовательская тестовая среда для кукловода.</target>
        </trans-unit>
        <trans-unit id="91f5afaec66d498efbeae8c4a2a41bd0c4feb389" translate="yes" xml:space="preserve">
          <source>Then you will see warnings in the console:</source>
          <target state="translated">Тогда вы увидите предупреждения в консоли:</target>
        </trans-unit>
        <trans-unit id="e559c23353ae644c58d965edecd0976830cfc4b2" translate="yes" xml:space="preserve">
          <source>Then, create a file named &lt;code&gt;sum.test.js&lt;/code&gt;. This will contain our actual test:</source>
          <target state="translated">Затем, создайте файл с именем &lt;code&gt;sum.test.js&lt;/code&gt; . Это будет наш настоящий тест:</target>
        </trans-unit>
        <trans-unit id="490b7879f324bbb8130b919839cb28e4ee52a87d" translate="yes" xml:space="preserve">
          <source>There are a number of helpful tools exposed on &lt;code&gt;this.utils&lt;/code&gt; primarily consisting of the exports from &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils&quot;&gt;&lt;code&gt;jest-matcher-utils&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">На &lt;code&gt;this.utils&lt;/code&gt; представлен ряд полезных инструментов, в основном состоящих из экспорта из &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils&quot;&gt; &lt;code&gt;jest-matcher-utils&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce3ddc7ca2ed0e64f9ff4f568a1875d4a36fac12" translate="yes" xml:space="preserve">
          <source>There are also scenarios where you might have a recursive timer -- that is a timer that sets a new timer in its own callback. For these, running all the timers would be an endless loop&amp;hellip; so something like &lt;code&gt;jest.runAllTimers()&lt;/code&gt; is not desirable. For these cases you might use &lt;code&gt;jest.runOnlyPendingTimers()&lt;/code&gt;:</source>
          <target state="translated">Есть также сценарии, в которых у вас может быть рекурсивный таймер - это таймер, который устанавливает новый таймер в своем собственном обратном вызове. Для них запуск всех таймеров был бы бесконечным циклом ... поэтому что-то вроде &lt;code&gt;jest.runAllTimers()&lt;/code&gt; нежелательно. В этих случаях вы можете использовать &lt;code&gt;jest.runOnlyPendingTimers()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8062c6b456eff0aa9aea644bdb6882897bba1ab7" translate="yes" xml:space="preserve">
          <source>There are multiple ways to debug Jest tests with &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;Visual Studio Code's&lt;/a&gt; built in &lt;a href=&quot;https://code.visualstudio.com/docs/nodejs/nodejs-debugging&quot;&gt;debugger&lt;/a&gt;.</source>
          <target state="translated">Существует несколько способов отладки тестов Jest с &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;помощью&lt;/a&gt; встроенного &lt;a href=&quot;https://code.visualstudio.com/docs/nodejs/nodejs-debugging&quot;&gt;отладчика &lt;/a&gt;Visual Studio Code .</target>
        </trans-unit>
        <trans-unit id="a0eee51d034df763b8fd5499614ddfe4723acc15" translate="yes" xml:space="preserve">
          <source>There are multiple ways to debug Jest tests with &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;Visual Studio Code's&lt;/a&gt; built-in &lt;a href=&quot;https://code.visualstudio.com/docs/nodejs/nodejs-debugging&quot;&gt;debugger&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f73f9113b29102310bf6ae603463dfb6eed9cda" translate="yes" xml:space="preserve">
          <source>There are times where you only want Jest to search in a single sub-directory (such as cases where you have a &lt;code&gt;src/&lt;/code&gt; directory in your repo), but prevent it from accessing the rest of the repo.</source>
          <target state="translated">Бывают случаи, когда вы хотите, чтобы Jest выполнял поиск только в одном подкаталоге (например, в случаях, когда у вас есть каталог &lt;code&gt;src/&lt;/code&gt; в вашем репо), но не позволяйте ему получить доступ к остальной части репо.</target>
        </trans-unit>
        <trans-unit id="0b73bd505ade591eff51524741c24e46983c0ab6" translate="yes" xml:space="preserve">
          <source>There are two ways to mock functions: Either by creating a mock function to use in test code, or writing a &lt;a href=&quot;manual-mocks&quot;&gt;&lt;code&gt;manual mock&lt;/code&gt;&lt;/a&gt; to override a module dependency.</source>
          <target state="translated">Существует два способа имитации функций: либо путем создания имитационной функции для использования в тестовом коде, либо путем написания &lt;a href=&quot;manual-mocks&quot;&gt; &lt;code&gt;manual mock&lt;/code&gt; &lt;/a&gt; для переопределения зависимости модуля.</target>
        </trans-unit>
        <trans-unit id="cb812ec7da9105ae82712a4e1f280b3919c21f67" translate="yes" xml:space="preserve">
          <source>There is a less verbose way using &lt;code&gt;resolves&lt;/code&gt; to unwrap the value of a fulfilled promise together with any other matcher. If the promise is rejected, the assertion will fail.</source>
          <target state="translated">Существует менее подробный способ использования &lt;code&gt;resolves&lt;/code&gt; для раскрытия значения выполненного обещания вместе с любым другим сопоставителем. Если обещание отклонено, утверждение не будет выполнено.</target>
        </trans-unit>
        <trans-unit id="d3bc98afc16f0c3f67ba16dbd3f93d1dbca283cf" translate="yes" xml:space="preserve">
          <source>There is an alternate form of &lt;code&gt;test&lt;/code&gt; that fixes this. Instead of putting the test in a function with an empty argument, use a single argument called &lt;code&gt;done&lt;/code&gt;. Jest will wait until the &lt;code&gt;done&lt;/code&gt; callback is called before finishing the test.</source>
          <target state="translated">Это исправляет альтернативная форма &lt;code&gt;test&lt;/code&gt; . Вместо помещения теста в функцию с пустым аргументом используйте единственный аргумент с именем &lt;code&gt;done&lt;/code&gt; . Jest будет ждать, пока не будет вызван обратный вызов &lt;code&gt;done&lt;/code&gt; перед завершением теста.</target>
        </trans-unit>
        <trans-unit id="38513f64442e40688964ff51c98714e3662f0ad9" translate="yes" xml:space="preserve">
          <source>There's a caveat around snapshot testing when using Enzyme and React 16+. If you mock out a module using the following style:</source>
          <target state="translated">Существует предостережение по поводу тестирования снимков при использовании фермента и реакции 16+.Если вы высмеиваете модуль,используя следующий стиль:</target>
        </trans-unit>
        <trans-unit id="45969bbe3aaa0e36ec651be5c3c1e2bc6f21618e" translate="yes" xml:space="preserve">
          <source>There's no need to load any dependencies.</source>
          <target state="translated">Нет необходимости загружать какие-то зависимости.</target>
        </trans-unit>
        <trans-unit id="feaa8cf5e94e8af347c21dcc253b06efd78e08cf" translate="yes" xml:space="preserve">
          <source>There's no need to load any dependencies. Puppeteer's &lt;code&gt;page&lt;/code&gt; and &lt;code&gt;browser&lt;/code&gt; classes will automatically be exposed</source>
          <target state="translated">Нет необходимости загружать какие-либо зависимости. &lt;code&gt;page&lt;/code&gt; кукловода и классы &lt;code&gt;browser&lt;/code&gt; будут открыты автоматически</target>
        </trans-unit>
        <trans-unit id="205f02d2ffd73f73e820d056d16ae760c3445b0d" translate="yes" xml:space="preserve">
          <source>These helper functions and properties can be found on &lt;code&gt;this&lt;/code&gt; inside a custom matcher:</source>
          <target state="translated">Эти вспомогательные функции и свойства могут быть найдены на &lt;code&gt;this&lt;/code&gt; внутри пользовательской согласовани:</target>
        </trans-unit>
        <trans-unit id="6b60550c5bbaa39ef042c5fe44f0a413fa65b5bf" translate="yes" xml:space="preserve">
          <source>These matchers are sugar for common forms of inspecting the &lt;code&gt;.mock&lt;/code&gt; property. You can always do this manually yourself if that's more to your taste or if you need to do something more specific:</source>
          <target state="translated">Эти сопоставители являются сахаром для обычных форм проверки свойства &lt;code&gt;.mock&lt;/code&gt; . Вы всегда можете сделать это самостоятельно, если вам так больше нравится или вам нужно сделать что-то более конкретное:</target>
        </trans-unit>
        <trans-unit id="9d8fa2963a415398720fb864829eb323209ccbff" translate="yes" xml:space="preserve">
          <source>These mock members are very useful in tests to assert how these functions get called, instantiated, or what they returned:</source>
          <target state="translated">Эти члены инсценировки очень полезны в тестах,чтобы утверждать,как эти функции вызываются,инстанцируются,или что они возвращаются:</target>
        </trans-unit>
        <trans-unit id="421ccddd05618e2071d86e6bbbe14f0b2076576e" translate="yes" xml:space="preserve">
          <source>These options let you control Jest's behavior in your &lt;code&gt;package.json&lt;/code&gt; file. The Jest philosophy is to work great by default, but sometimes you just need more configuration power.</source>
          <target state="translated">Эти параметры позволяют контролировать поведение Jest в файле &lt;code&gt;package.json&lt;/code&gt; . Философия Jest заключается в том, чтобы по умолчанию работать отлично, но иногда вам просто нужно больше возможностей для настройки.</target>
        </trans-unit>
        <trans-unit id="fcaea31195ac296456fff13bc787d5eef5067d3d" translate="yes" xml:space="preserve">
          <source>These pattern strings match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories.</source>
          <target state="translated">Эти строки шаблона соответствуют полному пути. Используйте строковый токен &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; , чтобы включить путь к корневому каталогу вашего проекта, чтобы предотвратить его случайное игнорирование всех ваших файлов в разных средах, которые могут иметь разные корневые каталоги.</target>
        </trans-unit>
        <trans-unit id="17b10be41180956fbf5d08f1f6d6c3f7a2db71c5" translate="yes" xml:space="preserve">
          <source>These pattern strings match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/build/&quot;, &quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt;.</source>
          <target state="translated">Эти строки шаблона соответствуют полному пути. Используйте строковый токен &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; , чтобы включить путь к корневому каталогу вашего проекта, чтобы предотвратить его случайное игнорирование всех ваших файлов в разных средах, которые могут иметь разные корневые каталоги. Пример: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/build/&quot;, &quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="005b28d7accf90e223dee1c8e7ebc452b6213877" translate="yes" xml:space="preserve">
          <source>These pattern strings match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/build/&quot;]&lt;/code&gt;.</source>
          <target state="translated">Эти строки шаблона соответствуют полному пути. Используйте строковый токен &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; , чтобы включить путь к корневому каталогу вашего проекта, чтобы предотвратить его случайное игнорирование всех ваших файлов в разных средах, которые могут иметь разные корневые каталоги. Пример: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/build/&quot;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b61d73386d7f1dedf935b736a15ddf6e38555ac" translate="yes" xml:space="preserve">
          <source>These patterns match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt;.</source>
          <target state="translated">Эти шаблоны соответствуют полному пути. Используйте строковый токен &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; , чтобы включить путь к корневому каталогу вашего проекта, чтобы предотвратить его случайное игнорирование всех ваших файлов в разных средах, которые могут иметь разные корневые каталоги. Пример: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c464bdbe395120d407822fbb18f9738c9a02965a" translate="yes" xml:space="preserve">
          <source>Third-party plugins are also forbidden to overwrite a key reserved already by another third-party plugin present earlier in the configured plugins list (&lt;code&gt;watchPlugins&lt;/code&gt; array setting). When this happens, you&amp;rsquo;ll also get an error message that tries to help you fix that:</source>
          <target state="translated">Сторонним подключаемым &lt;code&gt;watchPlugins&lt;/code&gt; также запрещено перезаписывать ключ, уже зарезервированный другим сторонним подключаемым модулем, ранее присутствующим в настроенном списке подключаемых модулей ( параметр массива watchPlugins ). Когда это произойдет, вы также получите сообщение об ошибке, которое поможет вам исправить это:</target>
        </trans-unit>
        <trans-unit id="ea26b0157e1130ece50df7d1c6b1515a7cc72eba" translate="yes" xml:space="preserve">
          <source>This allows your test file to import the actual &lt;code&gt;Response&lt;/code&gt; object from &lt;code&gt;node-fetch&lt;/code&gt;, rather than a mocked version. This means the test will now pass correctly.</source>
          <target state="translated">Это позволяет вашему тестовому файлу импортировать фактический объект &lt;code&gt;Response&lt;/code&gt; из &lt;code&gt;node-fetch&lt;/code&gt; , а не имитируемую версию. Это означает, что теперь тест пройдет правильно.</target>
        </trans-unit>
        <trans-unit id="6c57d62e399034f0a7b381de3e7d5f645f9ad504" translate="yes" xml:space="preserve">
          <source>This ensures that a value matches the most recent snapshot. Check out &lt;a href=&quot;snapshot-testing&quot;&gt;the Snapshot Testing guide&lt;/a&gt; for more information.</source>
          <target state="translated">Это гарантирует, что значение соответствует самому последнему снимку. Ознакомьтесь &lt;a href=&quot;snapshot-testing&quot;&gt;с руководством&lt;/a&gt; по тестированию снимков для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="dac9e840fc23ac31d800f8538975040bb9ecac74" translate="yes" xml:space="preserve">
          <source>This example also shows how you can nest multiple asymmetric matchers, with &lt;code&gt;expect.stringMatching&lt;/code&gt; inside the &lt;code&gt;expect.arrayContaining&lt;/code&gt;.</source>
          <target state="translated">В этом примере также показано, как можно вложить несколько асимметричных сопоставителей с &lt;code&gt;expect.stringMatching&lt;/code&gt; внутри &lt;code&gt;expect.arrayContaining&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b58eb0d982c4ebd2168b0b47532f786470fd666" translate="yes" xml:space="preserve">
          <source>This example configuration will run Jest in the root directory as well as in every folder in the examples directory. You can have an unlimited amount of projects running in the same Jest instance.</source>
          <target state="translated">Эта конфигурация примера запустит Jest в корневом каталоге,а также в каждой папке в каталоге примеров.Вы можете иметь неограниченное количество проектов,запущенных в одном и том же экземпляре Jest.</target>
        </trans-unit>
        <trans-unit id="07d5008923646b5de183b191e7806d1642e368f2" translate="yes" xml:space="preserve">
          <source>This is a deep-equality function that will return &lt;code&gt;true&lt;/code&gt; if two objects have the same values (recursively).</source>
          <target state="translated">Это функция глубокого равенства, которая вернет &lt;code&gt;true&lt;/code&gt; если два объекта имеют одинаковые значения (рекурсивно).</target>
        </trans-unit>
        <trans-unit id="8787606ea91f4fa45b63964dfe671fe216f1f18b" translate="yes" xml:space="preserve">
          <source>This is especially useful for checking arrays or strings size.</source>
          <target state="translated">Это особенно полезно для проверки размера массивов или строк.</target>
        </trans-unit>
        <trans-unit id="daedbdf3b3c492eb985c9a318c876db267766311" translate="yes" xml:space="preserve">
          <source>This is how &lt;code&gt;createMockFromModule&lt;/code&gt; will mock the following data types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6bb81a22b9aea2dc501ec88e58677f39b608e1" translate="yes" xml:space="preserve">
          <source>This is how &lt;code&gt;genMockFromModule&lt;/code&gt; will mock the following data types:</source>
          <target state="translated">Вот как &lt;code&gt;genMockFromModule&lt;/code&gt; имитирует следующие типы данных:</target>
        </trans-unit>
        <trans-unit id="3773feba2fd857753eb4d289910186bb5075a5d0" translate="yes" xml:space="preserve">
          <source>This is just a taste. For a complete list of matchers, check out the &lt;a href=&quot;expect&quot;&gt;reference docs&lt;/a&gt;.</source>
          <target state="translated">Это просто вкус. Полный список сопоставителей можно найти в &lt;a href=&quot;expect&quot;&gt;справочной документации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b91b6036665a31c72c932de515d167cc3324bf18" translate="yes" xml:space="preserve">
          <source>This is often useful for synchronously executing setTimeouts during a test in order to synchronously assert about some behavior that would only happen after the &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval()&lt;/code&gt; callbacks executed. See the &lt;a href=&quot;timer-mocks&quot;&gt;Timer mocks&lt;/a&gt; doc for more information.</source>
          <target state="translated">Это часто полезно для синхронного выполнения setTimeout во время теста, чтобы синхронно утверждать о некотором поведении, которое могло бы произойти только после выполнения обратных вызовов &lt;code&gt;setTimeout()&lt;/code&gt; или &lt;code&gt;setInterval()&lt;/code&gt; . Дополнительную информацию см. В документации по &lt;a href=&quot;timer-mocks&quot;&gt;фиксации таймера&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7d7c1519ae2cf4a773f1afd649832547d401f24" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to clean up some global setup state that is shared across tests.</source>
          <target state="translated">Это часто полезно,если вы хотите очистить некоторое состояние глобальной установки,которое является общим для всех тестов.</target>
        </trans-unit>
        <trans-unit id="f38502aacbc947736082f8a6708a41145ca79655" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to clean up some temporary state that is created by each test.</source>
          <target state="translated">Это часто бывает полезно,если вы хотите очистить какое-то временное состояние,которое создается каждым тестом.</target>
        </trans-unit>
        <trans-unit id="f0881bf0bef2a66191cfe13dc0ddb9fc67b1b880" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to reset some global state that will be used by many tests.</source>
          <target state="translated">Это часто полезно,если вы хотите сбросить некоторое глобальное состояние,которое будет использоваться многими тестами.</target>
        </trans-unit>
        <trans-unit id="c9eaf0b51489505b8e52db0ac5e52495ccfe19ba" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to set up some global state that will be used by many tests.</source>
          <target state="translated">Это часто полезно,если вы хотите установить некое глобальное состояние,которое будет использоваться многими тестами.</target>
        </trans-unit>
        <trans-unit id="72cca58df7454651ff7a323dceaea7ab640b298b" translate="yes" xml:space="preserve">
          <source>This is useful for scenarios such as one where the module being tested schedules a &lt;code&gt;setTimeout()&lt;/code&gt; whose callback schedules another &lt;code&gt;setTimeout()&lt;/code&gt; recursively (meaning the scheduling never stops). In these scenarios, it's useful to be able to run forward in time by a single step at a time.</source>
          <target state="translated">Это полезно для таких сценариев, как тот, где тестируемый модуль планирует &lt;code&gt;setTimeout()&lt;/code&gt; чей обратный вызов планирует другой &lt;code&gt;setTimeout()&lt;/code&gt; рекурсивно (что означает, что планирование никогда не прекращается). В этих сценариях полезно иметь возможность двигаться вперед во времени на один шаг за раз.</target>
        </trans-unit>
        <trans-unit id="3a5ea63e8ffdad93e9fef81bb115e6f5cff87758" translate="yes" xml:space="preserve">
          <source>This is useful for some commonly used 'utility' modules that are almost always used as implementation details almost all the time (like underscore/lo-dash, etc). It's generally a best practice to keep this list as small as possible and always use explicit &lt;code&gt;jest.mock()&lt;/code&gt;/&lt;code&gt;jest.unmock()&lt;/code&gt; calls in individual tests. Explicit per-test setup is far easier for other readers of the test to reason about the environment the test will run in.</source>
          <target state="translated">Это полезно для некоторых часто используемых &amp;laquo;служебных&amp;raquo; модулей, которые почти всегда используются в качестве деталей реализации почти все время (например, подчеркивание / нижнее тире и т. Д.). Обычно рекомендуется сохранять этот список как можно меньше и всегда использовать явные &lt;code&gt;jest.mock()&lt;/code&gt; / &lt;code&gt;jest.unmock()&lt;/code&gt; в отдельных тестах. Явная настройка для каждого теста намного проще для других читателей теста, чтобы понять, в какой среде будет выполняться тест.</target>
        </trans-unit>
        <trans-unit id="511f2fbaf8920a0608d26d5165905f63a5d73c88" translate="yes" xml:space="preserve">
          <source>This is useful when you want to completely reset a &lt;em&gt;mock&lt;/em&gt; back to its initial state. (Note that resetting a &lt;em&gt;spy&lt;/em&gt; will result in a function with no return value).</source>
          <target state="translated">Это полезно, когда вы хотите полностью сбросить &lt;em&gt;макет&lt;/em&gt; обратно в исходное состояние. (Обратите внимание, что сброс &lt;em&gt;шпиона&lt;/em&gt; приведет к функции без возвращаемого значения).</target>
        </trans-unit>
        <trans-unit id="c8d37ce85710fb471d0b215386de8769da78ab05" translate="yes" xml:space="preserve">
          <source>This is useful when you want to create a &lt;a href=&quot;manual-mocks&quot;&gt;manual mock&lt;/a&gt; that extends the automatic mock's behavior.</source>
          <target state="translated">Это полезно, когда вы хотите создать &lt;a href=&quot;manual-mocks&quot;&gt;ручной макет,&lt;/a&gt; который расширяет поведение автоматического макета.</target>
        </trans-unit>
        <trans-unit id="d837db43e33775ed71a2885c71c5a5602ed7202b" translate="yes" xml:space="preserve">
          <source>This is useful when you want to mock functions in certain test cases and restore the original implementation in others.</source>
          <target state="translated">Это полезно,когда вы хотите подделывать функции в одних тестовых случаях и восстанавливать оригинальную реализацию в других.</target>
        </trans-unit>
        <trans-unit id="990db4730f558f16c2dc74a09c332aa10da16053" translate="yes" xml:space="preserve">
          <source>This is usually useful when you have a scenario where the number of dependencies you want to mock is far less than the number of dependencies that you don't. For example, if you're writing a test for a module that uses a large number of dependencies that can be reasonably classified as &quot;implementation details&quot; of the module, then you likely do not want to mock them.</source>
          <target state="translated">Это обычно полезно,когда у вас есть сценарий,в котором количество зависимостей,над которыми вы хотите посмеяться,намного меньше,чем количество зависимостей,которых у вас нет.Например,если вы пишете тест для модуля,который использует большое количество зависимостей,которые можно обоснованно классифицировать как &quot;детали реализации&quot; модуля,то вы,скорее всего,не захотите над ними насмехаться.</target>
        </trans-unit>
        <trans-unit id="2cd58fa126aba532c56c9309e162bd465bef920f" translate="yes" xml:space="preserve">
          <source>This isn't required - you can write the &lt;code&gt;test&lt;/code&gt; blocks directly at the top level. But this can be handy if you prefer your tests to be organized into groups.</source>
          <target state="translated">Это не обязательно - вы можете писать &lt;code&gt;test&lt;/code&gt; блоки прямо на верхнем уровне. Но это может быть удобно, если вы предпочитаете организовывать тесты в группы.</target>
        </trans-unit>
        <trans-unit id="bc38e9460c76ac869bfb97b729c4bebd9601d3e9" translate="yes" xml:space="preserve">
          <source>This matcher also accepts a string, which it will try to match:</source>
          <target state="translated">Этот матчер также принимает строку,которую он попытается сопоставить:</target>
        </trans-unit>
        <trans-unit id="35176ec62e10ad24d9e5bf5b4f422f755d6dc150" translate="yes" xml:space="preserve">
          <source>This means, if any timers have been scheduled (but have not yet executed), they will be cleared and will never have the opportunity to execute in the future.</source>
          <target state="translated">Это означает,что если какие-либо таймеры были запланированы (но еще не выполнены),они будут очищены и у них никогда не будет возможности выполнить их в будущем.</target>
        </trans-unit>
        <trans-unit id="688cc7c951b98d9e176b0ce89e8ee57961515438" translate="yes" xml:space="preserve">
          <source>This option allow comments in &lt;code&gt;package.json&lt;/code&gt;. Include the comment text as the value of this key anywhere in &lt;code&gt;package.json&lt;/code&gt;.</source>
          <target state="translated">Эта опция разрешает комментарии в &lt;code&gt;package.json&lt;/code&gt; . Включите текст комментария в качестве значения этого ключа в любом месте &lt;code&gt;package.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e53db60be3e9be7e40274cb356ffc5b833ed548f" translate="yes" xml:space="preserve">
          <source>This option allows comments in &lt;code&gt;package.json&lt;/code&gt;. Include the comment text as the value of this key anywhere in &lt;code&gt;package.json&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f12b52eb11d088de9a4fec28160df38ac92acd" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom dependency extractor. It must be a node module that exports an object with an &lt;code&gt;extract&lt;/code&gt; function. E.g.:</source>
          <target state="translated">Этот параметр позволяет использовать настраиваемый экстрактор зависимостей. Это должен быть модуль узла, который экспортирует объект с функцией &lt;code&gt;extract&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="7387fe3f611db301893ec5bf7cc4bbe625475ab6" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom global setup module which exports an async function that is triggered once before all test suites. This function gets Jest's &lt;code&gt;globalConfig&lt;/code&gt; object as a parameter.</source>
          <target state="translated">Этот параметр позволяет использовать настраиваемый модуль глобальной настройки, который экспортирует асинхронную функцию, которая запускается один раз перед всеми наборами тестов. Эта функция получает в качестве параметра объект Jest &lt;code&gt;globalConfig&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f462a8db0f13013cff3f25a99166d1df5cc7a9d9" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom global teardown module which exports an async function that is triggered once after all test suites. This function gets Jest's &lt;code&gt;globalConfig&lt;/code&gt; object as a parameter.</source>
          <target state="translated">Этот параметр позволяет использовать настраиваемый модуль глобального разрыва, который экспортирует асинхронную функцию, которая запускается один раз после всех наборов тестов. Эта функция получает в качестве параметра объект Jest &lt;code&gt;globalConfig&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38a9ab5d714461ae4a524d403260c43d23431747" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom resolver. This resolver must be a node module that exports a function expecting a string as the first argument for the path to resolve and an object with the following structure as the second argument:</source>
          <target state="translated">Эта опция позволяет использовать пользовательский резольвер.Этот резольвер должен быть узловым модулем,который экспортирует функцию,ожидающую строку в качестве первого аргумента пути разрешения,и объект со следующей структурой в качестве второго аргумента:</target>
        </trans-unit>
        <trans-unit id="840ac7a9f3696ee6876dcc9f096bc867ff39672e" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom results processor. This processor must be a node module that exports a function expecting an object with the following structure as the first argument and return it:</source>
          <target state="translated">Эта опция позволяет использовать пользовательский процессор обработки результатов.Этот процессор должен быть узловым модулем,который экспортирует функцию,ожидающую объект со следующей структурой в качестве первого аргумента и возвращает его:</target>
        </trans-unit>
        <trans-unit id="5252ecd1f3fe162f8ab624586087da822d3f2adb" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom test runner. The default is jasmine2. A custom test runner can be provided by specifying a path to a test runner implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551495954b791bddca5765dca30e41d9a29511c6" translate="yes" xml:space="preserve">
          <source>This option allows use of a custom test runner. The default is jasmine2. A custom test runner can be provided by specifying a path to a test runner implementation.</source>
          <target state="translated">Эта опция позволяет использовать пользовательский тестовый бегунок.По умолчанию используется жасмин2.Пользовательский тестовый бегунок может быть предоставлен путем указания пути к реализации тестового бегунка.</target>
        </trans-unit>
        <trans-unit id="44d88dc72d1af311d80a8540431e21118807550c" translate="yes" xml:space="preserve">
          <source>This option allows you to use a custom runner instead of Jest's default test runner. Examples of runners include:</source>
          <target state="translated">Эта опция позволяет вам использовать пользовательский бегунок вместо стандартного тестового бегунка Jest.Примеры бегунов включают в себя:</target>
        </trans-unit>
        <trans-unit id="f5d6d08e3a74b9984da0a1564cf8f546a76f4a82" translate="yes" xml:space="preserve">
          <source>This option allows you to use a custom sequencer instead of Jest's default. &lt;code&gt;sort&lt;/code&gt; may optionally return a Promise.</source>
          <target state="translated">Эта опция позволяет вам использовать собственный секвенсор вместо стандартного Jest. &lt;code&gt;sort&lt;/code&gt; может при желании вернуть Promise.</target>
        </trans-unit>
        <trans-unit id="c90ce340f3088fe9972394e67acc0935ff513e5d" translate="yes" xml:space="preserve">
          <source>This option allows you to use a custom watch plugins. Read more about watch plugins &lt;a href=&quot;watch-plugins&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Этот параметр позволяет использовать настраиваемые плагины для просмотра. Подробнее о плагинах для часов читайте &lt;a href=&quot;watch-plugins&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01827b8a7366fbc8b3065a863a5d386474ea1e78" translate="yes" xml:space="preserve">
          <source>This option allows you to use custom watch plugins. Read more about watch plugins &lt;a href=&quot;watch-plugins&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a29c38f33c668ab5c982f199af3ff02856c863a" translate="yes" xml:space="preserve">
          <source>This option sets the URL for the jsdom environment. It is reflected in properties such as &lt;code&gt;location.href&lt;/code&gt;.</source>
          <target state="translated">Эта опция устанавливает URL-адрес для среды jsdom. Это отражается в таких свойствах, как &lt;code&gt;location.href&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6bd84ad18e9b644594d518b7f4d72e5c10823c4" translate="yes" xml:space="preserve">
          <source>This option tells Jest that all imported modules in your tests should be mocked automatically. All modules used in your tests will have a replacement implementation, keeping the API surface.</source>
          <target state="translated">Эта опция сообщает Jest,что все импортированные модули в ваших тестах должны быть автоматически высмеяны.Все модули,используемые в ваших тестах,будут иметь запасную реализацию,сохраняя поверхность API.</target>
        </trans-unit>
        <trans-unit id="98e2dcf1f1c275210f7dbe5eb1535d1ff6f9f4c3" translate="yes" xml:space="preserve">
          <source>This shouldn't normally be your option of choice as useful warnings could be lost. However, in some cases, for example when testing react-native's components we are rendering react-native tags into the DOM and many warnings are irrelevant. Another option is to swizzle the console.warn and suppress specific warnings.</source>
          <target state="translated">Обычно это не должно быть вашим выбором,так как полезные предупреждения могут быть потеряны.Однако,в некоторых случаях,например,при тестировании компонентов react-native,мы визуализируем теги react-native в DOM,и многие предупреждения не имеют отношения к делу.Другим вариантом является пролистывание console.warning и подавление конкретных предупреждений.</target>
        </trans-unit>
        <trans-unit id="360362a3cbe9313d68d1cf19949c3804d1f4ed87" translate="yes" xml:space="preserve">
          <source>This test used &lt;code&gt;expect&lt;/code&gt; and &lt;code&gt;toBe&lt;/code&gt; to test that two values were exactly identical. To learn about the other things that Jest can test, see &lt;a href=&quot;using-matchers&quot;&gt;Using Matchers&lt;/a&gt;.</source>
          <target state="translated">В этом тесте использовали &lt;code&gt;expect&lt;/code&gt; и &lt;code&gt;toBe&lt;/code&gt; для проверки идентичности двух значений. Чтобы узнать о других вещах, которые может тестировать Jest, см. &lt;a href=&quot;using-matchers&quot;&gt;Использование сопоставителей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6e9bf3c4c1c53fe256faefd1ca6b822f3ed81ba" translate="yes" xml:space="preserve">
          <source>This will add a line in the watch mode menu &lt;em&gt;(&lt;code&gt;&amp;rsaquo; Press s to do something.&lt;/code&gt;)&lt;/em&gt;</source>
          <target state="translated">Это добавит строку в меню режима часов &lt;em&gt;( &lt;code&gt;&amp;rsaquo; Press s to do something.&lt;/code&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5f973bafbc6c9d08f6e504faea0ed8253ab2995f" translate="yes" xml:space="preserve">
          <source>This will be used to configure minimum threshold enforcement for coverage results. Thresholds can be specified as &lt;code&gt;global&lt;/code&gt;, as a &lt;a href=&quot;https://github.com/isaacs/node-glob#glob-primer&quot;&gt;glob&lt;/a&gt;, and as a directory or file path. If thresholds aren't met, jest will fail. Thresholds specified as a positive number are taken to be the minimum percentage required. Thresholds specified as a negative number represent the maximum number of uncovered entities allowed.</source>
          <target state="translated">Это будет использоваться для настройки минимального порогового значения для результатов покрытия. Пороговые значения могут быть указаны как &lt;code&gt;global&lt;/code&gt; , как &lt;a href=&quot;https://github.com/isaacs/node-glob#glob-primer&quot;&gt;глобус&lt;/a&gt; , а также как путь к каталогу или файлу. Если пороговые значения не достигнуты, шутка не удастся. Пороговые значения, заданные как положительное число, принимаются за минимально необходимый процент. Пороговые значения, указанные как отрицательное число, представляют максимально допустимое количество непокрытых объектов.</target>
        </trans-unit>
        <trans-unit id="57f790c5005121416e8c2fd8ea8acb72b8b2e025" translate="yes" xml:space="preserve">
          <source>This will be used to configure the behavior of &lt;code&gt;jest-haste-map&lt;/code&gt;, Jest's internal file crawler/cache system. The following options are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b781fa5a1c5086d94b94b3ea9ed32876793c2c2" translate="yes" xml:space="preserve">
          <source>This will collect coverage information for all the files inside the project's &lt;code&gt;rootDir&lt;/code&gt;, except the ones that match &lt;code&gt;**/node_modules/**&lt;/code&gt; or &lt;code&gt;**/vendor/**&lt;/code&gt;.</source>
          <target state="translated">Это будет собирать информацию о покрытии для всех файлов внутри &lt;code&gt;rootDir&lt;/code&gt; проекта , кроме тех, которые соответствуют &lt;code&gt;**/node_modules/**&lt;/code&gt; или &lt;code&gt;**/vendor/**&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90cf7fb35e518c105a5552c6219ed3a42ba97b15" translate="yes" xml:space="preserve">
          <source>This will let us inspect usage of our mocked class, using &lt;code&gt;SoundPlayer.mock.calls&lt;/code&gt;: &lt;code&gt;expect(SoundPlayer).toHaveBeenCalled();&lt;/code&gt; or near-equivalent: &lt;code&gt;expect(SoundPlayer.mock.calls.length).toEqual(1);&lt;/code&gt;</source>
          <target state="translated">Это позволит нам проверить использование нашего &lt;code&gt;SoundPlayer.mock.calls&lt;/code&gt; класса, используя SoundPlayer.mock.calls : &lt;code&gt;expect(SoundPlayer).toHaveBeenCalled();&lt;/code&gt; или почти эквивалентный: &lt;code&gt;expect(SoundPlayer.mock.calls.length).toEqual(1);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="209071c8d9163c6dfec4225f989d2e729c2933ea" translate="yes" xml:space="preserve">
          <source>This will override default reporters:</source>
          <target state="translated">Это переопределит репортеры по умолчанию:</target>
        </trans-unit>
        <trans-unit id="1ce9f7467129f03386e85416d9a79207d3f3cd66" translate="yes" xml:space="preserve">
          <source>This will print something like this:</source>
          <target state="translated">Это напечатает что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="0128c1ff802183c48e311ffffeefd6c4c9feb5e7" translate="yes" xml:space="preserve">
          <source>This will render the component as &lt;code&gt;&amp;lt;Video {...props} /&amp;gt;&lt;/code&gt; with all of its props in the snapshot output. See also &lt;a href=&quot;tutorial-react#snapshot-testing-with-mocks-enzyme-and-react-16&quot;&gt;caveats around Enzyme and React 16&lt;/a&gt;.</source>
          <target state="translated">Это отобразит компонент как &lt;code&gt;&amp;lt;Video {...props} /&amp;gt;&lt;/code&gt; со всеми его свойствами в выводе моментального снимка. См. Также &lt;a href=&quot;tutorial-react#snapshot-testing-with-mocks-enzyme-and-react-16&quot;&gt;предостережения относительно Enzyme и React 16&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="031037a615f9d64385b25800b6c16eb718e695ad" translate="yes" xml:space="preserve">
          <source>This will run Jest in a Node process that an external debugger can connect to. Note that the process will pause until the debugger has connected to it.</source>
          <target state="translated">При этом будет запущен Jest в процессе Node,к которому может подключиться внешний отладчик.Обратите внимание,что процесс будет приостановлен до тех пор,пока отладчик не подключится к нему.</target>
        </trans-unit>
        <trans-unit id="ff1252de72d76270d68e2df9f8a951026c2b21af" translate="yes" xml:space="preserve">
          <source>This will throw &lt;strong&gt;&lt;em&gt;TypeError: _soundPlayer2.default is not a constructor&lt;/em&gt;&lt;/strong&gt;, unless the code is transpiled to ES5, e.g. by &lt;code&gt;@babel/preset-env&lt;/code&gt;. (ES5 doesn't have arrow functions nor classes, so both will be transpiled to plain functions.)</source>
          <target state="translated">Это вызовет &lt;strong&gt;&lt;em&gt;ошибку TypeError: _soundPlayer2.default не является конструктором&lt;/em&gt;&lt;/strong&gt; , если код не передан в ES5, например, &lt;code&gt;@babel/preset-env&lt;/code&gt; . (ES5 не имеет функций стрелок или классов, поэтому оба они будут перенесены в простые функции.)</target>
        </trans-unit>
        <trans-unit id="a06ab4358a87cc38d323a6fe966b85af4c53ee66" translate="yes" xml:space="preserve">
          <source>This will use custom reporter in addition to default reporters that Jest provides:</source>
          <target state="translated">При этом будет использоваться пользовательский репортер в дополнение к стандартным репортерам,которые предоставляет Jest:</target>
        </trans-unit>
        <trans-unit id="5c615ded93f646fc52958cfb01c7b4ab285ef4d0" translate="yes" xml:space="preserve">
          <source>This works if &lt;code&gt;window.matchMedia()&lt;/code&gt; is used in a function (or method) which is invoked in the test. If &lt;code&gt;window.matchMedia()&lt;/code&gt; is executed directly in the tested file, Jest reports the same error. In this case, the solution is to move the manual mock into a separate file and include this one in the test &lt;strong&gt;before&lt;/strong&gt; the tested file:</source>
          <target state="translated">Это работает, если &lt;code&gt;window.matchMedia()&lt;/code&gt; используется в функции (или методе), которая вызывается в тесте. Если &lt;code&gt;window.matchMedia()&lt;/code&gt; выполняется непосредственно в тестируемом файле, Jest сообщает о той же ошибке. В этом случае решение состоит в том, чтобы переместить ручной макет в отдельный файл и включить его в тест &lt;strong&gt;перед&lt;/strong&gt; тестируемым файлом:</target>
        </trans-unit>
        <trans-unit id="0bce8231bb2ded7244230db592d5f3864c807820" translate="yes" xml:space="preserve">
          <source>Timer Mocks</source>
          <target state="translated">Таймеры-издевательства</target>
        </trans-unit>
        <trans-unit id="4cf1b54b003a59c279d1ba0b615a8a5f3459ca8c" translate="yes" xml:space="preserve">
          <source>Tips</source>
          <target state="translated">Tips</target>
        </trans-unit>
        <trans-unit id="2ae1e08337e0c3fff9724e42846cabe84620ef36" translate="yes" xml:space="preserve">
          <source>To add a key to the watch menu, implement the &lt;code&gt;getUsageInfo&lt;/code&gt; method, returning a key and the prompt:</source>
          <target state="translated">Чтобы добавить ключ в меню часов, &lt;code&gt;getUsageInfo&lt;/code&gt; метод getUsageInfo , возвращающий ключ и приглашение:</target>
        </trans-unit>
        <trans-unit id="47b39578e06150847a8bca907a560548f45db25e" translate="yes" xml:space="preserve">
          <source>To attach the built-in debugger, run your tests as aforementioned:</source>
          <target state="translated">Чтобы подключить встроенный отладчик,запустите тесты,как описано выше:</target>
        </trans-unit>
        <trans-unit id="ecb87b5a4ec9578d9ae035bd9525d7f9a0bbc2d6" translate="yes" xml:space="preserve">
          <source>To automatically launch and attach to a process running your tests, use the following configuration:</source>
          <target state="translated">Чтобы автоматически запустить и подключиться к процессу,выполняющему ваши тесты,используйте следующую конфигурацию:</target>
        </trans-unit>
        <trans-unit id="8ef0aac5dc160f7cae3d13500ae91ad9928ac0f1" translate="yes" xml:space="preserve">
          <source>To build your own please visit the &lt;a href=&quot;tutorial-react#custom-transformers&quot;&gt;Custom Transformer&lt;/a&gt; section</source>
          <target state="translated">Чтобы создать свой собственный, посетите раздел &lt;a href=&quot;tutorial-react#custom-transformers&quot;&gt;Custom Transformer.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aacf02378e2b38f25b6b3e4a83d574f8e35ceb32" translate="yes" xml:space="preserve">
          <source>To clear the record of calls to the mock constructor function and its methods, we call &lt;a href=&quot;mock-function-api#mockfnmockclear&quot;&gt;&lt;code&gt;mockClear()&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;beforeEach()&lt;/code&gt; function:</source>
          <target state="translated">Чтобы очистить запись вызовов функции макетного конструктора и ее методов, мы вызываем &lt;a href=&quot;mock-function-api#mockfnmockclear&quot;&gt; &lt;code&gt;mockClear()&lt;/code&gt; &lt;/a&gt; в функции &lt;code&gt;beforeEach()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bbcbbcf6e6e23076d275df0fe406a4a0a2189298" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeGreaterThan&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of more than 10 ounces, write:</source>
          <target state="translated">Для сравнения чисел с плавающей запятой вы можете использовать &lt;code&gt;toBeGreaterThan&lt;/code&gt; . Например, если вы хотите проверить, что &lt;code&gt;ouncesPerCan()&lt;/code&gt; возвращает значение более 10 унций, напишите:</target>
        </trans-unit>
        <trans-unit id="f788e1ff5eca8835f05697583466e13f0b6a83d4" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeGreaterThanOrEqual&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of at least 12 ounces, write:</source>
          <target state="translated">Для сравнения чисел с плавающей запятой вы можете использовать &lt;code&gt;toBeGreaterThanOrEqual&lt;/code&gt; . Например, если вы хотите проверить, что &lt;code&gt;ouncesPerCan()&lt;/code&gt; возвращает значение не менее 12 унций, напишите:</target>
        </trans-unit>
        <trans-unit id="3630a179a57250195ccd7b5b31b4f9f6faacbab0" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeLessThan&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of less than 20 ounces, write:</source>
          <target state="translated">Для сравнения чисел с плавающей запятой вы можете использовать &lt;code&gt;toBeLessThan&lt;/code&gt; . Например, если вы хотите проверить, что &lt;code&gt;ouncesPerCan()&lt;/code&gt; возвращает значение менее 20 унций, напишите:</target>
        </trans-unit>
        <trans-unit id="7bc35d8ccb0dac837113cbb13a4a6a626da1b19b" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeLessThanOrEqual&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of at most 12 ounces, write:</source>
          <target state="translated">Для сравнения чисел с плавающей запятой вы можете использовать &lt;code&gt;toBeLessThanOrEqual&lt;/code&gt; . Например, если вы хотите проверить, что &lt;code&gt;ouncesPerCan()&lt;/code&gt; возвращает значение не более 12 унций, напишите:</target>
        </trans-unit>
        <trans-unit id="8488371ee9451e1b8abe49379e43d2abac066b15" translate="yes" xml:space="preserve">
          <source>To connect your watch plugin to Jest, add its path under &lt;code&gt;watchPlugins&lt;/code&gt; in your Jest configuration:</source>
          <target state="translated">Чтобы подключить ваш плагин часов к Jest, добавьте его путь в &lt;code&gt;watchPlugins&lt;/code&gt; в вашей конфигурации Jest:</target>
        </trans-unit>
        <trans-unit id="c020af932b115a7543d8e80249a02617ab77e279" translate="yes" xml:space="preserve">
          <source>To debug in Google Chrome (or any Chromium-based browser), open your browser and go to &lt;code&gt;chrome://inspect&lt;/code&gt; and click on &quot;Open Dedicated DevTools for Node&quot;, which will give you a list of available node instances you can connect to. Click on the address displayed in the terminal (usually something like &lt;code&gt;localhost:9229&lt;/code&gt;) after running the above command, and you will be able to debug Jest using Chrome's DevTools.</source>
          <target state="translated">Для отладки в Google Chrome (или в любом браузере на основе Chromium) откройте свой браузер, перейдите на страницу &lt;code&gt;chrome://inspect&lt;/code&gt; и нажмите &amp;laquo;Открыть выделенные инструменты разработки для узла&amp;raquo;, что даст вам список доступных экземпляров узлов, к которым вы можете подключиться. , Щелкните адрес, отображаемый в терминале (обычно что-то вроде &lt;code&gt;localhost:9229&lt;/code&gt; ) после выполнения указанной выше команды, и вы сможете отлаживать Jest с помощью Chrome DevTools.</target>
        </trans-unit>
        <trans-unit id="b40318402328b187f84e5d748dc7567c2272d612" translate="yes" xml:space="preserve">
          <source>To enable async/await in your project, install &lt;a href=&quot;https://babeljs.io/docs/en/babel-preset-env&quot;&gt;&lt;code&gt;@babel/preset-env&lt;/code&gt;&lt;/a&gt; and enable the feature in your &lt;code&gt;babel.config.js&lt;/code&gt; file.</source>
          <target state="translated">Чтобы включить async / await в вашем проекте, установите &lt;a href=&quot;https://babeljs.io/docs/en/babel-preset-env&quot;&gt; &lt;code&gt;@babel/preset-env&lt;/code&gt; &lt;/a&gt; и включите эту функцию в вашем файле &lt;code&gt;babel.config.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="302ab4340db66b28bf4eeafaae3f85ad66b05f81" translate="yes" xml:space="preserve">
          <source>To ensure that a manual mock and its real implementation stay in sync, it might be useful to require the real module using &lt;a href=&quot;jest-object#jestrequireactualmodulename&quot;&gt;&lt;code&gt;jest.requireActual(moduleName)&lt;/code&gt;&lt;/a&gt; in your manual mock and amending it with mock functions before exporting it.</source>
          <target state="translated">Чтобы гарантировать синхронизацию ручного макета и его реальной реализации, может быть полезно потребовать настоящий модуль с помощью &lt;a href=&quot;jest-object#jestrequireactualmodulename&quot;&gt; &lt;code&gt;jest.requireActual(moduleName)&lt;/code&gt; &lt;/a&gt; в вашем ручном макете и изменить его с помощью макетных функций перед его экспортом.</target>
        </trans-unit>
        <trans-unit id="d68306f89da229b2b38be29155f82cf63d2fefff" translate="yes" xml:space="preserve">
          <source>To get around problems like this, Jest provides the &lt;code&gt;jest.requireActual&lt;/code&gt; helper. To make the above test work, make the following change to the imports in the test file:</source>
          <target state="translated">Чтобы обойти подобные проблемы, Jest предоставляет помощник &lt;code&gt;jest.requireActual&lt;/code&gt; . Чтобы вышеуказанный тест работал, внесите следующие изменения в импорт в тестовом файле:</target>
        </trans-unit>
        <trans-unit id="11fabe8d8570a5bb7d31d77eddfbad12fd7006ea" translate="yes" xml:space="preserve">
          <source>To handle key press events from the key returned by &lt;code&gt;getUsageInfo&lt;/code&gt;, you can implement the &lt;code&gt;run&lt;/code&gt; method. This method returns a &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; that can be resolved when the plugin wants to return control to Jest. The &lt;code&gt;boolean&lt;/code&gt; specifies if Jest should rerun the tests after it gets the control back.</source>
          <target state="translated">Чтобы обрабатывать события нажатия клавиш из клавиши, возвращаемой &lt;code&gt;getUsageInfo&lt;/code&gt; , вы можете реализовать метод &lt;code&gt;run&lt;/code&gt; . Этот метод возвращает &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; которое может быть разрешено, когда плагин хочет вернуть управление Jest. В &lt;code&gt;boolean&lt;/code&gt; определяет , будет ли Шутки должны повторно испытания после того, как он получает управление обратно.</target>
        </trans-unit>
        <trans-unit id="90daa538926bb277438f39b2435beb57540f0d66" translate="yes" xml:space="preserve">
          <source>To inject nested object values use you can supply a keyPath i.e. &lt;code&gt;$variable.path.to.value&lt;/code&gt;</source>
          <target state="translated">Чтобы ввести значения вложенных объектов, вы можете указать keyPath, т.е. &lt;code&gt;$variable.path.to.value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="970630451f28f37da628f2cf8fe84113808b5a54" translate="yes" xml:space="preserve">
          <source>To make a dependency explicit instead of implicit, you can call &lt;a href=&quot;expect#expectaddsnapshotserializerserializer&quot;&gt;&lt;code&gt;expect.addSnapshotSerializer&lt;/code&gt;&lt;/a&gt; to add a module for an individual test file instead of adding its path to &lt;code&gt;snapshotSerializers&lt;/code&gt; in Jest configuration.</source>
          <target state="translated">Чтобы сделать зависимость явной, а не неявной, вы можете вызвать &lt;a href=&quot;expect#expectaddsnapshotserializerserializer&quot;&gt; &lt;code&gt;expect.addSnapshotSerializer&lt;/code&gt; ,&lt;/a&gt; чтобы добавить модуль для отдельного тестового файла вместо добавления его пути к &lt;code&gt;snapshotSerializers&lt;/code&gt; в конфигурации Jest.</target>
        </trans-unit>
        <trans-unit id="7cd5137812be95f283926c769870dc2156199426" translate="yes" xml:space="preserve">
          <source>To make this work with Jest you need to update your Jest configuration with this: &lt;code&gt;&quot;transform&quot;: {&quot;\\.js$&quot;: &quot;path/to/custom-transformer.js&quot;}&lt;/code&gt;.</source>
          <target state="translated">Чтобы это работало с Jest, вам необходимо обновить конфигурацию Jest следующим образом: &lt;code&gt;&quot;transform&quot;: {&quot;\\.js$&quot;: &quot;path/to/custom-transformer.js&quot;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="579190d7cd820daa4fd8a13a589227f7e2eaf9e7" translate="yes" xml:space="preserve">
          <source>To resolve this, we will need to update our snapshot artifacts. You can run Jest with a flag that will tell it to re-generate snapshots:</source>
          <target state="translated">Чтобы решить эту проблему,нам нужно обновить наши снимки артефактов.Вы можете запустить Jest с флагом,который скажет ему повторно генерировать снимки:</target>
        </trans-unit>
        <trans-unit id="ce42fc860995230ab9f043725c3815bd5aecd9d4" translate="yes" xml:space="preserve">
          <source>To test this function, we can use a mock function, and inspect the mock's state to ensure the callback is invoked as expected.</source>
          <target state="translated">Для проверки этой функции мы можем использовать функцию имитации и проверить состояние имитации,чтобы убедиться,что обратный вызов вызывается так,как ожидалось.</target>
        </trans-unit>
        <trans-unit id="5fe8e22ac596d3e8399b1774c9a6d272aedb50d5" translate="yes" xml:space="preserve">
          <source>To transform your existing tests, navigate to the project containing the tests and run:</source>
          <target state="translated">Чтобы преобразовать существующие тесты,перейдите в проект,содержащий тесты,и запустите его:</target>
        </trans-unit>
        <trans-unit id="aa8c2a8d1b80b426924e3a346cf5aa28210292b8" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt;, install required dependencies via &lt;code&gt;yarn&lt;/code&gt;:</source>
          <target state="translated">Чтобы использовать &lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt; , установите необходимые зависимости через &lt;code&gt;yarn&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4946751d041e4c3281bd74994c81b3a3ffb0fde6" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;, install required dependencies via &lt;code&gt;yarn&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ff297d04a3d2c50427a66fd27f8359258dbfcd" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;my-serializer-module&lt;/code&gt; as a serializer, configuration would be as follows:</source>
          <target state="translated">Чтобы использовать &lt;code&gt;my-serializer-module&lt;/code&gt; в качестве сериализатора, конфигурация будет следующей:</target>
        </trans-unit>
        <trans-unit id="244873608d8f270057c41ef22dd861ecd2f588e8" translate="yes" xml:space="preserve">
          <source>To use snapshot testing inside of your custom matcher you can import &lt;code&gt;jest-snapshot&lt;/code&gt; and use it from within your matcher.</source>
          <target state="translated">Чтобы использовать тестирование снимков внутри вашего настраиваемого сопоставителя, вы можете импортировать &lt;code&gt;jest-snapshot&lt;/code&gt; и использовать его из своего сопоставителя.</target>
        </trans-unit>
        <trans-unit id="24551f54e6dc91a01a872c5230741bbe5ab3d386" translate="yes" xml:space="preserve">
          <source>To use this class as your custom environment, refer to it by its full path within the project. For example, if your class is stored in &lt;code&gt;my-custom-environment.js&lt;/code&gt; in some subfolder of your project, then the annotation might looke like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d8bcde3184680e702bef641e43c9e47fee12e79" translate="yes" xml:space="preserve">
          <source>To write a test-runner, export a class with which accepts &lt;code&gt;globalConfig&lt;/code&gt; in the constructor, and has a &lt;code&gt;runTests&lt;/code&gt; method with the signature:</source>
          <target state="translated">Чтобы написать средство &lt;code&gt;runTests&lt;/code&gt; тестов, экспортируйте класс, который принимает &lt;code&gt;globalConfig&lt;/code&gt; в конструкторе и имеет метод runTests с подписью:</target>
        </trans-unit>
        <trans-unit id="7e7fbc811015943c1c30e7ceeea8b05c76a8ee58" translate="yes" xml:space="preserve">
          <source>To:</source>
          <target state="translated">To:</target>
        </trans-unit>
        <trans-unit id="2aa91be80e98aceeddfc910352453386480fb849" translate="yes" xml:space="preserve">
          <source>Tool for extracting and parsing the comments at the top of a JavaScript file. Exports various functions to manipulate the data inside the comment block.</source>
          <target state="translated">Инструмент для извлечения и разбора комментариев в верхней части JavaScript-файла.Экспорт различных функций для работы с данными внутри блока комментариев.</target>
        </trans-unit>
        <trans-unit id="b2489dcd056dffceaf32fcd13112faa56f6733de" translate="yes" xml:space="preserve">
          <source>Tool for identifying modified files in a git/hg repository. Exports two functions:</source>
          <target state="translated">Инструмент для идентификации изменённых файлов в git/hg репозитории.Экспорт двух функций:</target>
        </trans-unit>
        <trans-unit id="bba6cd68031555a8aa461d4b5c0878aad6420744" translate="yes" xml:space="preserve">
          <source>Tool for validating configurations submitted by users. Exports a function that takes two arguments: the user's configuration and an object containing an example configuration and other options. The return value is an object with two attributes:</source>
          <target state="translated">Инструмент для проверки конфигураций,предоставленных пользователями.Экспортирует функцию,которая принимает два аргумента:конфигурацию пользователя и объект,содержащий пример конфигурации и другие опции.Возвращаемое значение-объект с двумя атрибутами:</target>
        </trans-unit>
        <trans-unit id="49e105a4ea6033c274af2894a4fcb5d0e03e7eb5" translate="yes" xml:space="preserve">
          <source>Tool for visualizing changes in data. Exports a function that compares two values of any type and returns a &quot;pretty-printed&quot; string illustrating the difference between the two arguments.</source>
          <target state="translated">Инструмент для визуализации изменений данных.Экспортирует функцию,которая сравнивает два значения любого типа и возвращает &quot;красиво напечатанную&quot; строку,иллюстрирующую разницу между двумя аргументами.</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="9a02428b2ce5edfe4a952ba3e66ede7b538c678d" translate="yes" xml:space="preserve">
          <source>Truthiness</source>
          <target state="translated">Truthiness</target>
        </trans-unit>
        <trans-unit id="6bce18334982e1e09a6fddd7fb83bd243818a5bd" translate="yes" xml:space="preserve">
          <source>Try running Jest with &lt;a href=&quot;cli#--watchman&quot;&gt;&lt;code&gt;--no-watchman&lt;/code&gt;&lt;/a&gt; or set the &lt;code&gt;watchman&lt;/code&gt; configuration option to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Попробуйте запустить Jest с &lt;a href=&quot;cli#--watchman&quot;&gt; &lt;code&gt;--no-watchman&lt;/code&gt; &lt;/a&gt; или установите для параметра конфигурации &lt;code&gt;watchman&lt;/code&gt; значение &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5c112e63b4110470aacee270c74bf17085f1c78" translate="yes" xml:space="preserve">
          <source>Try using the debugging support built into Node. Note: This will only work in Node.js 8+.</source>
          <target state="translated">Попробуйте воспользоваться встроенной в Node поддержкой отладки.Замечание:Это будет работать только в Node.js 8+.</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="88ebf4f8084b9e64c1280cb83273c9798bb6700b" translate="yes" xml:space="preserve">
          <source>Uh oh, something went wrong? Use this guide to resolve issues with Jest.</source>
          <target state="translated">Что-то пошло не так? Используй это руководство,чтобы решить проблемы с Шутом.</target>
        </trans-unit>
        <trans-unit id="aed4821821385ee1bab0a8cb0c2780d5e1b4df72" translate="yes" xml:space="preserve">
          <source>Unresolved Promises</source>
          <target state="translated">Нерассмотренные обещания</target>
        </trans-unit>
        <trans-unit id="bb0295c9e03b394a6c931085d1d4692dabdf5136" translate="yes" xml:space="preserve">
          <source>Updating Snapshots</source>
          <target state="translated">Снимки обновления</target>
        </trans-unit>
        <trans-unit id="53431747077771927601efb2109e96aa6b694e10" translate="yes" xml:space="preserve">
          <source>Usage is similar to the module factory function, except that you can omit the second argument from &lt;code&gt;jest.mock()&lt;/code&gt;, and you must import the mocked method into your test file, since it is no longer defined there. Use the original module path for this; don't include &lt;code&gt;__mocks__&lt;/code&gt;.</source>
          <target state="translated">Использование аналогично функции фабрики модуля, за исключением того, что вы можете опустить второй аргумент из &lt;code&gt;jest.mock()&lt;/code&gt; , и вы должны импортировать фиктивный метод в свой тестовый файл, поскольку он больше там не определен. Используйте для этого исходный путь к модулю; не включайте &lt;code&gt;__mocks__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b944d8872fd4ee30de2cd74c68ff456d47e22c9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to refer to &lt;a href=&quot;#rootdir-string&quot;&gt;&lt;code&gt;rootDir&lt;/code&gt;&lt;/a&gt; value if you want to use file paths.</source>
          <target state="translated">Используйте строковый токен &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; для ссылки на значение &lt;a href=&quot;#rootdir-string&quot;&gt; &lt;code&gt;rootDir&lt;/code&gt; ,&lt;/a&gt; если вы хотите использовать пути к файлам.</target>
        </trans-unit>
        <trans-unit id="965fbdc0ee9e136c141ea84e0657f2fdfba937b0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;--watchAll=false&lt;/code&gt; to explicitly disable the watch mode. Note that in most CI environments, this is automatically handled for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="271c57d8c405fa9198756ec5064bbb4c3a46ab5a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.rejects&lt;/code&gt; to unwrap the reason of a rejected promise so any other matcher can be chained. If the promise is fulfilled the assertion fails.</source>
          <target state="translated">Используйте &lt;code&gt;.rejects&lt;/code&gt; , чтобы раскрыть причину отклоненного обещания, чтобы можно было связать любой другой сопоставитель. Если обещание выполнено, утверждение не выполняется.</target>
        </trans-unit>
        <trans-unit id="ff4d09b1ab22e18857563408d1fce004b2fe79a8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBe&lt;/code&gt; to compare primitive values or to check referential identity of object instances. It calls &lt;code&gt;Object.is&lt;/code&gt; to compare values, which is even better for testing than &lt;code&gt;===&lt;/code&gt; strict equality operator.</source>
          <target state="translated">Используйте &lt;code&gt;.toBe&lt;/code&gt; для сравнения примитивных значений или для проверки ссылочной идентичности экземпляров объектов. Он вызывает &lt;code&gt;Object.is&lt;/code&gt; для сравнения значений, что даже лучше для тестирования, чем оператор строгого равенства &lt;code&gt;===&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67ef92856838e5751e399698b48aa87c7d8163a4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeDefined&lt;/code&gt; to check that a variable is not undefined. For example, if you want to check that a function &lt;code&gt;fetchNewFlavorIdea()&lt;/code&gt; returns &lt;em&gt;something&lt;/em&gt;, you can write:</source>
          <target state="translated">Используйте &lt;code&gt;.toBeDefined&lt;/code&gt; , чтобы проверить, не является ли переменная неопределенной. Например, если вы хотите проверить, что функция &lt;code&gt;fetchNewFlavorIdea()&lt;/code&gt; &lt;em&gt;что-то&lt;/em&gt; возвращает , вы можете написать:</target>
        </trans-unit>
        <trans-unit id="f81a87ad40dde8019daa6911a9c4296bf8a5d015" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeFalsy&lt;/code&gt; when you don't care what a value is and you want to ensure a value is false in a boolean context. For example, let's say you have some application code that looks like:</source>
          <target state="translated">Используйте &lt;code&gt;.toBeFalsy&lt;/code&gt; , когда вам все равно, что такое значение, и вы хотите убедиться, что значение ложно в логическом контексте. Например, допустим, у вас есть код приложения, который выглядит так:</target>
        </trans-unit>
        <trans-unit id="50aa6948737b4375185feeebf13f13dbe3451e19" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeInstanceOf(Class)&lt;/code&gt; to check that an object is an instance of a class. This matcher uses &lt;code&gt;instanceof&lt;/code&gt; underneath.</source>
          <target state="translated">Используйте &lt;code&gt;.toBeInstanceOf(Class)&lt;/code&gt; чтобы проверить, является ли объект экземпляром класса. Этот сопоставитель использует &lt;code&gt;instanceof&lt;/code&gt; внизу.</target>
        </trans-unit>
        <trans-unit id="93a0ac0f3d847ffa6b85c3555bc23bce0abae9d2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeNaN&lt;/code&gt; when checking a value is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">Используйте &lt;code&gt;.toBeNaN&lt;/code&gt; при проверке значения &lt;code&gt;NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e05d177a2e90b6b046b4b02a5621b8f26893024" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeTruthy&lt;/code&gt; when you don't care what a value is and you want to ensure a value is true in a boolean context. For example, let's say you have some application code that looks like:</source>
          <target state="translated">Используйте &lt;code&gt;.toBeTruthy&lt;/code&gt; , если вам все равно, что такое значение, и вы хотите убедиться, что значение истинно в логическом контексте. Например, допустим, у вас есть код приложения, который выглядит так:</target>
        </trans-unit>
        <trans-unit id="c167d5affa8fa782feb54d90f30b85615f390e75" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeUndefined&lt;/code&gt; to check that a variable is undefined. For example, if you want to check that a function &lt;code&gt;bestDrinkForFlavor(flavor)&lt;/code&gt; returns &lt;code&gt;undefined&lt;/code&gt; for the &lt;code&gt;'octopus'&lt;/code&gt; flavor, because there is no good octopus-flavored drink:</source>
          <target state="translated">Используйте &lt;code&gt;.toBeUndefined&lt;/code&gt; , чтобы проверить, что переменная не определена. Например, если вы хотите проверить, что функция &lt;code&gt;bestDrinkForFlavor(flavor)&lt;/code&gt; возвращает значение &lt;code&gt;undefined&lt;/code&gt; для вкуса &lt;code&gt;'octopus'&lt;/code&gt; , потому что хорошего напитка со вкусом осьминога не существует:</target>
        </trans-unit>
        <trans-unit id="a934298864a7697607ca428a7e4d71c72de7efbf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toContain&lt;/code&gt; when you want to check that an item is in an array. For testing the items in the array, this uses &lt;code&gt;===&lt;/code&gt;, a strict equality check. &lt;code&gt;.toContain&lt;/code&gt; can also check whether a string is a substring of another string.</source>
          <target state="translated">Используйте &lt;code&gt;.toContain&lt;/code&gt; , если хотите проверить, находится ли элемент в массиве. Для тестирования элементов в массиве используется &lt;code&gt;===&lt;/code&gt; , строгая проверка на равенство. &lt;code&gt;.toContain&lt;/code&gt; также может проверять, является ли строка подстрокой другой строки.</target>
        </trans-unit>
        <trans-unit id="bd36fedc663beba2df99e661929cac1ca55d82a9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toContainEqual&lt;/code&gt; when you want to check that an item with a specific structure and values is contained in an array. For testing the items in the array, this matcher recursively checks the equality of all fields, rather than checking for object identity.</source>
          <target state="translated">Используйте &lt;code&gt;.toContainEqual&lt;/code&gt; , если вы хотите проверить, что элемент с определенной структурой и значениями содержится в массиве. Для тестирования элементов в массиве этот сопоставитель рекурсивно проверяет равенство всех полей, а не проверяет идентичность объекта.</target>
        </trans-unit>
        <trans-unit id="2892f11bab4090104beb941f4d3d44f139cd4a21" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toEqual&lt;/code&gt; to compare recursively all properties of object instances (also known as &quot;deep&quot; equality). It calls &lt;code&gt;Object.is&lt;/code&gt; to compare primitive values, which is even better for testing than &lt;code&gt;===&lt;/code&gt; strict equality operator.</source>
          <target state="translated">Используйте &lt;code&gt;.toEqual&lt;/code&gt; для рекурсивного сравнения всех свойств экземпляров объекта (также известного как &amp;laquo;глубокое&amp;raquo; равенство). Он вызывает &lt;code&gt;Object.is&lt;/code&gt; для сравнения примитивных значений, что даже лучше для тестирования, чем оператор строгого равенства &lt;code&gt;===&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22f31877b97035b92fb10441a1a3485e65903b49" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveBeenCalled&lt;/code&gt; to ensure that a mock function got called.</source>
          <target state="translated">Используйте &lt;code&gt;.toHaveBeenCalled&lt;/code&gt; , чтобы убедиться, что вызывалась фиктивная функция.</target>
        </trans-unit>
        <trans-unit id="dfcaf02f56b10c94ecc202b3c8d9087baccb5181" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveBeenCalledTimes&lt;/code&gt; to ensure that a mock function got called exact number of times.</source>
          <target state="translated">Используйте &lt;code&gt;.toHaveBeenCalledTimes&lt;/code&gt; , чтобы гарантировать, что фиктивная функция вызывается точное количество раз.</target>
        </trans-unit>
        <trans-unit id="6c8d2793887755a171ad2f5be4f1a01fc5c6e2d5" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveBeenCalledWith&lt;/code&gt; to ensure that a mock function was called with specific arguments.</source>
          <target state="translated">Используйте &lt;code&gt;.toHaveBeenCalledWith&lt;/code&gt; , чтобы гарантировать, что фиктивная функция вызывается с определенными аргументами.</target>
        </trans-unit>
        <trans-unit id="4be0de20431e47e5724878c19b00a0321ac838e1" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveLastReturnedWith&lt;/code&gt; to test the specific value that a mock function last returned. If the last call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value.</source>
          <target state="translated">Используйте &lt;code&gt;.toHaveLastReturnedWith&lt;/code&gt; , чтобы проверить конкретное значение, которое в последний раз вернула фиктивная функция. Если последний вызов фиктивной функции вызвал ошибку, то этот сопоставитель завершится ошибкой независимо от того, какое значение вы указали в качестве ожидаемого возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="7001ece11621c6dd7371042298806dcb68ab8bdd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveLength&lt;/code&gt; to check that an object has a &lt;code&gt;.length&lt;/code&gt; property and it is set to a certain numeric value.</source>
          <target state="translated">Используйте &lt;code&gt;.toHaveLength&lt;/code&gt; , чтобы проверить, что у объекта есть свойство &lt;code&gt;.length&lt;/code&gt; и для него установлено определенное числовое значение.</target>
        </trans-unit>
        <trans-unit id="4a20c538c65f701e8900dd32f27f93e926fbf397" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveNthReturnedWith&lt;/code&gt; to test the specific value that a mock function returned for the nth call. If the nth call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value.</source>
          <target state="translated">Используйте &lt;code&gt;.toHaveNthReturnedWith&lt;/code&gt; , чтобы проверить конкретное значение, которое фиктивная функция вернула для n-го вызова. Если n-й вызов фиктивной функции выдал ошибку, то этот сопоставитель завершится ошибкой независимо от того, какое значение вы указали в качестве ожидаемого возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="bc794bedf39c69791593b20f2971ba46bf591e64" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveProperty&lt;/code&gt; to check if property at provided reference &lt;code&gt;keyPath&lt;/code&gt; exists for an object. For checking deeply nested properties in an object you may use &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors&quot;&gt;dot notation&lt;/a&gt; or an array containing the keyPath for deep references.</source>
          <target state="translated">Используйте &lt;code&gt;.toHaveProperty&lt;/code&gt; , чтобы проверить, существует ли свойство по &lt;code&gt;keyPath&lt;/code&gt; ссылке keyPath для объекта. Для проверки глубоко вложенных свойств в объекте вы можете использовать &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors&quot;&gt;точечную нотацию&lt;/a&gt; или массив, содержащий keyPath для глубоких ссылок.</target>
        </trans-unit>
        <trans-unit id="5c5db22f649bb5e433fce75313e71f348fcdbe60" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveReturnedTimes&lt;/code&gt; to ensure that a mock function returned successfully (i.e., did not throw an error) an exact number of times. Any calls to the mock function that throw an error are not counted toward the number of times the function returned.</source>
          <target state="translated">Используйте &lt;code&gt;.toHaveReturnedTimes&lt;/code&gt; , чтобы гарантировать, что фиктивная функция успешно вернулась (т. Е. Не выдала ошибку) точное количество раз. Любые вызовы фиктивной функции, которые вызывают ошибку, не учитываются при подсчете количества возвращаемых функцией.</target>
        </trans-unit>
        <trans-unit id="00cc15ef74e3e3bbb9d04e26768f906229227777" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveReturnedWith&lt;/code&gt; to ensure that a mock function returned a specific value.</source>
          <target state="translated">Используйте &lt;code&gt;.toHaveReturnedWith&lt;/code&gt; , чтобы гарантировать, что фиктивная функция вернула определенное значение.</target>
        </trans-unit>
        <trans-unit id="3403bfc7d77f929d8284a0b531fb242672320cf2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toMatch&lt;/code&gt; to check that a string matches a regular expression.</source>
          <target state="translated">Используйте &lt;code&gt;.toMatch&lt;/code&gt; , чтобы проверить, соответствует ли строка регулярному выражению.</target>
        </trans-unit>
        <trans-unit id="6aa577eec7c4f8e335bb974a5ba8a04b9b825d62" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toMatchObject&lt;/code&gt; to check that a JavaScript object matches a subset of the properties of an object. It will match received objects with properties that are &lt;strong&gt;not&lt;/strong&gt; in the expected object.</source>
          <target state="translated">Используйте &lt;code&gt;.toMatchObject&lt;/code&gt; , чтобы проверить, соответствует ли объект JavaScript подмножеству свойств объекта. Он сопоставляет полученные объекты со свойствами, которых &lt;strong&gt;нет&lt;/strong&gt; в ожидаемом объекте.</target>
        </trans-unit>
        <trans-unit id="43d74a2c2c927835dbc06a10fe0a834ecd3cf583" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toStrictEqual&lt;/code&gt; to test that objects have the same types as well as structure.</source>
          <target state="translated">Используйте &lt;code&gt;.toStrictEqual&lt;/code&gt; , чтобы проверить, что объекты имеют одинаковые типы и структуру.</target>
        </trans-unit>
        <trans-unit id="60e9ea675b7707c4a125a8d5da6124d2b7dfa82a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toThrow&lt;/code&gt; to test that a function throws when it is called. For example, if we want to test that &lt;code&gt;drinkFlavor('octopus')&lt;/code&gt; throws, because octopus flavor is too disgusting to drink, we could write:</source>
          <target state="translated">Используйте &lt;code&gt;.toThrow&lt;/code&gt; , чтобы проверить, вызывает ли функция при ее вызове. Например, если мы хотим проверить, что &lt;code&gt;drinkFlavor('octopus')&lt;/code&gt; бросает, потому что вкус осьминога слишком отвратителен для питья, мы могли бы написать:</target>
        </trans-unit>
        <trans-unit id="b8835c8692fc22c521a477117dec692aecc544e4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toThrowErrorMatchingInlineSnapshot&lt;/code&gt; to test that a function throws an error matching the most recent snapshot when it is called.</source>
          <target state="translated">Используйте &lt;code&gt;.toThrowErrorMatchingInlineSnapshot&lt;/code&gt; , чтобы проверить, что функция выдает ошибку, соответствующую самому последнему снимку, когда она вызывается.</target>
        </trans-unit>
        <trans-unit id="8656cd1667dc531479d8b4cb204dd90a1579844f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toThrowErrorMatchingSnapshot&lt;/code&gt; to test that a function throws an error matching the most recent snapshot when it is called.</source>
          <target state="translated">Используйте &lt;code&gt;.toThrowErrorMatchingSnapshot&lt;/code&gt; , чтобы проверить, что функция выдает ошибку, соответствующую самому последнему снимку при ее вызове.</target>
        </trans-unit>
        <trans-unit id="0440b25bd05f6a2e3c56826df198b652d25c12c6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;describe.each&lt;/code&gt; if you keep duplicating the same test suites with different data. &lt;code&gt;describe.each&lt;/code&gt; allows you to write the test suite once and pass data in.</source>
          <target state="translated">Используйте &lt;code&gt;describe.each&lt;/code&gt; если вы продолжаете дублировать одни и те же наборы тестов с разными данными. &lt;code&gt;describe.each&lt;/code&gt; позволяет вам один раз написать набор тестов и передать в него данные.</target>
        </trans-unit>
        <trans-unit id="ef60fa41c287f5e40cf5103947099b8fe473bb0e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;describe.only.each&lt;/code&gt; if you want to only run specific tests suites of data driven tests.</source>
          <target state="translated">Используйте &lt;code&gt;describe.only.each&lt;/code&gt; , если вы хотите запускать только определенные наборы тестов тестов, управляемых данными.</target>
        </trans-unit>
        <trans-unit id="cedc27af374f9505722e2e0748157f331b8c1a04" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;describe.skip.each&lt;/code&gt; if you want to stop running a suite of data driven tests.</source>
          <target state="translated">Используйте &lt;code&gt;describe.skip.each&lt;/code&gt; , если вы хотите прекратить запуск набора тестов на основе данных.</target>
        </trans-unit>
        <trans-unit id="d406a9d711b46330782be9bc2cb621080a4ae6f6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;react-test-renderer&lt;/code&gt;. The test renderer doesn't care about element types and will happily accept e.g. &lt;code&gt;SomeComponent&lt;/code&gt;. You could check snapshots using the test renderer, and check component behavior separately using Enzyme.</source>
          <target state="translated">Используйте &lt;code&gt;react-test-renderer&lt;/code&gt; . Тестовый рендерер не заботится о типах элементов и с радостью примет, например, &lt;code&gt;SomeComponent&lt;/code&gt; . Вы можете проверять снимки с помощью тестового средства визуализации и отдельно проверять поведение компонентов с помощью Enzyme.</target>
        </trans-unit>
        <trans-unit id="7e3d957c7581b38a6f6d9efe05f990ae9f8f779c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;resolves&lt;/code&gt; to unwrap the value of a fulfilled promise so any other matcher can be chained. If the promise is rejected the assertion fails.</source>
          <target state="translated">Используйте &lt;code&gt;resolves&lt;/code&gt; , чтобы развернуть значение выполненного обещания, чтобы можно было связать любой другой сопоставитель. Если обещание отклонено, утверждение не выполняется.</target>
        </trans-unit>
        <trans-unit id="1345114e2fd1c60a6d60edc7450f9a4afadae484" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.concurrent.each&lt;/code&gt; if you keep duplicating the same test with different data. &lt;code&gt;test.each&lt;/code&gt; allows you to write the test once and pass data in, the tests are all run asynchronously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef6514f1b68a3a68401c341c0da426d04e4aa20" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.concurrent.only.each&lt;/code&gt; if you want to only run specific tests with different test data concurrently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="263222bc2f899a0d715a6fab20c766f111044fc2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.concurrent.skip.each&lt;/code&gt; if you want to stop running a collection of asynchronous data driven tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e28dd2d14db9066d63653631068e696eab675f0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.concurrent&lt;/code&gt; if you want the test to run concurrently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3afb7e6906f2b3257d85cde9c36efa5c6e5bcbfc" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.each&lt;/code&gt; if you keep duplicating the same test with different data. &lt;code&gt;test.each&lt;/code&gt; allows you to write the test once and pass data in.</source>
          <target state="translated">Используйте &lt;code&gt;test.each&lt;/code&gt; , если вы продолжаете дублировать один и тот же тест с разными данными. &lt;code&gt;test.each&lt;/code&gt; позволяет один раз написать тест и передать данные.</target>
        </trans-unit>
        <trans-unit id="5ed7e082f3c3b04fc36bc3b9da1fb4c701925c6d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.only.each&lt;/code&gt; if you want to only run specific tests with different test data.</source>
          <target state="translated">Используйте &lt;code&gt;test.only.each&lt;/code&gt; , если вы хотите запускать только определенные тесты с другими тестовыми данными.</target>
        </trans-unit>
        <trans-unit id="9a662231e654755bb86491a61d19bfda30bf8dea" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.skip.each&lt;/code&gt; if you want to stop running a collection of data driven tests.</source>
          <target state="translated">Используйте &lt;code&gt;test.skip.each&lt;/code&gt; , если вы хотите остановить набор тестов на основе данных.</target>
        </trans-unit>
        <trans-unit id="04f44ceaa0fcfd12976de28307ac74bab48f40fa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.todo&lt;/code&gt; when you are planning on writing tests. These tests will be highlighted in the summary output at the end so you know how many tests you still need todo.</source>
          <target state="translated">Используйте &lt;code&gt;test.todo&lt;/code&gt; , когда планируете писать тесты. Эти тесты будут выделены в итоговых выводах в конце, чтобы вы знали, сколько тестов вам еще нужно сделать.</target>
        </trans-unit>
        <trans-unit id="72b53cf691901a7f6c7db879139a7d5cc2a021bd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;toBeCloseTo&lt;/code&gt; to compare floating point numbers for approximate equality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67135d0a79cc68d7ce480429610bb2f2628671fa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;toBeGreaterThan&lt;/code&gt; to compare &lt;code&gt;received &amp;gt; expected&lt;/code&gt; for number or big integer values. For example, test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of more than 10 ounces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3930db7617a0eec776a6b70b86ff9f67aaf7165d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;toBeGreaterThanOrEqual&lt;/code&gt; to compare &lt;code&gt;received &amp;gt;= expected&lt;/code&gt; for number or big integer values. For example, test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of at least 12 ounces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c60b4cd3422307c10fbc69a5ebc0d409a25e545" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;toBeLessThan&lt;/code&gt; to compare &lt;code&gt;received &amp;lt; expected&lt;/code&gt; for number or big integer values. For example, test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of less than 20 ounces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ee9741a4bceeea1bf6f12bd38538086556426e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;toBeLessThanOrEqual&lt;/code&gt; to compare &lt;code&gt;received &amp;lt;= expected&lt;/code&gt; for number or big integer values. For example, test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of at most 12 ounces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67497066b431f7970b52aff03e2267c3031fe3af" translate="yes" xml:space="preserve">
          <source>Use it in your Jest config file like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="759c0eb81e3b691ac63ce62826c9faeffd303147" translate="yes" xml:space="preserve">
          <source>Use jest-dynamodb Preset</source>
          <target state="translated">Использовать is-dynamodb Предустановка</target>
        </trans-unit>
        <trans-unit id="7194dde7b6fdc7725f8efc98a8775cd0fe57fa0a" translate="yes" xml:space="preserve">
          <source>Use jest-mongodb Preset</source>
          <target state="translated">Использование is-mongodb Предустановленный</target>
        </trans-unit>
        <trans-unit id="d6629ac509cad69b4360ba597e78efb90888b162" translate="yes" xml:space="preserve">
          <source>Use jest-puppeteer Preset</source>
          <target state="translated">Использовать шутку-кукловод Предварительная установка</target>
        </trans-unit>
        <trans-unit id="8859f21b394eb7bddbe02c98d39f3c5d61b96c00" translate="yes" xml:space="preserve">
          <source>Use this configuration option to add custom reporters to Jest. A custom reporter is a class that implements &lt;code&gt;onRunStart&lt;/code&gt;, &lt;code&gt;onTestStart&lt;/code&gt;, &lt;code&gt;onTestResult&lt;/code&gt;, &lt;code&gt;onRunComplete&lt;/code&gt; methods that will be called when any of those events occurs.</source>
          <target state="translated">Используйте этот параметр конфигурации для добавления пользовательских репортеров в Jest. Пользовательский репортер - это класс, реализующий &lt;code&gt;onRunStart&lt;/code&gt; , &lt;code&gt;onTestStart&lt;/code&gt; , &lt;code&gt;onTestResult&lt;/code&gt; , &lt;code&gt;onRunComplete&lt;/code&gt; , которые будут вызываться при возникновении любого из этих событий.</target>
        </trans-unit>
        <trans-unit id="0ce722d28dd2ac22869f544554814473ced27729" translate="yes" xml:space="preserve">
          <source>Useful to create async mock functions that will always reject:</source>
          <target state="translated">Полезно для создания функций асинхронной имитации,которые всегда будут отвергаться:</target>
        </trans-unit>
        <trans-unit id="82fe22471a3c89a8a884379e2a589a9b9393684f" translate="yes" xml:space="preserve">
          <source>Useful to mock async functions in async tests:</source>
          <target state="translated">Полезно для имитации функций асинхронизации в тестах асинхронизации:</target>
        </trans-unit>
        <trans-unit id="4d6f5093469250351be715bab11328d708148671" translate="yes" xml:space="preserve">
          <source>Useful to resolve different values over multiple async calls:</source>
          <target state="translated">Полезно для разрешения различных значений при нескольких асинхронных вызовах:</target>
        </trans-unit>
        <trans-unit id="8386651610226fd04ae64f938ef5bbd0efe279f3" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;describe.skip&lt;/code&gt; is often a cleaner alternative to temporarily commenting out a chunk of tests.</source>
          <target state="translated">Использование &lt;code&gt;describe.skip&lt;/code&gt; часто является более удобной альтернативой временному комментированию части тестов.</target>
        </trans-unit>
        <trans-unit id="8da013e9c1193b5fd4e55adc4f5c72966bc2f345" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;jest.doMock()&lt;/code&gt; with ES6 imports requires additional steps. Follow these if you don't want to use &lt;code&gt;require&lt;/code&gt; in your tests:</source>
          <target state="translated">Использование &lt;code&gt;jest.doMock()&lt;/code&gt; с импортом ES6 требует дополнительных действий. Следуйте этим инструкциям, если вы не хотите использовать &lt;code&gt;require&lt;/code&gt; в своих тестах:</target>
        </trans-unit>
        <trans-unit id="5b7ceb252455569b8991c8fe4bfba034672b82cf" translate="yes" xml:space="preserve">
          <source>Using Babel</source>
          <target state="translated">Использование Вавилона</target>
        </trans-unit>
        <trans-unit id="ad353105ab08c29227ad5d0775b29687a1b718c7" translate="yes" xml:space="preserve">
          <source>Using Matchers</source>
          <target state="translated">Использование матчей</target>
        </trans-unit>
        <trans-unit id="8c578fdee5f39cae171b3ae3dc5e52be3eb3db63" translate="yes" xml:space="preserve">
          <source>Using TypeScript</source>
          <target state="translated">Использование TypeScript</target>
        </trans-unit>
        <trans-unit id="e2b797adce82409b798a1e85b5f20128645a30c7" translate="yes" xml:space="preserve">
          <source>Using a mock function</source>
          <target state="translated">Использование функции имитации</target>
        </trans-unit>
        <trans-unit id="fdad49cc59429141e7cc6464244c820172f9da4a" translate="yes" xml:space="preserve">
          <source>Using exact equality with floating point numbers is a bad idea. Rounding means that intuitive things fail. For example, this test fails:</source>
          <target state="translated">Использование точного равенства с числами с плавающей точкой-плохая идея.Округление означает,что интуитивные вещи терпят неудачу.Например,этот тест провалился:</target>
        </trans-unit>
        <trans-unit id="3dfac5af5bd078779708abe2d31733f55ae203b9" translate="yes" xml:space="preserve">
          <source>Using parcel</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d56e8185a2d6c77ca4726dcd2b55295a60bd2572" translate="yes" xml:space="preserve">
          <source>Using webpack</source>
          <target state="translated">Использование веб-пакета</target>
        </trans-unit>
        <trans-unit id="a5bf7b56e0fe9da5b66e110d7867887929aa794f" translate="yes" xml:space="preserve">
          <source>Using with DynamoDB</source>
          <target state="translated">Использование с DynamoDB</target>
        </trans-unit>
        <trans-unit id="ad43d620306250954a4a631c111cb745bc0804de" translate="yes" xml:space="preserve">
          <source>Using with ES module imports</source>
          <target state="translated">Использование с импортом модулей ES</target>
        </trans-unit>
        <trans-unit id="44be8a58330b5c23182d2274fdfd6efbdf4e83a9" translate="yes" xml:space="preserve">
          <source>Using with MongoDB</source>
          <target state="translated">Использование с MongoDB</target>
        </trans-unit>
        <trans-unit id="785e92a5d24055ece246e1162c6d740443f3f058" translate="yes" xml:space="preserve">
          <source>Using with npm scripts</source>
          <target state="translated">Использование с npm-скриптами</target>
        </trans-unit>
        <trans-unit id="094d8ae70af4304a0d4b4a837d18e1de8f8424c0" translate="yes" xml:space="preserve">
          <source>Using with puppeteer</source>
          <target state="translated">Использовать с кукловодом</target>
        </trans-unit>
        <trans-unit id="62915756095c500af390187568578de70abf9244" translate="yes" xml:space="preserve">
          <source>Using with webpack</source>
          <target state="translated">Использование с веб-пакетом</target>
        </trans-unit>
        <trans-unit id="2f6a259c826a5d9735d5a64063f1b31e207c2685" translate="yes" xml:space="preserve">
          <source>Using with webpack 2</source>
          <target state="translated">Использование с webpack 2</target>
        </trans-unit>
        <trans-unit id="e92e8a4901b69fac997e23f82569d015987ccae6" translate="yes" xml:space="preserve">
          <source>Using with yarn</source>
          <target state="translated">Использование с пряжей</target>
        </trans-unit>
        <trans-unit id="41c1155f49d57702ee239db81113c543bd9591e4" translate="yes" xml:space="preserve">
          <source>Usually you wouldn't check code using &lt;code&gt;test.only&lt;/code&gt; into source control - you would use it for debugging, and remove it once you have fixed the broken tests.</source>
          <target state="translated">Обычно вы не проверяете код с помощью &lt;code&gt;test.only&lt;/code&gt; в системе управления версиями - вы используете его для отладки и удаляете после исправления неработающих тестов.</target>
        </trans-unit>
        <trans-unit id="8bd43b7ad188ce8c3bb9691452ec856dcccbc84c" translate="yes" xml:space="preserve">
          <source>Vue.js</source>
          <target state="translated">Vue.js</target>
        </trans-unit>
        <trans-unit id="4af321d3223afd7ac8763fbd38707f1b871aa01e" translate="yes" xml:space="preserve">
          <source>Warning: If we want to mock Node's core modules (e.g.: &lt;code&gt;fs&lt;/code&gt; or &lt;code&gt;path&lt;/code&gt;), then explicitly calling e.g. &lt;code&gt;jest.mock('path')&lt;/code&gt; is &lt;strong&gt;required&lt;/strong&gt;, because core Node modules are not mocked by default.</source>
          <target state="translated">Предупреждение: Если мы хотим , чтобы дразнить узла основных модулей (например: &lt;code&gt;fs&lt;/code&gt; или &lt;code&gt;path&lt;/code&gt; ), то явного вызова , например &lt;code&gt;jest.mock('path')&lt;/code&gt; является &lt;strong&gt;требуется&lt;/strong&gt; , так как модули ядра узла не издевались по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d0993b420d1ece1c116d94df1eb882929103aacb" translate="yes" xml:space="preserve">
          <source>Watch Menu Integration</source>
          <target state="translated">Интеграция смотреть меню</target>
        </trans-unit>
        <trans-unit id="77162c2c5b3f4537b5a429cc13193176c9944f13" translate="yes" xml:space="preserve">
          <source>Watch Plugin Interface</source>
          <target state="translated">Интерфейс плагина часов</target>
        </trans-unit>
        <trans-unit id="730cb1589addfecd42b5dc91914d54090940dd7b" translate="yes" xml:space="preserve">
          <source>Watch Plugins</source>
          <target state="translated">Часовые плагины</target>
        </trans-unit>
        <trans-unit id="1b41755710b08ba989fe2719763a7cc16cd093cd" translate="yes" xml:space="preserve">
          <source>Watch files for changes and rerun all tests when something changes. If you want to re-run only the tests that depend on the changed files, use the &lt;code&gt;--watch&lt;/code&gt; option.</source>
          <target state="translated">Следите за изменениями в файлах и повторно запускайте все тесты, когда что-то меняется. Если вы хотите повторно запустить только те тесты, которые зависят от измененных файлов, используйте параметр &lt;code&gt;--watch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f500e5f9a091c5d91b9402809c2e1bfb82401f3" translate="yes" xml:space="preserve">
          <source>Watch files for changes and rerun tests related to changed files. If you want to re-run all tests when a file has changed, use the &lt;code&gt;--watchAll&lt;/code&gt; option instead.</source>
          <target state="translated">Следите за изменениями в файлах и повторно запускайте тесты, связанные с измененными файлами. Если вы хотите повторно запустить все тесты после изменения файла, используйте вместо этого параметр &lt;code&gt;--watchAll&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a33b701f8666961875a562f2fa71a7405de7c06" translate="yes" xml:space="preserve">
          <source>Watch mode also enables to specify the name or path to a file to focus on a specific set of tests.</source>
          <target state="translated">Режим Watch также позволяет указать имя или путь к файлу,чтобы сконцентрироваться на определенном наборе тестов.</target>
        </trans-unit>
        <trans-unit id="acd93772ed153d854aedd488090f5c82e983b44d" translate="yes" xml:space="preserve">
          <source>Watch plugin YourFaultyPlugin attempted to register key &lt;code&gt;q&lt;/code&gt;, that is reserved internally for quitting watch mode. Please change the configuration key for this plugin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aff9902a15b762dc90c7266ccddd98d2b3f64e24" translate="yes" xml:space="preserve">
          <source>Watch plugin YourFaultyPlugin attempted to register key &lt;q&gt;, that is reserved internally for quitting watch mode. Please change the configuration key for this plugin.&lt;/q&gt;</source>
          <target state="translated">Плагин Watch YourFaultyPlugin попытался зарегистрировать ключ &lt;q&gt;, зарезервированный внутри для выхода из режима просмотра. Измените конфигурационный ключ для этого плагина.&lt;/q&gt;</target>
        </trans-unit>
        <trans-unit id="a673577265e6ead99e3c23f76e5f29409c5b7d10" translate="yes" xml:space="preserve">
          <source>Watch plugins YourFaultyPlugin and TheirFaultyPlugin both attempted to register key</source>
          <target state="translated">Следите за плагинами YourFaultyPlugin и TheirFaultyPlugin,которые пытались зарегистрировать ключ.</target>
        </trans-unit>
        <trans-unit id="570ca6efbd4ac29fbe2679f4f54ef1e9c4dfefbc" translate="yes" xml:space="preserve">
          <source>Watch plugins YourFaultyPlugin and TheirFaultyPlugin both attempted to register key &lt;code&gt;x&lt;/code&gt;. Please change the key configuration for one of the conflicting plugins to avoid overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a8e0b7b820fac76887499e0730014073b6942fc" translate="yes" xml:space="preserve">
          <source>Watchman Issues</source>
          <target state="translated">Проблемы с наблюдателями</target>
        </trans-unit>
        <trans-unit id="58ed43a0f07990c616800d6e405003e52deb7101" translate="yes" xml:space="preserve">
          <source>We are mocking &lt;code&gt;fetchCurrentUser.js&lt;/code&gt; so that our test doesn't make a real network request but instead resolves to mock data locally. This ensures that our test can complete in milliseconds rather than seconds and guarantees a fast unit test iteration speed.</source>
          <target state="translated">Мы &lt;code&gt;fetchCurrentUser.js&lt;/code&gt; чтобы наш тест не отправлял настоящий сетевой запрос, а вместо этого разрешал имитировать данные локально. Это гарантирует, что наш тест может завершиться за миллисекунды, а не за секунды, и гарантирует высокую скорость итерации модульного теста.</target>
        </trans-unit>
        <trans-unit id="39fcaf5408d64ca526faacb5d58f9141c191b735" translate="yes" xml:space="preserve">
          <source>We call &lt;code&gt;jest.mock('../request')&lt;/code&gt; to tell Jest to use our manual mock. &lt;code&gt;it&lt;/code&gt; expects the return value to be a Promise that is going to be resolved. You can chain as many Promises as you like and call &lt;code&gt;expect&lt;/code&gt; at any time, as long as you return a Promise at the end.</source>
          <target state="translated">Мы вызываем &lt;code&gt;jest.mock('../request')&lt;/code&gt; чтобы указать Jest использовать наш ручной макет. &lt;code&gt;it&lt;/code&gt; ожидает, что возвращаемое значение будет обещанием, которое будет разрешено. Вы можете связать столько обещаний, сколько захотите, и в любой момент вызвать &lt;code&gt;expect&lt;/code&gt; , если в конце вы вернете обещание.</target>
        </trans-unit>
        <trans-unit id="69b678bb69e79c49e5b0a08e85e9a17993259892" translate="yes" xml:space="preserve">
          <source>We could test this error gets thrown in several ways:</source>
          <target state="translated">Мы могли бы протестировать,что эта ошибка выбрасывается несколькими способами:</target>
        </trans-unit>
        <trans-unit id="0bd52959384de0efc9e324b40ef0a059ef8e64cd" translate="yes" xml:space="preserve">
          <source>We have to specify the &lt;code&gt;__esModule: true&lt;/code&gt; property (see the &lt;a href=&quot;#jestmockmodulename-factory-options&quot;&gt;&lt;code&gt;jest.mock()&lt;/code&gt;&lt;/a&gt; API for more information).</source>
          <target state="translated">Мы должны указать &lt;code&gt;__esModule: true&lt;/code&gt; (дополнительную информацию см. &lt;a href=&quot;#jestmockmodulename-factory-options&quot;&gt; &lt;code&gt;jest.mock()&lt;/code&gt; &lt;/a&gt; API jest.mock () ).</target>
        </trans-unit>
        <trans-unit id="58e30d514b365fc2673e994c86e9d1067f92cb36" translate="yes" xml:space="preserve">
          <source>We recommend placing the extensions most commonly used in your project on the left, so if you are using TypeScript, you may want to consider moving &quot;ts&quot; and/or &quot;tsx&quot; to the beginning of the array.</source>
          <target state="translated">Мы рекомендуем расположить наиболее часто используемые в вашем проекте расширения слева,так что если вы используете TypeScript,то вы можете подумать о переносе &quot;ts&quot; и/или &quot;tsx&quot; в начало массива.</target>
        </trans-unit>
        <trans-unit id="49cfe85b5d9f91e87c2bb6c4919d6422b42d36a2" translate="yes" xml:space="preserve">
          <source>We'll use a contrived example of a class that plays sound files, &lt;code&gt;SoundPlayer&lt;/code&gt;, and a consumer class which uses that class, &lt;code&gt;SoundPlayerConsumer&lt;/code&gt;. We'll mock &lt;code&gt;SoundPlayer&lt;/code&gt; in our tests for &lt;code&gt;SoundPlayerConsumer&lt;/code&gt;.</source>
          <target state="translated">Мы будем использовать надуманный пример класса, который воспроизводит звуковые файлы, &lt;code&gt;SoundPlayer&lt;/code&gt; , и потребительского класса, который использует этот класс, &lt;code&gt;SoundPlayerConsumer&lt;/code&gt; . Мы будем издеваться над &lt;code&gt;SoundPlayer&lt;/code&gt; в наших тестах для &lt;code&gt;SoundPlayerConsumer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a570bfe57d90629aa64647c14bb9b9299f88f21" translate="yes" xml:space="preserve">
          <source>We've told Jest to ignore files matching a stylesheet or image extension, and instead, require our mock files. You can adjust the regular expression to match the file types your webpack config handles.</source>
          <target state="translated">Мы сказали Jest игнорировать файлы,соответствующие таблицам стилей или расширениям образов,и вместо этого требовать наши поддельные файлы.Вы можете настроить регулярное выражение в соответствии с типами файлов,с которыми работает ваш веб-пакет.</target>
        </trans-unit>
        <trans-unit id="6e27e07bef6adeae0276f0cd001319eb48d71a2c" translate="yes" xml:space="preserve">
          <source>What is the performance of snapshot testing regarding speed and size of the generated files?</source>
          <target state="translated">Какова производительность снимкового тестирования в отношении скорости и размера генерируемых файлов?</target>
        </trans-unit>
        <trans-unit id="3bc8902ad3e552d6e229d9ad2fb118f5b3735490" translate="yes" xml:space="preserve">
          <source>What's the difference between snapshot testing and visual regression testing?</source>
          <target state="translated">В чем разница между тестированием снимков и визуальным регрессионным тестированием?</target>
        </trans-unit>
        <trans-unit id="18c42c157f8a61af5c55926418fd204e7a9c5be1" translate="yes" xml:space="preserve">
          <source>When Jest runs your test to collect the &lt;code&gt;test&lt;/code&gt;s it will not find any because we have set the definition to happen asynchronously on the next tick of the event loop.</source>
          <target state="translated">Когда Jest запускает ваш тест, чтобы собрать &lt;code&gt;test&lt;/code&gt; он их не найдет, потому что мы установили, что определение выполняется асинхронно на следующем тике цикла событий.</target>
        </trans-unit>
        <trans-unit id="66a712f9c4762f8fb45d196c8b569be5ba0595bc" translate="yes" xml:space="preserve">
          <source>When a conflict happens</source>
          <target state="translated">Когда происходит конфликт</target>
        </trans-unit>
        <trans-unit id="6ddcfa27c2af8b12d25959aeb81f42c8a1e31340" translate="yes" xml:space="preserve">
          <source>When a manual mock exists for a given module, Jest's module system will use that module when explicitly calling &lt;code&gt;jest.mock('moduleName')&lt;/code&gt;. However, when &lt;code&gt;automock&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the manual mock implementation will be used instead of the automatically created mock, even if &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; is not called. To opt out of this behavior you will need to explicitly call &lt;code&gt;jest.unmock('moduleName')&lt;/code&gt; in tests that should use the actual module implementation.</source>
          <target state="translated">Если для данного модуля существует ручной макет, модульная система Jest будет использовать этот модуль при явном вызове &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; . Однако, если для параметра &lt;code&gt;automock&lt;/code&gt; установлено значение &lt;code&gt;true&lt;/code&gt; , вместо автоматически созданного макета будет использоваться ручная реализация макета, даже если &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; не вызывается. Чтобы отказаться от этого поведения, вам нужно будет явно вызвать &lt;code&gt;jest.unmock('moduleName')&lt;/code&gt; в тестах, которые должны использовать фактическую реализацию модуля.</target>
        </trans-unit>
        <trans-unit id="f71f327fabbf5c0637780926759d884ef99d4c6f" translate="yes" xml:space="preserve">
          <source>When an assertion fails, the error message should give as much signal as necessary to the user so they can resolve their issue quickly. You should craft a precise failure message to make sure users of your custom assertions have a good developer experience.</source>
          <target state="translated">Когда утверждение не удается,сообщение об ошибке должно давать столько сигнала,сколько необходимо пользователю,чтобы он мог быстро решить свою проблему.Вы должны создать точное сообщение об ошибке,чтобы убедиться,что пользователи ваших пользовательских утверждений имеют хороший опыт работы с разработчиками.</target>
        </trans-unit>
        <trans-unit id="92e3cf49c2e3a6035ec045cc54417bfd2ccb1023" translate="yes" xml:space="preserve">
          <source>When mocking time, &lt;code&gt;Date.now()&lt;/code&gt; will also be mocked. If you for some reason need access to the real current time, you can invoke this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8bace675f1044daa5589643fe0fa171a34a422" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;projects&lt;/code&gt; configuration is provided with an array of paths or glob patterns, Jest will run tests in all of the specified projects at the same time. This is great for monorepos or when working on multiple projects at the same time.</source>
          <target state="translated">Когда конфигурация &lt;code&gt;projects&lt;/code&gt; предоставляется с массивом путей или шаблонов глобусов, Jest будет запускать тесты во всех указанных проектах одновременно. Это отлично подходит для монорепозиториев или при одновременной работе над несколькими проектами.</target>
        </trans-unit>
        <trans-unit id="000d78fbd56ae8d851f29ec24ab5707f75357361" translate="yes" xml:space="preserve">
          <source>When the mocked function runs out of implementations defined with &lt;code&gt;mockImplementationOnce&lt;/code&gt;, it will execute the default implementation set with &lt;code&gt;jest.fn&lt;/code&gt; (if it is defined):</source>
          <target state="translated">Когда у имитируемой функции заканчивается реализация, определенная с помощью &lt;code&gt;mockImplementationOnce&lt;/code&gt; , она выполнит реализацию по умолчанию, установленную с помощью &lt;code&gt;jest.fn&lt;/code&gt; (если она определена):</target>
        </trans-unit>
        <trans-unit id="af9f009231011568611cfa6e9ad01b0075f8a8f9" translate="yes" xml:space="preserve">
          <source>When the mocked function runs out of implementations defined with mockImplementationOnce, it will execute the default implementation set with &lt;code&gt;jest.fn(() =&amp;gt; defaultValue)&lt;/code&gt; or &lt;code&gt;.mockImplementation(() =&amp;gt; defaultValue)&lt;/code&gt; if they were called:</source>
          <target state="translated">Когда у макетированной функции заканчиваются реализации, определенные с помощью mockImplementationOnce, она выполнит реализацию по умолчанию, установленную с помощью &lt;code&gt;jest.fn(() =&amp;gt; defaultValue)&lt;/code&gt; или &lt;code&gt;.mockImplementation(() =&amp;gt; defaultValue)&lt;/code&gt; если они были вызваны:</target>
        </trans-unit>
        <trans-unit id="efd67d9a5d58ddfafd6576c76e2d2b45c6a9f072" translate="yes" xml:space="preserve">
          <source>When this API is called, all pending macro-tasks and micro-tasks will be executed. If those tasks themselves schedule new tasks, those will be continually exhausted until there are no more tasks remaining in the queue.</source>
          <target state="translated">При вызове этого API будут выполнены все отложенные макро-задачи и микро-задачи.Если эти задачи сами по себе планируют новые задачи,то они будут постоянно исчерпываться до тех пор,пока в очереди не останется ни одной задачи.</target>
        </trans-unit>
        <trans-unit id="a158c79d89cb2f08512d4bfd3dd789cc435d27dc" translate="yes" xml:space="preserve">
          <source>When this API is called, all pending micro-tasks that have been queued via &lt;code&gt;process.nextTick&lt;/code&gt; will be executed. Additionally, if those micro-tasks themselves schedule new micro-tasks, those will be continually exhausted until there are no more micro-tasks remaining in the queue.</source>
          <target state="translated">При вызове этого API будут выполнены все незавершенные микрозадачи, поставленные в очередь через &lt;code&gt;process.nextTick&lt;/code&gt; . Кроме того, если эти микрозадачи сами планируют новые микрозадачи, они будут постоянно исчерпываться, пока в очереди не останется больше микрозадач.</target>
        </trans-unit>
        <trans-unit id="de6b8c35376469c436481e4abc3ac0840d106da8" translate="yes" xml:space="preserve">
          <source>When this API is called, all timers are advanced by &lt;code&gt;msToRun&lt;/code&gt; milliseconds. All pending &quot;macro-tasks&quot; that have been queued via &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval()&lt;/code&gt;, and would be executed within this time frame will be executed. Additionally if those macro-tasks schedule new macro-tasks that would be executed within the same time frame, those will be executed until there are no more macro-tasks remaining in the queue, that should be run within &lt;code&gt;msToRun&lt;/code&gt; milliseconds.</source>
          <target state="translated">При вызове этого API все таймеры продвигаются на миллисекунды &lt;code&gt;msToRun&lt;/code&gt; . Будут выполнены все ожидающие выполнения &amp;laquo;макро-задачи&amp;raquo;, которые были поставлены в очередь через &lt;code&gt;setTimeout()&lt;/code&gt; или &lt;code&gt;setInterval()&lt;/code&gt; и будут выполнены в течение этого периода времени. Кроме того, если эти макро-задачи планируют новые макро-задачи, которые будут выполняться в течение того же периода времени, они будут выполняться до тех пор, пока в очереди не останется больше макро-задач, которые должны выполняться в &lt;code&gt;msToRun&lt;/code&gt; миллисекунд msToRun .</target>
        </trans-unit>
        <trans-unit id="6a3d81ee3b01c0089e78905262e5dca231d9597b" translate="yes" xml:space="preserve">
          <source>When this API is called, all timers are advanced by &lt;code&gt;msToRun&lt;/code&gt; milliseconds. All pending &quot;macro-tasks&quot; that have been queued via &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval()&lt;/code&gt;, and would be executed within this time frame will be executed. Additionally, if those macro-tasks schedule new macro-tasks that would be executed within the same time frame, those will be executed until there are no more macro-tasks remaining in the queue, that should be run within &lt;code&gt;msToRun&lt;/code&gt; milliseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9dca7721cf62aeb16db42f482a108cce06f06d2" translate="yes" xml:space="preserve">
          <source>When this option is provided, Jest will assume it is running in a CI environment. This changes the behavior when a new snapshot is encountered. Instead of the regular behavior of storing a new snapshot automatically, it will fail the test and require Jest to be run with &lt;code&gt;--updateSnapshot&lt;/code&gt;.</source>
          <target state="translated">Когда предоставляется эта опция, Jest предполагает, что он работает в среде CI. Это изменяет поведение при обнаружении нового снимка. Вместо обычного автоматического сохранения нового снимка он не пройдет проверку и потребует, чтобы Jest был запущен с &lt;code&gt;--updateSnapshot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea2ae246f66a28582d68b56f98e9832a105b042f" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;babel-jest&lt;/code&gt;, calls to &lt;code&gt;mock&lt;/code&gt; will automatically be hoisted to the top of the code block. Use this method if you want to explicitly avoid this behavior.</source>
          <target state="translated">При использовании &lt;code&gt;babel-jest&lt;/code&gt; вызовы &lt;code&gt;mock&lt;/code&gt; автоматически переносятся в верхнюю часть блока кода. Используйте этот метод, если вы хотите явно избежать такого поведения.</target>
        </trans-unit>
        <trans-unit id="18b0443351a14618ca1bcb5f6aa3542dc98f4cfe" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;babel-jest&lt;/code&gt;, calls to &lt;code&gt;unmock&lt;/code&gt; will automatically be hoisted to the top of the code block. Use this method if you want to explicitly avoid this behavior.</source>
          <target state="translated">При использовании &lt;code&gt;babel-jest&lt;/code&gt; вызовы &lt;code&gt;unmock&lt;/code&gt; автоматически переносятся в верхнюю часть блока кода. Используйте этот метод, если вы хотите явно избежать такого поведения.</target>
        </trans-unit>
        <trans-unit id="f978d44fe3f641d915d3d23a0599b90ede804e61" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--config&lt;/code&gt; option, the JSON file must not contain a &quot;jest&quot; key:</source>
          <target state="translated">При использовании параметра &lt;code&gt;--config&lt;/code&gt; файл JSON не должен содержать ключа &quot;шутки&quot;:</target>
        </trans-unit>
        <trans-unit id="04fedd264e30315e94d0bfc357d0d1a8b0ecd6f0" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;factory&lt;/code&gt; parameter for an ES6 module with a default export, the &lt;code&gt;__esModule: true&lt;/code&gt; property needs to be specified. This property is normally generated by Babel / TypeScript, but here it needs to be set manually. When importing a default export, it's an instruction to import the property named &lt;code&gt;default&lt;/code&gt; from the export object:</source>
          <target state="translated">При использовании &lt;code&gt;factory&lt;/code&gt; параметра для модуля ES6 с экспортом по умолчанию необходимо &lt;code&gt;__esModule: true&lt;/code&gt; свойство __esModule: true . Это свойство обычно генерируется Babel / TypeScript, но здесь его нужно установить вручную. При импорте экспорта по умолчанию это инструкция для импорта свойства с именем &lt;code&gt;default&lt;/code&gt; из объекта экспорта:</target>
        </trans-unit>
        <trans-unit id="2d001438addabfdc9a62c0bd086018e034d25a28" translate="yes" xml:space="preserve">
          <source>When we require that module in our tests, explicitly calling &lt;code&gt;jest.mock('./moduleName')&lt;/code&gt; is &lt;strong&gt;required&lt;/strong&gt;.</source>
          <target state="translated">Когда мы требуем , чтобы модуль в наших тестах, явно вызывая &lt;code&gt;jest.mock('./moduleName')&lt;/code&gt; будет &lt;strong&gt;необходим&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="703ab40aa1656fee5bd7fb985cc5ca7e7af24578" translate="yes" xml:space="preserve">
          <source>When you are debugging a large test file, you will often only want to run a subset of tests. You can use &lt;code&gt;.only&lt;/code&gt; to specify which tests are the only ones you want to run in that test file.</source>
          <target state="translated">Когда вы отлаживаете большой тестовый файл, вам часто нужно запускать только подмножество тестов. Вы можете использовать &lt;code&gt;.only&lt;/code&gt; , чтобы указать, какие тесты вы хотите запускать только в этом тестовом файле.</target>
        </trans-unit>
        <trans-unit id="7d76e8040b92fed0c690e41513159f4832164a34" translate="yes" xml:space="preserve">
          <source>When you are maintaining a large codebase, you may sometimes find a test that is temporarily broken for some reason. If you want to skip running this test, but you don't want to delete this code, you can use &lt;code&gt;test.skip&lt;/code&gt; to specify some tests to skip.</source>
          <target state="translated">Когда вы поддерживаете большую базу кода, иногда вы можете обнаружить, что тест по какой-то причине временно не работает. Если вы хотите пропустить запуск этого теста, но не хотите удалять этот код, вы можете использовать &lt;code&gt;test.skip&lt;/code&gt; , чтобы указать некоторые тесты, которые нужно пропустить.</target>
        </trans-unit>
        <trans-unit id="8d417a3cdc1c802c0f3ae5fcb03331fd9db749a0" translate="yes" xml:space="preserve">
          <source>When you need to recreate a complex behavior of a mock function such that multiple function calls produce different results, use the &lt;code&gt;mockImplementationOnce&lt;/code&gt; method:</source>
          <target state="translated">Когда вам нужно воссоздать сложное поведение фиктивной функции, при котором несколько вызовов функций приводят к разным результатам, используйте метод &lt;code&gt;mockImplementationOnce&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0933ea7e8d1f77a530a24c9128f18fb45e5eb8fc" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;jest&lt;/code&gt; with an argument, that argument is treated as a regular expression to match against files in your project. It is possible to run test suites by providing a pattern. Only the files that the pattern matches will be picked up and executed. Depending on your terminal, you may need to quote this argument: &lt;code&gt;jest &quot;my.*(complex)?pattern&quot;&lt;/code&gt;. On Windows, you will need to use &lt;code&gt;/&lt;/code&gt; as a path separator or escape &lt;code&gt;\&lt;/code&gt; as &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="translated">Когда вы запускаете &lt;code&gt;jest&lt;/code&gt; с аргументом, этот аргумент обрабатывается как регулярное выражение для сопоставления с файлами в вашем проекте. Можно запускать наборы тестов, предоставив шаблон. Будут выбраны и выполнены только те файлы, которым соответствует шаблон. В зависимости от вашего терминала вам может потребоваться процитировать этот аргумент: &lt;code&gt;jest &quot;my.*(complex)?pattern&quot;&lt;/code&gt; . В Windows вам нужно будет использовать &lt;code&gt;/&lt;/code&gt; как разделитель путей или экранировать &lt;code&gt;\&lt;/code&gt; как &lt;code&gt;\\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68715485bd1666aefca572f144099e2aa37bff4b" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;yarn test&lt;/code&gt; or &lt;code&gt;jest&lt;/code&gt;, this will produce an output file like this:</source>
          <target state="translated">Когда вы запускаете &lt;code&gt;yarn test&lt;/code&gt; или &lt;code&gt;jest&lt;/code&gt; , это создаст выходной файл, подобный этому:</target>
        </trans-unit>
        <trans-unit id="a48c34ee84029428f3840a2f252c786c6d129c3b" translate="yes" xml:space="preserve">
          <source>When you're writing tests, you often need to check that values meet certain conditions. &lt;code&gt;expect&lt;/code&gt; gives you access to a number of &quot;matchers&quot; that let you validate different things.</source>
          <target state="translated">Когда вы пишете тесты, вам часто нужно проверить, соответствуют ли значения определенным условиям. &lt;code&gt;expect&lt;/code&gt; дает вам доступ к ряду &amp;laquo;сопоставителей&amp;raquo;, которые позволяют вам проверять разные вещи.</target>
        </trans-unit>
        <trans-unit id="1895f1fdbdf511f9d8c3b27d739559dc512e7472" translate="yes" xml:space="preserve">
          <source>Whether to use &lt;a href=&quot;https://facebook.github.io/watchman/&quot;&gt;&lt;code&gt;watchman&lt;/code&gt;&lt;/a&gt; for file crawling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6727f0146af0d44b58e9f9d090e4a61fff19955d" translate="yes" xml:space="preserve">
          <source>Whether to use &lt;a href=&quot;https://facebook.github.io/watchman/&quot;&gt;&lt;code&gt;watchman&lt;/code&gt;&lt;/a&gt; for file crawling. Defaults to &lt;code&gt;true&lt;/code&gt;. Disable using &lt;code&gt;--no-watchman&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35131e0d0e9059a4bd01bbcebb7af6e82ca76302" translate="yes" xml:space="preserve">
          <source>Whether to use the cache. Defaults to true. Disable the cache using &lt;code&gt;--no-cache&lt;/code&gt;. &lt;em&gt;Note: the cache should only be disabled if you are experiencing caching related problems. On average, disabling the cache makes Jest at least two times slower.&lt;/em&gt;</source>
          <target state="translated">Использовать ли кеш. По умолчанию true. Отключите кеш с помощью &lt;code&gt;--no-cache&lt;/code&gt; . &lt;em&gt;Примечание: кеш следует отключать только в случае возникновения проблем, связанных с кешированием. В среднем отключение кеша замедляет работу Jest как минимум в два раза.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="83164f909bcd8fc7ba78df4e824b24177b294067" translate="yes" xml:space="preserve">
          <source>Whether to use watchman for file crawling. Defaults to true. Disable using &lt;code&gt;--no-watchman&lt;/code&gt;.</source>
          <target state="translated">Использовать ли сторож для сканирования файлов. По умолчанию true. Отключите использование &lt;code&gt;--no-watchman&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1d2275b123b75427db7b2987318a2d50b013b7a" translate="yes" xml:space="preserve">
          <source>While Jest is most of the time extremely fast on modern multi-core computers with fast SSDs, it may be slow on certain setups as our users &lt;a href=&quot;https://github.com/facebook/jest/issues/1395&quot;&gt;have&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/jest/issues/1524#issuecomment-260246008&quot;&gt;discovered&lt;/a&gt;.</source>
          <target state="translated">Хотя Jest является большую часть времени чрезвычайно быстро на современных многоядерных компьютерах с быстрым SSD - накопителей, он может быть медленным на некоторых установках , как наши пользователи &lt;a href=&quot;https://github.com/facebook/jest/issues/1395&quot;&gt;уже &lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/jest/issues/1524#issuecomment-260246008&quot;&gt;обнаружили&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c1e359c575a75195c82ced579ca21229a1a43b9" translate="yes" xml:space="preserve">
          <source>While we generally recommend using the same version of every Jest package, this workaround will allow you to continue using the latest version of Jest with Babel 6 for now.</source>
          <target state="translated">Хотя мы обычно рекомендуем использовать одну и ту же версию каждого пакета &quot;Шут&quot;,этот обходной путь позволит вам продолжить использование последней версии &quot;Шутки&quot; с Babel 6 на данный момент.</target>
        </trans-unit>
        <trans-unit id="0ab9c7998614f26e4eb6805b1167e05ce5311b6e" translate="yes" xml:space="preserve">
          <source>Will result in this error:</source>
          <target state="translated">Приведет к этой ошибке:</target>
        </trans-unit>
        <trans-unit id="5924ea10aaabb62ee9bc1364ab2d6c8d39fa4316" translate="yes" xml:space="preserve">
          <source>With all the things set up, we can now write our tests like this:</source>
          <target state="translated">Теперь,когда все настроено,мы можем написать наши тесты вот так:</target>
        </trans-unit>
        <trans-unit id="f75c7b6834fbac10e18f4c82ab03776229eb74e2" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup/Teardown&lt;/a&gt; and &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; APIs, Jest can work smoothly with &lt;a href=&quot;https://aws.amazon.com/dynamodb/&quot;&gt;DynamoDB&lt;/a&gt;.</source>
          <target state="translated">Благодаря API-интерфейсам &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup / Teardown&lt;/a&gt; и &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; , Jest может без проблем работать с &lt;a href=&quot;https://aws.amazon.com/dynamodb/&quot;&gt;DynamoDB&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09d67fc0b64d61790fbe51d618d9c01a71c9767f" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup/Teardown&lt;/a&gt; and &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; APIs, Jest can work smoothly with &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt;.</source>
          <target state="translated">Благодаря API-интерфейсам &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup / Teardown&lt;/a&gt; и &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; , Jest может без проблем работать с &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;кукольником&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="efe0a1fdb2d38cad4bc73937febc9018ab5dfa08" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup/Teardown&lt;/a&gt; and &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; APIs, Jest can work smoothly with &lt;a href=&quot;https://www.mongodb.com/&quot;&gt;MongoDB&lt;/a&gt;.</source>
          <target state="translated">Благодаря API-интерфейсам &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup / Teardown&lt;/a&gt; и &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; , Jest может без проблем работать с &lt;a href=&quot;https://www.mongodb.com/&quot;&gt;MongoDB&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65847eb738fbe06a57caae0a366f5485491b7ed4" translate="yes" xml:space="preserve">
          <source>With the warnings out of the way, this is how you activate ESM support in your tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7a7d359c8bb23694d685fdf6e2b5cde46a49ff3" translate="yes" xml:space="preserve">
          <source>Write test results to a file when the &lt;code&gt;--json&lt;/code&gt; option is also specified. The returned JSON structure is documented in &lt;a href=&quot;configuration#testresultsprocessor-string&quot;&gt;testResultsProcessor&lt;/a&gt;.</source>
          <target state="translated">Записывать результаты теста в файл, если также &lt;code&gt;--json&lt;/code&gt; параметр --json . &lt;a href=&quot;configuration#testresultsprocessor-string&quot;&gt;Возвращенная&lt;/a&gt; структура JSON задокументирована в testResultsProcessor .</target>
        </trans-unit>
        <trans-unit id="391b1a9608423cb9c4d16a7886b9e07fab1acb00" translate="yes" xml:space="preserve">
          <source>Write tests</source>
          <target state="translated">Пишите тесты</target>
        </trans-unit>
        <trans-unit id="694bf05e5891dd2e709b08f7b1d50372246946ee" translate="yes" xml:space="preserve">
          <source>Write your test</source>
          <target state="translated">Напиши свой тест</target>
        </trans-unit>
        <trans-unit id="94ba98a24cca1fad5979f2e2b8b87aa24d441f8b" translate="yes" xml:space="preserve">
          <source>Writing tests using the &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; syntax is also possible. Here is how you'd write the same examples from before:</source>
          <target state="translated">Также возможно написание тестов с использованием синтаксиса &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; . Вот как можно было бы написать те же примеры, что и раньше:</target>
        </trans-unit>
        <trans-unit id="13442293f45d32c9c4218756254e61b25c456f59" translate="yes" xml:space="preserve">
          <source>Yes, all snapshot files should be committed alongside the modules they are covering and their tests. They should be considered part of a test, similar to the value of any other assertion in Jest. In fact, snapshots represent the state of the source modules at any given point in time. In this way, when the source modules are modified, Jest can tell what changed from the previous version. It can also provide a lot of additional context during code review in which reviewers can study your changes better.</source>
          <target state="translated">Да,все файлы снимков должны быть зафиксированы вместе с модулями,которые они покрывают и их тестами.Их следует рассматривать как часть теста,аналогично тому,как и любое другое утверждение в Jest.Фактически,снэпшоты представляют собой состояние исходных модулей в любой момент времени.Таким образом,при изменении исходных модулей,Jest может определить,что изменилось по сравнению с предыдущей версией.Он также может предоставить много дополнительного контекста при просмотре кода,в котором рецензенты могут лучше изучить ваши изменения.</target>
        </trans-unit>
        <trans-unit id="5059d1df734052fa39f05d1a230ebef9c450fdf6" translate="yes" xml:space="preserve">
          <source>Yes, as well as with any other test.</source>
          <target state="translated">Да,как и с любым другим тестом.</target>
        </trans-unit>
        <trans-unit id="933a2cbd693a2fc8e1c7cc9d0a79a6433195d072" translate="yes" xml:space="preserve">
          <source>You avoid limits to configuration that might cause you to eject from &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;create-react-app&lt;/a&gt;.</source>
          <target state="translated">Вы избегаете ограничений конфигурации, из-за которых вы можете выйти из приложения &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;create-react-app&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="406cbbf63f4fe22d5b8ccaa5240411c1502ac6c2" translate="yes" xml:space="preserve">
          <source>You can also hook up puppeteer from scratch. The basic idea is to:</source>
          <target state="translated">Также можно подцепить кукловода с нуля.Основная идея в том:</target>
        </trans-unit>
        <trans-unit id="35aff70317c576091536adc5e1a43d87f6a53f1b" translate="yes" xml:space="preserve">
          <source>You can also nest &lt;code&gt;describe&lt;/code&gt; blocks if you have a hierarchy of tests:</source>
          <target state="translated">Вы также можете вложить блоки &lt;code&gt;describe&lt;/code&gt; если у вас есть иерархия тестов:</target>
        </trans-unit>
        <trans-unit id="ecbf1217eb1b7413e5ac5532b9f18df62cd10cea" translate="yes" xml:space="preserve">
          <source>You can also pass an array of objects, in which case the method will return true only if each object in the received array matches (in the &lt;code&gt;toMatchObject&lt;/code&gt; sense described above) the corresponding object in the expected array. This is useful if you want to check that two arrays match in their number of elements, as opposed to &lt;code&gt;arrayContaining&lt;/code&gt;, which allows for extra elements in the received array.</source>
          <target state="translated">Вы также можете передать массив объектов, и в этом случае метод вернет true, только если каждый объект в полученном массиве совпадает (в смысле &lt;code&gt;toMatchObject&lt;/code&gt; , описанном выше) с соответствующим объектом в ожидаемом массиве. Это полезно, если вы хотите проверить совпадение двух массивов по количеству элементов, в отличие от &lt;code&gt;arrayContaining&lt;/code&gt; , который позволяет добавлять дополнительные элементы в полученный массив.</target>
        </trans-unit>
        <trans-unit id="33e631cdb46e5194143ae6343251d5d4abeebe0e" translate="yes" xml:space="preserve">
          <source>You can also test for the opposite of a matcher:</source>
          <target state="translated">Вы также можете протестировать на противоположность матча:</target>
        </trans-unit>
        <trans-unit id="766ae758010f2b190e41fbbc693bc28b84e8247c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;.resolves&lt;/code&gt; matcher in your expect statement, and Jest will wait for that promise to resolve. If the promise is rejected, the test will automatically fail.</source>
          <target state="translated">Вы также можете использовать сопоставитель &lt;code&gt;.resolves&lt;/code&gt; в своем операторе ожидания, и Jest будет ждать выполнения этого обещания. Если обещание отклонено, тест автоматически завершится неудачно.</target>
        </trans-unit>
        <trans-unit id="c23acb6b8a75eb059d0bf1a92f11f8a674f5b5ac" translate="yes" xml:space="preserve">
          <source>You can call &lt;code&gt;expect.addSnapshotSerializer&lt;/code&gt; to add a module that formats application-specific data structures.</source>
          <target state="translated">Вы можете вызвать &lt;code&gt;expect.addSnapshotSerializer&lt;/code&gt; , чтобы добавить модуль, форматирующий структуры данных для конкретного приложения.</target>
        </trans-unit>
        <trans-unit id="b0148d2ae9957ac3475428862737e46004f4bc04" translate="yes" xml:space="preserve">
          <source>You can check if an array or iterable contains a particular item using &lt;code&gt;toContain&lt;/code&gt;:</source>
          <target state="translated">Вы можете проверить, содержит ли массив или итерация определенный элемент, используя &lt;code&gt;toContain&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2d51d93712488643fb65c1c14ffe4c74aaa71d14" translate="yes" xml:space="preserve">
          <source>You can check strings against regular expressions with &lt;code&gt;toMatch&lt;/code&gt;:</source>
          <target state="translated">Вы можете проверять строки на соответствие регулярным выражениям с помощью &lt;code&gt;toMatch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e25edb586f40e9238795e2ba9b6c0d4c65291a8a" translate="yes" xml:space="preserve">
          <source>You can cherry pick specific features of Jest and use them as standalone packages. Here's a list of the available packages:</source>
          <target state="translated">Вы можете вишнёвым цветом выбрать специфические особенности Jest и использовать их как самостоятельные пакеты.Вот список доступных пакетов:</target>
        </trans-unit>
        <trans-unit id="42fd15afca8b3c0e27f3602b1bb8b499e91c1c6b" translate="yes" xml:space="preserve">
          <source>You can collect coverage from those files with setting &lt;code&gt;forceCoverageMatch&lt;/code&gt;.</source>
          <target state="translated">Вы можете получить покрытие из этих файлов с помощью параметра &lt;code&gt;forceCoverageMatch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0087ca484c125dc235349950ec51d13f3336f610" translate="yes" xml:space="preserve">
          <source>You can combine &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; with &lt;code&gt;.resolves&lt;/code&gt; or &lt;code&gt;.rejects&lt;/code&gt;.</source>
          <target state="translated">Вы можете комбинировать &lt;code&gt;async&lt;/code&gt; и &lt;code&gt;await&lt;/code&gt; с &lt;code&gt;.resolves&lt;/code&gt; или &lt;code&gt;.rejects&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d20f2b42e97c65aaef925a2c6a3961d0c033857b" translate="yes" xml:space="preserve">
          <source>You can create your own module that will be used for setting up the test environment. The module must export a class with &lt;code&gt;setup&lt;/code&gt;, &lt;code&gt;teardown&lt;/code&gt; and &lt;code&gt;runScript&lt;/code&gt; methods. You can also pass variables from this module to your test suites by assigning them to &lt;code&gt;this.global&lt;/code&gt; object &amp;ndash; this will make them available in your test suites as global variables.</source>
          <target state="translated">Вы можете создать свой собственный модуль, который будет использоваться для настройки тестовой среды. Модуль должен экспортировать класс с &lt;code&gt;teardown&lt;/code&gt; &lt;code&gt;setup&lt;/code&gt; , teardown и &lt;code&gt;runScript&lt;/code&gt; . Вы также можете передавать переменные из этого модуля в свои наборы тестов, назначая их объекту &lt;code&gt;this.global&lt;/code&gt; - это сделает их доступными в ваших наборах тестов в качестве глобальных переменных.</target>
        </trans-unit>
        <trans-unit id="1ef2f94dd57c5898c7b5cdef5978ab020627b6d9" translate="yes" xml:space="preserve">
          <source>You can match properties against values or against matchers.</source>
          <target state="translated">Вы можете сравнивать свойства со значениями или с матчами.</target>
        </trans-unit>
        <trans-unit id="f8d7a47b61e8074001017d01760195a44daa7d92" translate="yes" xml:space="preserve">
          <source>You can optionally provide a name for your mock functions, which will be displayed instead of &quot;jest.fn()&quot; in test error output. Use this if you want to be able to quickly identify the mock function reporting an error in your test output.</source>
          <target state="translated">В качестве опции вы можете указать имя для ваших имитационных функций,которое будет отображаться вместо &quot;jest.fn()&quot; в выводе ошибки теста.Используйте это имя,если хотите быстро определить функцию имитации,сообщающую об ошибке на выходе теста.</target>
        </trans-unit>
        <trans-unit id="62ba1633de645d2b4f3bdc636d51dbe0464a51e7" translate="yes" xml:space="preserve">
          <source>You can optionally provide a name for your mock functions, which will be displayed instead of &quot;jest.fn()&quot; in the test error output. Use this if you want to be able to quickly identify the mock function reporting an error in your test output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="141547ac2059520c584383a103038c5f0023150f" translate="yes" xml:space="preserve">
          <source>You can pass configuration to a transformer like &lt;code&gt;{filePattern: ['path-to-transformer', {options}]}&lt;/code&gt; For example, to configure babel-jest for non-default behavior, &lt;code&gt;{&quot;\\.js$&quot;: ['babel-jest', {rootMode: &quot;upward&quot;}]}&lt;/code&gt;</source>
          <target state="translated">Вы можете передать конфигурацию преобразователю, например &lt;code&gt;{filePattern: ['path-to-transformer', {options}]}&lt;/code&gt; Например, чтобы настроить babel-jest на нестандартное поведение, &lt;code&gt;{&quot;\\.js$&quot;: ['babel-jest', {rootMode: &quot;upward&quot;}]}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="800cb883045942cfd5bb4081f8af395b4c78910d" translate="yes" xml:space="preserve">
          <source>You can provide an optional &lt;code&gt;hint&lt;/code&gt; string argument that is appended to the test name. Although Jest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate &lt;strong&gt;multiple&lt;/strong&gt; snapshots in a &lt;strong&gt;single&lt;/strong&gt;&lt;code&gt;it&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; block. Jest sorts snapshots by name in the corresponding &lt;code&gt;.snap&lt;/code&gt; file.</source>
          <target state="translated">Вы можете указать необязательный аргумент строки &lt;code&gt;hint&lt;/code&gt; который будет добавлен к имени теста. Хотя Jest всегда добавляет число в конце имени снимки, короткие описательные подсказки могут быть более полезными , чем числа , чтобы различать &lt;strong&gt;несколько&lt;/strong&gt; снимков в &lt;strong&gt;едином &lt;/strong&gt; &lt;code&gt;it&lt;/code&gt; или &lt;code&gt;test&lt;/code&gt; блок. Jest сортирует снимки по имени в соответствующем файле &lt;code&gt;.snap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4cc4d175319a45a401106b9809e576146487b0b9" translate="yes" xml:space="preserve">
          <source>You can provide an optional &lt;code&gt;propertyMatchers&lt;/code&gt; object argument, which has asymmetric matchers as values of a subset of expected properties, &lt;strong&gt;if&lt;/strong&gt; the received value will be an &lt;strong&gt;object&lt;/strong&gt; instance. It is like &lt;code&gt;toMatchObject&lt;/code&gt; with flexible criteria for a subset of properties, followed by a snapshot test as exact criteria for the rest of the properties.</source>
          <target state="translated">Вы можете предоставить необязательный аргумент объекта &lt;code&gt;propertyMatchers&lt;/code&gt; , который имеет асимметричные сопоставители как значения подмножества ожидаемых свойств, &lt;strong&gt;если&lt;/strong&gt; полученное значение будет экземпляром &lt;strong&gt;объекта&lt;/strong&gt; . Это похоже на &lt;code&gt;toMatchObject&lt;/code&gt; с гибкими критериями для подмножества свойств, за которым следует тест снимка в качестве точных критериев для остальных свойств.</target>
        </trans-unit>
        <trans-unit id="342a9b14684325992d5ff139401436ae7682dd1a" translate="yes" xml:space="preserve">
          <source>You can provide an optional &lt;code&gt;value&lt;/code&gt; argument to compare the received property value (recursively for all properties of object instances, also known as deep equality, like the &lt;code&gt;toEqual&lt;/code&gt; matcher).</source>
          <target state="translated">Вы можете предоставить необязательный аргумент &lt;code&gt;value&lt;/code&gt; для сравнения полученного значения свойства (рекурсивно для всех свойств экземпляров объекта, также известного как глубокое равенство, например сопоставление &lt;code&gt;toEqual&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ecc5cea913bac7656555fb5571fc70b6c18f354b" translate="yes" xml:space="preserve">
          <source>You can provide an optional argument to test that a specific error is thrown:</source>
          <target state="translated">Вы можете предоставить необязательный аргумент для проверки того,что конкретная ошибка выбрасывается:</target>
        </trans-unit>
        <trans-unit id="c0387678f500b8dabacd6ece5ed81ebc2dad87e6" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-changed-files&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-changed-files/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">Вы можете прочитать больше о &lt;code&gt;jest-changed-files&lt;/code&gt; в &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-changed-files/README.md&quot;&gt;файле readme&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a117882f05bee0eb2692567e191ce66d663578e1" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-docblock&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-docblock/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше о &lt;code&gt;jest-docblock&lt;/code&gt; в &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-docblock/README.md&quot;&gt;файле readme&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46c165debafb7322f712fc6e454196637356e378" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-validate&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-validate/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше о &lt;code&gt;jest-validate&lt;/code&gt; в &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-validate/README.md&quot;&gt;файле readme&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2867c6d937c4005f8963139f59e55ad836a6852b" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-worker&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-worker/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше о &lt;code&gt;jest-worker&lt;/code&gt; в &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-worker/README.md&quot;&gt;файле readme&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d429e36c0ed20b800a39f032d046273b4cea53be" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;pretty-format&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/pretty-format/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше о &lt;code&gt;pretty-format&lt;/code&gt; в &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/pretty-format/README.md&quot;&gt;файле readme&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f91698c99b451b48fdef94d8133ba660ee4beb14" translate="yes" xml:space="preserve">
          <source>You can replace all of the above mocks in order to change the implementation, for a single test or all tests, by calling &lt;code&gt;mockImplementation()&lt;/code&gt; on the existing mock.</source>
          <target state="translated">Вы можете заменить все вышеперечисленные макеты, чтобы изменить реализацию для одного теста или всех тестов, вызвав &lt;code&gt;mockImplementation()&lt;/code&gt; для существующего макета.</target>
        </trans-unit>
        <trans-unit id="563bf00a2d98bb36c45fffa7a2f6aab090a1748e" translate="yes" xml:space="preserve">
          <source>You can retrieve Jest's default options to expand them if needed:</source>
          <target state="translated">При необходимости вы можете получить стандартные параметры Jest,чтобы расширить их:</target>
        </trans-unit>
        <trans-unit id="31bd27fefd08851ca3968f0ceda8045022a66264" translate="yes" xml:space="preserve">
          <source>You can run Jest directly from the CLI (if it's globally available in your &lt;code&gt;PATH&lt;/code&gt;, e.g. by &lt;code&gt;yarn global add jest&lt;/code&gt; or &lt;code&gt;npm install jest --global&lt;/code&gt;) with a variety of useful options.</source>
          <target state="translated">Вы можете запускать Jest непосредственно из интерфейса командной строки (если он глобально доступен в вашем &lt;code&gt;PATH&lt;/code&gt; , например, с помощью &lt;code&gt;yarn global add jest&lt;/code&gt; или &lt;code&gt;npm install jest --global&lt;/code&gt; ) с множеством полезных опций.</target>
        </trans-unit>
        <trans-unit id="bef775ff4d1e2656f1b8b8b28d2f88eef6be39e0" translate="yes" xml:space="preserve">
          <source>You can see an example of using Jest with TypeScript in our &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/typescript&quot;&gt;GitHub repository&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f225c905306c2c0014f6ff2fdd68b6007152b521" translate="yes" xml:space="preserve">
          <source>You can try out this functionality by cloning the &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/snapshot&quot;&gt;snapshot example&lt;/a&gt;, modifying the &lt;code&gt;Link&lt;/code&gt; component, and running Jest.</source>
          <target state="translated">Вы можете опробовать эту функцию, клонировав &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/snapshot&quot;&gt;пример снимка&lt;/a&gt; , изменив компонент &lt;code&gt;Link&lt;/code&gt; и запустив Jest.</target>
        </trans-unit>
        <trans-unit id="a5ed2e627ad2f097c8fe5c0666910c34f57925f1" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;describe.only&lt;/code&gt; if you want to run only one describe block:</source>
          <target state="translated">Вы можете использовать &lt;code&gt;describe.only&lt;/code&gt; , если хотите запустить только один блок описания:</target>
        </trans-unit>
        <trans-unit id="221b7b5d130528a59256d65bc2c5c5ab8c11adbb" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;describe.skip&lt;/code&gt; if you do not want to run a particular describe block:</source>
          <target state="translated">Вы можете использовать &lt;code&gt;describe.skip&lt;/code&gt; если не хотите запускать конкретный блок описания:</target>
        </trans-unit>
        <trans-unit id="29de8e17dc9a604ab72ee70bda29920afbd2d460" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;expect.extend&lt;/code&gt; to add your own matchers to Jest. For example, let's say that you're testing a number utility library and you're frequently asserting that numbers appear within particular ranges of other numbers. You could abstract that into a &lt;code&gt;toBeWithinRange&lt;/code&gt; matcher:</source>
          <target state="translated">Вы можете использовать &lt;code&gt;expect.extend&lt;/code&gt; , чтобы добавлять в Jest собственные сопоставления. Например, предположим, что вы тестируете библиотеку утилит для чисел и часто утверждаете, что числа появляются в определенных диапазонах других чисел. Вы можете абстрагировать это в сопоставлении &lt;code&gt;toBeWithinRange&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ce0b3ff83dde595fbf23f5b27e23e12d03a726e9" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;jest.MockedClass&lt;/code&gt; to represent a class that has been replaced by a Jest mock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883638c32cfdbaf6b10f47ce10c2b95fc3e1af40" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;jest.MockedFunction&lt;/code&gt; to represent a function that has been replaced by a Jest mock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="414d019cf0872729a505b6b1f50111cb1ce5b29d" translate="yes" xml:space="preserve">
          <source>You can use an &lt;a href=&quot;https://github.com/keyanzhang/identity-obj-proxy&quot;&gt;ES6 Proxy&lt;/a&gt; to mock &lt;a href=&quot;https://github.com/css-modules/css-modules&quot;&gt;CSS Modules&lt;/a&gt;:</source>
          <target state="translated">Вы можете использовать &lt;a href=&quot;https://github.com/keyanzhang/identity-obj-proxy&quot;&gt;прокси ES6&lt;/a&gt; для имитации &lt;a href=&quot;https://github.com/css-modules/css-modules&quot;&gt;модулей CSS&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e0ca37e74baa1f002bba25e20997f296e5781557" translate="yes" xml:space="preserve">
          <source>You can use it instead of a literal value:</source>
          <target state="translated">Вы можете использовать его вместо буквального значения:</target>
        </trans-unit>
        <trans-unit id="c085c131693a018bbc7ee86b6ff86c3192e859b0" translate="yes" xml:space="preserve">
          <source>You could comment the test out, but it's often a bit nicer to use &lt;code&gt;test.skip&lt;/code&gt; because it will maintain indentation and syntax highlighting.</source>
          <target state="translated">Вы можете прокомментировать тест, но часто лучше использовать &lt;code&gt;test.skip&lt;/code&gt; , потому что он будет поддерживать отступы и подсветку синтаксиса.</target>
        </trans-unit>
        <trans-unit id="5359ed25529846e45ba23e420d5b9e5c6713de18" translate="yes" xml:space="preserve">
          <source>You could write &lt;code&gt;expect(bestDrinkForFlavor('octopus')).toBe(undefined)&lt;/code&gt;, but it's better practice to avoid referring to &lt;code&gt;undefined&lt;/code&gt; directly in your code.</source>
          <target state="translated">Вы можете написать &lt;code&gt;expect(bestDrinkForFlavor('octopus')).toBe(undefined)&lt;/code&gt; , но лучше избегать ссылки на &lt;code&gt;undefined&lt;/code&gt; прямо в коде.</target>
        </trans-unit>
        <trans-unit id="1ba59aa451c75435f919998f9ebfc1c5a8dd95b2" translate="yes" xml:space="preserve">
          <source>You could write &lt;code&gt;expect(fetchNewFlavorIdea()).not.toBe(undefined)&lt;/code&gt;, but it's better practice to avoid referring to &lt;code&gt;undefined&lt;/code&gt; directly in your code.</source>
          <target state="translated">Вы можете написать &lt;code&gt;expect(fetchNewFlavorIdea()).not.toBe(undefined)&lt;/code&gt; , но лучше избегать ссылки на &lt;code&gt;undefined&lt;/code&gt; прямо в коде.</target>
        </trans-unit>
        <trans-unit id="88ed689c2ae9512a449e124212b726dc5d4e0c96" translate="yes" xml:space="preserve">
          <source>You have to run &lt;code&gt;yarn add --dev @testing-library/react&lt;/code&gt; to use react-testing-library.</source>
          <target state="translated">Вам нужно запустить &lt;code&gt;yarn add --dev @testing-library/react&lt;/code&gt; чтобы использовать react-testing-library.</target>
        </trans-unit>
        <trans-unit id="c2580df5ede4388981be8693d0eb04cda44e78ad" translate="yes" xml:space="preserve">
          <source>You have to run &lt;code&gt;yarn add --dev enzyme&lt;/code&gt; to use Enzyme. If you are using a React version below 15.5.0, you will also need to install &lt;code&gt;react-addons-test-utils&lt;/code&gt;.</source>
          <target state="translated">Чтобы использовать Enzyme, вам нужно запустить &lt;code&gt;yarn add --dev enzyme&lt;/code&gt; . Если вы используете версию React ниже 15.5.0, вам также потребуется установить response &lt;code&gt;react-addons-test-utils&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ab8163799282eb2cd2bcd483eb50ba23a2e1feb" translate="yes" xml:space="preserve">
          <source>You make the dependency explicit instead of implicit.</source>
          <target state="translated">Вы делаете зависимость явной,а не неявной.</target>
        </trans-unit>
        <trans-unit id="08d47da002fb02d0ffc5edc25d616083fbc6a387" translate="yes" xml:space="preserve">
          <source>You may also want to install the &lt;a href=&quot;https://www.npmjs.com/package/@types/jest&quot;&gt;&lt;code&gt;@types/jest&lt;/code&gt;&lt;/a&gt; module for the version of Jest you're using. This will help provide full typing when writing your tests with TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c38db17ba138256cbd5a96be8f1e6dc538f5fa8" translate="yes" xml:space="preserve">
          <source>You may not care what &lt;code&gt;getErrors&lt;/code&gt; returns, specifically - it might return &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;0&lt;/code&gt;, and your code would still work. So if you want to test there are no errors after drinking some La Croix, you could write:</source>
          <target state="translated">Вам может быть все равно, что возвращает &lt;code&gt;getErrors&lt;/code&gt; , в частности - он может вернуть &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;0&lt;/code&gt; , и ваш код все равно будет работать. Итак, если вы хотите проверить, нет ли ошибок после того, как выпили немного La Croix, вы можете написать:</target>
        </trans-unit>
        <trans-unit id="c89edf49de3c63952efdcc592f2e40d0e91b763b" translate="yes" xml:space="preserve">
          <source>You may not care what &lt;code&gt;thirstInfo&lt;/code&gt; returns, specifically - it might return &lt;code&gt;true&lt;/code&gt; or a complex object, and your code would still work. So if you want to test that &lt;code&gt;thirstInfo&lt;/code&gt; will be truthy after drinking some La Croix, you could write:</source>
          <target state="translated">Вам может быть все равно, что возвращает &lt;code&gt;thirstInfo&lt;/code&gt; , в частности - он может вернуть &lt;code&gt;true&lt;/code&gt; или сложный объект, и ваш код все равно будет работать. Так что если вы хотите проверить , что &lt;code&gt;thirstInfo&lt;/code&gt; будет truthy выпив некоторое La Croix, вы могли бы написать:</target>
        </trans-unit>
        <trans-unit id="17b4764286d414a473eaaf4d566a76ce25182294" translate="yes" xml:space="preserve">
          <source>You should use the matcher that most precisely corresponds to what you want your code to be doing.</source>
          <target state="translated">Вы должны использовать матчер,который наиболее точно соответствует тому,что вы хотите,чтобы ваш код делал.</target>
        </trans-unit>
        <trans-unit id="7f37219870fbd51ab28f12639a113236e2ba5334" translate="yes" xml:space="preserve">
          <source>You will find a number of example test cases in the &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples&quot;&gt;&lt;code&gt;examples&lt;/code&gt;&lt;/a&gt; folder on GitHub. You can also learn from the excellent tests used by the &lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react/src/__tests__&quot;&gt;React&lt;/a&gt;, &lt;a href=&quot;https://github.com/facebook/relay/tree/master/packages/react-relay/__tests__&quot;&gt;Relay&lt;/a&gt;, and &lt;a href=&quot;https://github.com/facebook/react-native/tree/master/Libraries/Animated/src/__tests__&quot;&gt;React Native&lt;/a&gt; projects.</source>
          <target state="translated">Вы найдете несколько примеров тестовых случаев в папке &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples&quot;&gt; &lt;code&gt;examples&lt;/code&gt; &lt;/a&gt; на GitHub. Вы также можете поучиться на превосходных тестах, используемых в проектах &lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react/src/__tests__&quot;&gt;React&lt;/a&gt; , &lt;a href=&quot;https://github.com/facebook/relay/tree/master/packages/react-relay/__tests__&quot;&gt;Relay&lt;/a&gt; и &lt;a href=&quot;https://github.com/facebook/react-native/tree/master/Libraries/Animated/src/__tests__&quot;&gt;React Native&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7eb67e376c7a0795313a9464135b5632741a836" translate="yes" xml:space="preserve">
          <source>Your &lt;code&gt;package.json&lt;/code&gt; should look something like this (where &lt;code&gt;&amp;lt;current-version&amp;gt;&lt;/code&gt; is the actual latest version number for the package). Please add the scripts and jest configuration entries:</source>
          <target state="translated">Ваш &lt;code&gt;package.json&lt;/code&gt; должен выглядеть примерно так (где &lt;code&gt;&amp;lt;current-version&amp;gt;&lt;/code&gt; - актуальный номер последней версии пакета). Пожалуйста, добавьте скрипты и записи конфигурации jest:</target>
        </trans-unit>
        <trans-unit id="ec89bd1c5f68c024aeca6e9e14636486318a74fe" translate="yes" xml:space="preserve">
          <source>Your test will want to mock the &lt;code&gt;fetch&lt;/code&gt; function so that we can be sure that it gets called without actually making the network request. However, you'll also need to mock the return value of &lt;code&gt;fetch&lt;/code&gt; with a &lt;code&gt;Response&lt;/code&gt; (wrapped in a &lt;code&gt;Promise&lt;/code&gt;), as our function uses it to grab the created user's ID. So you might initially try writing a test like this:</source>
          <target state="translated">Ваш тест захочет &lt;code&gt;fetch&lt;/code&gt; функцию выборки, чтобы мы могли быть уверены, что она вызывается без фактического выполнения сетевого запроса. Однако вам также потребуется имитировать возвращаемое значение &lt;code&gt;fetch&lt;/code&gt; с помощью &lt;code&gt;Response&lt;/code&gt; (завернутого в &lt;code&gt;Promise&lt;/code&gt; ), поскольку наша функция использует его для получения идентификатора созданного пользователя. Итак, вы можете сначала попробовать написать такой тест:</target>
        </trans-unit>
        <trans-unit id="1175cedc7032117d3657edf28dbe7bb9385d7c5c" translate="yes" xml:space="preserve">
          <source>Your tests should be deterministic. Running the same tests multiple times on a component that has not changed should produce the same results every time. You're responsible for making sure your generated snapshots do not include platform specific or other non-deterministic data.</source>
          <target state="translated">Твои тесты должны быть детерминированными.Многократный запуск одних и тех же тестов на не изменившемся компоненте должен каждый раз давать одни и те же результаты.Вы отвечаете за то,чтобы сгенерированные снимки не включали данные,специфичные для платформы,или другие недетерминистические данные.</target>
        </trans-unit>
        <trans-unit id="2f17fc980285f8ffe0be9e33ef7152af13254fe8" translate="yes" xml:space="preserve">
          <source>afterAll()</source>
          <target state="translated">afterAll()</target>
        </trans-unit>
        <trans-unit id="fb268a1811f730c2067165b083e360322d72f477" translate="yes" xml:space="preserve">
          <source>afterEach()</source>
          <target state="translated">afterEach()</target>
        </trans-unit>
        <trans-unit id="9ad6d2fa2c7de85e6b6dd37cd6a886c8f07ad319" translate="yes" xml:space="preserve">
          <source>async-to-gen</source>
          <target state="translated">async-to-gen</target>
        </trans-unit>
        <trans-unit id="bd90b357192cd27b16a70b7698bb14ee20cba402" translate="yes" xml:space="preserve">
          <source>awesome-jest</source>
          <target state="translated">awesome-jest</target>
        </trans-unit>
        <trans-unit id="d09b0fbfb51ee1470bcc585dd8ce8dfa55e488df" translate="yes" xml:space="preserve">
          <source>beforeAll()</source>
          <target state="translated">beforeAll()</target>
        </trans-unit>
        <trans-unit id="c70978f19975e8b38cf044b33e31fad2d272183a" translate="yes" xml:space="preserve">
          <source>beforeEach()</source>
          <target state="translated">beforeEach()</target>
        </trans-unit>
        <trans-unit id="740e438d6d95b968c3b9aaa798d54c124e64790b" translate="yes" xml:space="preserve">
          <source>close puppeteer with Global Teardown</source>
          <target state="translated">близкий кукловод с Global Teardown</target>
        </trans-unit>
        <trans-unit id="53cdcf56a867665dc933b593cb499286aadcbc80" translate="yes" xml:space="preserve">
          <source>connect to puppeteer from each Test Environment</source>
          <target state="translated">подключаться к кукловоду из каждой тестовой среды</target>
        </trans-unit>
        <trans-unit id="25509aa65c3b573b5425ab6624df82134524f006" translate="yes" xml:space="preserve">
          <source>default: &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">по умолчанию: &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8244e80092f3c12d77f6dd509da0f653409320b" translate="yes" xml:space="preserve">
          <source>describe()</source>
          <target state="translated">describe()</target>
        </trans-unit>
        <trans-unit id="398a5e26f7d6ff23078ffbb871957ca77291b3e7" translate="yes" xml:space="preserve">
          <source>describe.each()</source>
          <target state="translated">describe.each()</target>
        </trans-unit>
        <trans-unit id="4f24a48da5c59a6bd3845bdb54350e1d1d0ee38d" translate="yes" xml:space="preserve">
          <source>describe.only()</source>
          <target state="translated">describe.only()</target>
        </trans-unit>
        <trans-unit id="f11fce8c9ed55e7be7b2cbcc6e46f524b949f14e" translate="yes" xml:space="preserve">
          <source>describe.only.each()</source>
          <target state="translated">describe.only.each()</target>
        </trans-unit>
        <trans-unit id="c3382b09895d6af2c9e821d96ad003e58d4b96de" translate="yes" xml:space="preserve">
          <source>describe.skip()</source>
          <target state="translated">describe.skip()</target>
        </trans-unit>
        <trans-unit id="2c446c6cd1bf47770ef8c7d1bd166c465eedf771" translate="yes" xml:space="preserve">
          <source>describe.skip.each()</source>
          <target state="translated">describe.skip.each()</target>
        </trans-unit>
        <trans-unit id="fcf239e7993ef571d39b364c0de3fda8a3ae0c81" translate="yes" xml:space="preserve">
          <source>error class: error object is &lt;strong&gt;instance of&lt;/strong&gt; class</source>
          <target state="translated">класс ошибки: объект ошибки является &lt;strong&gt;экземпляром&lt;/strong&gt; класса</target>
        </trans-unit>
        <trans-unit id="7851c6709a8adac9e962eee4f13a4ff8d35c84c6" translate="yes" xml:space="preserve">
          <source>error object: error message is &lt;strong&gt;equal to&lt;/strong&gt; the message property of the object</source>
          <target state="translated">объект ошибки: сообщение об ошибке &lt;strong&gt;равно&lt;/strong&gt; свойству сообщения объекта</target>
        </trans-unit>
        <trans-unit id="a00f641af4b4bd382b037a5599ec8c6bd2a58a7a" translate="yes" xml:space="preserve">
          <source>eslint-plugin-jest</source>
          <target state="translated">eslint-plugin-jest</target>
        </trans-unit>
        <trans-unit id="3aede15b1d5d318f2bf628e79d06cd5ec821f235" translate="yes" xml:space="preserve">
          <source>expect()</source>
          <target state="translated">expect()</target>
        </trans-unit>
        <trans-unit id="c531f8f49210f5c5cc7e56c0bcf8809390d60182" translate="yes" xml:space="preserve">
          <source>expect.addSnapshotSerializer()</source>
          <target state="translated">expect.addSnapshotSerializer()</target>
        </trans-unit>
        <trans-unit id="73052babf147d5ab7087790cf489001a5fe6adef" translate="yes" xml:space="preserve">
          <source>expect.any()</source>
          <target state="translated">expect.any()</target>
        </trans-unit>
        <trans-unit id="041f3593b4cfc38ec52995cb888e8d017339e912" translate="yes" xml:space="preserve">
          <source>expect.anything()</source>
          <target state="translated">expect.anything()</target>
        </trans-unit>
        <trans-unit id="b1648f49219a878c2221460718595da8c398b8b3" translate="yes" xml:space="preserve">
          <source>expect.arrayContaining()</source>
          <target state="translated">expect.arrayContaining()</target>
        </trans-unit>
        <trans-unit id="07105ad3d99570c6ffdfd4ccea4770093ccd6589" translate="yes" xml:space="preserve">
          <source>expect.assertions()</source>
          <target state="translated">expect.assertions()</target>
        </trans-unit>
        <trans-unit id="cf206af29db6d448d19d0b2896ed0f7be77ca4b2" translate="yes" xml:space="preserve">
          <source>expect.extend()</source>
          <target state="translated">expect.extend()</target>
        </trans-unit>
        <trans-unit id="bef0c4a5294c45e4f23630650c298423d2b0033a" translate="yes" xml:space="preserve">
          <source>expect.hasAssertions()</source>
          <target state="translated">expect.hasAssertions()</target>
        </trans-unit>
        <trans-unit id="a4b4f299cc5121ba5bb42d780d793dd0d208d5d1" translate="yes" xml:space="preserve">
          <source>expect.not.arrayContaining()</source>
          <target state="translated">expect.not.arrayContaining()</target>
        </trans-unit>
        <trans-unit id="cd369cc867e384fabaa81e31b91e2ec5e06cb648" translate="yes" xml:space="preserve">
          <source>expect.not.objectContaining()</source>
          <target state="translated">expect.not.objectContaining()</target>
        </trans-unit>
        <trans-unit id="c3e51c2efa41f651e0f4da6911e099a7e6ae1ca4" translate="yes" xml:space="preserve">
          <source>expect.not.stringContaining()</source>
          <target state="translated">expect.not.stringContaining()</target>
        </trans-unit>
        <trans-unit id="1146b5bca92b76c491171096be15657da9f28d46" translate="yes" xml:space="preserve">
          <source>expect.not.stringMatching()</source>
          <target state="translated">expect.not.stringMatching()</target>
        </trans-unit>
        <trans-unit id="a323da51fabb3d791f0b36ac04909baab7f19868" translate="yes" xml:space="preserve">
          <source>expect.objectContaining()</source>
          <target state="translated">expect.objectContaining()</target>
        </trans-unit>
        <trans-unit id="05a9b81e11194231b386c00515a14089ffa1ab48" translate="yes" xml:space="preserve">
          <source>expect.stringContaining()</source>
          <target state="translated">expect.stringContaining()</target>
        </trans-unit>
        <trans-unit id="64a818d5f4128d542c68ad3e5b52cf9cb07239c5" translate="yes" xml:space="preserve">
          <source>expect.stringMatching()</source>
          <target state="translated">expect.stringMatching()</target>
        </trans-unit>
        <trans-unit id="5b53271817c17d31475c2601f79c760d8c18c932" translate="yes" xml:space="preserve">
          <source>in &lt;code&gt;toEqual&lt;/code&gt; or &lt;code&gt;toBeCalledWith&lt;/code&gt;</source>
          <target state="translated">в &lt;code&gt;toEqual&lt;/code&gt; или &lt;code&gt;toBeCalledWith&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14fdeea7a02add9f25f4b254a8109cebfb41a968" translate="yes" xml:space="preserve">
          <source>jest</source>
          <target state="translated">jest</target>
        </trans-unit>
        <trans-unit id="399f3e6c7d355276f40f586cacf83580961e34e9" translate="yes" xml:space="preserve">
          <source>jest --bail</source>
          <target state="translated">шутка-поручительство</target>
        </trans-unit>
        <trans-unit id="7728f73469dcbf23ae8e337f07d557f5387051c2" translate="yes" xml:space="preserve">
          <source>jest --cache</source>
          <target state="translated">кэш-память</target>
        </trans-unit>
        <trans-unit id="a4aa246751c414496487d54530974546f8e2e1a7" translate="yes" xml:space="preserve">
          <source>jest --changedFilesWithAncestor</source>
          <target state="translated">шутка-изменённые файлыС предком</target>
        </trans-unit>
        <trans-unit id="e4435b17b912dad78333d9c715e558d3c202ab34" translate="yes" xml:space="preserve">
          <source>jest --changedSince</source>
          <target state="translated">шутка-изменилсяСанс</target>
        </trans-unit>
        <trans-unit id="b5261799c92dd14f3365e36279542409dc1f4470" translate="yes" xml:space="preserve">
          <source>jest --ci</source>
          <target state="translated">шутка...</target>
        </trans-unit>
        <trans-unit id="18b3b63f5ed9f4cb059fbdfa287a7092d2bd46c8" translate="yes" xml:space="preserve">
          <source>jest --clearCache</source>
          <target state="translated">шутка --clearCache</target>
        </trans-unit>
        <trans-unit id="6b45786c23204e16069d34c716fc3df38b6aa6b3" translate="yes" xml:space="preserve">
          <source>jest --collectCoverageFrom</source>
          <target state="translated">шутка-сборПокрытие от</target>
        </trans-unit>
        <trans-unit id="16739578c7f61b7a8f8542434d00d6ab09963e57" translate="yes" xml:space="preserve">
          <source>jest --colors</source>
          <target state="translated">шуточные цвета</target>
        </trans-unit>
        <trans-unit id="16996765a63984335bd12471e86885562b954705" translate="yes" xml:space="preserve">
          <source>jest --config</source>
          <target state="translated">шутка-конфигурация</target>
        </trans-unit>
        <trans-unit id="ecd47d28d6d16f7e198f7bb676071b8de7aa625f" translate="yes" xml:space="preserve">
          <source>jest --coverage</source>
          <target state="translated">шутово-охватывание</target>
        </trans-unit>
        <trans-unit id="200e04fecf37753c77869affc65b05074a843073" translate="yes" xml:space="preserve">
          <source>jest --debug</source>
          <target state="translated">это...отладка</target>
        </trans-unit>
        <trans-unit id="d0896a807b1438960db7baa7a96cc00d29eb6fbf" translate="yes" xml:space="preserve">
          <source>jest --detectOpenHandles</source>
          <target state="translated">-detectOpenHandles</target>
        </trans-unit>
        <trans-unit id="1edb0e7b6eaef88efb6ed9a604136e0b2dc3df91" translate="yes" xml:space="preserve">
          <source>jest --env</source>
          <target state="translated">-всегда</target>
        </trans-unit>
        <trans-unit id="8a0f943b937dcd72c06bfe59afe73fb4a1f31d48" translate="yes" xml:space="preserve">
          <source>jest --errorOnDeprecated</source>
          <target state="translated">шутка...Уничтожена.</target>
        </trans-unit>
        <trans-unit id="451e3f27037c6eaedc5c0ee1528d6ecd3860ad73" translate="yes" xml:space="preserve">
          <source>jest --expand</source>
          <target state="translated">шутка-расширение</target>
        </trans-unit>
        <trans-unit id="75a8e4a783be5089515d60538e7e8125cdd33fe3" translate="yes" xml:space="preserve">
          <source>jest --findRelatedTests</source>
          <target state="translated">шутка-найденоРелевые тесты</target>
        </trans-unit>
        <trans-unit id="4959c728768cddd33ed24149b8756c30f1461b6c" translate="yes" xml:space="preserve">
          <source>jest --forceExit</source>
          <target state="translated">шутка-форс-выход</target>
        </trans-unit>
        <trans-unit id="e7042ae5c15d17e9dfb626d3b992b070a2b33ac3" translate="yes" xml:space="preserve">
          <source>jest --help</source>
          <target state="translated">шутка --помощь</target>
        </trans-unit>
        <trans-unit id="2b44f9af93a63dbc353bdbb59b8977473460ea15" translate="yes" xml:space="preserve">
          <source>jest --init</source>
          <target state="translated">шутка-нит</target>
        </trans-unit>
        <trans-unit id="b472735c07ba84430b5dcc73a9578211df4a2c7a" translate="yes" xml:space="preserve">
          <source>jest --json</source>
          <target state="translated">шутка...Джсон</target>
        </trans-unit>
        <trans-unit id="67842930eb4c451f524a5334d5d9987f944c0b62" translate="yes" xml:space="preserve">
          <source>jest --lastCommit</source>
          <target state="translated">шутка-последняя ставка</target>
        </trans-unit>
        <trans-unit id="5ef4898fedf76393b34edae0c0c9eb5f9becbdb5" translate="yes" xml:space="preserve">
          <source>jest --listTests</source>
          <target state="translated">шутка-листТесты</target>
        </trans-unit>
        <trans-unit id="68a8e8c37228016d5b69d8f98bc9033444f6dcfc" translate="yes" xml:space="preserve">
          <source>jest --logHeapUsage</source>
          <target state="translated">шутка --logHeapUsage</target>
        </trans-unit>
        <trans-unit id="34e1461f0465c9780fed87f508481d93f147883c" translate="yes" xml:space="preserve">
          <source>jest --maxConcurrency</source>
          <target state="translated">шутка --макс-валюта</target>
        </trans-unit>
        <trans-unit id="ff2ced6c82113057178b44c26a4df8d1cfcde5ad" translate="yes" xml:space="preserve">
          <source>jest --maxWorkers</source>
          <target state="translated">шутка --maxWorkers</target>
        </trans-unit>
        <trans-unit id="8c8c93cffedf5f51fbf6769d1b9f4b08296e0a72" translate="yes" xml:space="preserve">
          <source>jest --noStackTrace</source>
          <target state="translated">шутка --noStackTrace</target>
        </trans-unit>
        <trans-unit id="07fe4de480c74eb982dfd2fc1ffabbc5e8000f9a" translate="yes" xml:space="preserve">
          <source>jest --notify</source>
          <target state="translated">пошутить-уведомить</target>
        </trans-unit>
        <trans-unit id="777939208a77b6ed85265bb3541e0aaf5212fbb3" translate="yes" xml:space="preserve">
          <source>jest --onlyChanged</source>
          <target state="translated">шутка-только Шутка</target>
        </trans-unit>
        <trans-unit id="39d9ffe9fc23f87610839ef7d3409e4bdcaeb08c" translate="yes" xml:space="preserve">
          <source>jest --outputFile</source>
          <target state="translated">шутка-выпускФайл</target>
        </trans-unit>
        <trans-unit id="709a7d88446a6c333c370abdc7cbc81e5007aeb4" translate="yes" xml:space="preserve">
          <source>jest --passWithNoTests</source>
          <target state="translated">шутка-без испытаний</target>
        </trans-unit>
        <trans-unit id="c01b9e323723244523c23d1edd20bbd8fa1fad8b" translate="yes" xml:space="preserve">
          <source>jest --projects</source>
          <target state="translated">шуточные проекты</target>
        </trans-unit>
        <trans-unit id="28ccc63c68da10265b442f6ddb719c32cb336d21" translate="yes" xml:space="preserve">
          <source>jest --reporters</source>
          <target state="translated">шутники-репортёры</target>
        </trans-unit>
        <trans-unit id="64629dd6eadf22a13bedf72b140ffb326b3adf10" translate="yes" xml:space="preserve">
          <source>jest --runInBand</source>
          <target state="translated">шутка --runInBand</target>
        </trans-unit>
        <trans-unit id="6d7004d9e45fbe7afc81b68d019a0999a9bc0c7c" translate="yes" xml:space="preserve">
          <source>jest --runTestsByPath</source>
          <target state="translated">шутка --runTestsByPath</target>
        </trans-unit>
        <trans-unit id="096d835c379fd03e494f9bdb3bd4cbf0d83b2f71" translate="yes" xml:space="preserve">
          <source>jest --setupTestFrameworkScriptFile</source>
          <target state="translated">шутка --setupTestFrameworkScriptFile</target>
        </trans-unit>
        <trans-unit id="940e5b5b259afe41c7f972448e3b14ae829486ab" translate="yes" xml:space="preserve">
          <source>jest --showConfig</source>
          <target state="translated">шутка-шоуКонфиг</target>
        </trans-unit>
        <trans-unit id="a19e9fb882999e3c40b7635bba97bd9c793f3561" translate="yes" xml:space="preserve">
          <source>jest --silent</source>
          <target state="translated">шутливый-тихий</target>
        </trans-unit>
        <trans-unit id="3116d8e92505df6e40aa26ca10c8d3a5aefaf6af" translate="yes" xml:space="preserve">
          <source>jest --testLocationInResults</source>
          <target state="translated">шутка-тестЛокализацияРезульты</target>
        </trans-unit>
        <trans-unit id="8a07b564f31bb6e6c96720d77231a8a1e45f39e3" translate="yes" xml:space="preserve">
          <source>jest --testNamePattern</source>
          <target state="translated">шутка-testNamePattern</target>
        </trans-unit>
        <trans-unit id="4de2b306577ed62d6f8717e3427fffb985e1b43b" translate="yes" xml:space="preserve">
          <source>jest --testPathIgnorePatterns</source>
          <target state="translated">шутка-testPathIgnorePatterns</target>
        </trans-unit>
        <trans-unit id="c6d599e9db1d5b8b8b9b1e34af131cc7a609574c" translate="yes" xml:space="preserve">
          <source>jest --testPathPattern</source>
          <target state="translated">шутка-тестPathPattern</target>
        </trans-unit>
        <trans-unit id="f1e05395a90bfd20cc69363133868bb63d439c51" translate="yes" xml:space="preserve">
          <source>jest --testRunner</source>
          <target state="translated">шутка-тестRunner</target>
        </trans-unit>
        <trans-unit id="a107d7a62c0faae9d219c603e662cbdfb1168139" translate="yes" xml:space="preserve">
          <source>jest --testSequencer</source>
          <target state="translated">шутка-тестСеквенсер</target>
        </trans-unit>
        <trans-unit id="c7ef133f2b7dc919c3ad71da9cce4c6ffd6cd868" translate="yes" xml:space="preserve">
          <source>jest --testTimeout</source>
          <target state="translated">шутка-испытаниеTimeout</target>
        </trans-unit>
        <trans-unit id="855f8a66c2044d0c0aa8ce263401b44fa1019b06" translate="yes" xml:space="preserve">
          <source>jest --updateSnapshot</source>
          <target state="translated">шутка -обновлениеSnapshot</target>
        </trans-unit>
        <trans-unit id="4ea12447858a50cdd5c983e5da4ab87dbdf7bf88" translate="yes" xml:space="preserve">
          <source>jest --useStderr</source>
          <target state="translated">шутка-использованиеStderr</target>
        </trans-unit>
        <trans-unit id="f073ca0513417405f3d24492d3c2e48be87f71de" translate="yes" xml:space="preserve">
          <source>jest --verbose</source>
          <target state="translated">шутка --вербоза</target>
        </trans-unit>
        <trans-unit id="8144cdc86e9d7837063cedb0371d26f3eec4e393" translate="yes" xml:space="preserve">
          <source>jest --version</source>
          <target state="translated">шутка --версия</target>
        </trans-unit>
        <trans-unit id="24a92c60d5aa0d0bc0a04e89176cbe3de81ca593" translate="yes" xml:space="preserve">
          <source>jest --watch</source>
          <target state="translated">шутка-часы</target>
        </trans-unit>
        <trans-unit id="4a0c8c57a84aa98a2040ae7e753c42a9d15607d0" translate="yes" xml:space="preserve">
          <source>jest --watchAll</source>
          <target state="translated">шутка-все</target>
        </trans-unit>
        <trans-unit id="8357ee4077e5c430d196688e7e00e4f2b5298f39" translate="yes" xml:space="preserve">
          <source>jest --watchman</source>
          <target state="translated">шутник-часовой</target>
        </trans-unit>
        <trans-unit id="8dac8b8cbde7c22969d69a11d630521076ff0471" translate="yes" xml:space="preserve">
          <source>jest-changed-files</source>
          <target state="translated">jest-changed-files</target>
        </trans-unit>
        <trans-unit id="b54512fd3b9795a4772b2657ce0156724195ce07" translate="yes" xml:space="preserve">
          <source>jest-codemods</source>
          <target state="translated">jest-codemods</target>
        </trans-unit>
        <trans-unit id="4d0ba9791c912565a89e87ec93cd71cdc4b75579" translate="yes" xml:space="preserve">
          <source>jest-diff</source>
          <target state="translated">jest-diff</target>
        </trans-unit>
        <trans-unit id="fae57be3b9d4c6db0129364d146af1ae34bc4571" translate="yes" xml:space="preserve">
          <source>jest-docblock</source>
          <target state="translated">jest-docblock</target>
        </trans-unit>
        <trans-unit id="33815f7eafadf66bdf82b692a5d7500e04bdcf17" translate="yes" xml:space="preserve">
          <source>jest-extended</source>
          <target state="translated">jest-extended</target>
        </trans-unit>
        <trans-unit id="7a5cb26800c7666578e96bedb106ca6c76db8288" translate="yes" xml:space="preserve">
          <source>jest-get-type</source>
          <target state="translated">jest-get-type</target>
        </trans-unit>
        <trans-unit id="9930457414d8318490b519406b0d01e0c0af9388" translate="yes" xml:space="preserve">
          <source>jest-validate</source>
          <target state="translated">jest-validate</target>
        </trans-unit>
        <trans-unit id="74459ea621c5c89c1a6a8777f420f08a699ce618" translate="yes" xml:space="preserve">
          <source>jest-worker</source>
          <target state="translated">jest-worker</target>
        </trans-unit>
        <trans-unit id="b5268823984999cb437a77b35d87876782899202" translate="yes" xml:space="preserve">
          <source>jest.advanceTimersByTime()</source>
          <target state="translated">jest.advanceTimersByTime()</target>
        </trans-unit>
        <trans-unit id="4f84712675c1d51a3df5e0c8bc41ac8a5291b5b5" translate="yes" xml:space="preserve">
          <source>jest.advanceTimersToNextTimer()</source>
          <target state="translated">jest.advanceTimersToNextTimer()</target>
        </trans-unit>
        <trans-unit id="926befda6fecbd4a52674619f3af9b0e7f68fc1e" translate="yes" xml:space="preserve">
          <source>jest.clearAllMocks()</source>
          <target state="translated">jest.clearAllMocks()</target>
        </trans-unit>
        <trans-unit id="4222fbb57b1accc14807b98d10122439d4ff5022" translate="yes" xml:space="preserve">
          <source>jest.clearAllTimers()</source>
          <target state="translated">jest.clearAllTimers()</target>
        </trans-unit>
        <trans-unit id="c805b56432a104b93bac2f37dc3d95d0ee13d1ef" translate="yes" xml:space="preserve">
          <source>jest.disableAutomock()</source>
          <target state="translated">jest.disableAutomock()</target>
        </trans-unit>
        <trans-unit id="37431f3778ecbfb714d3adbd0be802b5c721c30f" translate="yes" xml:space="preserve">
          <source>jest.doMock()</source>
          <target state="translated">jest.doMock()</target>
        </trans-unit>
        <trans-unit id="e1eb654d0e6f9a86254eb54aacafc37839145bc6" translate="yes" xml:space="preserve">
          <source>jest.dontMock()</source>
          <target state="translated">jest.dontMock()</target>
        </trans-unit>
        <trans-unit id="96a8a03defe83d958b13a8db1048b48645fd3459" translate="yes" xml:space="preserve">
          <source>jest.enableAutomock()</source>
          <target state="translated">jest.enableAutomock()</target>
        </trans-unit>
        <trans-unit id="63706588ece2fbb5ee1cbc26ed3cd9b3394a2aa3" translate="yes" xml:space="preserve">
          <source>jest.fn()</source>
          <target state="translated">jest.fn()</target>
        </trans-unit>
        <trans-unit id="5219ae476b088f3b68bcaf6bf0a3ebfe1cd29904" translate="yes" xml:space="preserve">
          <source>jest.genMockFromModule()</source>
          <target state="translated">jest.genMockFromModule()</target>
        </trans-unit>
        <trans-unit id="def17227de8f296f563b72986222dc177bb11d6d" translate="yes" xml:space="preserve">
          <source>jest.getTimerCount()</source>
          <target state="translated">jest.getTimerCount()</target>
        </trans-unit>
        <trans-unit id="124a77d3e596a96e5e22131aaf874ab0b85168bc" translate="yes" xml:space="preserve">
          <source>jest.isMockFunction()</source>
          <target state="translated">jest.isMockFunction()</target>
        </trans-unit>
        <trans-unit id="f59381d1be107811c5f127861c8b25779aac8d08" translate="yes" xml:space="preserve">
          <source>jest.isolateModules()</source>
          <target state="translated">jest.isolateModules()</target>
        </trans-unit>
        <trans-unit id="7fa6adb6c9fe552d5205372a422e3d7869a09385" translate="yes" xml:space="preserve">
          <source>jest.mock()</source>
          <target state="translated">jest.mock()</target>
        </trans-unit>
        <trans-unit id="ea788268b388e4e34786b83b59c434649a2880ba" translate="yes" xml:space="preserve">
          <source>jest.requireActual()</source>
          <target state="translated">jest.requireActual()</target>
        </trans-unit>
        <trans-unit id="eb1640f83eb73de04420583fd51286a6f8f26358" translate="yes" xml:space="preserve">
          <source>jest.requireMock()</source>
          <target state="translated">jest.requireMock()</target>
        </trans-unit>
        <trans-unit id="d6eb5ae9749a1f0bfe615e87dae5660439f11371" translate="yes" xml:space="preserve">
          <source>jest.resetAllMocks()</source>
          <target state="translated">jest.resetAllMocks()</target>
        </trans-unit>
        <trans-unit id="f5adc7f97ed3055597a83e098ddd8044c1732177" translate="yes" xml:space="preserve">
          <source>jest.resetModules()</source>
          <target state="translated">jest.resetModules()</target>
        </trans-unit>
        <trans-unit id="3fafd64547192fe4a73efe5ad2a0deadac3f3422" translate="yes" xml:space="preserve">
          <source>jest.restoreAllMocks()</source>
          <target state="translated">jest.restoreAllMocks()</target>
        </trans-unit>
        <trans-unit id="a948703e7207e3be8661bf6365a632c32226671e" translate="yes" xml:space="preserve">
          <source>jest.retryTimes()</source>
          <target state="translated">jest.retryTimes()</target>
        </trans-unit>
        <trans-unit id="b8ce73ec4b14b469bb28764f3a8c3d19e82ac7b6" translate="yes" xml:space="preserve">
          <source>jest.runAllImmediates()</source>
          <target state="translated">jest.runAllImmediates()</target>
        </trans-unit>
        <trans-unit id="53af7c8ab5fc7e913ecfb6a326b3610f64160176" translate="yes" xml:space="preserve">
          <source>jest.runAllTicks()</source>
          <target state="translated">jest.runAllTicks()</target>
        </trans-unit>
        <trans-unit id="bdd7917ff7ed9b0c8f251b4ed7bfa4aaf2b6152b" translate="yes" xml:space="preserve">
          <source>jest.runAllTimers()</source>
          <target state="translated">jest.runAllTimers()</target>
        </trans-unit>
        <trans-unit id="5f8881d3c2fa2e3c3978c63711cfc41587308941" translate="yes" xml:space="preserve">
          <source>jest.runOnlyPendingTimers()</source>
          <target state="translated">jest.runOnlyPendingTimers()</target>
        </trans-unit>
        <trans-unit id="115ea6be6949d8073195cf40a89a2c53d963f31a" translate="yes" xml:space="preserve">
          <source>jest.setMock()</source>
          <target state="translated">jest.setMock()</target>
        </trans-unit>
        <trans-unit id="e38a82fd2d18d144fa8049c3a4042f3947d71db8" translate="yes" xml:space="preserve">
          <source>jest.setTimeout()</source>
          <target state="translated">jest.setTimeout()</target>
        </trans-unit>
        <trans-unit id="4a21c582c06cb9f55c32d6a0da8083dbef2d04a4" translate="yes" xml:space="preserve">
          <source>jest.spyOn()</source>
          <target state="translated">jest.spyOn()</target>
        </trans-unit>
        <trans-unit id="e51942569d340db8459bde0b3a57da7a3ae5bd19" translate="yes" xml:space="preserve">
          <source>jest.unmock()</source>
          <target state="translated">jest.unmock()</target>
        </trans-unit>
        <trans-unit id="7bdcc5f2e0051948cd9175cbfd47b9f3a5c8a112" translate="yes" xml:space="preserve">
          <source>jest.useFakeTimers()</source>
          <target state="translated">jest.useFakeTimers()</target>
        </trans-unit>
        <trans-unit id="567a022c7ff0ed1eeecf66243bfb760f39f98839" translate="yes" xml:space="preserve">
          <source>jest.useRealTimers()</source>
          <target state="translated">jest.useRealTimers()</target>
        </trans-unit>
        <trans-unit id="d6c73ed242e8279bf8b5008c49164ea76ecca716" translate="yes" xml:space="preserve">
          <source>launch &amp;amp; file the websocket endpoint of puppeteer with Global Setup</source>
          <target state="translated">запустите и зарегистрируйте конечную точку websocket кукловода с помощью Global Setup</target>
        </trans-unit>
        <trans-unit id="c5534dc1bf91cfa3f571372cc1df1fde4778c65c" translate="yes" xml:space="preserve">
          <source>matching the files that coverage info needs to be collected from.</source>
          <target state="translated">соответствующие файлам,из которых должна быть собрана информация о покрытии.</target>
        </trans-unit>
        <trans-unit id="bdaf39bbe2e8ce24d626e5d939f2687b7925a111" translate="yes" xml:space="preserve">
          <source>mockFn.getMockName()</source>
          <target state="translated">mockFn.getMockName()</target>
        </trans-unit>
        <trans-unit id="76ba86f80a3975694b82876ec035c67727b880ce" translate="yes" xml:space="preserve">
          <source>mockFn.mock.calls</source>
          <target state="translated">mockFn.mock.calls</target>
        </trans-unit>
        <trans-unit id="b8f5e098751b2e1a0b0c994fa0e253d7b6667585" translate="yes" xml:space="preserve">
          <source>mockFn.mock.instances</source>
          <target state="translated">mockFn.mock.instances</target>
        </trans-unit>
        <trans-unit id="37a607803e67bc8f0e277c4bad07d899cb8e68ee" translate="yes" xml:space="preserve">
          <source>mockFn.mock.results</source>
          <target state="translated">mockFn.mock.results</target>
        </trans-unit>
        <trans-unit id="d7884cf2e18f52e2befafea1329cc93891d01d0e" translate="yes" xml:space="preserve">
          <source>mockFn.mockClear()</source>
          <target state="translated">mockFn.mockClear()</target>
        </trans-unit>
        <trans-unit id="b1a1dc73ee86a9db45f473726c03a5d44e7d6e00" translate="yes" xml:space="preserve">
          <source>mockFn.mockImplementation()</source>
          <target state="translated">mockFn.mockImplementation()</target>
        </trans-unit>
        <trans-unit id="705599d736e3f800c387b8732532a981208d86f3" translate="yes" xml:space="preserve">
          <source>mockFn.mockImplementationOnce()</source>
          <target state="translated">mockFn.mockImplementationOnce()</target>
        </trans-unit>
        <trans-unit id="b15f7560dc442cfe559991bd028b3593dbedcfa3" translate="yes" xml:space="preserve">
          <source>mockFn.mockName()</source>
          <target state="translated">mockFn.mockName()</target>
        </trans-unit>
        <trans-unit id="cbee5a4253c363dd81a99f99a7171fe30ca56500" translate="yes" xml:space="preserve">
          <source>mockFn.mockRejectedValue()</source>
          <target state="translated">mockFn.mockRejectedValue()</target>
        </trans-unit>
        <trans-unit id="f0f879d05ce665721a5b420f915a6b799a9261b3" translate="yes" xml:space="preserve">
          <source>mockFn.mockRejectedValueOnce()</source>
          <target state="translated">mockFn.mockRejectedValueOnce()</target>
        </trans-unit>
        <trans-unit id="6379aa11d6a3d7b94b0cabd0ea38f28a5ac0a66b" translate="yes" xml:space="preserve">
          <source>mockFn.mockReset()</source>
          <target state="translated">mockFn.mockReset()</target>
        </trans-unit>
        <trans-unit id="e5f5a2cc9780e616fb57bcbabbb5e1b492e59a7c" translate="yes" xml:space="preserve">
          <source>mockFn.mockResolvedValue()</source>
          <target state="translated">mockFn.mockResolvedValue()</target>
        </trans-unit>
        <trans-unit id="a610c3278d44712a00c28aba1ba0a5f4c56f4602" translate="yes" xml:space="preserve">
          <source>mockFn.mockResolvedValueOnce()</source>
          <target state="translated">mockFn.mockResolvedValueOnce()</target>
        </trans-unit>
        <trans-unit id="93b4b4162d3f8f9f6743942f1582c22d36cf0434" translate="yes" xml:space="preserve">
          <source>mockFn.mockRestore()</source>
          <target state="translated">mockFn.mockRestore()</target>
        </trans-unit>
        <trans-unit id="b89668bf6eee3709904c8e914501f15481a0ec32" translate="yes" xml:space="preserve">
          <source>mockFn.mockReturnThis()</source>
          <target state="translated">mockFn.mockReturnThis()</target>
        </trans-unit>
        <trans-unit id="8406d4374df6cedb0774c198a5e18305079be058" translate="yes" xml:space="preserve">
          <source>mockFn.mockReturnValue()</source>
          <target state="translated">mockFn.mockReturnValue()</target>
        </trans-unit>
        <trans-unit id="91d18268f60b6021a577b531532180c54eed125c" translate="yes" xml:space="preserve">
          <source>mockFn.mockReturnValueOnce()</source>
          <target state="translated">mockFn.mockReturnValueOnce()</target>
        </trans-unit>
        <trans-unit id="110fd2eef67d470b905e3f770bc78bf0e48c4532" translate="yes" xml:space="preserve">
          <source>moduleNameMapper</source>
          <target state="translated">moduleNameMapper</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="f398e82965b003d86545395906bc58c426a160f4" translate="yes" xml:space="preserve">
          <source>or the following for Windows:</source>
          <target state="translated">или следующее для Windows:</target>
        </trans-unit>
        <trans-unit id="2e4e9d9ce9649c8da277337be899d54f4b10f016" translate="yes" xml:space="preserve">
          <source>pretty-format</source>
          <target state="translated">pretty-format</target>
        </trans-unit>
        <trans-unit id="b41c94dc77a8359c700e959dbc3271747436b9b8" translate="yes" xml:space="preserve">
          <source>react-testing-library</source>
          <target state="translated">react-testing-library</target>
        </trans-unit>
        <trans-unit id="6096aad9326ad51aa7277852583cdbbd0063c505" translate="yes" xml:space="preserve">
          <source>regular expression: error message &lt;strong&gt;matches&lt;/strong&gt; the pattern</source>
          <target state="translated">регулярное выражение: сообщение об ошибке &lt;strong&gt;соответствует&lt;/strong&gt; шаблону</target>
        </trans-unit>
        <trans-unit id="564cb4d408b58135c97baa36f450885bf9df5afd" translate="yes" xml:space="preserve">
          <source>renamed from &lt;code&gt;runTimersToTime&lt;/code&gt; to &lt;code&gt;advanceTimersByTime&lt;/code&gt; in Jest &lt;strong&gt;22.0.0&lt;/strong&gt;</source>
          <target state="translated">переименован из &lt;code&gt;runTimersToTime&lt;/code&gt; в &lt;code&gt;advanceTimersByTime&lt;/code&gt; в Jest &lt;strong&gt;22.0.0&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b081d67ddd0df4286abac590611b195d5398dfcd" translate="yes" xml:space="preserve">
          <source>renamed in Jest &lt;strong&gt;22.0.0+&lt;/strong&gt;</source>
          <target state="translated">переименован в Jest &lt;strong&gt;22.0.0+&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="694331c0b9e2b5401cd9005a2f8016a7f0913ff5" translate="yes" xml:space="preserve">
          <source>renamed in Jest &lt;strong&gt;26.0.0+&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa765d3c5cf61960d9c86c450acc1e2d6113a622" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).not.toBe(expected)&lt;/code&gt; as &lt;code&gt;expect(Object.is(received, expected)).toBe(false)&lt;/code&gt;</source>
          <target state="translated">переписать &lt;code&gt;expect(received).not.toBe(expected)&lt;/code&gt; как ожидаемый &lt;code&gt;expect(Object.is(received, expected)).toBe(false)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12ee99b45418f1c182987feaff420ab1c0a53144" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).not.toEqual(expected)&lt;/code&gt; as &lt;code&gt;expect(received.equals(expected)).toBe(false)&lt;/code&gt;</source>
          <target state="translated">переписать &lt;code&gt;expect(received).not.toEqual(expected)&lt;/code&gt; как ожидаемый &lt;code&gt;expect(received.equals(expected)).toBe(false)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="648a633ae93664b145f1de2382bce78296d0d025" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).toBe(expected)&lt;/code&gt; as &lt;code&gt;expect(Object.is(received, expected)).toBe(true)&lt;/code&gt;</source>
          <target state="translated">перезаписать &lt;code&gt;expect(received).toBe(expected)&lt;/code&gt; как ожидаемый &lt;code&gt;expect(Object.is(received, expected)).toBe(true)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4f197332e08a233e78868954dc8a7424597d992" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).toEqual(expected)&lt;/code&gt; as &lt;code&gt;expect(received.equals(expected)).toBe(true)&lt;/code&gt;</source>
          <target state="translated">перезаписать &lt;code&gt;expect(received).toEqual(expected)&lt;/code&gt; как ожидаемый &lt;code&gt;expect(received.equals(expected)).toBe(true)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98551bd9aa53f809816b1e04556754e5dbd233c3" translate="yes" xml:space="preserve">
          <source>setupFiles</source>
          <target state="translated">setupFiles</target>
        </trans-unit>
        <trans-unit id="cab3c689753017d9ed1c9833b41212afcceb0268" translate="yes" xml:space="preserve">
          <source>string: error message &lt;strong&gt;includes&lt;/strong&gt; the substring</source>
          <target state="translated">строка: сообщение об ошибке &lt;strong&gt;включает&lt;/strong&gt; подстроку</target>
        </trans-unit>
        <trans-unit id="1a13bd67d53c6ca5d0ba854cc1c6d8e1dc4db3cb" translate="yes" xml:space="preserve">
          <source>test()</source>
          <target state="translated">test()</target>
        </trans-unit>
        <trans-unit id="96bc193802c9de785826750faae2c6bc85cbfbb8" translate="yes" xml:space="preserve">
          <source>test.each()</source>
          <target state="translated">test.each()</target>
        </trans-unit>
        <trans-unit id="5d3becd10c06347f68018bdfb99aca7f0ac8047e" translate="yes" xml:space="preserve">
          <source>test.only()</source>
          <target state="translated">test.only()</target>
        </trans-unit>
        <trans-unit id="ab30dfd5db9a31603c2e47fbd6881ec8dab86d26" translate="yes" xml:space="preserve">
          <source>test.only.each()</source>
          <target state="translated">test.only.each()</target>
        </trans-unit>
        <trans-unit id="1176e40f403020d9366a6b52b73ff551f31b1814" translate="yes" xml:space="preserve">
          <source>test.skip()</source>
          <target state="translated">test.skip()</target>
        </trans-unit>
        <trans-unit id="f1d908eaf6e6e7fa35622b4b43d6a8af1a3c660e" translate="yes" xml:space="preserve">
          <source>test.skip.each()</source>
          <target state="translated">test.skip.each()</target>
        </trans-unit>
        <trans-unit id="74875a7933e712e5381bd416043bfb0b6616a91e" translate="yes" xml:space="preserve">
          <source>test.todo()</source>
          <target state="translated">test.todo()</target>
        </trans-unit>
        <trans-unit id="f4cea10a1c0dc3c50965ee387dece60500be5cff" translate="yes" xml:space="preserve">
          <source>to match a property in &lt;code&gt;objectContaining&lt;/code&gt; or &lt;code&gt;toMatchObject&lt;/code&gt;</source>
          <target state="translated">для соответствия свойству в &lt;code&gt;objectContaining&lt;/code&gt; или &lt;code&gt;toMatchObject&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1d3d79ec58192bdcdaff5e0ab0b7fbca133543f" translate="yes" xml:space="preserve">
          <source>to match an element in &lt;code&gt;arrayContaining&lt;/code&gt;</source>
          <target state="translated">для соответствия элементу в &lt;code&gt;arrayContaining&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3556cfc1ba0721081f3f93c076211e40ef1a22b9" translate="yes" xml:space="preserve">
          <source>transformIgnorePatterns customization</source>
          <target state="translated">настройка TransfIgnorePatterns</target>
        </trans-unit>
        <trans-unit id="fc220be1ad7bd8b6a9feda6f6ba1285b333e98e2" translate="yes" xml:space="preserve">
          <source>vscode-jest</source>
          <target state="translated">vscode-jest</target>
        </trans-unit>
        <trans-unit id="5218cb6aea807d0d643ecaa0be3719b154b08685" translate="yes" xml:space="preserve">
          <source>webpack 2 offers native support for ES modules. However, Jest runs in Node, and thus requires ES modules to be transpiled to CommonJS modules. As such, if you are using webpack 2, you most likely will want to configure Babel to transpile ES modules to CommonJS modules only in the &lt;code&gt;test&lt;/code&gt; environment.</source>
          <target state="translated">webpack 2 предлагает встроенную поддержку модулей ES. Однако Jest работает в Node и, следовательно, требует, чтобы модули ES были перенесены в модули CommonJS. Таким образом, если вы используете webpack 2, вы, скорее всего, захотите настроить Babel для преобразования модулей ES в модули CommonJS только в &lt;code&gt;test&lt;/code&gt; среде.</target>
        </trans-unit>
        <trans-unit id="5ebedacdf66fa11ed6c1f1cd9d9b0e19efbf3b58" translate="yes" xml:space="preserve">
          <source>you can use:</source>
          <target state="translated">ты можешь использовать:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
