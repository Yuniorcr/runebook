<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="redux">
    <body>
      <group id="redux">
        <trans-unit id="40839b1c8a38e69ec4218f19c9a385d95915a832" translate="yes" xml:space="preserve">
          <source>It is up to you to try a few options, choose a convention you like, and follow it, whether with, or without the middleware.</source>
          <target state="translated">いくつかのオプションを試してみて、好きな規約を選び、ミドルウェアの有無にかかわらず、それに従うかどうかはあなた次第です。</target>
        </trans-unit>
        <trans-unit id="b392f0ed8ea05e547e964224687831827c136e29" translate="yes" xml:space="preserve">
          <source>It is vital that these Prerequisite Concepts are &lt;strong&gt;thoroughly understood&lt;/strong&gt; before moving on to more advanced and Redux-specific techniques. A recommended reading list is available at:</source>
          <target state="translated">これらの前提条件の概念を&lt;strong&gt;完全に理解&lt;/strong&gt;してから、より高度なRedux固有の手法に進むことが重要です。推奨読書リストは次の場所にあります。</target>
        </trans-unit>
        <trans-unit id="d5fa6252549b34d2727aeeb1fe8e3c816a3d8827" translate="yes" xml:space="preserve">
          <source>It may be helpful to see examples of what the different types of sub-reducer functions look like and how they fit together. Let's look at a demonstration of how a large single reducer function can be refactored into a composition of several smaller functions.</source>
          <target state="translated">さまざまなタイプのサブレデューサ関数がどのように見えるか、また、それらがどのように組み合わされるかの例を見ると参考になるかもしれません。ここでは、大きな単一のリデューサ関数を、いくつかの小さな関数の組み合わせにリファクタリングする方法のデモを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="e02627810b718b477472f1f76a7b34ecc56b8eb7" translate="yes" xml:space="preserve">
          <source>It must never return &lt;code&gt;undefined&lt;/code&gt;. It is too easy to do this by mistake via an early &lt;code&gt;return&lt;/code&gt; statement, so &lt;code&gt;combineReducers&lt;/code&gt; throws if you do that instead of letting the error manifest itself somewhere else.</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; を返してはなりません。初期の &lt;code&gt;return&lt;/code&gt; ステートメントを使用してこれを誤って行うのは簡単すぎるため、エラーを他の場所に表示させる代わりに、 &lt;code&gt;combineReducers&lt;/code&gt; スローした場合にスローします。</target>
        </trans-unit>
        <trans-unit id="b1440628c9081aad68267a2e66c7ba0b0ef6cf7d" translate="yes" xml:space="preserve">
          <source>It needs to be rewritten like this:</source>
          <target state="translated">このように書き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="2003fb7b90831988d1d806aec866ee85ca010393" translate="yes" xml:space="preserve">
          <source>It needs to look at the previous state and the dispatched action, and determine what kind of work needs to be done</source>
          <target state="translated">前の状態と派遣された行動を見て、どのような作業が必要かを判断する必要があります。</target>
        </trans-unit>
        <trans-unit id="5761524a50c8fdeeafeab8c5ae63d8a8423998ef" translate="yes" xml:space="preserve">
          <source>It only exposes a subset of the &lt;a href=&quot;../api/store&quot;&gt;store API&lt;/a&gt; to the middleware: &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/store#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../api/store&quot;&gt;ストアAPIの&lt;/a&gt;サブセットをミドルウェアに公開するだけです：&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;dispatch(action)&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../api/store#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c914355546b42c63de745bfcca2aaeb3e2313f74" translate="yes" xml:space="preserve">
          <source>It seems that reducer isn't the right abstraction, but we're very close.</source>
          <target state="translated">reducerは正しい抽象化ではないようですが、とても近いですね。</target>
        </trans-unit>
        <trans-unit id="beb2e2454ed95b3107fe31d45f50cecc81a6856f" translate="yes" xml:space="preserve">
          <source>It then runs a shallow equality check on its reference to the root state object and the state object passed to it, and a separate series of shallow checks on each reference to the props object&amp;rsquo;s values and those that are returned from running the &lt;code&gt;mapStateToProps&lt;/code&gt; function again.</source>
          <target state="translated">次に、ルート状態オブジェクトへの参照とそれに渡された状態オブジェクトに対して浅い等価性チェックを実行し、propsオブジェクトの値と &lt;code&gt;mapStateToProps&lt;/code&gt; 関数の実行から返された値への各参照に対して一連の浅いチェックを個別に実行します。</target>
        </trans-unit>
        <trans-unit id="7396f0cc913742a2329483587f6bde1029a53425" translate="yes" xml:space="preserve">
          <source>It will then combine both sets of results into a single state tree:</source>
          <target state="translated">そして、両方の結果のセットを1つの状態ツリーに結合します。</target>
        </trans-unit>
        <trans-unit id="fe6fecbba3b0b6d0528af6e5ce21a171dd9d1cfb" translate="yes" xml:space="preserve">
          <source>It's a &lt;a href=&quot;http://knowyourmeme.com/memes/we-need-to-go-deeper&quot;&gt;&amp;ldquo;we need to go deeper&amp;rdquo;&lt;/a&gt; kind of moment, so it might take a while for this to make sense. The function cascade feels intimidating. ES6 arrow functions make this &lt;a href=&quot;https://en.wikipedia.org/wiki/Currying&quot;&gt;currying&lt;/a&gt; easier on eyes:</source>
          <target state="translated">&lt;a href=&quot;http://knowyourmeme.com/memes/we-need-to-go-deeper&quot;&gt;「もっと深く掘り下げる必要が&lt;/a&gt;ある」という瞬間なので、これが意味をなすまでには少し時間がかかるかもしれません。関数カスケードは威圧的に感じます。ES6の矢印機能は、この&lt;a href=&quot;https://en.wikipedia.org/wiki/Currying&quot;&gt;カリー&lt;/a&gt;化を目にやさしくします。</target>
        </trans-unit>
        <trans-unit id="53bb5e1d4ed878477f0cfe96c4cca984251e5713" translate="yes" xml:space="preserve">
          <source>It's a good idea to pass as little data in each action as possible. For example, it's better to pass &lt;code&gt;index&lt;/code&gt; than the whole todo object.</source>
          <target state="translated">各アクションで渡すデータはできるだけ少なくすることをお勧めします。たとえば、ToDoオブジェクト全体よりも &lt;code&gt;index&lt;/code&gt; を渡す方が適切です。</target>
        </trans-unit>
        <trans-unit id="66564241e2f2072f8ffd6342ef4d5f057cfbf2e9" translate="yes" xml:space="preserve">
          <source>It's also important to note that some of these suggestions may or may not be directly applicable based on architectural decisions in a specific application. For example, an application using Immutable.js Maps to store data would likely have its reducer logic structured at least somewhat differently than an application using plain Javascript objects. This documentation primarily assumes use of plain Javascript objects, but many of the principles would still apply if using other tools.</source>
          <target state="translated">また、これらの提案の中には、特定のアプリケーションのアーキテクチャ上の決定に基づいて直接適用できるものとそうでないものがあることにも注意が必要です。たとえば、Immutable.js Maps を使用してデータを保存するアプリケーションでは、そのリデューサ ロジックの構造は、プレーン Javascript オブジェクトを使用するアプリケーションとは少なくとも多少異なる可能性があります。このドキュメントでは、主にプレーンな Javascript オブジェクトの使用を前提としていますが、他のツールを使用している場合でも原則の多くが適用されます。</target>
        </trans-unit>
        <trans-unit id="1d8a4e5e3006a924b03ad0f0eb598b2f0f5eaed6" translate="yes" xml:space="preserve">
          <source>It's best not to mix this approach with standard Redux reducer composition. For typical web apps, stick with reducer composition. For &amp;ldquo;product hubs&amp;rdquo;, &amp;ldquo;dashboards&amp;rdquo;, or enterprise software that groups disparate tools into a unified package, give the sub-app approach a try.</source>
          <target state="translated">このアプローチを標準のReduxレデューサーコンポジションと混同しないことをお勧めします。典型的なWebアプリの場合は、レデューサーの構成に固執します。「製品ハブ」、「ダッシュボード」、またはさまざまなツールを統合パッケージにグループ化するエンタープライズソフトウェアの場合は、サブアプリアプローチを試してください。</target>
        </trans-unit>
        <trans-unit id="252a3efbc077a7d5a93fd6d1dbfedaa2d2669df6" translate="yes" xml:space="preserve">
          <source>It's called a reducer because it's the type of function you would pass to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array.prototype.reduce(reducer, ?initialValue)&lt;/code&gt;&lt;/a&gt;. It's very important that the reducer stays pure. Things you should &lt;strong&gt;never&lt;/strong&gt; do inside a reducer:</source>
          <target state="translated">これは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt; &lt;code&gt;Array.prototype.reduce(reducer, ?initialValue)&lt;/code&gt; &lt;/a&gt;渡す関数のタイプであるため、レデューサーと呼ばれます。減速機が純粋であることは非常に重要です。あなたが減速機の中で&lt;strong&gt;決して&lt;/strong&gt;してはいけ&lt;strong&gt;ないこと&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="6a58a3a8e0f482a446b06f379efada2fd4c57438" translate="yes" xml:space="preserve">
          <source>It's easy to create a store if you have a reducer. In the &lt;a href=&quot;reducers&quot;&gt;previous section&lt;/a&gt;, we used &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; to combine several reducers into one. We will now import it, and pass it to &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">レデューサーがあれば、簡単にストアを作成できます。で&lt;a href=&quot;reducers&quot;&gt;、前のセクション&lt;/a&gt;、我々は使用&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt;一つにいくつかのレデューサーを組み合わせること。それをインポートして&lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; に&lt;/a&gt;渡します。</target>
        </trans-unit>
        <trans-unit id="fb4ae669548f27a4108b547b46fa2c12ac612f32" translate="yes" xml:space="preserve">
          <source>It's for this improvement in performance that Redux uses shallow equality checking.</source>
          <target state="translated">Reduxが浅い平等性チェックを使用しているのは、このようなパフォーマンスの向上のためです。</target>
        </trans-unit>
        <trans-unit id="98dcf0d417fbe43fd9477364b70c4f9d857c65e0" translate="yes" xml:space="preserve">
          <source>It's generally suggested that selectors are defined alongside reducers and exported, and then reused elsewhere (such as in &lt;code&gt;mapStateToProps&lt;/code&gt; functions, in async action creators, or sagas) to colocate all the code that knows about the actual shape of the state tree in the reducer files.</source>
          <target state="translated">セレクターはレデューサーと一緒に定義されてエクスポートされ、次に他の場所（ &lt;code&gt;mapStateToProps&lt;/code&gt; 関数、非同期アクションクリエーター、またはsagasなど）で再利用して、レデューサーファイル内の状態ツリーの実際の形状を認識するすべてのコードを配置することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="9a8921bdd4ecd237805498907dc4327f0981b88e" translate="yes" xml:space="preserve">
          <source>It's important to note that a Redux store really only has a single reducer function. The store passes the current state and dispatched action to that one reducer function, and lets the reducer handle things appropriately.</source>
          <target state="translated">Redux ストアは、実際には単一の reducer 関数しか持っていないことに注意してください。ストアは、現在の状態とディスパッチされたアクションをその1つのレデューサ関数に渡し、レデューサに適切な処理をさせます。</target>
        </trans-unit>
        <trans-unit id="c36768ba51d801006d900629e7ac3f3a13e90bcd" translate="yes" xml:space="preserve">
          <source>It's important to note that you'll only have a single store in a Redux application. When you want to split your data handling logic, you'll use &lt;a href=&quot;reducers#splitting-reducers&quot;&gt;reducer composition&lt;/a&gt; instead of many stores.</source>
          <target state="translated">Reduxアプリケーションにはストアが1つしかないことに注意してください。データ処理ロジックを分割する場合は、多くのストアの代わりに&lt;a href=&quot;reducers#splitting-reducers&quot;&gt;リデューサー構成&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="61d4dad8daf83a3b27a53b849070082ed3ffa990" translate="yes" xml:space="preserve">
          <source>It's important to remember that whenever you update a nested value, you must also return new copies of anything above it in your state tree. If you have &lt;code&gt;state.a.b.c.d&lt;/code&gt;, and you want to make an update to &lt;code&gt;d&lt;/code&gt;, you would also need to return new copies of &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;state&lt;/code&gt;. This &lt;a href=&quot;http://arqex.com/wp-content/uploads/2015/02/trees.png&quot;&gt;state tree mutation diagram&lt;/a&gt; demonstrates how a change deep in a tree requires changes all the way up.</source>
          <target state="translated">ネストされた値を更新するときはいつでも、状態ツリーでその上にあるものの新しいコピーを返す必要があることを覚えておくことが重要です。あなたが持っている場合は &lt;code&gt;state.a.b.c.d&lt;/code&gt; 、そしてあなたに更新をしたい &lt;code&gt;d&lt;/code&gt; 、あなたもの新しいコピーを返す必要があるだろう &lt;code&gt;c&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 、および &lt;code&gt;state&lt;/code&gt; 。この&lt;a href=&quot;http://arqex.com/wp-content/uploads/2015/02/trees.png&quot;&gt;状態ツリーの変異図&lt;/a&gt;は、ツリーの深部での変更に至るまでの変更がどのように必要かを示しています。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c339b6732e0d2b2a42a0ddd93251b26fe3ad96b4" translate="yes" xml:space="preserve">
          <source>It's more code, but it's exactly what makes Redux predictable and efficient. If you want to have less code, you can use a helper like &lt;a href=&quot;https://facebook.github.io/react/docs/update.html&quot;&gt;&lt;code&gt;React.addons.update&lt;/code&gt;&lt;/a&gt; to write immutable transformations with a terse syntax:</source>
          <target state="translated">それはより多くのコードですが、それこそがReduxを予測可能かつ効率的にするものです。コードを減らしたい場合は、&lt;a href=&quot;https://facebook.github.io/react/docs/update.html&quot;&gt; &lt;code&gt;React.addons.update&lt;/code&gt; &lt;/a&gt;などのヘルパーを使用して、簡潔な構文で不変の変換を作成できます。</target>
        </trans-unit>
        <trans-unit id="6f3ca2b8ee117276e54d75838be64e770429f6ba" translate="yes" xml:space="preserve">
          <source>It's not always immediately clear how these two approaches interact. Fortunately, the process does follow some predictable rules. Here's how the pieces fit together.</source>
          <target state="translated">この2つのアプローチがどのように相互作用するかは、必ずしもすぐには明らかではありません。幸いなことに、このプロセスはいくつかの予測可能なルールに従っています。ここでは、これらがどのように組み合わされているかをご紹介します。</target>
        </trans-unit>
        <trans-unit id="d0ab78e0353e7cd035a999d2fa8e5af4c2f963ef" translate="yes" xml:space="preserve">
          <source>It's possible you're correctly dispatching an action and applying your reducer but the corresponding state is not being correctly translated into props.</source>
          <target state="translated">アクションを正しくディスパッチして減速機を適用しているのに、対応する状態が正しく小道具に変換されていない可能性があります。</target>
        </trans-unit>
        <trans-unit id="4543176cfbe02cd87a4507bdb08d9c22f1859120" translate="yes" xml:space="preserve">
          <source>It's unfortunate that many still choose Flux framework based on whether it uses &lt;code&gt;switch&lt;/code&gt; statements in the documentation. If you don't like &lt;code&gt;switch&lt;/code&gt;, you can solve this with a single function, as we show below.</source>
          <target state="translated">ドキュメントで &lt;code&gt;switch&lt;/code&gt; ステートメントを使用するかどうかに基づいて、まだ多くの人がFluxフレームワークを選択しているのは残念です。 &lt;code&gt;switch&lt;/code&gt; が気に入らない場合は、以下に示すように、1つの関数でこれを解決できます。</target>
        </trans-unit>
        <trans-unit id="7e539fa93863f712b20c2f16d75b4287d6434876" translate="yes" xml:space="preserve">
          <source>It's unfortunate that many still choose a framework based on whether it uses &lt;code&gt;switch&lt;/code&gt; statements in the documentation. If you don't like &lt;code&gt;switch&lt;/code&gt;, you can use a custom &lt;code&gt;createReducer&lt;/code&gt; function that accepts a handler map, as shown in &lt;a href=&quot;../recipes/reducingboilerplate#reducers&quot;&gt;&amp;ldquo;reducing boilerplate&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">多くの人がドキュメントで &lt;code&gt;switch&lt;/code&gt; ステートメントを使用するかどうかに基づいてフレームワークを選択しているのは残念です。 &lt;code&gt;switch&lt;/code&gt; が気に入らない場合は、&lt;a href=&quot;../recipes/reducingboilerplate#reducers&quot;&gt;「ボイラープレートの削減」に&lt;/a&gt;示すように、ハンドラーマップを受け入れるカスタム &lt;code&gt;createReducer&lt;/code&gt; 関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="2bb2765277319f208309e2db82a727dcbfdec808" translate="yes" xml:space="preserve">
          <source>JavaScript Application Architecture On The Road To 2015</source>
          <target state="translated">2015年に向けての道中でのJavaScriptアプリケーションアーキテクチャ</target>
        </trans-unit>
        <trans-unit id="5663d16ece82a891feaade5f2800177cdbd06bf0" translate="yes" xml:space="preserve">
          <source>JavaScript Immutability presentation (PDF - see slide 12 for benefits)</source>
          <target state="translated">JavaScriptの不変性のプレゼンテーション(PDF-メリットについてはスライド12を参照してください。</target>
        </trans-unit>
        <trans-unit id="5686c8f6acca3473e05ae8e791a2b0127eaac9e5" translate="yes" xml:space="preserve">
          <source>JavaScript and Immutability</source>
          <target state="translated">JavaScriptと不変性</target>
        </trans-unit>
        <trans-unit id="48e85cf4e700b35b1170cf47611de9569a23efdc" translate="yes" xml:space="preserve">
          <source>JavaScript does not provide immutable data structures. As such, for Immutable.JS to provide its immutable guarantees, your data must be encapsulated within an Immutable.JS object (such as a &lt;code&gt;Map&lt;/code&gt; or a &lt;code&gt;List&lt;/code&gt;, etc.). Once it&amp;rsquo;s contained in this way, it&amp;rsquo;s hard for that data to then interoperate with other, plain JavaScript objects.</source>
          <target state="translated">JavaScriptは不変のデータ構造を提供しません。したがって、Immutable.JSが不変の保証を提供するには、データがImmutable.JSオブジェクト（ &lt;code&gt;Map&lt;/code&gt; や &lt;code&gt;List&lt;/code&gt; など）内にカプセル化されている必要があります。このように格納すると、そのデータを他のプレーンなJavaScriptオブジェクトと相互運用することが困難になります。</target>
        </trans-unit>
        <trans-unit id="db1e7af6d4d988f37e8c96dfd9be6dd7f8c52667" translate="yes" xml:space="preserve">
          <source>JavaScript was never designed to provide guaranteed immutable operations. Accordingly, there are several issues you need to be aware of if you choose to use it for your immutable operations in your Redux app.</source>
          <target state="translated">JavaScriptは、決して保証された不変操作を提供するようには設計されていません。したがって、Reduxアプリで不変の操作にJavaScriptを使用する場合には、いくつかの問題に注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="e4f9a7a1a37cb18678bb27808982a0fab518f2bf" translate="yes" xml:space="preserve">
          <source>Javascript and Immutability</source>
          <target state="translated">Javascriptと不変性</target>
        </trans-unit>
        <trans-unit id="8190845a1ebdd8d76968f6c6f761a6be3b93edae" translate="yes" xml:space="preserve">
          <source>Jing Chen, creator of Flux</source>
          <target state="translated">Fluxの生みの親であるJing Chen氏</target>
        </trans-unit>
        <trans-unit id="951a42e3bc90a6103cf2aad8fcbde2477e07ad4f" translate="yes" xml:space="preserve">
          <source>Join the &lt;a href=&quot;https://discord.gg/0ZcbPKXt5bZ6au5t&quot;&gt;#redux&lt;/a&gt; channel of the &lt;a href=&quot;http://www.reactiflux.com&quot;&gt;Reactiflux&lt;/a&gt; Discord community.</source>
          <target state="translated">&lt;a href=&quot;http://www.reactiflux.com&quot;&gt;Reactiflux&lt;/a&gt; Discordコミュニティの&lt;a href=&quot;https://discord.gg/0ZcbPKXt5bZ6au5t&quot;&gt;#redux&lt;/a&gt;チャネルに参加してください。</target>
        </trans-unit>
        <trans-unit id="e399f1c349f8769ebbb0daf23b23eccbf46daf27" translate="yes" xml:space="preserve">
          <source>Just like before, we never write directly to &lt;code&gt;state&lt;/code&gt; or its fields, and instead we return new objects. The new &lt;code&gt;todos&lt;/code&gt; is equal to the old &lt;code&gt;todos&lt;/code&gt; concatenated with a single new item at the end. The fresh todo was constructed using the data from the action.</source>
          <target state="translated">以前と同様に、 &lt;code&gt;state&lt;/code&gt; またはそのフィールドに直接書き込むことはせず、代わりに新しいオブジェクトを返します。新しい &lt;code&gt;todos&lt;/code&gt; 古いと等しい &lt;code&gt;todos&lt;/code&gt; 最後に、単一の新しいアイテムと連結。新しいToDoは、アクションのデータを使用して作成されました。</target>
        </trans-unit>
        <trans-unit id="4775133d954dab5abc63710e9c6e38a2239ee177" translate="yes" xml:space="preserve">
          <source>Just like in the basic tutorial, you'll need to &lt;a href=&quot;../basics/reducers#designing-the-state-shape&quot;&gt;design the shape of your application's state&lt;/a&gt; before rushing into the implementation. With asynchronous code, there is more state to take care of, so we need to think it through.</source>
          <target state="translated">基本的なチュートリアルと同様に、実装に取り​​掛かる前&lt;a href=&quot;../basics/reducers#designing-the-state-shape&quot;&gt;に、アプリケーションの状態の形状&lt;/a&gt;を設計する必要があります。非同期コードを使用すると、処理する状態が増えるため、十分に検討する必要があります。</target>
        </trans-unit>
        <trans-unit id="c6df178ca4d41674a93e54d6ff850afe3eceb958" translate="yes" xml:space="preserve">
          <source>Laurence Roberts</source>
          <target state="translated">ローレンス・ロバーツ</target>
        </trans-unit>
        <trans-unit id="a8e78fb63e60ac2949bd5cbbb13dfecd20351939" translate="yes" xml:space="preserve">
          <source>Learn Redux from Its Creator</source>
          <target state="translated">Reduxの作成者からReduxを学ぶ</target>
        </trans-unit>
        <trans-unit id="815813ef04db0611309243e056689002bfca2f51" translate="yes" xml:space="preserve">
          <source>Learning Functional Programming in Javascript</source>
          <target state="translated">Javascriptで関数型プログラミングを学ぶ</target>
        </trans-unit>
        <trans-unit id="204c47c7f7b6077c5cc66fb4275cccc654adf5ff" translate="yes" xml:space="preserve">
          <source>Learning Redux</source>
          <target state="translated">ラーニングレドゥクス</target>
        </trans-unit>
        <trans-unit id="f18ace0f4dc5ebb1cb3f958d948cec6b1bfd54fc" translate="yes" xml:space="preserve">
          <source>Lee Byron on Twitter: &amp;ldquo;Perf tip for #immutablejs&amp;hellip;&amp;rdquo;</source>
          <target state="translated">Lee Byron on Twitter：「#immutablejsのパフォーマンスに関するヒント&amp;hellip;」</target>
        </trans-unit>
        <trans-unit id="0d516f563abbe7f29a4e3ee915a4a5746abb4a29" translate="yes" xml:space="preserve">
          <source>Let's consider a different scenario:</source>
          <target state="translated">別のシナリオを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="30e9663293d38e3d33c344fc2983eb83f3e158b6" translate="yes" xml:space="preserve">
          <source>Let's create a function named &lt;code&gt;makeGetVisibleTodos&lt;/code&gt; that returns a new copy of the &lt;code&gt;getVisibleTodos&lt;/code&gt; selector each time it is called:</source>
          <target state="translated">呼び出されるたびに &lt;code&gt;getVisibleTodos&lt;/code&gt; セレクターの新しいコピーを返す &lt;code&gt;makeGetVisibleTodos&lt;/code&gt; という名前の関数を作成してみましょう。</target>
        </trans-unit>
        <trans-unit id="fd130845bbec5d16d12cb399e0c3cbfeb2c430a7" translate="yes" xml:space="preserve">
          <source>Let's define a memoized selector named &lt;code&gt;getVisibleTodos&lt;/code&gt; to replace the non-memoized version above:</source>
          <target state="translated">上記のメモ化されていないバージョンを置き換えるために、 &lt;code&gt;getVisibleTodos&lt;/code&gt; という名前のメモ化されたセレクターを定義してみましょう。</target>
        </trans-unit>
        <trans-unit id="c3a4dc14b145305dfe293196d07e8aa73560d7a5" translate="yes" xml:space="preserve">
          <source>Let's explore reducer composition more. Can we also extract a reducer managing just &lt;code&gt;visibilityFilter&lt;/code&gt;? We can.</source>
          <target state="translated">レジューサーの構成についてさらに詳しく見てみましょう。また、 &lt;code&gt;visibilityFilter&lt;/code&gt; のみを管理するレデューサーを抽出できますか？私たちはできる。</target>
        </trans-unit>
        <trans-unit id="3d63428074244e2479b8e425262f560268ac5f43" translate="yes" xml:space="preserve">
          <source>Let's recall what the combined reducer does:</source>
          <target state="translated">コンバインドレデューサーが何をしているのか思い出してみましょう。</target>
        </trans-unit>
        <trans-unit id="384774d8dbe43962eb49ce001e2d96e26d96ea07" translate="yes" xml:space="preserve">
          <source>Let's revisit the &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Todos List example&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../basics/usagewithreact&quot;&gt;Todosリストの例を&lt;/a&gt;もう一度見てみましょう。</target>
        </trans-unit>
        <trans-unit id="ed19a0e0fde116aef33b7018b7a9bbcce6346bdc" translate="yes" xml:space="preserve">
          <source>Let's say a designer comes back to us after reviewing our prototype, and tells us that we need to allow three todos maximum. We can enforce this by rewriting our action creator to a callback form with &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; middleware and adding an early exit:</source>
          <target state="translated">プロトタイプを確認した後、デザイナーが戻ってきて、最大3つのtodosを許可する必要があると言ったとします。これを強制するには、アクションクリエーターを&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;ミドルウェアを含むコールバックフォームに書き換え、早期終了を追加します。</target>
        </trans-unit>
        <trans-unit id="d23a5d0451ec5d5abafa771961468240b19ed964" translate="yes" xml:space="preserve">
          <source>Let's say that our initial reducer looks like this:</source>
          <target state="translated">最初の減速機が次のようなものだとしましょう。</target>
        </trans-unit>
        <trans-unit id="a42244fb104feca9e7eb72186a85fa8a258a8b6f" translate="yes" xml:space="preserve">
          <source>Let's start by defining the several synchronous action types and action creators we need in our example app. Here, the user can select a subreddit to display:</source>
          <target state="translated">サンプルアプリで必要ないくつかの同期アクションタイプとアクションクリエーターを定義することから始めましょう。ここでは、ユーザーは表示するサブレディットを選択することができます。</target>
        </trans-unit>
        <trans-unit id="6be34e2837216ea61f99fc5d5668808369bc5adc" translate="yes" xml:space="preserve">
          <source>Let's take a look at our new client file:</source>
          <target state="translated">新しいクライアントファイルを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="b409b71e81ab2b58978b981a343bc5bce51dcd92" translate="yes" xml:space="preserve">
          <source>Let's talk through the algorithm to manipulate the state shape described above. We can define two actions to operate on this state: &lt;code&gt;UNDO&lt;/code&gt; and &lt;code&gt;REDO&lt;/code&gt;. In our reducer, we will do the following steps to handle these actions:</source>
          <target state="translated">上記の状態形状を操作するためのアルゴリズムについて説明します。この状態を操作する2つのアクション、 &lt;code&gt;UNDO&lt;/code&gt; と &lt;code&gt;REDO&lt;/code&gt; を定義できます。リデューサーでは、これらのアクションを処理するために次の手順を実行します。</target>
        </trans-unit>
        <trans-unit id="dd3902ab0d1d59de82883d31a36cdd78b461122c" translate="yes" xml:space="preserve">
          <source>Let's write a function that lets us express reducers as an object mapping from action types to handlers. For example, if we want our &lt;code&gt;todos&lt;/code&gt; reducers to be defined like this:</source>
          <target state="translated">アクションタイプからハンドラーへのオブジェクトマッピングとしてレデューサーを表現できる関数を記述してみましょう。たとえば、 &lt;code&gt;todos&lt;/code&gt; レデューサーを次のように定義したい場合：</target>
        </trans-unit>
        <trans-unit id="e72eaffd3ac1dcb5208c2d6ea7b42f2173627e6a" translate="yes" xml:space="preserve">
          <source>Let's write the components! We begin with the presentational components so we don't need to think about binding to Redux yet.</source>
          <target state="translated">コンポーネントを書こう Reduxへのバインディングを考える必要はありません。</target>
        </trans-unit>
        <trans-unit id="4642d8e2bbb9a67ffddd44f6258e15948144b9a5" translate="yes" xml:space="preserve">
          <source>Leveling Up with React: Redux</source>
          <target state="translated">Reactでレベルアップ。リュークス</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MITライセンスに基づいてライセンスされています。</target>
        </trans-unit>
        <trans-unit id="ef7dd92b3bad02dfcc7661e876c8b68c18ebfc35" translate="yes" xml:space="preserve">
          <source>Limit your use of &lt;code&gt;toJS()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;toJS()&lt;/code&gt; の使用を制限する</target>
        </trans-unit>
        <trans-unit id="83fce8327410848c9eb609acb21732c7c0fec96a" translate="yes" xml:space="preserve">
          <source>Logo</source>
          <target state="translated">Logo</target>
        </trans-unit>
        <trans-unit id="89690ac571dcf4c9c40c842efed3f11171d07b29" translate="yes" xml:space="preserve">
          <source>MIT</source>
          <target state="translated">MIT</target>
        </trans-unit>
        <trans-unit id="17367293ad2021231bf611dd0dd27a355d38e2d6" translate="yes" xml:space="preserve">
          <source>Make sure mapStateToProps is correct</source>
          <target state="translated">mapStateToPropsが正しいことを確認してください。</target>
        </trans-unit>
        <trans-unit id="9f370227bbf65772938b3d8e358e2ce2218a1a54" translate="yes" xml:space="preserve">
          <source>Make sure that you use &lt;code&gt;Object.assign&lt;/code&gt; correctly. For example, instead of returning something like &lt;code&gt;Object.assign(state, newData)&lt;/code&gt; from your reducers, return &lt;code&gt;Object.assign({}, state, newData)&lt;/code&gt;. This way you don't override the previous &lt;code&gt;state&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Object.assign&lt;/code&gt; を正しく使用していることを確認してください。たとえば、レデューサーから &lt;code&gt;Object.assign(state, newData)&lt;/code&gt; ようなものを返す代わりに、 &lt;code&gt;Object.assign({}, state, newData)&lt;/code&gt; ます。この方法では、以前の &lt;code&gt;state&lt;/code&gt; 上書きしません。</target>
        </trans-unit>
        <trans-unit id="5d8418eedd0d6a2db483537e4446820ce1952555" translate="yes" xml:space="preserve">
          <source>Make your entire Redux state tree an Immutable.JS object</source>
          <target state="translated">Redux のステートツリー全体を Immutable.JS オブジェクトにします。</target>
        </trans-unit>
        <trans-unit id="91529d50836c68b2f85612f8480c39828f101131" translate="yes" xml:space="preserve">
          <source>Managing Normalized Data</source>
          <target state="translated">正規化データの管理</target>
        </trans-unit>
        <trans-unit id="b8cfd188b6fb6ef58e95265e7bee55786bad588a" translate="yes" xml:space="preserve">
          <source>Managing this ever-changing state is hard. If a model can update another model, then a view can update a model, which updates another model, and this, in turn, might cause another view to update. At some point, you no longer understand what happens in your app as you have &lt;strong&gt;lost control over the when, why, and how of its state.&lt;/strong&gt; When a system is opaque and non-deterministic, it's hard to reproduce bugs or add new features.</source>
          <target state="translated">この絶え間なく変化する状態を管理することは困難です。モデルが別のモデルを更新できる場合、ビューは別のモデルを更新するモデルを更新できます。これにより、別のビューが更新される可能性があります。ある時点で&lt;strong&gt;、いつ、なぜ、どのように状態を制御&lt;/strong&gt;できなくなったため、アプリで何が発生するのか理解できなくなります&lt;strong&gt;。&lt;/strong&gt;システムが不透明で確定的でない場合、バグを再現したり、新しい機能を追加したりすることは困難です。</target>
        </trans-unit>
        <trans-unit id="770e69d1c946703f5c3589b40d2b5d1f60424fb5" translate="yes" xml:space="preserve">
          <source>Many applications deal with data that is nested or relational in nature. For example, a blog editor could have many Posts, each Post could have many Comments, and both Posts and Comments would be written by a User. Data for this kind of application might look like:</source>
          <target state="translated">多くのアプリケーションでは、入れ子になっているデータやリレーショナルなデータを扱います。例えば、ブログエディタは多くの投稿を持ち、それぞれの投稿は多くのコメントを持ち、投稿とコメントはユーザーによって書かれます。この種のアプリケーションのデータは次のようになります。</target>
        </trans-unit>
        <trans-unit id="d062b20c46aa58461072521c5ff06fd5c22eadb2" translate="yes" xml:space="preserve">
          <source>Many users later want to try to share data between two reducers, but find that &lt;code&gt;combineReducers&lt;/code&gt; does not allow them to do so. There are several approaches that can be used:</source>
          <target state="translated">多くのユーザーは後で2つのレデューサー間でデータを共有しようとしていますが、 &lt;code&gt;combineReducers&lt;/code&gt; では許可されていないことがわかりました。使用できる方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="1f7bcd6c888e6b88d0545bc697de285055397b49" translate="yes" xml:space="preserve">
          <source>Maybe we want to be able to run multiple instances of it in the same &amp;ldquo;bigger&amp;rdquo; app and keep it as a complete black box, with Redux being an implementation detail.</source>
          <target state="translated">Reduxを実装の詳細として、同じ「大きな」アプリでその複数のインスタンスを実行し、完全なブラックボックスとして保持できるようにしたい場合があります。</target>
        </trans-unit>
        <trans-unit id="99890f553cee2767e33647e04645b77191093369" translate="yes" xml:space="preserve">
          <source>Meet Reducer Enhancers</source>
          <target state="translated">レジューサーエンハンサーを満たす</target>
        </trans-unit>
        <trans-unit id="1335c9d05ff6249a581b2af47d8ca262af71f878" translate="yes" xml:space="preserve">
          <source>Meet some of the outstanding companies that made it possible:</source>
          <target state="translated">それを可能にした優秀な企業との出会い。</target>
        </trans-unit>
        <trans-unit id="eb8978ed84b5906ad4191a0b252828be64701bfa" translate="yes" xml:space="preserve">
          <source>Middleware</source>
          <target state="translated">Middleware</target>
        </trans-unit>
        <trans-unit id="4de8569a40d6be412d5f73fc6d679fbd847a1bc7" translate="yes" xml:space="preserve">
          <source>Middleware functions wrap behavior of &lt;code&gt;dispatch&lt;/code&gt; calls in Redux, so to test this modified behavior we need to mock the behavior of the &lt;code&gt;dispatch&lt;/code&gt; call.</source>
          <target state="translated">ミドルウェア関数はRedux の &lt;code&gt;dispatch&lt;/code&gt; 呼び出しの動作をラップするため、この変更された動作をテストするには、 &lt;code&gt;dispatch&lt;/code&gt; 呼び出しの動作を模擬する必要があります。</target>
        </trans-unit>
        <trans-unit id="4cfdea7cdd9cbecf25a5a88942621957d5c3dd05" translate="yes" xml:space="preserve">
          <source>Middleware is composable using function composition. It is useful for logging actions, performing side effects like routing, or turning an asynchronous API call into a series of synchronous actions.</source>
          <target state="translated">ミドルウェアは、関数合成を使用して合成することができます。これは、アクションのログを取ったり、ルーティングのような副作用を実行したり、非同期のAPIコールを一連の同期アクションに変えたりするのに便利です。</target>
        </trans-unit>
        <trans-unit id="b3958295af5cb6ac63c96e1bbd5629db43b83e95" translate="yes" xml:space="preserve">
          <source>Middleware is created by the community and does not ship with Redux by default. You need to explicitly install packages like &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; or &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; to use it. You may also create your own middleware.</source>
          <target state="translated">ミドルウェアはコミュニティによって作成され、デフォルトではReduxに付属していません。&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;や&lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt;などのパッケージを使用するには、明示的にインストールする必要があります。独自のミドルウェアを作成することもできます。</target>
        </trans-unit>
        <trans-unit id="709ac9c564fa8004f1018815a013faace4ceaf9b" translate="yes" xml:space="preserve">
          <source>Middleware is not baked into &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; and is not a fundamental part of the Redux architecture, but we consider it useful enough to be supported right in the core. This way, there is a single standard way to extend &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; in the ecosystem, and different middleware may compete in expressiveness and utility.</source>
          <target state="translated">ミドルウェアは&lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; に&lt;/a&gt;組み込まれておらず、Reduxアーキテクチャの基本的な部分ではありませんが、コアで正しくサポートされるのに十分に役立つと考えています。このように、エコシステムでの&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;を拡張する単一の標準的な方法があり、さまざまなミドルウェアが表現力と実用性を競い合う可能性があります。</target>
        </trans-unit>
        <trans-unit id="00c8a7e2c0f9e6b20fe14442f77d182a03eebb64" translate="yes" xml:space="preserve">
          <source>Middleware is the suggested way to extend Redux with custom functionality. Middleware lets you wrap the store's &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; method for fun and profit. The key feature of middleware is that it is composable. Multiple middleware can be combined together, where each middleware requires no knowledge of what comes before or after it in the chain.</source>
          <target state="translated">ミドルウェアは、カスタム機能でReduxを拡張するための推奨方法です。ミドルウェアを使用すると、ストアの&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;メソッドをラップして楽しさと利益を得ることができます。ミドルウェアの主要な機能は、それが構成可能であることです。複数のミドルウェアを組み合わせることができます。各ミドルウェアは、チェーンの前後にあるものについての知識を必要としません。</target>
        </trans-unit>
        <trans-unit id="9772321b9da9e355cae92c8995bc9b6d9b873c30" translate="yes" xml:space="preserve">
          <source>Middleware only wraps the store's &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function. Technically, anything a middleware can do, you can do manually by wrapping every &lt;code&gt;dispatch&lt;/code&gt; call, but it's easier to manage this in a single place and define action transformations on the scale of the whole project.</source>
          <target state="translated">ミドルウェアは、ストアの&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;機能のみをラップします。技術的には、ミドルウェアでできることは何でも、すべての &lt;code&gt;dispatch&lt;/code&gt; 呼び出しをラップして手動で行うことができますが、これを1か所で管理し、プロジェクト全体の規模でアクション変換を定義する方が簡単です。</target>
        </trans-unit>
        <trans-unit id="904b42b851f9aa103d834460d3e42948c262c785" translate="yes" xml:space="preserve">
          <source>Middleware sounds much more complicated than it really is. The only way to really understand middleware is to see how the existing middleware works, and try to write your own. The function nesting can be intimidating, but most of the middleware you'll find are, in fact, 10-liners, and the nesting and composability is what makes the middleware system powerful.</source>
          <target state="translated">ミドルウェアというと、実際よりもずっと複雑に聞こえます。ミドルウェアを本当に理解する唯一の方法は、既存のミドルウェアがどのように動作するかを見て、自分で書いてみることです。関数の入れ子には威圧感を覚えるかもしれませんが、実際に見かけるミドルウェアのほとんどは10ライナーで、その入れ子とコンポーザビリティこそがミドルウェアシステムを強力なものにしているのです。</target>
        </trans-unit>
        <trans-unit id="9302feee19404010fcac9af350604fe588e01046" translate="yes" xml:space="preserve">
          <source>Migrating to Redux</source>
          <target state="translated">Reduxへの移行</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="7cc7d31118fe440474864da8b1d74f693cb0f866" translate="yes" xml:space="preserve">
          <source>Modular Reducers and Selectors</source>
          <target state="translated">モジュラー式減速機とセレクター</target>
        </trans-unit>
        <trans-unit id="4e7b0b1e9c0a61f16b9a2611a1aa537d440279de" translate="yes" xml:space="preserve">
          <source>Monkeypatching is a hack. &amp;ldquo;Replace any method you like&amp;rdquo;, what kind of API is that? Let's figure out the essence of it instead. Previously, our functions replaced &lt;code&gt;store.dispatch&lt;/code&gt;. What if they &lt;em&gt;returned&lt;/em&gt; the new &lt;code&gt;dispatch&lt;/code&gt; function instead?</source>
          <target state="translated">モンキーパッチはハックです。「好きなメソッドを入れ替える」ってどんなAPI？代わりに、その本質を理解しましょう。以前、私たちの関数は &lt;code&gt;store.dispatch&lt;/code&gt; を置き換えました。代わりに新しい &lt;code&gt;dispatch&lt;/code&gt; 関数を&lt;em&gt;返し&lt;/em&gt;た場合はどうなりますか？</target>
        </trans-unit>
        <trans-unit id="4bab2d8fe13fa6ab57f80098b414f0f734c5dd25" translate="yes" xml:space="preserve">
          <source>More</source>
          <target state="translated">More</target>
        </trans-unit>
        <trans-unit id="65607507695dbb68853f7200e33956e39fd6a15d" translate="yes" xml:space="preserve">
          <source>More Examples</source>
          <target state="translated">その他の例</target>
        </trans-unit>
        <trans-unit id="fbb1457de42e260b67aaf3c234080db729e6567f" translate="yes" xml:space="preserve">
          <source>Most applications deal with multiple types of data, which can be broadly divided into three categories:</source>
          <target state="translated">ほとんどのアプリケーションでは、複数の種類のデータを扱っていますが、これは大きく分けて3つのカテゴリーに分けられます。</target>
        </trans-unit>
        <trans-unit id="89d03ee4b54b44641100dd50cccd338fa1f41b27" translate="yes" xml:space="preserve">
          <source>Most commonly people consume Redux as a collection of &lt;a href=&quot;http://webpack.github.io/docs/commonjs.html&quot;&gt;CommonJS&lt;/a&gt; modules. These modules are what you get when you import &lt;code&gt;redux&lt;/code&gt; in a &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;, &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;, or a Node environment. If you like to live on the edge and use &lt;a href=&quot;http://rollupjs.org&quot;&gt;Rollup&lt;/a&gt;, we support that as well.</source>
          <target state="translated">最も一般的に人々は&lt;a href=&quot;http://webpack.github.io/docs/commonjs.html&quot;&gt;CommonJS&lt;/a&gt;モジュールのコレクションとしてReduxを消費します。これらのモジュールは、&lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;、&lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;、またはNode環境で &lt;code&gt;redux&lt;/code&gt; をインポートしたときに得られるものです。エッジに住み、&lt;a href=&quot;http://rollupjs.org&quot;&gt;Rollup&lt;/a&gt;を使用したい場合は、それもサポートします。</target>
        </trans-unit>
        <trans-unit id="09f0cc4aec4d47d93c4e8a96edd682217c9476ac" translate="yes" xml:space="preserve">
          <source>Most likely you'll never write a store enhancer, but you may use the one provided by the &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;developer tools&lt;/a&gt;. It is what makes time travel possible without the app being aware it is happening. Amusingly, the &lt;a href=&quot;api/applymiddleware&quot;&gt;Redux middleware implementation&lt;/a&gt; is itself a store enhancer.</source>
          <target state="translated">ほとんどの場合、ストアエンハンサーを作成することはありませんが、&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;開発者ツールで&lt;/a&gt;提供されているものを使用できます。アプリが気づかないうちにタイムトラベルが可能になるのはこのためです。面白いことに、&lt;a href=&quot;api/applymiddleware&quot;&gt;Reduxミドルウェアの実装&lt;/a&gt;自体がストアエンハンサーです。</target>
        </trans-unit>
        <trans-unit id="390f7c239e26365aa378c0e0495e19cfea627097" translate="yes" xml:space="preserve">
          <source>Most likely, you'll also need &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;the React bindings&lt;/a&gt; and &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;the developer tools&lt;/a&gt;.</source>
          <target state="translated">ほとんどの場合&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;、Reactバインディング&lt;/a&gt;と&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;開発者ツール&lt;/a&gt;も必要になります。</target>
        </trans-unit>
        <trans-unit id="7e3a3d184b0b6d4dfa96e5964033c932e00274c5" translate="yes" xml:space="preserve">
          <source>Most of the components we'll write will be presentational, but we'll need to generate a few container components to connect them to the Redux store. This and the design brief below do not imply container components must be near the top of the component tree. If a container component becomes too complex (i.e. it has heavily nested presentional components with countless callbacks being passed down), introduce another container within the component tree as noted in the &lt;a href=&quot;../faq/reactredux#react-multiple-components&quot;&gt;FAQ&lt;/a&gt;.</source>
          <target state="translated">これから作成するコンポーネントのほとんどはプレゼンテーション用ですが、コンポーネントをReduxストアに接続するには、いくつかのコンテナコンポーネントを生成する必要があります。これと以下の設計概要は、コンテナコンポーネントがコンポーネントツリーの上部近くにある必要があることを意味しません。コンテナーコンポーネントが複雑になりすぎる場合（つまり、無数のコールバックが渡されて非常にネストされたプレゼンテーショナルコンポーネントがある場合）、&lt;a href=&quot;../faq/reactredux#react-multiple-components&quot;&gt;FAQに&lt;/a&gt;記載されているように、コンポーネントツリー内に別のコンテナーを導入します。</target>
        </trans-unit>
        <trans-unit id="4fd704d00a4e5a0c3b40b38e9218c4cbbf210bcc" translate="yes" xml:space="preserve">
          <source>Most of the functionality Baobab provides is related to updating the data with cursors, but Redux enforces that the only way to update the data is to dispatch an action. Therefore they solve the same problem differently, and don't complement each other.</source>
          <target state="translated">Baobabが提供する機能のほとんどはカーソルを使ってデータを更新することに関連していますが、Reduxはデータを更新する唯一の方法はアクションをディスパッチすることだと強制しています。そのため、両者は同じ問題を異なる方法で解決しており、お互いを補完するものではありません。</target>
        </trans-unit>
        <trans-unit id="d6a06199cc127e571d3588aef63c79108675eabc" translate="yes" xml:space="preserve">
          <source>Motivation</source>
          <target state="translated">Motivation</target>
        </trans-unit>
        <trans-unit id="723bf632acd68a56f2a8abd2cb40c71cceac0c0d" translate="yes" xml:space="preserve">
          <source>Motivation for Memoized Selectors</source>
          <target state="translated">メモ付きセレクターのモチベーション</target>
        </trans-unit>
        <trans-unit id="552b006eca5b663e553068321aa1dddaf3b1befb" translate="yes" xml:space="preserve">
          <source>Mozilla's experimental browser testbed</source>
          <target state="translated">Mozillaの実験的ブラウザテストベッド</target>
        </trans-unit>
        <trans-unit id="d88a4a071f039297bbb69db92ff026e19cea735d" translate="yes" xml:space="preserve">
          <source>Mutability vs immutability</source>
          <target state="translated">変異性対不変性</target>
        </trans-unit>
        <trans-unit id="efd8a68660022a43293fd5a672afacaf4b2ee1a5" translate="yes" xml:space="preserve">
          <source>Mutate its arguments;</source>
          <target state="translated">その引数を変異させます。</target>
        </trans-unit>
        <trans-unit id="654f242c8a1a04fd78d46a2eed456576101047e8" translate="yes" xml:space="preserve">
          <source>Mutation is discouraged because it generally breaks time-travel debugging, and React Redux's &lt;code&gt;connect&lt;/code&gt; function:</source>
          <target state="translated">突然変異は、一般的にタイムトラベルデバッグとReact Reduxの &lt;code&gt;connect&lt;/code&gt; 機能を壊すため、推奨されません。</target>
        </trans-unit>
        <trans-unit id="14131d656db4b7bdd8f8e3f363d86fcd460046b5" translate="yes" xml:space="preserve">
          <source>My journey towards a maintainable project structure for React/Redux</source>
          <target state="translated">React/Reduxのメンテナンス可能なプロジェクト構造に向けての私の旅路</target>
        </trans-unit>
        <trans-unit id="7b24ea7fdf4c6ff696c569545bd59b1ddc1a2075" translate="yes" xml:space="preserve">
          <source>Navigating with React Router</source>
          <target state="translated">React Routerでナビゲートする</target>
        </trans-unit>
        <trans-unit id="ffb832014d4614f14ecdf3023143c63e959c339a" translate="yes" xml:space="preserve">
          <source>Nested data means that the corresponding reducer logic has to be more nested or more complex. In particular, trying to update a deeply nested field can become very ugly very fast.</source>
          <target state="translated">ネストされたデータは、対応するレデューサロジックがより多くのネストされているか、より複雑でなければならないことを意味します。特に、深くネストされたフィールドを更新しようとすると、非常に速く醜いものになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="80a420ddf85790605c162653ce53a583b0952bbf" translate="yes" xml:space="preserve">
          <source>Never let a plain JavaScript object contain Immutable.JS properties. Equally, never let an Immutable.JS object contain a plain JavaScript object.</source>
          <target state="translated">プレーンな JavaScript オブジェクトに Immutable.JS プロパティを含ませてはいけません。同様に、Immutable.JS オブジェクトにプレーンな JavaScript オブジェクトを含ませてはいけません。</target>
        </trans-unit>
        <trans-unit id="a430ed54fb612f337f2ab8273ec4cbf9b6644bd7" translate="yes" xml:space="preserve">
          <source>Never mix plain JavaScript objects with Immutable.JS</source>
          <target state="translated">プレーンな JavaScript オブジェクトと Immutable.JS を混ぜてはいけない</target>
        </trans-unit>
        <trans-unit id="5a34cbfaae2d3943f4277799da4593a9d4e8866b" translate="yes" xml:space="preserve">
          <source>Never mutate reducer arguments</source>
          <target state="translated">減算器の引数を決してミューテーションしないでください。</target>
        </trans-unit>
        <trans-unit id="d5c80dd926f59c776bb8a92ea2761368f2163c20" translate="yes" xml:space="preserve">
          <source>Never use &lt;code&gt;toJS()&lt;/code&gt; in &lt;code&gt;mapStateToProps&lt;/code&gt;</source>
          <target state="translated">絶対に使用しないでください &lt;code&gt;toJS()&lt;/code&gt; で &lt;code&gt;mapStateToProps&lt;/code&gt; を</target>
        </trans-unit>
        <trans-unit id="880eef8459e455b9917669c0f642e566841426d2" translate="yes" xml:space="preserve">
          <source>Never use Immutable.JS in your Dumb Components</source>
          <target state="translated">ダムコンポーネントでは決して Immutable.JS を使用しないでください。</target>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">次のステップ</target>
        </trans-unit>
        <trans-unit id="0264cc83b356bb6ea59a462a975e062d839151d9" translate="yes" xml:space="preserve">
          <source>Next, we can split each specific case into its own function:</source>
          <target state="translated">次に、それぞれの具体的なケースをそれぞれの関数に分割します。</target>
        </trans-unit>
        <trans-unit id="841e4eea113da2949d5aa791e51d64a552200a40" translate="yes" xml:space="preserve">
          <source>Next, we'll explore how to &lt;a href=&quot;store&quot;&gt;create a Redux store&lt;/a&gt; that holds the state and takes care of calling your reducer when you dispatch an action.</source>
          <target state="translated">次に、状態を保持し、アクションをディスパッチするときにリデューサーの呼び出しを処理&lt;a href=&quot;store&quot;&gt;するReduxストア&lt;/a&gt;を作成する方法を探ります。</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="00e1f82b828451acc6eb547238db43005cf32c21" translate="yes" xml:space="preserve">
          <source>No Destructuring or Spread Operators</source>
          <target state="translated">デストラクチャリングやスプレッドオペレーターはありません。</target>
        </trans-unit>
        <trans-unit id="45a97bbdd6d1c0b59be783757a1880b3f98ba017" translate="yes" xml:space="preserve">
          <source>No. We suggest you write independent small reducer functions that are each responsible for updates to a specific slice of state. We call this pattern &amp;ldquo;reducer composition&amp;rdquo;. A given action could be handled by all, some, or none of them. This keeps components decoupled from the actual data changes, as one action may affect different parts of the state tree, and there is no need for the component to be aware of this. Some users do choose to bind them more tightly together, such as the &amp;ldquo;ducks&amp;rdquo; file structure, but there is definitely no one-to-one mapping by default, and you should break out of such a paradigm any time you feel you want to handle an action in many reducers.</source>
          <target state="translated">いいえ。それぞれが特定の状態スライスへの更新を担当する独立した小さなリデューサー関数を作成することをお勧めします。このパターンを「レデューサー構成」と呼びます。特定のアクションは、すべて、一部、またはまったく処理できません。これにより、1つのアクションが状態ツリーのさまざまな部分に影響を与える可能性があり、コンポーネントがこれを認識する必要がないため、コンポーネントは実際のデータ変更から切り離されたままになります。「アヒル」ファイル構造など、一部のユーザーはそれらをより緊密にバインドすることを選択しますが、デフォルトでは1対1のマッピングは絶対に存在しないので、必要に応じていつでもそのようなパラダイムから脱出する必要があります。多くのレデューサーでアクションを処理します。</target>
        </trans-unit>
        <trans-unit id="2d55eda060d4abd9e941e61eac1c5a4760b4b7fb" translate="yes" xml:space="preserve">
          <source>No. You are welcome to use any approach you'd like to respond to an action in a reducer. The &lt;code&gt;switch&lt;/code&gt; statement is the most common approach, but it's fine to use &lt;code&gt;if&lt;/code&gt; statements, a lookup table of functions, or to create a function that abstracts this away. In fact, while Redux does require that action objects contain a &lt;code&gt;type&lt;/code&gt; field, your reducer logic doesn't even have to rely on that to handle the action. That said, the standard approach is definitely using a switch statement or a lookup table based on &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">いいえ。レデューサーでのアクションに応答したい任意のアプローチを使用できます。 &lt;code&gt;switch&lt;/code&gt; ステートメントは、最も一般的な方法ですが、それの罰金を使用する &lt;code&gt;if&lt;/code&gt; ステートメント、関数のルックアップテーブルを、または離れてこれを抽象化関数を作成します。実際、Reduxではアクションオブジェクトに &lt;code&gt;type&lt;/code&gt; フィールドを含める必要がありますが、レデューサーロジックはアクションを処理するためにタイプフィールドに依存する必要さえありません。とは言っても、標準的なアプローチは間違いなく、switchステートメントまたは &lt;code&gt;type&lt;/code&gt; に基づくルックアップテーブルを使用しています。</target>
        </trans-unit>
        <trans-unit id="0e0d7b6b9e9168e473b1803957df55eb87b2031d" translate="yes" xml:space="preserve">
          <source>Nope, it's just HTML, some artisanal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags, and plain old DOM manipulation. Enjoy!</source>
          <target state="translated">いいえ、それは単なるHTML、いくつかの職人的な &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグ、そしてプレーンな古いDOM操作です。楽しい！</target>
        </trans-unit>
        <trans-unit id="327c34539b30a346bec5ad81c0c1b3f68e1bdeed" translate="yes" xml:space="preserve">
          <source>Normalizing Data</source>
          <target state="translated">データの正規化</target>
        </trans-unit>
        <trans-unit id="24e6df000cfc0eae18573e3ca083b23c0599cf6a" translate="yes" xml:space="preserve">
          <source>Normalizing Nested Data</source>
          <target state="translated">入れ子になったデータの正規化</target>
        </trans-unit>
        <trans-unit id="dcd338fb8e5bd8068c0c2b43bfce9d5de3e8a57c" translate="yes" xml:space="preserve">
          <source>Normalizing State Shape</source>
          <target state="translated">状態形状の正規化</target>
        </trans-unit>
        <trans-unit id="eb23cc3f5afc902e5be043420e1d724b51659962" translate="yes" xml:space="preserve">
          <source>Normalizr Documentation</source>
          <target state="translated">Normalizr ドキュメント</target>
        </trans-unit>
        <trans-unit id="335b95f34a7df1f471d9e66d848a822638f18b4c" translate="yes" xml:space="preserve">
          <source>Normally you should just call &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; directly on your &lt;a href=&quot;store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt; instance. If you use Redux with React, &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; will provide you with the &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function so you can call it directly, too.</source>
          <target state="translated">通常は、&lt;a href=&quot;store&quot;&gt; &lt;code&gt;Store&lt;/code&gt; &lt;/a&gt;インスタンスで直接&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;を呼び出す必要があります。ReactでReduxを使用する場合、&lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt;は&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;関数を提供するため、直接呼び出すこともできます。</target>
        </trans-unit>
        <trans-unit id="3c4e5332959aece0b47c0b738573f9bd470cb893" translate="yes" xml:space="preserve">
          <source>Normally, a Javascript array's contents are modified using mutative functions like &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;unshift&lt;/code&gt;, and &lt;code&gt;splice&lt;/code&gt;. Since we don't want to mutate state directly in reducers, those should normally be avoided. Because of that, you might see &quot;insert&quot; or &quot;remove&quot; behavior written like this:</source>
          <target state="translated">通常、JavaScript配列の内容は、 &lt;code&gt;push&lt;/code&gt; 、 &lt;code&gt;unshift&lt;/code&gt; 、および &lt;code&gt;splice&lt;/code&gt; などの変異関数を使用して変更されます。レデューサーで直接状態を変更したくないので、通常はそれらを回避する必要があります。そのため、次のように記述された「挿入」または「削除」動作が表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="5bf716978826f82f5c2d71096281b5d3d023f9c8" translate="yes" xml:space="preserve">
          <source>Not suitable for small values that change often</source>
          <target state="translated">頻繁に変化する小さな値には不向き</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="eb86ccd5312e5081a352de1334537a0b4650d54d" translate="yes" xml:space="preserve">
          <source>Note About Other Routing Libraries</source>
          <target state="translated">他のルーティングライブラリについて</target>
        </trans-unit>
        <trans-unit id="6bbf18fa1a59b4aceea2d7935084a5984b1e6199" translate="yes" xml:space="preserve">
          <source>Note about Server Rendering</source>
          <target state="translated">サーバーレンダリングについての注意点</target>
        </trans-unit>
        <trans-unit id="4c76dccbb579daeff6d19eccfc8338e7cf2dfdca" translate="yes" xml:space="preserve">
          <source>Note for Advanced Users</source>
          <target state="translated">上級者向けの注意事項</target>
        </trans-unit>
        <trans-unit id="0e1755ef6326ca3fc737a66979bb10b7fe7587af" translate="yes" xml:space="preserve">
          <source>Note for ES6 Savvy Users</source>
          <target state="translated">ES6に精通したユーザーへの注意事項</target>
        </trans-unit>
        <trans-unit id="4bfd422b1acf7ab6bcc2d683c3dcc9593e8dfe47" translate="yes" xml:space="preserve">
          <source>Note on &lt;code&gt;Object.assign&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Object.assign&lt;/code&gt; に関する注意</target>
        </trans-unit>
        <trans-unit id="759269df6e82649e8ad3a46ac965bc2b1dbc225c" translate="yes" xml:space="preserve">
          <source>Note on &lt;code&gt;fetch&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; に関する注意</target>
        </trans-unit>
        <trans-unit id="4191e14191dc73a177c536b0008fd934e599f6c0" translate="yes" xml:space="preserve">
          <source>Note on &lt;code&gt;switch&lt;/code&gt; and Boilerplate</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; とボイラープレートに関する注意</target>
        </trans-unit>
        <trans-unit id="ae1778afee8eaabfaf5e882ffee86fd7dfad1748" translate="yes" xml:space="preserve">
          <source>Note on Boilerplate</source>
          <target state="translated">ボイラープレートについての注意事項</target>
        </trans-unit>
        <trans-unit id="f520e769580a42a8ec1ab5c7de5b32126ab034fd" translate="yes" xml:space="preserve">
          <source>Note on Create React App</source>
          <target state="translated">Reactアプリ作成時の注意点</target>
        </trans-unit>
        <trans-unit id="0dba1d6300344edb76956054e6c0d4c05d8a5923" translate="yes" xml:space="preserve">
          <source>Note on Error Handling</source>
          <target state="translated">エラー処理の注意点</target>
        </trans-unit>
        <trans-unit id="226b6e169b44973eab9a3a7d4ce9abe63d0c7f07" translate="yes" xml:space="preserve">
          <source>Note on Nested Entities</source>
          <target state="translated">入れ子になっているエンティティに関する注意事項</target>
        </trans-unit>
        <trans-unit id="f85a104fce56d4fdf589c3dd1d9c7b40327d3c8b" translate="yes" xml:space="preserve">
          <source>Note on Reducer Composition</source>
          <target state="translated">レジューサーの組成に関する注意事項</target>
        </trans-unit>
        <trans-unit id="4d5561853fa6b8c8692a5c30631ba7770fde7366" translate="yes" xml:space="preserve">
          <source>Note on Relationships</source>
          <target state="translated">人間関係についての注意点</target>
        </trans-unit>
        <trans-unit id="0b2ca83fd75e901aec616d782b23314502061cce" translate="yes" xml:space="preserve">
          <source>Note on immutability, side effects, and mutation</source>
          <target state="translated">不変性、副作用、突然変異についての注意点</target>
        </trans-unit>
        <trans-unit id="068f9eefaa044d6807c7bf4c8c0f32ef9489c02e" translate="yes" xml:space="preserve">
          <source>Note that &amp;ldquo;updating data immutably&amp;rdquo; does &lt;em&gt;not&lt;/em&gt; mean that you must use &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable.js&lt;/a&gt;, although that is certainly an option. You can do immutable updates to plain JS objects and arrays using several different approaches:</source>
          <target state="translated">「不変にデータを更新する」とは、&lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable.jsを&lt;/a&gt;使用する必要があることを意味し&lt;em&gt;ない&lt;/em&gt;ことに注意してください。いくつかの異なるアプローチを使用して、プレーンなJSオブジェクトおよび配列に対して不変の更新を行うことができます。</target>
        </trans-unit>
        <trans-unit id="03a447c3fbe3d52e5d3b4ec4eb5f4cbd98b4d07a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;combineReducers&lt;/code&gt; doesn't know or care that there's anything special about the reducer function that's responsible for managing &lt;code&gt;a&lt;/code&gt;. We didn't need to modify &lt;code&gt;combineReducers&lt;/code&gt; to specifically know how to undo things - we just built up the pieces we needed into a new composed function.</source>
          <target state="translated">注意 &lt;code&gt;combineReducers&lt;/code&gt; を管理する責任がありますリデューサ機能については何の特別な存在だということを知っているか気にしません。 &lt;code&gt;combineReducers&lt;/code&gt; を元に戻す方法を具体的に知るために、combinReducersを変更する必要はありませんでした。必要な部分を新しい合成関数にビルドしただけです。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b8cedc1c11fc5e0b2729544aacc4a299dcef1a86" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;todos&lt;/code&gt; also accepts &lt;code&gt;state&lt;/code&gt;&amp;mdash;but it's an array! Now &lt;code&gt;todoApp&lt;/code&gt; just gives it the slice of the state to manage, and &lt;code&gt;todos&lt;/code&gt; knows how to update just that slice. &lt;strong&gt;This is called &lt;em&gt;reducer composition&lt;/em&gt;, and it's the fundamental pattern of building Redux apps.&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;todos&lt;/code&gt; は &lt;code&gt;state&lt;/code&gt; も受け入れることに注意してください&amp;mdash; しかし、それは配列です！これで、 &lt;code&gt;todoApp&lt;/code&gt; は管理する状態のスライスを提供するだけであり、 &lt;code&gt;todos&lt;/code&gt; はそのスライスだけを更新する方法を知っています。&lt;strong&gt;これは&lt;em&gt;レデューサーコンポジション&lt;/em&gt;と呼ばれ、Reduxアプリを構築するための基本的なパターンです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f8b0362b0a282b6bc627b26a9692c8cb48f4d7f" translate="yes" xml:space="preserve">
          <source>Note that Immutable.JS objects do have a &lt;code&gt;toJS()&lt;/code&gt; method, which returns the data as a plain JavaScript data structure, but this method is extremely slow, and using it extensively will negate the performance benefits that Immutable.JS provides</source>
          <target state="translated">Immutable.JSオブジェクトには &lt;code&gt;toJS()&lt;/code&gt; メソッドがあり、プレーンJavaScriptデータ構造としてデータを返すことに注意してください。ただし、このメソッドは非常に低速であり、このメソッドを広範囲に使用すると、Immutable.JSが提供するパフォーマンス上の利点が失われます。</target>
        </trans-unit>
        <trans-unit id="453c35dfa0c302d121b3eadd02c225634676ef9a" translate="yes" xml:space="preserve">
          <source>Note that a normalized state structure generally implies that more components are connected and each component is responsible for looking up its own data, as opposed to a few connected components looking up large amounts of data and passing all that data downwards. As it turns out, having connected parent components simply pass item IDs to connected children is a good pattern for optimizing UI performance in a React Redux application, so keeping state normalized plays a key role in improving performance.</source>
          <target state="translated">正規化された状態構造は、一般的に、より多くのコンポーネントが接続されており、いくつかの接続されたコンポーネントが大量のデータを調べて、そのデータをすべて下に渡すのとは対照的に、各コンポーネントが自分のデータを調べる責任を負っていることを意味していることに注意してください。結局のところ、接続された親コンポーネントが単にアイテムIDを接続された子コンポーネントに渡すことは、React ReduxアプリケーションのUIパフォーマンスを最適化するための良いパターンなので、状態を正規化しておくことはパフォーマンスを向上させる上で重要な役割を果たします。</target>
        </trans-unit>
        <trans-unit id="bd5f79bd2131ac43e4417a0d7a6aaff0b70dafa1" translate="yes" xml:space="preserve">
          <source>Note that a reducer is a pure function. It only &lt;em&gt;computes&lt;/em&gt; the next state. It should be completely predictable: calling it with the same inputs many times should produce the same outputs. It shouldn't perform any side effects like API calls or router transitions. These should happen before an action is dispatched.</source>
          <target state="translated">レデューサーは純粋な関数であることに注意してください。次の状態のみを&lt;em&gt;計算&lt;/em&gt;します。完全に予測可能である必要があります。同じ入力で何度も呼び出すと、同じ出力が生成されます。API呼び出しやルーターの移行などの副作用は発生しません。これらは、アクションがディスパッチされる前に発生する必要があります。</target>
        </trans-unit>
        <trans-unit id="dce445ddd99a63b5841226d22eed33b3bf5571f8" translate="yes" xml:space="preserve">
          <source>Note that experimental language features are subject to change.</source>
          <target state="translated">実験的な言語機能は変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6b9f2be80295a73b990bda31c5fcc186d2c3fd08" translate="yes" xml:space="preserve">
          <source>Note that if you use &lt;code&gt;reduceReducers&lt;/code&gt;, you should make sure that the first reducer in the list is able to define the initial state, since the later reducers will generally assume that the entire state already exists and not try to provide defaults.</source>
          <target state="translated">&lt;code&gt;reduceReducers&lt;/code&gt; を使用する場合は、リストの最初のレデューサーが初期状態を定義できることを確認する必要があることに注意してください。後のレデューサーは通常、状態全体がすでに存在し、デフォルトを提供しようとしないためです。</target>
        </trans-unit>
        <trans-unit id="3299e9657e0599957e5ab9cd478270d217e7c17c" translate="yes" xml:space="preserve">
          <source>Note that this is equivalent to:</source>
          <target state="translated">と同等であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e53104dd9201201207a0d3f3e75f9194a7e7bc6e" translate="yes" xml:space="preserve">
          <source>Note that this is still an experimental language feature proposal so it may change in the future. Nevertheless some large projects such as &lt;a href=&quot;https://github.com/facebook/react-native&quot;&gt;React Native&lt;/a&gt; already use it extensively so it is safe to say that there will be a good automated migration path if it changes.</source>
          <target state="translated">これはまだ実験的な言語機能の提案であるため、将来変更される可能性があることに注意してください。それにもかかわらず、&lt;a href=&quot;https://github.com/facebook/react-native&quot;&gt;React Native&lt;/a&gt;などの一部の大規模プロジェクトではすでに広く使用されているため、変更された場合に適切な自動移行パスがあると言っても安全です。</target>
        </trans-unit>
        <trans-unit id="83b83325ce50b1549fdb9a559ec6487d2af3c6cb" translate="yes" xml:space="preserve">
          <source>Note that unlike Redux itself, many packages in the Redux ecosystem don't provide UMD builds, so we recommend using CommonJS module bundlers like &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; and &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; for the most comfortable development experience.</source>
          <target state="translated">Redux自体とは異なり、Reduxエコシステムの多くのパッケージはUMDビルドを提供しないため、最も快適な開発体験のために、&lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;や&lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;などのCommonJSモジュールバンドルを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="62f695305f86349d2a0577aa88e353229236d1f1" translate="yes" xml:space="preserve">
          <source>Note that we are using &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6 destructuring&lt;/a&gt; on the properties to pass in &lt;code&gt;params&lt;/code&gt; to &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">プロパティで&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6の&lt;/a&gt; &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt; を使用して &lt;code&gt;params&lt;/code&gt; を&amp;lt;VisibleTodoList /&amp;gt;に渡すことに注意してください。</target>
        </trans-unit>
        <trans-unit id="1618ff7b8e1c0dbfdbf2def8e4b7d2220f232032" translate="yes" xml:space="preserve">
          <source>Note that your &lt;code&gt;combineReducers()&lt;/code&gt; call will stay exactly as it was, but the &lt;code&gt;todos&lt;/code&gt; reducer will now refer to the reducer enhanced with Redux Undo:</source>
          <target state="translated">ただし、 &lt;code&gt;combineReducers()&lt;/code&gt; 呼び出しはそのままですが、 &lt;code&gt;todos&lt;/code&gt; レデューサーはRedux Undoで拡張されたレデューサーを参照します。</target>
        </trans-unit>
        <trans-unit id="727f3c121140693e9689630208289bf9c864cbb3" translate="yes" xml:space="preserve">
          <source>Note that, conversely, if an &lt;em&gt;immutable&lt;/em&gt; object is used, the &lt;a href=&quot;#immutability-issues-with-react-redux&quot;&gt;component may re-render when it should not&lt;/a&gt;.</source>
          <target state="translated">逆に、&lt;em&gt;不変&lt;/em&gt;オブジェクトが使用されている場合、&lt;a href=&quot;#immutability-issues-with-react-redux&quot;&gt;コンポーネントは&lt;/a&gt;、不必要なときに再レンダリングする可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b863cfb1b4dca7e52579f1008befc33963aff3ba" translate="yes" xml:space="preserve">
          <source>Note that, conversely, if the values in your props object refer to mutable objects, &lt;a href=&quot;#shallow-checking-stops-component-re-rendering&quot;&gt;your component may not render when it should&lt;/a&gt;.</source>
          <target state="translated">逆に、propsオブジェクトの値が変更可能なオブジェクトを参照している場合、&lt;a href=&quot;#shallow-checking-stops-component-re-rendering&quot;&gt;コンポーネントがレンダリングできない場合があることに注意してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e99340e9e77003c33d3f85a388e8f45942421146" translate="yes" xml:space="preserve">
          <source>Note that, even if your immutable library supports cursors, you shouldn't use them in a Redux app. The whole state tree should be considered read-only, and you should use Redux for updating the state, and subscribing to the updates. Therefore writing via cursor doesn't make sense for Redux. &lt;strong&gt;If your only use case for cursors is decoupling the state tree from the UI tree and gradually refining the cursors, you should look at selectors instead.&lt;/strong&gt; Selectors are composable getter functions. See &lt;a href=&quot;http://github.com/faassen/reselect&quot;&gt;reselect&lt;/a&gt; for a really great and concise implementation of composable selectors.</source>
          <target state="translated">不変のライブラリーがカーソルをサポートしている場合でも、それらをReduxアプリで使用しないでください。状態ツリー全体は読み取り専用と見なされ、状態の更新および更新のサブスクライブにはReduxを使用する必要があります。したがって、カーソルを介して書き込むことはReduxには意味がありません。&lt;strong&gt;カーソルの唯一のユースケースがUIツリーから状態ツリーを分離し、カーソルを徐々に調整する場合は、代わりにセレクターを調べる必要があります。&lt;/strong&gt;セレクターは、合成可能なゲッター関数です。構成可能セレクターの非常に優れた簡潔な実装については、&lt;a href=&quot;http://github.com/faassen/reselect&quot;&gt;reselect&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">そのことに注意してください。</target>
        </trans-unit>
        <trans-unit id="9b3033c3ffc250f6cdbccd213236b9854f6e17c7" translate="yes" xml:space="preserve">
          <source>Note, however, that this does not apply to the Redux state tree, which is (usually) represented as a large collection of data.</source>
          <target state="translated">ただし、これは(通常は)大きなデータの集合として表現される Redux 状態ツリーには適用されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="401d2785d679a18987a35eba32cda5b4c90664ab" translate="yes" xml:space="preserve">
          <source>Nothing happens when I dispatch an action</source>
          <target state="translated">アクションをディスパッチしても何も起こらない</target>
        </trans-unit>
        <trans-unit id="f2f081e8fb2d918d664c68f1b3afaafa905dc9ec" translate="yes" xml:space="preserve">
          <source>Notice that because the two &quot;slice of state&quot; reducers are now getting only their own part of the whole state as arguments, they no longer need to return complex nested state objects, and are now simpler as a result.</source>
          <target state="translated">2つの &quot;slice of state &quot;レデューサは、全体の状態の自分の部分のみを引数として取得するようになったため、複雑な入れ子になった状態オブジェクトを返す必要がなくなり、結果としてよりシンプルになったことに注目してください。</target>
        </trans-unit>
        <trans-unit id="259bf730b245ab69768be3ff064b89e550ad7e24" translate="yes" xml:space="preserve">
          <source>Notice that because we used the ES6 shorthand for defining an object literal, the key names in the resulting state are the same as the variable names from the imports. This may not always be the desired behavior, and is often a cause of confusion for those who aren't as familiar with ES6 syntax.</source>
          <target state="translated">オブジェクト リテラルの定義には ES6 の短縮形を使用しているため、結果として得られる状態のキー名はインポートされた変数名と同じであることに注意してください。これは必ずしも望ましい動作とは限らず、ES6 の構文に慣れていない人にとっては混乱の原因となることがよくあります。</target>
        </trans-unit>
        <trans-unit id="c55d1d53bcc6077be7393d548df6e69409007456" translate="yes" xml:space="preserve">
          <source>Notice that the structure of the data is a bit complex, and some of the data is repeated. This is a concern for several reasons:</source>
          <target state="translated">データの構造が少し複雑で、いくつかのデータが繰り返されていることに注目してください。これはいくつかの理由で懸念されています。</target>
        </trans-unit>
        <trans-unit id="31c43966210d015eb458a0c29218a03e52a64682" translate="yes" xml:space="preserve">
          <source>Notice that this simple function fulfills all the basic requirements. It returns a default value if none exists, initializing the store; it determines what sort of update needs to be done based on the type of the action, and returns new values; and it returns the previous state if no work needs to be done.</source>
          <target state="translated">この単純な関数は基本的な要件をすべて満たしていることに注目してください。存在しない場合はデフォルト値を返し、ストアを初期化します。アクションのタイプに基づいてどのような更新が必要かを判断し、新しい値を返します。</target>
        </trans-unit>
        <trans-unit id="2f594ca01c521a947b3e348a3910ebef9ac4949d" translate="yes" xml:space="preserve">
          <source>Now I specified the &lt;code&gt;preloadedState&lt;/code&gt; as the argument to &lt;code&gt;createStore()&lt;/code&gt;. The state returned from the combined reducer &lt;em&gt;combines&lt;/em&gt; the initial state I specified for the &lt;code&gt;a&lt;/code&gt; reducer with the &lt;code&gt;'wat'&lt;/code&gt; default argument specified that &lt;code&gt;b&lt;/code&gt; reducer chose itself.</source>
          <target state="translated">今、私は指定された &lt;code&gt;preloadedState&lt;/code&gt; を引数として &lt;code&gt;createStore()&lt;/code&gt; 。結合されたレデューサーから返される状態は、 &lt;code&gt;a&lt;/code&gt; レデューサーに指定した初期状態と、 &lt;code&gt;b&lt;/code&gt; レデューサーがそれ自体を選択したことを指定した &lt;code&gt;'wat'&lt;/code&gt; デフォルト引数を&lt;em&gt;組み合わせ&lt;/em&gt;たものです。</target>
        </trans-unit>
        <trans-unit id="2b89cc88436f6b137ad4a9f780f72e731b9b03e7" translate="yes" xml:space="preserve">
          <source>Now all that's left to do is to port the UI to &lt;a href=&quot;../basics/usagewithreact&quot;&gt;use react-redux&lt;/a&gt; or equivalent.</source>
          <target state="translated">あとは、&lt;a href=&quot;../basics/usagewithreact&quot;&gt;react-redux&lt;/a&gt;または同等のものを使用するように UIを移植するだけです。</target>
        </trans-unit>
        <trans-unit id="eb64c52d4e3660f6e76a49dcb8eecf7480f674ab" translate="yes" xml:space="preserve">
          <source>Now all you need to do is add the buttons for the Undo and Redo actions.</source>
          <target state="translated">あとは、UndoとRedoアクションのボタンを追加するだけです。</target>
        </trans-unit>
        <trans-unit id="a13470744cb184c27b6870ae352da0030e60cab7" translate="yes" xml:space="preserve">
          <source>Now if you click on &lt;code&gt;&amp;lt;FilterLink /&amp;gt;&lt;/code&gt; you will see that your URL will change between &lt;code&gt;'/SHOW_COMPLETED'&lt;/code&gt;, &lt;code&gt;'/SHOW_ACTIVE'&lt;/code&gt;, and &lt;code&gt;'/'&lt;/code&gt;. Even if you are going back with your browser, it will use your browser's history and effectively go to your previous URL.</source>
          <target state="translated">&lt;code&gt;&amp;lt;FilterLink /&amp;gt;&lt;/code&gt; をクリックすると、URLが &lt;code&gt;'/SHOW_COMPLETED'&lt;/code&gt; 、 &lt;code&gt;'/SHOW_ACTIVE'&lt;/code&gt; 、および &lt;code&gt;'/'&lt;/code&gt; の間で変化することがわかります。ブラウザに戻った場合でも、ブラウザの履歴が使用され、以前のURLに効率的に移動します。</target>
        </trans-unit>
        <trans-unit id="b5c5b26561c588a93e62173562a3ad6868edb589" translate="yes" xml:space="preserve">
          <source>Now it's &lt;em&gt;very&lt;/em&gt; clear what's happening in each case. We can also start to see some patterns emerging.</source>
          <target state="translated">これで、各ケースで何が起こっているかが&lt;em&gt;非常に&lt;/em&gt;明確になりました。また、いくつかのパターンが出現し始めていることもわかります。</target>
        </trans-unit>
        <trans-unit id="039958ecab3a233f66de07e31ed5de4247ff1cc6" translate="yes" xml:space="preserve">
          <source>Now it's time to hook up those presentational components to Redux by creating some containers. Technically, a container component is just a React component that uses &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;store.subscribe()&lt;/code&gt;&lt;/a&gt; to read a part of the Redux state tree and supply props to a presentational component it renders. You could write a container component by hand, but we suggest instead generating container components with the React Redux library's &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; function, which provides many useful optimizations to prevent unnecessary re-renders. (One result of this is that you shouldn't have to worry about the &lt;a href=&quot;https://facebook.github.io/react/docs/advanced-performance.html&quot;&gt;React performance suggestion&lt;/a&gt; of implementing &lt;code&gt;shouldComponentUpdate&lt;/code&gt; yourself.)</source>
          <target state="translated">次に、コンテナを作成して、これらのプレゼンテーションコンポーネントをReduxに接続します。技術的には、コンテナーコンポーネントは、&lt;a href=&quot;../api/store#subscribe&quot;&gt; &lt;code&gt;store.subscribe()&lt;/code&gt; &lt;/a&gt;コンポーネントであり、store.subscribe（）を使用してRedux状態ツリーの一部を読み取り、レンダリングするプレゼンテーションコンポーネントに小道具を提供します。コンテナーコンポーネントを手動で作成することもできますが、代わりにReact Reduxライブラリの&lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt;関数を使用してコンテナーコンポーネントを生成することをお勧めします。これにより、不要な再レンダリングを防ぐための多くの便利な最適化が提供されます。 （これの1つの結果は、 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; を自分で実装するという&lt;a href=&quot;https://facebook.github.io/react/docs/advanced-performance.html&quot;&gt;Reactパフォーマンスの提案&lt;/a&gt;について心配する必要がないことです。）</target>
        </trans-unit>
        <trans-unit id="9e400bbf3cbd513fc16c8f3c4354394f2d6dfefd" translate="yes" xml:space="preserve">
          <source>Now let's &lt;a href=&quot;reducers&quot;&gt;define some reducers&lt;/a&gt; to specify how the state updates when you dispatch these actions!</source>
          <target state="translated">次に、これらのアクションをディスパッチしたときに状態がどのように更新されるかを指定&lt;a href=&quot;reducers&quot;&gt;するいくつかのレデューサー&lt;/a&gt;を定義しましょう！</target>
        </trans-unit>
        <trans-unit id="a861289e4760b669f41d014c314ded1b05995e5c" translate="yes" xml:space="preserve">
          <source>Now let's consider a case where you use &lt;code&gt;combineReducers()&lt;/code&gt;.</source>
          <target state="translated">次に、 &lt;code&gt;combineReducers()&lt;/code&gt; を使用する場合を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="25793e0576f1da9e1c2bfbfd26f6e9946bceb3cb" translate="yes" xml:space="preserve">
          <source>Now let's handle &lt;code&gt;SET_VISIBILITY_FILTER&lt;/code&gt;. All it needs to do is to change &lt;code&gt;visibilityFilter&lt;/code&gt; on the state. Easy:</source>
          <target state="translated">次に、 &lt;code&gt;SET_VISIBILITY_FILTER&lt;/code&gt; を処理します。必要なのは、状態の &lt;code&gt;visibilityFilter&lt;/code&gt; を変更することだけです。簡単：</target>
        </trans-unit>
        <trans-unit id="f7f2dcd080c7438e503e2c14d7c5e936c3fb8edb" translate="yes" xml:space="preserve">
          <source>Now let's say you create a store with it.</source>
          <target state="translated">では、それを使ってお店を作るとしましょう。</target>
        </trans-unit>
        <trans-unit id="29c32e5fc4131c9dccec8ae29eeeaccbf917ea78" translate="yes" xml:space="preserve">
          <source>Now middleware takes the &lt;code&gt;next()&lt;/code&gt; dispatch function, and returns a dispatch function, which in turn serves as &lt;code&gt;next()&lt;/code&gt; to the middleware to the left, and so on. It's still useful to have access to some store methods like &lt;code&gt;getState()&lt;/code&gt;, so &lt;code&gt;store&lt;/code&gt; stays available as the top-level argument.</source>
          <target state="translated">これで、ミドルウェアは &lt;code&gt;next()&lt;/code&gt; ディスパッチ関数を受け取り、ディスパッチ関数を返します。ディスパッチ関数は、左側のミドルウェアに対して &lt;code&gt;next()&lt;/code&gt; として機能します。 &lt;code&gt;getState()&lt;/code&gt; などの一部のストアメソッドにアクセスできると便利なため、 &lt;code&gt;store&lt;/code&gt; は最上位の引数として使用できます。</target>
        </trans-unit>
        <trans-unit id="382b9eb84610aaa6ea11db467333f8d6953604ec" translate="yes" xml:space="preserve">
          <source>Now that we have a better understanding of reducer enhancers, we can see that this is exactly what &lt;code&gt;undoable&lt;/code&gt; should have been:</source>
          <target state="translated">これでレデューサーエンハンサーについての理解が深まったので、これがまさに元に &lt;code&gt;undoable&lt;/code&gt; ことができるはずであることがわかります。</target>
        </trans-unit>
        <trans-unit id="a5a09e1de7d9c9396b8d34429449e39f8bd9943d" translate="yes" xml:space="preserve">
          <source>Now that we have created a store, let's verify our program works! Even without any UI, we can already test the update logic.</source>
          <target state="translated">ストアを作成したので、プログラムが動作することを確認してみましょう UIがなくても、更新ロジックをテストすることができます。</target>
        </trans-unit>
        <trans-unit id="b286277222e0bb8486e6265c655c4d0a7094d7a9" translate="yes" xml:space="preserve">
          <source>Now that we've decided what our state object looks like, we're ready to write a reducer for it. The reducer is a pure function that takes the previous state and an action, and returns the next state.</source>
          <target state="translated">これで、状態オブジェクトがどのようなものになるかが決まりましたので、そのためのレデューサを書く準備ができました。レデューサは、前の状態とアクションを受け取り、次の状態を返す純粋な関数です。</target>
        </trans-unit>
        <trans-unit id="c21e7038b2cfa1d79db9097dffc1cae32ab8eff6" translate="yes" xml:space="preserve">
          <source>Now that you know how Redux works, let's &lt;a href=&quot;usagewithreact&quot;&gt;connect it to a React app&lt;/a&gt;.</source>
          <target state="translated">Reduxの仕組みがわかっ&lt;a href=&quot;usagewithreact&quot;&gt;たところで、Reuxアプリに接続し&lt;/a&gt;ましょう。</target>
        </trans-unit>
        <trans-unit id="04bd1420551bdec742d2330183e8fe0464300fae" translate="yes" xml:space="preserve">
          <source>Now that you know how to do basic routing, you can learn more about &lt;a href=&quot;https://github.com/reactjs/react-router/tree/v3/docs/&quot;&gt;React Router API&lt;/a&gt;</source>
          <target state="translated">基本的なルーティングの方法がわかったので、&lt;a href=&quot;https://github.com/reactjs/react-router/tree/v3/docs/&quot;&gt;React Router API&lt;/a&gt;についてさらに学習します。</target>
        </trans-unit>
        <trans-unit id="df198929b555d3f025b9f4c6dce1d531c1c5ab85" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; component will be rendered if the URL matches '/'. Additionally, we will add the optional &lt;code&gt;(:filter)&lt;/code&gt; parameter to &lt;code&gt;/&lt;/code&gt;, because we will need it further on when we try to read the parameter &lt;code&gt;(:filter)&lt;/code&gt; from the URL.</source>
          <target state="translated">これで、URLが「/」に一致する場合、 &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; コンポーネントがレンダリングされます。さらに、オプションの &lt;code&gt;(:filter)&lt;/code&gt; パラメーターを &lt;code&gt;/&lt;/code&gt; に追加します。これは、URLからパラメーター &lt;code&gt;(:filter)&lt;/code&gt; を読み取ろうとするときにさらに必要になるためです。</target>
        </trans-unit>
        <trans-unit id="5d916cc36e1dd4f19a7f89bff47aaabeb96451f9" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;todos&lt;/code&gt; part of the state looks like this:</source>
          <target state="translated">今、 &lt;code&gt;todos&lt;/code&gt; このような状態に見えるの一部：</target>
        </trans-unit>
        <trans-unit id="d942270816eb39d5e0deb26630ac877f7158718d" translate="yes" xml:space="preserve">
          <source>Now we can rewrite the main reducer as a function that calls the reducers managing parts of the state, and combines them into a single object. It also doesn't need to know the complete initial state anymore. It's enough that the child reducers return their initial state when given &lt;code&gt;undefined&lt;/code&gt; at first.</source>
          <target state="translated">これで、メインのレデューサーを、状態の一部を管理するレデューサーを呼び出し、それらを単一のオブジェクトに結合する関数として書き換えることができます。また、完全な初期状態を知る必要もありません。子リデューサーは、最初は &lt;code&gt;undefined&lt;/code&gt; 場合、初期状態を返すだけで十分です。</target>
        </trans-unit>
        <trans-unit id="a667ae6de0b7dc9eab910e5e9d0c63d6e4240965" translate="yes" xml:space="preserve">
          <source>Now you can add &lt;code&gt;UndoRedo&lt;/code&gt; component to the &lt;code&gt;App&lt;/code&gt; component:</source>
          <target state="translated">これで、 &lt;code&gt;UndoRedo&lt;/code&gt; コンポーネントを &lt;code&gt;App&lt;/code&gt; コンポーネントに追加できます。</target>
        </trans-unit>
        <trans-unit id="c2b05aac713becd3e746ad95aee7b78fc6182e91" translate="yes" xml:space="preserve">
          <source>Now you saw an example of what middleware can do in Redux, it's time to learn how it actually works, and how you can create your own. Go on to the next detailed section about &lt;a href=&quot;middleware&quot;&gt;Middleware&lt;/a&gt;.</source>
          <target state="translated">これで、ミドルウェアがReduxで実行できることの例を見ました。次に、ミドルウェアが実際にどのように機能するか、そしてどのように独自のミドルウェアを作成できるかを学習します。&lt;a href=&quot;middleware&quot;&gt;ミドルウェア&lt;/a&gt;に関する次の詳細セクションに進んでください。</target>
        </trans-unit>
        <trans-unit id="65dfb2a3456a6347a253e5df887084ce9d5bc969" translate="yes" xml:space="preserve">
          <source>Now you'll be able to call them directly:</source>
          <target state="translated">これで直接電話ができるようになりました。</target>
        </trans-unit>
        <trans-unit id="e7d7d4bdf1f24961ac2cd4648199d9fca2b39f7d" translate="yes" xml:space="preserve">
          <source>Now, if user presses &amp;ldquo;Undo&amp;rdquo;, we want it to change to move into the past:</source>
          <target state="translated">ここで、ユーザーが[元に戻す]を押すと、過去に移動するように変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="9f0f0f51df5136b797764eade8b49d76aa9d3def" translate="yes" xml:space="preserve">
          <source>Now, the UI can be updated to reflect the new state. If you use bindings like &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;React Redux&lt;/a&gt;, this is the point at which &lt;code&gt;component.setState(newState)&lt;/code&gt; is called.</source>
          <target state="translated">これで、UIを更新して新しい状態を反映できます。&lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;React Reduxの&lt;/a&gt;ようなバインディングを使用する場合、これが、 &lt;code&gt;component.setState(newState)&lt;/code&gt; が呼び出されるポイントです。</target>
        </trans-unit>
        <trans-unit id="238539b34511566c52f015ab4f02c6eba84442e7" translate="yes" xml:space="preserve">
          <source>Now, the problem is what to put in the action creator and what in the reducer, the choice between fat and thin action objects. If you put all the logic in the action creator, you end up with fat action objects that basically declare the updates to the state. Reducers become pure, dumb, add-this, remove that, update these functions. They will be easy to compose. But not much of your business logic will be there. If you put more logic in the reducer, you end up with nice, thin action objects, most of your data logic in one place, but your reducers are harder to compose since you might need info from other branches. You end up with large reducers or reducers that take additional arguments from higher up in the state.</source>
          <target state="translated">さて、問題は、アクションクリエータに何を入れ、レデューサに何を入れるか、太いアクションオブジェクトと細いアクションオブジェクトの選択です。アクションクリエーターにすべてのロジックを入れると、基本的に状態の更新を宣言する太いアクションオブジェクトになってしまいます。レデューサーは、純粋に、これを追加して、これを削除して、これらの関数を更新する、間抜けなものになります。これらの関数は簡単に構成できます。しかし、ビジネスロジックの多くはそこにはありません。レデューサにより多くのロジックを入れた場合、1つの場所にデータロジックの大部分を配置した薄型のアクションオブジェクトになりますが、他のブランチからの情報が必要になる可能性があるため、レデューサを構成するのが難しくなります。大規模なレデューサや、状態の上位から追加の引数を取るレデューサになってしまいます。</target>
        </trans-unit>
        <trans-unit id="dd811c18dfe3457c25b793431983374970c1dbff" translate="yes" xml:space="preserve">
          <source>Object spread lets us simplify the above &lt;code&gt;map&lt;/code&gt; call to:</source>
          <target state="translated">オブジェクトスプレッドを使用すると、上記の &lt;code&gt;map&lt;/code&gt; 呼び出しを次のように簡略化できます。</target>
        </trans-unit>
        <trans-unit id="f2d82a77c6f21355d9167707cd08b4acf80faac7" translate="yes" xml:space="preserve">
          <source>Obviously, each layer of nesting makes this harder to read, and gives more chances to make mistakes. This is one of several reasons why you are encouraged to keep your state flattened, and compose reducers as much as possible.</source>
          <target state="translated">明らかに、入れ子の各層は、これを読みにくくし、間違いを犯す機会を多く与えます。これは、自分の状態をフラットにしておき、できるだけレデューサーを構成することが推奨されるいくつかの理由の一つです。</target>
        </trans-unit>
        <trans-unit id="99059fe3a8c10ea3a773517b2809c9d604ee1753" translate="yes" xml:space="preserve">
          <source>Obviously, trying to handle every possible action in a single function does not scale well, simply in terms of function size and readability, so it makes sense to split the actual work into separate functions that can be called by the top-level reducer. In particular, the common suggested pattern is to have a separate sub-reducer function that is responsible for managing updates to a particular slice of state at a specific key. The &lt;code&gt;combineReducers()&lt;/code&gt; that comes with Redux is one of the many possible ways to achieve this. It's also highly suggested to keep your store state as flat and as normalized as possible. Ultimately, though, you are in charge of organizing your reducer logic any way you want.</source>
          <target state="translated">明らかに、単一の関数で可能なすべてのアクションを処理しようとしても、単純に関数のサイズと読みやすさの点で適切にスケーリングされないため、実際の作業をトップレベルのレデューサーが呼び出すことができる個別の関数に分割することは理にかなっています。特に、一般的に推奨されるパターンは、特定のキーで特定の状態スライスへの更新を管理する役割を持つ個別のサブレデューサー関数を持つことです。Reduxに付属の &lt;code&gt;combineReducers()&lt;/code&gt; は、これを実現する多くの可能な方法の1つです。また、ストアの状態をできるだけフラットにし、できるだけ正規化することを強くお勧めします。ただし、最終的には、必要に応じてレデューサーロジックを整理する必要があります。</target>
        </trans-unit>
        <trans-unit id="0cc135e616ba1be37c0cfabb241f9c97c73b5f08" translate="yes" xml:space="preserve">
          <source>On the client side, a new Redux store will be created and initialized with the state provided from the server.</source>
          <target state="translated">クライアント側では、新しいReduxストアが作成され、サーバーから提供された状態で初期化されます。</target>
        </trans-unit>
        <trans-unit id="c6f42b17ddf866ba0ef881ccab2d5ac7ea6bba3a" translate="yes" xml:space="preserve">
          <source>On the server side, we simply wrap our existing code in the &lt;code&gt;fetchCounter&lt;/code&gt; and receive the result in the callback:</source>
          <target state="translated">サーバー側では、既存のコードを &lt;code&gt;fetchCounter&lt;/code&gt; でラップし、コールバックで結果を受け取ります。</target>
        </trans-unit>
        <trans-unit id="abb297d24ed9dbaa92d7ae801845e13d9a8c7d96" translate="yes" xml:space="preserve">
          <source>On this page we will only feature a few of them that the Redux maintainers have vetted personally. Don't let this discourage you from trying the rest of them! The ecosystem is growing too fast, and we have a limited time to look at everything. Consider these the &amp;ldquo;staff picks&amp;rdquo;, and don't hesitate to submit a PR if you've built something wonderful with Redux.</source>
          <target state="translated">このページでは、Reduxメンテナが個人的に精査したほんの一部を紹介します。これにより、残りの部分を試さないようにしてください。エコシステムは急速に成長しており、すべてを調べる時間は限られています。これらを「スタッフピック」と見なし、Reduxで素晴らしいものを作成した場合は、遠慮なくPRを送信してください。</target>
        </trans-unit>
        <trans-unit id="00a57ab237ca0a42b345eb1574324e493eaac905" translate="yes" xml:space="preserve">
          <source>Once used, Immutable.JS will spread throughout your codebase</source>
          <target state="translated">一度使用すると、Immutable.JS はコードベース全体に広がります。</target>
        </trans-unit>
        <trans-unit id="e388b344448bc1c302e673361dcd29e30a20c835" translate="yes" xml:space="preserve">
          <source>Once you encapsulate your data with Immutable.JS, you have to use Immutable.JS&amp;rsquo;s &lt;code&gt;get()&lt;/code&gt; or &lt;code&gt;getIn()&lt;/code&gt; property accessors to access it.</source>
          <target state="translated">Immutable.JSでデータをカプセル化したら、Immutable.JSの &lt;code&gt;get()&lt;/code&gt; または &lt;code&gt;getIn()&lt;/code&gt; プロパティアクセサーを使用してそれにアクセスする必要があります。</target>
        </trans-unit>
        <trans-unit id="99e18cc195c97bd7e16b2c5c00f317c2ee608dad" translate="yes" xml:space="preserve">
          <source>One approach is to merge the contents of the action in to the existing state. In this case, we need to do a deep recursive merge, not just a shallow copy. The Lodash &lt;code&gt;merge&lt;/code&gt; function can handle this for us:</source>
          <target state="translated">1つのアプローチは、アクションの内容を既存の状態にマージすることです。この場合、浅いコピーだけでなく、深い再帰的なマージを行う必要があります。 Lodash &lt;code&gt;merge&lt;/code&gt; 関数はこれを処理できます：</target>
        </trans-unit>
        <trans-unit id="d0a9b8df0f4b63915decda672bef5db25fe34cfb" translate="yes" xml:space="preserve">
          <source>One frequently asked question is whether Redux &quot;calls all reducers&quot; when dispatching an action. Since there really is only one root reducer function, the default answer is &quot;no, it does not&quot;. However, &lt;code&gt;combineReducers&lt;/code&gt; has specific behavior that &lt;em&gt;does&lt;/em&gt; work that way. In order to assemble the new state tree, &lt;code&gt;combineReducers&lt;/code&gt; will call each slice reducer with its current slice of state and the current action, giving the slice reducer a chance to respond and update its slice of state if needed. So, in that sense, using &lt;code&gt;combineReducers&lt;/code&gt;&lt;em&gt;does&lt;/em&gt; &quot;call all reducers&quot;, or at least all of the slice reducers it is wrapping.</source>
          <target state="translated">よくある質問の1つは、アクションをディスパッチするときにReduxが「すべてのレデューサーを呼び出す」かどうかです。ルートリデューサー関数は実際には1つしかないため、デフォルトの答えは「いいえ、ありません」です。ただし、 &lt;code&gt;combineReducers&lt;/code&gt; は、そのように&lt;em&gt;機能する&lt;/em&gt;特定の動作が&lt;em&gt;あり&lt;/em&gt;ます。新しい状態ツリーを組み立てるために、 &lt;code&gt;combineReducers&lt;/code&gt; は各スライスレデューサーを現在の状態スライスと現在のアクションで呼び出し、必要に応じてスライスレデューサーに応答してその状態スライスを更新する機会を与えます。したがって、その意味で、 &lt;code&gt;combineReducers&lt;/code&gt; を使用すると、「すべてのレデューサーを呼び出す」か、少なくともラッパー&lt;em&gt;が&lt;/em&gt;ラップ&lt;em&gt;している&lt;/em&gt;すべてのスライスレデューサーを呼び出します。</target>
        </trans-unit>
        <trans-unit id="a4284542792cb9fd32437214931abfe8482da4b0" translate="yes" xml:space="preserve">
          <source>One neat trick is to use the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/default_parameters&quot;&gt;ES6 default arguments syntax&lt;/a&gt; to write this in a more compact way:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/default_parameters&quot;&gt;巧妙&lt;/a&gt;なトリックの1つは、ES6のデフォルトの引数構文を使用して、これをよりコンパクトな方法で記述することです。</target>
        </trans-unit>
        <trans-unit id="da5b8fcb37f2ad97d55411d18f4f50a8acf81489" translate="yes" xml:space="preserve">
          <source>One of the benefits of Redux is that it makes state changes predictable and transparent. Every time an action is dispatched, the new state is computed and saved. The state cannot change by itself, it can only change as a consequence of a specific action.</source>
          <target state="translated">Reduxの利点の1つは、状態の変化が予測可能で透過的になることです。アクションがディスパッチされるたびに、新しい状態が計算されて保存されます。状態はそれ自体を変更することはできず、特定のアクションの結果としてのみ変更することができます。</target>
        </trans-unit>
        <trans-unit id="b05c40a81c382d7e1e4c5eb83c383c8c7dded6ae" translate="yes" xml:space="preserve">
          <source>One of the key advantages of immutability is that it enables shallow equality checking, which dramatically improves performance.</source>
          <target state="translated">不変性の大きなメリットの一つは、浅い平等性チェックが可能になり、パフォーマンスが飛躍的に向上することです。</target>
        </trans-unit>
        <trans-unit id="850c598dddd960ff8dafd82d078c789192dada81" translate="yes" xml:space="preserve">
          <source>Operating on JavaScript objects and arrays in an immutable way can be slow, particularly as your state tree grows larger.</source>
          <target state="translated">JavaScript のオブジェクトや配列を不変的に操作するのは、特に状態ツリーが大きくなるにつれて遅くなることがあります。</target>
        </trans-unit>
        <trans-unit id="af6c37b39bb6ed10d58088845d5a93da150bef3c" translate="yes" xml:space="preserve">
          <source>Operations like &quot;Look up all books by this author&quot; can then accomplished with a single loop over the join table. Given the typical amounts of data in a client application and the speed of Javascript engines, this kind of operation is likely to have sufficiently fast performance for most use cases.</source>
          <target state="translated">この著者のすべての書籍を検索する」というような操作は、結合テーブルの上で1つのループで実行できます。クライアントアプリケーションの典型的なデータ量とJavascriptエンジンの速度を考えると、この種の操作はほとんどのユースケースで十分に高速なパフォーマンスを発揮すると思われます。</target>
        </trans-unit>
        <trans-unit id="0d7d7275da2d9aaca178d7f0589e207de7175f18" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/async&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">または、&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/async&quot;&gt;サンドボックスを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="9a59e4840cfb59b6c79325bf664a6e38968716f6" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/counter&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">または、&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/counter&quot;&gt;サンドボックスを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="1b1b65f5915920208d15bbc3e393183be7f4d31d" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/real-world&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">または、&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/real-world&quot;&gt;サンドボックスを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="e36463d35299a6a01ac3b467e7d9564b1281179e" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">または、&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;サンドボックスを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="7b45aa8dcd97522495289719a1a18c6bc3300442" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todomvc&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">または、&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todomvc&quot;&gt;サンドボックスを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="d0e47b777f4c49cec0992d3e10c918d3a72df107" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">または、&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos&quot;&gt;サンドボックスを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="238eb2632136a6f032d42bfad2c07321a67db57b" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">または、&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;サンドボックスを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="6685195fe8e2bc04892759da1650e9052a5de4a3" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/tree-view&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">または、&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/tree-view&quot;&gt;サンドボックスを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="8370968834196c749ed73b6cfe92801e8117ab54" translate="yes" xml:space="preserve">
          <source>Or many granular histories so user can undo and redo actions in them independently:</source>
          <target state="translated">または、ユーザーがそれらの中のアクションを独立して元に戻したりやり直したりできるように、多くの粒度の高い履歴を作成することができます。</target>
        </trans-unit>
        <trans-unit id="0b392c8838a1573058a955eb668416b3dbbd0f9f" translate="yes" xml:space="preserve">
          <source>Or you can define separate types for them:</source>
          <target state="translated">または、それらのために別々のタイプを定義することができます。</target>
        </trans-unit>
        <trans-unit id="a0da4144d426fe2efff7bea61cbf27a014d43a17" translate="yes" xml:space="preserve">
          <source>Organizing Large React Applications</source>
          <target state="translated">大規模なReactアプリケーションの整理</target>
        </trans-unit>
        <trans-unit id="8ca854d46781915131c4b8db35d1de91075f652b" translate="yes" xml:space="preserve">
          <source>Organizing Normalized Data in State</source>
          <target state="translated">正規化されたデータを状態で整理する</target>
        </trans-unit>
        <trans-unit id="34d16c8765f577c8baee06d396d90415855ba54d" translate="yes" xml:space="preserve">
          <source>Organizing State</source>
          <target state="translated">組織化国家</target>
        </trans-unit>
        <trans-unit id="077be78f1b3e88543b41122cb8c6c6f77f12b367" translate="yes" xml:space="preserve">
          <source>Other Approaches</source>
          <target state="translated">その他のアプローチ</target>
        </trans-unit>
        <trans-unit id="eebb2f9cdc2951c739e98100dec8f3363c3a726b" translate="yes" xml:space="preserve">
          <source>Other Components</source>
          <target state="translated">その他の部品</target>
        </trans-unit>
        <trans-unit id="0b72b54d734e499b1f158ae8c13378ee3157b18a" translate="yes" xml:space="preserve">
          <source>Other side effects like generating unique IDs or timestamps in a reducer also make the code unpredictable and harder to debug and test.</source>
          <target state="translated">また、リデューサ内で一意の ID やタイムスタンプを生成するような他の副作用も、コードを予測不能にし、デバッグやテストを困難にします。</target>
        </trans-unit>
        <trans-unit id="fb937a0b9fb7519cc10c3b20032625261018ed28" translate="yes" xml:space="preserve">
          <source>Other than &lt;code&gt;type&lt;/code&gt;, the structure of an action object is really up to you. If you're interested, check out &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; for recommendations on how actions could be constructed.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 以外のアクションオブジェクトの構造は、実際にあなた次第です。興味がある場合は、&lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux標準アクション&lt;/a&gt;をチェックして、アクションの作成方法に関する推奨事項を確認してください。</target>
        </trans-unit>
        <trans-unit id="6536268ad716d89a65f56ced3b4cc69350c48fb9" translate="yes" xml:space="preserve">
          <source>Other than &lt;code&gt;type&lt;/code&gt;, the structure of an action object is really up to you. If you're interested, check out &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; for recommendations on how actions should be constructed.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 以外のアクションオブジェクトの構造は、実際にあなた次第です。興味がある場合は、&lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux標準アクション&lt;/a&gt;をチェックして、アクションの作成方法に関する推奨事項を確認してください。</target>
        </trans-unit>
        <trans-unit id="d77d9e8f5844c5c74da60395774b58f7d3f5387d" translate="yes" xml:space="preserve">
          <source>Others, like &lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper&lt;/a&gt; (a fork of the now-deprecated React Immutability Helpers addon), use nested values and helper functions:</source>
          <target state="translated">その他、&lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper&lt;/a&gt;（現在非推奨のReact Immutability Helpersアドオンのフォーク）のように、ネストされた値とヘルパー関数を使用しています。</target>
        </trans-unit>
        <trans-unit id="dda0bb30409a978c6095e977bd09a407e7ec0ccd" translate="yes" xml:space="preserve">
          <source>Our app reducer is still aware of all the different cases for our application. Let's try splitting things up so that the filter logic and the todo logic are separated:</source>
          <target state="translated">私たちのアプリの reducer は、私たちのアプリケーションのすべての異なるケースをまだ認識しています。フィルタロジックと TODO ロジックを分離するように分割してみましょう。</target>
        </trans-unit>
        <trans-unit id="57d76ff70a2b8d5f74ef5118abd52ad01b3bb657" translate="yes" xml:space="preserve">
          <source>Our design brief is simple. We want to show a list of todo items. On click, a todo item is crossed out as completed. We want to show a field where the user may add a new todo. In the footer, we want to show a toggle to show all, only completed, or only active todos.</source>
          <target state="translated">私たちのデザインの概要はシンプルです。TODO項目のリストを表示したいと思います。クリックすると、ToDo項目が完了したことになります。ユーザーが新しいToDoを追加できるフィールドを表示したい。フッターには、すべてのToDo、完了したToDoのみ、またはアクティブなToDoのみを表示するトグルを表示したいと思います。</target>
        </trans-unit>
        <trans-unit id="53d2ee76615e0933562a889f329ff05a0a727e4c" translate="yes" xml:space="preserve">
          <source>Overall, Redux-ORM provides a very useful set of abstractions for defining relations between data types, creating the &quot;tables&quot; in our state, retrieving and denormalizing relational data, and applying immutable updates to relational data.</source>
          <target state="translated">全体的に、Redux-ORMは、データ型間の関係を定義したり、私たちの状態で &quot;テーブル &quot;を作成したり、リレーショナルデータを取得して非正規化したり、リレーショナルデータに不変の更新を適用したりするための、非常に有用な抽象化のセットを提供しています。</target>
        </trans-unit>
        <trans-unit id="31d482d1d287457cca90cae82978407bee745dc3" translate="yes" xml:space="preserve">
          <source>PDF: JavaScript Immutability - Don&amp;rsquo;t go changing</source>
          <target state="translated">PDF：JavaScriptの不変性-変更しないでください</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="430ea9730cf326c3cf262aa3e00acbc94a6af33d" translate="yes" xml:space="preserve">
          <source>Passing the Store</source>
          <target state="translated">お店の合格点</target>
        </trans-unit>
        <trans-unit id="acae9ab8b8cf95f09e38c1fb61c7e7375972f22f" translate="yes" xml:space="preserve">
          <source>Patrons</source>
          <target state="translated">Patrons</target>
        </trans-unit>
        <trans-unit id="d9b870a4eca18252d7bd7d9da857129a2bd3ed18" translate="yes" xml:space="preserve">
          <source>Perform side effects like API calls and routing transitions;</source>
          <target state="translated">APIコールやルーティングトランジションのような副作用を実行します。</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="09c0613fe519089a7fc506820537146b438f0dc9" translate="yes" xml:space="preserve">
          <source>Pete Hunt, one of the early contributors to React, says:</source>
          <target state="translated">Reactの初期の貢献者の一人であるピート・ハント氏は言う。</target>
        </trans-unit>
        <trans-unit id="518776dd7f483eb0d4df7b1bd43c6cdb73104192" translate="yes" xml:space="preserve">
          <source>Poor Performance</source>
          <target state="translated">パフォーマンスの悪さ</target>
        </trans-unit>
        <trans-unit id="9993816052f22041086b70cb5e1a32b14dfbb33d" translate="yes" xml:space="preserve">
          <source>Practical Redux, Part 6: Connected Lists, Forms, and Performance</source>
          <target state="translated">実用的なRedux、パート6:接続されたリスト、フォーム、パフォーマンス</target>
        </trans-unit>
        <trans-unit id="738c6f9450a7465416076aa7cb2f7dbc8ca7bcb4" translate="yes" xml:space="preserve">
          <source>Preparing the Initial State</source>
          <target state="translated">初期状態の準備</target>
        </trans-unit>
        <trans-unit id="02510af1c9e56dc9bd70dc87dc84e81b435ad642" translate="yes" xml:space="preserve">
          <source>Prerequisite Concepts</source>
          <target state="translated">前提条件の概念</target>
        </trans-unit>
        <trans-unit id="69ac187c979012e887601c19566c66ee6ab15258" translate="yes" xml:space="preserve">
          <source>Prerequisite Concepts for Writing Reducers</source>
          <target state="translated">ライティングレデューサーの前提概念</target>
        </trans-unit>
        <trans-unit id="1c55cdda21f1ad5ea1b98437db0236145dd69099" translate="yes" xml:space="preserve">
          <source>Prerequisite Reducer Concepts</source>
          <target state="translated">前提条件 レッサーの概念</target>
        </trans-unit>
        <trans-unit id="b3ed0c728475ae7dfeea9ed4c1bc0af7c27941d6" translate="yes" xml:space="preserve">
          <source>Presentational Components</source>
          <target state="translated">提示成分</target>
        </trans-unit>
        <trans-unit id="69e7885b45c24e48f26b3abc065d13744594de0a" translate="yes" xml:space="preserve">
          <source>Presentational and Container Components</source>
          <target state="translated">プレゼンテーションとコンテナの構成要素</target>
        </trans-unit>
        <trans-unit id="f184d44b598b788adde29d493e92a5c25b0ed0b5" translate="yes" xml:space="preserve">
          <source>Prior Art</source>
          <target state="translated">先行芸術</target>
        </trans-unit>
        <trans-unit id="9cb3636454de25708139a72d5a8daebcbab292a1" translate="yes" xml:space="preserve">
          <source>Problem: Crash Reporting</source>
          <target state="translated">問題点:クラッシュの報告</target>
        </trans-unit>
        <trans-unit id="4367434447e2cee1f6e98eeb1e8d7bc393e9ff67" translate="yes" xml:space="preserve">
          <source>Problem: Logging</source>
          <target state="translated">問題:ロギング</target>
        </trans-unit>
        <trans-unit id="55ebe517b50c8c6c3d52435b9681b506cd9eed36" translate="yes" xml:space="preserve">
          <source>Processing Request Parameters</source>
          <target state="translated">処理要求パラメータ</target>
        </trans-unit>
        <trans-unit id="71d526269be49e8a2200a08466e2a7f151fbcce6" translate="yes" xml:space="preserve">
          <source>Pros and Cons of Using Immutability With React</source>
          <target state="translated">ReactでImmutabilityを使うことの長所と短所</target>
        </trans-unit>
        <trans-unit id="4be452a463fb3cf62c5a4a03fdd906246f9e80cd" translate="yes" xml:space="preserve">
          <source>Pros and Cons of Using Immutability with React</source>
          <target state="translated">Reactでイミュータブルを使うことの長所と短所</target>
        </trans-unit>
        <trans-unit id="dc98b8947b98b64aa54d5357f558ae0935c47d87" translate="yes" xml:space="preserve">
          <source>Pros and Cons of using immutability with React.js</source>
          <target state="translated">React.jsでイミュータブルを使うことの長所と短所</target>
        </trans-unit>
        <trans-unit id="d6e73fb000c8b75a17c1069b0079cbf4bdde15b6" translate="yes" xml:space="preserve">
          <source>Pros and Cons of using immutability with React.js - React Kung Fu</source>
          <target state="translated">React.jsでイミュータブルを使うことの長所と短所-React Kung Fu</target>
        </trans-unit>
        <trans-unit id="21cf88ab38b25368d2f9cb3c579e6a17bc644483" translate="yes" xml:space="preserve">
          <source>Pure Functions and Side Effects</source>
          <target state="translated">ピュアの機能と副作用</target>
        </trans-unit>
        <trans-unit id="86a07cd587b106a4018fbf8dbee2dbdcf791f1eb" translate="yes" xml:space="preserve">
          <source>Pure functionality and side effects in Redux</source>
          <target state="translated">Reduxの純粋な機能性と副作用</target>
        </trans-unit>
        <trans-unit id="82a325d136b15dd1db828b5e748b6d37453db386" translate="yes" xml:space="preserve">
          <source>Pure functions</source>
          <target state="translated">純粋な関数</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="ea644ff66049122da6969531a96ca0fe72184b08" translate="yes" xml:space="preserve">
          <source>Querying a Redux Store</source>
          <target state="translated">Redux ストアへの問い合わせ</target>
        </trans-unit>
        <trans-unit id="55075a14cfbfc51a035aba7e61a80df40309acdd" translate="yes" xml:space="preserve">
          <source>Rails-style: separate folders for &amp;ldquo;actions&amp;rdquo;, &amp;ldquo;constants&amp;rdquo;, &amp;ldquo;reducers&amp;rdquo;, &amp;ldquo;containers&amp;rdquo;, and &amp;ldquo;components&amp;rdquo;</source>
          <target state="translated">Railsスタイル：「アクション」、「定数」、「レデューサー」、「コンテナー」、および「コンポーネント」の個別のフォルダー</target>
        </trans-unit>
        <trans-unit id="45a38418ad120f3d535295f729a198b3b7c6c8d7" translate="yes" xml:space="preserve">
          <source>React Boilerplate #27: Application Structure</source>
          <target state="translated">Reactのボイラープレート#27。アプリケーションの構造</target>
        </trans-unit>
        <trans-unit id="efc78471488cf3d2e323b930c4ab2275310bd60b" translate="yes" xml:space="preserve">
          <source>React Forums: Redux and global state vs local state</source>
          <target state="translated">React フォーラム。Redux とグローバルステートとローカルステートの比較</target>
        </trans-unit>
        <trans-unit id="214641af7b84dcf096934eb2a695cb6d024aae3a" translate="yes" xml:space="preserve">
          <source>React Higher Order Components in depth</source>
          <target state="translated">React 高次コンポーネントの詳細</target>
        </trans-unit>
        <trans-unit id="01d8e1cb3dcc43b6aac331fa4ddc4ac02aff9465" translate="yes" xml:space="preserve">
          <source>React How-To</source>
          <target state="translated">リアクトハウツー</target>
        </trans-unit>
        <trans-unit id="c00f59a0285f84558e8d0d48133c22e6b6f706e6" translate="yes" xml:space="preserve">
          <source>React Redux</source>
          <target state="translated">React Redux</target>
        </trans-unit>
        <trans-unit id="e9ec3cce75743443bbba2142d270fc34d79b7599" translate="yes" xml:space="preserve">
          <source>React Redux #145: consider always passing down dispatch regardless of what mapDispatchToProps does</source>
          <target state="translated">React Redux #145:mapDispatchToPropsが何をするかに関わらず、常にディスパッチを渡すことを検討する</target>
        </trans-unit>
        <trans-unit id="732e7a5dfabaa54435e980f9e805a54c93e2dd29" translate="yes" xml:space="preserve">
          <source>React Redux #235: Predicate function for updating component</source>
          <target state="translated">React Redux #235。コンポーネントを更新するためのプレディケート関数</target>
        </trans-unit>
        <trans-unit id="01a98dba508a8efb62a16078cc6efb83597ba734" translate="yes" xml:space="preserve">
          <source>React Redux #255: this.props.dispatch is undefined if using mapDispatchToProps</source>
          <target state="translated">React Redux #255:mapDispatchToPropsを使用している場合、this.props.dispatchは未定義です。</target>
        </trans-unit>
        <trans-unit id="287e83661d0b0ace70aa4b2e7cbc6e6a0b50d186" translate="yes" xml:space="preserve">
          <source>React Redux #263: Huge performance issue when dispatching hundreds of actions</source>
          <target state="translated">React Redux #263:何百ものアクションをディスパッチするときに大きなパフォーマンスの問題が発生する</target>
        </trans-unit>
        <trans-unit id="2aea4e5f490054875b5d85d349369a3658b249ef" translate="yes" xml:space="preserve">
          <source>React Redux #269: Connect could be used with a custom subscribe method</source>
          <target state="translated">React Redux #269。Connect をカスタム subscribe メソッドで使用することができる</target>
        </trans-unit>
        <trans-unit id="bbdb52200c9c3640fa284dd7801b308c292acc73" translate="yes" xml:space="preserve">
          <source>React Redux #291: Should mapStateToProps be called every time an action is dispatched?</source>
          <target state="translated">React Redux #291:アクションがディスパッチされるたびに mapStateToProps を呼び出すべきか?</target>
        </trans-unit>
        <trans-unit id="ca17da9174a409f3ef37d08c9748a93925d108fc" translate="yes" xml:space="preserve">
          <source>React Redux #407: Rewrite connect to offer an advanced API</source>
          <target state="translated">React Redux #407:高度な API を提供するために connect を書き換える</target>
        </trans-unit>
        <trans-unit id="4e611799527e4e43143ed34634f793cd5a162cf1" translate="yes" xml:space="preserve">
          <source>React Redux #416: Rewrite connect for better performance and extensibility</source>
          <target state="translated">React Redux #416:パフォーマンスと拡張性を高めるためにコネクトを書き換える</target>
        </trans-unit>
        <trans-unit id="3f31b465a1a05e3ab0e22b96c59d09ee25c33ef2" translate="yes" xml:space="preserve">
          <source>React Redux #89: can i wrap multi actionCreators into one props with name?</source>
          <target state="translated">React Redux #89:複数のactionCreatorsを名前付きの1つの小道具にまとめることはできますか?</target>
        </trans-unit>
        <trans-unit id="fa04ceff7eca5e570aecaefd3ee71f236ce6eb9f" translate="yes" xml:space="preserve">
          <source>React Redux API: connect()</source>
          <target state="translated">React Redux API:connect()</target>
        </trans-unit>
        <trans-unit id="5fffe16c96023bbe3dd9abec1447678a45a147c0" translate="yes" xml:space="preserve">
          <source>React Redux implements several optimizations to ensure your actual component only re-renders when actually necessary. One of those is a shallow equality check on the combined props object generated by the &lt;code&gt;mapStateToProps&lt;/code&gt; and &lt;code&gt;mapDispatchToProps&lt;/code&gt; arguments passed to &lt;code&gt;connect&lt;/code&gt;. Unfortunately, shallow equality does not help in cases where new array or object instances are created each time &lt;code&gt;mapStateToProps&lt;/code&gt; is called. A typical example might be mapping over an array of IDs and returning the matching object references, such as:</source>
          <target state="translated">React Reduxはいくつかの最適化を実装して、実際のコンポーネントが実際に必要な場合にのみ再レンダリングされるようにします。それらの1つは、 &lt;code&gt;connect&lt;/code&gt; に渡された &lt;code&gt;mapStateToProps&lt;/code&gt; および &lt;code&gt;mapDispatchToProps&lt;/code&gt; 引数によって生成された、結合されたpropsオブジェクトに対する浅い等価チェックです。残念ながら、 &lt;code&gt;mapStateToProps&lt;/code&gt; が呼び出されるたびに新しい配列またはオブジェクトのインスタンスが作成される場合、浅い等価性は役に立ちません。典型的な例は、IDの配列をマッピングし、次のような一致するオブジェクト参照を返すことです。</target>
        </trans-unit>
        <trans-unit id="4b3923afd4f9b76fbadb161e5309fe47c5935c89" translate="yes" xml:space="preserve">
          <source>React Redux: Troubleshooting</source>
          <target state="translated">React Redux:トラブルシューティング</target>
        </trans-unit>
        <trans-unit id="7cf84f305d9b4ae3d2e5899504cef59f17174eb6" translate="yes" xml:space="preserve">
          <source>React Router comes with a &lt;a href=&quot;https://github.com/ReactTraining/react-router/blob/v3/docs/API.md#link&quot;&gt;&lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt;&lt;/a&gt; component that lets you navigate around your application. In our example, we can wrap &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; with a new container component &lt;code&gt;&amp;lt;FilterLink /&amp;gt;&lt;/code&gt; so as to dynamically change the URL. The &lt;code&gt;activeStyle={}&lt;/code&gt; property lets us apply a style on the active state.</source>
          <target state="translated">React Routerには、アプリケーション内を移動できる&lt;a href=&quot;https://github.com/ReactTraining/react-router/blob/v3/docs/API.md#link&quot;&gt; &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; &lt;/a&gt;コンポーネントが付属しています。この例では、URLを動的に変更するために、新しいコンテナコンポーネント &lt;code&gt;&amp;lt;FilterLink /&amp;gt;&lt;/code&gt; で &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; をラップできます。 &lt;code&gt;activeStyle={}&lt;/code&gt; プロパティは、私たちがアクティブ状態にスタイルを適用することができます。</target>
        </trans-unit>
        <trans-unit id="679ef62ec4985a413831aad6d5f132c1e1b0074f" translate="yes" xml:space="preserve">
          <source>React bindings for Redux embrace the idea of &lt;strong&gt;separating presentational and container components&lt;/strong&gt;. If you're not familiar with these terms, &lt;a href=&quot;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0&quot;&gt;read about them first&lt;/a&gt;, and then come back. They are important, so we'll wait!</source>
          <target state="translated">ReduxのReactバインディングは、&lt;strong&gt;プレゼンテーションコンポーネントとコンテナコンポーネント&lt;/strong&gt;を&lt;strong&gt;分離&lt;/strong&gt;するという考え方を採用して&lt;strong&gt;います&lt;/strong&gt;。これらの用語に慣れていない場合は、&lt;a href=&quot;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0&quot;&gt;まずそれらを読んで&lt;/a&gt;から、戻ってください。重要なので、お待ちしております！</target>
        </trans-unit>
        <trans-unit id="cd703ea889752160be52204476a7e5217587c640" translate="yes" xml:space="preserve">
          <source>React-Redux Bindings</source>
          <target state="translated">React-Redux のバインディング</target>
        </trans-unit>
        <trans-unit id="720534ae4ea5a2a18f4bb7bfe9ed16ef3bef02de" translate="yes" xml:space="preserve">
          <source>React-Redux performs a shallow equality check on on each &lt;em&gt;value&lt;/em&gt; within the props object, not on the props object itself.</source>
          <target state="translated">React-Reduxは、propsオブジェクト自体ではなく、propsオブジェクト内の各&lt;em&gt;値&lt;/em&gt;に対して浅い等価チェックを実行します。</target>
        </trans-unit>
        <trans-unit id="9a3b307a7afe13dcc2d2b56d385f6e7fcdd89e12" translate="yes" xml:space="preserve">
          <source>React-Redux therefore maintains separate references to each &lt;em&gt;value&lt;/em&gt; in the returned props object.</source>
          <target state="translated">したがって、React-Redux は、返されたpropsオブジェクトの各&lt;em&gt;値&lt;/em&gt;への個別の参照を維持します。</target>
        </trans-unit>
        <trans-unit id="a84961e51f0e9045534f55ef19c9b890ec0454dc" translate="yes" xml:space="preserve">
          <source>React-Redux uses shallow equality checking to determine whether the component it&amp;rsquo;s wrapping needs to be re-rendered.</source>
          <target state="translated">React-Reduxは浅い等価性チェックを使用して、ラップしているコンポーネントを再レンダリングする必要があるかどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="25f69fafc4d53ef37a01d27855717f1b910c32ee" translate="yes" xml:space="preserve">
          <source>React-Redux's &lt;code&gt;connect&lt;/code&gt; method generates components that &lt;a href=&quot;#how-react-redux-uses-shallow-checking&quot;&gt;shallowly check reference changes to the root state&lt;/a&gt;, and the return values from the &lt;code&gt;mapStateToProps&lt;/code&gt; function to see if the wrapped components actually need to re-render. Such &lt;a href=&quot;#redux-shallow-checking-requires-immutability&quot;&gt;shallow checking requires immutability&lt;/a&gt; to function correctly.</source>
          <target state="translated">React-Reduxの &lt;code&gt;connect&lt;/code&gt; メソッドは&lt;a href=&quot;#how-react-redux-uses-shallow-checking&quot;&gt;、ルート状態への参照の変更を浅くチェック&lt;/a&gt;するコンポーネントと、 &lt;code&gt;mapStateToProps&lt;/code&gt; 関数からの戻り値をチェックして、ラップされたコンポーネントが実際に再レンダリングする必要があるかどうかを確認します。このような&lt;a href=&quot;#redux-shallow-checking-requires-immutability&quot;&gt;浅いチェックでは、&lt;/a&gt;正しく機能するために不変性が必要です。</target>
        </trans-unit>
        <trans-unit id="7f4f4a56fd030dcfc889dad10f3ba7abdeb9bf09" translate="yes" xml:space="preserve">
          <source>React.js Pure Render Performance Anti-Pattern</source>
          <target state="translated">React.js Pure Render パフォーマンスアンチパターン</target>
        </trans-unit>
        <trans-unit id="efcf558b2b7ed1ce931d4bbaf10d10e4a81b9190" translate="yes" xml:space="preserve">
          <source>React.js pure render performance anti-pattern</source>
          <target state="translated">React.jsの純粋なレンダリングパフォーマンスのアンチパターン</target>
        </trans-unit>
        <trans-unit id="a6c84930df2d0caae45068e630cc45ccf1245b86" translate="yes" xml:space="preserve">
          <source>React/Redux Links: &quot;Redux Side Effects&quot; category</source>
          <target state="translated">React/Reduxのリンク集です。&quot;Reduxの副作用 &quot;カテゴリ</target>
        </trans-unit>
        <trans-unit id="e7b97ce28bebc20ce4023d4d1544d8ca708ac055" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Architecture - Project File Structure</source>
          <target state="translated">React/Reduxのリンク集です。アーキテクチャ-プロジェクトファイル構造</target>
        </trans-unit>
        <trans-unit id="799adc6d5d994e504c2c138e4ff53248644d5147" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Architecture - Redux Architecture</source>
          <target state="translated">React/Reduxのリンク集。アーキテクチャ-Redux アーキテクチャ</target>
        </trans-unit>
        <trans-unit id="f700891537e9332e39007ef543a0c7005ac696ee" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Immutable Data</source>
          <target state="translated">React/Reduxのリンク集です。不変データ</target>
        </trans-unit>
        <trans-unit id="fce00908db372392230a5dc59966f0556c9a96b3" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Performance - Redux</source>
          <target state="translated">React/Reduxのリンク集です。パフォーマンス-Redux</target>
        </trans-unit>
        <trans-unit id="ea6624400dd0619a4028a0782161b341f95b9bf3" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Performance - Redux Performance</source>
          <target state="translated">React/Reduxのリンク集です。パフォーマンス-Redux パフォーマンス</target>
        </trans-unit>
        <trans-unit id="11abaa387b4e1d4c6df486f331bca1593b96648d" translate="yes" xml:space="preserve">
          <source>React/Redux Links: React/Redux Performance</source>
          <target state="translated">React/Reduxのリンク集です。React/Redux のパフォーマンス</target>
        </trans-unit>
        <trans-unit id="86308254ca58c32a4b48e2e7a927c0057319908d" translate="yes" xml:space="preserve">
          <source>React: Higher-Order Components</source>
          <target state="translated">React:高次のコンポーネント</target>
        </trans-unit>
        <trans-unit id="2d90bde2bec2c8fa094a1d2200ae82033494cad5" translate="yes" xml:space="preserve">
          <source>React: Optimizing Performance</source>
          <target state="translated">React.React.React.React.React.React.React.React.React.React.React.React.React.React.React.React.React.パフォーマンスの最適化</target>
        </trans-unit>
        <trans-unit id="7d9c1b09aeb1d155202a538eba6d9a3492931ad1" translate="yes" xml:space="preserve">
          <source>Read &lt;a href=&quot;asyncflow&quot;&gt;Async Flow&lt;/a&gt; to recap how async actions fit into the Redux flow.</source>
          <target state="translated">&lt;a href=&quot;asyncflow&quot;&gt;非同期フロー&lt;/a&gt;を読んで、非同期アクションがReduxフローにどのように適合するかを要約します。</target>
        </trans-unit>
        <trans-unit id="b607ca1ed943113b8bd40acd28ee479c753558db" translate="yes" xml:space="preserve">
          <source>Read data from props</source>
          <target state="translated">小道具からデータを読み取る</target>
        </trans-unit>
        <trans-unit id="99172ffcab6825648dfba7e3fc262a9a5fbe7648" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;exampletodolist&quot;&gt;complete source code for this tutorial&lt;/a&gt; to better internalize the knowledge you have gained. Then, head straight to the &lt;a href=&quot;../advanced/index&quot;&gt;advanced tutorial&lt;/a&gt; to learn how to handle network requests and routing!</source>
          <target state="translated">&lt;a href=&quot;exampletodolist&quot;&gt;このチュートリアルの完全なソースコードを&lt;/a&gt;読んで、得た知識をよりよく内部化してください。次に、&lt;a href=&quot;../advanced/index&quot;&gt;高度なチュートリアル&lt;/a&gt;に進んで、ネットワーク要求とルーティングの処理方法を学びます。</target>
        </trans-unit>
        <trans-unit id="b21e1ed4d5217309315f564ff74b9eea1936e93c" translate="yes" xml:space="preserve">
          <source>Reading From the URL</source>
          <target state="translated">URLからの読み込み</target>
        </trans-unit>
        <trans-unit id="095c451a2e9ce2021d38bf795774b05403fc75f1" translate="yes" xml:space="preserve">
          <source>Real World</source>
          <target state="translated">現実世界</target>
        </trans-unit>
        <trans-unit id="a49698c20a1d19a475a3edf8be8f8f8b30ec65ca" translate="yes" xml:space="preserve">
          <source>Recap</source>
          <target state="translated">Recap</target>
        </trans-unit>
        <trans-unit id="9fb1092f32d4fcbf9e061ffd718d4ec689c6c95e" translate="yes" xml:space="preserve">
          <source>Recipes</source>
          <target state="translated">Recipes</target>
        </trans-unit>
        <trans-unit id="42624a20e6e4c1562537410bf82ff591ce07f160" translate="yes" xml:space="preserve">
          <source>Recipes: Computed Derived Data</source>
          <target state="translated">レシピ 計算された派生データ</target>
        </trans-unit>
        <trans-unit id="b6d39d52a5e86324ade1d44e7e08ce0b5387e017" translate="yes" xml:space="preserve">
          <source>Recipes: Computing Derived Data</source>
          <target state="translated">レシピ 派生データの計算</target>
        </trans-unit>
        <trans-unit id="5effb0f63ab3eb21c89f18e6368e7c1d5f17c3ac" translate="yes" xml:space="preserve">
          <source>Recipes: Immutable Update Patterns</source>
          <target state="translated">レシピ。不変の更新パターン</target>
        </trans-unit>
        <trans-unit id="cbeb9b0f5422b15a6d088c47aaf6e528d0350c4c" translate="yes" xml:space="preserve">
          <source>Recipes: Prerequisite Reducer Concepts</source>
          <target state="translated">レシピ。前提条件のレデューサーの概念</target>
        </trans-unit>
        <trans-unit id="49a1f34779a5afe85e05cff662577501366300bb" translate="yes" xml:space="preserve">
          <source>Recipes: Reducing Boilerplate</source>
          <target state="translated">レシピ。ボイラープレートを減らす</target>
        </trans-unit>
        <trans-unit id="8c1f469e59e4322a9cb07ef58ade84919608d01c" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers</source>
          <target state="translated">レシピ。レデューサーの構造化</target>
        </trans-unit>
        <trans-unit id="29196f40d836acaf77c762f6f7580bf65b85cab3" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Immutable Update Patterns</source>
          <target state="translated">レシピ。構造化された減速機-不変の更新パターン</target>
        </trans-unit>
        <trans-unit id="cb76eaeb79f5b86547d0360e4948f5f88d59b72d" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Normalizing State Shape</source>
          <target state="translated">レシピ。レデューサーの構造化-状態の形状の正規化</target>
        </trans-unit>
        <trans-unit id="e9e51b9812b2e58af4823344e551de6481db8b1b" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Prerequisite Concepts</source>
          <target state="translated">レシピ。レデューサーの構造化-前提条件の概念</target>
        </trans-unit>
        <trans-unit id="d8db7ccea3429c3219a46b29a7fb105658ffffce" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Splitting Reducer Logic</source>
          <target state="translated">レシピ。レジューサーの構造化-レジューサーロジックの分割</target>
        </trans-unit>
        <trans-unit id="e29b3bc65e2933e5a918d6357b2967374e89998f" translate="yes" xml:space="preserve">
          <source>Recipes: Using the Object Spread Operator</source>
          <target state="translated">レシピ オブジェクト拡散演算子の使用</target>
        </trans-unit>
        <trans-unit id="3b66d7a1f117e84d49ce190a144bfa4013537819" translate="yes" xml:space="preserve">
          <source>Recipes: immutability, side effects and mutation</source>
          <target state="translated">レシピ:不変性・副作用・突然変異</target>
        </trans-unit>
        <trans-unit id="f0284a396b98e7ed88f256c52e6515c77bb1b45d" translate="yes" xml:space="preserve">
          <source>Reddit: &quot;When should I put something into my Redux store?&quot;</source>
          <target state="translated">Redditのこと。&quot;Reduxストアに何かを入れるタイミングは?&quot;</target>
        </trans-unit>
        <trans-unit id="daca44adc4ef60f42583641246276d004e688c4b" translate="yes" xml:space="preserve">
          <source>Reddit: Help designing Redux state for a single page app</source>
          <target state="translated">Reddit.単一ページのアプリのためのReduxの状態を設計するためのヘルプ</target>
        </trans-unit>
        <trans-unit id="afe887e317c898f703e24f7d827235e7f21d4918" translate="yes" xml:space="preserve">
          <source>Reddit: Help performing Async API calls with Redux-Promise Middleware.</source>
          <target state="translated">Reddit.Redux-Promise ミドルウェアでの Async API 呼び出しの実行を支援します。</target>
        </trans-unit>
        <trans-unit id="15ccb05f9d496bf9727d87cee8b1f71f8bdbfba0" translate="yes" xml:space="preserve">
          <source>Reddit: Large open source react/redux projects?</source>
          <target state="translated">Reddit.大規模なオープンソースの react/redux プロジェクト?</target>
        </trans-unit>
        <trans-unit id="31b5fcaedfa00391f0da82305fa9d9c465e145ba" translate="yes" xml:space="preserve">
          <source>Reddit: React/Redux for Ultra Large Scale apps</source>
          <target state="translated">Reddit.超大規模アプリのためのReact/Redux</target>
        </trans-unit>
        <trans-unit id="dc41eb745ff0afdeef230ca621cfd49d330d77d6" translate="yes" xml:space="preserve">
          <source>Reddit: Redux performance issues with a large state object?</source>
          <target state="translated">Reddit.大きなステートオブジェクトでReduxのパフォーマンスの問題?</target>
        </trans-unit>
        <trans-unit id="ad1dcdbc206f62d81049e1fbbc24d1b99f39b065" translate="yes" xml:space="preserve">
          <source>Reddit: What's the best place to keep initial state?</source>
          <target state="translated">Reddit(レッドディット)。初期状態を保つのに最適な場所とは?</target>
        </trans-unit>
        <trans-unit id="216d6244581ce722d2b213f82dbff87a6148139c" translate="yes" xml:space="preserve">
          <source>Reddit: What's the best place to keep the initial state?</source>
          <target state="translated">Reddit(レッドディット)です。初期状態を維持するのに最適な場所は?</target>
        </trans-unit>
        <trans-unit id="6473c3e5bd0f3e386d368c764bc6cec02354577e" translate="yes" xml:space="preserve">
          <source>Reddit: Why Redux Needs Reducers To Be Pure Functions</source>
          <target state="translated">Reddit.Reduxが純粋な関数であるために減速機が必要な理由</target>
        </trans-unit>
        <trans-unit id="05ce1169a192ae766ca0f1d7c50a759c7c51974e" translate="yes" xml:space="preserve">
          <source>Reddit: You don't need Redux if your app just fetches something on a single page</source>
          <target state="translated">Reddit.アプリが単一ページで何かを取得するだけならReduxは必要ありません。</target>
        </trans-unit>
        <trans-unit id="cffbc53fcadf1ea0dddef2d232230038efb6dd3c" translate="yes" xml:space="preserve">
          <source>Reddit: acemarke and cpsubrian comments on Dan Abramov: Redux is not an architecture or design pattern, it is just a library.</source>
          <target state="translated">Reddit:acemarkeさんとcpsubrianさんがDan Abramovさんにコメントしています。Reduxはアーキテクチャやデザインパターンではなく、ただのライブラリです。</target>
        </trans-unit>
        <trans-unit id="59ce6f6beebd57025f07ecd7d9c06fc4781ffca1" translate="yes" xml:space="preserve">
          <source>Reducer</source>
          <target state="translated">Reducer</target>
        </trans-unit>
        <trans-unit id="1b526057cc1ef5812f4ada08c7de94063561f436" translate="yes" xml:space="preserve">
          <source>Reducer Concepts and Techniques</source>
          <target state="translated">レジューサーの概念と技術</target>
        </trans-unit>
        <trans-unit id="dda31a027bfa36f4ca8585837d08aaa1912d41bf" translate="yes" xml:space="preserve">
          <source>Reducers</source>
          <target state="translated">Reducers</target>
        </trans-unit>
        <trans-unit id="840f7767cb01214ba0a12025998a85422ab6e283" translate="yes" xml:space="preserve">
          <source>Reducers are just pure functions that take the previous state and an action, and return the next state. Remember to return new state objects, instead of mutating the previous state. You can start with a single reducer, and as your app grows, split it off into smaller reducers that manage specific parts of the state tree. Because reducers are just functions, you can control the order in which they are called, pass additional data, or even make reusable reducers for common tasks such as pagination.</source>
          <target state="translated">レデューサーは、前の状態とアクションを取り、次の状態を返す純粋な関数です。前の状態を突然変異させるのではなく、新しい状態オブジェクトを返すことを覚えておいてください。アプリが成長するにつれて、状態ツリーの特定の部分を管理する小さなレデューサに分割することができます。レデューサは単なる関数なので、呼び出される順序を制御したり、追加のデータを渡したり、ページネーションなどの一般的なタスクのために再利用可能なレデューサを作成することもできます。</target>
        </trans-unit>
        <trans-unit id="96a29cc7551675123cb7f5294dd805e57df90ca1" translate="yes" xml:space="preserve">
          <source>Reducers are not unique to Redux&amp;mdash;they are a fundamental concept in functional programming. Even most non-functional languages, like JavaScript, have a built-in API for reducing. In JavaScript, it's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array.prototype.reduce()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">レデューサーはReduxに固有のものではなく、関数型プログラミングの基本的な概念です。JavaScriptのようなほとんどの非関数型言語でさえ、削減のための組み込みAPIがあります。JavaScriptでは、それは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt; &lt;code&gt;Array.prototype.reduce()&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="693d4ec3dd35d12c94a5cb25d408b2e71be3d5b1" translate="yes" xml:space="preserve">
          <source>Reducers are the most important concept in Redux.</source>
          <target state="translated">レデューサーはReduxで最も重要な概念です。</target>
        </trans-unit>
        <trans-unit id="493c42af719ab1cd4cc31be798bcf7e6648293eb" translate="yes" xml:space="preserve">
          <source>Reducing Boilerplate</source>
          <target state="translated">ボイラープレートの削減</target>
        </trans-unit>
        <trans-unit id="1a5dd83d686967dbee491e598c66e203e42c8bea" translate="yes" xml:space="preserve">
          <source>Redux</source>
          <target state="translated">Redux</target>
        </trans-unit>
        <trans-unit id="ec290bd2917cc3416af368d34f3c085a675f09e6" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Component State</source>
          <target state="translated">Redux アドオンカタログ。コンポーネントの状態</target>
        </trans-unit>
        <trans-unit id="8290cc030aab4b8babf95fab40608d602458690f" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: DevTools - Component Update Monitoring</source>
          <target state="translated">Redux アドオンカタログ。DevTools-コンポーネント更新の監視</target>
        </trans-unit>
        <trans-unit id="f07485fcebaac4a393292df3922516fc30d4bbca" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Store - Change Subscriptions</source>
          <target state="translated">Reduxアドオンカタログ。ストア-サブスクリプションの変更</target>
        </trans-unit>
        <trans-unit id="a577b901e78ea650452597a6b1059b8084d2ebcb" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Store Change Subscriptions</source>
          <target state="translated">Redux アドオンカタログ。ストア変更サブスクリプション</target>
        </trans-unit>
        <trans-unit id="a6d683688573717dedb09bb8c524dd092308d6bd" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Use Cases - Authentication</source>
          <target state="translated">Redux アドオンカタログ。使用例-認証</target>
        </trans-unit>
        <trans-unit id="9344d1305fa4b38f64ad8cebd9635fa2921b0e1a" translate="yes" xml:space="preserve">
          <source>Redux Best Practices</source>
          <target state="translated">Reduxのベストプラクティス</target>
        </trans-unit>
        <trans-unit id="bfac34990e02b9e66cd0d6829d754be59da6a26f" translate="yes" xml:space="preserve">
          <source>Redux Docs: &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">Redux Docs： &lt;code&gt;combineReducers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="114c170f090803b3e9b2bcc5c3a6e50beaeed134" translate="yes" xml:space="preserve">
          <source>Redux Docs: Implementing Undo History</source>
          <target state="translated">Redux Docs.Undo履歴の実装</target>
        </trans-unit>
        <trans-unit id="9e6cb1adf2efb90cb6a27ea6a72f98f7ab473f85" translate="yes" xml:space="preserve">
          <source>Redux Docs: Reducers</source>
          <target state="translated">Redux Docs.レジューサー</target>
        </trans-unit>
        <trans-unit id="9d40a9cd844cea91b94b47ac94fa5330e9011c46" translate="yes" xml:space="preserve">
          <source>Redux Docs: Reducing Boilerplate</source>
          <target state="translated">Redux Docs.ボイラープレートの削減</target>
        </trans-unit>
        <trans-unit id="726708480591ce54144dc3645deedfceb6e02a27" translate="yes" xml:space="preserve">
          <source>Redux Docs: Using the Object Spread Operator</source>
          <target state="translated">Redux Docs.オブジェクト拡散演算子の使用</target>
        </trans-unit>
        <trans-unit id="43b86674da50a6ae9dfb143b4ed6cba4221221fc" translate="yes" xml:space="preserve">
          <source>Redux Egghead Course Notes</source>
          <target state="translated">Redux Eggheadのコースノート</target>
        </trans-unit>
        <trans-unit id="4428f96db39ca62c1587ebeaa693e35a74b127e5" translate="yes" xml:space="preserve">
          <source>Redux FAQ</source>
          <target state="translated">Redux FAQ</target>
        </trans-unit>
        <trans-unit id="d41715c0d155a118b9497d660d8d8ce21d26b4a2" translate="yes" xml:space="preserve">
          <source>Redux FAQ - How do I share state between two reducers? do I have to use &lt;code&gt;combineReducers&lt;/code&gt;?</source>
          <target state="translated">Redux FAQ-2つのレデューサー間で状態を共有するにはどうすればよいですか？ &lt;code&gt;combineReducers&lt;/code&gt; を使用する必要がありますか？</target>
        </trans-unit>
        <trans-unit id="c491bee4fced1d7081108b5ad804a138bbbbd52e" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Actions</source>
          <target state="translated">Redux FAQ:アクション</target>
        </trans-unit>
        <trans-unit id="d4e401fc452061ae23c6d3ded639c0139571e70a" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Code Structure</source>
          <target state="translated">Redux FAQ:構造コード</target>
        </trans-unit>
        <trans-unit id="b9dd7213b027596f3629ad531290ad9920e77526" translate="yes" xml:space="preserve">
          <source>Redux FAQ: General</source>
          <target state="translated">Redux FAQ.一般的な</target>
        </trans-unit>
        <trans-unit id="0d53c1155526d25e48dcd19338cae9548715d564" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Immutable Data</source>
          <target state="translated">Redux FAQ:不変データ</target>
        </trans-unit>
        <trans-unit id="af79a6a6e3a5246c79d316570a87b7cf700c435e" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Miscellaneous</source>
          <target state="translated">Redux FAQ.その他</target>
        </trans-unit>
        <trans-unit id="ac2ba19db266451829b5648e7675c23413cb2290" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Organizing State</source>
          <target state="translated">Redux FAQ.状態の整理</target>
        </trans-unit>
        <trans-unit id="b775beb138a1c3fb7195b5b0df10ccb6b82fa87d" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Performance</source>
          <target state="translated">Redux FAQ:パフォーマンス</target>
        </trans-unit>
        <trans-unit id="a5b614caad88c44f368607bba25481b521bd85c6" translate="yes" xml:space="preserve">
          <source>Redux FAQ: React Redux</source>
          <target state="translated">Redux FAQ.React Redux</target>
        </trans-unit>
        <trans-unit id="ef49df474a3cc851a7439d8e67a8e396e5ccf5d5" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Reducers</source>
          <target state="translated">Redux FAQ.レジューサー</target>
        </trans-unit>
        <trans-unit id="24a41d53bd26e4da6f09186f3361b234ecd45560" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Store Setup</source>
          <target state="translated">Redux FAQ.ストアの設定</target>
        </trans-unit>
        <trans-unit id="0102181826c0cb7d859681534988eee33484e834" translate="yes" xml:space="preserve">
          <source>Redux Patterns and Anti-Patterns</source>
          <target state="translated">Reduxパターンとアンチパターン</target>
        </trans-unit>
        <trans-unit id="e73b59699c981c999e9ca3504f30fe27527addd7" translate="yes" xml:space="preserve">
          <source>Redux Reducer Basics</source>
          <target state="translated">Redux レジューサーの基本</target>
        </trans-unit>
        <trans-unit id="56891cb67a23a2b058baaee611e9e76e2ced8ffb" translate="yes" xml:space="preserve">
          <source>Redux Reducer/Selector Asymmetry</source>
          <target state="translated">Redux レデューサ/セレクタの非対称性</target>
        </trans-unit>
        <trans-unit id="d7f6bdcedeb4f02ba8baec4a6f623462b01e41d1" translate="yes" xml:space="preserve">
          <source>Redux Side-Effects and You</source>
          <target state="translated">Reduxのサイドエフェクトとあなた</target>
        </trans-unit>
        <trans-unit id="ec9ae2589e9681b8d5b9a2330255a41898aa3398" translate="yes" xml:space="preserve">
          <source>Redux Tutorial</source>
          <target state="translated">Reduxチュートリアル</target>
        </trans-unit>
        <trans-unit id="d6c0eff7c8b338ccc1a25decaa770c2ce1222c1c" translate="yes" xml:space="preserve">
          <source>Redux Without Profanity: Normalizr</source>
          <target state="translated">冒涜のないRedux。ノーマライズ</target>
        </trans-unit>
        <trans-unit id="37f4f3e1befc5ff99eacec66375e5105a07bde1d" translate="yes" xml:space="preserve">
          <source>Redux architecture revolves around a &lt;strong&gt;strict unidirectional data flow&lt;/strong&gt;.</source>
          <target state="translated">Reduxアーキテクチャは、&lt;strong&gt;厳密な一方向のデータフロー&lt;/strong&gt;を中心に展開し&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="ca8fd39e0f583c4771e3b7ab47147f9b7250d1ac" translate="yes" xml:space="preserve">
          <source>Redux assumes that you never mutate the objects it gives to you in the reducer. &lt;strong&gt;Every single time, you must return the new state object.&lt;/strong&gt; Even if you don't use a library like &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt;, you need to completely avoid mutation.</source>
          <target state="translated">Reduxは、レデューサーで提供されるオブジェクトを変更しないことを前提としています。&lt;strong&gt;毎回、新しい状態オブジェクトを返す必要があります。&lt;/strong&gt;&lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutableの&lt;/a&gt;ようなライブラリを使用しない場合でも、完全に変異を回避する必要があります。</target>
        </trans-unit>
        <trans-unit id="d9b13f4fc65014317fe6e4b9892befedf11af3bc" translate="yes" xml:space="preserve">
          <source>Redux can be described in three fundamental principles:</source>
          <target state="translated">Reduxは3つの基本原則で説明することができます。</target>
        </trans-unit>
        <trans-unit id="325d0a3329fe90a45278bb0a0417bd084002d235" translate="yes" xml:space="preserve">
          <source>Redux can be used as a data store for any UI layer. The most common usage is with React and React Native, but there are bindings available for Angular, Angular 2, Vue, Mithril, and more. Redux simply provides a subscription mechanism which can be used by any other code. That said, it is most useful when combined with a declarative view implementation that can infer the UI updates from the state changes, such as React or one of the similar libraries available.</source>
          <target state="translated">Reduxは、あらゆるUIレイヤーのデータストアとして使用できます。最も一般的な使用法はReactとReact Nativeですが、Angular、Angular 2、Vue、Mithrilなどで利用できるバインディングもあります。Reduxは単純にサブスクリプションの仕組みを提供しているだけで、他のコードでも利用できるようになっています。つまり、状態変化からUIの更新を推論できる宣言的なビューの実装と組み合わせることで、Reactや利用可能な類似のライブラリの1つと組み合わせると最も便利です。</target>
        </trans-unit>
        <trans-unit id="b52d3f31e7f26a9796dbdf1e3a68c3e4fb5e3992" translate="yes" xml:space="preserve">
          <source>Redux does not store a history of actions itself. However, the Redux DevTools do store actions so they can be replayed, but those are generally only enabled during development, and not used in production.</source>
          <target state="translated">Reduxはアクションの履歴を保存しません。しかし、Redux DevToolsはアクションを保存して再生できるようにしますが、一般的には開発中のみ有効で、本番では使用されません。</target>
        </trans-unit>
        <trans-unit id="5dbbf7352cc48a4f94b3a8d8faa33290b580cd67" translate="yes" xml:space="preserve">
          <source>Redux encourages you to think about your application in terms of the data you need to manage. The data at any given point in time is the &quot;&lt;em&gt;state&lt;/em&gt;&quot; of your application, and the structure and organization of that state is typically referred to as its &quot;&lt;em&gt;shape&lt;/em&gt;&quot;. The shape of your state plays a major role in how you structure your reducer logic.</source>
          <target state="translated">Reduxは、管理する必要があるデータの観点からアプリケーションについて考えることをお勧めします。任意の時点でのデータはアプリケーションの「&lt;em&gt;状態&lt;/em&gt;」であり、その状態の構造と編成は通常、その「&lt;em&gt;形状&lt;/em&gt;」と呼ばれます。状態の形状は、レデューサーロジックをどのように構成するかで重要な役割を果たします。</target>
        </trans-unit>
        <trans-unit id="0516f1b49c0332831cef6d046aead301f5a49142" translate="yes" xml:space="preserve">
          <source>Redux evolves the ideas of &lt;a href=&quot;http://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt;, but avoids its complexity by taking cues from &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm&lt;/a&gt;.</source>
          <target state="translated">Reduxは&lt;a href=&quot;http://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt;のアイデアを進化させましたが、&lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm&lt;/a&gt;からヒントを得ることでその複雑さを回避しています。</target>
        </trans-unit>
        <trans-unit id="e3d9d039526eff2bcbbc1e2bb2c6ef489f1116bd" translate="yes" xml:space="preserve">
          <source>Redux has a mixed heritage. It is similar to some patterns and technologies, but is also different from them in important ways. We'll explore some of the similarities and the differences below.</source>
          <target state="translated">Reduxには混在した遺産があります。いくつかのパターンや技術に似ていますが、重要な点ではそれらとは異なっています。以下では、いくつかの類似点と相違点を探っていきます。</target>
        </trans-unit>
        <trans-unit id="08c2c8d16a217b7f149595bcdd911d990cf837d5" translate="yes" xml:space="preserve">
          <source>Redux is a predictable state container for JavaScript apps.</source>
          <target state="translated">ReduxはJavaScriptアプリのための予測可能な状態コンテナです。</target>
        </trans-unit>
        <trans-unit id="1658730b992fc25b0e570963398f980bbbac8597" translate="yes" xml:space="preserve">
          <source>Redux is a tiny library, but its contracts and APIs are carefully chosen to spawn an ecosystem of tools and extensions.</source>
          <target state="translated">Redux は小さなライブラリですが、その契約と API は、ツールや拡張機能のエコシステムを生み出すために慎重に選ばれています。</target>
        </trans-unit>
        <trans-unit id="d0def49afc1d69e709f05c3918091a08540604e3" translate="yes" xml:space="preserve">
          <source>Redux is distributed with a few examples in its &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples&quot;&gt;source code&lt;/a&gt;. Most of these examples are also on &lt;a href=&quot;https://codesandbox.io&quot;&gt;CodeSandbox&lt;/a&gt;, this is an online editor that lets you play with the examples online.</source>
          <target state="translated">Reduxの&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples&quot;&gt;ソースコードに&lt;/a&gt;はいくつかの例が含まれています。これらの例のほとんどは&lt;a href=&quot;https://codesandbox.io&quot;&gt;CodeSandbox&lt;/a&gt;にもあります。これは例をオンラインで再生できるオンラインエディターです。</target>
        </trans-unit>
        <trans-unit id="2bc1ca81429d291e4da182d33067adbc2146a5ff" translate="yes" xml:space="preserve">
          <source>Redux is in part &lt;a href=&quot;../introduction/priorart&quot;&gt;inspired by Flux&lt;/a&gt;, and the most common complaint about Flux is how it makes you write a lot of boilerplate. In this recipe, we will consider how Redux lets us choose how verbose we'd like our code to be, depending on personal style, team preferences, longer term maintainability, and so on.</source>
          <target state="translated">Reduxの一部は&lt;a href=&quot;../introduction/priorart&quot;&gt;Flux&lt;/a&gt;に触発されており、Fluxに関する最も一般的な不満は、多くのボイラープレートを作成する方法です。このレシピでは、個人的なスタイル、チームの好み、長期的な保守性などに応じて、Reduxがコードの冗長度をどのように選択できるかを検討します。</target>
        </trans-unit>
        <trans-unit id="8ca9a51778106939cd3dfebf9551abdc4b16988e" translate="yes" xml:space="preserve">
          <source>Redux is inspired by functional programming, and out of the box, has no place for side effects to be executed. In particular, reducer functions &lt;em&gt;must&lt;/em&gt; always be pure functions of &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt;. However, Redux's middleware makes it possible to intercept dispatched actions and add additional complex behavior around them, including side effects.</source>
          <target state="translated">Reduxは関数型プログラミングに触発されており、そのままでは副作用を実行する場所がありません。特に、レデューサー関数&lt;em&gt;は&lt;/em&gt;常に &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt; 純粋関数で&lt;em&gt;なければなりません&lt;/em&gt;。ただし、Reduxのミドルウェアを使用すると、ディスパッチされたアクションをインターセプトし、副作用などのアクションの周りに複雑な動作を追加できます。</target>
        </trans-unit>
        <trans-unit id="2e51cf296aaae20f776d432b753a50cb2d012fba" translate="yes" xml:space="preserve">
          <source>Redux is not a monolithic framework, but a set of contracts and a &lt;a href=&quot;../api/index&quot;&gt;few functions that make them work together&lt;/a&gt;. The majority of your &amp;ldquo;Redux code&amp;rdquo; will not even use Redux APIs, as most of the time you'll be writing functions.</source>
          <target state="translated">Reduxはモノリシックフレームワークではありませんが、一連のコントラクトと&lt;a href=&quot;../api/index&quot;&gt;それらを連携させるいくつかの関数です&lt;/a&gt;。ほとんどの場合、関数を作成するため、「Reduxコード」の大部分はRedux APIさえ使用しません。</target>
        </trans-unit>
        <trans-unit id="5fa50b0cdd3b8374bae86ce4f34e3e66331618ca" translate="yes" xml:space="preserve">
          <source>Redux is originally written in ES6 and transpiled for production into ES5 with Webpack and Babel. You should be able to use it regardless of your JavaScript build process. Redux also offers a UMD build that can be used directly without any build process at all. The &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;counter-vanilla&lt;/a&gt; example demonstrates basic ES5 usage with Redux included as a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. As the relevant pull request says:</source>
          <target state="translated">Reduxは元々ES6で作成され、WebpackとBabelを使用してES5にプロダクションするために変換されます。JavaScriptのビルドプロセスに関係なく使用できるはずです。Reduxは、ビルドプロセスなしで直接使用できるUMDビルドも提供します。&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;カウンターバニラ&lt;/a&gt;の例では、Reduxの持つ基本的なES5の使用量として含ま実証 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグ。関連するプルリクエストが言うように：</target>
        </trans-unit>
        <trans-unit id="34fee0109b88a277c57526193a6d212f3a10d90d" translate="yes" xml:space="preserve">
          <source>Redux itself is very simple.</source>
          <target state="translated">Redux自体はとてもシンプルです。</target>
        </trans-unit>
        <trans-unit id="42dce762d39e68e2336c77e1bc865792d15451f7" translate="yes" xml:space="preserve">
          <source>Redux may not be as efficient out of the box when compared to other libraries. For maximum rendering performance in a React application, state should be stored in a normalized shape, many individual components should be connected to the store instead of just a few, and connected list components should pass item IDs to their connected child list items (allowing the list items to look up their own data by ID). This minimizes the overall amount of rendering to be done. Use of memoized selector functions is also an important performance consideration.</source>
          <target state="translated">Redux は、他のライブラリと比較した場合、箱から出してすぐの状態では効率が悪いかもしれません。Reactアプリケーションでレンダリングパフォーマンスを最大化するためには、ステートは正規化された形で保存され、数個のコンポーネントではなく多くの個別のコンポーネントがストアに接続され、接続されたリストコンポーネントは、接続された子リストアイテムにアイテムIDを渡す必要があります(リストアイテムがIDで自分のデータを調べることができます)。これにより、実行されるレンダリングの全体的な量を最小限に抑えることができます。メモ付きセレクタ関数を使用することも、パフォーマンスの重要な考慮事項です。</target>
        </trans-unit>
        <trans-unit id="3d50c81abd53c840945ee2fdbaa44b7467c60100" translate="yes" xml:space="preserve">
          <source>Redux middleware act like a linked list. Each middleware function can either call &lt;code&gt;next(action)&lt;/code&gt; to pass an action along to the next middleware in line, call &lt;code&gt;dispatch(action)&lt;/code&gt; to restart the processing at the beginning of the list, or do nothing at all to stop the action from being processed further.</source>
          <target state="translated">Reduxミドルウェアはリンクリストのように動作します。各ミドルウェア関数は、次のミドルウェアにアクションを渡すために &lt;code&gt;next(action)&lt;/code&gt; を呼び出すか、リストの先頭から処理を再開するために &lt;code&gt;dispatch(action)&lt;/code&gt; を呼び出すか、アクションの処理を停止するために何もしないことができますさらに。</target>
        </trans-unit>
        <trans-unit id="66a12ac42dd9b817c0a1c7e67e3311842a1c46e9" translate="yes" xml:space="preserve">
          <source>Redux middleware solves different problems than Express or Koa middleware, but in a conceptually similar way. &lt;strong&gt;It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.&lt;/strong&gt; People use Redux middleware for logging, crash reporting, talking to an asynchronous API, routing, and more.</source>
          <target state="translated">Reduxミドルウェアは、ExpressまたはKoaミドルウェアとは異なる問題を解決しますが、概念的には同様の方法です。&lt;strong&gt;アクションをディスパッチしてから、レデューサーに到達するまでの間に、サードパーティの拡張ポイントを提供します。&lt;/strong&gt;人々はロギング、クラッシュレポート、非同期APIとの通信、ルーティングなどにReduxミドルウェアを使用しています。</target>
        </trans-unit>
        <trans-unit id="63d4a8adb65aae837c51967b76d09fff2ff98328" translate="yes" xml:space="preserve">
          <source>Redux notifies subscribers after each successfully dispatched action (i.e. an action reached the store and was handled by reducers). In some cases, it may be useful to cut down on the number of times subscribers are called, particularly if an action creator dispatches multiple distinct actions in a row.</source>
          <target state="translated">Redux は、各アクションが正常にディスパッチされた後(つまり、アクションがストアに到達し、レデューサーによって処理された後)、サブスクライバに通知します。場合によっては、特にアクション作成者が複数の異なるアクションを連続してディスパッチしている場合など、サブスクライバが呼び出される回数を減らすのに役立つかもしれません。</target>
        </trans-unit>
        <trans-unit id="5e36bd6fb2ddfb9b618b443d363e9df585734103" translate="yes" xml:space="preserve">
          <source>Redux on the Server</source>
          <target state="translated">サーバー上でのRedux</target>
        </trans-unit>
        <trans-unit id="321a21760687e7864fd03dec217ad326b52df5ef" translate="yes" xml:space="preserve">
          <source>Redux provides a single &lt;code&gt;store.subscribe&lt;/code&gt; method for notifying listeners that the store has updated. Listener callbacks do not receive the current state as an argument&amp;mdash;it is simply an indication that &lt;em&gt;something&lt;/em&gt; has changed. The subscriber logic can then call &lt;code&gt;getState()&lt;/code&gt; to get the current state value.</source>
          <target state="translated">Reduxは、ストアが更新されたことをリスナーに通知するための単一の &lt;code&gt;store.subscribe&lt;/code&gt; メソッドを提供します。リスナーコールバックは、現在の状態を引数として受け取りません。これは、&lt;em&gt;何か&lt;/em&gt;が変更されたことを示すだけです。次に、サブスクライバーロジックは &lt;code&gt;getState()&lt;/code&gt; を呼び出して、現在の状態値を取得できます。</target>
        </trans-unit>
        <trans-unit id="4319c52fd7a20695a4bdd02b2e2cc58d73b86bdf" translate="yes" xml:space="preserve">
          <source>Redux puts some basic constraints on how that write logic function should work. As described in &lt;a href=&quot;../basics/reducers&quot;&gt;Reducers&lt;/a&gt;, it has to have a signature of &lt;code&gt;(previousState, action) =&amp;gt; newState&lt;/code&gt;, is known as a &lt;strong&gt;&lt;em&gt;reducer function&lt;/em&gt;&lt;/strong&gt;, and must be &lt;em&gt;pure&lt;/em&gt; and predictable.</source>
          <target state="translated">Reduxは、その書き込みロジック関数がどのように機能するかに基本的な制約を課しています。記載されているように&lt;a href=&quot;../basics/reducers&quot;&gt;レデューサー&lt;/a&gt;、それの署名有していなければならない &lt;code&gt;(previousState, action) =&amp;gt; newState&lt;/code&gt; として知られており、&lt;strong&gt;&lt;em&gt;減速機能を&lt;/em&gt;&lt;/strong&gt;しなければならず、&lt;em&gt;純粋&lt;/em&gt;かつ予測。</target>
        </trans-unit>
        <trans-unit id="59977664d77ebcee933d545dac412554294aeaf2" translate="yes" xml:space="preserve">
          <source>Redux reduces the boilerplate of Flux stores considerably by describing the update logic as a function. A function is simpler than an object, and much simpler than a class.</source>
          <target state="translated">Reduxでは、更新ロジックを関数として記述することで、Fluxストアのボイレイプレートを大幅に削減しています。関数はオブジェクトよりもシンプルで、クラスよりもはるかにシンプルです。</target>
        </trans-unit>
        <trans-unit id="402da21959ad1b00c3d1ab6f8adf5613dbe09688" translate="yes" xml:space="preserve">
          <source>Redux uses shallow equality checking in its &lt;code&gt;combineReducers&lt;/code&gt; function to return either a new mutated copy of the root state object, or, if no mutations have been made, the current root state object.</source>
          <target state="translated">Reduxは、 &lt;code&gt;combineReducers&lt;/code&gt; 関数で浅い等価性チェックを使用して、ルート状態オブジェクトの新しい変更されたコピー、または変更が行われていない場合は現在のルート状態オブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="fc4318e83cc01aa898dd245b381a161bc5966ecd" translate="yes" xml:space="preserve">
          <source>Redux vs MobX TodoMVC Benchmark: #1</source>
          <target state="translated">Redux vs MobX TodoMVC ベンチマーク:#1</target>
        </trans-unit>
        <trans-unit id="6ad6e121085cd64eb499597e7144d3ad136b11ac" translate="yes" xml:space="preserve">
          <source>Redux was inspired by several important qualities of Flux. Like Flux, Redux prescribes that you concentrate your model update logic in a certain layer of your application (&amp;ldquo;stores&amp;rdquo; in Flux, &amp;ldquo;reducers&amp;rdquo; in Redux). Instead of letting the application code directly mutate the data, both tell you to describe every mutation as a plain object called an &amp;ldquo;action&amp;rdquo;.</source>
          <target state="translated">Reduxは、Fluxのいくつかの重要な性質に触発されました。Fluxと同様に、Reduxは、モデル更新ロジックをアプリケーションの特定のレイヤー（Fluxの「ストア」、Reduxの「リデューサー」）に集中させることを規定しています。アプリケーションコードに直接データを変化させる代わりに、どちらもすべての変化を「アクション」と呼ばれるプレーンオブジェクトとして説明するように指示します。</target>
        </trans-unit>
        <trans-unit id="fdbb1f1c5606597f48f095414e66742812988218" translate="yes" xml:space="preserve">
          <source>Redux's &lt;code&gt;combineReducers&lt;/code&gt; utility &lt;a href=&quot;#how-redux-uses-shallow-checking&quot;&gt;shallowly checks for reference changes&lt;/a&gt; caused by the reducers that it calls.</source>
          <target state="translated">Reduxの &lt;code&gt;combineReducers&lt;/code&gt; ユーティリティは、それが呼び出すレデューサーによって引き起こされる&lt;a href=&quot;#how-redux-uses-shallow-checking&quot;&gt;参照の変更を浅くチェックし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="88595cd44ffbc83a4871c93314b71b115c573390" translate="yes" xml:space="preserve">
          <source>Redux's &lt;strong&gt;&lt;em&gt;only&lt;/em&gt;&lt;/strong&gt; job on the server side is to provide the &lt;strong&gt;initial state&lt;/strong&gt; of our app.</source>
          <target state="translated">Reduxのサーバー側での&lt;strong&gt;&lt;em&gt;唯一の&lt;/em&gt;&lt;/strong&gt;仕事は、アプリの&lt;strong&gt;初期状態&lt;/strong&gt;を提供することです。</target>
        </trans-unit>
        <trans-unit id="d7eb32f60e5c70f3bc2c26ceb6005796e8b88abe" translate="yes" xml:space="preserve">
          <source>Redux's use of shallow equality checking requires immutability if any connected components are to be updated correctly. To see why, we need to understand the difference between shallow and deep equality checking in JavaScript.</source>
          <target state="translated">Redux の浅い平等性検査の使用は、接続されたコンポーネントが正しく更新されるためには不変性が必要です。その理由を知るために、JavaScript の浅い平等性チェックと深い平等性チェックの違いを理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="143302841cb0d7dca0440bc31869328f76d81e32" translate="yes" xml:space="preserve">
          <source>Redux-ORM</source>
          <target state="translated">Redux-ORM</target>
        </trans-unit>
        <trans-unit id="7367376eab7e449568c0adff1f6f05f157d89179" translate="yes" xml:space="preserve">
          <source>Reduxible #8: Reducers and action creators aren't a one-to-one mapping</source>
          <target state="translated">Reduxible #8:レデューサーとアクションクリエイターは一対一のマッピングではない</target>
        </trans-unit>
        <trans-unit id="1ccd2c30250c1777fda07e84c391cdb978d5d1e8" translate="yes" xml:space="preserve">
          <source>Refactoring Reducer Logic Using Functional Decomposition and Reducer Composition</source>
          <target state="translated">関数分解と減速機合成を用いた減速機ロジックのリファクタリング</target>
        </trans-unit>
        <trans-unit id="7b4c884acfadf4ccd7e8f7f80505e0cb44517215" translate="yes" xml:space="preserve">
          <source>Refactoring Reducers Example</source>
          <target state="translated">リファクタリングレデューサーの例</target>
        </trans-unit>
        <trans-unit id="e0710cd8e6f7d93aaa10c5bd0b7c50d5a6a0ac74" translate="yes" xml:space="preserve">
          <source>Referring to items by IDs</source>
          <target state="translated">IDで項目を参照する</target>
        </trans-unit>
        <trans-unit id="35a045863630981b0a8f647ab7457dcd879ee624" translate="yes" xml:space="preserve">
          <source>Regardless of the specific data type, the shape of the undo history state is the same:</source>
          <target state="translated">特定のデータ型に関わらず、元に戻す履歴状態の形状は同じです。</target>
        </trans-unit>
        <trans-unit id="c899eec73f6b556d4b90d92d6ad1d39154a4b74c" translate="yes" xml:space="preserve">
          <source>Registers listeners via &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;subscribe(listener)&lt;/code&gt;&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;../api/store#subscribe&quot;&gt; &lt;code&gt;subscribe(listener)&lt;/code&gt; &lt;/a&gt;を介してリスナーを登録します。</target>
        </trans-unit>
        <trans-unit id="07072abd45ba7236bb3989cbd897b07eeac1c93b" translate="yes" xml:space="preserve">
          <source>Relationships and Tables</source>
          <target state="translated">関係性とテーブル</target>
        </trans-unit>
        <trans-unit id="f9da905dbbbb2d63041deb7197b587a590301a7b" translate="yes" xml:space="preserve">
          <source>Remember how we &lt;a href=&quot;reducers&quot;&gt;designed the shape of the root state object&lt;/a&gt;? It's time we design the UI hierarchy to match it. This is not a Redux-specific task. &lt;a href=&quot;https://facebook.github.io/react/docs/thinking-in-react.html&quot;&gt;Thinking in React&lt;/a&gt; is a great tutorial that explains the process.</source>
          <target state="translated">&lt;a href=&quot;reducers&quot;&gt;ルート状態オブジェクトの形状&lt;/a&gt;を設計した方法を覚えていますか？これに合わせて、UI階層を設計します。これはRedux固有のタスクではありません。&lt;a href=&quot;https://facebook.github.io/react/docs/thinking-in-react.html&quot;&gt;Thinking in React&lt;/a&gt;は、プロセスを説明する優れたチュートリアルです。</target>
        </trans-unit>
        <trans-unit id="956f2f6dcc69fefbba147a07801daf0bec3cb1a6" translate="yes" xml:space="preserve">
          <source>Remember that reducers are just functions, so you can use functional composition and higher-order functions as much as you feel comfortable.</source>
          <target state="translated">レデューサーはあくまでも関数であることを覚えておいて、機能的な構成や高次関数は自分が納得できる範囲で使いましょう。</target>
        </trans-unit>
        <trans-unit id="186767200c580a2653e26a568dd78d79172ed4ba" translate="yes" xml:space="preserve">
          <source>Remember, to change an immutable object, you must mutate a &lt;em&gt;copy&lt;/em&gt; of it, and copying large objects can be slow as every property must be copied.</source>
          <target state="translated">不変オブジェクトを変更するには、そのオブジェクトの&lt;em&gt;コピー&lt;/em&gt;を変更する必要があります。すべてのプロパティをコピーする必要があるため、ラージオブジェクトの&lt;em&gt;コピー&lt;/em&gt;は遅くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="d14133871ccbb6d27982d438fb7486a531414b6e" translate="yes" xml:space="preserve">
          <source>Remove the &lt;em&gt;first&lt;/em&gt; element from the &lt;code&gt;future&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;future&lt;/code&gt; から&lt;em&gt;最初の&lt;/em&gt;要素を削除します。</target>
        </trans-unit>
        <trans-unit id="8db23b2ef380238e2a9332bbe7bb7805acafcd6f" translate="yes" xml:space="preserve">
          <source>Remove the &lt;em&gt;last&lt;/em&gt; element from the &lt;code&gt;past&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;past&lt;/code&gt; &lt;em&gt;最後の&lt;/em&gt;要素を削除します。</target>
        </trans-unit>
        <trans-unit id="d6bae9950e29a13f58e366e00739630628accfbd" translate="yes" xml:space="preserve">
          <source>Replaces the reducer currently used by the store to calculate the state.</source>
          <target state="translated">ストアが状態を計算するために現在使用しているリデューサを置き換えます。</target>
        </trans-unit>
        <trans-unit id="e267d53c29587c8cde50b829af85bdaecdc01bb5" translate="yes" xml:space="preserve">
          <source>Reselect #47: Memoizing Hierarchical Selectors</source>
          <target state="translated">再選択 #47:階層的セレクタをメモする</target>
        </trans-unit>
        <trans-unit id="d0e0bcc2864b7d77b721a68ce1600fd8bd2214df" translate="yes" xml:space="preserve">
          <source>Reselect Documentation: How do I use Reselect with Immutable.js?</source>
          <target state="translated">Reselectのドキュメント。Immutable.jsでReselectを使うには?</target>
        </trans-unit>
        <trans-unit id="c338cf732b237c24b1f0506400e28357d0f15bd3" translate="yes" xml:space="preserve">
          <source>Reselect provides a function &lt;code&gt;createSelector&lt;/code&gt; for creating memoized selectors. &lt;code&gt;createSelector&lt;/code&gt; takes an array of input-selectors and a transform function as its arguments. If the Redux state tree is mutated in a way that causes the value of an input-selector to change, the selector will call its transform function with the values of the input-selectors as arguments and return the result. If the values of the input-selectors are the same as the previous call to the selector, it will return the previously computed value instead of calling the transform function.</source>
          <target state="translated">Reselectは、メモ化されたセレクターを作成するための関数 &lt;code&gt;createSelector&lt;/code&gt; を提供します。 &lt;code&gt;createSelector&lt;/code&gt; は、引数として入力セレクタの配列と変換関数を受け取ります。 Redux状態ツリーが入力セレクターの値を変化させるような方法で変更された場合、セレクターは引数として入力セレクターの値を使用してその変換関数を呼び出し、結果を返します。 input-selectorsの値が以前のセレクターの呼び出しと同じ場合、transform関数を呼び出す代わりに、以前に計算された値を返します。</target>
        </trans-unit>
        <trans-unit id="9c51b3f2e5f8258e6431cab2fcee20d079a2248f" translate="yes" xml:space="preserve">
          <source>Reselect: Selector library for Redux</source>
          <target state="translated">再選択。Redux用セレクタライブラリ</target>
        </trans-unit>
        <trans-unit id="9582a02f141fc4b345b2936eba691cd0654efebc" translate="yes" xml:space="preserve">
          <source>Returns</source>
          <target state="translated">Returns</target>
        </trans-unit>
        <trans-unit id="9845b29c661b5f09755c1a2c1a4a6d8ac8f795eb" translate="yes" xml:space="preserve">
          <source>Returns the current state tree of your application.</source>
          <target state="translated">アプリケーションの現在の状態ツリーを返します。</target>
        </trans-unit>
        <trans-unit id="b78505f9e7ca9beb942dcc8131c9189c9eeb998a" translate="yes" xml:space="preserve">
          <source>Reusing Reducer Logic</source>
          <target state="translated">レデューサロジックの再利用</target>
        </trans-unit>
        <trans-unit id="0966cd2fd5d2cb35f03ce6b1bce5d1e7251e6744" translate="yes" xml:space="preserve">
          <source>Rich API</source>
          <target state="translated">リッチAPI</target>
        </trans-unit>
        <trans-unit id="a245bc64c38d63184404dacd3bd9f275e513df5f" translate="yes" xml:space="preserve">
          <source>Right now we are not passing anything to &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; so &lt;code&gt;ownProps&lt;/code&gt; is an empty object. To filter our todos according to the URL, we want to pass the URL params to &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">現在、 &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; には何も渡していないため、 &lt;code&gt;ownProps&lt;/code&gt; は空のオブジェクトです。URLに従って &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt; するには、URL パラメータを&amp;lt;VisibleTodoList /&amp;gt;に渡します。</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="c9f8b56b323ff1d67c59f2e6a12b4f9fd24bb536" translate="yes" xml:space="preserve">
          <source>Rules For Structuring (Redux) Applications</source>
          <target state="translated">構造化(Redux)アプリケーションのためのルール</target>
        </trans-unit>
        <trans-unit id="432cd1e0e18bce42cdef21bc0e2bf47d9952aaae" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/async&quot;&gt;Async&lt;/a&gt; example:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/async&quot;&gt;非同期の&lt;/a&gt;例を実行します。</target>
        </trans-unit>
        <trans-unit id="c8f9990ca1ff84f660e4614ac28b5a1202d83be9" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;Counter&lt;/a&gt; example:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;カウンターの&lt;/a&gt;例を実行します。</target>
        </trans-unit>
        <trans-unit id="02bc6e8d90233a64557847335ed8fd0a2138380c" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;Counter Vanilla&lt;/a&gt; example:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;Counter Vanillaの&lt;/a&gt;例を実行します。</target>
        </trans-unit>
        <trans-unit id="ff2baf0af3858008f9b05583c2312fb090bd1e5d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/real-world&quot;&gt;Real World&lt;/a&gt; example:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/real-world&quot;&gt;実際の&lt;/a&gt;例を実行します。</target>
        </trans-unit>
        <trans-unit id="a0e8812bdf4fabf867445d42be0aa6d8b7c05486" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;Shopping Cart&lt;/a&gt; example:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;ショッピングカートの&lt;/a&gt;例を実行します。</target>
        </trans-unit>
        <trans-unit id="d299f4e9292980bd1533a8b98ddf4a548b317e3d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todomvc&quot;&gt;TodoMVC&lt;/a&gt; example:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todomvc&quot;&gt;TodoMVC&lt;/a&gt;サンプルを実行します。</target>
        </trans-unit>
        <trans-unit id="0a20317121271e18a234a5efdad9fa25e4ae9ccb" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;Todos&lt;/a&gt; example:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;Todos&lt;/a&gt;サンプルを実行します。</target>
        </trans-unit>
        <trans-unit id="abfea29e9c7baf9015d33caddf86571e5480eee7" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;Todos with Undo&lt;/a&gt; example:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;Todos with Undoの&lt;/a&gt;例を実行します。</target>
        </trans-unit>
        <trans-unit id="3419ab9b88258855aae8167ab6392ff99bc35318" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/tree-view&quot;&gt;Tree View&lt;/a&gt; example:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/tree-view&quot;&gt;ツリービューの&lt;/a&gt;例を実行します。</target>
        </trans-unit>
        <trans-unit id="eaf774d91e164852adb76afadeea254ddd1b6e1d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/universal&quot;&gt;Universal&lt;/a&gt; example:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/universal&quot;&gt;Universalの&lt;/a&gt;例を実行します。</target>
        </trans-unit>
        <trans-unit id="297ff09ad1fee6372badff1acb02a01184e1b455" translate="yes" xml:space="preserve">
          <source>RxJS</source>
          <target state="translated">RxJS</target>
        </trans-unit>
        <trans-unit id="f5c8e7496f807cd64744816fba01dc672fea8b3c" translate="yes" xml:space="preserve">
          <source>Sandrino Di Mattia</source>
          <target state="translated">サンドリーノ・ディ・マッティア</target>
        </trans-unit>
        <trans-unit id="06c1e2b042f09a95936f43d636e7a9cfe06fa2c4" translate="yes" xml:space="preserve">
          <source>Say, you call this when creating a todo:</source>
          <target state="translated">todoを作成するときに、これを呼び出すと言ってください。</target>
        </trans-unit>
        <trans-unit id="e86aae6b5aebceaa76af1cce53d3199d645e9dcb" translate="yes" xml:space="preserve">
          <source>Screencasts</source>
          <target state="translated">Screencasts</target>
        </trans-unit>
        <trans-unit id="abf418e07a2bb8523e609c6622f0ee30e20593e9" translate="yes" xml:space="preserve">
          <source>Second Attempt: Writing a Reducer Enhancer</source>
          <target state="translated">2回目の試み。レッサー・エンハンサーを書く</target>
        </trans-unit>
        <trans-unit id="325c723ca2b67b9b7f5ba09ec5687e02ae1b0279" translate="yes" xml:space="preserve">
          <source>Secure Your React and Redux App with JWT Authentication</source>
          <target state="translated">JWT認証でReactとReduxアプリをセキュアに</target>
        </trans-unit>
        <trans-unit id="402cc3b6686cd294cb10dd3f5bccbebd0edd8a9b" translate="yes" xml:space="preserve">
          <source>Security Considerations</source>
          <target state="translated">セキュリティへの配慮</target>
        </trans-unit>
        <trans-unit id="919870200d649a13066b3447ce0f0c25022cc8f6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware(...middlewares)&lt;/code&gt;&lt;/a&gt; for a detailed look at middleware.</source>
          <target state="translated">&lt;a href=&quot;api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware(...middlewares)&lt;/code&gt; &lt;/a&gt;詳細については、applyMiddleware（... middlewares）を参照してください。</target>
        </trans-unit>
        <trans-unit id="94f2d6b880adb72fb73adf9d3a1c8276271ee55a" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#async-action&quot;&gt;async action&lt;/a&gt; below.</source>
          <target state="translated">以下の&lt;a href=&quot;#async-action&quot;&gt;非同期アクション&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="22ce2ecd3395a41aaf7f8cf591c10dd2e971bbd0" translate="yes" xml:space="preserve">
          <source>See the complete &lt;a href=&quot;api/store#dispatch&quot;&gt;store API reference&lt;/a&gt; for more details.</source>
          <target state="translated">詳細については、完全な&lt;a href=&quot;api/store#dispatch&quot;&gt;ストアAPIリファレンス&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="1664d8a03fa57f4c8be0067b9d13327134f1e58a" translate="yes" xml:space="preserve">
          <source>Separating Data Handling by Domain</source>
          <target state="translated">ドメインごとにデータ処理を分ける</target>
        </trans-unit>
        <trans-unit id="4ff6540c25bde7085cf0d2d1e9575cb74d3e0915" translate="yes" xml:space="preserve">
          <source>Server Rendering</source>
          <target state="translated">サーバーレンダリング</target>
        </trans-unit>
        <trans-unit id="25c47193088be9016d58e256803985285406a208" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;present&lt;/code&gt; to the element we removed in the previous step.</source>
          <target state="translated">&lt;code&gt;present&lt;/code&gt; を前のステップで削除した要素に設定します。</target>
        </trans-unit>
        <trans-unit id="d0b36286cd9781f93bd06e4cc2ba9bd4a1ae46eb" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;present&lt;/code&gt; to the new state after handling the action.</source>
          <target state="translated">アクションを処理した後、 &lt;code&gt;present&lt;/code&gt; を新しい状態に設定します。</target>
        </trans-unit>
        <trans-unit id="d60b0890a431be3750d67b0f7fe70b5f3af16d7e" translate="yes" xml:space="preserve">
          <source>Setting Up</source>
          <target state="translated">設定</target>
        </trans-unit>
        <trans-unit id="6ef3f0bd0914407afe72f32d7220011189833964" translate="yes" xml:space="preserve">
          <source>Seven Examples</source>
          <target state="translated">7つの例</target>
        </trans-unit>
        <trans-unit id="bceef6abe99285193523d99d3503c8cbe59abd17" translate="yes" xml:space="preserve">
          <source>Shallow equality checking (or &lt;em&gt;reference equality&lt;/em&gt;) simply checks that two different &lt;em&gt;variables&lt;/em&gt; reference the same object; in contrast, deep equality checking (or &lt;em&gt;value equality&lt;/em&gt;) must check every &lt;em&gt;value&lt;/em&gt; of two objects' properties.</source>
          <target state="translated">浅い等価チェック（または&lt;em&gt;参照等価&lt;/em&gt;）は、2つの異なる&lt;em&gt;変数&lt;/em&gt;が同じオブジェクトを参照しているかどうかをチェックするだけです。対照的に、深い等価チェック（または&lt;em&gt;値の等価&lt;/em&gt;）は、2つのオブジェクトのプロパティのすべての&lt;em&gt;値&lt;/em&gt;をチェックする必要があります。</target>
        </trans-unit>
        <trans-unit id="c1af20867da7a30bee30fa39bc87d4d6bf5086c5" translate="yes" xml:space="preserve">
          <source>Shallow equality checking cannot be used to detect if a function mutates an object passed into it if that object is mutable.</source>
          <target state="translated">浅い等値検査では、関数に渡されたオブジェクトが突然変異可能な場合に、関数がそのオブジェクトを変異させるかどうかを検出することはできません。</target>
        </trans-unit>
        <trans-unit id="9a3368201d828a558753e74bfb641b78ef4ebe17" translate="yes" xml:space="preserve">
          <source>Shallow equality checking with a mutable object will not cause problems with Redux, but &lt;a href=&quot;#shallow-checking-problems-with-react-redux&quot;&gt;it will cause problems with libraries that depend on the store, such as React-Redux&lt;/a&gt;.</source>
          <target state="translated">可変オブジェクトを使用した浅い等価チェックはReduxで問題を引き起こしませんが&lt;a href=&quot;#shallow-checking-problems-with-react-redux&quot;&gt;、React-Reduxなどのストアに依存するライブラリでは問題を引き起こします&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="54774f0c2c7e8f191039f8359b7b19ab53fad9f2" translate="yes" xml:space="preserve">
          <source>Sharing Selectors Across Multiple Components</source>
          <target state="translated">複数のコンポーネントでセレクタを共有する</target>
        </trans-unit>
        <trans-unit id="192f8cbb6f5871d94ba5fb03d97db29c7de825cd" translate="yes" xml:space="preserve">
          <source>Sharing State Between Redux Reducers</source>
          <target state="translated">Redux レジューサー間での状態の共有</target>
        </trans-unit>
        <trans-unit id="b89a118c798fa4a35e3c16cccb58dae4801140ac" translate="yes" xml:space="preserve">
          <source>Sharing data between slice reducers</source>
          <target state="translated">スライスレデューサ間でのデータ共有</target>
        </trans-unit>
        <trans-unit id="90d67309aeeeaf7718677d90e2400596d8e164bd" translate="yes" xml:space="preserve">
          <source>Shopping Cart</source>
          <target state="translated">ショッピングカート</target>
        </trans-unit>
        <trans-unit id="36fe368c9da0c4844911eb85a837f68dcae6c653" translate="yes" xml:space="preserve">
          <source>Should I dispatch multiple actions in a row from one action creator?</source>
          <target state="translated">1つのアクション作成者から複数のアクションを連続してディスパッチする必要がありますか?</target>
        </trans-unit>
        <trans-unit id="e5b09d329a9d354e9f3fa021df3644b2917c4096" translate="yes" xml:space="preserve">
          <source>Should I only connect my top component, or can I connect multiple components in my tree?</source>
          <target state="translated">トップコンポーネントだけを接続すべきか、それともツリー内の複数のコンポーネントを接続することはできますか?</target>
        </trans-unit>
        <trans-unit id="1737c8bf68fcf64ccfaf2774ab797e55426baaa7" translate="yes" xml:space="preserve">
          <source>Should be &quot;pure&quot;, which means the reducer:</source>
          <target state="translated">還元剤を意味する「純粋」でなければならない。</target>
        </trans-unit>
        <trans-unit id="e9fdc92b96e07741038b0992e2225ba1bf7f6560" translate="yes" xml:space="preserve">
          <source>Should have a signature of &lt;code&gt;(previousState, action) =&amp;gt; newState&lt;/code&gt;, similar to the type of function you would pass to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array.prototype.reduce(reducer, ?initialValue)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt; &lt;code&gt;Array.prototype.reduce(reducer, ?initialValue)&lt;/code&gt; &lt;/a&gt;渡す関数のタイプと同様に、 &lt;code&gt;(previousState, action) =&amp;gt; newState&lt;/code&gt; シグネチャが必要です</target>
        </trans-unit>
        <trans-unit id="f9b9f5929894997ad56cc3c83383ff218a8e4e68" translate="yes" xml:space="preserve">
          <source>Side effects</source>
          <target state="translated">副作用</target>
        </trans-unit>
        <trans-unit id="2bdc602c5e4f77691c4cf05236ccbfb9a3a7d6cd" translate="yes" xml:space="preserve">
          <source>Similarly, Dan Abramov, one of the creators of Redux, says:</source>
          <target state="translated">同様に、Reduxの生みの親の一人であるダン・アブラモフ氏は言う。</target>
        </trans-unit>
        <trans-unit id="a8d94bc8e96596ebe8e2c196ec3465a016861842" translate="yes" xml:space="preserve">
          <source>Similarly, if &lt;code&gt;sliceReducerA&lt;/code&gt; happens to need some data from &lt;code&gt;sliceReducerB&lt;/code&gt;'s slice of state in order to handle a particular action, or &lt;code&gt;sliceReducerB&lt;/code&gt; happens to need the entire state as an argument, &lt;code&gt;combineReducers&lt;/code&gt; does not handle that itself. This could be resolved by writing a custom function that knows to pass the needed data as an additional argument in those specific cases, such as:</source>
          <target state="translated">同様に、 &lt;code&gt;sliceReducerA&lt;/code&gt; が特定のアクションを処理するために &lt;code&gt;sliceReducerB&lt;/code&gt; の状態スライスからデータを必要とする場合、または &lt;code&gt;sliceReducerB&lt;/code&gt; が引数として状態全体を必要とする場合、 &lt;code&gt;combineReducers&lt;/code&gt; はそれ自体を処理しません。これは、次のような特定のケースで追加の引数として必要なデータを渡すことを認識しているカスタム関数を作成することで解決できます。</target>
        </trans-unit>
        <trans-unit id="442aad2b9dae61af274e1b5ffcce14c8db98f18c" translate="yes" xml:space="preserve">
          <source>Similarly, while you &lt;em&gt;can&lt;/em&gt; reference your store instance by importing it directly, this is not a recommended pattern in Redux. If you create a store instance and export it from a module, it will become a singleton. This means it will be harder to isolate a Redux app as a component of a larger app, if this is ever necessary, or to enable server rendering, because on the server you want to create separate store instances for every request.</source>
          <target state="translated">同様に、ストアインスタンスを直接インポートして参照すること&lt;em&gt;もでき&lt;/em&gt;ます&lt;em&gt;が&lt;/em&gt;、これはReduxでの推奨パターンではありません。ストアインスタンスを作成してモジュールからエクスポートすると、シングルトンになります。つまり、サーバー上ではリクエストごとに個別のストアインスタンスを作成する必要があるため、Reduxアプリを大きなアプリのコンポーネントとして分離することや、サーバーレンダリングを有効にすることが難しくなります。</target>
        </trans-unit>
        <trans-unit id="4f6c75f4d537fefd2d55e1099d473ae02742b468" translate="yes" xml:space="preserve">
          <source>Similarly, you can compose different asynchronous streams to turn them into actions before feeding them to &lt;code&gt;store.dispatch()&lt;/code&gt;.</source>
          <target state="translated">同様に、異なる非同期ストリームを構成して、それらを &lt;code&gt;store.dispatch()&lt;/code&gt; に供給する前にアクションに変換することができます。</target>
        </trans-unit>
        <trans-unit id="0b1172b53a0feb7a9bb295b5a660a2ffbcb58fc3" translate="yes" xml:space="preserve">
          <source>Simple Merging</source>
          <target state="translated">シンプルなマージ</target>
        </trans-unit>
        <trans-unit id="2070eaef74ea9323409e358647e9ae6ca53c37cd" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;combineReducers&lt;/code&gt; currently only works with plain Javascript objects, an application that uses an Immutable.js Map object for the top of its state tree could not use &lt;code&gt;combineReducers&lt;/code&gt; to manage that Map. Since many developers do use Immutable.js, there are a number of published utilities that provide equivalent functionality, such as &lt;a href=&quot;https://github.com/gajus/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt;. This package provides its own implementation of &lt;code&gt;combineReducers&lt;/code&gt; that knows how to iterate over an Immutable Map instead of a plain Javascript object.</source>
          <target state="translated">現在、 &lt;code&gt;combineReducers&lt;/code&gt; はプレーンJavaScriptオブジェクトでのみ機能するため、状態ツリーの最上位にImmutable.js Mapオブジェクトを使用するアプリケーションは、 &lt;code&gt;combineReducers&lt;/code&gt; を使用してそのマップを管理できませんでした。多くの開発者がImmutable.jsを使用しているため、&lt;a href=&quot;https://github.com/gajus/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt;など、同等の機能を提供する公開されたユーティリティが多数あります。このパッケージは、プレーンなJavaScriptオブジェクトの代わりに不変マップを反復処理する方法を知っている &lt;code&gt;combineReducers&lt;/code&gt; 独自の実装を提供します。</target>
        </trans-unit>
        <trans-unit id="81feae1ade917069a12cf9aa7539b91da9719215" translate="yes" xml:space="preserve">
          <source>Since Redux is just a data store library, it has no direct opinion on how your project should be structured. However, there are a few common patterns that most Redux developers tend to use:</source>
          <target state="translated">Reduxは単なるデータストアライブラリに過ぎないので、プロジェクトがどのように構造化されるべきかについての直接的な意見はありません。しかし、ほとんどの Redux 開発者が使いがちな共通のパターンがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="ec6d8987b40f3810e89420d79f0a03ad196ea3a0" translate="yes" xml:space="preserve">
          <source>Since a Redux reducer is &lt;em&gt;just&lt;/em&gt; a function, the same concept applies. You can split some of your reducer logic out into another function, and call that new function from the parent function.</source>
          <target state="translated">Reduxレデューサーは&lt;em&gt;単なる&lt;/em&gt;関数なので、同じ概念が適用されます。リデューサーロジックの一部を別の関数に分割し、親関数からその新しい関数を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="c7004cb2a5422c7e3364434a15f16aaad43e92c0" translate="yes" xml:space="preserve">
          <source>Since each data type is separated, an update like changing the text of a comment would only require new copies of the &quot;comments &amp;gt; byId &amp;gt; comment&quot; portion of the tree. This will generally mean fewer portions of the UI that need to update because their data has changed. In contrast, updating a comment in the original nested shape would have required updating the comment object, the parent post object, the array of all post objects, and likely have caused &lt;em&gt;all&lt;/em&gt; of the Post components and Comment components in the UI to re-render themselves.</source>
          <target state="translated">各データタイプが分離されているため、コメントのテキストを変更するような更新では、ツリーの &quot;comments&amp;gt; byId&amp;gt; comment&quot;部分の新しいコピーのみが必要になります。これは一般に、データが変更されたために更新が必要なUIの部分が少なくなることを意味します。対照的に、元のネストされた形状でコメントを更新するには、コメントオブジェクト、親投稿オブジェクト、すべての投稿オブジェクトの配列を更新する必要があり、UIの&lt;em&gt;すべて&lt;/em&gt;の投稿コンポーネントとコメントコンポーネントが再レンダリングされる可能性があります自分自身。</target>
        </trans-unit>
        <trans-unit id="3378207602b38cf49f27093860fe75762bdd12fe" translate="yes" xml:space="preserve">
          <source>Since immutable data updates require all ancestors in the state tree to be copied and updated as well, and new object references will cause connected UI components to re-render, an update to a deeply nested data object could force totally unrelated UI components to re-render even if the data they're displaying hasn't actually changed.</source>
          <target state="translated">不変データの更新では、状態ツリー内のすべての祖先もコピーされて更新される必要があり、新しいオブジェクト参照によって接続された UI コンポーネントが再レンダリングされるため、深く入れ子になっているデータ オブジェクトへの更新では、表示しているデータが実際に変更されていなくても、全く関係のない UI コンポーネントが再レンダリングされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="bc174df1294758024d3aa9d37156a3b1ea508c4a" translate="yes" xml:space="preserve">
          <source>Since one of the core tenets of Redux is to never mutate state, you'll often find yourself using &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/a&gt; to create copies of objects with new or updated values. For example, in the &lt;code&gt;todoApp&lt;/code&gt; below &lt;code&gt;Object.assign()&lt;/code&gt; is used to return a new &lt;code&gt;state&lt;/code&gt; object with an updated &lt;code&gt;visibilityFilter&lt;/code&gt; property:</source>
          <target state="translated">Reduxの中心的な信条の1つは状態を変更しないことです。そのため、&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign()&lt;/code&gt; &lt;/a&gt;を使用して、新しい値または更新された値を持つオブジェクトのコピーを作成することがよくあります。例えば、内 &lt;code&gt;todoApp&lt;/code&gt; 以下 &lt;code&gt;Object.assign()&lt;/code&gt; 新しい戻すために使用された &lt;code&gt;state&lt;/code&gt; に更新してオブジェクトを &lt;code&gt;visibilityFilter&lt;/code&gt; のプロパティ：</target>
        </trans-unit>
        <trans-unit id="751750d4cb79c6a8466b2981d8a7c11a9b335b87" translate="yes" xml:space="preserve">
          <source>Since reducers are just functions, there's an infinite number of ways to split up this logic. While using slice reducers is obviously the most common, it's also possible to organize behavior in a more task-oriented structure. Because this will often involve more nested updates, you may want to use an immutable update utility library like &lt;a href=&quot;https://github.com/debitoor/dot-prop-immutable&quot;&gt;dot-prop-immutable&lt;/a&gt; or &lt;a href=&quot;https://github.com/mariocasciaro/object-path-immutable&quot;&gt;object-path-immutable&lt;/a&gt; to simplify the update statements. Here's an example of what that might look like:</source>
          <target state="translated">レデューサーは単なる関数なので、このロジックを分割する方法は無数にあります。明らかにスライスリデューサーの使用が最も一般的ですが、よりタスク指向の構造で動作を整理することも可能です。多くの場合、これにはネストされた更新が含まれるため、更新ステートメントを簡略化するために&lt;a href=&quot;https://github.com/debitoor/dot-prop-immutable&quot;&gt;dot-prop-immutable&lt;/a&gt;または&lt;a href=&quot;https://github.com/mariocasciaro/object-path-immutable&quot;&gt;object-path-immutable&lt;/a&gt;などの不変の更新ユーティリティライブラリを使用することができます。これがどのように見えるかの例です：</target>
        </trans-unit>
        <trans-unit id="9524f9ed1b2581f0acc17e64cde44a8908d2e14e" translate="yes" xml:space="preserve">
          <source>Since the default export is still the decorated component, the import statement pictured above will work as before so you won't have to change your application code. However, you can now import the undecorated &lt;code&gt;App&lt;/code&gt; components in your test file like this:</source>
          <target state="translated">デフォルトのエクスポートは装飾されたコンポーネントであるため、上記のインポート文は以前と同じように機能するため、アプリケーションコードを変更する必要はありません。ただし、次のようにして、装飾されていない &lt;code&gt;App&lt;/code&gt; コンポーネントをテストファイルにインポートできます。</target>
        </trans-unit>
        <trans-unit id="1fb6dcac04c2641afe5f5ceba2752f16941c0489" translate="yes" xml:space="preserve">
          <source>Since the object spread syntax is still a &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread#status-of-this-proposal&quot;&gt;Stage 3&lt;/a&gt; proposal for ECMAScript you'll need to use a transpiler such as &lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt; to use it in production. You can use your existing &lt;code&gt;es2015&lt;/code&gt; preset, install &lt;a href=&quot;http://babeljs.io/docs/plugins/transform-object-rest-spread/&quot;&gt;&lt;code&gt;babel-plugin-transform-object-rest-spread&lt;/code&gt;&lt;/a&gt; and add it individually to the &lt;code&gt;plugins&lt;/code&gt; array in your &lt;code&gt;.babelrc&lt;/code&gt;.</source>
          <target state="translated">オブジェクトのスプレッド構文がまだあるので、&lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread#status-of-this-proposal&quot;&gt;ステージ3&lt;/a&gt;のECMAScriptのための提案あなたはこのようなtranspilerを使用する必要があります&lt;a href=&quot;http://babeljs.io/&quot;&gt;バベルが&lt;/a&gt;生産にそれを使用します。既存の &lt;code&gt;es2015&lt;/code&gt; プリセットを使用して&lt;a href=&quot;http://babeljs.io/docs/plugins/transform-object-rest-spread/&quot;&gt; &lt;code&gt;babel-plugin-transform-object-rest-spread&lt;/code&gt; &lt;/a&gt;をインストールし、 &lt;code&gt;.babelrc&lt;/code&gt; &lt;code&gt;plugins&lt;/code&gt; 配列に個別に追加できます。</target>
        </trans-unit>
        <trans-unit id="8ca51516913ff8c686b4181a9850b407d585f33e" translate="yes" xml:space="preserve">
          <source>Single Simple Reducer</source>
          <target state="translated">単一の単純な減速機</target>
        </trans-unit>
        <trans-unit id="c3607f5a3395346db279c8631885ad76c32cdec0" translate="yes" xml:space="preserve">
          <source>Single source of truth</source>
          <target state="translated">単一の真実のソース</target>
        </trans-unit>
        <trans-unit id="3d0ddd2467b9b23c1a85abd5a68ac4b84b509998" translate="yes" xml:space="preserve">
          <source>Slice Reducer Composition</source>
          <target state="translated">スライスレデューサの構成</target>
        </trans-unit>
        <trans-unit id="6f8966ee06a6a598a66e68a6f2128780e130ca9a" translate="yes" xml:space="preserve">
          <source>Small utility functions containing some reusable chunk of logic that is needed in multiple places (which may or may not be actually related to the specific business logic)</source>
          <target state="translated">複数の場所で必要とされる再利用可能なロジックの塊を含む小さなユーティリティ関数 (特定のビジネスロジックに実際に関連しているかどうかは不明)</target>
        </trans-unit>
        <trans-unit id="712ac3fdb33cc95ff1f79708b05bdbf85fc873a3" translate="yes" xml:space="preserve">
          <source>Smart and Dumb Components in React</source>
          <target state="translated">React のスマートなコンポーネントとダムなコンポーネント</target>
        </trans-unit>
        <trans-unit id="dd67eec5e031f2788f993ce1a20a1c919e9f1589" translate="yes" xml:space="preserve">
          <source>Smart components that access the store via React Redux&amp;rsquo;s &lt;code&gt;connect&lt;/code&gt; function must use the Immutable.JS values returned by your selectors. Make sure you avoid the potential issues this can cause with unnecessary component re-rendering. Memoize your selectors using a library such as reselect if necessary.</source>
          <target state="translated">React Reduxの &lt;code&gt;connect&lt;/code&gt; 関数を介してストアにアクセスするスマートコンポーネントは、セレクターから返されるImmutable.JS値を使用する必要があります。不要なコンポーネントの再レンダリングで発生する可能性がある潜在的な問題を回避してください。必要に応じて、reselectなどのライブラリを使用してセレクターをメモします。</target>
        </trans-unit>
        <trans-unit id="0fa28ccaea98dae4e7adc0d2f21a6688416f5c11" translate="yes" xml:space="preserve">
          <source>So far we have only seen selectors receive the Redux store state as an argument, but a selector can receive props too.</source>
          <target state="translated">これまでのところ、セレクタがReduxストアの状態を引数として受け取ることしか見てきませんでしたが、セレクタはpropsも受け取ることができます。</target>
        </trans-unit>
        <trans-unit id="7c7e37241e1ba9e69dbbe9b4a4d92f9d4db7b97e" translate="yes" xml:space="preserve">
          <source>So now &lt;code&gt;getVisibleTodos&lt;/code&gt; has access to &lt;code&gt;props&lt;/code&gt;, and everything seems to be working fine.</source>
          <target state="translated">これで &lt;code&gt;getVisibleTodos&lt;/code&gt; が &lt;code&gt;props&lt;/code&gt; にアクセスできるようになり、すべてが正常に動作しているようです。</target>
        </trans-unit>
        <trans-unit id="d7a8e420420cf895d7c454a61b1d5cb20007fa2a" translate="yes" xml:space="preserve">
          <source>So you want to do routing with your Redux app. You can use it with &lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt;. Redux will be the source of truth for your data and React Router will be the source of truth for your URL. In most of the cases, &lt;strong&gt;it is fine&lt;/strong&gt; to have them separate unless you need to time travel and rewind actions that triggers the change URL.</source>
          <target state="translated">そのため、Reduxアプリでルーティングを行います。&lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Routerで&lt;/a&gt;使用できます。Reduxがデータの真実のソースになり、React RouterがURLの真実のソースになります。ほとんどの場合、URLの変更をトリガーするタイムトラベルと巻き戻しのアクションが必要でない限り、それらを分離しても&lt;strong&gt;問題&lt;/strong&gt;ありません。</target>
        </trans-unit>
        <trans-unit id="2fc8fe9a73edd4d111843f389431f4101d5d9c17" translate="yes" xml:space="preserve">
          <source>So, for example, if your state shape is &lt;code&gt;{ todos, counter }&lt;/code&gt;, the call to &lt;code&gt;combineReducers&lt;/code&gt; would be:</source>
          <target state="translated">したがって、たとえば、状態の形状が &lt;code&gt;{ todos, counter }&lt;/code&gt; 場合、 &lt;code&gt;combineReducers&lt;/code&gt; の呼び出しは次のようになります。</target>
        </trans-unit>
        <trans-unit id="ccb9fbf6736643b0e42418e768268b9cd0d29f5f" translate="yes" xml:space="preserve">
          <source>So, what are you waiting for?</source>
          <target state="translated">で、何を待っているの?</target>
        </trans-unit>
        <trans-unit id="aaba548cf058bc58a2b9e6247d0f30696c87f137" translate="yes" xml:space="preserve">
          <source>Solving a performance issue caused by too frequent updates of some part of the state, when confirmed by profiling the app.</source>
          <target state="translated">アプリをプロファイリングして確認すると、状態の一部が頻繁に更新されすぎていることに起因するパフォーマンスの問題を解決します。</target>
        </trans-unit>
        <trans-unit id="d49f0c1ce0f85599fd62bed378620cb762c1e648" translate="yes" xml:space="preserve">
          <source>Some Reasons Why Redux is Useful in a React App</source>
          <target state="translated">ReactアプリでReduxが便利ないくつかの理由</target>
        </trans-unit>
        <trans-unit id="67effe7198ec1da2c9351c8b657b35336537bffb" translate="yes" xml:space="preserve">
          <source>Some common rules of thumb for determining what kind of data should be put into Redux:</source>
          <target state="translated">Reduxにどのようなデータを入れるべきかを決めるための、いくつかの一般的な経験則。</target>
        </trans-unit>
        <trans-unit id="fce335731003088c209cd9b37e95f6128c05deb1" translate="yes" xml:space="preserve">
          <source>Some frameworks like &lt;a href=&quot;https://github.com/acdlite/flummox&quot;&gt;Flummox&lt;/a&gt; generate action type constants automatically from the action creator function definitions. The idea is that you don't need to both define &lt;code&gt;ADD_TODO&lt;/code&gt; constant and &lt;code&gt;addTodo()&lt;/code&gt; action creator. Under the hood, such solutions still generate action type constants, but they're created implicitly so it's a level of indirection and can cause confusion. We recommend creating your action type constants explicitly.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/flummox&quot;&gt;Flummoxの&lt;/a&gt;ような一部のフレームワークは、アクションクリエーター関数定義からアクションタイプ定数を自動的に生成します。つまり、 &lt;code&gt;ADD_TODO&lt;/code&gt; 定数と &lt;code&gt;addTodo()&lt;/code&gt; アクション作成者の両方を定義する必要はありません。内部的には、このようなソリューションはアクションタイプの定数を生成しますが、暗黙的に作成されるため、間接参照のレベルになり、混乱を引き起こす可能性があります。アクションタイプ定数を明示的に作成することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="11a2735a6d7891b97c7769374cd7a4c5a0bb87e0" translate="yes" xml:space="preserve">
          <source>Some of these concepts are already described elsewhere in the Redux documentation. Others are generic and applicable outside of Redux itself, and there are numerous existing articles that cover these concepts in detail. These concepts and techniques form the foundation of writing solid Redux reducer logic.</source>
          <target state="translated">これらの概念のいくつかは、Redux ドキュメントの他の場所ですでに説明されています。また、これらの概念を詳細に説明した記事が多数存在します。これらの概念と技術は、しっかりとしたRedux reducerロジックを書くための基礎を形成しています。</target>
        </trans-unit>
        <trans-unit id="f81aa5aa34cf8b3e24fa1aaf08e9c45c13b0947d" translate="yes" xml:space="preserve">
          <source>Some valid reasons for using multiple stores in Redux might include:</source>
          <target state="translated">Reduxで複数のストアを使用する有効な理由としては、以下のようなものが考えられます。</target>
        </trans-unit>
        <trans-unit id="a0393764cde3422b70bb25ef444a0fd2f0c54e31" translate="yes" xml:space="preserve">
          <source>Something else doesn't work</source>
          <target state="translated">何か他のものが動作しない</target>
        </trans-unit>
        <trans-unit id="cb49415fd84ba99d743a94724fc704b532a5abb2" translate="yes" xml:space="preserve">
          <source>Something needs to map the Immutable.JS props in your Smart Component to the pure JavaScript props used in your Dumb Component. That something is a Higher Order Component (HOC) that simply takes the Immutable.JS props from your Smart Component, and converts them using &lt;code&gt;toJS()&lt;/code&gt; to plain JavaScript props, which are then passed to your Dumb Component.</source>
          <target state="translated">スマートコンポーネントのImmutable.JSプロップを、ダムコンポーネントで使用される純粋なJavaScriptプロップにマップする必要があります。これは、スマートコンポーネントからImmutable.JSプロップを単純に &lt;code&gt;toJS()&lt;/code&gt; し、toJS（）を使用してそれらをプレーンJavaScriptプロップに変換する高次コンポーネント（HOC）であり、それがDumbコンポーネントに渡されます。</target>
        </trans-unit>
        <trans-unit id="82c027e36202d6dbe2e05d86322f925c7f839e11" translate="yes" xml:space="preserve">
          <source>Sometimes it's hard to tell if some component should be a presentational component or a container. For example, sometimes form and function are really coupled together, such as in case of this tiny component:</source>
          <target state="translated">時には、あるコンポーネントが現在のコンポーネントであるべきか、コンテナであるべきかを見分けるのが難しいことがあります。例えば、この小さなコンポーネントの場合のように、形と機能が本当に一緒になっていることがあります。</target>
        </trans-unit>
        <trans-unit id="d627c00cc83e8506e9cca85f44caed1d800c8c74" translate="yes" xml:space="preserve">
          <source>Sometimes you want to see all existing actions before working on a new feature. It may be that the action you need was already added by somebody on the team, but you didn't know.</source>
          <target state="translated">新しい機能に取り組む前に、既存のすべてのアクションを見たいと思うことがあります。必要なアクションがすでにチームの誰かによって追加されているかもしれませんが、あなたは知らなかったのかもしれません。</target>
        </trans-unit>
        <trans-unit id="268852f5aa4bf3dafae464e32161ca334e3c609b" translate="yes" xml:space="preserve">
          <source>Sometimes, you are trying to dispatch an action, but your view does not update. Why does this happen? There may be several reasons for this.</source>
          <target state="translated">アクションをディスパッチしようとしているのに、ビューが更新されないことがあります。なぜこのようなことが起こるのでしょうか?これにはいくつかの理由が考えられます。</target>
        </trans-unit>
        <trans-unit id="7b37110e5b01350732eac4676af2611966b9ccef" translate="yes" xml:space="preserve">
          <source>Source Code</source>
          <target state="translated">ソースコード</target>
        </trans-unit>
        <trans-unit id="f7919286c635d777ca9b544031e60fec3b718ae8" translate="yes" xml:space="preserve">
          <source>Special thanks to &lt;a href=&quot;http://jdpaton.github.io&quot;&gt;Jamie Paton&lt;/a&gt; for handing over the &lt;code&gt;redux&lt;/code&gt; NPM package name.</source>
          <target state="translated">&lt;code&gt;redux&lt;/code&gt; NPMパッケージ名を引き渡してくれた&lt;a href=&quot;http://jdpaton.github.io&quot;&gt;Jamie Patonに&lt;/a&gt;特に感謝します。</target>
        </trans-unit>
        <trans-unit id="56c91bc14a02e8f889305106eb782729b8dd411c" translate="yes" xml:space="preserve">
          <source>Specifically, at each stage of the iteration, &lt;code&gt;combineReducers&lt;/code&gt; performs a shallow equality check on the current state slice and the state slice returned from the reducer. If the reducer returns a new object, the shallow equality check will fail, and &lt;code&gt;combineReducers&lt;/code&gt; will set a &lt;code&gt;hasChanged&lt;/code&gt; flag to true.</source>
          <target state="translated">具体的には、反復の各段階で、 &lt;code&gt;combineReducers&lt;/code&gt; は現在の状態スライスとリデューサーから返された状態スライスに対して浅い等価チェックを実行します。レデューサーが新しいオブジェクトを返す場合、浅い等価性チェックは失敗し、 &lt;code&gt;combineReducers&lt;/code&gt; は &lt;code&gt;hasChanged&lt;/code&gt; フラグをtrueに設定します。</target>
        </trans-unit>
        <trans-unit id="00a3d8825c5eff03d86ea087a0b53050c94c3f8c" translate="yes" xml:space="preserve">
          <source>Specifically, if the state slice passed to a reducer by &lt;code&gt;combineReducers&lt;/code&gt; is a mutable object, the reducer can modify it directly and return it.</source>
          <target state="translated">特に、 &lt;code&gt;combineReducers&lt;/code&gt; によってレデューサーに渡された状態スライスが変更可能なオブジェクトである場合、レデューサーはそれを直接変更して返すことができます。</target>
        </trans-unit>
        <trans-unit id="479e7df6db27bd135fe0142b00903715ac33068a" translate="yes" xml:space="preserve">
          <source>Splitting Reducer Logic</source>
          <target state="translated">スプリットリデューサロジック</target>
        </trans-unit>
        <trans-unit id="0b815e2bedf75de31f11e6b703026f6acada0f6e" translate="yes" xml:space="preserve">
          <source>Splitting Reducers</source>
          <target state="translated">スプリットレデューサー</target>
        </trans-unit>
        <trans-unit id="63a2a0cb21e82fc3b8d2808aae5b0cbb52a99600" translate="yes" xml:space="preserve">
          <source>Splitting Up Reducer Logic</source>
          <target state="translated">スプリットアップリデューサロジック</target>
        </trans-unit>
        <trans-unit id="d329a5765000192b22c2d117af29d9bee7c6537b" translate="yes" xml:space="preserve">
          <source>Splitting relational/nested data up into separate tables</source>
          <target state="translated">リレーショナル/入れ子になっているデータをテーブルごとに分割する</target>
        </trans-unit>
        <trans-unit id="1230663d5b652e72592a5cdc4822bd583ada50c6" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Accessing Redux state in an action creator</source>
          <target state="translated">スタックオーバーフロー。アクションクリエーターでReduxの状態にアクセスする</target>
        </trans-unit>
        <trans-unit id="af2ce625671f1ad526f0f824992d40592fc65945" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Accessing Redux state in an action creator?</source>
          <target state="translated">スタックオーバーフロー。アクションクリエーターでReduxの状態にアクセスするには?</target>
        </trans-unit>
        <trans-unit id="cc4a21e47f70cd2f23b0f2c342d8b431463d5d43" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Accessing other parts of the state when using combined reducers?</source>
          <target state="translated">スタックオーバーフロー。結合されたレデューサーを使用しているときに状態の他の部分にアクセスする?</target>
        </trans-unit>
        <trans-unit id="b04783e3f6d9939621df25d5e278f88f85d40f4e" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Can I dispatch multiple actions without Redux Thunk middleware?</source>
          <target state="translated">スタックオーバーフロー。Redux Thunkミドルウェアを使わずに複数のアクションをディスパッチできますか?</target>
        </trans-unit>
        <trans-unit id="48da126c64af14eeff2ddf00eef38c1862600c5d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Can a React Redux app scale as well as Backbone?</source>
          <target state="translated">スタックオーバーフロー。React ReduxアプリはBackboneと同じようにスケーリングできるか?</target>
        </trans-unit>
        <trans-unit id="4dfaf2359aff2ab31c33a3dbf21369953e0929ed" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Can a Redux store lead to a memory leak?</source>
          <target state="translated">スタックオーバーフロー。Reduxストアはメモリリークにつながる?</target>
        </trans-unit>
        <trans-unit id="988abe0fa36c2ebb4e0cbf914b4d5fe269cc989b" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Cleaner/shorter way to update nested state in Redux?</source>
          <target state="translated">スタックオーバーフロー。Redux で入れ子になった状態を更新する、よりクリーンで短い方法は?</target>
        </trans-unit>
        <trans-unit id="5b1e48bcacf1979014102c6547e344589cfc1043" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Do events and actions have a 1:1 relationship in Redux?</source>
          <target state="translated">スタックオーバーフロー。Reduxではイベントとアクションは1:1の関係になっていますか?</target>
        </trans-unit>
        <trans-unit id="ebddfda346f9cc1931bdaef9cad513e27fe3e4da" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How does Redux deal with deeply nested models?</source>
          <target state="translated">スタックオーバーフロー。Reduxはどのように深く入れ子になったモデルを扱うのですか?</target>
        </trans-unit>
        <trans-unit id="94b70dfefdce48458a92962024bd2e39922329c0" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to dispatch a Redux action with a timeout?</source>
          <target state="translated">スタックオーバーフロー。タイムアウトを使ってReduxアクションをディスパッチするには?</target>
        </trans-unit>
        <trans-unit id="b44a8af5f0a70fd30e935dc3f76e87f077627bbd" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to fire AJAX calls in response to the state changes with Redux?</source>
          <target state="translated">スタックオーバーフロー。Reduxで状態の変化に反応してAJAXコールを発射するには?</target>
        </trans-unit>
        <trans-unit id="3e47386ec6016dd7f3fc367e6cffa3cf96cda35c" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to get simple dispatch from this.props using connect w/ Redux?</source>
          <target state="translated">スタックオーバーフロー。connect w/Reduxを使ってthis.propsから簡単なディスパッチを取得するには?</target>
        </trans-unit>
        <trans-unit id="2165fe78c71949f8e9b453c57e11f6841bdc5b4c" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to handle complex side-effects in Redux?</source>
          <target state="translated">スタックオーバーフロー。Reduxで複雑な副作用を扱うには?</target>
        </trans-unit>
        <trans-unit id="28f22a2146692414a69f910d533939bac7f855eb" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to handle tree-shaped entities in Redux reducers?</source>
          <target state="translated">スタックオーバーフロー。Redux のレデューサでツリー型のエンティティを扱うには?</target>
        </trans-unit>
        <trans-unit id="9d4b50a3426c2e7c8b83c7f6061b71189fc4ad4d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to optimize small updates to props of nested components in React + Redux?</source>
          <target state="translated">スタックオーバーフロー。React+Reduxでネストされたコンポーネントのpropsに小さな更新を最適化するには?</target>
        </trans-unit>
        <trans-unit id="4d918cb89f55a87fe62b679dfe98194482be59ff" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to optimize small updates to props of nested components?</source>
          <target state="translated">スタックオーバーフロー。ネストされたコンポーネントの小道具に小さなアップデートを最適化するには?</target>
        </trans-unit>
        <trans-unit id="acba72b3df5c830d1b5aba0a48d173bc22d8fc32" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to structure Redux components/containers</source>
          <target state="translated">スタックオーバーフロー。Redux のコンポーネント/コンテナをどのように構成するか</target>
        </trans-unit>
        <trans-unit id="e3eccf206103856b93ecbd37ce4f41620479a06a" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to unit test async Redux actions to mock ajax response</source>
          <target state="translated">スタックオーバーフロー。ajaxレスポンスをモックするためのasync Reduxアクションをユニットテストする方法</target>
        </trans-unit>
        <trans-unit id="4927a93f0a45155d14400120ebde30fcac96c00b" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Is there any way to &quot;commit&quot; the state in Redux to free memory?</source>
          <target state="translated">スタックオーバーフロー。Redux の状態を「コミット」してメモリを解放する方法はありますか?</target>
        </trans-unit>
        <trans-unit id="8a704c1a402b4c7a231139affcc8b80dae9a39bc" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Memory Usage Concern with Controlled Components</source>
          <target state="translated">スタックオーバーフロー。制御されたコンポーネントのメモリ使用量の問題</target>
        </trans-unit>
        <trans-unit id="dee2e567cd35803ebf7a0cd85960b6e1c5f84ae0" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Reducing an entire subtree with redux combineReducers</source>
          <target state="translated">スタックオーバーフロー。redux combineReducers によるサブツリー全体の削減</target>
        </trans-unit>
        <trans-unit id="f5c28dc373c45c187ad94b9e7c8d28a1a1e19e92" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Redux and ALL the application state</source>
          <target state="translated">スタックオーバーフロー。ReduxとALLアプリケーションの状態</target>
        </trans-unit>
        <trans-unit id="c804eaac1de7836c4167b4c7ce22081a3aecc375" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Redux multiple stores, why not?</source>
          <target state="translated">スタックオーバーフロー。Redux複数店舗、なぜダメなのか?</target>
        </trans-unit>
        <trans-unit id="b7e9dc84c7d9700ead6d04e9e5ccc4ca7533584c" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Redux vs plain React?</source>
          <target state="translated">スタックオーバーフロー。Redux とプレーンな React の違いは?</target>
        </trans-unit>
        <trans-unit id="105923b79101b77a45fa4c3b2354a35798f4c76b" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Should I use one or several action types to represent this async action?</source>
          <target state="translated">スタックオーバーフロー。この非同期アクションを表現するには、1つまたは複数のアクションタイプを使うべきでしょうか?</target>
        </trans-unit>
        <trans-unit id="31fdb0827c84ebe2269807c61132bfaba82d6831" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Should actions be handled by reducers to related actions or generated by action creators themselves?</source>
          <target state="translated">スタックオーバーフロー。アクションは関連するアクションへのリデューサによって処理されるべきか、それともアクション作成者自身によって生成されるべきか?</target>
        </trans-unit>
        <trans-unit id="65014c400549c8612072befc0adf72ed3b081d64" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Should all component state be kept in Redux store?</source>
          <target state="translated">スタックオーバーフロー。すべてのコンポーネントの状態は Redux ストアに保持されるべきですか?</target>
        </trans-unit>
        <trans-unit id="b98acfbe9a6b5556936b1fc7e937ef42e8da0b73" translate="yes" xml:space="preserve">
          <source>Stack Overflow: State in Redux app has the name of the reducer</source>
          <target state="translated">スタックオーバーフロー。Redux アプリ内の状態が減速機の名前を持っている</target>
        </trans-unit>
        <trans-unit id="c9bb052748fb6d9f95b232931f6b7ce0b330d741" translate="yes" xml:space="preserve">
          <source>Stack Overflow: State key names and &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">スタックオーバーフロー：状態のキー名と &lt;code&gt;combineReducers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70cc3d889ceeb8e34d6f3922754c47f23bd9be8d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Store initial state and &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">スタックオーバーフロー：初期状態を &lt;code&gt;combineReducers&lt;/code&gt; 、reducerを結合します</target>
        </trans-unit>
        <trans-unit id="6c38c53a8386528fdbcdcab4494d509416d698fc" translate="yes" xml:space="preserve">
          <source>Stack Overflow: What could be the downsides of using Redux instead of Flux?</source>
          <target state="translated">スタックオーバーフロー Fluxの代わりにReduxを使うことのデメリットは何でしょうか?</target>
        </trans-unit>
        <trans-unit id="895ded7294588881bb7fc95054edf3c3db5d4e96" translate="yes" xml:space="preserve">
          <source>Stack Overflow: What is the point of the constants in Redux?</source>
          <target state="translated">スタックオーバーフロー。Redux の定数の意味は?</target>
        </trans-unit>
        <trans-unit id="658846fec2f949984f29281c5ad5f8e0b3afe04d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: When should I add Redux to a React app?</source>
          <target state="translated">スタックオーバーフロー。ReactアプリにReduxを追加するタイミングは?</target>
        </trans-unit>
        <trans-unit id="49f9fa997616236334bab1f021f4d95a98961d28" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Where should I put synchronous side effects linked to actions in redux?</source>
          <target state="translated">スタックオーバーフロー。アクションにリンクされた同期的な副作用をreduxのどこに置くべきか?</target>
        </trans-unit>
        <trans-unit id="936266740da7540850a532833e6a2df525b2a8b5" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why do we need middleware for async flow in Redux?</source>
          <target state="translated">スタックオーバーフロー。なぜReduxに非同期フロー用のミドルウェアが必要なのか?</target>
        </trans-unit>
        <trans-unit id="9bba3ac3bd12027bb6ac452b12ce38c7e56b122a" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why do you need 'Actions' as data in Redux?</source>
          <target state="translated">スタックオーバーフロー。なぜReduxでは'Actions'がデータとして必要なのか?</target>
        </trans-unit>
        <trans-unit id="18756cef85dbd29ab28641afa6772d3fefa20cc2" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why is state all in one place, even state that isn't global?</source>
          <target state="translated">スタックオーバーフロー。グローバルではないステートであっても、なぜステートは一か所にまとめてあるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="7d2d7c0b7e20393e0c17c7eab1c82b6b5fc50426" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why should I use Redux in this example?</source>
          <target state="translated">スタックオーバーフロー。なぜこの例で Redux を使う必要があるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="a0364f6c9c8a113f92fdf913bbb551039a9724ed" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why use Redux over Facebook Flux?</source>
          <target state="translated">スタックオーバーフロー。なぜFacebook FluxよりもReduxを使うのか?</target>
        </trans-unit>
        <trans-unit id="10aa1b0c136f369eeefa163ced6c37c7c591e72e" translate="yes" xml:space="preserve">
          <source>Stack Overflow: can a dumb component use a Redux container?</source>
          <target state="translated">Stack Overflow:ダムコンポーネントはReduxコンテナを使えるのか?</target>
        </trans-unit>
        <trans-unit id="4b161211956de081a873933a4c8a044abab7e0fb" translate="yes" xml:space="preserve">
          <source>Standard Approaches</source>
          <target state="translated">標準的なアプローチ</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="d587c099b9773435ddc0261ea9851ea406674dcf" translate="yes" xml:space="preserve">
          <source>State is read-only</source>
          <target state="translated">状態は読み取り専用</target>
        </trans-unit>
        <trans-unit id="88bdda40b1f54211bc74c1e437fac5cd7bd92718" translate="yes" xml:space="preserve">
          <source>Still, this isn't nice.</source>
          <target state="translated">それにしても、これは良くないですね。</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="6bd6be2595d77f48a33fbcd6f117fa074b3dc576" translate="yes" xml:space="preserve">
          <source>Store API</source>
          <target state="translated">ストアAPI</target>
        </trans-unit>
        <trans-unit id="2ae5ce622a7b9cf0a55280ae39f15ebca3636999" translate="yes" xml:space="preserve">
          <source>Store Methods</source>
          <target state="translated">ストアメソッド</target>
        </trans-unit>
        <trans-unit id="755c0688d517f4d1f3befaef9cbffed1a12611b7" translate="yes" xml:space="preserve">
          <source>Store Setup</source>
          <target state="translated">ストアセットアップ</target>
        </trans-unit>
        <trans-unit id="46284619675b8370e43c07e07ae7f90f0dc58a68" translate="yes" xml:space="preserve">
          <source>Store creator</source>
          <target state="translated">ストアクリエーター</target>
        </trans-unit>
        <trans-unit id="8ce0b798e0d4896a15608877012298d37342e347" translate="yes" xml:space="preserve">
          <source>Store enhancer</source>
          <target state="translated">ストアエンハンサー</target>
        </trans-unit>
        <trans-unit id="e142a8c534381fae47d56a5e16a0f2235b158282" translate="yes" xml:space="preserve">
          <source>Store enhancers are much the same concept as higher-order components in React, which are also occasionally called &amp;ldquo;component enhancers&amp;rdquo;.</source>
          <target state="translated">ストアエンハンサーは、Reactの高次コンポーネントとほとんど同じ概念で、「コンポーネントエンハンサー」と呼ばれることもあります。</target>
        </trans-unit>
        <trans-unit id="9416c1d5086bab5c721ad43af63fa3ab63c0a122" translate="yes" xml:space="preserve">
          <source>Store#dispatch()</source>
          <target state="translated">Store#dispatch()</target>
        </trans-unit>
        <trans-unit id="114eacc705a7df0e8c46ba7b192ea5316ba2c4ac" translate="yes" xml:space="preserve">
          <source>Store#getState()</source>
          <target state="translated">Store#getState()</target>
        </trans-unit>
        <trans-unit id="df99ee9fbf8a2efc5c7ed00b4492bf6b553163b9" translate="yes" xml:space="preserve">
          <source>Store#replaceReducer()</source>
          <target state="translated">Store#replaceReducer()</target>
        </trans-unit>
        <trans-unit id="013d0660eaa2690e6a9f899d36b23e021b36d850" translate="yes" xml:space="preserve">
          <source>Store#subscribe()</source>
          <target state="translated">Store#subscribe()</target>
        </trans-unit>
        <trans-unit id="71b541e49eef296d8df0cc8c719be0338a66cc03" translate="yes" xml:space="preserve">
          <source>Storing a single definition for a given item</source>
          <target state="translated">与えられた項目の単一の定義を保存する</target>
        </trans-unit>
        <trans-unit id="92eb6223892f134972ff80efa523a2000d6d1189" translate="yes" xml:space="preserve">
          <source>Structuring Reducers</source>
          <target state="translated">レデューサーの構造化</target>
        </trans-unit>
        <trans-unit id="2ff01fd753f588ce2cd880cdb10c47db54dde5a5" translate="yes" xml:space="preserve">
          <source>Subscribe to Redux state</source>
          <target state="translated">Reduxの状態を購読する</target>
        </trans-unit>
        <trans-unit id="a54bde2350739858cdd0b5bc888eeb8620d23e6e" translate="yes" xml:space="preserve">
          <source>Such a dependency renders the component impure, makes testing the component more difficult, and makes reusing and refactoring the component unnecessarily difficult.</source>
          <target state="translated">このような依存関係は、コンポーネントを不純にし、コンポーネントのテストをより困難にし、コンポーネントの再利用やリファクタリングを不必要に困難にします。</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="0fe97fb0406402fb59fa412b3bbeb9b60ac9262c" translate="yes" xml:space="preserve">
          <source>Synchronous Action Creators</source>
          <target state="translated">同期アクションクリエイター</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">目次</target>
        </trans-unit>
        <trans-unit id="15c674d7738210d0c5965059a30efc2059314bf7" translate="yes" xml:space="preserve">
          <source>Talks</source>
          <target state="translated">Talks</target>
        </trans-unit>
        <trans-unit id="2b65f913df556f349b0a7873cfdb7a6a8dd462a1" translate="yes" xml:space="preserve">
          <source>Task-Based Updates</source>
          <target state="translated">タスクベースの更新</target>
        </trans-unit>
        <trans-unit id="d95c7170ec15da472e1fc16a1b3628b7692d766d" translate="yes" xml:space="preserve">
          <source>Technically we could split it into two components but it might be too early at this stage. It's fine to mix presentation and logic in a component that is very small. As it grows, it will be more obvious how to split it, so we'll leave it mixed.</source>
          <target state="translated">技術的には2つのコンポーネントに分けることもできますが、現段階では早すぎるかもしれません。プレゼンとロジックが混在していても良いのですが、非常に小さなコンポーネントです。成長するにつれ、どうやって分割すればいいのかが明確になってくると思うので、混ぜたままにしておきます。</target>
        </trans-unit>
        <trans-unit id="97405b706d923beb562a978445f95da1784f550e" translate="yes" xml:space="preserve">
          <source>Technically you could write the container components by hand using &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;store.subscribe()&lt;/code&gt;&lt;/a&gt;. We don't advise you to do this because React Redux makes many performance optimizations that are hard to do by hand. For this reason, rather than write container components, we will generate them using the &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; function provided by React Redux, as you will see below.</source>
          <target state="translated">技術的には、&lt;a href=&quot;../api/store#subscribe&quot;&gt; &lt;code&gt;store.subscribe()&lt;/code&gt; &lt;/a&gt;を使用して手動でコンテナコンポーネントを記述できます。React Reduxは手動で行うのが難しい多くのパフォーマンス最適化を行うため、これを行うことはお勧めしません。このため、以下に示すように、コンテナーコンポーネントを作成するのではなく、React Reduxが提供&lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt;関数を使用してコンポーネントを生成します。</target>
        </trans-unit>
        <trans-unit id="2c2cd2ae8ff170115855201664f8bc10a106aa1d" translate="yes" xml:space="preserve">
          <source>Testimonials</source>
          <target state="translated">Testimonials</target>
        </trans-unit>
        <trans-unit id="97cba4858411c435e526dd651157aac20178222c" translate="yes" xml:space="preserve">
          <source>Thanks</source>
          <target state="translated">Thanks</target>
        </trans-unit>
        <trans-unit id="09191f5d1ae35f788275b3791134e5c6cc9695f6" translate="yes" xml:space="preserve">
          <source>That function is fairly short, but already becoming overly complex. We're dealing with two different areas of concern (filtering vs managing our list of todos), the nesting is making the update logic harder to read, and it's not exactly clear what's going on everywhere.</source>
          <target state="translated">この関数はかなり短いですが、すでに複雑になりすぎています。懸念される2つの異なる領域(フィルタリングとToDoリストの管理)に対応していること、入れ子になっていることで更新ロジックが読みにくくなっていること、そしてどこで何が起こっているのか正確にはわからないこと。</target>
        </trans-unit>
        <trans-unit id="532f0a532fc0a678855d599bf7ec4ac18d1963d4" translate="yes" xml:space="preserve">
          <source>That reduced the duplication and made things a bit easier to read.</source>
          <target state="translated">そのおかげで重複が減り、少し見やすくなりました。</target>
        </trans-unit>
        <trans-unit id="3d029300dc585308627967e2bccdc91655721462" translate="yes" xml:space="preserve">
          <source>That said, Redux works especially well with libraries like &lt;a href=&quot;http://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; and &lt;a href=&quot;https://github.com/dekujs/deku&quot;&gt;Deku&lt;/a&gt; because they let you describe UI as a function of state, and Redux emits state updates in response to actions.</source>
          <target state="translated">とは言っても、Reduxは、&lt;a href=&quot;http://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;や&lt;a href=&quot;https://github.com/dekujs/deku&quot;&gt;Deku&lt;/a&gt;などのライブラリで特にうまく機能します。これは、UIを状態の関数として記述でき、Reduxがアクションに応じて状態の更新を発行するためです。</target>
        </trans-unit>
        <trans-unit id="ba443c628e5456614af4a08cbb732b49948515da" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s perfectly OK when you mutate the copy, but in the context of a reducer, if you return a copy that &lt;em&gt;hasn&amp;rsquo;t&lt;/em&gt; been mutated, Redux&amp;rsquo;s &lt;code&gt;combineReducers&lt;/code&gt; function will still think that the state needs to be updated, as you're returning an entirely different object from the state slice object that was passed in.</source>
          <target state="translated">コピーを変更する場合&lt;em&gt;は問題ありません&lt;/em&gt;が、レデューサーのコンテキストでは、変更され&lt;em&gt;ていない&lt;/em&gt;コピーを返す場合、完全に返すため、Reduxの &lt;code&gt;combineReducers&lt;/code&gt; 関数は状態を更新する必要があると見なします。渡された状態スライスオブジェクトとは異なるオブジェクト。</target>
        </trans-unit>
        <trans-unit id="e93f4cf2c16977aa0828b84202ee64df60519c65" translate="yes" xml:space="preserve">
          <source>That's it!</source>
          <target state="translated">それだ!</target>
        </trans-unit>
        <trans-unit id="695a585b3252ff564ab700e0286c7c4e8dfbd47b" translate="yes" xml:space="preserve">
          <source>That's it! Now any actions dispatched to the store instance will flow through &lt;code&gt;logger&lt;/code&gt; and &lt;code&gt;crashReporter&lt;/code&gt;:</source>
          <target state="translated">それでおしまい！これで、ストアインスタンスにディスパッチされたすべてのアクションは、 &lt;code&gt;logger&lt;/code&gt; と &lt;code&gt;crashReporter&lt;/code&gt; を通過します。</target>
        </trans-unit>
        <trans-unit id="62c0daeb24847642ed1a353245f2da0b5ca7faa7" translate="yes" xml:space="preserve">
          <source>That's it! Now you know what Redux is all about.</source>
          <target state="translated">それだよ!これでReduxが何のためにあるのかがわかりましたね。</target>
        </trans-unit>
        <trans-unit id="9c632b918c1b5cb3e6e028274046e1a0dbd5fac5" translate="yes" xml:space="preserve">
          <source>The 5 Types of React Application State</source>
          <target state="translated">Reactアプリケーションの状態の5つのタイプ</target>
        </trans-unit>
        <trans-unit id="8082f45d35153e13c48e541bd18a7f65d42e1b2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/tommikaikkonen/redux-orm&quot;&gt;Redux-ORM&lt;/a&gt; library provides a very useful abstraction layer for managing normalized data in a Redux store. It allows you to declare Model classes and define relations between them. It can then generate the empty &quot;tables&quot; for your data types, act as a specialized selector tool for looking up the data, and perform immutable updates on that data.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tommikaikkonen/redux-orm&quot;&gt;Reduxの-ORMの&lt;/a&gt;ライブラリはReduxのストアに正規化されたデータを管理するための非常に有用な抽象化レイヤを提供します。これにより、Modelクラスを宣言し、それらの間の関係を定義できます。次に、データ型の空の「テーブル」を生成し、データを検索するための特殊なセレクターツールとして機能し、そのデータに対して不変の更新を実行します。</target>
        </trans-unit>
        <trans-unit id="a1c005dfb17d1e5ad9227170c4331db15898fd97" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reducers#reducers-share-state&quot;&gt;suggested structure&lt;/a&gt; for a Redux store is to split the state object into multiple &quot;slices&quot; or &quot;domains&quot; by key, and provide a separate reducer function to manage each individual data slice.</source>
          <target state="translated">Reduxストアの&lt;a href=&quot;reducers#reducers-share-state&quot;&gt;推奨構造&lt;/a&gt;は、状態オブジェクトをキーによって複数の「スライス」または「ドメイン」に分割し、個々のデータスライスを管理するための個別のリデューサー関数を提供することです。</target>
        </trans-unit>
        <trans-unit id="b9a0e951a049ef97cd89a4e10f26e1e463b189ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;store&quot;&gt;store&lt;/a&gt; will pass two arguments to the &lt;a href=&quot;reducers&quot;&gt;reducer&lt;/a&gt;: the current state tree and the action. For example, in the todo app, the root reducer might receive something like this:</source>
          <target state="translated">&lt;a href=&quot;store&quot;&gt;ストアは、&lt;/a&gt; 2つの引数を渡します&lt;a href=&quot;reducers&quot;&gt;減速&lt;/a&gt;：現在の状態ツリーとアクションを。たとえば、todoアプリでは、ルートリデューサーは次のようなものを受け取る可能性があります。</target>
        </trans-unit>
        <trans-unit id="738fb16f4a3da86b179b5fd2928c5cc0c8706445" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combineReducers&lt;/code&gt; helper function turns an object whose values are different reducing functions into a single reducing function you can pass to &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; のヘルパー関数は、値があなたに渡すことができ、単一の減少関数に機能を削減異なっているオブジェクトになります&lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a78fbb758be2a28c07a8ce0abb4a2f572f7c0bf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combineReducers&lt;/code&gt; utility included with Redux is very useful, but is deliberately limited to handle a single common use case: updating a state tree that is a plain Javascript object, by delegating the work of updating each slice of state to a specific slice reducer. It does &lt;em&gt;not&lt;/em&gt; handle other use cases, such as a state tree made up of Immutable.js Maps, trying to pass other portions of the state tree as an additional argument to a slice reducer, or performing &quot;ordering&quot; of slice reducer calls. It also does not care how a given slice reducer does its work.</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; の再来に付属のユーティリティは非常に便利ですが、意図的に単一の共通のユースケースを処理するために制限されます。特定のスライス減速に状態の各スライスを更新する作業を委任することで、プレーンなJavaScriptオブジェクトである状態ツリーを更新します。Immutable.jsマップで構成される状態ツリー、スライスレデューサーへの追加の引数として状態ツリーの他の部分を渡そうとしたり、スライスレデューサー呼び出しの「順序付け」を実行したりするなど、他のユースケース&lt;em&gt;は&lt;/em&gt;処理しませ&lt;em&gt;ん&lt;/em&gt;。また、特定のスライスレデューサーがどのように機能するかは関係ありません。</target>
        </trans-unit>
        <trans-unit id="48d1690c6f2d0e9c8b98b4f655fb56dfcdddc0d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connect()&lt;/code&gt; function takes two primary arguments, both optional. The first, &lt;code&gt;mapStateToProps&lt;/code&gt;, is a function you provide to pull data from the store when it changes, and pass those values as props to your component. The second, &lt;code&gt;mapDispatchToProps&lt;/code&gt;, is a function you provide to make use of the store's &lt;code&gt;dispatch&lt;/code&gt; function, usually by creating pre-bound versions of action creators that will automatically dispatch their actions as soon as they are called.</source>
          <target state="translated">&lt;code&gt;connect()&lt;/code&gt; 関数は、2つの主要な引数、両方のオプションを取ります。最初の &lt;code&gt;mapStateToProps&lt;/code&gt; は、変更時にストアからデータをプルし、それらの値をpropsとしてコンポーネントに渡すために提供する関数です。 2番目の &lt;code&gt;mapDispatchToProps&lt;/code&gt; は、ストアの &lt;code&gt;dispatch&lt;/code&gt; 関数を利用するために提供する関数で、通常は、アクションが呼び出されるとすぐにアクションを自動的にディスパッチする、事前にバインドされたバージョンのアクションクリエーターを作成します。</target>
        </trans-unit>
        <trans-unit id="a1f724426f5bed59b6fcff9c426308b18d862500" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dispatch()&lt;/code&gt; function can be accessed directly from the store as &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch()&lt;/code&gt;&lt;/a&gt;, but more likely you'll access it using a helper like &lt;a href=&quot;http://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt;'s &lt;code&gt;connect()&lt;/code&gt;. You can use &lt;a href=&quot;../api/bindactioncreators&quot;&gt;&lt;code&gt;bindActionCreators()&lt;/code&gt;&lt;/a&gt; to automatically bind many action creators to a &lt;code&gt;dispatch()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;dispatch()&lt;/code&gt; 関数は、などの店舗から直接アクセスすることができます&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch()&lt;/code&gt; &lt;/a&gt;が、より多くの可能性が高いようにあなたがヘルパーを使用してアクセスます&lt;a href=&quot;http://github.com/gaearon/react-redux&quot;&gt;-Reduxのは、反応&lt;/a&gt;の &lt;code&gt;connect()&lt;/code&gt; 。&lt;a href=&quot;../api/bindactioncreators&quot;&gt; &lt;code&gt;bindActionCreators()&lt;/code&gt; &lt;/a&gt;を使用して、多くのアクション作成者を &lt;code&gt;dispatch()&lt;/code&gt; 関数に自動的にバインドできます。</target>
        </trans-unit>
        <trans-unit id="0cc5ef634bd494a2bcb0eba3ea9aacd39c49c13b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;distinctState()&lt;/code&gt; filter serves to ignore the actions that didn't result in a state change. There are &lt;a href=&quot;https://github.com/omnidan/redux-undo#configuration&quot;&gt;many other options&lt;/a&gt; to configure your undoable reducer, like setting the action type for Undo and Redo actions.</source>
          <target state="translated">&lt;code&gt;distinctState()&lt;/code&gt; フィルタは、状態変化をもたらさなかったアクションを無視するのに役立ちます。取り消しおよびやり直しアクションのアクションタイプの設定など、取り消し可能なリデューサーを設定する&lt;a href=&quot;https://github.com/omnidan/redux-undo#configuration&quot;&gt;他の多くのオプション&lt;/a&gt;があります。</target>
        </trans-unit>
        <trans-unit id="c7e69fb3a56cc38e559d99f56a4e63839a609eb9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;preloadedState&lt;/code&gt; will then be available on the client side by accessing &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;preloadedState&lt;/code&gt; は、次にアクセスすることにより、クライアント側で利用できるようになります &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="454736cedd126ee22b50a1ed19c0f4bfc6ed98d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;switch&lt;/code&gt; statement is &lt;em&gt;not&lt;/em&gt; the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app).</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 文はあり&lt;em&gt;ません&lt;/em&gt;本当の決まり文句。Fluxの実際のボイラープレートは概念的なものです。更新を発行する必要性、DispatcherにStoreを登録する必要性、Storeをオブジェクトにする必要性（およびユニバーサルアプリが必要なときに発生する複雑さ）。</target>
        </trans-unit>
        <trans-unit id="5dfd028dd21b9e32d0060e5d401ade9a104ea3fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;switch&lt;/code&gt; statement is &lt;em&gt;not&lt;/em&gt; the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app). Redux solves these problems by using pure reducers instead of event emitters.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 文はあり&lt;em&gt;ません&lt;/em&gt;本当の決まり文句。Fluxの実際のボイラープレートは概念的なものです。更新を発行する必要性、DispatcherにStoreを登録する必要性、Storeをオブジェクトにする必要性（およびユニバーサルアプリが必要なときに発生する複雑さ）。Reduxは、イベントエミッターの代わりに純粋なリデューサーを使用してこれらの問題を解決します。</target>
        </trans-unit>
        <trans-unit id="3e916ef3dceacc26ab023c93511c4a41b777908e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Store&lt;/strong&gt; is the object that brings them together. The store has the following responsibilities:</source>
          <target state="translated">&lt;strong&gt;ストアは、&lt;/strong&gt;それらを一緒にもたらしますオブジェクトです。ストアには以下の責任があります。</target>
        </trans-unit>
        <trans-unit id="0dfb0a89f92611bca64f034a94a2f962e4ebd962" translate="yes" xml:space="preserve">
          <source>The Case for Flux</source>
          <target state="translated">フラックスのケース</target>
        </trans-unit>
        <trans-unit id="2be97967a036b4704b556ca385f3d427bc4090d4" translate="yes" xml:space="preserve">
          <source>The Client Side</source>
          <target state="translated">クライアント側</target>
        </trans-unit>
        <trans-unit id="8d8895e86bbb9fcbb32585f22afa4849467be15b" translate="yes" xml:space="preserve">
          <source>The Final Approach</source>
          <target state="translated">最終的なアプローチ</target>
        </trans-unit>
        <trans-unit id="2ec2a8c85e269f721fc1b0c962b89cc607899b26" translate="yes" xml:space="preserve">
          <source>The Gist</source>
          <target state="translated">ジスト</target>
        </trans-unit>
        <trans-unit id="de9191847383c1842749d836c1147436f76724d9" translate="yes" xml:space="preserve">
          <source>The HyperTerm terminal application</source>
          <target state="translated">ハイパーターミナルアプリケーション</target>
        </trans-unit>
        <trans-unit id="d571c123a7cfe23b3bbf561d3957e3c00ed11319" translate="yes" xml:space="preserve">
          <source>The Little Idea of Functional Programming</source>
          <target state="translated">関数型プログラミングの小さなアイデア</target>
        </trans-unit>
        <trans-unit id="dfb1aa70710a03922941317888e0b7cc0c028c48" translate="yes" xml:space="preserve">
          <source>The Power of Higher-Order Reducers</source>
          <target state="translated">高次減速機の力</target>
        </trans-unit>
        <trans-unit id="79913e28740ae0370c83c1b4c15cfb9703563d49" translate="yes" xml:space="preserve">
          <source>The Redux API surface is tiny. Redux defines a set of contracts for you to implement (such as &lt;a href=&quot;../glossary#reducer&quot;&gt;reducers&lt;/a&gt;) and provides a few helper functions to tie these contracts together.</source>
          <target state="translated">Redux APIの表面は小さいです。Reduxは、実装する一連のコントラクト（&lt;a href=&quot;../glossary#reducer&quot;&gt;reducer&lt;/a&gt;など）を定義し、これらのコントラクトを結び付けるいくつかのヘルパー関数を提供します。</target>
        </trans-unit>
        <trans-unit id="a5c1e3f8c2dd5838d397dba36b04c9a62e93369f" translate="yes" xml:space="preserve">
          <source>The Redux reducer API is &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt;, but how you create those reducers is up to you.</source>
          <target state="translated">ReduxレデューサーAPIは &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt; ですが、これらのレデューサーを作成する方法は自由です。</target>
        </trans-unit>
        <trans-unit id="4558623f708d5c23e2aa2461d3125df5fcd82d4a" translate="yes" xml:space="preserve">
          <source>The Redux source code is written in ES2015 but we precompile both CommonJS and UMD builds to ES5 so they work in &lt;a href=&quot;http://caniuse.com/#feat=es5&quot;&gt;any modern browser&lt;/a&gt;. You don't need to use Babel or a module bundler to &lt;a href=&quot;https://github.com/reactjs/redux/blob/master/examples/counter-vanilla/index.html&quot;&gt;get started with Redux&lt;/a&gt;.</source>
          <target state="translated">ReduxのソースコードはES2015で記述されていますが、CommonJSビルドとUMDビルドの両方をES5にプリコンパイルして&lt;a href=&quot;http://caniuse.com/#feat=es5&quot;&gt;、最新のブラウザーで&lt;/a&gt;動作するようにします。&lt;a href=&quot;https://github.com/reactjs/redux/blob/master/examples/counter-vanilla/index.html&quot;&gt;Redux&lt;/a&gt;を使い始めるのに、Babelやモジュールバンドルを使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="ecc1a1a17b3429a96287b0bd69b636f5a14dc84c" translate="yes" xml:space="preserve">
          <source>The Redux-ORM library maintains an internal queue of updates to be applied. Those updates are then applied immutably, simplifying the update process.</source>
          <target state="translated">Redux-ORMライブラリは、適用される更新の内部キューを保持しています。これらの更新は不変的に適用され、更新プロセスを簡素化します。</target>
        </trans-unit>
        <trans-unit id="478f0f344043467133811ff0c84e58dc576376c2" translate="yes" xml:space="preserve">
          <source>The Server Side</source>
          <target state="translated">サーバー側</target>
        </trans-unit>
        <trans-unit id="6a5fcafa1bd7939d8a0603992e21bd96c7692240" translate="yes" xml:space="preserve">
          <source>The Tao of Redux, Part 2 - Practice and Philosophy. Thick and thin reducers.</source>
          <target state="translated">レデュのタオ、その2-実践と哲学。厚かましくも薄かましいレデューサ。</target>
        </trans-unit>
        <trans-unit id="9b46572db1b8dfcd7649cde9229d79fb8affd4f2" translate="yes" xml:space="preserve">
          <source>The actual list of todos.</source>
          <target state="translated">実際のトドのリスト。</target>
        </trans-unit>
        <trans-unit id="5aef95989e50df9f820f46a8576b4cdb580a5dd4" translate="yes" xml:space="preserve">
          <source>The advantage of using the object spread syntax becomes more apparent when you're composing complex objects. Below &lt;code&gt;getAddedIds&lt;/code&gt; maps an array of &lt;code&gt;id&lt;/code&gt; values to an array of objects with values returned from &lt;code&gt;getProduct&lt;/code&gt; and &lt;code&gt;getQuantity&lt;/code&gt;.</source>
          <target state="translated">複雑なオブジェクトを作成する場合、オブジェクトスプレッド構文を使用する利点がより明確になります。以下の &lt;code&gt;getAddedIds&lt;/code&gt; は、 &lt;code&gt;id&lt;/code&gt; 値の配列を、 &lt;code&gt;getProduct&lt;/code&gt; および &lt;code&gt;getQuantity&lt;/code&gt; から返された値を持つオブジェクトの配列にマップします。</target>
        </trans-unit>
        <trans-unit id="1e2c53398d8416bc804266234b36f940f2c701d5" translate="yes" xml:space="preserve">
          <source>The array spread operator in ES6, and the similar object spread operator that is proposed for a future version of JavaScript</source>
          <target state="translated">ES6 の配列拡散演算子と、将来のバージョンの JavaScript で提案されている同様のオブジェクト拡散演算子</target>
        </trans-unit>
        <trans-unit id="e3bc116f9668143f3ac5c44b58f1126b54a0f5a3" translate="yes" xml:space="preserve">
          <source>The articles listed in &lt;a href=&quot;prerequisiteconcepts#immutable-data-management&quot;&gt;Prerequisite Concepts#Immutable Data Management&lt;/a&gt; give a number of good examples for how to perform basic update operations immutably, such as updating a field in an object or adding an item to the end of an array. However, reducers will often need to use those basic operations in combination to perform more complicated tasks. Here are some examples for some of the more common tasks you might have to implement.</source>
          <target state="translated">&lt;a href=&quot;prerequisiteconcepts#immutable-data-management&quot;&gt;前提条件の概念#Immutable Data Managementに&lt;/a&gt;リストされている記事は、オブジェクトのフィールドの更新や配列の最後に項目を追加するなど、基本的な更新操作を不変に実行する方法の多くの良い例を提供します。ただし、レデューサーは、より複雑なタスクを実行するために、これらの基本操作を組み合わせて使用​​する必要があることがよくあります。以下に、実装が必要になる可能性のある一般的なタスクの例をいくつか示します。</target>
        </trans-unit>
        <trans-unit id="6c3850419731a888edfb498c6aaa6ebf75a3a7c1" translate="yes" xml:space="preserve">
          <source>The base dispatch function &lt;em&gt;always&lt;/em&gt; synchronously sends an action to the store's reducer, along with the previous state returned by the store, to calculate a new state. It expects actions to be plain objects ready to be consumed by the reducer.</source>
          <target state="translated">ベースディスパッチ関数は&lt;em&gt;常に&lt;/em&gt;、ストアから返された以前の状態と共に、ストアのレデューサーにアクションを同期的に送信して、新しい状態を計算します。アクションは、レデューサーによって消費される準備ができているプレーンなオブジェクトであると想定しています。</target>
        </trans-unit>
        <trans-unit id="b132326ede652b0ef3bcc14eb28b705253858136" translate="yes" xml:space="preserve">
          <source>The basic concepts of normalizing data are:</source>
          <target state="translated">データの正規化の基本的な考え方は</target>
        </trans-unit>
        <trans-unit id="4e52a5e9fc4db9bd1340d6ab9bc0823d57fe77ab" translate="yes" xml:space="preserve">
          <source>The client side is very straightforward. All we need to do is grab the initial state from &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt;, and pass it to our &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt; function as the initial state.</source>
          <target state="translated">クライアント側は非常に単純です。 &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt; から初期状態を取得し、それを初期状態として&lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt;関数に渡すだけです。</target>
        </trans-unit>
        <trans-unit id="cf2d52f1f096bfa92fc770873878e027f7266621" translate="yes" xml:space="preserve">
          <source>The code reads from the Express &lt;code&gt;Request&lt;/code&gt; object passed into our server middleware. The parameter is parsed into a number and then set in the initial state. If you visit &lt;a href=&quot;http://localhost:3000/?counter=100&quot;&gt;http://localhost:3000/?counter=100&lt;/a&gt; in your browser, you'll see the counter starts at 100. In the rendered HTML, you'll see the counter output as 100 and the &lt;code&gt;__PRELOADED_STATE__&lt;/code&gt; variable has the counter set in it.</source>
          <target state="translated">コードは、サーバーミドルウェアに渡されたExpress &lt;code&gt;Request&lt;/code&gt; オブジェクトから読み取ります。パラメータは数値に解析され、初期状態に設定されます。ブラウザで&lt;a href=&quot;http://localhost:3000/?counter=100&quot;&gt;http：// localhost：3000 /？counter = 100&lt;/a&gt;にアクセスすると、カウンタは100から始まります。レンダリングされたHTMLでは、カウンタ出力が100として表示され、 &lt;code&gt;__PRELOADED_STATE__&lt;/code&gt; 変数にカウンタがありますそれに設定します。</target>
        </trans-unit>
        <trans-unit id="4826495f8f747fbdf0f71e9d47d5be2bf0b9040a" translate="yes" xml:space="preserve">
          <source>The common question, then, is &quot;How can I use &lt;code&gt;combineReducers&lt;/code&gt; to handle these other use cases?&quot;. The answer to that is simply: &quot;you don't - you probably need to use something else&quot;. &lt;strong&gt;Once you go past the core use case for &lt;code&gt;combineReducers&lt;/code&gt;, it's time to use more &quot;custom&quot; reducer logic&lt;/strong&gt;, whether it be specific logic for a one-off use case, or a reusable function that could be widely shared. Here's some suggestions for dealing with a couple of these typical use cases, but feel free to come up with your own approaches.</source>
          <target state="translated">よくある質問は、「 &lt;code&gt;combineReducers&lt;/code&gt; を使用してこれらの他のユースケースを処理するにはどうすればよいですか？」です。それに対する答えは単に「あなたはしません-あなたはおそらく何か他のものを使う必要がある」です。&lt;strong&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;コアユースケースを通過したら、&lt;/strong&gt; 1回限りのユースケースの特定のロジックであろうと、広く共有できる再利用可能な関数であろうと、&lt;strong&gt;より多くの「カスタム」レデューサーロジックを使用する時が&lt;/strong&gt;&lt;strong&gt;来&lt;/strong&gt;ました。これらの典型的な使用例のいくつかを処理するためのいくつかの提案を以下に示しますが、自由に独自のアプローチを考え出してください。</target>
        </trans-unit>
        <trans-unit id="1c5f1c9e6c8f5bdeafe0125ff96ed215a380912f" translate="yes" xml:space="preserve">
          <source>The current suggested best practice is to categorize your components as &amp;ldquo;presentational&amp;rdquo; or &amp;ldquo;container&amp;rdquo; components, and extract a connected container component wherever it makes sense:</source>
          <target state="translated">現在推奨されているベストプラクティスは、コンポーネントを「プレゼンテーション」または「コンテナ」コンポーネントとして分類し、接続されているコンテナコンポーネントを意味のある場所に抽出することです。</target>
        </trans-unit>
        <trans-unit id="89bd096d9d762c82ef72e28c42515ef633264780" translate="yes" xml:space="preserve">
          <source>The currently selected visibility filter;</source>
          <target state="translated">現在選択されている可視化フィルタ。</target>
        </trans-unit>
        <trans-unit id="edf1af83e4170e21d0f26a22f25cf9daa7c8184e" translate="yes" xml:space="preserve">
          <source>The data lifecycle in any Redux app follows these 4 steps:</source>
          <target state="translated">Reduxアプリのデータライフサイクルは、以下の4つのステップに従います。</target>
        </trans-unit>
        <trans-unit id="62b467d39a23989592c09583e8808c4f173188dd" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is to pass through some callback back to your synchronous code. In this case, that will be a function that will reference the response object and send back our rendered HTML to the client. Don't worry, it's not as hard as it may sound.</source>
          <target state="translated">これを行う最も簡単な方法は、同期コードにコールバックを渡すことです。この場合、コールバックはレスポンスオブジェクトを参照し、レンダリングした HTML をクライアントに送り返す関数になります。難しいと思われるかもしれませんが、心配しないでください。</target>
        </trans-unit>
        <trans-unit id="e4ce871b16323b1c0bb886336edf356b3878eb0d" translate="yes" xml:space="preserve">
          <source>The example is a bit long, because it's showing how all the different slice reducers and case reducers fit together. Note the delegation involved here. The &lt;code&gt;postsById&lt;/code&gt; slice reducer delegates the work for this case to &lt;code&gt;addComment&lt;/code&gt;, which inserts the new Comment's ID into the correct Post item. Meanwhile, both the &lt;code&gt;commentsById&lt;/code&gt; and &lt;code&gt;allComments&lt;/code&gt; slice reducers have their own case reducers, which update the Comments lookup table and list of all Comment IDs appropriately.</source>
          <target state="translated">例は少し長くなります。これは、さまざまなスライスレデューサーとケースレデューサーがすべてどのように組み合わされるかを示しているためです。ここに含まれる委任に注意してください。 &lt;code&gt;postsById&lt;/code&gt; スライス減速委譲に、この場合の作業 &lt;code&gt;addComment&lt;/code&gt; 正しいポスト項目に新しいコメントのIDを挿入し、。一方、 &lt;code&gt;commentsById&lt;/code&gt; と &lt;code&gt;allComments&lt;/code&gt; スライスリデューサーの両方に独自のケースリデューサーがあり、コメントルックアップテーブルとすべてのコメントIDのリストを適切に更新します。</target>
        </trans-unit>
        <trans-unit id="779dfe0ad26c982a1de5c2e0e8649831bf366e55" translate="yes" xml:space="preserve">
          <source>The examples in this section require React Redux v4.3.0 or greater</source>
          <target state="translated">このセクションの例では、React Redux v4.3.0 以上が必要です。</target>
        </trans-unit>
        <trans-unit id="e75214fea4fb1a9ffce832f2c35732c7381684ab" translate="yes" xml:space="preserve">
          <source>The examples use React, but you should still find them useful if you use something else.</source>
          <target state="translated">例はReactを使用していますが、他のものを使用していても役に立つはずです。</target>
        </trans-unit>
        <trans-unit id="5ea635408bd084da5b7ab91bad09e779b2cf750c" translate="yes" xml:space="preserve">
          <source>The extra re-renders could be resolved by saving the array of objects into the state using a reducer, caching the mapped array using &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt;, or implementing &lt;code&gt;shouldComponentUpdate&lt;/code&gt; in the component by hand and doing a more in-depth props comparison using a function such as &lt;code&gt;_.isEqual&lt;/code&gt;. Be careful to not make your custom &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; more expensive than the rendering itself! Always use a profiler to check your assumptions about performance.</source>
          <target state="translated">余分な再レンダリング使用してマッピングされた配列をキャッシュ、減速機を使用して状態にオブジェクトの配列を保存することによって解決することができる&lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;再選択を&lt;/a&gt;、または実施 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; のような機能を用いて手で成分およびより詳細な小道具の比較を行います &lt;code&gt;_.isEqual&lt;/code&gt; 。カスタム &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; をレンダリング自体よりも高価にしないように注意してください！常にプロファイラーを使用して、パフォーマンスに関する想定を確認してください。</target>
        </trans-unit>
        <trans-unit id="0da3ed8f89bdb310cc912494206553bc1426d386" translate="yes" xml:space="preserve">
          <source>The fact that we hide it inside the library doesn't alter this fact.</source>
          <target state="translated">図書館の中に隠したからといって、その事実が変わるわけではありません。</target>
        </trans-unit>
        <trans-unit id="1de0392a7f8331d8c01e93cc6658a1acbeb1d36b" translate="yes" xml:space="preserve">
          <source>The final step on the server side is to inject our initial component HTML and initial state into a template to be rendered on the client side. To pass along the state, we add a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag that will attach &lt;code&gt;preloadedState&lt;/code&gt; to &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt;.</source>
          <target state="translated">サーバー側での最後のステップは、初期コンポーネントのHTMLと初期状態をテンプレートに挿入して、クライアント側でレンダリングすることです。状態に沿って渡すために、我々は、追加 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 添付するタグ &lt;code&gt;preloadedState&lt;/code&gt; をする &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dba272babae41e9f815da394011efbc9abd976d3" translate="yes" xml:space="preserve">
          <source>The first thing that we need to do on every request is create a new Redux store instance. The only purpose of this store instance is to provide the initial state of our application.</source>
          <target state="translated">すべてのリクエストに対して最初に行う必要があることは、新しい Redux ストアインスタンスを作成することです。このストアインスタンスの唯一の目的は、アプリケーションの初期状態を提供することです。</target>
        </trans-unit>
        <trans-unit id="437ff180e90b483ac82f3a0b997133834d4da2f7" translate="yes" xml:space="preserve">
          <source>The first time the reducer is called, the &lt;code&gt;state&lt;/code&gt; value will be &lt;code&gt;undefined&lt;/code&gt;. The reducer needs to handle this case by supplying a default state value before handling the incoming action.</source>
          <target state="translated">リデューサーが初めて呼び出されたとき、 &lt;code&gt;state&lt;/code&gt; 値は &lt;code&gt;undefined&lt;/code&gt; になります。リデューサーは、着信アクションを処理する前にデフォルトの状態値を提供して、このケースを処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="3a95e0198d37edafccaeec5cfcad513398e60156" translate="yes" xml:space="preserve">
          <source>The fix is to call &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; method on the &lt;a href=&quot;api/store&quot;&gt;store&lt;/a&gt; instance:</source>
          <target state="translated">修正は、&lt;a href=&quot;api/store&quot;&gt;ストア&lt;/a&gt;インスタンスで&lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことです。</target>
        </trans-unit>
        <trans-unit id="9cbc5ae45e711e0e52c905a6773d8d1b1935dc93" translate="yes" xml:space="preserve">
          <source>The fixed code looks like this:</source>
          <target state="translated">固定コードはこんな感じです。</target>
        </trans-unit>
        <trans-unit id="023789ed8635b6b65d05d6a4ac33fe464c661c24" translate="yes" xml:space="preserve">
          <source>The following is the outline for what our server side is going to look like. We are going to set up an &lt;a href=&quot;http://expressjs.com/guide/using-middleware.html&quot;&gt;Express middleware&lt;/a&gt; using &lt;a href=&quot;http://expressjs.com/api.html#app.use&quot;&gt;app.use&lt;/a&gt; to handle all requests that come in to our server. If you're unfamiliar with Express or middleware, just know that our handleRender function will be called every time the server receives a request.</source>
          <target state="translated">以下は、サーバー側の外観の概要です。サーバーに&lt;a href=&quot;http://expressjs.com/api.html#app.use&quot;&gt;送ら&lt;/a&gt;れるすべてのリクエストを処理するために、app.useを使用して&lt;a href=&quot;http://expressjs.com/guide/using-middleware.html&quot;&gt;Expressミドルウェア&lt;/a&gt;をセットアップします。Expressやミドルウェアに慣れていない場合は、サーバーがリクエストを受信するたびに、handleRender関数が呼び出されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4316b779bf18bece5b0ccea09756426fce5c6d7c" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt; that ships with Redux is similar, but &lt;strong&gt;different in three important aspects&lt;/strong&gt;:</source>
          <target state="translated">Redux に&lt;a href=&quot;../api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware()&lt;/code&gt; &lt;/a&gt;されているapplyMiddleware（）の実装は似てい&lt;strong&gt;ますが、3つの重要な点&lt;/strong&gt;が&lt;strong&gt;異なります&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="a9eb650209f72859301cebd361ec76ff3db6f6bc" translate="yes" xml:space="preserve">
          <source>The initial state is zero. Why? Because the second argument to &lt;code&gt;createStore&lt;/code&gt; was &lt;code&gt;undefined&lt;/code&gt;. This is the &lt;code&gt;state&lt;/code&gt; passed to your reducer the first time. When Redux initializes it dispatches a &quot;dummy&quot; action to fill the state. So your &lt;code&gt;counter&lt;/code&gt; reducer was called with &lt;code&gt;state&lt;/code&gt; equal to &lt;code&gt;undefined&lt;/code&gt;. &lt;strong&gt;This is exactly the case that &quot;activates&quot; the default argument.&lt;/strong&gt; Therefore, &lt;code&gt;state&lt;/code&gt; is now &lt;code&gt;0&lt;/code&gt; as per the default &lt;code&gt;state&lt;/code&gt; value (&lt;code&gt;state = 0&lt;/code&gt;). This state (&lt;code&gt;0&lt;/code&gt;) will be returned.</source>
          <target state="translated">初期状態はゼロです。どうして？ &lt;code&gt;createStore&lt;/code&gt; の2番目の引数が &lt;code&gt;undefined&lt;/code&gt; だったためです。これは、初めてレデューサーに渡される &lt;code&gt;state&lt;/code&gt; です。 Reduxが初期化されると、状態を埋めるための「ダミー」アクションがディスパッチされます。したがって、 &lt;code&gt;counter&lt;/code&gt; レデューサーは、 &lt;code&gt;state&lt;/code&gt; が &lt;code&gt;undefined&lt;/code&gt; に等しい状態で呼び出されました。&lt;strong&gt;これは、デフォルトの引数を「アクティブ化」する場合とまったく同じです。&lt;/strong&gt;したがって、 &lt;code&gt;state&lt;/code&gt; はデフォルトの &lt;code&gt;state&lt;/code&gt; 値（ &lt;code&gt;state = 0&lt;/code&gt; ）に従って &lt;code&gt;0&lt;/code&gt; になります。この状態（ &lt;code&gt;0&lt;/code&gt; ）が返されます。</target>
        </trans-unit>
        <trans-unit id="f1870e4c91c65906a132e8ab3a09c561bb5d7c0e" translate="yes" xml:space="preserve">
          <source>The interesting part here is that it does not matter whether we want to keep an undo stack of numbers, strings, arrays, or objects. The structure will always be the same:</source>
          <target state="translated">ここで興味深いのは、数値、文字列、配列、オブジェクトのいずれのスタックを元に戻すかは問題ではないということです。構造は常に同じになります。</target>
        </trans-unit>
        <trans-unit id="aced1e5fb79ae68b6eba1085040abdf61e8e93fd" translate="yes" xml:space="preserve">
          <source>The invoke function runs our middleware in the same way Redux does.</source>
          <target state="translated">invoke 関数は Redux と同じようにミドルウェアを実行します。</target>
        </trans-unit>
        <trans-unit id="d2e2db63b16b97293e72fee9e740a81bd129896c" translate="yes" xml:space="preserve">
          <source>The key step in server side rendering is to render the initial HTML of our component &lt;em&gt;&lt;strong&gt;before&lt;/strong&gt;&lt;/em&gt; we send it to the client side. To do this, we use &lt;a href=&quot;https://facebook.github.io/react/docs/react-dom-server.html#rendertostring&quot;&gt;ReactDOMServer.renderToString()&lt;/a&gt;.</source>
          <target state="translated">サーバー側レンダリングの重要なステップは、コンポーネントの初期HTMLをクライアント側に送信する&lt;em&gt;&lt;strong&gt;前&lt;/strong&gt;&lt;/em&gt;にレンダリングすることです。これを行うには、&lt;a href=&quot;https://facebook.github.io/react/docs/react-dom-server.html#rendertostring&quot;&gt;ReactDOMServer.renderToString（）&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="ebf3991556cfed7c3eed26e9a4ebee92564c0c2e" translate="yes" xml:space="preserve">
          <source>The key to updating nested data is &lt;strong&gt;that &lt;em&gt;every&lt;/em&gt; level of nesting must be copied and updated appropriately&lt;/strong&gt;. This is often a difficult concept for those learning Redux, and there are some specific problems that frequently occur when trying to update nested objects. These lead to accidental direct mutation, and should be avoided.</source>
          <target state="translated">ネストされたデータを更新する鍵は&lt;strong&gt;、&lt;em&gt;&lt;/em&gt;&lt;/strong&gt;ネストの&lt;strong&gt;&lt;em&gt;すべての&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;レベルを適切にコピーおよび更新する必要があること&lt;/strong&gt;です。これはReduxを学ぶ人にとってはしばしば難しい概念であり、ネストされたオブジェクトを更新しようとするときに頻繁に発生する特定の問題があります。これらは偶発的な直接変異につながるため、回避する必要があります。</target>
        </trans-unit>
        <trans-unit id="a1f13b41716a56d3a6b663d8adeef0fbfebcd6da" translate="yes" xml:space="preserve">
          <source>The list of action types that were added, removed, and changed in a Pull Request helps everyone on the team keep track of scope and implementation of new features.</source>
          <target state="translated">プルリクエストで追加、削除、変更されたアクションタイプのリストは、チームの全員が新機能のスコープと実装を把握するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="7a909efdb80760679c43fc5e7380d281a27aa83b" translate="yes" xml:space="preserve">
          <source>The listener should not expect to see all state changes, as the state might have been updated multiple times during a nested &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; before the listener is called. It is, however, guaranteed that all subscribers registered before the &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; started will be called with the latest state by the time it exits.</source>
          <target state="translated">ネスト&lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;れたdispatch（）中にリスナーが呼び出される前に状態が複数回更新された可能性があるため、リスナーはすべての状態変化を確認する必要はありません。ただし、&lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;が開始する前に登録されたすべてのサブスクライバーは、終了するまでに最新の状態で呼び出されることが保証されています。</target>
        </trans-unit>
        <trans-unit id="dfc2ce49bb9fba9f11cb4c299cb527330ef38e0b" translate="yes" xml:space="preserve">
          <source>The listener should only call &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; either in response to user actions or under specific conditions (e. g. dispatching an action when the store has a specific field). Calling &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; without any conditions is technically possible, however it leads to an infinite loop as every &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call usually triggers the listener again.</source>
          <target state="translated">リスナーは、ユーザーアクションへの応答または特定の条件下（たとえば、ストアに特定のフィールドがある場合のアクションのディスパッチ&lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;のみdispatch（）を呼び出す必要があります。条件なしで&lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;を呼び出すことは技術的に可能ですが、通常、すべての&lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;呼び出しがリスナーを再びトリガーするため、無限ループにつながります。</target>
        </trans-unit>
        <trans-unit id="f1a0911c22c72f7c2742cacaf4dc763e35a23b3f" translate="yes" xml:space="preserve">
          <source>The logic for retrieving or updating a given item is now fairly simple and consistent. Given an item's type and its ID, we can directly look it up in a couple simple steps, without having to dig through other objects to find it.</source>
          <target state="translated">与えられたアイテムを検索したり更新したりするロジックが、かなりシンプルで一貫性のあるものになりました。アイテムのタイプとIDが与えられれば、他のオブジェクトを探し回ることなく、2、3の簡単なステップでそれを直接調べることができます。</target>
        </trans-unit>
        <trans-unit id="ea3c8144b116952a7e48b511c8b6726d8e7f3ef8" translate="yes" xml:space="preserve">
          <source>The middleware that interprets such actions could look like this:</source>
          <target state="translated">このようなアクションを解釈するミドルウェアは、次のようになります。</target>
        </trans-unit>
        <trans-unit id="d682e36630596f87baf92e1be74cab220ee7bbc6" translate="yes" xml:space="preserve">
          <source>The most common issue with server side rendering is dealing with state that comes in asynchronously. Rendering on the server is synchronous by nature, so it's necessary to map any asynchronous fetches into a synchronous operation.</source>
          <target state="translated">サーバーサイドのレンダリングで最も一般的な問題は、非同期に入ってくるステートを扱うことです。サーバー上でのレンダリングは本質的に同期的なものなので、非同期フェッチを同期操作にマッピングする必要があります。</target>
        </trans-unit>
        <trans-unit id="8bd487c6f173028a7534d7c66f721bcbc1a7152f" translate="yes" xml:space="preserve">
          <source>The most common state shape for a Redux app is a plain Javascript object containing &quot;slices&quot; of domain-specific data at each top-level key. Similarly, the most common approach to writing reducer logic for that state shape is to have &quot;slice reducer&quot; functions, each with the same &lt;code&gt;(state, action)&lt;/code&gt; signature, and each responsible for managing all updates to that specific slice of state. Multiple slice reducers can respond to the same action, independently update their own slice as needed, and the updated slices are combined into the new state object.</source>
          <target state="translated">Reduxアプリの最も一般的な状態の形は、各トップレベルのキーにドメイン固有のデータの「スライス」を含むプレーンなJavaScriptオブジェクトです。同様に、その状態形状のレデューサーロジックを記述する最も一般的なアプローチは、「スライスレデューサー」関数を使用することです。それぞれに同じ &lt;code&gt;(state, action)&lt;/code&gt; シグネチャがあり、それぞれが特定の状態スライスへのすべての更新を管理します。複数のスライスレデューサーが同じアクションに応答し、必要に応じて独自のスライスを個別に更新し、更新されたスライスが新しい状態オブジェクトに結合されます。</target>
        </trans-unit>
        <trans-unit id="93bd18e049d16d78b6a4f2d8ab6b83aaccc924a2" translate="yes" xml:space="preserve">
          <source>The most common use case for middleware is to support asynchronous actions without much boilerplate code or a dependency on a library like &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS&quot;&gt;Rx&lt;/a&gt;. It does so by letting you dispatch &lt;a href=&quot;../glossary#async-action&quot;&gt;async actions&lt;/a&gt; in addition to normal actions.</source>
          <target state="translated">ミドルウェアの最も一般的な使用例は、ボイラープレートコードや&lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS&quot;&gt;Rx&lt;/a&gt;などのライブラリに依存することなく、非同期アクションをサポートすることです。これは、通常のアクションに加えて&lt;a href=&quot;../glossary#async-action&quot;&gt;非同期アクション&lt;/a&gt;をディスパッチできるようにすることで実現します。</target>
        </trans-unit>
        <trans-unit id="5ca5c9f8c9076592f848e34b0f4212ad6547c204" translate="yes" xml:space="preserve">
          <source>The most common use case for server-side rendering is to handle the &lt;em&gt;initial render&lt;/em&gt; when a user (or search engine crawler) first requests our app. When the server receives the request, it renders the required component(s) into an HTML string, and then sends it as a response to the client. From that point on, the client takes over rendering duties.</source>
          <target state="translated">サーバー側レンダリングの最も一般的な使用例は、ユーザー（または検索エンジンクローラー）が最初にアプリをリクエストしたときに&lt;em&gt;初期レンダリング&lt;/em&gt;を処理することです。サーバーは要求を受信すると、必要なコンポーネントをHTML文字列にレンダリングし、それを応答としてクライアントに送信します。その時点から、クライアントはレンダリング作業を引き継ぎます。</target>
        </trans-unit>
        <trans-unit id="24ae76922e0a16060847d467d7cc8498c8e8fd41" translate="yes" xml:space="preserve">
          <source>The most na&amp;iuml;ve solution is just to log the action and the next state yourself every time you call &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch(action)&lt;/code&gt;&lt;/a&gt;. It's not really a solution, but just a first step towards understanding the problem.</source>
          <target state="translated">最も&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch(action)&lt;/code&gt; &lt;/a&gt;な解決策は、store.dispatch（action）を呼び出すたびに、アクションと次の状態を自分で記録することです。これは実際の解決策ではなく、問題を理解するための最初のステップにすぎません。</target>
        </trans-unit>
        <trans-unit id="c28210a81ca17cd5297b553285382ceab58a3637" translate="yes" xml:space="preserve">
          <source>The new Counter Vanilla example is aimed to dispel the myth that Redux requires Webpack, React, hot reloading, sagas, action creators, constants, Babel, npm, CSS modules, decorators, fluent Latin, an Egghead subscription, a PhD, or an Exceeds Expectations O.W.L. level.</source>
          <target state="translated">新しい Counter Vanilla の例は、Redux には Webpack、React、ホットリロード、サガ、アクションクリエイター、定数、Babel、npm、CSS モジュール、デコレータ、流暢なラテン語、Egghead のサブスクリプション、博士号、または Exceeds Expectations O.W.L.レベルが必要だという神話を払拭することを目的としています。</target>
        </trans-unit>
        <trans-unit id="93fb65536a0476327978e11533ea1a5d24a10c81" translate="yes" xml:space="preserve">
          <source>The new state is not passed to the listeners in order to simplify implementing store enhancers such as the Redux DevTools. In addition, subscribers are intended to react to the state value itself, not the action. Middleware can be used if the action is important and needs to be handled specifically.</source>
          <target state="translated">Redux DevTools のようなストアエンハンサーの実装を簡略化するために、新しいステートはリスナーに渡されません。さらに、サブスクライバはアクションではなく、ステート値自体に反応することを意図しています。アクションが重要で、特別に処理する必要がある場合は、ミドルウェアを使用することができます。</target>
        </trans-unit>
        <trans-unit id="5e78ce3d1d64476af75b7e5f41d5be781a323a4c" translate="yes" xml:space="preserve">
          <source>The nice thing about thunks is that they can dispatch results of each other:</source>
          <target state="translated">サンクスのいいところは、お互いの結果を派遣し合えるところです。</target>
        </trans-unit>
        <trans-unit id="6d99c20eac2d1658b7df0891305cdca243a9af62" translate="yes" xml:space="preserve">
          <source>The only input for server side code is the request made when loading up a page in your app in your browser. You may choose to configure the server during its boot (such as when you are running in a development vs. production environment), but that configuration is static.</source>
          <target state="translated">サーバーサイド コードの入力は、ブラウザでアプリのページを読み上げるときに行われるリクエストのみです。起動時(開発環境と本番環境で実行している場合など)にサーバーを設定することができますが、その設定は静的なものです。</target>
        </trans-unit>
        <trans-unit id="0f86933dcbbe66c8f04e7c9fc359e8fa49b3f7f3" translate="yes" xml:space="preserve">
          <source>The only use case for &lt;code&gt;bindActionCreators&lt;/code&gt; is when you want to pass some action creators down to a component that isn't aware of Redux, and you don't want to pass &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; or the Redux store to it.</source>
          <target state="translated">&lt;code&gt;bindActionCreators&lt;/code&gt; の唯一の使用例は、一部のアクション作成者をReduxを認識しないコンポーネントに渡し、&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;またはReduxストアをそれに渡さない場合です。</target>
        </trans-unit>
        <trans-unit id="66b4d49e553bb0efa470bbe85e68619297117596" translate="yes" xml:space="preserve">
          <source>The only way to change the state inside it is to dispatch an &lt;a href=&quot;../glossary#action&quot;&gt;action&lt;/a&gt; on it.</source>
          <target state="translated">内部の状態を変更する唯一の方法は、&lt;a href=&quot;../glossary#action&quot;&gt;アクション&lt;/a&gt;をディスパッチすることです。</target>
        </trans-unit>
        <trans-unit id="3d51f5c9be0da0a1475d839514b718722284186c" translate="yes" xml:space="preserve">
          <source>The only way to change the state tree is to emit an &lt;em&gt;action&lt;/em&gt;, an object describing what happened.</source>
          <target state="translated">状態ツリーを変更する唯一の方法は、何が起こったかを説明するオブジェクトである&lt;em&gt;action&lt;/em&gt;を発行することです。</target>
        </trans-unit>
        <trans-unit id="c24d16d7147d4d6eb8c10527b6a9d45b0beb9c87" translate="yes" xml:space="preserve">
          <source>The option we recommend is to use a special React Redux component called &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store&quot;&gt;&lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;https://facebook.github.io/react/docs/context.html&quot;&gt;magically&lt;/a&gt; make the store available to all container components in the application without passing it explicitly. You only need to use it once when you render the root component:</source>
          <target state="translated">私たちが推奨するオプションは、&lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store&quot;&gt; &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; &lt;/a&gt;と呼ばれる特別なReact Reduxコンポーネントを使用して、明示的に渡さずにアプリケーション内のすべてのコンテナーコンポーネントがストアを&lt;a href=&quot;https://facebook.github.io/react/docs/context.html&quot;&gt;魔法の&lt;/a&gt;ように利用できるようにすることです。ルートコンポーネントをレンダリングするときに、一度だけ使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="648fab04f4ba80945b0b8fe210f400cb5cd99721" translate="yes" xml:space="preserve">
          <source>The original Flux pattern describes having multiple &amp;ldquo;stores&amp;rdquo; in an app, each one holding a different area of domain data. This can introduce issues such as needing to have one store &amp;ldquo;&lt;code&gt;waitFor&lt;/code&gt;&amp;rdquo; another store to update. This is not necessary in Redux because the separation between data domains is already achieved by splitting a single reducer into smaller reducers.</source>
          <target state="translated">元のFluxパターンは、アプリに複数の「ストア」があり、それぞれがドメインデータの異なる領域を保持していることを示しています。これにより、あるストアに &quot; &lt;code&gt;waitFor&lt;/code&gt; &quot;別のストアを更新する必要があるなどの問題が発生する可能性があります。データドメイン間の分離は、単一のレデューサーをより小さなレデューサーに分割することですでに実現されているため、これはReduxでは必要ありません。</target>
        </trans-unit>
        <trans-unit id="62ee23332a72fc3750f78243b123043b65f95888" translate="yes" xml:space="preserve">
          <source>The question is: do you really need Redux if you already use Rx? Maybe not. It's not hard to &lt;a href=&quot;https://github.com/jas-chen/rx-redux&quot;&gt;re-implement Redux in Rx&lt;/a&gt;. Some say it's a two-liner using Rx &lt;code&gt;.scan()&lt;/code&gt; method. It may very well be!</source>
          <target state="translated">問題は、すでにRxを使用している場合、本当にReduxが必要かどうかです。そうでないかもしれない。&lt;a href=&quot;https://github.com/jas-chen/rx-redux&quot;&gt;RxでRedux&lt;/a&gt;を再実装することは難しくありません。Rx &lt;code&gt;.scan()&lt;/code&gt; メソッドを使用した2ライナーだと言う人もいます。それはよくあるかもしれません！</target>
        </trans-unit>
        <trans-unit id="b112f1eaa085df10f0fb3a949e7c7d0512123ef7" translate="yes" xml:space="preserve">
          <source>The reducer &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt; signature makes it natural to implement generic &amp;ldquo;reducer enhancers&amp;rdquo; or &amp;ldquo;higher order reducers&amp;rdquo;. They are functions that take your reducer and enhance it with some additional functionality while preserving its signature. Undo history is exactly such a case.</source>
          <target state="translated">レデューサー &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt; シグネチャにより、一般的な「レデューサーエンハンサー」または「高次レデューサー」の実装が自然になります。それらはあなたの減速機を取り、その署名を保持しながらいくつかの追加機能でそれを強化する関数です。元に戻す履歴はまさにそのような場合です。</target>
        </trans-unit>
        <trans-unit id="831cdccd0fe29b2292b102e71a67a95df749f9a5" translate="yes" xml:space="preserve">
          <source>The reducer generated by &lt;code&gt;combineReducers({ a, b })&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;combineReducers({ a, b })&lt;/code&gt; によって生成されるレデューサーは次のようになります。</target>
        </trans-unit>
        <trans-unit id="579bccc1a8ba0deb299c67fd02b66c1a0bde82b3" translate="yes" xml:space="preserve">
          <source>The reducer logic doesn't have to deal with deep levels of nesting, so it will probably be much simpler.</source>
          <target state="translated">レデューサーロジックは深いレベルのネストに対応する必要がないので、もっとシンプルになるのではないでしょうか。</target>
        </trans-unit>
        <trans-unit id="8b251f78a3911e16c890bcff055432910c7e244e" translate="yes" xml:space="preserve">
          <source>The reducers may handle this action by merging the new data into the state they manage and resetting &lt;code&gt;isFetching&lt;/code&gt;. The UI would hide the spinner, and display the fetched data.</source>
          <target state="translated">レデューサーは、新しいデータを管理者が管理する状態にマージし、 &lt;code&gt;isFetching&lt;/code&gt; をリセットすることにより、このアクションを処理できます。UIはスピナーを非表示にし、取得したデータを表示します。</target>
        </trans-unit>
        <trans-unit id="ef702e159de1a7ac56e685ea8e6312a6d8a5ae0e" translate="yes" xml:space="preserve">
          <source>The reducers may handle this action by resetting &lt;code&gt;isFetching&lt;/code&gt;. Additionally, some reducers may want to store the error message so the UI can display it.</source>
          <target state="translated">レデューサーは &lt;code&gt;isFetching&lt;/code&gt; をリセットすることでこのアクションを処理できます。さらに、一部のレデューサーは、UIが表示できるようにエラーメッセージを保存したい場合があります。</target>
        </trans-unit>
        <trans-unit id="e3589533d63065a42192671f978f7884a00c50eb" translate="yes" xml:space="preserve">
          <source>The reducers may handle this action by toggling an &lt;code&gt;isFetching&lt;/code&gt; flag in the state. This way the UI knows it's time to show a spinner.</source>
          <target state="translated">レデューサーは、状態の &lt;code&gt;isFetching&lt;/code&gt; フラグを切り替えることでこのアクションを処理できます。このようにして、UIはスピナーを表示するタイミングを認識します。</target>
        </trans-unit>
        <trans-unit id="fb415aec3abf5f69e7a7dbc95599da2a8b59bb09" translate="yes" xml:space="preserve">
          <source>The remove function could also be implemented as:</source>
          <target state="translated">remove関数は、次のように実装することもできます。</target>
        </trans-unit>
        <trans-unit id="34eee3e75bb47e88848e238f22d63bbf7668e6ee" translate="yes" xml:space="preserve">
          <source>The request contains information about the URL requested, including any query parameters, which will be useful when using something like &lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt;. It can also contain headers with inputs like cookies or authorization, or POST body data. Let's see how we can set the initial counter state based on a query parameter.</source>
          <target state="translated">リクエストには、リクエストされたURLに関する情報が含まれます。これには、&lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt;などを使用するときに役立つクエリパラメータが含まれます。また、Cookieや認証、POST本文データなどの入力を持つヘッダーを含めることもできます。クエリパラメーターに基づいて初期カウンター状態を設定する方法を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="cb8346bc09abdc2bdbbd4e730bada908b5a84b2e" translate="yes" xml:space="preserve">
          <source>The resulting reducer calls every child reducer, and gathers their results into a single state object. &lt;strong&gt;The shape of the state object matches the keys of the passed &lt;code&gt;reducers&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">結果のレデューサーはすべての子レデューサーを呼び出し、その結果を単一の状態オブジェクトに収集します。&lt;strong&gt;状態オブジェクトの形状は、渡された &lt;code&gt;reducers&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;キーと一致します&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="191b4037dec326d03a76e5e3d99a324826c75a29" translate="yes" xml:space="preserve">
          <source>The shallow check of &lt;code&gt;param&lt;/code&gt; and &lt;code&gt;returnValue&lt;/code&gt; simply checks whether both variables reference the same object, which they do.&lt;code&gt;mutateObj()&lt;/code&gt; may return a mutated version of &lt;code&gt;obj&lt;/code&gt;, but it's still the same object as that passed in. The fact that its values have been changed within &lt;code&gt;mutateObj&lt;/code&gt; matters not at all to a shallow check.</source>
          <target state="translated">&lt;code&gt;param&lt;/code&gt; と &lt;code&gt;returnValue&lt;/code&gt; の浅いチェックは、両方の変数が同じオブジェクトを参照しているかどうかを単純にチェックします。 &lt;code&gt;mutateObj()&lt;/code&gt; は、変更されたバージョンの &lt;code&gt;obj&lt;/code&gt; を返す場合がありますが、それは渡されたものと同じオブジェクトです &lt;code&gt;mutateObj&lt;/code&gt; 内でその値が変更されているという事実は、浅いチェックにはまったく関係ありません。</target>
        </trans-unit>
        <trans-unit id="bc6715934729123df24e127a2b31fa31c6f3d1d9" translate="yes" xml:space="preserve">
          <source>The simplest and most common way to do this is to add the &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; middleware that lets you write action creators with more complex and asynchronous logic. Another widely-used method is &lt;a href=&quot;https://github.com/yelouafi/redux-saga&quot;&gt;Redux Saga&lt;/a&gt; which lets you write more synchronous-looking code using generators, and can act like &amp;ldquo;background threads&amp;rdquo; or &amp;ldquo;daemons&amp;rdquo; in a Redux app. Yet another approach is &lt;a href=&quot;https://github.com/raisemarketplace/redux-loop&quot;&gt;Redux Loop&lt;/a&gt;, which inverts the process by allowing your reducers to declare side effects in response to state changes and have them executed separately. Beyond that, there are &lt;em&gt;many&lt;/em&gt; other community-developed libraries and ideas, each with their own take on how side effects should be managed.</source>
          <target state="translated">これを行う最も簡単で最も一般的な方法は、より複雑で非同期のロジックを使用してアクション作成者を作成できる&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt;ミドルウェアを追加することです。もう1つの広く使用されている方法は、ジェネレーターを使用して同期的に見えるコードを記述できる&lt;a href=&quot;https://github.com/yelouafi/redux-saga&quot;&gt;Redux Sagaで&lt;/a&gt;あり、Reduxアプリで「バックグラウンドスレッド」または「デーモン」のように機能できます。さらに別のアプローチは&lt;a href=&quot;https://github.com/raisemarketplace/redux-loop&quot;&gt;Redux Loopです&lt;/a&gt;。これは、レデューサーが状態の変化に応じて副作用を宣言し、それらを個別に実行できるようにすることでプロセスを逆にします。それ以外にも、コミュニティが開発したライブラリやアイデアは他にも&lt;em&gt;たくさん&lt;/em&gt;あり、それぞれに副作用の管理方法について独自の考えがあります。</target>
        </trans-unit>
        <trans-unit id="a1ef44d7beed8bc507d7e3d3fa102d8a5af7a998" translate="yes" xml:space="preserve">
          <source>The simplest example of middleware is &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;. &lt;strong&gt;&amp;ldquo;Thunk&amp;rdquo; middleware lets you write action creators as &amp;ldquo;thunks&amp;rdquo;, that is, functions returning functions.&lt;/strong&gt; This inverts the control: you will get &lt;code&gt;dispatch&lt;/code&gt; as an argument, so you can write an action creator that dispatches many times.</source>
          <target state="translated">ミドルウェアの最も単純な例は&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;です。&lt;strong&gt;「サンク」ミドルウェアを使用すると、アクション作成者を「サンク」、つまり関数を返す関数として作成できます。&lt;/strong&gt;これによりコントロールが反転します。 &lt;code&gt;dispatch&lt;/code&gt; を引数として取得するため、何度もディスパッチするアクションクリエーターを作成できます。</target>
        </trans-unit>
        <trans-unit id="a224c5bb5c7b0257b4abc9573a41ae755e11d225" translate="yes" xml:space="preserve">
          <source>The simplest possible approach to writing reducer logic is to put everything into a single function declaration, like this:</source>
          <target state="translated">リデューサロジックを書くための最もシンプルな方法は、以下のように、すべてを単一の関数宣言にまとめることです。</target>
        </trans-unit>
        <trans-unit id="df00019572e1d526628ee1357601871796c2e3aa" translate="yes" xml:space="preserve">
          <source>The state is already immutable, and mutations are already described as discrete actions, which is close to the undo stack mental model.</source>
          <target state="translated">状態はすでに不変であり、突然変異はすでに離散的な行為として記述されており、これはアンドゥスタックのメンタルモデルに近い。</target>
        </trans-unit>
        <trans-unit id="4e2a0df854ac3a6ba67f8bf8af131bbbadf64b8c" translate="yes" xml:space="preserve">
          <source>The store will still be updated with the new values for the root state, but because the root state object itself is still the same object, libraries that bind to Redux, such as React-Redux, will not be aware of the state&amp;rsquo;s mutation, and so will not trigger a wrapped component&amp;rsquo;s re-rendering.</source>
          <target state="translated">ストアは引き続きルート状態の新しい値で更新されますが、ルート状態オブジェクト自体はまだ同じオブジェクトであるため、React-ReduxなどのReduxにバインドするライブラリは状態の変化を認識しません。そのため、ラップされたコンポーネントの再レンダリングはトリガーされません。</target>
        </trans-unit>
        <trans-unit id="4f3016ca7583094ba4738ed1d27a81993f9cabc7" translate="yes" xml:space="preserve">
          <source>The store's reducing function will be called with the current &lt;a href=&quot;#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; result and the given &lt;code&gt;action&lt;/code&gt; synchronously. Its return value will be considered the next state. It will be returned from &lt;a href=&quot;#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; from now on, and the change listeners will immediately be notified.</source>
          <target state="translated">ストアのレデューシング関数は、現在の&lt;a href=&quot;#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; の&lt;/a&gt;結果と指定された &lt;code&gt;action&lt;/code&gt; 同時に呼び出されます。その戻り値は次の状態と見なされます。今後は&lt;a href=&quot;#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt;から返され、変更リスナーにすぐに通知されます。</target>
        </trans-unit>
        <trans-unit id="cea20ac25d592424eac6b0baa84b4cb2827c5999" translate="yes" xml:space="preserve">
          <source>The sub-app approach is also useful for large teams that are divided by product or feature verticals. These teams can ship sub-apps independently or in combination with an enclosing &amp;ldquo;app shell&amp;rdquo;.</source>
          <target state="translated">サブアプリアプローチは、製品または機能のカテゴリで分割された大規模なチームにも役立ちます。これらのチームは、サブアプリを個別に、または囲んでいる「アプリシェル」と組み合わせて出荷できます。</target>
        </trans-unit>
        <trans-unit id="375db8357be87b44ec99ec266964bcb0566ca944" translate="yes" xml:space="preserve">
          <source>The subscriptions are snapshotted just before every &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call. If you subscribe or unsubscribe while the listeners are being invoked, this will not have any effect on the &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; that is currently in progress. However, the next &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call, whether nested or not, will use a more recent snapshot of the subscription list.</source>
          <target state="translated">サブスクリプションは、すべての&lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;呼び出しの直前にスナップショットされます。リスナーの呼び出し中にサブスクライブまたはサブスクライブを解除しても、現在進行中の&lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;には影響しません。ただし、次の&lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;呼び出しは、ネストされているかどうかに関係なく、サブスクリプションリストの最新のスナップショットを使用します。</target>
        </trans-unit>
        <trans-unit id="e3fcb31aa94b0e76b32e4908a5de1c115f3b15a7" translate="yes" xml:space="preserve">
          <source>The suggested structure for a Redux store is to split the state object into multiple &amp;ldquo;slices&amp;rdquo; or &amp;ldquo;domains&amp;rdquo; by key, and provide a separate reducer function to manage each individual data slice. This is similar to how the standard Flux pattern has multiple independent stores, and Redux provides the &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; utility function to make this pattern easier. However, it's important to note that &lt;code&gt;combineReducers&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; required&amp;mdash;it is simply a utility function for the common use case of having a single reducer function per state slice, with plain JavaScript objects for the data.</source>
          <target state="translated">Reduxストアで推奨される構造は、状態オブジェクトをキーによって複数の「スライス」または「ドメイン」に分割し、個々のデータスライスを管理するための個別のリデューサー機能を提供することです。これは、標準のFluxパターンに複数の独立したストアがある方法に似ており、Reduxはこのパターンを簡単にするための&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt;ユーティリティ機能を提供します。ただし、 &lt;code&gt;combineReducers&lt;/code&gt; は必須では&lt;em&gt;ない&lt;/em&gt;ことに注意することが重要です。これは、データにプレーンJavaScriptオブジェクトを使用し、状態スライスごとに単一のレデューサー関数を使用する一般的な使用例の単なるユーティリティ関数です。</target>
        </trans-unit>
        <trans-unit id="19890ee5401ad9b13da13113d9a0a8f02936561b" translate="yes" xml:space="preserve">
          <source>The term &quot;&lt;em&gt;sub-reducer&lt;/em&gt;&quot; has also been used in various discussions to mean any function that is not the root reducer, although the term is not very precise. Some people may also refer to some functions as &quot;&lt;em&gt;business logic&lt;/em&gt;&quot; (functions that relate to application-specific behavior) or &quot;&lt;em&gt;utility functions&lt;/em&gt;&quot; (generic functions that are not application-specific).</source>
          <target state="translated">「&lt;em&gt;サブレデューサー&lt;/em&gt;」という用語は、根のレデューサーではない関数を意味するためにさまざまな議論で使用されてきましたが、この用語はあまり正確ではありません。一部の機能は、一部の機能を「&lt;em&gt;ビジネスロジック&lt;/em&gt;」（アプリケーション固有の動作に関連する機能）または「&lt;em&gt;ユーティリティ機能&lt;/em&gt;」（アプリケーション固有ではない汎用機能）と呼ぶ場合もあります。</target>
        </trans-unit>
        <trans-unit id="4efb799026840b45f617b41420282694075bcbb5" translate="yes" xml:space="preserve">
          <source>The two most common ways to specialize a reducer are to generate new action constants with a given prefix or suffix, or to attach additional info inside the action object. Here's what those might look like:</source>
          <target state="translated">減算器を特殊化する最も一般的な方法は、与えられた接頭辞や接尾辞を持つ新しいアクション定数を生成する方法と、アクションオブジェクトの内部に追加情報を添付する方法の2つです。これらは次のようなものです。</target>
        </trans-unit>
        <trans-unit id="8244d8d3077f561bcd0f5377b25ede16bd17a723" translate="yes" xml:space="preserve">
          <source>The whole state of your app is stored in an object tree inside a single &lt;em&gt;store&lt;/em&gt;.</source>
          <target state="translated">アプリの状態全体は、単一の&lt;em&gt;ストア&lt;/em&gt;内のオブジェクトツリーに格納されます。</target>
        </trans-unit>
        <trans-unit id="b55a43c532a7c8e9947bf52f67dd941ff93ac2e5" translate="yes" xml:space="preserve">
          <source>The work done by Redux generally falls into a few areas: processing actions in middleware and reducers (including object duplication for immutable updates), notifying subscribers after actions are dispatched, and updating UI components based on the state changes. While it's certainly &lt;em&gt;possible&lt;/em&gt; for each of these to become a performance concern in sufficiently complex situations, there's nothing inherently slow or inefficient about how Redux is implemented. In fact, React Redux in particular is heavily optimized to cut down on unnecessary re-renders, and React-Redux v5 shows noticeable improvements over earlier versions.</source>
          <target state="translated">Reduxによって行われる作業は、一般にいくつかの領域に分類されます。ミドルウェアとリデューサーでのアクションの処理（不変の更新のためのオブジェクトの複製を含む）、アクションがディスパッチされた後のサブスクライバーへの通知、状態変化に基づくUIコンポーネントの更新。これらのそれぞれが十分に複雑な状況でパフォーマンスの問題になる&lt;em&gt;可能性&lt;/em&gt;は確かにありますが、Reduxの実装方法について本質的に遅いまたは非効率的なものはありません。実際、React Reduxは特に、不要な再レンダリングを削減するために大幅に最適化されており、React-Redux v5は以前のバージョンよりも目立った改善を示しています。</target>
        </trans-unit>
        <trans-unit id="e621bbd33e777ec7ef3871509510242d1781c64a" translate="yes" xml:space="preserve">
          <source>The work on Redux was &lt;a href=&quot;https://www.patreon.com/reactdx&quot;&gt;funded by the community&lt;/a&gt;.</source>
          <target state="translated">Reduxに関する作業&lt;a href=&quot;https://www.patreon.com/reactdx&quot;&gt;はコミュニティから資金提供を受けました&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e58a6fbd2c7776a43fa3f20f5482c786c5abf51" translate="yes" xml:space="preserve">
          <source>Then your reducer might look like this:</source>
          <target state="translated">そうすると、減速機は次のようになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="b0b64fceb751659a715e3ef58186964669c75267" translate="yes" xml:space="preserve">
          <source>Then, add this to &lt;code&gt;scripts&lt;/code&gt; in your &lt;code&gt;package.json&lt;/code&gt;:</source>
          <target state="translated">次に、これを &lt;code&gt;package.json&lt;/code&gt; の &lt;code&gt;scripts&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="e96f86541d1773854c7bcc0e179868209a9a8589" translate="yes" xml:space="preserve">
          <source>There are a few important bits here:</source>
          <target state="translated">ここには重要なことがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="5d06a233fcb86cede2504f1d8109e3efa70aa46c" translate="yes" xml:space="preserve">
          <source>There are a number of community packages that implement various approaches for storing per-component state in a Redux store instead, such as &lt;a href=&quot;https://github.com/tonyhb/redux-ui&quot;&gt;redux-ui&lt;/a&gt;, &lt;a href=&quot;https://github.com/tomchentw/redux-component&quot;&gt;redux-component&lt;/a&gt;, &lt;a href=&quot;https://github.com/threepointone/redux-react-local&quot;&gt;redux-react-local&lt;/a&gt;, and more. It's also possible to apply Redux's principles and concept of reducers to the task of updating local component state as well, along the lines of &lt;code&gt;this.setState( (previousState) =&amp;gt; reducer(previousState, someAction))&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tonyhb/redux-ui&quot;&gt;redux-ui&lt;/a&gt;、&lt;a href=&quot;https://github.com/tomchentw/redux-component&quot;&gt;redux-component&lt;/a&gt;、&lt;a href=&quot;https://github.com/threepointone/redux-react-local&quot;&gt;redux-react-local&lt;/a&gt;など、コンポーネントごとの状態をReduxストアに格納するためのさまざまなアプローチを実装するコミュニティパッケージがいくつかあります。 &lt;code&gt;this.setState( (previousState) =&amp;gt; reducer(previousState, someAction))&lt;/code&gt; の行に沿って、Reduxの原則とレデューサーの概念をローカルコンポーネントの状態を更新するタスクにも適用することもできます。</target>
        </trans-unit>
        <trans-unit id="0014d11cb95b6c4884244108322b1ff44ccf44a1" translate="yes" xml:space="preserve">
          <source>There are also utility libraries to aid in generating action creators, such as &lt;a href=&quot;https://github.com/pauldijou/redux-act&quot;&gt;redux-act&lt;/a&gt; and &lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt;. These can help reduce boilerplate code and enforce adherence to standards such as &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action (FSA)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/pauldijou/redux-act&quot;&gt;redux-act&lt;/a&gt;や&lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt;などのアクション作成者の生成を支援するユーティリティライブラリもあります。これらは、定型コードを削減し、&lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action（FSA）&lt;/a&gt;などの標準への準拠を強化するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="6d7c3fb839d1de9f174190d1095682848236da15" translate="yes" xml:space="preserve">
          <source>There are frameworks claiming to be similar to Flux, but without a concept of action objects. In terms of being predictable, this is a step backwards from Flux or Redux. If there are no serializable plain object actions, it is impossible to record and replay user sessions, or to implement &lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;hot reloading with time travel&lt;/a&gt;. If you'd rather modify data directly, you don't need Redux.</source>
          <target state="translated">Fluxに似ていると主張するフレームワークがありますが、アクションオブジェクトの概念はありません。予測可能であるという点で、これはFluxまたはReduxから一歩後退しています。シリアル化可能なプレーンオブジェクトアクションがない場合、ユーザーセッションを記録して再生したり&lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;、タイムトラベルでホットリロード&lt;/a&gt;を実装したりすることはできません。データを直接変更する場合は、Reduxは必要ありません。</target>
        </trans-unit>
        <trans-unit id="cfa801b0cb8664a9ae599fb04c53df6ce12bf658" translate="yes" xml:space="preserve">
          <source>There are no multiple models&amp;mdash;just a state subtree that you want to keep track of.</source>
          <target state="translated">複数のモデルはありません。追跡したい状態サブツリーだけです。</target>
        </trans-unit>
        <trans-unit id="420577e78b88dd5a407cd7bcfca83fee052024be" translate="yes" xml:space="preserve">
          <source>There are several important ideas to be aware of when using &lt;code&gt;combineReducers&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; を使用する際に注意すべき重要なアイデアがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="31dadb8b332eafb541ac48d1ad1b0591872b1ba8" translate="yes" xml:space="preserve">
          <source>There are some simple tweaks that can be made to this reducer. First, repeated &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; statements quickly grow tiresome, so it's very common to use &lt;code&gt;switch&lt;/code&gt; statements instead. Second, we can use ES6's default parameter values to handle the initial &quot;no existing data&quot; case. With those changes, the reducer would look like:</source>
          <target state="translated">このレデューサーに加えることができるいくつかの簡単な調整があります。まず、繰り返し &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; ステートメントはすぐに飽き飽きするため、代わりに &lt;code&gt;switch&lt;/code&gt; ステートメントを使用するのが一般的です。次に、ES6のデフォルトのパラメーター値を使用して、最初の「既存のデータがない」場合を処理できます。これらの変更により、レデューサーは次のようになります。</target>
        </trans-unit>
        <trans-unit id="a0306be0f55c35417f1fb94a7a6a33b60158cc20" translate="yes" xml:space="preserve">
          <source>There are two main ways to initialize state for your application. The &lt;code&gt;createStore&lt;/code&gt; method can accept an optional &lt;code&gt;preloadedState&lt;/code&gt; value as its second argument. Reducers can also specify an initial value by looking for an incoming state argument that is &lt;code&gt;undefined&lt;/code&gt;, and returning the value they'd like to use as a default. This can either be done with an explicit check inside the reducer, or by using the ES6 default argument value syntax: &lt;code&gt;function myReducer(state = someDefaultValue, action)&lt;/code&gt;.</source>
          <target state="translated">アプリケーションの状態を初期化するには、主に2つの方法があります。 &lt;code&gt;createStore&lt;/code&gt; 方法は任意で受け入れることができる &lt;code&gt;preloadedState&lt;/code&gt; の 2番目の引数として値。リデューサーは、 &lt;code&gt;undefined&lt;/code&gt; である入力状態引数を探し、デフォルトとして使用する値を返すことにより、初期値を指定することもできます。これは、レデューサー内の明示的なチェックを使用するか、ES6のデフォルトの引数値の構文を使用して &lt;code&gt;function myReducer(state = someDefaultValue, action)&lt;/code&gt; ます：function myReducer（state = someDefaultValue、action）。</target>
        </trans-unit>
        <trans-unit id="597620fe64267cbabf96711d555ec9adca761b24" translate="yes" xml:space="preserve">
          <source>There are two ways to define the initial shape and contents of your store's state. First, the &lt;code&gt;createStore&lt;/code&gt; function can take &lt;code&gt;preloadedState&lt;/code&gt; as its second argument. This is primarily intended for initializing the store with state that was previously persisted elsewhere, such as the browser's localStorage. The other way is for the root reducer to return the initial state value when the state argument is &lt;code&gt;undefined&lt;/code&gt;. These two approaches are described in more detail in &lt;a href=&quot;initializingstate&quot;&gt;Initializing State&lt;/a&gt;, but there are some additional concerns to be aware of when using &lt;code&gt;combineReducers&lt;/code&gt;.</source>
          <target state="translated">ストアの状態の初期形状とコンテンツを定義するには、2つの方法があります。まず、 &lt;code&gt;createStore&lt;/code&gt; 機能を取ることができます &lt;code&gt;preloadedState&lt;/code&gt; を 2番目の引数として。これは主に、以前はブラウザーのlocalStorageなどの別の場所に永続化されていた状態でストアを初期化することを目的としています。もう1つの方法は、state引数が &lt;code&gt;undefined&lt;/code&gt; のときにルートレデューサーが初期状態値を返すことです。これらの2つのアプローチについては、「状態の&lt;a href=&quot;initializingstate&quot;&gt;初期化」で&lt;/a&gt;詳しく説明していますが、 &lt;code&gt;combineReducers&lt;/code&gt; を使用するときに注意する必要がある追加の懸念事項があります。</target>
        </trans-unit>
        <trans-unit id="56409b9a5183b19808817fe73374f07883b83a73" translate="yes" xml:space="preserve">
          <source>There is an important gotcha: you need to remember to append &lt;code&gt;.present&lt;/code&gt; to the current state when you retrieve it. You may also check &lt;code&gt;.past.length&lt;/code&gt; and &lt;code&gt;.future.length&lt;/code&gt; to determine whether to enable or to disable the Undo and Redo buttons, respectively.</source>
          <target state="translated">重要な &lt;code&gt;.present&lt;/code&gt; があります。取得するときに、現在の状態に.presentを追加することを忘れないでください。また、 &lt;code&gt;.past.length&lt;/code&gt; と &lt;code&gt;.future.length&lt;/code&gt; を確認して、[元に戻す]ボタンと[やり直し]ボタンをそれぞれ有効にするか無効にするかを決定することもできます。</target>
        </trans-unit>
        <trans-unit id="f5f4b92d40c5193a89ef2d973b4dea0cf41db580" translate="yes" xml:space="preserve">
          <source>There is no &amp;ldquo;right&amp;rdquo; answer for this. Some users prefer to keep every single piece of data in Redux, to maintain a fully serializable and controlled version of their application at all times. Others prefer to keep non-critical or UI state, such as &amp;ldquo;is this dropdown currently open&amp;rdquo;, inside a component's internal state.</source>
          <target state="translated">これに対する「正しい」答えはありません。一部のユーザーは、アプリケーションの完全にシリアライズ可能で制御されたバージョンを常に維持するために、すべてのデータをReduxに保持することを好みます。「このドロップダウンは現在開いている」など、重要ではない状態やUI状態をコンポーネントの内部状態に保持することを好む人もいます。</target>
        </trans-unit>
        <trans-unit id="90170588b4fa6d7f622136b2c7f8e6e07e225db6" translate="yes" xml:space="preserve">
          <source>There should only be a single store in a Redux app, as the composition happens on the reducer level.</source>
          <target state="translated">コンポジションはレデューサーレベルで行われるので、Reduxアプリには1つのストアしかないはずです。</target>
        </trans-unit>
        <trans-unit id="992aa1eaaf62b5438b3953fb40feec345ca3edf1" translate="yes" xml:space="preserve">
          <source>There should only be a single store in your app.</source>
          <target state="translated">アプリ内には1店舗しかないはずです。</target>
        </trans-unit>
        <trans-unit id="168b0114042369684de79c5fdf6b3e093b40d171" translate="yes" xml:space="preserve">
          <source>There will &lt;em&gt;rarely&lt;/em&gt; be a 1-to-1 correspondence between your UI tree and your state shape. The exception to that might be if you are explicitly tracking various aspects of UI data in your Redux store as well, but even then the shape of the UI data and the shape of the domain data would likely be different.</source>
          <target state="translated">UIツリーと状態の形状が1対1で対応する&lt;em&gt;こと&lt;/em&gt;は&lt;em&gt;ほとんど&lt;/em&gt;あり&lt;em&gt;ませ&lt;/em&gt;ん。その例外は、ReduxストアのUIデータのさまざまな側面も明示的に追跡している場合でも、UIデータの形状とドメインデータの形状が異なる可能性があります。</target>
        </trans-unit>
        <trans-unit id="f1d2ef296166ce0ecc73c05efc95f385ad2e7495" translate="yes" xml:space="preserve">
          <source>There's a couple ways Redux-ORM can be used to perform updates. First, the Redux-ORM docs suggest defining reducer functions on each Model subclass, then including the auto-generated combined reducer function into your store:</source>
          <target state="translated">Redux-ORMが更新を実行するためには、いくつかの方法があります。まず、Redux-ORMのドキュメントでは、各モデルのサブクラスにレデューサ関数を定義し、自動生成された結合されたレデューサ関数をストアに含めることを提案しています。</target>
        </trans-unit>
        <trans-unit id="51018a56e34b691dd014441eabce29bdbcbc8652" translate="yes" xml:space="preserve">
          <source>There's no single clear answer to exactly what pieces of logic should go in a reducer or an action creator. Some developers prefer to have &amp;ldquo;fat&amp;rdquo; action creators, with &amp;ldquo;thin&amp;rdquo; reducers that simply take the data in an action and blindly merge it into the corresponding state. Others try to emphasize keeping actions as small as possible, and minimize the usage of &lt;code&gt;getState()&lt;/code&gt; in an action creator. (For purposes of this question, other async approaches such as sagas and observables fall in the &quot;action creator&quot; category.)</source>
          <target state="translated">リデューサーやアクションクリエーターでどのロジックを実行する必要があるかについての明確な答えは1つではありません。一部の開発者は、アクションのデータを取得して対応する状態に盲目的にマージする「シン」レデューサーを備えた「ファット」アクションクリエーターを好む。他の人たちは、アクションをできるだけ小さく保つことを強調し、アクションクリエーターでの &lt;code&gt;getState()&lt;/code&gt; の使用を最小限に抑えようとします。（この質問の目的のために、sagasやオブザーバブルなどの他の非同期アプローチは「アクションクリエーター」カテゴリに分類されます。）</target>
        </trans-unit>
        <trans-unit id="28edc5708a2301951ec09979956f382164d459ec" translate="yes" xml:space="preserve">
          <source>There's no specific rule for how you should structure your actions. Using an async middleware like Redux Thunk certainly enables scenarios such as dispatching multiple distinct but related actions in a row, dispatching actions to represent progression of an AJAX request, dispatching actions conditionally based on state, or even dispatching an action and checking the updated state immediately afterwards.</source>
          <target state="translated">アクションをどのように構造化すべきかについては、特定のルールはありません。Redux Thunkのような非同期ミドルウェアを使うことで、複数の異なるが関連するアクションを一列に並べてディスパッチしたり、AJAXリクエストの進行を表すアクションをディスパッチしたり、状態に基づいて条件付きでアクションをディスパッチしたり、アクションをディスパッチしてすぐに更新された状態をチェックしたりといったシナリオを確かに可能にします。</target>
        </trans-unit>
        <trans-unit id="3919f394ea7f45a742af3ee7c733b38c93a6700c" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;&amp;lt;SubApp&amp;gt;&lt;/code&gt;s will be completely independent. They won't share data or actions, and won't see or communicate with each other.</source>
          <target state="translated">これらの &lt;code&gt;&amp;lt;SubApp&amp;gt;&lt;/code&gt; は完全に独立しています。彼らはデータやアクションを共有したり、お互いを見たり通信したりすることはありません。</target>
        </trans-unit>
        <trans-unit id="7403f67d70c46d230048ba2241787084beea6a95" translate="yes" xml:space="preserve">
          <source>These are all normal React components, so we won't examine them in detail. We write functional stateless components unless we need to use local state or the lifecycle methods. This doesn't mean that presentational components &lt;em&gt;have to&lt;/em&gt; be functions&amp;mdash;it's just easier to define them this way. If and when you need to add local state, lifecycle methods, or performance optimizations, you can convert them to classes.</source>
          <target state="translated">これらはすべて通常のReactコンポーネントであるため、詳細には説明しません。ローカル状態またはライフサイクルメソッドを使用する必要がない限り、機能的なステートレスコンポーネントを作成します。これは、プレゼンテーションコンポーネント&lt;em&gt;が&lt;/em&gt;関数である&lt;em&gt;必要がある&lt;/em&gt;という意味ではありません。このように定義する方が簡単です。ローカル状態、ライフサイクルメソッド、またはパフォーマンス最適化を追加する必要がある場合は、それらをクラスに変換できます。</target>
        </trans-unit>
        <trans-unit id="ad42b9f4f6a7ded866b5edd040dee5736736ad79" translate="yes" xml:space="preserve">
          <source>These are some use cases and code snippets to get you started with Redux in a real app. They assume you understand the topics in &lt;a href=&quot;../basics/index&quot;&gt;basic&lt;/a&gt; and &lt;a href=&quot;../advanced/index&quot;&gt;advanced&lt;/a&gt; tutorials.</source>
          <target state="translated">これらは、実際のアプリでReduxを使い始めるためのいくつかの使用例とコードスニペットです。&lt;a href=&quot;../basics/index&quot;&gt;基本&lt;/a&gt;および&lt;a href=&quot;../advanced/index&quot;&gt;高度な&lt;/a&gt;チュートリアルのトピックを理解していることを前提としています。</target>
        </trans-unit>
        <trans-unit id="d704feeae1991cd907524cb1c0f7f6fcf0575629" translate="yes" xml:space="preserve">
          <source>These are the basics of the React Redux API, but there are a few shortcuts and power options so we encourage you to check out &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;its documentation&lt;/a&gt; in detail. In case you are worried about &lt;code&gt;mapStateToProps&lt;/code&gt; creating new objects too often, you might want to learn about &lt;a href=&quot;../recipes/computingderiveddata&quot;&gt;computing derived data&lt;/a&gt; with &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;reselect&lt;/a&gt;.</source>
          <target state="translated">これらはReact Redux APIの基本ですが、いくつかのショートカットと電源オプションがあるので&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;、そのドキュメント&lt;/a&gt;を詳細に確認することをお勧めします。 &lt;code&gt;mapStateToProps&lt;/code&gt; が新しいオブジェクトを頻繁に作成することを心配している場合は、&lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;reselectを&lt;/a&gt;&lt;a href=&quot;../recipes/computingderiveddata&quot;&gt;使用&lt;/a&gt;した派生データの計算について学習することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="4c26d64685238ce4dbcec18d03116138fa0bb9a0" translate="yes" xml:space="preserve">
          <source>These basic patterns allow you to do things like having multiple instances of a smart connected component within the UI, or reuse common logic for generic capabilities such as pagination or sorting.</source>
          <target state="translated">これらの基本的なパターンを使用することで、UI 内にスマート接続されたコンポーネントの複数のインスタンスを作成したり、ページネーションやソートなどの汎用的な機能に共通のロジックを再利用したりすることができます。</target>
        </trans-unit>
        <trans-unit id="c558d4ebff40066937cf4fb4becc7cf460cf85d8" translate="yes" xml:space="preserve">
          <source>These new functions would typically fall into one of three categories:</source>
          <target state="translated">これらの新機能は、通常、3つのカテゴリのいずれかに分類されます。</target>
        </trans-unit>
        <trans-unit id="84e2759c050a4d6ddff70ba97270b913483ea299" translate="yes" xml:space="preserve">
          <source>These were the actions governed by the user interaction. We will also have another kind of action, governed by the network requests. We will see how to dispatch them later, but for now, we just want to define them.</source>
          <target state="translated">これらはユーザーのインタラクションによって支配されるアクションです。ネットワークリクエストに支配される別の種類のアクションもあります。これらをどのようにディスパッチするかは後ほど見ていきますが、今のところはそれらを定義するだけです。</target>
        </trans-unit>
        <trans-unit id="734284615f4837016bf49d7e82571425d6842e5d" translate="yes" xml:space="preserve">
          <source>They can also press a &amp;ldquo;refresh&amp;rdquo; button to update it:</source>
          <target state="translated">また、「更新」ボタンを押して更新することもできます。</target>
        </trans-unit>
        <trans-unit id="0d52a5e55f55bac64300f695ab9f42bb206bbca5" translate="yes" xml:space="preserve">
          <source>They can provide a useful alternative to writing manual immutable update logic.</source>
          <target state="translated">これらは、手動で不変の更新ロジックを書くことに代わる有用な代替手段を提供します。</target>
        </trans-unit>
        <trans-unit id="19c5827cb1612ac05aed827f421dec6e57380bb2" translate="yes" xml:space="preserve">
          <source>They describe the &lt;em&gt;look&lt;/em&gt; but don't know &lt;em&gt;where&lt;/em&gt; the data comes from, or &lt;em&gt;how&lt;/em&gt; to change it. They only render what's given to them. If you migrate from Redux to something else, you'll be able to keep all these components exactly the same. They have no dependency on Redux.</source>
          <target state="translated">それらは&lt;em&gt;外観&lt;/em&gt;を説明し&lt;em&gt;ます&lt;/em&gt;が、データが&lt;em&gt;どこ&lt;/em&gt;から来たの&lt;em&gt;か&lt;/em&gt;、または&lt;em&gt;どのよう&lt;/em&gt;に変更するの&lt;em&gt;か&lt;/em&gt;わかりません。与えられたものだけをレンダリングします。Reduxから別のものに移行する場合、これらすべてのコンポーネントをまったく同じに保つことができます。Reduxに依存していません。</target>
        </trans-unit>
        <trans-unit id="b1159323b5c6aa9389a4540485a8db710c7036ca" translate="yes" xml:space="preserve">
          <source>Think of an action as a very brief snippet of news. &amp;ldquo;Mary liked article 42.&amp;rdquo; or &amp;ldquo;&amp;lsquo;Read the Redux docs.' was added to the list of todos.&amp;rdquo;</source>
          <target state="translated">アクションはニュースの非常に短いスニペットと考えてください。「メアリーは42条が気に入りました。」または「Reduxのドキュメントを読んでください。」todosのリストに追加されました。」</target>
        </trans-unit>
        <trans-unit id="b4665b478e044391de06bdde9d3e79d16edd37cb" translate="yes" xml:space="preserve">
          <source>Thinking in terms of state and state shape</source>
          <target state="translated">状態と状態の形で考える</target>
        </trans-unit>
        <trans-unit id="91e52043da589de141b602e3e454bd09930f4ace" translate="yes" xml:space="preserve">
          <source>This API is intended as a low-level primitive with no dependencies or complications, and can be used to build higher-level subscription logic. UI bindings such as React Redux can create a subscription for each connected component. It is also possible to write functions that can intelligently compare the old state vs the new state, and execute additional logic if certain pieces have changed. Examples include &lt;a href=&quot;https://github.com/jprichardson/redux-watch&quot;&gt;redux-watch&lt;/a&gt;, &lt;a href=&quot;https://github.com/ashaffer/redux-subscribe&quot;&gt;redux-subscribe&lt;/a&gt; and &lt;a href=&quot;https://github.com/ivantsov/redux-subscriber&quot;&gt;redux-subscriber&lt;/a&gt; which offer different approaches to specifying subscriptions and handling changes.</source>
          <target state="translated">このAPIは、依存関係や複雑さのない低レベルのプリミティブとして意図されており、高レベルのサブスクリプションロジックを構築するために使用できます。React ReduxなどのUIバインディングは、接続されている各コンポーネントのサブスクリプションを作成できます。古い状態と新しい状態をインテリジェントに比較できる関数を記述し、特定の部分が変更された場合に追加のロジックを実行することもできます。例には、サブスクリプションの指定と変更の処理に対するさまざまなアプローチを提供する&lt;a href=&quot;https://github.com/jprichardson/redux-watch&quot;&gt;redux-watch&lt;/a&gt;、&lt;a href=&quot;https://github.com/ashaffer/redux-subscribe&quot;&gt;redux-subscribe&lt;/a&gt;、および&lt;a href=&quot;https://github.com/ivantsov/redux-subscriber&quot;&gt;redux-subscriberが&lt;/a&gt;含まれます。</target>
        </trans-unit>
        <trans-unit id="b5bc9835804c7bf5d69285a0788d4ec1618aaf13" translate="yes" xml:space="preserve">
          <source>This allows you to gradually rewrite every Flux Store in your app as a reducer, but still export &lt;code&gt;createFluxStore(reducer)&lt;/code&gt; so the rest of your app is not aware that this is happening and sees the Flux stores.</source>
          <target state="translated">これにより、アプリ内のすべてのFlux Storeをレデューサーとして徐々に書き換えることができますが、それでも &lt;code&gt;createFluxStore(reducer)&lt;/code&gt; をエクスポートして、アプリの残りの部分でこれが発生していることを認識せず、Fluxストアを確認できます。</target>
        </trans-unit>
        <trans-unit id="a519a41d84a5c9b747a85285b24fa851ba29b4a3" translate="yes" xml:space="preserve">
          <source>This approach makes it very clear what's happening for the &lt;code&gt;&quot;ADD_COMMENTS&quot;&lt;/code&gt; case, but it does require nested updating logic, and some specific knowledge of the state tree shape. Depending on how you want to compose your reducer logic, this may or may not be desired.</source>
          <target state="translated">このアプローチにより、 &lt;code&gt;&quot;ADD_COMMENTS&quot;&lt;/code&gt; ケースで何が起こっているかが非常に明確になりますが、ネストされた更新ロジックと、状態ツリーの形状に関する特定の知識が必要です。リデューサーロジックの構成方法によっては、これが望ましい場合と望ましくない場合があります。</target>
        </trans-unit>
        <trans-unit id="e5b98104ccad15391aa66227a6551d8fc9f45bc0" translate="yes" xml:space="preserve">
          <source>This architecture might seem like an overkill for a counter app, but the beauty of this pattern is how well it scales to large and complex apps. It also enables very powerful developer tools, because it is possible to trace every mutation to the action that caused it. You can record user sessions and reproduce them just by replaying every action.</source>
          <target state="translated">このアーキテクチャはカウンターアプリとしてはやり過ぎのように思えるかもしれませんが、このパターンの美しさは、大規模で複雑なアプリへの拡張性の高さにあります。また、すべての突然変異をその原因となったアクションまでトレースすることができるので、非常に強力な開発者ツールも可能になります。ユーザーセッションを記録し、すべてのアクションを再生するだけで再現することができます。</target>
        </trans-unit>
        <trans-unit id="af9a7125c23f1d9f99cfc569936c1de486169781" translate="yes" xml:space="preserve">
          <source>This article is divided into an in-depth intro to help you grok the concept, and &lt;a href=&quot;#seven-examples&quot;&gt;a few practical examples&lt;/a&gt; to show the power of middleware at the very end. You may find it helpful to switch back and forth between them, as you flip between feeling bored and inspired.</source>
          <target state="translated">この記事は、概念を理解するのに役立つ詳細なイントロと&lt;a href=&quot;#seven-examples&quot;&gt;、&lt;/a&gt;最後にミドルウェアの力を示すいくつかの実用的な例に分かれています。退屈とインスピレーションを感じながら、それらを切り替えてみるとよいでしょう。</target>
        </trans-unit>
        <trans-unit id="8cbc20dacc9ba008323bf48c00c65d6371405cdd" translate="yes" xml:space="preserve">
          <source>This assumes you are using &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; as your package manager.</source>
          <target state="translated">これは、パッケージマネージャーとして&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;を使用していることを前提としています。</target>
        </trans-unit>
        <trans-unit id="36abb8e476a11a68638ccf33afca7adf0759ffbc" translate="yes" xml:space="preserve">
          <source>This can be prevented by using &lt;code&gt;toJS()&lt;/code&gt; in a Higher Order Component, as discussed in the &lt;a href=&quot;#immutable-js-best-practices&quot;&gt;Best Practices section&lt;/a&gt; below.</source>
          <target state="translated">これは、以下の&lt;a href=&quot;#immutable-js-best-practices&quot;&gt;ベストプラクティスのセクションで&lt;/a&gt;説明するように、高次コンポーネントで &lt;code&gt;toJS()&lt;/code&gt; を使用することで防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="80afa0a6f3a3ec186233802f8708789e06fce0fb" translate="yes" xml:space="preserve">
          <source>This chain of middleware is defined by the arguments passed to the &lt;code&gt;applyMiddleware&lt;/code&gt; function used when creating a store. Defining multiple chains will not work correctly, as they would have distinctly different &lt;code&gt;dispatch&lt;/code&gt; references and the different chains would effectively be disconnected.</source>
          <target state="translated">このミドルウェアのチェーンは、ストアの作成時に使用される &lt;code&gt;applyMiddleware&lt;/code&gt; 関数に渡される引数によって定義されます。複数のチェーンを定義すると、 &lt;code&gt;dispatch&lt;/code&gt; 参照が明確に異なり、異なるチェーンが効果的に切断されるため、正しく機能しません。</target>
        </trans-unit>
        <trans-unit id="e1fe353295b682382d86ef4ed3fc4f643382d4c5" translate="yes" xml:space="preserve">
          <source>This comment sums up the dichotomy nicely:</source>
          <target state="translated">このコメントは二項対立をうまくまとめている。</target>
        </trans-unit>
        <trans-unit id="324ca41cb1e96cbdc6d22ac4f0dc0ea7baff76ab" translate="yes" xml:space="preserve">
          <source>This complexity is difficult to handle as &lt;strong&gt;we're mixing two concepts&lt;/strong&gt; that are very hard for the human mind to reason about: &lt;strong&gt;mutation and asynchronicity.&lt;/strong&gt; I call them &lt;a href=&quot;https://en.wikipedia.org/wiki/Diet_Coke_and_Mentos_eruption&quot;&gt;Mentos and Coke&lt;/a&gt;. Both can be great in separation, but together they create a mess. Libraries like &lt;a href=&quot;http://facebook.github.io/react&quot;&gt;React&lt;/a&gt; attempt to solve this problem in the view layer by removing both asynchrony and direct DOM manipulation. However, managing the state of your data is left up to you. This is where Redux enters.</source>
          <target state="translated">この複雑さは、人間の心が&lt;strong&gt;考えるの&lt;/strong&gt;が非常に難しい&lt;strong&gt;2つの概念&lt;/strong&gt;、つまり&lt;strong&gt;突然変異と非同期&lt;/strong&gt;性&lt;strong&gt;を混合&lt;/strong&gt;し&lt;strong&gt;ている&lt;/strong&gt;ため、処理が困難&lt;strong&gt;です&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt;私はそれらを&lt;a href=&quot;https://en.wikipedia.org/wiki/Diet_Coke_and_Mentos_eruption&quot;&gt;メントスとコーラ&lt;/a&gt;と呼んでいます。どちらも分離に優れていますが、一緒にすると混乱を引き起こします。&lt;a href=&quot;http://facebook.github.io/react&quot;&gt;Reactの&lt;/a&gt;ようなライブラリは、非同期と直接DOM操作の両方を削除することにより、ビューレイヤーでこの問題を解決しようとします。ただし、データの状態の管理はユーザーに任されています。ここからReduxが登場します。</target>
        </trans-unit>
        <trans-unit id="bed55034327edcc9ff177976049dde9f1a8518bf" translate="yes" xml:space="preserve">
          <source>This could be expanded in a number of ways. For example, an application that does a lot of editing of entities might want to keep two sets of &quot;tables&quot; in the state, one for the &quot;current&quot; item values and one for the &quot;work-in-progress&quot; item values. When an item is edited, its values could be copied into the &quot;work-in-progress&quot; section, and any actions that update it would be applied to the &quot;work-in-progress&quot; copy, allowing the editing form to be controlled by that set of data while another part of the UI still refers to the original version. &quot;Resetting&quot; the edit form would simply require removing the item from the &quot;work-in-progress&quot; section and re-copying the original data from &quot;current&quot; to &quot;work-in-progress&quot;, while &quot;applying&quot; the edits would involve copying the values from the &quot;work-in-progress&quot; section to the &quot;current&quot; section.</source>
          <target state="translated">これは、いくつかの方法で拡張することができます。例えば、エンティティの編集を多く行うアプリケーションは、ステートに2つの「テーブル」を保持したいと思うかもしれません。アイテムが編集されると、その値は &quot;work-in-progress &quot;セクションにコピーされ、それを更新するアクションは &quot;work-in-progress &quot;コピーに適用され、UIの別の部分が元のバージョンを参照している間、編集フォームはそのデータセットによって制御されます。編集フォームを &quot;リセット &quot;するには、&quot;work-in-progress &quot;セクションからアイテムを削除し、元のデータを &quot;current &quot;から &quot;work-in-progress &quot;に再コピーする必要があり、&quot;適用 &quot;するには &quot;work-in-progress &quot;セクションから &quot;current &quot;セクションに値をコピーする必要があります。</target>
        </trans-unit>
        <trans-unit id="707c74a21f1746d2a960832a6b8a8cb90405d2f5" translate="yes" xml:space="preserve">
          <source>This ensures that neither the views nor the network callbacks will ever write directly to the state. Instead, they express an intent to transform the state. Because all changes are centralized and happen one by one in a strict order, there are no subtle race conditions to watch out for. As actions are just plain objects, they can be logged, serialized, stored, and later replayed for debugging or testing purposes.</source>
          <target state="translated">これにより、ビューもネットワーク・コールバックもステートに直接書き込むことはありません。その代わりに、状態を変換しようとする意図を表現します。すべての変更は集中化されており、厳密な順序で一つずつ行われるため、気をつけるべき微妙な競合条件はありません。アクションは単なるオブジェクトなので、ログを記録したり、シリアル化したり、保存したり、後でデバッグやテストのために再生したりすることができます。</target>
        </trans-unit>
        <trans-unit id="9210dbb4de5b40a1c13ddea412dbce790a6977d8" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use &lt;code&gt;compose&lt;/code&gt; to enhance a &lt;a href=&quot;store&quot;&gt;store&lt;/a&gt; with &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware&lt;/code&gt;&lt;/a&gt; and a few developer tools from the &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt; package.</source>
          <target state="translated">この例は、 &lt;code&gt;compose&lt;/code&gt; を使用して、&lt;a href=&quot;applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt;パッケージのいくつかの開発者ツールで&lt;a href=&quot;store&quot;&gt;ストア&lt;/a&gt;を拡張する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="e6a4f9f87221d4ef2187fb40a3e81e24b1380c59" translate="yes" xml:space="preserve">
          <source>This example demonstrates rendering a deeply nested tree view and representing its state in a normalized form so it is easy to update from reducers. Good rendering performance is achieved by the container components granularly subscribing only to the tree nodes that they render.</source>
          <target state="translated">この例では、深い入れ子になったツリービューをレンダリングし、その状態を正規化された形で表現することで、レデューサーからの更新が容易になることを示しています。コンテナコンポーネントが、レンダリングするツリーノードのみをきめ細かくサブスクライブすることで、優れたレンダリングパフォーマンスを実現しています。</target>
        </trans-unit>
        <trans-unit id="23160794e888b31513354f69f0e10e67f1dfbb27" translate="yes" xml:space="preserve">
          <source>This example includes reading from an asynchronous API, fetching data in response to user input, showing loading indicators, caching the response, and invalidating the cache. It uses &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; middleware to encapsulate asynchronous side effects.</source>
          <target state="translated">この例には、非同期APIからの読み取り、ユーザー入力に応じたデータのフェッチ、読み込みインジケーターの表示、応答のキャッシュ、およびキャッシュの無効化が含まれます。&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt;ミドルウェアを使用して、非同期の副作用をカプセル化します。</target>
        </trans-unit>
        <trans-unit id="6057ac5d12f923863450854603485d162d2c570a" translate="yes" xml:space="preserve">
          <source>This example includes tests.</source>
          <target state="translated">この例にはテストが含まれています。</target>
        </trans-unit>
        <trans-unit id="41942bb35c722938329a0363bb8f7775d2d0a267" translate="yes" xml:space="preserve">
          <source>This example shows important idiomatic Redux patterns that become important as your app grows. In particular, it shows how to store entities in a normalized way by their IDs, how to compose reducers on several levels, and how to define selectors alongside the reducers so the knowledge about the state shape is encapsulated. It also demonstrates logging with &lt;a href=&quot;https://github.com/fcomb/redux-logger&quot;&gt;Redux Logger&lt;/a&gt; and conditional dispatching of actions with &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; middleware.</source>
          <target state="translated">この例は、アプリが成長するにつれて重要になる重要な慣用的なReduxパターンを示しています。特に、IDによってエンティティを正規化された方法で格納する方法、複数のレベルでレデューサーを構成する方法、およびレデューサーと一緒にセレクターを定義して状態の形状に関する知識をカプセル化する方法を示します。また、&lt;a href=&quot;https://github.com/fcomb/redux-logger&quot;&gt;Redux Logger&lt;/a&gt;を使用したロギング、および&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt;ミドルウェアを使用したアクションの条件付きディスパッチも示します。</target>
        </trans-unit>
        <trans-unit id="5a2efc02036a88d2c881bcfa8505561b220da980" translate="yes" xml:space="preserve">
          <source>This function does correctly return a shallow copy of the top-level state object, but because the &lt;code&gt;nestedState&lt;/code&gt; variable was still pointing at the existing object, the state was directly mutated.</source>
          <target state="translated">この関数はトップレベルの状態オブジェクトの浅いコピーを正しく返しますが、 &lt;code&gt;nestedState&lt;/code&gt; 変数がまだ既存のオブジェクトを指しているため、状態は直接変化しました。</target>
        </trans-unit>
        <trans-unit id="25186369f150cbdf9cc822a9194a9d16061eb99f" translate="yes" xml:space="preserve">
          <source>This function helps you organize your reducers to manage their own slices of state, similar to how you would have different Flux Stores to manage different state. With Redux, there is just one store, but &lt;code&gt;combineReducers&lt;/code&gt; helps you keep the same logical division between reducers.</source>
          <target state="translated">この機能は、さまざまな状態を管理するためのさまざまなフラックスストアと同じように、レデューサーを整理して独自の状態のスライスを管理するのに役立ちます。Reduxの場合、ストアは1つだけですが、 &lt;code&gt;combineReducers&lt;/code&gt; は、レデューサー間で論理的に同じ区分を維持するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="1b6fed5d5eb1e62767d1062998c1daeac688f17a" translate="yes" xml:space="preserve">
          <source>This function is mildly opinionated and is skewed towards helping beginners avoid common pitfalls. This is why it attempts to enforce some rules that you don't have to follow if you write the root reducer manually.</source>
          <target state="translated">この機能は軽度の意見であり、初心者がよくある落とし穴を回避できるようにすることを目的としています。このため、ルートレデューサを手動で書いた場合に従わなくてもよいいくつかのルールを強制しようとしています。</target>
        </trans-unit>
        <trans-unit id="bd18efd9ce822617a56ac05dccc19791483c2b46" translate="yes" xml:space="preserve">
          <source>This has the effect of spreading Immutable.JS across your entire codebase, including potentially your components, where you may prefer not to have such external dependencies. Your entire codebase must know what is, and what is not, an Immutable.JS object. It also makes removing Immutable.JS from your app difficult in the future, should you ever need to.</source>
          <target state="translated">これは Immutable.JS をコードベース全体に分散させる効果があります。コードベース全体が、何が Immutable.JS オブジェクトで、何が Immutable.JS オブジェクトではないのかを知っていなければなりません。また、将来必要になった場合にアプリからImmutable.JSを削除することが困難になります。</target>
        </trans-unit>
        <trans-unit id="452cdbd1b5122ca3249e3d165f402ca90ca1b7d3" translate="yes" xml:space="preserve">
          <source>This helper is just a convenience! You can write your own &lt;code&gt;combineReducers&lt;/code&gt; that &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;works differently&lt;/a&gt;, or even assemble the state object from the child reducers manually and write a root reducing function explicitly, like you would write any other function.</source>
          <target state="translated">このヘルパーは便利です！&lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;別&lt;/a&gt;の &lt;code&gt;combineReducers&lt;/code&gt; で動作する独自のCombineReducerを作成するか、他の関数を作成する場合と同様に、子レデューサーから状態オブジェクトを手動でアセンブルし、ルート削減関数を明示的に作成することもできます。</target>
        </trans-unit>
        <trans-unit id="ebc9476c901cfaf7607621afa617534b0f6a0851" translate="yes" xml:space="preserve">
          <source>This implementation isn't usable because it leaves out three important questions:</source>
          <target state="translated">この実装では、3つの重要な質問を省いているため、使い物になりません。</target>
        </trans-unit>
        <trans-unit id="5af3f9d227b391b86b28a8a3163dbc7f9de3e1f6" translate="yes" xml:space="preserve">
          <source>This installs the package that provides the &lt;code&gt;undoable&lt;/code&gt; reducer enhancer.</source>
          <target state="translated">これにより、 &lt;code&gt;undoable&lt;/code&gt; リデューサーエンハンサーを提供するパッケージがインストールされます。</target>
        </trans-unit>
        <trans-unit id="930f0e45185d6f76c2ee37901cdc264e626e46fc" translate="yes" xml:space="preserve">
          <source>This is a basic demonstration of &lt;a href=&quot;../recipes/serverrendering&quot;&gt;server rendering&lt;/a&gt; with Redux and React. It shows how to prepare the initial store state on the server, and pass it down to the client so the client store can boot up from an existing state.</source>
          <target state="translated">これは、ReduxとReact を&lt;a href=&quot;../recipes/serverrendering&quot;&gt;使用したサーバーレンダリングの&lt;/a&gt;基本的なデモです。これは、サーバーでストアの初期状態を準備し、クライアントに渡し、クライアントストアが既存の状態から起動できるようにする方法を示しています。</target>
        </trans-unit>
        <trans-unit id="b54fe358811791887040e3628c693b0d5817b4bb" translate="yes" xml:space="preserve">
          <source>This is a functional programming utility, and is included in Redux as a convenience.</source>
          <target state="translated">これは機能的なプログラミングユーティリティで、便利なものとしてReduxに含まれています。</target>
        </trans-unit>
        <trans-unit id="902e57be6eebfba5d7e76929983c6c6258e9c271" translate="yes" xml:space="preserve">
          <source>This is a glossary of the core terms in Redux, along with their type signatures. The types are documented using &lt;a href=&quot;http://flowtype.org/docs/quick-reference.html&quot;&gt;Flow notation&lt;/a&gt;.</source>
          <target state="translated">これは、Reduxの主要な用語とそのタイプシグネチャの用語集です。タイプは、&lt;a href=&quot;http://flowtype.org/docs/quick-reference.html&quot;&gt;フロー表記法&lt;/a&gt;を使用して文書化されています。</target>
        </trans-unit>
        <trans-unit id="6257b5ee434e5a7cbdec29bbbff466cb0f6850ea" translate="yes" xml:space="preserve">
          <source>This is a long and complex topic, with a wide variety of opinions on how code should be organized and what approaches should be used.</source>
          <target state="translated">コードをどのように整理すべきか、どのようなアプローチをとるべきかなど、さまざまな意見が飛び交う、長くて複雑なトピックです。</target>
        </trans-unit>
        <trans-unit id="e6d24f497bb054862fa8e8a2557607b7b064ec7c" translate="yes" xml:space="preserve">
          <source>This is a particular issue if you use &lt;code&gt;toJS()&lt;/code&gt; in a wrapped component&amp;rsquo;s &lt;code&gt;mapStateToProps&lt;/code&gt; function, as React-Redux shallowly compares each value in the returned props object. For example, the value referenced by the &lt;code&gt;todos&lt;/code&gt; prop returned from &lt;code&gt;mapStateToProps&lt;/code&gt; below will always be a different object, and so will fail a shallow equality check.</source>
          <target state="translated">React-Reduxは返されたpropsオブジェクトの各値を浅く比較するため、ラップされたコンポーネントの &lt;code&gt;mapStateToProps&lt;/code&gt; 関数で &lt;code&gt;toJS()&lt;/code&gt; を使用する場合、これは特定の問題です。たとえば、以下の &lt;code&gt;mapStateToProps&lt;/code&gt; から返された &lt;code&gt;todos&lt;/code&gt; プロパティが参照する値は常に別のオブジェクトになるため、浅い等価性チェックに失敗します。</target>
        </trans-unit>
        <trans-unit id="cf9d83f291ff6e78c4b43b491bded250a9eb9edd" translate="yes" xml:space="preserve">
          <source>This is a place to share common problems and solutions to them.</source>
          <target state="translated">共通の問題点や解決策を共有する場となっています。</target>
        </trans-unit>
        <trans-unit id="a195446956524ddebe615c6b4dea2d58bc44adbd" translate="yes" xml:space="preserve">
          <source>This is a variation on the previous example. It is almost identical, but additionally shows how wrapping your reducer with &lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt; lets you add a Undo/Redo functionality to your app with a few lines of code.</source>
          <target state="translated">これは、前の例のバリエーションです。これはほとんど同じですが、リデューサーを&lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undoで&lt;/a&gt;ラップすることで、数行のコードでアプリにUndo / Redo機能を追加する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="0b62f6d500da56c6baedf79190677dba7f4254d1" translate="yes" xml:space="preserve">
          <source>This is all we need to know for now. The particular mechanism to dispatch these actions together with network requests will be discussed later.</source>
          <target state="translated">今のところ知っておく必要があるのはこれだけです。これらのアクションをネットワークリクエストと一緒にディスパッチする特定のメカニズムについては後述します。</target>
        </trans-unit>
        <trans-unit id="eb3caec81383b1f746ae38119a27f33a05999d77" translate="yes" xml:space="preserve">
          <source>This is already closer to what we want! No matter where we dispatch an action, it is guaranteed to be logged. Monkeypatching never feels right, but we can live with this for now.</source>
          <target state="translated">これはもう、私たちが望むものに近づいています! どこにアクションを派遣しても、それは記録されることが保証されています。モンキーパッチは決して正しいとは思えないが、今のところはこれで生きていける。</target>
        </trans-unit>
        <trans-unit id="f9084a2b0e6567c9efcaf4f6cafe694a18afbf28" translate="yes" xml:space="preserve">
          <source>This is already looking good! When the app is larger, we can split the reducers into separate files and keep them completely independent and managing different data domains.</source>
          <target state="translated">これはもう、いい感じですね! アプリが大きくなったら、レデューサーを別のファイルに分割して、完全に独立して別のデータ領域を管理するようにしています。</target>
        </trans-unit>
        <trans-unit id="6e84b6d20c865b455ea1e36d59bd6ef0bdf66609" translate="yes" xml:space="preserve">
          <source>This is basically the whole idea of Redux. Note that we haven&amp;rsquo;t used any Redux APIs. It comes with a few utilities to facilitate this pattern, but the main idea is that you describe how your state is updated over time in response to action objects, and 90% of the code you write is just plain JavaScript, with no use of Redux itself, its APIs, or any magic.</source>
          <target state="translated">これは基本的にReduxの全体的な考え方です。Redux APIを使用していないことに注意してください。このパターンを容易にするいくつかのユーティリティが付属していますが、主なアイデアは、アクションオブジェクトに応じて状態が時間とともに更新される方法を説明することであり、作成するコードの90％は単なるJavaScriptであり、Reduxを使用しませんそれ自体、そのAPI、または魔法。</target>
        </trans-unit>
        <trans-unit id="1d949a0761f2189999f3ad52f3288abf9de3a495" translate="yes" xml:space="preserve">
          <source>This is because two variables that reference the same object will &lt;em&gt;always&lt;/em&gt; be equal, regardless of whether the object&amp;rsquo;s values changes or not, as they're both referencing the same object. Thus, the following will always return true:</source>
          <target state="translated">これは、同じオブジェクトを参照している2つの変数は、オブジェクトの値が変更されたかどうかに関係なく、&lt;em&gt;常に&lt;/em&gt;同じオブジェクトを参照しているため、&lt;em&gt;常に&lt;/em&gt;等しいためです。したがって、以下は常にtrueを返します。</target>
        </trans-unit>
        <trans-unit id="fc3fc2dfb4922ecd32a6e14514c4b08ea0d0030f" translate="yes" xml:space="preserve">
          <source>This is it! Run &lt;code&gt;npm install&lt;/code&gt; and &lt;code&gt;npm start&lt;/code&gt; in the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;example folder&lt;/a&gt; and try it out!</source>
          <target state="translated">これだよ！&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;サンプルフォルダー&lt;/a&gt;で &lt;code&gt;npm install&lt;/code&gt; と &lt;code&gt;npm start&lt;/code&gt; を実行して、試してみてください！</target>
        </trans-unit>
        <trans-unit id="7e796128df0ba3814b3885d8d0519693c9b9ad24" translate="yes" xml:space="preserve">
          <source>This is much less typing! If you'd like, you can still have &amp;ldquo;vanilla&amp;rdquo; action creators like &lt;code&gt;loadPostsSuccess&lt;/code&gt; which you'd use from a container &lt;code&gt;loadPosts&lt;/code&gt; action creator.</source>
          <target state="translated">これはタイピングがはるかに少ないです！必要に &lt;code&gt;loadPostsSuccess&lt;/code&gt; て、コンテナーの &lt;code&gt;loadPosts&lt;/code&gt; アクションクリエーターから使用するloadPostsSuccessなどの「バニラ」アクションクリエーターを引き続き使用できます。</target>
        </trans-unit>
        <trans-unit id="eb9aca90fe801173ceb6b822d63183ddbc28a375" translate="yes" xml:space="preserve">
          <source>This is the basic structure that a typical Redux reducer function uses.</source>
          <target state="translated">これは、代表的なReduxのレデューサ関数が使用する基本的な構造です。</target>
        </trans-unit>
        <trans-unit id="368280f7bdb144d919f7347598b1d6a5599ac6c1" translate="yes" xml:space="preserve">
          <source>This is the best example to get a deeper understanding of how the state updates work together with components in Redux. It shows how reducers can delegate handling actions to other reducers, and how you can use &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; to generate container components from your presentational components.</source>
          <target state="translated">これは、状態の更新がReduxのコンポーネントとどのように連携するかをより深く理解するための最良の例です。リデューサーが処理アクションを他のリデューサーに委任する方法、および&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;を使用してプレゼンテーションコンポーネントからコンテナーコンポーネントを生成する方法を示します。</target>
        </trans-unit>
        <trans-unit id="7c0930eaef048e02ff0d006be39c4d3167f83671" translate="yes" xml:space="preserve">
          <source>This is the classical &lt;a href=&quot;http://todomvc.com/&quot;&gt;TodoMVC&lt;/a&gt; example. It's here for the sake of comparison, but it covers the same points as the Todos example.</source>
          <target state="translated">これは古典的な&lt;a href=&quot;http://todomvc.com/&quot;&gt;TodoMVCの&lt;/a&gt;例です。比較のためにここにありますが、Todosの例と同じ点をカバーしています。</target>
        </trans-unit>
        <trans-unit id="881a664225fae7f2e081dcac2b6413fc1deac116" translate="yes" xml:space="preserve">
          <source>This is the complete source code of the Reddit headline fetching example we built during the &lt;a href=&quot;index&quot;&gt;advanced tutorial&lt;/a&gt;.</source>
          <target state="translated">これは、&lt;a href=&quot;index&quot;&gt;高度なチュートリアルで&lt;/a&gt;作成したRedditのヘッドラインフェッチのサンプルの完全なソースコードです。</target>
        </trans-unit>
        <trans-unit id="b128d306a5e5a953daf8f443d8e01801093f1c92" translate="yes" xml:space="preserve">
          <source>This is the complete source code of the tiny todo app we built during the &lt;a href=&quot;index&quot;&gt;basics tutorial&lt;/a&gt;.</source>
          <target state="translated">これは、&lt;a href=&quot;index&quot;&gt;基本チュートリアルで&lt;/a&gt;作成した小さなtodoアプリの完全なソースコードです。</target>
        </trans-unit>
        <trans-unit id="bc3837809c1d7850b463c21cec48fd076bd0bf1f" translate="yes" xml:space="preserve">
          <source>This is the most advanced example. It is dense by design. It covers keeping fetched entities in a normalized cache, implementing a custom middleware for API calls, rendering partially loaded data, pagination, caching responses, displaying error messages, and routing. Additionally, it includes Redux DevTools.</source>
          <target state="translated">これが最上級の例です。設計上、密度が高いです。フェッチされたエンティティを正規化されたキャッシュに保持すること、API 呼び出し用のカスタム ミドルウェアの実装、部分的にロードされたデータのレンダリング、ページネーション、レスポンスのキャッシュ、エラーメッセージの表示、およびルーティングをカバーしています。さらに、Redux DevToolsも含まれています。</target>
        </trans-unit>
        <trans-unit id="2c30e411c7f43679e4c0b5f0869178bc002c0cf5" translate="yes" xml:space="preserve">
          <source>This is the most basic example of using Redux together with React. For simplicity, it re-renders the React component manually when the store changes. In real projects, you will likely want to use the highly performant &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; bindings instead.</source>
          <target state="translated">これは、Reuxと一緒にReduxを使用する最も基本的な例です。簡単にするために、ストアが変更されると、Reactコンポーネントを手動で再レンダリングします。実際のプロジェクトでは、代わりに高性能の&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;バインディングを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="45b51f5c0e7ff3cf14ba10063daa88c68ff8ff42" translate="yes" xml:space="preserve">
          <source>This is worth emphasising: &lt;em&gt;If the reducers all return the same &lt;code&gt;state&lt;/code&gt; object passed to them, then &lt;code&gt;combineReducers&lt;/code&gt; will return the &lt;em&gt;current&lt;/em&gt; root state object, not the newly updated one.&lt;/em&gt;</source>
          <target state="translated">これは強調する価値があります。&lt;em&gt;すべてのレデューサーが渡された同じ &lt;code&gt;state&lt;/code&gt; オブジェクトを返す場合、 &lt;code&gt;combineReducers&lt;/code&gt; は新しく更新されたオブジェクトではなく、&lt;em&gt;現在の&lt;/em&gt;ルート状態オブジェクトを返します。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="903f50f13ad03393a3f2547dd8b1848ec4cbcd1e" translate="yes" xml:space="preserve">
          <source>This issue can be avoided by &lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;uncoupling your application logic from your data structures&lt;/a&gt;, as outlined in the &lt;a href=&quot;#immutable-js-best-practices&quot;&gt;best practices section&lt;/a&gt; below.</source>
          <target state="translated">この問題は、以下の&lt;a href=&quot;#immutable-js-best-practices&quot;&gt;ベストプラクティスセクションで&lt;/a&gt;概説&lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;するように&lt;/a&gt;、アプリケーションロジックをデータ構造から切り離すことで回避できます。</target>
        </trans-unit>
        <trans-unit id="584dbd560993face7c721c8a75c7abf6bb57ad23" translate="yes" xml:space="preserve">
          <source>This lets us write more sophisticated async control flow gradually, while the consuming code can stay pretty much the same:</source>
          <target state="translated">これにより、より洗練された非同期制御フローを徐々に書くことができますが、消費するコードはほとんど変わりません。</target>
        </trans-unit>
        <trans-unit id="f2f3d7f982ac8af695c62a8985d12ce4b3081ba8" translate="yes" xml:space="preserve">
          <source>This makes it awkward to interoperate not just with your own code, but also with other libraries, such as lodash or ramda, that expect plain JavaScript objects.</source>
          <target state="translated">このため、あなた自身のコードだけでなく、lodash や ramda のような、プレーンな JavaScript オブジェクトを期待している他のライブラリとの相互運用が厄介になります。</target>
        </trans-unit>
        <trans-unit id="8150ebb2edf39875f24f4fc61c627e5d2769703b" translate="yes" xml:space="preserve">
          <source>This makes it easier for bundling tools to cut out unneeded modules and reduces the size of your builds.</source>
          <target state="translated">これにより、ツールを束ねて不要なモジュールをカットしたり、ビルドのサイズを小さくしたりすることが容易になります。</target>
        </trans-unit>
        <trans-unit id="cf383b9f03a180ee3b947f3cafa81eed01efef2e" translate="yes" xml:space="preserve">
          <source>This makes it easy to create universal apps, as the state from your server can be serialized and hydrated into the client with no extra coding effort. A single state tree also makes it easier to debug or inspect an application; it also enables you to persist your app's state in development, for a faster development cycle. Some functionality which has been traditionally difficult to implement - Undo/Redo, for example - can suddenly become trivial to implement, if all of your state is stored in a single tree.</source>
          <target state="translated">これにより、サーバーからの状態をシリアル化して、余分なコーディング作業なしにクライアントに反映させることができるため、ユニバーサルアプリを簡単に作成することができます。また、単一のステートツリーは、アプリケーションのデバッグや検査を容易にします。また、開発中のアプリの状態を永続化して開発サイクルを短縮することもできます。例えば、元に戻す/やり直すなど、従来は実装が難しかった機能も、すべての状態が単一のツリーに保存されていれば、突然実装が簡単になります。</target>
        </trans-unit>
        <trans-unit id="a7a113870425edd65d4dff2ca88a4e416744f63a" translate="yes" xml:space="preserve">
          <source>This makes it easy to migrate both to and from Redux.</source>
          <target state="translated">これにより、Reduxへの移行もReduxからの移行も簡単になります。</target>
        </trans-unit>
        <trans-unit id="6870275e1cdc117fad62310af9bce1130ddad1e5" translate="yes" xml:space="preserve">
          <source>This makes them portable and easy to test.</source>
          <target state="translated">そのため、持ち運びができ、テストも簡単です。</target>
        </trans-unit>
        <trans-unit id="0117d509de0b7ec1b99dd909691fb32267c2c284" translate="yes" xml:space="preserve">
          <source>This means that all data in an application follows the same lifecycle pattern, making the logic of your app more predictable and easier to understand. It also encourages data normalization, so that you don't end up with multiple, independent copies of the same data that are unaware of one another.</source>
          <target state="translated">これは、アプリケーション内のすべてのデータが同じライフサイクルパターンに従うことを意味し、アプリのロジックをより予測しやすく、理解しやすくします。また、データの正規化も促進されるため、同じデータの複数の独立したコピーがお互いに気づかないままになってしまうこともありません。</target>
        </trans-unit>
        <trans-unit id="f34593a4e623dbcb3f458552c5cd1622e7dfef63" translate="yes" xml:space="preserve">
          <source>This means that implementing Undo and Redo in an MVC application usually forces you to rewrite parts of your application to use a specific data mutation pattern like &lt;a href=&quot;https://en.wikipedia.org/wiki/Command_pattern&quot;&gt;Command&lt;/a&gt;.</source>
          <target state="translated">これは、MVCアプリケーションに元に戻すとやり直しを実装すると、通常、&lt;a href=&quot;https://en.wikipedia.org/wiki/Command_pattern&quot;&gt;コマンドの&lt;/a&gt;ような特定のデータ変更パターンを使用するようにアプリケーションの一部を書き換える必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="fc5b85dff1510174b626939c1704dc6629908600" translate="yes" xml:space="preserve">
          <source>This means that we could also write the insert and remove functions like this:</source>
          <target state="translated">つまり、このような挿入・削除関数も書けるということです。</target>
        </trans-unit>
        <trans-unit id="cbde7ae30a809fab338b95f7689a7203a8a17b4d" translate="yes" xml:space="preserve">
          <source>This means you need to access your state with &lt;code&gt;state.todos.present&lt;/code&gt; instead of just &lt;code&gt;state.todos&lt;/code&gt;:</source>
          <target state="translated">この手段は、あなたがあなたの状態にアクセスする必要が &lt;code&gt;state.todos.present&lt;/code&gt; だけではなくの &lt;code&gt;state.todos&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="386fbee61a70c4b922b5caaee2907587414b6c05" translate="yes" xml:space="preserve">
          <source>This mutated copy is a &lt;em&gt;separate&lt;/em&gt; object from that passed into the function, and so when it is returned, a shallow check will identify it as being a different object from that passed in, and so will fail.</source>
          <target state="translated">この変更されたコピーは、関数に渡されたものとは&lt;em&gt;別の&lt;/em&gt;オブジェクトであるため、返されると、浅いチェックにより、渡されたものとは異なるオブジェクトとして識別され、失敗します。</target>
        </trans-unit>
        <trans-unit id="ca74d22b1244f1a72be0424378b1b4d590fc1e51" translate="yes" xml:space="preserve">
          <source>This new tree is now the next state of your app! Every listener registered with &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;store.subscribe(listener)&lt;/code&gt;&lt;/a&gt; will now be invoked; listeners may call &lt;a href=&quot;../api/store#getState&quot;&gt;&lt;code&gt;store.getState()&lt;/code&gt;&lt;/a&gt; to get the current state.</source>
          <target state="translated">この新しいツリーがアプリの次の状態になりました！&lt;a href=&quot;../api/store#subscribe&quot;&gt; &lt;code&gt;store.subscribe(listener)&lt;/code&gt; で&lt;/a&gt;登録されたすべてのリスナーが呼び出されます。リスナーは、&lt;a href=&quot;../api/store#getState&quot;&gt; &lt;code&gt;store.getState()&lt;/code&gt; &lt;/a&gt;を呼び出して現在の状態を取得できます。</target>
        </trans-unit>
        <trans-unit id="375420430845c3b31d4e0a7e67b9eb12e1e064ee" translate="yes" xml:space="preserve">
          <source>This object is like a &amp;ldquo;model&amp;rdquo; except that there are no setters. This is so that different parts of the code can&amp;rsquo;t change the state arbitrarily, causing hard-to-reproduce bugs.</source>
          <target state="translated">このオブジェクトは、セッターがないことを除いて「モデル」に似ています。これは、コードのさまざまな部分が状態を勝手に変更できず、再現が難しいバグを引き起こすためです。</target>
        </trans-unit>
        <trans-unit id="10b96d7bed30bd18afc4040b966809bdd54e8f1c" translate="yes" xml:space="preserve">
          <source>This part is often confusing to beginners, because it is not immediately clear what information describes the state of an asynchronous application, and how to organize it in a single tree.</source>
          <target state="translated">この部分は、どのような情報が非同期アプリケーションの状態を記述しているのか、どのように1つのツリーにまとめればよいのかがすぐにはわからないため、初心者には戸惑うことが多いです。</target>
        </trans-unit>
        <trans-unit id="726e2aa43c64e8c49eac59a956f48c4350c3da4d" translate="yes" xml:space="preserve">
          <source>This pattern is &lt;em&gt;not&lt;/em&gt; recommended for parts of the same app that share data. However, it can be useful when the bigger app has zero access to the smaller apps' internals, and we'd like to keep the fact that they are implemented with Redux as an implementation detail. Each component instance will have its own store, so they won't &amp;ldquo;know&amp;rdquo; about each other.</source>
          <target state="translated">このパターンは、データを共有する同じアプリの部分には推奨され&lt;em&gt;ません&lt;/em&gt;。ただし、大きなアプリが小さなアプリの内部にアクセスできない場合に役立ちます。実装の詳細としてReduxで実装されているという事実を維持したいと考えています。各コンポーネントインスタンスは独自のストアを持つため、お互いについて「知る」ことはありません。</target>
        </trans-unit>
        <trans-unit id="4797209ab61d0cba555b0ba999e5df76ff770f2a" translate="yes" xml:space="preserve">
          <source>This problem is caused predominantly by returning a mutated state object from a Redux reducer. With Immutable.JS, this problem simply does not exist, thereby removing a whole class of bugs from your app.</source>
          <target state="translated">この問題は、主にReduxのレデューサーから突然変異したステートオブジェクトを返すことで発生します。Immutable.JSでは、この問題は存在しないので、アプリからバグの全クラスを取り除くことができます。</target>
        </trans-unit>
        <trans-unit id="faee56a051b54fbdf7c577f45ce201c8fd514250" translate="yes" xml:space="preserve">
          <source>This produces the desired effect, but you wouldn't want to do it every time.</source>
          <target state="translated">これは期待通りの効果が得られますが、毎回はやりたくないでしょう。</target>
        </trans-unit>
        <trans-unit id="112bf8b2448707863e70924e561703fd39856861" translate="yes" xml:space="preserve">
          <source>This project adheres to &lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning&lt;/a&gt;.</source>
          <target state="translated">このプロジェクトは、&lt;a href=&quot;http://semver.org/&quot;&gt;セマンティックバージョニングに&lt;/a&gt;準拠しています。</target>
        </trans-unit>
        <trans-unit id="9ca436d5a0e732efb5749020024d046800e0f232" translate="yes" xml:space="preserve">
          <source>This requires the least amount of work on the reducer side, but does require that the action creator potentially do a fair amount of work to organize the data into the correct shape before the action is dispatched. It also doesn't handle trying to delete an item.</source>
          <target state="translated">これは、レデューサ側での作業量が最も少なくて済みますが、アクションがディスパッチされる前にデータを正しい形に整理するために、アクション作成者がかなりの作業を行う必要があります。また、アイテムを削除しようとしても処理されません。</target>
        </trans-unit>
        <trans-unit id="2e32344333ff16130ad1fc8d8911f91949fab05e" translate="yes" xml:space="preserve">
          <source>This section documents the complete Redux API. Keep in mind that Redux is only concerned with managing the state. In a real app, you'll also want to use UI bindings like &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt;.</source>
          <target state="translated">このセクションでは、完全なRedux APIについて説明します。Reduxは状態の管理のみに関係していることに注意してください。実際のアプリでは、&lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-reduxの&lt;/a&gt;ようなUIバインディングも使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="8e4e2606978c9371c54128bb24c749164cec9f04" translate="yes" xml:space="preserve">
          <source>This section introduces a hypothetical extension to our app that allows it to support multiple Todo Lists. Please note that a full implementation of this extension requires changes to the reducers, components, actions etc. that aren't directly relevant to the topics discussed and have been omitted for brevity.</source>
          <target state="translated">このセクションでは、複数の Todo リストをサポートするためのアプリの仮想的な拡張機能を紹介します。この拡張機能を完全に実装するには、レデューサー、コンポーネント、アクションなどの変更が必要になります。</target>
        </trans-unit>
        <trans-unit id="d91b745838a2d3e64174d93a13b4a7f1adc65cd3" translate="yes" xml:space="preserve">
          <source>This state shape better reflects the data involved, because we took care to set up the keys we passed to &lt;code&gt;combineReducers&lt;/code&gt;.</source>
          <target state="translated">この状態の形状は、関連するデータをより適切に反映しています。 &lt;code&gt;combineReducers&lt;/code&gt; 、CombineReducersに渡したキーを設定するように注意したからです。</target>
        </trans-unit>
        <trans-unit id="125428949dd664c2936fb5646d4a4a0944ef542f" translate="yes" xml:space="preserve">
          <source>This state structure is much flatter overall. Compared to the original nested format, this is an improvement in several ways:</source>
          <target state="translated">このステート構造は、全体的にはるかにフラットになっています。オリジナルのネストされたフォーマットと比較して、これはいくつかの点で改善されています。</target>
        </trans-unit>
        <trans-unit id="94ba4d7a3e72dccff4a9100d843bda3c33581bff" translate="yes" xml:space="preserve">
          <source>This was all very informative, but can't we just drop a library and use it instead of implementing &lt;code&gt;undoable&lt;/code&gt; ourselves? Sure, we can! Meet &lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt;, a library that provides simple Undo and Redo functionality for any part of your Redux tree.</source>
          <target state="translated">これはすべて非常に有益でしたが、ライブラリをドロップして、元に &lt;code&gt;undoable&lt;/code&gt; で実装する代わりにそれを使用することはできませんか？もちろんできるよ！ミート&lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Reduxの元に戻す&lt;/a&gt;、あなたの再来ツリーの任意の部分のための簡単なアンドゥやリドゥ機能を提供するライブラリ。</target>
        </trans-unit>
        <trans-unit id="96ab6b14f2ef0811b01a8fd50008edc6febd0745" translate="yes" xml:space="preserve">
          <source>This wasn't difficult, was it? Redux doesn't provide such a helper function by default because there are many ways to write it. Maybe you want it to automatically convert plain JS objects to Immutable objects to hydrate the server state. Maybe you want to merge the returned state with the current state. There may be different approaches to a &amp;ldquo;catch all&amp;rdquo; handler. All of this depends on the conventions you choose for your team on a specific project.</source>
          <target state="translated">難しいことではありませんでしたか？Reduxでは、このようなヘルパー関数を作成する方法がたくさんあるため、デフォルトでは提供していません。おそらく、プレーンなJSオブジェクトを不変オブジェクトに自動的に変換して、サーバーの状態をハイドレートさせたい場合があります。おそらく、返された状態を現在の状態とマージしたいでしょう。「catch all」ハンドラーにはさまざまなアプローチがあるかもしれません。これはすべて、特定のプロジェクトでチーム用に選択した規則によって異なります。</target>
        </trans-unit>
        <trans-unit id="445c1e6f198a1adb4c272f78fb177f8661af0686" translate="yes" xml:space="preserve">
          <source>This way every instance will be independent.</source>
          <target state="translated">こうすることで、すべてのインスタンスが独立したものになります。</target>
        </trans-unit>
        <trans-unit id="92e38ef43aaabbe31217e626c55343afb37a1c0f" translate="yes" xml:space="preserve">
          <source>This, together with its performance and rich API for data manipulation, is why Immutable.JS is worth the effort.</source>
          <target state="translated">これが、そのパフォーマンスとデータ操作のための豊富なAPIと相まって、Immutable.JSが努力する価値がある理由です。</target>
        </trans-unit>
        <trans-unit id="a60662bb0cf6dca00077914648ad22d8b2ebadfe" translate="yes" xml:space="preserve">
          <source>Three Principles</source>
          <target state="translated">三原則</target>
        </trans-unit>
        <trans-unit id="45a585aa3738a0a8dc2ee89ca5d822a00a010018" translate="yes" xml:space="preserve">
          <source>Thunk middleware is just one example of middleware. Middleware is not about &amp;ldquo;letting you dispatch functions&amp;rdquo;. It's about letting you dispatch anything that the particular middleware you use knows how to handle. Thunk middleware adds a specific behavior when you dispatch functions, but it really depends on the middleware you use.</source>
          <target state="translated">サンクミドルウェアは、ミドルウェアの一例にすぎません。ミドルウェアは、「関数をディスパッチさせる」ことではありません。それは、使用する特定のミドルウェアが処理方法を知っているものをディスパッチさせることです。サンクミドルウェアは、関数をディスパッチするときに特定の動作を追加しますが、実際には、使用するミドルウェアによって異なります。</target>
        </trans-unit>
        <trans-unit id="031dd77e620cd8fc8065335ff0e03be8cb20884f" translate="yes" xml:space="preserve">
          <source>Time-travel debugging requires that reducers be pure functions with no side effects, so that you can correctly jump between different states.</source>
          <target state="translated">タイムトラベルデバッグでは、異なる状態間を正しくジャンプできるように、レデューサは副作用のない純粋な関数である必要があります。</target>
        </trans-unit>
        <trans-unit id="4cf1b54b003a59c279d1ba0b615a8a5f3459ca8c" translate="yes" xml:space="preserve">
          <source>Tips</source>
          <target state="translated">Tips</target>
        </trans-unit>
        <trans-unit id="ee1f5ebc6cc52d4f51b113f5097b8455a407c4ed" translate="yes" xml:space="preserve">
          <source>Tips For a Better Redux Architecture: Lessons for Enterprise Scale</source>
          <target state="translated">より良いReduxアーキテクチャのためのヒント。エンタープライズ・スケールのための教訓</target>
        </trans-unit>
        <trans-unit id="901c769f8e578666848aa3aae81fe0b1028b6236" translate="yes" xml:space="preserve">
          <source>Tips to Handle Authentication in Redux</source>
          <target state="translated">Reduxで認証を処理するためのヒント</target>
        </trans-unit>
        <trans-unit id="e74f240f49222ea150d6391c54e16b213cd2b1cd" translate="yes" xml:space="preserve">
          <source>To apply multiple store enhancers, you may use &lt;a href=&quot;compose&quot;&gt;&lt;code&gt;compose()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">複数のストアエンハンサーを適用するには、&lt;a href=&quot;compose&quot;&gt; &lt;code&gt;compose()&lt;/code&gt; を&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="6e0f538cbe1b062d76f03414cbe7f487e9b2e5a6" translate="yes" xml:space="preserve">
          <source>To avoid these issues, ensure you follow the recommended &lt;a href=&quot;../recipes/reducers/immutableupdatepatterns&quot;&gt;immutable update patterns for ES6&lt;/a&gt;.</source>
          <target state="translated">これらの問題を回避するには、&lt;a href=&quot;../recipes/reducers/immutableupdatepatterns&quot;&gt;ES6の&lt;/a&gt;推奨される不変の更新パターンに従ってください。</target>
        </trans-unit>
        <trans-unit id="2f92fd6720446a22647fac455b49ebc045cfee8c" translate="yes" xml:space="preserve">
          <source>To change data</source>
          <target state="translated">データを変更するには</target>
        </trans-unit>
        <trans-unit id="6565dc46b441e1305f44f9389c074e1086ac2ba7" translate="yes" xml:space="preserve">
          <source>To change something in the state, you need to dispatch an action. An action is a plain JavaScript object (notice how we don&amp;rsquo;t introduce any magic?) that describes what happened. Here are a few example actions:</source>
          <target state="translated">状態を変更するには、アクションをディスパッチする必要があります。アクションは、何が起こったのかを説明するプレーンなJavaScriptオブジェクトです（マジックを導入しないことに注意してください）。アクションの例をいくつか示します。</target>
        </trans-unit>
        <trans-unit id="eda24989c78e46dab8c06cd8412d3b18d2d68eab" translate="yes" xml:space="preserve">
          <source>To create it, pass your root &lt;a href=&quot;../glossary#reducer&quot;&gt;reducing function&lt;/a&gt; to &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これを作成するには、ルート&lt;a href=&quot;../glossary#reducer&quot;&gt;削減関数&lt;/a&gt;を&lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; &lt;/a&gt;に渡します。</target>
        </trans-unit>
        <trans-unit id="ac7a33667ce69790c31c3c6959a00eb15d3762e3" translate="yes" xml:space="preserve">
          <source>To do this, it assumes that the wrapped component is pure; that is, that the component will produce the &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/f4d55840a14601c3a5bdc0c3d741fc5753e87f66/docs/troubleshooting.md#my-views-arent-updating-when-something-changes-outside-of-redux&quot;&gt;same results given the same props and state&lt;/a&gt;.</source>
          <target state="translated">これを行うには、ラップされたコンポーネントが純粋であると想定します。つまり&lt;a href=&quot;https://github.com/reactjs/react-redux/blob/f4d55840a14601c3a5bdc0c3d741fc5753e87f66/docs/troubleshooting.md#my-views-arent-updating-when-something-changes-outside-of-redux&quot;&gt;、同じ小道具と状態が与えられた場合&lt;/a&gt;、コンポーネントは同じ結果を生成します。</target>
        </trans-unit>
        <trans-unit id="29e591a3897c0d0b177067748378b071109328ac" translate="yes" xml:space="preserve">
          <source>To ensure that you may only apply middleware once, it operates on &lt;code&gt;createStore()&lt;/code&gt; rather than on &lt;code&gt;store&lt;/code&gt; itself. Instead of &lt;code&gt;(store, middlewares) =&amp;gt; store&lt;/code&gt;, its signature is &lt;code&gt;(...middlewares) =&amp;gt; (createStore) =&amp;gt; createStore&lt;/code&gt;.</source>
          <target state="translated">ミドルウェアを一度だけ適用できるようにするために、ミドルウェアは &lt;code&gt;store&lt;/code&gt; 自体ではなく &lt;code&gt;createStore()&lt;/code&gt; で動作します。 &lt;code&gt;(store, middlewares) =&amp;gt; store&lt;/code&gt; 代わりに、その署名は &lt;code&gt;(...middlewares) =&amp;gt; (createStore) =&amp;gt; createStore&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6b6f0480002ee862ea4e286d796db8dca014c865" translate="yes" xml:space="preserve">
          <source>To hide Redux behind a React API, we can wrap it in a special component that initializes the store in the constructor:</source>
          <target state="translated">React APIの後ろにReduxを隠すために、コンストラクタでストアを初期化する特別なコンポーネントでReduxを包むことができます。</target>
        </trans-unit>
        <trans-unit id="3a523db44ce0192bb638d90e57a1f49df365f204" translate="yes" xml:space="preserve">
          <source>To install the stable version:</source>
          <target state="translated">安定版をインストールするには</target>
        </trans-unit>
        <trans-unit id="598097c2e73e4e488253e6050c3375112c094ef7" translate="yes" xml:space="preserve">
          <source>To learn how to describe asynchronous API calls, read the current state inside action creators, perform side effects, or chain them to execute in a sequence, see the examples for &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">非同期API呼び出しを記述する方法、アクションクリエーター内の現在の状態を読み取る方法、副作用を実行する方法、または連鎖して実行する方法については、&lt;a href=&quot;applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware&lt;/code&gt; &lt;/a&gt;の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="6ed8cb192b488a31ce6935bdfe7a74665d721d67" translate="yes" xml:space="preserve">
          <source>To log the action and state, you can change it to something like this:</source>
          <target state="translated">アクションや状態をログに記録するには、こんな感じに変更します。</target>
        </trans-unit>
        <trans-unit id="a5f1cce2ba9b1ff85191ae7e2687f49081a21c5b" translate="yes" xml:space="preserve">
          <source>To prevent this from happening, you must &lt;em&gt;always return the state slice object that&amp;rsquo;s passed into a reducer if the reducer does not mutate the state.&lt;/em&gt;</source>
          <target state="translated">これが発生&lt;em&gt;しないようにするには、レデューサーが状態を変更しない場合、レデューサーに渡される状態スライスオブジェクトを常に返す&lt;/em&gt;必要があります&lt;em&gt;。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="89ea208e2cc969561f1309636abe373b57da32a9" translate="yes" xml:space="preserve">
          <source>To read data</source>
          <target state="translated">データを読み込むには</target>
        </trans-unit>
        <trans-unit id="eed3ad29a679d760cf82b7215bd55f2febaeba23" translate="yes" xml:space="preserve">
          <source>To resolve this issue, use a browser extension such as the &lt;a href=&quot;https://chrome.google.com/webstore/detail/immutablejs-object-format/hgldghadipiblonfkkicmgcbbijnpeog&quot;&gt;Immutable.js Object Formatter&lt;/a&gt;, which surfaces your data in Chrome Dev Tools, and hides Immutable.JS&amp;rsquo;s properties when inspecting your data.</source>
          <target state="translated">この問題を解決するには、&lt;a href=&quot;https://chrome.google.com/webstore/detail/immutablejs-object-format/hgldghadipiblonfkkicmgcbbijnpeog&quot;&gt;Immutable.js Object Formatter&lt;/a&gt;などのブラウザー拡張機能を使用します。これにより、Chrome Dev Toolsにデータが表示され、データの検査時にImmutable.JSのプロパティが非表示になります。</target>
        </trans-unit>
        <trans-unit id="2401479a503b53af9fbceea514e83457e1c292ef" translate="yes" xml:space="preserve">
          <source>To send the data down to the client, we need to:</source>
          <target state="translated">クライアントにデータを送るためには</target>
        </trans-unit>
        <trans-unit id="2ab24a1445cfb045dd93cf66376dc281c3f5f6bd" translate="yes" xml:space="preserve">
          <source>To specify how the actions transform the state tree, you write pure &lt;em&gt;reducers&lt;/em&gt;.</source>
          <target state="translated">アクションが状態ツリーを変換する方法を指定するには、純粋な&lt;em&gt;レデューサー&lt;/em&gt;を作成します。</target>
        </trans-unit>
        <trans-unit id="50ef1b259d84757adca29f3df1d2d641b6eec11c" translate="yes" xml:space="preserve">
          <source>To sum this up, if you stick to Redux conventions and return the initial state from reducers when they're called with &lt;code&gt;undefined&lt;/code&gt; as the &lt;code&gt;state&lt;/code&gt; argument (the easiest way to implement this is to specify the &lt;code&gt;state&lt;/code&gt; ES6 default argument value), you're going to have a nice useful behavior for combined reducers. &lt;strong&gt;They will prefer the corresponding value in the &lt;code&gt;preloadedState&lt;/code&gt; object you pass to the &lt;code&gt;createStore()&lt;/code&gt; function, but if you didn't pass any, or if the corresponding field is not set, the default &lt;code&gt;state&lt;/code&gt; argument specified by the reducer is chosen instead.&lt;/strong&gt; This approach works well because it provides both initialization and hydration of existing data, but lets individual reducers reset their state if their data was not preserved. Of course you can apply this pattern recursively, as you can use &lt;code&gt;combineReducers()&lt;/code&gt; on many levels, or even compose reducers manually by calling reducers and giving them the relevant part of the state tree.</source>
          <target state="translated">これを要約すると、Reduxの規則に固執し、 &lt;code&gt;state&lt;/code&gt; 引数として &lt;code&gt;undefined&lt;/code&gt; で呼び出されたときにレデューサーから初期状態を返す場合（これを実装する最も簡単な方法は、 &lt;code&gt;state&lt;/code&gt; ES6のデフォルト引数値を指定することです）、結合されたレデューサーに便利な動作を提供します。&lt;strong&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;関数に&lt;/strong&gt;&lt;strong&gt;渡す&lt;/strong&gt;&lt;strong&gt;preloadedState&lt;/strong&gt;&lt;strong&gt;オブジェクトの&lt;/strong&gt;&lt;strong&gt;対応する値が優先&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;preloadedState&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;ます&lt;/strong&gt;&lt;strong&gt;が、何も渡さなかった場合、または対応するフィールドが設定されていない場合は、&lt;/strong&gt;&lt;strong&gt;代わりに、レデューサーによって指定された&lt;/strong&gt;&lt;strong&gt;デフォルトの&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;state&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;引数が選択されます。&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;このアプローチは、既存のデータの初期化とハイドレーションの両方を提供するのでうまく機能しますが、データが保存されなかった場合、個々のレデューサーが状態をリセットできます。もちろん、このパターンを再帰的に適用することもできます &lt;code&gt;combineReducers()&lt;/code&gt; を多くのレベルで使用したり、レデューサーを呼び出して状態ツリーの関連部分を提供することで手動でレデューサーを作成したりすることもできます。</target>
        </trans-unit>
        <trans-unit id="d8cdb0c4afd8333274d4833966816662659fdba2" translate="yes" xml:space="preserve">
          <source>To test the components we make a &lt;code&gt;setup()&lt;/code&gt; helper that passes the stubbed callbacks as props and renders the component with &lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;shallow rendering&lt;/a&gt;. This lets individual tests assert on whether the callbacks were called when expected.</source>
          <target state="translated">コンポーネントをテストするために、スタブ化されたコールバックを小道具として渡し、&lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;浅いレンダリングで&lt;/a&gt;コンポーネントをレンダリングする &lt;code&gt;setup()&lt;/code&gt; ヘルパーを作成します。これにより、期待どおりにコールバックが呼び出されたかどうかを個々のテストでアサートできます。</target>
        </trans-unit>
        <trans-unit id="511c9087c67a4a067c397c7eec06e3c3e446f664" translate="yes" xml:space="preserve">
          <source>To unsubscribe the change listener, invoke the function returned by &lt;code&gt;subscribe&lt;/code&gt;.</source>
          <target state="translated">変更リスナーの登録を解除するには、 &lt;code&gt;subscribe&lt;/code&gt; によって返された関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="898034cb5cc5c4fc7410f57fc7be8100ebeae451" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;connect()&lt;/code&gt;, you need to define a special function called &lt;code&gt;mapStateToProps&lt;/code&gt; that tells how to transform the current Redux store state into the props you want to pass to a presentational component you are wrapping. For example, &lt;code&gt;VisibleTodoList&lt;/code&gt; needs to calculate &lt;code&gt;todos&lt;/code&gt; to pass to the &lt;code&gt;TodoList&lt;/code&gt;, so we define a function that filters the &lt;code&gt;state.todos&lt;/code&gt; according to the &lt;code&gt;state.visibilityFilter&lt;/code&gt;, and use it in its &lt;code&gt;mapStateToProps&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;connect()&lt;/code&gt; を使用するには、現在のReduxストアの状態を、ラップしているプレゼンテーションコンポーネントに渡したい小道具に変換する方法を指示する &lt;code&gt;mapStateToProps&lt;/code&gt; と呼ばれる特別な関数を定義する必要があります。例えば、 &lt;code&gt;VisibleTodoList&lt;/code&gt; は計算する必要が &lt;code&gt;todos&lt;/code&gt; に渡す &lt;code&gt;TodoList&lt;/code&gt; 我々はフィルタ機能を定義して、 &lt;code&gt;state.todos&lt;/code&gt; をに従って &lt;code&gt;state.visibilityFilter&lt;/code&gt; をし、その中でそれを使用 &lt;code&gt;mapStateToProps&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9b84ac1ca067a403df64cc26ea17e56c8180c71f" translate="yes" xml:space="preserve">
          <source>To use it together with &lt;a href=&quot;http://babeljs.io&quot;&gt;Babel&lt;/a&gt;, you will need to install &lt;code&gt;babel-jest&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://babeljs.io&quot;&gt;Babel&lt;/a&gt;と一緒に使用するには、 &lt;code&gt;babel-jest&lt;/code&gt; をインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="717cd30aec4dd5a323fdb13aff5182c806d12d1b" translate="yes" xml:space="preserve">
          <source>TodoMVC</source>
          <target state="translated">TodoMVC</target>
        </trans-unit>
        <trans-unit id="a4114a83f4c6b03e326fda4a57471ca7c2d9fa96" translate="yes" xml:space="preserve">
          <source>Todos</source>
          <target state="translated">Todos</target>
        </trans-unit>
        <trans-unit id="6426098ad9410ea40ed780712b90e9b1ee4b090c" translate="yes" xml:space="preserve">
          <source>Todos with Undo</source>
          <target state="translated">元に戻す</target>
        </trans-unit>
        <trans-unit id="11dbf4818429dd1d9ae43c9b6f0078f50d78eca5" translate="yes" xml:space="preserve">
          <source>Top-Level Exports</source>
          <target state="translated">トップレベルの輸出</target>
        </trans-unit>
        <trans-unit id="8ad8302d110b05d7e02330dac58628134fdcff02" translate="yes" xml:space="preserve">
          <source>Translations</source>
          <target state="translated">Translations</target>
        </trans-unit>
        <trans-unit id="c579263052bf20f3a459fb334a149d298234c3f6" translate="yes" xml:space="preserve">
          <source>Tree View</source>
          <target state="translated">ツリービュー</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="63ae2d8b43c9bd5c5d9a4a0152b1f52dd71f01f5" translate="yes" xml:space="preserve">
          <source>Troubleshooting: My views aren&amp;rsquo;t updating when something changes outside of Redux</source>
          <target state="translated">トラブルシューティング：Redux以外で何かが変更されたときにビューが更新されない</target>
        </trans-unit>
        <trans-unit id="c5984c35d0b5720f5ededf659b1e4bb94f25efcc" translate="yes" xml:space="preserve">
          <source>Troubleshooting: Never mutate reducer arguments</source>
          <target state="translated">トラブルシューティング。レデューサの引数を絶対にミューテーションしない</target>
        </trans-unit>
        <trans-unit id="f2569e4c2636e5cc4f4bc61ec91ab96c592717fa" translate="yes" xml:space="preserve">
          <source>Troubleshooting: Nothing happens when I dispatch an action</source>
          <target state="translated">トラブルシューティング。アクションをディスパッチしても何も起こらない</target>
        </trans-unit>
        <trans-unit id="5c79bb1da81bc4cdf1612625ab31bb11eaf51494" translate="yes" xml:space="preserve">
          <source>Try to avoid dispatching several times synchronously in a row in the places where you're concerned about performance. There are a number of addons and approaches that can batch up dispatches as well.</source>
          <target state="translated">パフォーマンスが気になるところでは、同期して何度も連続してディスパッチするのは避けましょう。ディスパッチをバッチアップすることができるアドオンやアプローチはいくつかあります。</target>
        </trans-unit>
        <trans-unit id="72970471e5d1f5bed9e5c8dccde351d73710853a" translate="yes" xml:space="preserve">
          <source>Turns an object whose values are &lt;a href=&quot;../glossary#action-creator&quot;&gt;action creators&lt;/a&gt;, into an object with the same keys, but with every action creator wrapped into a &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; call so they may be invoked directly.</source>
          <target state="translated">値が&lt;a href=&quot;../glossary#action-creator&quot;&gt;アクションクリエーター&lt;/a&gt;であるオブジェクトを、同じキーを持つオブジェクトに変換しますが、すべてのアクションクリエーターは&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;コールにラップされているため、直接呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="e1733ad2a0216b6de85e1fcd35dfdee394e2afa0" translate="yes" xml:space="preserve">
          <source>Tutorials and Articles</source>
          <target state="translated">チュートリアルと記事</target>
        </trans-unit>
        <trans-unit id="606fbca55ef1c11f19a4f936a99beb986380cf17" translate="yes" xml:space="preserve">
          <source>Twitter's mobile site</source>
          <target state="translated">ツイッターのモバイルサイト</target>
        </trans-unit>
        <trans-unit id="9404d68c02ebdd30a4a808a24f9060471b759192" translate="yes" xml:space="preserve">
          <source>Twitter: Don't use Redux unless you're unhappy with local component state</source>
          <target state="translated">ツイッターです。ローカルコンポーネントの状態に不満がない限りReduxを使うな</target>
        </trans-unit>
        <trans-unit id="d2affd0dcee2425ca66385d0faf980e7f7ecdf02" translate="yes" xml:space="preserve">
          <source>Twitter: Don't use Redux until...</source>
          <target state="translated">ツイッターです。Reduxは使うなよ...までは。</target>
        </trans-unit>
        <trans-unit id="d7fb782e77a8b9b4edadf5251f4fd4a2b65f0b1b" translate="yes" xml:space="preserve">
          <source>Twitter: If your reducer looks boring, don't use redux</source>
          <target state="translated">ツイッターです。レデューサーがつまらなそうならreduxを使うな</target>
        </trans-unit>
        <trans-unit id="ee9af1a3c185fc74743f29130b1e126141719508" translate="yes" xml:space="preserve">
          <source>Twitter: Redux is a platform for developers to build customized state management with reusable things</source>
          <target state="translated">ツイッターで紹介されています。Reduxは、再利用可能なものでカスタマイズされた状態管理を構築するための開発者のためのプラットフォームです。</target>
        </trans-unit>
        <trans-unit id="c1674978f90c098b4d6e689712105d7a768088c7" translate="yes" xml:space="preserve">
          <source>Twitter: Redux is designed to be predictable, not concise</source>
          <target state="translated">ツイッターです。Reduxは簡潔ではなく予測できるように設計されている</target>
        </trans-unit>
        <trans-unit id="6df45452576b437fd3a9fe2fc716cd66dddc4433" translate="yes" xml:space="preserve">
          <source>Twitter: Redux is useful to eliminate deep prop passing</source>
          <target state="translated">ツイッター。深いプロップパスをなくすにはReduxが便利</target>
        </trans-unit>
        <trans-unit id="66661fb38bd97dedfe9248a69ac48fe3658b604e" translate="yes" xml:space="preserve">
          <source>Twitter: Redux scaling</source>
          <target state="translated">ツイッターです。Reduxのスケーリング</target>
        </trans-unit>
        <trans-unit id="ecc8be1c9df1cfaf1fb1dfafd8fc3b52bba36bca" translate="yes" xml:space="preserve">
          <source>Twitter: Redux vs MobX benchmark graph - Redux state shape matters</source>
          <target state="translated">Twitterの様子。Redux vs MobXのベンチマークグラフ-Reduxの状態形状が重要</target>
        </trans-unit>
        <trans-unit id="129f727416c8f720bb392b36e9ceac07d9339857" translate="yes" xml:space="preserve">
          <source>Twitter: Should I keep something in React component state?</source>
          <target state="translated">ツイッターです。Reactコンポーネントの状態で何かを保持しておくべきか?</target>
        </trans-unit>
        <trans-unit id="1951b46de5200e3cec6a0f10d24bc32b95efcec1" translate="yes" xml:space="preserve">
          <source>Twitter: There is no ultimate file structure for Redux</source>
          <target state="translated">ツイッターです。Reduxには究極のファイル構造がない</target>
        </trans-unit>
        <trans-unit id="a5ab467d2f0669472526a676c4046e4696c17a6a" translate="yes" xml:space="preserve">
          <source>Twitter: Using a reducer to update a component</source>
          <target state="translated">ツイッターです。レデューサーを使ってコンポーネントを更新する</target>
        </trans-unit>
        <trans-unit id="cd42d6934051561b9a42541c428d37e9a49eefd7" translate="yes" xml:space="preserve">
          <source>Twitter: You don't need Redux if your data never changes</source>
          <target state="translated">ツイッターです。データが変わらないならReduxは必要ない</target>
        </trans-unit>
        <trans-unit id="65143436c2a655126e87e9283def5be8f1f1d3d7" translate="yes" xml:space="preserve">
          <source>Twitter: common misconception - deep cloning</source>
          <target state="translated">Twitter:よくある誤解-ディープクローニング</target>
        </trans-unit>
        <trans-unit id="f7449ca3dc33732cd2745f1868991eecc95eeb34" translate="yes" xml:space="preserve">
          <source>Twitter: emphasizing &amp;ldquo;one container&amp;rdquo; was a mistake</source>
          <target state="translated">Twitter：「1つのコンテナ」を強調するのは誤りでした</target>
        </trans-unit>
        <trans-unit id="94f434b5b79b7481ac06603cc2fe9a2a75efff91" translate="yes" xml:space="preserve">
          <source>Twitter: most common Redux misconception</source>
          <target state="translated">Twitter:最もよくあるReduxの誤解</target>
        </trans-unit>
        <trans-unit id="dec8b9c8b688102b7c98c2e00ef8f8e810be3a8d" translate="yes" xml:space="preserve">
          <source>Twitter: possible comparison between sagas, loops, and other approaches</source>
          <target state="translated">Twitter:サガ、ループ、その他のアプローチの比較可能性</target>
        </trans-unit>
        <trans-unit id="eb2d03183352dc0e1406c06a363bec69ab899d18" translate="yes" xml:space="preserve">
          <source>Twitter: state shape should be normalized</source>
          <target state="translated">ツイッター:状態の形を正規化すべき</target>
        </trans-unit>
        <trans-unit id="0fc31910b305d54661578ccc6703279eccabacfc" translate="yes" xml:space="preserve">
          <source>Understanding Middleware</source>
          <target state="translated">ミドルウェアを理解する</target>
        </trans-unit>
        <trans-unit id="aa44a604eeec984741a16fa1f77345805911c705" translate="yes" xml:space="preserve">
          <source>Understanding Programmatic Side-Effects</source>
          <target state="translated">プログラムの副作用を理解する</target>
        </trans-unit>
        <trans-unit id="5f8aabc2d6ab53ecb7bf65fd5b21232c2d632dbb" translate="yes" xml:space="preserve">
          <source>Understanding Redux</source>
          <target state="translated">Reduxを理解する</target>
        </trans-unit>
        <trans-unit id="da9a514a65a385fa6f49e9ff3ac2134dd5049f72" translate="yes" xml:space="preserve">
          <source>Understanding Redux Middleware</source>
          <target state="translated">Reduxミドルウェアを理解する</target>
        </trans-unit>
        <trans-unit id="1126940f0f175f3010de4d728fe1b602fc4c7c2e" translate="yes" xml:space="preserve">
          <source>Understanding Undo History</source>
          <target state="translated">Undoの歴史を理解する</target>
        </trans-unit>
        <trans-unit id="29149689e59122b80c1e38105a1193a813f6026c" translate="yes" xml:space="preserve">
          <source>Undo history is also part of your app's state, and there is no reason why we should approach it differently. Regardless of the type of the state changing over time, when you implement Undo and Redo, you want to keep track of the &lt;em&gt;history&lt;/em&gt; of this state at different points in time.</source>
          <target state="translated">元に戻す履歴もアプリの状態の一部であり、別の方法で対処する必要がある理由はありません。時間の経過とともに変化する状態のタイプに関係なく、元に戻すとやり直しを実装するときは、この状態の&lt;em&gt;履歴&lt;/em&gt;をさまざまな時点で追跡する必要があります。</target>
        </trans-unit>
        <trans-unit id="64a01a0c422c934a7950b6881de9ff78984dfa04" translate="yes" xml:space="preserve">
          <source>Unfortunately, the process of correctly applying immutable updates to deeply nested state can easily become verbose and hard to read. Here's what an example of updating &lt;code&gt;state.first.second[someId].fourth&lt;/code&gt; might look like:</source>
          <target state="translated">残念ながら、不変更新を深くネストされた状態に正しく適用するプロセスは、簡単に冗長になり、読みにくくなる可能性があります。次に、 &lt;code&gt;state.first.second[someId].fourth&lt;/code&gt; 更新例を示します。</target>
        </trans-unit>
        <trans-unit id="e9541a9acaaaf0a817940ec4f10e5183c2dd8e50" translate="yes" xml:space="preserve">
          <source>Unfortunately, this setup has a problem. Because &lt;code&gt;combineReducers&lt;/code&gt; will call each slice reducer with the same action, dispatching &lt;code&gt;{type : 'INCREMENT'}&lt;/code&gt; will actually cause &lt;em&gt;all three&lt;/em&gt; counter values to be incremented, not just one of them. We need some way to wrap the &lt;code&gt;counter&lt;/code&gt; logic so that we can ensure that only the counter we care about is updated.</source>
          <target state="translated">残念ながら、このセットアップには問題があります。 &lt;code&gt;combineReducers&lt;/code&gt; は各スライスレデューサーを同じアクションで呼び出すため、 &lt;code&gt;{type : 'INCREMENT'}&lt;/code&gt; をディスパッチすると、実際には1つだけではなく&lt;em&gt;3つすべての&lt;/em&gt;カウンター値がインクリメントされます。必要な &lt;code&gt;counter&lt;/code&gt; のみが確実に更新されるように、カウンターロジックをラップする方法が必要です。</target>
        </trans-unit>
        <trans-unit id="d02603176f8822a40aaa5b4270e49934a7f83824" translate="yes" xml:space="preserve">
          <source>Universal</source>
          <target state="translated">Universal</target>
        </trans-unit>
        <trans-unit id="994fe41b283ff02621f9c7dc77840d41dc98c31d" translate="yes" xml:space="preserve">
          <source>Unless you are targeting old browsers like IE9, you can always use &lt;code&gt;browserHistory&lt;/code&gt;.</source>
          <target state="translated">IE9のような古いブラウザを対象としない限り、常に &lt;code&gt;browserHistory&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="2b1ae928f14271308acdf16284c1c3318ffccaac" translate="yes" xml:space="preserve">
          <source>Unlike Flux, &lt;strong&gt;Redux does not have the concept of a Dispatcher&lt;/strong&gt;. This is because it relies on pure functions instead of event emitters, and pure functions are easy to compose and don't need an additional entity managing them. Depending on how you view Flux, you may see this as either a deviation or an implementation detail. Flux has often been &lt;a href=&quot;https://speakerdeck.com/jmorrell/jsconf-uy-flux-those-who-forget-the-past-dot-dot-dot-1&quot;&gt;described as &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt;&lt;/a&gt;. In this sense, Redux is true to the Flux architecture, but makes it simpler thanks to pure functions.</source>
          <target state="translated">Fluxとは異なり、&lt;strong&gt;ReduxにはDispatcherの概念がありません&lt;/strong&gt;。これは、イベントエミッターではなく純粋な関数に依存しているためであり、純粋な関数は簡単に構成でき、それらを管理する追加のエンティティを必要としません。 Fluxの表示方法に応じて、これは偏差または実装の詳細として表示される場合があります。 Fluxは&lt;a href=&quot;https://speakerdeck.com/jmorrell/jsconf-uy-flux-those-who-forget-the-past-dot-dot-dot-1&quot;&gt; &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt; &lt;/a&gt;表現されることがよくあります。この意味で、ReduxはFluxアーキテクチャに忠実ですが、純粋な関数のおかげでよりシンプルになっています。</target>
        </trans-unit>
        <trans-unit id="369afc8b01a8d03d314e492b4f13b9436b7f3540" translate="yes" xml:space="preserve">
          <source>Unlike Immutable, Baobab doesn't yet implement any special efficient data structures under the hood, so you don't really win anything from using it together with Redux. It's easier to just use plain objects in this case.</source>
          <target state="translated">Immutableとは異なり、Baobabはまだ特別な効率的なデータ構造を実装していないので、Reduxと一緒に使っても何の得にもなりません。この場合、プレーンなオブジェクトを使う方が簡単です。</target>
        </trans-unit>
        <trans-unit id="dafc7d2108e005fe79487a219c36098fea188c9e" translate="yes" xml:space="preserve">
          <source>Unlike Redux, Elm is a language, so it is able to benefit from many things like enforced purity, static typing, out of the box immutability, and pattern matching (using the &lt;code&gt;case&lt;/code&gt; expression). Even if you don't plan to use Elm, you should read about the Elm architecture, and play with it. There is an interesting &lt;a href=&quot;https://github.com/paldepind/noname-functional-frontend-framework&quot;&gt;JavaScript library playground implementing similar ideas&lt;/a&gt;. We should look there for inspiration on Redux! One way that we can get closer to the static typing of Elm is by &lt;a href=&quot;https://github.com/reactjs/redux/issues/290&quot;&gt;using a gradual typing solution like Flow&lt;/a&gt;.</source>
          <target state="translated">Redmとは異なり、Elmは言語であるため、強制された純粋性、静的型付け、デフォルトの不変性、パターンマッチング（ &lt;code&gt;case&lt;/code&gt; 式を使用）などの多くのメリットを享受できます。Elmを使用する予定がない場合でも、Elmアーキテクチャについて読んで、それを試してみてください。&lt;a href=&quot;https://github.com/paldepind/noname-functional-frontend-framework&quot;&gt;同様のアイデアを実装&lt;/a&gt;する興味深いJavaScriptライブラリの遊び場があります。Reduxのインスピレーションを得るためにそこを見る必要があります！Elmの静的型付けに近づける1つの方法は、&lt;a href=&quot;https://github.com/reactjs/redux/issues/290&quot;&gt;Flowのような段階的な型付けソリューションを使用すること&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="fb573dae642cd298a26b5ad3f7d8a6aa2a22ab64" translate="yes" xml:space="preserve">
          <source>Updating Nested Objects</source>
          <target state="translated">入れ子になったオブジェクトの更新</target>
        </trans-unit>
        <trans-unit id="ba005750a992aac6711d42039081d7dea24565c8" translate="yes" xml:space="preserve">
          <source>Updating Normalized Data</source>
          <target state="translated">正規化データの更新</target>
        </trans-unit>
        <trans-unit id="34a615077aef7febb310a581aba6ddb1f4573a22" translate="yes" xml:space="preserve">
          <source>Updating an Item in an Array</source>
          <target state="translated">配列内の項目の更新</target>
        </trans-unit>
        <trans-unit id="38f356713eaa6d37ea438e2f8aa17840c5f0c625" translate="yes" xml:space="preserve">
          <source>Updating complex nested state trees can lead to verbose code that is tedious to write and difficult to debug.</source>
          <target state="translated">複雑な入れ子になったステートツリーを更新すると、書くのが面倒でデバッグが困難な冗長なコードになってしまうことがあります。</target>
        </trans-unit>
        <trans-unit id="692659407b3b434cf95e2a7e004744aa8b983be9" translate="yes" xml:space="preserve">
          <source>Updating one item in an array can be accomplished by using &lt;code&gt;Array.map&lt;/code&gt;, returning a new value for the item we want to update, and returning the existing values for all other items:</source>
          <target state="translated">配列内の1つの項目を更新するには、 &lt;code&gt;Array.map&lt;/code&gt; を使用して、更新する項目の新しい値を返し、他のすべての項目の既存の値を返します。</target>
        </trans-unit>
        <trans-unit id="46dd59ad0b98ced1d4302c19c79265603a50b5a9" translate="yes" xml:space="preserve">
          <source>Updating the Selectors</source>
          <target state="translated">セレクタの更新</target>
        </trans-unit>
        <trans-unit id="59dca19d5e82666b029e887367ee83ee76a6cde5" translate="yes" xml:space="preserve">
          <source>Usage with React</source>
          <target state="translated">Reactでの使い方</target>
        </trans-unit>
        <trans-unit id="4bd635c7ecaee77c3a25d970afecbab5846b8de6" translate="yes" xml:space="preserve">
          <source>Usage with React Router</source>
          <target state="translated">React Routerでの使用法</target>
        </trans-unit>
        <trans-unit id="f27c1c781c4770c2582ae4093ae556d8904e293c" translate="yes" xml:space="preserve">
          <source>Use Immutable.JS everywhere except your dumb components</source>
          <target state="translated">Immutable.JSを馬鹿なコンポーネント以外の場所で使用します。</target>
        </trans-unit>
        <trans-unit id="9cd0943012b7d196bcc304b78eaf4d76beb5b078" translate="yes" xml:space="preserve">
          <source>Use Immutable.JS objects in your Smart Components</source>
          <target state="translated">スマート コンポーネントで Immutable.JS オブジェクトを使用する</target>
        </trans-unit>
        <trans-unit id="14a99c911eb8f6fe086d95ec62a6192b50d4564c" translate="yes" xml:space="preserve">
          <source>Use a Higher Order Component to convert your Smart Component&amp;rsquo;s Immutable.JS props to your Dumb Component&amp;rsquo;s JavaScript props</source>
          <target state="translated">高次コンポーネントを使用して、スマートコンポーネントのImmutable.JSプロップをダムコンポーネントのJavaScriptプロップに変換します。</target>
        </trans-unit>
        <trans-unit id="5f88c0684b6236b23ff1f689452822f930944d64" translate="yes" xml:space="preserve">
          <source>Use an Immutable.JS-aware version of the &lt;code&gt;combineReducers&lt;/code&gt; function, such as the one in &lt;a href=&quot;https://www.npmjs.com/package/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt;, as Redux itself expects the state tree to be a plain JavaScript object.</source>
          <target state="translated">Redux自体が状態ツリーがプレーンJavaScriptオブジェクトであると想定しているため、&lt;a href=&quot;https://www.npmjs.com/package/redux-immutable&quot;&gt;redux-immutableの&lt;/a&gt;関数のように、 &lt;code&gt;combineReducers&lt;/code&gt; 対応バージョンのCombineReducers関数を使用します。</target>
        </trans-unit>
        <trans-unit id="3e7660e3d84caaf8d0d389dd1aa86ddb2e25f9d1" translate="yes" xml:space="preserve">
          <source>Use the Immutable Object Formatter Chrome Extension to Aid Debugging</source>
          <target state="translated">不変オブジェクトフォーマッターの Chrome 拡張機能を使用してデバッグを支援する</target>
        </trans-unit>
        <trans-unit id="f02307698aa7f146036376ea5c566843affb0cce" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 使用</target>
        </trans-unit>
        <trans-unit id="f08b702827057616968fd391c82f707b1a5a2d8f" translate="yes" xml:space="preserve">
          <source>Using Immutable.JS everywhere keeps your code performant. Use it in your smart components, your selectors, your sagas or thunks, action creators, and especially your reducers.</source>
          <target state="translated">Immutable.JS をあらゆる場所で使用することで、コードのパフォーマンスを維持することができます。スマートコンポーネント、セレクタ、サガやサンク、アクションクリエータ、特にレデューサで使用してください。</target>
        </trans-unit>
        <trans-unit id="f7293e4f3b5e035630a5bc60b64f59c693251afd" translate="yes" xml:space="preserve">
          <source>Using Immutable.JS with Redux</source>
          <target state="translated">ReduxでImmutable.JSを使う</target>
        </trans-unit>
        <trans-unit id="67ca03c7a7625d155b3a537ee064c3e9d484c709" translate="yes" xml:space="preserve">
          <source>Using Object Spread Operator</source>
          <target state="translated">オブジェクトスプレッド演算子の使用</target>
        </trans-unit>
        <trans-unit id="ac6f51d94e4af12a8acd288d8eb407840de3df95" translate="yes" xml:space="preserve">
          <source>Using Redux</source>
          <target state="translated">Reduxの使用</target>
        </trans-unit>
        <trans-unit id="fe5bda3640263724e1162e68bdb4f3f60a23f165" translate="yes" xml:space="preserve">
          <source>Using Redux Undo</source>
          <target state="translated">Reduxを使って元に戻す</target>
        </trans-unit>
        <trans-unit id="4350d0f8a60fb29773b2696fff9bb5c97e53d8b5" translate="yes" xml:space="preserve">
          <source>Using combineReducers</source>
          <target state="translated">コンバインReducersの使用</target>
        </trans-unit>
        <trans-unit id="7d518ee67915b609a1dd9ff6c8af1cfadb6c6da1" translate="yes" xml:space="preserve">
          <source>Using objects keyed by item IDs as lookup tables, and arrays of IDs to track ordering</source>
          <target state="translated">アイテムIDでキー設定されたオブジェクトをルックアップテーブルとして使用し、IDの配列を使用して順序を追跡する</target>
        </trans-unit>
        <trans-unit id="8ed1d4412e834bf938d3923e0b8f3cc5b2463506" translate="yes" xml:space="preserve">
          <source>Using redux-saga To Simplify Your Growing React Native Codebase</source>
          <target state="translated">成長するReact Nativeコードベースを簡素化するためにredux-sagaを使う</target>
        </trans-unit>
        <trans-unit id="021b423143ef7a73f92d60003574a87608876b96" translate="yes" xml:space="preserve">
          <source>Using slice reducers with Immutable.js objects</source>
          <target state="translated">Immutable.js オブジェクトでスライスレデューサーを使う</target>
        </trans-unit>
        <trans-unit id="b97756d7719f737231f86a444a2d68e775b67e86" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;getVisibleTodos&lt;/code&gt; selector with multiple instances of the &lt;code&gt;visibleTodoList&lt;/code&gt; container will not correctly memoize:</source>
          <target state="translated">使用 &lt;code&gt;getVisibleTodos&lt;/code&gt; のの複数のインスタンスをセレクタを &lt;code&gt;visibleTodoList&lt;/code&gt; のコンテナが正しくmemoizeません。</target>
        </trans-unit>
        <trans-unit id="4df7fb586380ea5e7c187fb0014d6c3d49e85d05" translate="yes" xml:space="preserve">
          <source>Usually generated by React Redux</source>
          <target state="translated">通常はReact Reduxで生成される</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="3b6bce0bc82ec87711aba57c2f985407b17ac4e1" translate="yes" xml:space="preserve">
          <source>Utility libraries that wrap immutable update logic into simpler functions</source>
          <target state="translated">不変更新ロジックをよりシンプルな関数にラップするユーティリティライブラリ</target>
        </trans-unit>
        <trans-unit id="a83ddc10110955dee4bc01b56024b22edcbf4ac4" translate="yes" xml:space="preserve">
          <source>Verbose Code</source>
          <target state="translated">冗長コード</target>
        </trans-unit>
        <trans-unit id="306838c8867984c3b915bde4dd3f78004f4ca086" translate="yes" xml:space="preserve">
          <source>Watch the 30 Free Videos!</source>
          <target state="translated">30本の無料動画を見てみよう</target>
        </trans-unit>
        <trans-unit id="0483b60e25b0c25edcc348bff84793a3d91be49a" translate="yes" xml:space="preserve">
          <source>We also include our bundle file for the client-side application via a script tag. This is whatever output your bundling tool provides for your client entry point. It may be a static file or a URL to a hot reloading development server.</source>
          <target state="translated">また、クライアント側アプリケーション用のバンドルファイルを script タグでインクルードします。これは、バンドルツールがクライアントのエントリポイントに提供する出力です。静的なファイルであったり、ホットリロード開発サーバーへのURLであったりします。</target>
        </trans-unit>
        <trans-unit id="10bbc3b0c569fe69fdd473c376b8f564d7a80d0e" translate="yes" xml:space="preserve">
          <source>We also need a way to give each instance of a container access to its own private selector. The &lt;code&gt;mapStateToProps&lt;/code&gt; argument of &lt;code&gt;connect&lt;/code&gt; can help with this.</source>
          <target state="translated">また、コンテナーの各インスタンスに独自のプライベートセレクターへのアクセス権を与える方法も必要です。 &lt;code&gt;connect&lt;/code&gt; の &lt;code&gt;mapStateToProps&lt;/code&gt; 引数がこれに役立ちます。</target>
        </trans-unit>
        <trans-unit id="fdaefd698de230a2f7c12c50f1c7217019df8d31" translate="yes" xml:space="preserve">
          <source>We can now wrap any reducer into &lt;code&gt;undoable&lt;/code&gt; reducer enhancer to teach it to react to &lt;code&gt;UNDO&lt;/code&gt; and &lt;code&gt;REDO&lt;/code&gt; actions.</source>
          <target state="translated">これで、すべてのリデューサーを &lt;code&gt;undoable&lt;/code&gt; リデューサーエンハンサーにラップして、 &lt;code&gt;UNDO&lt;/code&gt; および &lt;code&gt;REDO&lt;/code&gt; アクションに反応するように教えることができます。</target>
        </trans-unit>
        <trans-unit id="9c827f05d5a3cbe83f760b9cd2939ca0c33269a0" translate="yes" xml:space="preserve">
          <source>We can still define these special thunk action creators inside our &lt;code&gt;actions.js&lt;/code&gt; file:</source>
          <target state="translated">これらの特別なサンクアクションクリエーターは、 &lt;code&gt;actions.js&lt;/code&gt; ファイル内で定義できます。</target>
        </trans-unit>
        <trans-unit id="938b765a6a181b2876b551536787a61427ae0513" translate="yes" xml:space="preserve">
          <source>We can write the following helper to accomplish this:</source>
          <target state="translated">これを実現するために、以下のようなヘルパーを書けばいいのではないでしょうか。</target>
        </trans-unit>
        <trans-unit id="c8360b823356a1165aff2dcb5acddb15d0faf8a6" translate="yes" xml:space="preserve">
          <source>We can't reliably enforce serializable actions for performance reasons, so Redux only checks that every action is a plain object, and that the &lt;code&gt;type&lt;/code&gt; is defined. The rest is up to you, but you might find that keeping everything serializable helps debug and reproduce issues.</source>
          <target state="translated">パフォーマンス上の理由から、シリアライズ可能なアクションを確実に実施することはできないため、Reduxはすべてのアクションがプレーンオブジェクトであること、および &lt;code&gt;type&lt;/code&gt; が定義されていることのみをチェックします。残りはあなた次第ですが、シリアライズ可能なものをすべて保持することで問題のデバッグと再現に役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="00855934fc4901f8d981dcebd3bffdd698a1fcbf" translate="yes" xml:space="preserve">
          <source>We could also vary the approach somewhat, and create a more generic higher-order reducer that accepts both a given reducer function and a name or identifier:</source>
          <target state="translated">また、このアプローチを少し変えて、与えられた減速機関数と名前や識別子の両方を受け付ける、より汎用的な高次減速機を作成することもできます。</target>
        </trans-unit>
        <trans-unit id="f190e4360534b4c5d20b45090414be9e9e50cea0" translate="yes" xml:space="preserve">
          <source>We could end this here, but it's not very convenient to import a special function every time.</source>
          <target state="translated">ここで終わりにしてもいいのですが、毎回特殊な関数をインポートするのは不便です。</target>
        </trans-unit>
        <trans-unit id="05ab24ad4034d462a58f7bf871314f5e1296bcbc" translate="yes" xml:space="preserve">
          <source>We could provide a helper inside Redux that would apply the actual monkeypatching as an implementation detail:</source>
          <target state="translated">実装の詳細として実際のモンキーパッチを適用するRedux内部のヘルパーを提供することができます。</target>
        </trans-unit>
        <trans-unit id="9014512e14daf5d56a7fc1c2a33ed8ae10444137" translate="yes" xml:space="preserve">
          <source>We could use it to apply multiple middleware like this:</source>
          <target state="translated">こんな感じで複数のミドルウェアを適用するのに使えそうですね。</target>
        </trans-unit>
        <trans-unit id="62783244d2f4a7054a2bb285d688f4cb5a60d38f" translate="yes" xml:space="preserve">
          <source>We don't want to lock you in!</source>
          <target state="translated">閉じ込めたくない!</target>
        </trans-unit>
        <trans-unit id="8a9e7b213f0799be76b21fa0d3f91f45192784f7" translate="yes" xml:space="preserve">
          <source>We extracted &lt;code&gt;posts(state, action)&lt;/code&gt; that manages the state of a specific post list. This is just &lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;reducer composition&lt;/a&gt;! It is our choice how to split the reducer into smaller reducers, and in this case, we're delegating updating items inside an object to a &lt;code&gt;posts&lt;/code&gt; reducer. The &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; goes even further, showing how to create a reducer factory for parameterized pagination reducers.</source>
          <target state="translated">特定の投稿リストの状態を管理する &lt;code&gt;posts(state, action)&lt;/code&gt; を抽出しました。これは単なる&lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;減速剤の組成&lt;/a&gt;です！これは、レデューサーをより小さなレデューサーに分割する方法の選択であり、この場合、オブジェクト内の更新アイテムを &lt;code&gt;posts&lt;/code&gt; レデューサーに委任しています。&lt;a href=&quot;../introduction/examples#real-world&quot;&gt;現実世界の例では、&lt;/a&gt;パラメータ化されたページネーション減速用減速機工場を作成する方法を示し、さらに行きます。</target>
        </trans-unit>
        <trans-unit id="f2ba230f751c2afe5d48e98a148b40dba74b740d" translate="yes" xml:space="preserve">
          <source>We have two more actions to handle! Just like we did with &lt;code&gt;SET_VISIBILITY_FILTER&lt;/code&gt;, we'll import the &lt;code&gt;ADD_TODO&lt;/code&gt; and &lt;code&gt;TOGGLE_TODO&lt;/code&gt; actions and then extend our reducer to handle &lt;code&gt;ADD_TODO&lt;/code&gt;.</source>
          <target state="translated">処理するアクションがさらに2つあります！我々が行ったよう &lt;code&gt;SET_VISIBILITY_FILTER&lt;/code&gt; 、我々は輸入ます &lt;code&gt;ADD_TODO&lt;/code&gt; と &lt;code&gt;TOGGLE_TODO&lt;/code&gt; 行動をして、ハンドルに私たちの減速を拡張 &lt;code&gt;ADD_TODO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="937d04010c34a1830de25cf054cedd314fd77775" translate="yes" xml:space="preserve">
          <source>We just modified how the &lt;code&gt;addTodo&lt;/code&gt; action creator behaves, completely invisible to the calling code. &lt;strong&gt;We don't have to worry about looking at each place where todos are being added, to make sure they have this check.&lt;/strong&gt; Action creators let you decouple additional logic around dispatching an action, from the actual components emitting those actions. It's very handy when the application is under heavy development, and the requirements change often.</source>
          <target state="translated">&lt;code&gt;addTodo&lt;/code&gt; アクションクリエーターの動作を変更しただけで、呼び出し元のコードからは完全に見えません。&lt;strong&gt;このチェックがあることを確認するために、ToDoが追加されている各場所を確認する必要はありません。&lt;/strong&gt;アクションクリエーターを使用すると、アクションのディスパッチに関する追加のロジックを、それらのアクションを発行する実際のコンポーネントから切り離すことができます。アプリケーションが大規模に開発されており、要件が頻繁に変更される場合に非常に便利です。</target>
        </trans-unit>
        <trans-unit id="727029cc06658123c8225de825d04ad8f8957f5b" translate="yes" xml:space="preserve">
          <source>We must distinguish between dispatching functions in general and the base &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function provided by the store instance without any middleware.</source>
          <target state="translated">一般的なディスパッチ機能と、ミドルウェアなしでストアインスタンスによって提供される基本&lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;機能を区別する必要があります。</target>
        </trans-unit>
        <trans-unit id="44bbe40c8a0e33b691c1b061d98660259d085213" translate="yes" xml:space="preserve">
          <source>We need to create a fake &lt;code&gt;getState&lt;/code&gt;, &lt;code&gt;dispatch&lt;/code&gt;, and &lt;code&gt;next&lt;/code&gt; functions. We use &lt;code&gt;jest.fn()&lt;/code&gt; to create stubs, but with other test frameworks you would likely use sinon.</source>
          <target state="translated">偽の &lt;code&gt;getState&lt;/code&gt; 、 &lt;code&gt;dispatch&lt;/code&gt; 、および &lt;code&gt;next&lt;/code&gt; 関数を作成する必要があります。 &lt;code&gt;jest.fn()&lt;/code&gt; を使用してスタブを作成しますが、他のテストフレームワークでは、おそらくsinonを使用します。</target>
        </trans-unit>
        <trans-unit id="299e4ddfafdfef1e85fc435e6d7114d6525ef4bd" translate="yes" xml:space="preserve">
          <source>We now have examples of several kinds of split-up reducer functions: helper utilities like &lt;code&gt;updateObject&lt;/code&gt; and &lt;code&gt;createReducer&lt;/code&gt;, handlers for specific cases like &lt;code&gt;setVisibilityFilter&lt;/code&gt; and &lt;code&gt;addTodo&lt;/code&gt;, and slice-of-state handlers like &lt;code&gt;visibilityReducer&lt;/code&gt; and &lt;code&gt;todosReducer&lt;/code&gt;. We also can see that &lt;code&gt;appReducer&lt;/code&gt; is an example of a &quot;root reducer&quot;.</source>
          <target state="translated">これで、いくつかの種類の分割レデューサー関数の例があります &lt;code&gt;updateObject&lt;/code&gt; や &lt;code&gt;createReducer&lt;/code&gt; などのヘルパーユーティリティ、 &lt;code&gt;setVisibilityFilter&lt;/code&gt; や &lt;code&gt;addTodo&lt;/code&gt; などの特定のケースのハンドラー、 &lt;code&gt;visibilityReducer&lt;/code&gt; や &lt;code&gt;todosReducer&lt;/code&gt; などの状態のスライスハンドラーです。 &lt;code&gt;appReducer&lt;/code&gt; が「ルートリデューサー」の例であることもわかります。</target>
        </trans-unit>
        <trans-unit id="f931773a23d44ef9110cfd8557dfc7aa1e3202fa" translate="yes" xml:space="preserve">
          <source>We recommend &lt;a href=&quot;http://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt; as the testing engine. Note that it runs in a Node environment, so you won't have access to the DOM.</source>
          <target state="translated">テストエンジンとして&lt;a href=&quot;http://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt;をお勧めします。ノード環境で実行されるため、DOMにアクセスできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="c48c28638a818ee714914dc38026f386ac75db5b" translate="yes" xml:space="preserve">
          <source>We should now be able to use either of these to generate our specialized counter reducers, and then dispatch actions that will affect the portion of the state that we care about:</source>
          <target state="translated">これで、これらのいずれかを使用して、特殊なカウンタ減速器を生成し、状態の気になる部分に影響を与えるアクションをディスパッチできるようになりました。</target>
        </trans-unit>
        <trans-unit id="c89ee6942601c0a301153e30e9c58b2f5d8ec40b" translate="yes" xml:space="preserve">
          <source>We specified the behavior of our app before we even started writing the UI. We won't do this in this tutorial, but at this point you can write tests for your reducers and action creators. You won't need to mock anything because they are just &lt;a href=&quot;../introduction/threeprinciples#changes-are-made-with-pure-functions&quot;&gt;pure&lt;/a&gt; functions. Call them, and make assertions on what they return.</source>
          <target state="translated">UIの作成を始める前に、アプリの動作を指定しました。このチュートリアルではこれを行いませんが、この時点でレデューサーとアクションクリエーター用のテストを作成できます。これらは単なる&lt;a href=&quot;../introduction/threeprinciples#changes-are-made-with-pure-functions&quot;&gt;純粋な&lt;/a&gt;関数であるため、モックする必要はありません。それらを呼び出し、それらが返すものについて断言します。</target>
        </trans-unit>
        <trans-unit id="c4470bb993a07bc6bfa269c5fb94507004598031" translate="yes" xml:space="preserve">
          <source>We store each subreddit's information separately so we can cache every subreddit. When the user switches between them the second time, the update will be instant, and we won't need to refetch unless we want to. Don't worry about all these items being in memory: unless you're dealing with tens of thousands of items, and your user rarely closes the tab, you won't need any sort of cleanup.</source>
          <target state="translated">それぞれのsubredditの情報を別々に保存しているので、すべてのsubredditをキャッシュすることができます。ユーザーが2回目にそれらの間を切り替えたときに、更新は即座に行われ、必要がない限り再取得する必要はありません。何万ものアイテムを扱っていて、ユーザーがめったにタブを閉じないのでなければ、クリーンアップの必要はありません。</target>
        </trans-unit>
        <trans-unit id="1e50f981325b4d6e7b5e1ac94e3d14479ea909a5" translate="yes" xml:space="preserve">
          <source>We test that our middleware is calling the &lt;code&gt;getState&lt;/code&gt;, &lt;code&gt;dispatch&lt;/code&gt;, and &lt;code&gt;next&lt;/code&gt; functions at the right time.</source>
          <target state="translated">ミドルウェアが &lt;code&gt;getState&lt;/code&gt; 、 &lt;code&gt;dispatch&lt;/code&gt; 、および &lt;code&gt;next&lt;/code&gt; 関数を適切なタイミングで呼び出していることをテストします。</target>
        </trans-unit>
        <trans-unit id="75cf0f6e6b134023b61b31d405a78b8ef43ce618" translate="yes" xml:space="preserve">
          <source>We then get the initial state from our Redux store using &lt;a href=&quot;../api/store#getState&quot;&gt;&lt;code&gt;store.getState()&lt;/code&gt;&lt;/a&gt;. We will see how this is passed along in our &lt;code&gt;renderFullPage&lt;/code&gt; function.</source>
          <target state="translated">次に、&lt;a href=&quot;../api/store#getState&quot;&gt; &lt;code&gt;store.getState()&lt;/code&gt; &lt;/a&gt;を使用してReduxストアから初期状態を取得します。これが &lt;code&gt;renderFullPage&lt;/code&gt; 関数でどのように渡されるかを確認します。</target>
        </trans-unit>
        <trans-unit id="319de368fdc28c8b195a6d2c03281f6821c69298" translate="yes" xml:space="preserve">
          <source>We use &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/API/Fetch_API&quot;&gt;&lt;code&gt;fetch&lt;/code&gt; API&lt;/a&gt; in the examples. It is a new API for making network requests that replaces &lt;code&gt;XMLHttpRequest&lt;/code&gt; for most common needs. Because most browsers don't yet support it natively, we suggest that you use &lt;a href=&quot;https://github.com/matthew-andrews/isomorphic-fetch&quot;&gt;&lt;code&gt;isomorphic-fetch&lt;/code&gt;&lt;/a&gt; library:</source>
          <target state="translated">例では&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/API/Fetch_API&quot;&gt; &lt;code&gt;fetch&lt;/code&gt; API&lt;/a&gt;を使用しています。これは、最も一般的なニーズの &lt;code&gt;XMLHttpRequest&lt;/code&gt; に代わる、ネットワークリクエストを作成するための新しいAPIです。ほとんどのブラウザーはまだネイティブでサポートしていないため、&lt;a href=&quot;https://github.com/matthew-andrews/isomorphic-fetch&quot;&gt; &lt;code&gt;isomorphic-fetch&lt;/code&gt; &lt;/a&gt;ライブラリを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a7b84a5beb3839d0cf7131fb4a2fbbb7aa5d2618" translate="yes" xml:space="preserve">
          <source>We use ES6 computed property syntax so we can update &lt;code&gt;state[action.subreddit]&lt;/code&gt; with &lt;code&gt;Object.assign()&lt;/code&gt; in a concise way. This:</source>
          <target state="translated">ES6の計算されたプロパティ構文を使用するので、 &lt;code&gt;Object.assign()&lt;/code&gt; &lt;code&gt;state[action.subreddit]&lt;/code&gt; assign（）を使用してstate [action.subreddit]を簡潔な方法で更新できます。この：</target>
        </trans-unit>
        <trans-unit id="38db718a04799e7dc7479e35fa4bd78f62cd7909" translate="yes" xml:space="preserve">
          <source>We will also need some container components to connect the presentational components to Redux. For example, the presentational &lt;code&gt;TodoList&lt;/code&gt; component needs a container like &lt;code&gt;VisibleTodoList&lt;/code&gt; that subscribes to the Redux store and knows how to apply the current visibility filter. To change the visibility filter, we will provide a &lt;code&gt;FilterLink&lt;/code&gt; container component that renders a &lt;code&gt;Link&lt;/code&gt; that dispatches an appropriate action on click:</source>
          <target state="translated">プレゼンテーションコンポーネントをReduxに接続するには、いくつかのコンテナコンポーネントも必要です。たとえば、プレゼンテーションの &lt;code&gt;TodoList&lt;/code&gt; コンポーネントには、Reduxストアにサブスクライブし、現在の可視性フィルターを適用する方法を知っている &lt;code&gt;VisibleTodoList&lt;/code&gt; のようなコンテナーが必要です。可視性フィルターを変更するために、クリック時に適切なアクションをディスパッチする &lt;code&gt;Link&lt;/code&gt; をレンダリングする &lt;code&gt;FilterLink&lt;/code&gt; コンテナーコンポーネントを提供します。</target>
        </trans-unit>
        <trans-unit id="cbe16722b5d079bcbcd195adcf84c0f8b9537578" translate="yes" xml:space="preserve">
          <source>We will also need to refactor &lt;code&gt;index.js&lt;/code&gt; to render the &lt;code&gt;&amp;lt;Root /&amp;gt;&lt;/code&gt; component to the DOM.</source>
          <target state="translated">また、 &lt;code&gt;&amp;lt;Root /&amp;gt;&lt;/code&gt; コンポーネントをDOM にレンダリングするには、 &lt;code&gt;index.js&lt;/code&gt; をリファクタリングする必要があります。</target>
        </trans-unit>
        <trans-unit id="eed46c74461e18da655f49826f9bb4cec981c01c" translate="yes" xml:space="preserve">
          <source>We will see later how the approach we take lets us choose how granular Undo and Redo need to be.</source>
          <target state="translated">私たちがどのようなアプローチを取るかは後ほど説明しますが、どの程度の粒度でUndoとRedoを行う必要があるかを選択することができます。</target>
        </trans-unit>
        <trans-unit id="e48b8e0b74723fbbce7a038049b47d5983a8ab63" translate="yes" xml:space="preserve">
          <source>We will then import the &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; from React Redux:</source>
          <target state="translated">次に、React Reduxから &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; をインポートします。</target>
        </trans-unit>
        <trans-unit id="3dfe117d376bf6280908c658894a43c98efefd9b" translate="yes" xml:space="preserve">
          <source>We will use React in the examples below, but the same techniques can be used with other view frameworks that can render on the server.</source>
          <target state="translated">以下の例ではReactを使用しますが、サーバー上でレンダリングできる他のビューフレームワークでも同じテクニックを使うことができます。</target>
        </trans-unit>
        <trans-unit id="1cfc720c34e5f99bae08591a1d21b8028d872f1f" translate="yes" xml:space="preserve">
          <source>We will use React to build our simple todo app.</source>
          <target state="translated">Reactを使ってシンプルなtodoアプリを作っていきます。</target>
        </trans-unit>
        <trans-unit id="77e9494b8c84b985dfa4f4d49ca2fb485e0d6cbd" translate="yes" xml:space="preserve">
          <source>We will wrap &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; in &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; so that route handlers can get &lt;a href=&quot;../basics/usagewithreact#passing-the-store&quot;&gt;access to the &lt;code&gt;store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; を &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; /&amp;gt;でラップして、ルートハンドラーが&lt;a href=&quot;../basics/usagewithreact#passing-the-store&quot;&gt; &lt;code&gt;store&lt;/code&gt; &lt;/a&gt;アクセスできるようにします。</target>
        </trans-unit>
        <trans-unit id="1d2a4109058f0af68e149216b99cc33debbea027" translate="yes" xml:space="preserve">
          <source>We would like to replace &lt;code&gt;getVisibleTodos&lt;/code&gt; with a memoized selector that recalculates &lt;code&gt;todos&lt;/code&gt; when the value of &lt;code&gt;state.todos&lt;/code&gt; or &lt;code&gt;state.visibilityFilter&lt;/code&gt; changes, but not when changes occur in other (unrelated) parts of the state tree.</source>
          <target state="translated">&lt;code&gt;getVisibleTodos&lt;/code&gt; を、 &lt;code&gt;state.todos&lt;/code&gt; または &lt;code&gt;state.visibilityFilter&lt;/code&gt; の値が変更されたときに &lt;code&gt;todos&lt;/code&gt; を再計算するメモ化されたセレクターに置き換えますが、状態ツリーの他の（関連しない）部分で変更が行われた場合は変更しません。</target>
        </trans-unit>
        <trans-unit id="6c0e7d729963aa201c31d1a06cb609fdf81434f4" translate="yes" xml:space="preserve">
          <source>We'll add one more action type to describe a user ticking off a todo as completed. We refer to a particular todo by &lt;code&gt;index&lt;/code&gt; because we store them in an array. In a real app, it is wiser to generate a unique ID every time something new is created.</source>
          <target state="translated">アクションをもう1つ追加して、完了したTodoをチェックオフしているユーザーを記述します。配列に格納するため、特定の仕事を &lt;code&gt;index&lt;/code&gt; 参照します。実際のアプリでは、何か新しいものが作成されるたびに一意のIDを生成する方が賢明です。</target>
        </trans-unit>
        <trans-unit id="070f3dc99d82df0afd700715eae9b841ac7a6b07" translate="yes" xml:space="preserve">
          <source>We'll explore how to perform side effects in the &lt;a href=&quot;../advanced/index&quot;&gt;advanced walkthrough&lt;/a&gt;. For now, just remember that the reducer must be pure. &lt;strong&gt;Given the same arguments, it should calculate the next state and return it. No surprises. No side effects. No API calls. No mutations. Just a calculation.&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;../advanced/index&quot;&gt;高度なウォークスルーで&lt;/a&gt;副作用を実行する方法を探ります。とりあえず、リデューサーは純粋でなければならないことを覚えておいてください。&lt;strong&gt;同じ引数があれば、次の状態を計算して返す必要があります。驚く様な事じゃない。副作用はありません。 API呼び出しはありません。突然変異なし。単なる計算。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eaa545b7295152e58ab853f3d912b19f7b907eb9" translate="yes" xml:space="preserve">
          <source>We'll start by specifying the initial state. Redux will call our reducer with an &lt;code&gt;undefined&lt;/code&gt; state for the first time. This is our chance to return the initial state of our app:</source>
          <target state="translated">最初に、初期状態を指定します。Reduxは初めて、 &lt;code&gt;undefined&lt;/code&gt; 状態でリデューサーを呼び出します。これは、アプリの初期状態を返すチャンスです。</target>
        </trans-unit>
        <trans-unit id="a566f04c7bb96e3dad921f4e977a52579a6948e3" translate="yes" xml:space="preserve">
          <source>We'll start with the most common use case: lists. Web applications often show lists of things. For example, a list of posts, or a list of friends. You'll need to figure out what sorts of lists your app can show. You want to store them separately in the state, because this way you can cache them and only fetch again if necessary.</source>
          <target state="translated">まず、最も一般的なユースケースであるリストから始めましょう。ウェブアプリケーションではよくリストを表示します。たとえば、投稿のリストや友達のリストなどです。アプリが表示できるリストの種類を把握する必要があります。この方法では、それらをキャッシュし、必要に応じて再度取得するだけで済むため、状態に分けて保存しておきたいものです。</target>
        </trans-unit>
        <trans-unit id="bf88ce0d8fb03a1213e9e5aff6c740f652fabdf4" translate="yes" xml:space="preserve">
          <source>We'll use separate types in this tutorial.</source>
          <target state="translated">このチュートリアルでは、別々のタイプを使用します。</target>
        </trans-unit>
        <trans-unit id="6deda5b238140890ee6ed5f2e792c4827705c840" translate="yes" xml:space="preserve">
          <source>We're almost done. Since many people don't like switch statements, it's very common to use a function that creates a lookup table of action types to case functions. We'll use the &lt;code&gt;createReducer&lt;/code&gt; function described in &lt;a href=&quot;../reducingboilerplate#generating-reducers&quot;&gt;Reducing Boilerplate&lt;/a&gt;:</source>
          <target state="translated">あと少しで完了です。多くの人はswitchステートメントを好まないため、関数をケース処理するアクションタイプのルックアップテーブルを作成する関数を使用することは非常に一般的です。&lt;a href=&quot;../reducingboilerplate#generating-reducers&quot;&gt;ボイラープレートの削減で&lt;/a&gt;説明されている &lt;code&gt;createReducer&lt;/code&gt; 関数を使用します。</target>
        </trans-unit>
        <trans-unit id="cf8eb046053a065111d778fef4cfcdc223cb9816" translate="yes" xml:space="preserve">
          <source>Webflow</source>
          <target state="translated">Webflow</target>
        </trans-unit>
        <trans-unit id="cb59effde77f318efa4856b404dd72c191879fc1" translate="yes" xml:space="preserve">
          <source>What approaches are there for handling data immutably? Do I have to use Immutable.JS?</source>
          <target state="translated">データをイミュータブルに扱うには、どのようなアプローチがあるのでしょうか?Immutable.JSを使用する必要がありますか?</target>
        </trans-unit>
        <trans-unit id="2ec40d3e3697bdc90d47223d9a786375d4854093" translate="yes" xml:space="preserve">
          <source>What are some opinionated Best Practices for using Immutable.JS with Redux?</source>
          <target state="translated">Immutable.JSをReduxで使用するための意見のあるベストプラクティスは何ですか?</target>
        </trans-unit>
        <trans-unit id="4617f0a4931acbdece3479c94cd5d9b8a29ffbc4" translate="yes" xml:space="preserve">
          <source>What are the benefits of Immutability?</source>
          <target state="translated">不変性のメリットとは?</target>
        </trans-unit>
        <trans-unit id="60982d038a3233ff8e99646cab1b3f3181f09be8" translate="yes" xml:space="preserve">
          <source>What are the benefits of immutability?</source>
          <target state="translated">不変性のメリットとは?</target>
        </trans-unit>
        <trans-unit id="de1352defc592755d5729188ff9c5931f975beca" translate="yes" xml:space="preserve">
          <source>What are the issues with using ES6 for immutable operations?</source>
          <target state="translated">ES6を不変演算に使う場合の問題点は?</target>
        </trans-unit>
        <trans-unit id="87f7ec6d6c32ff8a62aada75fa88678bc51d6ac0" translate="yes" xml:space="preserve">
          <source>What are the issues with using Immutable.JS?</source>
          <target state="translated">Immutable.JSを使う上での問題点は?</target>
        </trans-unit>
        <trans-unit id="7669cca5868cf84a7c911639d6206223bbfb9011" translate="yes" xml:space="preserve">
          <source>What are the issues with using JavaScript for immutable operations?</source>
          <target state="translated">JavaScriptを不変演算に使う場合の問題点は?</target>
        </trans-unit>
        <trans-unit id="b6f105fcf428cb482f2dba1e64704d18ef939497" translate="yes" xml:space="preserve">
          <source>What are the issues with using plain JavaScript for immutable operations?</source>
          <target state="translated">プレーンJavaScriptを不変演算に使う場合の問題点は何ですか?</target>
        </trans-unit>
        <trans-unit id="502931ac19eb7ad8e3a6b09a7f30f2039e70b8f9" translate="yes" xml:space="preserve">
          <source>What are the past (and future) states in the undo stack?</source>
          <target state="translated">undoスタックの過去(と未来)の状態はどうなっているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="7af9c4632a04865406facc7a09e8fff13bee6fa5" translate="yes" xml:space="preserve">
          <source>What if we just replace the &lt;code&gt;dispatch&lt;/code&gt; function on the store instance? The Redux store is just a plain object with &lt;a href=&quot;../api/store&quot;&gt;a few methods&lt;/a&gt;, and we're writing JavaScript, so we can just monkeypatch the &lt;code&gt;dispatch&lt;/code&gt; implementation:</source>
          <target state="translated">ストアインスタンスの &lt;code&gt;dispatch&lt;/code&gt; 関数を単に置き換えるとどうなりますか？Reduxストアは&lt;a href=&quot;../api/store&quot;&gt;、いくつかのメソッドを&lt;/a&gt;持つ単純なオブジェクトであり、 JavaScriptを作成しているため、 &lt;code&gt;dispatch&lt;/code&gt; 実装をモンキーパッチできます。</target>
        </trans-unit>
        <trans-unit id="da380f2420edcb4fe953f900cae3cd95adf19059" translate="yes" xml:space="preserve">
          <source>What if we want to apply &lt;strong&gt;more than one&lt;/strong&gt; such transformation to &lt;code&gt;dispatch&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;dispatch&lt;/code&gt; このような変換を&lt;strong&gt;複数&lt;/strong&gt;適用したい場合はどうなりますか？</target>
        </trans-unit>
        <trans-unit id="8d5e21ca6d6c7949c97bbb82b6de23a8e86a90ba" translate="yes" xml:space="preserve">
          <source>What is the current state?</source>
          <target state="translated">現在の状況はどうなっているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="ccdd9f0a8546e0e957522917e3028ad2fdff0b9e" translate="yes" xml:space="preserve">
          <source>What should my file structure look like? How should I group my action creators and reducers in my project? Where should my selectors go?</source>
          <target state="translated">ファイル構造はどのようにしたらよいですか?プロジェクト内のアクションクリエーターとレデューサをどのようにグループ化すればいいですか?セレクタはどこに行けばいいですか?</target>
        </trans-unit>
        <trans-unit id="39b7e4ebfa46344ad4758dbb7c54ade6b182a09d" translate="yes" xml:space="preserve">
          <source>What the Flux?! Let's Redux.</source>
          <target state="translated">何がフラックスだ!レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・レッツ・リドゥ。</target>
        </trans-unit>
        <trans-unit id="7685a22848ac997a066fa32d4715b4fcb5b90efa" translate="yes" xml:space="preserve">
          <source>Whatever convention you choose, stick with it throughout the application.</source>
          <target state="translated">どのようなコンベンションを選択しても、アプリケーション全体でそれを使用してください。</target>
        </trans-unit>
        <trans-unit id="7e44dc3bb557d164a1c8cd909a8179ffc29fe58f" translate="yes" xml:space="preserve">
          <source>When a piece of data is duplicated in several places, it becomes harder to make sure that it is updated appropriately.</source>
          <target state="translated">データの一部が複数箇所に重複していると、適切に更新することが難しくなります。</target>
        </trans-unit>
        <trans-unit id="c0b74de7e07b265987ff3765a92ea469eb3be3c6" translate="yes" xml:space="preserve">
          <source>When a store is created, Redux dispatches a dummy action to your reducer to populate the store with the initial state. You are not meant to handle the dummy action directly. Just remember that your reducer should return some kind of initial state if the state given to it as the first argument is &lt;code&gt;undefined&lt;/code&gt;, and you're all set.</source>
          <target state="translated">ストアが作成されると、Reduxはダミーアクションをレデューサーにディスパッチして、ストアに初期状態を設定します。ダミーアクションを直接処理するためのものではありません。最初の引数として指定された状態が &lt;code&gt;undefined&lt;/code&gt; であり、すべてが設定されている場合、レデューサーは何らかの初期状態を返す必要があることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="55f47f3d19e55c7f647cc1402dfe664e913c42b7" translate="yes" xml:space="preserve">
          <source>When adding JavaScript objects to an Immutable.JS Map or List using Immutable.JS&amp;rsquo;s &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; methods, ensure that the object being added is first converted to an Immutable object using &lt;code&gt;fromJS()&lt;/code&gt;.</source>
          <target state="translated">Immutable.JSの &lt;code&gt;update&lt;/code&gt; 、 &lt;code&gt;merge&lt;/code&gt; 、または &lt;code&gt;set&lt;/code&gt; メソッドを使用してJavaScriptオブジェクトをImmutable.JSマップまたはリストに追加する場合、追加するオブジェクトが最初に &lt;code&gt;fromJS()&lt;/code&gt; を使用してImmutableオブジェクトに変換されていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="5532214553b2a415074b0f39f2cead024233404a" translate="yes" xml:space="preserve">
          <source>When an action creator returns a function, that function will get executed by the Redux Thunk middleware. This function doesn't need to be pure; it is thus allowed to have side effects, including executing asynchronous API calls. The function can also dispatch actions&amp;mdash;like those synchronous actions we defined earlier.</source>
          <target state="translated">アクション作成者が関数を返すと、その関数はRedux Thunkミドルウェアによって実行されます。この関数は純粋である必要はありません。したがって、非同期API呼び出しの実行を含む副作用が許可されます。この関数は、前に定義した同期アクションのように、アクションをディスパッチすることもできます。</target>
        </trans-unit>
        <trans-unit id="d2b511652b6790f3eca5e3448a96b4a14c313d91" translate="yes" xml:space="preserve">
          <source>When it's time to fetch the posts for some subreddit, we will dispatch a &lt;code&gt;REQUEST_POSTS&lt;/code&gt; action:</source>
          <target state="translated">subredditの投稿を取得するときは、 &lt;code&gt;REQUEST_POSTS&lt;/code&gt; アクションをディスパッチします。</target>
        </trans-unit>
        <trans-unit id="c552f80b72ecd37903e2d6ffce7bb1a0b3ba91ad" translate="yes" xml:space="preserve">
          <source>When previously we wrote: &lt;code&gt;&amp;lt;Route path=&quot;/(:filter)&quot; component={App} /&amp;gt;&lt;/code&gt;, it made available inside &lt;code&gt;App&lt;/code&gt; a &lt;code&gt;params&lt;/code&gt; property.</source>
          <target state="translated">以前に &lt;code&gt;&amp;lt;Route path=&quot;/(:filter)&quot; component={App} /&amp;gt;&lt;/code&gt; と書いたとき、それは &lt;code&gt;App&lt;/code&gt; 内で &lt;code&gt;params&lt;/code&gt; プロパティとして利用可能になりました。</target>
        </trans-unit>
        <trans-unit id="c55e37eb1a90ec0796f6a4f05992a64917889494" translate="yes" xml:space="preserve">
          <source>When rendering, we will wrap &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt;, our root component, inside a &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; to make the store available to all components in the component tree, as we saw in &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Usage with React&lt;/a&gt;.</source>
          <target state="translated">レンダリング時には、ルートコンポーネントである &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; を &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; 内でラップして、&lt;a href=&quot;../basics/usagewithreact&quot;&gt;React&lt;/a&gt;での使用法で見たように、コンポーネントツリーのすべてのコンポーネントでストアを使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="b8f09b0e83401e68e4c33132aa1b3b73a6d4dcd4" translate="yes" xml:space="preserve">
          <source>When should I use Redux?</source>
          <target state="translated">Reduxはいつ使うべきですか?</target>
        </trans-unit>
        <trans-unit id="d794925cbdb0e31214ecfc88910755d33c4f0b10" translate="yes" xml:space="preserve">
          <source>When the last middleware in the chain dispatches an action, it has to be a plain object. This is when the &lt;a href=&quot;../basics/dataflow&quot;&gt;synchronous Redux data flow&lt;/a&gt; takes place.</source>
          <target state="translated">チェーンの最後のミドルウェアがアクションをディスパッチするとき、それはプレーンオブジェクトでなければなりません。これは、&lt;a href=&quot;../basics/dataflow&quot;&gt;同期Reduxデータフロー&lt;/a&gt;が発生したときです。</target>
        </trans-unit>
        <trans-unit id="d74a3e9748d787071d9c2fe4d73363cc68c2dcd3" translate="yes" xml:space="preserve">
          <source>When the page loads, the bundle file will be started up and &lt;a href=&quot;https://facebook.github.io/react/docs/top-level-api.html#reactdom.render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt; will hook into the &lt;code&gt;data-react-id&lt;/code&gt; attributes from the server-rendered HTML. This will connect our newly-started React instance to the virtual DOM used on the server. Since we have the same initial state for our Redux store and used the same code for all our view components, the result will be the same real DOM.</source>
          <target state="translated">ページが読み込まれると、バンドルファイルが起動し、&lt;a href=&quot;https://facebook.github.io/react/docs/top-level-api.html#reactdom.render&quot;&gt; &lt;code&gt;ReactDOM.render()&lt;/code&gt; &lt;/a&gt;がサーバーレンダリングされたHTML の &lt;code&gt;data-react-id&lt;/code&gt; 属性にフックします。これにより、新しく起動したReactインスタンスがサーバーで使用されている仮想DOMに接続されます。Reduxストアの初期状態は同じであり、すべてのビューコンポーネントに同じコードを使用しているため、結果は同じ実際のDOMになります。</target>
        </trans-unit>
        <trans-unit id="fdc93b372187dd00b09c70c8f0349010aacbd69a" translate="yes" xml:space="preserve">
          <source>When the shallow check fails, React-Redux will cause the component to re-render. Using &lt;code&gt;toJS()&lt;/code&gt; in &lt;code&gt;mapStateToProps&lt;/code&gt; in this way, therefore, will always cause the component to re-render, even if the value never changes, impacting heavily on performance.</source>
          <target state="translated">浅いチェックが失敗すると、React-Reduxはコンポーネントを再レンダリングします。したがって、この方法で &lt;code&gt;mapStateToProps&lt;/code&gt; で &lt;code&gt;toJS()&lt;/code&gt; を使用すると、値が変更されない場合でも、常にコンポーネントが再レンダリングされ、パフォーマンスに大きな影響を与えます。</target>
        </trans-unit>
        <trans-unit id="4aa9765bfd105e5641e876f4bda241427a866bc5" translate="yes" xml:space="preserve">
          <source>When the user presses &amp;ldquo;Redo&amp;rdquo;, we want to move one step back into the future:</source>
          <target state="translated">ユーザーが「やり直し」を押すと、1つ前のステップに戻ります。</target>
        </trans-unit>
        <trans-unit id="6f1dc68360b35a018ee091fccfa401d6fad91461" translate="yes" xml:space="preserve">
          <source>When using Redux with server rendering, we must also send the state of our app along in our response, so the client can use it as the initial state. This is important because, if we preload any data before generating the HTML, we want the client to also have access to this data. Otherwise, the markup generated on the client won't match the server markup, and the client would have to load the data again.</source>
          <target state="translated">サーバーレンダリングでReduxを使用する場合、クライアントが初期状態として使用できるように、アプリの状態もレスポンスで送信する必要があります。これは、HTMLを生成する前にデータをプリロードした場合、クライアントもそのデータにアクセスできるようにしたいからです。そうしないと、クライアントで生成されたマークアップがサーバーのマークアップと一致せず、クライアントはデータを再度ロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="08905f564cddc435b39d4746befbbfde05d56c89" translate="yes" xml:space="preserve">
          <source>When you call an asynchronous API, there are two crucial moments in time: the moment you start the call, and the moment when you receive an answer (or a timeout).</source>
          <target state="translated">非同期APIを呼び出すときには、2つの重要な瞬間があります:呼び出しを開始した瞬間と、応答を受け取る瞬間(またはタイムアウト)です。</target>
        </trans-unit>
        <trans-unit id="b17e363eb01279dd12d04917f1f023babea53839" translate="yes" xml:space="preserve">
          <source>When you emit an action, &lt;code&gt;todoApp&lt;/code&gt; returned by &lt;code&gt;combineReducers&lt;/code&gt; will call both reducers:</source>
          <target state="translated">アクションを &lt;code&gt;combineReducers&lt;/code&gt; すると、 &lt;code&gt;todoApp&lt;/code&gt; によって返されたtodoAppが両方のリデューサーを呼び出します。</target>
        </trans-unit>
        <trans-unit id="9320a916b3e55e2e80a21708cceecfcf437cc640" translate="yes" xml:space="preserve">
          <source>When you have ported all of your Flux Stores to be implemented on top of reducers, you can replace the Flux library with a single Redux store, and combine those reducers you already have into one using &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers(reducers)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">すべてのFluxストアをレデューサーの上に実装するように移植したら、Fluxライブラリを単一のReduxストアに置き換え、&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers(reducers)&lt;/code&gt; &lt;/a&gt;を使用して、すでに持っているレデューサーを1つに結合できます。</target>
        </trans-unit>
        <trans-unit id="c0a2799ac8efd1f6499c6fb41130094d5c12a451" translate="yes" xml:space="preserve">
          <source>Where do I put my business logic in a React/Redux application?</source>
          <target state="translated">React/Reduxアプリケーションのどこにビジネスロジックを入れればいいのか?</target>
        </trans-unit>
        <trans-unit id="8c07523b65b47a0ad36e94ad44e0e56dd3913c89" translate="yes" xml:space="preserve">
          <source>Where do we get the initial &lt;code&gt;present&lt;/code&gt; state from? We don't seem to know it beforehand.</source>
          <target state="translated">初期の &lt;code&gt;present&lt;/code&gt; 状態はどこから取得しますか？事前に知らないようです。</target>
        </trans-unit>
        <trans-unit id="2c79f8ed0107a7fe0a477df33c48d8c228e7eee0" translate="yes" xml:space="preserve">
          <source>Where do we react to the external actions to save the &lt;code&gt;present&lt;/code&gt; to the &lt;code&gt;past&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;present&lt;/code&gt; を &lt;code&gt;past&lt;/code&gt; に救うために、外部の行動にどこで反応しますか？</target>
        </trans-unit>
        <trans-unit id="6559f99fd936b0050a5d2a1fc16d0873490da574" translate="yes" xml:space="preserve">
          <source>Where to Hold React Component Data: state, store, static, and this</source>
          <target state="translated">Reactコンポーネントのデータを保持する場所:ステート、ストア、スタティック、そしてこれ</target>
        </trans-unit>
        <trans-unit id="03693bfdc7508d98809d55b857217f95caac409e" translate="yes" xml:space="preserve">
          <source>Whether you choose to use such a library, or stick with plain JavaScript, depends on how comfortable you are with adding another dependency to your app, or how sure you are that you can avoid the pitfalls inherent within JavaScript&amp;rsquo;s approach to immutability.</source>
          <target state="translated">そのようなライブラリを使用するか、プレーンJavaScriptを使用するかを選択するかどうかは、アプリに別の依存関係を追加することの快適さ、またはJavaScriptの不変性へのアプローチに内在する落とし穴を回避できるかどうかに依存します。</target>
        </trans-unit>
        <trans-unit id="067c7d896d6446815e8315d7a4fcfafc8f8da43b" translate="yes" xml:space="preserve">
          <source>Whether you have used them or not, Redux only takes a few minutes to get started with.</source>
          <target state="translated">使ったことがある人もない人も、Reduxは数分で始められます。</target>
        </trans-unit>
        <trans-unit id="cbfecd927f559c2b5baf796e97b2ca728811bf43" translate="yes" xml:space="preserve">
          <source>Whichever option you choose, make sure you&amp;rsquo;re familiar with the concepts of &lt;a href=&quot;reducers/prerequisiteconcepts#note-on-immutability-side-effects-and-mutation&quot;&gt;immutability, side effects and mutation&lt;/a&gt;. In particular, ensure you have a deep understanding of what JavaScript does when updating and copying values in order to guard against accidental mutations that will degrade your app&amp;rsquo;s performance, or break it altogether.</source>
          <target state="translated">どちらのオプションを選択する場合でも、&lt;a href=&quot;reducers/prerequisiteconcepts#note-on-immutability-side-effects-and-mutation&quot;&gt;不変性、副作用、突然変異の&lt;/a&gt;概念に精通していることを確認してください。特に、値を更新およびコピーするときにJavaScriptが何を行うかを十分に理解して、アプリのパフォーマンスを低下させたり、完全に壊したりする偶発的な変更から保護してください。</target>
        </trans-unit>
        <trans-unit id="03047acfd57571e8bdbc8135d9d15cea99035eb1" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; is a handy helper utility, you don't have to use it; feel free to write your own root reducer!</source>
          <target state="translated">一方で&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; は&lt;/a&gt;便利なヘルパーユーティリティである、あなたはそれを使用する必要はありません。独自のルートリデューサーを自由に記述してください！</target>
        </trans-unit>
        <trans-unit id="4089c3ad2441e642d6adb86e7f9d112ea7103b43" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;combineReducers&lt;/code&gt; attempts to check that your reducers conform to some of these rules, you should remember them, and do your best to follow them. &lt;code&gt;combineReducers&lt;/code&gt; will check your reducers by passing &lt;code&gt;undefined&lt;/code&gt; to them; this is done even if you specify initial state to &lt;code&gt;Redux.createStore(combineReducers(...), initialState)&lt;/code&gt;. Therefore, you &lt;strong&gt;must&lt;/strong&gt; ensure your reducers work properly when receiving &lt;code&gt;undefined&lt;/code&gt; as state, even if you never intend for them to actually receive &lt;code&gt;undefined&lt;/code&gt; in your own code.</source>
          <target state="translated">一方で &lt;code&gt;combineReducers&lt;/code&gt; の試みがあなたのレデューサーはこれらの規則の一部に適合していることを確認するために、あなたはそれらを覚えているし、それらを追跡するために最善を行う必要があります。 &lt;code&gt;combineReducers&lt;/code&gt; は、 &lt;code&gt;undefined&lt;/code&gt; をリデューサーに渡してチェックします。これは、 &lt;code&gt;Redux.createStore(combineReducers(...), initialState)&lt;/code&gt; 初期状態を指定した場合でも行われます。したがって、独自のコードで実際に &lt;code&gt;undefined&lt;/code&gt; を受信するつもりがない場合でも、 &lt;code&gt;undefined&lt;/code&gt; 状態を受信したときに、レデューサーが適切に機能することを確認する&lt;strong&gt;必要&lt;/strong&gt;が&lt;strong&gt;あり&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="1a1e65f5bf9037c5912b84c5835b30699b791739" translate="yes" xml:space="preserve">
          <source>While React Redux does work to minimize the number of times that your &lt;code&gt;mapStateToProps&lt;/code&gt; function is called, it's still a good idea to ensure that your &lt;code&gt;mapStateToProps&lt;/code&gt; runs quickly and also minimizes the amount of work it does. The common recommended approach is to create memoized &amp;ldquo;selector&amp;rdquo; functions using &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt;. These selectors can be combined and composed together, and selectors later in a pipeline will only run if their inputs have changed. This means you can create selectors that do things like filtering or sorting, and ensure that the real work only happens if needed.</source>
          <target state="translated">React Reduxは &lt;code&gt;mapStateToProps&lt;/code&gt; 関数が呼び出される回数を最小限に抑えるために機能しますが、 &lt;code&gt;mapStateToProps&lt;/code&gt; が迅速に実行され、実行する作業量を最小限に抑えることをお勧めします。一般的な推奨されるアプローチは、使用してメモ化「セレクター」機能を作成することです&lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;再選択を&lt;/a&gt;。これらのセレクターは組み合わせて構成でき、パイプラインの後のセレクターは、入力が変更された場合にのみ実行されます。つまり、フィルタリングや並べ替えなどを行うセレクターを作成し、実際の作業が必要な場合にのみ行われるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="040c756905d96ee1b18a17c4c17f4f0537e48ce8" translate="yes" xml:space="preserve">
          <source>While Redux itself is not opinionated about how your state is organized, &lt;code&gt;combineReducers&lt;/code&gt; enforces several rules to help users avoid common errors. (See &lt;a href=&quot;../../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">Redux自体は状態の編成方法について意見を &lt;code&gt;combineReducers&lt;/code&gt; していませんが、combinReducersはいくつかのルールを適用して、ユーザーが一般的なエラーを回避できるようにします。（詳細については、&lt;a href=&quot;../../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="8dfc58574b33f1efddcb65068c1c7a976c89a49a" translate="yes" xml:space="preserve">
          <source>While effective, using &lt;code&gt;Object.assign()&lt;/code&gt; can quickly make simple reducers difficult to read given its rather verbose syntax.</source>
          <target state="translated">効果的ではありますが、 &lt;code&gt;Object.assign()&lt;/code&gt; を使用すると、構文がかなり冗長であるため、単純なリデューサーがすぐに読みにくくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="269ba06048a7e4e70129f1c6f218059f072f2367" translate="yes" xml:space="preserve">
          <source>While it is technically &lt;em&gt;possible&lt;/em&gt; to &lt;a href=&quot;https://github.com/reactjs/redux/issues/328#issuecomment-125035516&quot;&gt;write impure reducers&lt;/a&gt; that mutate the data for performance corner cases, we actively discourage you from doing this. Development features like time travel, record/replay, or hot reloading will break. Moreover it doesn't seem like immutability poses performance problems in most real apps, because, as &lt;a href=&quot;https://github.com/omcljs/om&quot;&gt;Om&lt;/a&gt; demonstrates, even if you lose out on object allocation, you still win by avoiding expensive re-renders and re-calculations, as you know exactly what changed thanks to reducer purity.</source>
          <target state="translated">パフォーマンスコーナーケースのデータを変更する&lt;a href=&quot;https://github.com/reactjs/redux/issues/328#issuecomment-125035516&quot;&gt;不純なリデューサー&lt;/a&gt;を作成することは技術的には&lt;em&gt;可能&lt;/em&gt;ですが、そうすることはお勧めしません。タイムトラベル、記録/再生、またはホットリロードなどの開発機能は機能しなくなります。さらに、&lt;a href=&quot;https://github.com/omcljs/om&quot;&gt;Omが&lt;/a&gt;実証しているように、オブジェクトの割り当てに失敗しても、高価な再レンダリングと再計算を回避することで勝つため、不変性がほとんどの実際のアプリでパフォーマンスの問題を引き起こすようには見えません。レデューサー純度のおかげで変更されました。</target>
        </trans-unit>
        <trans-unit id="abcdc11df5ffeb4a687df7b1d5bbf50fd78fa63f" translate="yes" xml:space="preserve">
          <source>While it ultimately doesn't matter how you lay out your code on disk, it's important to remember that actions and reducers shouldn't be considered in isolation. It's entirely possible (and encouraged) for a reducer defined in one folder to respond to an action defined in another folder.</source>
          <target state="translated">ディスク上にコードをどのように配置するかは最終的には問題ではありませんが、アクションとレデューサを分離して考えるべきではないことを覚えておくことが重要です。あるフォルダに定義されたレデューサが、別のフォルダに定義されたアクションに反応することは完全に可能です(推奨されます)。</target>
        </trans-unit>
        <trans-unit id="d174eaad0823043371c5b288b8705217853f594b" translate="yes" xml:space="preserve">
          <source>While middleware can be used for a variety of things, including asynchronous API calls, it's really important that you understand where it comes from. We'll guide you through the thought process leading to middleware, by using logging and crash reporting as examples.</source>
          <target state="translated">ミドルウェアは非同期APIの呼び出しなど様々なことに利用できますが、それがどこから来ているのかを理解することは本当に重要です。ロギングやクラッシュレポートを例に挙げながら、ミドルウェアに至るまでの思考プロセスをご案内します。</target>
        </trans-unit>
        <trans-unit id="5ad63caddc89503ad9515ff6b17c9b9ddad8c44b" translate="yes" xml:space="preserve">
          <source>While there's no single definitive answer to this, most of the time this should not be a concern in either case.</source>
          <target state="translated">これに対する決定的な答えは一つではありませんが、ほとんどの場合、これはどちらのケースでも気にするべきではありません。</target>
        </trans-unit>
        <trans-unit id="baecaba85a30f210b6df40e0df3b4579a527b679" translate="yes" xml:space="preserve">
          <source>Why do we even overwrite &lt;code&gt;dispatch&lt;/code&gt;? Of course, to be able to call it later, but there's also another reason: so that every middleware can access (and call) the previously wrapped &lt;code&gt;store.dispatch&lt;/code&gt;:</source>
          <target state="translated">なぜ &lt;code&gt;dispatch&lt;/code&gt; を上書きするのですか？もちろん、後で呼び出すこともできますが、別の理由もあります。すべてのミドルウェアが、以前にラップされた &lt;code&gt;store.dispatch&lt;/code&gt; にアクセス（および呼び出し）できるようにするためです。</target>
        </trans-unit>
        <trans-unit id="8f16b35538e53672818a41ec6538a37dcb3ab3da" translate="yes" xml:space="preserve">
          <source>Why does React-Redux shallowly check each value within the props object returned from &lt;code&gt;mapStateToProp&lt;/code&gt;?</source>
          <target state="translated">React-Reduxが &lt;code&gt;mapStateToProp&lt;/code&gt; から返されたpropsオブジェクト内の各値を浅くチェックするのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="94db3c68fc052fe95a3526f89400cbf7608c18b8" translate="yes" xml:space="preserve">
          <source>Why does Redux&amp;rsquo;s use of shallow equality checking require immutability?</source>
          <target state="translated">Reduxの浅い等価性チェックの使用に不変性が必要なのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="1e3c854da8974033215e1fa6680270278cfeb926" translate="yes" xml:space="preserve">
          <source>Why does a reducer mutating the state prevent React-Redux from re-rendering a wrapped component?</source>
          <target state="translated">レデューサが状態を変異させると、React-Redux がラップされたコンポーネントを再レンダリングできなくなるのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="8ee3c091a66db76035f8a4ca74463446e1e64e6a" translate="yes" xml:space="preserve">
          <source>Why does a selector mutating and returning a persistent object to &lt;code&gt;mapStateToProps&lt;/code&gt; prevent React-Redux from re-rendering a wrapped component?</source>
          <target state="translated">セレクターが変更して永続オブジェクトを &lt;code&gt;mapStateToProps&lt;/code&gt; に返すのはなぜReact-Reduxがラップされたコンポーネントを再レンダリングしないのですか？</target>
        </trans-unit>
        <trans-unit id="644fb85f7f965c72f4406c2ac164f794580f3172" translate="yes" xml:space="preserve">
          <source>Why don't I have &lt;code&gt;this.props.dispatch&lt;/code&gt; available in my connected component?</source>
          <target state="translated">接続コンポーネントで &lt;code&gt;this.props.dispatch&lt;/code&gt; を使用できないのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="9070dbd8c65265905f9ee4a7b2376e7eafe21a53" translate="yes" xml:space="preserve">
          <source>Why don't I have this.props.dispatch available in my connected component?</source>
          <target state="translated">接続されているコンポーネントでthis.props.dispatchが利用できるようになっていないのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="187fff4819a25361b7b72220761e6b7a66afabd9" translate="yes" xml:space="preserve">
          <source>Why is immutability required by Redux?</source>
          <target state="translated">なぜReduxでは不変性が必要なのか?</target>
        </trans-unit>
        <trans-unit id="ef930e2cf88a5db6b834d3fe1be3317cae525972" translate="yes" xml:space="preserve">
          <source>Why is immutability required in Redux?</source>
          <target state="translated">なぜReduxでは不変性が必要なのか?</target>
        </trans-unit>
        <trans-unit id="8bcdba5809f1620e1841e83e3768ab2d2842bcd2" translate="yes" xml:space="preserve">
          <source>Why is it &lt;code&gt;42&lt;/code&gt;, and not &lt;code&gt;0&lt;/code&gt;, this time? Because &lt;code&gt;createStore&lt;/code&gt; was called with &lt;code&gt;42&lt;/code&gt; as the second argument. This argument becomes the &lt;code&gt;state&lt;/code&gt; passed to your reducer along with the dummy action. &lt;strong&gt;This time, &lt;code&gt;state&lt;/code&gt; is not undefined (it's &lt;code&gt;42&lt;/code&gt;!), so ES6 default argument syntax has no effect.&lt;/strong&gt; The &lt;code&gt;state&lt;/code&gt; is &lt;code&gt;42&lt;/code&gt;, and &lt;code&gt;42&lt;/code&gt; is returned from the reducer.</source>
          <target state="translated">今回は &lt;code&gt;0&lt;/code&gt; ではなく &lt;code&gt;42&lt;/code&gt; になっているのはなぜですか？2番目の引数として &lt;code&gt;42&lt;/code&gt; を指定して &lt;code&gt;createStore&lt;/code&gt; が呼び出されたためです。この引数は、ダミーアクションとともにレデューサーに渡される &lt;code&gt;state&lt;/code&gt; なります。&lt;strong&gt;今回&lt;/strong&gt;&lt;strong&gt;は&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;state&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;が未定義ではない（&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;42&lt;/code&gt; である&lt;/strong&gt;&lt;strong&gt;）ため、ES6のデフォルトの引数構文は無効です。&lt;/strong&gt; &lt;code&gt;state&lt;/code&gt; ある &lt;code&gt;42&lt;/code&gt; 、および &lt;code&gt;42&lt;/code&gt; が減速から返されます。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d09f931d0864d72b3013ba7e135c68d6b2c0d13" translate="yes" xml:space="preserve">
          <source>Why is my component re-rendering too often?</source>
          <target state="translated">コンポーネントの再レンダリングが頻繁に行われるのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="77273d55a2a0fbeee2220902bad56163a526b540" translate="yes" xml:space="preserve">
          <source>Why is this beneficial? &lt;strong&gt;It is often claimed that constants are unnecessary, and for small projects, this might be correct.&lt;/strong&gt; For larger projects, there are some benefits to defining action types as constants:</source>
          <target state="translated">なぜこれが有益なのですか？&lt;strong&gt;定数は不要であるとよく言われます。小規模なプロジェクトの場合、これは正しいかもしれません。&lt;/strong&gt;大規模なプロジェクトの場合、アクションタイプを定数として定義することにはいくつかの利点があります。</target>
        </trans-unit>
        <trans-unit id="ff0296d28f6b024408ea92b7c1ed963cf8a64adf" translate="yes" xml:space="preserve">
          <source>Why isn't my component re-rendering, or my mapStateToProps running?</source>
          <target state="translated">コンポーネントが再レンダリングされない、または mapStateToProps が実行されないのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="67ac165008f4be935481141e41f5ad4f0e445971" translate="yes" xml:space="preserve">
          <source>Why should &lt;code&gt;type&lt;/code&gt; be a string, or at least serializable? Why should my action types be constants?</source>
          <target state="translated">なぜ &lt;code&gt;type&lt;/code&gt; は文字列、または少なくともシリアライズ可能であるべきですか？アクションタイプが定数である必要があるのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="6250d26c1c06d76575d238d1fd90a39d732b6647" translate="yes" xml:space="preserve">
          <source>Why should I choose Immutable.JS as an immutable library?</source>
          <target state="translated">Immutable.JSをイミュータブルなライブラリとして選ぶべき理由は?</target>
        </trans-unit>
        <trans-unit id="36a89fdc5d2eadc3e614ad18a6f439b16e06ba2e" translate="yes" xml:space="preserve">
          <source>Why should I use an immutable-focused library such as Immutable.JS?</source>
          <target state="translated">なぜImmutable.JSのようなイミュータブルに特化したライブラリを使うべきなのか?</target>
        </trans-unit>
        <trans-unit id="f9c9ff5d2aa97da2f3c187af80701dfecc789475" translate="yes" xml:space="preserve">
          <source>Why should type be a string, or at least serializable? Why should my action types be constants?</source>
          <target state="translated">なぜ型は文字列でなければならないのか、少なくともシリアライズ可能なものでなければならないのか?なぜアクションの型は定数でなければならないのですか?</target>
        </trans-unit>
        <trans-unit id="dab3df4bfeab70c04e3398ba91567702008bac36" translate="yes" xml:space="preserve">
          <source>Why will shallow equality checking not work with mutable objects?</source>
          <target state="translated">なぜ浅い等質性チェックは、ミュータブルオブジェクトでは機能しないのでしょうか?</target>
        </trans-unit>
        <trans-unit id="478cc11a21f0ce66c20e68a01399e12557bac4a6" translate="yes" xml:space="preserve">
          <source>Wikipedia: Associative Entity</source>
          <target state="translated">ウィキペディア 連想主体</target>
        </trans-unit>
        <trans-unit id="923fc7415b6af8016333316d63e41417d9181e99" translate="yes" xml:space="preserve">
          <source>Will having &amp;ldquo;one state tree&amp;rdquo; cause memory problems? Will dispatching many actions take up memory?</source>
          <target state="translated">「1つの状態ツリー」があると、メモリの問題が発生しますか？多くのアクションをディスパッチするとメモリが消費されますか？</target>
        </trans-unit>
        <trans-unit id="1ca4941ae83a69d23ea4d39fc06d98dc6f0b9802" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;, the wrapper classes generated by the &lt;code&gt;connect()&lt;/code&gt; function do actually look for &lt;code&gt;props.store&lt;/code&gt; if it exists, but it's best if you wrap your root component in &lt;code&gt;&amp;lt;Provider store={store}&amp;gt;&lt;/code&gt; and let React Redux worry about passing the store down. This way components don't need to worry about importing a store module, and isolating a Redux app or enabling server rendering is much easier to do later.</source>
          <target state="translated">で&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;Reduxのに反応&lt;/a&gt;によって生成されたラッパークラス &lt;code&gt;connect()&lt;/code&gt; 関数は、実際に探してください &lt;code&gt;props.store&lt;/code&gt; が存在する場合、しかし、あなたはあなたのルートコンポーネントをラップした場合には最適です &lt;code&gt;&amp;lt;Provider store={store}&amp;gt;&lt;/code&gt; と通過についてReduxの心配と反応させダウンストア。このようにして、コンポーネントはストアモジュールのインポートについて心配する必要がなく、Reduxアプリの分離やサーバーレンダリングの有効化は後で行う方がはるかに簡単です。</target>
        </trans-unit>
        <trans-unit id="fb5a653a3a5bc160a77a07e48c7fddec333e9161" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;combineReducers()&lt;/code&gt; the behavior is more nuanced. Those reducers whose state is specified in &lt;code&gt;preloadedState&lt;/code&gt; will receive that state. Other reducers will receive &lt;code&gt;undefined&lt;/code&gt;&lt;em&gt;and because of that&lt;/em&gt; will fall back to the &lt;code&gt;state = ...&lt;/code&gt; default argument they specify.</source>
          <target state="translated">&lt;code&gt;combineReducers()&lt;/code&gt; の挙動は、より微妙です。その状態で指定されたものレデューサー &lt;code&gt;preloadedState&lt;/code&gt; はその状態を受信します。他のレデューサーは &lt;code&gt;undefined&lt;/code&gt; を受け取り&lt;em&gt;、そのため、&lt;/em&gt;指定した &lt;code&gt;state = ...&lt;/code&gt; デフォルト引数にフォールバックします。</target>
        </trans-unit>
        <trans-unit id="dcb12ee583209b8bb9b311e92be2aa73c59c20e7" translate="yes" xml:space="preserve">
          <source>With JavaScript, you can accidentally mutate an object (such as the Redux state tree) quite easily without realising it. For example, updating deeply nested properties, creating a new &lt;em&gt;reference&lt;/em&gt; to an object instead of a new object, or performing a shallow copy rather than a deep copy, can all lead to inadvertent object mutations, and can trip up even the most experienced JavaScript coder.</source>
          <target state="translated">JavaScriptを使用すると、オブジェクト（Redux状態ツリーなど）を、気付かないうちに簡単に誤って変更してしまう可能性があります。たとえば、深くネストされたプロパティを更新したり、新しいオブジェクトではなくオブジェクトへの新しい&lt;em&gt;参照&lt;/em&gt;を作成したり、ディープコピーではなく浅いコピーを実行したりすると、不注意によるオブジェクトの変更につながり、最も経験豊富なJavaScriptコーダーでさえもトリップする可能性があります。 。</target>
        </trans-unit>
        <trans-unit id="c279bb3233aaa1e17c77c8a143b0f1883f9cd4d7" translate="yes" xml:space="preserve">
          <source>With Redux, however, implementing undo history is a breeze. There are three reasons for this:</source>
          <target state="translated">しかし、Reduxを使えば、undoの履歴を実装するのは簡単です。これには3つの理由があります。</target>
        </trans-unit>
        <trans-unit id="30a10f999841101d22cd135f2d787dcfd7a220dd" translate="yes" xml:space="preserve">
          <source>With Redux, the same update logic can be described as a reducing function:</source>
          <target state="translated">Reduxでは、同じ更新ロジックを還元関数として記述することができます。</target>
        </trans-unit>
        <trans-unit id="c60d5cf0665575903c5afa25eb7d3eed7b4fc200" translate="yes" xml:space="preserve">
          <source>With this out of the way, let's start writing our reducer by gradually teaching it to understand the &lt;a href=&quot;actions&quot;&gt;actions&lt;/a&gt; we defined earlier.</source>
          <target state="translated">これが邪魔にならないように、少し前に定義した&lt;a href=&quot;actions&quot;&gt;アクション&lt;/a&gt;を理解するように徐々に教えて、レデューサーを書き始めましょう。</target>
        </trans-unit>
        <trans-unit id="fee9030454f12e22bef2b8be7208f6154da76739" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;middleware&quot;&gt;middleware&lt;/a&gt;, Redux store only supports &lt;a href=&quot;../basics/dataflow&quot;&gt;synchronous data flow&lt;/a&gt;. This is what you get by default with &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;middleware&quot;&gt;ミドルウェアが&lt;/a&gt;ない場合、Reduxストアは&lt;a href=&quot;../basics/dataflow&quot;&gt;同期データフロー&lt;/a&gt;のみをサポートします。これは、デフォルトで&lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt;で取得できるものです。</target>
        </trans-unit>
        <trans-unit id="b879db99111e27d801d9201a249f4ff8dadbc225" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;combineReducers()&lt;/code&gt; or similar manual code, &lt;code&gt;preloadedState&lt;/code&gt; always wins over &lt;code&gt;state = ...&lt;/code&gt; in the reducer because the &lt;code&gt;state&lt;/code&gt; passed to the reducer &lt;em&gt;is&lt;/em&gt;&lt;code&gt;preloadedState&lt;/code&gt; and &lt;em&gt;is not&lt;/em&gt;&lt;code&gt;undefined&lt;/code&gt;, so the ES6 argument syntax doesn't apply.</source>
          <target state="translated">なければ &lt;code&gt;combineReducers()&lt;/code&gt; または同様のマニュアルコード、 &lt;code&gt;preloadedState&lt;/code&gt; はいつもに勝ち &lt;code&gt;state = ...&lt;/code&gt; ので、減速中 &lt;code&gt;state&lt;/code&gt; 減速に渡さが&lt;em&gt;ある&lt;/em&gt; &lt;code&gt;preloadedState&lt;/code&gt; と&lt;em&gt;されていない&lt;/em&gt; &lt;code&gt;undefined&lt;/code&gt; ES6引数の構文が適用されませんので、。</target>
        </trans-unit>
        <trans-unit id="93111501bb024fd914d89cdba95cef4a48a41268" translate="yes" xml:space="preserve">
          <source>Without any middleware, &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; only accepts a plain object, so we have to perform AJAX calls inside our components:</source>
          <target state="translated">ミドルウェアがない場合、&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;はプレーンオブジェクトのみを受け入れるため、コンポーネント内でAJAX呼び出しを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="3eaee8c6d91975cebb24c4050db09591d953bf58" translate="yes" xml:space="preserve">
          <source>Won't calling &amp;ldquo;all my reducers&amp;rdquo; for each action be slow?</source>
          <target state="translated">各アクションで「すべてのレデューサー」を呼び出すのが遅いのではないですか？</target>
        </trans-unit>
        <trans-unit id="6136c4a62a84feac2443e18a9f39e199c0a98340" translate="yes" xml:space="preserve">
          <source>Wordpress's new admin page</source>
          <target state="translated">ワードプレスの新しい管理画面</target>
        </trans-unit>
        <trans-unit id="69c79c2885e8ffba979a60fb509366f84a77cc7d" translate="yes" xml:space="preserve">
          <source>Working with VK API (in Russian)</source>
          <target state="translated">VK API での作業 (ロシア語)</target>
        </trans-unit>
        <trans-unit id="1a31d58278381294346a4e44a8fa95eea8b2e991" translate="yes" xml:space="preserve">
          <source>Wouldn't it be nice if we logged every action that happens in the app, together with the state computed after it? When something goes wrong, we can look back at our log, and figure out which action corrupted the state.</source>
          <target state="translated">アプリ内で発生したすべてのアクションを、その後に計算された状態とともにログに記録しておくといいと思いませんか?何か問題が発生したとき、ログを見返して、どのアクションがステートを破損させたかを把握できます。</target>
        </trans-unit>
        <trans-unit id="287cf4a678ff4e9d1ea3555ab140fc6d89ea8b80" translate="yes" xml:space="preserve">
          <source>Wouldn't it be useful if, any time an error is thrown as a result of dispatching an action, we would send it to a crash reporting service like &lt;a href=&quot;https://getsentry.com/welcome/&quot;&gt;Sentry&lt;/a&gt; with the stack trace, the action that caused the error, and the current state? This way it's much easier to reproduce the error in development.</source>
          <target state="translated">アクションのディスパッチの結果としてエラーがスローされるときはいつでも、スタックトレース、エラーの原因となったアクション、および現在の状態とともに、それを&lt;a href=&quot;https://getsentry.com/welcome/&quot;&gt;Sentry&lt;/a&gt;などのクラッシュレポートサービスに送信すると便利ではないでしょうか。これにより、開発中のエラーを再現するのがはるかに簡単になります。</target>
        </trans-unit>
        <trans-unit id="411ddc1bcac2f709ddb631f9805e03c11ac7e355" translate="yes" xml:space="preserve">
          <source>Wrapping the Reducer</source>
          <target state="translated">レジューサーを包む</target>
        </trans-unit>
        <trans-unit id="ba0e9312c8cb9cd6ef1a61e5d88575514a7ba12b" translate="yes" xml:space="preserve">
          <source>Writing Tests</source>
          <target state="translated">筆記試験</target>
        </trans-unit>
        <trans-unit id="e92ef945f3ed541f8b7064bd91824ad741ef1405" translate="yes" xml:space="preserve">
          <source>Writing simple action creators can be tiresome and often ends up generating redundant boilerplate code:</source>
          <target state="translated">シンプルなアクションクリエイターを書くのは疲れるし、多くの場合、冗長なボイラプレートコードを生成することになります。</target>
        </trans-unit>
        <trans-unit id="80dc0881b1c90b466a5ebf41c749b8683c142f76" translate="yes" xml:space="preserve">
          <source>Ximedes</source>
          <target state="translated">Ximedes</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="885f3940d9ce7913d6e6d671fe072b2efd348d82" translate="yes" xml:space="preserve">
          <source>Yes, lots of them! To name just a few:</source>
          <target state="translated">そう、たくさん!いくつか挙げればキリがありません。</target>
        </trans-unit>
        <trans-unit id="677676d61dff082b230a183ba82de368a4fd2ae9" translate="yes" xml:space="preserve">
          <source>You Might Not Need Redux</source>
          <target state="translated">あなたはReduxを必要としないかもしれません</target>
        </trans-unit>
        <trans-unit id="b5debd85103d524869a8aafb925b357862c1933e" translate="yes" xml:space="preserve">
          <source>You can also enable the &lt;a href=&quot;recipes/usingobjectspreadoperator&quot;&gt;object spread operator proposal&lt;/a&gt; for a more succinct syntax:</source>
          <target state="translated">より簡潔な構文の&lt;a href=&quot;recipes/usingobjectspreadoperator&quot;&gt;オブジェクトスプレッドオペレーターの提案&lt;/a&gt;を有効にすることもできます。</target>
        </trans-unit>
        <trans-unit id="ea3d01095c6b6725a225b7568204932eba587586" translate="yes" xml:space="preserve">
          <source>You can always write a function that generates an action creator:</source>
          <target state="translated">アクションクリエーターを生成する関数は必ず書けます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
