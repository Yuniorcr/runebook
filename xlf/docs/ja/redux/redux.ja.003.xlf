<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="redux">
    <body>
      <group id="redux">
        <trans-unit id="5ad63caddc89503ad9515ff6b17c9b9ddad8c44b" translate="yes" xml:space="preserve">
          <source>While there's no single definitive answer to this, most of the time this should not be a concern in either case.</source>
          <target state="translated">これに対する決定的な答えは一つではありませんが、ほとんどの場合、これはどちらのケースでも気にするべきではありません。</target>
        </trans-unit>
        <trans-unit id="baecaba85a30f210b6df40e0df3b4579a527b679" translate="yes" xml:space="preserve">
          <source>Why do we even overwrite &lt;code&gt;dispatch&lt;/code&gt;? Of course, to be able to call it later, but there's also another reason: so that every middleware can access (and call) the previously wrapped &lt;code&gt;store.dispatch&lt;/code&gt;:</source>
          <target state="translated">なぜ &lt;code&gt;dispatch&lt;/code&gt; を上書きするのですか？もちろん、後で呼び出すこともできますが、別の理由もあります。すべてのミドルウェアが、以前にラップされた &lt;code&gt;store.dispatch&lt;/code&gt; にアクセス（および呼び出し）できるようにするためです。</target>
        </trans-unit>
        <trans-unit id="8f16b35538e53672818a41ec6538a37dcb3ab3da" translate="yes" xml:space="preserve">
          <source>Why does React-Redux shallowly check each value within the props object returned from &lt;code&gt;mapStateToProp&lt;/code&gt;?</source>
          <target state="translated">React-Reduxが &lt;code&gt;mapStateToProp&lt;/code&gt; から返されたpropsオブジェクト内の各値を浅くチェックするのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="94db3c68fc052fe95a3526f89400cbf7608c18b8" translate="yes" xml:space="preserve">
          <source>Why does Redux&amp;rsquo;s use of shallow equality checking require immutability?</source>
          <target state="translated">Reduxの浅い等価性チェックの使用に不変性が必要なのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="1e3c854da8974033215e1fa6680270278cfeb926" translate="yes" xml:space="preserve">
          <source>Why does a reducer mutating the state prevent React-Redux from re-rendering a wrapped component?</source>
          <target state="translated">レデューサが状態を変異させると、React-Redux がラップされたコンポーネントを再レンダリングできなくなるのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="8ee3c091a66db76035f8a4ca74463446e1e64e6a" translate="yes" xml:space="preserve">
          <source>Why does a selector mutating and returning a persistent object to &lt;code&gt;mapStateToProps&lt;/code&gt; prevent React-Redux from re-rendering a wrapped component?</source>
          <target state="translated">セレクターが変更して永続オブジェクトを &lt;code&gt;mapStateToProps&lt;/code&gt; に返すのはなぜReact-Reduxがラップされたコンポーネントを再レンダリングしないのですか？</target>
        </trans-unit>
        <trans-unit id="644fb85f7f965c72f4406c2ac164f794580f3172" translate="yes" xml:space="preserve">
          <source>Why don't I have &lt;code&gt;this.props.dispatch&lt;/code&gt; available in my connected component?</source>
          <target state="translated">接続コンポーネントで &lt;code&gt;this.props.dispatch&lt;/code&gt; を使用できないのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="9070dbd8c65265905f9ee4a7b2376e7eafe21a53" translate="yes" xml:space="preserve">
          <source>Why don't I have this.props.dispatch available in my connected component?</source>
          <target state="translated">接続されているコンポーネントでthis.props.dispatchが利用できるようになっていないのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="187fff4819a25361b7b72220761e6b7a66afabd9" translate="yes" xml:space="preserve">
          <source>Why is immutability required by Redux?</source>
          <target state="translated">なぜReduxでは不変性が必要なのか?</target>
        </trans-unit>
        <trans-unit id="ef930e2cf88a5db6b834d3fe1be3317cae525972" translate="yes" xml:space="preserve">
          <source>Why is immutability required in Redux?</source>
          <target state="translated">なぜReduxでは不変性が必要なのか?</target>
        </trans-unit>
        <trans-unit id="8bcdba5809f1620e1841e83e3768ab2d2842bcd2" translate="yes" xml:space="preserve">
          <source>Why is it &lt;code&gt;42&lt;/code&gt;, and not &lt;code&gt;0&lt;/code&gt;, this time? Because &lt;code&gt;createStore&lt;/code&gt; was called with &lt;code&gt;42&lt;/code&gt; as the second argument. This argument becomes the &lt;code&gt;state&lt;/code&gt; passed to your reducer along with the dummy action. &lt;strong&gt;This time, &lt;code&gt;state&lt;/code&gt; is not undefined (it's &lt;code&gt;42&lt;/code&gt;!), so ES6 default argument syntax has no effect.&lt;/strong&gt; The &lt;code&gt;state&lt;/code&gt; is &lt;code&gt;42&lt;/code&gt;, and &lt;code&gt;42&lt;/code&gt; is returned from the reducer.</source>
          <target state="translated">今回は &lt;code&gt;0&lt;/code&gt; ではなく &lt;code&gt;42&lt;/code&gt; になっているのはなぜですか？2番目の引数として &lt;code&gt;42&lt;/code&gt; を指定して &lt;code&gt;createStore&lt;/code&gt; が呼び出されたためです。この引数は、ダミーアクションとともにレデューサーに渡される &lt;code&gt;state&lt;/code&gt; なります。&lt;strong&gt;今回&lt;/strong&gt;&lt;strong&gt;は&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;state&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;が未定義ではない（&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;42&lt;/code&gt; である&lt;/strong&gt;&lt;strong&gt;）ため、ES6のデフォルトの引数構文は無効です。&lt;/strong&gt; &lt;code&gt;state&lt;/code&gt; ある &lt;code&gt;42&lt;/code&gt; 、および &lt;code&gt;42&lt;/code&gt; が減速から返されます。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d09f931d0864d72b3013ba7e135c68d6b2c0d13" translate="yes" xml:space="preserve">
          <source>Why is my component re-rendering too often?</source>
          <target state="translated">コンポーネントの再レンダリングが頻繁に行われるのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="77273d55a2a0fbeee2220902bad56163a526b540" translate="yes" xml:space="preserve">
          <source>Why is this beneficial? &lt;strong&gt;It is often claimed that constants are unnecessary, and for small projects, this might be correct.&lt;/strong&gt; For larger projects, there are some benefits to defining action types as constants:</source>
          <target state="translated">なぜこれが有益なのですか？&lt;strong&gt;定数は不要であるとよく言われます。小規模なプロジェクトの場合、これは正しいかもしれません。&lt;/strong&gt;大規模なプロジェクトの場合、アクションタイプを定数として定義することにはいくつかの利点があります。</target>
        </trans-unit>
        <trans-unit id="ff0296d28f6b024408ea92b7c1ed963cf8a64adf" translate="yes" xml:space="preserve">
          <source>Why isn't my component re-rendering, or my mapStateToProps running?</source>
          <target state="translated">コンポーネントが再レンダリングされない、または mapStateToProps が実行されないのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="67ac165008f4be935481141e41f5ad4f0e445971" translate="yes" xml:space="preserve">
          <source>Why should &lt;code&gt;type&lt;/code&gt; be a string, or at least serializable? Why should my action types be constants?</source>
          <target state="translated">なぜ &lt;code&gt;type&lt;/code&gt; は文字列、または少なくともシリアライズ可能であるべきですか？アクションタイプが定数である必要があるのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="6250d26c1c06d76575d238d1fd90a39d732b6647" translate="yes" xml:space="preserve">
          <source>Why should I choose Immutable.JS as an immutable library?</source>
          <target state="translated">Immutable.JSをイミュータブルなライブラリとして選ぶべき理由は?</target>
        </trans-unit>
        <trans-unit id="36a89fdc5d2eadc3e614ad18a6f439b16e06ba2e" translate="yes" xml:space="preserve">
          <source>Why should I use an immutable-focused library such as Immutable.JS?</source>
          <target state="translated">なぜImmutable.JSのようなイミュータブルに特化したライブラリを使うべきなのか?</target>
        </trans-unit>
        <trans-unit id="f9c9ff5d2aa97da2f3c187af80701dfecc789475" translate="yes" xml:space="preserve">
          <source>Why should type be a string, or at least serializable? Why should my action types be constants?</source>
          <target state="translated">なぜ型は文字列でなければならないのか、少なくともシリアライズ可能なものでなければならないのか?なぜアクションの型は定数でなければならないのですか?</target>
        </trans-unit>
        <trans-unit id="dab3df4bfeab70c04e3398ba91567702008bac36" translate="yes" xml:space="preserve">
          <source>Why will shallow equality checking not work with mutable objects?</source>
          <target state="translated">なぜ浅い等質性チェックは、ミュータブルオブジェクトでは機能しないのでしょうか?</target>
        </trans-unit>
        <trans-unit id="478cc11a21f0ce66c20e68a01399e12557bac4a6" translate="yes" xml:space="preserve">
          <source>Wikipedia: Associative Entity</source>
          <target state="translated">ウィキペディア 連想主体</target>
        </trans-unit>
        <trans-unit id="923fc7415b6af8016333316d63e41417d9181e99" translate="yes" xml:space="preserve">
          <source>Will having &amp;ldquo;one state tree&amp;rdquo; cause memory problems? Will dispatching many actions take up memory?</source>
          <target state="translated">「1つの状態ツリー」があると、メモリの問題が発生しますか？多くのアクションをディスパッチするとメモリが消費されますか？</target>
        </trans-unit>
        <trans-unit id="1ca4941ae83a69d23ea4d39fc06d98dc6f0b9802" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;, the wrapper classes generated by the &lt;code&gt;connect()&lt;/code&gt; function do actually look for &lt;code&gt;props.store&lt;/code&gt; if it exists, but it's best if you wrap your root component in &lt;code&gt;&amp;lt;Provider store={store}&amp;gt;&lt;/code&gt; and let React Redux worry about passing the store down. This way components don't need to worry about importing a store module, and isolating a Redux app or enabling server rendering is much easier to do later.</source>
          <target state="translated">で&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;Reduxのに反応&lt;/a&gt;によって生成されたラッパークラス &lt;code&gt;connect()&lt;/code&gt; 関数は、実際に探してください &lt;code&gt;props.store&lt;/code&gt; が存在する場合、しかし、あなたはあなたのルートコンポーネントをラップした場合には最適です &lt;code&gt;&amp;lt;Provider store={store}&amp;gt;&lt;/code&gt; と通過についてReduxの心配と反応させダウンストア。このようにして、コンポーネントはストアモジュールのインポートについて心配する必要がなく、Reduxアプリの分離やサーバーレンダリングの有効化は後で行う方がはるかに簡単です。</target>
        </trans-unit>
        <trans-unit id="fb5a653a3a5bc160a77a07e48c7fddec333e9161" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;combineReducers()&lt;/code&gt; the behavior is more nuanced. Those reducers whose state is specified in &lt;code&gt;preloadedState&lt;/code&gt; will receive that state. Other reducers will receive &lt;code&gt;undefined&lt;/code&gt;&lt;em&gt;and because of that&lt;/em&gt; will fall back to the &lt;code&gt;state = ...&lt;/code&gt; default argument they specify.</source>
          <target state="translated">&lt;code&gt;combineReducers()&lt;/code&gt; の挙動は、より微妙です。その状態で指定されたものレデューサー &lt;code&gt;preloadedState&lt;/code&gt; はその状態を受信します。他のレデューサーは &lt;code&gt;undefined&lt;/code&gt; を受け取り&lt;em&gt;、そのため、&lt;/em&gt;指定した &lt;code&gt;state = ...&lt;/code&gt; デフォルト引数にフォールバックします。</target>
        </trans-unit>
        <trans-unit id="dcb12ee583209b8bb9b311e92be2aa73c59c20e7" translate="yes" xml:space="preserve">
          <source>With JavaScript, you can accidentally mutate an object (such as the Redux state tree) quite easily without realising it. For example, updating deeply nested properties, creating a new &lt;em&gt;reference&lt;/em&gt; to an object instead of a new object, or performing a shallow copy rather than a deep copy, can all lead to inadvertent object mutations, and can trip up even the most experienced JavaScript coder.</source>
          <target state="translated">JavaScriptを使用すると、オブジェクト（Redux状態ツリーなど）を、気付かないうちに簡単に誤って変更してしまう可能性があります。たとえば、深くネストされたプロパティを更新したり、新しいオブジェクトではなくオブジェクトへの新しい&lt;em&gt;参照&lt;/em&gt;を作成したり、ディープコピーではなく浅いコピーを実行したりすると、不注意によるオブジェクトの変更につながり、最も経験豊富なJavaScriptコーダーでさえもトリップする可能性があります。 。</target>
        </trans-unit>
        <trans-unit id="c279bb3233aaa1e17c77c8a143b0f1883f9cd4d7" translate="yes" xml:space="preserve">
          <source>With Redux, however, implementing undo history is a breeze. There are three reasons for this:</source>
          <target state="translated">しかし、Reduxを使えば、undoの履歴を実装するのは簡単です。これには3つの理由があります。</target>
        </trans-unit>
        <trans-unit id="30a10f999841101d22cd135f2d787dcfd7a220dd" translate="yes" xml:space="preserve">
          <source>With Redux, the same update logic can be described as a reducing function:</source>
          <target state="translated">Reduxでは、同じ更新ロジックを還元関数として記述することができます。</target>
        </trans-unit>
        <trans-unit id="c60d5cf0665575903c5afa25eb7d3eed7b4fc200" translate="yes" xml:space="preserve">
          <source>With this out of the way, let's start writing our reducer by gradually teaching it to understand the &lt;a href=&quot;actions&quot;&gt;actions&lt;/a&gt; we defined earlier.</source>
          <target state="translated">これが邪魔にならないように、少し前に定義した&lt;a href=&quot;actions&quot;&gt;アクション&lt;/a&gt;を理解するように徐々に教えて、レデューサーを書き始めましょう。</target>
        </trans-unit>
        <trans-unit id="fee9030454f12e22bef2b8be7208f6154da76739" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;middleware&quot;&gt;middleware&lt;/a&gt;, Redux store only supports &lt;a href=&quot;../basics/dataflow&quot;&gt;synchronous data flow&lt;/a&gt;. This is what you get by default with &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;middleware&quot;&gt;ミドルウェアが&lt;/a&gt;ない場合、Reduxストアは&lt;a href=&quot;../basics/dataflow&quot;&gt;同期データフロー&lt;/a&gt;のみをサポートします。これは、デフォルトで&lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt;で取得できるものです。</target>
        </trans-unit>
        <trans-unit id="b879db99111e27d801d9201a249f4ff8dadbc225" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;combineReducers()&lt;/code&gt; or similar manual code, &lt;code&gt;preloadedState&lt;/code&gt; always wins over &lt;code&gt;state = ...&lt;/code&gt; in the reducer because the &lt;code&gt;state&lt;/code&gt; passed to the reducer &lt;em&gt;is&lt;/em&gt;&lt;code&gt;preloadedState&lt;/code&gt; and &lt;em&gt;is not&lt;/em&gt;&lt;code&gt;undefined&lt;/code&gt;, so the ES6 argument syntax doesn't apply.</source>
          <target state="translated">なければ &lt;code&gt;combineReducers()&lt;/code&gt; または同様のマニュアルコード、 &lt;code&gt;preloadedState&lt;/code&gt; はいつもに勝ち &lt;code&gt;state = ...&lt;/code&gt; ので、減速中 &lt;code&gt;state&lt;/code&gt; 減速に渡さが&lt;em&gt;ある&lt;/em&gt; &lt;code&gt;preloadedState&lt;/code&gt; と&lt;em&gt;されていない&lt;/em&gt; &lt;code&gt;undefined&lt;/code&gt; ES6引数の構文が適用されませんので、。</target>
        </trans-unit>
        <trans-unit id="93111501bb024fd914d89cdba95cef4a48a41268" translate="yes" xml:space="preserve">
          <source>Without any middleware, &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; only accepts a plain object, so we have to perform AJAX calls inside our components:</source>
          <target state="translated">ミドルウェアがない場合、&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;はプレーンオブジェクトのみを受け入れるため、コンポーネント内でAJAX呼び出しを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="3eaee8c6d91975cebb24c4050db09591d953bf58" translate="yes" xml:space="preserve">
          <source>Won't calling &amp;ldquo;all my reducers&amp;rdquo; for each action be slow?</source>
          <target state="translated">各アクションで「すべてのレデューサー」を呼び出すのが遅いのではないですか？</target>
        </trans-unit>
        <trans-unit id="6136c4a62a84feac2443e18a9f39e199c0a98340" translate="yes" xml:space="preserve">
          <source>Wordpress's new admin page</source>
          <target state="translated">ワードプレスの新しい管理画面</target>
        </trans-unit>
        <trans-unit id="69c79c2885e8ffba979a60fb509366f84a77cc7d" translate="yes" xml:space="preserve">
          <source>Working with VK API (in Russian)</source>
          <target state="translated">VK API での作業 (ロシア語)</target>
        </trans-unit>
        <trans-unit id="1a31d58278381294346a4e44a8fa95eea8b2e991" translate="yes" xml:space="preserve">
          <source>Wouldn't it be nice if we logged every action that happens in the app, together with the state computed after it? When something goes wrong, we can look back at our log, and figure out which action corrupted the state.</source>
          <target state="translated">アプリ内で発生したすべてのアクションを、その後に計算された状態とともにログに記録しておくといいと思いませんか?何か問題が発生したとき、ログを見返して、どのアクションがステートを破損させたかを把握できます。</target>
        </trans-unit>
        <trans-unit id="287cf4a678ff4e9d1ea3555ab140fc6d89ea8b80" translate="yes" xml:space="preserve">
          <source>Wouldn't it be useful if, any time an error is thrown as a result of dispatching an action, we would send it to a crash reporting service like &lt;a href=&quot;https://getsentry.com/welcome/&quot;&gt;Sentry&lt;/a&gt; with the stack trace, the action that caused the error, and the current state? This way it's much easier to reproduce the error in development.</source>
          <target state="translated">アクションのディスパッチの結果としてエラーがスローされるときはいつでも、スタックトレース、エラーの原因となったアクション、および現在の状態とともに、それを&lt;a href=&quot;https://getsentry.com/welcome/&quot;&gt;Sentry&lt;/a&gt;などのクラッシュレポートサービスに送信すると便利ではないでしょうか。これにより、開発中のエラーを再現するのがはるかに簡単になります。</target>
        </trans-unit>
        <trans-unit id="411ddc1bcac2f709ddb631f9805e03c11ac7e355" translate="yes" xml:space="preserve">
          <source>Wrapping the Reducer</source>
          <target state="translated">レジューサーを包む</target>
        </trans-unit>
        <trans-unit id="ba0e9312c8cb9cd6ef1a61e5d88575514a7ba12b" translate="yes" xml:space="preserve">
          <source>Writing Tests</source>
          <target state="translated">筆記試験</target>
        </trans-unit>
        <trans-unit id="e92ef945f3ed541f8b7064bd91824ad741ef1405" translate="yes" xml:space="preserve">
          <source>Writing simple action creators can be tiresome and often ends up generating redundant boilerplate code:</source>
          <target state="translated">シンプルなアクションクリエイターを書くのは疲れるし、多くの場合、冗長なボイラプレートコードを生成することになります。</target>
        </trans-unit>
        <trans-unit id="80dc0881b1c90b466a5ebf41c749b8683c142f76" translate="yes" xml:space="preserve">
          <source>Ximedes</source>
          <target state="translated">Ximedes</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="885f3940d9ce7913d6e6d671fe072b2efd348d82" translate="yes" xml:space="preserve">
          <source>Yes, lots of them! To name just a few:</source>
          <target state="translated">そう、たくさん!いくつか挙げればキリがありません。</target>
        </trans-unit>
        <trans-unit id="677676d61dff082b230a183ba82de368a4fd2ae9" translate="yes" xml:space="preserve">
          <source>You Might Not Need Redux</source>
          <target state="translated">あなたはReduxを必要としないかもしれません</target>
        </trans-unit>
        <trans-unit id="b5debd85103d524869a8aafb925b357862c1933e" translate="yes" xml:space="preserve">
          <source>You can also enable the &lt;a href=&quot;recipes/usingobjectspreadoperator&quot;&gt;object spread operator proposal&lt;/a&gt; for a more succinct syntax:</source>
          <target state="translated">より簡潔な構文の&lt;a href=&quot;recipes/usingobjectspreadoperator&quot;&gt;オブジェクトスプレッドオペレーターの提案&lt;/a&gt;を有効にすることもできます。</target>
        </trans-unit>
        <trans-unit id="ea3d01095c6b6725a225b7568204932eba587586" translate="yes" xml:space="preserve">
          <source>You can always write a function that generates an action creator:</source>
          <target state="translated">アクションクリエーターを生成する関数は必ず書けます。</target>
        </trans-unit>
        <trans-unit id="ebedd29e20c0b181d70ffe15f5988d119d67516f" translate="yes" xml:space="preserve">
          <source>You can call &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch(action)&lt;/code&gt;&lt;/a&gt; from anywhere in your app, including components and XHR callbacks, or even at scheduled intervals.</source>
          <target state="translated">&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch(action)&lt;/code&gt; &lt;/a&gt;は、コンポーネントやXHRコールバックを含むアプリ内のどこからでも、またはスケジュールされた間隔ででも呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="870b3b70e7feab01dc48305e33a3f7b71d9e003a" translate="yes" xml:space="preserve">
          <source>You can control state key names by using different keys for the reducers in the passed object. For example, you may call &lt;code&gt;combineReducers({ todos: myTodosReducer, counter: myCounterReducer })&lt;/code&gt; for the state shape to be &lt;code&gt;{ todos, counter }&lt;/code&gt;.</source>
          <target state="translated">渡されたオブジェクトのレデューサーにさまざまなキーを使用して、状態キーの名前を制御できます。たとえば、ステート形状を &lt;code&gt;{ todos, counter }&lt;/code&gt; ために、 &lt;code&gt;combineReducers({ todos: myTodosReducer, counter: myCounterReducer })&lt;/code&gt; を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="84b80aff840c6b3c2cb0814711f2e90fb9add9aa" translate="yes" xml:space="preserve">
          <source>You can even write a custom middleware to describe calls to your API, like the &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; does.</source>
          <target state="translated">&lt;a href=&quot;../introduction/examples#real-world&quot;&gt;実際の例の&lt;/a&gt;ように、カスタムミドルウェアを記述して、APIへの呼び出しを記述することもできます。</target>
        </trans-unit>
        <trans-unit id="1bcfc87ae98655e6e4c23b31a5690541a13ff642" translate="yes" xml:space="preserve">
          <source>You can extract logging into a function:</source>
          <target state="translated">ログを関数に抽出することができます。</target>
        </trans-unit>
        <trans-unit id="1306a831686a52c567f5d3446dae27226d983c27" translate="yes" xml:space="preserve">
          <source>You can find more examples in &lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Reduxで&lt;/a&gt;他の例を見つけることができます。</target>
        </trans-unit>
        <trans-unit id="1db4cdd68a98570c03ba8a576e981e8641ef738b" translate="yes" xml:space="preserve">
          <source>You can find the official logo &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/logo&quot;&gt;on GitHub&lt;/a&gt;.</source>
          <target state="translated">公式ロゴ&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/logo&quot;&gt;はGitHubにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8fb1259c8d739932d68e05103d65deeafc4b13b1" translate="yes" xml:space="preserve">
          <source>You can see how this causes the state held by the store to change:</source>
          <target state="translated">これで、お店が保持している状態が変化してしまうことがわかります。</target>
        </trans-unit>
        <trans-unit id="a4eddcb9e81b002608a7bf4ef875c82738729233" translate="yes" xml:space="preserve">
          <source>You can set up your build tool of choice (Webpack, Browserify, etc.) to compile a bundle file into &lt;code&gt;static/bundle.js&lt;/code&gt;.</source>
          <target state="translated">選択したビルドツール（Webpack、Browserifyなど）をセットアップして、バンドルファイルを &lt;code&gt;static/bundle.js&lt;/code&gt; にコンパイルできます。</target>
        </trans-unit>
        <trans-unit id="23310ba75752c6caee4c2c18e21c9fe454bf81a2" translate="yes" xml:space="preserve">
          <source>You can then pass &lt;code&gt;dispatch&lt;/code&gt; down to other components manually, if you want to.</source>
          <target state="translated">その後、必要に応じて、 &lt;code&gt;dispatch&lt;/code&gt; を他のコンポーネントに手動で渡すことができます。</target>
        </trans-unit>
        <trans-unit id="f95f737abcdb30e78aa13a25f5076e2ef6dc3676" translate="yes" xml:space="preserve">
          <source>You can then use it everywhere instead of &lt;code&gt;store.dispatch()&lt;/code&gt;:</source>
          <target state="translated">その後、 &lt;code&gt;store.dispatch()&lt;/code&gt; の代わりにどこでも使用できます。</target>
        </trans-unit>
        <trans-unit id="bfbaa58ba5417a98c5d0d32b5ce14eba1d4e2fef" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; or &lt;a href=&quot;https://github.com/pburtchaell/redux-promise-middleware&quot;&gt;redux-promise-middleware&lt;/a&gt; to dispatch Promises instead of functions.</source>
          <target state="translated">関数の代わりに&lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt;または&lt;a href=&quot;https://github.com/pburtchaell/redux-promise-middleware&quot;&gt;redux-promise-middleware&lt;/a&gt;を使用してPromiseをディスパッチできます。</target>
        </trans-unit>
        <trans-unit id="9d98266f375d43672febffb46f3ed5355675dc5b" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://github.com/redux-observable/redux-observable&quot;&gt;redux-observable&lt;/a&gt; to dispatch Observables.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/redux-observable/redux-observable&quot;&gt;redux-observable&lt;/a&gt;を使用して、Observableをディスパッチできます。</target>
        </trans-unit>
        <trans-unit id="8d9c266f69d53ba1763af2ada1d6653210151773" translate="yes" xml:space="preserve">
          <source>You can use Redux together with &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;, or with any other view library.</source>
          <target state="translated">Reduxを&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;やその他のビューライブラリと一緒に使用できます。</target>
        </trans-unit>
        <trans-unit id="28d3cd95f0d488448a63a6b338cb50068a95d5d9" translate="yes" xml:space="preserve">
          <source>You can use it at all levels of your reducer structure, not just to create the root reducer. It's very common to have multiple combined reducers in various places, which are composed together to create the root reducer.</source>
          <target state="translated">ルートレデューサを作成するだけでなく、レデューサ構造のすべてのレベルで使用することができます。様々な場所に複数の結合されたレデューサがあり、それらを一緒に構成してルートレデューサを作成することは非常に一般的です。</target>
        </trans-unit>
        <trans-unit id="490b5a07e2c5aad3ad0c9fd7a27a52665898f60e" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://github.com/lelandrichardson/redux-pack&quot;&gt;redux-pack&lt;/a&gt; middleware to dispatch promise-based asynchronous actions.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/lelandrichardson/redux-pack&quot;&gt;redux-pack&lt;/a&gt;ミドルウェアを使用して、promiseベースの非同期アクションをディスパッチできます。</target>
        </trans-unit>
        <trans-unit id="df0e299c97c2207cdace456ccd47c72d8b63f087" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://github.com/yelouafi/redux-saga/&quot;&gt;redux-saga&lt;/a&gt; middleware to build more complex asynchronous actions.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/yelouafi/redux-saga/&quot;&gt;redux-saga&lt;/a&gt;ミドルウェアを使用して、より複雑な非同期アクションを構築できます。</target>
        </trans-unit>
        <trans-unit id="2be61aa399225330ac3c7c8f8b6d9263d4b58435" translate="yes" xml:space="preserve">
          <source>You cannot mutate an immutable object; instead, you must mutate a copy of it, leaving the original intact.</source>
          <target state="translated">不変オブジェクトを突然変異させることはできません。その代わりに、元のオブジェクトをそのままにして、そのコピーを突然変異させなければなりません。</target>
        </trans-unit>
        <trans-unit id="9002cfc3dd43f6e0951811e8e815e8e77752e185" translate="yes" xml:space="preserve">
          <source>You could also give them different keys, or call functions differently. These two ways to write a combined reducer are equivalent:</source>
          <target state="translated">また、異なるキーを与えたり、異なる関数を呼び出したりすることもできます。これら2つの方法は、結合されたレデューサの書き方に相当します。</target>
        </trans-unit>
        <trans-unit id="1be388744a3e109fec6dfea1a28f5eb27d9ed9a9" translate="yes" xml:space="preserve">
          <source>You could even go as far as to make a generic filtering higher-order reducer:</source>
          <target state="translated">汎用的なフィルタリング高次減速機を作るところまで行ってもいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="1e73413f8379bbd8e9bb56a500c7eb3c5f375e13" translate="yes" xml:space="preserve">
          <source>You do not need to use Immutable.JS with Redux. Plain JavaScript, if written correctly, is perfectly capable of providing immutability without having to use an immutable-focused library.</source>
          <target state="translated">ReduxでImmutable.JSを使う必要はありません。正しく書かれていれば、プレーンな JavaScript は Immutable に特化したライブラリを使わなくても Immutability を提供することができます。</target>
        </trans-unit>
        <trans-unit id="9581e0ed51066ff103253aa77beee1d1478416ea" translate="yes" xml:space="preserve">
          <source>You don't have to define action type constants in a separate file, or even to define them at all. For a small project, it might be easier to just use string literals for action types. However, there are some benefits to explicitly declaring constants in larger codebases. Read &lt;a href=&quot;../recipes/reducingboilerplate&quot;&gt;Reducing Boilerplate&lt;/a&gt; for more practical tips on keeping your codebase clean.</source>
          <target state="translated">アクションタイプの定数を別のファイルで定義したり、まったく定義したりする必要はありません。小規模なプロジェクトの場合、アクションタイプに文字列リテラルを使用する方が簡単な場合があります。ただし、より大きなコードベースで定数を明示的に宣言することにはいくつかの利点があります。コードベースをクリーンに保つためのより実用的なヒントについては、&lt;a href=&quot;../recipes/reducingboilerplate&quot;&gt;ボイラープレートの削減&lt;/a&gt;をお読みください。</target>
        </trans-unit>
        <trans-unit id="199448d814bc5e9584035a52d2115857f50dad49" translate="yes" xml:space="preserve">
          <source>You have two reducers:</source>
          <target state="translated">2つの減速機を持っていますね。</target>
        </trans-unit>
        <trans-unit id="192eb5ae977897417943647ddbcb6a6f3d4104d2" translate="yes" xml:space="preserve">
          <source>You may call &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; from a change listener, with the following caveats:</source>
          <target state="translated">次の点に注意して、変更リスナーから&lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="b929863aa2c2de96072c024f0b1ab365c66cfa6b" translate="yes" xml:space="preserve">
          <source>You may call &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; from a change listener, with the following caveats:</source>
          <target state="translated">変更リスナーから&lt;a href=&quot;#dispatchaction&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;を呼び出すことができますが、次の点に注意してください。</target>
        </trans-unit>
        <trans-unit id="3ebca9d5f96869ed296e545e937054edc0f8c94d" translate="yes" xml:space="preserve">
          <source>You may call &lt;code&gt;combineReducers&lt;/code&gt; at any level of the reducer hierarchy. It doesn't have to happen at the top. In fact you may use it again to split the child reducers that get too complicated into independent grandchildren, and so on.</source>
          <target state="translated">あなたはリデューサー階層の任意のレベルで &lt;code&gt;combineReducers&lt;/code&gt; を呼び出すことができます。上部で発生する必要はありません。実際、これを再度使用して、複雑すぎる子リデューサーを独立した孫に分割することもできます。</target>
        </trans-unit>
        <trans-unit id="3644afb1fd9b1feb972c2dc856f2ca012f2fd6b3" translate="yes" xml:space="preserve">
          <source>You may enhance &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt;. It is not required, but it lets you &lt;a href=&quot;asyncactions&quot;&gt;express asynchronous actions in a convenient way&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware()&lt;/code&gt; &lt;/a&gt;を使用して&lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt;を拡張できます。必須ではありませんが、&lt;a href=&quot;asyncactions&quot;&gt;非同期アクションを便利な方法で表現&lt;/a&gt;できます。</target>
        </trans-unit>
        <trans-unit id="d912b7407f7325b0f1291dd95c400a5024e9614d" translate="yes" xml:space="preserve">
          <source>You may need to write some custom functions for handling some of these actions. This may require replacing &lt;code&gt;combineReducers&lt;/code&gt; with your own top-level reducer function. You can also use a utility such as &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;reduce-reducers&lt;/a&gt; to run &lt;code&gt;combineReducers&lt;/code&gt; to handle most actions, but also run a more specialized reducer for specific actions that cross state slices.</source>
          <target state="translated">これらのアクションの一部を処理するために、いくつかのカスタム関数を作成する必要がある場合があります。これには、 &lt;code&gt;combineReducers&lt;/code&gt; を独自のトップレベルのリデューサー関数に置き換える必要がある場合があります。また、&lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;reduce- &lt;/a&gt; &lt;code&gt;combineReducers&lt;/code&gt; などのユーティリティを使用して、combinReducerを実行してほとんどのアクションを処理することもできますが、状態のスライスをまたがる特定のアクションに対して、より特化したリデューサーを実行することもできます。</target>
        </trans-unit>
        <trans-unit id="09059cc37b1193dbc15c30252c07daa76e286f64" translate="yes" xml:space="preserve">
          <source>You may optionally specify the initial state as the second argument to &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt;. This is useful for hydrating the state of the client to match the state of a Redux application running on the server.</source>
          <target state="translated">オプションで、初期状態を&lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; の&lt;/a&gt; 2番目の引数として指定できます。これは、サーバーで実行されているReduxアプリケーションの状態と一致するようにクライアントの状態を調整するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="3ee0e53b45fb2fa831d9c837168e8230281cd9d8" translate="yes" xml:space="preserve">
          <source>You may use a dedicated &lt;code&gt;status&lt;/code&gt; field in your actions:</source>
          <target state="translated">アクションでは専用の &lt;code&gt;status&lt;/code&gt; フィールドを使用できます。</target>
        </trans-unit>
        <trans-unit id="db87382954c55c5d2ee83adf7f38146a50266b8e" translate="yes" xml:space="preserve">
          <source>You may want to read &lt;a href=&quot;../advanced/asyncactions&quot;&gt;Async Actions&lt;/a&gt; to learn more about expressing asynchronous flow in Redux with async primitives such as Promises and thunks. Keep in mind that anything you learn there can also be applied to universal rendering.</source>
          <target state="translated">&lt;a href=&quot;../advanced/asyncactions&quot;&gt;非同期アクション&lt;/a&gt;を読んで、Promiseやサンクなどの非同期プリミティブを使用してReduxで非同期フローを表現する方法について学ぶことができます。そこで学んだことはすべてユニバーサルレンダリングにも適用できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ec6c69e4ca4e0cce6a488148dc045be49daaf6a8" translate="yes" xml:space="preserve">
          <source>You may wrap one or more reducers in &lt;code&gt;undoable&lt;/code&gt; at any level of the reducer composition hierarchy. We choose to wrap &lt;code&gt;todos&lt;/code&gt; instead of the top-level combined reducer so that changes to &lt;code&gt;visibilityFilter&lt;/code&gt; are not reflected in the undo history.</source>
          <target state="translated">リデューサー構成階層のどのレベルでも、1つ以上のリデューサーを &lt;code&gt;undoable&lt;/code&gt; ラップできます。トップレベルの結合されたリデューサーの代わりに &lt;code&gt;todos&lt;/code&gt; をラップすることを選択し、 &lt;code&gt;visibilityFilter&lt;/code&gt; への変更が元に戻す履歴に反映されないようにします。</target>
        </trans-unit>
        <trans-unit id="b5dbd93add81c61b1e16815b79f40079a123eba8" translate="yes" xml:space="preserve">
          <source>You might ask: why don't we bind the action creators to the store instance right away, like in classical Flux? The problem is that this won't work well with universal apps that need to render on the server. Most likely you want to have a separate store instance per request so you can prepare them with different data, but binding action creators during their definition means you're stuck with a single store instance for all requests.</source>
          <target state="translated">なぜ従来のFLUXのように、アクションクリエイターをストアインスタンスにバインドしないのか?問題は、サーバー上でレンダリングする必要のあるユニバーサルアプリではうまく機能しないことです。しかし、アクションクリエイターを定義中にバインドすると、すべてのリクエストに対して1つのストアインスタンスを使用しなければならなくなります。</target>
        </trans-unit>
        <trans-unit id="2896f8f64f8c4e00e8362d43f027ff694ea34032" translate="yes" xml:space="preserve">
          <source>You might be familiar with &lt;a href=&quot;https://en.wikipedia.org/wiki/Higher-order_function&quot;&gt;higher order functions&lt;/a&gt;. If you use React, you might be familiar with &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;higher order components&lt;/a&gt;. Here is a variation on the same pattern, applied to reducers.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Higher-order_function&quot;&gt;より高次の関数に&lt;/a&gt;慣れているかもしれません。Reactを使用する場合は、&lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;より高次のコンポーネントに&lt;/a&gt;慣れている可能性があります。これは、レデューサーに適用された同じパターンのバリエーションです。</target>
        </trans-unit>
        <trans-unit id="fc80378efa78f4250982b149969a4e4206388634" translate="yes" xml:space="preserve">
          <source>You might have heard that Redux was influenced by &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm Architecture&lt;/a&gt;. It shouldn't come as a surprise that this example is very similar to &lt;a href=&quot;http://package.elm-lang.org/packages/TheSeamau5/elm-undo-redo/2.0.0&quot;&gt;elm-undo-redo package&lt;/a&gt;.</source>
          <target state="translated">Reduxが&lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm Architectureの&lt;/a&gt;影響を受けたと聞いたことがあるかもしれません。この例が&lt;a href=&quot;http://package.elm-lang.org/packages/TheSeamau5/elm-undo-redo/2.0.0&quot;&gt;elm-undo-redoパッケージ&lt;/a&gt;に非常に似ていることは驚くに値しません。</target>
        </trans-unit>
        <trans-unit id="be8f897b9ef506870651387b41362b89ab366329" translate="yes" xml:space="preserve">
          <source>You might want to use it to apply several &lt;a href=&quot;../glossary#store-enhancer&quot;&gt;store enhancers&lt;/a&gt; in a row.</source>
          <target state="translated">これを使用して、複数の&lt;a href=&quot;../glossary#store-enhancer&quot;&gt;ストアエンハンサー&lt;/a&gt;を連続して適用することができます。</target>
        </trans-unit>
        <trans-unit id="cb8edb49caaa697733e02d643699b140e0476f6b" translate="yes" xml:space="preserve">
          <source>You might write an action creator in a separate file, and import it into your component:</source>
          <target state="translated">アクションクリエーターを別ファイルに書いて、それをコンポーネントにインポートしてもいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="5012c361d888ca9c67b230342b72327b08a9b0ab" translate="yes" xml:space="preserve">
          <source>You never see this, of course - the data you give to an Immutable.JS object is never mutated. Rather, it&amp;rsquo;s the &lt;em&gt;intermediate&lt;/em&gt; data generated within Immutable.JS from a chained sequence of method calls that is free to be mutated. You therefore get all the benefits of immutable data structures with none (or very little) of the potential performance hits.</source>
          <target state="translated">もちろん、これを目にすることはありません。Immutable.JSオブジェクトに渡すデータは変更されません。むしろ、自由に変更できるメソッド呼び出しの連鎖シーケンスからImmutable.JS内で生成された&lt;em&gt;中間&lt;/em&gt;データです。したがって、潜在的なパフォーマンスへの影響がまったくない（またはほとんどない）場合でも、不変のデータ構造のすべての利点を得ることができます。</target>
        </trans-unit>
        <trans-unit id="536f6105b2c796a51f197bb3552df6076809a08a" translate="yes" xml:space="preserve">
          <source>You will need to wrap the reducer you wish to enhance with &lt;code&gt;undoable&lt;/code&gt; function. For example, if you exported a &lt;code&gt;todos&lt;/code&gt; reducer from a dedicated file, you will want to change it to export the result of calling &lt;code&gt;undoable()&lt;/code&gt; with the reducer you wrote:</source>
          <target state="translated">元に &lt;code&gt;undoable&lt;/code&gt; 機能を使用して、拡張するレデューサーをラップする必要があります。たとえば、専用ファイルから &lt;code&gt;todos&lt;/code&gt; レデューサーをエクスポートした場合は、それを変更して、作成したレデューサーで &lt;code&gt;undoable()&lt;/code&gt; を呼び出した結果をエクスポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="0d71f702363520e8d52cd5cf66c6865dbac24253" translate="yes" xml:space="preserve">
          <source>You will probably want to remove the hash from the URL (e.g: &lt;code&gt;http://localhost:3000/#/?_k=4sbb0i&lt;/code&gt;). For doing this, you will need to also import &lt;code&gt;browserHistory&lt;/code&gt; from React Router:</source>
          <target state="translated">おそらく、URLからハッシュを削除する必要があります（例： &lt;code&gt;http://localhost:3000/#/?_k=4sbb0i&lt;/code&gt; ）。これを行うには、React Routerから &lt;code&gt;browserHistory&lt;/code&gt; もインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="847e7a43a897e6825651ba6a7171789bd4f8c993" translate="yes" xml:space="preserve">
          <source>You will use &lt;code&gt;connect()&lt;/code&gt; from &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; to generate a container component. To determine whether to enable Undo and Redo buttons, you can check &lt;code&gt;state.todos.past.length&lt;/code&gt; and &lt;code&gt;state.todos.future.length&lt;/code&gt;. You won't need to write action creators for performing undo and redo because Redux Undo already provides them:</source>
          <target state="translated">あなたは使います &lt;code&gt;connect()&lt;/code&gt; から&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;リアクトReduxの&lt;/a&gt;コンテナコンポーネントを生成します。[元に戻す]ボタンと[やり直し]ボタンを有効にするかどうかを判断するには、 &lt;code&gt;state.todos.past.length&lt;/code&gt; と &lt;code&gt;state.todos.future.length&lt;/code&gt; を確認します。取り消しとやり直しを実行するためのアクションクリエーターを作成する必要はありません。</target>
        </trans-unit>
        <trans-unit id="ced3f60087b9c7dc7b64e901bea63d5a41a88099" translate="yes" xml:space="preserve">
          <source>You would only use the named export for tests.</source>
          <target state="translated">テストのためだけに名前付きエクスポートを使用することになります。</target>
        </trans-unit>
        <trans-unit id="f002654c7b958bdea2528eaaa9c1e1ce5d2cfe9d" translate="yes" xml:space="preserve">
          <source>You'll know when you need Flux. If you aren't sure if you need it, you don't need it.</source>
          <target state="translated">フラックスが必要かどうかは、あなたが知ることができます。必要かどうかわからない場合は、必要ありません。</target>
        </trans-unit>
        <trans-unit id="9e4884b4000a8d2ac41ed531bf7a37bd6a9faaa2" translate="yes" xml:space="preserve">
          <source>You'll often find that you need to store some data, as well as some UI state, in the state tree. This is fine, but try to keep the data separate from the UI state.</source>
          <target state="translated">UI の状態と同様に、いくつかのデータを状態ツリーに保存する必要があることに気づくでしょう。これは問題ありませんが、データと UI の状態を分離しておくようにしてください。</target>
        </trans-unit>
        <trans-unit id="483dc0e6baee4af78f1c3f12ab8f28dda9a34453" translate="yes" xml:space="preserve">
          <source>You've seen middleware in action in the &lt;a href=&quot;asyncactions&quot;&gt;Async Actions&lt;/a&gt; example. If you've used server-side libraries like &lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt; and &lt;a href=&quot;http://koajs.com/&quot;&gt;Koa&lt;/a&gt;, you were also probably already familiar with the concept of &lt;em&gt;middleware&lt;/em&gt;. In these frameworks, middleware is some code you can put between the framework receiving a request, and the framework generating a response. For example, Express or Koa middleware may add CORS headers, logging, compression, and more. The best feature of middleware is that it's composable in a chain. You can use multiple independent third-party middleware in a single project.</source>
          <target state="translated">&lt;a href=&quot;asyncactions&quot;&gt;非同期アクションの&lt;/a&gt;例でミドルウェアが動作しているのを見てきました。&lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt;や&lt;a href=&quot;http://koajs.com/&quot;&gt;Koa&lt;/a&gt;などのサーバー側のライブラリを使用したことがある場合は、&lt;em&gt;ミドルウェア&lt;/em&gt;の概念にも既に慣れている&lt;em&gt;はずです&lt;/em&gt;。これらのフレームワークでは、ミドルウェアは、要求を受信するフレームワークと応答を生成するフレームワークの間に置くことができるいくつかのコードです。たとえば、ExpressまたはKoaミドルウェアは、CORSヘッダー、ロギング、圧縮などを追加します。ミドルウェアの最大の特徴は、チェーンで構成できることです。 1つのプロジェクトで複数の独立したサードパーティのミドルウェアを使用できます。</target>
        </trans-unit>
        <trans-unit id="7028f3891ebf7e4827d5eaddfa0e16584b0b4466" translate="yes" xml:space="preserve">
          <source>Your dumb components should be pure; that is, they should produce the same output given the same input, and have no external dependencies. If you pass such a component an Immutable.JS object as a prop, you make it dependent upon Immutable.JS to extract the prop&amp;rsquo;s value and otherwise manipulate it.</source>
          <target state="translated">ダムコンポーネントは純粋でなければなりません。つまり、同じ入力が与えられた場合、同じ出力を生成し、外部への依存関係はありません。そのようなコンポーネントにImmutable.JSオブジェクトを小道具として渡す場合は、Immutable.JSに依存して小道具の値を抽出し、それ以外の場合はそれを操作します。</target>
        </trans-unit>
        <trans-unit id="395dd2fb0c94aec217ae48791e24ace04816fc89" translate="yes" xml:space="preserve">
          <source>Your process will look like this:</source>
          <target state="translated">あなたのプロセスは次のようになります。</target>
        </trans-unit>
        <trans-unit id="2b13a159884d03a53c5b0abbb9540e28b3419ef7" translate="yes" xml:space="preserve">
          <source>Your selectors should return Immutable.JS objects</source>
          <target state="translated">セレクタは Immutable.JS オブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="281e35c0465b8b3d761e36f053ead41086e72367" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;enhancer&lt;/code&gt;] &lt;em&gt;(Function)&lt;/em&gt;: The store enhancer. You may optionally specify it to enhance the store with third-party capabilities such as middleware, time travel, persistence, etc. The only store enhancer that ships with Redux is &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">[ &lt;code&gt;enhancer&lt;/code&gt; ] &lt;em&gt;（機能）&lt;/em&gt;：ストアエンハンサー。オプションで、ミドルウェア、タイムトラベル、パーシスタンスなどのサードパーティの機能でストアを拡張するように指定することもできます&lt;a href=&quot;applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware()&lt;/code&gt; &lt;/a&gt;れる唯一のストアエンハンサーは、applyMiddleware（）です。</target>
        </trans-unit>
        <trans-unit id="87286375e4668a58823fba92d2b07b7a44fc0be4" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;preloadedState&lt;/code&gt;] &lt;em&gt;(any)&lt;/em&gt;: The initial state. You may optionally specify it to hydrate the state from the server in universal apps, or to restore a previously serialized user session. If you produced &lt;code&gt;reducer&lt;/code&gt; with &lt;a href=&quot;combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt;, this must be a plain object with the same shape as the keys passed to it. Otherwise, you are free to pass anything that your &lt;code&gt;reducer&lt;/code&gt; can understand.</source>
          <target state="translated">[ &lt;code&gt;preloadedState&lt;/code&gt; ] &lt;em&gt;（any）&lt;/em&gt;：初期状態。オプションでそれを指定して、ユニバーサルアプリのサーバーから状態をハイドレートするか、以前にシリアル化されたユーザーセッションを復元することができます。&lt;a href=&quot;combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt;を使用して &lt;code&gt;reducer&lt;/code&gt; を作成した場合、これは、渡されるキーと同じ形状のプレーンオブジェクトである必要があります。それ以外の場合は、 &lt;code&gt;reducer&lt;/code&gt; が理解できるものは何でも渡すことができます。</target>
        </trans-unit>
        <trans-unit id="c70c7e915a4a2b3601daa15f9ed309a470505e50" translate="yes" xml:space="preserve">
          <source>and configure it to use ES2015 features in &lt;code&gt;.babelrc&lt;/code&gt;:</source>
          <target state="translated">そして、でES2015の機能を使用するように設定 &lt;code&gt;.babelrc&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fd3ab734b4fb4c62257230890e59143d0e998962" translate="yes" xml:space="preserve">
          <source>and pass it to the &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; in order to remove the hash from the URL:</source>
          <target state="translated">URLからハッシュを削除するために、それを &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; に渡します。</target>
        </trans-unit>
        <trans-unit id="5f432ecbf9e6a7a5c1f170d992e60626ab120d96" translate="yes" xml:space="preserve">
          <source>and run &lt;code&gt;npm test&lt;/code&gt; to run it once, or &lt;code&gt;npm run test:watch&lt;/code&gt; to test on every file change.</source>
          <target state="translated">そして実行 &lt;code&gt;npm test&lt;/code&gt; 一度それを実行するために、または &lt;code&gt;npm run test:watch&lt;/code&gt; すべてのファイルの変更のテストには。</target>
        </trans-unit>
        <trans-unit id="f81edf81cd89734f8439987c58e09f5451875a46" translate="yes" xml:space="preserve">
          <source>and then pass the state along to the client.</source>
          <target state="translated">を使用して、その状態をクライアントに渡します。</target>
        </trans-unit>
        <trans-unit id="f3894228d526596c3cf53c57bbed5aae8b11537a" translate="yes" xml:space="preserve">
          <source>applyMiddleware()</source>
          <target state="translated">applyMiddleware()</target>
        </trans-unit>
        <trans-unit id="b6ad41cdd6bf4c2b18169a773d483861384cd204" translate="yes" xml:space="preserve">
          <source>applyMiddleware(...middleware)</source>
          <target state="translated">applyMiddleware(...middleware)</target>
        </trans-unit>
        <trans-unit id="7fedb9730abc492e1bcf1596264f044b04661aab" translate="yes" xml:space="preserve">
          <source>applyMiddleware(...middlewares)</source>
          <target state="translated">applyMiddleware(...middlewares)</target>
        </trans-unit>
        <trans-unit id="3f5c37526331395762baf88047f99e6d8b619f94" translate="yes" xml:space="preserve">
          <source>bindActionCreators()</source>
          <target state="translated">bindActionCreators()</target>
        </trans-unit>
        <trans-unit id="88e632a0686333c0fcc1b71ebd9b524a2ddd992d" translate="yes" xml:space="preserve">
          <source>bindActionCreators(actionCreators, dispatch)</source>
          <target state="translated">bindActionCreators(actionCreators,ディスパッチ)</target>
        </trans-unit>
        <trans-unit id="3042d6bd02c4ca7273effadee7e63bf42bed16c9" translate="yes" xml:space="preserve">
          <source>calls the appropriate reducer and passes it the slice;</source>
          <target state="translated">は適切なリデューサを呼び出してスライスを渡します。</target>
        </trans-unit>
        <trans-unit id="c3cf4ce11b3b5577a3871fe5b3cd80587b04a46c" translate="yes" xml:space="preserve">
          <source>can be tested like:</source>
          <target state="translated">のようにテストすることができます。</target>
        </trans-unit>
        <trans-unit id="991b9417df7c9c174211ba006b7edc0195725286" translate="yes" xml:space="preserve">
          <source>combineReducers()</source>
          <target state="translated">combineReducers()</target>
        </trans-unit>
        <trans-unit id="50f164696008c84fbdf8d8f93fe6bbfa9b14e143" translate="yes" xml:space="preserve">
          <source>combineReducers(reducers)</source>
          <target state="translated">combineReducers(reducers)</target>
        </trans-unit>
        <trans-unit id="c8dc852570744e8e3067cca75ce9fe7af17afec8" translate="yes" xml:space="preserve">
          <source>compose()</source>
          <target state="translated">compose()</target>
        </trans-unit>
        <trans-unit id="5745a141fb4592e3d9eb885924e51235574f61c6" translate="yes" xml:space="preserve">
          <source>compose(...functions)</source>
          <target state="translated">compose(...functions)</target>
        </trans-unit>
        <trans-unit id="112d9f2631778cd8a08a4296c2ccbf312712f2b3" translate="yes" xml:space="preserve">
          <source>cpsubrian: React decorators for redux/react-router/immutable &amp;lsquo;smart&amp;rsquo; components</source>
          <target state="translated">cpsubrian：redux / react-router /不変の「スマート」コンポーネント用のReactデコレーター</target>
        </trans-unit>
        <trans-unit id="94ba045109577a1f4ae2fedc6ca6e16e7cec8d37" translate="yes" xml:space="preserve">
          <source>create a fresh, new Redux store instance on every request;</source>
          <target state="translated">は、リクエストのたびに新しい Redux ストアのインスタンスを作成します。</target>
        </trans-unit>
        <trans-unit id="b44915cfa2285ca11f257a840e99d4d3f28fc3a7" translate="yes" xml:space="preserve">
          <source>createStore()</source>
          <target state="translated">createStore()</target>
        </trans-unit>
        <trans-unit id="6ab01e2a484c9683cca2393d2ba3c93180699ee0" translate="yes" xml:space="preserve">
          <source>createStore(reducer, [preloadedState], [enhancer])</source>
          <target state="translated">createStore(reducer,[preloadedState],[enhancer])</target>
        </trans-unit>
        <trans-unit id="8fa33131b6a660bc8d77fd4bb48a66d021301526" translate="yes" xml:space="preserve">
          <source>creates a reference to the current state slice referred to by each key;</source>
          <target state="translated">は、各キーで参照される現在の状態スライスへの参照を作成します。</target>
        </trans-unit>
        <trans-unit id="e3a4682977bb863d850d9eae5d719e2585e731e5" translate="yes" xml:space="preserve">
          <source>creates a reference to the possibly-mutated state slice that's returned by the reducer.</source>
          <target state="translated">減算器が返す、変異した可能性のある状態のスライスへの参照を作成します。</target>
        </trans-unit>
        <trans-unit id="280c1cc5f52574880ff013357b30094632bcbd78" translate="yes" xml:space="preserve">
          <source>dispatch(action)</source>
          <target state="translated">dispatch(action)</target>
        </trans-unit>
        <trans-unit id="b6e86cff86751f0236e17d84f44ac6dc44060213" translate="yes" xml:space="preserve">
          <source>for scale, we have ~500 action types, ~400 reducer cases, ~150 components, 5 middlewares, ~200 actions, ~2300 tests</source>
          <target state="translated">スケールでは、~500のアクションタイプ、~400のレデューサケース、~150のコンポーネント、5つのミドルウェア、~200のアクション、~2300のテストがあります。</target>
        </trans-unit>
        <trans-unit id="5fe375f56e9a0fa7dc88b61b3c4b3425c5636e79" translate="yes" xml:space="preserve">
          <source>getState()</source>
          <target state="translated">getState()</target>
        </trans-unit>
        <trans-unit id="5cffe5ee80305aeabc52048276f1acf872533639" translate="yes" xml:space="preserve">
          <source>is equivalent to this:</source>
          <target state="translated">がこれに相当します。</target>
        </trans-unit>
        <trans-unit id="1c0bbc97bd6780fb3baf83d4730c736904a39e76" translate="yes" xml:space="preserve">
          <source>optionally dispatch some actions;</source>
          <target state="translated">オプションでいくつかのアクションをディスパッチします。</target>
        </trans-unit>
        <trans-unit id="e7916345e570f1bcf19d018b0792a5db68935506" translate="yes" xml:space="preserve">
          <source>pull the state out of store;</source>
          <target state="translated">状態を店から引き抜く</target>
        </trans-unit>
        <trans-unit id="71ad63d785b9b9fdb536fac77ce747b9c5a69bc1" translate="yes" xml:space="preserve">
          <source>react-redux-jwt-auth-example</source>
          <target state="translated">react-redux-jwt-auth-example</target>
        </trans-unit>
        <trans-unit id="52295e92a7867dd2bf6e329dcebd064d09c14653" translate="yes" xml:space="preserve">
          <source>redux-immutable</source>
          <target state="translated">redux-immutable</target>
        </trans-unit>
        <trans-unit id="a88f184d5bfff1ab2b78bc41b8b30999ba677a10" translate="yes" xml:space="preserve">
          <source>replaceReducer(nextReducer)</source>
          <target state="translated">replaceReducer(nextReducer)</target>
        </trans-unit>
        <trans-unit id="9a9bbe4119c43d2a84a043196b4690c761b01d0a" translate="yes" xml:space="preserve">
          <source>subscribe(listener)</source>
          <target state="translated">subscribe(listener)</target>
        </trans-unit>
        <trans-unit id="26c8253fda7262249d6aacde189c2d069461b383" translate="yes" xml:space="preserve">
          <source>the keys &lt;code&gt;todos&lt;/code&gt; and &lt;code&gt;counter&lt;/code&gt; each refer to a separate state slice;</source>
          <target state="translated">キーの &lt;code&gt;todos&lt;/code&gt; と &lt;code&gt;counter&lt;/code&gt; はそれぞれ別個の状態スライスを参照します。</target>
        </trans-unit>
        <trans-unit id="afd2b6bf0fb616dda82e8ec1df11d135e0adf003" translate="yes" xml:space="preserve">
          <source>the values &lt;code&gt;myTodosReducer&lt;/code&gt; and &lt;code&gt;myCounterReducer&lt;/code&gt; are reducer functions, with each acting on the state slice identified by the respective key.</source>
          <target state="translated">&lt;code&gt;myTodosReducer&lt;/code&gt; と &lt;code&gt;myCounterReducer&lt;/code&gt; の値はリデューサー関数であり、それぞれがそれぞれのキーで識別される状態スライスに作用します。</target>
        </trans-unit>
        <trans-unit id="365862a50c0682caa8baa6f30edca76e3e5f81ed" translate="yes" xml:space="preserve">
          <source>where:</source>
          <target state="translated">where:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
