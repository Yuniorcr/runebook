<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="83cb868a19ad904f84bd14cae43f07e0e83d2688" translate="yes" xml:space="preserve">
          <source>Type widening</source>
          <target state="translated">タイプワイド化</target>
        </trans-unit>
        <trans-unit id="3e24ac06d77df39af05bd30d658cb57a3337ea7e" translate="yes" xml:space="preserve">
          <source>Type-checking for &lt;code&gt;globalThis&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;globalThis&lt;/code&gt; の型チェック</target>
        </trans-unit>
        <trans-unit id="132ee1e5890623f8c51b5d7832771ea869685cc0" translate="yes" xml:space="preserve">
          <source>Type-checking speed-ups</source>
          <target state="translated">タイプチェックのスピードアップ</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="51f19890936977049a98344a575f9d1393582141" translate="yes" xml:space="preserve">
          <source>TypeScript 1.1</source>
          <target state="translated">TypeScript 1.1</target>
        </trans-unit>
        <trans-unit id="b1d54818952af192cd88b3450b54f2603e4f7e6b" translate="yes" xml:space="preserve">
          <source>TypeScript 1.3</source>
          <target state="translated">TypeScript 1.3</target>
        </trans-unit>
        <trans-unit id="4e048202597f480e0a0a50251a2d17601a97331c" translate="yes" xml:space="preserve">
          <source>TypeScript 1.4</source>
          <target state="translated">TypeScript 1.4</target>
        </trans-unit>
        <trans-unit id="f1963162918ae8e217f030a5c747f80a58b5003c" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5</source>
          <target state="translated">TypeScript 1.5</target>
        </trans-unit>
        <trans-unit id="f1a5005d913327706c332f5d05905d598d513f83" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 adds support to ES6 destructuring declarations and assignments.</source>
          <target state="translated">TypeScript 1.5 では、ES6 のデストラクチャリング宣言と代入のサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="335ed14095b748ea23e413ca55e75e72c5f81c2f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 adds support to ES6 for..of loops on arrays for ES3/ES5 as well as full support for Iterator interfaces when targeting ES6.</source>
          <target state="translated">TypeScript 1.5 では、ES3/ES5 での配列上でのループのサポートに加え、ES6 をターゲットにした場合の Iterator インターフェイスのフルサポートが追加されています。</target>
        </trans-unit>
        <trans-unit id="147499580851a581c1ebc7b1eb35e61574c9455f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 supports ECMAScript 6 (ES6) modules. ES6 modules are effectively TypeScript external modules with a new syntax: ES6 modules are separately loaded source files that possibly import other modules and provide a number of externally accessible exports. ES6 modules feature several new export and import declarations. It is recommended that TypeScript libraries and applications be updated to use the new syntax, but this is not a requirement. The new ES6 module syntax coexists with TypeScript&amp;rsquo;s original internal and external module constructs and the constructs can be mixed and matched at will.</source>
          <target state="translated">TypeScript 1.5はECMAScript 6（ES6）モジュールをサポートしています。ES6モジュールは事実上、新しい構文のTypeScript外部モジュールです。ES6モジュールは、他のモジュールをインポートし、外部からアクセス可能な多数のエクスポートを提供する個別に読み込まれたソースファイルです。ES6モジュールは、いくつかの新しいエクスポートおよびインポート宣言を備えています。TypeScriptライブラリとアプリケーションを更新して新しい構文を使用することをお勧めしますが、これは必須ではありません。新しいES6モジュールの構文は、TypeScriptの元の内部および外部モジュール構成と共存し、構成は自由に組み合わせて組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="26a05cf740016ec03540fa113e60b6681f5d2b43" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6</source>
          <target state="translated">TypeScript 1.6</target>
        </trans-unit>
        <trans-unit id="257249ad75fda76652230e9b8ec23343f481d876" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds a new way to narrow a variable type inside an &lt;code&gt;if&lt;/code&gt; block, in addition to &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt;. A user-defined type guard functions is one with a return type annotation of the form &lt;code&gt;x is T&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is a declared parameter in the signature, and &lt;code&gt;T&lt;/code&gt; is any type. When a user-defined type guard function is invoked on a variable in an &lt;code&gt;if&lt;/code&gt; block, the type of the variable will be narrowed to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.6では、 &lt;code&gt;typeof&lt;/code&gt; および &lt;code&gt;instanceof&lt;/code&gt; に加えて、 &lt;code&gt;if&lt;/code&gt; ブロック内の変数の型を絞り込む新しい方法が追加されています。ユーザー定義のタイプガード関数は、 &lt;code&gt;x is T&lt;/code&gt; という形式の戻り値型注釈を持つ関数です。ここで、 &lt;code&gt;x&lt;/code&gt; はシグネチャの宣言されたパラメーターで、 &lt;code&gt;T&lt;/code&gt; は任意のタイプです。 &lt;code&gt;if&lt;/code&gt; ブロックの変数でユーザー定義型のガード関数が呼び出されると、変数の型は &lt;code&gt;T&lt;/code&gt; に狭められます。</target>
        </trans-unit>
        <trans-unit id="1f559afb4f11f75baf94b34b6c1d2a9f3ffb7db7" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for &lt;code&gt;abstract&lt;/code&gt; keyword for classes and their methods. An abstract class is allowed to have methods with no implementation, and cannot be constructed.</source>
          <target state="translated">TypeScript 1.6では、クラスとそのメソッドの &lt;code&gt;abstract&lt;/code&gt; キーワードのサポートが追加されています。抽象クラスは、実装のないメソッドを持つことが許可されており、構築することはできません。</target>
        </trans-unit>
        <trans-unit id="b5e601692f8167fd347befb7fc0e15d90de2b5e2" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for ES6 class expressions. In a class expression, the class name is optional and, if specified, is only in scope in the class expression itself. This is similar to the optional name of a function expression. It is not possible to refer to the class instance type of a class expression outside the class expression, but the type can of course be matched structurally. For example:</source>
          <target state="translated">TypeScript 1.6 では、ES6 のクラス式のサポートが追加されました。クラス式では、クラス名はオプションであり、指定された場合、クラス式自体のスコープ内にのみ存在します。これは関数式のオプション名と似ています。クラス式の外でクラス式のクラスインスタンス型を参照することはできませんが、もちろん型は構造的に一致させることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="d34db5c0571adb17d9dbb4e011e6ce7abf305442" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for classes extending arbitrary expression that computes a constructor function. This means that built-in types can now be extended in class declarations.</source>
          <target state="translated">TypeScript 1.6 では、コンストラクタ関数を計算する任意の式を拡張するクラスのサポートが追加されました。これは、組み込み型をクラス宣言で拡張できるようになったことを意味します。</target>
        </trans-unit>
        <trans-unit id="6dc2d923fb5094bd0e7c94f1ead891676ccf6b36" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for generators when targeting ES6.</source>
          <target state="translated">TypeScript 1.6では、ES6をターゲットにした場合のジェネレータのサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="c2708dce6a915f6b14074965fa09a0d65239987f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 enforces stricter object literal assignment checks for the purpose of catching excess or misspelled properties. Specifically, when a fresh object literal is assigned to a variable or passed as an argument for a non-empty target type, it is an error for the object literal to specify properties that don&amp;rsquo;t exist in the target type.</source>
          <target state="translated">TypeScript 1.6は、過剰なプロパティやスペルミスのあるプロパティをキャッチする目的で、より厳密なオブジェクトリテラル割り当てチェックを実施します。具体的には、新しいオブジェクトリテラルが変数に割り当てられているか、空でないターゲットタイプの引数として渡されている場合、オブジェクトリテラルがターゲットタイプに存在しないプロパティを指定するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="75bb78b9b873fbe1d3340640c97864da1f68f446" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces a new &lt;code&gt;.tsx&lt;/code&gt; file extension. This extension does two things: it enables JSX inside of TypeScript files, and it makes the new &lt;code&gt;as&lt;/code&gt; operator the default way to cast (removing any ambiguity between JSX expressions and the TypeScript prefix cast operator). For example:</source>
          <target state="translated">TypeScript 1.6では、新しい &lt;code&gt;.tsx&lt;/code&gt; ファイル拡張子が導入されています。この拡張機能は2つのことを行います。TypeScriptファイル内でJSXを有効にし、新しい &lt;code&gt;as&lt;/code&gt; 演算子をデフォルトのキャスト方法にします（JSX式とTypeScriptプレフィックスキャスト演算子のあいまいさを取り除く）。例えば：</target>
        </trans-unit>
        <trans-unit id="389c8891386ded2a5990a7399a0c8581f595589d" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces experimental support of &lt;code&gt;async&lt;/code&gt; functions when targeting ES6. Async functions are expected to invoke an asynchronous operation and await its result without blocking normal execution of the program. This accomplished through the use of an ES6-compatible &lt;code&gt;Promise&lt;/code&gt; implementation, and transposition of the function body into a compatible form to resume execution when the awaited asynchronous operation completes.</source>
          <target state="translated">TypeScript 1.6では、ES6を対象とする場合の &lt;code&gt;async&lt;/code&gt; 関数の実験的なサポートが導入されています。非同期関数は、非同期操作を呼び出し、プログラムの通常の実行をブロックせずに結果を待つことが期待されています。これは、ES6互換の &lt;code&gt;Promise&lt;/code&gt; 実装の使用と、待機中の非同期操作が完了したときに実行を再開するための互換性のある形式への関数本体の転置によって達成されました。</target>
        </trans-unit>
        <trans-unit id="6d3985068c5007795b0f129f437f0236376e44ee" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces intersection types, the logical complement of union types. A union type &lt;code&gt;A | B&lt;/code&gt; represents an entity that is either of type &lt;code&gt;A&lt;/code&gt; or type &lt;code&gt;B&lt;/code&gt;, whereas an intersection type &lt;code&gt;A &amp;amp; B&lt;/code&gt; represents an entity that is both of type &lt;code&gt;A&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; type &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.6では、共用体型の論理的な補完である交差型が導入されています。ユニオンタイプ &lt;code&gt;A | B&lt;/code&gt; はタイプ &lt;code&gt;A&lt;/code&gt; またはタイプ &lt;code&gt;B&lt;/code&gt; のいずれかのエンティティーを表し、交差タイプ &lt;code&gt;A &amp;amp; B&lt;/code&gt; はタイプ &lt;code&gt;A&lt;/code&gt; &lt;em&gt;と&lt;/em&gt;タイプ &lt;code&gt;B&lt;/code&gt; の両方のエンティティーを表します。</target>
        </trans-unit>
        <trans-unit id="5adb28b0e2ffb9129f1f8e6e88f1a6d027c82cfd" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7</source>
          <target state="translated">TypeScript 1.7</target>
        </trans-unit>
        <trans-unit id="b8049d25161330d1dbcbb77bfa401335476ed317" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 adds &lt;code&gt;ES6&lt;/code&gt; to the list of options available for the &lt;code&gt;--module&lt;/code&gt; flag and allows you to specify the module output when targeting &lt;code&gt;ES6&lt;/code&gt;. This provides more flexibility to target exactly the features you want in specific runtimes.</source>
          <target state="translated">活字体1.7が追加されます &lt;code&gt;ES6&lt;/code&gt; のために利用可能なオプションのリストに &lt;code&gt;--module&lt;/code&gt; フラグ、あなたがターゲットとする場合、モジュールの出力を指定することができます &lt;code&gt;ES6&lt;/code&gt; を。これにより、特定のランタイムで必要な機能を的確にターゲットにできる柔軟性が高まります。</target>
        </trans-unit>
        <trans-unit id="372cae9853890909499623bfc1859384ca77ae13" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 makes checking of destructuring patterns with an object literal or array literal initializers less rigid and more intuitive.</source>
          <target state="translated">TypeScript 1.7 では、オブジェクトリテラルや配列リテラルのイニシャライザを使った破壊パターンのチェックが、より堅苦しくなく、より直感的に行えるようになりました。</target>
        </trans-unit>
        <trans-unit id="3a8e0881b9f6a916c5d699f8a8930f131e755c61" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 supports upcoming &lt;a href=&quot;https://github.com/rwaldron/exponentiation-operator&quot;&gt;ES7/ES2016 exponentiation operators&lt;/a&gt;: &lt;code&gt;**&lt;/code&gt; and &lt;code&gt;**=&lt;/code&gt;. The operators will be transformed in the output to ES3/ES5 using &lt;code&gt;Math.pow&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.7は、次の&lt;a href=&quot;https://github.com/rwaldron/exponentiation-operator&quot;&gt;ES7 / ES2016指数演算子を&lt;/a&gt;サポートします： &lt;code&gt;**&lt;/code&gt; および &lt;code&gt;**=&lt;/code&gt; 。演算子は、 &lt;code&gt;Math.pow&lt;/code&gt; を使用して出力でES3 / ES5に変換されます。</target>
        </trans-unit>
        <trans-unit id="90324bee80eec2d37872bcfe8ebd584d982ffa5e" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8</source>
          <target state="translated">TypeScript 1.8</target>
        </trans-unit>
        <trans-unit id="bf434e8d29bed8fa2f0c97832e4f7465ceae4e51" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 allows &lt;code&gt;tsconfig.json&lt;/code&gt; files in all project types. This includes ASP.NET v4 projects, &lt;em&gt;Console Application&lt;/em&gt;, and the &lt;em&gt;Html Application with TypeScript&lt;/em&gt; project types. Further, you are no longer limited to a single &lt;code&gt;tsconfig.json&lt;/code&gt; file but can add multiple, and each will be built as part of the project. This allows you to separate the configuration for different parts of your application without having to use multiple different projects.</source>
          <target state="translated">TypeScript 1.8では、すべてのプロジェクトタイプで &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを使用できます。これには、ASP.NET v4プロジェクト、&lt;em&gt;コンソールアプリケーション&lt;/em&gt;、および&lt;em&gt;TypeScript&lt;/em&gt;プロジェクトタイプの&lt;em&gt;HTMLアプリケーションが&lt;/em&gt;含まれます。さらに、1つの &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルに制限されることはなくなりましたが、複数を追加でき、それぞれがプロジェクトの一部としてビルドされます。これにより、複数の異なるプロジェクトを使用せずに、アプリケーションのさまざまな部分の構成を分離できます。</target>
        </trans-unit>
        <trans-unit id="523ae0c6d720551553d08e322cbe5f48827a2f11" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 allows users to use the &lt;code&gt;--outFile&lt;/code&gt; argument with special file system entities like named pipes, devices, etc.</source>
          <target state="translated">TypeScript 1.8では、名前付きパイプやデバイスなどの特別なファイルシステムエンティティで &lt;code&gt;--outFile&lt;/code&gt; 引数を使用できます。</target>
        </trans-unit>
        <trans-unit id="c4f9c3f076e54a2df1c744ed292a1d25e9395f14" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 extends &lt;a href=&quot;typescript-1.6#user-defined-type-guard-functions&quot;&gt;user-defined type guard functions&lt;/a&gt; to class and interface methods.</source>
          <target state="translated">TypeScript 1.8は、&lt;a href=&quot;typescript-1.6#user-defined-type-guard-functions&quot;&gt;ユーザー定義のタイプガード関数&lt;/a&gt;をクラスおよびインターフェースメソッドに拡張します。</target>
        </trans-unit>
        <trans-unit id="c547a86975df477d786c26c38684de89346ada33" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 improves type inference involving source and target sides that are both union or intersection types. For example, when inferring from &lt;code&gt;string | string[]&lt;/code&gt; to &lt;code&gt;string | T&lt;/code&gt;, we reduce the types to &lt;code&gt;string[]&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt;, thus inferring &lt;code&gt;string[]&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.8は、和集合または交差型であるソース側とターゲット側を含む型推論を改善します。たとえば、 &lt;code&gt;string | string[]&lt;/code&gt; から推測する場合| string []から &lt;code&gt;string | T&lt;/code&gt; は、我々はに種類を減らす &lt;code&gt;string[]&lt;/code&gt; および &lt;code&gt;T&lt;/code&gt; ので推測、 &lt;code&gt;string[]&lt;/code&gt; のために &lt;code&gt;T&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="8f21f8b70d4093a0a0b9a977e3f5e108e10ca93f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 introduces control flow analysis to help catch common errors that users tend to run into. Read on to get more details, and check out these errors in action:</source>
          <target state="translated">TypeScript 1.8 では、ユーザーが遭遇しがちな一般的なエラーを検出するためのコントロールフロー解析が導入されました。詳細はこちらを読んで、これらのエラーを実際に確認してください。</target>
        </trans-unit>
        <trans-unit id="316c73dc14076f7eaec6a1b058acbdbcd6b03a9b" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0</source>
          <target state="translated">タイプスクリプト2.0</target>
        </trans-unit>
        <trans-unit id="7ed2b43586705d3525a6d00f06348de23a60d9e8" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 adds a new &lt;code&gt;--skipLibCheck&lt;/code&gt; compiler option that causes type checking of declaration files (files with extension &lt;code&gt;.d.ts&lt;/code&gt;) to be skipped. When a program includes large declaration files, the compiler spends a lot of time type checking declarations that are already known to not contain errors, and compile times may be significantly shortened by skipping declaration file type checks.</source>
          <target state="translated">TypeScript 2.0には、宣言ファイル（拡張子が &lt;code&gt;.d.ts&lt;/code&gt; のファイル）の型チェックをスキップする新しい &lt;code&gt;--skipLibCheck&lt;/code&gt; コンパイラオプションが追加されています。プログラムに大きな宣言ファイルが含まれている場合、コンパイラーは多くの時間を費やして、すでにエラーが含まれていないことがわかっている宣言の型検査を行い、宣言ファイルの型検査をスキップすることでコンパイル時間を大幅に短縮できます。</target>
        </trans-unit>
        <trans-unit id="5a7e5d59bd5cadb1929863b64869919254d9fa38" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 has two new flags to help you maintain a clean code base. &lt;code&gt;--noUnusedParameters&lt;/code&gt; flags any unused function or method parameters errors. &lt;code&gt;--noUnusedLocals&lt;/code&gt; flags any unused local (un-exported) declaration like variables, functions, classes, imports, etc&amp;hellip; Also, unused private members of a class would be flagged as errors under &lt;code&gt;--noUnusedLocals&lt;/code&gt;.</source>
          <target state="translated">TypeScript 2.0には、クリーンなコードベースを維持するのに役立つ2つの新しいフラグがあります。 &lt;code&gt;--noUnusedParameters&lt;/code&gt; は、未使用の関数またはメソッドパラメータのエラーにフラグを立てます。 &lt;code&gt;--noUnusedLocals&lt;/code&gt; は、変数、関数、クラス、インポートなどの未使用のローカル（エクスポートされていない）宣言にフラグを付けます。また、クラスの未使用のプライベートメンバーには、 &lt;code&gt;--noUnusedLocals&lt;/code&gt; でエラーのフラグが付けられます。</target>
        </trans-unit>
        <trans-unit id="cc8a687464d96e2157a2c30deb24a3363ed46e0d" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 implements a control flow-based type analysis for local variables and parameters. Previously, the type analysis performed for type guards was limited to &lt;code&gt;if&lt;/code&gt; statements and &lt;code&gt;?:&lt;/code&gt; conditional expressions and didn&amp;rsquo;t include effects of assignments and control flow constructs such as &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;break&lt;/code&gt; statements. With TypeScript 2.0, the type checker analyses all possible flows of control in statements and expressions to produce the most specific type possible (the &lt;em&gt;narrowed type&lt;/em&gt;) at any given location for a local variable or parameter that is declared to have a union type.</source>
          <target state="translated">TypeScript 2.0は、ローカル変数およびパラメーターの制御フローベースの型分析を実装します。以前は、タイプガードに対して実行されるタイプ分析は、 &lt;code&gt;if&lt;/code&gt; ステートメントと &lt;code&gt;?:&lt;/code&gt; 条件式に限定され、割り当ての影響や、 &lt;code&gt;return&lt;/code&gt; ステートメントや &lt;code&gt;break&lt;/code&gt; ステートメントなどの制御フロー構造は含まれていませんでした。 TypeScript 2.0では、型チェッカーがステートメントと式で考えられるすべての制御フローを分析し、union型を持つと宣言されているローカル変数またはパラメーターの任意の場所で、最も具体的な型（&lt;em&gt;ナロー型&lt;/em&gt;）を生成します。</target>
        </trans-unit>
        <trans-unit id="b991a7d51345ee804bcdb5d52051777fdcb20357" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 implements support for tagged (or discriminated) union types. Specifically, the TS compiler now support type guards that narrow union types based on tests of a discriminant property and furthermore extend that capability to &lt;code&gt;switch&lt;/code&gt; statements.</source>
          <target state="translated">TypeScript 2.0は、タグ付き（または識別された）共用体型のサポートを実装しています。具体的には、TSコンパイラは、判別特性のテストに基づいて共用体型を絞り込み、さらにその機能を拡張してステートメントを &lt;code&gt;switch&lt;/code&gt; タイプガードをサポートするようになりました。</target>
        </trans-unit>
        <trans-unit id="f541e32a97ad0b756a4e358c4745c3b45d62017f" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 introduces a new primitive type &lt;code&gt;never&lt;/code&gt;. The &lt;code&gt;never&lt;/code&gt; type represents the type of values that never occur. Specifically, &lt;code&gt;never&lt;/code&gt; is the return type for functions that never return and &lt;code&gt;never&lt;/code&gt; is the type of variables under type guards that are never true.</source>
          <target state="translated">TypeScript 2.0では、新しいプリミティブ型 &lt;code&gt;never&lt;/code&gt; 導入されていません。 &lt;code&gt;never&lt;/code&gt; 種類は発生しない値の種類を表します。具体的には、 &lt;code&gt;never&lt;/code&gt; 戻らない関数の戻り値の型ではありませんし、 &lt;code&gt;never&lt;/code&gt; 本当のことはありません型のガード下の変数のタイプです。</target>
        </trans-unit>
        <trans-unit id="c6947ff29cc72002ee0d4fa4f9ecea90ea690c25" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 provides a set of additional module resolution knops to &lt;em&gt;inform&lt;/em&gt; the compiler where to find declarations for a given module.</source>
          <target state="translated">TypeScript 2.0は、特定のモジュールの宣言を見つける場所をコンパイラーに&lt;em&gt;通知&lt;/em&gt;するための追加のモジュール解決ノブのセットを提供します。</target>
        </trans-unit>
        <trans-unit id="3f3705d152a2f1f40c51f05e54dd28f6cc6cc047" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 relaxes this constraint and allows duplicate identifiers across blocks, as long as they have &lt;em&gt;identical&lt;/em&gt; types.</source>
          <target state="translated">TypeScript 2.0では、この制約が緩和され、&lt;em&gt;同一の&lt;/em&gt;タイプである限り、ブロック間で重複した識別子が許可されます。</target>
        </trans-unit>
        <trans-unit id="1a29a22cd01cb9654bf025f544accb002ba6f777" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 supports the use of the wildcard character (&lt;code&gt;*&lt;/code&gt;) to declare a &amp;ldquo;family&amp;rdquo; of module names; this way, a declaration is only required once for an extension, and not for every resource.</source>
          <target state="translated">TypeScript 2.0は、モジュール名の「ファミリ」を宣言するためのワイルドカード文字（ &lt;code&gt;*&lt;/code&gt; ）の使用をサポートしています。このように、宣言はすべてのリソースに対してではなく、拡張に対して一度だけ必要です。</target>
        </trans-unit>
        <trans-unit id="e87039bc208381c858aaf91b34ef9a99581764c4" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1</source>
          <target state="translated">TypeScript 2.1</target>
        </trans-unit>
        <trans-unit id="0eb31cb3569ffcba88f7cd6f2aa1426af6d2ca9f" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1 allows for including these files in your project once in a separate module, and the compiler will emit imports to them as needed.</source>
          <target state="translated">TypeScript 2.1 では、これらのファイルをプロジェクト内の別のモジュールに一度だけ含めることができ、コンパイラは必要に応じてこれらのファイルのインポートを行います。</target>
        </trans-unit>
        <trans-unit id="4d20c0e4270450dc5df5d6df69b86f9a3084c753" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1 brings support for &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;ESnext Spread and Rest&lt;/a&gt;.</source>
          <target state="translated">TypeScript 2.1では、&lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;ESnext Spread and Rest&lt;/a&gt;がサポートされています。</target>
        </trans-unit>
        <trans-unit id="1a2602f6bc15b060152681aebb2deae22d1b7344" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1 supports inheriting configuration using &lt;code&gt;extends&lt;/code&gt;, where:</source>
          <target state="translated">TypeScript 2.1は &lt;code&gt;extends&lt;/code&gt; を使用した構成の継承をサポートしています。</target>
        </trans-unit>
        <trans-unit id="e46023b88cb014edcb72d5fe91dd5e9bb7df4962" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1 supports three new target values &lt;code&gt;--target ES2016&lt;/code&gt;, &lt;code&gt;--target ES2017&lt;/code&gt; and &lt;code&gt;--target ESNext&lt;/code&gt;.</source>
          <target state="translated">TypeScript 2.1は、3つの新しいターゲット値 &lt;code&gt;--target ES2016&lt;/code&gt; 、 &lt;code&gt;--target ES2017&lt;/code&gt; 、および &lt;code&gt;--target ESNext&lt;/code&gt; をサポートしています。</target>
        </trans-unit>
        <trans-unit id="9b933ffe70d107fc6bfc7a208af67d2175dec62d" translate="yes" xml:space="preserve">
          <source>TypeScript 2.2</source>
          <target state="translated">TypeScript 2.2</target>
        </trans-unit>
        <trans-unit id="af11383d0a489a01508b14d16cfebecdac9851f5" translate="yes" xml:space="preserve">
          <source>TypeScript 2.2 adds support for the ECMAScript 2015 mixin class pattern (see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Mix-ins&quot;&gt;MDN Mixin description&lt;/a&gt; and &lt;a href=&quot;http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/&quot;&gt;&amp;ldquo;Real&amp;rdquo; Mixins with JavaScript Classes&lt;/a&gt; for more details) as well as rules for combining mixin construct signatures with regular construct signatures in intersection types.</source>
          <target state="translated">TypeScript 2.2では、ECMAScript 2015のミックスインクラスパターン（詳細については、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Mix-ins&quot;&gt;MDN &lt;/a&gt;&lt;a href=&quot;http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/&quot;&gt;ミックスインの&lt;/a&gt;説明と「実際の」ミックスインとJavaScriptクラスを参照）、および交差タイプのミックスインコンストラクトシグネチャと通常のコンストラクトシグネチャを組み合わせるルールのサポートが追加されています。</target>
        </trans-unit>
        <trans-unit id="0a2dbbdfdaba8d57c906119c6fac6d8266bfac36" translate="yes" xml:space="preserve">
          <source>TypeScript 2.2 adds support for using spread on a JSX element children. Please see &lt;a href=&quot;https://github.com/facebook/jsx/issues/57&quot;&gt;facebook/jsx#57&lt;/a&gt; for more details.</source>
          <target state="translated">TypeScript 2.2では、JSX要素の子でSpreadを使用するためのサポートが追加されています。詳細については、&lt;a href=&quot;https://github.com/facebook/jsx/issues/57&quot;&gt;facebook / jsx＃57&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4c48aa745cc516094ac80f0eaa3816fe06bddfbf" translate="yes" xml:space="preserve">
          <source>TypeScript 2.2 improves checking of nullable operands in expressions. Specifically, these are now flagged as errors:</source>
          <target state="translated">TypeScript 2.2 では、式中のヌル可能なオペランドのチェックが改善されました。具体的には、これらはエラーとしてフラグが立てられるようになりました。</target>
        </trans-unit>
        <trans-unit id="d38d07af3e985997222428fd513a69781f6cc8f7" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3</source>
          <target state="translated">TypeScript 2.3</target>
        </trans-unit>
        <trans-unit id="b61f4d2dcbfa7df846edf73961314986771cb44f" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3 adds full support for generators and the Iterator protocol for ES3 and ES5 targets with &lt;code&gt;--downlevelIteration&lt;/code&gt; flag.</source>
          <target state="translated">TypeScript 2.3では、 &lt;code&gt;--downlevelIteration&lt;/code&gt; フラグを使用して、ジェネレーターとES3およびES5ターゲットのイテレータープロトコルの完全なサポートが追加されています。</target>
        </trans-unit>
        <trans-unit id="c7db822200563cfa58805541c7f52f40509bd7eb" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3 adds support for declaring defaults for generic type parameters.</source>
          <target state="translated">TypeScript 2.3 では、一般的な型パラメータのデフォルト宣言のサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="576c3abf51df0a1e8501d6946731fd5b93e9a596" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3 adds support for the async iterators and generators as described by the current &lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;TC39 proposal&lt;/a&gt;.</source>
          <target state="translated">TypeScript 2.3では、現在の&lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;TC39提案で&lt;/a&gt;説明されているように、非同期イテレータとジェネレータのサポートが追加されています。</target>
        </trans-unit>
        <trans-unit id="f9905a786ea9066024ac4028d0fd104e321fa970" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3 and later support type-checking and reporting errors in &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--checkJs&lt;/code&gt;.</source>
          <target state="translated">TypeScript 2.3以降では、-- &lt;code&gt;--checkJs&lt;/code&gt; 使用して &lt;code&gt;.js&lt;/code&gt; ファイルのタイプチェックとエラー報告をサポートしています。</target>
        </trans-unit>
        <trans-unit id="a711e374d74b34d98e80b0011ffc309914ec3f56" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4</source>
          <target state="translated">TypeScript 2.4</target>
        </trans-unit>
        <trans-unit id="63121e1a86e22e0c3bb62dbea7a515bd9e567278" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4 introduces a few wonderful changes around the way generics are inferred.</source>
          <target state="translated">TypeScript 2.4では、ジェネリックの推論方法にいくつかの素晴らしい変更が加えられています。</target>
        </trans-unit>
        <trans-unit id="4047de971a7748310180f70bca2f83ce413444e5" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4 introduces the concept of &amp;ldquo;weak types&amp;rdquo;. Any type that contains nothing but a set of all-optional properties is considered to be &lt;em&gt;weak&lt;/em&gt;. For example, this &lt;code&gt;Options&lt;/code&gt; type is a weak type:</source>
          <target state="translated">TypeScript 2.4では、「弱い型」の概念が導入されています。すべてオプションのプロパティのセットしか含まれていないタイプは、&lt;em&gt;弱い&lt;/em&gt;と見なされます。たとえば、この &lt;code&gt;Options&lt;/code&gt; タイプは弱いタイプです。</target>
        </trans-unit>
        <trans-unit id="86b2369322c0e2cb12bd30f7af1523fb15f271df" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4 introduces tightens this up when relating two callback types. For example:</source>
          <target state="translated">TypeScript 2.4では、2つのコールバックタイプを関連付ける際にこれを強化しています。例えば</target>
        </trans-unit>
        <trans-unit id="76b70868a8ecce2623fa642627ea2865c40679ae" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4 now allows enum members to contain string initializers.</source>
          <target state="translated">TypeScript 2.4では、enumメンバに文字列イニシャライザを含めることができるようになりました。</target>
        </trans-unit>
        <trans-unit id="c757b8632386bce7302d5253a3fe5a403ad48f5b" translate="yes" xml:space="preserve">
          <source>TypeScript 2.5</source>
          <target state="translated">タイプスクリプト2.5</target>
        </trans-unit>
        <trans-unit id="96d62a44f6ecea4f2d8ccb3d978b4697f85a8fe0" translate="yes" xml:space="preserve">
          <source>TypeScript 2.5 brings the &lt;code&gt;preserveSymlinks&lt;/code&gt; flag, which parallels the behavior of &lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;the &lt;code&gt;--preserve-symlinks&lt;/code&gt; flag in Node.js&lt;/a&gt;. This flag also exhibits the opposite behavior to Webpack&amp;rsquo;s &lt;code&gt;resolve.symlinks&lt;/code&gt; option (i.e. setting TypeScript&amp;rsquo;s &lt;code&gt;preserveSymlinks&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; parallels setting Webpack&amp;rsquo;s &lt;code&gt;resolve.symlinks&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, and vice-versa).</source>
          <target state="translated">活字体2.5をもたらす &lt;code&gt;preserveSymlinks&lt;/code&gt; 用の挙動平行フラグ、&lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt; &lt;code&gt;--preserve-symlinks&lt;/code&gt; &lt;/a&gt;のNode.jsでフラグ。このフラグは、Webpackの &lt;code&gt;resolve.symlinks&lt;/code&gt; オプションとは逆の動作も示します（つまり、TypeScriptの &lt;code&gt;preserveSymlinks&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定し、Webpackの &lt;code&gt;resolve.symlinks&lt;/code&gt; を &lt;code&gt;false&lt;/code&gt; に設定します（逆も同様））。</target>
        </trans-unit>
        <trans-unit id="c8ad58c085604fcd7c2e1f3468a3e3e991a926ce" translate="yes" xml:space="preserve">
          <source>TypeScript 2.5 introduces the ability to &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/5158&quot;&gt;assert the type of expressions when using plain JavaScript in your projects&lt;/a&gt;. The syntax is an &lt;code&gt;/** @type {...} */&lt;/code&gt; annotation comment followed by a parenthesized expression whose type needs to be re-evaluated. For example:</source>
          <target state="translated">TypeScript 2.5では、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/5158&quot;&gt;プロジェクトでプレーンJavaScriptを使用するときに式のタイプ&lt;/a&gt;をアサートする機能が導入されています。構文は、 &lt;code&gt;/** @type {...} */&lt;/code&gt; 注釈コメントの後に、型を再評価する必要がある括弧で囲まれた式が続きます。例えば：</target>
        </trans-unit>
        <trans-unit id="669d038e7cc1925c80d686495e192a922f14d7e5" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6</source>
          <target state="translated">TypeScript 2.6</target>
        </trans-unit>
        <trans-unit id="f05ad28a2eccdd4292c999695e9643dff88f04a9" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 adds revised implementation the &lt;code&gt;--noUnusedLocals&lt;/code&gt; and &lt;code&gt;--noUnusedParameters&lt;/code&gt;&lt;a href=&quot;../compiler-options&quot;&gt;compiler options&lt;/a&gt;. Declarations are only written to but never read from are now flagged as unused.</source>
          <target state="translated">TypeScript 2.6では、改訂された実装である &lt;code&gt;--noUnusedLocals&lt;/code&gt; および &lt;code&gt;--noUnusedParameters&lt;/code&gt; &lt;a href=&quot;../compiler-options&quot;&gt;コンパイラオプションが&lt;/a&gt;追加されています。宣言は書き込まれるだけで読み取りは行われず、未使用のフラグが付けられます。</target>
        </trans-unit>
        <trans-unit id="b3d5a37c18c460f27ef01973c59f69c2b7e4b6db" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 also improves type inference involving contravariant positions:</source>
          <target state="translated">TypeScript 2.6では、対照的な位置を含む型推論も改善されています。</target>
        </trans-unit>
        <trans-unit id="597afbba7d51bc72adeb8bdd4361ee8ee1244087" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 brings a faster &lt;code&gt;--watch&lt;/code&gt; implementation. The new version optimizes code generation and checking for code bases using ES modules. Changes detected in a module file will result in &lt;em&gt;only&lt;/em&gt; regenerating the changed module, and files that depend on it, instead of the whole project. Projects with large number of files should reap the most benefit from this change.</source>
          <target state="translated">TypeScript 2.6は &lt;code&gt;--watch&lt;/code&gt; の実装を高速化します。新しいバージョンでは、ESモジュールを使用してコード生成とコードベースのチェックを最適化します。モジュールファイルで検出された変更は、プロジェクト全体ではなく、変更されたモジュールとそれに依存するファイル&lt;em&gt;のみを&lt;/em&gt;再生成します。多数のファイルを含むプロジェクトは、この変更から最も恩恵を受けるはずです。</target>
        </trans-unit>
        <trans-unit id="bff2120308b7a70612c6347b0884825c125b9bb6" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 fixes the tagged string template emit to align better with the ECMAScript spec. As per the &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-gettemplateobject&quot;&gt;ECMAScript spec&lt;/a&gt;, every time a template tag is evaluated, the &lt;em&gt;same&lt;/em&gt; template strings object (the same &lt;code&gt;TemplateStringsArray&lt;/code&gt;) should be passed as the first argument. Before TypeScript 2.6, the generated output was a completely new template object each time. Though the string contents are the same, this emit affects libraries that use the identity of the string for cache invalidation purposes, e.g. &lt;a href=&quot;https://github.com/PolymerLabs/lit-html/issues/58&quot;&gt;lit-html&lt;/a&gt;.</source>
          <target state="translated">TypeScript 2.6は、タグ付き文字列テンプレートの放出を修正して、ECMAScript仕様とよりよく整合します。&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-gettemplateobject&quot;&gt;ECMAScript仕様&lt;/a&gt;に従って、テンプレートタグが評価されるたびに、&lt;em&gt;同じ&lt;/em&gt;テンプレート文字列オブジェクト（同じ &lt;code&gt;TemplateStringsArray&lt;/code&gt; ）が最初の引数として渡される必要があります。 TypeScript 2.6より前は、生成された出力は毎回完全に新しいテンプレートオブジェクトでした。文字列の内容は同じですが、この出力は、キャッシュの無効化のために文字列のIDを使用するライブラリに影響します（例：&lt;a href=&quot;https://github.com/PolymerLabs/lit-html/issues/58&quot;&gt;lit-html）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3332e1f0228da76e93e5e699b31c42f80f487ec2" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 introduces a new strict checking flag, &lt;code&gt;--strictFunctionTypes&lt;/code&gt;. The &lt;code&gt;--strictFunctionTypes&lt;/code&gt; switch is part of the &lt;code&gt;--strict&lt;/code&gt; family of switches, meaning that it defaults to on in &lt;code&gt;--strict&lt;/code&gt; mode. You can opt-out by setting &lt;code&gt;--strictFunctionTypes false&lt;/code&gt; on your command line or in your tsconfig.json.</source>
          <target state="translated">TypeScript 2.6では、新しい厳密なチェックフラグ &lt;code&gt;--strictFunctionTypes&lt;/code&gt; が導入されています。 &lt;code&gt;--strictFunctionTypes&lt;/code&gt; スイッチはの一部である &lt;code&gt;--strict&lt;/code&gt; ONにそれがデフォルトであることを意味し、スイッチの家族 &lt;code&gt;--strict&lt;/code&gt; モード。コマンドラインまたはtsconfig.jsonで &lt;code&gt;--strictFunctionTypes false&lt;/code&gt; に設定することでオプトアウトできます。</target>
        </trans-unit>
        <trans-unit id="50b83579cf141ddf3a24a6600e359e207807258a" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 npm package ships with localized versions of diagnostic messages for 13 languages. The localized messages are available when using &lt;code&gt;--locale&lt;/code&gt; flag on the command line.</source>
          <target state="translated">TypeScript 2.6 npmパッケージには、13言語のローカライズバージョンの診断メッセージが付属しています。コマンドラインで &lt;code&gt;--locale&lt;/code&gt; フラグを使用すると、ローカライズされたメッセージを利用できます。</target>
        </trans-unit>
        <trans-unit id="71107e6f11d3d9498db10524c3f3c164f19e9415" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 support suppressing errors in .js files using &lt;code&gt;// @ts-ignore&lt;/code&gt; comments placed above the offending lines.</source>
          <target state="translated">TypeScript 2.6 は、問題の行の上に配置された &lt;code&gt;// @ts-ignore&lt;/code&gt; コメントを使用した.jsファイルのエラーの抑制をサポートしています。</target>
        </trans-unit>
        <trans-unit id="bef45e6468d0c0a17f09c30d2b82dd8a05124a51" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7</source>
          <target state="translated">TypeScript 2.7</target>
        </trans-unit>
        <trans-unit id="79e7e447b60909166288dcf8cb72e27e89f7cec5" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 adds support for declaring const-named properties on types including ECMAScript symbols.</source>
          <target state="translated">TypeScript 2.7 では、ECMAScript シンボルを含む型に対して const-named プロパティを宣言できるようになりました。</target>
        </trans-unit>
        <trans-unit id="a51783c99c59b3257833940324affc2689b71a24" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 also introduced &lt;code&gt;--watch&lt;/code&gt; mode builds via a new incremental &amp;ldquo;builder&amp;rdquo; API. In a similar vein, the entire idea is that this mode only re-checks and re-emits changed files or files whose dependencies might impact type-checking. You can think of this as optimizing &lt;em&gt;intra&lt;/em&gt;-project builds.</source>
          <target state="translated">TypeScript 2.7では、新しいインクリメンタル「ビルダー」APIを介して &lt;code&gt;--watch&lt;/code&gt; モードビルドも導入されました。同様に、このモード全体では、変更されたファイルまたは依存関係がタイプチェックに影響を与える可能性のあるファイルのみを再チェックして再出力するという考え方です。これは、プロジェクト&lt;em&gt;内&lt;/em&gt;ビルドの最適化と考えることができます。</target>
        </trans-unit>
        <trans-unit id="162b6515dd83712cce22c0f4cc8d254c9b33661b" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 brings support for &lt;a href=&quot;https://github.com/tc39/proposal-numeric-separator&quot;&gt;ES Numeric Separators&lt;/a&gt;. Numeric literals can now be separated into segments using &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">TypeScript 2.7は、&lt;a href=&quot;https://github.com/tc39/proposal-numeric-separator&quot;&gt;ES Numeric Separators&lt;/a&gt;をサポートします。数値リテラルは、 &lt;code&gt;_&lt;/code&gt; を使用してセグメントに分離できるようになりました。</target>
        </trans-unit>
        <trans-unit id="af59c15c50945a988e8dab909a898e4259657c00" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 improves the handling of structurally identical classes in union types and &lt;code&gt;instanceof&lt;/code&gt; expressions:</source>
          <target state="translated">TypeScript 2.7は、共用体型および &lt;code&gt;instanceof&lt;/code&gt; 式における構造的に同一のクラスの処理を改善します。</target>
        </trans-unit>
        <trans-unit id="91f038aff687710c549846983751034fac966226" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 improves type inference for multiple object literals occurring in the same context. When multiple object literal types contribute to a union type, we now &lt;em&gt;normalize&lt;/em&gt; the object literal types such that all properties are present in each constituent of the union type.</source>
          <target state="translated">TypeScript 2.7は、同じコンテキストで発生する複数のオブジェクトリテラルの型推論を改善します。複数のオブジェクトリテラルタイプがユニオンタイプに寄与する場合、すべてのプロパティがユニオンタイプの各構成要素に存在するように、オブジェクトリテラルタイプを&lt;em&gt;正規化&lt;/em&gt;します。</target>
        </trans-unit>
        <trans-unit id="6ab94d5588595f01a47bea04f5db381bcbb5dba9" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 introduces a new flag called &lt;code&gt;--strictPropertyInitialization&lt;/code&gt;. This flag performs checks to ensure that each instance property of a class gets initialized in the constructor body, or by a property initializer. For example</source>
          <target state="translated">TypeScript 2.7では、-- &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; と呼ばれる新しいフラグが導入されています。このフラグは、クラスの各インスタンスプロパティがコンストラクター本体で、またはプロパティ初期化子によって初期化されていることを確認するためのチェックを実行します。例えば</target>
        </trans-unit>
        <trans-unit id="50a1f4f6bc66299bafe27e7f60a3413972205937" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 updates CommonJS/AMD/UMD module emit to synthesize namespace records based on the presence of an &lt;code&gt;__esModule&lt;/code&gt; indicator under &lt;code&gt;--esModuleInterop&lt;/code&gt;. The change brings the generated output from TypeScript closer to that generated by Babel.</source>
          <target state="translated">TypeScript 2.7は、CommonJS / AMD / UMDモジュールの出力を更新して、-- &lt;code&gt;__esModule&lt;/code&gt; 下の &lt;code&gt;--esModuleInterop&lt;/code&gt; インジケーターの存在に基づいて名前空間レコードを合成します。この変更により、TypeScriptから生成された出力がBabelによって生成された出力に近づきます。</target>
        </trans-unit>
        <trans-unit id="4e42d10f15cd2510b82037d64e9dbecd5c11e732" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8</source>
          <target state="translated">TypeScript 2.8</target>
        </trans-unit>
        <trans-unit id="3b84208a266962375c246ada5aa0bd123c9cfe9e" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 adds several predefined conditional types to &lt;code&gt;lib.d.ts&lt;/code&gt;:</source>
          <target state="translated">TypeScript 2.8は、いくつかの事前定義された条件型を &lt;code&gt;lib.d.ts&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="c5e0ed8e368b2f12d192ed317481ad4102d428b8" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 adds support for a per-file configurable JSX factory name using &lt;code&gt;@jsx dom&lt;/code&gt; pragma. JSX factory can be configured for a compilation using &lt;code&gt;--jsxFactory&lt;/code&gt; (default is &lt;code&gt;React.createElement&lt;/code&gt;). With TypeScript 2.8 you can override this on a per-file-basis by adding a comment to the beginning of the file.</source>
          <target state="translated">TypeScript 2.8では、 &lt;code&gt;@jsx dom&lt;/code&gt; プラグマを使用して、ファイルごとに構成可能なJSXファクトリ名のサポートが追加されています。JSXファクトリは、 &lt;code&gt;--jsxFactory&lt;/code&gt; を使用してコンパイルするように構成できます（デフォルトは &lt;code&gt;React.createElement&lt;/code&gt; です）。TypeScript 2.8では、ファイルの先頭にコメントを追加することにより、ファイルごとにこれをオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="4f6ad1955b40525b81ee6b350e3efda1dca7803e" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 adds support for understanding more namespace patterns in &lt;code&gt;.js&lt;/code&gt; files. Empty object literals declarations on top level, just like functions and classes, are now recognized as as namespace declarations in JavaScript.</source>
          <target state="translated">TypeScript 2.8は、 &lt;code&gt;.js&lt;/code&gt; ファイルのより多くの名前空間パターンを理解するためのサポートを追加します。トップレベルの空のオブジェクトリテラル宣言は、関数やクラスと同様に、JavaScriptでは名前空間宣言として認識されるようになりました。</target>
        </trans-unit>
        <trans-unit id="f9e15ad123318d14a1567d61a8eb9b88ec3f14c9" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 adds the ability for a mapped type to either add or remove a particular modifier. Specifically, a &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; property modifier in a mapped type can now be prefixed with either &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; to indicate that the modifier should be added or removed.</source>
          <target state="translated">TypeScript 2.8は、マップされた型が特定の修飾子を追加または削除する機能を追加します。具体的には、 &lt;code&gt;readonly&lt;/code&gt; または &lt;code&gt;?&lt;/code&gt; マップされたタイプのプロパティ修飾子の前に &lt;code&gt;+&lt;/code&gt; または &lt;code&gt;-&lt;/code&gt; を付けて、修飾子を追加または削除する必要があることを示すことができます。</target>
        </trans-unit>
        <trans-unit id="ccbc7d666b3ba41052f2f21dcaf1e812e9bac36a" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 introduces &lt;em&gt;conditional types&lt;/em&gt; which add the ability to express non-uniform type mappings. A conditional type selects one of two possible types based on a condition expressed as a type relationship test:</source>
          <target state="translated">TypeScript 2.8では、非均一型マッピングを表現する機能を追加する&lt;em&gt;条件型&lt;/em&gt;が導入されてい&lt;em&gt;ます&lt;/em&gt;。条件付きタイプは、タイプ関係テストとして表現された条件に基づいて、2つの可能なタイプの1つを選択します。</target>
        </trans-unit>
        <trans-unit id="38d22337c31f40538f05a1b3be32d35d5d040ad3" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9</source>
          <target state="translated">TypeScript 2.9</target>
        </trans-unit>
        <trans-unit id="79a8a3cdfaf2e7ea5b694163b786814a57e8ccbe" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9 adds support for &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named properties in index types and mapped types. Previously, the &lt;code&gt;keyof&lt;/code&gt; operator and mapped types only supported &lt;code&gt;string&lt;/code&gt; named properties.</source>
          <target state="translated">TypeScript 2.9は、インデックスタイプとマップされたタイプの &lt;code&gt;number&lt;/code&gt; と &lt;code&gt;symbol&lt;/code&gt; 名前付きプロパティのサポートを追加します。以前は、 &lt;code&gt;keyof&lt;/code&gt; 演算子とマップされたタイプは、プロパティという名前の &lt;code&gt;string&lt;/code&gt; のみをサポートしていました。</target>
        </trans-unit>
        <trans-unit id="f3af31e687b53bc6028a7656648578f8526d1535" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9 allows passing generic type arguments to tagged template strings.</source>
          <target state="translated">TypeScript 2.9 では、一般的な型引数をタグ付きテンプレート文字列に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="c576ebab33996a3a7642529b1b3cf098557fad0c" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9 and earlier didn&amp;rsquo;t leverage &lt;a href=&quot;https://reactjs.org/docs/typechecking-with-proptypes.html#default-prop-values&quot;&gt;React &lt;code&gt;defaultProps&lt;/code&gt;&lt;/a&gt; declarations inside JSX components. Users would often have to declare properties optional and use non-null assertions inside of &lt;code&gt;render&lt;/code&gt;, or they&amp;rsquo;d use type-assertions to fix up the type of the component before exporting it.</source>
          <target state="translated">TypeScript 2.9以前では、JSXコンポーネント内の&lt;a href=&quot;https://reactjs.org/docs/typechecking-with-proptypes.html#default-prop-values&quot;&gt;React &lt;code&gt;defaultProps&lt;/code&gt; &lt;/a&gt;宣言を利用していませんでした。多くの場合、ユーザーはプロパティをオプションとして宣言し、 &lt;code&gt;render&lt;/code&gt; 内でnull以外のアサーションを使用する必要があります。または、エクスポートする前にタイプアサーションを使用してコンポーネントのタイプを修正します。</target>
        </trans-unit>
        <trans-unit id="54d0224b3f561c10aa0b8f9cc4af3cf6fc0acd70" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9 introduces support for &lt;code&gt;import.meta&lt;/code&gt;, a new meta-property as described by the current &lt;a href=&quot;https://github.com/tc39/proposal-import-meta&quot;&gt;TC39 proposal&lt;/a&gt;.</source>
          <target state="translated">TypeScript 2.9では、現在の&lt;a href=&quot;https://github.com/tc39/proposal-import-meta&quot;&gt;TC39提案で&lt;/a&gt;説明されている新しいメタプロパティである &lt;code&gt;import.meta&lt;/code&gt; のサポートが導入されています。</target>
        </trans-unit>
        <trans-unit id="ff47669d6e3d77ab534a2150af62bcea4228ce7e" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0</source>
          <target state="translated">タイプスクリプト3.0</target>
        </trans-unit>
        <trans-unit id="1b5495b8f8bb8ada5fe9aabb083f17ca19955412" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 adds support for a new type alias in the &lt;code&gt;JSX&lt;/code&gt; namespace called &lt;code&gt;LibraryManagedAttributes&lt;/code&gt;. This helper type defines a transformation on the component&amp;rsquo;s &lt;code&gt;Props&lt;/code&gt; type, before using to check a JSX expression targeting it; thus allowing customization like: how conflicts between provided props and inferred props are handled, how inferences are mapped, how optionality is handled, and how inferences from differing places should be combined.</source>
          <target state="translated">TypeScript 3.0では、 &lt;code&gt;JSX&lt;/code&gt; 名前空間に &lt;code&gt;LibraryManagedAttributes&lt;/code&gt; と呼ばれる新しい型エイリアスのサポートが追加されています。このヘルパータイプは、コンポーネントを使用するJSX式のチェックに使用する前に、コンポーネントの &lt;code&gt;Props&lt;/code&gt; タイプの変換を定義します。したがって、次のようなカスタマイズが可能になります。提供された小道具と推論された小道具間の競合の処理方法、推論のマッピング方法、オプション性の処理方法、異なる場所からの推論の組み合わせ方法。</target>
        </trans-unit>
        <trans-unit id="898331749799c0ae0af6a27a2c4a2bf1b9107b53" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 adds support to multiple new capabilities to interact with function parameter lists as tuple types. TypeScript 3.0 adds support for:</source>
          <target state="translated">TypeScript 3.0 では、関数のパラメータリストをタプル型として扱うための複数の新機能がサポートされています。TypeScript 3.0 では、以下の機能がサポートされています。</target>
        </trans-unit>
        <trans-unit id="24d0fe89da15fd3c400693e525d5250f550dd57a" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 also introduces a new mode for tsc, the &lt;code&gt;--build&lt;/code&gt; flag, that works hand-in-hand with project references to enable faster TypeScript builds.</source>
          <target state="translated">TypeScript 3.0では、tscの新しいモードである &lt;code&gt;--build&lt;/code&gt; フラグも導入されています。これは、プロジェクト参照と連携して、より高速なTypeScriptビルドを可能にします。</target>
        </trans-unit>
        <trans-unit id="76ebacc06303039a717759a1bc81f839c55d819c" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 introduced a new feature for structuring builds called &amp;ldquo;composite projects&amp;rdquo;. Part of the goal here was to ensure users could break up large projects into smaller parts that build quickly and preserve project structure, without compromising the existing TypeScript experience. Thanks to composite projects, TypeScript can use &lt;code&gt;--build&lt;/code&gt; mode to recompile only the set of projects and dependencies. You can think of this as optimizing &lt;em&gt;inter&lt;/em&gt;-project builds.</source>
          <target state="translated">TypeScript 3.0では、「複合プロジェクト」と呼ばれるビルドを構造化するための新機能が導入されました。ここでの目標の一部は、既存のTypeScriptエクスペリエンスを損なうことなく、ユーザーが大きなプロジェクトを小さな部分に分割して、すばやく構築してプロジェクト構造を維持できるようにすることでした。複合プロジェクトのおかげで、TypeScriptは &lt;code&gt;--build&lt;/code&gt; モードを使用して、プロジェクトと依存関係のセットのみを再コンパイルできます。これは、プロジェクト&lt;em&gt;間&lt;/em&gt;ビルドの最適化と考えることができます。</target>
        </trans-unit>
        <trans-unit id="12be550f3be8a1f6da19a996860414de543a9312" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 introduced support for referencing other and building them incrementally using the &lt;code&gt;--build&lt;/code&gt; flag. Additionally, TypeScript 3.4 introduced the &lt;code&gt;--incremental&lt;/code&gt; flag for saving information about previous compilations to only rebuild certain files. These flags were incredibly useful for structuring projects more flexibly and speeding builds up. Unfortunately, using these flags didn&amp;rsquo;t work with 3rd party build tools like Gulp and Webpack. TypeScript 3.6 now exposes two sets of APIs to operate on project references and incremental program building.</source>
          <target state="translated">TypeScript 3.0では、 &lt;code&gt;--build&lt;/code&gt; フラグを使用して他を参照し、それらを段階的に構築するためのサポートが導入されました。さらに、TypeScript 3.4では、以前のコンパイルに関する情報を保存して特定のファイルのみを再構築するための &lt;code&gt;--incremental&lt;/code&gt; フラグが導入されました。これらのフラグは、プロジェクトをより柔軟に構成し、ビルドを高速化するのに非常に役立ちました。残念ながら、これらのフラグの使用は、GulpやWebpackなどのサードパーティのビルドツールでは機能しませんでした。 TypeScript 3.6は、プロジェクト参照とインクリメンタルプログラム構築を操作するための2セットのAPIを公開しています。</target>
        </trans-unit>
        <trans-unit id="ef2e2b53b736d1c6d2b067c0b85011c12a528c2f" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 introduces a new concept of project references. Project references allow TypeScript projects to depend on other TypeScript projects - specifically, allowing &lt;code&gt;tsconfig.json&lt;/code&gt; files to reference other &lt;code&gt;tsconfig.json&lt;/code&gt; files. Specifying these dependencies makes it easier to split your code into smaller projects, since it gives TypeScript (and tools around it) a way to understand build ordering and output structure.</source>
          <target state="translated">TypeScript 3.0では、プロジェクト参照の新しい概念が導入されています。プロジェクト参照により、TypeScriptプロジェクトは他のTypeScriptプロジェクトに依存できます。具体的には、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルが他の &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを参照できるようにします。これらの依存関係を指定すると、TypeScript（およびその周辺のツール）にビルドの順序と出力構造を理解する方法が提供されるため、コードを小さなプロジェクトに分割しやすくなります。</target>
        </trans-unit>
        <trans-unit id="303ce39af16c9af3efeedd99c02704afd6f021df" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 introduces a new top type &lt;code&gt;unknown&lt;/code&gt;. &lt;code&gt;unknown&lt;/code&gt; is the type-safe counterpart of &lt;code&gt;any&lt;/code&gt;. Anything is assignable to &lt;code&gt;unknown&lt;/code&gt;, but &lt;code&gt;unknown&lt;/code&gt; isn&amp;rsquo;t assignable to anything but itself and &lt;code&gt;any&lt;/code&gt; without a type assertion or a control flow based narrowing. Likewise, no operations are permitted on an &lt;code&gt;unknown&lt;/code&gt; without first asserting or narrowing to a more specific type.</source>
          <target state="translated">TypeScript 3.0では、 &lt;code&gt;unknown&lt;/code&gt; 新しいトップタイプが導入されています。 &lt;code&gt;unknown&lt;/code&gt; は &lt;code&gt;any&lt;/code&gt; のタイプセーフな対応物です。何でもへ割り当て可能である &lt;code&gt;unknown&lt;/code&gt; 、しかし &lt;code&gt;unknown&lt;/code&gt; 何に割り当てることではなく、自分自身と &lt;code&gt;any&lt;/code&gt; 種類の表明または制御フローベースの狭小化なし。同様に、 &lt;code&gt;unknown&lt;/code&gt; ものに対する操作は、最初に特定のタイプにアサートまたはナローイングしない限り許可されません。</target>
        </trans-unit>
        <trans-unit id="7978444d69de42e59647fdd6e697c61c835aefcc" translate="yes" xml:space="preserve">
          <source>TypeScript 3.1</source>
          <target state="translated">TypeScript 3.1</target>
        </trans-unit>
        <trans-unit id="277efbe36e840571109f3bbb5578c95d9d3c2d0f" translate="yes" xml:space="preserve">
          <source>TypeScript 3.1 brings the ability to define properties on function declarations and &lt;code&gt;const&lt;/code&gt;-declared functions, simply by assigning to properties on these functions in the same scope. This allows us to write canonical JavaScript code without resorting to &lt;code&gt;namespace&lt;/code&gt; hacks. For example:</source>
          <target state="translated">TypeScript 3.1では、同じスコープ内のこれらの関数のプロパティに割り当てるだけで、関数宣言と &lt;code&gt;const&lt;/code&gt; で宣言された関数のプロパティを定義できます。これにより、 &lt;code&gt;namespace&lt;/code&gt; ハックに頼ることなく、正規のJavaScriptコードを記述できます。例えば：</target>
        </trans-unit>
        <trans-unit id="b9f00fd1052d436127e4de48e371112ca1399051" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2</source>
          <target state="translated">TypeScript 3.2</target>
        </trans-unit>
        <trans-unit id="1bd9c97a859cbb3246a80b48f6fdb33c3666de34" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2 also allows destructuring a rest binding from a generic variable. This is achieved by using the predefined &lt;code&gt;Pick&lt;/code&gt; and &lt;code&gt;Exclude&lt;/code&gt; helper types from &lt;code&gt;lib.d.ts&lt;/code&gt;, and using the generic type in question as well as the names of the other bindings in the destructuring pattern.</source>
          <target state="translated">TypeScript 3.2では、ジェネリック変数からRESTバインディングを分解することもできます。これは、 &lt;code&gt;lib.d.ts&lt;/code&gt; からの事前定義された &lt;code&gt;Pick&lt;/code&gt; および &lt;code&gt;Exclude&lt;/code&gt; ヘルパータイプを使用し、問題のジェネリックタイプおよびデストラチャパターン内の他のバインディングの名前を使用することで実現されます。</target>
        </trans-unit>
        <trans-unit id="32739636ab98224be8b965eab8472c294e08c8bd" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2 introduces a new &lt;code&gt;--strictBindCallApply&lt;/code&gt; compiler option (in the &lt;code&gt;--strict&lt;/code&gt; family of options) with which the &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; methods on function objects are strongly typed and strictly checked.</source>
          <target state="translated">TypeScript 3.2では、新しい &lt;code&gt;--strictBindCallApply&lt;/code&gt; コンパイラオプションが導入され（オプションの &lt;code&gt;--strict&lt;/code&gt; ファミリに含まれる）、関数オブジェクトの &lt;code&gt;bind&lt;/code&gt; 、 &lt;code&gt;call&lt;/code&gt; 、および &lt;code&gt;apply&lt;/code&gt; メソッドが厳密に型指定され、厳密にチェックされます。</target>
        </trans-unit>
        <trans-unit id="b0c6e2bed7992d15f04fd899cadd250b20a960e6" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2 makes narrowing easier by relaxing rules for what it considers a discriminant property. Common properties of unions are now considered discriminants as long as they contain &lt;em&gt;some&lt;/em&gt; singleton type (e.g. a string literal, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;), and they contain no generics.</source>
          <target state="translated">TypeScript 3.2は、判別特性と見なされるもののルールを緩和することにより、ナローイングを容易にします。共用体の共通プロパティは&lt;em&gt;、&lt;/em&gt;シングルトンタイプ（文字列リテラル、 &lt;code&gt;null&lt;/code&gt; 、 &lt;code&gt;undefined&lt;/code&gt; など）を含み、ジェネリックを含まない限り、判別式と見なされるようになりました。</target>
        </trans-unit>
        <trans-unit id="7a26700dbb32ecd2b75ac980f07316d21f373a07" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2 now resolves &lt;code&gt;tsconfig.json&lt;/code&gt;s from &lt;code&gt;node_modules&lt;/code&gt;. When using a bare path for the &lt;code&gt;&quot;extends&quot;&lt;/code&gt; field in &lt;code&gt;tsconfig.json&lt;/code&gt;, TypeScript will dive into &lt;code&gt;node_modules&lt;/code&gt; packages for us.</source>
          <target state="translated">TypeScript 3.2は、 &lt;code&gt;tsconfig.json&lt;/code&gt; からの &lt;code&gt;node_modules&lt;/code&gt; 解決するようになりました。 &lt;code&gt;tsconfig.json&lt;/code&gt; の &lt;code&gt;&quot;extends&quot;&lt;/code&gt; フィールドに裸のパスを使用すると、TypeScriptは &lt;code&gt;node_modules&lt;/code&gt; パッケージに飛び込みます。</target>
        </trans-unit>
        <trans-unit id="cfd2b961db2e8cd46070f763e5c724b34d770631" translate="yes" xml:space="preserve">
          <source>TypeScript 3.3</source>
          <target state="translated">TypeScript 3.3</target>
        </trans-unit>
        <trans-unit id="151f809570316cd705748f077714354101e09c3c" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4</source>
          <target state="translated">TypeScript 3.4</target>
        </trans-unit>
        <trans-unit id="289b2ef5b5dba27b6f9d27a73f1f934655330ac2" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 also introduces new support for &lt;code&gt;readonly&lt;/code&gt; tuples. We can prefix any tuple type with the &lt;code&gt;readonly&lt;/code&gt; keyword to make it a &lt;code&gt;readonly&lt;/code&gt; tuple, much like we now can with array shorthand syntax. As you might expect, unlike ordinary tuples whose slots could be written to, &lt;code&gt;readonly&lt;/code&gt; tuples only permit reading from those positions.</source>
          <target state="translated">TypeScript 3.4では、 &lt;code&gt;readonly&lt;/code&gt; タプルの新しいサポートも導入されています。配列の省略構文でできるように、任意のタプルタイプの前に &lt;code&gt;readonly&lt;/code&gt; キーワードを付けて、それを &lt;code&gt;readonly&lt;/code&gt; タプルにすることができます。ご想像のとおり、スロットに書き込むことができる通常のタプルとは異なり、 &lt;code&gt;readonly&lt;/code&gt; タプルはそれらの位置からの読み取りのみを許可します。</target>
        </trans-unit>
        <trans-unit id="d5ae4e4e2dd524eb742ca067c90d1124fa510b9b" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 can now produce generic function types when inference from other generic functions produces free type variables for inferences. This means many function composition patterns now work better in 3.4.</source>
          <target state="translated">TypeScript 3.4では、他の汎用関数からの推論で推論用の自由な型変数が生成された場合に、汎用関数型を生成できるようになりました。これは、多くの関数構成パターンが 3.4 でより良く動作するようになったことを意味します。</target>
        </trans-unit>
        <trans-unit id="bf09bd81476b0409b652aa37d69d0d04e6689320" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 introduces a new construct for literal values called &lt;em&gt;&lt;code&gt;const&lt;/code&gt;&lt;/em&gt; assertions. Its syntax is a type assertion with &lt;code&gt;const&lt;/code&gt; in place of the type name (e.g. &lt;code&gt;123 as const&lt;/code&gt;). When we construct new literal expressions with &lt;code&gt;const&lt;/code&gt; assertions, we can signal to the language that</source>
          <target state="translated">TypeScript 3.4では、&lt;em&gt; &lt;code&gt;const&lt;/code&gt; &lt;/em&gt;アサーションと呼ばれるリテラル値の新しい構成が導入されています。その構文は、型名の代わりに &lt;code&gt;const&lt;/code&gt; を使用した型アサーションです（例： &lt;code&gt;123 as const&lt;/code&gt; ）。 &lt;code&gt;const&lt;/code&gt; アサーションを使用して新しいリテラル式を作成すると、言語に次のことを通知できます。</target>
        </trans-unit>
        <trans-unit id="1d6b24572a67a82fae359fdfff1468ec35fb0de9" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 introduces a new flag called &lt;code&gt;--incremental&lt;/code&gt; which tells TypeScript to save information about the project graph from the last compilation. The next time TypeScript is invoked with &lt;code&gt;--incremental&lt;/code&gt;, it will use that information to detect the least costly way to type-check and emit changes to your project.</source>
          <target state="translated">TypeScript 3.4では、 &lt;code&gt;--incremental&lt;/code&gt; と呼ばれる新しいフラグが導入され、最後のコンパイルからのプロジェクトグラフに関する情報を保存するようTypeScriptに指示しています。次回TypeScriptが &lt;code&gt;--incremental&lt;/code&gt; で呼び出されたときに、その情報を使用して、タイプチェックを行ってプロジェクトに変更を送信するための最もコストのかからない方法を検出します。</target>
        </trans-unit>
        <trans-unit id="ac5af210d9695056d6101c62263f01f5967d4e08" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 introduces a new syntax for &lt;code&gt;ReadonlyArray&lt;/code&gt; using a new &lt;code&gt;readonly&lt;/code&gt; modifier for array types.</source>
          <target state="translated">TypeScript 3.4では、配列型に新しい &lt;code&gt;readonly&lt;/code&gt; 修飾子を使用する &lt;code&gt;ReadonlyArray&lt;/code&gt; の新しい構文が導入されています。</target>
        </trans-unit>
        <trans-unit id="12a10c24cba59cb68af585f1698de8ae3445244e" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 introduces support for type-checking ECMAScript&amp;rsquo;s new &lt;code&gt;globalThis&lt;/code&gt; - a global variable that, well, refers to the global scope. Unlike the above solutions, &lt;code&gt;globalThis&lt;/code&gt; provides a standard way for accessing the global scope which can be used across different environments.</source>
          <target state="translated">TypeScript 3.4では、ECMAScriptの新しい &lt;code&gt;globalThis&lt;/code&gt; の型チェックのサポートが導入されました。これは、グローバルスコープを参照するグローバル変数です。上記のソリューションとは異なり、 &lt;code&gt;globalThis&lt;/code&gt; は、さまざまな環境で使用できるグローバルスコープにアクセスするための標準的な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="f91b4dd92032cff1d431b2484ffb02c538b2840a" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 makes it a little bit easier to use read-only array-like types.</source>
          <target state="translated">TypeScript 3.4では、読み取り専用の配列のような型が少し使いやすくなりました。</target>
        </trans-unit>
        <trans-unit id="9ab9e17f2ce04fc3d04ccc515b149cf9aa3aa203" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 produces the type</source>
          <target state="translated">TypeScript 3.4では</target>
        </trans-unit>
        <trans-unit id="10f518faa467d8e0e2925a31d9b4b672b9c2e19b" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5</source>
          <target state="translated">TypeScript 3.5</target>
        </trans-unit>
        <trans-unit id="359b79f7544026e6404a7f5dc527aa3cfdbf0be7" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 contains certain optimizations over TypeScript 3.4 for type-checking more efficiently. These improvements are significantly more pronounced in editor scenarios where type-checking drives operations like code completion lists.</source>
          <target state="translated">TypeScript 3.5 には、TypeScript 3.4 よりも効率的にタイプチェックを行うための、ある種の最適化が含まれています。これらの改善は、コード補完リストのような操作を型チェックによって行うエディタのシナリオにおいて、より顕著に現れています。</target>
        </trans-unit>
        <trans-unit id="a6938b07665eedd653729021d3cce39e74883c08" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 generalizes this behavior to work on constructor functions as well.</source>
          <target state="translated">TypeScript 3.5では、この動作を一般化してコンストラクタ関数でも動作するようにしています。</target>
        </trans-unit>
        <trans-unit id="a73d70bff8d5fc727c0bd14cb107e1c1b473750e" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 improves on 3.4&amp;rsquo;s &lt;code&gt;--incremental&lt;/code&gt; build mode, by saving information about how the state of the world was calculated - compiler settings, why files were looked up, where files were found, etc. In scenarios involving hundreds of projects using TypeScript&amp;rsquo;s project references in &lt;code&gt;--build&lt;/code&gt; mode, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/31101&quot;&gt;we&amp;rsquo;ve found that the amount of time rebuilding can be reduced by as much as 68% compared to TypeScript 3.4&lt;/a&gt;!</source>
          <target state="translated">TypeScript 3.5 は、コンパイラの設定、ファイルが検索された理由、ファイルが見つかった場所など、世界の状態の計算方法に関する情報を保存することにより、3.4の &lt;code&gt;--incremental&lt;/code&gt; ビルドモードを改善しています。TypeScriptを使用する何百ものプロジェクトが関係するシナリオでは &lt;code&gt;--build&lt;/code&gt; モードのプロジェクト参照では、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/31101&quot;&gt;TypeScript 3.4と比較して、再構築にかかる時間が68％も削減できることがわかりました&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8870d39de72c9538f7b989e9c665dcecc3f792f4" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 introduces several optimizations around type-checking and incremental builds.</source>
          <target state="translated">TypeScript 3.5では、タイプチェックやインクリメンタルビルドに関するいくつかの最適化が導入されています。</target>
        </trans-unit>
        <trans-unit id="a67354830dc88bba666b8a01f15200fc520abe67" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 introduces the new &lt;code&gt;Omit&lt;/code&gt; helper type, which creates a new type with some properties dropped from the original.</source>
          <target state="translated">TypeScript 3.5では新しい &lt;code&gt;Omit&lt;/code&gt; ヘルパータイプが導入され、元のタイプからいくつかのプロパティが削除された新しいタイプが作成されます。</target>
        </trans-unit>
        <trans-unit id="860169965c68715ea7e25ddf2b4ae280a663fdd6" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6</source>
          <target state="translated">TypeScript 3.6</target>
        </trans-unit>
        <trans-unit id="43040204a5b205b20ce117e9abeba80afa37f954" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 contains better support for Unicode characters in identifiers when emitting to ES2015 and later targets.</source>
          <target state="translated">TypeScript 3.6では、ES2015以降のターゲットにエミットする際に、識別子に含まれるUnicode文字のサポートが強化されています。</target>
        </trans-unit>
        <trans-unit id="bd36d48e4d1462dffb6c3c392323087bb23fcc1d" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 introduces a new &lt;code&gt;__spreadArrays&lt;/code&gt; helper to accurately model what happens in ECMAScript 2015 in older targets outside of &lt;code&gt;--downlevelIteration&lt;/code&gt;. &lt;code&gt;__spreadArrays&lt;/code&gt; is also available in &lt;a href=&quot;https://github.com/Microsoft/tslib/&quot;&gt;tslib&lt;/a&gt;.</source>
          <target state="translated">新しい活字体3.6が導入 &lt;code&gt;__spreadArrays&lt;/code&gt; が正確外の古いターゲットにECMAScriptの2015年に何が起こるかをモデル化するためにヘルパー &lt;code&gt;--downlevelIteration&lt;/code&gt; 。 &lt;code&gt;__spreadArrays&lt;/code&gt; は&lt;a href=&quot;https://github.com/Microsoft/tslib/&quot;&gt;tslib&lt;/a&gt;でも使用できます。</target>
        </trans-unit>
        <trans-unit id="33cd49dc97acf9b88dbc38ffefb886129306a9c4" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 introduces some improvements for when &lt;code&gt;Promise&lt;/code&gt;s are mis-handled.</source>
          <target state="translated">TypeScript 3.6では、 &lt;code&gt;Promise&lt;/code&gt; が誤って処理される場合のいくつかの改善が導入されています。</target>
        </trans-unit>
        <trans-unit id="74c9e7c03722726e70a2ffe1f76f8a558869d112" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 introduces stricter checking for iterators and generator functions. In earlier versions, users of generators had no way to differentiate whether a value was yielded or returned from a generator.</source>
          <target state="translated">TypeScript 3.6 では、イテレータとジェネレータ関数のチェックがより厳密に行われるようになりました。以前のバージョンでは、ジェネレータのユーザは値が生成されたのか返されたのかを区別する方法がありませんでした。</target>
        </trans-unit>
        <trans-unit id="81aa3de148cf46d845b3cd5b3e434a89e256c4c6" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 is now a bit smarter about looking at your existing imports before deciding on how to auto-import other modules. You can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32684&quot;&gt;see more details in the original pull request here&lt;/a&gt;.</source>
          <target state="translated">TypeScript 3.6は、他のモジュールを自動インポートする方法を決定する前に、既存のインポートを確認するのが少し賢くなりました。あなたはできます&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32684&quot;&gt;ここでは、元のプルリクエストで詳細を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="314b10ba05a1161535cb19963756c6c11ff953ee" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 supports transforming &lt;code&gt;import.meta&lt;/code&gt; to &lt;code&gt;context.meta&lt;/code&gt; when your &lt;code&gt;module&lt;/code&gt; target is set to &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">TypeScript 3.6は、 &lt;code&gt;module&lt;/code&gt; ターゲットが &lt;code&gt;system&lt;/code&gt; に設定されている場合の &lt;code&gt;import.meta&lt;/code&gt; から &lt;code&gt;context.meta&lt;/code&gt; への変換をサポートしています。</target>
        </trans-unit>
        <trans-unit id="5f7ed4364cfc54d058bc3677d8dbecd5e3827aa5" translate="yes" xml:space="preserve">
          <source>TypeScript 3.7</source>
          <target state="translated">TypeScript 3.7</target>
        </trans-unit>
        <trans-unit id="27083dbf128c773c5403938ac6b066e57d56ab6a" translate="yes" xml:space="preserve">
          <source>TypeScript 3.7 allows us to add &lt;code&gt;// @ts-nocheck&lt;/code&gt; comments to the top of TypeScript files to disable semantic checks. Historically this comment was only respected in JavaScript source files in the presence of &lt;code&gt;checkJs&lt;/code&gt;, but we&amp;rsquo;ve expanded support to TypeScript files to make migrations easier for all users.</source>
          <target state="translated">TypeScript 3.7では、TypeScriptファイルの先頭に &lt;code&gt;// @ts-nocheck&lt;/code&gt; コメントを追加して、セマンティックチェックを無効にすることができます。これまで、このコメントは &lt;code&gt;checkJs&lt;/code&gt; が存在する場合にのみJavaScriptソースファイルで尊重されていましたが、TypeScriptファイルへのサポートを拡大して、すべてのユーザーが移行しやすくしました。</target>
        </trans-unit>
        <trans-unit id="3948f56aa0a7c4b97a01b6021dd36790f3c27f3b" translate="yes" xml:space="preserve">
          <source>TypeScript 3.8 shipped a new strategy for watching directories, which is crucial for efficiently picking up changes to &lt;code&gt;node_modules&lt;/code&gt;.</source>
          <target state="translated">TypeScript 3.8は、ディレクトリを監視するための新しい戦略を出荷しました。これは、 &lt;code&gt;node_modules&lt;/code&gt; への変更を効率的に取得するために重要です。</target>
        </trans-unit>
        <trans-unit id="79e6c0e6d51157bb20e26a7e863eb63b56787312" translate="yes" xml:space="preserve">
          <source>TypeScript Documentation</source>
          <target state="translated">TypeScript ドキュメント</target>
        </trans-unit>
        <trans-unit id="5d719aff063d96145b68e6a617af89b4002a79f6" translate="yes" xml:space="preserve">
          <source>TypeScript Tooling in 5 minutes</source>
          <target state="translated">5分でわかるTypeScriptのツーリング</target>
        </trans-unit>
        <trans-unit id="403fb75c6290c33e1ee26eea036308b48aa46bfe" translate="yes" xml:space="preserve">
          <source>TypeScript Version: If you installed with npm: &lt;code&gt;/usr/local/lib/node_modules/typescript/lib&lt;/code&gt;</source>
          <target state="translated">TypeScriptバージョン：npmでインストールした場合： &lt;code&gt;/usr/local/lib/node_modules/typescript/lib&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d9bf97b3981273152e80b422491273038dfba6f7" translate="yes" xml:space="preserve">
          <source>TypeScript Version: If you installed with npm: &lt;code&gt;C:\Users\USERNAME\AppData\Roaming\npm\node_modules\typescript\lib&lt;/code&gt;</source>
          <target state="translated">TypeScriptバージョン：npmでインストールした場合： &lt;code&gt;C:\Users\USERNAME\AppData\Roaming\npm\node_modules\typescript\lib&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92158f74ec4a49fce0c3bbd7e4df145bfac809dd" translate="yes" xml:space="preserve">
          <source>TypeScript additionally has a &lt;code&gt;readonly&lt;/code&gt; modifier for properties.</source>
          <target state="translated">TypeScriptには、プロパティの &lt;code&gt;readonly&lt;/code&gt; 修飾子が追加されています。</target>
        </trans-unit>
        <trans-unit id="9786e84531c7e9e6709c98099bfd87c8dde49dc4" translate="yes" xml:space="preserve">
          <source>TypeScript adds a new triple-slash-reference directive (&lt;code&gt;/// &amp;lt;reference lib=&quot;name&quot; /&amp;gt;&lt;/code&gt;), allowing a file to explicitly include an existing built-in &lt;em&gt;lib&lt;/em&gt; file.</source>
          <target state="translated">TypeScriptは、新しいトリプルスラッシュ参照ディレクティブ（ &lt;code&gt;/// &amp;lt;reference lib=&quot;name&quot; /&amp;gt;&lt;/code&gt; ）を追加し、ファイルに既存の組み込み&lt;em&gt;lib&lt;/em&gt;ファイルを明示的に含めることができるようにします。</target>
        </trans-unit>
        <trans-unit id="ab30849b28c84e739618b723a20cd7f3bd9f8230" translate="yes" xml:space="preserve">
          <source>TypeScript adds several predefined conditional types, you can find the full list and examples in &lt;a href=&quot;utility-types&quot;&gt;Utility Types&lt;/a&gt;.</source>
          <target state="translated">TypeScriptはいくつかの事前定義された条件付きタイプを追加します。完全なリストと例は&lt;a href=&quot;utility-types&quot;&gt;ユーティリティタイプにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="933684eac8c53f3d3b595b291f7f85a2962ff42b" translate="yes" xml:space="preserve">
          <source>TypeScript also has boolean literal types. You might use these to constrain object values whose properties are interrelated.</source>
          <target state="translated">TypeScriptにはブーリアンリテラル型もあります。これらを使用して、プロパティが相互に関連しているオブジェクトの値を制限することができます。</target>
        </trans-unit>
        <trans-unit id="27cb184abb97e12b74ad8254592410b6fab20413" translate="yes" xml:space="preserve">
          <source>TypeScript also has its own way to declare a member as being marked &lt;code&gt;private&lt;/code&gt;, it cannot be accessed from outside of its containing class. For example:</source>
          <target state="translated">TypeScriptには、メンバーを &lt;code&gt;private&lt;/code&gt; としてマークするように宣言する独自の方法もあり、それを含むクラスの外部からアクセスすることはできません。例えば：</target>
        </trans-unit>
        <trans-unit id="53b23712d0cd1521663db4c571af695acc5fe01d" translate="yes" xml:space="preserve">
          <source>TypeScript also has numeric literal types, which act the same as the string literals above.</source>
          <target state="translated">TypeScriptには数値リテラル型もあり、上記の文字列リテラルと同じように動作します。</target>
        </trans-unit>
        <trans-unit id="627afeb35305a2b7b628a49f47ad27ec0e7523cd" translate="yes" xml:space="preserve">
          <source>TypeScript also has numeric literal types.</source>
          <target state="translated">TypeScriptには数値リテラル型もあります。</target>
        </trans-unit>
        <trans-unit id="cd15608e954ae2e54d306fd4af46560be232f740" translate="yes" xml:space="preserve">
          <source>TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript&amp;rsquo;s type system has evolved to model code written by native JavaScripters. The resulting system is powerful, interesting and messy.</source>
          <target state="translated">TypeScriptは、Microsoftのプログラマーが従来のオブジェクト指向プログラムをWebに導入できるように、従来のオブジェクト指向型をJavaScriptに導入する試みとして誕生しました。それが発展するにつれて、TypeScriptの型システムはネイティブJavaScripterによって書かれたモデルコードに進化しました。結果として得られるシステムは、強力で、面白く、乱雑です。</target>
        </trans-unit>
        <trans-unit id="d421259d60dd75e6cc38c009347d8fbd16eecddf" translate="yes" xml:space="preserve">
          <source>TypeScript borrows cast syntax from Closure. This lets you cast types to other types by adding a &lt;code&gt;@type&lt;/code&gt; tag before any parenthesized expression.</source>
          <target state="translated">TypeScriptはClosureからキャスト構文を借用しています。これにより、括弧で囲まれた式の前に &lt;code&gt;@type&lt;/code&gt; タグを追加することで、型を他の型にキャストできます。</target>
        </trans-unit>
        <trans-unit id="f845ee328e4da8982a9cb87a1d1fe60de76cba85" translate="yes" xml:space="preserve">
          <source>TypeScript can reports errors for fall-through cases in switch statement where the case clause is non-empty. This check is turned &lt;em&gt;off&lt;/em&gt; by default, and can be enabled using &lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt;.</source>
          <target state="translated">TypeScriptは、case文節が空でないswitchステートメントのフォールスルーケースのエラーを報告できます。このチェックはデフォルトで&lt;em&gt;オフ&lt;/em&gt;になっており、-- &lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt; を使用して有効にできます。</target>
        </trans-unit>
        <trans-unit id="86267f4e18cd09316cea7bbab141853557982d64" translate="yes" xml:space="preserve">
          <source>TypeScript can usually infer type arguments from a call based on the type of the arguments, so type arguments are usually not needed.</source>
          <target state="translated">TypeScript は通常、引数の型に基づいて呼び出しから型引数を推論することができるので、型引数は通常必要ありません。</target>
        </trans-unit>
        <trans-unit id="051064120a5cd70ddad4ed87c1bc2af64d3d9e4b" translate="yes" xml:space="preserve">
          <source>TypeScript checks a program for errors before execution, and does so based on the &lt;em&gt;kinds of values&lt;/em&gt;, it&amp;rsquo;s a &lt;em&gt;static type checker&lt;/em&gt;. For example, the last example above has an error because of the &lt;em&gt;type&lt;/em&gt; of &lt;code&gt;obj&lt;/code&gt;. Here&amp;rsquo;s the error TypeScript found:</source>
          <target state="translated">TypeScriptは、実行前にプログラムのエラーをチェックし、&lt;em&gt;値&lt;/em&gt;の&lt;em&gt;種類に&lt;/em&gt;基づいて&lt;em&gt;チェックし&lt;/em&gt;ます。これは&lt;em&gt;静的な型チェッカー&lt;/em&gt;です。たとえば、上記の最後の例では、 &lt;code&gt;obj&lt;/code&gt; の&lt;em&gt;タイプ&lt;/em&gt;が原因でエラーが発生しています。TypeScriptで見つかったエラーは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="98b9849713d9bf4417e9c5210a0c528aff29dc06" translate="yes" xml:space="preserve">
          <source>TypeScript code</source>
          <target state="translated">タイプスクリプトコード</target>
        </trans-unit>
        <trans-unit id="3883e486fe04d1f7d13e0ad9f1b9eb0d552664b9" translate="yes" xml:space="preserve">
          <source>TypeScript comes with a &lt;code&gt;ReadonlyArray&amp;lt;T&amp;gt;&lt;/code&gt; type that is the same as &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; with all mutating methods removed, so you can make sure you don&amp;rsquo;t change your arrays after creation:</source>
          <target state="translated">TypeScriptには、すべての変更メソッドが削除された &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; と同じ &lt;code&gt;ReadonlyArray&amp;lt;T&amp;gt;&lt;/code&gt; 型が付属しているため、作成後に配列を変更しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="c46782ad571ccfa1375c328c08d6d8a52aae9f4e" translate="yes" xml:space="preserve">
          <source>TypeScript comes with certain checks to give you more safety and analysis of your program. Once you&amp;rsquo;ve converted your codebase to TypeScript, you can start enabling these checks for greater safety.</source>
          <target state="translated">TypeScriptには、プログラムの安全性と分析を強化するための特定のチェックが付属しています。コードベースをTypeScriptに変換したら、これらのチェックを有効にして安全性を高めることができます。</target>
        </trans-unit>
        <trans-unit id="ccbb64b768c9b80a0141d5b0cacdf027e032576b" translate="yes" xml:space="preserve">
          <source>TypeScript compiles this down to the following JavaScript:</source>
          <target state="translated">TypeScriptはこれを以下のJavaScriptにコンパイルします。</target>
        </trans-unit>
        <trans-unit id="982bd44a5cc8b5512117571aef28b0ebcb320b22" translate="yes" xml:space="preserve">
          <source>TypeScript decorators are based on the &lt;a href=&quot;https://github.com/wycats/javascript-decorators&quot;&gt;ES7 decorator proposal&lt;/a&gt;.</source>
          <target state="translated">TypeScriptデコレーターは、&lt;a href=&quot;https://github.com/wycats/javascript-decorators&quot;&gt;ES7デコレーターの提案に&lt;/a&gt;基づいています。</target>
        </trans-unit>
        <trans-unit id="c49eb75318af39272125eec481e10dad28c42573" translate="yes" xml:space="preserve">
          <source>TypeScript determines if the call to &lt;code&gt;fn&lt;/code&gt; here is valid by seeing if the provided argument is a valid &lt;code&gt;Empty&lt;/code&gt;. It does so by examining the &lt;em&gt;structure&lt;/em&gt; of &lt;code&gt;{ k: 10 }&lt;/code&gt; and &lt;code&gt;class Empty { }&lt;/code&gt;. We can see that &lt;code&gt;{ k: 10 }&lt;/code&gt; has &lt;em&gt;all&lt;/em&gt; of the properties that &lt;code&gt;Empty&lt;/code&gt; does, because &lt;code&gt;Empty&lt;/code&gt; has no properties. Therefore, this is a valid call!</source>
          <target state="translated">TypeScriptは、指定された引数が有効な &lt;code&gt;Empty&lt;/code&gt; であるかどうかを確認することにより、ここでの &lt;code&gt;fn&lt;/code&gt; の呼び出しが有効かどうかを判断します。これは、 &lt;code&gt;{ k: 10 }&lt;/code&gt; と &lt;code&gt;class Empty { }&lt;/code&gt; の&lt;em&gt;構造&lt;/em&gt;を調べることによって行われます。 &lt;code&gt;Empty&lt;/code&gt; にはプロパティがないため、 &lt;code&gt;{ k: 10 }&lt;/code&gt; は &lt;code&gt;Empty&lt;/code&gt; が持つ&lt;em&gt;すべて&lt;/em&gt;のプロパティがあることがわかります。したがって、これは有効な呼び出しです。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="250cd79d3d3268a25a6551d40fbaae96eebab0e3" translate="yes" xml:space="preserve">
          <source>TypeScript did not have a type that represents the non-primitive type, i.e. any thing that is not &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;. Enter the new &lt;code&gt;object&lt;/code&gt; type.</source>
          <target state="translated">TypeScriptには、プリミティブ以外の型を表す型がありませんでした。つまり、 &lt;code&gt;number&lt;/code&gt; 、 &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;boolean&lt;/code&gt; 、 &lt;code&gt;symbol&lt;/code&gt; 、 &lt;code&gt;null&lt;/code&gt; 、または &lt;code&gt;undefined&lt;/code&gt; 以外のものはありません。新しい &lt;code&gt;object&lt;/code&gt; タイプを入力します。</target>
        </trans-unit>
        <trans-unit id="b5ef0d0e7c127dd5aa5d2057bcc3b018aa657ae1" translate="yes" xml:space="preserve">
          <source>TypeScript does not have higher kinded types, so the following is not legal:</source>
          <target state="translated">TypeScriptには上位の kinded 型がないので、以下はご法度です。</target>
        </trans-unit>
        <trans-unit id="0ecbedd4aac4c783dc5087f561c9c49681b205cd" translate="yes" xml:space="preserve">
          <source>TypeScript does not support resolving JSON files by default:</source>
          <target state="translated">TypeScriptはデフォルトでJSONファイルの解決をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="99706e78c25c70ab97b91669035d38e90b305ea6" translate="yes" xml:space="preserve">
          <source>TypeScript doesn&amp;rsquo;t consider any JavaScript code to be an error because of its syntax. This means you can take any working JavaScript code and put it in a TypeScript file without worrying about exactly how it is written.</source>
          <target state="translated">TypeScriptは、その構文のため、JavaScriptコードをエラーとは見なしません。つまり、動作しているJavaScriptコードを取得して、その記述方法を正確に気にすることなくTypeScriptファイルに入れることができます。</target>
        </trans-unit>
        <trans-unit id="fada45685495c730f9a9cc2a93bbb49026908546" translate="yes" xml:space="preserve">
          <source>TypeScript doesn&amp;rsquo;t exist in a vacuum. It was built with the JavaScript ecosystem in mind, and a lot of JavaScript exists today. Converting a JavaScript codebase over to TypeScript is, while somewhat tedious, usually not challenging. In this tutorial, we&amp;rsquo;re going to look at how you might start out. We assume you&amp;rsquo;ve read enough of the handbook to write new TypeScript code.</source>
          <target state="translated">TypeScriptは孤立して存在しません。これはJavaScriptエコシステムを念頭に置いて構築されており、現在、多くのJavaScriptが存在しています。JavaScriptコードベースをTypeScriptに変換することは、やや退屈ですが、通常は難しくありません。このチュートリアルでは、どのように始めればよいかを見ていきます。新しいTypeScriptコードを作成するためのハンドブックを十分に読んだことを前提としています。</target>
        </trans-unit>
        <trans-unit id="1c8cdf286fbbcc4e7b49af3039a27393efcafa25" translate="yes" xml:space="preserve">
          <source>TypeScript files will start out in your &lt;code&gt;src&lt;/code&gt; folder, run through the TypeScript compiler and end up in &lt;code&gt;dist&lt;/code&gt;.</source>
          <target state="translated">TypeScriptファイルは &lt;code&gt;src&lt;/code&gt; フォルダーから始まり、TypeScriptコンパイラーを介して実行され、最後に &lt;code&gt;dist&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="59c18fee8487cdeda3b2f34b4ca8e8a543f5cab1" translate="yes" xml:space="preserve">
          <source>TypeScript files will start out in your &lt;code&gt;src&lt;/code&gt; folder, run through the TypeScript compiler, then webpack, and end up in a &lt;code&gt;main.js&lt;/code&gt; file in &lt;code&gt;dist&lt;/code&gt;. Any components that we write will go in the &lt;code&gt;src/components&lt;/code&gt; folder.</source>
          <target state="translated">TypeScriptファイルは、 &lt;code&gt;src&lt;/code&gt; フォルダーから始まり、TypeScriptコンパイラーを介して実行され、 &lt;code&gt;main.js&lt;/code&gt; 実行して、 &lt;code&gt;dist&lt;/code&gt; のmain.jsファイルになります。作成するコンポーネントはすべて &lt;code&gt;src/components&lt;/code&gt; フォルダーに配置されます。</target>
        </trans-unit>
        <trans-unit id="24e928664e9ba3db7f949861f05d81f86d70adeb" translate="yes" xml:space="preserve">
          <source>TypeScript follows the case sensitivity rules of the file system it&amp;rsquo;s running on. This can be problematic if some developers are working in a case-sensitive file system and others aren&amp;rsquo;t. If a file attempts to import &lt;code&gt;fileManager.ts&lt;/code&gt; by specifying &lt;code&gt;./FileManager.ts&lt;/code&gt; the file will be found in a case-insensitive file system, but not on a case-sensitive file system.</source>
          <target state="translated">TypeScriptは、実行されているファイルシステムの大文字と小文字の区別の規則に従います。一部の開発者が大文字と小文字を区別するファイルシステムで作業している場合とそうでない場合、これは問題になる可能性があります。ファイルが &lt;code&gt;fileManager.ts&lt;/code&gt; を指定して &lt;code&gt;./FileManager.ts&lt;/code&gt; をインポートしようとすると、ファイルは大文字と小文字を区別しないファイルシステムで検出されますが、大文字と小文字を区別するファイルシステムでは検出されません。</target>
        </trans-unit>
        <trans-unit id="bc050e207c38920097293143b10d59b473dbcff4" translate="yes" xml:space="preserve">
          <source>TypeScript for Functional Programmers</source>
          <target state="translated">関数型プログラマーのためのTypeScript</target>
        </trans-unit>
        <trans-unit id="9fc592d6d7ce7d2bc3c3f49068e5d4fff5338e8e" translate="yes" xml:space="preserve">
          <source>TypeScript for JS Programmers</source>
          <target state="translated">JSプログラマーのためのTypeScript</target>
        </trans-unit>
        <trans-unit id="0ad7cb0c6b7a5eb829a0cd66ebdfe0d11d25b842" translate="yes" xml:space="preserve">
          <source>TypeScript for Java/C# Programmers</source>
          <target state="translated">Java/C#プログラマのためのTypeScript</target>
        </trans-unit>
        <trans-unit id="e7d15563ab88aa0acbcf181a27f272f5268b418d" translate="yes" xml:space="preserve">
          <source>TypeScript for JavaScript Programmers</source>
          <target state="translated">JavaScriptプログラマのためのTypeScript</target>
        </trans-unit>
        <trans-unit id="24cf59fb1a4572acf6d6413101225073873cc311" translate="yes" xml:space="preserve">
          <source>TypeScript for New Programmers</source>
          <target state="translated">新しいプログラマーのためのTypeScript</target>
        </trans-unit>
        <trans-unit id="871854b83287d4786ba7236204173f606ee249bb" translate="yes" xml:space="preserve">
          <source>TypeScript for OOP Programmers</source>
          <target state="translated">OOPプログラマのためのTypeScript</target>
        </trans-unit>
        <trans-unit id="5a6afc05f4efdee6736a14797a9429ba616e9f7d" translate="yes" xml:space="preserve">
          <source>TypeScript for the New Programmer</source>
          <target state="translated">新米プログラマーのためのTypeScript</target>
        </trans-unit>
        <trans-unit id="e275a1ab2aa2f59571ca8cefeaf8a68b8704838b" translate="yes" xml:space="preserve">
          <source>TypeScript has a way to describe objects which have unknown keys but known values on an object, via index signatures.</source>
          <target state="translated">TypeScript には、未知のキーを持ちながらもオブジェクト上の値が既知であるオブジェクトをインデックスシグネチャで記述する方法があります。</target>
        </trans-unit>
        <trans-unit id="a367ff679df04f05c3c34e6560229bdc2557a732" translate="yes" xml:space="preserve">
          <source>TypeScript has always compared parameters in a bivariant way. There are a number of reasons for this, but by-and-large this was not been a huge issue for our users until we saw some of the adverse effects it had with &lt;code&gt;Promise&lt;/code&gt;s and &lt;code&gt;Observable&lt;/code&gt;s.</source>
          <target state="translated">TypeScriptは常にパラメーターを二変法で比較してきました。これにはいくつかの理由がありますが、 &lt;code&gt;Observable&lt;/code&gt; 、 &lt;code&gt;Promise&lt;/code&gt; とObservableで悪影響が見られるまで、ユーザーにとって大きな問題ではありませんでした。</target>
        </trans-unit>
        <trans-unit id="2cc6486a45098c6f81cc098930195dc52786060c" translate="yes" xml:space="preserve">
          <source>TypeScript has corresponding primitive types for the built-in types:</source>
          <target state="translated">TypeScriptには、組み込み型に対応するプリミティブ型があります。</target>
        </trans-unit>
        <trans-unit id="994258a317498ea30e98974b2dd26c0832e6c8f6" translate="yes" xml:space="preserve">
          <source>TypeScript has some obvious places where it can infer types, like variable declarations:</source>
          <target state="translated">TypeScriptには、変数宣言のように型を推論できる場所がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="db02a42b5c74e823760580106f119d33d32acab0" translate="yes" xml:space="preserve">
          <source>TypeScript has traditionally been overly strict about how you can import modules. This was to avoid typos and prevent users from using modules incorrectly.</source>
          <target state="translated">TypeScript は伝統的に、モジュールのインポート方法について過度に厳しくしてきました。これはタイプミスを避け、ユーザーがモジュールを誤って使用しないようにするためでした。</target>
        </trans-unit>
        <trans-unit id="6506fa415538aa5ce5fe042526c3ba02ac3c0356" translate="yes" xml:space="preserve">
          <source>TypeScript has two special types, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, that have the values null and undefined respectively. We mentioned these briefly in &lt;a href=&quot;basic-types&quot;&gt;the Basic Types section&lt;/a&gt;.</source>
          <target state="translated">TypeScriptには、 &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; の2つの特別なタイプがあり、それぞれnullとundefinedの値を持ちます。これらについては&lt;a href=&quot;basic-types&quot;&gt;、基本タイプのセクションで&lt;/a&gt;簡単に説明しました。</target>
        </trans-unit>
        <trans-unit id="b5b5002b156ed20abcb2373b3f1a34e30ef133d5" translate="yes" xml:space="preserve">
          <source>TypeScript has two special types, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, that have the values null and undefined respectively. We mentioned these briefly in &lt;a href=&quot;basic-types&quot;&gt;the Basic Types section&lt;/a&gt;. By default, the type checker considers &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; assignable to anything. Effectively, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are valid values of every type. That means it&amp;rsquo;s not possible to &lt;em&gt;stop&lt;/em&gt; them from being assigned to any type, even when you would like to prevent it. The inventor of &lt;code&gt;null&lt;/code&gt;, Tony Hoare, calls this his &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_pointer#History&quot;&gt;&amp;ldquo;billion dollar mistake&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">TypeScriptには、 &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; の 2つの特別なタイプがあり、それぞれnullとundefinedの値を持っています。これらについては&lt;a href=&quot;basic-types&quot;&gt;、基本タイプのセクションで&lt;/a&gt;簡単に説明しました。デフォルトでは、型チェッカーは &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; 割り当て可能と見なします。事実上、 &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; はすべてのタイプの有効な値です。つまり、それを防止したい場合でも、それらの型への割り当てを&lt;em&gt;停止&lt;/em&gt;することはできません。 &lt;code&gt;null&lt;/code&gt; の発明者であるTony Hoareは、これを彼の&lt;a href=&quot;https://en.wikipedia.org/wiki/Null_pointer#History&quot;&gt;「10億ドルの間違い」と呼んでい&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="75fc1f90351ac73e35a5f3f576d18314c46dc6c2" translate="yes" xml:space="preserve">
          <source>TypeScript has two special types, Null and Undefined, that have the values &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; respectively. Previously it was not possible to explicitly name these types, but &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; may now be used as type names regardless of type checking mode.</source>
          <target state="translated">TypeScriptには2つの特別な型、NullとUndefinedがあり、それぞれ &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; の値を持っています。以前は、これらの型に明示的に名前を付けることはできませんでしたが、型チェックモードに関係なく、 &lt;code&gt;null&lt;/code&gt; および &lt;code&gt;undefined&lt;/code&gt; を型名として使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="76257f3717800dcd967d87bc9d2ef1e67b788bfb" translate="yes" xml:space="preserve">
          <source>TypeScript ignores any unsupported JSDoc tags.</source>
          <target state="translated">TypeScript はサポートされていない JSDoc タグを無視します。</target>
        </trans-unit>
        <trans-unit id="669ae0c383f0ebc9a1b71a33795f2fba316ff636" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes</source>
          <target state="translated">5分でできるTypeScript</target>
        </trans-unit>
        <trans-unit id="452bd92ef7047873dae5fa9a26760186598678c6" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Building your first TypeScript file</source>
          <target state="translated">5分でできるTypeScript 初めてのTypeScriptファイルの作成</target>
        </trans-unit>
        <trans-unit id="cfe56778efe914c509395d743856f638e0b2dc80" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Classes</source>
          <target state="translated">5分でできるTypeScript クラス</target>
        </trans-unit>
        <trans-unit id="66f6d1b030c2c31817cfd629aeaf4e9f8e001440" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Compiling your code</source>
          <target state="translated">TypeScriptを5分で コードのコンパイル</target>
        </trans-unit>
        <trans-unit id="64b3883005157157bc3e05fd1909ad05a7782093" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Installing TypeScript</source>
          <target state="translated">TypeScriptを5分でインストール TypeScript のインストール</target>
        </trans-unit>
        <trans-unit id="679437aa54596d7921f489403e44c2b30fef5aed" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Interfaces</source>
          <target state="translated">5分でTypeScriptが使えるようになりました。インターフェース</target>
        </trans-unit>
        <trans-unit id="520fec1d849d26fa3641ec76d5fda0df2e56b07e" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Running your TypeScript web app</source>
          <target state="translated">5分でわかるTypeScript TypeScript ウェブアプリを実行する</target>
        </trans-unit>
        <trans-unit id="6a574132fb48839d07c1e73530345fd9189655e2" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Type annotations</source>
          <target state="translated">5分でできるTypeScript。タイプアノテーション</target>
        </trans-unit>
        <trans-unit id="49f01d7597e304266b95072fc59979cc8fe48d0a" translate="yes" xml:space="preserve">
          <source>TypeScript includes a default set of type definitions for built-in JS APIs (like &lt;code&gt;Math&lt;/code&gt;), as well as type definitions for things found in browser environments (like &lt;code&gt;document&lt;/code&gt;). TypeScript also includes APIs for newer JS features matching the &lt;code&gt;target&lt;/code&gt; you specify; for example the definition for &lt;code&gt;Map&lt;/code&gt; is available if &lt;code&gt;target&lt;/code&gt; is &lt;code&gt;ES6&lt;/code&gt; or newer.</source>
          <target state="translated">TypeScriptには、組み込みのJS API（ &lt;code&gt;Math&lt;/code&gt; など）のデフォルトの型定義セットと、ブラウザー環境（ &lt;code&gt;document&lt;/code&gt; など）にあるものの型定義が含まれています。TypeScriptには、指定した &lt;code&gt;target&lt;/code&gt; 一致する新しいJS機能のAPIも含まれています。たとえば、 &lt;code&gt;target&lt;/code&gt; が &lt;code&gt;ES6&lt;/code&gt; 以降の場合、 &lt;code&gt;Map&lt;/code&gt; の定義を使用できます。</target>
        </trans-unit>
        <trans-unit id="fa27fdf7da61b594edc2419147ebeb6293bab089" translate="yes" xml:space="preserve">
          <source>TypeScript includes experimental support for emitting certain types of metadata for declarations that have decorators. To enable this experimental support, you must set the &lt;code&gt;emitDecoratorMetadata&lt;/code&gt; compiler option either on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">TypeScriptには、デコレータを持つ宣言に対して特定のタイプのメタデータを発行する実験的なサポートが含まれています。この実験的なサポートを有効にするには、設定する必要があり &lt;code&gt;emitDecoratorMetadata&lt;/code&gt; のコマンドラインまたはあなたの中のいずれかのコンパイラオプションを &lt;code&gt;tsconfig.json&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="65097970997af32f38424bf7e3969825b3d282b6" translate="yes" xml:space="preserve">
          <source>TypeScript injects a handful of helper functions such as &lt;code&gt;__extends&lt;/code&gt; for inheritance, &lt;code&gt;__assign&lt;/code&gt; for spread operator in object literals and JSX elements, and &lt;code&gt;__awaiter&lt;/code&gt; for async functions.</source>
          <target state="translated">TypeScriptは、継承用の &lt;code&gt;__assign&lt;/code&gt; 、オブジェクトリテラルとJSX要素内のスプレッド演算子用の &lt;code&gt;__awaiter&lt;/code&gt; 、非同期関数用の &lt;code&gt;__extends&lt;/code&gt; など、いくつかのヘルパー関数を注入します。</target>
        </trans-unit>
        <trans-unit id="1676238ce5402b50fb854510e52fc28497e635a6" translate="yes" xml:space="preserve">
          <source>TypeScript is a language that is a &lt;em&gt;superset&lt;/em&gt; of JavaScript: JS syntax is therefore legal TS. Syntax refers to the way we write text to form a program. For example, this code has a &lt;em&gt;syntax&lt;/em&gt; error because it&amp;rsquo;s missing a &lt;code&gt;)&lt;/code&gt;:</source>
          <target state="translated">TypeScriptは、JavaScriptの&lt;em&gt;スーパーセット&lt;/em&gt;である言語です。したがって、JS構文は正当なTSです。構文とは、プログラムを形成するためにテキストを書く方法を指します。たとえば、このコードには &lt;code&gt;)&lt;/code&gt; ：がないため、&lt;em&gt;構文&lt;/em&gt;エラーがあり&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="9a40df62f3fab8b8861efc1fdf68a3995194acce" translate="yes" xml:space="preserve">
          <source>TypeScript is a popular choice for programmers accustomed to other languages with static typing, such as C# and Java.</source>
          <target state="translated">TypeScriptは、C#やJavaなどの静的型付けを行う他の言語に慣れているプログラマーに人気があります。</target>
        </trans-unit>
        <trans-unit id="4865203c87f3f94d8f8566ed718390d0119234fb" translate="yes" xml:space="preserve">
          <source>TypeScript is a structural type system. When we compare two different types, regardless of where they came from, if the types of all members are compatible, then we say the types themselves are compatible.</source>
          <target state="translated">TypeScript は構造的な型システムです。2つの異なる型がどこから来たかに関係なく比較したときに、すべてのメンバーの型が互換性があれば、その型自体が互換性があると言うことになります。</target>
        </trans-unit>
        <trans-unit id="03aae380405163f427174ac0826d59a0323fbdd4" translate="yes" xml:space="preserve">
          <source>TypeScript is a typed superset of JavaScript, and it ships type definitions for the DOM API. These definitions are readily available in any default TypeScript project. Of the 20,000+ lines of definitions in &lt;em&gt;lib.dom.d.ts&lt;/em&gt;, one stands out among the rest: &lt;code&gt;HTMLElement&lt;/code&gt; . This type is the backbone for DOM manipulation with TypeScript.</source>
          <target state="translated">TypeScriptはJavaScriptの型付きスーパーセットであり、DOMAPIの型定義を提供します。これらの定義は、デフォルトのTypeScriptプロジェクトですぐに利用できます。定義の20,000行のうち&lt;em&gt;lib.dom.d.ts&lt;/em&gt;：、1は残りの中で際立っている &lt;code&gt;HTMLElement&lt;/code&gt; 。このタイプは、TypeScriptを使用したDOM操作のバックボーンです。</target>
        </trans-unit>
        <trans-unit id="a2a4f8e7040f4dce8be2768117a4691b14f816d0" translate="yes" xml:space="preserve">
          <source>TypeScript is also a programming language that preserves the &lt;em&gt;runtime behavior&lt;/em&gt; of JavaScript. For example, dividing by zero in JavaScript produces &lt;code&gt;Infinity&lt;/code&gt; instead of throwing a runtime exception. As a principle, TypeScript &lt;strong&gt;never&lt;/strong&gt; changes the runtime behavior of JavaScript code.</source>
          <target state="translated">TypeScriptは、JavaScriptの&lt;em&gt;実行時の動作&lt;/em&gt;を保持するプログラミング言語でもあります。たとえば、JavaScriptでゼロで除算すると、実行時例外をスローする代わりに &lt;code&gt;Infinity&lt;/code&gt; が生成されます。原則として、TypeScriptはJavaScriptコードの実行時の動作を変更し&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="9e5933fe400768d081ab73894e4f792a102e8c04" translate="yes" xml:space="preserve">
          <source>TypeScript is now smart enough to detect whether your file uses semicolons when applying these sorts of edits. If your file generally lacks semicolons, TypeScript won&amp;rsquo;t add one.</source>
          <target state="translated">TypeScriptは、これらの種類の編集を適用するときにファイルがセミコロンを使用しているかどうかを検出するのに十分なほどスマートになりました。ファイルに通常セミコロンがない場合、TypeScriptはセミコロンを追加しません。</target>
        </trans-unit>
        <trans-unit id="f8e7896660208a1071901f88668396a6aa40f6ae" translate="yes" xml:space="preserve">
          <source>TypeScript is smart enough to infer types in other contexts as well:</source>
          <target state="translated">TypeScript は、他の文脈でも型を推論することができるほどスマートです。</target>
        </trans-unit>
        <trans-unit id="df5a722ba8718780ca30a3749f2e85938a171a6e" translate="yes" xml:space="preserve">
          <source>TypeScript knows the JavaScript language and will generate types for you in many cases. For example in creating a variable and assigning it to a particular value, TypeScript will use the value as its type.</source>
          <target state="translated">TypeScriptはJavaScript言語を知っており、多くの場合、型を生成してくれます。例えば、変数を作成して特定の値に代入する場合、TypeScript はその値を型として使用します。</target>
        </trans-unit>
        <trans-unit id="1b561cb58276a15cfc408ce85335f9d608e3f0d7" translate="yes" xml:space="preserve">
          <source>TypeScript may offer you errors which you disagree with, in those cases you can ignore errors on specific lines by adding &lt;code&gt;// @ts-ignore&lt;/code&gt; or &lt;code&gt;// @ts-expect-error&lt;/code&gt; on the preceding line.</source>
          <target state="translated">TypeScriptはあなたが同意しないエラーを提供するかもしれません、そのような場合、あなたは前の行に &lt;code&gt;// @ts-ignore&lt;/code&gt; または &lt;code&gt;// @ts-expect-error&lt;/code&gt; を追加することによって、特定の行のエラーを無視することができます。</target>
        </trans-unit>
        <trans-unit id="c0716da88bf8553ba341ae10829c8d80565f07b2" translate="yes" xml:space="preserve">
          <source>TypeScript might compile this down to something like the the following JavaScript:</source>
          <target state="translated">TypeScript はこれをコンパイルして、以下の JavaScript のようなものにすることができます。</target>
        </trans-unit>
        <trans-unit id="32fed70cd34feef29d0649f498d61da78cbda0ab" translate="yes" xml:space="preserve">
          <source>TypeScript now only strictly enforces the visibility of types in modules if the &lt;code&gt;--declaration&lt;/code&gt; flag is provided. This is very useful for Angular scenarios, for example:</source>
          <target state="translated">TypeScriptは、 &lt;code&gt;--declaration&lt;/code&gt; フラグが指定されている場合にのみ、モジュール内の型の可視性を厳密に適用するようになりました。これは、たとえば次のようなAngularシナリオで非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="bf627cab04633b795ac087dea296a4bdb609bc4d" translate="yes" xml:space="preserve">
          <source>TypeScript now supports &lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;Function components&lt;/a&gt;. These are lightweight components that easily compose other components:</source>
          <target state="translated">TypeScriptが&lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;Functionコンポーネントを&lt;/a&gt;サポートするようになりました。これらは、他のコンポーネントを簡単に構成できる軽量コンポーネントです。</target>
        </trans-unit>
        <trans-unit id="52d1c2115b1983ad21a42bf4d3fb47956062ab0c" translate="yes" xml:space="preserve">
          <source>TypeScript now supports ES6 template strings. These are an easy way to embed arbitrary expressions in strings:</source>
          <target state="translated">TypeScript が ES6 のテンプレート文字列をサポートするようになりました。これらは、任意の式を文字列に簡単に埋め込む方法です。</target>
        </trans-unit>
        <trans-unit id="dca2d3b95767ef524c8d3421355c36053ab3819a" translate="yes" xml:space="preserve">
          <source>TypeScript now supports asynchronous functions for engines that have native support for ES6 generators, e.g. Node v4 and above. Asynchronous functions are prefixed with the &lt;code&gt;async&lt;/code&gt; keyword; &lt;code&gt;await&lt;/code&gt; suspends the execution until an asynchronous function return promise is fulfilled and unwraps the value from the &lt;code&gt;Promise&lt;/code&gt; returned.</source>
          <target state="translated">TypeScriptは、Node v4以降など、ES6ジェネレーターをネイティブでサポートするエンジンの非同期関数をサポートするようになりました。非同期関数の前には &lt;code&gt;async&lt;/code&gt; キーワードが付いています。 &lt;code&gt;await&lt;/code&gt; は、非同期関数のreturn promiseが満たされるまで実行を中断し、返された &lt;code&gt;Promise&lt;/code&gt; から値をアンラップします。</target>
        </trans-unit>
        <trans-unit id="0e7958ec88d9f0faef067488c643d885da64e7bf" translate="yes" xml:space="preserve">
          <source>TypeScript now tries to unify type parameters when comparing two single-signature types. As a result, you&amp;rsquo;ll get stricter checks when relating two generic signatures, and may catch some bugs.</source>
          <target state="translated">TypeScriptは、2つの単一署名の型を比較す​​るときに型パラメーターを統一しようとします。その結果、2つの一般的な署名を関連付けるときにより厳密なチェックが行われ、いくつかのバグが検出される可能性があります。</target>
        </trans-unit>
        <trans-unit id="a1e4e94f6714f3b9449e43db5907067b8f68b98e" translate="yes" xml:space="preserve">
          <source>TypeScript provides a number of mechanisms to work with types in a set-theoretic way, and you&amp;rsquo;ll find them more intuitive if you think of types as sets.</source>
          <target state="translated">TypeScriptは、集合論的な方法で型を操作するための多くのメカニズムを提供します。型を集合として考えると、それらはより直感的に理解できます。</target>
        </trans-unit>
        <trans-unit id="d62273ee78dee44c5da22f4945f26ce4659fc27f" translate="yes" xml:space="preserve">
          <source>TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally.</source>
          <target state="translated">TypeScript は、一般的な型変換を容易にするために、いくつかのユーティリティタイプを提供しています。これらのユーティリティはグローバルに利用できます。</target>
        </trans-unit>
        <trans-unit id="4ef0844b7f909249d5a9f9e273a4f9a6ba63eb30" translate="yes" xml:space="preserve">
          <source>TypeScript replicates the node resolution for modules in a &lt;code&gt;package.json&lt;/code&gt;, with an additional step for finding .d.ts files. Roughly, the resolution will first check the optional &lt;code&gt;&quot;types&quot;&lt;/code&gt; field, then the &lt;code&gt;&quot;main&quot;&lt;/code&gt; field, and finally will try &lt;code&gt;index.d.ts&lt;/code&gt; in the root.</source>
          <target state="translated">TypeScriptは、 &lt;code&gt;package.json&lt;/code&gt; 内のモジュールのノード解像度を複製し、.d.tsファイルを検索するための追加の手順を追加します。大まかに言って、解決策は最初にオプションの &lt;code&gt;&quot;types&quot;&lt;/code&gt; フィールドをチェックし、次に &lt;code&gt;&quot;main&quot;&lt;/code&gt; フィールドをチェックし、最後にルートで &lt;code&gt;index.d.ts&lt;/code&gt; を試します。</target>
        </trans-unit>
        <trans-unit id="988860fc02a853b3a27d2af5425c58bd62c2eceb" translate="yes" xml:space="preserve">
          <source>TypeScript resolves signature compatibility by seeing if any signature of the target can be invoked with the arguments of the source, &lt;em&gt;and extraneous arguments are allowed&lt;/em&gt;. This code, for example, exposes a bug only when the signature is correctly written using optional parameters:</source>
          <target state="translated">TypeScriptは、ソースの引数を使用してターゲットの署名を呼び出すことができるかどうか、&lt;em&gt;および無関係な引数が許可&lt;/em&gt;されるかどうかを確認することによって、署名の互換性を解決します。たとえば、このコードは、オプションのパラメーターを使用して署名が正しく記述されている場合にのみバグを公開します。</target>
        </trans-unit>
        <trans-unit id="8a0c2fdfc90997d639e7e23066198c7742ba74d7" translate="yes" xml:space="preserve">
          <source>TypeScript ships with three JSX modes: &lt;code&gt;preserve&lt;/code&gt;, &lt;code&gt;react&lt;/code&gt;, and &lt;code&gt;react-native&lt;/code&gt;. These modes only affect the emit stage - type checking is unaffected. The &lt;code&gt;preserve&lt;/code&gt; mode will keep the JSX as part of the output to be further consumed by another transform step (e.g. &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;). Additionally the output will have a &lt;code&gt;.jsx&lt;/code&gt; file extension. The &lt;code&gt;react&lt;/code&gt; mode will emit &lt;code&gt;React.createElement&lt;/code&gt;, does not need to go through a JSX transformation before use, and the output will have a &lt;code&gt;.js&lt;/code&gt; file extension. The &lt;code&gt;react-native&lt;/code&gt; mode is the equivalent of &lt;code&gt;preserve&lt;/code&gt; in that it keeps all JSX, but the output will instead have a &lt;code&gt;.js&lt;/code&gt; file extension.</source>
          <target state="translated">TypeScript に &lt;code&gt;react&lt;/code&gt; 、 &lt;code&gt;preserve&lt;/code&gt; 、反応、および &lt;code&gt;react-native&lt;/code&gt; 3つのJSXモードが付属しています。これらのモードは、発行ステージにのみ影響します。タイプチェックは影響を受けません。 &lt;code&gt;preserve&lt;/code&gt; モードは、さらに別の変換ステップ（例えばによって消費される出力の一部としてJSXを維持します&lt;a href=&quot;https://babeljs.io/&quot;&gt;バベル&lt;/a&gt;）。さらに、出力には &lt;code&gt;.jsx&lt;/code&gt; ファイル拡張子が付きます。 &lt;code&gt;react&lt;/code&gt; 発光するモード &lt;code&gt;React.createElement&lt;/code&gt; は、使用前にJSX変換を通過する必要はありません、と出力があります &lt;code&gt;.js&lt;/code&gt; ファイル拡張子を。 &lt;code&gt;react-native&lt;/code&gt; モードの等価で &lt;code&gt;preserve&lt;/code&gt; JSXはすべて保持されますが、出力には &lt;code&gt;.js&lt;/code&gt; ファイル拡張子が付きます。</target>
        </trans-unit>
        <trans-unit id="f2cd47e8e27537ecdbea6c76c0813851141bdf88" translate="yes" xml:space="preserve">
          <source>TypeScript ships with two JSX modes: &lt;code&gt;preserve&lt;/code&gt; and &lt;code&gt;react&lt;/code&gt;.</source>
          <target state="translated">TypeScriptには、2つのJSXモード（ &lt;code&gt;preserve&lt;/code&gt; と &lt;code&gt;react&lt;/code&gt; 付属しています。</target>
        </trans-unit>
        <trans-unit id="00a935a3f7579d721385691d1b84e679d883dff3" translate="yes" xml:space="preserve">
          <source>TypeScript stands in an unusual relationship to JavaScript. TypeScript offers all of JavaScript&amp;rsquo;s features, and an additional layer on top of these: TypeScript&amp;rsquo;s type system.</source>
          <target state="translated">TypeScriptはJavaScriptとは珍しい関係にあります。TypeScriptは、JavaScriptのすべての機能と、これらの上に追加のレイヤーを提供します。TypeScriptの型システム。</target>
        </trans-unit>
        <trans-unit id="87bbddad2b4d434df60aaa882de571170d946407" translate="yes" xml:space="preserve">
          <source>TypeScript strives to only include features which are confirmed to be added into the JavaScript language.</source>
          <target state="translated">TypeScriptは、JavaScript言語に追加されることが確認された機能のみを含めるように努めています。</target>
        </trans-unit>
        <trans-unit id="e350ae43b9a5687315f9cb51fc6866456b882a7f" translate="yes" xml:space="preserve">
          <source>TypeScript supports a wide spectrum of JavaScript patterns and defaults to allowing for quite a lot of flexibility in accommodating these styles. Often the safety and potential scalability of a codebase can be at odds with some of these techniques.</source>
          <target state="translated">TypeScriptは幅広いJavaScriptのパターンをサポートしており、デフォルトではこれらのスタイルに対応するためにかなりの柔軟性を持っています。コードベースの安全性や潜在的なスケーラビリティは、これらのテクニックのいくつかと対立することがよくあります。</target>
        </trans-unit>
        <trans-unit id="a68cb065a26c6d898de1ad77c499a5380c7336c0" translate="yes" xml:space="preserve">
          <source>TypeScript supports getters/setters as a way of intercepting accesses to a member of an object. This gives you a way of having finer-grained control over how a member is accessed on each object.</source>
          <target state="translated">TypeScript は、オブジェクトのメンバへのアクセスを傍受する方法としてゲッター/セッターをサポートしています。これにより、各オブジェクトのメンバがどのようにアクセスされるかをより細かく制御することができます。</target>
        </trans-unit>
        <trans-unit id="b66debd096de5790d32615c82aeae20dd89c1b00" translate="yes" xml:space="preserve">
          <source>TypeScript treats a namespace import (i.e. &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt;) for a CommonJS/AMD/UMD module as equivalent to &lt;code&gt;const foo = require(&quot;foo&quot;)&lt;/code&gt;.Things are simple here, but they don&amp;rsquo;t work out if the primary object being imported is a primitive or a class or a function. ECMAScript spec stipulates that a namespace record is a plain object, and that a namespace import (&lt;code&gt;foo&lt;/code&gt; in the example above) is not callable, though allowed by TypeScript</source>
          <target state="translated">TypeScriptは、CommonJS / AMD / UMDモジュールの名前空間インポート（つまり、 &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt; ）を、 &lt;code&gt;const foo = require(&quot;foo&quot;)&lt;/code&gt; 同等に扱います。ここでは簡単ですが、次の場合はうまくいきません。インポートされるプライマリオブジェクトは、プリミティブ、クラス、または関数です。ECMAScript仕様では、名前空間レコードはプレーンオブジェクトであり、名前空間のインポート（上記の例では &lt;code&gt;foo&lt;/code&gt; ）は、TypeScriptでは許可されていますが、呼び出し可能ではないことが規定されています</target>
        </trans-unit>
        <trans-unit id="190d779979c1c225024b4faf8c71539ad6be2768" translate="yes" xml:space="preserve">
          <source>TypeScript used the &lt;code&gt;module&lt;/code&gt; keyword to define both &amp;ldquo;internal modules&amp;rdquo; and &amp;ldquo;external modules&amp;rdquo;; this has been a bit of confusion for developers new to TypeScript. &amp;ldquo;Internal modules&amp;rdquo; are closer to what most people would call a namespace; likewise, &amp;ldquo;external modules&amp;rdquo; in JS speak really just are modules now.</source>
          <target state="translated">TypeScriptは &lt;code&gt;module&lt;/code&gt; キーワードを使用して、「内部モジュール」と「外部モジュール」の両方を定義しました。TypeScriptを初めて使用する開発者にとって、これは少し混乱しています。「内部モジュール」は、ほとんどの人が名前空間と呼ぶものに近いものです。同様に、JSの「外部モジュール」は、まさに今のモジュールです。</target>
        </trans-unit>
        <trans-unit id="1b58b6b726ed6ef37d5ab19f3e08450acedef197" translate="yes" xml:space="preserve">
          <source>TypeScript uses a file called &lt;code&gt;tsconfig.json&lt;/code&gt; for managing your project&amp;rsquo;s options, such as which files you want to include, and what sorts of checking you want to perform. Let&amp;rsquo;s create a bare-bones one for our project:</source>
          <target state="translated">TypeScriptは、 &lt;code&gt;tsconfig.json&lt;/code&gt; というファイルを使用して、含めるファイルや実行するチェックの種類など、プロジェクトのオプションを管理します。私たちのプロジェクトに必要最小限のものを作成しましょう：</target>
        </trans-unit>
        <trans-unit id="f56d1e973d936e7e25808ece950aef4bac63d378" translate="yes" xml:space="preserve">
          <source>TypeScript uses the &lt;a href=&quot;http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components&quot;&gt;same convention that React does&lt;/a&gt; for distinguishing between these. An intrinsic element always begins with a lowercase letter, and a value-based element always begins with an uppercase letter.</source>
          <target state="translated">TypeScriptは、&lt;a href=&quot;http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components&quot;&gt;Reactが&lt;/a&gt;これらを区別するために行うのと同じ規則を使用します。組み込み要素は常に小文字で始まり、値ベースの要素は常に大文字で始まります。</target>
        </trans-unit>
        <trans-unit id="7fed99366cf22869561ff0cde11374db19d9f07b" translate="yes" xml:space="preserve">
          <source>TypeScript uses the type &lt;code&gt;any&lt;/code&gt; whenever it can&amp;rsquo;t tell what the type of an expression should be. Compared to &lt;code&gt;Dynamic&lt;/code&gt;, calling &lt;code&gt;any&lt;/code&gt; a type is an overstatement. It just turns off the type checker wherever it appears. For example, you can push any value into an &lt;code&gt;any[]&lt;/code&gt; without marking the value in any way:</source>
          <target state="translated">TypeScriptは、式のタイプがどうあるべきかを判断できない &lt;code&gt;any&lt;/code&gt; 常に、タイプanyを使用します。 &lt;code&gt;Dynamic&lt;/code&gt; と比較して、 &lt;code&gt;any&lt;/code&gt; のタイプを呼び出すことは誇張です。表示される場所でタイプチェッカーをオフにするだけです。たとえば、値をマークせずに、任意の値を &lt;code&gt;any[]&lt;/code&gt; プッシュできます。</target>
        </trans-unit>
        <trans-unit id="a94cd2357ef6caf93ae4025491d6f6435c0dfc38" translate="yes" xml:space="preserve">
          <source>TypeScript will also now compute enum values when possible:</source>
          <target state="translated">TypeScript は、可能な限り enum 値を計算するようになりました。</target>
        </trans-unit>
        <trans-unit id="363493eaf871474aebe9c026f44b9b57be878dd1" translate="yes" xml:space="preserve">
          <source>TypeScript will also warn about unreachable code and labels, which you can disable with &lt;code&gt;allowUnreachableCode&lt;/code&gt; and &lt;code&gt;allowUnusedLabels&lt;/code&gt; respectively.</source>
          <target state="translated">TypeScriptは到達不可能なコードとラベルについても警告します。 &lt;code&gt;allowUnusedLabels&lt;/code&gt; 、 &lt;code&gt;allowUnreachableCode&lt;/code&gt; とallowUnusedLabelsでそれぞれ無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="e8a61643ec3271fd661861cae15f39927b074e83" translate="yes" xml:space="preserve">
          <source>TypeScript will mimic the Node.js run-time resolution strategy in order to locate definition files for modules at compile-time. To accomplish this, TypeScript overlays the TypeScript source file extensions (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and &lt;code&gt;.d.ts&lt;/code&gt;) over Node&amp;rsquo;s resolution logic. TypeScript will also use a field in &lt;code&gt;package.json&lt;/code&gt; named &lt;code&gt;&quot;types&quot;&lt;/code&gt; to mirror the purpose of &lt;code&gt;&quot;main&quot;&lt;/code&gt; - the compiler will use it to find the &amp;ldquo;main&amp;rdquo; definition file to consult.</source>
          <target state="translated">TypeScriptは、コンパイル時にモジュールの定義ファイルを見つけるために、Node.js実行時解決戦略を模倣します。これを実現するために、TypeScriptは、ノードの解決ロジック上にTypeScriptソースファイル拡張子（ &lt;code&gt;.ts&lt;/code&gt; 、 &lt;code&gt;.tsx&lt;/code&gt; 、および &lt;code&gt;.d.ts&lt;/code&gt; ）をオーバーレイします。TypeScriptはまた、 &lt;code&gt;&quot;types&quot;&lt;/code&gt; という名前の &lt;code&gt;package.json&lt;/code&gt; 内のフィールドを使用して、 &lt;code&gt;&quot;main&quot;&lt;/code&gt; 目的を反映します-コンパイラーはそれを使用して、参照する「main」定義ファイルを見つけます。</target>
        </trans-unit>
        <trans-unit id="d20fd8b3bcedf7d11d40c55cf087585df77e7708" translate="yes" xml:space="preserve">
          <source>TypeScript will say that you can&amp;rsquo;t assign to &lt;code&gt;color&lt;/code&gt; and &lt;code&gt;volume&lt;/code&gt; because it first figured out the type of &lt;code&gt;options&lt;/code&gt; as &lt;code&gt;{}&lt;/code&gt; which doesn&amp;rsquo;t have any properties. If you instead moved the declarations into the object literal themselves, you&amp;rsquo;d get no errors:</source>
          <target state="translated">TypeScriptは、プロパティのない &lt;code&gt;{}&lt;/code&gt; として &lt;code&gt;options&lt;/code&gt; のタイプを最初に見つけたため、 &lt;code&gt;color&lt;/code&gt; と &lt;code&gt;volume&lt;/code&gt; 割り当てることができないと言います。代わりに宣言をオブジェクトリテラル自体に移動した場合、エラーは発生しません。</target>
        </trans-unit>
        <trans-unit id="b835b008208b64fdab50a54358ce702512ec0e47" translate="yes" xml:space="preserve">
          <source>TypeScript will unify type parameters when comparing two generic functions.</source>
          <target state="translated">TypeScriptは、2つの汎用関数を比較する際に、型パラメータを統一します。</target>
        </trans-unit>
        <trans-unit id="3f0ca513c7dc163be9ae8d550d8e42ef8b211838" translate="yes" xml:space="preserve">
          <source>TypeScript will usually add a compiler flag for the latter set of errors, and by default these are not enabled.</source>
          <target state="translated">TypeScript は通常、後者のエラーに対してコンパイラフラグを追加し、デフォルトでは有効になっていません。</target>
        </trans-unit>
        <trans-unit id="38bf0c53ba4aa0ec1095c2375e35e8a2ae0dd7f7" translate="yes" xml:space="preserve">
          <source>TypeScript with &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#strict&quot;&gt;&lt;code&gt;strict&lt;/code&gt;&lt;/a&gt; enabled</source>
          <target state="translated">&lt;a href=&quot;https://www.typescriptlang.org/tsconfig#strict&quot;&gt; &lt;code&gt;strict&lt;/code&gt; が&lt;/a&gt;有効になっているTypeScript</target>
        </trans-unit>
        <trans-unit id="68e22e69ba01fd253f8ca30b84167b834c8db6f0" translate="yes" xml:space="preserve">
          <source>TypeScript with JavaScript</source>
          <target state="translated">JavaScriptを使ったTypeScript</target>
        </trans-unit>
        <trans-unit id="cd367b77df54efafc687e3d2bce712bf9f604879" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s &lt;code&gt;--pretty&lt;/code&gt; flag can make error messages easier to read and manage. &lt;code&gt;--pretty&lt;/code&gt; now uses colors for file names, diagnostic codes, and line numbers. File names and positions are now also formatted to allow navigation in common terminals (e.g. Visual Studio Code terminal).</source>
          <target state="translated">TypeScriptの &lt;code&gt;--pretty&lt;/code&gt; フラグを使用すると、エラーメッセージを読みやすく、管理しやすくなります。 &lt;code&gt;--pretty&lt;/code&gt; は、ファイル名、診断コード、行番号に色を使用するようになりました。ファイル名と位置もフォーマットされ、一般的なターミナル（Visual Studio Codeターミナルなど）でナビゲーションできるようになりました。</target>
        </trans-unit>
        <trans-unit id="82367d5505123220713eb9aa76910332cb1314fc" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s &lt;code&gt;--watch&lt;/code&gt; mode now clears the screen after a re-compilation is requested.</source>
          <target state="translated">TypeScriptの &lt;code&gt;--watch&lt;/code&gt; モードは、再コンパイルが要求された後に画面をクリアするようになりました。</target>
        </trans-unit>
        <trans-unit id="e240610ed534bc76d20bc7bebb7e8fd4ee492fe3" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s built-in formatter now supports semicolon insertion and removal at locations where a trailing semicolon is optional due to JavaScript&amp;rsquo;s automatic semicolon insertion (ASI) rules. The setting is available now in &lt;a href=&quot;https://code.visualstudio.com/insiders/&quot;&gt;Visual Studio Code Insiders&lt;/a&gt;, and will be available in Visual Studio 16.4 Preview 2 in the Tools Options menu.</source>
          <target state="translated">TypeScriptの組み込みフォーマッタは、JavaScriptの自動セミコロン挿入（ASI）ルールにより、末尾のセミコロンがオプションである場所でのセミコロンの挿入と削除をサポートするようになりました。この設定は&lt;a href=&quot;https://code.visualstudio.com/insiders/&quot;&gt;Visual Studio Code Insiders&lt;/a&gt;で利用できるようになり、[ツールオプション]メニューのVisual Studio 16.4プレビュー2でも利用できるようになります。</target>
        </trans-unit>
        <trans-unit id="08c6179dcf1375ce19533b773a6b25765f412389" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s project references provide us with an easy way to break codebases up to give us faster compiles. Unfortunately, editing a project whose dependencies hadn&amp;rsquo;t been built (or whose output was out of date) meant that the editing experience wouldn&amp;rsquo;t work well.</source>
          <target state="translated">TypeScriptのプロジェクト参照は、コードベースを分解してコンパイルを高速化する簡単な方法を提供します。残念ながら、依存関係が構築されていない（または出力が古い）プロジェクトを編集すると、編集エクスペリエンスがうまく機能しませんでした。</target>
        </trans-unit>
        <trans-unit id="8e33dd464f3004daae495bfbf61b1d8f4515a8bc" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s structural type system was designed based on how JavaScript code is typically written. Because JavaScript widely uses anonymous objects like function expressions and object literals, it&amp;rsquo;s much more natural to represent the kinds of relationships found in JavaScript libraries with a structural type system instead of a nominal one.</source>
          <target state="translated">TypeScriptの構造型システムは、JavaScriptコードの一般的な記述方法に基づいて設計されました。JavaScriptは、関数式やオブジェクトリテラルなどの匿名オブジェクトを広く使用しているため、JavaScriptライブラリで見られる種類の関係を、名目的なものではなく構造型システムで表現する方がはるかに自然です。</target>
        </trans-unit>
        <trans-unit id="bb4cd132d17765763f4ec7ad513fe8c0ba6e5307" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s type system allows certain operations that can&amp;rsquo;t be known at compile-time to be safe. When a type system has this property, it is said to not be &amp;ldquo;sound&amp;rdquo;. The places where TypeScript allows unsound behavior were carefully considered, and throughout this document we&amp;rsquo;ll explain where these happen and the motivating scenarios behind them.</source>
          <target state="translated">TypeScriptの型システムを使用すると、コンパイル時に認識できない特定の操作を安全にすることができます。型システムにこの特性がある場合、それは「健全」ではないと言われます。TypeScriptが不健全な動作を許可する場所は慎重に検討されました。このドキュメント全体で、これらが発生する場所とその背後にある動機付けのシナリオについて説明します。</target>
        </trans-unit>
        <trans-unit id="bc25ef434b456b8e9b3f38204ffc2330bc4fb76d" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s type system is &lt;em&gt;structural&lt;/em&gt;, not nominal: We can use &lt;code&gt;obj&lt;/code&gt; as a &lt;code&gt;Pointlike&lt;/code&gt; because it has &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; properties that are both numbers. The relationships between types are determined by the properties they contain, not whether they were declared with some particular relationship.</source>
          <target state="translated">活字体の型システムは、&lt;em&gt;構造的な&lt;/em&gt;名目ない、：私たちは使用することができ &lt;code&gt;obj&lt;/code&gt; として &lt;code&gt;Pointlike&lt;/code&gt; 、それは持っているので &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方の数値である特性を。タイプ間の関係は、特定の関係で宣言されているかどうかではなく、タイプに含まれるプロパティによって決定されます。</target>
        </trans-unit>
        <trans-unit id="699fd96b329576b8e4f3bea33063886228ddc2e0" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s type system is also &lt;em&gt;not reified&lt;/em&gt;: There&amp;rsquo;s nothing at runtime that will tell us that &lt;code&gt;obj&lt;/code&gt; is &lt;code&gt;Pointlike&lt;/code&gt;. In fact, the &lt;code&gt;Pointlike&lt;/code&gt; type is not present &lt;em&gt;in any form&lt;/em&gt; at runtime.</source>
          <target state="translated">活字体の型システムもされ&lt;em&gt;具体化ではない&lt;/em&gt;。ということを教えてくれる、実行時には何もありません &lt;code&gt;obj&lt;/code&gt; がある &lt;code&gt;Pointlike&lt;/code&gt; 。実際、 &lt;code&gt;Pointlike&lt;/code&gt; 型は、実行時&lt;em&gt;にどのような形式&lt;/em&gt;で&lt;em&gt;も&lt;/em&gt;存在&lt;em&gt;し&lt;/em&gt;ません。</target>
        </trans-unit>
        <trans-unit id="7dd0cf7a946fdeea7bb4261a202a46f6a006f525" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s type system offers many of the same benefits, such as better code completion, earlier detection of errors, and clearer communication between parts of your program. While TypeScript provides many familiar features for these developers, it&amp;rsquo;s worth stepping back to see how JavaScript (and therefore TypeScript) differ from traditional OOP languages. Understanding these differences will help you write better JavaScript code, and avoid common pitfalls that programmers who go straight from C#/Java to TypeScript may fall in to.</source>
          <target state="translated">TypeScriptの型システムは、コードの完成度の向上、エラーの早期検出、プログラムの各部分間の通信の明確化など、同じ利点の多くを提供します。TypeScriptはこれらの開発者に多くの使い慣れた機能を提供しますが、JavaScript（したがってTypeScript）が従来のOOP言語とどのように異なるかを確認することは価値があります。これらの違いを理解することで、より優れたJavaScriptコードを記述し、C＃/ JavaからTypeScriptに直接移行するプログラマーが陥る可能性のある一般的な落とし穴を回避できます。</target>
        </trans-unit>
        <trans-unit id="2727a72bb787115b0b255c31ef21d7adbe04c368" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s understanding of a &lt;em&gt;type&lt;/em&gt; is actually quite different from C# or Java&amp;rsquo;s. Let&amp;rsquo;s explore some differences.</source>
          <target state="translated">TypeScriptによる&lt;em&gt;型&lt;/em&gt;の理解は、実際にはC＃やJavaの理解とはかなり異なります。いくつかの違いを調べてみましょう。</target>
        </trans-unit>
        <trans-unit id="349e8ba90638f01a95ebe613d90e5ffbcee9736b" translate="yes" xml:space="preserve">
          <source>TypeScript, like JavaScript, allows you to work with arrays of values. Array types can be written in one of two ways. In the first, you use the type of the elements followed by &lt;code&gt;[]&lt;/code&gt; to denote an array of that element type:</source>
          <target state="translated">TypeScriptは、JavaScriptと同様に、値の配列を操作できます。配列型は2つの方法のいずれかで記述できます。最初の例では、要素のタイプに続けて &lt;code&gt;[]&lt;/code&gt; を使用して、その要素タイプの配列を示しています。</target>
        </trans-unit>
        <trans-unit id="4ad04619aba3f2f4ed81caa26fedf4a7d7810729" translate="yes" xml:space="preserve">
          <source>TypeScript-Preview</source>
          <target state="translated">TypeScript-Preview</target>
        </trans-unit>
        <trans-unit id="0fbb22e14b529ffecc219e421d78a3fd5f50af73" translate="yes" xml:space="preserve">
          <source>TypeScript: A Static Type Checker</source>
          <target state="translated">TypeScript。静的型チェッカー</target>
        </trans-unit>
        <trans-unit id="41d9bbe35312804100303ce4556c7c954c09e309" translate="yes" xml:space="preserve">
          <source>TypeScriptAdditionalFlags</source>
          <target state="translated">TypeScriptAdditionalFlags</target>
        </trans-unit>
        <trans-unit id="7b5fe2a5e0980eb4438ba0537940cad4dba1cbf4" translate="yes" xml:space="preserve">
          <source>TypeScriptAllowSyntheticDefaultImports</source>
          <target state="translated">TypeScriptAllowSyntheticDefaultImports</target>
        </trans-unit>
        <trans-unit id="a94bfbe88239bd8121e18f907e172dde0a5dee8d" translate="yes" xml:space="preserve">
          <source>TypeScriptAllowUnreachableCode</source>
          <target state="translated">TypeScriptAllowUnreachableCode</target>
        </trans-unit>
        <trans-unit id="a57b98365d2468c29049e5c8c8ee824604a3fdb7" translate="yes" xml:space="preserve">
          <source>TypeScriptAllowUnusedLabels</source>
          <target state="translated">TypeScriptAllowUnusedLabels</target>
        </trans-unit>
        <trans-unit id="52c7a27301fde259e8f6bb99fc56cb8133f9b303" translate="yes" xml:space="preserve">
          <source>TypeScriptAlwaysStrict</source>
          <target state="translated">TypeScriptAlwaysStrict</target>
        </trans-unit>
        <trans-unit id="2ed81307b38a7333d37096546abf4a0b57b93c74" translate="yes" xml:space="preserve">
          <source>TypeScriptBaseUrl</source>
          <target state="translated">TypeScriptBaseUrl</target>
        </trans-unit>
        <trans-unit id="77f797b2abb4954f5643abb4b5b80d59868c9236" translate="yes" xml:space="preserve">
          <source>TypeScriptCharset</source>
          <target state="translated">TypeScriptCharset</target>
        </trans-unit>
        <trans-unit id="107cd94d243e6194c069f50feafef3b1230a7556" translate="yes" xml:space="preserve">
          <source>TypeScriptCompileBlocked</source>
          <target state="translated">TypeScriptCompileBlocked</target>
        </trans-unit>
        <trans-unit id="7acf8c8a12467f8aca42a0fb5a3ef1f764482e71" translate="yes" xml:space="preserve">
          <source>TypeScriptDeclarationDir</source>
          <target state="translated">TypeScriptDeclarationDir</target>
        </trans-unit>
        <trans-unit id="4a2236f58ea00d2b0bb17b6cea7aca0c8a68c053" translate="yes" xml:space="preserve">
          <source>TypeScriptESModuleInterop</source>
          <target state="translated">TypeScriptESModuleInterop</target>
        </trans-unit>
        <trans-unit id="55c811b895566e510d35f99a3a36ec8a3177f330" translate="yes" xml:space="preserve">
          <source>TypeScriptEmitBOM</source>
          <target state="translated">TypeScriptEmitBOM</target>
        </trans-unit>
        <trans-unit id="b2959142651db2ba36f7a76acb1a7cd0464dd2f0" translate="yes" xml:space="preserve">
          <source>TypeScriptEmitDeclarationOnly</source>
          <target state="translated">TypeScriptEmitDeclarationOnly</target>
        </trans-unit>
        <trans-unit id="17656226f24afbbb0494dc47d1fdf5cb6aec6e7e" translate="yes" xml:space="preserve">
          <source>TypeScriptEmitDecoratorMetadata</source>
          <target state="translated">TypeScriptEmitDecoratorMetadata</target>
        </trans-unit>
        <trans-unit id="f1a24003307b278d63a345cf4646070ee3538d81" translate="yes" xml:space="preserve">
          <source>TypeScriptExperimentalAsyncFunctions</source>
          <target state="translated">TypeScriptExperimentalAsyncFunctions</target>
        </trans-unit>
        <trans-unit id="f178eb0d68749f84390526fcfcf73643580199b8" translate="yes" xml:space="preserve">
          <source>TypeScriptExperimentalDecorators</source>
          <target state="translated">TypeScriptExperimentalDecorators</target>
        </trans-unit>
        <trans-unit id="227102f3c5d5c0c4fe35d5a94e14769df56ea3ea" translate="yes" xml:space="preserve">
          <source>TypeScriptForceConsistentCasingInFileNames</source>
          <target state="translated">TypeScriptForceConsistentCasingInFileNames</target>
        </trans-unit>
        <trans-unit id="e8221bda0f5ae2cb80b553adafbf9c7d7eb1ff79" translate="yes" xml:space="preserve">
          <source>TypeScriptGeneratesDeclarations</source>
          <target state="translated">TypeScriptGeneratesDeclarations</target>
        </trans-unit>
        <trans-unit id="12faa091e4a57a36c933420258af4a9f60dccc85" translate="yes" xml:space="preserve">
          <source>TypeScriptImportHelpers</source>
          <target state="translated">TypeScriptImportHelpers</target>
        </trans-unit>
        <trans-unit id="ee1203ba67f873be0ddd284d0922dc4eaed56181" translate="yes" xml:space="preserve">
          <source>TypeScriptInlineSourceMap</source>
          <target state="translated">TypeScriptInlineSourceMap</target>
        </trans-unit>
        <trans-unit id="388355e20cca01322235dfa01c312ca0d6781b5a" translate="yes" xml:space="preserve">
          <source>TypeScriptInlineSources</source>
          <target state="translated">TypeScriptInlineSources</target>
        </trans-unit>
        <trans-unit id="d77acf48160dec4408ea9726aa2e65d9aca96302" translate="yes" xml:space="preserve">
          <source>TypeScriptIsolatedModules</source>
          <target state="translated">TypeScriptIsolatedModules</target>
        </trans-unit>
        <trans-unit id="956314972e52b72d9e36530ee0a4e72a92acae0b" translate="yes" xml:space="preserve">
          <source>TypeScriptJSXEmit</source>
          <target state="translated">TypeScriptJSXEmit</target>
        </trans-unit>
        <trans-unit id="a67c071d130c25aefdb45b19dfa130ff6bb485ad" translate="yes" xml:space="preserve">
          <source>TypeScriptJSXFactory</source>
          <target state="translated">TypeScriptJSXFactory</target>
        </trans-unit>
        <trans-unit id="37a4427a09452551dd538cba6e5a87a9c65983c9" translate="yes" xml:space="preserve">
          <source>TypeScriptJSXFragmentFactory</source>
          <target state="translated">TypeScriptJSXFragmentFactory</target>
        </trans-unit>
        <trans-unit id="4552cc5179a4f2f2d43bbca69cfe48ae1d8a59ca" translate="yes" xml:space="preserve">
          <source>TypeScriptLib</source>
          <target state="translated">TypeScriptLib</target>
        </trans-unit>
        <trans-unit id="0572909efb507dda301b9d8012fab7e5de772948" translate="yes" xml:space="preserve">
          <source>TypeScriptMapRoot</source>
          <target state="translated">TypeScriptMapRoot</target>
        </trans-unit>
        <trans-unit id="dc7b169788198faee3555056c08f9f57327e0a3f" translate="yes" xml:space="preserve">
          <source>TypeScriptModuleKind</source>
          <target state="translated">TypeScriptModuleKind</target>
        </trans-unit>
        <trans-unit id="421c0ae622f44c1602b14f2b708d2cca0d2934ce" translate="yes" xml:space="preserve">
          <source>TypeScriptModuleResolution</source>
          <target state="translated">TypeScriptModuleResolution</target>
        </trans-unit>
        <trans-unit id="35fa542971e052e37cc4839000b5258adf72a14c" translate="yes" xml:space="preserve">
          <source>TypeScriptNewLine</source>
          <target state="translated">TypeScriptNewLine</target>
        </trans-unit>
        <trans-unit id="fc2a8ef1565c45f435f3d5ef342d1c6dae60cbb5" translate="yes" xml:space="preserve">
          <source>TypeScriptNoEmitHelpers</source>
          <target state="translated">TypeScriptNoEmitHelpers</target>
        </trans-unit>
        <trans-unit id="e36e19ff5e1f6a8202b09c668028ec57276c68b9" translate="yes" xml:space="preserve">
          <source>TypeScriptNoEmitOnError</source>
          <target state="translated">TypeScriptNoEmitOnError</target>
        </trans-unit>
        <trans-unit id="5b756225451ecee18834373559b43fedcb96fba8" translate="yes" xml:space="preserve">
          <source>TypeScriptNoFallthroughCasesInSwitch</source>
          <target state="translated">TypeScriptNoFallthroughCasesInSwitch</target>
        </trans-unit>
        <trans-unit id="d92e432f5565e45efa98aec9e0c61f938d26c756" translate="yes" xml:space="preserve">
          <source>TypeScriptNoImplicitAny</source>
          <target state="translated">TypeScriptNoImplicitAny</target>
        </trans-unit>
        <trans-unit id="1c9c8201c130add485ca511eb79ea6e375bc4375" translate="yes" xml:space="preserve">
          <source>TypeScriptNoImplicitReturns</source>
          <target state="translated">TypeScriptNoImplicitReturns</target>
        </trans-unit>
        <trans-unit id="3f55bf3dfa28bf03f3b28f94aa19817851b78cae" translate="yes" xml:space="preserve">
          <source>TypeScriptNoImplicitThis</source>
          <target state="translated">TypeScriptNoImplicitThis</target>
        </trans-unit>
        <trans-unit id="6f256f510247fb48347ab1a84a79bfdc18f35187" translate="yes" xml:space="preserve">
          <source>TypeScriptNoImplicitUseStrict</source>
          <target state="translated">TypeScriptNoImplicitUseStrict</target>
        </trans-unit>
        <trans-unit id="8bd63af2b503b90aadf320b0938c7cc2e9e1080f" translate="yes" xml:space="preserve">
          <source>TypeScriptNoLib</source>
          <target state="translated">TypeScriptNoLib</target>
        </trans-unit>
        <trans-unit id="aba68b0d2bfe600c1b7505f9cf090259fafedf3a" translate="yes" xml:space="preserve">
          <source>TypeScriptNoResolve</source>
          <target state="translated">TypeScriptNoResolve</target>
        </trans-unit>
        <trans-unit id="362c0511319630974131db1f54ca0f8546597ce7" translate="yes" xml:space="preserve">
          <source>TypeScriptNoStrictGenericChecks</source>
          <target state="translated">TypeScriptNoStrictGenericChecks</target>
        </trans-unit>
        <trans-unit id="dfa69886ed42a2dc63f9a0eab77d8450ce96b009" translate="yes" xml:space="preserve">
          <source>TypeScriptNoUnusedLocals</source>
          <target state="translated">TypeScriptNoUnusedLocals</target>
        </trans-unit>
        <trans-unit id="cefd9f6aa4a0ee3b0be73fb43be3ecc77bfe22df" translate="yes" xml:space="preserve">
          <source>TypeScriptNoUnusedParameters</source>
          <target state="translated">TypeScriptNoUnusedParameters</target>
        </trans-unit>
        <trans-unit id="6565a78c53fe02fdb81995bb6c6ec68f1f0ea3bd" translate="yes" xml:space="preserve">
          <source>TypeScriptOutDir</source>
          <target state="translated">TypeScriptOutDir</target>
        </trans-unit>
        <trans-unit id="b14c0569c9dd07bb52cefa5e53a9ee362f59b00f" translate="yes" xml:space="preserve">
          <source>TypeScriptOutFile</source>
          <target state="translated">TypeScriptOutFile</target>
        </trans-unit>
        <trans-unit id="644b7783acc77f0caa187daf9c367ba62b739548" translate="yes" xml:space="preserve">
          <source>TypeScriptPreserveConstEnums</source>
          <target state="translated">TypeScriptPreserveConstEnums</target>
        </trans-unit>
        <trans-unit id="44c9e768eb6070e00bdba352e27ce7e68b24160f" translate="yes" xml:space="preserve">
          <source>TypeScriptPreserveSymlinks</source>
          <target state="translated">TypeScriptPreserveSymlinks</target>
        </trans-unit>
        <trans-unit id="4130284b0addaca5f98609c12c577055315ad705" translate="yes" xml:space="preserve">
          <source>TypeScriptReactNamespace</source>
          <target state="translated">TypeScriptReactNamespace</target>
        </trans-unit>
        <trans-unit id="373f7134beec8752f28917f8c2d07c6972a8eda7" translate="yes" xml:space="preserve">
          <source>TypeScriptRemoveComments</source>
          <target state="translated">TypeScriptRemoveComments</target>
        </trans-unit>
        <trans-unit id="72de35523759783c4427070755e0bb5453621f68" translate="yes" xml:space="preserve">
          <source>TypeScriptRootDir</source>
          <target state="translated">TypeScriptRootDir</target>
        </trans-unit>
        <trans-unit id="6aa743721c9942df651b926d8a6b9d1d8b06dee1" translate="yes" xml:space="preserve">
          <source>TypeScriptSkipDefaultLibCheck</source>
          <target state="translated">TypeScriptSkipDefaultLibCheck</target>
        </trans-unit>
        <trans-unit id="8bfb0bbce64d6d061521026129b6afc021fdb739" translate="yes" xml:space="preserve">
          <source>TypeScriptSkipLibCheck</source>
          <target state="translated">TypeScriptSkipLibCheck</target>
        </trans-unit>
        <trans-unit id="11cea9751a4427f602e3999e641567437522451c" translate="yes" xml:space="preserve">
          <source>TypeScriptSourceMap</source>
          <target state="translated">TypeScriptSourceMap</target>
        </trans-unit>
        <trans-unit id="981b0099a78995ed3e09e63f3468ae20d833111d" translate="yes" xml:space="preserve">
          <source>TypeScriptSourceRoot</source>
          <target state="translated">TypeScriptSourceRoot</target>
        </trans-unit>
        <trans-unit id="144320f2ae79b3129b36ee19ddeac0b49fefd1cb" translate="yes" xml:space="preserve">
          <source>TypeScriptStrict</source>
          <target state="translated">TypeScriptStrict</target>
        </trans-unit>
        <trans-unit id="dd87b21546d155f9fa69bfbdc72090ba951be0b1" translate="yes" xml:space="preserve">
          <source>TypeScriptStrictFunctionTypes</source>
          <target state="translated">TypeScriptStrictFunctionTypes</target>
        </trans-unit>
        <trans-unit id="a6d54bf19b0c132487ec76f847985482640ea044" translate="yes" xml:space="preserve">
          <source>TypeScriptStrictNullChecks</source>
          <target state="translated">TypeScriptStrictNullChecks</target>
        </trans-unit>
        <trans-unit id="102ce2e8221cdb409f6a7a01055c5b3f52db3b57" translate="yes" xml:space="preserve">
          <source>TypeScriptStrictPropertyInitialization</source>
          <target state="translated">TypeScriptStrictPropertyInitialization</target>
        </trans-unit>
        <trans-unit id="565bf41241b63a69256bebd7801f835b429830df" translate="yes" xml:space="preserve">
          <source>TypeScriptStripInternal</source>
          <target state="translated">TypeScriptStripInternal</target>
        </trans-unit>
        <trans-unit id="558de0db52b8fdbbfefba7315f0e5b368e1bccc8" translate="yes" xml:space="preserve">
          <source>TypeScriptSuppressExcessPropertyErrors</source>
          <target state="translated">TypeScriptSuppressExcessPropertyErrors</target>
        </trans-unit>
        <trans-unit id="321f13b1fb2371cd5951fbfd893bddec800abf02" translate="yes" xml:space="preserve">
          <source>TypeScriptSuppressImplicitAnyIndexErrors</source>
          <target state="translated">TypeScriptSuppressImplicitAnyIndexErrors</target>
        </trans-unit>
        <trans-unit id="1df2c0c33e87134f7b9585a2fc5c306565947b0c" translate="yes" xml:space="preserve">
          <source>TypeScriptTarget</source>
          <target state="translated">TypeScriptTarget</target>
        </trans-unit>
        <trans-unit id="71d1dceb1918725eab2477bf3bc8195ca94011da" translate="yes" xml:space="preserve">
          <source>TypeScriptUseDefineForClassFields</source>
          <target state="translated">TypeScriptUseDefineForClassFields</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="d69d793fa4b90aab364868879e764b399a806ac0" translate="yes" xml:space="preserve">
          <source>Types - &lt;code&gt;types&lt;/code&gt;</source>
          <target state="translated">タイプ- &lt;code&gt;types&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f831a607f5835e209904afa74400f9d95d0c1f0" translate="yes" xml:space="preserve">
          <source>Types as Sets</source>
          <target state="translated">セットとしての型</target>
        </trans-unit>
        <trans-unit id="d0a23621c19578981ae69a01b97eead68c0765db" translate="yes" xml:space="preserve">
          <source>Types by Inference</source>
          <target state="translated">推論によるタイプ</target>
        </trans-unit>
        <trans-unit id="34915d42cc54d52a01ea82c5bdce2991a6ef1cbb" translate="yes" xml:space="preserve">
          <source>Types can exist in &lt;em&gt;namespaces&lt;/em&gt;. For example, if we have the declaration &lt;code&gt;let x: A.B.C&lt;/code&gt;, we say that the type &lt;code&gt;C&lt;/code&gt; comes from the &lt;code&gt;A.B&lt;/code&gt; namespace.</source>
          <target state="translated">型は&lt;em&gt;名前空間に&lt;/em&gt;存在でき&lt;em&gt;ます&lt;/em&gt;。たとえば、 &lt;code&gt;let x: A.B.C&lt;/code&gt; という宣言がある場合、タイプ &lt;code&gt;C&lt;/code&gt; は &lt;code&gt;A.B&lt;/code&gt; 名前空間に由来するとします。</target>
        </trans-unit>
        <trans-unit id="4ee9af272b9b52e38ff727c2aeeaf8e298f25123" translate="yes" xml:space="preserve">
          <source>Types in Modules</source>
          <target state="translated">モジュールのタイプ</target>
        </trans-unit>
        <trans-unit id="4983c5239614810aa77447dfbec17bd7041d4202" translate="yes" xml:space="preserve">
          <source>Types that have a common, singleton type property &amp;mdash; the &lt;em&gt;discriminant&lt;/em&gt;.</source>
          <target state="translated">共通のシングルトンタイププロパティを持つタイプ&amp;mdash; &lt;em&gt;判別式&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ab7315f529976c1e9046634d7f86b088c404171a" translate="yes" xml:space="preserve">
          <source>Types with a string index signature can be indexed using the &lt;code&gt;[]&lt;/code&gt; notation, but were not allowed to use the &lt;code&gt;.&lt;/code&gt;. Starting with TypeScript 2.2 using either should be allowed.</source>
          <target state="translated">文字列インデックスシグネチャを持つ型には、 &lt;code&gt;[]&lt;/code&gt; 表記を使用してインデックスを付けることができますが、の使用は許可されていません &lt;code&gt;.&lt;/code&gt; 。TypeScript 2.2以降では、どちらを使用しても許可されます。</target>
        </trans-unit>
        <trans-unit id="eefc11c2a4fd735c4e7783f6bcfa193306bfe237" translate="yes" xml:space="preserve">
          <source>Typescript borrows cast syntax from Closure. This lets you cast types to other types by adding a &lt;code&gt;@type&lt;/code&gt; tag before any parenthesized expression.</source>
          <target state="translated">TypescriptはClosureからキャスト構文を借用します。これにより、括弧で囲まれた式の前に &lt;code&gt;@type&lt;/code&gt; タグを追加することで、型を他の型にキャストできます。</target>
        </trans-unit>
        <trans-unit id="4c9358fb040ac0e3e60567763fe2b8b87185ed9b" translate="yes" xml:space="preserve">
          <source>Typescript is smart enough to infer the type of things in other contexts as well:</source>
          <target state="translated">Typescriptは、他の文脈でも物事の種類を推論できるほど賢いです。</target>
        </trans-unit>
        <trans-unit id="aa237f14744bf9c080f4239d70330d26fd6782a1" translate="yes" xml:space="preserve">
          <source>Typically, exporting from a module involves adding properties to a value like &lt;code&gt;exports&lt;/code&gt; or &lt;code&gt;module.exports&lt;/code&gt;. TypeScript allows you to use top-level export statements. For instance, if you exported a function like so:</source>
          <target state="translated">通常、モジュールからのエクスポートには、 &lt;code&gt;exports&lt;/code&gt; や &lt;code&gt;module.exports&lt;/code&gt; などの値へのプロパティの追加が含まれます。TypeScriptを使用すると、トップレベルのエクスポートステートメントを使用できます。たとえば、次のように関数をエクスポートしたとします。</target>
        </trans-unit>
        <trans-unit id="c2df529fd52e531e7ccfbb71ef147f00c590c161" translate="yes" xml:space="preserve">
          <source>Typing the function</source>
          <target state="translated">関数を入力する</target>
        </trans-unit>
        <trans-unit id="1184391d4660ab61ecb650550cc662801a4ad10e" translate="yes" xml:space="preserve">
          <source>UMD SimpleModule.js</source>
          <target state="translated">UMD SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="afb3e96e84eea2d4709a70ab3751ff0f583aa243" translate="yes" xml:space="preserve">
          <source>UMD modules</source>
          <target state="translated">UMDモジュール</target>
        </trans-unit>
        <trans-unit id="bf3e09cfd260f3d9900f06488088b667722b7926" translate="yes" xml:space="preserve">
          <source>Uglify</source>
          <target state="translated">Uglify</target>
        </trans-unit>
        <trans-unit id="0a5bbb787c318135c5901c5f8fb697634bd5bb32" translate="yes" xml:space="preserve">
          <source>Uglify compacts your code so that it takes less time to download.</source>
          <target state="translated">Uglifyはコードをコンパクトにして、ダウンロードにかかる時間を短縮します。</target>
        </trans-unit>
        <trans-unit id="ae386e47ac367ccb8dc289004083400a638ccbc5" translate="yes" xml:space="preserve">
          <source>Ultimately the goal of TypeScript is to type existing JavaScript constructs in the least disruptive way. For that reason, TypeScript 3.7 introduces a new concept called &amp;ldquo;assertion signatures&amp;rdquo; which model these assertion functions.</source>
          <target state="translated">TypeScriptの最終的な目的は、既存のJavaScript構成体を最小限の中断で入力することです。そのため、TypeScript 3.7では、これらのアサーション関数をモデル化する「アサーションシグネチャ」と呼ばれる新しいコンセプトが導入されています。</target>
        </trans-unit>
        <trans-unit id="4339e741945b9652bb1d49489e6a98543eef7bb2" translate="yes" xml:space="preserve">
          <source>Uncalled Function Checks</source>
          <target state="translated">呼び出されていない関数のチェック</target>
        </trans-unit>
        <trans-unit id="180b1f03e6992ccd4fc623bfa5063f77a58ada25" translate="yes" xml:space="preserve">
          <source>Unconditional calls to &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;define&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; または &lt;code&gt;define&lt;/code&gt; 無条件の呼び出し</target>
        </trans-unit>
        <trans-unit id="b497122fd6b99841feeae2f0b3528acf90c34986" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--strictFunctionTypes&lt;/code&gt; function type parameter positions are checked &lt;em&gt;contravariantly&lt;/em&gt; instead of &lt;em&gt;bivariantly&lt;/em&gt;. For some background on what variance means for function types check out &lt;a href=&quot;https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance&quot;&gt;What are covariance and contravariance?&lt;/a&gt;.</source>
          <target state="translated">下に &lt;code&gt;--strictFunctionTypes&lt;/code&gt; 関数型パラメータ位置がチェックされている&lt;em&gt;contravariantly&lt;/em&gt;の代わり&lt;em&gt;bivariantly&lt;/em&gt;。関数タイプの分散が何を意味するかについての背景について&lt;a href=&quot;https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance&quot;&gt;は、共分散と反分散とは何ですか？&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2346be489fd11bd810e990b096f9680008f047bd" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--strictFunctionTypes&lt;/code&gt; the first assignment is still permitted if &lt;code&gt;compare&lt;/code&gt; was declared as a method. Effectively, &lt;code&gt;T&lt;/code&gt; is bivariant in &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; because it is used only in method parameter positions.</source>
          <target state="translated">&lt;code&gt;--strictFunctionTypes&lt;/code&gt; の下では、 &lt;code&gt;compare&lt;/code&gt; がメソッドとして宣言されている場合、最初の割り当ては引き続き許可されます。事実上、 &lt;code&gt;T&lt;/code&gt; はメソッドパラメーターの位置でのみ使用されるため、Comparer &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; では2変量です。</target>
        </trans-unit>
        <trans-unit id="33054f0cbee74c9f788ca4bd77541c3e143d3d3f" translate="yes" xml:space="preserve">
          <source>Under the new &lt;code&gt;--esModuleInterop&lt;/code&gt; these two issues should be addressed:</source>
          <target state="translated">新しい &lt;code&gt;--esModuleInterop&lt;/code&gt; では、次の2つの問題に対処する必要があります。</target>
        </trans-unit>
        <trans-unit id="128561d89ec896d82327b08129ac6710b805e301" translate="yes" xml:space="preserve">
          <source>Understanding &lt;code&gt;private&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; 理解する</target>
        </trans-unit>
        <trans-unit id="54219e3d20bedb021463636f2132089eb4de56ba" translate="yes" xml:space="preserve">
          <source>Understanding &lt;code&gt;protected&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; 理解する</target>
        </trans-unit>
        <trans-unit id="dfc76f54e044a62bc08d7f563732d6c4137e806c" translate="yes" xml:space="preserve">
          <source>Understanding Errors</source>
          <target state="translated">エラーの理解</target>
        </trans-unit>
        <trans-unit id="3eb57f5cf2c9525393089f7f613c8715146826b2" translate="yes" xml:space="preserve">
          <source>Understanding TypeScript&amp;rsquo;s &lt;code&gt;private&lt;/code&gt;</source>
          <target state="translated">TypeScriptの &lt;code&gt;private&lt;/code&gt; 理解する</target>
        </trans-unit>
        <trans-unit id="e23e9d7d02cff72c54df81048c1a4380b98b0319" translate="yes" xml:space="preserve">
          <source>Understanding private</source>
          <target state="translated">プライベートを理解する</target>
        </trans-unit>
        <trans-unit id="95841ad8022df544f75a9cb58504b9e361799465" translate="yes" xml:space="preserve">
          <source>Understanding protected</source>
          <target state="translated">保護されていることを理解する</target>
        </trans-unit>
        <trans-unit id="ce277cc9234cfe2b86b777dd92906ff2f86a4ffc" translate="yes" xml:space="preserve">
          <source>Understanding the sample</source>
          <target state="translated">サンプルを理解する</target>
        </trans-unit>
        <trans-unit id="b8046695cbb07b887254bfc5fba8b62777baab42" translate="yes" xml:space="preserve">
          <source>Understanding what is created with each declaration will help you understand what is merged when you perform a declaration merge.</source>
          <target state="translated">各宣言で何が作成されるのかを理解することで、宣言のマージを行う際に何がマージされるのかを理解することができます。</target>
        </trans-unit>
        <trans-unit id="b6d31265a9d2bb701584804cfe2084c1e863a4e3" translate="yes" xml:space="preserve">
          <source>Unfortunately in TypeScript these checks could never be properly encoded. For loosely-typed code this meant TypeScript was checking less, and for slightly conservative code it often forced users to use type assertions.</source>
          <target state="translated">残念ながら、TypeScript ではこれらのチェックを適切にエンコードすることができませんでした。ゆるいタイプのコードでは、これは TypeScript のチェックが少なくなることを意味し、少し保守的なコードでは型アサーションを使わざるを得なくなることがよくありました。</target>
        </trans-unit>
        <trans-unit id="f5ac25ede763c83433a3b880f5f3fc5c401f7ac2" translate="yes" xml:space="preserve">
          <source>Unfortunately, &lt;code&gt;--declaration&lt;/code&gt; didn&amp;rsquo;t work with the &lt;code&gt;--allowJs&lt;/code&gt; flag which allows mixing TypeScript and JavaScript input files. This was a frustrating limitation because it meant users couldn&amp;rsquo;t use the &lt;code&gt;--declaration&lt;/code&gt; flag when migrating codebases, even if they were JSDoc-annotated. TypeScript 3.7 changes that, and allows the two options to be used together!</source>
          <target state="translated">残念ながら、 &lt;code&gt;--declaration&lt;/code&gt; は、TypeScriptとJavaScriptの入力ファイルを混在させることができる &lt;code&gt;--allowJs&lt;/code&gt; フラグでは機能しませんでした。JSDocアノテーションが付けられていても、コードベースの移行時に &lt;code&gt;--declaration&lt;/code&gt; フラグを使用できないため、これは苛立たしい制限でした。TypeScript 3.7はそれを変更し、2つのオプションを一緒に使用できるようにします！</target>
        </trans-unit>
        <trans-unit id="90407376a294ed45dab6024b8ace72b1f1a4f495" translate="yes" xml:space="preserve">
          <source>Unfortunately, mapped types like the &lt;code&gt;Readonly&lt;/code&gt; utility type were effectively no-ops on array and tuple types.</source>
          <target state="translated">残念ながら、 &lt;code&gt;Readonly&lt;/code&gt; ユーティリティタイプのようなマップされたタイプは、配列およびタプルタイプに対して事実上何もしませんでした。</target>
        </trans-unit>
        <trans-unit id="c9f9b24434ff80b111bededc5c17e2eb1610c1fc" translate="yes" xml:space="preserve">
          <source>Unfortunately, the type of &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; is still &lt;code&gt;any&lt;/code&gt;. That&amp;rsquo;s because &lt;code&gt;this&lt;/code&gt; comes from the function expression inside the object literal. To fix this, you can provide an explicit &lt;code&gt;this&lt;/code&gt; parameter. &lt;code&gt;this&lt;/code&gt; parameters are fake parameters that come first in the parameter list of a function:</source>
          <target state="translated">残念ながら、 &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; タイプはまだ &lt;code&gt;any&lt;/code&gt; です。 &lt;code&gt;this&lt;/code&gt; は、オブジェクトリテラル内の関数式に由来するためです。これを修正するには、明示的に &lt;code&gt;this&lt;/code&gt; パラメータを指定できます。 &lt;code&gt;this&lt;/code&gt; パラメーターは、関数のパラメーターリストの最初にある偽のパラメーターです。</target>
        </trans-unit>
        <trans-unit id="e53ce54f63b88cf452ded6201871a14783c0be8e" translate="yes" xml:space="preserve">
          <source>Unfortunately, this means that constructor functions that are also callable cannot use &lt;code&gt;@constructor&lt;/code&gt;.</source>
          <target state="translated">残念ながら、これは、呼び出し可能なコンストラクター関数が &lt;code&gt;@constructor&lt;/code&gt; を使用できないことを意味します。</target>
        </trans-unit>
        <trans-unit id="da9748783613337de4d74ee2abacadcb4e991578" translate="yes" xml:space="preserve">
          <source>Unfortunately, while this seemed to be the direction that the proposal moved towards in its earlier days, there is an extremely strong chance that public class fields will be standardized differently. Instead, the original code sample might need to de-sugar to something closer to the following:</source>
          <target state="translated">残念ながら、これが提案の初期段階での方向性であるように見えましたが、パブリッククラスのフィールドが異なる標準化される可能性が非常に高いです。代わりに、元のコードサンプルでは、以下のようなものに近いものに脱糖する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="b582e2c337ad84d8772f97cd78414fbed01f687b" translate="yes" xml:space="preserve">
          <source>Unicode codepoint escapes in strings</source>
          <target state="translated">文字列内の Unicode コードポイントエスケープ</target>
        </trans-unit>
        <trans-unit id="d0fec623da4b84453812e1c4c0b17b0a532ec7d4" translate="yes" xml:space="preserve">
          <source>Union Exhaustiveness checking</source>
          <target state="translated">ユニオンの消耗度チェック</target>
        </trans-unit>
        <trans-unit id="468ccd5bcf72e4958742b43ae3e09374a05c2b83" translate="yes" xml:space="preserve">
          <source>Union Types</source>
          <target state="translated">ユニオンの種類</target>
        </trans-unit>
        <trans-unit id="b7ed90cee7078e9ede776e2d455827cd6c390d7b" translate="yes" xml:space="preserve">
          <source>Union enums and enum member types</source>
          <target state="translated">ユニオン列挙型と列挙メンバ型</target>
        </trans-unit>
        <trans-unit id="aba2f05474229fdcd9d1da33808bf8c11dd33d17" translate="yes" xml:space="preserve">
          <source>Union type subtype reduction only removes a class type if it is a subclass of &lt;em&gt;and&lt;/em&gt; derives from another class type in the union.</source>
          <target state="translated">共用体型のサブタイプの削減は、それがサブクラスで&lt;em&gt;あり&lt;/em&gt;、共用体の別のクラス型から派生している場合にのみ、クラス型を削除します。</target>
        </trans-unit>
        <trans-unit id="2697f04d1c34bc0fd003a5d4f2f248be3c9842cb" translate="yes" xml:space="preserve">
          <source>Union types</source>
          <target state="translated">ユニオンタイプ</target>
        </trans-unit>
        <trans-unit id="56de4c1005168da2654053cbc54188220ab6bb4f" translate="yes" xml:space="preserve">
          <source>Union types also allow for better type inference in arrays and other places where you might have multiple kinds of values in a collection:</source>
          <target state="translated">ユニオン型を使用すると、配列やその他のコレクション内で複数の種類の値を持つ可能性のある場所で、より良い型推論が可能になります。</target>
        </trans-unit>
        <trans-unit id="3e7108953bcfc1c7c0311e2518816a93bc306b40" translate="yes" xml:space="preserve">
          <source>Union types are a powerful way to express a value that can be one of several types. For example, you might have an API for running a program that takes a commandline as either a &lt;code&gt;string&lt;/code&gt;, a &lt;code&gt;string[]&lt;/code&gt; or a function that returns a &lt;code&gt;string&lt;/code&gt;. You can now write:</source>
          <target state="translated">共用体型は、いくつかの型の1つになる可能性のある値を表現する強力な方法です。たとえば、コマンドラインを &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;string[]&lt;/code&gt; または &lt;code&gt;string&lt;/code&gt; を返す関数として受け取るプログラムを実行するためのAPI があるとします。あなたは今書くことができます：</target>
        </trans-unit>
        <trans-unit id="70635a04ab9351bca09c5621dffee8f76929cc2c" translate="yes" xml:space="preserve">
          <source>Union types are an advanced topic that we&amp;rsquo;ll cover in a later chapter.</source>
          <target state="translated">ユニオンタイプは、後の章で説明する高度なトピックです。</target>
        </trans-unit>
        <trans-unit id="3fa5955704db38dbb3e16e34ca92691e9ea2bbf5" translate="yes" xml:space="preserve">
          <source>Union types are closely related to intersection types, but they are used very differently. Occasionally, you&amp;rsquo;ll run into a library that expects a parameter to be either a &lt;code&gt;number&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;. For instance, take the following function:</source>
          <target state="translated">ユニオンタイプは交差タイプに密接に関連していますが、使用方法は大きく異なります。ときどき、パラメータが &lt;code&gt;number&lt;/code&gt; または &lt;code&gt;string&lt;/code&gt; いずれかであると想定されるライブラリに出くわします。たとえば、次の関数を取ります。</target>
        </trans-unit>
        <trans-unit id="cd921c2ea01c32f5a34e452b767384ff1f31852e" translate="yes" xml:space="preserve">
          <source>Union types are useful for modeling situations when values can overlap in the types they can take on. What happens when we need to know specifically whether we have a &lt;code&gt;Fish&lt;/code&gt;? A common idiom in JavaScript to differentiate between two possible values is to check for the presence of a member. As we mentioned, you can only access members that are guaranteed to be in all the constituents of a union type.</source>
          <target state="translated">ユニオンタイプは、値が取り得るタイプで値が重複する可能性がある状況のモデリングに役立ちます。 &lt;code&gt;Fish&lt;/code&gt; があるかどうかを具体的に知る必要がある場合はどうなりますか？ 2つの可能な値を区別するためのJavaScriptの一般的なイディオムは、メンバーの存在を確認することです。前述したように、アクセスできるのは、共用体タイプのすべての構成要素であることが保証されているメンバーのみです。</target>
        </trans-unit>
        <trans-unit id="d4d68a0298812ddd887befc8ebd536a465311e12" translate="yes" xml:space="preserve">
          <source>Union types can be a bit tricky here, but it just takes a bit of intuition to get used to. If a value has the type &lt;code&gt;A | B&lt;/code&gt;, we only know for &lt;em&gt;certain&lt;/em&gt; that it has members that both &lt;code&gt;A&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;B&lt;/code&gt; have. In this example, &lt;code&gt;Bird&lt;/code&gt; has a member named &lt;code&gt;fly&lt;/code&gt;. We can&amp;rsquo;t be sure whether a variable typed as &lt;code&gt;Bird | Fish&lt;/code&gt; has a &lt;code&gt;fly&lt;/code&gt; method. If the variable is really a &lt;code&gt;Fish&lt;/code&gt; at runtime, then calling &lt;code&gt;pet.fly()&lt;/code&gt; will fail.</source>
          <target state="translated">ここでユニオン型は少しトリッキーですが、慣れるには少し直感が必要です。値のタイプが &lt;code&gt;A | B&lt;/code&gt; 、それは &lt;code&gt;A&lt;/code&gt; &lt;em&gt;と&lt;/em&gt; &lt;code&gt;B&lt;/code&gt; の両方が持っているメンバーがいることを&lt;em&gt;確実に&lt;/em&gt;知っているだけです。この例では、 &lt;code&gt;Bird&lt;/code&gt; に &lt;code&gt;fly&lt;/code&gt; という名前のメンバーがあります。変数が &lt;code&gt;Bird | Fish&lt;/code&gt; 入力されているかどうかはわかりません。魚には &lt;code&gt;fly&lt;/code&gt; 方法があります。変数が実行時に実際に &lt;code&gt;Fish&lt;/code&gt; である場合、 &lt;code&gt;pet.fly()&lt;/code&gt; の呼び出しは失敗します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="00002b164c08859d5a15579e55c8f17ce6478546" translate="yes" xml:space="preserve">
          <source>Unions</source>
          <target state="translated">Unions</target>
        </trans-unit>
        <trans-unit id="f48468b06a9e4516b5c97a2b05c0405b665a11bd" translate="yes" xml:space="preserve">
          <source>Unions and Intersection Types</source>
          <target state="translated">ユニオンと交差点の種類</target>
        </trans-unit>
        <trans-unit id="a013266da3448b7cdbeb6ae12b743b8431bc0dc9" translate="yes" xml:space="preserve">
          <source>Unions provide a way to handle different types too. For example, you may have a function that takes an &lt;code&gt;array&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;:</source>
          <target state="translated">ユニオンは、さまざまなタイプを処理する方法も提供します。たとえば、 &lt;code&gt;array&lt;/code&gt; または &lt;code&gt;string&lt;/code&gt; 受け取る関数があるとします。</target>
        </trans-unit>
        <trans-unit id="716232e9652a75720d14510144c825017458f7cc" translate="yes" xml:space="preserve">
          <source>Unions with Common Fields</source>
          <target state="translated">共通分野を持つ組合</target>
        </trans-unit>
        <trans-unit id="2ec354f7a8e237dd28115d025f20f869218004ad" translate="yes" xml:space="preserve">
          <source>Unit types</source>
          <target state="translated">ユニットタイプ</target>
        </trans-unit>
        <trans-unit id="9003e1fae84a4609d6b8fb77cb5eb2556e480e27" translate="yes" xml:space="preserve">
          <source>Unit types are subtypes of primitive types that contain exactly one primitive value. For example, the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; has the type &lt;code&gt;&quot;foo&quot;&lt;/code&gt;. Since JavaScript has no built-in enums, it is common to use a set of well-known strings instead. Unions of string literal types allow TypeScript to type this pattern:</source>
          <target state="translated">ユニットタイプは、1つのプリミティブ値のみを含むプリミティブタイプのサブタイプです。たとえば、文字列 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; のタイプは &lt;code&gt;&quot;foo&quot;&lt;/code&gt; です。JavaScriptには組み込みの列挙型がないため、代わりによく知られた文字列のセットを使用するのが一般的です。文字列リテラルタイプの和集合により、TypeScriptは次のパターンを入力できます。</target>
        </trans-unit>
        <trans-unit id="bc7819b34ff87570745fbe461e36a16f80e562ce" translate="yes" xml:space="preserve">
          <source>Unknown</source>
          <target state="translated">Unknown</target>
        </trans-unit>
        <trans-unit id="ece8b3c6faf7510538396ff92255b9fc5deb4014" translate="yes" xml:space="preserve">
          <source>Unless you take specific measures to avoid it, the internal state of a &lt;code&gt;const&lt;/code&gt; variable is still modifiable. Fortunately, TypeScript allows you to specify that members of an object are &lt;code&gt;readonly&lt;/code&gt;. The &lt;a href=&quot;interfaces&quot;&gt;chapter on Interfaces&lt;/a&gt; has the details.</source>
          <target state="translated">それを回避するための特別な対策を講じない限り、 &lt;code&gt;const&lt;/code&gt; 変数の内部状態は変更可能です。さいわい、TypeScriptを使用すると、オブジェクトのメンバーを &lt;code&gt;readonly&lt;/code&gt; に指定できます。&lt;a href=&quot;interfaces&quot;&gt;インターフェイスでの章では、&lt;/a&gt;詳細があります。</target>
        </trans-unit>
        <trans-unit id="c861cf88ebb1a5b494f6992b73222db7fff28246" translate="yes" xml:space="preserve">
          <source>Unless you&amp;rsquo;re really trying to take advantage of JavaScript&amp;rsquo;s runtime behavior in a clever way, it&amp;rsquo;s advised that you don&amp;rsquo;t do this.</source>
          <target state="translated">JavaScriptの実行時の動作を巧みに利用しようとしない限り、これを行わないことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="84b3e4863aee46ac562de68360e58df6ef13bb83" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;unknown&lt;/code&gt;, variables of type &lt;code&gt;any&lt;/code&gt; allow you to access arbitrary properties, even ones that don&amp;rsquo;t exist. These properties include functions and TypeScript will not check their existence or type:</source>
          <target state="translated">&lt;code&gt;unknown&lt;/code&gt; とは異なり、 &lt;code&gt;any&lt;/code&gt; 型の変数を使用すると、存在しないプロパティであっても、任意のプロパティにアクセスできます。これらのプロパティには関数が含まれており、TypeScriptはそれらの存在やタイプをチェックしません。</target>
        </trans-unit>
        <trans-unit id="43f45df55b8eab061b85101f488f9a767624cd64" translate="yes" xml:space="preserve">
          <source>Unlike Haskell, the tag, or discriminant, is just a property in each object type. Each variant has an identical property with a different unit type. This is still a normal union type; the leading &lt;code&gt;|&lt;/code&gt; is an optional part of the union type syntax. You can discriminate the members of the union using normal JavaScript code:</source>
          <target state="translated">Haskellとは異なり、タグ、つまり判別式は、各オブジェクトタイプの単なるプロパティです。各バリアントには、異なるユニットタイプを持つ同一のプロパティがあります。これはまだ通常の共用体タイプです。リーディング &lt;code&gt;|&lt;/code&gt; 共用体型構文のオプション部分です。通常のJavaScriptコードを使用して、ユニオンのメンバーを区別できます。</target>
        </trans-unit>
        <trans-unit id="9c675fd40f67f1744d7a77a8ad4c15f4daebdc18" translate="yes" xml:space="preserve">
          <source>Unlike JSDoc&amp;rsquo;s type system, TypeScript only allows you to mark types as containing null or not. There is no explicit non-nullability &amp;mdash; if strictNullChecks is on, then &lt;code&gt;number&lt;/code&gt; is not nullable. If it is off, then &lt;code&gt;number&lt;/code&gt; is nullable.</source>
          <target state="translated">JSDocの型システムとは異なり、TypeScriptでは型にnullを含むかどうかのみをマークできます。明示的な非NULL可能性はありません&amp;mdash; strictNullChecksがオンの場合、 &lt;code&gt;number&lt;/code&gt; はNULL可能ではありません。オフの場合、 &lt;code&gt;number&lt;/code&gt; はnull許容です。</target>
        </trans-unit>
        <trans-unit id="1a1461542d00d5010806839c20e64aa1678fdff5" translate="yes" xml:space="preserve">
          <source>Unlike JSDoc&amp;rsquo;s type system, Typescript only allows you to mark types as containing null or not. There is no explicit non-nullability &amp;ndash; if strictNullChecks is on, then &lt;code&gt;number&lt;/code&gt; is not nullable. If it is off, then &lt;code&gt;number&lt;/code&gt; is nullable.</source>
          <target state="translated">JSDocの型システムとは異なり、Typescriptでは、型にnullを含むかどうかをマークすることしかできません。明示的なnull可能性はありません。strictNullChecksがオンの場合、 &lt;code&gt;number&lt;/code&gt; はnull可能ではありません。オフの場合、 &lt;code&gt;number&lt;/code&gt; はNULL可能です。</target>
        </trans-unit>
        <trans-unit id="51985852906766cae660d6a12174c73de43d98b6" translate="yes" xml:space="preserve">
          <source>Unlike plain optional parameters, default-initialized parameters don&amp;rsquo;t &lt;em&gt;need&lt;/em&gt; to occur after required parameters. If a default-initialized parameter comes before a required parameter, users need to explicitly pass &lt;code&gt;undefined&lt;/code&gt; to get the default initialized value. For example, we could write our last example with only a default initializer on &lt;code&gt;firstName&lt;/code&gt;:</source>
          <target state="translated">単純なオプションのパラメーターとは異なり、デフォルトで初期化されたパラメーターは、必須パラメーターの後に出現する&lt;em&gt;必要&lt;/em&gt;は&lt;em&gt;あり&lt;/em&gt;ません。デフォルトで初期化されたパラメーターが必須パラメーターの前にある場合、ユーザーは &lt;code&gt;undefined&lt;/code&gt; を明示的に渡してデフォルトの初期化値を取得する必要があります。たとえば、 &lt;code&gt;firstName&lt;/code&gt; にデフォルトの初期化子のみを使用して最後の例を書くことができます。</target>
        </trans-unit>
        <trans-unit id="4b497f9d0d5c2c4f2547035f0fcd80ba5746c84a" translate="yes" xml:space="preserve">
          <source>Unreachable code</source>
          <target state="translated">到達不可能なコード</target>
        </trans-unit>
        <trans-unit id="1d0500c74b8aa49d1d2f3d7c0b7c86b3a9d2a921" translate="yes" xml:space="preserve">
          <source>Unspecified type parameters default to &lt;code&gt;any&lt;/code&gt;</source>
          <target state="translated">未指定の型パラメーターはデフォルトで &lt;code&gt;any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96c849b45ea75a8c2321b502c7837adbcdc9a6ff" translate="yes" xml:space="preserve">
          <source>Unsupported tags</source>
          <target state="translated">サポートされていないタグ</target>
        </trans-unit>
        <trans-unit id="1948c97816d203ebc2f90700d76faedc4fbbccfe" translate="yes" xml:space="preserve">
          <source>Untyped imports</source>
          <target state="translated">タイプされていない輸入品</target>
        </trans-unit>
        <trans-unit id="42a377f570d337b6d69100d6ff55ff5b9e97a424" translate="yes" xml:space="preserve">
          <source>Unused labels</source>
          <target state="translated">未使用のラベル</target>
        </trans-unit>
        <trans-unit id="950c29b1f717e4fff1d2a159fa44b64e58240c0f" translate="yes" xml:space="preserve">
          <source>Unused labels are also flagged. Just like unreachable code checks, these are turned on by default; use &lt;code&gt;--allowUnusedLabels&lt;/code&gt; to stop reporting these errors.</source>
          <target state="translated">未使用のラベルにもフラグが付けられます。到達不能コードチェックと同様に、これらはデフォルトでオンになっています。 &lt;code&gt;--allowUnusedLabels&lt;/code&gt; を使用して、これらのエラーの報告を停止します。</target>
        </trans-unit>
        <trans-unit id="3ea5ca14dc52b9bd423f61c07136cde4865d6a52" translate="yes" xml:space="preserve">
          <source>Up to this point, we&amp;rsquo;ve only talked about the &lt;em&gt;instance&lt;/em&gt; members of the class, those that show up on the object when it&amp;rsquo;s instantiated. We can also create &lt;em&gt;static&lt;/em&gt; members of a class, those that are visible on the class itself rather than on the instances. In this example, we use &lt;code&gt;static&lt;/code&gt; on the origin, as it&amp;rsquo;s a general value for all grids. Each instance accesses this value through prepending the name of the class. Similarly to prepending &lt;code&gt;this.&lt;/code&gt; in front of instance accesses, here we prepend &lt;code&gt;Grid.&lt;/code&gt; in front of static accesses.</source>
          <target state="translated">ここまでは、インスタンス化されたときにオブジェクトに表示される、クラスの&lt;em&gt;インスタンス&lt;/em&gt;メンバーについてのみ説明しました。クラスの&lt;em&gt;静的&lt;/em&gt;メンバーを作成することもできます。インスタンスではなく、クラス自体に表示されます。この例では、すべてのグリッドの一般的な値であるため、原点に &lt;code&gt;static&lt;/code&gt; を使用します。各インスタンスは、クラスの名前を先頭に追加することでこの値にアクセスします。同様に &lt;code&gt;this.&lt;/code&gt; を前に付ける。インスタンスアクセスの前に、ここでは &lt;code&gt;Grid.&lt;/code&gt; を付加します。静的アクセスの前。</target>
        </trans-unit>
        <trans-unit id="ad67feee99a0f439a0e27027c5ea3dcbcf7ff3d4" translate="yes" xml:space="preserve">
          <source>Update &lt;code&gt;.vscode/settings.json&lt;/code&gt; with the following:</source>
          <target state="translated">&lt;code&gt;.vscode/settings.json&lt;/code&gt; を次のように更新します。</target>
        </trans-unit>
        <trans-unit id="0c453d2caa8ecb4d47c7c21d916dd5de2c9571a9" translate="yes" xml:space="preserve">
          <source>Update project file to include locally installed &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt; (at the top) and &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; (at the bottom) files:</source>
          <target state="translated">ローカルにインストールされた &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt; （上部）および &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; （下部）ファイルを含むようにプロジェクトファイルを更新します。</target>
        </trans-unit>
        <trans-unit id="61ef22d6991101f4978ea02b3e277ed08f8a02ed" translate="yes" xml:space="preserve">
          <source>Update the &lt;code&gt;Settings - User&lt;/code&gt; file with the following:</source>
          <target state="translated">&lt;code&gt;Settings - User&lt;/code&gt; ファイルを次のように更新します。</target>
        </trans-unit>
        <trans-unit id="8b2b612f6daeee72c04fac6bf2b62e95619d91d9" translate="yes" xml:space="preserve">
          <source>Updating your IDE to use the nightly builds</source>
          <target state="translated">ナイトリービルドを使用するための IDE の更新</target>
        </trans-unit>
        <trans-unit id="baadd0b4691cd923997ea6041f0a70f9d9c1d58d" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#jsxFactory&quot;&gt;&lt;code&gt;--jsxFactory&lt;/code&gt;&lt;/a&gt; instead. Specify the object invoked for &lt;code&gt;createElement&lt;/code&gt; when targeting &lt;code&gt;react&lt;/code&gt; for TSX files.</source>
          <target state="translated">代わりに&lt;a href=&quot;#jsxFactory&quot;&gt; &lt;code&gt;--jsxFactory&lt;/code&gt; &lt;/a&gt;を使用してください。TSXファイルの &lt;code&gt;react&lt;/code&gt; をターゲットにするときに &lt;code&gt;createElement&lt;/code&gt; に対して呼び出されるオブジェクトを指定します。</target>
        </trans-unit>
        <trans-unit id="396d021a8d5ef888effc1abd9236b7f66ab50d42" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#outFile&quot;&gt;outFile&lt;/a&gt; instead.</source>
          <target state="translated">代わりに&lt;a href=&quot;#outFile&quot;&gt;outFile&lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="794a3710c02b705cb8176f0ebe766dee147dd40c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#skipLibCheck&quot;&gt;&lt;code&gt;--skipLibCheck&lt;/code&gt;&lt;/a&gt; instead. Skip type checking of default library declaration files.</source>
          <target state="translated">代わりに&lt;a href=&quot;#skipLibCheck&quot;&gt; &lt;code&gt;--skipLibCheck&lt;/code&gt; &lt;/a&gt;を使用してください。デフォルトのライブラリ宣言ファイルの型チェックをスキップします。</target>
        </trans-unit>
        <trans-unit id="8cd29d9aedccf4abdd9f95da49e8b3e269208158" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;constructed&lt;/em&gt; using &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; ：を使用してモジュールを&lt;em&gt;構築&lt;/em&gt;できる場合は、&lt;a href=&quot;module-class-d-ts&quot;&gt; &lt;code&gt;module-class.d.ts&lt;/code&gt; を&lt;/a&gt;使用します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a820b114f9666c422cc3a7015e046eea0e5ef5f7" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;called&lt;/em&gt; like a function:</source>
          <target state="translated">&lt;a href=&quot;module-function-d-ts&quot;&gt; &lt;code&gt;module-function.d.ts&lt;/code&gt; &lt;/a&gt;ように&lt;em&gt;呼び出す&lt;/em&gt;ことができる場合は、module-function.d.tsを使用します。</target>
        </trans-unit>
        <trans-unit id="4dc2e4b6eb759a2e235283631204f80eaa19dc57" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;templates/module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;constructed&lt;/em&gt; using &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="translated">使用&lt;a href=&quot;templates/module-class-d-ts&quot;&gt; &lt;code&gt;module-class.d.ts&lt;/code&gt; &lt;/a&gt;あなたのモジュールができるのであれば&lt;em&gt;構築&lt;/em&gt;使用して &lt;code&gt;new&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dcb83b510816e0232e4eea4a6e8821858e1d88cf" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;templates/module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;called&lt;/em&gt; like a function:</source>
          <target state="translated">使用&lt;a href=&quot;templates/module-function-d-ts&quot;&gt; &lt;code&gt;module-function.d.ts&lt;/code&gt; &lt;/a&gt;あなたのモジュールができる場合&lt;em&gt;と呼ばれる&lt;/em&gt;関数のように：</target>
        </trans-unit>
        <trans-unit id="9135ad666eb865ef0f03b22c777b4833dda580f4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;--pretty false&lt;/code&gt; on the command line or set &lt;code&gt;&quot;pretty&quot;: false&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt; to disable &lt;code&gt;--pretty&lt;/code&gt; output.</source>
          <target state="translated">使用 &lt;code&gt;--pretty false&lt;/code&gt; コマンドラインまたはセットの &lt;code&gt;&quot;pretty&quot;: false&lt;/code&gt; あなたの中 &lt;code&gt;tsconfig.json&lt;/code&gt; 無効に &lt;code&gt;--pretty&lt;/code&gt; 出力。</target>
        </trans-unit>
        <trans-unit id="d777cba827da4d9bd0a80b90d7cc7d35bc7eb763" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;declare class&lt;/code&gt; to describe a class or class-like object. Classes can have properties and methods as well as a constructor.</source>
          <target state="translated">クラスまたはクラスのようなオブジェクトを説明するには、 &lt;code&gt;declare class&lt;/code&gt; を使用します。クラスには、コンストラクターだけでなく、プロパティとメソッドを含めることができます。</target>
        </trans-unit>
        <trans-unit id="1d25646e3d1c96527dec663a49cd97e0a677f024" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;declare function&lt;/code&gt; to declare functions.</source>
          <target state="translated">&lt;code&gt;declare function&lt;/code&gt; を宣言するには、関数の宣言を使用します。</target>
        </trans-unit>
        <trans-unit id="dc5e87631ffbf23b795c1170d5135c6525f91882" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;declare namespace&lt;/code&gt; to describe types or values accessed by dotted notation.</source>
          <target state="translated">&lt;code&gt;declare namespace&lt;/code&gt; を使用して、ドット表記でアクセスされるタイプまたは値を記述します。</target>
        </trans-unit>
        <trans-unit id="646cf6b60f19ec39b9a348c993659c06af5ff17e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;declare var&lt;/code&gt; to declare variables. If the variable is read-only, you can use &lt;code&gt;declare const&lt;/code&gt;. You can also use &lt;code&gt;declare let&lt;/code&gt; if the variable is block-scoped.</source>
          <target state="translated">変数を宣言するには、 &lt;code&gt;declare var&lt;/code&gt; を使用します。変数が読み取り専用の場合は、 &lt;code&gt;declare const&lt;/code&gt; を使用できます。変数がブロックスコープの場合は、 &lt;code&gt;declare let&lt;/code&gt; を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="fc7b733452effbd68c17f48699824b764aa4d5c8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fs.watch&lt;/code&gt; to watch directories and child directories</source>
          <target state="translated">&lt;code&gt;fs.watch&lt;/code&gt; を使用してディレクトリと子ディレクトリを監視する</target>
        </trans-unit>
        <trans-unit id="a20558d88b96350c2a6617d2a8806bb939c26e75" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fs.watch&lt;/code&gt; which uses file system events (but might not be accurate on different OS) to get the notifications for the file changes/creation/deletion. Note that few OS eg. linux has limit on number of watches and failing to create watcher using &lt;code&gt;fs.watch&lt;/code&gt; will result it in creating using &lt;code&gt;fs.watchFile&lt;/code&gt;</source>
          <target state="translated">ファイルシステムイベントを使用する &lt;code&gt;fs.watch&lt;/code&gt; を使用して（ただし、OSによっては正確でない場合があります）、ファイルの変更/作成/削除の通知を取得します。OSが少ないことに注意してください。Linuxは、時計の数及び使用ウォッチャーの作成に失敗した上で限界が &lt;code&gt;fs.watch&lt;/code&gt; を使用して作成する際にそれをもたらす &lt;code&gt;fs.watchFile&lt;/code&gt; を</target>
        </trans-unit>
        <trans-unit id="b8a0ecc46b3020c85d683ef9e7bfc225a06e140d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fs.watchFile&lt;/code&gt; but use different polling intervals for source files, config files and missing files</source>
          <target state="translated">使用 &lt;code&gt;fs.watchFile&lt;/code&gt; しかし、ソースファイル、設定ファイルや不足しているファイルに対して異なるポーリング間隔を使用します</target>
        </trans-unit>
        <trans-unit id="d9b3f25a00b42d34692eae633c97a930b3ef45c2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fs.watchFile&lt;/code&gt; to watch the directories and child directories which is a polling watch (consuming CPU cycles)</source>
          <target state="translated">&lt;code&gt;fs.watchFile&lt;/code&gt; を使用して、ポーリング監視であるディレクトリと子ディレクトリを監視します（CPUサイクルを消費します）。</target>
        </trans-unit>
        <trans-unit id="b82d02e810b66cfc5287f1002d1703389ec9f322" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;static defaultProps: Pick&amp;lt;Props, &quot;name&quot;&amp;gt;;&lt;/code&gt; as an explicit type annotation instead, or do not add a type annotation as done in the example above.</source>
          <target state="translated">&lt;code&gt;static defaultProps: Pick&amp;lt;Props, &quot;name&quot;&amp;gt;;&lt;/code&gt; 使用：Pick &amp;lt;Props、 &quot;name&quot;&amp;gt;; 代わりに明示的な型注釈として、または上記の例のように型注釈を追加しないでください。</target>
        </trans-unit>
        <trans-unit id="6e4e750a17d76a60f93d2129a4bfe65128e56bdc" translate="yes" xml:space="preserve">
          <source>Use Define For Class Fields - &lt;code&gt;useDefineForClassFields&lt;/code&gt;</source>
          <target state="translated">クラスフィールドの定義を使用 &lt;code&gt;useDefineForClassFields&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c797e1ab4188af4e8f2f348f9d4813348e879b0b" translate="yes" xml:space="preserve">
          <source>Use JSDoc &lt;code&gt;@augments&lt;/code&gt; to specify the types explicitly. for instance:</source>
          <target state="translated">JSDoc &lt;code&gt;@augments&lt;/code&gt; を使用してタイプを明示的に指定します。例えば：</target>
        </trans-unit>
        <trans-unit id="26914e7e48730258a108abb453430cd3518851d2" translate="yes" xml:space="preserve">
          <source>Use Optional Parameters</source>
          <target state="translated">オプションのパラメータを使用する</target>
        </trans-unit>
        <trans-unit id="1f551ab7cd042c6186f08b5016c6fbb015348adf" translate="yes" xml:space="preserve">
          <source>Use Union Types</source>
          <target state="translated">ユニオンタイプを使用する</target>
        </trans-unit>
        <trans-unit id="c6e9ca22aa2af3128ca0dfccc6ca984b9a53e2f4" translate="yes" xml:space="preserve">
          <source>Use a dynamic queue where in the frequently modified files will be polled at shorter interval and the files unchanged will be polled less frequently</source>
          <target state="translated">頻繁に変更されたファイルがより短い間隔でポーリングされ、変更されていないファイルがより頻繁にポーリングされます動的なキューを使用してください。</target>
        </trans-unit>
        <trans-unit id="b6bcaab1110f17c72658c24deb9f410172d12ea7" translate="yes" xml:space="preserve">
          <source>Use a type assertion (i.e. &lt;code&gt;opts as Options&lt;/code&gt;).</source>
          <target state="translated">タイプアサーションを使用し &lt;code&gt;opts as Options&lt;/code&gt; （つまり、Optionsとして選択します）。</target>
        </trans-unit>
        <trans-unit id="c373f04992cf46cf315a11d0cfd773d124512011" translate="yes" xml:space="preserve">
          <source>Use an &lt;code&gt;interface&lt;/code&gt; to define a type with properties.</source>
          <target state="translated">プロパティを使用してタイプを定義するには、 &lt;code&gt;interface&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="de6bf5682731fffe8d17a1a2893ad0e0e875fbd9" translate="yes" xml:space="preserve">
          <source>Use comma or multiple tags to declare multiple type parameters:</source>
          <target state="translated">カンマまたは複数のタグを使用して、複数の型のパラメータを宣言します。</target>
        </trans-unit>
        <trans-unit id="813eb2c164fdf97484adee07af475b49c979cbf5" translate="yes" xml:space="preserve">
          <source>Use destructuring with care. As the previous example demonstrates, anything but the simplest destructuring expression is confusing. This is especially true with deeply nested destructuring, which gets &lt;em&gt;really&lt;/em&gt; hard to understand even without piling on renaming, default values, and type annotations. Try to keep destructuring expressions small and simple. You can always write the assignments that destructuring would generate yourself.</source>
          <target state="translated">注意して破壊を使用してください。前の例が示すように、最も単純な構造化式以外は混乱を招きます。これは特に、深くネストされた構造化の場合に当てはまります。これは、名前の変更、デフォルト値、および型注釈を重ねなくても、理解が&lt;em&gt;非常に&lt;/em&gt;難しくなります。解体式は小さくシンプルにしてください。解体によって自分自身が生成するであろう割り当てをいつでも書くことができます。</target>
        </trans-unit>
        <trans-unit id="84ca1d512ea34e66413a09bf03aea43da1cd5e61" translate="yes" xml:space="preserve">
          <source>Use dynamic polling queue to poll changes to the directory and child directories.</source>
          <target state="translated">動的ポーリングキューを使用して、ディレクトリと子ディレクトリへの変更をポーリングします。</target>
        </trans-unit>
        <trans-unit id="476bd570b1cb323c844b457111807cf0bfe14c03" translate="yes" xml:space="preserve">
          <source>Use namespaces to organize types.</source>
          <target state="translated">名前空間を使用して型を整理します。</target>
        </trans-unit>
        <trans-unit id="a7fb2226e7d1637c125b100d2ae8ebe1ff2bbb66" translate="yes" xml:space="preserve">
          <source>Use returned values from super calls as &amp;lsquo;this&amp;rsquo;</source>
          <target state="translated">スーパーコールからの戻り値を「this」として使用する</target>
        </trans-unit>
        <trans-unit id="4281cb2734b20854fad7ce1621ef834a4a1b4e65" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;global-plugin-d-ts&quot;&gt;&lt;code&gt;global-plugin.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="translated">&lt;a href=&quot;global-plugin-d-ts&quot;&gt; &lt;code&gt;global-plugin.d.ts&lt;/code&gt; &lt;/a&gt;テンプレートを使用します。</target>
        </trans-unit>
        <trans-unit id="674fffd874755fee3353fca4923c07272aaa239e" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;module-plugin-d-ts&quot;&gt;&lt;code&gt;module-plugin.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="translated">&lt;a href=&quot;module-plugin-d-ts&quot;&gt; &lt;code&gt;module-plugin.d.ts&lt;/code&gt; &lt;/a&gt;テンプレートを使用します。</target>
        </trans-unit>
        <trans-unit id="cec0cfa03e45ca3f1d25fc09af8034cc6ba3a098" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;templates/global-modifying-module-d-ts&quot;&gt;&lt;code&gt;global-modifying-module.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="translated">使用する&lt;a href=&quot;templates/global-modifying-module-d-ts&quot;&gt; &lt;code&gt;global-modifying-module.d.ts&lt;/code&gt; &lt;/a&gt;テンプレートを。</target>
        </trans-unit>
        <trans-unit id="f66cc8b895d213df6b8e2c503e64c2fdad1da70f" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;templates/global-modifying-module.d.ts.md&quot;&gt;&lt;code&gt;global-modifying-module.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="translated">使用する&lt;a href=&quot;templates/global-modifying-module.d.ts.md&quot;&gt; &lt;code&gt;global-modifying-module.d.ts&lt;/code&gt; &lt;/a&gt;テンプレートを。</target>
        </trans-unit>
        <trans-unit id="467a1132d18100a2fea14dea179fb807cc8c9786" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;templates/global-plugin-d-ts&quot;&gt;&lt;code&gt;global-plugin.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="translated">&lt;a href=&quot;templates/global-plugin-d-ts&quot;&gt; &lt;code&gt;global-plugin.d.ts&lt;/code&gt; &lt;/a&gt;テンプレートを使用します。</target>
        </trans-unit>
        <trans-unit id="ded88ccc850f489f2c1db682f66acc6ce6e89c02" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;templates/module-plugin-d-ts&quot;&gt;&lt;code&gt;module-plugin.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="translated">&lt;a href=&quot;templates/module-plugin-d-ts&quot;&gt; &lt;code&gt;module-plugin.d.ts&lt;/code&gt; &lt;/a&gt;テンプレートを使用します。</target>
        </trans-unit>
        <trans-unit id="d00f93f8ed19c310af833f02b233f61189f29867" translate="yes" xml:space="preserve">
          <source>Use the namespace import pattern if you&amp;rsquo;re importing a large number of things</source>
          <target state="translated">多数のものをインポートする場合は、名前空間インポートパターンを使用します</target>
        </trans-unit>
        <trans-unit id="181dfdffa543aacf139786370fa1942354e5e0e8" translate="yes" xml:space="preserve">
          <source>Use the specified end of line sequence to be used when emitting files: &lt;code&gt;&quot;crlf&quot;&lt;/code&gt; (windows) or &lt;code&gt;&quot;lf&quot;&lt;/code&gt; (unix).&amp;rdquo;</source>
          <target state="translated">ファイルを出力するときに使用される、指定された行末シーケンスを使用します： &lt;code&gt;&quot;crlf&quot;&lt;/code&gt; （windows）または &lt;code&gt;&quot;lf&quot;&lt;/code&gt; （unix）。 &quot;</target>
        </trans-unit>
        <trans-unit id="991f181fa1f670d03fe9e8348c63df208559c8f3" translate="yes" xml:space="preserve">
          <source>Use the template &lt;a href=&quot;templates/module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;constructed&lt;/em&gt; using &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; ：を使用してモジュールを&lt;em&gt;構築&lt;/em&gt;できる場合は、テンプレート&lt;a href=&quot;templates/module-class-d-ts&quot;&gt; &lt;code&gt;module-class.d.ts&lt;/code&gt; を&lt;/a&gt;使用します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6c5dbc74cf020a727ea7578eaadc331456e2cdd0" translate="yes" xml:space="preserve">
          <source>Use these directives only when you&amp;rsquo;re authoring a &lt;code&gt;d.ts&lt;/code&gt; file by hand.</source>
          <target state="translated">これらのディレクティブは、 &lt;code&gt;d.ts&lt;/code&gt; ファイルを手動で作成する場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="3c9eac17e15f70b4957575dc44afd54e3e8ed5d8" translate="yes" xml:space="preserve">
          <source>Use your best judgement, and if applicable, consult the matter with the rest of your team.</source>
          <target state="translated">最善の判断を下し、必要に応じて他のチームと相談してください。</target>
        </trans-unit>
        <trans-unit id="2adb0f1b976920901a418d9f6d757aa6988d5b84" translate="yes" xml:space="preserve">
          <source>Used to output diagnostic information for debugging. This command is a subset of &lt;a href=&quot;#extendedDiagnostics&quot;&gt;&lt;code&gt;extendedDiagnostics&lt;/code&gt;&lt;/a&gt; which are more user-facing results, and easier to interpret.</source>
          <target state="translated">デバッグ用の診断情報を出力するために使用されます。このコマンドは&lt;a href=&quot;#extendedDiagnostics&quot;&gt; &lt;code&gt;extendedDiagnostics&lt;/code&gt; の&lt;/a&gt;サブセットであり、よりユーザー向けの結果であり、解釈が容易です。</target>
        </trans-unit>
        <trans-unit id="49e789822c27891d496e2d1c824f3137fc0a60e8" translate="yes" xml:space="preserve">
          <source>User Combinations</source>
          <target state="translated">ユーザーの組み合わせ</target>
        </trans-unit>
        <trans-unit id="6db409b39dc46fb85822ac1924c1fb876244cc1a" translate="yes" xml:space="preserve">
          <source>User-Defined Type Guards</source>
          <target state="translated">ユーザー定義タイプガード</target>
        </trans-unit>
        <trans-unit id="d8895e69c18f832a3dc18dc0b25ac0287a552c83" translate="yes" xml:space="preserve">
          <source>User-defined type guard functions</source>
          <target state="translated">ユーザー定義型ガード機能</target>
        </trans-unit>
        <trans-unit id="865aa2eab27a2eebc9f8c1b7ee2b45dba99a5722" translate="yes" xml:space="preserve">
          <source>Users can now declare any augmentations that they want to make, or that any other consumers already have made, to an existing module. Module augmentations look like plain old ambient module declarations (i.e. the &lt;code&gt;declare module &quot;foo&quot; { }&lt;/code&gt; syntax), and are directly nested either your own modules, or in another top level ambient external module.</source>
          <target state="translated">ユーザーは、既存のモジュールに対して、追加したい拡張や、他のコンシューマがすでに作成した拡張を宣言できるようになりました。モジュールの拡張は、単純な古いアンビエントモジュール宣言（つまり、 &lt;code&gt;declare module &quot;foo&quot; { }&lt;/code&gt; 構文）のように見え、独自のモジュールまたは別の最上位アンビエント外部モジュールに直接ネストされます。</target>
        </trans-unit>
        <trans-unit id="b92638c4a093946ffe782b9c6ea843146edd2d04" translate="yes" xml:space="preserve">
          <source>Users can now ensure that the type system will catch such errors. Here&amp;rsquo;s our new &lt;code&gt;AnimationOptions&lt;/code&gt; using string literal types:</source>
          <target state="translated">ユーザーは、型システムがそのようなエラーを確実にキャッチできるようになりました。文字列リテラルタイプを使用した新しい &lt;code&gt;AnimationOptions&lt;/code&gt; は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="971fc6da1fad26d48864984a1a77ed97685d4f3a" translate="yes" xml:space="preserve">
          <source>Users using newer versions of TS, will see a prompt to upgrade their project on first load.</source>
          <target state="translated">新しいバージョンのTSを使用しているユーザーは、最初のロード時にプロジェクトをアップグレードするプロンプトが表示されます。</target>
        </trans-unit>
        <trans-unit id="076baa79ca77082f0ca2b3320f7136b88d1a143c" translate="yes" xml:space="preserve">
          <source>Using &amp;lsquo;rootDirs&amp;rsquo;, you can inform the compiler of the &lt;em&gt;roots&lt;/em&gt; making up this &amp;ldquo;virtual&amp;rdquo; directory; and thus the compiler can resolve relative modules imports within these &amp;ldquo;virtual&amp;rdquo; directories &lt;em&gt;as if&lt;/em&gt; were merged together in one directory.</source>
          <target state="translated">「rootDirs」を使用すると、この「仮想」ディレクトリを構成する&lt;em&gt;ルート&lt;/em&gt;をコンパイラに通知できます。したがって、コンパイラは、これらの「仮想」ディレクトリ内の相対モジュールのインポートを、1つのディレクトリにマージさ&lt;em&gt;れたかのように&lt;/em&gt;解決できます。</target>
        </trans-unit>
        <trans-unit id="9c907fc236b5576ec4b9496e0b00bbfb71e593bd" translate="yes" xml:space="preserve">
          <source>Using --noResolve</source>
          <target state="translated">noResolveを使用する</target>
        </trans-unit>
        <trans-unit id="fea016f48554330486c9c94e60974382dcd30124" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; also allow for more sophisticated mappings including multiple fall back locations. Consider a project configuration where only some modules are available in one location, and the rest are in another.</source>
          <target state="translated">&lt;code&gt;&quot;paths&quot;&lt;/code&gt; を使用すると、複数のフォールバック場所を含むより洗練されたマッピングも可能になります。一部のモジュールのみが1つの場所で使用可能で、残りは別の場所にあるプロジェクト構成を検討してください。</target>
        </trans-unit>
        <trans-unit id="42ba4227d3af5762437561f59f30ce6a1e5f2260" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; also allows for more sophisticated mappings including multiple fall back locations. Consider a project configuration where only some modules are available in one location, and the rest are in another. A build step would put them all together in one place. The project layout may look like:</source>
          <target state="translated">使い方 &lt;code&gt;&quot;paths&quot;&lt;/code&gt; また、複数のフォールバックの位置など、より洗練されたマッピングが可能になります。一部のモジュールのみが1つの場所で使用可能で、残りは別の場所にあるプロジェクト構成を検討してください。ビルドステップでは、それらすべてを1つの場所にまとめます。プロジェクトのレイアウトは次のようになります。</target>
        </trans-unit>
        <trans-unit id="06cd012e6c788da38d72b27da1a7bbf3bef7051d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--noResolve&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--noResolve&lt;/code&gt; の使用</target>
        </trans-unit>
        <trans-unit id="e5d3bbb6573d95fdc85524c7db21fa164109d78e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;// @ts-check&lt;/code&gt; in a JavaScript file</source>
          <target state="translated">使い方 &lt;code&gt;// @ts-check&lt;/code&gt; JavaScriptファイルに</target>
        </trans-unit>
        <trans-unit id="8afa8edba85ebf100416b76304f95c6450f3141c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; to one of the files in a compilation is equivalent to compiling with &lt;code&gt;--lib es2017.string&lt;/code&gt;.</source>
          <target state="translated">使い方 &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; 編集中のファイルのいずれかにしてコンパイルすると等価である &lt;code&gt;--lib es2017.string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e4933f2a2e7814cc135c9b1388e792cdd66475c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;from&lt;/code&gt; clause a module can copy the exports of a given module to the current module without introducing local names.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 句を使用すると、モジュールはローカル名を導入せずに、特定のモジュールのエクスポートを現在のモジュールにコピーできます。</target>
        </trans-unit>
        <trans-unit id="37a797ad92e300fcb869331595d2c4e343d74dfd" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;import(&quot;mod&quot;)&lt;/code&gt; in a type annotation allows for reaching in a module and accessing its exported declaration without importing it.</source>
          <target state="translated">使用して &lt;code&gt;import(&quot;mod&quot;)&lt;/code&gt; 型注釈には、モジュールに到達し、それをインポートすることなく、そのエクスポート宣言にアクセスすることを可能にします。</target>
        </trans-unit>
        <trans-unit id="72074f269aec1329aae7105fabf958e05d5c07ed" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;instanceof&lt;/code&gt; with classes and union types:</source>
          <target state="translated">クラスと共用体タイプで &lt;code&gt;instanceof&lt;/code&gt; を使用する：</target>
        </trans-unit>
        <trans-unit id="111256c2f12b3cd232c38c44c986dfdd41c62efb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;rootDirs&lt;/code&gt;, you can inform the compiler that there are many &amp;ldquo;virtual&amp;rdquo; directories acting as a single root. This allows the compiler to resolve relative module imports within these &amp;ldquo;virtual&amp;rdquo; directories, as if they were merged in to one directory.</source>
          <target state="translated">&lt;code&gt;rootDirs&lt;/code&gt; を使用すると、単一のルートとして機能する「仮想」ディレクトリが多数あることをコンパイラに通知できます。これにより、コンパイラは、これらの「仮想」ディレクトリ内の相対的なモジュールインポートを、1つのディレクトリにマージされたかのように解決できます。</target>
        </trans-unit>
        <trans-unit id="6fdc800bcd35f72f5dd0659132e5a66ef820079a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;suppressImplicitAnyIndexErrors&lt;/code&gt; is quite a drastic approach. It is recommended to use a &lt;code&gt;@ts-ignore&lt;/code&gt; comment instead:</source>
          <target state="translated">&lt;code&gt;suppressImplicitAnyIndexErrors&lt;/code&gt; の使用は、非常に抜本的なアプローチです。代わりに &lt;code&gt;@ts-ignore&lt;/code&gt; コメントを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="cfd8860cf6465e1b2bdf45812f3f39ab68cf98e0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;tsconfig.json&lt;/code&gt; or &lt;code&gt;jsconfig.json&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; または &lt;code&gt;jsconfig.json&lt;/code&gt; を使用する</target>
        </trans-unit>
        <trans-unit id="3148c33827558727523c9ea9ec8a97850719dfe8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;typeof&lt;/code&gt; to test a variable:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; を使用して変数をテストする：</target>
        </trans-unit>
        <trans-unit id="3512c5d8c5a6f92bc7eb3bc3316fb1091e9fc207" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;typeof&lt;/code&gt; with union types and &lt;code&gt;else&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;typeof&lt;/code&gt; 演算組合の種類として &lt;code&gt;else&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4d577340ac4bb94fb9a7eb6e17e1355af2faee1e" translate="yes" xml:space="preserve">
          <source>Using API</source>
          <target state="translated">APIの利用</target>
        </trans-unit>
        <trans-unit id="87b350fddfa272510c3726ee54b4b05350ba043d" translate="yes" xml:space="preserve">
          <source>Using Babel with TypeScript</source>
          <target state="translated">TypeScriptでBabelを使う</target>
        </trans-unit>
        <trans-unit id="aea338f92c90962e364abdd73770a9a8e0a22f76" translate="yes" xml:space="preserve">
          <source>Using Class Types in Generics</source>
          <target state="translated">ジェネリックでのクラス型の使用</target>
        </trans-unit>
        <trans-unit id="43300137282de05306e305d02f5a4e3a4a8e2d0d" translate="yes" xml:space="preserve">
          <source>Using Command Line Interface</source>
          <target state="translated">コマンドラインインターフェースの使用</target>
        </trans-unit>
        <trans-unit id="8b74d8a06cce7b65888ba4e8c7818fe0688bd9a8" translate="yes" xml:space="preserve">
          <source>Using Modules</source>
          <target state="translated">モジュールの使用</target>
        </trans-unit>
        <trans-unit id="c5dfdd934dc02ab2c210cf3f3003872dcd3d25e6" translate="yes" xml:space="preserve">
          <source>Using Namespaces</source>
          <target state="translated">名前空間の使用</target>
        </trans-unit>
        <trans-unit id="2340df0448163b853367fed9720dff6a29c60ae1" translate="yes" xml:space="preserve">
          <source>Using NuGet with MSBuild</source>
          <target state="translated">MSBuildでNuGetを使う</target>
        </trans-unit>
        <trans-unit id="547f3d366f6ba6dbebb442ff52e5209ac22bfe3d" translate="yes" xml:space="preserve">
          <source>Using React</source>
          <target state="translated">Reactを使う</target>
        </trans-unit>
        <trans-unit id="d7491bb32b4d14f757fef9c824559f69f7177e06" translate="yes" xml:space="preserve">
          <source>Using Type Guards, you can easily work with a variable of a union type:</source>
          <target state="translated">タイプガードを使用すると、ユニオン型の変数を簡単に扱うことができます。</target>
        </trans-unit>
        <trans-unit id="eccd06efc2831f9179398ffcb9ce80cec01c9e63" translate="yes" xml:space="preserve">
          <source>Using Type Parameters in Generic Constraints</source>
          <target state="translated">汎用制約での型パラメータの使用</target>
        </trans-unit>
        <trans-unit id="bb7c0204b1637ead9e29a3786a6bee30ee0e9071" translate="yes" xml:space="preserve">
          <source>Using TypeScript in several environments.</source>
          <target state="translated">いくつかの環境でTypeScriptを使う</target>
        </trans-unit>
        <trans-unit id="ba60f8a349037067c0634dc31a0ac923864cdd8c" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;baseUrl&lt;/code&gt; is a common practice in applications using AMD module loaders where modules are &amp;ldquo;deployed&amp;rdquo; to a single folder at run-time. All module imports with non-relative names are assumed to be relative to the &lt;code&gt;baseUrl&lt;/code&gt;.</source>
          <target state="translated">実行時にモジュールが単一のフォルダーに「デプロイ」されるAMDモジュールローダーを使用するアプリケーションでは、 &lt;code&gt;baseUrl&lt;/code&gt; の使用が一般的です。非相対名でのすべてのモジュールのインポートは、 &lt;code&gt;baseUrl&lt;/code&gt; に関連していると見なされます。</target>
        </trans-unit>
        <trans-unit id="eb2a81ce273392d8c282cd088fcd0585336e4cfd" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;baseUrl&lt;/code&gt; is a common practice in applications using AMD module loaders where modules are &amp;ldquo;deployed&amp;rdquo; to a single folder at run-time. The sources of these modules can live in different directories, but a build script will put them all together.</source>
          <target state="translated">実行時にモジュールが単一のフォルダーに「デプロイ」されるAMDモジュールローダーを使用するアプリケーションでは、 &lt;code&gt;baseUrl&lt;/code&gt; の使用が一般的です。これらのモジュールのソースは異なるディレクトリに存在する場合がありますが、ビルドスクリプトはそれらをすべてまとめます。</target>
        </trans-unit>
        <trans-unit id="b5e01fea434d511ae7f89196d33d7e8c07fa0679" translate="yes" xml:space="preserve">
          <source>Using a class as an interface</source>
          <target state="translated">クラスをインターフェイスとして使う</target>
        </trans-unit>
        <trans-unit id="b21dff09db83d498fc08fa858a2c6f95c4bc7857" translate="yes" xml:space="preserve">
          <source>Using an enum is simple: just access any member as a property off of the enum itself, and declare types using the name of the enum:</source>
          <target state="translated">enumを使うのは簡単です。enum自体からプロパティとして任意のメンバにアクセスし、enumの名前を使って型を宣言するだけです。</target>
        </trans-unit>
        <trans-unit id="e8cff08e29703580b7ac86809f0f79615642a204" translate="yes" xml:space="preserve">
          <source>Using npm</source>
          <target state="translated">npmを使用して</target>
        </trans-unit>
        <trans-unit id="f97748b0bee558e2605da416afdbef74fd01695b" translate="yes" xml:space="preserve">
          <source>Using other JSX frameworks</source>
          <target state="translated">他のJSXフレームワークを使う</target>
        </trans-unit>
        <trans-unit id="5c78cf487464fa0e7c06524cc2aed76314129a78" translate="yes" xml:space="preserve">
          <source>Using target &lt;code&gt;--target ES2016&lt;/code&gt; will instruct the compiler not to transform ES2016-specific features, e.g. &lt;code&gt;**&lt;/code&gt; operator.</source>
          <target state="translated">target &lt;code&gt;--target ES2016&lt;/code&gt; を使用すると、 &lt;code&gt;**&lt;/code&gt; 演算子など、ES2016固有の機能を変換しないようコンパイラーに指示します。</target>
        </trans-unit>
        <trans-unit id="c2bbd5627cb0ada9bd95ef8d96473ec05f861c62" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property</source>
          <target state="translated">使用 &lt;code&gt;&quot;files&quot;&lt;/code&gt; プロパティを</target>
        </trans-unit>
        <trans-unit id="dd019ddcfa9a356cc6a71911adc51d98cc08a82d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&quot;include&quot;&lt;/code&gt; and &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; properties</source>
          <target state="translated">使い方 &lt;code&gt;&quot;include&quot;&lt;/code&gt; と &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; プロパティを</target>
        </trans-unit>
        <trans-unit id="1f9ecf041c00e73da91e933f322f297654272ffc" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;in&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 演算子の使用</target>
        </trans-unit>
        <trans-unit id="8f1886e62dc25a8ce4c42a8a5cea86b655977fa4" translate="yes" xml:space="preserve">
          <source>Using the CLI</source>
          <target state="translated">CLIを使用する</target>
        </trans-unit>
        <trans-unit id="bd12de5962e5ab568b3c5a067da105ee87fe5e16" translate="yes" xml:space="preserve">
          <source>Using this TSConfig:</source>
          <target state="translated">このTSConfigを使って</target>
        </trans-unit>
        <trans-unit id="05695053496c73d09b9080abbb8ddbcec5718d22" translate="yes" xml:space="preserve">
          <source>Using this ability, &lt;code&gt;lib.d.ts&lt;/code&gt; now has a new &lt;code&gt;Required&amp;lt;T&amp;gt;&lt;/code&gt; type. This type strips &lt;code&gt;?&lt;/code&gt; modifiers from all properties of &lt;code&gt;T&lt;/code&gt;, thus making all properties required.</source>
          <target state="translated">この機能を使用して、 &lt;code&gt;lib.d.ts&lt;/code&gt; に新しい &lt;code&gt;Required&amp;lt;T&amp;gt;&lt;/code&gt; タイプが追加されました。このタイプのストリップ &lt;code&gt;?&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; のすべてのプロパティの修飾子。したがって、すべてのプロパティが必要になります。</target>
        </trans-unit>
        <trans-unit id="6f3cf80ca63760070e6103046db8653a28ce64e1" translate="yes" xml:space="preserve">
          <source>Using tsconfig.json</source>
          <target state="translated">tsconfig.jsonを使う</target>
        </trans-unit>
        <trans-unit id="e3ff1e8a9c36f6f4750c05884c5f542d5a46249b" translate="yes" xml:space="preserve">
          <source>Using type predicates</source>
          <target state="translated">型述語の使用</target>
        </trans-unit>
        <trans-unit id="3601427971630988ad2755ef28a7717d757f3df8" translate="yes" xml:space="preserve">
          <source>Using with &lt;code&gt;export =&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;export =&lt;/code&gt; または &lt;code&gt;import&lt;/code&gt; で使用する</target>
        </trans-unit>
        <trans-unit id="aba045b792a727f53d493f5cc2d4bbe68e26bbc6" translate="yes" xml:space="preserve">
          <source>Utility Types</source>
          <target state="translated">ユーティリティの種類</target>
        </trans-unit>
        <trans-unit id="9f89751a678d7643787dbd16a9f2d25d5880c644" translate="yes" xml:space="preserve">
          <source>VS Code has the ability for a extension to &lt;a href=&quot;https://code.visualstudio.com/api/references/contribution-points#contributes.typescriptServerPlugins&quot;&gt;automatically include language service plugins&lt;/a&gt;, and so you may have some running in your editor without needing to define them in your &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="translated">VS Codeには、&lt;a href=&quot;https://code.visualstudio.com/api/references/contribution-points#contributes.typescriptServerPlugins&quot;&gt;言語サービスプラグイン&lt;/a&gt;を自動的に含める拡張機能があります。そのため、 &lt;code&gt;tsconfig.json&lt;/code&gt; でプラグインを定義しなくても、エディターでプラグインを実行できる場合があります。</target>
        </trans-unit>
        <trans-unit id="afdf32ce970b80477ef67d464ba5d9d15cfb327c" translate="yes" xml:space="preserve">
          <source>Validation.ts</source>
          <target state="translated">Validation.ts</target>
        </trans-unit>
        <trans-unit id="524163f0faa0530bac2b1baaeb887189c9c73216" translate="yes" xml:space="preserve">
          <source>Validators in a single file</source>
          <target state="translated">単一ファイルのバリデータ</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="5a0535139a31a774a3c9068d34adc7058d5bf642" translate="yes" xml:space="preserve">
          <source>Value of &lt;em&gt;baseUrl&lt;/em&gt; is determined as either:</source>
          <target state="translated">&lt;em&gt;baseUrlの&lt;/em&gt;値は、&lt;em&gt;次の&lt;/em&gt;いずれかとして決定されます。</target>
        </trans-unit>
        <trans-unit id="577084450a5e984b5f6966940c5dcc148307a726" translate="yes" xml:space="preserve">
          <source>Value-based elements</source>
          <target state="translated">バリューベースの要素</target>
        </trans-unit>
        <trans-unit id="3f2f78c89fa82d18f5843ae8eee30d072a82336b" translate="yes" xml:space="preserve">
          <source>Value-based elements are simply looked up by identifiers that are in scope.</source>
          <target state="translated">値ベースの要素は、単純にスコープ内の識別子で調べます。</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="d79ccf393d6a199b4ad9ea5944ca607bfd113cf4" translate="yes" xml:space="preserve">
          <source>Var-args parameter declaration inferred from use of &lt;code&gt;arguments&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;arguments&lt;/code&gt; 使用から推測されるVar-argsパラメーター宣言</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="5ae56dde19ee92722af581b79a15e413c188460b" translate="yes" xml:space="preserve">
          <source>Variable Declaration</source>
          <target state="translated">変数宣言</target>
        </trans-unit>
        <trans-unit id="532e17316f9909fba79f94428471eb6888d1b255" translate="yes" xml:space="preserve">
          <source>Variable Declarations</source>
          <target state="translated">変数宣言</target>
        </trans-unit>
        <trans-unit id="b3912d587e9569bb7bfd495613a05ef2130c8e37" translate="yes" xml:space="preserve">
          <source>Variable capturing quirks</source>
          <target state="translated">可変キャプチャーのクセ</target>
        </trans-unit>
        <trans-unit id="7c09718bb5da0232e2044986eb3a280f493f26a9" translate="yes" xml:space="preserve">
          <source>Variables declared in a &lt;code&gt;catch&lt;/code&gt; clause also have similar scoping rules.</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 節で宣言された変数にも、同様のスコープ規則があります。</target>
        </trans-unit>
        <trans-unit id="b11bd74b68068c8cda414d69c145cdd12377e1bb" translate="yes" xml:space="preserve">
          <source>Version selection with &lt;code&gt;typesVersions&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;typesVersions&lt;/code&gt; バージョンの選択</target>
        </trans-unit>
        <trans-unit id="4133624045854a306b02e62768cbf604af93f40f" translate="yes" xml:space="preserve">
          <source>Via npm (the Node.js package manager)</source>
          <target state="translated">npm (Node.js パッケージマネージャ)を介して</target>
        </trans-unit>
        <trans-unit id="bbef03a29ac970d4beb2f168015277f559e746e0" translate="yes" xml:space="preserve">
          <source>Virtual Directories with &lt;code&gt;rootDirs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rootDirs&lt;/code&gt; を使用した仮想ディレクトリ</target>
        </trans-unit>
        <trans-unit id="fd7f9c3ff1ebf06a17bf0502aaa043bb8f017fe6" translate="yes" xml:space="preserve">
          <source>Visual Studio 2013 and 2015</source>
          <target state="translated">Visual Studio 2013年と2015年</target>
        </trans-unit>
        <trans-unit id="023fa801554be0ffd9cb5b6327c0e269a7154d1a" translate="yes" xml:space="preserve">
          <source>Visual Studio 2015 and Visual Studio 2013 Update 2 include TypeScript by default. If you didn&amp;rsquo;t install TypeScript with Visual Studio, you can still &lt;a href=&quot;https://www.typescriptlang.org/#download-links&quot;&gt;download it&lt;/a&gt;.</source>
          <target state="translated">Visual Studio 2015およびVisual Studio 2013 Update 2には、デフォルトでTypeScriptが含まれています。TypeScriptをVisual Studioと共にインストールしなかった場合でも、&lt;a href=&quot;https://www.typescriptlang.org/#download-links&quot;&gt;ダウンロードできます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="353b01045c518e21b3e08d0cee10940ef65c683f" translate="yes" xml:space="preserve">
          <source>Visual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript by default. If you didn&amp;rsquo;t install TypeScript with Visual Studio, you can still &lt;a href=&quot;https://www.typescriptlang.org/#download-links&quot;&gt;download it&lt;/a&gt;.</source>
          <target state="translated">Visual Studio 2017およびVisual Studio 2015 Update 3には、デフォルトでTypeScriptが含まれています。TypeScriptをVisual Studioと共にインストールしなかった場合でも、&lt;a href=&quot;https://www.typescriptlang.org/#download-links&quot;&gt;ダウンロードできます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4bd86a16fcf22eb738bf2f6614ab69242ef036b" translate="yes" xml:space="preserve">
          <source>Visual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript by default. If you didn&amp;rsquo;t install TypeScript with Visual Studio, you can still &lt;a href=&quot;https://www.typescriptlang.org/download&quot;&gt;download it&lt;/a&gt;.</source>
          <target state="translated">Visual Studio2017およびVisualStudio 2015 Update 3には、デフォルトでTypeScriptが含まれています。Visual StudioでTypeScriptをインストールしなかった場合でも、&lt;a href=&quot;https://www.typescriptlang.org/download&quot;&gt;ダウンロードできます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="423f1f3d80c4d824ca917e13649a5c584a13ec87" translate="yes" xml:space="preserve">
          <source>Visual Studio Code</source>
          <target state="translated">Visual Studioコード</target>
        </trans-unit>
        <trans-unit id="a54600c66809939b059f9682e260da90c5cc8595" translate="yes" xml:space="preserve">
          <source>Visual Studio should start installing gulp and del as soon as you save the file. If not, right-click package.json and then Restore Packages.</source>
          <target state="translated">Visual Studioはファイルを保存するとすぐにgulpとdelのインストールを開始するはずです。そうでない場合は、package.jsonを右クリックしてからRestore Packagesを実行してください。</target>
        </trans-unit>
        <trans-unit id="207c7c00630b836d3afb46848bdb24a92023331d" translate="yes" xml:space="preserve">
          <source>Void</source>
          <target state="translated">Void</target>
        </trans-unit>
        <trans-unit id="1e2aae0cdb6f3a79d62e669c768545f8953beef6" translate="yes" xml:space="preserve">
          <source>Watch Options</source>
          <target state="translated">時計のオプション</target>
        </trans-unit>
        <trans-unit id="369e965336691b4254b406f11997b3fb8754eafe" translate="yes" xml:space="preserve">
          <source>Watchify</source>
          <target state="translated">Watchify</target>
        </trans-unit>
        <trans-unit id="4306cbf1196af02448fb51c54f07ce1e5c41ddbb" translate="yes" xml:space="preserve">
          <source>Watchify starts gulp and keeps it running, incrementally compiling whenever you save a file. This lets you keep an edit-save-refresh cycle going in the browser.</source>
          <target state="translated">Watchify は gulp を起動して実行し続け、ファイルを保存するたびにインクリメンタルにコンパイルする。これにより、ブラウザ上で編集・保存・再更新のサイクルを維持することができる。</target>
        </trans-unit>
        <trans-unit id="2e4ac287a7b8a6ec87dd3885f171fdb1cb26939c" translate="yes" xml:space="preserve">
          <source>Watchify, Babel, and Uglify</source>
          <target state="translated">ウォッチファイ、バベル、ウグライファイ</target>
        </trans-unit>
        <trans-unit id="f89058c451cdea76e04b5f0c00e5ff23bd62a1b8" translate="yes" xml:space="preserve">
          <source>We added two overload signatures to &lt;code&gt;myCoolFunction&lt;/code&gt;. The first checks states that &lt;code&gt;myCoolFunction&lt;/code&gt; takes a function (which takes a &lt;code&gt;number&lt;/code&gt;), and then a list of &lt;code&gt;number&lt;/code&gt;s. The second one says that it will take a function as well, and then uses a rest parameter (&lt;code&gt;...nums&lt;/code&gt;) to state that any number of arguments after that need to be &lt;code&gt;number&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;myCoolFunction&lt;/code&gt; に 2つのオーバーロードシグネチャを追加しました。最初のチェックでは、 &lt;code&gt;myCoolFunction&lt;/code&gt; が関数（ &lt;code&gt;number&lt;/code&gt; をとる）を取り、次に &lt;code&gt;number&lt;/code&gt; sのリストをとります。もう一つは、それは、同様の機能を取り、その後、残りのパラメータ（使用することを言います &lt;code&gt;...nums&lt;/code&gt; 可能にすることの必要性の後に任意の数の引数という状態に） &lt;code&gt;number&lt;/code&gt; 秒。</target>
        </trans-unit>
        <trans-unit id="906c596e0e9e46a347b462739c927291c09ad640" translate="yes" xml:space="preserve">
          <source>We also disable the project properties page when you add a &lt;code&gt;tsconfig.json&lt;/code&gt; file. This means that all configuration changes have to be made in the &lt;code&gt;tsconfig.json&lt;/code&gt; file itself.</source>
          <target state="translated">また、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを追加すると、プロジェクトのプロパティページが無効になります。つまり、すべての構成変更は &lt;code&gt;tsconfig.json&lt;/code&gt; ファイル自体で行う必要があります。</target>
        </trans-unit>
        <trans-unit id="862f52cc171b96bf071e122091285af320650575" translate="yes" xml:space="preserve">
          <source>We also have an &lt;a href=&quot;https://www.typescriptlang.org/assets/typescript-handbook-beta.epub&quot;&gt;epub&lt;/a&gt; and &lt;a href=&quot;https://www.typescriptlang.org/assets/typescript-handbook-beta.pdf&quot;&gt;pdf&lt;/a&gt; version of the Handbook.</source>
          <target state="translated">我々はまた、持っている&lt;a href=&quot;https://www.typescriptlang.org/assets/typescript-handbook-beta.epub&quot;&gt;EPUB&lt;/a&gt;と&lt;a href=&quot;https://www.typescriptlang.org/assets/typescript-handbook-beta.pdf&quot;&gt;PDF&lt;/a&gt;ハンドブックのバージョンを。</target>
        </trans-unit>
        <trans-unit id="fce7ec51558a4620670481cd3447782aedb45ad7" translate="yes" xml:space="preserve">
          <source>We also need to have TypeScript target ES2015. Babel will then produce ES5 from the ES2015 code that TypeScript emits. Let&amp;rsquo;s modify &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">TypeScriptターゲットES2015も必要です。その後、BabelはTypeScriptが発行するES2015コードからES5を生成します。 &lt;code&gt;tsconfig.json&lt;/code&gt; を変更してみましょう：</target>
        </trans-unit>
        <trans-unit id="eb158a631eeb5215d7f9b41d49e937425bf4888b" translate="yes" xml:space="preserve">
          <source>We are often faced with writing a declaration file when we only have examples of the underlying library to guide us. The &lt;a href=&quot;by-example&quot;&gt;Declaration Reference&lt;/a&gt; section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.</source>
          <target state="translated">基礎となるライブラリの例しかない場合、宣言ファイルの作成に直面することがよくあります。「&lt;a href=&quot;by-example&quot;&gt;宣言リファレンス」&lt;/a&gt;セクションには、多くの一般的なAPIパターンと、それぞれの宣言の記述方法が示されています。このガイドは、TypeScriptのすべての言語構成にまだ精通していない可能性のあるTypeScript初心者を対象としています。</target>
        </trans-unit>
        <trans-unit id="eca6da16584407722c05c582e9312d4b12506c7e" translate="yes" xml:space="preserve">
          <source>We assume that you&amp;rsquo;re already using &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; with &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npmで&lt;/a&gt;&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;をすでに使用していることを前提としています。</target>
        </trans-unit>
        <trans-unit id="dccbace9aee63165dc6770bfacb34962fe498a76" translate="yes" xml:space="preserve">
          <source>We call declarations that don&amp;rsquo;t define an implementation &amp;ldquo;ambient&amp;rdquo;. Typically these are defined in &lt;code&gt;.d.ts&lt;/code&gt; files. If you&amp;rsquo;re familiar with C/C++, you can think of these as &lt;code&gt;.h&lt;/code&gt; files. Let&amp;rsquo;s look at a few examples.</source>
          <target state="translated">実装を定義しない宣言を「アンビエント」と呼びます。通常、これらは &lt;code&gt;.d.ts&lt;/code&gt; ファイルで定義されます。C / C ++に精通している場合は、これらを &lt;code&gt;.h&lt;/code&gt; ファイルと考えることができます。いくつかの例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="92c076044fe3078a3a2d956ae660fa0b4723354a" translate="yes" xml:space="preserve">
          <source>We call declarations that don&amp;rsquo;t define an implementation &amp;ldquo;ambient&amp;rdquo;. Typically, these are defined in &lt;code&gt;.d.ts&lt;/code&gt; files. If you&amp;rsquo;re familiar with C/C++, you can think of these as &lt;code&gt;.h&lt;/code&gt; files. Let&amp;rsquo;s look at a few examples.</source>
          <target state="translated">実装を定義しない宣言を「アンビエント」と呼びます。通常、これらは &lt;code&gt;.d.ts&lt;/code&gt; ファイルで定義されます。C / C ++に精通している場合は、これらを &lt;code&gt;.h&lt;/code&gt; ファイルと考えることができます。いくつかの例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="d7554b9ee0145ef5796d9b34e5b993a1e04de397" translate="yes" xml:space="preserve">
          <source>We called &lt;code&gt;watchedBrowserify.on('log', fancy_log);&lt;/code&gt; to log to the console.</source>
          <target state="translated">私たちはと呼ばれる &lt;code&gt;watchedBrowserify.on('log', fancy_log);&lt;/code&gt; コンソールにログインします。</target>
        </trans-unit>
        <trans-unit id="5dedc9b8f5d0ca8dda8092dbf79a3b7121e6221e" translate="yes" xml:space="preserve">
          <source>We called &lt;code&gt;watchedBrowserify.on('update', bundle);&lt;/code&gt; so that Browserify will run the &lt;code&gt;bundle&lt;/code&gt; function every time one of your TypeScript files changes.</source>
          <target state="translated">&lt;code&gt;watchedBrowserify.on('update', bundle);&lt;/code&gt; を呼び出しました。Typeify ファイルが変更されるたびにBrowserifyが &lt;code&gt;bundle&lt;/code&gt; 関数を実行するようにします。</target>
        </trans-unit>
        <trans-unit id="d78c8a7db971a258629029d93d5ac32c8f9a6480" translate="yes" xml:space="preserve">
          <source>We can add additional members to an &lt;code&gt;interface&lt;/code&gt; with another &lt;code&gt;interface&lt;/code&gt; declaration:</source>
          <target state="translated">別の &lt;code&gt;interface&lt;/code&gt; 宣言を &lt;code&gt;interface&lt;/code&gt; して、インターフェースにメンバーを追加できます。</target>
        </trans-unit>
        <trans-unit id="72346222530ba2a9b0966af45f7d0245b45ebadb" translate="yes" xml:space="preserve">
          <source>We can add types to each of the parameters and then to the function itself to add a return type. TypeScript can figure the return type out by looking at the return statements, so we can also optionally leave this off in many cases.</source>
          <target state="translated">それぞれのパラメータに型を追加し、関数自体に戻り値の型を追加することができます。TypeScriptはreturn文を見てreturn型を見つけ出すことができるので、多くの場合はオプションでこれを省略することもできます。</target>
        </trans-unit>
        <trans-unit id="3ffa5dba257543828c847bbd33acb3e1bdc1db72" translate="yes" xml:space="preserve">
          <source>We can also declare a variable inside of a function:</source>
          <target state="translated">関数の中で変数を宣言することもできます。</target>
        </trans-unit>
        <trans-unit id="661d963b4beb85aa27dfba66adb8817f5f2d18c5" translate="yes" xml:space="preserve">
          <source>We can also explicitly give type information to the function&amp;rsquo;s argument to override any contextual type:</source>
          <target state="translated">関数の引数に型情報を明示的に与えて、コンテキストタイプをオーバーライドすることもできます。</target>
        </trans-unit>
        <trans-unit id="eaa8774bff1b83856163130bd5db5fa1d1e6c687" translate="yes" xml:space="preserve">
          <source>We can also have a type alias refer to itself in a property:</source>
          <target state="translated">また、プロパティ内で型のエイリアスがそれ自身を参照することもできます。</target>
        </trans-unit>
        <trans-unit id="a869a9aafbfef91521e95e5db94bb387cae93e3a" translate="yes" xml:space="preserve">
          <source>We can also write the generic type as a call signature of an object literal type:</source>
          <target state="translated">また、オブジェクトリテラル型のコールシグネチャとしてジェネリック型を書くこともできます。</target>
        </trans-unit>
        <trans-unit id="658e04fc9fb0e75106204a24f2c9d06bdf8f78c2" translate="yes" xml:space="preserve">
          <source>We can alternatively write the sample example this way:</source>
          <target state="translated">代わりにサンプル例をこのように書くこともできます。</target>
        </trans-unit>
        <trans-unit id="ff36204ad2dc388ad3938b7f629d5c14ff6e7faf" translate="yes" xml:space="preserve">
          <source>We can define the &lt;code&gt;@configurable&lt;/code&gt; decorator using the following function declaration:</source>
          <target state="translated">次の関数宣言を使用して、 &lt;code&gt;@configurable&lt;/code&gt; デコレータを定義できます。</target>
        </trans-unit>
        <trans-unit id="82bc383c0b279737360de0b5872e4eaf53cabffa" translate="yes" xml:space="preserve">
          <source>We can define the &lt;code&gt;@enumerable&lt;/code&gt; decorator using the following function declaration:</source>
          <target state="translated">次の関数宣言を使用して、 &lt;code&gt;@enumerable&lt;/code&gt; デコレータを定義できます。</target>
        </trans-unit>
        <trans-unit id="7089db4e18a0f27d1d43d048ff6a50fbd3dce944" translate="yes" xml:space="preserve">
          <source>We can define the &lt;code&gt;@sealed&lt;/code&gt; decorator using the following function declaration:</source>
          <target state="translated">次の関数宣言を使用して &lt;code&gt;@sealed&lt;/code&gt; デコレータを定義できます。</target>
        </trans-unit>
        <trans-unit id="9b791fa8333e00451d101fd617a6f57b865394fd" translate="yes" xml:space="preserve">
          <source>We can extend the existing module like the following:</source>
          <target state="translated">既存のモジュールを以下のように拡張します。</target>
        </trans-unit>
        <trans-unit id="12d89086425b5ee284135e15deb90e23ed2590c7" translate="yes" xml:space="preserve">
          <source>We can fix this by making sure the function is bound to the correct &lt;code&gt;this&lt;/code&gt; before we return the function to be used later. This way, regardless of how it&amp;rsquo;s later used, it will still be able to see the original &lt;code&gt;deck&lt;/code&gt; object. To do this, we change the function expression to use the ECMAScript 6 arrow syntax. Arrow functions capture the &lt;code&gt;this&lt;/code&gt; where the function is created rather than where it is invoked:</source>
          <target state="translated">これを修正するには、後で使用する関数を返す前に、関数が正しい &lt;code&gt;this&lt;/code&gt; にバインドされていることを確認します。この方法では、後でどのように使用されるかに関係なく、元の &lt;code&gt;deck&lt;/code&gt; オブジェクトを引き続き表示できます。これを行うには、ECMAScript 6の矢印構文を使用するように関数式を変更します。矢印関数は、関数が呼び出される場所ではなく、作成される &lt;code&gt;this&lt;/code&gt; をキャプチャします。</target>
        </trans-unit>
        <trans-unit id="c6ea0d2b6b5f45da1e1324a08cfc0e11b786897c" translate="yes" xml:space="preserve">
          <source>We can see this in action in the following example:</source>
          <target state="translated">このことは、次の例で見ることができます。</target>
        </trans-unit>
        <trans-unit id="65140ca83fcc5d0530859c1beb185464ff42f37a" translate="yes" xml:space="preserve">
          <source>We can see this more clearly in this example:</source>
          <target state="translated">この例では、このことがより明確にわかります。</target>
        </trans-unit>
        <trans-unit id="ee21326f232b62bacd8134f20c57de98fb355244" translate="yes" xml:space="preserve">
          <source>We can then define the &lt;code&gt;@format&lt;/code&gt; decorator and &lt;code&gt;getFormat&lt;/code&gt; functions using the following function declarations:</source>
          <target state="translated">次に、以下の関数宣言を使用して、 &lt;code&gt;@format&lt;/code&gt; デコレーターおよび &lt;code&gt;getFormat&lt;/code&gt; 関数を定義できます。</target>
        </trans-unit>
        <trans-unit id="bd3c3bda45ff67c029de2e2368aec01e7ef3a4eb" translate="yes" xml:space="preserve">
          <source>We can then define the &lt;code&gt;@required&lt;/code&gt; and &lt;code&gt;@validate&lt;/code&gt; decorators using the following function declarations:</source>
          <target state="translated">次に、次の関数宣言を使用して &lt;code&gt;@required&lt;/code&gt; および &lt;code&gt;@validate&lt;/code&gt; デコレータを定義できます。</target>
        </trans-unit>
        <trans-unit id="db549ad2d4eebb5605913a990e51c4ee29c07c32" translate="yes" xml:space="preserve">
          <source>We can use this information to record metadata about the property, as in the following example:</source>
          <target state="translated">この情報を利用して、次の例のようにプロパティに関するメタデータを記録することができます。</target>
        </trans-unit>
        <trans-unit id="ea01d2c138e3b5218d8e1d52564f033747bdd0ce" translate="yes" xml:space="preserve">
          <source>We can write a decorator factory in the following fashion:</source>
          <target state="translated">デコレータファクトリーは以下のような書き方で書けます。</target>
        </trans-unit>
        <trans-unit id="171a94c1fd6a31b533d269529646e906879fde4e" translate="yes" xml:space="preserve">
          <source>We can write the same example again, this time using an interface to describe the requirement of having the &lt;code&gt;label&lt;/code&gt; property that is a string:</source>
          <target state="translated">同じ例をもう一度書くことができますが、今度はインターフェースを使用して、文字列である &lt;code&gt;label&lt;/code&gt; プロパティが必要であることを説明します。</target>
        </trans-unit>
        <trans-unit id="d0f35bfcf99e7f68867547c0414c1be9551ec721" translate="yes" xml:space="preserve">
          <source>We could also add a namespaced type to a class:</source>
          <target state="translated">また、クラスにネームスペース型を追加することもできます。</target>
        </trans-unit>
        <trans-unit id="f1593c28383f7f19b9f300464de36e13bda32294" translate="yes" xml:space="preserve">
          <source>We could also have used a different name for the generic type parameter in the type, so long as the number of type variables and how the type variables are used line up.</source>
          <target state="translated">型の中の汎用型パラメータの名前を変えても、型変数の数と型変数の使い方が一致していれば大丈夫でした。</target>
        </trans-unit>
        <trans-unit id="81879f8730c017d5576f5e7bef1f5b5dd6185843" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend using this flag in a modern codebase, you can suppress one-off cases where you need it using &lt;code&gt;// @ts-ignore&lt;/code&gt;.</source>
          <target state="translated">私たちは、現代のコードベースでこのフラグを使用することはお勧めしません、あなたは一回限りの使用して、それを必要とする場合も抑えることができます &lt;code&gt;// @ts-ignore&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ae12050685d86d62a3f9d2765b3b1a3a61021e1" translate="yes" xml:space="preserve">
          <source>We frequently see the question &amp;ldquo;Should I learn JavaScript or TypeScript?&amp;ldquo;.</source>
          <target state="translated">「JavaScriptとTypeScriptのどちらを学ぶべきか」という質問をよく目にします。</target>
        </trans-unit>
        <trans-unit id="13a79655a0f6dc78edf29c467dcf807b7ee04905" translate="yes" xml:space="preserve">
          <source>We just imported our &lt;code&gt;Hello&lt;/code&gt; component into &lt;code&gt;index.tsx&lt;/code&gt;. Notice that unlike with &lt;code&gt;&quot;react&quot;&lt;/code&gt; or &lt;code&gt;&quot;react-dom&quot;&lt;/code&gt;, we used a &lt;em&gt;relative path&lt;/em&gt; to &lt;code&gt;Hello.tsx&lt;/code&gt; - this is important. If we hadn&amp;rsquo;t, TypeScript would&amp;rsquo;ve instead tried looking in our &lt;code&gt;node_modules&lt;/code&gt; folder.</source>
          <target state="translated">&lt;code&gt;Hello&lt;/code&gt; コンポーネントを &lt;code&gt;index.tsx&lt;/code&gt; にインポートしました。 &lt;code&gt;&quot;react&quot;&lt;/code&gt; や &lt;code&gt;&quot;react-dom&quot;&lt;/code&gt; とは異なり、 &lt;code&gt;Hello.tsx&lt;/code&gt; への&lt;em&gt;相対パス&lt;/em&gt;を使用した&lt;em&gt;こと&lt;/em&gt;に注意してください。これは重要です。そうでなければ、TypeScriptは代わりに &lt;code&gt;node_modules&lt;/code&gt; フォルダーを調べてみました。</target>
        </trans-unit>
        <trans-unit id="3fbc60a8f3964107caa151501b90a1aec6061763" translate="yes" xml:space="preserve">
          <source>We may need to describe the type of variables that we do not know when we are writing an application. These values may come from dynamic content &amp;ndash; e.g. from the user &amp;ndash; or we may want to intentionally accept all values in our API. In these cases, we want to provide a type that tells the compiler and future readers that this variable could be anything, so we give it the &lt;code&gt;unknown&lt;/code&gt; type.</source>
          <target state="translated">アプリケーションを作成するときにわからない変数のタイプを説明する必要があるかもしれません。これらの値は、動的コンテンツ（ユーザーなど）から取得される場合もあれば、APIのすべての値を意図的に受け入れる場合もあります。このような場合、コンパイラと将来の読者にこの変数は何でもよいことを伝える型を提供したいので、 &lt;code&gt;unknown&lt;/code&gt; 型を指定します。</target>
        </trans-unit>
        <trans-unit id="e3b6c237e5c56a0727a6cedbb2962b0899558457" translate="yes" xml:space="preserve">
          <source>We may need to describe the type of variables that we do not know when we are writing an application. These values may come from dynamic content, e.g. from the user or a 3rd party library. In these cases, we want to opt-out of type checking and let the values pass through compile-time checks. To do so, we label these with the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target state="translated">アプリケーションの作成時にわからない変数のタイプを説明する必要がある場合があります。これらの値は、ユーザーやサードパーティライブラリなどの動的コンテンツから取得される場合があります。これらの場合、型チェックをオプトアウトして、値をコンパイル時チェックに通したいとします。これを行うには、これらに &lt;code&gt;any&lt;/code&gt; タイプのラベルを付けます。</target>
        </trans-unit>
        <trans-unit id="7e0b762a7d5b6b35f90cd8500631ccf9ab22b8c1" translate="yes" xml:space="preserve">
          <source>We need to setup NPM so that JavaScript packages can be downloaded. Right click on the project and select &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;NPM Configuration File&lt;/strong&gt; and use the default name of &lt;code&gt;package.json&lt;/code&gt;.</source>
          <target state="translated">JavaScriptパッケージをダウンロードできるように、NPMをセットアップする必要があります。プロジェクトを右クリックし、[ &lt;strong&gt;新しいアイテム&lt;/strong&gt; ]を選択します。次に、&lt;strong&gt;NPM構成ファイル&lt;/strong&gt;を選択し、 &lt;code&gt;package.json&lt;/code&gt; のデフォルト名を使用します。</target>
        </trans-unit>
        <trans-unit id="ebc466c22e7712a5cff2da5cf89c0cc81b64e2a7" translate="yes" xml:space="preserve">
          <source>We owe a big thanks to GitHub user &lt;a href=&quot;https://github.com/jwbay&quot;&gt;@jwbay&lt;/a&gt; who took the initiative to create a &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32802&quot;&gt;proof-of-concept&lt;/a&gt; and iterated to provide us with with &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33178&quot;&gt;the current version&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32802&quot;&gt;概念実証の&lt;/a&gt;作成に率先して取り組み&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33178&quot;&gt;、現在のバージョン&lt;/a&gt;を提供するために&lt;a href=&quot;https://github.com/jwbay&quot;&gt;イテレーション&lt;/a&gt;を行ったGitHubユーザー@jwbayに深く感謝します。</target>
        </trans-unit>
        <trans-unit id="894e0a020d31c47096948e05d4d7e1a77b0f6785" translate="yes" xml:space="preserve">
          <source>We owe a large thanks to community members &lt;a href=&quot;https://github.com/Kingwl&quot;&gt;Wenlu Wang&lt;/a&gt; and &lt;a href=&quot;https://github.com/dragomirtitian&quot;&gt;Titian Cernicova Dragomir&lt;/a&gt; for implementing this feature! For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32883&quot;&gt;check out their pull request&lt;/a&gt; and &lt;a href=&quot;https://github.com/tc39/proposal-nullish-coalescing/&quot;&gt;the nullish coalescing proposal repository&lt;/a&gt;.</source>
          <target state="translated">この機能を実装してくれたコミュニティメンバーの&lt;a href=&quot;https://github.com/Kingwl&quot;&gt;Wenlu Wang&lt;/a&gt;と&lt;a href=&quot;https://github.com/dragomirtitian&quot;&gt;Titian Cernicova Dragomir&lt;/a&gt;に感謝します。詳細については、&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32883&quot;&gt;プルリクエスト&lt;/a&gt;と&lt;a href=&quot;https://github.com/tc39/proposal-nullish-coalescing/&quot;&gt;無効な合体提案リポジトリを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="cbd7c75518818af1c60b72b48de1120f76c7411f" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;a href=&quot;#strict&quot;&gt;compiler option &lt;code&gt;strict&lt;/code&gt;&lt;/a&gt; to opt-in to every possible improvement as they are built.</source>
          <target state="translated">&lt;a href=&quot;#strict&quot;&gt;コンパイラオプション &lt;code&gt;strict&lt;/code&gt; &lt;/a&gt;を使用して、構築時に考えられるすべての改善をオプトインすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="027ffea53cb8344a8ca0b02644101c1fc88508e6" translate="yes" xml:space="preserve">
          <source>We said earlier that some languages wouldn&amp;rsquo;t allow those buggy programs to run at all. Detecting errors in code without running it is referred to as &lt;em&gt;static checking&lt;/em&gt;. Determining what&amp;rsquo;s an error and what&amp;rsquo;s not based on the kinds of values being operated on is known as static &lt;em&gt;type&lt;/em&gt; checking.</source>
          <target state="translated">一部の言語では、これらのバグのあるプログラムをまったく実行できないと前述しました。コードを実行せずにエラーを検出することを&lt;em&gt;静的チェック&lt;/em&gt;と呼びます。何がエラーで、何が操作されている値の種類に基づいていないかを判別することは、静的&lt;em&gt;型&lt;/em&gt;チェックと呼ばれます。</target>
        </trans-unit>
        <trans-unit id="2be98474a5452e0a16847898535c758700d80e71" translate="yes" xml:space="preserve">
          <source>We say that this version of the &lt;code&gt;identity&lt;/code&gt; function is generic, as it works over a range of types. Unlike using &lt;code&gt;any&lt;/code&gt;, it&amp;rsquo;s also just as precise (ie, it doesn&amp;rsquo;t lose any information) as the first &lt;code&gt;identity&lt;/code&gt; function that used numbers for the argument and return type.</source>
          <target state="translated">&lt;code&gt;identity&lt;/code&gt; 関数のこのバージョンは、さまざまなタイプで機能するため、ジェネリックであると言います。 &lt;code&gt;any&lt;/code&gt; を使用する場合とは異なり、引数と戻り値の型に数値を使用した最初の &lt;code&gt;identity&lt;/code&gt; 関数と同じくらい正確です（つまり、情報を失うことはありません）。</target>
        </trans-unit>
        <trans-unit id="b6da2cbd96b3e75b9187d15de475de9ac9b10faa" translate="yes" xml:space="preserve">
          <source>We strongly encourage users to try the &lt;code&gt;useDefineForClassFields&lt;/code&gt; flag and report back on our issue tracker or in the comments below. This includes feedback on difficulty of adopting the flag so we can understand how we can make migration easier.</source>
          <target state="translated">&lt;code&gt;useDefineForClassFields&lt;/code&gt; フラグを試して、問題トラッカーまたは以下のコメントに報告することを強くお勧めします。これには、移行を容易にする方法を理解できるように、フラグを採用する難しさに関するフィードバックが含まれます。</target>
        </trans-unit>
        <trans-unit id="c7a2b84a24b11f7b028b0dbae7870221e6b866b5" translate="yes" xml:space="preserve">
          <source>We understand that a ton of monochrome output can be a little difficult on the eyes. Colors can help discern where a message starts and ends, and these visual clues are important when error output gets overwhelming.</source>
          <target state="translated">1トンのモノクロ出力は、目に少し負担がかかることは理解しています。色は、メッセージがどこで始まり、どこで終わるのかを識別するのに役立ち、エラー出力が圧倒される場合には、これらの視覚的な手がかりが重要です。</target>
        </trans-unit>
        <trans-unit id="9c538d5dd6bb04252a1e101d363501930cb1f96c" translate="yes" xml:space="preserve">
          <source>We used a &lt;code&gt;.ts&lt;/code&gt; extension, but this code is just JavaScript. You could have copy/pasted this straight out of an existing JavaScript app.</source>
          <target state="translated">&lt;code&gt;.ts&lt;/code&gt; 拡張子を使用しましたが、このコードは単なるJavaScriptです。これを既存のJavaScriptアプリから直接コピー/貼り付けることができます。</target>
        </trans-unit>
        <trans-unit id="0e0159d00e8ed5efa3d03297f6ba1361aeceb56f" translate="yes" xml:space="preserve">
          <source>We would like the compiler to tell us when we don&amp;rsquo;t cover all variants of the discriminated union. For example, if we add &lt;code&gt;NetworkFromCachedState&lt;/code&gt; to &lt;code&gt;NetworkState&lt;/code&gt;, we need to update &lt;code&gt;logger&lt;/code&gt; as well:</source>
          <target state="translated">識別された共用体のすべてのバリアントをカバーしていない場合は、コンパイラに通知してもらいたいと思います。たとえば、 &lt;code&gt;NetworkFromCachedState&lt;/code&gt; を &lt;code&gt;NetworkState&lt;/code&gt; に追加する場合、 &lt;code&gt;logger&lt;/code&gt; も更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="5123383e9966536bbcb7f101d2b7d8f6a074dca8" translate="yes" xml:space="preserve">
          <source>We would like the compiler to tell us when we don&amp;rsquo;t cover all variants of the discriminated union. For example, if we add &lt;code&gt;Triangle&lt;/code&gt; to &lt;code&gt;Shape&lt;/code&gt;, we need to update &lt;code&gt;area&lt;/code&gt; as well:</source>
          <target state="translated">差別化された共用体のすべてのバリアントをカバーしない場合は、コンパイラーにそのことを知らせてください。たとえば、 &lt;code&gt;Triangle&lt;/code&gt; を &lt;code&gt;Shape&lt;/code&gt; に追加する場合、 &lt;code&gt;area&lt;/code&gt; も更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="9c5b24b66e133e695b5340a53b29a9a03a4588c0" translate="yes" xml:space="preserve">
          <source>We wrapped our &lt;code&gt;browserify&lt;/code&gt; instance in a call to &lt;code&gt;watchify&lt;/code&gt;, and then held on to the result.</source>
          <target state="translated">私たちは、ラップ &lt;code&gt;browserify&lt;/code&gt; の呼び出しでインスタンスを &lt;code&gt;watchify&lt;/code&gt; し、その結果に開催します。</target>
        </trans-unit>
        <trans-unit id="b6077b883e1d7e622df4d40c8eae3398ce7b9837" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d like to extend a huge thanks to &lt;a href=&quot;https://github.com/calebsander&quot;&gt;Caleb Sander&lt;/a&gt; for all the work on this feature. We&amp;rsquo;re grateful for the contribution, and we&amp;rsquo;re sure our users are too!</source>
          <target state="translated">この機能に関するすべての作業について、&lt;a href=&quot;https://github.com/calebsander&quot;&gt;Caleb Sander&lt;/a&gt;に深く感謝します。私たちは貢献に感謝しており、ユーザーもそうであると確信しています！</target>
        </trans-unit>
        <trans-unit id="2955af2348407c162d10bf22c8f15b1a2bc20810" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll also need a page to display our &lt;code&gt;Hello&lt;/code&gt; component. Create a file at the root of &lt;code&gt;proj&lt;/code&gt; named &lt;code&gt;index.html&lt;/code&gt; with the following contents:</source>
          <target state="translated">&lt;code&gt;Hello&lt;/code&gt; コンポーネントを表示するページも必要です。 &lt;code&gt;proj&lt;/code&gt; のルートに &lt;code&gt;index.html&lt;/code&gt; という名前のファイルを作成し、次の内容を含めます。</target>
        </trans-unit>
        <trans-unit id="9886aca5459083f9b058f494e9b979c3c4ef1899" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll cover classes later in this guide.</source>
          <target state="translated">このガイドの後半でクラスについて説明します。</target>
        </trans-unit>
        <trans-unit id="eb0e5a7f6725b7d626b76e36ae307b3fc402a1e2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss index signatures in a bit, but here we&amp;rsquo;re saying a &lt;code&gt;SquareConfig&lt;/code&gt; can have any number of properties, and as long as they aren&amp;rsquo;t &lt;code&gt;color&lt;/code&gt; or &lt;code&gt;width&lt;/code&gt;, their types don&amp;rsquo;t matter.</source>
          <target state="translated">インデックスシグネチャについて少し説明しますが、ここでは &lt;code&gt;SquareConfig&lt;/code&gt; は任意の数のプロパティを持つことができ、それらが &lt;code&gt;color&lt;/code&gt; または &lt;code&gt;width&lt;/code&gt; でない限り、それらのタイプは重要ではありません。</target>
        </trans-unit>
        <trans-unit id="1a2f59b32ace790506f0abdad902dd97d8982882" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll first start off with numeric enums, which are probably more familiar if you&amp;rsquo;re coming from other languages. An enum can be defined using the &lt;code&gt;enum&lt;/code&gt; keyword.</source>
          <target state="translated">最初に数値列挙型から始めます。他の言語を使用している場合は、おそらくより馴染みがあります。enumは、 &lt;code&gt;enum&lt;/code&gt; キーワードを使用して定義できます。</target>
        </trans-unit>
        <trans-unit id="ff341e9ebeb5367479b561ddef0d845208be6d6e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll learn more about how classes relate to each other in the Classes chapter.</source>
          <target state="translated">クラスの相互関係については、クラスの章で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="19448f8bcee986b6f99112a504f95247ef4c159e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll start with Watchify to provide background compilation:</source>
          <target state="translated">Watchifyから始めて、バックグラウンドコンパイルを提供します。</target>
        </trans-unit>
        <trans-unit id="0b37518565138e9254324247a79b02efcfc6deef" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re also creating another value that we call the &lt;em&gt;constructor function&lt;/em&gt;. This is the function that is called when we &lt;code&gt;new&lt;/code&gt; up instances of the class. To see what this looks like in practice, let&amp;rsquo;s take a look at the JavaScript created by the above example:</source>
          <target state="translated">また、&lt;em&gt;コンストラクター関数&lt;/em&gt;と呼ばれる別の値を作成しています。これは、クラスのインスタンスを &lt;code&gt;new&lt;/code&gt; するときに呼び出される関数です。これが実際にどのように見えるかを確認するために、上記の例で作成されたJavaScriptを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="7aff8cf77620ede7bc7d3e8d39158810b0f689b3" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re also including two other utility types as well: &lt;code&gt;Record&lt;/code&gt; and &lt;code&gt;Pick&lt;/code&gt;.</source>
          <target state="translated">他に2つのユーティリティタイプ、 &lt;code&gt;Record&lt;/code&gt; と &lt;code&gt;Pick&lt;/code&gt; も含まれています。</target>
        </trans-unit>
        <trans-unit id="6f3e9714b389303e76259f45a7e8e4a3371445cb" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re also introducing a new mode for &lt;code&gt;tsc&lt;/code&gt;, the &lt;code&gt;--build&lt;/code&gt; flag, that works hand in hand with project references to enable faster TypeScript builds.</source>
          <target state="translated">また、 &lt;code&gt;tsc&lt;/code&gt; の新しいモードである &lt;code&gt;--build&lt;/code&gt; フラグも導入しています。これは、プロジェクト参照と連携して、より高速なTypeScriptビルドを可能にします。</target>
        </trans-unit>
        <trans-unit id="0a856c3b5c5d0b1b8b27ac26776fabf8b60ed0f0" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve also added support for &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14479&quot;&gt;declaration source maps&lt;/a&gt;. If you enable &lt;code&gt;--declarationMap&lt;/code&gt;, you&amp;rsquo;ll be able to use editor features like &amp;ldquo;Go to Definition&amp;rdquo; and Rename to transparently navigate and edit code across project boundaries in supported editors.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14479&quot;&gt;宣言ソースマップの&lt;/a&gt;サポートも追加しました。 &lt;code&gt;--declarationMap&lt;/code&gt; を有効にすると、「定義に移動」や「名前の変更」などのエディター機能を使用して、サポートされているエディターでプロジェクトの境界を越えてコードを透過的にナビゲートおよび編集できます。</target>
        </trans-unit>
        <trans-unit id="f8e13c786c22514d18489b8a515cda5e549982a7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve now added a type variable &lt;code&gt;T&lt;/code&gt; to the identity function. This &lt;code&gt;T&lt;/code&gt; allows us to capture the type the user provides (e.g. &lt;code&gt;number&lt;/code&gt;), so that we can use that information later. Here, we use &lt;code&gt;T&lt;/code&gt; again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other.</source>
          <target state="translated">型変数 &lt;code&gt;T&lt;/code&gt; を恒等関数に追加しました。この &lt;code&gt;T&lt;/code&gt; により、ユーザーが入力したタイプ（例： &lt;code&gt;number&lt;/code&gt; ）をキャプチャできるため、後でその情報を使用できます。ここでは、戻り値の型として再び &lt;code&gt;T&lt;/code&gt; を使用します。検査すると、引数と戻り値の型に同じ型が使用されていることがわかります。これにより、そのタイプの情報を関数の一方の側に、もう一方の側にトラフィッキングできます。</target>
        </trans-unit>
        <trans-unit id="5d422ede737ddc07ca03c94e0a0c10b9d58412d1" translate="yes" xml:space="preserve">
          <source>Weak Type Detection</source>
          <target state="translated">弱いタイプの検出</target>
        </trans-unit>
        <trans-unit id="1b5eb8b25701e63a0124e28e65777b9976429161" translate="yes" xml:space="preserve">
          <source>Web browser developers responded to this increased JS usage by optimizing their execution engines (dynamic compilation) and extending what could be done with it (adding APIs), which in turn made web developers use it even more. On modern websites, your browser is frequently running applications that span hundreds of thousands of lines of code. This is long and gradual growth of &amp;ldquo;the web&amp;rdquo;, starting as a simple network of static pages, and evolving into a platform for rich &lt;em&gt;applications&lt;/em&gt; of all kinds.</source>
          <target state="translated">Webブラウザー開発者は、実行エンジンを最適化し（動的コンパイル）、それを使用して実行できることを拡張し（APIを追加）、このJS使用量の増加に対応しました。これにより、Web開発者はJSの使用をさらに増やすことができました。最新のWebサイトでは、ブラウザーは数十万行のコードにまたがるアプリケーションを頻繁に実行しています。これは、静的ページの単純なネットワークとして始まり、あらゆる種類のリッチ&lt;em&gt;アプリケーション&lt;/em&gt;のプラットフォームに進化する「Web」の長く段階的な成長です。</target>
        </trans-unit>
        <trans-unit id="642803d03826095e048310e6f6fdb2336f081224" translate="yes" xml:space="preserve">
          <source>Webpack</source>
          <target state="translated">Webpack</target>
        </trans-unit>
        <trans-unit id="c81830d8b730ad2fae90f8032a7776f8b0e39714" translate="yes" xml:space="preserve">
          <source>Webpack integration is pretty simple. You can use &lt;code&gt;awesome-typescript-loader&lt;/code&gt;, a TypeScript loader, combined with &lt;code&gt;source-map-loader&lt;/code&gt; for easier debugging. Simply run</source>
          <target state="translated">Webpackの統合は非常に簡単です。あなたは使用することができます &lt;code&gt;awesome-typescript-loader&lt;/code&gt; と組み合わせ、活字体ローダー、 &lt;code&gt;source-map-loader&lt;/code&gt; 簡単にデバッグのために。単に走る</target>
        </trans-unit>
        <trans-unit id="ac0ca563dd0d3261e9ed866ed6e122036a96d12c" translate="yes" xml:space="preserve">
          <source>Webpack integration is pretty simple. You can use &lt;code&gt;ts-loader&lt;/code&gt;, a TypeScript loader, combined with &lt;code&gt;source-map-loader&lt;/code&gt; for easier debugging. Simply run</source>
          <target state="translated">Webpackの統合は非常に簡単です。TypeScript &lt;code&gt;ts-loader&lt;/code&gt; であるts-loaderを &lt;code&gt;source-map-loader&lt;/code&gt; と組み合わせて使用すると、デバッグが容易になります。単に実行する</target>
        </trans-unit>
        <trans-unit id="0f41141dbd3f1cbecbaad98cf3de708ecdf41b9b" translate="yes" xml:space="preserve">
          <source>Webpack is a tool that will bundle your code and optionally all of its dependencies into a single &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">Webpackは、コードとオプションですべての依存関係を単一の &lt;code&gt;.js&lt;/code&gt; ファイルにバンドルするツールです。</target>
        </trans-unit>
        <trans-unit id="7901ed28bacfe5bf0d524efc7190b1e5a54f7326" translate="yes" xml:space="preserve">
          <source>Webpack will eventually generate the &lt;code&gt;dist&lt;/code&gt; directory for us.</source>
          <target state="translated">Webpackは最終的に &lt;code&gt;dist&lt;/code&gt; ディレクトリを生成します。</target>
        </trans-unit>
        <trans-unit id="7fad9fe5b80f48cd956db4822a16674a29a1b973" translate="yes" xml:space="preserve">
          <source>Websites are made up of HTML and/or XML documents. These documents are static, they do not change. The &lt;em&gt;Document Object Model (DOM)&lt;/em&gt; is a programming interface implemented by browsers in order to make static websites functional. The DOM API can be used to change the document structure, style, and content. The API is so powerful that countless frontend frameworks (jQuery, React, Angular, etc.) have been developed around it in order to make dynamic websites even easier to develop.</source>
          <target state="translated">Webサイトは、HTMLおよび/またはXMLドキュメントで構成されています。これらのドキュメントは静的であり、変更されません。&lt;em&gt;ドキュメントオブジェクトモデル（DOM）は&lt;/em&gt;、静的なウェブサイトが機能するようにするためには、ブラウザによって実装されるプログラミングインタフェースです。DOM APIを使用して、ドキュメントの構造、スタイル、およびコンテンツを変更できます。APIは非常に強力であるため、動的Webサイトの開発をさらに容易にするために、その周りに無数のフロントエンドフレームワーク（jQuery、React、Angularなど）が開発されています。</target>
        </trans-unit>
        <trans-unit id="39db66a63832d879643a9c74c80d078ce3a9abfa" translate="yes" xml:space="preserve">
          <source>Weeding out Errors</source>
          <target state="translated">エラーの除草</target>
        </trans-unit>
        <trans-unit id="e97ac55d12c65e8ccc90515dafcb06d1bbf38e6c" translate="yes" xml:space="preserve">
          <source>Well-known Symbols</source>
          <target state="translated">よく知られたシンボル</target>
        </trans-unit>
        <trans-unit id="a62da38185ade2ed494ca3c34e28aed2e07c4954" translate="yes" xml:space="preserve">
          <source>What does this affect?</source>
          <target state="translated">これはどんな影響があるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="b453e4894b5221614db3412183873d5d5a3d6fc9" translate="yes" xml:space="preserve">
          <source>What if we want to also log the length of the argument &lt;code&gt;arg&lt;/code&gt; to the console with each call? We might be tempted to write this:</source>
          <target state="translated">呼び出しのたびに引数 &lt;code&gt;arg&lt;/code&gt; の長さもコンソールに記録したい場合はどうでしょうか。これを書きたくなるかもしれません：</target>
        </trans-unit>
        <trans-unit id="45fda52dea40ed49a1af31b0fc06e0a0f19b734d" translate="yes" xml:space="preserve">
          <source>What if we&amp;rsquo;re not running in TypeScript 3.1 in this example? Well, if none of the fields in &lt;code&gt;typesVersions&lt;/code&gt; get matched, TypeScript falls back to the &lt;code&gt;types&lt;/code&gt; field, so here TypeScript 3.0 and earlier will be redirected to &lt;code&gt;[...]/node_modules/package-name/index.d.ts&lt;/code&gt;.</source>
          <target state="translated">この例でTypeScript 3.1を実行していない場合はどうなりますか？まあ、 &lt;code&gt;typesVersions&lt;/code&gt; のどのフィールドも一致しない場合、TypeScriptは &lt;code&gt;types&lt;/code&gt; フィールドにフォールバックするため、TypeScript 3.0以前は &lt;code&gt;[...]/node_modules/package-name/index.d.ts&lt;/code&gt; にリダイレクトされます。</target>
        </trans-unit>
        <trans-unit id="7e305f4bbf1ed90aa73345044f0a492bd2c96f31" translate="yes" xml:space="preserve">
          <source>What is JavaScript? A Brief History</source>
          <target state="translated">JavaScriptとは?簡単な歴史</target>
        </trans-unit>
        <trans-unit id="6349e923db276196bacfe2471e600626fa732ab4" translate="yes" xml:space="preserve">
          <source>What is a Project Reference?</source>
          <target state="translated">プロジェクトリファレンスとは?</target>
        </trans-unit>
        <trans-unit id="549e8639ff7e2907dd68d7e827ef96b82a333747" translate="yes" xml:space="preserve">
          <source>What is a tsconfig.json</source>
          <target state="translated">tsconfig.jsonとは</target>
        </trans-unit>
        <trans-unit id="59beb27768eff0de85903d679ab600335df3cfc4" translate="yes" xml:space="preserve">
          <source>What is supported in my version of Visual Studio?</source>
          <target state="translated">私のバージョンのVisual Studioでは何がサポートされていますか?</target>
        </trans-unit>
        <trans-unit id="2aab3d2a4f95d11fe606c90edd3b7781f2071f7b" translate="yes" xml:space="preserve">
          <source>What should you look for?</source>
          <target state="translated">何を探せばいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="6ebc3fc3da860ce67243a9d91e606b84eda07cf2" translate="yes" xml:space="preserve">
          <source>What these two boil down to is that mixing properties with accessors is going to cause issues, and so will re-declaring properties with no initializers.</source>
          <target state="translated">この2つの結論は、プロパティとアクセサを混ぜると問題が発生し、イニシャライザを使わずにプロパティを再宣言することになるということです。</target>
        </trans-unit>
        <trans-unit id="d5327b36090577d46345fd56199590737f1090b4" translate="yes" xml:space="preserve">
          <source>What&amp;#x27;s New</source>
          <target state="translated">新着情報</target>
        </trans-unit>
        <trans-unit id="b19f846e4de2aa633d8a22d53f27123620724843" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;@sealed&lt;/code&gt; is executed, it will seal both the constructor and its prototype.</source>
          <target state="translated">場合 &lt;code&gt;@sealed&lt;/code&gt; が実行され、それはコンストラクタとそのプロトタイプの両方をシールします。</target>
        </trans-unit>
        <trans-unit id="de89d2eba1215f58d1dd8899c9e7c9afa82b2bb8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;declaration&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, running the compiler with this TypeScript code:</source>
          <target state="translated">ときに &lt;code&gt;declaration&lt;/code&gt; に設定されている &lt;code&gt;true&lt;/code&gt; この活字体のコードでコンパイラを実行し、：</target>
        </trans-unit>
        <trans-unit id="0d97be1b8d72d15598e3c754e9841feedf07996a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;downlevelIteration&lt;/code&gt; is enabled, TypeScript will use a helper function that checks for a &lt;code&gt;Symbol.iterator&lt;/code&gt; implementation (either native or polyfill). If this implementation is missing, you&amp;rsquo;ll fall back to index-based iteration.</source>
          <target state="translated">&lt;code&gt;downlevelIteration&lt;/code&gt; が有効になっている場合、TypeScriptは &lt;code&gt;Symbol.iterator&lt;/code&gt; の実装（ネイティブまたはポリフィル）をチェックするヘルパー関数を使用します。この実装が欠落している場合は、インデックスベースの反復にフォールバックします。</target>
        </trans-unit>
        <trans-unit id="030f0dfcec29d2c5288e91c918593dc6c753cec6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;localStorage.volume&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;, the page will set the volume to &lt;code&gt;0.5&lt;/code&gt; which is unintended. &lt;code&gt;??&lt;/code&gt; avoids some unintended behavior from &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; being treated as falsy values.</source>
          <target state="translated">&lt;code&gt;localStorage.volume&lt;/code&gt; が &lt;code&gt;0&lt;/code&gt; に設定されている場合、ページはボリュームを意図しない &lt;code&gt;0.5&lt;/code&gt; に設定します。 &lt;code&gt;??&lt;/code&gt; &lt;code&gt;0&lt;/code&gt; 、 &lt;code&gt;NaN&lt;/code&gt; 、および &lt;code&gt;&quot;&quot;&lt;/code&gt; が意図しない動作をして偽の値として扱われるのを回避します。</target>
        </trans-unit>
        <trans-unit id="f8cdcfeef8004c101022b373d173e5e67f254a91" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;outFile&lt;/code&gt; is used, the build information file&amp;rsquo;s name will be based on the output file&amp;rsquo;s name. As an example, if our output JavaScript file is &lt;code&gt;./output/foo.js&lt;/code&gt;, then under the &lt;code&gt;--incremental&lt;/code&gt; flag, TypeScript will generate the file &lt;code&gt;./output/foo.tsbuildinfo&lt;/code&gt;. As above, this can be controlled with the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target state="translated">とき &lt;code&gt;outFile&lt;/code&gt; 使用され、ビルド情報ファイルの名前は、出力ファイルの名前に基づいて行われます。例として、出力JavaScriptファイルが &lt;code&gt;./output/foo.js&lt;/code&gt; の場合、 &lt;code&gt;--incremental&lt;/code&gt; フラグの下で、TypeScriptはファイル &lt;code&gt;./output/foo.tsbuildinfo&lt;/code&gt; を生成します。上記のように、これは &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; フラグで制御できます。</target>
        </trans-unit>
        <trans-unit id="a6b4ab4c97cea9690c0e23272de9b69e351862d1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;removeComments&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">とき &lt;code&gt;removeComments&lt;/code&gt; がに設定されている &lt;code&gt;true&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e85b0524d36ff619229702608a55d6837ddd69c1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;strictNullChecks&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are effectively ignored by the language. This can lead to unexpected errors at runtime.</source>
          <target state="translated">&lt;code&gt;strictNullChecks&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; の場合、 &lt;code&gt;null&lt;/code&gt; および &lt;code&gt;undefined&lt;/code&gt; は言語によって事実上無視されます。これにより、実行時に予期しないエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="0f13327933b18823e01adeaea42756b80600b7ea" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;strictNullChecks&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; have their own distinct types and you&amp;rsquo;ll get a type error if you try to use them where a concrete value is expected.</source>
          <target state="translated">とき &lt;code&gt;strictNullChecks&lt;/code&gt; はある &lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; 自分の特殊タイプを持っていて、具体的な値が期待されている場所にそれらを使用しようとすると、型エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="f520248f652ff2167281b35bfd68546d3ba6914b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;strictNullChecks&lt;/code&gt; is enabled, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; get their own types called &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; respectively. Whenever anything is &lt;em&gt;possibly&lt;/em&gt;&lt;code&gt;null&lt;/code&gt;, you can use a union type with the original type. So for instance, if something could be a &lt;code&gt;number&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;, you&amp;rsquo;d write the type out as &lt;code&gt;number | null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strictNullChecks&lt;/code&gt; が有効な場合、 &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; は、それぞれ &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; と呼ばれる独自の型を取得します。 &lt;code&gt;null&lt;/code&gt; の&lt;em&gt;可能性&lt;/em&gt;が&lt;em&gt;ある場合&lt;/em&gt;はいつでも、元の型と共用体型を使用できます。したがって、たとえば、何かが &lt;code&gt;number&lt;/code&gt; または &lt;code&gt;null&lt;/code&gt; である可能性がある場合は、型を &lt;code&gt;number | null&lt;/code&gt; として記述します。null。</target>
        </trans-unit>
        <trans-unit id="5bbf9f8fcdd1b99e48e1893b7a75fd930f81e35d" translate="yes" xml:space="preserve">
          <source>When Javascript classes extend a generic base class, there is nowhere to specify what the type parameter should be. The &lt;code&gt;@extends&lt;/code&gt; tag provides a place for that type parameter:</source>
          <target state="translated">Javascriptクラスが汎用基本クラスを拡張する場合、型パラメーターを指定する場所はありません。 &lt;code&gt;@extends&lt;/code&gt; のタグは、その型パラメータのための場所を提供しています。</target>
        </trans-unit>
        <trans-unit id="04de13704216a9db06f5ffa39317b375f05787e0" translate="yes" xml:space="preserve">
          <source>When TypeScript compiles files, it keeps the same directory structure in the output directory as exists in the input directory.</source>
          <target state="translated">TypeScriptはファイルをコンパイルする際、入力ディレクトリに存在するものと同じディレクトリ構造を出力ディレクトリに保持します。</target>
        </trans-unit>
        <trans-unit id="a4d424ff2d89383aadc098c9555b347abf8e1516" translate="yes" xml:space="preserve">
          <source>When TypeScript opens a &lt;code&gt;package.json&lt;/code&gt; file to figure out which files it needs to read, it first looks at a new field called &lt;code&gt;typesVersions&lt;/code&gt;.</source>
          <target state="translated">TypeScriptが &lt;code&gt;package.json&lt;/code&gt; ファイルを開いて、読み取る必要のあるファイルを &lt;code&gt;typesVersions&lt;/code&gt; するとき、TypeScriptは最初にtypesVersionsという新しいフィールドを調べます。</target>
        </trans-unit>
        <trans-unit id="ac8c176e99ff6882e6b0d9b7305bf530d1b1a588" translate="yes" xml:space="preserve">
          <source>When a function call includes a spread expression of a tuple type as the last argument, the spread expression corresponds to a sequence of discrete arguments of the tuple element types.</source>
          <target state="translated">関数呼び出しがタプル型のスプレッド式を最後の引数に含む場合、スプレッド式はタプル要素型の離散的な引数のシーケンスに対応します。</target>
        </trans-unit>
        <trans-unit id="9c33bce0f75302f0d6e1a7e860836fefe8f472c2" translate="yes" xml:space="preserve">
          <source>When a function has a rest parameter, it is treated as if it were an infinite series of optional parameters.</source>
          <target state="translated">関数が残りのパラメータを持つ場合、それはあたかも無限のオプションパラメータの系列であるかのように扱われます。</target>
        </trans-unit>
        <trans-unit id="fd713400776c7d40925b3ed1ecacc3ed2345c946" translate="yes" xml:space="preserve">
          <source>When a function has overloads, each overload in the source type must be matched by a compatible signature on the target type. This ensures that the target function can be called in all the same situations as the source function.</source>
          <target state="translated">関数がオーバーロードを持つ場合、ソース型の各オーバーロードはターゲット型の互換性のあるシグネチャでマッチしなければなりません。これにより、ソース関数と同じ状況でターゲット関数を呼び出すことができるようになります。</target>
        </trans-unit>
        <trans-unit id="5607cf867fc582d411cd22588c4ee37feb393557" translate="yes" xml:space="preserve">
          <source>When a member is marked &lt;code&gt;private&lt;/code&gt;, it cannot be accessed from outside of its containing class. For example:</source>
          <target state="translated">メンバーが &lt;code&gt;private&lt;/code&gt; とマークされている場合、そのメンバーであるクラスの外部からはアクセスできません。例えば：</target>
        </trans-unit>
        <trans-unit id="584d36e45bec249f6c98a43c17d122b7fd42bae9" translate="yes" xml:space="preserve">
          <source>When a rest parameter has a tuple type, the tuple type is expanded into a sequence of discrete parameters. For example the following two declarations are equivalent:</source>
          <target state="translated">残りのパラメータがタプル型を持つ場合、タプル型は離散パラメータのシーケンスに展開されます。例えば、以下の2つの宣言は等価です。</target>
        </trans-unit>
        <trans-unit id="564e9e469a41360585db50dc07312fe0e7a957af" translate="yes" xml:space="preserve">
          <source>When a type inference is made from several expressions, the types of those expressions are used to calculate a &amp;ldquo;best common type&amp;rdquo;. For example,</source>
          <target state="translated">いくつかの式から型推論が行われる場合、それらの式の型を使用して「最も一般的な型」が計算されます。例えば、</target>
        </trans-unit>
        <trans-unit id="5b460fc1b0afb2a95c11c3857f5c3f8edcb0a57d" translate="yes" xml:space="preserve">
          <source>When a variable is declared using &lt;code&gt;let&lt;/code&gt;, it uses what some call &lt;em&gt;lexical-scoping&lt;/em&gt; or &lt;em&gt;block-scoping&lt;/em&gt;. Unlike variables declared with &lt;code&gt;var&lt;/code&gt; whose scopes leak out to their containing function, block-scoped variables are not visible outside of their nearest containing block or &lt;code&gt;for&lt;/code&gt;-loop.</source>
          <target state="translated">変数が &lt;code&gt;let&lt;/code&gt; を使用して宣言されている場合、その変数は&lt;em&gt;lexical-scoping&lt;/em&gt;または&lt;em&gt;block-scoping&lt;/em&gt;と呼ばれるものを使用し&lt;em&gt;ます&lt;/em&gt;。スコープが包含関数にリークする &lt;code&gt;var&lt;/code&gt; で宣言された変数とは異なり、ブロックスコープの変数は、最も近い包含ブロックの外側や &lt;code&gt;for&lt;/code&gt; ループからは見えません。</target>
        </trans-unit>
        <trans-unit id="e90a72104ebe8868314228d24725924c08766c5b" translate="yes" xml:space="preserve">
          <source>When accessing an element with a known index, the correct type is retrieved:</source>
          <target state="translated">既知のインデックスを持つ要素にアクセスすると、正しい型が取得されます。</target>
        </trans-unit>
        <trans-unit id="d43b1825ee2b2cb0d745c365143986923701b4d7" translate="yes" xml:space="preserve">
          <source>When all members in an enum have literal enum values, some special semantics come to play.</source>
          <target state="translated">列挙型のすべてのメンバがリテラル列挙型の値を持つ場合、いくつかの特別な意味論が適用されます。</target>
        </trans-unit>
        <trans-unit id="84234191fb7cb5a1d6647ae5bcd64e2e66fdf73e" translate="yes" xml:space="preserve">
          <source>When an array literal is contextually typed by the implied type of an array binding pattern:</source>
          <target state="translated">配列リテラルが、配列バインディングパターンの暗黙の型によって文脈的に型付けされている場合。</target>
        </trans-unit>
        <trans-unit id="6db5ea81f7f1151fab25e118bfe8501e1c5b8304" translate="yes" xml:space="preserve">
          <source>When an interface type extends a class type it inherits the members of the class but not their implementations. It is as if the interface had declared all of the members of the class without providing an implementation. Interfaces inherit even the private and protected members of a base class. This means that when you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it.</source>
          <target state="translated">インターフェース型がクラス型を拡張すると、そのクラスのメンバは継承されますが、その実装は継承されません。これは、あたかもインターフェイスが実装を提供せずにクラスのすべてのメンバを宣言しているかのようです。インターフェースは基底クラスのプライベートとプロテクトされたメンバーさえも継承します。つまり、プライベートやプロテクトされたメンバーを持つクラスを拡張するインターフェイスを作成した場合、そのインターフェイス型はそのクラスまたはそのサブクラスによってしか実装できないということです。</target>
        </trans-unit>
        <trans-unit id="5744d6fdcbf8dc3476727393bac3b4cddf93ada3" translate="yes" xml:space="preserve">
          <source>When an object literal is contextually typed by the implied type of an object binding pattern:</source>
          <target state="translated">オブジェクトリテラルが、オブジェクトバインディングパターンの暗黙の型によって文脈的に型付けされている場合。</target>
        </trans-unit>
        <trans-unit id="be88d1b03a9be5d8830da895b57d21e37b131ee9" translate="yes" xml:space="preserve">
          <source>When an object with a numeric index signature of type &lt;code&gt;T&lt;/code&gt; (such as an array) is indexed by a &lt;code&gt;for..in&lt;/code&gt; variable of a containing &lt;code&gt;for..in&lt;/code&gt; statement for an object &lt;em&gt;with&lt;/em&gt; a numeric index signature and &lt;em&gt;without&lt;/em&gt; a string index signature (again such as an array), the value produced is of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">タイプの数値インデックス署名付きオブジェクトとき &lt;code&gt;T&lt;/code&gt; （配列など）をすることによってインデックス付けされる &lt;code&gt;for..in&lt;/code&gt; 含有の可変 &lt;code&gt;for..in&lt;/code&gt; オブジェクトのステートメント&lt;em&gt;で&lt;/em&gt;数値インデックス署名と&lt;em&gt;せずに&lt;/em&gt;、再び（列インデックス署名配列など）、生成される値はタイプ &lt;code&gt;T&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6a191b524d20c2c29223783fb417af58e807f338" translate="yes" xml:space="preserve">
          <source>When calling this function, TypeScript will try to figure out the types of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt; through a process called &lt;em&gt;type argument inference&lt;/em&gt;. This inference process usually works pretty well:</source>
          <target state="translated">この関数を呼び出すと、TypeScriptは、&lt;em&gt;型引数推論&lt;/em&gt;と呼ばれるプロセスを通じて &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; 、および &lt;code&gt;C&lt;/code&gt; の型を理解しようとし&lt;em&gt;ます&lt;/em&gt;。この推論プロセスは通常、かなりうまく機能します。</target>
        </trans-unit>
        <trans-unit id="a79acd611da5588e33a3cd349e2f634dc5e04388" translate="yes" xml:space="preserve">
          <source>When comparing functions for compatibility, optional and required parameters are interchangeable. Extra optional parameters of the source type are not an error, and optional parameters of the target type without corresponding parameters in the source type are not an error.</source>
          <target state="translated">互換性のために関数を比較する場合、オプションパラメータと必須パラメータは互換性があります。ソース型の余分なオプションパラメータはエラーにはなりませんし、ソース型に対応するパラメータを持たないターゲット型のオプションパラメータはエラーにはなりません。</target>
        </trans-unit>
        <trans-unit id="03084317d53b13f20dd727e5c86474664f6cced3" translate="yes" xml:space="preserve">
          <source>When comparing the types of function parameters, assignment succeeds if either the source parameter is assignable to the target parameter, or vice versa. This is unsound because a caller might end up being given a function that takes a more specialized type, but invokes the function with a less specialized type. In practice, this sort of error is rare, and allowing this enables many common JavaScript patterns. A brief example:</source>
          <target state="translated">関数パラメータの型を比較する場合、ソースパラメータがターゲットパラメータに代入可能な場合は代入が成功し、その逆の場合は代入が成功しません。これは、呼び出し元がより専門的な型を取る関数を与えられているにもかかわらず、より専門的ではない型の関数を呼び出してしまう可能性があるため、健全ではありません。実際には、この種のエラーは稀であり、これを許可することで多くの一般的なJavaScriptのパターンが可能になります。簡単な例を挙げます。</target>
        </trans-unit>
        <trans-unit id="e381f7d0b16f43f925b00a27f8c4e30f5d16099b" translate="yes" xml:space="preserve">
          <source>When compiled in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, optional properties and methods automatically have &lt;code&gt;undefined&lt;/code&gt; included in their type. Thus, the &lt;code&gt;b&lt;/code&gt; property above is of type &lt;code&gt;number | undefined&lt;/code&gt; and the &lt;code&gt;g&lt;/code&gt; method above is of type &lt;code&gt;(() =&amp;gt; number) | undefined&lt;/code&gt;. Type guards can be used to strip away the &lt;code&gt;undefined&lt;/code&gt; part of the type:</source>
          <target state="translated">&lt;code&gt;--strictNullChecks&lt;/code&gt; モードでコンパイルすると、オプションのプロパティとメソッドの型に含まれる &lt;code&gt;undefined&lt;/code&gt; が自動的に含まれます。したがって、上記の &lt;code&gt;b&lt;/code&gt; プロパティのタイプは &lt;code&gt;number | undefined&lt;/code&gt; あり、上記の &lt;code&gt;g&lt;/code&gt; メソッドのタイプは &lt;code&gt;(() =&amp;gt; number) | undefined&lt;/code&gt; 。型ガードを使用して、型の &lt;code&gt;undefined&lt;/code&gt; 部分を取り除くことができます。</target>
        </trans-unit>
        <trans-unit id="5bbcd2d4cb15d58c0854ed82d657d8c796031edd" translate="yes" xml:space="preserve">
          <source>When compiled, each module will become a separate &lt;code&gt;.js&lt;/code&gt; file. As with reference tags, the compiler will follow &lt;code&gt;import&lt;/code&gt; statements to compile dependent files.</source>
          <target state="translated">コンパイルすると、各モジュールは個別の &lt;code&gt;.js&lt;/code&gt; ファイルになります。参照タグと同様に、コンパイラーは依存ステートメントをコンパイルするために &lt;code&gt;import&lt;/code&gt; 文に従います。</target>
        </trans-unit>
        <trans-unit id="751fdd8e03ce07c29b56146fecc9f825067cb792" translate="yes" xml:space="preserve">
          <source>When compiling to pre-ES6 targets, the string is decomposed:</source>
          <target state="translated">ES6以前のターゲットにコンパイルすると、文字列が分解されます。</target>
        </trans-unit>
        <trans-unit id="4156655ae276c8b3ed96d041dfc8baeba1797652" translate="yes" xml:space="preserve">
          <source>When creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example,</source>
          <target state="translated">TypeScriptでジェネリックを使ってファクトリーを作成する場合、クラスの型をコンストラクタ関数で参照する必要があります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="dcace02a91899e1f338f3e9e2fa474b942645716" translate="yes" xml:space="preserve">
          <source>When enabled, TypeScript will check all code paths in a function to ensure they return a value.</source>
          <target state="translated">この機能を有効にすると、TypeScript は関数内のすべてのコードパスをチェックして値を返すかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="f2a561b2561570486c65edf072423fc080bd866b" translate="yes" xml:space="preserve">
          <source>When enabled, as long as the &lt;code&gt;reflect-metadata&lt;/code&gt; library has been imported, additional design-time type information will be exposed at runtime.</source>
          <target state="translated">有効にすると、 &lt;code&gt;reflect-metadata&lt;/code&gt; ライブラリがインポートされている限り、追加の設計時タイプ情報が実行時に公開されます。</target>
        </trans-unit>
        <trans-unit id="2e2b57241329652bf13e53eebcd41139c80c8d1c" translate="yes" xml:space="preserve">
          <source>When enabled, this flag causes functions parameters to be checked more correctly.</source>
          <target state="translated">このフラグを有効にすると、関数のパラメータがより正確にチェックされるようになります。</target>
        </trans-unit>
        <trans-unit id="7c2be8d3bddd72617c23414391cc48bc565dfaa5" translate="yes" xml:space="preserve">
          <source>When exporting a module using &lt;code&gt;export =&lt;/code&gt;, TypeScript-specific &lt;code&gt;import module = require(&quot;module&quot;)&lt;/code&gt; must be used to import the module.</source>
          <target state="translated">&lt;code&gt;export =&lt;/code&gt; を使用してモジュールをエクスポートする場合、TypeScript固有の &lt;code&gt;import module = require(&quot;module&quot;)&lt;/code&gt; 使用してモジュールをインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="06ca5da26932f2433c3883f2ba92d649c8f8ac14" translate="yes" xml:space="preserve">
          <source>When first moving to a module-based organization, a common tendency is to wrap exports in an additional layer of namespaces. Modules have their own scope, and only exported declarations are visible from outside the module. With this in mind, namespace provide very little, if any, value when working with modules.</source>
          <target state="translated">最初にモジュールベースの組織に移行するとき、一般的な傾向として、エクスポートを名前空間の追加レイヤーで包むことがあります。モジュールには独自のスコープがあり、エクスポートされた宣言だけがモジュールの外から見えるようになっています。このことを念頭に置いて、名前空間はモジュールを扱う際には、ほとんど価値がありません。</target>
        </trans-unit>
        <trans-unit id="668eaece6bc69ffaa69b4efacde9943b15dbace6" translate="yes" xml:space="preserve">
          <source>When imported into a TypeScript file will raise an error:</source>
          <target state="translated">TypeScriptファイルにインポートするとエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="e7376b10eff8993749ce4879a342660552379ff7" translate="yes" xml:space="preserve">
          <source>When imported into a TypeScript module:</source>
          <target state="translated">TypeScriptモジュールにインポートする場合。</target>
        </trans-unit>
        <trans-unit id="e0cbb0349fc79c96ec431ec47e8f342090438ecb" translate="yes" xml:space="preserve">
          <source>When importing using the &lt;code&gt;Node&lt;/code&gt; module resolution strategy in TypeScript 2.5, the compiler will now check whether files originate from &amp;ldquo;identical&amp;rdquo; packages. If a file originates from a package with a &lt;code&gt;package.json&lt;/code&gt; containing the same &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;version&lt;/code&gt; fields as a previously encountered package, then TypeScript will redirect itself to the top-most package. This helps resolve problems where two packages might contain identical declarations of classes, but which contain &lt;code&gt;private&lt;/code&gt; members that cause them to be structurally incompatible.</source>
          <target state="translated">TypeScript 2.5 の &lt;code&gt;Node&lt;/code&gt; モジュール解決戦略を使用してインポートする場合、コンパイラーはファイルが「同一の」パッケージからのものかどうかをチェックするようになりました。以前に遭遇したパッケージと同じ &lt;code&gt;name&lt;/code&gt; と &lt;code&gt;version&lt;/code&gt; フィールドを含む &lt;code&gt;package.json&lt;/code&gt; を持つパッケージからファイルが発生した場合、TypeScriptはそれ自体を最上位のパッケージにリダイレクトします。これは、2つのパッケージにクラスの同一の宣言が含まれている可能性があるが、構造的に互換性がない原因になる &lt;code&gt;private&lt;/code&gt; メンバーが含まれているという問題の解決に役立ちます。</target>
        </trans-unit>
        <trans-unit id="e53d751bb35ec11bb8d50707759e0855efc875fb" translate="yes" xml:space="preserve">
          <source>When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the &lt;em&gt;last&lt;/em&gt; signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.</source>
          <target state="translated">複数の呼び出しシグネチャを持つ型（オーバーロードされた関数の型など）から推論する場合、&lt;em&gt;最後の&lt;/em&gt;シグネチャから推論が行われます（おそらく、これは最も寛容なキャッチオールケースです）。引数タイプのリストに基づいてオーバーロード解決を実行することはできません。</target>
        </trans-unit>
        <trans-unit id="c0e5d12e818f1a128405e0dcf37599e5124ab4c5" translate="yes" xml:space="preserve">
          <source>When input files are specified on the command line, &lt;code&gt;tsconfig.json&lt;/code&gt; files are ignored.</source>
          <target state="translated">コマンドラインで入力ファイルを指定すると、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルは無視されます。</target>
        </trans-unit>
        <trans-unit id="c7dbba16b050a53843a9368cb4cf7aacd6cb532e" translate="yes" xml:space="preserve">
          <source>When install is complete, rebuild!</source>
          <target state="translated">インストールが完了したら、再構築!</target>
        </trans-unit>
        <trans-unit id="9030ab49af527527a3048a47ea128f0c0c219027" translate="yes" xml:space="preserve">
          <source>When interacting with 3rd-party JavaScript, you may need to use patterns like the above to fully describe the shape of the type.</source>
          <target state="translated">サードパーティのJavaScriptと対話する際には、上記のようなパターンを使用して型の形状を完全に記述する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="6164dc5fed96c16868282dad3b94f86d550f8593" translate="yes" xml:space="preserve">
          <source>When looking at the code of a global library, you&amp;rsquo;ll usually see:</source>
          <target state="translated">グローバルライブラリのコードを見ると、通常は次のように表示されます。</target>
        </trans-unit>
        <trans-unit id="8a513a2bca42391a3829f6aa2918feafe16fa0e9" translate="yes" xml:space="preserve">
          <source>When making a modern JavaScript project, you might ask yourself what is the right way to convert files from TypeScript to JavaScript?</source>
          <target state="translated">最近のJavaScriptプロジェクトを作るときに、TypeScriptからJavaScriptにファイルを変換するには何が正しい方法なのかと疑問に思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="5b922be38a1d8a16178d415d54259031e8aa4f6f" translate="yes" xml:space="preserve">
          <source>When multiple decorators apply to a single declaration, their evaluation is similar to &lt;a href=&quot;http://en.wikipedia.org/wiki/Function_composition&quot;&gt;function composition in mathematics&lt;/a&gt;. In this model, when composing functions &lt;em&gt;f&lt;/em&gt; and &lt;em&gt;g&lt;/em&gt;, the resulting composite (&lt;em&gt;f&lt;/em&gt; ∘ &lt;em&gt;g&lt;/em&gt;)(&lt;em&gt;x&lt;/em&gt;) is equivalent to &lt;em&gt;f&lt;/em&gt;(&lt;em&gt;g&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)).</source>
          <target state="translated">複数のデコレーターが1つの宣言に適用される場合、それらの評価は&lt;a href=&quot;http://en.wikipedia.org/wiki/Function_composition&quot;&gt;数学の関数構成に&lt;/a&gt;似ています。合成関数このモデルにおいて、&lt;em&gt;F&lt;/em&gt;および&lt;em&gt;G&lt;/em&gt;、得られた複合体（&lt;em&gt;F&lt;/em&gt; ∘ &lt;em&gt;G&lt;/em&gt;）（&lt;em&gt;xは&lt;/em&gt;）と等価である&lt;em&gt;F&lt;/em&gt;（&lt;em&gt;G&lt;/em&gt;（&lt;em&gt;X&lt;/em&gt;））。</target>
        </trans-unit>
        <trans-unit id="954328cfc017ca1687105e4509b95a1b13d2af54" translate="yes" xml:space="preserve">
          <source>When multiple decorators apply to a single declaration, their evaluation is similar to &lt;a href=&quot;http://wikipedia.org/wiki/Function_composition&quot;&gt;function composition in mathematics&lt;/a&gt;. In this model, when composing functions &lt;em&gt;f&lt;/em&gt; and &lt;em&gt;g&lt;/em&gt;, the resulting composite (&lt;em&gt;f&lt;/em&gt; ∘ &lt;em&gt;g&lt;/em&gt;)(&lt;em&gt;x&lt;/em&gt;) is equivalent to &lt;em&gt;f&lt;/em&gt;(&lt;em&gt;g&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)).</source>
          <target state="translated">複数のデコレータが単一の宣言に適用される場合、それらの評価は&lt;a href=&quot;http://wikipedia.org/wiki/Function_composition&quot;&gt;数学の関数合成に&lt;/a&gt;似ています。合成関数このモデルにおいて、&lt;em&gt;F&lt;/em&gt;および&lt;em&gt;G&lt;/em&gt;、得られた複合体（&lt;em&gt;F&lt;/em&gt; ∘ &lt;em&gt;G&lt;/em&gt;）（&lt;em&gt;xは&lt;/em&gt;）と等価である&lt;em&gt;F&lt;/em&gt;（&lt;em&gt;G&lt;/em&gt;（&lt;em&gt;X&lt;/em&gt;））。</target>
        </trans-unit>
        <trans-unit id="6f2ce3b2acc4dd5238eaac40a3c2b746b0805538" translate="yes" xml:space="preserve">
          <source>When needed, the compiler &lt;em&gt;widens&lt;/em&gt; &amp;mdash; converts to a supertype &amp;mdash; the unit type to the primitive type, such as &lt;code&gt;&quot;foo&quot;&lt;/code&gt; to &lt;code&gt;string&lt;/code&gt;. This happens when using mutability, which can hamper some uses of mutable variables:</source>
          <target state="translated">必要に応じて、コンパイラ&lt;em&gt;は&lt;/em&gt;、ユニット型を &lt;code&gt;&quot;foo&quot;&lt;/code&gt; から &lt;code&gt;string&lt;/code&gt; などのプリミティブ型に&lt;em&gt;拡張&lt;/em&gt;します（スーパータイプに変換します）。これは、可変性を使用する場合に発生し、可変変数の一部の使用を妨げる可能性があります。</target>
        </trans-unit>
        <trans-unit id="1f6f6092ccbf1d0a9294c7e4c282859a027ca09d" translate="yes" xml:space="preserve">
          <source>When no best common type is found, the resulting inference is the union array type, &lt;code&gt;(Rhino | Elephant | Snake)[]&lt;/code&gt;.</source>
          <target state="translated">最も一般的なタイプが見つからない場合、結果として得られる推論は共用体配列タイプ &lt;code&gt;(Rhino | Elephant | Snake)[]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="577abe4bb126beb561a8efdcb48a28392a4a75af" translate="yes" xml:space="preserve">
          <source>When obtaining the construct signatures of an intersection type that contains mixin constructor types, the mixin construct signatures are discarded and their instance types are mixed into the return types of the other construct signatures in the intersection type. For example, the intersection type &lt;code&gt;{ new(...args: any[]) =&amp;gt; A } &amp;amp; { new(s: string) =&amp;gt; B }&lt;/code&gt; has a single construct signature &lt;code&gt;new(s: string) =&amp;gt; A &amp;amp; B&lt;/code&gt;.</source>
          <target state="translated">ミックスインコンストラクタータイプを含む交差タイプの構成シグネチャを取得すると、ミックスイン構成シグネチャは破棄され、それらのインスタンスタイプが交差タイプの他の構成シグネチャの戻り値のタイプに混合されます。たとえば、交差タイプ &lt;code&gt;{ new(...args: any[]) =&amp;gt; A } &amp;amp; { new(s: string) =&amp;gt; B }&lt;/code&gt; は、単一の構成シグネチャ &lt;code&gt;new(s: string) =&amp;gt; A &amp;amp; B&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5037d7b746e687be44f9da9ad23e7dc846aba52" translate="yes" xml:space="preserve">
          <source>When reading from a union type, you can see any properties that are shared by them:</source>
          <target state="translated">ユニオン型から読み込むときに、それらが共有しているプロパティを見ることができます。</target>
        </trans-unit>
        <trans-unit id="35582d74eec1d631b57c2de10a47c90c793d3dde" translate="yes" xml:space="preserve">
          <source>When relating the type of &lt;code&gt;map&lt;/code&gt; in TS 2.4, the language will check whether each parameter is a callback type, and if so, it will ensure that those parameters are checked in a contravariant manner with respect to the current relation.</source>
          <target state="translated">TS 2.4 で &lt;code&gt;map&lt;/code&gt; のタイプを関連付ける場合、言語は各パラメーターがコールバックタイプであるかどうかを確認し、そうである場合は、それらのパラメーターが現在の関係に関して反変的な方法で確認されるようにします。</target>
        </trans-unit>
        <trans-unit id="39dea6a28c7ed5ec45fbae153245367a81c4db31" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt; allows you to write an import like:</source>
          <target state="translated">trueに設定すると、 &lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt; を使用して次のようなインポートを記述できます。</target>
        </trans-unit>
        <trans-unit id="c583a10fdbc7daf7e0efcc6636eb8647630843da" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;allowUmdGlobalAccess&lt;/code&gt; lets you access UMD exports as globals from inside module files. A module file is a file that has imports and/or exports. Without this flag, using an export from a UMD module requires an import declaration.</source>
          <target state="translated">trueに設定すると、 &lt;code&gt;allowUmdGlobalAccess&lt;/code&gt; を使用して、モジュールファイル内からグローバルとしてUMDエクスポートにアクセスできます。モジュールファイルは、インポートまたはエクスポート、あるいはその両方を含むファイルです。このフラグがない場合、UMDモジュールからのエクスポートを使用するには、インポート宣言が必要です。</target>
        </trans-unit>
        <trans-unit id="7c950a1a9d1adb8bf75c10364f43b53406e85813" translate="yes" xml:space="preserve">
          <source>When set to true, TypeScript will raise an error when a class property was declared but not set in the constructor.</source>
          <target state="translated">true に設定すると、クラスのプロパティが宣言されていてもコンストラクタで設定されていない場合、TypeScript はエラーを発生させます。</target>
        </trans-unit>
        <trans-unit id="4e345c366b26184d9f74a06f292f247bfab9bfef" translate="yes" xml:space="preserve">
          <source>When set, TypeScript will check that the built-in methods of functions &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;bind&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; are invoked with correct argument for the underlying function:</source>
          <target state="translated">設定すると、TypeScriptは、関数 &lt;code&gt;call&lt;/code&gt; 、 &lt;code&gt;bind&lt;/code&gt; 、 &lt;code&gt;apply&lt;/code&gt; の組み込みメソッドが、基になる関数の正しい引数で呼び出されることを確認します。</target>
        </trans-unit>
        <trans-unit id="d2ba421a210ee671b7d2e94cf97295f944594d7c" translate="yes" xml:space="preserve">
          <source>When set, TypeScript will include the original content of the &lt;code&gt;.ts&lt;/code&gt; file as an embedded string in the source map. This is often useful in the same cases as &lt;code&gt;inlineSourceMap&lt;/code&gt;.</source>
          <target state="translated">設定すると、TypeScriptは &lt;code&gt;.ts&lt;/code&gt; ファイルの元のコンテンツをソースマップに埋め込まれた文字列として含めます。これは、 &lt;code&gt;inlineSourceMap&lt;/code&gt; と同じ場合に役立つことがよくあります。</target>
        </trans-unit>
        <trans-unit id="af4ff52db3699946536782a20c9a209457b23419" translate="yes" xml:space="preserve">
          <source>When set, instead of writing out a &lt;code&gt;.js.map&lt;/code&gt; file to provide source maps, TypeScript will embed the source map content in the &lt;code&gt;.js&lt;/code&gt; files. Although this results in larger JS files, it can be convenient in some scenarios. For example, you might want to debug JS files on a webserver that doesn&amp;rsquo;t allow &lt;code&gt;.map&lt;/code&gt; files to be served.</source>
          <target state="translated">設定すると、ソースマップを提供するために &lt;code&gt;.js.map&lt;/code&gt; ファイルを書き出す代わりに、TypeScriptはソースマップのコンテンツを &lt;code&gt;.js&lt;/code&gt; ファイルに埋め込みます。これによりJSファイルが大きくなりますが、シナリオによっては便利な場合があります。たとえば、 &lt;code&gt;.map&lt;/code&gt; ファイルの提供を許可しないWebサーバー上のJSファイルをデバッグしたい場合があります。</target>
        </trans-unit>
        <trans-unit id="1ff10b12f6a9033fbc10cf950cc0ed31b94b4a4d" translate="yes" xml:space="preserve">
          <source>When specifying a greeting, you must pass a &lt;code&gt;GreetingSettings&lt;/code&gt; object. This object has the following properties:</source>
          <target state="translated">挨拶を指定するときは、 &lt;code&gt;GreetingSettings&lt;/code&gt; オブジェクトを渡す必要があります。このオブジェクトには次のプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="43988d6b430a774a26861955cc54fd9c702d0452" translate="yes" xml:space="preserve">
          <source>When specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types.</source>
          <target state="translated">型引数を指定する場合は、必要な型パラメータに対してのみ型引数を指定する必要があります。指定されていない型パラメータは、既定の型に解決されます。</target>
        </trans-unit>
        <trans-unit id="1ebe929f8f784ba5280922a50ab6e379d8859057" translate="yes" xml:space="preserve">
          <source>When targeting ES3/ES5, the following code</source>
          <target state="translated">ES3/ES5をターゲットにする場合は、以下のコードを使用します。</target>
        </trans-unit>
        <trans-unit id="156025a3f40907ffeac72e030a3a730a1deebeb1" translate="yes" xml:space="preserve">
          <source>When targeting an ECMAScipt 2015-compliant engine, the compiler will generate &lt;code&gt;for..of&lt;/code&gt; loops to target the built-in iterator implementation in the engine.</source>
          <target state="translated">ECMAScipt 2015準拠のエンジンを対象とする場合、コンパイラーは &lt;code&gt;for..of&lt;/code&gt; ループを生成して、エンジンの組み込みイテレーター実装を対象にします。</target>
        </trans-unit>
        <trans-unit id="81f1ae5ab6877859c51c53b6981d29f05adff0a6" translate="yes" xml:space="preserve">
          <source>When targeting an ES5 or ES3-compliant engine, iterators are only allowed on values of &lt;code&gt;Array&lt;/code&gt; type. It is an error to use &lt;code&gt;for..of&lt;/code&gt; loops on non-Array values, even if these non-Array values implement the &lt;code&gt;Symbol.iterator&lt;/code&gt; property.</source>
          <target state="translated">ES5またはES3準拠のエンジンを対象とする場合、反復子は &lt;code&gt;Array&lt;/code&gt; 型の値でのみ許可されます。これらの非配列値が &lt;code&gt;Symbol.iterator&lt;/code&gt; プロパティを実装している場合でも、非配列値に対して &lt;code&gt;for..of&lt;/code&gt; ループを使用するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="c6f752156fda72ea7aae2689896f7e4699113094" translate="yes" xml:space="preserve">
          <source>When the module &lt;strong&gt;does not&lt;/strong&gt; explicitly specify a default export.</source>
          <target state="translated">モジュール&lt;strong&gt;が&lt;/strong&gt;デフォルトのエクスポートを明示的に指定&lt;strong&gt;していない&lt;/strong&gt;場合。</target>
        </trans-unit>
        <trans-unit id="8c37c6770fe59c21b776453641387b80134be5e8" translate="yes" xml:space="preserve">
          <source>When this option is enabled, TypeScript will avoid rechecking/rebuilding all truly possibly-affected files, and only recheck/rebuild files that have changed as well as files that directly import them.</source>
          <target state="translated">このオプションを有効にすると、TypeScript は本当に影響を受ける可能性のあるすべてのファイルの再チェックや再構築を回避し、変更されたファイルや直接インポートされたファイルの再チェックや再構築のみを行います。</target>
        </trans-unit>
        <trans-unit id="da87dafd3c996b8acd299c5e81f629e20d29370b" translate="yes" xml:space="preserve">
          <source>When this option is set, TypeScript will issue an error if a program tries to include a file by a casing different from the casing on disk.</source>
          <target state="translated">このオプションが設定されている場合、プログラムがディスク上のケーシングとは異なるケーシングでファイルをインクルードしようとすると、TypeScriptはエラーを発行します。</target>
        </trans-unit>
        <trans-unit id="990f9e6deb289272b10e4e4125770810112d182e" translate="yes" xml:space="preserve">
          <source>When this setting is on:</source>
          <target state="translated">この設定がオンの場合。</target>
        </trans-unit>
        <trans-unit id="2fff15c1d3e5e5f2e18f1d4a6ac9350c4a78b3f2" translate="yes" xml:space="preserve">
          <source>When tuple types are inferred for rest parameters, optional parameters in the source become optional tuple elements in the inferred type.</source>
          <target state="translated">残りのパラメータに対してタプル型が推論される場合、ソース内のオプションパラメータは推論された型内のオプションのタプル要素になります。</target>
        </trans-unit>
        <trans-unit id="75737547c96987306eebfed378fbd115f0634d72" translate="yes" xml:space="preserve">
          <source>When using Node module resolution in TypeScript 3.1, when TypeScript cracks open a &lt;code&gt;package.json&lt;/code&gt; file to figure out which files it needs to read, it first looks at a new field called &lt;code&gt;typesVersions&lt;/code&gt;. A &lt;code&gt;package.json&lt;/code&gt; with a &lt;code&gt;typesVersions&lt;/code&gt; field might look like this:</source>
          <target state="translated">TypeScript 3.1でNodeモジュール解決を使用する場合、TypeScriptが &lt;code&gt;package.json&lt;/code&gt; ファイルをクラックして開いて、読み取る必要のあるファイルを &lt;code&gt;typesVersions&lt;/code&gt; と、最初にtypesVersionsという新しいフィールドを調べます。 &lt;code&gt;package.json&lt;/code&gt; と &lt;code&gt;typesVersions&lt;/code&gt; のフィールドは次のようになります。</target>
        </trans-unit>
        <trans-unit id="1ae8b3b63e3d4432d7dcb8ebb6d1406c00d3f904" translate="yes" xml:space="preserve">
          <source>When using file system events, this option specifies the polling strategy that gets used when the system runs out of native file watchers and/or doesn&amp;rsquo;t support native file watchers.</source>
          <target state="translated">ファイルシステムイベントを使用する場合、このオプションは、システムがネイティブファイルウォッチャーを使い果たした場合やネイティブファイルウォッチャーをサポートしていない場合に使用されるポーリング戦略を指定します。</target>
        </trans-unit>
        <trans-unit id="4850716ae612670ae2d56349b6a2660a6446e72a" translate="yes" xml:space="preserve">
          <source>When we do, the compiler will give us an error that we&amp;rsquo;re using the &lt;code&gt;.length&lt;/code&gt; member of &lt;code&gt;arg&lt;/code&gt;, but nowhere have we said that &lt;code&gt;arg&lt;/code&gt; has this member. Remember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in a &lt;code&gt;number&lt;/code&gt; instead, which does not have a &lt;code&gt;.length&lt;/code&gt; member.</source>
          <target state="translated">&lt;code&gt;.length&lt;/code&gt; 、コンパイラーは &lt;code&gt;arg&lt;/code&gt; の.lengthメンバーを使用しているというエラーを出しますが、 &lt;code&gt;arg&lt;/code&gt; にこのメンバーがあると言ったことはどこにもありません。これらの型変数はすべての型の代わりになることを先に述べたので、この関数を使用する誰かが代わりに &lt;code&gt;.length&lt;/code&gt; メンバーのない &lt;code&gt;number&lt;/code&gt; を渡した可能性があります。</target>
        </trans-unit>
        <trans-unit id="217dd70751ec70c2507f34daeb4f28f27ba30001" translate="yes" xml:space="preserve">
          <source>When we first touched on the idea of variable capturing with &lt;code&gt;var&lt;/code&gt; declaration, we briefly went into how variables act once captured. To give a better intuition of this, each time a scope is run, it creates an &amp;ldquo;environment&amp;rdquo; of variables. That environment and its captured variables can exist even after everything within its scope has finished executing.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 宣言を使用した変数のキャプチャのアイデアに初めて触れたとき、変数がキャプチャされた後の動作について簡単に説明しました。これをよりよく理解するために、スコープが実行されるたびに、変数の「環境」が作成されます。その環境とキャプチャーされた変数は、そのスコープ内のすべての実行が終了した後でも存在できます。</target>
        </trans-unit>
        <trans-unit id="7c4c9e905df51f2991607084fd0766320f038e1a" translate="yes" xml:space="preserve">
          <source>When working with &lt;a href=&quot;docs/handbook/project-references&quot;&gt;composite TypeScript projects&lt;/a&gt;, this option provides a way to declare that you do not want a project to be included when using features like &lt;em&gt;find all references&lt;/em&gt; or &lt;em&gt;jump to definition&lt;/em&gt; in an editor.</source>
          <target state="translated">で作業する場合&lt;a href=&quot;docs/handbook/project-references&quot;&gt;、複合活字体のプロジェクト&lt;/a&gt;は、このオプションは使用して機能が気に入ったときにプロジェクトが含まれたくないことを宣言するための方法を提供し&lt;em&gt;、すべての参照を見つける&lt;/em&gt;か、&lt;em&gt;定義にジャンプを&lt;/em&gt;エディタで。</target>
        </trans-unit>
        <trans-unit id="9c31435415edfd38b4ca387c630ed5c177c68f06" translate="yes" xml:space="preserve">
          <source>When working with &lt;a href=&quot;docs/handbook/project-references&quot;&gt;composite TypeScript projects&lt;/a&gt;, this option provides a way to go &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#build-free-editing-with-project-references&quot;&gt;back to the pre-3.7&lt;/a&gt; behavior where d.ts files were used to as the boundaries between modules. In 3.7 the source of truth is now your TypeScript files.</source>
          <target state="translated">&lt;a href=&quot;docs/handbook/project-references&quot;&gt;複合TypeScriptプロジェクト&lt;/a&gt;で作業する場合、このオプションは、モジュール間の境界としてd.tsファイルが使用されていた&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#build-free-editing-with-project-references&quot;&gt;3.7より前の&lt;/a&gt;動作に戻る方法を提供します。3.7では、信頼できる情報源はTypeScriptファイルになりました。</target>
        </trans-unit>
        <trans-unit id="93fe803409a586a0ea7a977ee5a94d526da6f55e" translate="yes" xml:space="preserve">
          <source>When working with &lt;code&gt;.d.ts&lt;/code&gt; files for JavaScript files you may want to use &lt;a href=&quot;#emitDeclarationOnly&quot;&gt;&lt;code&gt;emitDeclarationOnly&lt;/code&gt;&lt;/a&gt; or use &lt;a href=&quot;#outDir&quot;&gt;&lt;code&gt;outDir&lt;/code&gt;&lt;/a&gt; to ensure that the JavaScript files are not overwritten.</source>
          <target state="translated">で作業する場合 &lt;code&gt;.d.ts&lt;/code&gt; のファイルJavaScriptが使用する可能性があるファイルの&lt;a href=&quot;#emitDeclarationOnly&quot;&gt; &lt;code&gt;emitDeclarationOnly&lt;/code&gt; を&lt;/a&gt;または使用&lt;a href=&quot;#outDir&quot;&gt; &lt;code&gt;outDir&lt;/code&gt; &lt;/a&gt;JavaScriptファイルが上書きされないように。</target>
        </trans-unit>
        <trans-unit id="3ff7f4efa05e217597245c432a821c2527e220ab" translate="yes" xml:space="preserve">
          <source>When working with classes and interfaces, it helps to keep in mind that a class has &lt;em&gt;two&lt;/em&gt; types: the type of the static side and the type of the instance side. You may notice that if you create an interface with a construct signature and try to create a class that implements this interface you get an error:</source>
          <target state="translated">クラスとインターフェースを操作する場合、クラスには静的側のタイプとインスタンス側のタイプの&lt;em&gt;2つの&lt;/em&gt;タイプがあることに注意してください。構成シグニチャーを使用してインターフェースを作成し、このインターフェースを実装するクラスを作成しようとすると、エラーが発生する場合があります。</target>
        </trans-unit>
        <trans-unit id="59ca9320ae741734ed0a3e6c543e8c5deef3ad35" translate="yes" xml:space="preserve">
          <source>When writing in JavaScript files (using &lt;code&gt;allowJs&lt;/code&gt;), TypeScript now recognizes declarations that use &lt;code&gt;Object.defineProperty&lt;/code&gt;. This means you&amp;rsquo;ll get better completions, and stronger type-checking when enabling type-checking in JavaScript files (by turning on the &lt;code&gt;checkJs&lt;/code&gt; option or adding a &lt;code&gt;// @ts-check&lt;/code&gt; comment to the top of your file).</source>
          <target state="translated">JavaScriptファイルで（ &lt;code&gt;allowJs&lt;/code&gt; を使用して）書き込む場合、TypeScriptは &lt;code&gt;Object.defineProperty&lt;/code&gt; を使用する宣言を認識するようになりました。つまり、JavaScriptファイルで型チェックを有効にすると、より優れた補完とより強力な型チェックが行われます（ &lt;code&gt;checkJs&lt;/code&gt; オプションをオンにするか、ファイルの先頭に &lt;code&gt;// @ts-check&lt;/code&gt; コメントを追加することにより）。</target>
        </trans-unit>
        <trans-unit id="2c9a1bcb431f60ef891dc5272428f61ccd6deae4" translate="yes" xml:space="preserve">
          <source>When you are trying to debug why a module isn&amp;rsquo;t being included. You can set &lt;code&gt;traceResolutions&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; to have TypeScript print information about its resolution process for each processed file.</source>
          <target state="translated">モジュールが含まれていない理由をデバッグしようとしているとき。 &lt;code&gt;traceResolutions&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定すると、TypeScriptで、処理された各ファイルの解決プロセスに関する情報を出力できます。</target>
        </trans-unit>
        <trans-unit id="ec5f993452425d2ee4ab0f5de68ed85198028eec" translate="yes" xml:space="preserve">
          <source>When you begin to use generics, you&amp;rsquo;ll notice that when you create generic functions like &lt;code&gt;identity&lt;/code&gt;, the compiler will enforce that you use any generically typed parameters in the body of the function correctly. That is, that you actually treat these parameters as if they could be any and all types.</source>
          <target state="translated">ジェネリックを使用し始めると、 &lt;code&gt;identity&lt;/code&gt; などのジェネリック関数を作成すると、コンパイラーは、関数の本体でジェネリック型パラメーターを正しく使用するように強制します。つまり、これらのパラメーターを実際にはすべてのタイプであるかのように扱うということです。</target>
        </trans-unit>
        <trans-unit id="bb76a0dfbc0b927a30bc60fb3308eae1c0c32030" translate="yes" xml:space="preserve">
          <source>When you declare a class in TypeScript, you are actually creating multiple declarations at the same time. The first is the type of the &lt;em&gt;instance&lt;/em&gt; of the class.</source>
          <target state="translated">TypeScriptでクラスを宣言すると、実際には複数の宣言が同時に作成されます。1つ目は、クラスの&lt;em&gt;インスタンス&lt;/em&gt;のタイプです。</target>
        </trans-unit>
        <trans-unit id="63841123e89ff79b5bb8a778012e2675dfb6bf27" translate="yes" xml:space="preserve">
          <source>When you declare a variable via &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;, you are telling the compiler that there is the chance that this variable will change its contents. In contrast, using &lt;code&gt;const&lt;/code&gt; to declare a variable will inform TypeScript that this object will never change.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; または &lt;code&gt;let&lt;/code&gt; を介して変数を宣言すると、この変数がその内容を変更する可能性があることをコンパイラーに通知します。対照的に、 &lt;code&gt;const&lt;/code&gt; を使用して変数を宣言すると、このオブジェクトは決して変更されないことがTypeScriptに通知されます。</target>
        </trans-unit>
        <trans-unit id="cffefcf45ac3a82bd7f38544ffbfd55e8c346d30" translate="yes" xml:space="preserve">
          <source>When you have a JavaScript project in your editor, TypeScript will provide types for your &lt;code&gt;node_modules&lt;/code&gt; automatically using the DefinitelyTyped set of &lt;code&gt;@types&lt;/code&gt; definitions. This is called automatic type acquisition, and you can customize it using the &lt;code&gt;typeAcquisition&lt;/code&gt; object in your configuration.</source>
          <target state="translated">エディタにJavaScriptプロジェクトがある場合、TypeScriptは、 &lt;code&gt;@types&lt;/code&gt; 定義のDefinitelyTypedセットを使用して、 &lt;code&gt;node_modules&lt;/code&gt; の型を自動的に提供します。これは自動型取得と呼ばれ、構成で &lt;code&gt;typeAcquisition&lt;/code&gt; オブジェクトを使用してカスタマイズできます。</target>
        </trans-unit>
        <trans-unit id="e7c36dbc166af4c2b15a69645f3c727647f3368c" translate="yes" xml:space="preserve">
          <source>When you have this option set, by not including a module in the &lt;code&gt;types&lt;/code&gt; array it:</source>
          <target state="translated">このオプションを設定している場合、 &lt;code&gt;types&lt;/code&gt; 配列にモジュールを含めないことで、次のようになります。</target>
        </trans-unit>
        <trans-unit id="cbca5cdf2d57a23f367d0a1514252e4f2c75c7b6" translate="yes" xml:space="preserve">
          <source>When you reference a project, new things happen:</source>
          <target state="translated">プロジェクトを参照すると、新しいことが起こります。</target>
        </trans-unit>
        <trans-unit id="34a19e5b1b2f656dfeb0df790e074ddaa8c1d34a" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;this&lt;/code&gt; keyword outside of classes, it has the type &lt;code&gt;any&lt;/code&gt; by default. For instance, imagine a &lt;code&gt;Point&lt;/code&gt; class, and imagine a function that we wish to add as a method:</source>
          <target state="translated">クラスの外で &lt;code&gt;this&lt;/code&gt; キーワードを使用すると、デフォルトでタイプ &lt;code&gt;any&lt;/code&gt; になります。たとえば、 &lt;code&gt;Point&lt;/code&gt; クラスと、メソッドとして追加する関数を想像してください。</target>
        </trans-unit>
        <trans-unit id="70c371f96f2c201ef59af8e252df237c2c99859d" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re happy, clone &lt;a href=&quot;https://github.com/DefinitelyTyped&quot;&gt;DefinitelyTyped/DefinitelyTyped&lt;/a&gt; and follow the instructions in the README.</source>
          <target state="translated">満足したら、&lt;a href=&quot;https://github.com/DefinitelyTyped&quot;&gt;DefinitelyTyped / DefinitelyTypedの&lt;/a&gt;クローンを作成し、READMEの指示に従います。</target>
        </trans-unit>
        <trans-unit id="4a2ff1337f892c7263b4813735bcd04bc80f2255" translate="yes" xml:space="preserve">
          <source>When:</source>
          <target state="translated">When:</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="2e1366df4a2e5026b79e734a847a45f2224acce3" translate="yes" xml:space="preserve">
          <source>Whether to keep outdated console output in watch mode instead of clearing the screen every time a change happened.</source>
          <target state="translated">変更が起こるたびに画面をクリアするのではなく、古いコンソール出力をウォッチモードで維持するかどうか。</target>
        </trans-unit>
        <trans-unit id="619362ecade2fffba9685e4a969d18b8cca8689d" translate="yes" xml:space="preserve">
          <source>Which can be described by the following .d.ts:</source>
          <target state="translated">これは、次の.d.ts.によって記述することができます。</target>
        </trans-unit>
        <trans-unit id="33710489e78a6feef64468d41a06aab499f59059" translate="yes" xml:space="preserve">
          <source>Which can be described with:</source>
          <target state="translated">と記述することができます。</target>
        </trans-unit>
        <trans-unit id="15bbf399003bd64788409edf57ef8dcc79e01d02" translate="yes" xml:space="preserve">
          <source>Which can be switched out with your own globals via this flag:</source>
          <target state="translated">このフラグを使用して、独自のグローバルで切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="0b6de3b1c6e1142dd03c8ec0d38d67a76b4d0290" translate="yes" xml:space="preserve">
          <source>Which creates quite a lot of JavaScript:</source>
          <target state="translated">これはかなり多くのJavaScriptを作成します。</target>
        </trans-unit>
        <trans-unit id="938fe38b788f59c1c6e957d41be0c2a25ffdccf8" translate="yes" xml:space="preserve">
          <source>Which generates code like:</source>
          <target state="translated">コードを生成している</target>
        </trans-unit>
        <trans-unit id="962849684c80963bf61b9a409447ab660d400c45" translate="yes" xml:space="preserve">
          <source>Which in turn can be imported using default imports:</source>
          <target state="translated">これは、デフォルトのインポートを使用してインポートすることができます。</target>
        </trans-unit>
        <trans-unit id="cf6447c6242e379fc5cad3f436eb54be60f4dba3" translate="yes" xml:space="preserve">
          <source>Which leads us to writing our first generic interface. Let&amp;rsquo;s take the object literal from the previous example and move it to an interface:</source>
          <target state="translated">これにより、最初の汎用インターフェースを作成することができます。前の例のオブジェクトリテラルをインターフェイスに移動してみましょう。</target>
        </trans-unit>
        <trans-unit id="70bd03441762cc2b325aef1bac1f313f2d0e16b5" translate="yes" xml:space="preserve">
          <source>Which translates to:</source>
          <target state="translated">翻訳すると</target>
        </trans-unit>
        <trans-unit id="3dbf1444b14bbeff8ff24b42f88c1114396361cf" translate="yes" xml:space="preserve">
          <source>Which would include:</source>
          <target state="translated">どっちが含まれているのか</target>
        </trans-unit>
        <trans-unit id="acfe760aa187d990362b3f4c61beb430484ea0d1" translate="yes" xml:space="preserve">
          <source>Which would print this output to the console:</source>
          <target state="translated">これはこの出力をコンソールに出力します。</target>
        </trans-unit>
        <trans-unit id="53ebf7ccbab25bb66042f79bfb51a8652406a52d" translate="yes" xml:space="preserve">
          <source>While ECMAScript exports are often a better way of providing this functionality, this new support allows code written in this style to &amp;ldquo;just work&amp;rdquo; TypeScript. Additionally, this approach for property declarations allows us to express common patterns like &lt;code&gt;defaultProps&lt;/code&gt; and &lt;code&gt;propTypes&lt;/code&gt; on React function components (formerly known as SFCs).</source>
          <target state="translated">ECMAScriptエクスポートは、多くの場合、この機能を提供するためのより良い方法ですが、この新しいサポートにより、このスタイルで記述されたコードはTypeScriptを「そのまま」機能させることができます。さらに、このプロパティ宣言のアプローチにより、React関数コンポーネント（以前はSFCと呼ばれていました）の &lt;code&gt;defaultProps&lt;/code&gt; や &lt;code&gt;propTypes&lt;/code&gt; などの一般的なパターンを表現できます。</target>
        </trans-unit>
        <trans-unit id="fad58bbb4ff5e3b9b95e4764b17888edf69eef4d" translate="yes" xml:space="preserve">
          <source>While TypeScript 3.7 isn&amp;rsquo;t changing any existing emit by default, we&amp;rsquo;ve been rolling out changes incrementally to help users mitigate potential future breakage. We&amp;rsquo;ve provided a new flag called &lt;code&gt;useDefineForClassFields&lt;/code&gt; to enable this emit mode with some new checking logic.</source>
          <target state="translated">TypeScript 3.7はデフォルトでは既存の出力を変更しませんが、ユーザーは潜在的な将来の破損を軽減するために変更を段階的に展開しています。いくつかの新しいチェックロジックでこの &lt;code&gt;useDefineForClassFields&lt;/code&gt; モードを有効にするために、useDefineForClassFieldsと呼ばれる新しいフラグを提供しました。</target>
        </trans-unit>
        <trans-unit id="f56a592c618616410fc71f4bbabb49d78514f411" translate="yes" xml:space="preserve">
          <source>While allowing people to randomly set &lt;code&gt;fullName&lt;/code&gt; directly is pretty handy, we may also want enforce some constraints when &lt;code&gt;fullName&lt;/code&gt; is set.</source>
          <target state="translated">&lt;code&gt;fullName&lt;/code&gt; を直接ランダムに設定できるようにすることは非常に便利ですが、 &lt;code&gt;fullName&lt;/code&gt; を設定するときにいくつかの制約を適用することもできます。</target>
        </trans-unit>
        <trans-unit id="636d4d19d4405d30263f2aa95da0f2c2a734da53" translate="yes" xml:space="preserve">
          <source>While comparing primitive types and object types is relatively straightforward, the question of what kinds of functions should be considered compatible is a bit more involved. Let&amp;rsquo;s start with a basic example of two functions that differ only in their parameter lists:</source>
          <target state="translated">プリミティブ型とオブジェクト型を比較す​​るのは比較的簡単ですが、互換性があると見なされる関数の種類の問題は少し複雑です。パラメータリストのみが異なる2つの関数の基本的な例から始めましょう。</target>
        </trans-unit>
        <trans-unit id="03a5fd4e6d293c6d495eff753858affb70025397" translate="yes" xml:space="preserve">
          <source>While it&amp;rsquo;s good practice to use &lt;code&gt;ReadonlyArray&lt;/code&gt; over &lt;code&gt;Array&lt;/code&gt; when no mutation is intended, it&amp;rsquo;s often been a pain given that arrays have a nicer syntax. Specifically, &lt;code&gt;number[]&lt;/code&gt; is a shorthand version of &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt;, just as &lt;code&gt;Date[]&lt;/code&gt; is a shorthand for &lt;code&gt;Array&amp;lt;Date&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">変更を意図していない場合は、 &lt;code&gt;ReadonlyArray&lt;/code&gt; を &lt;code&gt;Array&lt;/code&gt; よりも使用することをお勧めしますが、配列の構文が適切であることを考えると、多くの場合面倒です。具体的には、 &lt;code&gt;Date[]&lt;/code&gt; が &lt;code&gt;Array&amp;lt;Date&amp;gt;&lt;/code&gt; 省略形であるのと同様に、 &lt;code&gt;number[]&lt;/code&gt; は &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt; の省略形です。</target>
        </trans-unit>
        <trans-unit id="2c74aaa3335f7bff7bf6990f82abec0b22352a01" translate="yes" xml:space="preserve">
          <source>While not a breakage per se, opting in to the &lt;code&gt;useDefineForClassFields&lt;/code&gt; flag can cause breakage when:</source>
          <target state="translated">それ自体は破損ではありませんが、 &lt;code&gt;useDefineForClassFields&lt;/code&gt; フラグを有効にすると、次の場合に破損が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ebbe87035da271030af0d806842f81f2cc35cc3b" translate="yes" xml:space="preserve">
          <source>While not strictly a language change, nightly builds are now available by installing with the following command:</source>
          <target state="translated">厳密には言語の変更ではありませんが、以下のコマンドでインストールすることでナイトリービルドが利用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="3360869251a9b9ea8953b44e203398f6f81cb993" translate="yes" xml:space="preserve">
          <source>While string enums don&amp;rsquo;t have auto-incrementing behavior, string enums have the benefit that they &amp;ldquo;serialize&amp;rdquo; well. In other words, if you were debugging and had to read the runtime value of a numeric enum, the value is often opaque - it doesn&amp;rsquo;t convey any useful meaning on its own (though &lt;a href=&quot;#enums-at-runtime&quot;&gt;reverse mapping&lt;/a&gt; can often help), string enums allow you to give a meaningful and readable value when your code runs, independent of the name of the enum member itself.</source>
          <target state="translated">文字列列挙型には自動インクリメント動作はありませんが、文字列列挙型には、「シリアル化」が適切に行われるという利点があります。つまり、デバッグ中に数値列挙型のランタイム値を読み取る必要があった場合、値は不透明であることがよくあります-それ自体では有用な意味を伝えません（&lt;a href=&quot;#enums-at-runtime&quot;&gt;逆マッピング&lt;/a&gt;が役立つことがよくあります）。文字列列挙型を使用すると、 enumメンバー自体の名前とは無関係に、コードの実行時に意味のある読みやすい値を提供します。</target>
        </trans-unit>
        <trans-unit id="9889e9833569f06fb69539d73f7b2696ca91f5f9" translate="yes" xml:space="preserve">
          <source>While string enums don&amp;rsquo;t have auto-incrementing behavior, string enums have the benefit that they &amp;ldquo;serialize&amp;rdquo; well. In other words, if you were debugging and had to read the runtime value of a numeric enum, the value is often opaque - it doesn&amp;rsquo;t convey any useful meaning on its own (though &lt;a href=&quot;#reverse-mappings&quot;&gt;reverse mapping&lt;/a&gt; can often help), string enums allow you to give a meaningful and readable value when your code runs, independent of the name of the enum member itself.</source>
          <target state="translated">文字列列挙型には自動インクリメントの動作はありませんが、文字列列挙型には、適切に「シリアル化」されるという利点があります。言い換えると、デバッグ中に数値列挙型の実行時値を読み取る必要がある場合、値は不透明であることがよくあります-それ自体では有用な意味を伝えません（&lt;a href=&quot;#reverse-mappings&quot;&gt;逆マッピング&lt;/a&gt;が役立つことがよくありますが）、文字列列挙型を使用すると列挙型メンバー自体の名前に関係なく、コードの実行時に意味のある読みやすい値を提供します。</target>
        </trans-unit>
        <trans-unit id="f4c063d2ee2675e04f30864acccf31e9c245c672" translate="yes" xml:space="preserve">
          <source>While string index signatures are a powerful way to describe the &amp;ldquo;dictionary&amp;rdquo; pattern, they also enforce that all properties match their return type. This is because a string index declares that &lt;code&gt;obj.property&lt;/code&gt; is also available as &lt;code&gt;obj[&quot;property&quot;]&lt;/code&gt;. In the following example, &lt;code&gt;name&lt;/code&gt;&amp;rsquo;s type does not match the string index&amp;rsquo;s type, and the type checker gives an error:</source>
          <target state="translated">文字列インデックスシグネチャは「ディクショナリ」パターンを説明する強力な方法ですが、すべてのプロパティが戻り値の型と一致することも強制します。これは、文字列インデックスが &lt;code&gt;obj.property&lt;/code&gt; が &lt;code&gt;obj[&quot;property&quot;]&lt;/code&gt; としても使用できることを宣言しているためです。次の例では、 &lt;code&gt;name&lt;/code&gt; のタイプが文字列インデックスのタイプと一致せず、タイプチェッカーがエラーを出します。</target>
        </trans-unit>
        <trans-unit id="205fbdc2b0eb96d4c083fa10d1cf873197618502" translate="yes" xml:space="preserve">
          <source>While using &lt;code&gt;any&lt;/code&gt; is certainly generic in that it will cause the function to accept any and all types for the type of &lt;code&gt;arg&lt;/code&gt;, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned.</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; を使用すると、関数が &lt;code&gt;arg&lt;/code&gt; のタイプのすべてのタイプを受け入れるようになるという点で確かに汎用的ですが、実際には、関数が戻るときにそのタイプが何であったかに関する情報が失われています。数値を渡した場合、唯一の情報は、任意のタイプが返される可能性があるということです。</target>
        </trans-unit>
        <trans-unit id="ad9ab077983f93d52e50138e0c0b8bb1d71036dc" translate="yes" xml:space="preserve">
          <source>While you can use TypeScript to produce JavaScript code from TypeScript code, it&amp;rsquo;s also common to use other transpilers such as &lt;a href=&quot;https://babeljs.io&quot;&gt;Babel&lt;/a&gt; to do this. However, other transpilers only operate on a single file at a time, which means they can&amp;rsquo;t apply code transforms that depend on understanding the full type system. This restriction also applies to TypeScript&amp;rsquo;s &lt;code&gt;ts.transpileModule&lt;/code&gt; API which is used by some build tools.</source>
          <target state="translated">TypeScriptを使用してTypeScriptコードからJavaScriptコードを生成できますが、これを行うために&lt;a href=&quot;https://babeljs.io&quot;&gt;Babel&lt;/a&gt;などの他のトランスパイラーを使用することも一般的です。ただし、他のトランスパイラーは一度に1つのファイルのみを操作するため、完全な型システムの理解に依存するコード変換を適用することはできません。この制限は、一部のビルドツールで使用されるTypeScriptの &lt;code&gt;ts.transpileModule&lt;/code&gt; APIにも適用されます。</target>
        </trans-unit>
        <trans-unit id="3773d499a43f196d119753de15012adfe413581f" translate="yes" xml:space="preserve">
          <source>While you might imagine close interaction between &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;bigint&lt;/code&gt;, the two are separate domains.</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; と &lt;code&gt;bigint&lt;/code&gt; の密接な相互作用を想像するかもしれませんが、2つは別々のドメインです。</target>
        </trans-unit>
        <trans-unit id="7942bdf53c9b517b254a399642caadffcd723ac5" translate="yes" xml:space="preserve">
          <source>Why does a module in the exclude list still get picked up by the compiler?</source>
          <target state="translated">除外リストにあるモジュールがコンパイラに拾われるのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="dd7392a9f697967405bb99a3337ee2df7f8bb374" translate="yes" xml:space="preserve">
          <source>Wildcard character in module names</source>
          <target state="translated">モジュール名のワイルドカード文字</target>
        </trans-unit>
        <trans-unit id="90ff022ca86ce297643ad53057127508fda59a21" translate="yes" xml:space="preserve">
          <source>Wildcard module declarations</source>
          <target state="translated">ワイルドカードモジュール宣言</target>
        </trans-unit>
        <trans-unit id="e1deac0ee95462765acc0e4d19e587e5b367dac8" translate="yes" xml:space="preserve">
          <source>Wildcard module names can be even more useful when migrating from an un-typed code base. Combined with Shorthand ambient module declarations, a set of modules can be easily declared as &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">ワイルドカードモジュール名は、型指定されていないコードベースから移行する場合にさらに役立ちます。簡易アンビエントモジュール宣言と組み合わせると、モジュールのセットを &lt;code&gt;any&lt;/code&gt; として簡単に宣言できます。</target>
        </trans-unit>
        <trans-unit id="576eaaaec7aa1978999d8da3f80d2816c7c61923" translate="yes" xml:space="preserve">
          <source>Will generate an &lt;code&gt;index.js&lt;/code&gt; file like this:</source>
          <target state="translated">次のような &lt;code&gt;index.js&lt;/code&gt; ファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="294ac8947e55f645c50e17c1f027a18712e8f38f" translate="yes" xml:space="preserve">
          <source>Will generate the following JavaScript output:</source>
          <target state="translated">以下のJavaScript出力を生成します。</target>
        </trans-unit>
        <trans-unit id="49659e5a07d9ec9ddbc5ea2cded9dfed86235252" translate="yes" xml:space="preserve">
          <source>Will generate:</source>
          <target state="translated">生成します。</target>
        </trans-unit>
        <trans-unit id="9d704e8d8dc3b8c3f478cd3a1e99749549751af4" translate="yes" xml:space="preserve">
          <source>Will not add globals to your project (e.g &lt;code&gt;process&lt;/code&gt; in node, or &lt;code&gt;expect&lt;/code&gt; in Jest)</source>
          <target state="translated">プロジェクトにグローバルを追加しません（たとえば、ノードでの &lt;code&gt;process&lt;/code&gt; 、またはJestでの &lt;code&gt;expect&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="21c5226c3b0025dce708838e9de5a2bc24249633" translate="yes" xml:space="preserve">
          <source>Will not have exports appear as auto-import recommendations</source>
          <target state="translated">エクスポートが自動インポート推奨として表示されないようになります。</target>
        </trans-unit>
        <trans-unit id="74eea0f1c70b52371bc0816bb556d0f8780652ce" translate="yes" xml:space="preserve">
          <source>Will produce a &lt;code&gt;.d.ts&lt;/code&gt; file like</source>
          <target state="translated">のような &lt;code&gt;.d.ts&lt;/code&gt; ファイルを生成します</target>
        </trans-unit>
        <trans-unit id="8dc5830cdd248d481961de84dd0f5250619d9bd8" translate="yes" xml:space="preserve">
          <source>Will result in assigning the name &lt;code&gt;NamedModule&lt;/code&gt; to the module as part of calling the AMD &lt;code&gt;define&lt;/code&gt;:</source>
          <target state="translated">AMD &lt;code&gt;define&lt;/code&gt; の呼び出しの一部として、 &lt;code&gt;NamedModule&lt;/code&gt; という名前がモジュールに割り当てられます。</target>
        </trans-unit>
        <trans-unit id="ccd47948ed1aa34956ec39f702d4f4d8e5beb53d" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;React 17&lt;/a&gt; the library supports a new form of JSX transformation via a separate import.</source>
          <target state="translated">&lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;17が反応&lt;/a&gt;ライブラリは別々のインポートを経由してJSX変換の新しいフォームをサポートしています。</target>
        </trans-unit>
        <trans-unit id="d439834e2baaed052d93e4971a2a939ad111045c" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#strictNullChecks&quot;&gt;&lt;code&gt;--strictNullChecks&lt;/code&gt;&lt;/a&gt;, an optional parameter automatically adds &lt;code&gt;| undefined&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://www.typescriptlang.org/tsconfig#strictNullChecks&quot;&gt; &lt;code&gt;--strictNullChecks&lt;/code&gt; &lt;/a&gt;、オプションのパラメータが自動的に追加します &lt;code&gt;| undefined&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f3fa735b620d5297fbccee8fa108c418d0b3be08" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&quot;allowUnreachableCode&quot;: false&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&quot;allowUnreachableCode&quot;: false&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7c698c1cfe17edf510077db506e15f74e06ad129" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&quot;baseUrl&quot;: &quot;./&quot;&lt;/code&gt; inside this project TypeScript will look for files starting at the same folder as the &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="translated">では &lt;code&gt;&quot;baseUrl&quot;: &quot;./&quot;&lt;/code&gt; このプロジェクト内の活字体は、同じフォルダで始まるファイルを探します &lt;code&gt;tsconfig.json&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13740d4f0b7aedad3ff699e83aa212feeaefbb89" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--downlevelIteration&lt;/code&gt;, the compiler uses new type check and emit behavior that attempts to call a &lt;code&gt;[Symbol.iterator]()&lt;/code&gt; method on the iterated object if it is found, and creates a synthetic array iterator over the object if it is not.</source>
          <target state="translated">&lt;code&gt;--downlevelIteration&lt;/code&gt; 、コンパイラが試みが呼び出すことが新しい型チェックとEMIT挙動使用 &lt;code&gt;[Symbol.iterator]()&lt;/code&gt; 、それが見つかった場合、反復オブジェクトのメソッドを、それがない場合は、オブジェクト上の合成配列イテレータを作成します。</target>
        </trans-unit>
        <trans-unit id="0baf96b645c93694808d46132810c65e4ff0d180" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--esModuleInterop&lt;/code&gt; two new helpers are generated &lt;code&gt;__importStar&lt;/code&gt; and &lt;code&gt;__importDefault&lt;/code&gt; for import &lt;code&gt;*&lt;/code&gt; and import &lt;code&gt;default&lt;/code&gt; respectively. For instance input like:</source>
          <target state="translated">&lt;code&gt;--esModuleInterop&lt;/code&gt; 二つの新しいヘルパーが生成され &lt;code&gt;__importStar&lt;/code&gt; と &lt;code&gt;__importDefault&lt;/code&gt; をインポートするために &lt;code&gt;*&lt;/code&gt; と輸入 &lt;code&gt;default&lt;/code&gt; それぞれ。たとえば、次のような入力：</target>
        </trans-unit>
        <trans-unit id="3da68912666fd5861031d156bf5a2c7082eb8729" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt;, this example will trigger an error:</source>
          <target state="translated">では &lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt; 、この例では、エラーがトリガされます。</target>
        </trans-unit>
        <trans-unit id="f2e90c030cc7f4b83e2a77c542e137b8a0ccca5d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--strictNullChecks&lt;/code&gt;, an optional parameter automatically adds &lt;code&gt;| undefined&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;--strictNullChecks&lt;/code&gt; 、オプションのパラメータが自動的に追加します &lt;code&gt;| undefined&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="32a499399a274aac8c9b26572f194ee6506912c8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;@constructor&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; is checked inside the constructor function &lt;code&gt;C&lt;/code&gt;, so you will get suggestions for the &lt;code&gt;initialize&lt;/code&gt; method and an error if you pass it a number. You will also get an error if you call &lt;code&gt;C&lt;/code&gt; instead of constructing it.</source>
          <target state="translated">では &lt;code&gt;@constructor&lt;/code&gt; 、 &lt;code&gt;this&lt;/code&gt; コンストラクタ関数内でチェックされている &lt;code&gt;C&lt;/code&gt; あなたがのための提案を取得しますので、 &lt;code&gt;initialize&lt;/code&gt; あなたがそれに番号を渡す場合の方法とエラーが。また、 &lt;code&gt;C&lt;/code&gt; を作成する代わりにCを呼び出すと、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="a035a3570a36bd407b773b9516d29f13b1a3f416" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;@constructor&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; is checked inside the constructor function &lt;code&gt;C&lt;/code&gt;, so you will get suggestions for the &lt;code&gt;initialize&lt;/code&gt; method and an error if you pass it a number. Your editor may also show warnings if you call &lt;code&gt;C&lt;/code&gt; instead of constructing it.</source>
          <target state="translated">では &lt;code&gt;@constructor&lt;/code&gt; 、 &lt;code&gt;this&lt;/code&gt; コンストラクタ関数内でチェックされている &lt;code&gt;C&lt;/code&gt; あなたがのための提案を取得しますので、 &lt;code&gt;initialize&lt;/code&gt; あなたがそれに番号を渡す場合の方法とエラーが。 &lt;code&gt;C&lt;/code&gt; を作成する代わりに呼び出すと、エディターに警告が表示される場合もあります。</target>
        </trans-unit>
        <trans-unit id="5d91be3836c575b7186f6f373bced4bbebe5f6bb" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;emitDecoratorMetadata&lt;/code&gt; not set to true (default):</source>
          <target state="translated">&lt;code&gt;emitDecoratorMetadata&lt;/code&gt; true（デフォルト）に設定されていません。</target>
        </trans-unit>
        <trans-unit id="81bf84665fe838195d196abf704465f50c25a018" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;emitDecoratorMetadata&lt;/code&gt; set to true:</source>
          <target state="translated">&lt;code&gt;emitDecoratorMetadata&lt;/code&gt; trueに設定します。</target>
        </trans-unit>
        <trans-unit id="a91ba76f93ca7d7e7796d620a3627489f9dfc963" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;esModuleInterop&lt;/code&gt; disabled:</source>
          <target state="translated">&lt;code&gt;esModuleInterop&lt;/code&gt; 無効：</target>
        </trans-unit>
        <trans-unit id="856c403e9c9ac477d8823a19f4509e5405076b88" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;esModuleInterop&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;esModuleInterop&lt;/code&gt; に設定し &lt;code&gt;true&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0df6054d7160294fcb8ad604c1672c83e1b676c9" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;false&lt;/code&gt;, the default.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 、デフォルト。</target>
        </trans-unit>
        <trans-unit id="b1ea5d91d6887a555bb6f2794a07c5714e99ed42" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;import&lt;/code&gt; types available, many of the visibility errors reported during declaration file generation can be handled by the compiler without the need to change the input.</source>
          <target state="translated">で &lt;code&gt;import&lt;/code&gt; 可能なタイプ、宣言ファイル生成時に報告された可視性エラーの多くは、入力を変更することなく、コンパイラによって処理することができます。</target>
        </trans-unit>
        <trans-unit id="0b3f0c8f5386232b3414f9e7bc8c3f6e1ed65eec" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;jsxFactory: &quot;h&quot;&lt;/code&gt; looks like:</source>
          <target state="translated">&lt;code&gt;jsxFactory: &quot;h&quot;&lt;/code&gt; 次のようになります。</target>
        </trans-unit>
        <trans-unit id="f84d42cb295076793894c8acadb047e99a4e746a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;object&lt;/code&gt; type, APIs like &lt;code&gt;Object.create&lt;/code&gt; can be better represented. For example:</source>
          <target state="translated">では &lt;code&gt;object&lt;/code&gt; タイプ、のようなAPIを &lt;code&gt;Object.create&lt;/code&gt; をよりよく表現することができます。例えば：</target>
        </trans-unit>
        <trans-unit id="8ea2d3d828b1a918f20e697667351b7f6a125a32" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;preserveConstEnums&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;enum&lt;/code&gt; exists at runtime and the numbers are still emitted.</source>
          <target state="translated">&lt;code&gt;preserveConstEnums&lt;/code&gt; に設定 &lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;enum&lt;/code&gt; 実行時に存在し、番号がまだ放出されます。</target>
        </trans-unit>
        <trans-unit id="26a01b47e5ab896c53b6fbdf6dc40647a614653e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;state&lt;/code&gt; as a literal type, you can compare the value of &lt;code&gt;state&lt;/code&gt; to the equivalent string and TypeScript will know which type is currently being used.</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; リテラルタイプとして、次の値と比較することができる &lt;code&gt;state&lt;/code&gt; 等価の文字列にし、活字体は、現在使用されているタイプを知っているだろう。</target>
        </trans-unit>
        <trans-unit id="00e1537de3780fc9b8daffc9debdc08216587d32" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;strictFunctionTypes&lt;/code&gt;&lt;em&gt;on&lt;/em&gt;, the error is correctly detected:</source>
          <target state="translated">&lt;code&gt;strictFunctionTypes&lt;/code&gt; &lt;em&gt;に&lt;/em&gt;、エラーが正しく検出されています。</target>
        </trans-unit>
        <trans-unit id="787b06dec962cd4ac1d5fed3f2e1a225bfd61e2b" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;stripInternal&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; the &lt;code&gt;d.ts&lt;/code&gt; emitted will be redacted.</source>
          <target state="translated">&lt;code&gt;stripInternal&lt;/code&gt; がに設定され &lt;code&gt;true&lt;/code&gt; &lt;code&gt;d.ts&lt;/code&gt; 放出されるが編集されます。</target>
        </trans-unit>
        <trans-unit id="5fa847821456a4401d0546fcc0d18f6208406246" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;this&lt;/code&gt; annotated, you make it explicit that &lt;code&gt;onClickBad&lt;/code&gt; must be called on an instance of &lt;code&gt;Handler&lt;/code&gt;. Then TypeScript will detect that &lt;code&gt;addClickListener&lt;/code&gt; requires a function that has &lt;code&gt;this: void&lt;/code&gt;. To fix the error, change the type of &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">で &lt;code&gt;this&lt;/code&gt; 注釈を付け、あなたはそれが明示的なことを確認 &lt;code&gt;onClickBad&lt;/code&gt; はのインスタンスで呼び出さなければなりません &lt;code&gt;Handler&lt;/code&gt; 。次に、TypeScriptは、 &lt;code&gt;addClickListener&lt;/code&gt; に &lt;code&gt;this: void&lt;/code&gt; 含む関数が必要であることを検出します。エラーを修正するには、 &lt;code&gt;this&lt;/code&gt; タイプを変更します：</target>
        </trans-unit>
        <trans-unit id="af6f22a2cba3d56fa994838cc0aadc7b657d06d7" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="275d348200c6c9320565561ab80694a7f189a460" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;var&lt;/code&gt; declarations, we mentioned that it didn&amp;rsquo;t matter how many times you declared your variables; you just got one.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 宣言、我々はあなたがあなたの変数を宣言した回数問題ではありませんでしたと述べました。あなたはちょうどそれを手に入れました。</target>
        </trans-unit>
        <trans-unit id="c9b5a6af6e81107e965d92874d8f98c54b8d5351" translate="yes" xml:space="preserve">
          <source>With ES6&amp;rsquo;s codepoint escapes, you can cleanly represent that exact character in strings and template strings with a single escape: &lt;code&gt;&quot;\u{20bb7}&quot;&lt;/code&gt;. TypeScript will emit the string in ES3/ES5 as &lt;code&gt;&quot;\uD842\uDFB7&quot;&lt;/code&gt;.</source>
          <target state="translated">ES6のコードポイントエスケープを使用すると、 &lt;code&gt;&quot;\u{20bb7}&quot;&lt;/code&gt; という単一のエスケープで、文字列およびテンプレート文字列内のその正確な文字を明確に表すことができます。TypeScriptは、ES3 / ES5で文字列を &lt;code&gt;&quot;\uD842\uDFB7&quot;&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="a3fe0d7c3c1bcf18bd50d0141170db310dc43d9e" translate="yes" xml:space="preserve">
          <source>With TypeScript 1.6, type aliases can be generic. For example:</source>
          <target state="translated">TypeScript 1.6 では、型のエイリアスは汎用的なものにすることができます。例えば</target>
        </trans-unit>
        <trans-unit id="460f7c766e92b496f73d02d4ccf0cc4d7ee440b6" translate="yes" xml:space="preserve">
          <source>With TypeScript 1.8 it becomes possible for a type parameter constraint to reference type parameters from the same type parameter list. Previously this was an error. This capability is usually referred to as &lt;a href=&quot;https://en.wikipedia.org/wiki/Bounded_quantification#F-bounded_quantification&quot;&gt;F-Bounded Polymorphism&lt;/a&gt;.</source>
          <target state="translated">TypeScript 1.8では、型パラメーター制約が同じ型パラメーターリストから型パラメーターを参照することが可能になります。以前は、これはエラーでした。この機能は、通常、&lt;a href=&quot;https://en.wikipedia.org/wiki/Bounded_quantification#F-bounded_quantification&quot;&gt;F境界ポリモーフィズム&lt;/a&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="10bf274b692b3bbc5a7692bb92ffc8f07852abb4" translate="yes" xml:space="preserve">
          <source>With TypeScript 1.8, JSX tags are now classified and colorized in Visual Studio 2015.</source>
          <target state="translated">TypeScript 1.8では、Visual Studio 2015でJSXタグが分類され、色付けされるようになりました。</target>
        </trans-unit>
        <trans-unit id="c62a9b4ded80d831595f6cf41c707a66d7b472df" translate="yes" xml:space="preserve">
          <source>With TypeScript 1.8, we&amp;rsquo;ve introduced string literal types. These types are written the same way string literals are, but in type positions.</source>
          <target state="translated">TypeScript 1.8では、文字列リテラル型を導入しました。これらの型は、文字列リテラルと同じように書き込まれますが、型の位置にあります。</target>
        </trans-unit>
        <trans-unit id="cafdb66c7fc578df947b8db9b1207f3133582261" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.0, the compiler will look up definition of &lt;code&gt;&quot;moduleA.js&quot;&lt;/code&gt; in &lt;code&gt;./moduleA.ts&lt;/code&gt; or &lt;code&gt;./moduleA.d.t&lt;/code&gt;.</source>
          <target state="translated">活字体2.0を使用すると、コンパイラは、の定義検索します &lt;code&gt;&quot;moduleA.js&quot;&lt;/code&gt; で &lt;code&gt;./moduleA.ts&lt;/code&gt; または &lt;code&gt;./moduleA.d.t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4f9f7cdd4003c7ab1f53ac08b77e405631b7232" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.1, instead of just choosing &lt;code&gt;any&lt;/code&gt;, TypeScript will infer types based on what you end up assigning later on.</source>
          <target state="translated">TypeScript 2.1では、を選択 &lt;code&gt;any&lt;/code&gt; だけでなく、TypeScriptは後で割り当てた結果に基づいて型を推測します。</target>
        </trans-unit>
        <trans-unit id="9277e32824b441ad62cb76d21644b7bd58f69e2f" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.1, you can import a JavaScript module without needing a type declaration. A type declaration (such as &lt;code&gt;declare module &quot;foo&quot; { ... }&lt;/code&gt; or &lt;code&gt;node_modules/@types/foo&lt;/code&gt;) still takes priority if it exists.</source>
          <target state="translated">TypeScript 2.1を使用すると、型宣言を必要とせずにJavaScriptモジュールをインポートできます。型宣言（ &lt;code&gt;declare module &quot;foo&quot; { ... }&lt;/code&gt; または &lt;code&gt;node_modules/@types/foo&lt;/code&gt; ）は、存在する場合でも優先されます。</target>
        </trans-unit>
        <trans-unit id="fbf94ecb57bb0f01e4f682c5fcfc23891843f05c" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.8 &lt;code&gt;keyof&lt;/code&gt; applied to an intersection type is transformed to a union of &lt;code&gt;keyof&lt;/code&gt; applied to each intersection constituent. In other words, types of the form &lt;code&gt;keyof (A &amp;amp; B)&lt;/code&gt; are transformed to be &lt;code&gt;keyof A | keyof B&lt;/code&gt;. This change should address inconsistencies with inference from &lt;code&gt;keyof&lt;/code&gt; expressions.</source>
          <target state="translated">TypeScript 2.8を &lt;code&gt;keyof&lt;/code&gt; して、交差点タイプにkeyofを適用すると、交差点の各構成要素に適用される &lt;code&gt;keyof&lt;/code&gt; の和集合に変換されます。つまり、 &lt;code&gt;keyof (A &amp;amp; B)&lt;/code&gt; という形式の型は、 &lt;code&gt;keyof A | keyof B&lt;/code&gt; 変換されます。keyof B。この変更により、 &lt;code&gt;keyof&lt;/code&gt; 式からの推論による矛盾に対処する必要があります。</target>
        </trans-unit>
        <trans-unit id="799099f20671837db4b655a12286097f02ebcd18" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.9, no errors are reported, and now the generated file looks like:</source>
          <target state="translated">TypeScript 2.9では、エラーは報告されず、生成されたファイルは以下のようになりました。</target>
        </trans-unit>
        <trans-unit id="593a67e967dde8319eb871882cb980edd2921bd0" translate="yes" xml:space="preserve">
          <source>With TypeScript 3.8, TypeScript supports the new JavaScript syntax for private fields:</source>
          <target state="translated">TypeScript 3.8では、プライベートフィールドのための新しいJavaScript構文がサポートされています。</target>
        </trans-unit>
        <trans-unit id="c155aa6cb506c0f0942a50171b6b5c899640514a" translate="yes" xml:space="preserve">
          <source>With TypeScript 3.8, you can use &lt;code&gt;export * as ns&lt;/code&gt; as a shorthand for re-exporting another module with a name:</source>
          <target state="translated">TypeScript 3.8では、次の名前の別のモジュールを再エクスポートするための省略形として &lt;code&gt;export * as ns&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="d61e7a4d8ea1ab6a29d0ab09e04c9367f5313f2f" translate="yes" xml:space="preserve">
          <source>With TypeScript being a superset of JavaScript, the language naturally supports &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. Here we&amp;rsquo;ll elaborate more on these new declarations and why they&amp;rsquo;re preferable to &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">TypeScriptがJavaScriptのスーパーセットであるため、この言語は自然に &lt;code&gt;let&lt;/code&gt; と &lt;code&gt;const&lt;/code&gt; をサポートします。ここでは、これらの新しい宣言と、それらが &lt;code&gt;var&lt;/code&gt; よりも望ましい理由について詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="64acedeec41f3540960ea284815c1fcdf273f591" translate="yes" xml:space="preserve">
          <source>With TypeScript being an extension of JavaScript, the language naturally supports &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. Here we&amp;rsquo;ll elaborate more on these new declarations and why they&amp;rsquo;re preferable to &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">TypeScriptはJavaScriptの拡張であるため、言語は当然 &lt;code&gt;let&lt;/code&gt; と &lt;code&gt;const&lt;/code&gt; をサポートします。ここでは、これらの新しい宣言と、それらが &lt;code&gt;var&lt;/code&gt; よりも好ましい理由について詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="05547de14b26a58915e578c86428fac86c5d55e1" translate="yes" xml:space="preserve">
          <source>With TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: with Unions, and with Generics.</source>
          <target state="translated">TypeScriptでは、単純な型を組み合わせて複雑な型を作ることができます。これには、ユニオンを使う方法とジェネリックを使う方法の2つがあります。</target>
        </trans-unit>
        <trans-unit id="1d707a1290fe39949a2e479395f58ab100dab281" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;tsconfig.json&lt;/code&gt; like this:</source>
          <target state="translated">このような &lt;code&gt;tsconfig.json&lt;/code&gt; を使用すると：</target>
        </trans-unit>
        <trans-unit id="3feff2c10853072f1034314c16cdb18d37370a30" translate="yes" xml:space="preserve">
          <source>With a corresponding &lt;code&gt;helloWorld.d.ts&lt;/code&gt;:</source>
          <target state="translated">対応する &lt;code&gt;helloWorld.d.ts&lt;/code&gt; を使用して：</target>
        </trans-unit>
        <trans-unit id="f706ee444b6a34fbb533bf241523f396e3c6d47a" translate="yes" xml:space="preserve">
          <source>With a union, you can declare that a type could be one of many types. For example, you can describe a &lt;code&gt;boolean&lt;/code&gt; type as being either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">ユニオンを使用すると、型が多くの型の1つになる可能性があることを宣言できます。たとえば、 &lt;code&gt;boolean&lt;/code&gt; 型を &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; のいずれかとして記述できます。</target>
        </trans-unit>
        <trans-unit id="82f558e3e809cb29cfb2ac66cc2514576d7422f4" translate="yes" xml:space="preserve">
          <source>With definite assignment assertions, we can assert that &lt;code&gt;x&lt;/code&gt; is really assigned by appending an &lt;code&gt;!&lt;/code&gt; to its declaration:</source>
          <target state="translated">明確な代入アサーションを使用すると、 &lt;code&gt;!&lt;/code&gt; を追加することにより、 &lt;code&gt;x&lt;/code&gt; が実際に代入されていることをアサートできます。その宣言に：</target>
        </trans-unit>
        <trans-unit id="1b9ea4bd3d43c0f24f8d1235be222ef088964840" translate="yes" xml:space="preserve">
          <source>With generic parameter defaults we can reduce it to:</source>
          <target state="translated">一般的なパラメータのデフォルトを使用すると、以下のように減らすことができます。</target>
        </trans-unit>
        <trans-unit id="285525d91c532d67502baa5d535e42948f1fec46" translate="yes" xml:space="preserve">
          <source>With index types, you can get the compiler to check code that uses dynamic property names. For example, a common JavaScript pattern is to pick a subset of properties from an object:</source>
          <target state="translated">インデックス型を使用すると、動的なプロパティ名を使用するコードをコンパイラにチェックさせることができます。例えば、JavaScript の一般的なパターンは、オブジェクトからプロパティのサブセットを選択することです。</target>
        </trans-unit>
        <trans-unit id="16dcd92f3ae6feec4cfbb7198eb7027566939a02" translate="yes" xml:space="preserve">
          <source>With more &lt;code&gt;tsconfig.json&lt;/code&gt; files, you&amp;rsquo;ll usually want to use &lt;a href=&quot;tsconfig-json&quot;&gt;Configuration file inheritance&lt;/a&gt; to centralize your common compiler options. This way you can change a setting in one file rather than having to edit multiple files.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; ファイルの数が増えると、通常、&lt;a href=&quot;tsconfig-json&quot;&gt;構成ファイルの継承&lt;/a&gt;を使用して、共通のコンパイラオプションを一元化します。これにより、複数のファイルを編集する必要がなく、1つのファイルの設定を変更できます。</target>
        </trans-unit>
        <trans-unit id="6c19413ec559ade6957207124c85c3143a8ddce9" translate="yes" xml:space="preserve">
          <source>With the flag set to &lt;code&gt;false&lt;/code&gt; (default):</source>
          <target state="translated">フラグを &lt;code&gt;false&lt;/code&gt; に設定した場合（デフォルト）：</target>
        </trans-unit>
        <trans-unit id="dc980dcbd81da3823a44dd1638ddc07a1ed0b4b4" translate="yes" xml:space="preserve">
          <source>With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members. Decorators provide a way to add both annotations and a meta-programming syntax for class declarations and members. Decorators are a &lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot;&gt;stage 2 proposal&lt;/a&gt; for JavaScript and are available as an experimental feature of TypeScript.</source>
          <target state="translated">TypeScriptおよびES6でのクラスの導入により、クラスおよびクラスメンバーの注釈付けまたは変更をサポートするために追加の機能を必要とする特定のシナリオが存在するようになりました。デコレータは、クラスの宣言とメンバーに注釈とメタプログラミング構文の両方を追加する方法を提供します。デコレータは、JavaScriptの&lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot;&gt;ステージ2の提案&lt;/a&gt;であり、TypeScriptの実験的な機能として利用できます。</target>
        </trans-unit>
        <trans-unit id="d5cc45fbb67785639194811b9d1feec6410a8444" translate="yes" xml:space="preserve">
          <source>With these all set up, then you can create a class which represents the base class with mixins applied:</source>
          <target state="translated">これらの設定が完了したら、ミックスインを適用したベースクラスを表すクラスを作成します。</target>
        </trans-unit>
        <trans-unit id="f8c7c6883f9c76d8e00e3e2c0ffe4b6a8b55fa95" translate="yes" xml:space="preserve">
          <source>With these features it becomes possible to strongly type a number of higher-order functions that transform functions and their parameter lists.</source>
          <target state="translated">これらの機能により、関数とそのパラメータリストを変換する多数の高次関数を強力にタイプすることが可能になります。</target>
        </trans-unit>
        <trans-unit id="57d2f941d62c110711648e01f573d26e835149f4" translate="yes" xml:space="preserve">
          <source>With this TypeScript code:</source>
          <target state="translated">このTypeScriptのコードで</target>
        </trans-unit>
        <trans-unit id="433e4f23f467e7ae0dc8cfdd04d371137cd886c1" translate="yes" xml:space="preserve">
          <source>With this change, the overloads now give us type checked calls to the &lt;code&gt;pickCard&lt;/code&gt; function.</source>
          <target state="translated">この変更により、オーバーロードは、 &lt;code&gt;pickCard&lt;/code&gt; 関数の型チェック済み呼び出しを提供します。</target>
        </trans-unit>
        <trans-unit id="78f2f313b67611945a513d63a8211e0d1592c710" translate="yes" xml:space="preserve">
          <source>With this enabled, references to modules and packages (e.g. &lt;code&gt;import&lt;/code&gt;s and &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to.</source>
          <target state="translated">これにより（例えば、モジュールやパッケージへの参照を有効に &lt;code&gt;import&lt;/code&gt; sおよび &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; ディレクティブ）は、すべてのパスとシンボリックリンクファイルの場所からの相対ではなく、相対的に解決されていますシンボリックリンクはに解決されます。</target>
        </trans-unit>
        <trans-unit id="50288405a714a4c057a990453fc548fab19c0a86" translate="yes" xml:space="preserve">
          <source>With union types able to represent a wide range of type scenarios, we&amp;rsquo;ve decided to improve the strictness of certain generic calls. Previously, code like this would (surprisingly) compile without error:</source>
          <target state="translated">ユニオンタイプはさまざまなタイプのシナリオを表すことができるため、特定のジェネリックコールの厳密性を向上させることにしました。以前は、このようなコードは（驚くべきことに）エラーなしでコンパイルされていました。</target>
        </trans-unit>
        <trans-unit id="4aaf334cc02fe3036ee03973d99bc9627c8d8c34" translate="yes" xml:space="preserve">
          <source>With union types, you can now specify the desired behavior at both the function declaration site and the call site:</source>
          <target state="translated">ユニオン型を使用すると、関数の宣言サイトと呼び出しサイトの両方で必要な動作を指定できるようになりました。</target>
        </trans-unit>
        <trans-unit id="cfa2a879186e45980c1b4dd8c08f6c7e24cfb812" translate="yes" xml:space="preserve">
          <source>With:</source>
          <target state="translated">With:</target>
        </trans-unit>
        <trans-unit id="1faa6ed78c77561690bfff2329835e7f699fad40" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;Control&lt;/code&gt; class it is possible to access the &lt;code&gt;state&lt;/code&gt; private member through an instance of &lt;code&gt;SelectableControl&lt;/code&gt;. Effectively, a &lt;code&gt;SelectableControl&lt;/code&gt; acts like a &lt;code&gt;Control&lt;/code&gt; that is known to have a &lt;code&gt;select&lt;/code&gt; method. The &lt;code&gt;Button&lt;/code&gt; and &lt;code&gt;TextBox&lt;/code&gt; classes are subtypes of &lt;code&gt;SelectableControl&lt;/code&gt; (because they both inherit from &lt;code&gt;Control&lt;/code&gt; and have a &lt;code&gt;select&lt;/code&gt; method), but the &lt;code&gt;Image&lt;/code&gt; and &lt;code&gt;Location&lt;/code&gt; classes are not.</source>
          <target state="translated">&lt;code&gt;Control&lt;/code&gt; クラス内では、 &lt;code&gt;SelectableControl&lt;/code&gt; のインスタンスを介して &lt;code&gt;state&lt;/code&gt; プライベートメンバーにアクセスできます。事実上、 &lt;code&gt;SelectableControl&lt;/code&gt; は、 &lt;code&gt;select&lt;/code&gt; メソッドを持つことが知られている &lt;code&gt;Control&lt;/code&gt; ように機能します。 &lt;code&gt;Button&lt;/code&gt; や &lt;code&gt;TextBox&lt;/code&gt; のクラスはのサブタイプです &lt;code&gt;SelectableControl&lt;/code&gt; （彼らはから継承両方のため &lt;code&gt;Control&lt;/code&gt; と持って &lt;code&gt;select&lt;/code&gt; 方法を）が、 &lt;code&gt;Image&lt;/code&gt; や &lt;code&gt;Location&lt;/code&gt; のクラスはありません。</target>
        </trans-unit>
        <trans-unit id="40659a03fa7e7592baf48c7a0c5720e665372319" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;Control&lt;/code&gt; class it is possible to access the &lt;code&gt;state&lt;/code&gt; private member through an instance of &lt;code&gt;SelectableControl&lt;/code&gt;. Effectively, a &lt;code&gt;SelectableControl&lt;/code&gt; acts like a &lt;code&gt;Control&lt;/code&gt; that is known to have a &lt;code&gt;select&lt;/code&gt; method. The &lt;code&gt;Button&lt;/code&gt; and &lt;code&gt;TextBox&lt;/code&gt; classes are subtypes of &lt;code&gt;SelectableControl&lt;/code&gt; (because they both inherit from &lt;code&gt;Control&lt;/code&gt; and have a &lt;code&gt;select&lt;/code&gt; method). The &lt;code&gt;ImageControl&lt;/code&gt; class has it&amp;rsquo;s own &lt;code&gt;state&lt;/code&gt; private member rather than extending &lt;code&gt;Control&lt;/code&gt;, so it cannot implement &lt;code&gt;SelectableControl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Control&lt;/code&gt; クラス内では、 &lt;code&gt;SelectableControl&lt;/code&gt; のインスタンスを介して &lt;code&gt;state&lt;/code&gt; プライベートメンバーにアクセスできます。事実上、 &lt;code&gt;SelectableControl&lt;/code&gt; は、 &lt;code&gt;select&lt;/code&gt; メソッドを持つことがわかっている &lt;code&gt;Control&lt;/code&gt; ように機能します。 &lt;code&gt;Button&lt;/code&gt; や &lt;code&gt;TextBox&lt;/code&gt; のクラスはのサブタイプです &lt;code&gt;SelectableControl&lt;/code&gt; （なぜなら、彼らはから継承両方の &lt;code&gt;Control&lt;/code&gt; と持って &lt;code&gt;select&lt;/code&gt; 方法を）。 &lt;code&gt;ImageControl&lt;/code&gt; のクラスは、それ自身の持っている &lt;code&gt;state&lt;/code&gt; のプライベートメンバーではなく、拡張 &lt;code&gt;Control&lt;/code&gt; 、それが実現することはできませんので、 &lt;code&gt;SelectableControl&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="11991f5f3539f8365b2755a33096a790d376c466" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;extends&lt;/code&gt; clause of a conditional type, it is now possible to have &lt;code&gt;infer&lt;/code&gt; declarations that introduce a type variable to be inferred. Such inferred type variables may be referenced in the true branch of the conditional type. It is possible to have multiple &lt;code&gt;infer&lt;/code&gt; locations for the same type variable.</source>
          <target state="translated">条件型の &lt;code&gt;extends&lt;/code&gt; 句内で、 &lt;code&gt;infer&lt;/code&gt; される型変数を導入する推論宣言を持つことが可能になりました。そのような推定された型変数は、条件付き型の真の分岐で参照される場合があります。同じ型変数に対して複数の &lt;code&gt;infer&lt;/code&gt; 場所を設定することができます。</target>
        </trans-unit>
        <trans-unit id="025d407dde53ca8d56d3a7b67f8687df35d8b119" translate="yes" xml:space="preserve">
          <source>Within the same block duplicate definitions are still disallowed.</source>
          <target state="translated">同一のブロック内では、重複した定義はまだ許可されていません。</target>
        </trans-unit>
        <trans-unit id="9735c33d4a9302da353c7b0e0f8ad6d2bbb66115" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;downlevelIteration&lt;/code&gt; enabled, a &lt;code&gt;for / of&lt;/code&gt; loop on any object is downleveled to a traditional &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">なければ &lt;code&gt;downlevelIteration&lt;/code&gt; 、有効な &lt;code&gt;for / of&lt;/code&gt; 任意のオブジェクト上のループは伝統的にdownleveledれる &lt;code&gt;for&lt;/code&gt; ループ：</target>
        </trans-unit>
        <trans-unit id="244687c671b9bf5c3bf00c75ac23daf9254dabd2" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;this&lt;/code&gt; types, &lt;code&gt;ScientificCalculator&lt;/code&gt; would not have been able to extend &lt;code&gt;BasicCalculator&lt;/code&gt; and keep the fluent interface. &lt;code&gt;multiply&lt;/code&gt; would have returned &lt;code&gt;BasicCalculator&lt;/code&gt;, which doesn&amp;rsquo;t have the &lt;code&gt;sin&lt;/code&gt; method. However, with &lt;code&gt;this&lt;/code&gt; types, &lt;code&gt;multiply&lt;/code&gt; returns &lt;code&gt;this&lt;/code&gt;, which is &lt;code&gt;ScientificCalculator&lt;/code&gt; here.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; タイプがなければ、 &lt;code&gt;ScientificCalculator&lt;/code&gt; は &lt;code&gt;BasicCalculator&lt;/code&gt; を拡張して流暢なインターフェイスを維持できなかったでしょう。 &lt;code&gt;multiply&lt;/code&gt; は &lt;code&gt;BasicCalculator&lt;/code&gt; を返しますが、これには &lt;code&gt;sin&lt;/code&gt; メソッドがありません。ただし、 &lt;code&gt;this&lt;/code&gt; タイプの場合、 &lt;code&gt;multiply&lt;/code&gt; は &lt;code&gt;this&lt;/code&gt; を返します。これは &lt;code&gt;ScientificCalculator&lt;/code&gt; ここではScientificCalculatorです。</target>
        </trans-unit>
        <trans-unit id="4e062851d9b41c2fc52e761a5a5db277213a8a79" translate="yes" xml:space="preserve">
          <source>Without generics, we would either have to give the identity function a specific type:</source>
          <target state="translated">ジェネリックがなければ、アイデンティティ関数に特定の型を与えなければなりません。</target>
        </trans-unit>
        <trans-unit id="94acabacd4951abae06ed7d329ea42ae0a58c740" translate="yes" xml:space="preserve">
          <source>Without knowledge of the values of these members, other transpilers can&amp;rsquo;t replace the references to &lt;code&gt;Number&lt;/code&gt;, which would be a runtime error if left alone (since there are no &lt;code&gt;Numbers&lt;/code&gt; object at runtime). Because of this, when &lt;code&gt;isolatedModules&lt;/code&gt; is set, it is an error to reference an ambient &lt;code&gt;const enum&lt;/code&gt; member.</source>
          <target state="translated">これらのメンバーの値を知らないと、他のトランスパイラーは &lt;code&gt;Number&lt;/code&gt; への参照を置き換えることができません。これは、そのままにしておくと実行時エラーになります（実行時に &lt;code&gt;Numbers&lt;/code&gt; オブジェクトがないため）。このため、 &lt;code&gt;isolatedModules&lt;/code&gt; が設定されている場合、アンビエント &lt;code&gt;const enum&lt;/code&gt; メンバーを参照するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="00201f849d1c48c82416c11f802e9a66c3600782" translate="yes" xml:space="preserve">
          <source>Without setting &lt;code&gt;removeComments&lt;/code&gt; or having it as &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;removeComments&lt;/code&gt; を設定したり、 &lt;code&gt;false&lt;/code&gt; として設定したりしないでください：</target>
        </trans-unit>
        <trans-unit id="2f67c21f22ceab8ce26ba774a06869c3e5ea9d49" translate="yes" xml:space="preserve">
          <source>Working with Generic Type Variables</source>
          <target state="translated">汎用型変数の使用</target>
        </trans-unit>
        <trans-unit id="5dec7390553f0c8e11febdec62abeb23d870ba14" translate="yes" xml:space="preserve">
          <source>Working with Other JavaScript Libraries</source>
          <target state="translated">他の JavaScript ライブラリとの連携</target>
        </trans-unit>
        <trans-unit id="0e5c5aeb5b5c1f3bc5c5f5f8d62b7bc1a585d5dc" translate="yes" xml:space="preserve">
          <source>Works in tandem with &lt;code&gt;allowJs&lt;/code&gt;. When &lt;code&gt;checkJs&lt;/code&gt; is enabled then errors are reported in JavaScript files. This is the equivalent of including &lt;code&gt;// @ts-check&lt;/code&gt; at the top of all JavaScript files which are included in your project.</source>
          <target state="translated">&lt;code&gt;allowJs&lt;/code&gt; と連携して動作します。とき &lt;code&gt;checkJs&lt;/code&gt; が有効になって、その後のエラーはJavaScriptファイルで報告されています。これは、プロジェクトに含まれるすべてのJavaScriptファイルの先頭に &lt;code&gt;// @ts-check&lt;/code&gt; を含めるのと同じです。</target>
        </trans-unit>
        <trans-unit id="dbb174c18ecc84cb0d3bcf90788707696b007bc5" translate="yes" xml:space="preserve">
          <source>Would add &lt;code&gt;preact/jsx-runtime&lt;/code&gt; as an import for the &lt;code&gt;_jsx&lt;/code&gt; factory.</source>
          <target state="translated">&lt;code&gt;_jsx&lt;/code&gt; ファクトリのインポートとして &lt;code&gt;preact/jsx-runtime&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="584f179f141358ddf434da1f8a8d5abbc0ae519b" translate="yes" xml:space="preserve">
          <source>Would declare that &lt;code&gt;index.js&lt;/code&gt; will have a source file at &lt;code&gt;https://my-website.com/debug/source/index.ts&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;index.js&lt;/code&gt; に &lt;code&gt;https://my-website.com/debug/source/index.ts&lt;/code&gt; にソースファイルがあることを宣言します。</target>
        </trans-unit>
        <trans-unit id="6efdb26317cc1befd0965c705beeabd7a3facadd" translate="yes" xml:space="preserve">
          <source>Would declare that &lt;code&gt;index.js&lt;/code&gt; will have sourcemaps at &lt;code&gt;https://my-website.com/debug/sourcemaps/index.js.map&lt;/code&gt;.</source>
          <target state="translated">ことを宣言します &lt;code&gt;index.js&lt;/code&gt; がでsourcemapsを持っています &lt;code&gt;https://my-website.com/debug/sourcemaps/index.js.map&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6170858562fd81d218ec9a03c46f20224b39cf2" translate="yes" xml:space="preserve">
          <source>Would echo paths like:</source>
          <target state="translated">エコーパスのように</target>
        </trans-unit>
        <trans-unit id="1231a1512daa0744414ea3f58fde0c7b8ae3edc8" translate="yes" xml:space="preserve">
          <source>Would look like:</source>
          <target state="translated">そう見えるだろう。</target>
        </trans-unit>
        <trans-unit id="9c17b2d1a864a8fcd44eef5059b45f5c7e951923" translate="yes" xml:space="preserve">
          <source>Would place the d.ts for the &lt;code&gt;index.ts&lt;/code&gt; in a &lt;code&gt;types&lt;/code&gt; folder:</source>
          <target state="translated">用d.ts置きます &lt;code&gt;index.ts&lt;/code&gt; で &lt;code&gt;types&lt;/code&gt; フォルダを：</target>
        </trans-unit>
        <trans-unit id="3bb6c46801aca7729ea1a91a878ce6c995fb3d2b" translate="yes" xml:space="preserve">
          <source>Write a .d.ts declaration for a simple function, object, or class</source>
          <target state="translated">単純な関数、オブジェクト、クラスの.d.ts宣言を書く</target>
        </trans-unit>
        <trans-unit id="944e87083d9fc0d208f24e3ca6004e001d6ee8c0" translate="yes" xml:space="preserve">
          <source>Write a HTML page</source>
          <target state="translated">HTMLページを書く</target>
        </trans-unit>
        <trans-unit id="9a3206c5e21cfc9c171ea878cfc1acee74565cd8" translate="yes" xml:space="preserve">
          <source>Write a simple example</source>
          <target state="translated">簡単な例を書く</target>
        </trans-unit>
        <trans-unit id="e885a108400a007a39fa103119566542fbe5da72" translate="yes" xml:space="preserve">
          <source>Write some code</source>
          <target state="translated">コードを書く</target>
        </trans-unit>
        <trans-unit id="efab40cfd729fdef6a3321a502f603a5fd3d1efd" translate="yes" xml:space="preserve">
          <source>Write-only references now flagged as unused</source>
          <target state="translated">書き込みのみの参照が未使用としてフラグが立てられるようになりました。</target>
        </trans-unit>
        <trans-unit id="1f09dbf6607d2b3a3fef434b06897c0d44094e34" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; directive atop every generated file.</source>
          <target state="translated">&lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; 書く; 生成されたすべてのファイルの上のディレクティブ。</target>
        </trans-unit>
        <trans-unit id="caefe3ddb12a11eef5e5aa559be74af44b08a512" translate="yes" xml:space="preserve">
          <source>Writing a Configuration File</source>
          <target state="translated">設定ファイルの書き込み</target>
        </trans-unit>
        <trans-unit id="8d3bf80dd76a472762dc04013242f325f5d4630a" translate="yes" xml:space="preserve">
          <source>Writing the function type</source>
          <target state="translated">関数型の記述</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="124e1188da963d3aaab4e295c7a108fbd2a41dd4" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; see:</source>
          <target state="translated">あなた&lt;em&gt;は&lt;/em&gt;表示&lt;em&gt;されません&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="a0826b2d3de77311d09a836d3625c330fde392d4" translate="yes" xml:space="preserve">
          <source>You also need to include &lt;code&gt;esnext&lt;/code&gt; in your &lt;code&gt;--lib&lt;/code&gt; option, to get the &lt;code&gt;AsyncIterator&lt;/code&gt; declaration if you do not already have it.</source>
          <target state="translated">あなたも含める必要があり &lt;code&gt;esnext&lt;/code&gt; あなたに &lt;code&gt;--lib&lt;/code&gt; 取得するには、オプション &lt;code&gt;AsyncIterator&lt;/code&gt; のあなたはすでにそれを持っていない場合、宣言を。</target>
        </trans-unit>
        <trans-unit id="9dbfe774d94760df702cae74c61861ed61736c9f" translate="yes" xml:space="preserve">
          <source>You are not sure that TypeScript has included a file you expected, as a part of debugging the &lt;a href=&quot;#Project_Files_0&quot;&gt;file inclusion settings&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Project_Files_0&quot;&gt;ファイルインクルード設定の&lt;/a&gt;デバッグの一環として、TypeScriptに予期したファイルが含まれているかどうかがわかりません。</target>
        </trans-unit>
        <trans-unit id="9fb77374dde597ec3f89f049a8b2572ac5e594b0" translate="yes" xml:space="preserve">
          <source>You are using TypeScript to only generate &lt;code&gt;d.ts&lt;/code&gt; files for your consumers.</source>
          <target state="translated">TypeScriptを使用して、コンシューマー用の &lt;code&gt;d.ts&lt;/code&gt; ファイルのみを生成しています。</target>
        </trans-unit>
        <trans-unit id="f61cc6e69930635f4f2ec81f40d529f5f6496336" translate="yes" xml:space="preserve">
          <source>You are using a transpiler other than TypeScript to generate your JavaScript.</source>
          <target state="translated">JavaScriptを生成するためにTypeScript以外のトランスパイラを使用しています。</target>
        </trans-unit>
        <trans-unit id="62d178984134105b099386ca1a8bdc43d115ba87" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29435&quot;&gt;see more details in the pull request&lt;/a&gt;.</source>
          <target state="translated">あなたはできる&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29435&quot;&gt;プルリクエストで詳細を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4fc0ff3454e62e27b1d1616762b98ba9e340784f" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32028&quot;&gt;read up more about this change by reading up on its pull request&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32028&quot;&gt;このプルリクエストを確認することで、この変更の詳細を&lt;/a&gt;確認できます。</target>
        </trans-unit>
        <trans-unit id="8f2d37b1f71e5cef3cd269ee2fede52081b3627c" translate="yes" xml:space="preserve">
          <source>You can also add declarations to the global scope from inside a module:</source>
          <target state="translated">モジュール内部からグローバルスコープに宣言を追加することもできます。</target>
        </trans-unit>
        <trans-unit id="aa5e7508cbf31286f90d3fa92778943caff41bbb" translate="yes" xml:space="preserve">
          <source>You can also create nested namespaces in one declaration:</source>
          <target state="translated">また、1つの宣言でネストされた名前空間を作成することもできます。</target>
        </trans-unit>
        <trans-unit id="c9e0636992c973f4dd8a12b1aab83b4e3dc21c83" translate="yes" xml:space="preserve">
          <source>You can also describe methods in an interface that are implemented in the class, as we do with &lt;code&gt;setTime&lt;/code&gt; in the below example:</source>
          <target state="translated">以下の例の &lt;code&gt;setTime&lt;/code&gt; で行うように、クラスに実装されているインターフェースのメソッドを記述することもできます。</target>
        </trans-unit>
        <trans-unit id="10881a4ac29a88d1e8e385325bacc892d71cbc57" translate="yes" xml:space="preserve">
          <source>You can also destructure objects:</source>
          <target state="translated">オブジェクトを破壊することもできます。</target>
        </trans-unit>
        <trans-unit id="f263658c8957170383fc6acd098a9e253a17a6eb" translate="yes" xml:space="preserve">
          <source>You can also enable prepending the output of a dependency using the &lt;code&gt;prepend&lt;/code&gt; option in a reference:</source>
          <target state="translated">リファレンスの &lt;code&gt;prepend&lt;/code&gt; オプションを使用して、依存関係の出力の先頭に追加することもできます。</target>
        </trans-unit>
        <trans-unit id="7a3ee9c0b30719b4ec3010d9b67f41513948956a" translate="yes" xml:space="preserve">
          <source>You can also give different names to properties:</source>
          <target state="translated">また、プロパティに異なる名前を付けることもできます。</target>
        </trans-unit>
        <trans-unit id="46914e5a790630d332743102ee7c0fd4a1d3bfaa" translate="yes" xml:space="preserve">
          <source>You can also import commonjs modules &amp;mdash; modules written using node.js&amp;rsquo; module system:</source>
          <target state="translated">commonjsモジュール（node.jsのモジュールシステムを使用して記述されたモジュール）をインポートすることもできます。</target>
        </trans-unit>
        <trans-unit id="57504dce8579275ca3fec263bbff7e03026c0c14" translate="yes" xml:space="preserve">
          <source>You can also import declarations from other files using import types. This syntax is TypeScript-specific and differs from the JSDoc standard:</source>
          <target state="translated">また、インポート型を使用して他のファイルから宣言をインポートすることもできます。この構文はTypeScript固有のもので、JSDoc標準とは異なります。</target>
        </trans-unit>
        <trans-unit id="fa56c11bed0da0fe19acfcb08f266a5ef3e86db8" translate="yes" xml:space="preserve">
          <source>You can also import declarations from other files using import types. This syntax is Typescript-specific and differs from the JSDoc standard:</source>
          <target state="translated">また、インポート型を使用して他のファイルから宣言をインポートすることもできます。この構文は Typescript 固有のもので、JSDoc 標準とは異なります。</target>
        </trans-unit>
        <trans-unit id="dca8a7aa37da66a7e0661bda41e830a52a5189ae" translate="yes" xml:space="preserve">
          <source>You can also override existing properties and add new ones:</source>
          <target state="translated">既存のプロパティをオーバーライドして、新しいプロパティを追加することもできます。</target>
        </trans-unit>
        <trans-unit id="e783edc2ccbd9e24ba2f903e758def00265edb8b" translate="yes" xml:space="preserve">
          <source>You can also run into errors with &lt;code&gt;this&lt;/code&gt; in callbacks, when you pass functions to a library that will later call them. Because the library that calls your callback will call it like a normal function, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;. With some work you can use &lt;code&gt;this&lt;/code&gt; parameters to prevent errors with callbacks too. First, the library author needs to annotate the callback type with &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">後でコールバックするライブラリに関数を渡すときに、コールバックで &lt;code&gt;this&lt;/code&gt; してエラーが発生する可能性もあります。コールバックを呼び出すライブラリは通常の関数のように呼び出すため、 &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;undefined&lt;/code&gt; になります。いくつかの作業では、 &lt;code&gt;this&lt;/code&gt; パラメーターを使用して、コールバックのエラーも防ぐことができます。まず、ライブラリ作者はでコールバックタイプに注釈を付ける必要があり &lt;code&gt;this&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8bc617eb0b3c708d101d575cea082665b2e4c486" translate="yes" xml:space="preserve">
          <source>You can also specify a type constraint before the type parameter name. Only the first type parameter in a list is constrained:</source>
          <target state="translated">型パラメータ名の前に型制約を指定することもできます。リストの最初の型パラメータのみが制約を受けます。</target>
        </trans-unit>
        <trans-unit id="d00d3142af394bb2294c1c64058dcebe2e496a01" translate="yes" xml:space="preserve">
          <source>You can also specify object literal types. For example, an object with properties &amp;lsquo;a&amp;rsquo; (string) and &amp;lsquo;b&amp;rsquo; (number) uses the following syntax:</source>
          <target state="translated">オブジェクトリテラルタイプを指定することもできます。たとえば、プロパティ 'a'（文字列）と 'b'（数値）を持つオブジェクトは、次の構文を使用します。</target>
        </trans-unit>
        <trans-unit id="fe8328cdac7d502c96b86354aece870f05fd04b3" translate="yes" xml:space="preserve">
          <source>You can also spread objects:</source>
          <target state="translated">オブジェクトを広げることもできます。</target>
        </trans-unit>
        <trans-unit id="1908bbe93e9847a90199e01d70ec2bf4ba120262" translate="yes" xml:space="preserve">
          <source>You can also update your IDE to use the nightly drop. First you will need to install the package through npm. You can either install the npm package globally or to a local &lt;code&gt;node_modules&lt;/code&gt; folder.</source>
          <target state="translated">IDEを更新して、毎晩のドロップを使用することもできます。まず、npmからパッケージをインストールする必要があります。npmパッケージをグローバルにインストールすることも、ローカルの &lt;code&gt;node_modules&lt;/code&gt; フォルダーにインストールすることもできます。</target>
        </trans-unit>
        <trans-unit id="2fd769df0df5d6f0aa6315e5bbbcccdf2351c2f6" translate="yes" xml:space="preserve">
          <source>You can also use &lt;em&gt;template strings&lt;/em&gt;, which can span multiple lines and have embedded expressions. These strings are surrounded by the backtick/backquote (&lt;code&gt;`&lt;/code&gt;) character, and embedded expressions are of the form &lt;code&gt;${ expr }&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;テンプレート文字列を&lt;/em&gt;使用することもできます。&lt;em&gt;テンプレート文字列は&lt;/em&gt;、複数行にまたがることができ、式が埋め込まれています。これらの文字列は、バックティック/バッククォート（ &lt;code&gt;`&lt;/code&gt; ）文字で囲まれ、埋め込まれた式は &lt;code&gt;${ expr }&lt;/code&gt; 形式です。</target>
        </trans-unit>
        <trans-unit id="c8642a91579cb79f285b253bbe1a7a6a5ff3ec30" translate="yes" xml:space="preserve">
          <source>You can also use a const-assertion, which operates on arrays and object literals:</source>
          <target state="translated">配列やオブジェクトリテラルを操作する const アサーションを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="faf980f17e02d8f2a94115cf1b8ed0aa09a9c8f3" translate="yes" xml:space="preserve">
          <source>You can also use a union type:</source>
          <target state="translated">ユニオン型を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="f55dd36012d4dbcf4dacc5832f2294fe2f575c7c" translate="yes" xml:space="preserve">
          <source>You can assign an object literal directly to the prototype property. Individual prototype assignments still work too:</source>
          <target state="translated">オブジェクトリテラルをprototypeプロパティに直接代入することができます。個々のプロトタイプの割り当てもまだ機能します。</target>
        </trans-unit>
        <trans-unit id="8c16422cd5326d69a5eb84cd5f6aae392dfed484" translate="yes" xml:space="preserve">
          <source>You can call the function &lt;code&gt;greet&lt;/code&gt; with a string to show a greeting to the user.</source>
          <target state="translated">文字列で関数 &lt;code&gt;greet&lt;/code&gt; を呼び出して、ユーザーに挨拶を表示できます。</target>
        </trans-unit>
        <trans-unit id="1a7ff571453a3f2b2057590cf96aa4493691af9b" translate="yes" xml:space="preserve">
          <source>You can combine singleton types, union types, type guards, and type aliases to build an advanced pattern called &lt;em&gt;discriminated unions&lt;/em&gt;, also known as &lt;em&gt;tagged unions&lt;/em&gt; or &lt;em&gt;algebraic data types&lt;/em&gt;. Discriminated unions are useful in functional programming. Some languages automatically discriminate unions for you; TypeScript instead builds on JavaScript patterns as they exist today. There are three ingredients:</source>
          <target state="translated">シングルトンタイプ、ユニオンタイプ、タイプガード、タイプエイリアスを組み合わせて、&lt;em&gt;タグ付きユニオン&lt;/em&gt;または&lt;em&gt;代数的データタイプ&lt;/em&gt;とも呼ばれる、&lt;em&gt;判別ユニオン&lt;/em&gt;と呼ばれる高度なパターンを構築&lt;em&gt;できます&lt;/em&gt;。識別された共用体は関数型プログラミングに役立ちます。一部の言語は自動的に共用体を区別します。TypeScriptは、現在のJavaScriptパターンに基づいて構築されています。3つの成分があります。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d357850b01dac1eeac6457b17d7ca5319c972ef" translate="yes" xml:space="preserve">
          <source>You can construct a &lt;code&gt;Point&lt;/code&gt; by assigning an object literal. After the assignment, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; can&amp;rsquo;t be changed.</source>
          <target state="translated">オブジェクトリテラルを割り当てることにより、 &lt;code&gt;Point&lt;/code&gt; を構築できます。割り当て後は、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; を変更できません。</target>
        </trans-unit>
        <trans-unit id="4fb6b2a81bd2b7aaa5985f5e53a25640c10196cd" translate="yes" xml:space="preserve">
          <source>You can create a greeter by instantiating the &lt;code&gt;Greeter&lt;/code&gt; object, or create a customized greeter by extending from it.</source>
          <target state="translated">&lt;code&gt;Greeter&lt;/code&gt; オブジェクトをインスタンス化してグリーターを作成するか、それから拡張してカスタマイズされたグリーターを作成できます。</target>
        </trans-unit>
        <trans-unit id="75665cb8837cc0487308ee22852413c93f1fc259" translate="yes" xml:space="preserve">
          <source>You can create a variable for the remaining items in a list using the syntax &lt;code&gt;...&lt;/code&gt;:</source>
          <target state="translated">構文 &lt;code&gt;...&lt;/code&gt; を使用して、リスト内の残りの項目の変数を作成できます。</target>
        </trans-unit>
        <trans-unit id="8460f1444f4aa17633ac5c787a8314796932f6a5" translate="yes" xml:space="preserve">
          <source>You can create a variable for the remaining items in an object using the syntax &lt;code&gt;...&lt;/code&gt;:</source>
          <target state="translated">構文 &lt;code&gt;...&lt;/code&gt; を使用して、オブジェクトの残りの項目の変数を作成できます。</target>
        </trans-unit>
        <trans-unit id="671e7dc200d0c80a25936e430c7090352f3d72ae" translate="yes" xml:space="preserve">
          <source>You can declare a type parameter that is constrained by another type parameter. For example, here we&amp;rsquo;d like to get a property from an object given its name. We&amp;rsquo;d like to ensure that we&amp;rsquo;re not accidentally grabbing a property that does not exist on the &lt;code&gt;obj&lt;/code&gt;, so we&amp;rsquo;ll place a constraint between the two types:</source>
          <target state="translated">別の型パラメーターによって制約されている型パラメーターを宣言できます。たとえば、ここでは、名前が指定されたオブジェクトからプロパティを取得します。 &lt;code&gt;obj&lt;/code&gt; に存在しないプロパティを誤って取得しないようにするため、2つのタイプの間に制約を配置します。</target>
        </trans-unit>
        <trans-unit id="bb0d4186733111c3ff772adfa9929d9115f1fe52" translate="yes" xml:space="preserve">
          <source>You can declare generic functions with the &lt;code&gt;@template&lt;/code&gt; tag:</source>
          <target state="translated">&lt;code&gt;@template&lt;/code&gt; タグを使用してジェネリック関数を宣言できます。</target>
        </trans-unit>
        <trans-unit id="f192a3654a48e7ea0a0cc0a370781ac7a446e607" translate="yes" xml:space="preserve">
          <source>You can declare generic types with the &lt;code&gt;@template&lt;/code&gt; tag:</source>
          <target state="translated">&lt;code&gt;@template&lt;/code&gt; タグでジェネリック型を宣言できます。</target>
        </trans-unit>
        <trans-unit id="39c755b295968915cb7f36206ab4acb5152d4feb" translate="yes" xml:space="preserve">
          <source>You can declare your own types that use generics:</source>
          <target state="translated">ジェネリックを使用する独自の型を宣言することができます。</target>
        </trans-unit>
        <trans-unit id="125273b21991da50ace34ccf074e5c40f14c2af0" translate="yes" xml:space="preserve">
          <source>You can define a root folder where you can do absolute file resolution. E.g.</source>
          <target state="translated">ルートフォルダを定義することで、絶対的なファイル解決を行うことができます。例えば</target>
        </trans-unit>
        <trans-unit id="fdc9cd9cf610e86ca2fc0386a0460cd60dd0d41d" translate="yes" xml:space="preserve">
          <source>You can explicitly describe this object&amp;rsquo;s shape using an &lt;code&gt;interface&lt;/code&gt; declaration:</source>
          <target state="translated">&lt;code&gt;interface&lt;/code&gt; 宣言を使用して、このオブジェクトの形状を明示的に記述することができます。</target>
        </trans-unit>
        <trans-unit id="fc8f084feb2f8af2ede413a048aa5f0369d9c8d1" translate="yes" xml:space="preserve">
          <source>You can explore the source code for the &lt;a href=&quot;https://github.com/microsoft/TypeScript/blob/master/lib/lib.dom.d.ts&quot;&gt;DOM type definitions&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/microsoft/TypeScript/blob/master/lib/lib.dom.d.ts&quot;&gt;DOMタイプ定義の&lt;/a&gt;ソースコードを調べることができます</target>
        </trans-unit>
        <trans-unit id="2e46331273cd57070033fdf01cbe89968dccfda4" translate="yes" xml:space="preserve">
          <source>You can export with an export list:</source>
          <target state="translated">エクスポートリストを使ってエクスポートすることができます。</target>
        </trans-unit>
        <trans-unit id="20c976f009cdbf256d8a8056997c9ba760d321e8" translate="yes" xml:space="preserve">
          <source>You can find documentation on TypeScript projects in &lt;a href=&quot;docs/handbook/project-references&quot;&gt;the handbook&lt;/a&gt;.</source>
          <target state="translated">TypeScriptプロジェクトに関するドキュメント&lt;a href=&quot;docs/handbook/project-references&quot;&gt;はハンドブックにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="3f9a4311f9cdef796f23298f9df9ad3c9567377d" translate="yes" xml:space="preserve">
          <source>You can find more documentation on baseUrl in &lt;a href=&quot;http://requirejs.org/docs/api.html#config-baseUrl&quot;&gt;RequireJS&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/api.md#baseurl&quot;&gt;SystemJS&lt;/a&gt; documentation.</source>
          <target state="translated">baseUrlに関するその他のドキュメントは、&lt;a href=&quot;http://requirejs.org/docs/api.html#config-baseUrl&quot;&gt;RequireJS&lt;/a&gt;および&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/api.md#baseurl&quot;&gt;SystemJSの&lt;/a&gt;ドキュメントにあります。</target>
        </trans-unit>
        <trans-unit id="578813d014f5da6ccea41bacd872a0d259c87786" translate="yes" xml:space="preserve">
          <source>You can find more documentation on baseUrl in &lt;a href=&quot;http://requirejs.org/docs/api.html#config-baseUrl&quot;&gt;RequireJS&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#baseurl&quot;&gt;SystemJS&lt;/a&gt; documentation.</source>
          <target state="translated">baseUrlに関するその他のドキュメントは、&lt;a href=&quot;http://requirejs.org/docs/api.html#config-baseUrl&quot;&gt;RequireJS&lt;/a&gt;および&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#baseurl&quot;&gt;SystemJSの&lt;/a&gt;ドキュメントにあります。</target>
        </trans-unit>
        <trans-unit id="3565b07531ff1df206f19c27fc9bf382f93d1b9c" translate="yes" xml:space="preserve">
          <source>You can find out more about decorator support in TypeScript in &lt;a href=&quot;docs/handbook/decorators&quot;&gt;the handbook&lt;/a&gt;.</source>
          <target state="translated">TypeScriptのデコレータサポートの詳細については&lt;a href=&quot;docs/handbook/decorators&quot;&gt;、ハンドブックを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ba620983de41a7ef95236f421d1dc97955b1aa9" translate="yes" xml:space="preserve">
          <source>You can find the full list of supported JSDoc patterns &lt;a href=&quot;#supported-jsdoc&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">サポートされているJSDocパターンの完全なリストを&lt;a href=&quot;#supported-jsdoc&quot;&gt;以下に示します&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="34fda10118f041f159330cd7abc22afc3606cf87" translate="yes" xml:space="preserve">
          <source>You can find the full list of supported JSDoc patterns &lt;a href=&quot;jsdoc-supported-types&quot;&gt;in JSDoc Supported Types&lt;/a&gt;.</source>
          <target state="translated">サポートされているJSDocパターンの完全なリストは&lt;a href=&quot;jsdoc-supported-types&quot;&gt;、JSDocでサポートされているタイプにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="c476c80d4a52dce79024022ae48c95db9d5b6f4d" translate="yes" xml:space="preserve">
          <source>You can fully understand how to make any shape of declaration by understanding some key concepts of how TypeScript works.</source>
          <target state="translated">TypeScriptがどのように動作するのか、いくつかの重要な概念を理解することで、どのような形の宣言をするのかを十分に理解することができます。</target>
        </trans-unit>
        <trans-unit id="8f608f667f472aa22cebd5f33fb938554db51b9e" translate="yes" xml:space="preserve">
          <source>You can fully understand how to make any shape of definition by understanding some key concepts of how TypeScript works.</source>
          <target state="translated">TypeScriptがどのように動作するのか、いくつかの重要な概念を理解することで、どのようにしてどのような形の定義を作るのかを十分に理解することができます。</target>
        </trans-unit>
        <trans-unit id="ffbbf130c4a666890a749997011788aa15e53216" translate="yes" xml:space="preserve">
          <source>You can have TypeScript raise errors when this happens via the compiler flag &lt;code&gt;strictFunctionTypes&lt;/code&gt;.</source>
          <target state="translated">コンパイラフラグ &lt;code&gt;strictFunctionTypes&lt;/code&gt; を介して発生すると、TypeScriptでエラーを発生させることができます。</target>
        </trans-unit>
        <trans-unit id="e7cf81fd3fe04126a6e45600ef8b2c4d2d493009" translate="yes" xml:space="preserve">
          <source>You can install this library via npm:</source>
          <target state="translated">このライブラリは npm でインストールできます。</target>
        </trans-unit>
        <trans-unit id="6152873a2f68376c518851001d0d205cfc51fe07" translate="yes" xml:space="preserve">
          <source>You can learn how to do this in our &lt;a href=&quot;https://www.typescriptlang.org/download&quot;&gt;installation page&lt;/a&gt;.</source>
          <target state="translated">これを行う方法については、&lt;a href=&quot;https://www.typescriptlang.org/download&quot;&gt;インストールページをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="68173b0a46e94261744a5e3bad0e83f40a64e4d8" translate="yes" xml:space="preserve">
          <source>You can learn how to do this in our &lt;a href=&quot;https://www.typescriptlang.org/download&quot;&gt;installation page&lt;/a&gt;. You want to make sure these files are included in your package if you have the files in your project&amp;rsquo;s &lt;code&gt;.gitignore&lt;/code&gt;.</source>
          <target state="translated">これを行う方法については、&lt;a href=&quot;https://www.typescriptlang.org/download&quot;&gt;インストールページをご覧ください&lt;/a&gt;。プロジェクトの &lt;code&gt;.gitignore&lt;/code&gt; にファイルがある場合は、これらのファイルがパッケージに含まれていることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="947cee68bd128ad7579db636c222ec6f612e50a8" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;code&gt;tsconfig.json&lt;/code&gt; files &lt;a href=&quot;tsconfig-json&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; ファイルについて詳しくは、&lt;a href=&quot;tsconfig-json&quot;&gt;こちらをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0002bbb784dd22adfca99735cd3bee016fc7bc2f" translate="yes" xml:space="preserve">
          <source>You can learn more about configuring webpack &lt;a href=&quot;https://webpack.js.org/concepts&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://webpack.js.org/concepts&quot;&gt;ここで、&lt;/a&gt; webpackの構成の詳細を学ぶことができます。</target>
        </trans-unit>
        <trans-unit id="11a81cf552959831fd7e6995da492be14d30da53" translate="yes" xml:space="preserve">
          <source>You can learn more about how to measure and understand the output in the performance &lt;a href=&quot;https://github.com/microsoft/TypeScript/wiki/Performance&quot;&gt;section of the wiki&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/microsoft/TypeScript/wiki/Performance&quot;&gt;ウィキの&lt;/a&gt;パフォーマンスセクションで、出力を測定して理解する方法について詳しく知ることができます。</target>
        </trans-unit>
        <trans-unit id="fd112a39c804a14040d8ee141d2691324c73c733" translate="yes" xml:space="preserve">
          <source>You can learn more about the options in the &lt;a href=&quot;https://www.typescriptlang.org/reference&quot;&gt;tsconfig reference&lt;/a&gt;. An alternative to using a TSConfig file is the CLI, this is the same behavior as a CLI command.</source>
          <target state="translated">オプションの詳細については、&lt;a href=&quot;https://www.typescriptlang.org/reference&quot;&gt;tsconfigリファレンスを参照してください&lt;/a&gt;。TSConfigファイルを使用する代わりにCLIを使用します。これは、CLIコマンドと同じ動作です。</target>
        </trans-unit>
        <trans-unit id="2acea5010ea541a31bcbc5992b38da22bdf966f2" translate="yes" xml:space="preserve">
          <source>You can make properties readonly by using the &lt;code&gt;readonly&lt;/code&gt; keyword. Readonly properties must be initialized at their declaration or in the constructor.</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; キーワードを使用して、プロパティを読み取り専用にすることができます。読み取り専用プロパティは、宣言時またはコンストラクターで初期化する必要があります。</target>
        </trans-unit>
        <trans-unit id="5ac33330400d5a0e5b89b577a3c10f0de7e4e12f" translate="yes" xml:space="preserve">
          <source>You can now define an &lt;em&gt;alias&lt;/em&gt; for a type using the &lt;code&gt;type&lt;/code&gt; keyword:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; キーワードを使用して、タイプの&lt;em&gt;エイリアス&lt;/em&gt;を定義できるようになりました。</target>
        </trans-unit>
        <trans-unit id="3e434657788b8ddc40cdc0edab54832db855ade3" translate="yes" xml:space="preserve">
          <source>You can pass any of the three allowed strings, but any other string will give the error</source>
          <target state="translated">3 つの文字列のうちどれかを渡すことができますが、それ以外の文字列はエラーになります。</target>
        </trans-unit>
        <trans-unit id="d470740bd26919fb50f6301789d422e287938cf6" translate="yes" xml:space="preserve">
          <source>You can provide &lt;code&gt;tsc -b&lt;/code&gt; with multiple config file paths (e.g. &lt;code&gt;tsc -b src test&lt;/code&gt;). Just like &lt;code&gt;tsc -p&lt;/code&gt;, specifying the config file name itself is unnecessary if it&amp;rsquo;s named &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tsc -b&lt;/code&gt; には複数の設定ファイルのパスを指定できます。（例えば &lt;code&gt;tsc -b src test&lt;/code&gt; ） &lt;code&gt;tsc -p&lt;/code&gt; と同じように、&lt;code&gt;tsconfig.json&lt;/code&gt; という名前の場合は、構成ファイル名自体を指定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="e8c2c8135b90f55175c15912e8774ea2151cd6c3" translate="yes" xml:space="preserve">
          <source>You can read more about how references works in the &lt;a href=&quot;docs/handbook/project-references&quot;&gt;Project References&lt;/a&gt; section of the handbook</source>
          <target state="translated">参照がどのように機能するかについて詳しくは、ハンドブックの「&lt;a href=&quot;docs/handbook/project-references&quot;&gt;プロジェクト参照」&lt;/a&gt;セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="1f0c4b0cf188a255ee3afb8b2ea5e76910a20990" translate="yes" xml:space="preserve">
          <source>You can read more about the process in Node.js documentation on &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders&quot;&gt;loading modules from &lt;code&gt;node_modules&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders&quot;&gt; &lt;code&gt;node_modules&lt;/code&gt; &lt;/a&gt;からのモジュールのロードに関するNode.jsのドキュメントでプロセスの詳細を読むことができます。</target>
        </trans-unit>
        <trans-unit id="45ae7c33d245bc14dc13773d18d87a71cb89dde7" translate="yes" xml:space="preserve">
          <source>You can read more about the transition in &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;the 3.7 release notes&lt;/a&gt;.</source>
          <target state="translated">移行の詳細については&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;、3.7リリースノートを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="5500a793cafd40811d12bec320b636a9073b8503" translate="yes" xml:space="preserve">
          <source>You can read more about this in &lt;a href=&quot;docs/handbook/module-resolution#tracing-module-resolution&quot;&gt;the handbook&lt;/a&gt;.</source>
          <target state="translated">これについて詳しくは&lt;a href=&quot;docs/handbook/module-resolution#tracing-module-resolution&quot;&gt;、ハンドブックを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="b4dbf3245e466cb4f090abb7404f3d0e9c3f028b" translate="yes" xml:space="preserve">
          <source>You can read more about this in &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#better-directory-watching-on-linux-and-watchoptions&quot;&gt;the release notes&lt;/a&gt;.</source>
          <target state="translated">これについて詳しくは&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#better-directory-watching-on-linux-and-watchoptions&quot;&gt;、リリースノートを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="01c1237490875a34de9e3a6f34ec2e6bab8560cf" translate="yes" xml:space="preserve">
          <source>You can read more about this in Node.js documentation on &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_file_modules&quot;&gt;file modules&lt;/a&gt; and &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_folders_as_modules&quot;&gt;folder modules&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://nodejs.org/api/modules.html#modules_file_modules&quot;&gt;ファイルモジュール&lt;/a&gt;と&lt;a href=&quot;https://nodejs.org/api/modules.html#modules_folders_as_modules&quot;&gt;フォルダモジュール&lt;/a&gt;に関するNode.jsのドキュメントをご覧ください。</target>
        </trans-unit>
        <trans-unit id="ecd3a208f74e578df2b2a2fa60c227e643c4ba88" translate="yes" xml:space="preserve">
          <source>You can read the type of &lt;code&gt;loggingIdentity&lt;/code&gt; as &amp;ldquo;the generic function &lt;code&gt;loggingIdentity&lt;/code&gt; takes a type parameter &lt;code&gt;T&lt;/code&gt;, and an argument &lt;code&gt;arg&lt;/code&gt; which is an array of &lt;code&gt;T&lt;/code&gt;s, and returns an array of &lt;code&gt;T&lt;/code&gt;s.&amp;rdquo; If we passed in an array of numbers, we&amp;rsquo;d get an array of numbers back out, as &lt;code&gt;T&lt;/code&gt; would bind to &lt;code&gt;number&lt;/code&gt;. This allows us to use our generic type variable &lt;code&gt;T&lt;/code&gt; as part of the types we&amp;rsquo;re working with, rather than the whole type, giving us greater flexibility.</source>
          <target state="translated">あなたはのタイプ読むことができます &lt;code&gt;loggingIdentity&lt;/code&gt; を「汎用関数として &lt;code&gt;loggingIdentity&lt;/code&gt; は、パラメータの種類取り &lt;code&gt;T&lt;/code&gt; 、および引数の &lt;code&gt;arg&lt;/code&gt; の配列である &lt;code&gt;T&lt;/code&gt; S、およびリターンの配列 &lt;code&gt;T&lt;/code&gt; 秒。」数値の配列を渡した場合、 &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;number&lt;/code&gt; にバインドするため、数値の配列が返されます。これにより、型全体ではなく、処理する型の一部としてジェネリック型変数 &lt;code&gt;T&lt;/code&gt; を使用できるようになり、柔軟性が向上します。</target>
        </trans-unit>
        <trans-unit id="39f93a09cc5f4b2491c0b2ccab1b26b016dd256f" translate="yes" xml:space="preserve">
          <source>You can see an example DTS below:</source>
          <target state="translated">下にDTSの例があります。</target>
        </trans-unit>
        <trans-unit id="eeb82b9593a1fc045e2a68f5072eaf1a1f4d845d" translate="yes" xml:space="preserve">
          <source>You can see an example of using Webpack in our &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/react-&amp;amp;-webpack.html&quot;&gt;tutorial on React and Webpack&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/react-&amp;amp;-webpack.html&quot;&gt;ReactとWebpackのチュートリアルで&lt;/a&gt;Webpackの使用例を見ることができます。</target>
        </trans-unit>
        <trans-unit id="4219455f5a7b401b488cbe6f3cc25db24a4f9204" translate="yes" xml:space="preserve">
          <source>You can see an example of using Webpack in our &lt;a href=&quot;react-&amp;amp;-webpack&quot;&gt;tutorial on React and Webpack&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;react-&amp;amp;-webpack&quot;&gt;ReactとWebpackに関するチュートリアル&lt;/a&gt;で、Webpackの使用例を確認できます。</target>
        </trans-unit>
        <trans-unit id="522afc6f6129110c8704aded05f62e148f7fcfe8" translate="yes" xml:space="preserve">
          <source>You can see these patterns in the TypeScript repo - see &lt;code&gt;src/tsconfig_base.json&lt;/code&gt;, &lt;code&gt;src/tsconfig.json&lt;/code&gt;, and &lt;code&gt;src/tsc/tsconfig.json&lt;/code&gt; as key examples.</source>
          <target state="translated">これらのパターンは TypeScript のリポジトリで見ることができます。 &lt;code&gt;src/tsconfig_base.json&lt;/code&gt; 、 &lt;code&gt;src/tsconfig.json&lt;/code&gt; および &lt;code&gt;src/tsc/tsconfig.json&lt;/code&gt; を主な例として参照してください。</target>
        </trans-unit>
        <trans-unit id="342e97c124555c4631ae12805973e016d0bd72c0" translate="yes" xml:space="preserve">
          <source>You can skip checking some files by adding &lt;code&gt;// @ts-nocheck&lt;/code&gt; comment to them; conversely you can choose to check only a few &lt;code&gt;.js&lt;/code&gt; files by adding &lt;code&gt;// @ts-check&lt;/code&gt; comment to them without setting &lt;code&gt;--checkJs&lt;/code&gt;. You can also ignore errors on specific lines by adding &lt;code&gt;// @ts-ignore&lt;/code&gt; on the preceding line.</source>
          <target state="translated">&lt;code&gt;// @ts-nocheck&lt;/code&gt; コメントをファイルに追加することで、一部のファイルのチェックをスキップできます。逆に、 &lt;code&gt;// @ts-check&lt;/code&gt; &lt;code&gt;--checkJs&lt;/code&gt; を設定せずに// @ ts-checkコメントを追加することで、いくつかの &lt;code&gt;.js&lt;/code&gt; ファイルのみをチェックすることを選択できます。前の行に &lt;code&gt;// @ts-ignore&lt;/code&gt; を追加して、特定の行のエラーを無視することもできます。</target>
        </trans-unit>
        <trans-unit id="964c60dd8551d7582983d7537470492d6195db2c" translate="yes" xml:space="preserve">
          <source>You can skip checking some files by adding a &lt;code&gt;// @ts-nocheck&lt;/code&gt; comment to them; conversely, you can choose to check only a few &lt;code&gt;.js&lt;/code&gt; files by adding a &lt;code&gt;// @ts-check&lt;/code&gt; comment to them without setting &lt;code&gt;--checkJs&lt;/code&gt;. You can also ignore errors on specific lines by adding &lt;code&gt;// @ts-ignore&lt;/code&gt; on the preceding line. Note that if you have a &lt;code&gt;tsconfig.json&lt;/code&gt;, JS checking will respect strict flags like &lt;code&gt;noImplicitAny&lt;/code&gt;, &lt;code&gt;strictNullChecks&lt;/code&gt;, etc. However, because of the relative looseness of JS checking, combining strict flags with it may be surprising.</source>
          <target state="translated">&lt;code&gt;// @ts-nocheck&lt;/code&gt; コメントをファイルに追加することで、一部のファイルのチェックをスキップできます。逆に、 &lt;code&gt;// @ts-check&lt;/code&gt; &lt;code&gt;--checkJs&lt;/code&gt; を設定せずに// @ ts-checkコメントを追加することで、少数の &lt;code&gt;.js&lt;/code&gt; ファイルのみをチェックするように選択できます。前の行に &lt;code&gt;// @ts-ignore&lt;/code&gt; を追加して、特定の行のエラーを無視することもできます。 &lt;code&gt;tsconfig.json&lt;/code&gt; がある場合、JSチェックは &lt;code&gt;noImplicitAny&lt;/code&gt; 、 &lt;code&gt;strictNullChecks&lt;/code&gt; などの厳格なフラグを尊重することに注意してください。ただし、JSのチェックが比較的緩いため、厳格なフラグを組み合わせると、驚くかもしれません。</target>
        </trans-unit>
        <trans-unit id="a94719f47d299841e6e51ceee5706dcecbbee79d" translate="yes" xml:space="preserve">
          <source>You can specify any number of config files:</source>
          <target state="translated">コンフィグファイルはいくつでも指定できます。</target>
        </trans-unit>
        <trans-unit id="49e57a0ea093e19313c1e384f922d69417882b6c" translate="yes" xml:space="preserve">
          <source>You can specify array types using a variety of syntaxes:</source>
          <target state="translated">様々な構文を使用して配列の型を指定することができます。</target>
        </trans-unit>
        <trans-unit id="a70277082e31e5e52d3d480b2d3e85e69cad3826" translate="yes" xml:space="preserve">
          <source>You can specify function types using either TypeScript or Closure syntax:</source>
          <target state="translated">関数タイプは、TypeScriptまたはClosure構文を使用して指定することができます。</target>
        </trans-unit>
        <trans-unit id="34efcdea59af77ca626a5d378a5a510fc13373a4" translate="yes" xml:space="preserve">
          <source>You can specify function types using either Typescript or Closure syntax:</source>
          <target state="translated">関数の型は、TypescriptまたはClosure構文を使用して指定することができます。</target>
        </trans-unit>
        <trans-unit id="374bf1cc94385f96a421817886992b3a7d544791" translate="yes" xml:space="preserve">
          <source>You can specify map-like and array-like objects using string and number index signatures, using either standard JSDoc syntax or TypeScript syntax.</source>
          <target state="translated">文字列と数値インデックスのシグネチャを使用して、標準のJSDoc構文またはTypeScript構文のいずれかを使用して、マップライクなオブジェクトと配列ライクなオブジェクトを指定することができます。</target>
        </trans-unit>
        <trans-unit id="fa7d6f924eeeb484fecdc0bbd17378d7530144b6" translate="yes" xml:space="preserve">
          <source>You can specify map-like and array-like objects using string and number index signatures, using either standard JSDoc syntax or Typescript syntax.</source>
          <target state="translated">文字列と数値インデックスのシグネチャを使用して、標準のJSDoc構文またはTypescript構文のいずれかを使用して、マップライクなオブジェクトと配列ライクなオブジェクトを指定することができます。</target>
        </trans-unit>
        <trans-unit id="e5b4c27e6b170dfa095f022ece8aad3250bbb88a" translate="yes" xml:space="preserve">
          <source>You can specify the type of &lt;em&gt;children&lt;/em&gt; like any other attribute. This will override the default type from, eg the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;React typings&lt;/a&gt; if you use them.</source>
          <target state="translated">他の属性と同様に、&lt;em&gt;子&lt;/em&gt;のタイプを指定できます。これにより、たとえば&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;Reactのタイピング&lt;/a&gt;を使用する場合は、それらのデフォルトのタイプがオーバーライドされます。</target>
        </trans-unit>
        <trans-unit id="aa5974276811e58130f1843d3263db447637e938" translate="yes" xml:space="preserve">
          <source>You can specify this mode using either the &lt;code&gt;--jsx&lt;/code&gt; command line flag or the corresponding option &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#jsx&quot;&gt;&lt;code&gt;jsx&lt;/code&gt; in your tsconfig.json&lt;/a&gt; file.</source>
          <target state="translated">このモード&lt;a href=&quot;https://www.typescriptlang.org/tsconfig#jsx&quot;&gt;は、tsconfig.json&lt;/a&gt;ファイルの &lt;code&gt;--jsx&lt;/code&gt; コマンドラインフラグまたは対応するオプション &lt;code&gt;jsx&lt;/code&gt; のいずれかを使用して指定できます。</target>
        </trans-unit>
        <trans-unit id="e37fd121d8b3692df1ee3680ad29d96a4b8894ae" translate="yes" xml:space="preserve">
          <source>You can specify this mode using either the &lt;code&gt;--jsx&lt;/code&gt; command line flag or the corresponding option in your &lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.json&lt;/a&gt; file.</source>
          <target state="translated">&lt;code&gt;--jsx&lt;/code&gt; コマンドラインフラグまたは&lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.json&lt;/a&gt;ファイルの対応するオプションを使用して、このモードを指定できます。</target>
        </trans-unit>
        <trans-unit id="e710607df82b140e1dbb754cf8fc5b94b8059800" translate="yes" xml:space="preserve">
          <source>You can then declare that a JavaScript object conforms to the shape of your new &lt;code&gt;interface&lt;/code&gt; by using syntax like &lt;code&gt;: TypeName&lt;/code&gt; after a variable declaration:</source>
          <target state="translated">次に、あなたの新しいの形状にJavaScriptオブジェクトが準拠することを宣言することができる &lt;code&gt;interface&lt;/code&gt; のような構文を使用して &lt;code&gt;: TypeName&lt;/code&gt; 変数宣言の後に：</target>
        </trans-unit>
        <trans-unit id="90dfbdf6b89a09fcab1c28a3e863c8c3729853fd" translate="yes" xml:space="preserve">
          <source>You can then use TypeScript as a tool for providing editor integration, and as a source code type-checker.</source>
          <target state="translated">そして、エディタ統合を提供するツールとして、またソースコードのタイプチェックツールとして、TypeScriptを使用することができます。</target>
        </trans-unit>
        <trans-unit id="b65236d6747127a47949cb8a9fb216884384fd47" translate="yes" xml:space="preserve">
          <source>You can think of this as TypeScript &amp;ldquo;toughening up&amp;rdquo; the weak guarantees of these types to catch what would otherwise be silent bugs.</source>
          <target state="translated">TypeScriptは、これらの型の弱い保証を「強化」して、本来なら何もしないバグをキャッチするものと考えることができます。</target>
        </trans-unit>
        <trans-unit id="5097622074f85132325f78b68e79fba79fe3f621" translate="yes" xml:space="preserve">
          <source>You can think of this feature - the &lt;code&gt;??&lt;/code&gt; operator - as a way to &amp;ldquo;fall back&amp;rdquo; to a default value when dealing with &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. When we write code like</source>
          <target state="translated">この機能について考えることができます- &lt;code&gt;??&lt;/code&gt; 演算子 &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; を処理するときにデフォルト値に「フォールバック」する方法として。次のようなコードを書くとき</target>
        </trans-unit>
        <trans-unit id="be980ac4c9e799583178b2189eb7f2bb72eb8228" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#noEmitHelpers&quot;&gt;&lt;code&gt;noEmitHelpers&lt;/code&gt;&lt;/a&gt; when you provide your own implementations of these functions.</source>
          <target state="translated">これらの関数の独自の実装を提供する場合は、&lt;a href=&quot;#noEmitHelpers&quot;&gt; &lt;code&gt;noEmitHelpers&lt;/code&gt; &lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="d66e09412263a50bdba0d73f81189d39cb3e2051" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt;tslib&lt;/a&gt; via &lt;a href=&quot;#importHelpers&quot;&gt;&lt;code&gt;importHelpers&lt;/code&gt;&lt;/a&gt; to reduce the amount of inline JavaScript too:</source>
          <target state="translated">&lt;a href=&quot;#importHelpers&quot;&gt; &lt;code&gt;importHelpers&lt;/code&gt; &lt;/a&gt;を介して&lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt;tslib&lt;/a&gt;を使用して、インラインJavaScriptの量を減らすこともできます。</target>
        </trans-unit>
        <trans-unit id="5b09ddf784752f3c6f4d86dc25ca304e62284b0e" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;export as namespace&lt;/code&gt; to declare that your module will be available in the global scope in UMD contexts:</source>
          <target state="translated">&lt;code&gt;export as namespace&lt;/code&gt; 使用して、モジュールがUMDコンテキストのグローバルスコープで使用可能になることを宣言できます。</target>
        </trans-unit>
        <trans-unit id="e2b715cffb2277991c0db4c0b6b9e109955e0bcf" translate="yes" xml:space="preserve">
          <source>You can use a type alias to make a shorthand for a type:</source>
          <target state="translated">型のエイリアスを使って、型の短縮形を作ることができます。</target>
        </trans-unit>
        <trans-unit id="f059cdce98ff966444670c2070525a863818425c" translate="yes" xml:space="preserve">
          <source>You can use a wide variety of design patterns in JavaScript. However, some design patterns make it difficult for types to be inferred automatically (for example, patterns that use dynamic programming). To cover these cases, TypeScript supports an extension of the JavaScript language, which offers places for you to tell TypeScript what the types should be.</source>
          <target state="translated">JavaScriptでは様々なデザインパターンを使うことができます。しかし、いくつかのデザインパターンでは型を自動的に推測することが難しくなっています (例えば、動的プログラミングを使用するパターンなど)。このようなケースをカバーするために、TypeScript は JavaScript 言語の拡張機能をサポートしています。</target>
        </trans-unit>
        <trans-unit id="391c1498a82ae1b3dc563cb57e6b7cbe9562f400" translate="yes" xml:space="preserve">
          <source>You can use either &lt;code&gt;object&lt;/code&gt; or &lt;code&gt;Object&lt;/code&gt; on the first line.</source>
          <target state="translated">最初の行では &lt;code&gt;object&lt;/code&gt; または &lt;code&gt;Object&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="73ad51c87d1ff2edbd6bedd2ce2c75e2f55b6846" translate="yes" xml:space="preserve">
          <source>You can use interfaces to annotate parameters and return values to functions:</source>
          <target state="translated">インターフェースを使ってパラメータにアノテーションを付けたり、関数に値を返したりすることができます。</target>
        </trans-unit>
        <trans-unit id="446759c7e9287dd9b2744b78bd72e945161fa89b" translate="yes" xml:space="preserve">
          <source>You can use the &amp;ldquo;@type&amp;rdquo; tag and reference a type name (either primitive, defined in a TypeScript declaration, or in a JSDoc &amp;ldquo;@typedef&amp;rdquo; tag). You can use any Typescript type, and most JSDoc types.</source>
          <target state="translated">&amp;ldquo; @type&amp;rdquo;タグを使用してタイプ名を参照できます（TypeScript宣言で定義されたプリミティブ、またはJSDoc&amp;ldquo; @typedef&amp;rdquo;タグで定義）。任意のTypescriptタイプ、およびほとんどのJSDocタイプを使用できます。</target>
        </trans-unit>
        <trans-unit id="46b8562cf700f30f831c7873691acf285a8928d7" translate="yes" xml:space="preserve">
          <source>You can use the &amp;ldquo;@type&amp;rdquo; tag and reference a type name (either primitive, defined in a TypeScript declaration, or in a JSDoc &amp;ldquo;@typedef&amp;rdquo; tag). You can use most JSDoc types and any TypeScript type, from &lt;a href=&quot;basic-types&quot;&gt;the most basic like &lt;code&gt;string&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;advanced-types&quot;&gt;the most advanced, like conditional types&lt;/a&gt;.</source>
          <target state="translated">「@type」タグを使用して、型名を参照できます（プリミティブ、TypeScript宣言で定義されているか、JSDocの「@typedef」タグで定義されています）。あなたはから、ほとんどのJSDocのタイプと任意の活字体のタイプを使用することができる&lt;a href=&quot;basic-types&quot;&gt;ような最も基本的な &lt;code&gt;string&lt;/code&gt; &lt;/a&gt;に&lt;a href=&quot;advanced-types&quot;&gt;条件付きのタイプと同様に、最も先進的な&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce6198a75a95e389a7a03972f1adcbada6802fc1" translate="yes" xml:space="preserve">
          <source>You can use this flag to discover where TypeScript is spending it&amp;rsquo;s time when compiling. This is a tool used for understanding the performance characteristics of your codebase overall.</source>
          <target state="translated">このフラグを使用して、TypeScriptがコンパイル時に時間を費やしている場所を見つけることができます。これは、コードベース全体のパフォーマンス特性を理解するために使用されるツールです。</target>
        </trans-unit>
        <trans-unit id="c6a45fbb2d4cb410ac9052a3f0018033b37e3130" translate="yes" xml:space="preserve">
          <source>You can use this pattern with other parts of the type system to get type-safe lookups.</source>
          <target state="translated">このパターンは、型システムの他の部分と組み合わせて使用することで、型安全なルックアップを得ることができます。</target>
        </trans-unit>
        <trans-unit id="ca792ffbb908ece0647bb752e2d90bf39f35c90e" translate="yes" xml:space="preserve">
          <source>You can work around this by using functions to return your classes which differ based on a generic:</source>
          <target state="translated">ジェネリックに基づいて異なるクラスを返す関数を使用することで、これを回避することができます。</target>
        </trans-unit>
        <trans-unit id="bfcf07ddca5f6840ea854ce2231a54e72513b8b2" translate="yes" xml:space="preserve">
          <source>You can work around this with a type annotation for &lt;code&gt;s&lt;/code&gt;, but that in turn prevents assignments to &lt;code&gt;s&lt;/code&gt; of variables that are not of type &lt;code&gt;&quot;left&quot; | &quot;right&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; の型注釈を使用してこれを回避できますが、これにより、 &lt;code&gt;&quot;left&quot; | &quot;right&quot;&lt;/code&gt; 型ではない変数 &lt;code&gt;s&lt;/code&gt; への割り当てが防止されます。「正しい」。</target>
        </trans-unit>
        <trans-unit id="597b5c6c408a6a967509763c765d774adc0ad149" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t declare new top-level declarations in the augmentation &amp;mdash; just patches to existing declarations.</source>
          <target state="translated">拡張で新しいトップレベルの宣言を宣言することはできません。既存の宣言にパッチを当てるだけです。</target>
        </trans-unit>
        <trans-unit id="4df1f23ca2dd7c39f8e49a4cc5f4fc6278b9486d" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t declare new top-level declarations in the augmentation &amp;ndash; just patches to existing declarations.</source>
          <target state="translated">拡張で新しい最上位の宣言を宣言することはできません。既存の宣言にパッチを当てるだけです。</target>
        </trans-unit>
        <trans-unit id="81a1eeecad5bacc57bd430d953c632133311eb85" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t set &lt;code&gt;myArray[2]&lt;/code&gt; because the index signature is &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target state="translated">インデックスの署名は &lt;code&gt;readonly&lt;/code&gt; ため、 &lt;code&gt;myArray[2]&lt;/code&gt; 設定することはできません。</target>
        </trans-unit>
        <trans-unit id="61e3055df49675bbb87854f15fad0bf01e0d93c4" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t set &lt;code&gt;myArray[2]&lt;/code&gt; because the index signature is readonly.</source>
          <target state="translated">インデックスシグネチャは読み取り専用であるため、 &lt;code&gt;myArray[2]&lt;/code&gt; 設定できません。</target>
        </trans-unit>
        <trans-unit id="767af037748d5f5e35da8733c684e29d4e2efa46" translate="yes" xml:space="preserve">
          <source>You cannot use decorators to provide mixins via code flow analysis:</source>
          <target state="translated">デコレータを使用してコードフロー解析を介してmixinsを提供することはできません。</target>
        </trans-unit>
        <trans-unit id="c7e14e65723450d9d571a4aeb121d26c5a7c7c1f" translate="yes" xml:space="preserve">
          <source>You could also define the type of &lt;code&gt;options&lt;/code&gt; and add a type assertion on the object literal.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; のタイプを定義し、オブジェクトリテラルにタイプアサーションを追加することもできます。</target>
        </trans-unit>
        <trans-unit id="10223649f26ed1ba254c71d5968c360f3987e66e" translate="yes" xml:space="preserve">
          <source>You could argue that this program is correctly typed, since the &lt;code&gt;width&lt;/code&gt; properties are compatible, there&amp;rsquo;s no &lt;code&gt;color&lt;/code&gt; property present, and the extra &lt;code&gt;colour&lt;/code&gt; property is insignificant.</source>
          <target state="translated">&lt;code&gt;width&lt;/code&gt; プロパティは互換性があり、 &lt;code&gt;color&lt;/code&gt; プロパティは存在せず、余分な &lt;code&gt;colour&lt;/code&gt; プロパティは重要ではないため、このプログラムは正しく入力されていると主張できます。</target>
        </trans-unit>
        <trans-unit id="453e1d8a491394744db85218dccb0ae80c5b3442" translate="yes" xml:space="preserve">
          <source>You could use multiple tsconfig files to solve &lt;em&gt;some&lt;/em&gt; of those problems, but new ones would appear:</source>
          <target state="translated">複数のtsconfigファイルを使用してこれらの問題の&lt;em&gt;一部&lt;/em&gt;を解決できますが、新しいファイルが表示されます。</target>
        </trans-unit>
        <trans-unit id="3c150ba833a45169bc5e39fe665acb71dd66349e" translate="yes" xml:space="preserve">
          <source>You have polyfills or native implementations for some, but not all, of a higher level ECMAScript version</source>
          <target state="translated">より高いレベルの ECMAScript バージョンの一部(すべてではありませんが)に対してポリフィルまたはネイティブ実装を持っています。</target>
        </trans-unit>
        <trans-unit id="783ca79e34aba59fadb024fdf75ec796a34f288d" translate="yes" xml:space="preserve">
          <source>You may already be familiar with this style of type from other languages. In the next section, we&amp;rsquo;ll cover how you can create your own generic types like &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">他の言語のこのタイプのスタイルにすでに慣れているかもしれません。次のセクションでは、 &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; ような独自のジェネリック型を作成する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="0e224facb474f21f90e2b2be7d6c67fc9a0105ac" translate="yes" xml:space="preserve">
          <source>You may be wondering why we allow &amp;lsquo;discarding&amp;rsquo; parameters like in the example &lt;code&gt;y = x&lt;/code&gt;. The reason for this assignment to be allowed is that ignoring extra function parameters is actually quite common in JavaScript. For example, &lt;code&gt;Array#forEach&lt;/code&gt; provides three parameters to the callback function: the array element, its index, and the containing array. Nevertheless, it&amp;rsquo;s very useful to provide a callback that only uses the first parameter:</source>
          <target state="translated">例 &lt;code&gt;y = x&lt;/code&gt; ように「破棄」パラメーターを許可する理由を不思議に思うかもしれません。この割り当てが許可される理由は、JavaScriptでは余分な関数パラメーターを無視することが実際に非常に一般的であるためです。たとえば、 &lt;code&gt;Array#forEach&lt;/code&gt; は、コールバック関数に3つのパラメーターを提供します：配列要素、そのインデックス、および包含配列です。それでも、最初のパラメーターのみを使用するコールバックを提供すると非常に便利です。</target>
        </trans-unit>
        <trans-unit id="52a0e16871788839263e691e58ca61bc61635cd5" translate="yes" xml:space="preserve">
          <source>You may have noticed that so far, we&amp;rsquo;ve been using the &lt;code&gt;let&lt;/code&gt; keyword instead of JavaScript&amp;rsquo;s &lt;code&gt;var&lt;/code&gt; keyword which you might be more familiar with. The &lt;code&gt;let&lt;/code&gt; keyword is actually a newer JavaScript construct that TypeScript makes available. You can read in the Handbook Reference on &lt;a href=&quot;variable-declarations&quot;&gt;Variable Declarations&lt;/a&gt; more about how &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; fix a lot of the problems with &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">これまでのところ、JavaScriptの &lt;code&gt;var&lt;/code&gt; キーワードの代わりに &lt;code&gt;let&lt;/code&gt; キーワードを使用していることに気付いたかもしれません。 &lt;code&gt;let&lt;/code&gt; キーワードは、実際に活字体が利用できるようにすることを、新しいJavaScriptの構築物です。 &lt;code&gt;let&lt;/code&gt; と &lt;code&gt;const&lt;/code&gt; が &lt;code&gt;var&lt;/code&gt; の多くの問題をどのように修正するかについては、&lt;a href=&quot;variable-declarations&quot;&gt;変数宣言&lt;/a&gt;に関するハンドブックリファレンスを参照してください。</target>
        </trans-unit>
        <trans-unit id="0160fde4a217a4e964a5d1723b8afe990d3ed06e" translate="yes" xml:space="preserve">
          <source>You may have written JavaScript in Visual Studio Code, and had editor auto-completion. Visual Studio Code uses TypeScript under the hood to make it easier to work with JavaScript.</source>
          <target state="translated">Visual Studio CodeでJavaScriptを書いていて、エディタの自動補完があったことがあるかもしれません。Visual Studio Codeでは、JavaScriptでの作業をより簡単にするために、フードの下にTypeScriptを使用しています。</target>
        </trans-unit>
        <trans-unit id="6203b314b9679b4e6a450edc94780928a6921225" translate="yes" xml:space="preserve">
          <source>You may need to restart VS for the red squiggly lines below &lt;code&gt;UseDefaultFiles&lt;/code&gt; and &lt;code&gt;UseStaticFiles&lt;/code&gt; to disappear.</source>
          <target state="translated">&lt;code&gt;UseDefaultFiles&lt;/code&gt; および &lt;code&gt;UseStaticFiles&lt;/code&gt; の下の赤い波線が消えるように、VSを再起動する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="5d0a6344f0b1a26e856b642628201bf4d2566c8e" translate="yes" xml:space="preserve">
          <source>You may still mark a member &lt;code&gt;public&lt;/code&gt; explicitly. We could have written the &lt;code&gt;Animal&lt;/code&gt; class from the previous section in the following way:</source>
          <target state="translated">メンバーを明示的に &lt;code&gt;public&lt;/code&gt; することもできます。前のセクションの &lt;code&gt;Animal&lt;/code&gt; クラスを次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="7ef83e7afe42eda500cffed4a0d1116b24bc397f" translate="yes" xml:space="preserve">
          <source>You may use the type guard &lt;code&gt;isFish&lt;/code&gt; to filter an array of &lt;code&gt;Fish | Bird&lt;/code&gt; and obtain an array of &lt;code&gt;Fish&lt;/code&gt;:</source>
          <target state="translated">タイプガード &lt;code&gt;isFish&lt;/code&gt; を使用して、 &lt;code&gt;Fish | Bird&lt;/code&gt; 配列をフィルタリングできます。鳥と &lt;code&gt;Fish&lt;/code&gt; 配列を取得します。</target>
        </trans-unit>
        <trans-unit id="cb996842f792b4271e727f1a43257b60e8cebb4e" translate="yes" xml:space="preserve">
          <source>You may want to change these for a few reasons:</source>
          <target state="translated">いくつかの理由でこれらを変更した方がいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="cf04c61ef2202484a43e999d7405474bf9abd112" translate="yes" xml:space="preserve">
          <source>You may want to provide a type for JavaScript code which does not exist</source>
          <target state="translated">存在しない JavaScript コードのために型を提供したい場合があります。</target>
        </trans-unit>
        <trans-unit id="ddc16c019974ce3ac91057cddfe1e72a32d707b7" translate="yes" xml:space="preserve">
          <source>You may&amp;rsquo;ve noticed that so far, we&amp;rsquo;ve been using the &lt;code&gt;let&lt;/code&gt; keyword instead of JavaScript&amp;rsquo;s &lt;code&gt;var&lt;/code&gt; keyword which you might be more familiar with. The &lt;code&gt;let&lt;/code&gt; keyword was introduced to JavaScript in ES2015 and is now considered the standard because it&amp;rsquo;s safer than &lt;code&gt;var&lt;/code&gt;. We&amp;rsquo;ll discuss the details later, but many common problems in JavaScript are alleviated by using &lt;code&gt;let&lt;/code&gt;, so you should use it instead of &lt;code&gt;var&lt;/code&gt; whenever possible.</source>
          <target state="translated">お気づきかもしれませんが、これまで、JavaScriptの &lt;code&gt;var&lt;/code&gt; キーワードの代わりに &lt;code&gt;let&lt;/code&gt; キーワードを使用してきました。 &lt;code&gt;let&lt;/code&gt; キーワードは、ES2015にJavaScriptに導入され、それがより安全だから、今の標準と考えられている &lt;code&gt;var&lt;/code&gt; 。詳細は後で説明しますが、JavaScriptの多くの一般的な問題は &lt;code&gt;let&lt;/code&gt; を使用することで軽減されるため、可能な場合は常に &lt;code&gt;var&lt;/code&gt; ではなくそれを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="c6ca7fd5f06b5916404ff0286e5a8b87e56d87ec" translate="yes" xml:space="preserve">
          <source>You might also be running some intermediate steps on your JavaScript, such as bundling or using another transpiler like Babel. In this case, you might already have a folder structure like this set up.</source>
          <target state="translated">また、バンドルや Babel のような別のトランスパイラを使用するなど、JavaScript の中間的なステップを実行しているかもしれません。この場合、すでにこのようなフォルダ構造が設定されているかもしれません。</target>
        </trans-unit>
        <trans-unit id="77d12568f27dbc483de4e3aa9461fb0fdafcd3b7" translate="yes" xml:space="preserve">
          <source>You might be tempted to use &lt;code&gt;Object&lt;/code&gt; or &lt;code&gt;{}&lt;/code&gt; to say that a value can have any property on it because &lt;code&gt;Object&lt;/code&gt; is, for most purposes, the most general type. However &lt;strong&gt;&lt;code&gt;any&lt;/code&gt; is actually the type you want to use&lt;/strong&gt; in those situations, since it&amp;rsquo;s the most &lt;em&gt;flexible&lt;/em&gt; type.</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; はほとんどの目的で最も一般的なタイプであるため、値に任意のプロパティを設定できると言うために &lt;code&gt;Object&lt;/code&gt; または &lt;code&gt;{}&lt;/code&gt; を使用したくなるかもしれません。しかし、&lt;strong&gt; &lt;code&gt;any&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;実際に使用したいタイプである&lt;/strong&gt;ことがほとんどなので、それらの状況に&lt;em&gt;柔軟&lt;/em&gt;タイプ。&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="902577569221e3d57d91dd10a280916026992b82" translate="yes" xml:space="preserve">
          <source>You might be wondering about that &lt;code&gt;externals&lt;/code&gt; field. We want to avoid bundling all of React into the same file, since this increases compilation time and browsers will typically be able to cache a library if it doesn&amp;rsquo;t change.</source>
          <target state="translated">その &lt;code&gt;externals&lt;/code&gt; フィールドについて疑問に思うかもしれません。Reactのすべてを同じファイルにバンドルすることは避けたいです。これにより、コンパイル時間が長くなり、ブラウザーは通常、ライブラリが変更されない場合にライブラリをキャッシュできるようになるためです。</target>
        </trans-unit>
        <trans-unit id="3787c905bb80e813db582cc0b39b9469c3749297" translate="yes" xml:space="preserve">
          <source>You might find yourself using &lt;code&gt;?.&lt;/code&gt; to replace a lot of code that performs repetitive nullish checks using the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;?.&lt;/code&gt; を使用している可能性があります。 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 演算子を使用してヌルチェックを繰り返し実行する多くのコードを置き換える。</target>
        </trans-unit>
        <trans-unit id="453b06c204a19fa2060d497fe42b9d6b893f9b0c" translate="yes" xml:space="preserve">
          <source>You might have previously written that like so:</source>
          <target state="translated">以前にもそのように書いていたかもしれません。</target>
        </trans-unit>
        <trans-unit id="79ec33e56a8b7eaeb4d65dc92383b5f0d769696d" translate="yes" xml:space="preserve">
          <source>You might have some more build steps in your pipeline. Perhaps you concatenate something to each of your files. Each build tool is different, but we&amp;rsquo;ll do our best to cover the gist of things.</source>
          <target state="translated">パイプラインにさらにいくつかのビルドステップがある可能性があります。おそらく、各ファイルに何かを連結します。ビルドツールはそれぞれ異なりますが、私たちはすべての要点をカバーするために最善を尽くします。</target>
        </trans-unit>
        <trans-unit id="4d2749eb8b0574a3a2922dc523ce38ed21997148" translate="yes" xml:space="preserve">
          <source>You might see documentation like this:</source>
          <target state="translated">こんな感じのドキュメントが出てくるかもしれません。</target>
        </trans-unit>
        <trans-unit id="9ebbdb79f43467b01f07e5bf9e813b83bf4b06f2" translate="yes" xml:space="preserve">
          <source>You might start out getting a bunch of errors like &lt;code&gt;Cannot find name 'require'.&lt;/code&gt;, and &lt;code&gt;Cannot find name 'define'.&lt;/code&gt;. In these cases, it&amp;rsquo;s likely that you&amp;rsquo;re using modules. While you can just convince TypeScript that these exist by writing out</source>
          <target state="translated">&lt;code&gt;Cannot find name 'require'.&lt;/code&gt; ような一連のエラーが発生する場合があります。、および &lt;code&gt;Cannot find name 'define'.&lt;/code&gt; 。これらの場合、モジュールを使用している可能性があります。TypeScriptにこれらを存在させることは、</target>
        </trans-unit>
        <trans-unit id="a98f3b8ccf34fbf5eb87c6d57b621277a9a767e5" translate="yes" xml:space="preserve">
          <source>You no longer need to either explicitly declare &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; or &lt;code&gt;extend React.Props&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; と &lt;code&gt;key&lt;/code&gt; 明示的に宣言したり &lt;code&gt;extend React.Props&lt;/code&gt; たりする必要がなくなりました。</target>
        </trans-unit>
        <trans-unit id="dc9e6801f613004f3ef228abfb6dc5acf9a7df7a" translate="yes" xml:space="preserve">
          <source>You should expect each chapter or page to provide you with a strong understanding of the given concepts. The TypeScript Handbook is not a complete language specification, but it is intended to be a comprehensive guide to all of the language&amp;rsquo;s features and behaviors.</source>
          <target state="translated">各章またはページが、与えられた概念の強力な理解を提供することを期待する必要があります。TypeScriptハンドブックは完全な言語仕様ではありませんが、言語のすべての機能と動作の包括的なガイドとなることを目的としています。</target>
        </trans-unit>
        <trans-unit id="e20ea1578d72074920168379785a4d62e2beb851" translate="yes" xml:space="preserve">
          <source>You should first read &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt; for an overview on the way they all work.</source>
          <target state="translated">それらがすべて機能する方法の概要については、最初に&lt;a href=&quot;templates/module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt;を読む必要があります。</target>
        </trans-unit>
        <trans-unit id="22090ec26c2134c8a6e2097c73237d381154a0ba" translate="yes" xml:space="preserve">
          <source>You should strongly consider turning this on if you&amp;rsquo;re using project references.</source>
          <target state="translated">プロジェクト参照を使用している場合は、これをオンにすることを強く検討する必要があります。</target>
        </trans-unit>
        <trans-unit id="273fc30ccbe12c9343d1e8b3f416cecb591b9158" translate="yes" xml:space="preserve">
          <source>You shouldn&amp;rsquo;t need this. By default, when emitting a module file to a non-ES6 target, TypeScript emits a &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; prologue at the top of the file. This setting disables the prologue.</source>
          <target state="translated">これは必要ありません。デフォルトでは、モジュールファイルをES6以外のターゲットに発行すると、TypeScriptは &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; usestrict 」を発行します。ファイルの先頭にあるプロローグ。この設定はプロローグを無効にします。</target>
        </trans-unit>
        <trans-unit id="9cb008eccba10a9a792e21493ddf4d96a2e05ffe" translate="yes" xml:space="preserve">
          <source>You want to transpile TypeScript as a part of a build chain in the terminal where the filenames are processed in the next command.</source>
          <target state="translated">次のコマンドでファイル名が処理されるターミナルで、ビルドチェーンの一部としてTypeScriptをトランスパイルしたいとします。</target>
        </trans-unit>
        <trans-unit id="5bcfb9bf7e9a5a70d6661bc4978c8808ff85beea" translate="yes" xml:space="preserve">
          <source>You will mostly see intersection types used for mixins and other concepts that don&amp;rsquo;t fit in the classic object-oriented mold. (There are a lot of these in JavaScript!) Here&amp;rsquo;s a simple example that shows how to create a mixin:</source>
          <target state="translated">ほとんどの場合、ミックスインに使用される交差タイプや、古典的なオブジェクト指向の型には適合しないその他の概念が表示されます。（JavaScriptにはこれらの多くがあります！）以下は、ミックスインの作成方法を示す簡単な例です。</target>
        </trans-unit>
        <trans-unit id="f88663c08b841df52333cc0dae0185031e7b194f" translate="yes" xml:space="preserve">
          <source>You will not get any errors. However, if you turn on &lt;code&gt;checkJs&lt;/code&gt; then you will get error messages from the JavaScript file.</source>
          <target state="translated">エラーは発生しません。ただし、 &lt;code&gt;checkJs&lt;/code&gt; をオンにすると、JavaScriptファイルからエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="d538693b1e7a8713fd015bc6f34e84e12105e70c" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll be given a series of prompts. You can use the defaults except for your entry point. For your entry point, use &lt;code&gt;./dist/main.js&lt;/code&gt;. You can always go back and change these in the &lt;code&gt;package.json&lt;/code&gt; file that&amp;rsquo;s been generated for you.</source>
          <target state="translated">一連のプロンプトが表示されます。エントリポイント以外のデフォルトを使用できます。エントリポイントには、. &lt;code&gt;./dist/main.js&lt;/code&gt; 使用します。いつでも戻って、生成された &lt;code&gt;package.json&lt;/code&gt; ファイルでこれらを変更できます。</target>
        </trans-unit>
        <trans-unit id="639d21bc62abc7441d41597c046101c12fe57e01" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll notice that in the class when we refer to one of the members of the class we prepend &lt;code&gt;this.&lt;/code&gt;. This denotes that it&amp;rsquo;s a member access.</source>
          <target state="translated">クラスのメンバーの1つを参照すると、 &lt;code&gt;this.&lt;/code&gt; を前に付加することに気付くでしょう。。これは、メンバーアクセスであることを示します。</target>
        </trans-unit>
        <trans-unit id="96310a35cd7703a91b61529ec989ae56b9f242ba" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see examples that look like this:</source>
          <target state="translated">次のような例が表示されます。</target>
        </trans-unit>
        <trans-unit id="5a5b2c7c93441f6c370caaf81abe9018ba769023" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see that there are two syntaxes for building types: &lt;a href=&quot;https://www.typescriptlang.org/play/?e=83#example/types-vs-interfaces&quot;&gt;Interfaces and Types&lt;/a&gt;. You should prefer &lt;code&gt;interface&lt;/code&gt;. Use &lt;code&gt;type&lt;/code&gt; when you need specific features.</source>
          <target state="translated">タイプを構築するには、&lt;a href=&quot;https://www.typescriptlang.org/play/?e=83#example/types-vs-interfaces&quot;&gt;インターフェースとタイプの&lt;/a&gt;2つの構文があることがわかります。あなたは &lt;code&gt;interface&lt;/code&gt; を好むべきです。特定の機能が必要な場合は &lt;code&gt;type&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="82f270d2ae21cc7300335c3380e8b45bcd31b76c" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll sometimes find yourself calling a function with too many/few arguments. Typically, this is a bug, but in some cases, you might have declared a function that uses the &lt;code&gt;arguments&lt;/code&gt; object instead of writing out any parameters:</source>
          <target state="translated">引数が多すぎる、または少なすぎる関数を呼び出すことがあります。通常、これはバグですが、場合によっては、パラメーターを書き込む代わりに、 &lt;code&gt;arguments&lt;/code&gt; オブジェクトを使用する関数を宣言している可能性があります。</target>
        </trans-unit>
        <trans-unit id="20cb63d917861135d9d38ee4daf7eae6a3aead46" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll typically see modular libraries include one of these lines in their documentation:</source>
          <target state="translated">通常、モジュール式ライブラリのドキュメントには、次のいずれかの行が含まれています。</target>
        </trans-unit>
        <trans-unit id="c9d443a11ab3a7c14d4920d4c70eef21109fe48c" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:</source>
          <target state="translated">通常、グローバルスクリプトのドキュメントに、HTMLスクリプトタグでライブラリを使用する方法のガイダンスが表示されます。</target>
        </trans-unit>
        <trans-unit id="3dffae8ffc86fe15706e64a3a387cd0d95f60fa7" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll want to bring your TypeScript files together - both the code you&amp;rsquo;ll be writing as well as any necessary declaration files.</source>
          <target state="translated">TypeScriptファイルをまとめる必要があります-作成するコードと必要な宣言ファイルの両方。</target>
        </trans-unit>
        <trans-unit id="6c61d3ce52f41b7a2b4d4549b6255c2f3af699ec" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve probably already heard that TypeScript is a &amp;ldquo;flavor&amp;rdquo; or &amp;ldquo;variant&amp;rdquo; of JavaScript. The relationship between TypeScript (TS) and JavaScript (JS) is rather unique among modern programming languages, so learning more about this relationship will help you understand how TypeScript adds to JavaScript.</source>
          <target state="translated">TypeScriptはJavaScriptの「フレーバー」または「バリアント」であることをすでに聞いたことがあるでしょう。TypeScript（TS）とJavaScript（JS）の関係は、最新のプログラミング言語の中でかなり独特であるため、この関係についてさらに学ぶことは、TypeScriptがJavaScriptにどのように追加されるかを理解するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="947d14a2174247c5b66d9b89b8d5cbb14d3c55b1" translate="yes" xml:space="preserve">
          <source>Your declaration files should thus be</source>
          <target state="translated">宣言ファイルは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="3e3e5fe5867a90441e1c7a4c99511a740d6fdb06" translate="yes" xml:space="preserve">
          <source>Your program doesn&amp;rsquo;t run in a browser, so you don&amp;rsquo;t want the &lt;code&gt;&quot;dom&quot;&lt;/code&gt; type definitions</source>
          <target state="translated">プログラムはブラウザで実行されないため、 &lt;code&gt;&quot;dom&quot;&lt;/code&gt; 型の定義は必要ありません。</target>
        </trans-unit>
        <trans-unit id="5fee6aeee4c8ecf2f473cd812413ce00001a6540" translate="yes" xml:space="preserve">
          <source>Your runtime platform provides certain JavaScript API objects (maybe through polyfills), but doesn&amp;rsquo;t yet support the full syntax of a given ECMAScript version</source>
          <target state="translated">ランタイムプラットフォームは特定のJavaScriptAPIオブジェクトを（おそらくポリフィルを介して）提供しますが、特定のECMAScriptバージョンの完全な構文をまだサポートしていません</target>
        </trans-unit>
        <trans-unit id="440ddccd9fb08c957f616ff6766040aab7a385dd" translate="yes" xml:space="preserve">
          <source>ZipCodeValidator.ts</source>
          <target state="translated">ZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="d130dd019725c3415fcffb0d0068497b6ab5463c" translate="yes" xml:space="preserve">
          <source>a default import like &lt;code&gt;import moment from &quot;moment&quot;&lt;/code&gt; acts the same as &lt;code&gt;const moment = require(&quot;moment&quot;).default&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;import moment from &quot;moment&quot;&lt;/code&gt; importmomentのようなデフォルトのインポートは、 &lt;code&gt;const moment = require(&quot;moment&quot;).default&lt;/code&gt; と同じように機能します。</target>
        </trans-unit>
        <trans-unit id="3f974c701a93b4450d9860f64bfb55d3dd330753" translate="yes" xml:space="preserve">
          <source>a double-precision IEEE 754 floating point.</source>
          <target state="translated">倍精度IEEE 754浮動小数点。</target>
        </trans-unit>
        <trans-unit id="103388cf7ca274b241718ae87f010b3c451a1308" translate="yes" xml:space="preserve">
          <source>a literal enum expression (basically a string literal or a numeric literal)</source>
          <target state="translated">リテラル列挙式</target>
        </trans-unit>
        <trans-unit id="d8a7d3fe2ecf18d5a1f75697ddb3939f637d6862" translate="yes" xml:space="preserve">
          <source>a namespace import like &lt;code&gt;import * as moment from &quot;moment&quot;&lt;/code&gt; acts the same as &lt;code&gt;const moment = require(&quot;moment&quot;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;import * as moment from &quot;moment&quot;&lt;/code&gt; ような名前空間のインポートは、 &lt;code&gt;const moment = require(&quot;moment&quot;)&lt;/code&gt; 同じように機能します。</target>
        </trans-unit>
        <trans-unit id="2c353e97b94a39673f6777646c09f2fc9ba56cf1" translate="yes" xml:space="preserve">
          <source>a parenthesized constant enum expression</source>
          <target state="translated">括弧付き定数列挙式</target>
        </trans-unit>
        <trans-unit id="6f264047eeed3d46fe957e11ffb9269c2a50015e" translate="yes" xml:space="preserve">
          <source>a reference to previously defined constant enum member (which can originate from a different enum)</source>
          <target state="translated">以前に定義された定数列挙メンバへの参照 (別の列挙に由来する可能性があります)</target>
        </trans-unit>
        <trans-unit id="9fd2ce9f0c4f3c8c3e340067701294ac5d5eb8f9" translate="yes" xml:space="preserve">
          <source>a subtype of &lt;code&gt;undefined&lt;/code&gt; intended for use as a return type.</source>
          <target state="translated">戻り値の型として使用することを目的とした &lt;code&gt;undefined&lt;/code&gt; サブタイプ。</target>
        </trans-unit>
        <trans-unit id="c528b1c807d172a8f416db6731cf13e39f6f146c" translate="yes" xml:space="preserve">
          <source>a unary minus applied to any numeric literal (e.g. &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;-100&lt;/code&gt;)</source>
          <target state="translated">数値リテラルに適用される単項マイナス（例： &lt;code&gt;-1&lt;/code&gt; 、 &lt;code&gt;-100&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e0de8923dd9a86f5d289496a0c29c4b707c6eee6" translate="yes" xml:space="preserve">
          <source>a unique value usually used as a key.</source>
          <target state="translated">通常はキーとして使用される一意の値。</target>
        </trans-unit>
        <trans-unit id="bd4ccee361c095697aa4c9d3e90553c49ca21ae4" translate="yes" xml:space="preserve">
          <source>also equivalent to the unit type.</source>
          <target state="translated">もユニットタイプに相当します。</target>
        </trans-unit>
        <trans-unit id="442d3d9c923419455d4cda7f945720f15e70bc16" translate="yes" xml:space="preserve">
          <source>amdModule.js</source>
          <target state="translated">amdModule.js</target>
        </trans-unit>
        <trans-unit id="bd7d452e38c7164a50e08e9fa4635c29c0daaa0b" translate="yes" xml:space="preserve">
          <source>amdModule.ts</source>
          <target state="translated">amdModule.ts</target>
        </trans-unit>
        <trans-unit id="d28fdf8d5aa89ce199b0e06ebcd80f424c23a2d8" translate="yes" xml:space="preserve">
          <source>an expression</source>
          <target state="translated">一言</target>
        </trans-unit>
        <trans-unit id="c9d85523bbe34073152505725bb477f4e59b253d" translate="yes" xml:space="preserve">
          <source>an immutable UTF-16 string.</source>
          <target state="translated">不変のUTF-16文字列。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="2f7e39bb1317b9d8b35bfd3478e54eeafbdfcc2b" translate="yes" xml:space="preserve">
          <source>and as expected, this will print out</source>
          <target state="translated">と予想通り、これがプリントアウトされます。</target>
        </trans-unit>
        <trans-unit id="5a1d8e9654b07127c7e5e0c08c9afa232068f17f" translate="yes" xml:space="preserve">
          <source>and merge in options from the following into your &lt;code&gt;webpack.config.js&lt;/code&gt; file:</source>
          <target state="translated">次のオプションを &lt;code&gt;webpack.config.js&lt;/code&gt; ファイルにマージします。</target>
        </trans-unit>
        <trans-unit id="23fcd315817eba480bb49d04295a2aed7b06de1d" translate="yes" xml:space="preserve">
          <source>and optionally returns a property descriptor to install on the target object</source>
          <target state="translated">オプションで、ターゲットオブジェクトにインストールするプロパティ記述子を返します。</target>
        </trans-unit>
        <trans-unit id="70d4ff6caac47a36ba7af0fb07acabf9735a878b" translate="yes" xml:space="preserve">
          <source>and we can also access those same variables within other functions:</source>
          <target state="translated">で、他の関数内でも同じ変数にアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="c5fe0200d1c7a5139bd18fd22268c4ca8bf45e90" translate="yes" xml:space="preserve">
          <source>any</source>
          <target state="translated">any</target>
        </trans-unit>
        <trans-unit id="14539c18332daf6c00ef5a5fb87c44bcec15c080" translate="yes" xml:space="preserve">
          <source>any numeric literal (e.g. &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;100&lt;/code&gt;)</source>
          <target state="translated">任意の数値リテラル（例： &lt;code&gt;1&lt;/code&gt; 、 &lt;code&gt;100&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="d4fc9c2ab5d3af99646bec10e59c8eeb1d9814d0" translate="yes" xml:space="preserve">
          <source>any string literal (e.g. &lt;code&gt;&quot;foo&quot;&lt;/code&gt;, &lt;code&gt;&quot;bar&lt;/code&gt;, &lt;code&gt;&quot;baz&quot;&lt;/code&gt;)</source>
          <target state="translated">任意の文字列リテラル（例： &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;bar&lt;/code&gt; 、 &lt;code&gt;&quot;baz&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="94012cbdbf0e0cf94a72971e951224b4fef1ce18" translate="yes" xml:space="preserve">
          <source>app.ts</source>
          <target state="translated">app.ts</target>
        </trans-unit>
        <trans-unit id="19edc1210777ba4d45049c29280d9cc5e1064c25" translate="yes" xml:space="preserve">
          <source>array</source>
          <target state="translated">array</target>
        </trans-unit>
        <trans-unit id="90e0d93d8b273dfcd00bd87849d5d11bf6a1ff97" translate="yes" xml:space="preserve">
          <source>array literals become &lt;code&gt;readonly&lt;/code&gt; tuples</source>
          <target state="translated">配列リテラルは &lt;code&gt;readonly&lt;/code&gt; タプルになります</target>
        </trans-unit>
        <trans-unit id="850ad5d4afbea97738fa95acd1da7e607bd530cc" translate="yes" xml:space="preserve">
          <source>at compile time</source>
          <target state="translated">コンパイル時</target>
        </trans-unit>
        <trans-unit id="ea0880f5346592a44bf582fa485ad5c011fc5cda" translate="yes" xml:space="preserve">
          <source>at runtime</source>
          <target state="translated">実行時</target>
        </trans-unit>
        <trans-unit id="864ec6413a2ca497c9c6969ef6b7506903f57beb" translate="yes" xml:space="preserve">
          <source>awesome-typescript-loader</source>
          <target state="translated">awesome-typescript-loader</target>
        </trans-unit>
        <trans-unit id="5f9c9d32d71f1ef8b8014c350a5f8aec50c577ec" translate="yes" xml:space="preserve">
          <source>bigint</source>
          <target state="translated">bigint</target>
        </trans-unit>
        <trans-unit id="48647474b89fa8f56ed6bda0f8148a17b51b97bd" translate="yes" xml:space="preserve">
          <source>boolean</source>
          <target state="translated">boolean</target>
        </trans-unit>
        <trans-unit id="4946408acb38561a9b39f78af5d1c6064ba23a12" translate="yes" xml:space="preserve">
          <source>bundling with your npm package</source>
          <target state="translated">npm パッケージとのバンドル</target>
        </trans-unit>
        <trans-unit id="ba69ef3aa7bab274d4a266a6dcb623595c1d29fe" translate="yes" xml:space="preserve">
          <source>bundling with your npm package, or</source>
          <target state="translated">npm パッケージにバンドルするか</target>
        </trans-unit>
        <trans-unit id="231393efbaac44c960b4ab365234afea0360d138" translate="yes" xml:space="preserve">
          <source>cache module resolution</source>
          <target state="translated">キャッシュモジュール解決</target>
        </trans-unit>
        <trans-unit id="30fdfe9db20efa1fbadcfb48f8e2224b604a7625" translate="yes" xml:space="preserve">
          <source>cache settings calculated from &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; から計算されたキャッシュ設定</target>
        </trans-unit>
        <trans-unit id="fb02f65cfddd8df81baf783711476ad11f820af3" translate="yes" xml:space="preserve">
          <source>can actually be passed around to functions</source>
          <target state="translated">は実際に関数に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="1628f3e3fa5143b8a4026ed6fba31449a9455f0b" translate="yes" xml:space="preserve">
          <source>can be rewritten as the following array literal</source>
          <target state="translated">は次の配列リテラルとして書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="f3d83e025c075f2d6dbf66e81628a8d397f050ac" translate="yes" xml:space="preserve">
          <source>can finally be rewritten without helper interfaces.</source>
          <target state="translated">ようやくヘルパーインターフェイスを使わずに書き換えられるようになりました。</target>
        </trans-unit>
        <trans-unit id="3bd6f396d9282cc0e5d8f5658854945a9c9a7565" translate="yes" xml:space="preserve">
          <source>checks &amp;ldquo;main&amp;rdquo;, then index.d.ts</source>
          <target state="translated">「メイン」をチェックしてから、index.d.tsをチェックします</target>
        </trans-unit>
        <trans-unit id="e6fb06210fafc02fd7479ddbed2d042cc3a5155e" translate="yes" xml:space="preserve">
          <source>code</source>
          <target state="translated">code</target>
        </trans-unit>
        <trans-unit id="e40f6b5c83d4e391396b982f962d9261185c5bc7" translate="yes" xml:space="preserve">
          <source>const declarations</source>
          <target state="translated">定数宣言</target>
        </trans-unit>
        <trans-unit id="6d43229f086c7e1519152492bb976fdefa4cd26f" translate="yes" xml:space="preserve">
          <source>declarations.d.ts</source>
          <target state="translated">declarations.d.ts</target>
        </trans-unit>
        <trans-unit id="2c78b75bf2045753edca089f4a8b164e61897b5b" translate="yes" xml:space="preserve">
          <source>default (no value specified)</source>
          <target state="translated">デフォルト</target>
        </trans-unit>
        <trans-unit id="4dfe6906050d68d5f43e33ba17ba494351d18a0f" translate="yes" xml:space="preserve">
          <source>disableReferencedProjectLoad - &lt;code&gt;disableReferencedProjectLoad&lt;/code&gt;</source>
          <target state="translated">disableReferencedProjectLoad - &lt;code&gt;disableReferencedProjectLoad&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eaa6f0ed9db98407e1677119423605d0592c8193" translate="yes" xml:space="preserve">
          <source>doesn&amp;rsquo;t stop the division or &lt;code&gt;someComputation()&lt;/code&gt; call from occurring. It&amp;rsquo;s equivalent to</source>
          <target state="translated">除算または &lt;code&gt;someComputation()&lt;/code&gt; 呼び出しの発生を停止しません。それは同等です</target>
        </trans-unit>
        <trans-unit id="be65d27ae088a0e03fd8e1331d90b01649464cb6" translate="yes" xml:space="preserve">
          <source>dom</source>
          <target state="translated">dom</target>
        </trans-unit>
        <trans-unit id="44b226e39304e9a0605138651ed370e25b549357" translate="yes" xml:space="preserve">
          <source>dramaticWelcome.ts</source>
          <target state="translated">dramaticWelcome.ts</target>
        </trans-unit>
        <trans-unit id="e2608af6f0beabaa750585a646e365513da9f22e" translate="yes" xml:space="preserve">
          <source>dynamicPriorityPolling</source>
          <target state="translated">dynamicPriorityPolling</target>
        </trans-unit>
        <trans-unit id="959d6a167eca6ea657af75189c740aa4548ab0b3" translate="yes" xml:space="preserve">
          <source>dynamicPriorityPolling,</source>
          <target state="translated">dynamicPriorityPolling,</target>
        </trans-unit>
        <trans-unit id="aa96353082ad7b23abd85373f7bcda3b74f29b1f" translate="yes" xml:space="preserve">
          <source>eg &lt;code&gt;{ property: Type }&lt;/code&gt;</source>
          <target state="translated">例： &lt;code&gt;{ property: Type }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0c3d909b5b29bd46a7edf52931b97737d5d1ace" translate="yes" xml:space="preserve">
          <source>emits as:</source>
          <target state="translated">として放出します。</target>
        </trans-unit>
        <trans-unit id="37c5d2d3764f1aed8efd4b2dab6e40c6ae488747" translate="yes" xml:space="preserve">
          <source>equivalent to the unit type.</source>
          <target state="translated">ユニットタイプに相当します。</target>
        </trans-unit>
        <trans-unit id="11f9578d05e6f7bb58a3cdd00107e9f4e3882671" translate="yes" xml:space="preserve">
          <source>error</source>
          <target state="translated">error</target>
        </trans-unit>
        <trans-unit id="3c5fff4d0016b644ab9720bf2113d69e16ee0db5" translate="yes" xml:space="preserve">
          <source>es2015.collection</source>
          <target state="translated">es2015.collection</target>
        </trans-unit>
        <trans-unit id="77452a908deffdbe4e25c0322f6fc17a39206ee1" translate="yes" xml:space="preserve">
          <source>es2015.core</source>
          <target state="translated">es2015.core</target>
        </trans-unit>
        <trans-unit id="4860f22d1763b9179816b962767983a680787ab3" translate="yes" xml:space="preserve">
          <source>es2015.generator</source>
          <target state="translated">es2015.generator</target>
        </trans-unit>
        <trans-unit id="a55fcf72537ff6199c436b9f28cfe5f307a1cc8d" translate="yes" xml:space="preserve">
          <source>es2015.iterable</source>
          <target state="translated">es2015.iterable</target>
        </trans-unit>
        <trans-unit id="455275f9b321b188ad0398ce86c78e923eb8b72b" translate="yes" xml:space="preserve">
          <source>es2015.promise</source>
          <target state="translated">es2015.promise</target>
        </trans-unit>
        <trans-unit id="ec95b856e9e47298430b5eb6799d9d8096bc4095" translate="yes" xml:space="preserve">
          <source>es2015.proxy</source>
          <target state="translated">es2015.proxy</target>
        </trans-unit>
        <trans-unit id="e6a8c5db65e11ddb62cc5fade31b70004048dc2c" translate="yes" xml:space="preserve">
          <source>es2015.reflect</source>
          <target state="translated">es2015.reflect</target>
        </trans-unit>
        <trans-unit id="de3c65e6af009d778471d8136d3c826fe99099be" translate="yes" xml:space="preserve">
          <source>es2015.symbol</source>
          <target state="translated">es2015.symbol</target>
        </trans-unit>
        <trans-unit id="671a9cd26cd3ffb3ef770f5b5b32cdcb27809d42" translate="yes" xml:space="preserve">
          <source>es2015.symbol.wellknown</source>
          <target state="translated">es2015.symbol.wellknown</target>
        </trans-unit>
        <trans-unit id="139a6dc78bee16dab8bae5ac789d730b614b917b" translate="yes" xml:space="preserve">
          <source>es2016</source>
          <target state="translated">es2016</target>
        </trans-unit>
        <trans-unit id="cd9583a356098ba3a4b81fc650ae36d83d670a5d" translate="yes" xml:space="preserve">
          <source>es2016.array.include</source>
          <target state="translated">es2016.array.include</target>
        </trans-unit>
        <trans-unit id="911015d28bbfae967ffe9225bd0fbdb225773f33" translate="yes" xml:space="preserve">
          <source>es2017</source>
          <target state="translated">es2017</target>
        </trans-unit>
        <trans-unit id="70890fd881ddc0e6b5672ad7751679f721fb15d1" translate="yes" xml:space="preserve">
          <source>es2017.object</source>
          <target state="translated">es2017.object</target>
        </trans-unit>
        <trans-unit id="5c6dbbf6f5b69fd02229a5a287b71af3d57a3f79" translate="yes" xml:space="preserve">
          <source>es2017.sharedmemory</source>
          <target state="translated">es2017.sharedmemory</target>
        </trans-unit>
        <trans-unit id="04fd367a754d12acaf37607d62e169a42efc8e2f" translate="yes" xml:space="preserve">
          <source>es5</source>
          <target state="translated">es5</target>
        </trans-unit>
        <trans-unit id="616df35d1ecf30f8712a0292c2c5a1d0030a5cf2" translate="yes" xml:space="preserve">
          <source>es6 / es2015</source>
          <target state="translated">es6/es2015</target>
        </trans-unit>
        <trans-unit id="dfb1e3d26774a3a7d06095ec73fbb40447cd1e68" translate="yes" xml:space="preserve">
          <source>export = and import = require()</source>
          <target state="translated">export=and import=require()</target>
        </trans-unit>
        <trans-unit id="9639877bbfe3d90ce8d23fd8941c66db62463627" translate="yes" xml:space="preserve">
          <source>fallbackPolling - &lt;code&gt;fallbackPolling&lt;/code&gt;</source>
          <target state="translated">fallbackPolling - &lt;code&gt;fallbackPolling&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4c5ca2976cdf4d1995987c214fc85c32c370ff40" translate="yes" xml:space="preserve">
          <source>fixedPollingInterval,</source>
          <target state="translated">fixedPollingInterval,</target>
        </trans-unit>
        <trans-unit id="552fc8d9cfca0ff2b5ed367c413c5cc38420bb95" translate="yes" xml:space="preserve">
          <source>folders whose combined content represent the structure of the project at runtime. See &lt;a href=&quot;module-resolution#virtual-directories-with-rootdirs&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">結合されたコンテンツが実行時のプロジェクトの構造を表すフォルダ。詳細については、&lt;a href=&quot;module-resolution#virtual-directories-with-rootdirs&quot;&gt;モジュール解決のドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c6111b4c03a562ccddbf99c1de8d5cfee0039f5a" translate="yes" xml:space="preserve">
          <source>for...of statements</source>
          <target state="translated">のために</target>
        </trans-unit>
        <trans-unit id="31f79b8f38a6b1aee4464af7bf6e58995fdcc55c" translate="yes" xml:space="preserve">
          <source>for..of support</source>
          <target state="translated">支持のために</target>
        </trans-unit>
        <trans-unit id="e777919351daf00b0d9ef805e8c06560be596a16" translate="yes" xml:space="preserve">
          <source>from anywhere - even modules - using the new &lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; flag.</source>
          <target state="translated">どこからでも-モジュールでも-新しい &lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; フラグを使用します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
