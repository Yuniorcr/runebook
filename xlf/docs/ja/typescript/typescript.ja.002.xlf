<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="521f1850ff33993c5964d68a9803ec6e468bad0b" translate="yes" xml:space="preserve">
          <source>Composing Types</source>
          <target state="translated">作曲の種類</target>
        </trans-unit>
        <trans-unit id="523183c97b725cfd5eba763765cb7911d0754153" translate="yes" xml:space="preserve">
          <source>Composite - &lt;code&gt;composite&lt;/code&gt;</source>
          <target state="translated">コンポジット- &lt;code&gt;composite&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3049a2659da50c034aba15cbcd7a9e1060cf134b" translate="yes" xml:space="preserve">
          <source>Composite projects</source>
          <target state="translated">複合プロジェクト</target>
        </trans-unit>
        <trans-unit id="ca5e00120498b815c12de59fd45e93f8086a8bfc" translate="yes" xml:space="preserve">
          <source>Composition</source>
          <target state="translated">Composition</target>
        </trans-unit>
        <trans-unit id="83cafe53ded70f2997ef3800657948653907c039" translate="yes" xml:space="preserve">
          <source>Computed and constant members</source>
          <target state="translated">計算メンバと定数メンバ</target>
        </trans-unit>
        <trans-unit id="ca1724f8382a9edb4d244befe1a458fd2670cf7c" translate="yes" xml:space="preserve">
          <source>Computed from the list of input files</source>
          <target state="translated">入力ファイルのリストから計算</target>
        </trans-unit>
        <trans-unit id="38e65524c92dd7a22334161d17dd8cd47bc733c7" translate="yes" xml:space="preserve">
          <source>Computed properties</source>
          <target state="translated">計算されたプロパティ</target>
        </trans-unit>
        <trans-unit id="9428f1236d3847420fd8cb9cd0a04ad850ff601f" translate="yes" xml:space="preserve">
          <source>Concatenate &lt;code&gt;AMD&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt; modules with &lt;code&gt;--outFile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;AMD&lt;/code&gt; モジュールと &lt;code&gt;System&lt;/code&gt; モジュールを &lt;code&gt;--outFile&lt;/code&gt; で連結する</target>
        </trans-unit>
        <trans-unit id="60da387f3f2a8e412f962b386bbaf111b07be7fc" translate="yes" xml:space="preserve">
          <source>Concatenate and emit output to single file. The order of concatenation is determined by the list of files passed to the compiler on the command line along with triple-slash references and imports. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out&quot;&gt;output file order documentation&lt;/a&gt; for more details.</source>
          <target state="translated">出力を連結して単一のファイルに出力します。連結の順序は、コマンドラインでコンパイラに渡されるファイルのリストと、トリプルスラッシュの参照およびインポートによって決定されます。詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out&quot;&gt;出力ファイルの注文ドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3b5e0753cd9e20392bcaed52137c783d4a9ddd51" translate="yes" xml:space="preserve">
          <source>Concatenate and emit output to single file. The order of concatenation is determined by the list of files passed to the compiler on the command line along with triple-slash references and imports. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out-&quot;&gt;output file order documentation&lt;/a&gt; for more details.</source>
          <target state="translated">出力を連結して単一のファイルに出力します。連結の順序は、コマンドラインでコンパイラに渡されるファイルのリストと、3つのスラッシュの参照およびインポートによって決まります。詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out-&quot;&gt;出力ファイルの注文ドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="00c20ea179f46b34657af7c3ca762e28ca33f1eb" translate="yes" xml:space="preserve">
          <source>Concepts not in Haskell</source>
          <target state="translated">Haskell にはない概念</target>
        </trans-unit>
        <trans-unit id="9e542d345cbe531aa5f8452be22d9352fd6b119c" translate="yes" xml:space="preserve">
          <source>Concepts similar to Haskell</source>
          <target state="translated">Haskellに似た概念</target>
        </trans-unit>
        <trans-unit id="8d387732801bd4a6ea409c7bad5379547b3bde5c" translate="yes" xml:space="preserve">
          <source>Conceptually, you might consider the type &lt;code&gt;[number, string]&lt;/code&gt; to be equivalent to the following declaration of &lt;code&gt;NumStrTuple&lt;/code&gt;:</source>
          <target state="translated">概念的には、タイプ &lt;code&gt;[number, string]&lt;/code&gt; は次の &lt;code&gt;NumStrTuple&lt;/code&gt; の宣言と同等であると考えるかもしれません：</target>
        </trans-unit>
        <trans-unit id="cc5885783b19275de55be53a8442d9638f3760ca" translate="yes" xml:space="preserve">
          <source>Conditional Types</source>
          <target state="translated">条件付きタイプ</target>
        </trans-unit>
        <trans-unit id="18754d6645b008e9cccf73f1f4d972ff5e83d7ff" translate="yes" xml:space="preserve">
          <source>Conditional types are particularly useful when combined with mapped types:</source>
          <target state="translated">条件付き型は、マップされた型と組み合わせると特に便利です。</target>
        </trans-unit>
        <trans-unit id="a91f85c89a26e57f7343ae39715ed71a281561e2" translate="yes" xml:space="preserve">
          <source>Conditional types can be nested to form a sequence of pattern matches that are evaluated in order:</source>
          <target state="translated">条件付き型は、順番に評価されるパターンマッチのシーケンスを形成するために入れ子にすることができます。</target>
        </trans-unit>
        <trans-unit id="a8e0afa63b781a425483833f9aa183ceaf9ab905" translate="yes" xml:space="preserve">
          <source>Conditional types in which the checked type is a naked type parameter are called &lt;em&gt;distributive conditional types&lt;/em&gt;. Distributive conditional types are automatically distributed over union types during instantiation. For example, an instantiation of &lt;code&gt;T extends U ? X : Y&lt;/code&gt; with the type argument &lt;code&gt;A | B | C&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt; is resolved as &lt;code&gt;(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)&lt;/code&gt;.</source>
          <target state="translated">チェックされた型がネイキッド型パラメーターである&lt;em&gt;条件付き型&lt;/em&gt;は、&lt;em&gt;分散条件付き型&lt;/em&gt;と呼ば&lt;em&gt;れます&lt;/em&gt;。分散条件付きタイプは、インスタンス化中にユニオンタイプに自動的に分散されます。たとえば、 &lt;code&gt;T extends U ? X : Y&lt;/code&gt; インスタンス化はUを拡張しますか？X：Yと型引数 &lt;code&gt;A | B | C&lt;/code&gt; のための &lt;code&gt;T&lt;/code&gt; はとして解決される &lt;code&gt;(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0df65b2f0f0c2d6eb36f5ad9bffffc45bb73cf7" translate="yes" xml:space="preserve">
          <source>Configuration inheritance</source>
          <target state="translated">コンフィグレーションの継承</target>
        </trans-unit>
        <trans-unit id="0cf99561f068c66c86d1639cb9577f23d61bf6ef" translate="yes" xml:space="preserve">
          <source>Configuration inheritance with &lt;code&gt;extends&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; 構成の継承</target>
        </trans-unit>
        <trans-unit id="1901418fbdfe5d2c8f43a50daa474bda691aa7e5" translate="yes" xml:space="preserve">
          <source>Configuring JSX</source>
          <target state="translated">JSXの設定</target>
        </trans-unit>
        <trans-unit id="ced1a4e9ff8bc70735fabd8ba078581258e51943" translate="yes" xml:space="preserve">
          <source>Configuring Watch</source>
          <target state="translated">ウォッチの設定</target>
        </trans-unit>
        <trans-unit id="1dc951f746dfbc3c750c7470abaf09a1940d201f" translate="yes" xml:space="preserve">
          <source>Configuring Watch: Background</source>
          <target state="translated">Watchを設定する。バックグラウンド</target>
        </trans-unit>
        <trans-unit id="cfdfb6d0adf0c6f64224be19c2696050ea66bf86" translate="yes" xml:space="preserve">
          <source>Configuring directory watching using environment variable &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;</source>
          <target state="translated">環境変数を使用したディレクトリ監視の構成 &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="154dfa8a6af04f2d727ad938b2a0b29854531465" translate="yes" xml:space="preserve">
          <source>Configuring file watching using a &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; を使用したファイル監視の構成</target>
        </trans-unit>
        <trans-unit id="f22e46f20a3414bdd5ff21017ac41439569be928" translate="yes" xml:space="preserve">
          <source>Configuring file watching using environment variable &lt;code&gt;TSC_WATCHFILE&lt;/code&gt;</source>
          <target state="translated">環境変数を使用したファイル監視の構成 &lt;code&gt;TSC_WATCHFILE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17d698cd217deceb13be84ca6f6626fed1b6ab6f" translate="yes" xml:space="preserve">
          <source>Confusingly, the colon here does &lt;em&gt;not&lt;/em&gt; indicate the type. The type, if you specify it, still needs to be written after the entire destructuring:</source>
          <target state="translated">紛らわしいことに、ここのコロン&lt;em&gt;は&lt;/em&gt;はタイプを示して。タイプは、それを指定する場合でも、完全な構造化の後に書き込む必要があります。</target>
        </trans-unit>
        <trans-unit id="89f0f2bf53179367a5dd94383df864d838cb31c8" translate="yes" xml:space="preserve">
          <source>Congrats you&amp;rsquo;ve built your own .NET Core project with a TypeScript frontend.</source>
          <target state="translated">TypeScriptフロントエンドを使用して独自の.NET Coreプロジェクトを構築できました。</target>
        </trans-unit>
        <trans-unit id="9e5193ad94fca6c20c365f83052b979e6e703a9c" translate="yes" xml:space="preserve">
          <source>Congratulations on choosing TypeScript as one of your first languages &amp;mdash; you&amp;rsquo;re already making good decisions!</source>
          <target state="translated">TypeScriptを最初の言語の1つとして選択して、おめでとうございます&amp;mdash;あなたはすでに良い決断をしています！</target>
        </trans-unit>
        <trans-unit id="155316928dc20330bb4f13299267e694e6babaed" translate="yes" xml:space="preserve">
          <source>Consequences of Structural Typing</source>
          <target state="translated">構造的なタイピングの結果</target>
        </trans-unit>
        <trans-unit id="941a22f7b9c2d7277c983fd34ff491234fe4dbe8" translate="yes" xml:space="preserve">
          <source>Consider a function that creates a new &lt;code&gt;HTMLElement&lt;/code&gt;, calling it with no arguments generates a &lt;code&gt;Div&lt;/code&gt;; you can optionally pass a list of children as well. Previously you would have to define it as:</source>
          <target state="translated">新しい &lt;code&gt;HTMLElement&lt;/code&gt; を作成する関数を考えます。引数なしで呼び出すと、 &lt;code&gt;Div&lt;/code&gt; が生成されます。ます。ます。オプションで子のリストを渡すこともできます。以前は、次のように定義する必要がありました。</target>
        </trans-unit>
        <trans-unit id="9a93950d7261d2e851d7f697ab5cb3ac7485af4e" translate="yes" xml:space="preserve">
          <source>Consider a simple calculator implementation defined in module &lt;code&gt;Calculator.ts&lt;/code&gt;. The module also exports a helper function to test the calculator functionality by passing a list of input strings and writing the result at the end.</source>
          <target state="translated">モジュール &lt;code&gt;Calculator.ts&lt;/code&gt; で定義された簡単な電卓の実装を考えてみましょう。また、モジュールはヘルパー関数をエクスポートして、入力文字列のリストを渡し、最後に結果を書き込むことにより、電卓の機能をテストします。</target>
        </trans-unit>
        <trans-unit id="64b47866222baeccb4c64149b4ef01b8e0a587f3" translate="yes" xml:space="preserve">
          <source>Consider an internationalization scenario where a build tool automatically generates locale specific bundles by interpolating a special path token, say &lt;code&gt;#{locale}&lt;/code&gt;, as part of a relative module path such as &lt;code&gt;./#{locale}/messages&lt;/code&gt;. In this hypothetical setup the tool enumerates supported locales, mapping the abstracted path into &lt;code&gt;./zh/messages&lt;/code&gt;, &lt;code&gt;./de/messages&lt;/code&gt;, and so forth.</source>
          <target state="translated">ビルドツールが &lt;code&gt;./#{locale}/messages&lt;/code&gt; などの相対モジュールパスの一部として &lt;code&gt;#{locale}&lt;/code&gt; などの特別なパストークンを補間することにより、ロケール固有のバンドルを自動的に生成する国際化シナリオを考えてみましょう。この架空の設定では、ツールを列挙は、に抽象化されたパスをマッピングし、ロケールをサポート &lt;code&gt;./zh/messages&lt;/code&gt; 、 &lt;code&gt;./de/messages&lt;/code&gt; など、と。</target>
        </trans-unit>
        <trans-unit id="e51d52c45ed3cf02e41cacc5bac70bcc7582c3f8" translate="yes" xml:space="preserve">
          <source>Consider the following example in which &lt;code&gt;Animal&lt;/code&gt; is the supertype of &lt;code&gt;Dog&lt;/code&gt; and &lt;code&gt;Cat&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Animal&lt;/code&gt; が &lt;code&gt;Dog&lt;/code&gt; と &lt;code&gt;Cat&lt;/code&gt; スーパータイプである次の例を考えます。ます。</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="56d0232c998d778ef55ad35e83c8072f0d14ad7f" translate="yes" xml:space="preserve">
          <source>Const</source>
          <target state="translated">Const</target>
        </trans-unit>
        <trans-unit id="3a99b4ee5816a7cb6e3ef98324d960dc2e81d981" translate="yes" xml:space="preserve">
          <source>Const enums can only use constant enum expressions and unlike regular enums they are completely removed during compilation. Const enum members are inlined at use sites. This is possible since const enums cannot have computed members.</source>
          <target state="translated">Const enumは定数列挙式しか使用できず、通常の列挙式とは異なり、コンパイル時に完全に削除されます。const enum のメンバは使用するサイトでインライン化されます。これは const enum が計算メンバを持つことができないためです。</target>
        </trans-unit>
        <trans-unit id="fb4e962186bdd37258f8b448774e2dcc2ffcf28a" translate="yes" xml:space="preserve">
          <source>Constant-named properties</source>
          <target state="translated">定数名のプロパティ</target>
        </trans-unit>
        <trans-unit id="49d53b0e2ba12586322d0eec2518e118c2445b29" translate="yes" xml:space="preserve">
          <source>Constrained Mixins</source>
          <target state="translated">制約付きミックスイン</target>
        </trans-unit>
        <trans-unit id="52e68a873a2be3470675b9ee933b98d781ae7fef" translate="yes" xml:space="preserve">
          <source>Constraints</source>
          <target state="translated">Constraints</target>
        </trans-unit>
        <trans-unit id="d14be1865dab7ff31185f4ebfd1097f17695a8ad" translate="yes" xml:space="preserve">
          <source>Constructor functions</source>
          <target state="translated">コンストラクタ関数</target>
        </trans-unit>
        <trans-unit id="b457798406732b22f251fa45881744c1f45d717e" translate="yes" xml:space="preserve">
          <source>Constructor functions are equivalent to classes</source>
          <target state="translated">コンストラクタ関数はクラスと同等</target>
        </trans-unit>
        <trans-unit id="b78d1b6cb187422161c01ee1e5d55ae78d30cf52" translate="yes" xml:space="preserve">
          <source>ConstructorParameters&amp;lt;T&amp;gt;</source>
          <target state="translated">ConstructorParameters&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ca826ddb7dbf23aebcf75ed24ec5bc07d856c905" translate="yes" xml:space="preserve">
          <source>Constructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the type &lt;code&gt;never&lt;/code&gt; if &lt;code&gt;Type&lt;/code&gt; is not a function).</source>
          <target state="translated">コンストラクター関数型の型からタプルまたは配列型を構築します。これは、すべてのパラメータタイプ（またはタイプとタプル型生産 &lt;code&gt;never&lt;/code&gt; ならば &lt;code&gt;Type&lt;/code&gt; 関数ではありませんが）。</target>
        </trans-unit>
        <trans-unit id="9d4b322cc323263a5f94064b1dd22d65f4128610" translate="yes" xml:space="preserve">
          <source>Constructs a tuple type from the types used in the parameters of a function type &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">関数型 &lt;code&gt;Type&lt;/code&gt; のパラメーターで使用される型からタプル型を構築します。</target>
        </trans-unit>
        <trans-unit id="da51e1fa96b8ea9420b5fa91983ad6d946a019bc" translate="yes" xml:space="preserve">
          <source>Constructs a tuple type of the types of the parameters of a function type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">関数型 &lt;code&gt;T&lt;/code&gt; のパラメーターの型のタプル型を構築します。</target>
        </trans-unit>
        <trans-unit id="d79c41aef449a13b15632406dd45cb3296e79353" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; から &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; を除外して型を構築します。</target>
        </trans-unit>
        <trans-unit id="d5b40d6ba8fbb32a11e5ef0ea59f2a6613cdd70b" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; から &lt;code&gt;null&lt;/code&gt; および &lt;code&gt;undefined&lt;/code&gt; を除外して型を構築します。</target>
        </trans-unit>
        <trans-unit id="8d9a660daa90148f4ac3004bd45d9aa896dbca1c" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding from &lt;code&gt;T&lt;/code&gt; all properties that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;U&lt;/code&gt; に割り当て可能なすべてのプロパティを &lt;code&gt;T&lt;/code&gt; から除外することにより、型を構築します。</target>
        </trans-unit>
        <trans-unit id="8caddbb3ddee9f5ae43f3e24c9baf74c9d40a4b9" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding from &lt;code&gt;Type&lt;/code&gt; all union members that are assignable to &lt;code&gt;ExcludedUnion&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ExcludedUnion&lt;/code&gt; に割り当て可能なすべてのユニオンメンバーを &lt;code&gt;Type&lt;/code&gt; から除外することにより、タイプを構築します。</target>
        </trans-unit>
        <trans-unit id="534a3be9726f529289895ca42ccc7f72d9c3024c" translate="yes" xml:space="preserve">
          <source>Constructs a type by extracting from &lt;code&gt;T&lt;/code&gt; all properties that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;U&lt;/code&gt; に割り当て可能なすべてのプロパティを &lt;code&gt;T&lt;/code&gt; から抽出することにより、型を構築します。</target>
        </trans-unit>
        <trans-unit id="b8b9d1c1c29172750935e9c25ec87d393c9cbc4e" translate="yes" xml:space="preserve">
          <source>Constructs a type by extracting from &lt;code&gt;Type&lt;/code&gt; all union members that are assignable to &lt;code&gt;Union&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Union&lt;/code&gt; 割り当て可能なすべてのユニオンメンバーを &lt;code&gt;Type&lt;/code&gt; から抽出することにより、タイプを構築します。</target>
        </trans-unit>
        <trans-unit id="3e405f5b40b51987ceb9ba1254eee89e3f48777c" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking all properties from &lt;code&gt;T&lt;/code&gt; and then removing &lt;code&gt;K&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; からすべてのプロパティを選択してから &lt;code&gt;K&lt;/code&gt; を削除することにより、型を構築します。</target>
        </trans-unit>
        <trans-unit id="09cc5c4b6a37c1bdbee9dd0d7660c6620a24b5a9" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking all properties from &lt;code&gt;Type&lt;/code&gt; and then removing &lt;code&gt;Keys&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; からすべてのプロパティを選択し、 &lt;code&gt;Keys&lt;/code&gt; を削除して、型を作成します。</target>
        </trans-unit>
        <trans-unit id="13581efb3c161daf55efaa641c95a2937e6fa92d" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking the set of properties &lt;code&gt;K&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; からプロパティ &lt;code&gt;K&lt;/code&gt; のセットを選択して型を構築します。</target>
        </trans-unit>
        <trans-unit id="68c0c0b3c69f4491f5b7e112f6aa41891acb587a" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking the set of properties &lt;code&gt;Keys&lt;/code&gt; from &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; からプロパティ &lt;code&gt;Keys&lt;/code&gt; のセットを選択して、型を作成します。</target>
        </trans-unit>
        <trans-unit id="9fa9c5cf9d32c720825d39df29969f2f2dfdb044" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of all properties of &lt;code&gt;T&lt;/code&gt; set to required.</source>
          <target state="translated">必須に設定された &lt;code&gt;T&lt;/code&gt; のすべてのプロパティで構成される型を構築します。</target>
        </trans-unit>
        <trans-unit id="932e1b16b3a2393ed1e71294aedc0172a3c58d7f" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of all properties of &lt;code&gt;T&lt;/code&gt; set to required. The opposite of &lt;a href=&quot;#partialtype&quot;&gt;&lt;code&gt;Partial&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">必須に設定された &lt;code&gt;T&lt;/code&gt; のすべてのプロパティで構成されるタイプを構築します。&lt;a href=&quot;#partialtype&quot;&gt; &lt;code&gt;Partial&lt;/code&gt; &lt;/a&gt;の反対。</target>
        </trans-unit>
        <trans-unit id="1f68e6fde23a08ff88d024111ed166b6b258e4fd" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the instance type of a constructor function in &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; のコンストラクター関数のインスタンス型で構成される型を構築します。</target>
        </trans-unit>
        <trans-unit id="8af78f1563236125ebb587f0510bfdfbb33bcfd1" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the instance type of a constructor function type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">コンストラクター関数型 &lt;code&gt;T&lt;/code&gt; のインスタンス型で構成される型を構築します。</target>
        </trans-unit>
        <trans-unit id="67178f246747dfdb076d24fd6fe244d35eea9de7" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the return type of function &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;T&lt;/code&gt; の戻り値の型で構成される型を構築します。</target>
        </trans-unit>
        <trans-unit id="6248af074741172f00aa42821fdc5ca624e3bfe0" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the return type of function &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;Type&lt;/code&gt; の戻り値の型で構成される型を構築します。</target>
        </trans-unit>
        <trans-unit id="b92a41e86aee02470adc5b04c55124c13aaff3f2" translate="yes" xml:space="preserve">
          <source>Constructs a type with a set of properties &lt;code&gt;K&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;. This utility can be used to map the properties of a type to another type.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 型の一連のプロパティ &lt;code&gt;K&lt;/code&gt; を持つ型を構築します。このユーティリティを使用して、タイプのプロパティを別のタイプにマップできます。</target>
        </trans-unit>
        <trans-unit id="302b3ef8a60040355be3458fc77a6c0e18ea642f" translate="yes" xml:space="preserve">
          <source>Constructs a type with a set of properties &lt;code&gt;Keys&lt;/code&gt; of type &lt;code&gt;Type&lt;/code&gt;. This utility can be used to map the properties of a type to another type.</source>
          <target state="translated">タイプ &lt;code&gt;Type&lt;/code&gt; のプロパティ &lt;code&gt;Keys&lt;/code&gt; のセットを使用してタイプを構築します。このユーティリティを使用して、あるタイプのプロパティを別のタイプにマップできます。</target>
        </trans-unit>
        <trans-unit id="87140e5d46947bf6adcacabd45f115a7d1fa950d" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;T&lt;/code&gt; set to &lt;code&gt;readonly&lt;/code&gt;, meaning the properties of the constructed type cannot be reassigned.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; のすべてのプロパティを &lt;code&gt;readonly&lt;/code&gt; に設定して型を構築します。つまり、構築された型のプロパティは再割り当てできません。</target>
        </trans-unit>
        <trans-unit id="6638ebe736931ecdde61f721cb96423f589cf127" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;T&lt;/code&gt; set to optional. This utility will return a type that represents all subsets of a given type.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; のすべてのプロパティをオプションに設定して型を構築します。このユーティリティは、指定されたタイプのすべてのサブセットを表すタイプを返します。</target>
        </trans-unit>
        <trans-unit id="f31c4d16e9ff4bfb1cded19332727ccef1b3be41" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;Type&lt;/code&gt; set to &lt;code&gt;readonly&lt;/code&gt;, meaning the properties of the constructed type cannot be reassigned.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; のすべてのプロパティが &lt;code&gt;readonly&lt;/code&gt; に設定されたタイプを構築します。つまり、構築されたタイプのプロパティを再割り当てすることはできません。</target>
        </trans-unit>
        <trans-unit id="e6f4cbe62efb06cc53e3a14039a9db23ac8c8cda" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;Type&lt;/code&gt; set to optional. This utility will return a type that represents all subsets of a given type.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; のすべてのプロパティがオプションに設定されたタイプを構築します。このユーティリティは、指定されたタイプのすべてのサブセットを表すタイプを返します。</target>
        </trans-unit>
        <trans-unit id="0cd2ae0ee1c90002e81a2a4c5b16f430d5eb5d5d" translate="yes" xml:space="preserve">
          <source>Consumer.ts</source>
          <target state="translated">Consumer.ts</target>
        </trans-unit>
        <trans-unit id="19643388856c2476ec9508c66a7a7a22828effd3" translate="yes" xml:space="preserve">
          <source>Consumers of your module should have as little friction as possible when using things that you export. Adding too many levels of nesting tends to be cumbersome, so think carefully about how you want to structure things.</source>
          <target state="translated">モジュールの消費者は、エクスポートしたものを使用する際の摩擦をできるだけ少なくする必要があります。あまりにも多くのレベルの入れ子を追加すると面倒になる傾向があるので、どのように構造化したいかを慎重に考えてください。</target>
        </trans-unit>
        <trans-unit id="9e33338e8781d70a603018c5dde7772e8b7ed456" translate="yes" xml:space="preserve">
          <source>Consuming</source>
          <target state="translated">Consuming</target>
        </trans-unit>
        <trans-unit id="1e2af544c5c4ac1500ff8f4ed22cff22ab2d98d9" translate="yes" xml:space="preserve">
          <source>Consuming Dependencies</source>
          <target state="translated">依存関係の消費</target>
        </trans-unit>
        <trans-unit id="47a106946fb54af2e98e522133b69f05659ad46a" translate="yes" xml:space="preserve">
          <source>Consumption</source>
          <target state="translated">Consumption</target>
        </trans-unit>
        <trans-unit id="43d406bfbbaf7c88699230d3aef03ec04c451529" translate="yes" xml:space="preserve">
          <source>Consumption: Consuming</source>
          <target state="translated">消費 消費すること</target>
        </trans-unit>
        <trans-unit id="a38855f0870542b992b5fff7c96208a8884a3edf" translate="yes" xml:space="preserve">
          <source>Consumption: Downloading</source>
          <target state="translated">消費します。ダウンロード</target>
        </trans-unit>
        <trans-unit id="83a031c3bd99a755d80e5f7da09ef9648fc64a91" translate="yes" xml:space="preserve">
          <source>Consumption: Searching</source>
          <target state="translated">消費 探索中</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">Contents</target>
        </trans-unit>
        <trans-unit id="345009d8692863e53f52a509ffa69fac9f8c1193" translate="yes" xml:space="preserve">
          <source>Contextual Typing</source>
          <target state="translated">文脈に応じたタイピング</target>
        </trans-unit>
        <trans-unit id="603feab4fc9b8d65cd86c21a0640771b620b3af7" translate="yes" xml:space="preserve">
          <source>Contextual typing</source>
          <target state="translated">文脈に応じたタイピング</target>
        </trans-unit>
        <trans-unit id="5ffb5489166008419359898740eeed46cbeb1671" translate="yes" xml:space="preserve">
          <source>Contextual typing also works recursively through object literals, and on unit types that would otherwise be inferred as &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;number&lt;/code&gt;. And it can infer return types from context:</source>
          <target state="translated">コンテキストタイピングは、オブジェクトリテラルを介して再帰的に機能し、そうでなければ &lt;code&gt;string&lt;/code&gt; または &lt;code&gt;number&lt;/code&gt; として推測されるユニットタイプに対しても機能します。そして、コンテキストから戻り値の型を推測できます。</target>
        </trans-unit>
        <trans-unit id="3890ff4bf80a096d2b98096a8e255fb1438bedf3" translate="yes" xml:space="preserve">
          <source>Contextual typing applies in many cases. Common cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements. The contextual type also acts as a candidate type in best common type. For example:</source>
          <target state="translated">文脈に応じた型付けは多くの場合に適用されます。一般的なケースとしては、関数呼び出しの引数、代入の右辺、型のアサーション、オブジェクトや配列リテラルのメンバ、戻り値の文などがあります。また、文脈型は、最良の共通型の候補型としても機能します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="8991bf4cd6fcd903e6d8843735f575800e222a1b" translate="yes" xml:space="preserve">
          <source>Control flow analysis errors</source>
          <target state="translated">制御フロー解析エラー</target>
        </trans-unit>
        <trans-unit id="26b790f356c8f06689edb0506cd42e89fdf6a448" translate="yes" xml:space="preserve">
          <source>Control flow based type analysis</source>
          <target state="translated">制御フローに基づくタイプ分析</target>
        </trans-unit>
        <trans-unit id="5608c55cda3285cb7a6c58d2a3953e2990e12df3" translate="yes" xml:space="preserve">
          <source>Control flow based type analysis is particularly relevant in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode because nullable types are represented using union types:</source>
          <target state="translated">制御フローベースの型分析は、null許容型がユニオン型を使用して表されるため、 &lt;code&gt;--strictNullChecks&lt;/code&gt; モードで特に重要です。</target>
        </trans-unit>
        <trans-unit id="ac60e4fabc9d2458046e40ecaa2efebb0c647716" translate="yes" xml:space="preserve">
          <source>Controls how JSX constructs are emitted in JavaScript files. This only affects output of JS files that started in &lt;code&gt;.tsx&lt;/code&gt; files.</source>
          <target state="translated">JSXコンストラクトがJavaScriptファイルでどのように出力されるかを制御します。これは、 &lt;code&gt;.tsx&lt;/code&gt; ファイルで開始されたJSファイルの出力にのみ影響します。</target>
        </trans-unit>
        <trans-unit id="372e1a5c72020e79bfc4592c655c28b0c15b1125" translate="yes" xml:space="preserve">
          <source>Controls whether TypeScript will emit a &lt;a href=&quot;https://wikipedia.org/wiki/Byte_order_mark&quot;&gt;byte order mark (BOM)&lt;/a&gt; when writing output files. Some runtime environments require a BOM to correctly interpret a JavaScript files; others require that it is not present. The default value of &lt;code&gt;false&lt;/code&gt; is generally best unless you have a reason to change it.</source>
          <target state="translated">TypeScriptが出力ファイルの書き込み時に&lt;a href=&quot;https://wikipedia.org/wiki/Byte_order_mark&quot;&gt;バイトオーダーマーク（BOM）を&lt;/a&gt;発行するかどうかを制御します。一部のランタイム環境では、JavaScriptファイルを正しく解釈するためにBOMが必要です。他の人はそれが存在しないことを要求します。変更する理由がない限り、通常、デフォルト値の &lt;code&gt;false&lt;/code&gt; が最適です。</target>
        </trans-unit>
        <trans-unit id="676622699467dc4bbf4104746ce06f96c9893b26" translate="yes" xml:space="preserve">
          <source>Conversely when importing:</source>
          <target state="translated">逆に輸入する場合。</target>
        </trans-unit>
        <trans-unit id="f31b6614a525392ec0858195de4c10be17398d28" translate="yes" xml:space="preserve">
          <source>Converts to this JavaScript:</source>
          <target state="translated">このJavaScriptに変換します。</target>
        </trans-unit>
        <trans-unit id="d9701bf4f89400101efb5b5908d4ea6d132c91f0" translate="yes" xml:space="preserve">
          <source>Core definitions for all ES3 and ES5 functionality</source>
          <target state="translated">ES3とES5の全機能のコア定義</target>
        </trans-unit>
        <trans-unit id="19762d1065d05ceddeccf92411a8f237f298697e" translate="yes" xml:space="preserve">
          <source>Correctly finding &lt;code&gt;moduleA&lt;/code&gt; as it was passed on the command-line.</source>
          <target state="translated">コマンドラインで渡された &lt;code&gt;moduleA&lt;/code&gt; を正しく検索します。</target>
        </trans-unit>
        <trans-unit id="ae18f0902f48e8ccca9ad33f1e24aa69738ce04c" translate="yes" xml:space="preserve">
          <source>Correctly predict type system behavior in most cases</source>
          <target state="translated">ほとんどの場合、型システムの動作を正しく予測することができます。</target>
        </trans-unit>
        <trans-unit id="cebcad9c0d7aa9b4035b16adbfe6b459f9f243ec" translate="yes" xml:space="preserve">
          <source>Corresponding changes to add &lt;code&gt;LibraryManagedAttributes&lt;/code&gt; definition to the &lt;code&gt;JSX&lt;/code&gt; namespace in &lt;code&gt;@types/React&lt;/code&gt; are still needed. Keep in mind that there are some limitations.</source>
          <target state="translated">&lt;code&gt;LibraryManagedAttributes&lt;/code&gt; 定義を &lt;code&gt;@types/React&lt;/code&gt; &lt;code&gt;JSX&lt;/code&gt; 名前空間に追加するための対応する変更が引き続き必要です。いくつかの制限があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5ba6a73c0093201ece582d1fb4d7bbc3d859ef7a" translate="yes" xml:space="preserve">
          <source>Covering all of these cases requires the JavaScript code to actually support all of these patterns. To support many of these patterns, a CommonJS module would need to look something like:</source>
          <target state="translated">これらのケースをすべてカバーするには、実際にこれらのパターンをすべてサポートするJavaScriptコードが必要です。これらのパターンの多くをサポートするために、CommonJSモジュールは以下のようなものが必要になります。</target>
        </trans-unit>
        <trans-unit id="d4152f39c03c0eb9e811b3dbb568be8c9505d1aa" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;gulpfile.js&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;gulpfile.js&lt;/code&gt; を作成する</target>
        </trans-unit>
        <trans-unit id="3021179bd177130f09b3a8316daec30a4b2b93d6" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;webpack.config.js&lt;/code&gt; file at the root of the project directory.</source>
          <target state="translated">プロジェクトディレクトリのルートに &lt;code&gt;webpack.config.js&lt;/code&gt; ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="03be7fc935f815567fa5a4bac79cc78db732e8e0" translate="yes" xml:space="preserve">
          <source>Create a file called &lt;code&gt;src/greet.ts&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;src/greet.ts&lt;/code&gt; というファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="a9ff776f31b78475f53c7d5b1e090dd761e922f3" translate="yes" xml:space="preserve">
          <source>Create a file in &lt;code&gt;src&lt;/code&gt; named &lt;code&gt;index.html&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;index.html&lt;/code&gt; という名前のファイルを &lt;code&gt;src&lt;/code&gt; に作成します。</target>
        </trans-unit>
        <trans-unit id="72c972c59f1f27b703d41ea9aa9823f618a2d30a" translate="yes" xml:space="preserve">
          <source>Create a new file in the root of your source tree: &lt;code&gt;[libname].d.ts&lt;/code&gt;</source>
          <target state="translated">ソースツリーのルートに新しいファイルを作成します： &lt;code&gt;[libname].d.ts&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9d670257b5f8858306ee09e6f9274710bd7a4022" translate="yes" xml:space="preserve">
          <source>Create a new folder in &lt;code&gt;node_modules/@types/[libname]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;node_modules/@types/[libname]&lt;/code&gt; 新しいフォルダーを作成します</target>
        </trans-unit>
        <trans-unit id="325cf797263cfffdce479b5e173823121f9d4d73" translate="yes" xml:space="preserve">
          <source>Create a new project</source>
          <target state="translated">新規プロジェクトの作成</target>
        </trans-unit>
        <trans-unit id="79b403f57bb09e035ae3515269845b15ce38bd27" translate="yes" xml:space="preserve">
          <source>Create a page</source>
          <target state="translated">ページを作成する</target>
        </trans-unit>
        <trans-unit id="647abbb31ccf904ba3c2c45c79357305334edf70" translate="yes" xml:space="preserve">
          <source>Create a webpack configuration file</source>
          <target state="translated">webpackの設定ファイルを作成する</target>
        </trans-unit>
        <trans-unit id="78a14b786be544c7e444994e89b63a1bab9e7ec1" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;index.d.ts&lt;/code&gt; in that folder, and copy the example in</source>
          <target state="translated">そのフォルダーに &lt;code&gt;index.d.ts&lt;/code&gt; を作成し、の例をコピーします。</target>
        </trans-unit>
        <trans-unit id="a80520c836bad8ac980c6af04074db460cf2a83d" translate="yes" xml:space="preserve">
          <source>Creating .d.ts Files from .js files</source>
          <target state="translated">.jsファイルから.d.tsファイルを作成する</target>
        </trans-unit>
        <trans-unit id="2f4329f654175ad323032c9448bb383b6b11a42c" translate="yes" xml:space="preserve">
          <source>Currently &lt;code&gt;useDefineForClassFields&lt;/code&gt; is only available when targeting ES5 and upwards, since &lt;code&gt;Object.defineProperty&lt;/code&gt; doesn&amp;rsquo;t exist in ES3. To achieve similar checking for issues, you can create a seperate project that targets ES5 and uses &lt;code&gt;--noEmit&lt;/code&gt; to avoid a full build.</source>
          <target state="translated">現在、 &lt;code&gt;useDefineForClassFields&lt;/code&gt; はES3に存在しないため、 &lt;code&gt;Object.defineProperty&lt;/code&gt; はES5以上を対象とする場合にのみ使用できます。同様の問題チェックを実現するには、ES5を対象とする &lt;code&gt;--noEmit&lt;/code&gt; プロジェクトを作成し、-noEmitを使用して完全なビルドを回避します。</target>
        </trans-unit>
        <trans-unit id="96526436a6307d6465c867047c87cca576ddfe01" translate="yes" xml:space="preserve">
          <source>Currently, the only top-level property that is excluded from inheritance is &lt;a href=&quot;#references&quot;&gt;&lt;code&gt;references&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在、継承から除外される最上位のプロパティは&lt;a href=&quot;#references&quot;&gt; &lt;code&gt;references&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="e9cd15468b55ecfe136f817794b0238725c3ba6b" translate="yes" xml:space="preserve">
          <source>Custom JSX factories using &lt;code&gt;--reactNamespace&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--reactNamespace&lt;/code&gt; を使用したカスタムJSXファクトリ</target>
        </trans-unit>
        <trans-unit id="13be717a73cc5b208ba90837f91718dbedc0e5c7" translate="yes" xml:space="preserve">
          <source>D3.d.ts (simplified excerpt)</source>
          <target state="translated">D3.d.ts(簡略化された抜粋</target>
        </trans-unit>
        <trans-unit id="6be0205f470d4c7a15a776fec93f63444a3c1da3" translate="yes" xml:space="preserve">
          <source>DEPRECATED. Use &lt;code&gt;--jsxFactory&lt;/code&gt; instead.</source>
          <target state="translated">非推奨。代わりに &lt;code&gt;--jsxFactory&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="5799536cf1759401f5d741ea6f17c63a6dec9bbc" translate="yes" xml:space="preserve">
          <source>DEPRECATED. Use &lt;code&gt;--outFile&lt;/code&gt; instead.</source>
          <target state="translated">非推奨。代わりに &lt;code&gt;--outFile&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="59b53d5c8edc70418359a1b34ceac44b0e0760de" translate="yes" xml:space="preserve">
          <source>DEPRECATED. Use &lt;code&gt;--skipLibCheck&lt;/code&gt; instead.</source>
          <target state="translated">非推奨。代わりに &lt;code&gt;--skipLibCheck&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="4c8569d62477c3f3a8139ad175f1b65dec4c78eb" translate="yes" xml:space="preserve">
          <source>DOM Changes</source>
          <target state="translated">DOM の変更</target>
        </trans-unit>
        <trans-unit id="97bc0d0faf1db6773f46f77993cbfab01aef6415" translate="yes" xml:space="preserve">
          <source>DOM Manipulation</source>
          <target state="translated">DOM の操作</target>
        </trans-unit>
        <trans-unit id="bd604d99e75e45d38bc7ac8fc714cde0097d901f" translate="yes" xml:space="preserve">
          <source>Debug</source>
          <target state="translated">Debug</target>
        </trans-unit>
        <trans-unit id="d4a6e25daaa79e164346a5df8f97d22e51c38251" translate="yes" xml:space="preserve">
          <source>Declaration - &lt;code&gt;declaration&lt;/code&gt;</source>
          <target state="translated">宣言- &lt;code&gt;declaration&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83a6e664769b464317ab5bac295d9c6ac3c0507f" translate="yes" xml:space="preserve">
          <source>Declaration Dir - &lt;code&gt;declarationDir&lt;/code&gt;</source>
          <target state="translated">宣言ディレクトリ- &lt;code&gt;declarationDir&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad92a8160441d1375fed7cf194406ee120a09e46" translate="yes" xml:space="preserve">
          <source>Declaration File Theory: A Deep Dive</source>
          <target state="translated">宣言ファイル理論。ディープダイブ</target>
        </trans-unit>
        <trans-unit id="2f52e43b6882a3466f1d969c1cb1001473303ede" translate="yes" xml:space="preserve">
          <source>Declaration Files</source>
          <target state="translated">宣言ファイル</target>
        </trans-unit>
        <trans-unit id="b50be50c5afb7e54332d8b1bf30d309b0eae0711" translate="yes" xml:space="preserve">
          <source>Declaration Map - &lt;code&gt;declarationMap&lt;/code&gt;</source>
          <target state="translated">宣言マップ &lt;code&gt;declarationMap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dddf315bf8c952c79983330b50ceb284d3027070" translate="yes" xml:space="preserve">
          <source>Declaration Merging</source>
          <target state="translated">宣言のマージ</target>
        </trans-unit>
        <trans-unit id="851f4d7f22e2bf61aa3d231bae99e9eaaf320d8e" translate="yes" xml:space="preserve">
          <source>Declaration Reference</source>
          <target state="translated">宣言リファレンス</target>
        </trans-unit>
        <trans-unit id="2b8121a4da07765109d3a1ebd4396566febe4c31" translate="yes" xml:space="preserve">
          <source>Declaration Type</source>
          <target state="translated">宣言タイプ</target>
        </trans-unit>
        <trans-unit id="2411670cd38002dcd5a4989aaf25d65b85643783" translate="yes" xml:space="preserve">
          <source>Declaration initialisers are contextually typed by the declaration&amp;rsquo;s type: &lt;code&gt;{ inference: string }&lt;/code&gt;.</source>
          <target state="translated">宣言の初期化子は、宣言のタイプによってコンテキストで型付けされます： &lt;code&gt;{ inference: string }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9b846963186dedc9a34aab11fab9a0a092e2d1b" translate="yes" xml:space="preserve">
          <source>Declarations</source>
          <target state="translated">Declarations</target>
        </trans-unit>
        <trans-unit id="dc141dc5502f9e0e32e0ce70ae020fbf031bce6e" translate="yes" xml:space="preserve">
          <source>Declarations are &lt;em&gt;always&lt;/em&gt; initialized to &lt;code&gt;undefined&lt;/code&gt;, even if they have no initializer.</source>
          <target state="translated">宣言は&lt;em&gt;常に&lt;/em&gt; &lt;code&gt;undefined&lt;/code&gt; 初期化されます場合でも、にます。</target>
        </trans-unit>
        <trans-unit id="f41d762770bc6126d4d1fc990ef90759d58eb809" translate="yes" xml:space="preserve">
          <source>Declarations are initialized with &lt;code&gt;Object.defineProperty&lt;/code&gt;.</source>
          <target state="translated">宣言は &lt;code&gt;Object.defineProperty&lt;/code&gt; で初期化されます。</target>
        </trans-unit>
        <trans-unit id="6fcdb4b2cc50995c39a00cc184737f3ebc0aa6de" translate="yes" xml:space="preserve">
          <source>Declarations like &lt;code&gt;import * as a from 'b';&lt;/code&gt; or &lt;code&gt;export c;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;import * as a from 'b';&lt;/code&gt; ような宣言。または &lt;code&gt;export c;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="347802d3a4b4ece7d3a20faf11435d4ac3181083" translate="yes" xml:space="preserve">
          <source>Declare the properties if they really do exist.</source>
          <target state="translated">プロパティが本当に存在するかどうかを宣言します。</target>
        </trans-unit>
        <trans-unit id="378818e31f6df21ace4ff334a5f33be4e8cb393e" translate="yes" xml:space="preserve">
          <source>Declares the module specifier to be used for importing the &lt;code&gt;jsx&lt;/code&gt; and &lt;code&gt;jsxs&lt;/code&gt; factory functions when using &lt;a href=&quot;#jsx&quot;&gt;&lt;code&gt;jsx&lt;/code&gt;&lt;/a&gt; as &lt;code&gt;&quot;react-jsx&quot;&lt;/code&gt; or &lt;code&gt;&quot;react-jsxdev&quot;&lt;/code&gt; which were introduced in TypeScript 4.1.</source>
          <target state="translated">TypeScript 4.1で導入された &lt;code&gt;&quot;react-jsx&quot;&lt;/code&gt; または &lt;code&gt;&quot;react-jsxdev&quot;&lt;/code&gt; として&lt;a href=&quot;#jsx&quot;&gt; &lt;code&gt;jsx&lt;/code&gt; &lt;/a&gt;を使用する場合に、 &lt;code&gt;jsx&lt;/code&gt; および &lt;code&gt;jsxs&lt;/code&gt; ファクトリ関数をインポートするために使用されるモジュール指定子を宣言します。</target>
        </trans-unit>
        <trans-unit id="0d6cb4979eadd458a450c7ab965139630dc251e6" translate="yes" xml:space="preserve">
          <source>Declaring a variable in JavaScript has always traditionally been done with the &lt;code&gt;var&lt;/code&gt; keyword.</source>
          <target state="translated">JavaScriptで変数を宣言することは、常に伝統的に &lt;code&gt;var&lt;/code&gt; キーワードで行われてきました。</target>
        </trans-unit>
        <trans-unit id="76e978b48c2e7ee378c2b0140f7507fecee38d99" translate="yes" xml:space="preserve">
          <source>Declaring generic classes or types is unsupported.</source>
          <target state="translated">汎用クラスや型の宣言はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="45c3eb65b36120d75303dd4d19ce72e6c44591cc" translate="yes" xml:space="preserve">
          <source>Declaring variables of type &lt;code&gt;void&lt;/code&gt; is not useful because you can only assign &lt;code&gt;null&lt;/code&gt; (only if &lt;code&gt;--strictNullChecks&lt;/code&gt; is not specified, see next section) or &lt;code&gt;undefined&lt;/code&gt; to them:</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 型の変数の宣言は、 &lt;code&gt;null&lt;/code&gt; （-- &lt;code&gt;--strictNullChecks&lt;/code&gt; が指定されていない場合のみ、次のセクションを参照）またはそれらに &lt;code&gt;undefined&lt;/code&gt; しか割り当てられないため、役に立ちません。</target>
        </trans-unit>
        <trans-unit id="c9d80403b6c6762d3135cc4b0364ef0ded8f2e39" translate="yes" xml:space="preserve">
          <source>Decorator Composition</source>
          <target state="translated">デコレーターの構成</target>
        </trans-unit>
        <trans-unit id="94dcd3c584c6cd82aa44ce93304239e663bb5afb" translate="yes" xml:space="preserve">
          <source>Decorator Evaluation</source>
          <target state="translated">デコレーターの評価</target>
        </trans-unit>
        <trans-unit id="bc8d0308046fee6336b61acda5e70c000a657952" translate="yes" xml:space="preserve">
          <source>Decorator Factories</source>
          <target state="translated">デコレーター工場</target>
        </trans-unit>
        <trans-unit id="a2e23b650a15e5c693ca1445133d5ee60d9d20b4" translate="yes" xml:space="preserve">
          <source>Decorators</source>
          <target state="translated">Decorators</target>
        </trans-unit>
        <trans-unit id="ef21caee016081351dbb5463efe6ee7af49ce158" translate="yes" xml:space="preserve">
          <source>Decorators &lt;code&gt;readonly&lt;/code&gt; and &lt;code&gt;enumerable(false)&lt;/code&gt; will be applied to the property &lt;code&gt;method&lt;/code&gt; before it is installed on class &lt;code&gt;C&lt;/code&gt;. This allows the decorator to change the implementation, and in this case, augment the descriptor to be writable: false and enumerable: false.</source>
          <target state="translated">クラス &lt;code&gt;C&lt;/code&gt; にインストールされる前に、デコレーター &lt;code&gt;readonly&lt;/code&gt; および &lt;code&gt;enumerable(false)&lt;/code&gt; がプロパティ &lt;code&gt;method&lt;/code&gt; に適用されます。これにより、デコレーターが実装を変更できるようになり、この場合は、記述子が書き込み可能：falseおよび列挙可能：falseに拡張されます。</target>
        </trans-unit>
        <trans-unit id="9956dce12bd8a076975367fb2d5e9353aca43d48" translate="yes" xml:space="preserve">
          <source>Decorators and Mixins &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/4881&quot;&gt;&lt;code&gt;#4881&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">デコレータとミックスイン&lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/4881&quot;&gt; &lt;code&gt;#4881&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6522aedcbf21b215104c1f4c00a269d73f7737d0" translate="yes" xml:space="preserve">
          <source>Decorators are a language feature which hasn&amp;rsquo;t yet been fully ratified into the JavaScript specification. This means that the implementation version in TypeScript may differ from the implementation in JavaScript when it it decided by TC39.</source>
          <target state="translated">デコレータは、JavaScript仕様にまだ完全に承認されていない言語機能です。つまり、TypeScriptの実装バージョンは、TC39によって決定されたときのJavaScriptの実装とは異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="8a0adc2fcd71ed541d9efa8c14c5ad593144b45d" translate="yes" xml:space="preserve">
          <source>Decorators are now allowed when targeting ES3. TypeScript 1.7 removes the ES5-specific use of &lt;code&gt;reduceRight&lt;/code&gt; from the &lt;code&gt;__decorate&lt;/code&gt; helper. The changes also inline calls &lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt; and &lt;code&gt;Object.defineProperty&lt;/code&gt; in a backwards-compatible fashion that allows for a to clean up the emit for ES5 and later by removing various repetitive calls to the aforementioned &lt;code&gt;Object&lt;/code&gt; methods.</source>
          <target state="translated">ES3を対象とする場合、デコレータが許可されるようになりました。TypeScript 1.7では、 &lt;code&gt;reduceRight&lt;/code&gt; の ES5固有の使用が &lt;code&gt;__decorate&lt;/code&gt; ヘルパーから削除されています。また、変更により、下位互換性のある方法で &lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt; および &lt;code&gt;Object.defineProperty&lt;/code&gt; がインラインで呼び出され、前述の &lt;code&gt;Object&lt;/code&gt; メソッドへのさまざまな繰り返し呼び出しを削除することで、ES5以降の出力をクリーンアップできます。</target>
        </trans-unit>
        <trans-unit id="ab1c2fe01ec5b2e45d64dd5c8c5b343bff75cd10" translate="yes" xml:space="preserve">
          <source>Deduplicated and redirected packages</source>
          <target state="translated">重複してリダイレクトされたパッケージ</target>
        </trans-unit>
        <trans-unit id="c34129b088d5dff9241ab7abdee9bb553051e041" translate="yes" xml:space="preserve">
          <source>Deep Dive</source>
          <target state="translated">ディープダイブ</target>
        </trans-unit>
        <trans-unit id="8f606bc9715586c081faee92e0f2cbb0b58c9865" translate="yes" xml:space="preserve">
          <source>Deep Dive: Advanced Combinations</source>
          <target state="translated">ディープダイブ 高度な組み合わせ</target>
        </trans-unit>
        <trans-unit id="8dce9edac26c50b7afe597930a0e4d53c87e0151" translate="yes" xml:space="preserve">
          <source>Deep Dive: Definition File Theory: A Deep Dive</source>
          <target state="translated">ディープダイブ 定義ファイル理論。ディープダイブ</target>
        </trans-unit>
        <trans-unit id="df3520f4ddd89ba26396acae5290727ff5fa15a2" translate="yes" xml:space="preserve">
          <source>Deep Dive: Using with export = or import</source>
          <target state="translated">ディープダイブ。export=または import での使用</target>
        </trans-unit>
        <trans-unit id="7924171a48438d5b2e1b6937ed62b292cb09fd2a" translate="yes" xml:space="preserve">
          <source>Deep dive reference materials.</source>
          <target state="translated">ディープダイブの参考資料。</target>
        </trans-unit>
        <trans-unit id="808d7dca8a74d84af27a2d6602c3d786de45fe1e" translate="yes" xml:space="preserve">
          <source>Default</source>
          <target state="translated">Default</target>
        </trans-unit>
        <trans-unit id="1dcd95e322dde1a1ed9488f1a9be1d85f6302d4a" translate="yes" xml:space="preserve">
          <source>Default Export</source>
          <target state="translated">デフォルトのエクスポート</target>
        </trans-unit>
        <trans-unit id="af087002f31d0ea4e967c16e89ad0e158cdeb097" translate="yes" xml:space="preserve">
          <source>Default Exports</source>
          <target state="translated">デフォルトのエクスポート</target>
        </trans-unit>
        <trans-unit id="967dd37853ad5171b91867584cc350ce812dd723" translate="yes" xml:space="preserve">
          <source>Default exports</source>
          <target state="translated">デフォルトのエクスポート</target>
        </trans-unit>
        <trans-unit id="6c547e1ab7ad80d7eb94ac89b9475cb2f4ad47cf" translate="yes" xml:space="preserve">
          <source>Default exports also cannot be augmented, only named exports (since you need to augment an export by its exported name, and &lt;code&gt;default&lt;/code&gt; is a reserved word - see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14080&quot;&gt;#14080&lt;/a&gt; for details)</source>
          <target state="translated">デフォルトのエクスポートも拡張できません。名前付きエクスポートのみです（エクスポートをエクスポート名で拡張する必要があるため、 &lt;code&gt;default&lt;/code&gt; は予約語です-詳細は&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14080&quot;&gt;＃14080&lt;/a&gt;を参照してください）</target>
        </trans-unit>
        <trans-unit id="aaafa95b77c94d35023aa4c831339a5f6888b4bd" translate="yes" xml:space="preserve">
          <source>Default imports to CommonJS/AMD/UMD are now allowed (e.g. &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt;), and should work as expected.</source>
          <target state="translated">CommonJS / AMD / UMDへのデフォルトのインポートが許可され（たとえば &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; ）、期待どおりに機能するはずです。</target>
        </trans-unit>
        <trans-unit id="ca5a7e29bf0dd24fa5da97c8a78bd7b6478ae9da" translate="yes" xml:space="preserve">
          <source>Default types for a type parameter must satisfy the constraint for the type parameter, if it exists.</source>
          <target state="translated">型パラメータのデフォルト型は、型パラメータが存在する場合には、その型パラメータの制約を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="e034cbbe2b8762f796d4892d08bbfed1145d3ef8" translate="yes" xml:space="preserve">
          <source>Default values</source>
          <target state="translated">デフォルト値</target>
        </trans-unit>
        <trans-unit id="373c6cd274b89a3c2582c933d56ada3fedbd82e3" translate="yes" xml:space="preserve">
          <source>Default values let you specify a default value in case a property is undefined:</source>
          <target state="translated">デフォルト値では、プロパティが未定義の場合のデフォルト値を指定することができます。</target>
        </trans-unit>
        <trans-unit id="b1bceef18898234e393aee21da6ed7ad228f35ee" translate="yes" xml:space="preserve">
          <source>Default-initialized parameters that come after all required parameters are treated as optional, and just like optional parameters, can be omitted when calling their respective function. This means optional parameters and trailing default parameters will share commonality in their types, so both</source>
          <target state="translated">すべての必須パラメータの後に来るデフォルト初期化されたパラメータはオプションとして扱われ、 オプションパラメータと同様に、それぞれの関数を呼び出す際に省略することができます。これは、オプションパラメータと後続のデフォルトパラメータが型の共通性を共有することを意味します。</target>
        </trans-unit>
        <trans-unit id="317bbd656753a9dd8ea52dce97e89a2822b25653" translate="yes" xml:space="preserve">
          <source>Default:</source>
          <target state="translated">Default:</target>
        </trans-unit>
        <trans-unit id="74041b7807a7d4e7910b8959338951cb903fa127" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;&quot;react&quot;&lt;/code&gt;</source>
          <target state="translated">デフォルト： &lt;code&gt;&quot;react&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd59cfb04075f034cef59cd0fa42daf1eb79992e" translate="yes" xml:space="preserve">
          <source>Defaulted declarations</source>
          <target state="translated">デフォルトの宣言</target>
        </trans-unit>
        <trans-unit id="990fdad3673f0e5fcfe37a06c68fc3e568969839" translate="yes" xml:space="preserve">
          <source>Defining Types</source>
          <target state="translated">タイプの定義</target>
        </trans-unit>
        <trans-unit id="abc6fc711e9d8d97a334f473c6d8d10ccc6870a3" translate="yes" xml:space="preserve">
          <source>Definite Assignment Assertions</source>
          <target state="translated">定量的なアサーション</target>
        </trans-unit>
        <trans-unit id="4cf6455d1dfb8e1b31ee9a23f39f86c7d9682067" translate="yes" xml:space="preserve">
          <source>Definition File Theory: A Deep Dive</source>
          <target state="translated">定義ファイル理論。ディープダイブ</target>
        </trans-unit>
        <trans-unit id="3760ef166e35af012373e12d01c8cf9b2e33236e" translate="yes" xml:space="preserve">
          <source>Deno</source>
          <target state="translated">Deno</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="a5295ab13650a7fc6f7e3962a265606df1d7d936" translate="yes" xml:space="preserve">
          <source>Dependencies on Global Libraries</source>
          <target state="translated">グローバルライブラリへの依存</target>
        </trans-unit>
        <trans-unit id="6067defa2476905bfad8665adf2145c0c736a17f" translate="yes" xml:space="preserve">
          <source>Dependencies on Modules</source>
          <target state="translated">モジュールへの依存性</target>
        </trans-unit>
        <trans-unit id="30e045eae2e7599477b456a7f9a5428b685bf5aa" translate="yes" xml:space="preserve">
          <source>Dependencies on UMD libraries</source>
          <target state="translated">UMD ライブラリへの依存性</target>
        </trans-unit>
        <trans-unit id="918fe5bb958d61b9b61fe33be50330ae07bd5a2b" translate="yes" xml:space="preserve">
          <source>Depending on the JavaScript runtime environment which you intend to run your code in, there may be a base configuration which you can use at &lt;a href=&quot;https://github.com/tsconfig/bases/&quot;&gt;github.com/tsconfig/bases&lt;/a&gt;. These are &lt;code&gt;tsconfig.json&lt;/code&gt; files which your project extends from which simplifies your &lt;code&gt;tsconfig.json&lt;/code&gt; by handling the runtime support.</source>
          <target state="translated">コードを実行するJavaScriptランタイム環境によっては、&lt;a href=&quot;https://github.com/tsconfig/bases/&quot;&gt;github.com / tsconfig / basesで&lt;/a&gt;使用できる基本構成が存在する場合があります。これらは、プロジェクトが拡張する &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルであり、ランタイムサポートを処理することで &lt;code&gt;tsconfig.json&lt;/code&gt; を簡素化します。</target>
        </trans-unit>
        <trans-unit id="b6e13e2a33f9902dfc93501c0d9a6a0bb02f3d22" translate="yes" xml:space="preserve">
          <source>Depending on the module target specified during compilation, the compiler will generate appropriate code for Node.js (&lt;a href=&quot;http://wiki.commonjs.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt;), require.js (&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;AMD&lt;/a&gt;), &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;, &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt;, or &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-modules&quot;&gt;ECMAScript 2015 native modules&lt;/a&gt; (ES6) module-loading systems. For more information on what the &lt;code&gt;define&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;register&lt;/code&gt; calls in the generated code do, consult the documentation for each module loader.</source>
          <target state="translated">コンパイラーは、コンパイル時に指定されたモジュールターゲットに応じて、Node.js（&lt;a href=&quot;http://wiki.commonjs.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt;）、require.js（&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;AMD&lt;/a&gt;）、&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;、&lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt;、または&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-modules&quot;&gt;ECMAScript 2015ネイティブモジュール&lt;/a&gt;（ES6）モジュールロードシステム用の適切なコードを生成します。生成されたコードの &lt;code&gt;define&lt;/code&gt; 、 &lt;code&gt;require&lt;/code&gt; 、および &lt;code&gt;register&lt;/code&gt; 呼び出しの詳細については、各モジュールローダーのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="527600bf0272b6bf3abcb495a99c6ee346bb82b2" translate="yes" xml:space="preserve">
          <source>Deprecated</source>
          <target state="translated">Deprecated</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="3e9c954b8528b960f8219e88a4099c898d44449d" translate="yes" xml:space="preserve">
          <source>Despite its appearance, the &lt;code&gt;readonly&lt;/code&gt; type modifier can only be used for syntax on array types and tuple types. It is not a general-purpose type operator.</source>
          <target state="translated">その外観にもかかわらず、 &lt;code&gt;readonly&lt;/code&gt; 型修飾子は、配列型とタプル型の構文にのみ使用できます。汎用型の演算子ではありません。</target>
        </trans-unit>
        <trans-unit id="077ef6bb7e9ca7a81dc6c9028d61cccdb0c255dd" translate="yes" xml:space="preserve">
          <source>Destructuring</source>
          <target state="translated">Destructuring</target>
        </trans-unit>
        <trans-unit id="b44f48048febb0c759b20a351a087cf970585895" translate="yes" xml:space="preserve">
          <source>Destructuring also works in function declarations. For simple cases this is straightforward:</source>
          <target state="translated">デストラクチャリングは関数宣言でも動作します。単純なケースでは、これは簡単です。</target>
        </trans-unit>
        <trans-unit id="c10db471f87802e009d06682868c12eb36cc956b" translate="yes" xml:space="preserve">
          <source>Destructuring declarations also works for extracting values from arrays:</source>
          <target state="translated">宣言の構造化は、配列から値を抽出するためにも機能します。</target>
        </trans-unit>
        <trans-unit id="aae36bb7ef10a1d27e89e1a1e5cab353c1f39861" translate="yes" xml:space="preserve">
          <source>Destructuring in declarations and assignments</source>
          <target state="translated">宣言と代入での構造化</target>
        </trans-unit>
        <trans-unit id="30ec4f69e7cfb0ff17a5b214356b9461fa3e35ea" translate="yes" xml:space="preserve">
          <source>Destructuring patterns can also be used in regular assignment expressions. For instance, swapping two variables can be written as a single destructuring assignment:</source>
          <target state="translated">構造化パターンは、通常の代入式でも使用できます。例えば、2つの変数のスワップは1つの破壊的代入として書くことができます。</target>
        </trans-unit>
        <trans-unit id="b42315aeb1e4c4a5777df9a8f177e68cf09a45e0" translate="yes" xml:space="preserve">
          <source>Destructuring works with already-declared variables as well:</source>
          <target state="translated">構造化は、既に宣言されている変数でも動作します。</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="93207507957b31ebda343db069ec516064c2e248" translate="yes" xml:space="preserve">
          <source>Detect if they are up-to-date</source>
          <target state="translated">それらが最新であるかどうかを検出</target>
        </trans-unit>
        <trans-unit id="bec760709f148364d8b2d7249cf252878131b36c" translate="yes" xml:space="preserve">
          <source>Determine how modules get resolved. Either &lt;code&gt;&quot;Node&quot;&lt;/code&gt; for Node.js/io.js style resolution, or &lt;code&gt;&quot;Classic&quot;&lt;/code&gt;. See &lt;a href=&quot;module-resolution&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">モジュールの解決方法を決定します。Node.js / io.jsスタイルの解決には &lt;code&gt;&quot;Node&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;Classic&quot;&lt;/code&gt; いずれか。詳細については、&lt;a href=&quot;module-resolution&quot;&gt;モジュール解決のドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3c1b1483372c227a508b8463543c7a9308b81a78" translate="yes" xml:space="preserve">
          <source>Diagnostics - &lt;code&gt;diagnostics&lt;/code&gt;</source>
          <target state="translated">診断- &lt;code&gt;diagnostics&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea5a55f6f2e4530ea94d346bb5232949c83852a7" translate="yes" xml:space="preserve">
          <source>Difference between &lt;code&gt;children&lt;/code&gt; and &lt;code&gt;childNodes&lt;/code&gt;</source>
          <target state="translated">間の差 &lt;code&gt;children&lt;/code&gt; と &lt;code&gt;childNodes&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4dff229f34e808acb097e68696d3c3718ad33a9" translate="yes" xml:space="preserve">
          <source>Difference between the static and instance sides of classes</source>
          <target state="translated">クラスの静的側とインスタンス側の違い</target>
        </trans-unit>
        <trans-unit id="369d22e8ba9dcb70fad4ac90845eb7df1bdf8234" translate="yes" xml:space="preserve">
          <source>Different places in the language use one of the two compatibility mechanisms, depending on the situation. For practical purposes, type compatibility is dictated by assignment compatibility, even in the cases of the &lt;code&gt;implements&lt;/code&gt; and &lt;code&gt;extends&lt;/code&gt; clauses.</source>
          <target state="translated">言語の異なる場所では、状況に応じて、2つの互換性メカニズムのいずれかを使用します。実際には、 &lt;code&gt;implements&lt;/code&gt; および &lt;code&gt;extends&lt;/code&gt; 句の場合でも、型の互換性は割り当ての互換性によって決まります。</target>
        </trans-unit>
        <trans-unit id="95bcb1c49cad60f2d25122fcd19b63040c889429" translate="yes" xml:space="preserve">
          <source>Disable Size Limit - &lt;code&gt;disableSizeLimit&lt;/code&gt;</source>
          <target state="translated">サイズ制限を無効にする &lt;code&gt;disableSizeLimit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04a32974e72060c10cc1f472534786de4686092d" translate="yes" xml:space="preserve">
          <source>Disable Solution Searching - &lt;code&gt;disableSolutionSearching&lt;/code&gt;</source>
          <target state="translated">ソリューション検索を無効にする &lt;code&gt;disableSolutionSearching&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66c23df2605c409c3157537bdcacc045f0801eb0" translate="yes" xml:space="preserve">
          <source>Disable Source Project Reference Redirect - &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt;</source>
          <target state="translated">ソースプロジェクト参照リダイレクトを無効にする &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3bd0e1c1cd621e6fbcc274e9d250ab1db3c03d9" translate="yes" xml:space="preserve">
          <source>Disable bivariant parameter checking for function types.</source>
          <target state="translated">関数型の二変量パラメータ検査を無効にします。</target>
        </trans-unit>
        <trans-unit id="0d5492f8c219bc96eb3e1f985831cc36749273fc" translate="yes" xml:space="preserve">
          <source>Disable size limitation on JavaScript project.</source>
          <target state="translated">JavaScriptプロジェクトのサイズ制限を無効にします。</target>
        </trans-unit>
        <trans-unit id="c0d6cff3c670100d6c4947847436586c9f909a0c" translate="yes" xml:space="preserve">
          <source>Disable strict checking of generic signatures in function types.</source>
          <target state="translated">関数型のジェネリックシグネチャの厳密なチェックを無効にします。</target>
        </trans-unit>
        <trans-unit id="e5a053c8b9e96a66ffa4c28b3bd57ff2472f950d" translate="yes" xml:space="preserve">
          <source>Disables the automatic inclusion of any library files. If this option is set, &lt;code&gt;lib&lt;/code&gt; is ignored.</source>
          <target state="translated">ライブラリファイルの自動インクルードを無効にします。このオプションが設定されている場合、 &lt;code&gt;lib&lt;/code&gt; は無視されます。</target>
        </trans-unit>
        <trans-unit id="fc94ad5a04140e86aa8535c4085feefac81708ef" translate="yes" xml:space="preserve">
          <source>Disallow inconsistently-cased references to the same file.</source>
          <target state="translated">矛盾したケースの同じファイルへの参照を許可しないようにします。</target>
        </trans-unit>
        <trans-unit id="ca07b6b5d34354414804d10f0627d23afc021014" translate="yes" xml:space="preserve">
          <source>Disallowed Merges</source>
          <target state="translated">許可されていないマージ</target>
        </trans-unit>
        <trans-unit id="6e50354a241d00dc8de3bce0c769ecd4f5445e88" translate="yes" xml:space="preserve">
          <source>Discriminated Unions</source>
          <target state="translated">差別された組合</target>
        </trans-unit>
        <trans-unit id="4f995145bd06a1e9b5d7514449a82f5503e6e06f" translate="yes" xml:space="preserve">
          <source>Discriminating Unions</source>
          <target state="translated">差別的な組合</target>
        </trans-unit>
        <trans-unit id="8f4eecd214b9b9b6bc1adea133960de053499fa9" translate="yes" xml:space="preserve">
          <source>Distributive conditional types</source>
          <target state="translated">分布条件型</target>
        </trans-unit>
        <trans-unit id="5528e62826cea5c6ba5ef36621e1eb9d42697e3e" translate="yes" xml:space="preserve">
          <source>Do &lt;em&gt;not&lt;/em&gt; use a &lt;code&gt;/// &amp;lt;reference&lt;/code&gt; directive to declare a dependency to a UMD library!</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;reference&lt;/code&gt; ディレクティブを使用して、UMDライブラリへの依存関係を宣言し&lt;em&gt;ないで&lt;/em&gt;ください！</target>
        </trans-unit>
        <trans-unit id="008b4d242c76d59d51967dc8ca342e5c9c0171f2" translate="yes" xml:space="preserve">
          <source>Do not add triple-slash references or module import targets to the list of compiled files.</source>
          <target state="translated">コンパイルされたファイルのリストにトリプルスラッシュ参照やモジュールのインポートターゲットを追加しないでください。</target>
        </trans-unit>
        <trans-unit id="bbda7eadbbdea2540dfa2471e3343bfd9af51dfa" translate="yes" xml:space="preserve">
          <source>Do not emit &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; directives in module output.</source>
          <target state="translated">モジュール出力で &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; ディレクティブを発行しません。</target>
        </trans-unit>
        <trans-unit id="1ce6e36e455f554889b5d6bc9e169d6efc81747f" translate="yes" xml:space="preserve">
          <source>Do not emit compiler output files like JavaScript source code, source-maps or declarations if any errors were reported.</source>
          <target state="translated">エラーが報告された場合は、JavaScript のソースコード、ソースマップ、宣言などのコンパイラ出力ファイルを出力しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="0eae0aff266e745600e62273aeb329a274d44532" translate="yes" xml:space="preserve">
          <source>Do not emit compiler output files like JavaScript source code, source-maps or declarations.</source>
          <target state="translated">JavaScript のソースコード、ソースマップ、宣言などのコンパイラ出力ファイルを出力しないでください。</target>
        </trans-unit>
        <trans-unit id="3eb6ba65f5d19029d630e79f609d97ba6b1be452" translate="yes" xml:space="preserve">
          <source>Do not emit declarations for code that has an &lt;code&gt;@internal&lt;/code&gt; annotation in it&amp;rsquo;s JSDoc comment. This is an internal compiler option; use at your own risk, because the compiler does not check that the result is valid. If you are searching for a tool to handle additional levels of visibility within your &lt;code&gt;d.ts&lt;/code&gt; files, look at &lt;a href=&quot;https://api-extractor.com&quot;&gt;api-extractor&lt;/a&gt;.</source>
          <target state="translated">JSDocコメントに &lt;code&gt;@internal&lt;/code&gt; アノテーションが含まれているコードの宣言を発行しないでください。これは内部コンパイラオプションです。コンパイラは結果が有効かどうかをチェックしないため、自己責任で使用してください。 &lt;code&gt;d.ts&lt;/code&gt; ファイル内の追加レベルの可視性を処理するツールを探している場合は、&lt;a href=&quot;https://api-extractor.com&quot;&gt;api-extractorを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f59925b0be84543d3516bc127648bdda000f9a36" translate="yes" xml:space="preserve">
          <source>Do not emit outputs if any errors were reported.</source>
          <target state="translated">エラーが報告された場合は出力を出さないでください。</target>
        </trans-unit>
        <trans-unit id="8813a3a637738cb30116f3e3de2e596160d664a4" translate="yes" xml:space="preserve">
          <source>Do not emit outputs.</source>
          <target state="translated">出力を出さないでください。</target>
        </trans-unit>
        <trans-unit id="75e54c4e6371e16cfe8d5e2477971052228922b4" translate="yes" xml:space="preserve">
          <source>Do not erase &lt;code&gt;const enum&lt;/code&gt; declarations in generated code. &lt;code&gt;const enum&lt;/code&gt;s provide a way to reduce the overall memory footprint of your application at runtime by emitting the enum value instead of a reference.</source>
          <target state="translated">生成されたコードの &lt;code&gt;const enum&lt;/code&gt; 宣言を消去しないでください。 &lt;code&gt;const enum&lt;/code&gt; は、参照の代わりにenum値を発行することにより、実行時にアプリケーションの全体的なメモリフットプリントを削減する方法を提供します。</target>
        </trans-unit>
        <trans-unit id="110fa485165295f6412f7a19e4cf78d89958e5a1" translate="yes" xml:space="preserve">
          <source>Do not erase const enum declarations in generated code. See &lt;a href=&quot;enums#const-enums&quot;&gt;const enums documentation&lt;/a&gt; for more details.</source>
          <target state="translated">生成されたコードのconstenum宣言を消去しないでください。詳細については、&lt;a href=&quot;enums#const-enums&quot;&gt;constenumsのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2b4aecc96dbac4010750a03d9cdf681cad5a2782" translate="yes" xml:space="preserve">
          <source>Do not erase const enum declarations in generated code. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html#94-constant-enum-declarations&quot;&gt;const enums documentation&lt;/a&gt; for more details.</source>
          <target state="translated">生成されたコードのconst enum宣言を消去しないでください。詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html#94-constant-enum-declarations&quot;&gt;const enumsのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3ca81886d5434cef3d191c1781471a917134a9cf" translate="yes" xml:space="preserve">
          <source>Do not generate custom helper functions like &lt;code&gt;__extends&lt;/code&gt; in compiled output.</source>
          <target state="translated">コンパイルされた出力で &lt;code&gt;__extends&lt;/code&gt; のようなカスタムヘルパー関数を生成しません。</target>
        </trans-unit>
        <trans-unit id="f47ae1f25d416955ab5b35ad58b6d952ed341297" translate="yes" xml:space="preserve">
          <source>Do not include the default library file (&lt;code&gt;lib.d.ts&lt;/code&gt;).</source>
          <target state="translated">デフォルトのライブラリファイル（ &lt;code&gt;lib.d.ts&lt;/code&gt; ）は含めないでください。</target>
        </trans-unit>
        <trans-unit id="0d8700379392a841b4a989a2aedc6ee39cc22535" translate="yes" xml:space="preserve">
          <source>Do not report errors on unreachable code.</source>
          <target state="translated">到達不可能なコードでエラーを報告しないでください。</target>
        </trans-unit>
        <trans-unit id="e15fbdc059493fca2d963af5c43ecf0c0d7a9902" translate="yes" xml:space="preserve">
          <source>Do not report errors on unused labels.</source>
          <target state="translated">未使用のラベルにはエラーを報告しないでください。</target>
        </trans-unit>
        <trans-unit id="566fc4907f5c0c600bf0a19df75cc66685e5a833" translate="yes" xml:space="preserve">
          <source>Do not resolve symlinks to their real path; treat a symlinked file like a real one.</source>
          <target state="translated">シンボリックリンクを実際のパスに解決しないでください。</target>
        </trans-unit>
        <trans-unit id="f7c490d4d3e51d3eaf23f688f0c04328a2f1e119" translate="yes" xml:space="preserve">
          <source>Do not truncate error messages.</source>
          <target state="translated">エラーメッセージは切り捨てないでください。</target>
        </trans-unit>
        <trans-unit id="de81d23a68639d446e1d87128f4ef58b96239449" translate="yes" xml:space="preserve">
          <source>Do not use namespaces in modules</source>
          <target state="translated">モジュールで名前空間を使用しない</target>
        </trans-unit>
        <trans-unit id="4bcbf5a1fc2c5b15cdcbd417c596ae653a2554d0" translate="yes" xml:space="preserve">
          <source>Do you need a build pipeline with multiple potential outputs? Use &lt;code&gt;babel&lt;/code&gt; for transpiling and &lt;code&gt;tsc&lt;/code&gt; for type checking</source>
          <target state="translated">複数の潜在的な出力を備えたビルドパイプラインが必要ですか？使用 &lt;code&gt;babel&lt;/code&gt; transpilingとのための &lt;code&gt;tsc&lt;/code&gt; 型チェックのために</target>
        </trans-unit>
        <trans-unit id="9c1bd4c5b18a5e7128a31d98a66a29dfc33c9ab2" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts</source>
          <target state="translated">すべきこととすべきでないこと</target>
        </trans-unit>
        <trans-unit id="719ef97fc832b36afac23fa78d5c08cea2bf6141" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Generics</source>
          <target state="translated">すべきこととすべきでないこと：ジェネリック</target>
        </trans-unit>
        <trans-unit id="a51c5dd50f698ff95f77e37efad482a71ac91486" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Optional Parameters in Callbacks</source>
          <target state="translated">すべきこととすべきでないこと：コールバックのオプションパラメータ</target>
        </trans-unit>
        <trans-unit id="2db0d779491e142ea96422450aabb72ea9596eb7" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Ordering</source>
          <target state="translated">すべきこととすべきでないこと：順序付け</target>
        </trans-unit>
        <trans-unit id="7d768f81a860ccede1d11160fcbc58466d96e618" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Overloads and Callbacks</source>
          <target state="translated">すべきこととすべきでないこと：オーバーロードとコールバック</target>
        </trans-unit>
        <trans-unit id="7b5ad4c0d887c26ae55bb8c0b3d5849755f0038c" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Return Types of Callbacks</source>
          <target state="translated">すべきこととすべきでないこと：コールバックの戻り値のタイプ</target>
        </trans-unit>
        <trans-unit id="77f700abeac2aeb953e0842c2152d024b8f203e3" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Use Optional Parameters</source>
          <target state="translated">すべきこととすべきでないこと：オプションのパラメータを使用する</target>
        </trans-unit>
        <trans-unit id="ade57914de371d49ae2e67dcf398d7ca7cd0c7e5" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Use Union Types</source>
          <target state="translated">すべきこととすべきでないこと：ユニオンタイプを使用する</target>
        </trans-unit>
        <trans-unit id="bbfd2cbcdd441b33e2a5bbad3336a20b3defd13a" translate="yes" xml:space="preserve">
          <source>Do's and Don'ts</source>
          <target state="translated">してはいけないこととしてはいけないこと</target>
        </trans-unit>
        <trans-unit id="acc9e9cd405cd7ed7a8fcb091e91a562cac25433" translate="yes" xml:space="preserve">
          <source>Documentation describing how to &lt;code&gt;require&lt;/code&gt; or import the library</source>
          <target state="translated">ライブラリを &lt;code&gt;require&lt;/code&gt; またはインポートする方法を説明したドキュメント</target>
        </trans-unit>
        <trans-unit id="3bbfdc360214d58c7cb91ac8521019e85f36e4d8" translate="yes" xml:space="preserve">
          <source>Documentation for UMD libraries will also often demonstrate a &amp;ldquo;Using in Node.js&amp;rdquo; example showing &lt;code&gt;require&lt;/code&gt;, and a &amp;ldquo;Using in the browser&amp;rdquo; example showing using a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to load the script.</source>
          <target state="translated">UMDライブラリのドキュメントで &lt;code&gt;require&lt;/code&gt; 、requireを示す「Node.js での使用」の例と、 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグを使用してスクリプトをロードすることを示す「ブラウザでの使用」の例もよく示されます。</target>
        </trans-unit>
        <trans-unit id="a885ffddfd2d0e82b05e37f87bbdf798e4f9f6d4" translate="yes" xml:space="preserve">
          <source>Does it add a global object? Does it use &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;export&lt;/code&gt; statements?</source>
          <target state="translated">グローバルオブジェクトを追加しますか？ &lt;code&gt;require&lt;/code&gt; または &lt;code&gt;import&lt;/code&gt; / &lt;code&gt;export&lt;/code&gt; ステートメントを使用していますか？</target>
        </trans-unit>
        <trans-unit id="24a9672278fb4d7400c1863d3b7c6f36d8ac8ae1" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t be intimidated by the number of steps here - TypeScript is still only jumping up directories twice at steps (9) and (17). This is really no more complex than what Node.js itself is doing.</source>
          <target state="translated">ここでの手順の数に怯えないでください-TypeScriptは、手順（9）と（17）で2回だけディレクトリをジャンプします。これは、Node.js自体が行っていることよりも実際には複雑ではありません。</target>
        </trans-unit>
        <trans-unit id="1c8722b1128de0f74ea224044ed5056ae0d0f337" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t worry about ordering the files you pass on the commandline - &lt;code&gt;tsc&lt;/code&gt; will re-order them if needed so that dependencies are always built first.</source>
          <target state="translated">コマンドラインで渡すファイルの順序を気にしないでください- 依存関係が常に最初に構築されるように、 &lt;code&gt;tsc&lt;/code&gt; は必要に応じてそれらを並べ替えます。</target>
        </trans-unit>
        <trans-unit id="c119e0650ca90fa2b62e09ff44c7b5ae64f45581" translate="yes" xml:space="preserve">
          <source>Dotted names in type guards</source>
          <target state="translated">タイプガードのドット名</target>
        </trans-unit>
        <trans-unit id="ccdea752338ea9ee00074218ee9537a9bfdb03c3" translate="yes" xml:space="preserve">
          <source>Dotted property for types with string index signatures</source>
          <target state="translated">文字列インデックスシグネチャを持つ型のドットプロパティ</target>
        </trans-unit>
        <trans-unit id="e035b7411ed359c6cdcd7655c199afa4eea32876" translate="yes" xml:space="preserve">
          <source>Downlevel Async Functions</source>
          <target state="translated">ダウンレベル非同期関数</target>
        </trans-unit>
        <trans-unit id="183506505f400de899633b4af1eabf4c89a43b4a" translate="yes" xml:space="preserve">
          <source>Downlevel Iteration - &lt;code&gt;downlevelIteration&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;downlevelIteration&lt;/code&gt; 反復-downlevelIteration</target>
        </trans-unit>
        <trans-unit id="294cb786a27af75c6b7bfcf3924fee299a4870ec" translate="yes" xml:space="preserve">
          <source>Downleveling is TypeScript&amp;rsquo;s term for transpiling to an older version of JavaScript. This flag is to enable support for a more accurate implementation of how modern JavaScript iterates through new concepts in older JavaScript runtimes.</source>
          <target state="translated">ダウンレベリングは、古いバージョンのJavaScriptにトランスパイルするためのTypeScriptの用語です。このフラグは、最新のJavaScriptが古いJavaScriptランタイムの新しい概念を反復処理する方法のより正確な実装のサポートを有効にするためのものです。</target>
        </trans-unit>
        <trans-unit id="d5cabcaa6a9d5f4be82b1397ad3c7fd26169c044" translate="yes" xml:space="preserve">
          <source>Download the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/scripts/VSDevMode.ps1&quot;&gt;VSDevMode.ps1&lt;/a&gt; script.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/scripts/VSDevMode.ps1&quot;&gt;VSDevMode.ps1&lt;/a&gt;スクリプトをダウンロードします。</target>
        </trans-unit>
        <trans-unit id="9b4592f9ae45a647155e857c8bbbe5e38c83f01e" translate="yes" xml:space="preserve">
          <source>Downloading</source>
          <target state="translated">Downloading</target>
        </trans-unit>
        <trans-unit id="984d20c7f5194c7c76c4882260c3e8e0fde40023" translate="yes" xml:space="preserve">
          <source>Due to a bug, the following construct was previously allowed in TypeScript:</source>
          <target state="translated">バグのため、以前は以下のような構文がTypeScriptで許可されていました。</target>
        </trans-unit>
        <trans-unit id="3c5d9cd03387fb41a856eb94a3f12c1e7c45d2c1" translate="yes" xml:space="preserve">
          <source>Duo</source>
          <target state="translated">Duo</target>
        </trans-unit>
        <trans-unit id="db11c375055a24f360ae47b840505b64422c9a27" translate="yes" xml:space="preserve">
          <source>During development of this feature, we discovered a large number of inherently unsafe class hierarchies, including some in the DOM. Because of this, the setting only applies to functions written in &lt;em&gt;function&lt;/em&gt; syntax, not to those in &lt;em&gt;method&lt;/em&gt; syntax:</source>
          <target state="translated">この機能の開発中に、DOM内の一部を含む、本質的に安全でないクラス階層が多数発見されました。このため、この設定は&lt;em&gt;関数&lt;/em&gt;構文で記述された関数にのみ適用され、&lt;em&gt;メソッド&lt;/em&gt;構文の&lt;em&gt;関数に&lt;/em&gt;は適用されません。</target>
        </trans-unit>
        <trans-unit id="39a8e581f6169ec0a9b5700af7954883b503baa0" translate="yes" xml:space="preserve">
          <source>During type argument inference in TypeScript 3.4, for a call to a generic function that returns a function type, TypeScript &lt;em&gt;will&lt;/em&gt;, as appropriate, propagate type parameters from generic function arguments onto the resulting function type.</source>
          <target state="translated">TypeScript 3.4での型引数の推論中に、関数型を返すジェネリック関数の呼び出しの場合、TypeScript &lt;em&gt;は&lt;/em&gt;、必要に応じて、型パラメーターをジェネリック関数引数から結果の関数型に伝達します。</target>
        </trans-unit>
        <trans-unit id="d9d2b88aa61f766d2be10ae43782a97a76b6067a" translate="yes" xml:space="preserve">
          <source>Dynamic &lt;code&gt;import&lt;/code&gt; expressions are a new feature and part of ECMAScript that allows users to asynchronously request a module at any arbitrary point in your program.</source>
          <target state="translated">動的 &lt;code&gt;import&lt;/code&gt; 式はECMAScriptの新機能であり、ユーザーがプログラム内の任意のポイントで非同期にモジュールを要求できるようにします。</target>
        </trans-unit>
        <trans-unit id="d3eb3dff1f243ca444cd0f21c8fa73f06b676b18" translate="yes" xml:space="preserve">
          <source>Dynamic Import Expressions</source>
          <target state="translated">動的インポート式</target>
        </trans-unit>
        <trans-unit id="65d07d2547264048b907ca688317344223d5a0bb" translate="yes" xml:space="preserve">
          <source>Dynamic Module Loading in Node.js</source>
          <target state="translated">Node.jsでの動的モジュールロード</target>
        </trans-unit>
        <trans-unit id="e67a2edba452a5455e675d6f3d31c528be815de5" translate="yes" xml:space="preserve">
          <source>ECMA-262 Standard</source>
          <target state="translated">ECMA-262規格</target>
        </trans-unit>
        <trans-unit id="728508cddb478117297b77baabcf7bb4bfc6cd00" translate="yes" xml:space="preserve">
          <source>ECMAScript 2015 (also known as ES2015, ECMAScript 6, and ES6), CommonJS, and RequireJS have similar notions of &lt;em&gt;importing&lt;/em&gt; a &lt;em&gt;module&lt;/em&gt;. In JavaScript CommonJS (Node.js), for example, you would write</source>
          <target state="translated">ECMAScript 2015（ES2015、ECMAScript 6、ES6とも呼ばれます）、CommonJS、およびRequireJSには、&lt;em&gt;モジュール&lt;/em&gt;の&lt;em&gt;インポート&lt;/em&gt;に関する同様の概念があり&lt;em&gt;ます&lt;/em&gt;。たとえば、JavaScript CommonJS（Node.js）では、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="0fa32652049aa2b5542973c2441565a7dd912fa2" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 added several new iteration primitives: the &lt;code&gt;for / of&lt;/code&gt; loop (&lt;code&gt;for (el of arr)&lt;/code&gt;), Array spread (&lt;code&gt;[a, ...b]&lt;/code&gt;), argument spread (&lt;code&gt;fn(...args)&lt;/code&gt;), and &lt;code&gt;Symbol.iterator&lt;/code&gt;. &lt;code&gt;--downlevelIteration&lt;/code&gt; allows for these iteration primitives to be used more accurately in ES5 environments if a &lt;code&gt;Symbol.iterator&lt;/code&gt; implementation is present.</source>
          <target state="translated">ECMAScript 6は、いくつかの新しい反復プリミティブを追加しました： &lt;code&gt;for / of&lt;/code&gt; loop（ &lt;code&gt;for (el of arr)&lt;/code&gt; ）、Array Spread（ &lt;code&gt;[a, ...b]&lt;/code&gt; ）、argument Spread（ &lt;code&gt;fn(...args)&lt;/code&gt; ）、 &lt;code&gt;Symbol.iterator&lt;/code&gt; 。 &lt;code&gt;--downlevelIteration&lt;/code&gt; を使用すると、 &lt;code&gt;Symbol.iterator&lt;/code&gt; 実装が存在する場合、これらの反復プリミティブをES5環境でより正確に使用できます。</target>
        </trans-unit>
        <trans-unit id="66e029ab9fd3fb22e4e3981b8b4649135674638a" translate="yes" xml:space="preserve">
          <source>ECMAScript Private Fields</source>
          <target state="translated">ECMAScript プライベートフィールド</target>
        </trans-unit>
        <trans-unit id="3e52a38a1db2363571bfdfdb94baa4cbfd95e124" translate="yes" xml:space="preserve">
          <source>ES Module Interop - &lt;code&gt;esModuleInterop&lt;/code&gt;</source>
          <target state="translated">ESモジュール相互運用 &lt;code&gt;esModuleInterop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f85cdebb2ea7d4e839607ea71d7d48e0db5d1567" translate="yes" xml:space="preserve">
          <source>ES2015 does not have a means for declaring properties on classes. Properties are dynamically assigned, just like object literals.</source>
          <target state="translated">ES2015には、クラスにプロパティを宣言する手段がありません。プロパティは、オブジェクトリテラルと同様に動的に割り当てられます。</target>
        </trans-unit>
        <trans-unit id="8f11e274662541f2c8e0e3cb8196626ffc1b7d1e" translate="yes" xml:space="preserve">
          <source>ES6 &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; declarations are now supported when targeting ES3 and ES5.</source>
          <target state="translated">ES3およびES5をターゲットとする場合、ES6の &lt;code&gt;let&lt;/code&gt; および &lt;code&gt;const&lt;/code&gt; 宣言がサポートされるようになりました。</target>
        </trans-unit>
        <trans-unit id="f9d8a7611370241de60b894de016326924a7a9e7" translate="yes" xml:space="preserve">
          <source>ES6 Modules</source>
          <target state="translated">ES6モジュール</target>
        </trans-unit>
        <trans-unit id="e2acc8bb5a67f66241c722af8d11c013fb591c49" translate="yes" xml:space="preserve">
          <source>ES6 generators</source>
          <target state="translated">ES6ジェネレータ</target>
        </trans-unit>
        <trans-unit id="ed61ecf2ad6576a5906a380e425433052f29a51a" translate="yes" xml:space="preserve">
          <source>ES6 introduces escapes that allow users to represent a Unicode codepoint using just a single escape.</source>
          <target state="translated">ES6 にはエスケープが導入されており、単一のエスケープを使って Unicode コードポイントを表現することができます。</target>
        </trans-unit>
        <trans-unit id="facf2ab431b3ab3e7ec6da17f65766fba3092531" translate="yes" xml:space="preserve">
          <source>ES7 exponentiation operator</source>
          <target state="translated">ES7指数演算子</target>
        </trans-unit>
        <trans-unit id="df1c0c4164faa864b6980e867e23ee2da1e921b7" translate="yes" xml:space="preserve">
          <source>Each enum member has a value associated with it which can be either &lt;em&gt;constant&lt;/em&gt; or &lt;em&gt;computed&lt;/em&gt;. An enum member is considered constant if:</source>
          <target state="translated">各列挙型メンバーには、&lt;em&gt;定数&lt;/em&gt;または&lt;em&gt;計算され&lt;/em&gt;た値のいずれかが関連付けられています。次の場合、列挙型メンバーは定数と見なされます。</target>
        </trans-unit>
        <trans-unit id="5e4c52e3c0a22643b225662844bb284bc77facc8" translate="yes" xml:space="preserve">
          <source>Each module can optionally export a &lt;code&gt;default&lt;/code&gt; export. Default exports are marked with the keyword &lt;code&gt;default&lt;/code&gt;; and there can only be one &lt;code&gt;default&lt;/code&gt; export per module. &lt;code&gt;default&lt;/code&gt; exports are imported using a different import form.</source>
          <target state="translated">各モジュールはオプションで &lt;code&gt;default&lt;/code&gt; エクスポートをエクスポートできます。デフォルトのエクスポートは、キーワード &lt;code&gt;default&lt;/code&gt; でマークされます。また、モジュールごとに &lt;code&gt;default&lt;/code&gt; エクスポートは1 つだけです。 &lt;code&gt;default&lt;/code&gt; エクスポートは、別のインポートフォームを使用してインポートされます。</target>
        </trans-unit>
        <trans-unit id="1854fec7a183b17dc9b4b01211c91e48aea1794a" translate="yes" xml:space="preserve">
          <source>Each of these declaration forms creates a new type name.</source>
          <target state="translated">これらの宣言フォームのそれぞれが新しい型名を作成します。</target>
        </trans-unit>
        <trans-unit id="e60fbc5aa90c5637a80cca5bb6a944053a0e909a" translate="yes" xml:space="preserve">
          <source>Each step represents a move towards a safer type-system, but not every project needs that level of verification.</source>
          <target state="translated">各ステップは、より安全なタイプシステムへの移行を表していますが、すべてのプロジェクトがそのレベルの検証を必要としているわけではありません。</target>
        </trans-unit>
        <trans-unit id="b86f360c4781ee31be3d35dcc610cf923afd132b" translate="yes" xml:space="preserve">
          <source>Each type of major library structuring pattern has a corresponding file in the &lt;a href=&quot;templates&quot;&gt;Templates&lt;/a&gt; section. You can start with these templates to help you get going faster.</source>
          <target state="translated">主要なライブラリ構造化パターンの各タイプには、[ &lt;a href=&quot;templates&quot;&gt;テンプレート]&lt;/a&gt;セクションに対応するファイルがあります。これらのテンプレートを使用して、作業を迅速化できます。</target>
        </trans-unit>
        <trans-unit id="2e038538a33dfc2af3364ce4ef765b965c2e718a" translate="yes" xml:space="preserve">
          <source>Early Benefits</source>
          <target state="translated">早期特典</target>
        </trans-unit>
        <trans-unit id="b122bd4aba545fcb88070e3be4ef84508e72d3b0" translate="yes" xml:space="preserve">
          <source>Editing the package.json</source>
          <target state="translated">package.jsonの編集</target>
        </trans-unit>
        <trans-unit id="ffd303c2b780c5345fb91f72058772c5f0edd26f" translate="yes" xml:space="preserve">
          <source>Editors like Visual Studio and Visual Studio Code can automatically apply quick fixes, refactorings, and other transformations like automatically importing values from other modules. These transformations are powered by TypeScript, and older versions of TypeScript unconditionally added semicolons to the end of every statement; unfortunately, this disagreed with many users&amp;rsquo; style guidelines, and many users were displeased with the editor inserting semicolons.</source>
          <target state="translated">Visual StudioやVisual Studio Codeなどのエディターは、クイックフィックス、リファクタリング、および他のモジュールからの値の自動インポートなどの他の変換を自動的に適用できます。これらの変換はTypeScriptを利用しており、古いバージョンのTypeScriptは無条件にすべてのステートメントの最後にセミコロンを追加しました。残念ながら、これは多くのユーザーのスタイルガイドラインに同意せず、多くのユーザーはセミコロンを挿入するエディターに不満を抱いていました。</target>
        </trans-unit>
        <trans-unit id="ab2fc66180c7c3d32691e8c42f8df3300e931653" translate="yes" xml:space="preserve">
          <source>Either the constructor function of the class for a static member, or the prototype of the class for an instance member.</source>
          <target state="translated">スタティック・メンバの場合はクラスのコンストラクタ関数、インスタンス・メンバの場合はクラスのプロトタイプ。</target>
        </trans-unit>
        <trans-unit id="0871854bfc9d5eb95db51d532c4a4da986a587e1" translate="yes" xml:space="preserve">
          <source>Elements in the array binding pattern that have no match in the array literal are required to have a default value in the array binding pattern and are automatically added to the array literal type.</source>
          <target state="translated">配列リテラルにマッチしない要素は、配列バインディングパターンでデフォルト値を持つ必要があり、配列リテラル型に自動的に追加されます。</target>
        </trans-unit>
        <trans-unit id="d77d85d60ae04f1f62d384d542f348cbe2876ff0" translate="yes" xml:space="preserve">
          <source>Embedding Expressions</source>
          <target state="translated">式の埋め込み</target>
        </trans-unit>
        <trans-unit id="596bc3c5e7f94b3b0596259252b4462615ba5b98" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;__importStar&lt;/code&gt; and &lt;code&gt;__importDefault&lt;/code&gt; helpers for runtime babel ecosystem compatibility and enable &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; for typesystem compatibility.</source>
          <target state="translated">EMIT &lt;code&gt;__importStar&lt;/code&gt; と &lt;code&gt;__importDefault&lt;/code&gt; ランタイムバベルエコシステムの互換性のためのヘルパーと有効 &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; 型システムとの互換性のために。</target>
        </trans-unit>
        <trans-unit id="123d5430b7726bc1ca6fdb384bc205c8fa112251" translate="yes" xml:space="preserve">
          <source>Emit BOM - &lt;code&gt;emitBOM&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;emitBOM&lt;/code&gt; - emitBOM</target>
        </trans-unit>
        <trans-unit id="b82eac2f5a8d4b5a64f3e121a2d0286cb7295a10" translate="yes" xml:space="preserve">
          <source>Emit Declaration Only - &lt;code&gt;emitDeclarationOnly&lt;/code&gt;</source>
          <target state="translated">宣言のみを &lt;code&gt;emitDeclarationOnly&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26ca9b8f663272a641132bd7279ee178b83d3fa3" translate="yes" xml:space="preserve">
          <source>Emit Decorator Metadata - &lt;code&gt;emitDecoratorMetadata&lt;/code&gt;</source>
          <target state="translated">デコレータメタデータの &lt;code&gt;emitDecoratorMetadata&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10fd7d2a0af6ba17c8a5d6662cb400314be7d895" translate="yes" xml:space="preserve">
          <source>Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.</source>
          <target state="translated">出力ファイルの先頭に UTF-8 バイトオーダーマーク(BOM)を表示します。</target>
        </trans-unit>
        <trans-unit id="53b14d1fa9901ab52b3d302030734ec92bfda008" translate="yes" xml:space="preserve">
          <source>Emit a single file with source maps instead of having a separate file.</source>
          <target state="translated">別々のファイルを持つのではなく、ソース マップを含む単一のファイルを送信します。</target>
        </trans-unit>
        <trans-unit id="87aee0db862567627436ed01449478f0361912f7" translate="yes" xml:space="preserve">
          <source>Emit all of the output files in &lt;code&gt;built&lt;/code&gt; (with &lt;code&gt;outDir&lt;/code&gt;).</source>
          <target state="translated">すべての出力ファイルを &lt;code&gt;built&lt;/code&gt; 出力します（ &lt;code&gt;outDir&lt;/code&gt; を使用）。</target>
        </trans-unit>
        <trans-unit id="6ac823149db4776d1721774a8881dd70ce3fbb97" translate="yes" xml:space="preserve">
          <source>Emit class fields with ECMAScript-standard semantics.</source>
          <target state="translated">ECMAScript 標準のセマンティクスでクラスフィールドを送信します。</target>
        </trans-unit>
        <trans-unit id="41ad8902099d4f51e2a118572dcabdcda9aa3360" translate="yes" xml:space="preserve">
          <source>Emit design-type metadata for decorated declarations in source. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2577&quot;&gt;issue #2577&lt;/a&gt; for details.</source>
          <target state="translated">ソース内の装飾された宣言のデザインタイプメタデータを出力します。詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2577&quot;&gt;問題＃2577&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ca3085fd048897dd750ce3fb153c2e815abe1acf" translate="yes" xml:space="preserve">
          <source>Emit the source alongside the sourcemaps within a single file; requires &lt;code&gt;--inlineSourceMap&lt;/code&gt; or &lt;code&gt;--sourceMap&lt;/code&gt; to be set.</source>
          <target state="translated">1つのファイル内のソースマップと一緒にソースを放出します。 &lt;code&gt;--inlineSourceMap&lt;/code&gt; または &lt;code&gt;--sourceMap&lt;/code&gt; を設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="b327d3b6deafdd67337cc0d9e334080a73b07f46" translate="yes" xml:space="preserve">
          <source>Empty Types</source>
          <target state="translated">空の型</target>
        </trans-unit>
        <trans-unit id="07885f70bcc0b163283a8d21b81002971b80cbe8" translate="yes" xml:space="preserve">
          <source>Enable all strict type checking options.</source>
          <target state="translated">すべての厳格な型チェックオプションを有効にします。</target>
        </trans-unit>
        <trans-unit id="f3f87c2518fb86141f76c027d8adadd8fdd9cf78" translate="yes" xml:space="preserve">
          <source>Enable incremental compilation by reading/writing information from prior compilations to a file on disk. This file is controlled by the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target state="translated">以前のコンパイルからディスク上のファイルに情報を読み書きすることにより、インクリメンタルコンパイルを有効にします。このファイルは &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; フラグによって制御されます。</target>
        </trans-unit>
        <trans-unit id="29470d5b922e340851c6d198cc824890a7ae92da" translate="yes" xml:space="preserve">
          <source>Enable stricter checking of the &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; methods on functions.</source>
          <target state="translated">関数の &lt;code&gt;bind&lt;/code&gt; 、 &lt;code&gt;call&lt;/code&gt; 、および &lt;code&gt;apply&lt;/code&gt; メソッドのより厳密なチェックを有効にします。</target>
        </trans-unit>
        <trans-unit id="91f7049440bfb40ca1c47e9547370380c5c3f2e9" translate="yes" xml:space="preserve">
          <source>Enable the &lt;code&gt;jsx&lt;/code&gt; option</source>
          <target state="translated">&lt;code&gt;jsx&lt;/code&gt; オプションを有効にする</target>
        </trans-unit>
        <trans-unit id="d4a3eed1cf65a963ddf3f9b30f57ca9cb73fcaa1" translate="yes" xml:space="preserve">
          <source>Enables &lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot;&gt;experimental support for decorators&lt;/a&gt;, which is in stage 2 of the TC39 standardization process.</source>
          <target state="translated">TC39標準化プロセスのステージ2にある&lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot;&gt;デコレータの実験的サポートを&lt;/a&gt;有効にします。</target>
        </trans-unit>
        <trans-unit id="da566f675009da0e991b7854614c23e919fa5b97" translate="yes" xml:space="preserve">
          <source>Enables experimental support for ES decorators.</source>
          <target state="translated">ESデコレータの実験的なサポートを可能にします。</target>
        </trans-unit>
        <trans-unit id="e1b4a6f5d796dc27b38b366249d014d055262aaf" translate="yes" xml:space="preserve">
          <source>Enables experimental support for emitting type metadata for decorators which works with the module &lt;a href=&quot;https://www.npmjs.com/package/reflect-metadata&quot;&gt;&lt;code&gt;reflect-metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">モジュール&lt;a href=&quot;https://www.npmjs.com/package/reflect-metadata&quot;&gt; &lt;code&gt;reflect-metadata&lt;/code&gt; &lt;/a&gt;で動作するデコレータのタイプメタデータを発行するための実験的なサポートを有効にします。</target>
        </trans-unit>
        <trans-unit id="0d931513b0509143ecae93fe072c8701ba3bef1a" translate="yes" xml:space="preserve">
          <source>Enables the generation of &lt;a href=&quot;https://developer.mozilla.org/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;sourcemap files&lt;/a&gt;. These files allow debuggers and other tools to display the original TypeScript source code when actually working with the emitted JavaScript files. Source map files are emitted as &lt;code&gt;.js.map&lt;/code&gt; (or &lt;code&gt;.jsx.map&lt;/code&gt;) files next to the corresponding &lt;code&gt;.js&lt;/code&gt; output file.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;ソースマップファイル&lt;/a&gt;の生成を有効にします。これらのファイルを使用すると、デバッガーやその他のツールで、発行されたJavaScriptファイルを実際に操作するときに元のTypeScriptソースコードを表示できます。ソースマップファイルは、対応する &lt;code&gt;.js&lt;/code&gt; 出力ファイルの隣に &lt;code&gt;.js.map&lt;/code&gt; （または &lt;code&gt;.jsx.map&lt;/code&gt; ）ファイルとして出力されます。</target>
        </trans-unit>
        <trans-unit id="c4ba38450ee027bba050ddc6f6958b0dc5a751f2" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;--declarationMap&lt;/code&gt; alongside &lt;code&gt;--declaration&lt;/code&gt; causes the compiler to emit &lt;code&gt;.d.ts.map&lt;/code&gt; files alongside the output &lt;code&gt;.d.ts&lt;/code&gt; files. Language Services can also now understand these map files, and uses them to map declaration-file based definition locations to their original source, when available.</source>
          <target state="translated">&lt;code&gt;--declarationMap&lt;/code&gt; と一緒に &lt;code&gt;--declaration&lt;/code&gt; Mapを有効にすると、コンパイラーは &lt;code&gt;.d.ts.map&lt;/code&gt; ファイルを出力 &lt;code&gt;.d.ts&lt;/code&gt; ファイルとともに出力します。言語サービスもこれらのマップファイルを理解できるようになり、それらを使用して宣言ファイルベースの定義の場所を元のソースにマップします（可能な場合）。</target>
        </trans-unit>
        <trans-unit id="72c9407930092256221610ac7ab395e789b77dfa" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;--strict&lt;/code&gt; enables &lt;code&gt;--noImplicitAny&lt;/code&gt;, &lt;code&gt;--noImplicitThis&lt;/code&gt;, &lt;code&gt;--alwaysStrict&lt;/code&gt;, &lt;code&gt;--strictBindCallApply&lt;/code&gt;, &lt;code&gt;--strictNullChecks&lt;/code&gt;, &lt;code&gt;--strictFunctionTypes&lt;/code&gt; and &lt;code&gt;--strictPropertyInitialization&lt;/code&gt;.</source>
          <target state="translated">有効 &lt;code&gt;--strict&lt;/code&gt; することができます &lt;code&gt;--noImplicitAny&lt;/code&gt; 、 &lt;code&gt;--noImplicitThis&lt;/code&gt; 、 &lt;code&gt;--alwaysStrict&lt;/code&gt; 、 &lt;code&gt;--strictBindCallApply&lt;/code&gt; 、 &lt;code&gt;--strictNullChecks&lt;/code&gt; 、 &lt;code&gt;--strictFunctionTypes&lt;/code&gt; と &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e34ed7ff6f716b586d5cdcceccbaca058f72fc3" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;esModuleInterop&lt;/code&gt; will also enable &lt;a href=&quot;#allowSyntheticDefaultImports&quot;&gt;&lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有効 &lt;code&gt;esModuleInterop&lt;/code&gt; することも可能になります&lt;a href=&quot;#allowSyntheticDefaultImports&quot;&gt; &lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b00df6ae9f4549f7d57c88d20b001737628bc763" translate="yes" xml:space="preserve">
          <source>Enabling the option allows importing JSON, and validating the types in that JSON file.</source>
          <target state="translated">このオプションを有効にすると、JSONをインポートし、そのJSONファイルの型を検証することができます。</target>
        </trans-unit>
        <trans-unit id="0c09f58749451934cce8c0be5ef42b0d3dbd75b5" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;code&gt;--init&lt;/code&gt; output</source>
          <target state="translated">拡張された &lt;code&gt;--init&lt;/code&gt; 出力</target>
        </trans-unit>
        <trans-unit id="c5a806eb89f7dea65ab700be49a0d4d559514188" translate="yes" xml:space="preserve">
          <source>Ensure TypeScript can determine where to find the outputs of the referenced project to compile project.</source>
          <target state="translated">TypeScriptがプロジェクトをコンパイルする際に、参照されたプロジェクトの出力がどこにあるかを判断できるようにします。</target>
        </trans-unit>
        <trans-unit id="90ebaa427f44ae4c263b34e0e48d73b34fd5b03c" translate="yes" xml:space="preserve">
          <source>Ensure non-undefined class properties are initialized in the constructor. This option requires &lt;code&gt;--strictNullChecks&lt;/code&gt; be enabled in order to take effect.</source>
          <target state="translated">未定義でないクラスプロパティがコンストラクターで初期化されていることを確認してください。このオプションを有効にするには、 &lt;code&gt;--strictNullChecks&lt;/code&gt; を有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="9a3144235c8641b90eb9884c83f0c03e49fe7f2e" translate="yes" xml:space="preserve">
          <source>Ensures that your files are parsed in the ECMAScript strict mode, and emit &amp;ldquo;use strict&amp;rdquo; for each source file.</source>
          <target state="translated">ファイルがECMAScriptstrictモードで解析され、ソースファイルごとに「usestrict」が出力されるようにします。</target>
        </trans-unit>
        <trans-unit id="63b63149cd444d6b9da7fe416ce289557f10a9e7" translate="yes" xml:space="preserve">
          <source>Enter Index Type Query or &lt;code&gt;keyof&lt;/code&gt;; An indexed type query &lt;code&gt;keyof T&lt;/code&gt; yields the type of permitted property names for &lt;code&gt;T&lt;/code&gt;. A &lt;code&gt;keyof T&lt;/code&gt; type is considered a subtype of &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">インデックスタイプクエリまたは &lt;code&gt;keyof&lt;/code&gt; を入力してください。インデックス付きタイプのクエリ &lt;code&gt;keyof T&lt;/code&gt; のための許可プロパティ名の種類生み出す &lt;code&gt;T&lt;/code&gt; を。 &lt;code&gt;keyof T&lt;/code&gt; 型のキーは &lt;code&gt;string&lt;/code&gt; のサブタイプと見なされます。</target>
        </trans-unit>
        <trans-unit id="20588ae8e5c269292d35f9dfffa8f2eb3fd3c259" translate="yes" xml:space="preserve">
          <source>Enum</source>
          <target state="translated">Enum</target>
        </trans-unit>
        <trans-unit id="04dd4dbb8815c963d82df0161b050d4d9dafeb1d" translate="yes" xml:space="preserve">
          <source>Enum Member Types</source>
          <target state="translated">列挙メンバタイプ</target>
        </trans-unit>
        <trans-unit id="f3104dd45718e6d1ac6a03b91ae67193ae8361f0" translate="yes" xml:space="preserve">
          <source>Enums</source>
          <target state="translated">Enums</target>
        </trans-unit>
        <trans-unit id="988d8f6199e4b6350a2137c1e9bd419a30312b8e" translate="yes" xml:space="preserve">
          <source>Enums allow a developer to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.</source>
          <target state="translated">列挙型は、開発者が名前付き定数のセットを定義することを可能にします。列挙型を使用することで、意図を文書化したり、異なるケースのセットを作成したりすることが容易になります。TypeScript には、数値ベースの列挙型と文字列ベースの列挙型があります。</target>
        </trans-unit>
        <trans-unit id="f0e0e96cf6626f01df64dec457720adc8996018c" translate="yes" xml:space="preserve">
          <source>Enums allow us to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.</source>
          <target state="translated">列挙型を使用すると、名前付き定数のセットを定義することができます。列挙型を使うことで、意図を文書化したり、異なるケースのセットを作成したりすることが容易になります。TypeScript には、数値ベースの列挙型と文字列ベースの列挙型があります。</target>
        </trans-unit>
        <trans-unit id="446bd29a002c17497b41b96657fcf40bf1d514a6" translate="yes" xml:space="preserve">
          <source>Enums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,</source>
          <target state="translated">列挙型は数値と互換性があり、数値は列挙型と互換性があります。異なる種類の列挙型の列挙型の値は互換性がないとみなされます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="5829a150f7ef6409938f989938645fcde15588e4" translate="yes" xml:space="preserve">
          <source>Enums are one of the few features TypeScript has which is not a type-level extension of JavaScript.</source>
          <target state="translated">列挙型はTypeScriptが持つ数少ない機能の一つで、JavaScriptの型レベルの拡張ではありません。</target>
        </trans-unit>
        <trans-unit id="9611d38688bf1d99ca887b354676cea9ac16e83d" translate="yes" xml:space="preserve">
          <source>Enums are real objects that exist at runtime. For example, the following enum</source>
          <target state="translated">列挙型は実行時に存在する実在のオブジェクトです。例えば、以下のような列挙</target>
        </trans-unit>
        <trans-unit id="aa2b9875683168f991703bdf2407bc70e31110ed" translate="yes" xml:space="preserve">
          <source>Enums are very useful, but some programs don&amp;rsquo;t actually need the generated code and would benefit from simply inlining all instances of enum members with their numeric equivalents. The new &lt;code&gt;const enum&lt;/code&gt; declaration works just like a regular &lt;code&gt;enum&lt;/code&gt; for type safety, but erases completely at compile time.</source>
          <target state="translated">列挙型は非常に便利ですが、一部のプログラムは実際には生成されたコードを必要とせず、列挙型メンバーのすべてのインスタンスを同等の数値で単純にインライン化することでメリットを得られます。新しい &lt;code&gt;const enum&lt;/code&gt; 宣言は、型安全のための通常の &lt;code&gt;enum&lt;/code&gt; と同じように機能しますが、コンパイル時に完全に消去されます。</target>
        </trans-unit>
        <trans-unit id="1efbfb0dab275f1ef5a349fd19a692fb55ff662d" translate="yes" xml:space="preserve">
          <source>Enums at compile time</source>
          <target state="translated">コンパイル時のEnums</target>
        </trans-unit>
        <trans-unit id="91ebfc95d6553fab6dcdd9b37826083250ec08fa" translate="yes" xml:space="preserve">
          <source>Enums at runtime</source>
          <target state="translated">実行時のEnums</target>
        </trans-unit>
        <trans-unit id="a995ff457a717bdb048c8c9232b3366e472f2af1" translate="yes" xml:space="preserve">
          <source>Erased Structural Types</source>
          <target state="translated">消された構造タイプ</target>
        </trans-unit>
        <trans-unit id="b14aa42c384f51c886a258b319db2b853b34f4b0" translate="yes" xml:space="preserve">
          <source>Erased Types</source>
          <target state="translated">消去されたタイプ</target>
        </trans-unit>
        <trans-unit id="d12be1b5b741cc430eaddee58fc5792da5e03257" translate="yes" xml:space="preserve">
          <source>Error for not finding &lt;code&gt;moduleB&lt;/code&gt; as it was not passed.</source>
          <target state="translated">&lt;code&gt;moduleB&lt;/code&gt; れなかったため、moduleBが見つからないためのエラー。</target>
        </trans-unit>
        <trans-unit id="5dbdd5b8b6b60bfdc1de358cfd5636ff3b41ecfd" translate="yes" xml:space="preserve">
          <source>Error messages in Russian:</source>
          <target state="translated">ロシア語でのエラーメッセージ。</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="6f19afca75f8b76cf43de3568bc8609dc8d889e8" translate="yes" xml:space="preserve">
          <source>Errors in .js files with &lt;code&gt;--checkJs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--checkJs&lt;/code&gt; を使用した.jsファイルのエラー</target>
        </trans-unit>
        <trans-unit id="4ceaa96be69ab42f127926b9976ca00d796f12ac" translate="yes" xml:space="preserve">
          <source>Errors which already exist in your codebase, which TypeScript has uncovered because the language has refined its understanding of JavaScript.</source>
          <target state="translated">あなたのコードベースにすでに存在するエラーで、TypeScriptがJavaScriptの理解を深めてきたために発見したものです。</target>
        </trans-unit>
        <trans-unit id="ff7513853508e7c6e3aa07908df2a450a026eb88" translate="yes" xml:space="preserve">
          <source>Evaluation</source>
          <target state="translated">Evaluation</target>
        </trans-unit>
        <trans-unit id="c4995d18bbd28ef5b42bb49d1ba1191de1d44e61" translate="yes" xml:space="preserve">
          <source>Even at this point you can get some great benefits from TypeScript understanding your project. If you open up an editor like &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;VS Code&lt;/a&gt; or &lt;a href=&quot;https://visualstudio.com&quot;&gt;Visual Studio&lt;/a&gt;, you&amp;rsquo;ll see that you can often get some tooling support like completion. You can also catch certain bugs with options like:</source>
          <target state="translated">この時点でさえ、プロジェクトを理解するTypeScriptからいくつかの大きな利益を得ることができます。&lt;a href=&quot;https://code.visualstudio.com&quot;&gt;VS Code&lt;/a&gt;や&lt;a href=&quot;https://visualstudio.com&quot;&gt;Visual Studio&lt;/a&gt;などのエディターを開くと、完了などのツールのサポートが得られることがよくあります。次のようなオプションを使用して特定のバグをキャッチすることもできます。</target>
        </trans-unit>
        <trans-unit id="30bbcbc5524ea12d314a912290ed9ada676d698e" translate="yes" xml:space="preserve">
          <source>Even better, TypeScript will warn you when you make this mistake if you pass the &lt;code&gt;--noImplicitThis&lt;/code&gt; flag to the compiler. It will point out that &lt;code&gt;this&lt;/code&gt; in &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; is of type &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">さらに良いことに、-- &lt;code&gt;--noImplicitThis&lt;/code&gt; フラグをコンパイラーに渡した場合、この間違いをするとTypeScriptが警告を出します。 &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; はany型であることを指摘し &lt;code&gt;any&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="173ad8610f22a569603ffb0f1d0d6365bdf43e93" translate="yes" xml:space="preserve">
          <source>Even though Enums are real objects that exist at runtime, the &lt;code&gt;keyof&lt;/code&gt; keyword works differently than you might expect for typical objects. Instead, use &lt;code&gt;keyof typeof&lt;/code&gt; to get a Type that represents all Enum keys as strings.</source>
          <target state="translated">Enumは実行時に存在する実際のオブジェクトですが、 &lt;code&gt;keyof&lt;/code&gt; キーワードの動作は、一般的なオブジェクトに期待されるものとは異なります。代わりに、 &lt;code&gt;keyof typeof&lt;/code&gt; を使用して、すべてのEnumキーを文字列として表すTypeを取得します。</target>
        </trans-unit>
        <trans-unit id="351b0bfe6af01cc3af80d3c225ca18f3413c36bf" translate="yes" xml:space="preserve">
          <source>Every option is fully explained in the &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;TSConfig Reference&lt;/a&gt;.</source>
          <target state="translated">すべてのオプションについては、&lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;TSConfigリファレンス&lt;/a&gt;で詳しく説明されています。</target>
        </trans-unit>
        <trans-unit id="fce516d03ed65b851ebf38e0525aa5bb18cc7fca" translate="yes" xml:space="preserve">
          <source>Every time the compiler sees a relative module import in a subfolder of one of the &lt;code&gt;rootDirs&lt;/code&gt;, it will attempt to look for this import in each of the entries of &lt;code&gt;rootDirs&lt;/code&gt;.</source>
          <target state="translated">コンパイラは、いずれかの &lt;code&gt;rootDirs&lt;/code&gt; のサブフォルダに相対モジュールインポートを検出するたびに、 &lt;code&gt;rootDirs&lt;/code&gt; の各エントリでこのインポートを検索しようとします。</target>
        </trans-unit>
        <trans-unit id="b6a95cb3eaeb836cfc786e3694e94cec3a8b9a84" translate="yes" xml:space="preserve">
          <source>Everyday Types</source>
          <target state="translated">日常のタイプ</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="7db0747c7372815c3b79f00827a669c7a4dff2d2" translate="yes" xml:space="preserve">
          <source>Example &lt;code&gt;tsconfig.json&lt;/code&gt; files:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; ファイルの例：</target>
        </trans-unit>
        <trans-unit id="678e0ce800d6be194877dbcb671642b8653408c3" translate="yes" xml:space="preserve">
          <source>Example: Effects on &lt;code&gt;for / of&lt;/code&gt;</source>
          <target state="translated">例： &lt;code&gt;for / of&lt;/code&gt; 影響</target>
        </trans-unit>
        <trans-unit id="0a1e2321887c3e9bb33ef80db139e7686530c71b" translate="yes" xml:space="preserve">
          <source>Example: Effects on Array Spreads</source>
          <target state="translated">例。配列のスプレッドへの影響</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="d90ae2c05a80c11c94b6d08fd48a89595af4e49d" translate="yes" xml:space="preserve">
          <source>Examples of Global Libraries</source>
          <target state="translated">グローバルライブラリの例</target>
        </trans-unit>
        <trans-unit id="816ee629d75640df7d32cc7a04c198a2ba361b71" translate="yes" xml:space="preserve">
          <source>Examples of Modular Libraries</source>
          <target state="translated">モジュラーライブラリの例</target>
        </trans-unit>
        <trans-unit id="d278e672973bdd09840c8aa311736e998691e0d6" translate="yes" xml:space="preserve">
          <source>Examples of UMD libraries</source>
          <target state="translated">UMDライブラリの例</target>
        </trans-unit>
        <trans-unit id="713425259fb0fd114e02f534a62ae30601cda2b7" translate="yes" xml:space="preserve">
          <source>Excess Property Checks</source>
          <target state="translated">余剰財産のチェック</target>
        </trans-unit>
        <trans-unit id="8f00aff99521b0b67d7cf2a6f99b9b1382e2bec8" translate="yes" xml:space="preserve">
          <source>Exclude - &lt;code&gt;exclude&lt;/code&gt;</source>
          <target state="translated">除外- &lt;code&gt;exclude&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="547cac401b8bdafefb3c93432b560b402f27bd52" translate="yes" xml:space="preserve">
          <source>Exclude&amp;lt;T,U&amp;gt;</source>
          <target state="translated">Exclude&amp;lt;T,U&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e6d793aeaefda145ae379cd867a6553a054c4ae4" translate="yes" xml:space="preserve">
          <source>Execute Babel from the command line</source>
          <target state="translated">コマンドラインからBabelを実行する</target>
        </trans-unit>
        <trans-unit id="36e4946cdd24644aa9627cc6ffbfecf2fb7124a0" translate="yes" xml:space="preserve">
          <source>Exhaustiveness checking</source>
          <target state="translated">排熱チェック</target>
        </trans-unit>
        <trans-unit id="be111b001bea1086e5ed60f0def95e565522aa10" translate="yes" xml:space="preserve">
          <source>Expansion of rest parameters with tuple types into discrete parameters.</source>
          <target state="translated">タプル型による休息パラメータの離散パラメータへの展開</target>
        </trans-unit>
        <trans-unit id="0f747d8df97d89385abfc342525e23104fc53d2b" translate="yes" xml:space="preserve">
          <source>Expansion of spread expressions with tuple types into discrete arguments.</source>
          <target state="translated">タプル型を持つスプレッド式の離散引数への拡張。</target>
        </trans-unit>
        <trans-unit id="b718f8c3a83788b1b360cc38380401a994fb4892" translate="yes" xml:space="preserve">
          <source>Experimental</source>
          <target state="translated">Experimental</target>
        </trans-unit>
        <trans-unit id="e63f550a4c8e9f47ff813f81f98e044c934b5e77" translate="yes" xml:space="preserve">
          <source>Experimental Decorators - &lt;code&gt;experimentalDecorators&lt;/code&gt;</source>
          <target state="translated">実験デコレータ- &lt;code&gt;experimentalDecorators&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb541c0761ac733bf3e3daebf487a743c08ec49f" translate="yes" xml:space="preserve">
          <source>Experimental support for &lt;code&gt;async&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; 関数の実験的サポート</target>
        </trans-unit>
        <trans-unit id="7f86b7832ad902539ef49647ed1b68f24295f259" translate="yes" xml:space="preserve">
          <source>Explain the effects of important compiler options</source>
          <target state="translated">重要なコンパイラオプションの効果を説明する</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="c2368c03d9c425fa5b1b554196b18d9b35543814" translate="yes" xml:space="preserve">
          <source>Explicit types on &lt;code&gt;defaultProps&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;defaultProps&lt;/code&gt; の明示的な型</target>
        </trans-unit>
        <trans-unit id="7038922b5a5d6db45da593914421a491587b2f7f" translate="yes" xml:space="preserve">
          <source>Explicitly list imported names</source>
          <target state="translated">インポートされた名前を明示的にリストアップ</target>
        </trans-unit>
        <trans-unit id="b4d49c128ea27c0b476f0c2a2de93b85b8758f3c" translate="yes" xml:space="preserve">
          <source>Explore the &lt;a href=&quot;https://www.typescriptlang.org/play#show-examples&quot;&gt;Playground examples&lt;/a&gt;.</source>
          <target state="translated">探検&lt;a href=&quot;https://www.typescriptlang.org/play#show-examples&quot;&gt;遊び場例を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3e4fadb9e370a1e2c0c622c01fc8c77daf93a2c" translate="yes" xml:space="preserve">
          <source>Export</source>
          <target state="translated">Export</target>
        </trans-unit>
        <trans-unit id="ee287a51eb5e0d85cc359b2e80f44c061f51aae0" translate="yes" xml:space="preserve">
          <source>Export Declarations</source>
          <target state="translated">輸出申告</target>
        </trans-unit>
        <trans-unit id="0d00dcedcb60c65ca444794366f3702bd2f190a2" translate="yes" xml:space="preserve">
          <source>Export all as x</source>
          <target state="translated">すべてを x としてエクスポート</target>
        </trans-unit>
        <trans-unit id="3eb5fdc5e694d39f19fe4b7038742fba0274b196" translate="yes" xml:space="preserve">
          <source>Export as close to top-level as possible</source>
          <target state="translated">できるだけトップレベルに近い状態でエクスポート</target>
        </trans-unit>
        <trans-unit id="d426e470cf0b8e87df60e791d67c0cc7797da09b" translate="yes" xml:space="preserve">
          <source>Export statements</source>
          <target state="translated">エクスポートステートメント</target>
        </trans-unit>
        <trans-unit id="b321b13d568f9f33b7a4846fbc6a9d7e3b9d6029" translate="yes" xml:space="preserve">
          <source>Export statements are handy when exports need to be renamed for consumers, so the above example can be written as:</source>
          <target state="translated">エクスポートステートメントは、消費者のためにエクスポートの名前を変更する必要がある場合に便利なので、上の例は次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="f3b534c8bf9a0c462bc4987c3561321862fa8572" translate="yes" xml:space="preserve">
          <source>Exporting a declaration</source>
          <target state="translated">宣言のエクスポート</target>
        </trans-unit>
        <trans-unit id="20ed777374ec9c640b886c9f9410bc59fc7a8afa" translate="yes" xml:space="preserve">
          <source>Exporting a namespace from your module is an example of adding too many layers of nesting. While namespaces sometime have their uses, they add an extra level of indirection when using modules. This can quickly become a pain point for users, and is usually unnecessary.</source>
          <target state="translated">モジュールから名前空間をエクスポートするのは、入れ子のレイヤーを増やしすぎた例です。名前空間には用途があることもありますが、モジュールを使用する際には余分なレベルの間接性を追加してしまいます。これはすぐにユーザーにとって苦痛なポイントとなり、通常は不要です。</target>
        </trans-unit>
        <trans-unit id="33b0e248cae60e2ac77c9d292f495d69dfef3e27" translate="yes" xml:space="preserve">
          <source>Exporting from Modules</source>
          <target state="translated">モジュールからのエクスポート</target>
        </trans-unit>
        <trans-unit id="3f1c3ff321429d2eb6717b5d648a871fa208dfe3" translate="yes" xml:space="preserve">
          <source>Exports of Non-Value Identifiers</source>
          <target state="translated">非値識別子の輸出</target>
        </trans-unit>
        <trans-unit id="79421f7ea94b7e0cba104ffc2178605b08987de2" translate="yes" xml:space="preserve">
          <source>Expression operators</source>
          <target state="translated">式演算子</target>
        </trans-unit>
        <trans-unit id="e03a0c147ab3a0e6973bff36e8c810e9858d8a41" translate="yes" xml:space="preserve">
          <source>Expression operators permit operand types to include &lt;code&gt;null&lt;/code&gt; and/or &lt;code&gt;undefined&lt;/code&gt; but always produce values of non-null and non-undefined types.</source>
          <target state="translated">式演算子を使用すると、オペランドの型に &lt;code&gt;null&lt;/code&gt; や &lt;code&gt;undefined&lt;/code&gt; 型を含めることができますが、常にnull以外の型や未定義の型の値が生成されます。</target>
        </trans-unit>
        <trans-unit id="7764ab55f19ed7e0cf007e50b5bc8b2938b82904" translate="yes" xml:space="preserve">
          <source>Extended Diagnostics - &lt;code&gt;extendedDiagnostics&lt;/code&gt;</source>
          <target state="translated">拡張診断- &lt;code&gt;extendedDiagnostics&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcabbc390e17d15f91473972556065a69ff821df" translate="yes" xml:space="preserve">
          <source>Extending Classes</source>
          <target state="translated">クラスの拡張</target>
        </trans-unit>
        <trans-unit id="464d90ddf01b4a7d7fb2059732ea18c0a56423b4" translate="yes" xml:space="preserve">
          <source>Extending Interfaces</source>
          <target state="translated">インターフェースの拡張</target>
        </trans-unit>
        <trans-unit id="375df0f41528acadecbb25ba2ba1c7a3fb7ba51c" translate="yes" xml:space="preserve">
          <source>Extending a type via intersections</source>
          <target state="translated">交差点を介した型の拡張</target>
        </trans-unit>
        <trans-unit id="b0184e831bfb3d0f17bb14cf78557f4879766c11" translate="yes" xml:space="preserve">
          <source>Extending an interface</source>
          <target state="translated">インターフェースの拡張</target>
        </trans-unit>
        <trans-unit id="70c729194ffb9f8bd9ec475f03a3057bb1e60a4e" translate="yes" xml:space="preserve">
          <source>Extending expressions</source>
          <target state="translated">式の拡張</target>
        </trans-unit>
        <trans-unit id="2c62365e86a53d80330c0805ef1f6ee2b629a938" translate="yes" xml:space="preserve">
          <source>Extends - &lt;code&gt;extends&lt;/code&gt;</source>
          <target state="translated">拡張- &lt;code&gt;extends&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3843d37d93289eadbc1958c41f1c13c309bbf8e" translate="yes" xml:space="preserve">
          <source>Extract&amp;lt;T,U&amp;gt;</source>
          <target state="translated">Extract&amp;lt;T,U&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d9ec862d01090b18ed0a5b1f9fab74b9212f3809" translate="yes" xml:space="preserve">
          <source>Extracts the type of the &lt;a href=&quot;functions#this-parameters&quot;&gt;this&lt;/a&gt; parameter for a function type, or &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type&quot;&gt;unknown&lt;/a&gt; if the function type has no &lt;code&gt;this&lt;/code&gt; parameter.</source>
          <target state="translated">関数タイプの&lt;a href=&quot;functions#this-parameters&quot;&gt;this&lt;/a&gt;パラメーターのタイプを抽出します。関数タイプに &lt;code&gt;this&lt;/code&gt; パラメーターがない場合は&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type&quot;&gt;不明&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="515872ad64c38522409e00410e68ba6e32a29116" translate="yes" xml:space="preserve">
          <source>Extracts the type of the &lt;code&gt;this&lt;/code&gt; parameter of a function type, or &lt;code&gt;unknown&lt;/code&gt; if the function type has no &lt;code&gt;this&lt;/code&gt; parameter.</source>
          <target state="translated">関数型の &lt;code&gt;this&lt;/code&gt; パラメータの型を抽出します。関数型に &lt;code&gt;this&lt;/code&gt; パラメータがない場合は、 &lt;code&gt;unknown&lt;/code&gt; を抽出します。</target>
        </trans-unit>
        <trans-unit id="5580687121fcfefa146981fb36d296bc3f0de348" translate="yes" xml:space="preserve">
          <source>Factories</source>
          <target state="translated">Factories</target>
        </trans-unit>
        <trans-unit id="bead528d19950f71ea30380d09df640a3d7210ca" translate="yes" xml:space="preserve">
          <source>Factory Functions</source>
          <target state="translated">工場機能</target>
        </trans-unit>
        <trans-unit id="4a32e2f9caf4e668d29618328e51a2647e2d967d" translate="yes" xml:space="preserve">
          <source>Faster &lt;code&gt;tsc --watch&lt;/code&gt;</source>
          <target state="translated">より高速な &lt;code&gt;tsc --watch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbdafc5050207465ed19f95ed57e21102e2c0067" translate="yes" xml:space="preserve">
          <source>Faster subsequent builds with the &lt;code&gt;--incremental&lt;/code&gt; flag</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; フラグを使用した後続のビルドの高速化</target>
        </trans-unit>
        <trans-unit id="a29227a71e68767de435c445f3ac1547081655fc" translate="yes" xml:space="preserve">
          <source>Feedback from our community, as well as our own experience, has shown us that leveraging the newest TypeScript features while also accommodating users on the older versions are difficult. TypeScript introduces a new feature called &lt;code&gt;typesVersions&lt;/code&gt; to help accommodate these scenarios.</source>
          <target state="translated">私たちのコミュニティからのフィードバックと私たち自身の経験から、最新のTypeScript機能を活用しながら、古いバージョンのユーザーに対応することは難しいことがわかりました。TypeScriptには、 &lt;code&gt;typesVersions&lt;/code&gt; と呼ばれる新機能が導入され、これらのシナリオに対応するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="812fb4ba4e595ba2544dd885ed6718d2c6cdeed2" translate="yes" xml:space="preserve">
          <source>File Inclusion</source>
          <target state="translated">ファイルの包含</target>
        </trans-unit>
        <trans-unit id="6748207b859ccfa7f82ac49d731d1b27113a3b98" translate="yes" xml:space="preserve">
          <source>File does not exist, move to the second substitution</source>
          <target state="translated">ファイルが存在しない場合は、2番目の置換に移動します。</target>
        </trans-unit>
        <trans-unit id="0fe8300347a5d2fe3f7b4e21e6708ddf628f2eeb" translate="yes" xml:space="preserve">
          <source>File exists. Done.</source>
          <target state="translated">ファイルが存在します。完了しました。</target>
        </trans-unit>
        <trans-unit id="1214946f7d95ef7612951c5654019274eb30d8ea" translate="yes" xml:space="preserve">
          <source>File path</source>
          <target state="translated">ファイルパス</target>
        </trans-unit>
        <trans-unit id="0086a262afcd9e4f6a1dcc9082579481ec576eaf" translate="yes" xml:space="preserve">
          <source>Files - &lt;code&gt;files&lt;/code&gt;</source>
          <target state="translated">ファイル- &lt;code&gt;files&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1b26fa5a34d56fb3e3920fe7c3dc4952d2ae44c" translate="yes" xml:space="preserve">
          <source>Files in &lt;code&gt;src/views&lt;/code&gt; are user code for some UI controls. Files in &lt;code&gt;generated/templates&lt;/code&gt; are UI template binding code auto-generated by a template generator as part of the build. A build step will copy the files in &lt;code&gt;/src/views&lt;/code&gt; and &lt;code&gt;/generated/templates/views&lt;/code&gt; to the same directory in the output. At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as &lt;code&gt;&quot;./template&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src/views&lt;/code&gt; 内のファイルは、一部のUIコントロールのユーザーコードです。 &lt;code&gt;generated/templates&lt;/code&gt; 内のファイルは、ビルドの一部としてテンプレートジェネレーターによって自動生成されたUIテンプレートバインディングコードです。ビルドステップは、 &lt;code&gt;/src/views&lt;/code&gt; および &lt;code&gt;/generated/templates/views&lt;/code&gt; のファイルを出力の同じディレクトリにコピーします。実行時に、ビューはそのテンプレートがその横に存在することを期待できるため、相対名を &lt;code&gt;&quot;./template&quot;&lt;/code&gt; としてインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="944999053b7485f3f5c651758da5734b4f1b2630" translate="yes" xml:space="preserve">
          <source>Files included using &lt;code&gt;&quot;include&quot;&lt;/code&gt; can be filtered using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. However, files included explicitly using the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property are always included regardless of &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;. The &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property defaults to excluding the &lt;code&gt;node_modules&lt;/code&gt;, &lt;code&gt;bower_components&lt;/code&gt;, &lt;code&gt;jspm_packages&lt;/code&gt; and &lt;code&gt;&amp;lt;outDir&amp;gt;&lt;/code&gt; directories when not specified.</source>
          <target state="translated">&lt;code&gt;&quot;include&quot;&lt;/code&gt; を使用して組み込まれたファイルは、 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; プロパティーを使用してフィルターに掛けることができます。ただし、 &lt;code&gt;&quot;files&quot;&lt;/code&gt; プロパティを使用して明示的に含まれるファイルは、 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 関係なく常に含まれます。 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; を除くへのプロパティのデフォルト値を &lt;code&gt;node_modules&lt;/code&gt; 、 &lt;code&gt;bower_components&lt;/code&gt; 、 &lt;code&gt;jspm_packages&lt;/code&gt; と &lt;code&gt;&amp;lt;outDir&amp;gt;&lt;/code&gt; 指定されていないときのディレクトリを。</target>
        </trans-unit>
        <trans-unit id="c86be6e064d368e35d514286147756e446d3864b" translate="yes" xml:space="preserve">
          <source>Files included using &lt;code&gt;&quot;include&quot;&lt;/code&gt; can be filtered using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. However, files included explicitly using the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property are always included regardless of &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;. The &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property defaults to excluding the &lt;code&gt;node_modules&lt;/code&gt;, &lt;code&gt;bower_components&lt;/code&gt;, and &lt;code&gt;jspm_packages&lt;/code&gt; directories when not specified.</source>
          <target state="translated">&lt;code&gt;&quot;include&quot;&lt;/code&gt; を使用して組み込まれたファイルは、 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; プロパティーを使用してフィルターに掛けることができます。ただし、 &lt;code&gt;&quot;files&quot;&lt;/code&gt; プロパティを使用して明示的に含まれるファイルは、 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 関係なく常に含まれます。 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; を除くへのプロパティのデフォルト値を &lt;code&gt;node_modules&lt;/code&gt; 、 &lt;code&gt;bower_components&lt;/code&gt; 、および &lt;code&gt;jspm_packages&lt;/code&gt; の指定がないときのディレクトリを。</target>
        </trans-unit>
        <trans-unit id="a0de52ada9537ab464bb6d45e97f86eaaff6bac8" translate="yes" xml:space="preserve">
          <source>Final result</source>
          <target state="translated">最終結果</target>
        </trans-unit>
        <trans-unit id="c716a5f69a835c7b207ef913676c36b3f4cf7fe7" translate="yes" xml:space="preserve">
          <source>Finally, ES2015 introduced the &lt;code&gt;for..of&lt;/code&gt; statement as a means of iterating over an iterable. Similarly, the Async Iteration proposal introduces the &lt;code&gt;for..await..of&lt;/code&gt; statement to iterate over an async iterable:</source>
          <target state="translated">最後に、ES2015 は、反復可能 &lt;code&gt;for..of&lt;/code&gt; を反復する手段としてfor..ofステートメントを導入しました。同様に、非同期反復の提案では、非同期反復可能 &lt;code&gt;for..await..of&lt;/code&gt; を反復処理するためのfor..await..ofステートメントが導入されています。</target>
        </trans-unit>
        <trans-unit id="05320552d7f5f92b22b211023dcc2e57253aede5" translate="yes" xml:space="preserve">
          <source>Finally, TypeScript doesn&amp;rsquo;t provide any additional runtime libraries. Your programs will use the same standard library (or external libraries) as JavaScript programs, so there&amp;rsquo;s no additional TypeScript-specific framework to learn.</source>
          <target state="translated">最後に、TypeScriptは追加のランタイムライブラリを提供しません。プログラムはJavaScriptプログラムと同じ標準ライブラリ（または外部ライブラリ）を使用するため、追加のTypeScript固有のフレームワークを学習する必要はありません。</target>
        </trans-unit>
        <trans-unit id="7d78a77f9353986a905d8c074f3df1efad103d2d" translate="yes" xml:space="preserve">
          <source>Finally, add &lt;code&gt;src/greet.ts&lt;/code&gt; to &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">最後に、 &lt;code&gt;src/greet.ts&lt;/code&gt; を &lt;code&gt;tsconfig.json&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="48e51bf84514484baa2e7212c0375ccee83ffca6" translate="yes" xml:space="preserve">
          <source>Finally, if the compiler could not resolve the module, it will log an error. In this case, the error would be something like &lt;code&gt;error TS2307: Cannot find module 'moduleA'.&lt;/code&gt;</source>
          <target state="translated">最後に、コンパイラがモジュールを解決できなかった場合、エラーがログに記録されます。この場合、エラーは次のような &lt;code&gt;error TS2307: Cannot find module 'moduleA'.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c70f3dc4718552bbb66574b06291ac4442a2ee94" translate="yes" xml:space="preserve">
          <source>Finally, if your target is ES5 or ES3, you&amp;rsquo;ll also need to set the &lt;code&gt;--downlevelIterators&lt;/code&gt; flag.</source>
          <target state="translated">最後に、ターゲットがES5またはES3の場合は、 &lt;code&gt;--downlevelIterators&lt;/code&gt; フラグも設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="625382271b526d5909aa39a000a69074afb94c9c" translate="yes" xml:space="preserve">
          <source>Finally, let&amp;rsquo;s extend the example one last time with classes. TypeScript supports new features in JavaScript, like support for class-based object-oriented programming.</source>
          <target state="translated">最後に、例を最後にクラスで拡張してみましょう。TypeScriptは、クラスベースのオブジェクト指向プログラミングのサポートなど、JavaScriptの新機能をサポートしています。</target>
        </trans-unit>
        <trans-unit id="8e6a9c2de74efedbcef22e11a709230e67b2b36f" translate="yes" xml:space="preserve">
          <source>Finally, the Handbook won&amp;rsquo;t cover how TypeScript interacts with other tools, except where necessary. Topics like how to configure TypeScript with webpack, rollup, parcel, react, babel, closure, lerna, rush, bazel, preact, vue, angular, svelte, jquery, yarn, or npm are out of scope - you can find these resources elsewhere on the web.</source>
          <target state="translated">最後に、ハンドブックでは、必要な場合を除いて、TypeScriptが他のツールとどのように相互作用するかについては説明していません。Webpack、rollup、parcel、react、babel、closure、lerna、rush、bazel、preact、vue、angular、svelte、jquery、yarn、npmを使用してTypeScriptを構成する方法などのトピックは、範囲外です-これらのリソースは他の場所で見つけることができますウェブ上で。</target>
        </trans-unit>
        <trans-unit id="c6b76794e34c66667cc7c06423ff09561a2db9b4" translate="yes" xml:space="preserve">
          <source>Finally, we could perform many different merges using &lt;code&gt;namespace&lt;/code&gt; declarations. This isn&amp;rsquo;t a particularly realistic example, but shows all sorts of interesting behavior:</source>
          <target state="translated">最後に、 &lt;code&gt;namespace&lt;/code&gt; 宣言を使用してさまざまなマージを実行できます。これは特に現実的な例ではありませんが、あらゆる種類の興味深い動作を示しています。</target>
        </trans-unit>
        <trans-unit id="2a1cbf967f1f59d7ed905556a7ba174d0d91c432" translate="yes" xml:space="preserve">
          <source>Finally, we mix our mixins into the class implementation.</source>
          <target state="translated">最後に、ミックスインをクラスの実装に組み込みます。</target>
        </trans-unit>
        <trans-unit id="5d24682490796967f2d44a64ea932e79d1b2fb40" translate="yes" xml:space="preserve">
          <source>Finally, you can make index signatures &lt;code&gt;readonly&lt;/code&gt; in order to prevent assignment to their indices:</source>
          <target state="translated">最後に、インデックスへの割り当てを防ぐために、インデックスシグネチャを &lt;code&gt;readonly&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="36f4ab4ec74314f1c6473ad2b642469fa92db24a" translate="yes" xml:space="preserve">
          <source>Find all referenced projects</source>
          <target state="translated">参照されているすべてのプロジェクトを検索</target>
        </trans-unit>
        <trans-unit id="f36d6416266be79de49dbd1cd5564e2c29d74695" translate="yes" xml:space="preserve">
          <source>Find and Install Declaration Files</source>
          <target state="translated">宣言ファイルの検索とインストール</target>
        </trans-unit>
        <trans-unit id="107a7b9e0a62d571bcbb1e3e04401f38fb4be3c9" translate="yes" xml:space="preserve">
          <source>Finished with that step? Great! You&amp;rsquo;ve successfully migrated a file from JavaScript to TypeScript!</source>
          <target state="translated">そのステップで終了しましたか？すごい！ファイルをJavaScriptからTypeScriptに正常に移行しました！</target>
        </trans-unit>
        <trans-unit id="c8bb450db4ab929fdfadf7c4e435fbd8ded8de50" translate="yes" xml:space="preserve">
          <source>First ensure Webpack is installed.</source>
          <target state="translated">まず、Webpackがインストールされていることを確認します。</target>
        </trans-unit>
        <trans-unit id="3df868c33500281a256aa0f7044d7222e49fa905" translate="yes" xml:space="preserve">
          <source>First install Babelify and the Babel preset for ES2015. Like Uglify, Babelify mangles code, so we&amp;rsquo;ll need vinyl-buffer and gulp-sourcemaps. By default Babelify will only process files with extensions of &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.es&lt;/code&gt;, &lt;code&gt;.es6&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; so we need to add the &lt;code&gt;.ts&lt;/code&gt; extension as an option to Babelify.</source>
          <target state="translated">まず、ES2015のBabelifyとBabelプリセットをインストールします。Uglifyのように、Babelifyはコードをマングルするので、ビニールバッファーとgulp-sourcemapsが必要になります。デフォルトでは、Babelifyは拡張子が &lt;code&gt;.js&lt;/code&gt; 、 &lt;code&gt;.es&lt;/code&gt; 、 &lt;code&gt;.es6&lt;/code&gt; 、 &lt;code&gt;.jsx&lt;/code&gt; のファイルのみを処理するため、 &lt;code&gt;.ts&lt;/code&gt; のオプションとして.ts拡張子を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="735b0c16eaf95bad801406a590783a07bff54840" translate="yes" xml:space="preserve">
          <source>First install Uglify. Since the point of Uglify is to mangle your code, we also need to install vinyl-buffer and gulp-sourcemaps to keep sourcemaps working.</source>
          <target state="translated">最初に Uglify をインストールします。Uglify のポイントはコードを混乱させることなので、ソースマップを動作させ続けるために vinyl-buffer と gulp-sourcemaps もインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="89e20ebbee86fab209c76b802ba242b064d21b1b" translate="yes" xml:space="preserve">
          <source>First of all, they&amp;rsquo;re important because they allow TypeScript to type-check against other projects without re-checking the original source code. They&amp;rsquo;re also important because they allow TypeScript to interoperate with existing JavaScript libraries that weren&amp;rsquo;t built with TypeScript in mind. Finally, a benefit that is often underappreciated: both TypeScript &lt;em&gt;and&lt;/em&gt; JavaScript users can benefit from these files when using editors powered by TypeScript to get things like better auto-completion.</source>
          <target state="translated">まず第一に、元のソースコードを再確認することなくTypeScriptが他のプロジェクトに対して型チェックを行えるようにするため、これらは重要です。 TypeScriptを念頭に置いて構築されていない既存のJavaScriptライブラリと相互運用できるようにするため、これらも重要です。最後に、あまり評価されない利点もあります。TypeScript &lt;em&gt;と&lt;/em&gt; JavaScriptの両方のユーザーは、TypeScriptを利用したエディターを使用してオートコンプリートを改善するときに、これらのファイルから利益を得ることができます。</target>
        </trans-unit>
        <trans-unit id="8618e8a440e50c5a75000139af77b5f2c4300871" translate="yes" xml:space="preserve">
          <source>First some terminology</source>
          <target state="translated">最初にいくつかの用語</target>
        </trans-unit>
        <trans-unit id="99290d59716a55c82e8b063db8bf7f05e1a4b00b" translate="yes" xml:space="preserve">
          <source>First steps</source>
          <target state="translated">はじめの一歩</target>
        </trans-unit>
        <trans-unit id="8336905fe9b50c35195d1e701772f27af4d34cab" translate="yes" xml:space="preserve">
          <source>First we declare the interfaces we will union. Each interface has a &lt;code&gt;kind&lt;/code&gt; property with a different string literal type. The &lt;code&gt;kind&lt;/code&gt; property is called the &lt;em&gt;discriminant&lt;/em&gt; or &lt;em&gt;tag&lt;/em&gt;. The other properties are specific to each interface. Notice that the interfaces are currently unrelated. Let&amp;rsquo;s put them into a union:</source>
          <target state="translated">最初に、結合するインターフェースを宣言します。各インターフェイスには、異なる文字列リテラルタイプの &lt;code&gt;kind&lt;/code&gt; プロパティがあります。 &lt;code&gt;kind&lt;/code&gt; プロパティが呼び出される&lt;em&gt;判別式&lt;/em&gt;または&lt;em&gt;タグ&lt;/em&gt;。その他のプロパティは、各インターフェイスに固有です。現在、インターフェースは無関係です。それらを組合に入れましょう：</target>
        </trans-unit>
        <trans-unit id="a34ce699f43cedcd3aa6a4d39d183ca5e70a6e0b" translate="yes" xml:space="preserve">
          <source>First we need to tell TypeScript how to build. Right click on &lt;code&gt;scripts&lt;/code&gt; and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;TypeScript Configuration File&lt;/strong&gt; and use the default name of &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">最初に、TypeScriptにビルド方法を指示する必要があります。 &lt;code&gt;scripts&lt;/code&gt; を右クリックし、[ &lt;strong&gt;新しいアイテム&lt;/strong&gt; ]をクリックします。次に、&lt;strong&gt;TypeScript構成ファイル&lt;/strong&gt;を選択し、 &lt;code&gt;tsconfig.json&lt;/code&gt; のデフォルト名を使用します</target>
        </trans-unit>
        <trans-unit id="2dfb573ed967d8c6c17580ed779ecdccc14311ef" translate="yes" xml:space="preserve">
          <source>First, accessors require you to set the compiler to output ECMAScript 5 or higher. Downleveling to ECMAScript 3 is not supported. Second, accessors with a &lt;code&gt;get&lt;/code&gt; and no &lt;code&gt;set&lt;/code&gt; are automatically inferred to be &lt;code&gt;readonly&lt;/code&gt;. This is helpful when generating a &lt;code&gt;.d.ts&lt;/code&gt; file from your code, because users of your property can see that they can&amp;rsquo;t change it.</source>
          <target state="translated">まず、アクセサは、ECMAScript 5以降を出力するようにコンパイラを設定する必要があります。 ECMAScript 3へのダウンレベル化はサポートされていません。次に、 &lt;code&gt;get&lt;/code&gt; があり、 &lt;code&gt;set&lt;/code&gt; がないアクセサは、自動的に &lt;code&gt;readonly&lt;/code&gt; であると推定されます。これは、コードから &lt;code&gt;.d.ts&lt;/code&gt; ファイルを生成するときに役立ちます。プロパティのユーザーは、変更できないことがわかるからです。</target>
        </trans-unit>
        <trans-unit id="2f1af0e65e7f250987a6b875f7a585e406660a62" translate="yes" xml:space="preserve">
          <source>First, given types &lt;code&gt;T'&lt;/code&gt; and &lt;code&gt;U'&lt;/code&gt; that are instantiations of &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; where all occurrences of type parameters are replaced with &lt;code&gt;any&lt;/code&gt;, if &lt;code&gt;T'&lt;/code&gt; is not assignable to &lt;code&gt;U'&lt;/code&gt;, the conditional type is resolved to &lt;code&gt;Y&lt;/code&gt;. Intuitively, if the most permissive instantiation of &lt;code&gt;T&lt;/code&gt; is not assignable to the most permissive instantiation of &lt;code&gt;U&lt;/code&gt;, we know that no instantiation will be and we can just resolve to &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">まず、与えられたタイプ &lt;code&gt;T'&lt;/code&gt; および &lt;code&gt;U'&lt;/code&gt; のインスタンスである &lt;code&gt;T&lt;/code&gt; と &lt;code&gt;U&lt;/code&gt; 型パラメータのすべての発生がで置換されている &lt;code&gt;any&lt;/code&gt; 場合、 &lt;code&gt;T'&lt;/code&gt; に割り当てない &lt;code&gt;U'&lt;/code&gt; 、条件タイプに解決されている &lt;code&gt;Y&lt;/code&gt; 。直感的に、 &lt;code&gt;T&lt;/code&gt; の最も許容的なインスタンス化が &lt;code&gt;U&lt;/code&gt; の最も許容的なインスタンス化に割り当てられない場合、インスタンス化は行われず、 &lt;code&gt;Y&lt;/code&gt; に解決できます。</target>
        </trans-unit>
        <trans-unit id="e0f154b6d3560afc04e7423c292457f3d4c696d4" translate="yes" xml:space="preserve">
          <source>First, install &lt;a href=&quot;https://dotnet.microsoft.com/apps/aspnet&quot;&gt;ASP.NET Core&lt;/a&gt; if you need it. This quick-start guide requires Visual Studio 2015 or 2017.</source>
          <target state="translated">必要に応じて、まず&lt;a href=&quot;https://dotnet.microsoft.com/apps/aspnet&quot;&gt;ASP.NET Coreを&lt;/a&gt;インストールします。このクイックスタートガイドには、Visual Studio 2015または2017が必要です。</target>
        </trans-unit>
        <trans-unit id="5fe122cf8e822627b9c191ebbd95f6c78e81f570" translate="yes" xml:space="preserve">
          <source>First, install browserify, &lt;a href=&quot;https://www.npmjs.com/package/tsify&quot;&gt;tsify&lt;/a&gt;, and vinyl-source-stream. tsify is a Browserify plugin that, like gulp-typescript, gives access to the TypeScript compiler. vinyl-source-stream lets us adapt the file output of Browserify back into a format that gulp understands called &lt;a href=&quot;https://github.com/gulpjs/vinyl&quot;&gt;vinyl&lt;/a&gt;.</source>
          <target state="translated">まず、browserify、&lt;a href=&quot;https://www.npmjs.com/package/tsify&quot;&gt;tsify&lt;/a&gt;、およびvinyl-source-streamをインストールします。tsifyは、gulp-typescriptと同様に、TypeScriptコンパイラへのアクセスを提供するBrowserifyプラグインです。vinyl-source-streamを使用すると、Browserifyのファイル出力を、gulpが理解できる&lt;a href=&quot;https://github.com/gulpjs/vinyl&quot;&gt;vinyl&lt;/a&gt;と呼ばれる形式に適合させることができます。</target>
        </trans-unit>
        <trans-unit id="51744cf60b9ea9e03623f5527d487a42b621f3c4" translate="yes" xml:space="preserve">
          <source>First, install the &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt; utility library:</source>
          <target state="translated">まず、&lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt;ユーティリティライブラリをインストールします。</target>
        </trans-unit>
        <trans-unit id="f59152e91c742c2580784c2fb852897f78a3c5bd" translate="yes" xml:space="preserve">
          <source>First, the compiler will try to locate a file that represents the imported module. To do so the compiler follows one of two different strategies: &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; or &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt;. These strategies tell the compiler &lt;em&gt;where&lt;/em&gt; to look for &lt;code&gt;moduleA&lt;/code&gt;.</source>
          <target state="translated">まず、コンパイラーはインポートされたモジュールを表すファイルを見つけようとします。これを行うには、コンパイラーは、&lt;a href=&quot;#classic&quot;&gt;クラシック&lt;/a&gt;または&lt;a href=&quot;#node&quot;&gt;ノードの&lt;/a&gt; 2つの異なる戦略のいずれかに従います。これらの戦略は、 &lt;code&gt;moduleA&lt;/code&gt; を探す&lt;em&gt;場所&lt;/em&gt;をコンパイラー&lt;em&gt;に&lt;/em&gt;指示します。</target>
        </trans-unit>
        <trans-unit id="fee2aae2ee58d3140d673d1cb82204dd56b9f63b" translate="yes" xml:space="preserve">
          <source>First, we can use concatenated output using the &lt;code&gt;--outFile&lt;/code&gt; flag to compile all of the input files into a single JavaScript output file:</source>
          <target state="translated">まず、-- &lt;code&gt;--outFile&lt;/code&gt; フラグを使用して連結出力を使用し、すべての入力ファイルを単一のJavaScript出力ファイルにコンパイルできます。</target>
        </trans-unit>
        <trans-unit id="28d19122adb2247e67a766539293d7db8d64dd97" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll review the kinds of libraries TypeScript declaration files can represent. We&amp;rsquo;ll briefly show how each kind of library is &lt;em&gt;used&lt;/em&gt;, how it is &lt;em&gt;written&lt;/em&gt;, and list some example libraries from the real world.</source>
          <target state="translated">最初に、TypeScript宣言ファイルが表すことができるライブラリの種類を確認します。各種類のライブラリがどのように&lt;em&gt;使用され&lt;/em&gt;、どのように&lt;em&gt;記述されている&lt;/em&gt;かを簡単に示し、実際のライブラリの例をいくつか示します。</target>
        </trans-unit>
        <trans-unit id="a7a574b0f49a4d1d52dcd069a74b5d55c404e3a8" translate="yes" xml:space="preserve">
          <source>First, you&amp;rsquo;ll need to enable some module system by setting TypeScript&amp;rsquo;s &lt;code&gt;module&lt;/code&gt; flag. Valid options are &lt;code&gt;commonjs&lt;/code&gt;, &lt;code&gt;amd&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, and &lt;code&gt;umd&lt;/code&gt;.</source>
          <target state="translated">まず、TypeScriptの &lt;code&gt;module&lt;/code&gt; フラグを設定して、モジュールシステムを有効にする必要があります。有効なオプションは、 &lt;code&gt;commonjs&lt;/code&gt; 、 &lt;code&gt;amd&lt;/code&gt; 、 &lt;code&gt;system&lt;/code&gt; 、および &lt;code&gt;umd&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7d0c91cebd6414c6cadf4f9352001f643b829f0b" translate="yes" xml:space="preserve">
          <source>Fixed Length Tuples</source>
          <target state="translated">固定長タプル</target>
        </trans-unit>
        <trans-unit id="3ca7815b9ccb9b2f4adbee87c52250c1c035669b" translate="yes" xml:space="preserve">
          <source>Flag unused declarations with &lt;code&gt;--noUnusedParameters&lt;/code&gt; and &lt;code&gt;--noUnusedLocals&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--noUnusedParameters&lt;/code&gt; および &lt;code&gt;--noUnusedLocals&lt;/code&gt; を使用して未使用の宣言にフラグを付けます</target>
        </trans-unit>
        <trans-unit id="bd3ca27f2fe942c2bbe6da7b0df5ec8ca268ccce" translate="yes" xml:space="preserve">
          <source>Flags which help with debugging</source>
          <target state="translated">デバッグに役立つフラグ</target>
        </trans-unit>
        <trans-unit id="82a9583e4b01eda6ab596923bd11954f7465daf4" translate="yes" xml:space="preserve">
          <source>Following this logic, the compiler will attempt to resolve the two imports as such:</source>
          <target state="translated">このロジックに従って、コンパイラは2つのインポートをそのように解決しようとします。</target>
        </trans-unit>
        <trans-unit id="26431a2529d203186f1196ee3c1e08f1f5a1e8c1" translate="yes" xml:space="preserve">
          <source>Following up on specifying the type of &lt;code&gt;this&lt;/code&gt; in a class or an interface, functions and methods can now declare the type of &lt;code&gt;this&lt;/code&gt; they expect.</source>
          <target state="translated">クラスまたはインターフェースでの &lt;code&gt;this&lt;/code&gt; のタイプの指定に続いて、関数とメソッドは期待する &lt;code&gt;this&lt;/code&gt; のタイプを宣言できるようになりました。</target>
        </trans-unit>
        <trans-unit id="1c46fd3b2bfcf228c256745663f71fdbf4e9f242" translate="yes" xml:space="preserve">
          <source>Following up our example above, consider if &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; instead used a non-relative path and had the import &lt;code&gt;var x = require(&quot;moduleB&quot;);&lt;/code&gt;. Node would then try to resolve &lt;code&gt;moduleB&lt;/code&gt; to each of the locations until one worked.</source>
          <target state="translated">上記の例に従って、 &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; が代わりに非相対パスを使用し、インポート &lt;code&gt;var x = require(&quot;moduleB&quot;);&lt;/code&gt; があったかどうかを検討します。。次に、ノードは、いずれかが機能するまで &lt;code&gt;moduleB&lt;/code&gt; を各場所に解決しようとします。</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="d651257c7219d6828652b8ed3ae590398f5b2d5c" translate="yes" xml:space="preserve">
          <source>For JavaScript library users, the &lt;a href=&quot;consumption&quot;&gt;Consumption&lt;/a&gt; section offers a few simple steps to locate and install corresponding declaration files.</source>
          <target state="translated">JavaScriptライブラリー・ユーザーの場合、「&lt;a href=&quot;consumption&quot;&gt;消費」&lt;/a&gt;セクションでは、対応する宣言ファイルを見つけてインストールするためのいくつかの簡単なステップを提供しています。</target>
        </trans-unit>
        <trans-unit id="3f13871c6491a9fb503e0b3db6f8d157fced814c" translate="yes" xml:space="preserve">
          <source>For NPM users:</source>
          <target state="translated">NPMをお使いの方へ。</target>
        </trans-unit>
        <trans-unit id="f29506c87493e2d6a8464c1671b709d1038182e2" translate="yes" xml:space="preserve">
          <source>For React, intrinsic elements are emitted as strings (&lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt;), whereas a component you&amp;rsquo;ve created is not (&lt;code&gt;React.createElement(MyComponent)&lt;/code&gt;).</source>
          <target state="translated">Reactの場合、組み込み要素は文字列として出力されます（ &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt; ）が、作成したコンポーネントは出力されません（ &lt;code&gt;React.createElement(MyComponent)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2bc6cffb51efec5345d518d22e0c722de0a63bbe" translate="yes" xml:space="preserve">
          <source>For VS 2013:</source>
          <target state="translated">VS2013の場合。</target>
        </trans-unit>
        <trans-unit id="614775d6367bb72e6635063a6e9a003dfc10d404" translate="yes" xml:space="preserve">
          <source>For VS 2015:</source>
          <target state="translated">VS 2015のために。</target>
        </trans-unit>
        <trans-unit id="fabf9dab407dafe6e4158a0fb10d99a963d13936" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;n in x&lt;/code&gt; expression, where &lt;code&gt;n&lt;/code&gt; is a string literal or string literal type and &lt;code&gt;x&lt;/code&gt; is a union type, the &amp;ldquo;true&amp;rdquo; branch narrows to types which have an optional or required property &lt;code&gt;n&lt;/code&gt;, and the &amp;ldquo;false&amp;rdquo; branch narrows to types which have an optional or missing property &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">以下のため &lt;code&gt;n in x&lt;/code&gt; の式、 &lt;code&gt;n&lt;/code&gt; 個の文字列リテラルや文字列リテラルの型で、 &lt;code&gt;x&lt;/code&gt; は共用体型で、オプションまたは必須の性質を持っているタイプを「true」分岐狭く &lt;code&gt;n&lt;/code&gt; 型にし、「偽」の分岐が狭くオプションまたは欠落しているプロパティ &lt;code&gt;n&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="75b6d27cd5a1c972beb5c2e01a0a9c58217f3d2c" translate="yes" xml:space="preserve">
          <source>For certain downleveling operations, TypeScript uses some helper code for operations like extending class, spreading arrays or objects, and async operations. By default, these helpers are inserted into files which use them. This can result in code duplication if the same helper is used in many different modules.</source>
          <target state="translated">特定のダウンレベル操作のために、TypeScript はクラスの拡張、配列やオブジェクトの分散、非同期操作などの操作のためにヘルパーコードを使用します。デフォルトでは、これらのヘルパーはそれらを使用するファイルに挿入されます。これは、同じヘルパーが多くの異なるモジュールで使われている場合、コードの重複を招く可能性があります。</target>
        </trans-unit>
        <trans-unit id="59f0e903aa4d967be8cee2ad438a3b8e7a692972" translate="yes" xml:space="preserve">
          <source>For creating &lt;code&gt;--incremental&lt;/code&gt; builds, users can leverage the &lt;code&gt;createIncrementalProgram&lt;/code&gt; and &lt;code&gt;createIncrementalCompilerHost&lt;/code&gt; APIs. Users can also re-hydrate old program instances from &lt;code&gt;.tsbuildinfo&lt;/code&gt; files generated by this API using the newly exposed &lt;code&gt;readBuilderProgram&lt;/code&gt; function, which is only meant to be used as for creating new programs (i.e. you can&amp;rsquo;t modify the returned instance - it&amp;rsquo;s only meant to be used for the &lt;code&gt;oldProgram&lt;/code&gt; parameter in other &lt;code&gt;create*Program&lt;/code&gt; functions).</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; ビルドを作成する場合、ユーザーは &lt;code&gt;createIncrementalProgram&lt;/code&gt; および &lt;code&gt;createIncrementalCompilerHost&lt;/code&gt; APIを利用できます。ユーザーは、新しく公開された &lt;code&gt;readBuilderProgram&lt;/code&gt; 関数を使用して、このAPIによって生成された &lt;code&gt;.tsbuildinfo&lt;/code&gt; ファイルから古いプログラムインスタンスを再水和することもできます。他の &lt;code&gt;create*Program&lt;/code&gt; 関数の &lt;code&gt;oldProgram&lt;/code&gt; パラメーターに使用されます）。</target>
        </trans-unit>
        <trans-unit id="13c650c5b2c3bf134743f81ee8a751c72f2c46d5" translate="yes" xml:space="preserve">
          <source>For declaration file authors who relay on built-in types, e.g. DOM APIs or built-in JS run-time constructors like &lt;code&gt;Symbol&lt;/code&gt; or &lt;code&gt;Iterable&lt;/code&gt;, triple-slash-reference lib directives are the recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.</source>
          <target state="translated">DOM APIや &lt;code&gt;Symbol&lt;/code&gt; や &lt;code&gt;Iterable&lt;/code&gt; のような組み込みのJSランタイムコンストラクターなどの組み込み型を中継する宣言ファイルの作成者には、トリプルスラッシュ参照libディレクティブをお勧めします。以前は、これらの.d.tsファイルは、そのようなタイプの前方/重複宣言を追加する必要がありました。</target>
        </trans-unit>
        <trans-unit id="f730367034cc3e65c4c80c7cc48438917a47a1a4" translate="yes" xml:space="preserve">
          <source>For declaration file authors who rely on built-in types, e.g. DOM APIs or built-in JS run-time constructors like &lt;code&gt;Symbol&lt;/code&gt; or &lt;code&gt;Iterable&lt;/code&gt;, triple-slash-reference lib directives are recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.</source>
          <target state="translated">DOM APIや &lt;code&gt;Symbol&lt;/code&gt; や &lt;code&gt;Iterable&lt;/code&gt; などの組み込み JSランタイムコンストラクターなどの組み込み型に依存する宣言ファイルの作成者には、トリプルスラッシュ参照libディレクティブをお勧めします。以前は、これらの.d.tsファイルは、そのようなタイプの前方/重複宣言を追加する必要がありました。</target>
        </trans-unit>
        <trans-unit id="c7b31102ddf3ec0f8a01da2c2c2faaf0cec3c40b" translate="yes" xml:space="preserve">
          <source>For declaration files generated during compilation, the compiler will automatically add &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; for you; A &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; in a generated declaration file is added &lt;em&gt;if and only if&lt;/em&gt; the resulting file uses any declarations from the referenced package.</source>
          <target state="translated">コンパイル中に生成された宣言ファイルの場合、コンパイラーは自動的に &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; を追加します。生成された宣言ファイル内の &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; が追加さ&lt;em&gt;れるの&lt;/em&gt;は、結果のファイルが参照パッケージの宣言を使用する&lt;em&gt;場合のみです&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="4710530ea547f1515550efbf2971f53cc2a8b738" translate="yes" xml:space="preserve">
          <source>For declaring a dependency on an &lt;code&gt;@types&lt;/code&gt; package in a &lt;code&gt;.ts&lt;/code&gt; file, use &lt;code&gt;--types&lt;/code&gt; on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt; instead. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;using &lt;code&gt;@types&lt;/code&gt;, &lt;code&gt;typeRoots&lt;/code&gt; and &lt;code&gt;types&lt;/code&gt; in &lt;code&gt;tsconfig.json&lt;/code&gt; files&lt;/a&gt; for more details.</source>
          <target state="translated">上の依存関係を宣言するための &lt;code&gt;@types&lt;/code&gt; のパッケージ &lt;code&gt;.ts&lt;/code&gt; ファイル、使用が &lt;code&gt;--types&lt;/code&gt; コマンドラインや、あなたの中に &lt;code&gt;tsconfig.json&lt;/code&gt; 代わりに。詳細について&lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;は、&lt;/a&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルでの@ &lt;code&gt;@types&lt;/code&gt; 、 &lt;code&gt;typeRoots&lt;/code&gt; 、および &lt;code&gt;types&lt;/code&gt; の使用を参照してください。</target>
        </trans-unit>
        <trans-unit id="fc0c74f5013de3695703ff3f7978efc260f1a6e9" translate="yes" xml:space="preserve">
          <source>For developer platforms like Node will have a certain baselines for the their target depending on their version. You can find a set of community organized TSConfigs at &lt;a href=&quot;https://github.com/tsconfig/bases#centralized-recommendations-for-tsconfig-bases&quot;&gt;tsconfig/bases&lt;/a&gt; for common platforms and their versions.</source>
          <target state="translated">Nodeのような開発者プラットフォームの場合、バージョンに応じて、ターゲットの特定のベースラインがあります。コミュニティで編成されたTSConfigのセットは、一般的なプラットフォームとそのバージョンの&lt;a href=&quot;https://github.com/tsconfig/bases#centralized-recommendations-for-tsconfig-bases&quot;&gt;tsconfig / bases&lt;/a&gt;にあります。</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="2ed40c6f0c1780add8b6c27390450ea1294c1186" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;document.createElement('xyz')&lt;/code&gt; returns a &lt;code&gt;&amp;lt;xyz&amp;gt;&amp;lt;/xyz&amp;gt;&lt;/code&gt; element, clearly not an element that is specified by the HTML specification.</source>
          <target state="translated">たとえば、 &lt;code&gt;document.createElement('xyz')&lt;/code&gt; は &lt;code&gt;&amp;lt;xyz&amp;gt;&amp;lt;/xyz&amp;gt;&lt;/code&gt; 要素を返しますが、HTML仕様で指定されている要素ではないことは明らかです。</target>
        </trans-unit>
        <trans-unit id="b927d147a48a1d8a678317e5dc270ab1fa0bd354" translate="yes" xml:space="preserve">
          <source>For example consider this project structure:</source>
          <target state="translated">例えば、次のようなプロジェクト構造を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="e330faf79858eff15ab1fa16b480f9af8a75e723" translate="yes" xml:space="preserve">
          <source>For example if you wanted to use &lt;code&gt;&quot;jsxImportSource&quot;: &quot;preact&quot;&lt;/code&gt;, you need a tsconfig like:</source>
          <target state="translated">たとえば、 &lt;code&gt;&quot;jsxImportSource&quot;: &quot;preact&quot;&lt;/code&gt; を使用する場合は、次のようなtsconfigが必要です。</target>
        </trans-unit>
        <trans-unit id="d8da11b0efd47b16f48058eb8799a7168124fbd1" translate="yes" xml:space="preserve">
          <source>For example with this TSConfig:</source>
          <target state="translated">例えば、この TSConfig.</target>
        </trans-unit>
        <trans-unit id="7eea9d386cac8ef8110732486a228ddec7a04971" translate="yes" xml:space="preserve">
          <source>For example with this TypeScript code, &lt;code&gt;users.find&lt;/code&gt; has no guarantee that it will actually find a user, but you can write code as though it will:</source>
          <target state="translated">たとえば、このTypeScriptコードでは、 &lt;code&gt;users.find&lt;/code&gt; は実際にユーザーを見つける保証はありませんが、次のようにコードを記述できます。</target>
        </trans-unit>
        <trans-unit id="3aa37fb2b6671c00d8d1e61a2de6e276f5b9d8e6" translate="yes" xml:space="preserve">
          <source>For example with this TypeScript:</source>
          <target state="translated">例えば、このTypeScriptで。</target>
        </trans-unit>
        <trans-unit id="5bf9c1c74c2f780a51e1fe18b7af85788137a273" translate="yes" xml:space="preserve">
          <source>For example with this code:</source>
          <target state="translated">例えば次のようなコードです。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="9589441950a7ba70ac32a866e7cbc78c60f18f3b" translate="yes" xml:space="preserve">
          <source>For example, JavaScript provides language primitives like &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, and &lt;code&gt;object&lt;/code&gt;, but it doesn&amp;rsquo;t check that you&amp;rsquo;ve consistently assigned these. TypeScript does.</source>
          <target state="translated">たとえば、JavaScriptは &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;number&lt;/code&gt; 、 &lt;code&gt;object&lt;/code&gt; などの言語プリミティブを提供しますが、これらが一貫して割り当てられているかどうかはチェックされません。TypeScriptはそうします。</target>
        </trans-unit>
        <trans-unit id="b84169ea004a1106235d82bc2a5c66557575c167" translate="yes" xml:space="preserve">
          <source>For example, adding &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; to one of the files in a compilation is equivalent to compiling with &lt;code&gt;--lib es2017.string&lt;/code&gt;.</source>
          <target state="translated">たとえば、コンパイルで &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; をファイルの1つに追加することは、-- lib es2017.stringを使用してコンパイルすることと &lt;code&gt;--lib es2017.string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f435730a5bc00012d3042f3d1a8d4332e64f206" translate="yes" xml:space="preserve">
          <source>For example, an import statement like &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; in &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; would result in attempting the following locations for locating &lt;code&gt;&quot;./moduleB&quot;&lt;/code&gt;:</source>
          <target state="translated">たとえば、 &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; の &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; ようなインポート文を実行すると、 &lt;code&gt;&quot;./moduleB&quot;&lt;/code&gt; を見つけるために次の場所が試行されます。</target>
        </trans-unit>
        <trans-unit id="fb0268932a575e89ddaf5adf469f05cd6fb3e89a" translate="yes" xml:space="preserve">
          <source>For example, can you &lt;em&gt;only&lt;/em&gt; get it through npm or only from a CDN?</source>
          <target state="translated">たとえば、npmから&lt;em&gt;のみ&lt;/em&gt;取得できますか、それともCDNから&lt;em&gt;のみ&lt;/em&gt;取得できますか？</target>
        </trans-unit>
        <trans-unit id="4dfb27ce129bee760fed1ebcb688044df6ad992b" translate="yes" xml:space="preserve">
          <source>For example, given the decorator &lt;code&gt;@sealed&lt;/code&gt; we might write the &lt;code&gt;sealed&lt;/code&gt; function as follows:</source>
          <target state="translated">たとえば、デコレータ &lt;code&gt;@sealed&lt;/code&gt; を指定すると、次のように &lt;code&gt;sealed&lt;/code&gt; 関数を作成できます。</target>
        </trans-unit>
        <trans-unit id="d0e1f04886e8aa232b1f5ca87afb79f3e9db1b4b" translate="yes" xml:space="preserve">
          <source>For example, here is the JavaScript</source>
          <target state="translated">例えば、ここではJavaScriptの</target>
        </trans-unit>
        <trans-unit id="379a411593e5b86332a2083bee7043e6f9882715" translate="yes" xml:space="preserve">
          <source>For example, if you had networking requests with consistent error handling then you could separate out the error handling into its own type which is merged with types which correspond to a single response type.</source>
          <target state="translated">例えば、一貫したエラー処理を持つネットワーキングリクエストがあった場合、エラー処理をそれ自身の型に分離し、それを単一のレスポンス型に対応する型にマージすることができます。</target>
        </trans-unit>
        <trans-unit id="23596f0dc1eff87037eef75f96316f4284f9ed16" translate="yes" xml:space="preserve">
          <source>For example, if you were writing a project which uses Node.js version 12 and above, then you could use the npm module &lt;a href=&quot;https://www.npmjs.com/package/@tsconfig/node12&quot;&gt;&lt;code&gt;@tsconfig/node12&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">たとえば、Node.jsバージョン12以降を使用するプロジェクトを作成している場合は、npmモジュール&lt;a href=&quot;https://www.npmjs.com/package/@tsconfig/node12&quot;&gt; &lt;code&gt;@tsconfig/node12&lt;/code&gt; &lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="ba290a075f0c2045568e30b972340550a085db75" translate="yes" xml:space="preserve">
          <source>For example, including &lt;code&gt;/// &amp;lt;reference types=&quot;node&quot; /&amp;gt;&lt;/code&gt; in a declaration file declares that this file uses names declared in &lt;code&gt;@types/node/index.d.ts&lt;/code&gt;; and thus, this package needs to be included in the compilation along with the declaration file.</source>
          <target state="translated">たとえば、宣言ファイルに &lt;code&gt;/// &amp;lt;reference types=&quot;node&quot; /&amp;gt;&lt;/code&gt; を含めると、このファイルは &lt;code&gt;@types/node/index.d.ts&lt;/code&gt; 宣言された名前を使用することを宣言します。したがって、このパッケージは、宣言ファイルとともにコンパイルに含める必要があります。</target>
        </trans-unit>
        <trans-unit id="7f2169f30439c664d4891dafe1197f03d77f4716" translate="yes" xml:space="preserve">
          <source>For example, it&amp;rsquo;s often very common to forget to &lt;code&gt;.then()&lt;/code&gt; or &lt;code&gt;await&lt;/code&gt; the contents of a &lt;code&gt;Promise&lt;/code&gt; before passing it to another function. TypeScript&amp;rsquo;s error messages are now specialized, and inform the user that perhaps they should consider using the &lt;code&gt;await&lt;/code&gt; keyword.</source>
          <target state="translated">たとえば、 &lt;code&gt;.then()&lt;/code&gt; を忘れたり、 &lt;code&gt;Promise&lt;/code&gt; の内容を &lt;code&gt;await&lt;/code&gt; てから別の関数に渡したりすることはよくあることです。TypeScriptのエラーメッセージは特殊化され、 &lt;code&gt;await&lt;/code&gt; キーワードの使用を検討する必要があることをユーザーに通知します。</target>
        </trans-unit>
        <trans-unit id="3ad31453ee6f39d96c1afdaaf6077d0e43f26289" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say you had this tree:</source>
          <target state="translated">たとえば、次のツリーがあるとします。</target>
        </trans-unit>
        <trans-unit id="5c6fd2fe67c6fb7f9ef03666af8aa720461e76ff" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say you have some input files:</source>
          <target state="translated">たとえば、いくつかの入力ファイルがあるとします。</target>
        </trans-unit>
        <trans-unit id="ffcedc1552ccfc47d112e6dad0906deb0847258a" translate="yes" xml:space="preserve">
          <source>For example, once you&amp;rsquo;ve &lt;code&gt;npm install&lt;/code&gt;-ed your type declarations, you can use imports and write</source>
          <target state="translated">たとえば、型宣言を &lt;code&gt;npm install&lt;/code&gt; -edしたら、インポートと書き込みを使用できます</target>
        </trans-unit>
        <trans-unit id="502a1d2b7504dbb10d71367198e70328d93e9cdc" translate="yes" xml:space="preserve">
          <source>For example, some libraries add new functions to &lt;code&gt;Array.prototype&lt;/code&gt; or &lt;code&gt;String.prototype&lt;/code&gt;.</source>
          <target state="translated">たとえば、一部のライブラリは、 &lt;code&gt;Array.prototype&lt;/code&gt; または &lt;code&gt;String.prototype&lt;/code&gt; に新しい関数を追加します。</target>
        </trans-unit>
        <trans-unit id="8be4ce18dfa625c450ddd4bc1142e60f3523955d" translate="yes" xml:space="preserve">
          <source>For example, the class below returns a function which tries to access &lt;code&gt;this.width&lt;/code&gt; and &lt;code&gt;this.height&lt;/code&gt; &amp;ndash; but the context for &lt;code&gt;this&lt;/code&gt; inside the function inside &lt;code&gt;getAreaFunction&lt;/code&gt; is not the instance of the Rectangle.</source>
          <target state="translated">例えば、戻りアクセスしようとする機能下記クラス &lt;code&gt;this.width&lt;/code&gt; と &lt;code&gt;this.height&lt;/code&gt; -しかしのコンテキスト &lt;code&gt;this&lt;/code&gt; 内部関数内部 &lt;code&gt;getAreaFunction&lt;/code&gt; は長方形のインスタンスではありません。</target>
        </trans-unit>
        <trans-unit id="6eec7c26069b784720c61be112395d7efa3ccaf5" translate="yes" xml:space="preserve">
          <source>For example, the following extracts the return type of a function type:</source>
          <target state="translated">例えば、以下は関数型の戻り値の型を抽出しています。</target>
        </trans-unit>
        <trans-unit id="a37862b00fe2100e1e8f8d8cb1ffd54013028ebd" translate="yes" xml:space="preserve">
          <source>For example, the following sample declares variables &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;, and initializes them to &lt;code&gt;getSomeObject().x&lt;/code&gt;, &lt;code&gt;getSomeObject().y&lt;/code&gt; and &lt;code&gt;getSomeObject().z&lt;/code&gt; respectively:</source>
          <target state="translated">たとえば、次のサンプルでは、​​変数 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、 &lt;code&gt;z&lt;/code&gt; を宣言し、それらを &lt;code&gt;getSomeObject().x&lt;/code&gt; 、 &lt;code&gt;getSomeObject().y&lt;/code&gt; 、および &lt;code&gt;getSomeObject().z&lt;/code&gt; 初期化しています。</target>
        </trans-unit>
        <trans-unit id="db47b423be9c6dadb503643273e40da05e66f4c4" translate="yes" xml:space="preserve">
          <source>For example, this TSX file:</source>
          <target state="translated">例えば、このTSXファイル。</target>
        </trans-unit>
        <trans-unit id="1f64ae55bad6947723cb4c39980b51075ca559f5" translate="yes" xml:space="preserve">
          <source>For example, this is a TypeScript file which has a JSDoc comment:</source>
          <target state="translated">例えば、これはJSDocのコメントを持つTypeScriptファイルです。</target>
        </trans-unit>
        <trans-unit id="1c40d41ae5f1e7ca8179e936e44a9e441a4508b8" translate="yes" xml:space="preserve">
          <source>For example, this is incorrect JavaScript according to the &lt;code&gt;parseFloat&lt;/code&gt; type definition which comes with TypeScript:</source>
          <target state="translated">たとえば、TypeScriptに付属している &lt;code&gt;parseFloat&lt;/code&gt; タイプ定義によると、これは正しくないJavaScriptです。</target>
        </trans-unit>
        <trans-unit id="e34c291950276ec5991b5d85beb6f5e3667694b8" translate="yes" xml:space="preserve">
          <source>For example, to create an object with an inferred type which includes &lt;code&gt;name: string&lt;/code&gt; and &lt;code&gt;id: number&lt;/code&gt;, you can write:</source>
          <target state="translated">たとえば、 &lt;code&gt;name: string&lt;/code&gt; と &lt;code&gt;id: number&lt;/code&gt; を含む推定型のオブジェクトを作成するには、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="ac02d1dd1384ae853294c750a143c0f2d98423a5" translate="yes" xml:space="preserve">
          <source>For example, using this &lt;code&gt;async&lt;/code&gt; function in ES5 requires a &lt;code&gt;await&lt;/code&gt;-like function and &lt;code&gt;generator&lt;/code&gt;-like function to run:</source>
          <target state="translated">たとえば、ES5でこの &lt;code&gt;async&lt;/code&gt; 関数を使用するには、 &lt;code&gt;await&lt;/code&gt; のような関数と &lt;code&gt;generator&lt;/code&gt; ような関数を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="3bfab5d35b8a0425d2cd933627ba6f494f7b15e6" translate="yes" xml:space="preserve">
          <source>For example, we can add a static member to a class:</source>
          <target state="translated">例えば、クラスに静的メンバを追加することができます。</target>
        </trans-unit>
        <trans-unit id="0a9664482ad4cfe889b90b76aeb2032d715f790d" translate="yes" xml:space="preserve">
          <source>For example, when you want to work with JavaScript code which extends another library.</source>
          <target state="translated">例えば、別のライブラリを拡張したJavaScriptのコードで作業したい場合。</target>
        </trans-unit>
        <trans-unit id="8e00ba77940c0426f8b1134fd175e919b0cb5147" translate="yes" xml:space="preserve">
          <source>For example, when you want to work with JavaScript code which looks like:</source>
          <target state="translated">例えば、次のようなJavaScriptのコードで作業をしたい場合。</target>
        </trans-unit>
        <trans-unit id="ba51f2462f3773f1dc6da5083642677ae6d1eee2" translate="yes" xml:space="preserve">
          <source>For example, with this TypeScript:</source>
          <target state="translated">例えば、このTypeScriptで</target>
        </trans-unit>
        <trans-unit id="4f1959c8518d6114cd18bf03e5cd677c322abf43" translate="yes" xml:space="preserve">
          <source>For example, without &lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt; as true:</source>
          <target state="translated">たとえば、 &lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt; がtrueでない場合：</target>
        </trans-unit>
        <trans-unit id="057ce67e6843578753929fc21dae6a5768fef84b" translate="yes" xml:space="preserve">
          <source>For example, you can make a function return different values depending on whether it is passed a string or an array:</source>
          <target state="translated">例えば、関数に文字列を渡すか配列を渡すかによって異なる値を返すようにすることができます。</target>
        </trans-unit>
        <trans-unit id="2a5f12f7c7d4059c89ae626ee915d1d0eb216e44" translate="yes" xml:space="preserve">
          <source>For example, you may have complex enough types to describe that you choose to namespace them inside your &lt;code&gt;.d.ts&lt;/code&gt;:</source>
          <target state="translated">たとえば、 &lt;code&gt;.d.ts&lt;/code&gt; 内で名前空間を付けることを選択したことを説明するのに十分な複雑なタイプがある場合があります。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="49d355e75376d6e3edd30760b3a9dda119888e8c" translate="yes" xml:space="preserve">
          <source>For function components (formerly known as SFCs) use ES2015 default initializers:</source>
          <target state="translated">関数コンポーネント(以前はSFCと呼ばれていた)には、ES2015のデフォルトのイニシャライザを使用します。</target>
        </trans-unit>
        <trans-unit id="6be2baf6180fb6fd27b9800124346282c6fe8435" translate="yes" xml:space="preserve">
          <source>For function members, each function member of the same name is treated as describing an overload of the same function. Of note, too, is that in the case of interface &lt;code&gt;A&lt;/code&gt; merging with later interface &lt;code&gt;A&lt;/code&gt;, the second interface will have a higher precedence than the first.</source>
          <target state="translated">関数メンバーの場合、同じ名前の各関数メンバーは、同じ関数のオーバーロードを記述するものとして扱われます。また、注目すべきは、インターフェイス &lt;code&gt;A&lt;/code&gt; が後のインターフェイス &lt;code&gt;A&lt;/code&gt; とマージする場合、2番目のインターフェイスが最初のインターフェイスよりも優先されることです。</target>
        </trans-unit>
        <trans-unit id="550510b2afc3402e9b75627c000d9fd8d68b9d48" translate="yes" xml:space="preserve">
          <source>For function types to correctly type check, the names of the parameters do not need to match. We could have, for example, written the above example like this:</source>
          <target state="translated">関数型が正しく型チェックを行うためには、パラメータの名前が一致する必要はありません。例えば、上の例ではこのように書くことができました。</target>
        </trans-unit>
        <trans-unit id="6e49fcf610fb59d8414be6f760fd4d96f45600af" translate="yes" xml:space="preserve">
          <source>For generic types that do not have their type arguments specified, compatibility is checked by specifying &lt;code&gt;any&lt;/code&gt; in place of all unspecified type arguments. The resulting types are then checked for compatibility, just as in the non-generic case.</source>
          <target state="translated">型引数が指定されていないジェネリック型の場合、互換性は、すべての未指定の型引数の代わりに &lt;code&gt;any&lt;/code&gt; を指定することによってチェックされます。結果の型は、一般的でない場合と同様に、互換性がチェックされます。</target>
        </trans-unit>
        <trans-unit id="5b3be90cb960b60b8143e001874d26a541dce254" translate="yes" xml:space="preserve">
          <source>For instance, &lt;code&gt;React.Component&lt;/code&gt; is defined to have two type parameters, &lt;code&gt;Props&lt;/code&gt; and &lt;code&gt;State&lt;/code&gt;. In a &lt;code&gt;.js&lt;/code&gt; file, there is no legal way to specify these in the extends clause. By default the type arguments will be &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">たとえば、 &lt;code&gt;React.Component&lt;/code&gt; は、 &lt;code&gt;Props&lt;/code&gt; と &lt;code&gt;State&lt;/code&gt; の 2つの型パラメーターを持つように定義されています。 &lt;code&gt;.js&lt;/code&gt; ファイル、extends節でこれらを指定する法的方法はありません。デフォルトでは、タイプ引数は &lt;code&gt;any&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ad0724dca69663ba4a457c62bb2dc6d54f13c7f2" translate="yes" xml:space="preserve">
          <source>For instance, an import to a module &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; would be translated at runtime to &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt;.</source>
          <target state="translated">たとえば、モジュール &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; へのインポートは、実行時に &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt; 変換されます。</target>
        </trans-unit>
        <trans-unit id="e127b9ec7aa54a885066eddbf73a9390682ef004" translate="yes" xml:space="preserve">
          <source>For instance, if you have something that&amp;rsquo;s typed as &lt;code&gt;Object&lt;/code&gt; you won&amp;rsquo;t be able to call methods like &lt;code&gt;toLowerCase()&lt;/code&gt; on it. Being more general usually means you can do less with a type, but &lt;code&gt;any&lt;/code&gt; is special in that it is the most general type while still allowing you to do anything with it. That means you can call it, construct it, access properties on it, etc. Keep in mind though, whenever you use &lt;code&gt;any&lt;/code&gt;, you lose out on most of the error checking and editor support that TypeScript gives you.</source>
          <target state="translated">たとえば、 &lt;code&gt;Object&lt;/code&gt; として入力されたものがある場合、そのオブジェクト &lt;code&gt;toLowerCase()&lt;/code&gt; などのメソッドを呼び出すことはできません。より一般的であることは、通常、あなたがタイプとあまり行うことができることを意味しますが、 &lt;code&gt;any&lt;/code&gt; まだあなたはそれで何かをできるようにしながら、それは最も一般的なタイプであるという点で特別です。つまり、それを呼び出したり、構築したり、プロパティにアクセスしたりできます。ただし、を使用 &lt;code&gt;any&lt;/code&gt; たびに、TypeScriptが提供するほとんどのエラーチェックとエディターサポートが失われることに注意してください。</target>
        </trans-unit>
        <trans-unit id="76f20136bdec4c8a094a4948f37f41bd9373cd0e" translate="yes" xml:space="preserve">
          <source>For instance, the following interfaces will merge together:</source>
          <target state="translated">例えば、以下のインターフェイスはマージされます。</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="cc15a1d1ae77d156b224c9eb01c61c6a21c1a488" translate="yes" xml:space="preserve">
          <source>For intrinsic elements, it is the type of the property on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;</source>
          <target state="translated">組み込み要素の場合は、 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; のプロパティのタイプです。</target>
        </trans-unit>
        <trans-unit id="63e99ee6fde01714eebc90d83730b70795fea95a" translate="yes" xml:space="preserve">
          <source>For leveraging project references, a new &lt;code&gt;createSolutionBuilder&lt;/code&gt; function has been exposed, which returns an instance of the new type &lt;code&gt;SolutionBuilder&lt;/code&gt;.</source>
          <target state="translated">プロジェクト参照を活用するために、新しい &lt;code&gt;createSolutionBuilder&lt;/code&gt; 関数が公開されました。この関数は、新しいタイプ &lt;code&gt;SolutionBuilder&lt;/code&gt; のインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="d4f49775acc3a4322a0557d39b3d6b9d1f2d24cf" translate="yes" xml:space="preserve">
          <source>For more details on the change, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2983&quot;&gt;see the pull request here&lt;/a&gt;.</source>
          <target state="translated">変更の詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2983&quot;&gt;こちらのプルリクエストをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="43fc548897db905fa8c2333f2655e946bf2edbda" translate="yes" xml:space="preserve">
          <source>For more details on the implementation, see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29332&quot;&gt;the feature&amp;rsquo;s pull request&lt;/a&gt;.</source>
          <target state="translated">実装の詳細について&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29332&quot;&gt;は、機能のプルリクエストを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="c866e562806b98ab3450aefd85c82570ae3dbe52" translate="yes" xml:space="preserve">
          <source>For more details on these APIs, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31432&quot;&gt;see the original pull request&lt;/a&gt;.</source>
          <target state="translated">これらのAPIの詳細&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31432&quot;&gt;については、元のプルリクエストをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9db932b4f370cac7158608164dcc7323460cd641" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30552&quot;&gt;see the pull request on GitHub to add &lt;code&gt;Omit&lt;/code&gt;&lt;/a&gt;, as well as &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31134&quot;&gt;the change to use &lt;code&gt;Omit&lt;/code&gt; for object rest&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30552&quot;&gt;GitHubの上のプルリクエストを追加するために見 &lt;code&gt;Omit&lt;/code&gt; &lt;/a&gt;だけでなく、&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31134&quot;&gt;使用するために変更 &lt;code&gt;Omit&lt;/code&gt; 目的残りのため&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc45d221d48c167e7361605c82635e85e5e5877b" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30776/files&quot;&gt;see the pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30776/files&quot;&gt;GitHubのプルリクエストをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="273ca0c112dc6b1882314478ee8c1e6544170b8e" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/30646&quot;&gt;see the originating issue&lt;/a&gt;, as well as the pull requests that link back to it.</source>
          <target state="translated">詳細について&lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/30646&quot;&gt;は、元の問題と&lt;/a&gt;、それにリンクしているプルリクエストをご覧ください。</target>
        </trans-unit>
        <trans-unit id="990cc8daa552812b9673fb27d79710d0a0853e7a" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31801&quot;&gt;see the corresponding pull request&lt;/a&gt;.</source>
          <target state="translated">詳細について&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31801&quot;&gt;は、対応するプルリクエストをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0320510c766022af54173463f58fd051469373de" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32584&quot;&gt;see the original PR on GitHub&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32584&quot;&gt;GitHubの元のPRを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1fe5d1addf9d0d4b733550ed18ffe6381b947a86" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29510&quot;&gt;check out the respective pull request&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29510&quot;&gt;それぞれのプルリクエストを確認してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65484dc7f4c4daea7c1d319eb8233395f4407267" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30215&quot;&gt;read more at the original change&lt;/a&gt;.</source>
          <target state="translated">詳しくは、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30215&quot;&gt;最初の変更点をご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="563dc4e63b054412d2401fc516c6fac2d3df7317" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/30779&quot;&gt;see the original pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">詳細について&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/30779&quot;&gt;は、元のプルリクエストをGitHubで確認&lt;/a&gt;できます。</target>
        </trans-unit>
        <trans-unit id="01a8abf26dc21e0236d3ae01896624d8b626ea07" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32372&quot;&gt;check out the original pull request&lt;/a&gt;.</source>
          <target state="translated">詳しくは、&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32372&quot;&gt;元のプルリクエストを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="d623177cf84777887441acfa37b705f15554d05f" translate="yes" xml:space="preserve">
          <source>For more details, you can see the pull requests to</source>
          <target state="translated">へのプルリクエストを参照してください。</target>
        </trans-unit>
        <trans-unit id="3e64e60d7e437a1ebcf2869771b212e3f2906370" translate="yes" xml:space="preserve">
          <source>For more discussion about modules and namespaces see &lt;a href=&quot;namespaces-and-modules&quot;&gt;Namespaces and Modules&lt;/a&gt;.</source>
          <target state="translated">モジュールと名前空間の詳細については、&lt;a href=&quot;namespaces-and-modules&quot;&gt;名前空間とモジュールを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c362b5af66f291c8b84b625e56119e3fdeab25b4" translate="yes" xml:space="preserve">
          <source>For more information about module, please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2242&quot;&gt;ES6 module support spec&lt;/a&gt;.</source>
          <target state="translated">モジュールの詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2242&quot;&gt;ES6モジュールサポート仕様&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="1d6421ff56f450a4d8627e4516ee9a9c34657258" translate="yes" xml:space="preserve">
          <source>For more information on temporal dead zones, see relevant content on the &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;Mozilla Developer Network&lt;/a&gt;.</source>
          <target state="translated">一時的なデッドゾーンの詳細については、&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;Mozilla DeveloperNetworkの&lt;/a&gt;関連コンテンツを参照してください。</target>
        </trans-unit>
        <trans-unit id="570e8203155764ac5cbba766759ffb8d69bcac89" translate="yes" xml:space="preserve">
          <source>For more information on temporal dead zones, see relevant content on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;Mozilla Developer Network&lt;/a&gt;.</source>
          <target state="translated">一時的なデッドゾーンの詳細については、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;Mozilla Developer Networkの&lt;/a&gt;関連コンテンツを参照してください。</target>
        </trans-unit>
        <trans-unit id="0ab5ee6f96a4e7a69065dcddd9a55b08eb5aae39" translate="yes" xml:space="preserve">
          <source>For more information on these flags:</source>
          <target state="translated">これらの旗の詳細については</target>
        </trans-unit>
        <trans-unit id="c6fb17b499b05834e5a93ed9076041c12b5a0a99" translate="yes" xml:space="preserve">
          <source>For more information see &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx&quot;&gt;Async Functions&lt;/a&gt; blog post.</source>
          <target state="translated">詳細については、&lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx&quot;&gt;非同期関数の&lt;/a&gt;ブログ投稿を参照してください。</target>
        </trans-unit>
        <trans-unit id="e181d79ed93cb811ae26b48402f5381960e6dbda" translate="yes" xml:space="preserve">
          <source>For more information, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31166&quot;&gt;see the relevant pull request&lt;/a&gt;.</source>
          <target state="translated">詳細について&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31166&quot;&gt;は、関連するプルリクエストをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b92828c4a7429aa0dedb168e31c48305dd400088" translate="yes" xml:space="preserve">
          <source>For more information, please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2249&quot;&gt;Decorators&lt;/a&gt; proposal.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2249&quot;&gt;デコレータの&lt;/a&gt;提案をご覧ください。</target>
        </trans-unit>
        <trans-unit id="e5cfc8aafd6a1b42f41322e6dfe173a4a83dcba5" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html&quot;&gt;TypeScript spec&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html&quot;&gt;TypeScript仕様を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7b6d8db7682d13acc39e4cc45f1bdba1511a9906" translate="yes" xml:space="preserve">
          <source>For more information, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33050&quot;&gt;read up on the original pull request&lt;/a&gt;.</source>
          <target state="translated">詳細について&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33050&quot;&gt;は、元のプルリクエストを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="343ef5950853198d94dec424b2d3547e8d8f6fca" translate="yes" xml:space="preserve">
          <source>For more information, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33509&quot;&gt;take a look at the original pull request for these changes&lt;/a&gt;.</source>
          <target state="translated">詳細については&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33509&quot;&gt;、これらの変更の元のプルリクエストを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="705c8bb533b7a415fffecd94e72c06081d3e2f68" translate="yes" xml:space="preserve">
          <source>For non-relative module imports, however, the compiler walks up the directory tree starting with the directory containing the importing file, trying to locate a matching definition file.</source>
          <target state="translated">しかし、非関連モジュールのインポートでは、コンパイラはインポートファイルのあるディレクトリから始まるディレクトリツリーを歩き、一致する定義ファイルを見つけようとします。</target>
        </trans-unit>
        <trans-unit id="d23566da87d8229f77380a239e48562a8a823cce" translate="yes" xml:space="preserve">
          <source>For npm users:</source>
          <target state="translated">npmをお使いの方へ。</target>
        </trans-unit>
        <trans-unit id="fe8f9cb290ffb799bb30074ff74b3c823de4c1a0" translate="yes" xml:space="preserve">
          <source>For one, TypeScript can now make inferences for the return type of a call. This can improve your experience and catch errors. Something that now works:</source>
          <target state="translated">一つには、TypeScript は呼び出しの戻り値の型を推論できるようになりました。これにより、経験値を向上させ、エラーをキャッチすることができます。何かが動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="8e2e83bc37a28c5942c02bb933ef427bb23983d8" translate="yes" xml:space="preserve">
          <source>For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like. In TypeScript, we support much the same types as you would expect in JavaScript, with a convenient enumeration type thrown in to help things along.</source>
          <target state="translated">プログラムが有用であるためには、最も単純なデータ単位である数値、文字列、構造体、ブール値などを扱うことができる必要があります。TypeScriptでは、JavaScriptで期待されているのと同じ型をサポートしていますが、便利な列挙型が追加されています。</target>
        </trans-unit>
        <trans-unit id="15f0842c032b4d0063a3b23f1886d7cbeefa49c8" translate="yes" xml:space="preserve">
          <source>For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like. In TypeScript, we support the same types as you would expect in JavaScript, with an extra enumeration type thrown in to help things along.</source>
          <target state="translated">プログラムが有用であるためには、最も単純なデータ単位である数値、文字列、構造体、ブール値などを扱うことができる必要があります。TypeScriptでは、JavaScriptで期待されているのと同じ型をサポートしていますが、それを助けるために列挙型を追加しています。</target>
        </trans-unit>
        <trans-unit id="d3344c32461a0db1e0c782f128f60f424dfe694b" translate="yes" xml:space="preserve">
          <source>For seasoned authors interested in the underlying mechanics of how declaration files work, the &lt;a href=&quot;deep-dive&quot;&gt;Deep Dive&lt;/a&gt; section explains many advanced concepts in declaration writing, and shows how to leverage these concepts to create cleaner and more intuitive declaration files.</source>
          <target state="translated">&lt;a href=&quot;deep-dive&quot;&gt;ディープダイブ&lt;/a&gt;セクションでは、宣言ファイルの仕組みの基礎となるメカニズムに関心のある熟練した著者向けに、宣言の記述における多くの高度な概念を説明し、これらの概念を活用してより明確で直感的な宣言ファイルを作成する方法を示します。</target>
        </trans-unit>
        <trans-unit id="13f368b0d84c902186b48234f4040bb16257c671" translate="yes" xml:space="preserve">
          <source>For that reason, we have no immediate plans to provide downleveling support. On the bright side, Node 11 and newer versions of Chrome already support this feature, so you&amp;rsquo;ll be able to use BigInts there when targeting &lt;code&gt;esnext&lt;/code&gt;.</source>
          <target state="translated">そのため、ダウンレベリングのサポートを提供する計画は今のところありません。あなたがターゲットとする場合がありBigIntsを使用することができますので、明るい側では、ノード11とChromeの新しいバージョンがすでに、この機能をサポート &lt;code&gt;esnext&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="496e704960f5aa1a3e087ed13654d88d3dfbb5fa" translate="yes" xml:space="preserve">
          <source>For the first definition of &lt;code&gt;createElement&lt;/code&gt;, it is using some advanced generic patterns. It is best understood broken down into chunks, starting with the generic expression: &lt;code&gt;&amp;lt;K extends keyof HTMLElementTagNameMap&amp;gt;&lt;/code&gt;. This expression defines a generic parameter &lt;code&gt;K&lt;/code&gt; that is &lt;em&gt;constrained&lt;/em&gt; to the keys of the interface &lt;code&gt;HTMLElementTagNameMap&lt;/code&gt;. The map interface contains every specified HTML tag name and its corresponding type interface. For example here are the first 5 mapped values:</source>
          <target state="translated">&lt;code&gt;createElement&lt;/code&gt; の最初の定義では、いくつかの高度な汎用パターンを使用しています。 &lt;code&gt;&amp;lt;K extends keyof HTMLElementTagNameMap&amp;gt;&lt;/code&gt; という一般的な式から始めて、チャンクに分割して理解するのが最も適切です。この式は、インターフェース &lt;code&gt;HTMLElementTagNameMap&lt;/code&gt; のキーに&lt;em&gt;制約&lt;/em&gt;されるジェネリックパラメーター &lt;code&gt;K&lt;/code&gt; を定義します。マップインターフェイスには、指定されたすべてのHTMLタグ名とそれに対応するタイプインターフェイスが含まれています。たとえば、最初の5つのマップ値は次のとおりです。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a1b0a9136ffac4466c13d6e276a81e02a3314c15" translate="yes" xml:space="preserve">
          <source>For the most part, type declaration packages should always have the same name as the package name on &lt;code&gt;npm&lt;/code&gt;, but prefixed with &lt;code&gt;@types/&lt;/code&gt;, but if you need, you can check out &lt;a href=&quot;https://aka.ms/types&quot;&gt;https://aka.ms/types&lt;/a&gt; to find the package for your favorite library.</source>
          <target state="translated">ほとんどの場合、型宣言パッケージは常に &lt;code&gt;npm&lt;/code&gt; のパッケージ名と同じ名前にする必要がありますが、先頭に &lt;code&gt;@types/&lt;/code&gt; 付けますが、必要に応じて、&lt;a href=&quot;https://aka.ms/types&quot;&gt;https：//aka.ms/types&lt;/a&gt;をチェックしてパッケージを見つけることができます。お気に入りのライブラリに。</target>
        </trans-unit>
        <trans-unit id="bf75b06c8fc661aa3a2f64f5da3a4e9c2051e897" translate="yes" xml:space="preserve">
          <source>For the most part, type declaration packages should always have the same name as the package name on &lt;code&gt;npm&lt;/code&gt;, but prefixed with &lt;code&gt;@types/&lt;/code&gt;, but if you need, you can check out &lt;a href=&quot;https://aka.ms/types&quot;&gt;this Type Search&lt;/a&gt; to find the package for your favorite library.</source>
          <target state="translated">ほとんどの場合、型宣言パッケージは常に &lt;code&gt;npm&lt;/code&gt; のパッケージ名と同じ名前である必要がありますが、接頭辞は &lt;code&gt;@types/&lt;/code&gt; ですが、必要に応じて、&lt;a href=&quot;https://aka.ms/types&quot;&gt;この型検索&lt;/a&gt;をチェックして、お気に入りのライブラリのパッケージを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="034fabf95397dd3d830d8bf8625f29b5fecddc83" translate="yes" xml:space="preserve">
          <source>For the purposes of this article, &amp;ldquo;declaration merging&amp;rdquo; means that the compiler merges two separate declarations declared with the same name into a single definition. This merged definition has the features of both of the original declarations. Any number of declarations can be merged; it&amp;rsquo;s not limited to just two declarations.</source>
          <target state="translated">この記事では、「宣言のマージ」とは、コンパイラーが同じ名前で宣言された2つの別々の宣言を1つの定義にマージすることを意味します。このマージされた定義には、元の宣言の両方の機能があります。宣言はいくつでもマージできます。2つの宣言に限定されません。</target>
        </trans-unit>
        <trans-unit id="14bbf380d646374ad4976a37ddd3a52586d0778f" translate="yes" xml:space="preserve">
          <source>For the purposes of writing a declaration file, you&amp;rsquo;ll write the same code whether the module being changed is a plain module or UMD module.</source>
          <target state="translated">宣言ファイルを作成するために、変更するモジュールがプレーンモジュールでもUMDモジュールでも同じコードを作成します。</target>
        </trans-unit>
        <trans-unit id="4aa3bad258aff42d4d06a5737732c3217bc98418" translate="yes" xml:space="preserve">
          <source>For this feature and simplified props, be sure to be use the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react&quot;&gt;latest version of react.d.ts&lt;/a&gt;.</source>
          <target state="translated">この機能と簡略化された小道具については、必ず&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react&quot;&gt;最新バージョンのreact.d.tsを&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="c1668e641a54e156c170e61580f6a7e55c2d3f64" translate="yes" xml:space="preserve">
          <source>For those interested, you can interact with custom tag elements using the &lt;code&gt;document.getElementsByTagName&lt;/code&gt;</source>
          <target state="translated">興味のある方は、 &lt;code&gt;document.getElementsByTagName&lt;/code&gt; を使用してカスタムタグ要素を操作できます。</target>
        </trans-unit>
        <trans-unit id="a33482387ee5a013d484cb5ab80e458b7353dca7" translate="yes" xml:space="preserve">
          <source>For those unfamiliar, &lt;code&gt;setTimeout&lt;/code&gt; will try to execute a function after a certain number of milliseconds (though waiting for anything else to stop running).</source>
          <target state="translated">なじみのない人のために、 &lt;code&gt;setTimeout&lt;/code&gt; は特定のミリ秒後に関数の実行を試みます（ただし、他のものが実行を停止するのを待っています）。</target>
        </trans-unit>
        <trans-unit id="a2a4c15a4041ed86596a75791caa9f86b76bf038" translate="yes" xml:space="preserve">
          <source>For value-based elements, it is a bit more complex. It is determined by the type of a property on the &lt;em&gt;element instance type&lt;/em&gt; that was previously determined. Which property to use is determined by &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt;. It should be declared with a single property. The name of that property is then used. As of TypeScript 2.8, if &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; is not provided, the type of first parameter of the class element&amp;rsquo;s constructor or Function Component&amp;rsquo;s call will be used instead.</source>
          <target state="translated">値ベースの要素の場合、少し複雑です。これは、以前に決定された&lt;em&gt;要素インスタンスタイプの&lt;/em&gt;プロパティのタイプによって決定され&lt;em&gt;ます&lt;/em&gt;。使用するプロパティは &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; によって決定されます。単一のプロパティで宣言する必要があります。次に、そのプロパティの名前が使用されます。TypeScript 2.8以降、 &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; が提供されていない場合は、代わりにクラス要素のコンストラクターの最初のパラメーターのタイプまたは関数コンポーネントの呼び出しが使用されます。</target>
        </trans-unit>
        <trans-unit id="ec762285a1b4a4ed67329132319bc54b9b6e3580" translate="yes" xml:space="preserve">
          <source>Force Consistent Casing In File Names - &lt;code&gt;forceConsistentCasingInFileNames&lt;/code&gt;</source>
          <target state="translated">ファイル名の一貫したケーシングを &lt;code&gt;forceConsistentCasingInFileNames&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c5aa86e5ed9112fe776d6f8c8f31ff44490232e" translate="yes" xml:space="preserve">
          <source>Free Functions and Data</source>
          <target state="translated">フリー関数とデータ</target>
        </trans-unit>
        <trans-unit id="a5600addb2b77d2558fa7ff723f4b60ade1a0397" translate="yes" xml:space="preserve">
          <source>From TypeScript 3.7 and onwards, you can use &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining&quot;&gt;optional chaining&lt;/a&gt; to simplify working with nullable types.</source>
          <target state="translated">TypeScript 3.7以降では、&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining&quot;&gt;オプションのチェーン&lt;/a&gt;を使用して、null許容型の操作を簡素化できます。</target>
        </trans-unit>
        <trans-unit id="cd4106b2c3bf5670711745c735fa13bc35a27218" translate="yes" xml:space="preserve">
          <source>From TypeScript 3.7 and onwards, you can use &lt;a href=&quot;release-notes/typescript-3-7#optional-chaining&quot;&gt;optional chaining&lt;/a&gt; to simplify working with nullable types.</source>
          <target state="translated">TypeScript 3.7以降では、&lt;a href=&quot;release-notes/typescript-3-7#optional-chaining&quot;&gt;オプションのチェーン&lt;/a&gt;を使用して、null許容型の操作を簡略化できます。</target>
        </trans-unit>
        <trans-unit id="978d60f8509ec4db7ded456faee49383919753b1" translate="yes" xml:space="preserve">
          <source>From TypeScript 3.8 onwards, you can use JSDoc to modify the properties in a class. First are the accessibility modifiers: &lt;code&gt;@public&lt;/code&gt;, &lt;code&gt;@private&lt;/code&gt;, and &lt;code&gt;@protected&lt;/code&gt;. These tags work exactly like &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;, and &lt;code&gt;protected&lt;/code&gt; respectively work in TypeScript.</source>
          <target state="translated">TypeScript 3.8以降では、JSDocを使用してクラスのプロパティを変更できます。最初はアクセシビリティ修飾子です： &lt;code&gt;@private&lt;/code&gt; &lt;code&gt;@public&lt;/code&gt; 、@ private、および &lt;code&gt;@protected&lt;/code&gt; 。これらのタグは、 &lt;code&gt;public&lt;/code&gt; 、 &lt;code&gt;private&lt;/code&gt; 、 &lt;code&gt;protected&lt;/code&gt; がそれぞれTypeScriptで機能するのとまったく同じように機能します。</target>
        </trans-unit>
        <trans-unit id="2c70347006d57179eb4e0296dfeec4d48fd56374" translate="yes" xml:space="preserve">
          <source>From a Global Library</source>
          <target state="translated">グローバルライブラリから</target>
        </trans-unit>
        <trans-unit id="7a9218b43b092d03a0883f8b7857dbb282cdf813" translate="yes" xml:space="preserve">
          <source>From a Module or UMD Library</source>
          <target state="translated">モジュールまたはUMDライブラリから</target>
        </trans-unit>
        <trans-unit id="3f9c703cb24035f076046daf82d5597961381bc0" translate="yes" xml:space="preserve">
          <source>From a PowerShell command window, run:</source>
          <target state="translated">PowerShell のコマンドウィンドウから実行します。</target>
        </trans-unit>
        <trans-unit id="b107342b8b3dda22c1b15ba7f4fbcc3adcc5a2ea" translate="yes" xml:space="preserve">
          <source>From here, we&amp;rsquo;d recommend learning some of the JavaScript fundamentals (the &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Guide&quot;&gt;JavaScript guide at the Mozilla Web Docs&lt;/a&gt; is a good starting point.)</source>
          <target state="translated">ここから、JavaScriptの基礎のいくつかを学ぶことをお勧めします（&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Guide&quot;&gt;Mozilla Web DocsのJavaScriptガイド&lt;/a&gt;は良い出発点です）。</target>
        </trans-unit>
        <trans-unit id="108836dc86d3f675e6c3eef00af882d27efb9073" translate="yes" xml:space="preserve">
          <source>From there you&amp;rsquo;ll be able to use lodash in your TypeScript code with no fuss. This works for both modules and global code.</source>
          <target state="translated">そこからTypeScriptコードでlodashを手間をかけずに使用できます。これは、モジュールとグローバルコードの両方で機能します。</target>
        </trans-unit>
        <trans-unit id="50c9f7eb832e49ced6feaff6d4be4040d50a7444" translate="yes" xml:space="preserve">
          <source>From this point on, we&amp;rsquo;re going to assume that your directory is set up something like this:</source>
          <target state="translated">この時点から、ディレクトリが次のように設定されていると想定します。</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="1177b1db377a31fa211c1c837c048902a33fbabc" translate="yes" xml:space="preserve">
          <source>Function Component</source>
          <target state="translated">機能コンポーネント</target>
        </trans-unit>
        <trans-unit id="14e60fa4031e0e6cd85f9e19b012d6dbfc7853ec" translate="yes" xml:space="preserve">
          <source>Function Component (FC)</source>
          <target state="translated">ファンクションコンポーネント(FC)</target>
        </trans-unit>
        <trans-unit id="957953f67e0718500a80224139b161eb239e35fa" translate="yes" xml:space="preserve">
          <source>Function Components in React</source>
          <target state="translated">Reactにおける関数コンポーネント</target>
        </trans-unit>
        <trans-unit id="37eaf4a6db3ea0747ab9364bd4d5e24895e0a544" translate="yes" xml:space="preserve">
          <source>Function Overloads</source>
          <target state="translated">関数のオーバーロード</target>
        </trans-unit>
        <trans-unit id="a258c02eba54e3e0953a40abe8602fb6e1a74ef6" translate="yes" xml:space="preserve">
          <source>Function Parameter Bivariance</source>
          <target state="translated">関数パラメータの二重分散</target>
        </trans-unit>
        <trans-unit id="c57d64280c18c54778c8d1947833e0036b6e26da" translate="yes" xml:space="preserve">
          <source>Function Truthy Checks</source>
          <target state="translated">ファンクション・トゥルーティチェック</target>
        </trans-unit>
        <trans-unit id="5b51ae5c386fcffd7ce1ff55e49610a2a8af3637" translate="yes" xml:space="preserve">
          <source>Function Types</source>
          <target state="translated">機能の種類</target>
        </trans-unit>
        <trans-unit id="301ffb948f7d729015635b11db6553b40624b34f" translate="yes" xml:space="preserve">
          <source>Function declarations</source>
          <target state="translated">関数宣言</target>
        </trans-unit>
        <trans-unit id="c5db83a75bbeef08fa2e0b320c74460786ae66aa" translate="yes" xml:space="preserve">
          <source>Function parameters are checked one at a time, with the type in each corresponding parameter position checked against each other. If you do not want to specify types at all, TypeScript&amp;rsquo;s contextual typing can infer the argument types since the function value is assigned directly to a variable of type &lt;code&gt;SearchFunc&lt;/code&gt;. Here, also, the return type of our function expression is implied by the values it returns (here &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">関数パラメーターは一度に1つずつチェックされ、対応する各パラメーター位置の型が互いにチェックされます。タイプをまったく指定したくない場合、関数値はタイプ &lt;code&gt;SearchFunc&lt;/code&gt; の変数に直接割り当てられるため、TypeScriptのコンテキストタイプは引数タイプを推測できます。ここでも、関数式の戻り値の型は、関数が返す値（ここでは &lt;code&gt;false&lt;/code&gt; と &lt;code&gt;true&lt;/code&gt; ）によって暗示されています。</target>
        </trans-unit>
        <trans-unit id="53ffe91c4f4d77a902ebdf074913f42349003bbc" translate="yes" xml:space="preserve">
          <source>Function parameters are optional by default</source>
          <target state="translated">関数パラメータはデフォルトではオプションです。</target>
        </trans-unit>
        <trans-unit id="ed95afc615d05f6e5368c71005cf262d6343db73" translate="yes" xml:space="preserve">
          <source>Function syntax includes parameter names. This is pretty hard to get used to!</source>
          <target state="translated">関数の構文にはパラメータ名が含まれています。これは慣れるまでかなり大変です!</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="f3665432e1a6db576efaea1b6e2d8f839bcdcc98" translate="yes" xml:space="preserve">
          <source>Functions are the fundamental building block of any application in JavaScript. They&amp;rsquo;re how you build up layers of abstraction, mimicking classes, information hiding, and modules. In TypeScript, while there are classes, namespaces, and modules, functions still play the key role in describing how to &lt;em&gt;do&lt;/em&gt; things. TypeScript also adds some new capabilities to the standard JavaScript functions to make them easier to work with.</source>
          <target state="translated">関数は、JavaScriptのアプリケーションの基本的な構成要素です。これらは、抽象化、模倣クラス、情報非表示、およびモジュールのレイヤーを構築する方法です。TypeScriptでは、クラス、名前空間、およびモジュールがありますが、関数&lt;em&gt;は、&lt;/em&gt;物事を&lt;em&gt;行う&lt;/em&gt;方法を説明する上で重要な役割を果たします。TypeScriptは、標準のJavaScript関数にいくつかの新しい機能を追加して、操作をより簡単にします。</target>
        </trans-unit>
        <trans-unit id="16cd3a7ed4cd7f04f6e352a9b0a671ae06c3867d" translate="yes" xml:space="preserve">
          <source>Functions with code paths that do not return a value in JS implicitly return &lt;code&gt;undefined&lt;/code&gt;. These can now be flagged by the compiler as implicit returns. The check is turned &lt;em&gt;off&lt;/em&gt; by default; use &lt;code&gt;--noImplicitReturns&lt;/code&gt; to turn it on.</source>
          <target state="translated">JSで値を返さないコードパスを持つ関数は、暗黙的に &lt;code&gt;undefined&lt;/code&gt; を返します。これらは、コンパイラによって暗黙的な戻りとしてフラグを立てられるようになりました。チェックはデフォルトで&lt;em&gt;オフになっ&lt;/em&gt;ています。オンにするには、 &lt;code&gt;--noImplicitReturns&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="ecfd08105c3b9ed934caafb326908c0acb570490" translate="yes" xml:space="preserve">
          <source>Functions with overloads</source>
          <target state="translated">オーバーロードを持つ関数</target>
        </trans-unit>
        <trans-unit id="4f257e8843abb1bab8a5b85a60f95a4c0139aa46" translate="yes" xml:space="preserve">
          <source>Functions: this</source>
          <target state="translated">関数:この</target>
        </trans-unit>
        <trans-unit id="6089bda1a34a0c953770c8e3b78bec0ef08e1cc9" translate="yes" xml:space="preserve">
          <source>Furthermore, TypeScript also has the notion of &lt;em&gt;global&lt;/em&gt; augmentations of the form &lt;code&gt;declare global { }&lt;/code&gt;. This allows modules to augment global types such as &lt;code&gt;Array&lt;/code&gt; if necessary.</source>
          <target state="translated">さらに、TypeScriptには、 &lt;code&gt;declare global { }&lt;/code&gt; という形式の&lt;em&gt;グローバルな&lt;/em&gt;拡張の概念もあります。これにより、モジュールは必要に応じて &lt;code&gt;Array&lt;/code&gt; などのグローバルタイプを拡張できます。</target>
        </trans-unit>
        <trans-unit id="4df80e4187f2b8baf6d47a6fdeef464676adeda2" translate="yes" xml:space="preserve">
          <source>Furthermore, in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, control flow based type analysis includes &lt;em&gt;definite assignment analysis&lt;/em&gt; for local variables of types that don&amp;rsquo;t permit the value &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">さらに、 &lt;code&gt;--strictNullChecks&lt;/code&gt; モードでは、制御フローベースのタイプ分析に、値 &lt;code&gt;undefined&lt;/code&gt; を許可しないタイプのローカル変数の&lt;em&gt;明確な代入分析が&lt;/em&gt;含まれます。</target>
        </trans-unit>
        <trans-unit id="b94633d2f5a1028f484d02bb58c0c7929a0b9214" translate="yes" xml:space="preserve">
          <source>Furthermore, with the &lt;code&gt;keyof&lt;/code&gt; operator&amp;rsquo;s support for &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named keys, it is now possible to abstract over access to properties of objects that are indexed by numeric literals (such as numeric enum types) and unique symbols.</source>
          <target state="translated">さらに、 &lt;code&gt;keyof&lt;/code&gt; オペレーターが &lt;code&gt;number&lt;/code&gt; と &lt;code&gt;symbol&lt;/code&gt; 名前付きキーをサポートすることで、数値リテラル（数値列挙型など）と一意のシンボルによってインデックスが付けられたオブジェクトのプロパティへのアクセスを抽象化できるようになりました。</target>
        </trans-unit>
        <trans-unit id="33a55d7b2a4c629fc605606fd7d8bd91685e04a3" translate="yes" xml:space="preserve">
          <source>Future versions of TypeScript may introduce additional stricter checking under this flag, so upgrades of TypeScript might result in new type errors in your program. When appropriate and possible, a corresponding flag will be added to disable that behavior.</source>
          <target state="translated">TypeScript の将来のバージョンでは、このフラグの下でさらに厳しいチェックが導入されるかもしれないので、TypeScript をアップグレードすると、プログラム内で新しい型エラーが発生する可能性があります。適切で可能な場合には、この動作を無効にするためのフラグが追加されます。</target>
        </trans-unit>
        <trans-unit id="0c7eb0b3402889bd567c0d3af8902acae19e04ce" translate="yes" xml:space="preserve">
          <source>General Types</source>
          <target state="translated">一般的なタイプ</target>
        </trans-unit>
        <trans-unit id="31aa08b13ef05b660d703277cd9eaf4495dd69d5" translate="yes" xml:space="preserve">
          <source>Generally, you won&amp;rsquo;t need to use this.</source>
          <target state="translated">通常、これを使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="4b96ccfadf72cdc8e8186c38b80b976cc57f7091" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;.d.ts&lt;/code&gt; files for every TypeScript or JavaScript file inside your project. These &lt;code&gt;.d.ts&lt;/code&gt; files are type definition files which describe the external API of your module. With &lt;code&gt;.d.ts&lt;/code&gt; files, tools like TypeScript can provide intellisense and accurate types for un-typed code.</source>
          <target state="translated">プロジェクト内のすべてのTypeScriptまたはJavaScriptファイルに対して &lt;code&gt;.d.ts&lt;/code&gt; ファイルを生成します。これらの &lt;code&gt;.d.ts&lt;/code&gt; ファイルは、モジュールの外部APIを記述するタイプ定義ファイルです。 &lt;code&gt;.d.ts&lt;/code&gt; のファイル、活字体のようなツールがun-入力したコードのためのインテリセンスや正確な種類を提供することができます。</target>
        </trans-unit>
        <trans-unit id="437f20984d6e132889941d988b14b86cfa9f9862" translate="yes" xml:space="preserve">
          <source>Generate CPU Profile - &lt;code&gt;generateCpuProfile&lt;/code&gt;</source>
          <target state="translated">CPUプロファイルを生成- &lt;code&gt;generateCpuProfile&lt;/code&gt; を</target>
        </trans-unit>
        <trans-unit id="b2fce69037144d8c17c57e4cd48ef47f73df98fb" translate="yes" xml:space="preserve">
          <source>Generated JS code:</source>
          <target state="translated">JSコードを生成しました。</target>
        </trans-unit>
        <trans-unit id="819ddb970af7944124739b463d184873a1a7a985" translate="yes" xml:space="preserve">
          <source>Generates a cpu profile at the given path. Passing an existing directory name instead of a file path will cause a timestamp-named profile to be generated in that directory instead.</source>
          <target state="translated">指定されたパスに CPU プロファイルを生成します。ファイルパスの代わりに既存のディレクトリ名を渡すと、代わりにそのディレクトリにタイムスタンプ名のプロファイルが生成されます。</target>
        </trans-unit>
        <trans-unit id="dfdc500a2df569ef69f2127f8241641852a3dbd0" translate="yes" xml:space="preserve">
          <source>Generates a source map for &lt;code&gt;.d.ts&lt;/code&gt; files which map back to the original &lt;code&gt;.ts&lt;/code&gt; source file. This will allow editors such as VS Code to go to the original &lt;code&gt;.ts&lt;/code&gt; file when using features like &lt;em&gt;Go to Definition&lt;/em&gt;.</source>
          <target state="translated">元の &lt;code&gt;.ts&lt;/code&gt; ソースファイルにマップする &lt;code&gt;.d.ts&lt;/code&gt; ファイルのソースマップを生成します。これにより、&lt;em&gt;Go to Definition&lt;/em&gt;などの機能を使用するときに、 &lt;code&gt;.ts&lt;/code&gt; などのエディターが元の.tsファイルに&lt;em&gt;移動&lt;/em&gt;できるようになります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2d8f07103db6977c68e0ada027ab65c5c23862d9" translate="yes" xml:space="preserve">
          <source>Generates a sourcemap for each corresponding &amp;lsquo;.d.ts&amp;rsquo; file.</source>
          <target state="translated">対応する各「.d.ts」ファイルのソースマップを生成します。</target>
        </trans-unit>
        <trans-unit id="0ba70dfbfb3ac05d2ef01a114d8d061e0873111b" translate="yes" xml:space="preserve">
          <source>Generates a sourcemap for each corresponding &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="translated">対応する各 &lt;code&gt;.d.ts&lt;/code&gt; ファイルのソースマップを生成します。</target>
        </trans-unit>
        <trans-unit id="a2e42f3b65f8aeda6abb391f2b5c0feb9f71f346" translate="yes" xml:space="preserve">
          <source>Generates corresponding &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="translated">対応する &lt;code&gt;.d.ts&lt;/code&gt; ファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="285e568bc8b6f7ba3db03d758216b4279b6fb84a" translate="yes" xml:space="preserve">
          <source>Generates corresponding &lt;code&gt;.map&lt;/code&gt; file.</source>
          <target state="translated">対応する &lt;code&gt;.map&lt;/code&gt; ファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="0edb628a9542a14f813bd7de9f8386b56c8a58b5" translate="yes" xml:space="preserve">
          <source>Generates:</source>
          <target state="translated">Generates:</target>
        </trans-unit>
        <trans-unit id="a3e705cc61a19f33d7c9c030f107a70569966485" translate="yes" xml:space="preserve">
          <source>Generators</source>
          <target state="translated">Generators</target>
        </trans-unit>
        <trans-unit id="44da76948f45623de7d336c343233faa5d2b509e" translate="yes" xml:space="preserve">
          <source>Generators and Iteration for ES5/ES3</source>
          <target state="translated">ES5/ES3用のジェネレータとイテレーション</target>
        </trans-unit>
        <trans-unit id="052f4c16b4b91a827312bf3baa166ba53bfe5efa" translate="yes" xml:space="preserve">
          <source>Generic Classes</source>
          <target state="translated">汎用クラス</target>
        </trans-unit>
        <trans-unit id="c1219cf49a0e939b3e16bf04e12e2eafc84ee7fd" translate="yes" xml:space="preserve">
          <source>Generic Constraints</source>
          <target state="translated">一般的な制約</target>
        </trans-unit>
        <trans-unit id="6e69a2fc2c745899f35839a75d651978ee056569" translate="yes" xml:space="preserve">
          <source>Generic Types</source>
          <target state="translated">一般的なタイプ</target>
        </trans-unit>
        <trans-unit id="15d759be2080d6d18e338e98d07714f4c409146a" translate="yes" xml:space="preserve">
          <source>Generic object rest variables and parameters</source>
          <target state="translated">一般的なオブジェクトの残りの変数とパラメータ</target>
        </trans-unit>
        <trans-unit id="1fdeebd1c396649ca4cc647737cc5d4a10b10b8f" translate="yes" xml:space="preserve">
          <source>Generic parameter defaults</source>
          <target state="translated">汎用パラメータのデフォルト</target>
        </trans-unit>
        <trans-unit id="001622f41013d0601ab935e2183da475e787cfd4" translate="yes" xml:space="preserve">
          <source>Generic rest parameters</source>
          <target state="translated">一般的な休息パラメータ</target>
        </trans-unit>
        <trans-unit id="ee51cfb54175ecd5fb6d2ccc67d80a3554912ff7" translate="yes" xml:space="preserve">
          <source>Generic rest parameters and corresponding inference of tuple types.</source>
          <target state="translated">一般的な休息パラメータとタプル型の対応する推論.</target>
        </trans-unit>
        <trans-unit id="77980b7a1bd9bc29a811f3721a4ca0efc1244e89" translate="yes" xml:space="preserve">
          <source>Generic spread expressions in object literals</source>
          <target state="translated">オブジェクトリテラルでの一般的な広がり表現</target>
        </trans-unit>
        <trans-unit id="a62000d34890a9f512301dfa28ec7342f3e45eb8" translate="yes" xml:space="preserve">
          <source>Generic type aliases</source>
          <target state="translated">汎用型エイリアス</target>
        </trans-unit>
        <trans-unit id="92dacb7528945ed9815a679921369b1471575a3f" translate="yes" xml:space="preserve">
          <source>Generic type arguments in JSX elements</source>
          <target state="translated">JSX 要素における一般的な型の引数</target>
        </trans-unit>
        <trans-unit id="f865cd9dc0cd462591b83a2927cb41d99ab230cd" translate="yes" xml:space="preserve">
          <source>Generic type arguments in generic tagged templates</source>
          <target state="translated">汎用タグ付きテンプレートの汎用型引数</target>
        </trans-unit>
        <trans-unit id="80dadd86173d0ff3979257793d4e45beb238b6a2" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generics</target>
        </trans-unit>
        <trans-unit id="db53d33f081c24d027b3c7e1e7024838559d94b2" translate="yes" xml:space="preserve">
          <source>Generics provide variables to types. A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains.</source>
          <target state="translated">ジェネリックは型に変数を提供します。一般的な例は配列です。ジェネリックを持たない配列は、何でも含むことができます。ジェネリックを持つ配列は、その配列が含む値を記述することができます。</target>
        </trans-unit>
        <trans-unit id="4d9ef11b75691cea9a6edfb497c3b9914c3b1021" translate="yes" xml:space="preserve">
          <source>Generics: Types</source>
          <target state="translated">ジェネリック。タイプ</target>
        </trans-unit>
        <trans-unit id="bd2cb051773a703fdbabd8c09f218722870e6d61" translate="yes" xml:space="preserve">
          <source>Get Started</source>
          <target state="translated">始める</target>
        </trans-unit>
        <trans-unit id="00a40ea9152c19baaaa2f05a471ec1e36c25f25b" translate="yes" xml:space="preserve">
          <source>Get started with a simple TypeScript app.</source>
          <target state="translated">シンプルなTypeScriptアプリで始めましょう。</target>
        </trans-unit>
        <trans-unit id="5ef75e8c40e485b27abd25b4a16247e142017634" translate="yes" xml:space="preserve">
          <source>Getting Declaration Files</source>
          <target state="translated">宣言ファイルの取得</target>
        </trans-unit>
        <trans-unit id="9ed37766bb349044c2259b48865fbf239e26a5e7" translate="yes" xml:space="preserve">
          <source>Getting Stricter Checks</source>
          <target state="translated">チェックを厳しくする</target>
        </trans-unit>
        <trans-unit id="b7b2818d4eceb3a3c55e7b64b0c852e4d5109657" translate="yes" xml:space="preserve">
          <source>Getting around these checks is actually really simple. The easiest method is to just use a type assertion:</source>
          <target state="translated">これらのチェックを回避する方法は、実はとても簡単です。最も簡単な方法は、型アサーションを使うことです。</target>
        </trans-unit>
        <trans-unit id="1ed2ad4b9d2d91f971b1ebd9e80d9238f9735423" translate="yes" xml:space="preserve">
          <source>Getting to ES6/ES2015 built-in API declarations were only limited to &lt;code&gt;target: ES6&lt;/code&gt;. Enter &lt;code&gt;--lib&lt;/code&gt;; with &lt;code&gt;--lib&lt;/code&gt; you can specify a list of built-in API declaration groups that you can chose to include in your project. For instance, if you expect your runtime to have support for &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;Promise&lt;/code&gt; (e.g. most evergreen browsers today), just include &lt;code&gt;--lib es2015.collection,es2015.promise&lt;/code&gt;. Similarly you can exclude declarations you do not want to include in your project, e.g. DOM if you are working on a node project using &lt;code&gt;--lib es5,es6&lt;/code&gt;.</source>
          <target state="translated">ES6 / ES2015組み込みAPI宣言へのアクセスは、 &lt;code&gt;target: ES6&lt;/code&gt; のみ制限されていました。 &lt;code&gt;--lib&lt;/code&gt; と入力します。 &lt;code&gt;--lib&lt;/code&gt; あなたはあなたのプロジェクトに含めることを選択したことを内蔵のAPI宣言グループのリストを指定することができます。たとえば、ランタイムが &lt;code&gt;Map&lt;/code&gt; 、 &lt;code&gt;Set&lt;/code&gt; 、および &lt;code&gt;Promise&lt;/code&gt; のサポートを期待している場合（たとえば、今日のほとんどの常緑樹ブラウザー）、-- &lt;code&gt;--lib es2015.collection,es2015.promise&lt;/code&gt; 含めるだけです。同様に、プロジェクトに含めたくない宣言を除外できます。 &lt;code&gt;--lib es5,es6&lt;/code&gt; を使用してノードプロジェクトで作業している場合はDOMです。</target>
        </trans-unit>
        <trans-unit id="ca2334233ff9d62586c90c8425d61ccf0156ad00" translate="yes" xml:space="preserve">
          <source>Getting type declarations in TypeScript 2.0 and above requires no tools apart from npm.</source>
          <target state="translated">TypeScript 2.0 以上で型宣言を取得するには、npm 以外のツールは必要ありません。</target>
        </trans-unit>
        <trans-unit id="8ad931cf8eb2acc56be9415f5e0a4f34de91ca82" translate="yes" xml:space="preserve">
          <source>Getting type declarations requires no tools apart from npm.</source>
          <target state="translated">型宣言の取得には npm 以外のツールは必要ありません。</target>
        </trans-unit>
        <trans-unit id="0128ee2411d4cce5db2af199ae139a20b41fb10c" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;&amp;lt;Expr /&amp;gt;&lt;/code&gt;, the &lt;em&gt;element class type&lt;/em&gt; is the type of &lt;code&gt;Expr&lt;/code&gt;. So in the example above, if &lt;code&gt;MyComponent&lt;/code&gt; was an ES6 class the class type would be that class&amp;rsquo;s constructor and statics. If &lt;code&gt;MyComponent&lt;/code&gt; was a factory function, the class type would be that function.</source>
          <target state="translated">与えられた &lt;code&gt;&amp;lt;Expr /&amp;gt;&lt;/code&gt; 、&lt;em&gt;要素のクラス型は、&lt;/em&gt;のタイプです &lt;code&gt;Expr&lt;/code&gt; に。したがって、上記の例では、 &lt;code&gt;MyComponent&lt;/code&gt; がES6クラスの場合、クラスタイプはそのクラスのコンストラクターと静的クラスになります。場合 &lt;code&gt;MyComponent&lt;/code&gt; のは、工場出荷時の関数であった、クラス型は、その関数になります。</target>
        </trans-unit>
        <trans-unit id="975e78d60e0d980036725e953131ac369a323b6f" translate="yes" xml:space="preserve">
          <source>Given a declaration of a class &lt;code&gt;Pet&lt;/code&gt; in a module file:</source>
          <target state="translated">モジュールファイルでクラス &lt;code&gt;Pet&lt;/code&gt; の宣言が与えられた場合：</target>
        </trans-unit>
        <trans-unit id="8083d6ae5a9d183ac1a96bad2a32806cb23140c9" translate="yes" xml:space="preserve">
          <source>Given a name &lt;code&gt;A&lt;/code&gt;, we might find up to three different meanings for &lt;code&gt;A&lt;/code&gt;: a type, a value or a namespace. How the name is interpreted depends on the context in which it is used. For example, in the declaration &lt;code&gt;let m: A.A = A;&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is used first as a namespace, then as a type name, then as a value. These meanings might end up referring to entirely different declarations!</source>
          <target state="translated">名前の与えられた &lt;code&gt;A&lt;/code&gt; 、我々はのための3つの異なる意味までを見つけるかもしれない &lt;code&gt;A&lt;/code&gt; タイプ、値または名前空間：。名前の解釈方法は、その名前が使用されるコンテキストによって異なります。たとえば、宣言で次の &lt;code&gt;let m: A.A = A;&lt;/code&gt; 、 &lt;code&gt;A&lt;/code&gt; は最初に名前空間として、次に型名として、次に値として使用されます。これらの意味は、まったく異なる宣言を指すことになるかもしれません！</target>
        </trans-unit>
        <trans-unit id="368b78c1924bb611f6364ba9c26348188f7788e5" translate="yes" xml:space="preserve">
          <source>Given a simplified &lt;em&gt;index.html&lt;/em&gt; file:</source>
          <target state="translated">簡略化された&lt;em&gt;index.html&lt;/em&gt;ファイルがあるとします。</target>
        </trans-unit>
        <trans-unit id="a00264a5f3c6cd0479bb605da5bdecfcbf5f69bb" translate="yes" xml:space="preserve">
          <source>Given an expression &lt;code&gt;Base&lt;/code&gt; of a parametric type &lt;code&gt;T&lt;/code&gt; with a constraint &lt;code&gt;X&lt;/code&gt;, a mixin class &lt;code&gt;class C extends Base {...}&lt;/code&gt; is processed as if &lt;code&gt;Base&lt;/code&gt; had type &lt;code&gt;X&lt;/code&gt; and the resulting type is the intersection &lt;code&gt;typeof C &amp;amp; T&lt;/code&gt;. In other words, a mixin class is represented as an intersection between the mixin class constructor type and the parametric base class constructor type.</source>
          <target state="translated">制約 &lt;code&gt;X&lt;/code&gt; を持つパラメトリックタイプ &lt;code&gt;T&lt;/code&gt; の式 &lt;code&gt;Base&lt;/code&gt; が与えられると、ミックスインクラス &lt;code&gt;class C extends Base {...}&lt;/code&gt; は、 &lt;code&gt;Base&lt;/code&gt; がタイプ &lt;code&gt;X&lt;/code&gt; を持ち、結果のタイプが &lt;code&gt;typeof C &amp;amp; T&lt;/code&gt; 交差typeであるかのように処理されます。つまり、ミックスインクラスは、ミックスインクラスコンストラクタータイプとパラメトリックベースクラスコンストラクタータイプの間の共通部分として表されます。</target>
        </trans-unit>
        <trans-unit id="f747221667578c67b9937edae87fe4b1bb4a08b1" translate="yes" xml:space="preserve">
          <source>Given an object type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;keyof X&lt;/code&gt; is resolved as follows:</source>
          <target state="translated">オブジェクトタイプ &lt;code&gt;X&lt;/code&gt; を指定すると、 &lt;code&gt;keyof X&lt;/code&gt; は次のように解決されます。</target>
        </trans-unit>
        <trans-unit id="fa581e6e08169205d8be1ad319fd8832a173be18" translate="yes" xml:space="preserve">
          <source>Given that we have two types of declarations with similar scoping semantics, it&amp;rsquo;s natural to find ourselves asking which one to use. Like most broad questions, the answer is: it depends.</source>
          <target state="translated">スコープセマンティクスが似ている2種類の宣言があるとすると、どちらを使用するかを自問するのは自然なことです。ほとんどの幅広い質問と同様に、答えは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c71bdff34c04312e874f58b0595438841c748916" translate="yes" xml:space="preserve">
          <source>Given the &lt;code&gt;state&lt;/code&gt; field is common in every type inside &lt;code&gt;NetworkState&lt;/code&gt; - it is safe for your code to access without an existence check.</source>
          <target state="translated">与えられた &lt;code&gt;state&lt;/code&gt; 欄には、内部のすべてのタイプに共通である &lt;code&gt;NetworkState&lt;/code&gt; -それは存在チェックせずにアクセスするあなたのコードのために安全です。</target>
        </trans-unit>
        <trans-unit id="610048c0b076b1fb8790fd96c3fc109500ce0670" translate="yes" xml:space="preserve">
          <source>Given this project structure:</source>
          <target state="translated">このプロジェクトの構造を考えると</target>
        </trans-unit>
        <trans-unit id="05ab21d96c8cc217d9d3bf8ed1a8cf0dc14dc590" translate="yes" xml:space="preserve">
          <source>Glob support in &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; での Globサポート</target>
        </trans-unit>
        <trans-unit id="ee29cd5c1e941ea77b1bcc2b4464658a76d6b503" translate="yes" xml:space="preserve">
          <source>Glob support is here!! Glob support has been &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1927&quot;&gt;one of the most requested features&lt;/a&gt;.</source>
          <target state="translated">Globサポートはこちらです!! Globサポートは&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1927&quot;&gt;、最も要求&lt;/a&gt;されている機能の1つです。</target>
        </trans-unit>
        <trans-unit id="26021db1ea30cf082e152c820806cb17b431aff1" translate="yes" xml:space="preserve">
          <source>Glob-like file patterns are supported two properties &lt;code&gt;&quot;include&quot;&lt;/code&gt; and &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;.</source>
          <target state="translated">Globのようなファイルパターンは、 &lt;code&gt;&quot;include&quot;&lt;/code&gt; と &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; の 2つのプロパティでサポートされています。</target>
        </trans-unit>
        <trans-unit id="3cc9c6744751ed4cf4a2b29e9b22ac831592172b" translate="yes" xml:space="preserve">
          <source>Global .d.ts</source>
          <target state="translated">グローバル.d.ts</target>
        </trans-unit>
        <trans-unit id="ae4f56ae4da16df74b3d2aeca8b4352281e7be45" translate="yes" xml:space="preserve">
          <source>Global Functions</source>
          <target state="translated">グローバル機能</target>
        </trans-unit>
        <trans-unit id="bb90b4e7b4f156d78c1c4607edb92deecea2726f" translate="yes" xml:space="preserve">
          <source>Global Libraries</source>
          <target state="translated">グローバルライブラリ</target>
        </trans-unit>
        <trans-unit id="086706851e81b0cda50c1ad12a71bbbe92f2b609" translate="yes" xml:space="preserve">
          <source>Global Library Template</source>
          <target state="translated">グローバルライブラリテンプレート</target>
        </trans-unit>
        <trans-unit id="2ff4e53e2b802e1ec127c83da80fa5fc4b5333fa" translate="yes" xml:space="preserve">
          <source>Global Variables</source>
          <target state="translated">グローバル変数</target>
        </trans-unit>
        <trans-unit id="f939f94390f04e9a571e774b88f07fa51a7034c9" translate="yes" xml:space="preserve">
          <source>Global augmentation</source>
          <target state="translated">世界的な増加</target>
        </trans-unit>
        <trans-unit id="d9627061a8f161c085d6425d99b5bcd04461ec21" translate="yes" xml:space="preserve">
          <source>Global augmentations have the same behavior and limits as module augmentations.</source>
          <target state="translated">グローバル拡張は、モジュール拡張と同じ動作と制限があります。</target>
        </trans-unit>
        <trans-unit id="551b0be00de6f59a327fffe248fc43dd021a48e0" translate="yes" xml:space="preserve">
          <source>Global library code is usually extremely simple. A global &amp;ldquo;Hello, world&amp;rdquo; library might look like this:</source>
          <target state="translated">グローバルライブラリコードは通常、非常に単純です。グローバルな「Hello、world」ライブラリは次のようになります。</target>
        </trans-unit>
        <trans-unit id="a2a3ce92a02e2b38f5f0131a3a2a15d9bd6e27fc" translate="yes" xml:space="preserve">
          <source>Global plugins are generally easy to identify from their documentation.</source>
          <target state="translated">グローバルなプラグインは、一般的にドキュメントを見れば一目瞭然です。</target>
        </trans-unit>
        <trans-unit id="4f705c81915f4a397894296d2b81a9e9f219df5d" translate="yes" xml:space="preserve">
          <source>Global-modifying modules are generally easy to identify from their documentation. In general, they&amp;rsquo;re similar to global plugins, but need a &lt;code&gt;require&lt;/code&gt; call to activate their effects.</source>
          <target state="translated">グローバル変更モジュールは、一般的にドキュメントから簡単に識別できます。一般に、これらはグローバルプラグインに似ていますが、その効果をアクティブにするには &lt;code&gt;require&lt;/code&gt; 呼び出しが必要です。</target>
        </trans-unit>
        <trans-unit id="985e370903f557eb77f2957da19dbd086883f48f" translate="yes" xml:space="preserve">
          <source>Global: Modifying Module</source>
          <target state="translated">グローバル:モジュールの変更</target>
        </trans-unit>
        <trans-unit id="bc6922ba498ce785a869200f44c3ccbf5a4f68f2" translate="yes" xml:space="preserve">
          <source>Global: Plugin</source>
          <target state="translated">グローバル:プラグイン</target>
        </trans-unit>
        <trans-unit id="24713d72fbb7ed9e4d613388f61f4edcd1171735" translate="yes" xml:space="preserve">
          <source>Go to &lt;code&gt;File&lt;/code&gt; &amp;gt; &lt;code&gt;Settings&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; &amp;gt; &lt;code&gt;Settings&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt; に移動します。</target>
        </trans-unit>
        <trans-unit id="cb7da868a3e2b03846cee16319e4528c9916294a" translate="yes" xml:space="preserve">
          <source>Go to &lt;code&gt;Preferences&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt;:</source>
          <target state="translated">[ &lt;code&gt;Preferences&lt;/code&gt; &amp;gt; [ &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; ] &amp;gt; [ &lt;code&gt;TypeScript&lt;/code&gt; ]に移動します。</target>
        </trans-unit>
        <trans-unit id="86d8b5a249b3cc55d73040fe87c867b93ac1ecb6" translate="yes" xml:space="preserve">
          <source>Going back to the idea of &lt;em&gt;types as sets&lt;/em&gt;, we can think of &lt;code&gt;obj&lt;/code&gt; as being a member of both the &lt;code&gt;Pointlike&lt;/code&gt; set of values and the &lt;code&gt;Named&lt;/code&gt; set of values.</source>
          <target state="translated">&lt;em&gt;型を集合として&lt;/em&gt;考えることに戻ると、 &lt;code&gt;obj&lt;/code&gt; は &lt;code&gt;Pointlike&lt;/code&gt; 値の集合と &lt;code&gt;Named&lt;/code&gt; の値の集合の両方のメンバーであると考えることができます。</target>
        </trans-unit>
        <trans-unit id="e05780e3cac998950011571da3d75ed12a7e2108" translate="yes" xml:space="preserve">
          <source>Gradual typing</source>
          <target state="translated">漸進的なタイピング</target>
        </trans-unit>
        <trans-unit id="c06ca0601da1369de3d0247e6e4f8b7bbe8e4bfd" translate="yes" xml:space="preserve">
          <source>Grunt</source>
          <target state="translated">Grunt</target>
        </trans-unit>
        <trans-unit id="b5e0b544d4f7e5ecf776c530d4637f9254bfad0b" translate="yes" xml:space="preserve">
          <source>Guidance</source>
          <target state="translated">Guidance</target>
        </trans-unit>
        <trans-unit id="6b06b3debeeac8b24443fbaf25e471200f47e47b" translate="yes" xml:space="preserve">
          <source>Guidance for structuring modules</source>
          <target state="translated">モジュール構造化のガイダンス</target>
        </trans-unit>
        <trans-unit id="5a6238801e2733bcdc7249e97a255df97e530fc4" translate="yes" xml:space="preserve">
          <source>Gulp</source>
          <target state="translated">Gulp</target>
        </trans-unit>
        <trans-unit id="79914411b3c89953fe030c6c8025f0574c41a8f8" translate="yes" xml:space="preserve">
          <source>Gulp: Add modules to the code</source>
          <target state="translated">ガルプ コードにモジュールを追加する</target>
        </trans-unit>
        <trans-unit id="21e98a38e254fad84f4a4bbd9e8fa3fea802a72c" translate="yes" xml:space="preserve">
          <source>Gulp: Babel</source>
          <target state="translated">ガルプ バベル</target>
        </trans-unit>
        <trans-unit id="c3699841f2d588970283b562ce18c4a12378b39f" translate="yes" xml:space="preserve">
          <source>Gulp: Browserify</source>
          <target state="translated">ガルプ ブラウザー化</target>
        </trans-unit>
        <trans-unit id="67718aa41c7c302d8015e6a1f55245492dfe7b5f" translate="yes" xml:space="preserve">
          <source>Gulp: Create a gulpfile.js</source>
          <target state="translated">gulp(ガルプ)。gulpfile.jsを作成する</target>
        </trans-unit>
        <trans-unit id="d5f376a8524ce9e40602f913685d1f14707f0f24" translate="yes" xml:space="preserve">
          <source>Gulp: Create a page</source>
          <target state="translated">ガルプ ページを作成する</target>
        </trans-unit>
        <trans-unit id="26f1b5afe4ab8f7ba7d8e64daae6616d336e7b8d" translate="yes" xml:space="preserve">
          <source>Gulp: Initialize the project</source>
          <target state="translated">ガルプ プロジェクトを初期化する</target>
        </trans-unit>
        <trans-unit id="89ec650baa395d7c6395a96eac5b8b07e6aefed3" translate="yes" xml:space="preserve">
          <source>Gulp: Install our dependencies</source>
          <target state="translated">ガルプ 依存関係のインストール</target>
        </trans-unit>
        <trans-unit id="94ff547657bd3ea294e187a2a5b6c4e9da41ae2e" translate="yes" xml:space="preserve">
          <source>Gulp: Minimal project</source>
          <target state="translated">ガルプ。ミニマルプロジェクト</target>
        </trans-unit>
        <trans-unit id="5bf88642d6a4c72b1400115e631d3c1241d0a62f" translate="yes" xml:space="preserve">
          <source>Gulp: Test the resulting app</source>
          <target state="translated">ガルプします。結果のアプリをテストする</target>
        </trans-unit>
        <trans-unit id="5c5e381120e6ca17177cab8dd1c9b114707b4f32" translate="yes" xml:space="preserve">
          <source>Gulp: Uglify</source>
          <target state="translated">ガルプ 鵜呑みにする</target>
        </trans-unit>
        <trans-unit id="378ef94af067892dc3f571669da77f2d28b9d848" translate="yes" xml:space="preserve">
          <source>Gulp: Watchify</source>
          <target state="translated">ガルプ Watchify</target>
        </trans-unit>
        <trans-unit id="339b09b31f6400bfbd9df2cc056c03bbce7e1947" translate="yes" xml:space="preserve">
          <source>Gulp: Write a simple example</source>
          <target state="translated">ガルプ 簡単な例を書く</target>
        </trans-unit>
        <trans-unit id="28e2147303cd82753a34e2e9e286d0181633c0c4" translate="yes" xml:space="preserve">
          <source>Had the function expression returned numbers or strings, the type checker would have made an error that indicates return type doesn&amp;rsquo;t match the return type described in the &lt;code&gt;SearchFunc&lt;/code&gt; interface.</source>
          <target state="translated">関数式が数値または文字列を返した場合、型チェッカーは、戻り値の型が &lt;code&gt;SearchFunc&lt;/code&gt; インターフェイスで説明されている戻り値の型と一致しないことを示すエラーを発生させます。</target>
        </trans-unit>
        <trans-unit id="048279b51d66beecd8037dba2d0ea88f2006f017" translate="yes" xml:space="preserve">
          <source>Handbook</source>
          <target state="translated">Handbook</target>
        </trans-unit>
        <trans-unit id="60e7f26d0bfbb76e605b8559ae9629c763bda244" translate="yes" xml:space="preserve">
          <source>Handbook Reference</source>
          <target state="translated">ハンドブックリファレンス</target>
        </trans-unit>
        <trans-unit id="025c00357defd4539f61638601fbe4d91d8be15e" translate="yes" xml:space="preserve">
          <source>Handbook v2: Beta</source>
          <target state="translated">ハンドブック v2:ベータ</target>
        </trans-unit>
        <trans-unit id="47336902c998cc0d39cea91a005587dbb3655556" translate="yes" xml:space="preserve">
          <source>Handling Many Consuming Import</source>
          <target state="translated">多くの消耗する輸入品を扱う</target>
        </trans-unit>
        <trans-unit id="8c3f9ca937ff27ba265d41da2558bebb545acf05" translate="yes" xml:space="preserve">
          <source>Have recompiles in &lt;code&gt;--incremental&lt;/code&gt; and &lt;code&gt;--watch&lt;/code&gt; assume that changes within a file will only affect files directly depending on it</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; および &lt;code&gt;--watch&lt;/code&gt; で再コンパイルする場合、ファイル内の変更は、ファイルに直接依存するファイルにのみ影響することを前提としています。</target>
        </trans-unit>
        <trans-unit id="9a7699299b167b02f3b309a214e186f89e6ac90a" translate="yes" xml:space="preserve">
          <source>Hello World of Generics</source>
          <target state="translated">ハロージェネリックの世界</target>
        </trans-unit>
        <trans-unit id="4868c6cfe667dc94ff39de6f11b3b8c2dde32455" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;asserts val is string&lt;/code&gt; ensures that after any call to &lt;code&gt;assertIsString&lt;/code&gt;, any variable passed in will be known to be a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;asserts val is string&lt;/code&gt; ことにより、 &lt;code&gt;assertIsString&lt;/code&gt; への呼び出しの後、渡された変数が文字列であることを確実にし &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="217c263c0612cdb8818f0c2bb1cc2cee17136759" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;map.ts&lt;/code&gt; can declare that it will internally patch the &lt;code&gt;Observable&lt;/code&gt; type from &lt;code&gt;observable.ts&lt;/code&gt; and add the &lt;code&gt;map&lt;/code&gt; method to it.</source>
          <target state="translated">ここ &lt;code&gt;map.ts&lt;/code&gt; は、それが内部的にパッチを適用することを宣言することができ &lt;code&gt;Observable&lt;/code&gt; のタイプ &lt;code&gt;observable.ts&lt;/code&gt; をし、追加 &lt;code&gt;map&lt;/code&gt; それに方法を。</target>
        </trans-unit>
        <trans-unit id="d7da085e82459c85f19fe707c9181a9e46b7b5cc" translate="yes" xml:space="preserve">
          <source>Here are some notable differences on how checking works in &lt;code&gt;.js&lt;/code&gt; files compared to &lt;code&gt;.ts&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;.ts&lt;/code&gt; ファイルと比較した &lt;code&gt;.js&lt;/code&gt; ファイルでのチェックの動作に関するいくつかの注目すべき違いを次に示します。</target>
        </trans-unit>
        <trans-unit id="b504fd8672cd71981cb916f0743aeadaf081b517" translate="yes" xml:space="preserve">
          <source>Here are some notable differences on how checking works in &lt;code&gt;.js&lt;/code&gt; files compared to &lt;code&gt;.ts&lt;/code&gt; files:</source>
          <target state="translated">&lt;code&gt;.ts&lt;/code&gt; ファイルと比較した &lt;code&gt;.js&lt;/code&gt; ファイルでのチェックの動作に関するいくつかの注目すべき違いは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="14fd63d436a290048d4c1831116810e1e69345e4" translate="yes" xml:space="preserve">
          <source>Here is a list of available API groups:</source>
          <target state="translated">利用可能なAPIグループの一覧です。</target>
        </trans-unit>
        <trans-unit id="83f91cc0372adb4b62657eb83b59506603d1d14b" translate="yes" xml:space="preserve">
          <source>Here is a list of well-known symbols:</source>
          <target state="translated">よく知られている記号の一覧です。</target>
        </trans-unit>
        <trans-unit id="d7c6390605af8c73015b19f7184792241b88e764" translate="yes" xml:space="preserve">
          <source>Here is a simple test for the calculator using the exposed &lt;code&gt;test&lt;/code&gt; function.</source>
          <target state="translated">これは、公開された &lt;code&gt;test&lt;/code&gt; 関数を使用した計算機の簡単なテストです。</target>
        </trans-unit>
        <trans-unit id="ab4601038071e90a3110c691f3d278bb312c50c8" translate="yes" xml:space="preserve">
          <source>Here is an example</source>
          <target state="translated">以下に一例を示します。</target>
        </trans-unit>
        <trans-unit id="d867fe52f6b4323b3aa6d543dd0bd5c2bb91d3f0" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates this distinction:</source>
          <target state="translated">この違いを示す例を紹介します。</target>
        </trans-unit>
        <trans-unit id="9d689481e7c027a1b04a6cc241ceab676b7e9d0f" translate="yes" xml:space="preserve">
          <source>Here the syntax starts to get confusing. You can read &lt;code&gt;a: newName1&lt;/code&gt; as &amp;ldquo;&lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt;&amp;rdquo;. The direction is left-to-right, as if you had written:</source>
          <target state="translated">ここで構文は混乱し始めます。 &lt;code&gt;a: newName1&lt;/code&gt; を「 &lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt; 」として読み取ることができます。書いたかのように、方向は左から右です。</target>
        </trans-unit>
        <trans-unit id="38b470aca3704e2927b6fc439cdffa46d4653713" translate="yes" xml:space="preserve">
          <source>Here the syntax starts to get confusing. You can read &lt;code&gt;a: newName1&lt;/code&gt; as &amp;rdquo;&lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt;&amp;rdquo;. The direction is left-to-right, as if you had written:</source>
          <target state="translated">ここで、構文が混乱し始めます。 &lt;code&gt;a: newName1&lt;/code&gt; を&amp;rdquo; &lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt; &amp;rdquo;と読むことができます。あなたが書いたかのように、方向は左から右です：</target>
        </trans-unit>
        <trans-unit id="0e7c23e184f2a3fc2239ba7dd64a12dacf4b5975" translate="yes" xml:space="preserve">
          <source>Here we explicitly set &lt;code&gt;T&lt;/code&gt; to be &lt;code&gt;string&lt;/code&gt; as one of the arguments to the function call, denoted using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; around the arguments rather than &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">ここでは、関数呼び出しの引数の1つとして &lt;code&gt;T&lt;/code&gt; を明示的に &lt;code&gt;string&lt;/code&gt; 設定し、 &lt;code&gt;()&lt;/code&gt; ではなく引数を &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; で囲んで示しています。</target>
        </trans-unit>
        <trans-unit id="4a521f4f8c69adda61863ae271ec13a08aca0267" translate="yes" xml:space="preserve">
          <source>Here we need to create a variable to hold on to the neighbor-map so that we can initialize it. With TypeScript 1.5, we can let the compiler do the heavy lifting:</source>
          <target state="translated">ここでは、Neighbor-Mapを初期化できるように、Neighbor-Mapを保持するための変数を作成する必要があります。TypeScript 1.5では、コンパイラに力仕事を任せることができます。</target>
        </trans-unit>
        <trans-unit id="f454fc62879aec4c05c5b0553ae23ecb3678fbdb" translate="yes" xml:space="preserve">
          <source>Here we were able to copy over all the properties of &lt;code&gt;Person&lt;/code&gt; except for &lt;code&gt;location&lt;/code&gt; using the &lt;code&gt;Omit&lt;/code&gt; helper.</source>
          <target state="translated">ここでは、 &lt;code&gt;Omit&lt;/code&gt; ヘルパーを使用して、 &lt;code&gt;location&lt;/code&gt; を除く &lt;code&gt;Person&lt;/code&gt; のすべてのプロパティをコピーできました。</target>
        </trans-unit>
        <trans-unit id="1036409900634ac21f92613c301ba8e5286a4bef" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re going to create a &lt;code&gt;Student&lt;/code&gt; class with a constructor and a few public fields. Notice that classes and interfaces play well together, letting the programmer decide on the right level of abstraction.</source>
          <target state="translated">ここでは、コンストラクターといくつかのパブリックフィールドを持つ &lt;code&gt;Student&lt;/code&gt; クラスを作成します。クラスとインターフェースがうまく連携し、プログラマーに適切な抽象化レベルを決定させることに注意してください。</target>
        </trans-unit>
        <trans-unit id="285b0ed2d436f147e6b99b312065319a3bd9b594" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re specifying a few things to TypeScript:</source>
          <target state="translated">ここでは、TypeScriptにいくつかのことを指定しています。</target>
        </trans-unit>
        <trans-unit id="cb80aa21b4ae837ee53363a494d841d8934317d2" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a basic example with &lt;code&gt;strictFunctionTypes&lt;/code&gt; off:</source>
          <target state="translated">&lt;code&gt;strictFunctionTypes&lt;/code&gt; をオフにした基本的な例を次に示します。</target>
        </trans-unit>
        <trans-unit id="371971b4f21066fe668fdda84538194651b56819" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a revised example:</source>
          <target state="translated">これが改訂された例です：</target>
        </trans-unit>
        <trans-unit id="ecace45a094904ef8f89699739d61e7f83e4e706" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a simple example of an unreachable code error:</source>
          <target state="translated">到達できないコードエラーの簡単な例を次に示します。</target>
        </trans-unit>
        <trans-unit id="33855c52e889ba154150d2b3670aeb240d95c340" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of this pattern:</source>
          <target state="translated">このパターンの例を次に示します。</target>
        </trans-unit>
        <trans-unit id="213ae2c641322b822eadac21eb578a78502cdaed" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how the error happens:</source>
          <target state="translated">エラーが発生する方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="4e232701f3c0f0553f27b93d9845181d7b9b01bd" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how you would write and use this function in TypeScript, using the &lt;strong&gt;index type query&lt;/strong&gt; and &lt;strong&gt;indexed access&lt;/strong&gt; operators:</source>
          <target state="translated">TypeScriptでこの関数を作成して使用するには、&lt;strong&gt;インデックスタイプクエリ&lt;/strong&gt;と&lt;strong&gt;インデックス付きアクセス&lt;/strong&gt;演算子を&lt;strong&gt;使用&lt;/strong&gt;し&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="fb902d04d0d6f8c7ca19c25536908ff73f061681" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s one more example, in which &lt;code&gt;T[P]&lt;/code&gt; is wrapped in a &lt;code&gt;Proxy&amp;lt;T&amp;gt;&lt;/code&gt; class:</source>
          <target state="translated">&lt;code&gt;T[P]&lt;/code&gt; が &lt;code&gt;Proxy&amp;lt;T&amp;gt;&lt;/code&gt; クラスにラップされているもう1つの例を次に示します。</target>
        </trans-unit>
        <trans-unit id="a63587f4e1d9560ec04fcfe839944b3ae506477b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s some example output for this file:</source>
          <target state="translated">このファイルの出力例を次に示します。</target>
        </trans-unit>
        <trans-unit id="c2ea446bd29277ad18a8bf4252379c5046cdf44d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;SomeType&lt;/code&gt; appears to originate in both the &lt;code&gt;import&lt;/code&gt; declaration and the local &lt;code&gt;interface&lt;/code&gt; declaration. Perhaps surprisingly, inside the module, &lt;code&gt;SomeType&lt;/code&gt; refers exclusively to the &lt;code&gt;import&lt;/code&gt;ed definition, and the local declaration &lt;code&gt;SomeType&lt;/code&gt; is only usable when imported from another file. This is very confusing and our review of the very small number of cases of code like this in the wild showed that developers usually thought something different was happening.</source>
          <target state="translated">ここでは、 &lt;code&gt;SomeType&lt;/code&gt; は &lt;code&gt;import&lt;/code&gt; 宣言とローカル &lt;code&gt;interface&lt;/code&gt; 宣言の両方で発生しているように見えます。おそらく驚くべきことに、モジュール内で、 &lt;code&gt;SomeType&lt;/code&gt; は &lt;code&gt;import&lt;/code&gt; ed定義のみを &lt;code&gt;SomeType&lt;/code&gt; 、ローカル宣言SomeTypeは別のファイルからインポートされた場合にのみ使用できます。これは非常に混乱します。このようなコードの非常に少数のケースを実際に確認したところ、開発者は通常、何か別のことが起こっていると考えていました。</target>
        </trans-unit>
        <trans-unit id="a3816a0ed94cd7ceadd9968bd7c237ebde8a5f88" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Up&lt;/code&gt; would have the value &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;Down&lt;/code&gt; would have &lt;code&gt;1&lt;/code&gt;, etc. This auto-incrementing behavior is useful for cases where we might not care about the member values themselves, but do care that each value is distinct from other values in the same enum.</source>
          <target state="translated">ここでは、 &lt;code&gt;Up&lt;/code&gt; の値は &lt;code&gt;0&lt;/code&gt; で、 &lt;code&gt;Down&lt;/code&gt; の値は &lt;code&gt;1&lt;/code&gt; です。この自動インクリメント動作は、メンバーの値自体は気にしないかもしれないが、同じ値の他の値とは異なることに注意してください。列挙型。</target>
        </trans-unit>
        <trans-unit id="7add7dc4368781c75bdc4173ec3100b108107d32" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;assertNever&lt;/code&gt; checks that &lt;code&gt;s&lt;/code&gt; is of type &lt;code&gt;never&lt;/code&gt; &amp;mdash; the type that&amp;rsquo;s left after all other cases have been removed. If you forget a case, then &lt;code&gt;s&lt;/code&gt; will have a real type and you will get a type error. This method requires you to define an extra function, but it&amp;rsquo;s much more obvious when you forget it because the error message includes the missing type name.</source>
          <target state="translated">ここで、 &lt;code&gt;assertNever&lt;/code&gt; は、 &lt;code&gt;s&lt;/code&gt; が &lt;code&gt;never&lt;/code&gt; 型（他のすべてのケースが削除された後に残された型）であることを確認します。ケースを忘れると、 &lt;code&gt;s&lt;/code&gt; は実際の型になり、型エラーが発生します。この方法では、追加の関数を定義する必要がありますが、エラーメッセージに欠落している型名が含まれているため、それを忘れるとはるかに明白になります。</target>
        </trans-unit>
        <trans-unit id="57a9abf556999c9646907cab4f7c7e1dc771a6d2" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;assertNever&lt;/code&gt; checks that &lt;code&gt;s&lt;/code&gt; is of type &lt;code&gt;never&lt;/code&gt; &amp;mdash; the type that&amp;rsquo;s left after all other cases have been removed. If you forget a case, then &lt;code&gt;s&lt;/code&gt; will have a real type and you will get a type error. This method requires you to define an extra function, but it&amp;rsquo;s much more obvious when you forget it.</source>
          <target state="translated">ここで、 &lt;code&gt;assertNever&lt;/code&gt; は、 &lt;code&gt;s&lt;/code&gt; が &lt;code&gt;never&lt;/code&gt; タイプであること、つまり他のすべてのケースが削除された後に残ったタイプであることを確認します。ケースを忘れると、 &lt;code&gt;s&lt;/code&gt; は実際の型になり、型エラーになります。この方法では、追加の関数を定義する必要がありますが、それを忘れるとはるかにわかりやすくなります。</target>
        </trans-unit>
        <trans-unit id="d05882792ac23d4a8b28c31469c8bc7607445ef8" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;let Greeter&lt;/code&gt; is going to be assigned the constructor function. When we call &lt;code&gt;new&lt;/code&gt; and run this function, we get an instance of the class. The constructor function also contains all of the static members of the class. Another way to think of each class is that there is an &lt;em&gt;instance&lt;/em&gt; side and a &lt;em&gt;static&lt;/em&gt; side.</source>
          <target state="translated">ここで &lt;code&gt;let Greeter&lt;/code&gt; コンストラクター関数を割り当てます。 &lt;code&gt;new&lt;/code&gt; を呼び出してこの関数を実行すると、クラスのインスタンスが取得されます。コンストラクター関数には、クラスのすべての静的メンバーも含まれます。各クラスについて考えるもう1つの方法は、&lt;em&gt;インスタンス&lt;/em&gt;側と&lt;em&gt;静的&lt;/em&gt;側があるということです。</target>
        </trans-unit>
        <trans-unit id="a0aeea38a3dd24023c3fa8431f6367d7d758da1c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;n: number&lt;/code&gt; in this example also, despite the fact that &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; have not been inferred before the call. In fact, after &lt;code&gt;[1,2,3]&lt;/code&gt; has been used to infer &lt;code&gt;T=number&lt;/code&gt;, the return type of &lt;code&gt;n =&amp;gt; n.toString()&lt;/code&gt; is used to infer &lt;code&gt;U=string&lt;/code&gt;, causing &lt;code&gt;sns&lt;/code&gt; to have the type &lt;code&gt;string[]&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;n: number&lt;/code&gt; この例の番号も、呼び出し前に &lt;code&gt;T&lt;/code&gt; と &lt;code&gt;U&lt;/code&gt; が推測されていないにもかかわらずです。実際、 &lt;code&gt;[1,2,3]&lt;/code&gt; を使用して &lt;code&gt;T=number&lt;/code&gt; を推測した後、戻り値の型 &lt;code&gt;n =&amp;gt; n.toString()&lt;/code&gt; を使用して &lt;code&gt;U=string&lt;/code&gt; を推測し、 &lt;code&gt;sns&lt;/code&gt; の型を &lt;code&gt;string[]&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="8dc42a1abbc3302381c653975f640c8b543442a7" translate="yes" xml:space="preserve">
          <source>Here, TypeScript will climb up &lt;code&gt;node_modules&lt;/code&gt; folders looking for a &lt;code&gt;@my-team/tsconfig-base&lt;/code&gt; package. For each of those packages, TypeScript will first check whether &lt;code&gt;package.json&lt;/code&gt; contains a &lt;code&gt;&quot;tsconfig&quot;&lt;/code&gt; field, and if it does, TypeScript will try to load a configuration file from that field. If neither exists, TypeScript will try to read from a &lt;code&gt;tsconfig.json&lt;/code&gt; at the root. This is similar to the lookup process for &lt;code&gt;.js&lt;/code&gt; files in packages that Node uses, and the &lt;code&gt;.d.ts&lt;/code&gt; lookup process that TypeScript already uses.</source>
          <target state="translated">ここで、TypeScriptは &lt;code&gt;@my-team/tsconfig-base&lt;/code&gt; パッケージを探す &lt;code&gt;node_modules&lt;/code&gt; フォルダーを登っていきます。これらの各パッケージについて、TypeScriptは最初に &lt;code&gt;package.json&lt;/code&gt; に &lt;code&gt;&quot;tsconfig&quot;&lt;/code&gt; フィールドが含まれているかどうかをチェックし、含まれている場合、TypeScriptはそのフィールドから構成ファイルをロードしようとします。どちらも存在しない場合、TypeScriptはルートにある &lt;code&gt;tsconfig.json&lt;/code&gt; から読み取ろうとします。これは、Nodeが使用するパッケージ内の &lt;code&gt;.js&lt;/code&gt; ファイルのルックアッププロセス、およびTypeScriptがすでに使用している &lt;code&gt;.d.ts&lt;/code&gt; ルックアッププロセスに似ています。</target>
        </trans-unit>
        <trans-unit id="3034e1d8a6bc8a9342b8171fa30badb5f8ee1757" translate="yes" xml:space="preserve">
          <source>Here, our package depends on the &lt;code&gt;browserify&lt;/code&gt; and &lt;code&gt;typescript&lt;/code&gt; packages. &lt;code&gt;browserify&lt;/code&gt; does not bundle its declaration files with its npm packages, so we needed to depend on &lt;code&gt;@types/browserify&lt;/code&gt; for its declarations. &lt;code&gt;typescript&lt;/code&gt;, on the other hand, packages its declaration files, so there was no need for any additional dependencies.</source>
          <target state="translated">ここでは、パッケージは &lt;code&gt;browserify&lt;/code&gt; パッケージと &lt;code&gt;typescript&lt;/code&gt; パッケージに依存しています。 &lt;code&gt;browserify&lt;/code&gt; はその宣言ファイルをnpmパッケージにバンドルしていません。そのため、宣言は &lt;code&gt;@types/browserify&lt;/code&gt; に依存する必要がありました。一方、 &lt;code&gt;typescript&lt;/code&gt; は宣言ファイルをパッケージ化するため、追加の依存関係は必要ありませんでした。</target>
        </trans-unit>
        <trans-unit id="3cda7ef7ff2200b657be6b6273e0dac1be53b72f" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;pickCard&lt;/code&gt; function will return two different things based on what the user has passed in. If the users passes in an object that represents the deck, the function will pick the card. If the user picks the card, we tell them which card they&amp;rsquo;ve picked. But how do we describe this to the type system?</source>
          <target state="translated">ここで、 &lt;code&gt;pickCard&lt;/code&gt; 関数は、ユーザーが渡したものに基づいて2つの異なるものを返します。ユーザーがデッキを表すオブジェクトを渡した場合、関数はカードを選択します。ユーザーがカードを選んだ場合は、選んだカードを知らせます。しかし、これを型システムにどのように説明しますか？</target>
        </trans-unit>
        <trans-unit id="eaeffdb6112e2f8dae638c67608f6ba2778d3117" translate="yes" xml:space="preserve">
          <source>Here, the TypeScript type checker used the type of the &lt;code&gt;Window.onmousedown&lt;/code&gt; function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/MouseEvent&quot;&gt;type&lt;/a&gt; of the &lt;code&gt;mouseEvent&lt;/code&gt; parameter, which does contain a &lt;code&gt;button&lt;/code&gt; property, but not a &lt;code&gt;kangaroo&lt;/code&gt; property.</source>
          <target state="translated">ここで、TypeScriptタイプチェッカーは、 &lt;code&gt;Window.onmousedown&lt;/code&gt; 関数のタイプを使用して、割り当ての右側にある関数式のタイプを推測しました。それはそのようにしたとき、推測することができた&lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/MouseEvent&quot;&gt;タイプ&lt;/a&gt;の &lt;code&gt;mouseEvent&lt;/code&gt; 含まれないパラメータ、 &lt;code&gt;button&lt;/code&gt; プロパティをではなく、 &lt;code&gt;kangaroo&lt;/code&gt; プロパティを。</target>
        </trans-unit>
        <trans-unit id="e58fec9d06a5ad9c41dd9bdefb16a98bb9094511" translate="yes" xml:space="preserve">
          <source>Here, the Typescript type checker used the type of the &lt;code&gt;Window.onmousedown&lt;/code&gt; function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;type&lt;/a&gt; of the &lt;code&gt;mouseEvent&lt;/code&gt; parameter, which does contain a &lt;code&gt;button&lt;/code&gt; property, but not a &lt;code&gt;kangaroo&lt;/code&gt; property.</source>
          <target state="translated">ここで、 &lt;code&gt;Window.onmousedown&lt;/code&gt; 型チェッカーはWindow.onmousedown関数の型を使用して、割り当ての右側にある関数式の型を推測しました。 &lt;code&gt;mouseEvent&lt;/code&gt; 、 &lt;code&gt;button&lt;/code&gt; プロパティは含まれますが、 &lt;code&gt;kangaroo&lt;/code&gt; プロパティは含まれません、mouseEventパラメータの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;タイプ&lt;/a&gt;を推測できました。</target>
        </trans-unit>
        <trans-unit id="5c595f669d2beb3aaae563a230a33b04db9bfa77" translate="yes" xml:space="preserve">
          <source>Here, the object literal &lt;code&gt;{ x: &quot;hi&quot;, extra: 1 }&lt;/code&gt; has a matching literal type &lt;code&gt;{ x: string, extra: number }&lt;/code&gt;. That type is assignable to &lt;code&gt;{ x: string }&lt;/code&gt; since it has all the required properties and those properties have assignable types. The extra property doesn&amp;rsquo;t prevent assignment, it just makes it a subtype of &lt;code&gt;{ x: string }&lt;/code&gt;.</source>
          <target state="translated">ここで、オブジェクトリテラル &lt;code&gt;{ x: &quot;hi&quot;, extra: 1 }&lt;/code&gt; は、一致するリテラルタイプ &lt;code&gt;{ x: string, extra: number }&lt;/code&gt; 持っています。そのタイプには、必要なすべてのプロパティがあり、それらのプロパティに割り当て可能なタイプがあるため、 &lt;code&gt;{ x: string }&lt;/code&gt; 割り当てることができます。追加のプロパティは割り当てを妨げるものではなく、 &lt;code&gt;{ x: string }&lt;/code&gt; サブタイプにするだけです。</target>
        </trans-unit>
        <trans-unit id="e4d6507505357d507200a72953f1d420dfbcafaf" translate="yes" xml:space="preserve">
          <source>Here, we forgot to call &lt;code&gt;isAdministrator&lt;/code&gt;, and the code incorrectly allows non-adminstrator users to edit the configuration!</source>
          <target state="translated">ここでは、 &lt;code&gt;isAdministrator&lt;/code&gt; を呼び出すのを忘れており、コードでは管理者以外のユーザーが構成を編集することを誤って許可しています！</target>
        </trans-unit>
        <trans-unit id="30996a44efb8790cbea6f775764e2a95c008cc8a" translate="yes" xml:space="preserve">
          <source>Here, we have a function &lt;code&gt;readImage&lt;/code&gt; which reads an image in a non-blocking asynchronous way. In addition to &lt;code&gt;readImage&lt;/code&gt;, we&amp;rsquo;ve provided a convenience function on &lt;code&gt;readImage&lt;/code&gt; itself called &lt;code&gt;readImage.sync&lt;/code&gt;.</source>
          <target state="translated">ここでは、非ブロッキング非同期の方法で画像を読み取る関数 &lt;code&gt;readImage&lt;/code&gt; があります。加えて &lt;code&gt;readImage&lt;/code&gt; 、我々は上の便利な機能提供してきました &lt;code&gt;readImage&lt;/code&gt; と呼ばれる自身 &lt;code&gt;readImage.sync&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="4776f9836ab53c81a717b79d18761f412dcd4953" translate="yes" xml:space="preserve">
          <source>Here, we have two local variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s scope is limited to the body of &lt;code&gt;f&lt;/code&gt; while &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s scope is limited to the containing &lt;code&gt;if&lt;/code&gt; statement&amp;rsquo;s block.</source>
          <target state="translated">ここでは、2つのローカル変数 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; があります。範囲は、本体に限定されている &lt;code&gt;f&lt;/code&gt; ながら &lt;code&gt;b&lt;/code&gt; の範囲が含まに限定されている &lt;code&gt;if&lt;/code&gt; 、文のブロック。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48b66ea86a98afc6732087affea2266d22665ee9" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ll split our &lt;code&gt;Validation&lt;/code&gt; namespace across many files. Even though the files are separate, they can each contribute to the same namespace and can be consumed as if they were all defined in one place. Because there are dependencies between files, we&amp;rsquo;ll add reference tags to tell the compiler about the relationships between the files. Our test code is otherwise unchanged.</source>
          <target state="translated">ここでは、 &lt;code&gt;Validation&lt;/code&gt; 名前空間を多数のファイルに分割します。ファイルは別々ですが、それぞれが同じ名前空間に関与し、すべてが1つの場所で定義されているかのように使用できます。ファイル間に依存関係があるため、ファイル間の関係をコンパイラーに通知する参照タグを追加します。それ以外のテストコードは変更されていません。</target>
        </trans-unit>
        <trans-unit id="0be76e8a894cfa9a5cd3d9c31525aeb3396a52fc" translate="yes" xml:space="preserve">
          <source>Here, when we say &lt;code&gt;let greeter: Greeter&lt;/code&gt;, we&amp;rsquo;re using &lt;code&gt;Greeter&lt;/code&gt; as the type of instances of the class &lt;code&gt;Greeter&lt;/code&gt;. This is almost second nature to programmers from other object-oriented languages.</source>
          <target state="translated">ここで、 &lt;code&gt;let greeter: Greeter&lt;/code&gt; と言うときは、 &lt;code&gt;Greeter&lt;/code&gt; クラスのインスタンスのタイプとして &lt;code&gt;Greeter&lt;/code&gt; を使用しています。これは、他のオブジェクト指向言語のプログラマにとって、ほぼ2番目の性質です。</target>
        </trans-unit>
        <trans-unit id="af2cc1b97022b7d58d48c283943b530d0c3a629b" translate="yes" xml:space="preserve">
          <source>Heterogeneous enums</source>
          <target state="translated">異種列挙</target>
        </trans-unit>
        <trans-unit id="fc6421364e8a88466f0b8a656c2d54672e0df2a5" translate="yes" xml:space="preserve">
          <source>High Level libraries</source>
          <target state="translated">高レベルライブラリ</target>
        </trans-unit>
        <trans-unit id="bcaf520cc3089e4cf8ad0800fc58fb622275eea2" translate="yes" xml:space="preserve">
          <source>Higher order type inference from generic constructors</source>
          <target state="translated">汎用コンストラクタからの高次型推論</target>
        </trans-unit>
        <trans-unit id="f7dd4ac35eed5e4b0152fe5390ac0fc4fdadf710" translate="yes" xml:space="preserve">
          <source>Higher order type inference from generic functions</source>
          <target state="translated">汎用関数からの高次型推論</target>
        </trans-unit>
        <trans-unit id="836a8611eb0ab70ee1d218e7f51d504c7581df05" translate="yes" xml:space="preserve">
          <source>Higher-kinded types</source>
          <target state="translated">高貴なタイプ</target>
        </trans-unit>
        <trans-unit id="173efd9dce0319d3f71e1aa5317de963557d2d4c" translate="yes" xml:space="preserve">
          <source>Hit &lt;code&gt;Install&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Install&lt;/code&gt; ヒット</target>
        </trans-unit>
        <trans-unit id="347baca49873f29800c610e216fe9cd584b6b62d" translate="yes" xml:space="preserve">
          <source>How Does A Mixin Work?</source>
          <target state="translated">ミキシングはどのように機能するのですか?</target>
        </trans-unit>
        <trans-unit id="89d412a555ac9119a1cb2746b4a8a508c5b127a6" translate="yes" xml:space="preserve">
          <source>How Node.js resolves modules</source>
          <target state="translated">Node.jsがモジュールを解決する方法</target>
        </trans-unit>
        <trans-unit id="1a330f9df74d0d83d178ec1580eb2080a18f5765" translate="yes" xml:space="preserve">
          <source>How TypeScript resolves modules</source>
          <target state="translated">TypeScriptがモジュールを解決する方法</target>
        </trans-unit>
        <trans-unit id="54183e0fc7898d58bfb00430e9606ee2944f7524" translate="yes" xml:space="preserve">
          <source>How do you obtain the library?</source>
          <target state="translated">図書館の入手方法を教えてください。</target>
        </trans-unit>
        <trans-unit id="0752a189682fd73c97a85ecfb50c84d4af385645" translate="yes" xml:space="preserve">
          <source>How does TypeScript relate to JavaScript, though?</source>
          <target state="translated">しかし、TypeScriptはJavaScriptとどのように関係しているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="5bd674995e2b8b711665e2c0340b40adea0356b1" translate="yes" xml:space="preserve">
          <source>How is this Handbook Structured</source>
          <target state="translated">このハンドブックはどのように構成されているか</target>
        </trans-unit>
        <trans-unit id="e505420e927902bf517a25b3ee02c1df4f205b0d" translate="yes" xml:space="preserve">
          <source>How to program in JavaScript, the good parts.</source>
          <target state="translated">JavaScriptでプログラミングする方法、良いところ。</target>
        </trans-unit>
        <trans-unit id="a165cba49bf6f53be535d3bada5e871711caec2e" translate="yes" xml:space="preserve">
          <source>How to use TypeScript-powered JavaScript tooling.</source>
          <target state="translated">TypeScriptを使ったJavaScriptツールの使い方。</target>
        </trans-unit>
        <trans-unit id="88bab0a4785a544d72f7174abbe7378f0e4c5e6b" translate="yes" xml:space="preserve">
          <source>How would you import it?</source>
          <target state="translated">どうやってインポートするの?</target>
        </trans-unit>
        <trans-unit id="62e32177f5bf0ee0e14e3a31c7e50429ce2039cd" translate="yes" xml:space="preserve">
          <source>However, TypeScript is a &lt;em&gt;typed&lt;/em&gt; superset, meaning that it adds rules about how different kinds of values can be used. The earlier error about &lt;code&gt;obj.heigth&lt;/code&gt; was not a &lt;em&gt;syntax&lt;/em&gt; error: it is an error of using some kind of value (a &lt;em&gt;type&lt;/em&gt;) in an incorrect way.</source>
          <target state="translated">ただし、TypeScriptは&lt;em&gt;型付き&lt;/em&gt;スーパーセットです。つまり、さまざまな種類の値を使用する方法に関するルールが追加されます。 &lt;code&gt;obj.heigth&lt;/code&gt; に関する以前のエラーは、&lt;em&gt;構文&lt;/em&gt;エラーではありませんでした。これは、ある種の値（&lt;em&gt;タイプ&lt;/em&gt;）を誤った方法で使用した場合のエラーです。</target>
        </trans-unit>
        <trans-unit id="aea32d84fa10a6814afacd1681bb1e9a0cfcb214" translate="yes" xml:space="preserve">
          <source>However, TypeScript takes the stance that there&amp;rsquo;s probably a bug in this code. Object literals get special treatment and undergo &lt;em&gt;excess property checking&lt;/em&gt; when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the &amp;ldquo;target type&amp;rdquo; doesn&amp;rsquo;t have, you&amp;rsquo;ll get an error:</source>
          <target state="translated">ただし、TypeScriptは、このコードにバグがある可能性があるという立場を取ります。オブジェクトリテラルは特別な扱いを受け、他の変数に割り当てたり、引数として渡したり&lt;em&gt;する&lt;/em&gt;ときに&lt;em&gt;過剰なプロパティチェック&lt;/em&gt;を受けます。オブジェクトリテラルに「ターゲットタイプ」にはないプロパティがある場合、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="2df3cad6545d1673cff30d2239dcbcac86f68714" translate="yes" xml:space="preserve">
          <source>However, TypeScript would instead transform the original code into this code:</source>
          <target state="translated">しかし、TypeScript は元のコードをこのコードに変換します。</target>
        </trans-unit>
        <trans-unit id="d67a8b4fe7f16ad0a4a00091ab517503777587fe" translate="yes" xml:space="preserve">
          <source>However, a better approach might be to add a string index signature if you&amp;rsquo;re sure that the object can have some extra properties that are used in some special way. If &lt;code&gt;SquareConfig&lt;/code&gt; can have &lt;code&gt;color&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; properties with the above types, but could &lt;em&gt;also&lt;/em&gt; have any number of other properties, then we could define it like so:</source>
          <target state="translated">ただし、オブジェクトが特別な方法で使用される追加のプロパティを持つことが確実である場合は、文字列インデックスシグネチャを追加することをお勧めします。場合 &lt;code&gt;SquareConfig&lt;/code&gt; を持つことができ &lt;code&gt;color&lt;/code&gt; と &lt;code&gt;width&lt;/code&gt; 上記のタイプと特性が、しかし可能性&lt;em&gt;も&lt;/em&gt;他の任意の数のプロパティを持っている、そして我々はそれがとても好きで定義することができます。</target>
        </trans-unit>
        <trans-unit id="ae34467865c8caaf898bf37d8295d39c36fa465b" translate="yes" xml:space="preserve">
          <source>However, a lot of the time, you might just want to import an existing module that may not have its own &lt;code&gt;.d.ts&lt;/code&gt; file. Previously this was an error. Starting with TypeScript 2.1 this is now much easier.</source>
          <target state="translated">ただし、多くの場合、独自の &lt;code&gt;.d.ts&lt;/code&gt; ファイルを持たない可能性がある既存のモジュールをインポートしたいだけかもしれません。以前は、これはエラーでした。TypeScript 2.1以降、これははるかに簡単になりました。</target>
        </trans-unit>
        <trans-unit id="f0b057c2f8bc22925ee5d37f69c394f9bb4475bc" translate="yes" xml:space="preserve">
          <source>However, a useful heuristic could be:</source>
          <target state="translated">しかし、有用なヒューリスティックは可能性があります。</target>
        </trans-unit>
        <trans-unit id="52fd9d1ab67ec13644f81aac04cb75b6dad506bf" translate="yes" xml:space="preserve">
          <source>However, combining the two naively would allow an error to sneak in. For example, taking our last example using &lt;code&gt;createSquare&lt;/code&gt;:</source>
          <target state="translated">ただし、2つを &lt;code&gt;createSquare&lt;/code&gt; に組み合わせると、エラーが潜入する可能性があります。たとえば、createSquareを使用した最後の例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="5fd6902ab8657b5adb4ddbc9ea60a37a54d752ab" translate="yes" xml:space="preserve">
          <source>However, having to define a function to figure out if a type is a primitive is kind of a pain. Luckily, you don&amp;rsquo;t need to abstract &lt;code&gt;typeof x === &quot;number&quot;&lt;/code&gt; into its own function because TypeScript will recognize it as a type guard on its own. That means we could just write these checks inline.</source>
          <target state="translated">ただし、型がプリミティブであるかどうかを判別するために関数を定義する必要があるのは、一種の苦痛です。幸い、TypeScriptはそれ自体をタイプガードとして認識するため、 &lt;code&gt;typeof x === &quot;number&quot;&lt;/code&gt; を独自の関数に抽象化する必要はありません。つまり、これらのチェックをインラインで記述できます。</target>
        </trans-unit>
        <trans-unit id="cb2ee9a73119ef2301052f4deb325a8b58f2559f" translate="yes" xml:space="preserve">
          <source>However, in the above example, both &lt;code&gt;FruitEater&lt;/code&gt;s and &lt;code&gt;ColorConsumer&lt;/code&gt;s should be able to take the string &lt;code&gt;&quot;orange&quot;&lt;/code&gt;, and return either a &lt;code&gt;number&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">ただし、上記の例では、 &lt;code&gt;FruitEater&lt;/code&gt; と &lt;code&gt;ColorConsumer&lt;/code&gt; の両方が文字列 &lt;code&gt;&quot;orange&quot;&lt;/code&gt; を取り、 &lt;code&gt;number&lt;/code&gt; または &lt;code&gt;string&lt;/code&gt; を返すことができる必要があります。</target>
        </trans-unit>
        <trans-unit id="6b3269ba44655740fda35e4a6cc5c78cee6e3c08" translate="yes" xml:space="preserve">
          <source>However, in the following example, no error will be reported because the fall-through case is empty:</source>
          <target state="translated">しかし、以下の例では、フォールスルーケースが空なのでエラーは出ません。</target>
        </trans-unit>
        <trans-unit id="9b7d9dc4338c505863904ace315d827dbbcdc28f" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s not possible for a type alias to appear anywhere else on the right side of the declaration:</source>
          <target state="translated">ただし、型エイリアスを宣言の右側の他の場所に表示することはできません。</target>
        </trans-unit>
        <trans-unit id="261cdca866e8fca9691e1b837aea779937f4bb40" translate="yes" xml:space="preserve">
          <source>However, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:</source>
          <target state="translated">しかし、制約の型変数を削除し、代わりに条件付き型を指定することで、ほとんど同じ効果を得ることができます。</target>
        </trans-unit>
        <trans-unit id="876ffd4a2dccce5f7851ed0c26a166758d84a1c1" translate="yes" xml:space="preserve">
          <source>However, none of these options are the default, so they are not consistently used in TypeScript code.</source>
          <target state="translated">しかし、これらのオプションはどれもデフォルトではないので、TypeScriptのコードでは一貫して使用されていません。</target>
        </trans-unit>
        <trans-unit id="e03cd94fc4a5be72b1eb26d1ba79c9cc8372ade3" translate="yes" xml:space="preserve">
          <source>However, properties of different types are acceptable if the index signature is a union of the property types:</source>
          <target state="translated">ただし、インデックス署名がプロパティタイプの和であれば、異なるタイプのプロパティも許容されます。</target>
        </trans-unit>
        <trans-unit id="21bd5d4e23e02c99e9395288fd2b3c14719c2452" translate="yes" xml:space="preserve">
          <source>However, resolution for a &lt;a href=&quot;#relative-vs-non-relative-module-imports&quot;&gt;non-relative module name&lt;/a&gt; is performed differently. Node will look for your modules in special folders named &lt;code&gt;node_modules&lt;/code&gt;. A &lt;code&gt;node_modules&lt;/code&gt; folder can be on the same level as the current file, or higher up in the directory chain. Node will walk up the directory chain, looking through each &lt;code&gt;node_modules&lt;/code&gt; until it finds the module you tried to load.</source>
          <target state="translated">ただし、&lt;a href=&quot;#relative-vs-non-relative-module-imports&quot;&gt;非相対モジュール名の解決&lt;/a&gt;は異なる方法で実行されます。Nodeは &lt;code&gt;node_modules&lt;/code&gt; という名前の特別なフォルダーでモジュールを探します。 &lt;code&gt;node_modules&lt;/code&gt; は、フォルダは、ディレクトリチェーンのアップ高い現在のファイルと同じレベルにあること、またはすることができます。ノードは、ロードしようとしたモジュールが見つかるまで、各 &lt;code&gt;node_modules&lt;/code&gt; を調べながら、ディレクトリチェーンを上に移動します。</target>
        </trans-unit>
        <trans-unit id="4066c0cf22c6617cd0e99b116883a9d0812e7a0a" translate="yes" xml:space="preserve">
          <source>However, there are two limitations to keep in mind:</source>
          <target state="translated">しかし、注意しなければならないことは2つあります。</target>
        </trans-unit>
        <trans-unit id="1b475ae409f46bd0059bada064f2253dfa62d98f" translate="yes" xml:space="preserve">
          <source>However, this code will log &lt;code&gt;undefined&lt;/code&gt;, since &lt;code&gt;uiEvent&lt;/code&gt; has no property called &lt;code&gt;button&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;uiEvent&lt;/code&gt; には &lt;code&gt;button&lt;/code&gt; というプロパティがないため、このコードは &lt;code&gt;undefined&lt;/code&gt; ログを記録します。</target>
        </trans-unit>
        <trans-unit id="e528b8c265ab20d7ddf0074a5c552ac0aa502914" translate="yes" xml:space="preserve">
          <source>However, this is error prone - there is nothing stopping a user from accidentally misspelling one of the valid easing values:</source>
          <target state="translated">しかし、これはエラーになりやすいものです-有効な緩和値のいずれかを誤って書き間違えてしまうことは何もありません。</target>
        </trans-unit>
        <trans-unit id="5a8176fb9274a3dbc59832e6bbcd686e944cd704" translate="yes" xml:space="preserve">
          <source>However, this is observably different in certain rare cases. For example, if an array has a &amp;ldquo;hole&amp;rdquo; in it, the missing index will create an &lt;em&gt;own&lt;/em&gt; property if spreaded, but will not if built using &lt;code&gt;concat&lt;/code&gt;:</source>
          <target state="translated">ただし、これは特定のまれなケースで明らかに異なります。たとえば、配列に「穴」がある場合、欠落しているインデックスは、拡散すると&lt;em&gt;独自の&lt;/em&gt;プロパティを作成しますが、 &lt;code&gt;concat&lt;/code&gt; を使用して構築した場合は作成しません。</target>
        </trans-unit>
        <trans-unit id="47f0cbbb6af8b4a1e0b5d52577ef8a8ca00678b1" translate="yes" xml:space="preserve">
          <source>However, this was a bit overly strict for the original example. If you figure out the precise type of any possible value of &lt;code&gt;S&lt;/code&gt;, you can actually see that it matches the types in &lt;code&gt;T&lt;/code&gt; exactly.</source>
          <target state="translated">ただし、これは元の例では少し厳しすぎました。 &lt;code&gt;S&lt;/code&gt; の考えられる値の正確な型を理解すると、実際に &lt;code&gt;T&lt;/code&gt; の型と正確に一致していることがわかります。</target>
        </trans-unit>
        <trans-unit id="a82aa6652361ecc5084c82f581d35a4cecb03722" translate="yes" xml:space="preserve">
          <source>However, when comparing types that have &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; members, we treat these types differently. For two types to be considered compatible, if one of them has a &lt;code&gt;private&lt;/code&gt; member, then the other must have a &lt;code&gt;private&lt;/code&gt; member that originated in the same declaration. The same applies to &lt;code&gt;protected&lt;/code&gt; members.</source>
          <target state="translated">ただし、 &lt;code&gt;private&lt;/code&gt; メンバーと &lt;code&gt;protected&lt;/code&gt; メンバーを持つ型を比較す​​る場合、これらの型の扱いは異なります。2つのタイプが互換性があると見なされるには、一方に &lt;code&gt;private&lt;/code&gt; メンバーがある場合、もう一方には同じ宣言で発生した &lt;code&gt;private&lt;/code&gt; メンバーが必要です。 &lt;code&gt;protected&lt;/code&gt; メンバーについても同様です。</target>
        </trans-unit>
        <trans-unit id="e30d71bb57f4f77a84a108277b5b36c06cf3ebc6" translate="yes" xml:space="preserve">
          <source>However, when using the &lt;code&gt;--strictNullChecks&lt;/code&gt; flag, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are only assignable to &lt;code&gt;any&lt;/code&gt; and their respective types (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). This helps avoid &lt;em&gt;many&lt;/em&gt; common errors. In cases where you want to pass in either a &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the union type &lt;code&gt;string | null | undefined&lt;/code&gt;.</source>
          <target state="translated">ただし、-- &lt;code&gt;--strictNullChecks&lt;/code&gt; フラグを使用する場合、 &lt;code&gt;null&lt;/code&gt; および &lt;code&gt;undefined&lt;/code&gt; は、 &lt;code&gt;any&lt;/code&gt; およびそれぞれのタイプにのみ割り当て可能です（1つの例外は、 &lt;code&gt;undefined&lt;/code&gt; も &lt;code&gt;void&lt;/code&gt; に割り当て可能であることです）。これにより、&lt;em&gt;多くの&lt;/em&gt;一般的なエラーを回避できます。 &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;null&lt;/code&gt; 、または &lt;code&gt;undefined&lt;/code&gt; のいずれかを渡したい場合は、共用体型の &lt;code&gt;string | null | undefined&lt;/code&gt; 使用できます。 null |未定義。</target>
        </trans-unit>
        <trans-unit id="047dbc98484657ac4d0055ecd2b94304fd075dce" translate="yes" xml:space="preserve">
          <source>However, when using the &lt;code&gt;--strictNullChecks&lt;/code&gt; flag, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are only assignable to &lt;code&gt;unknown&lt;/code&gt;, &lt;code&gt;any&lt;/code&gt; and their respective types (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). This helps avoid &lt;em&gt;many&lt;/em&gt; common errors. In cases where you want to pass in either a &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the union type &lt;code&gt;string | null | undefined&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;--strictNullChecks&lt;/code&gt; フラグを使用する場合、 &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; は &lt;code&gt;unknown&lt;/code&gt; 、 &lt;code&gt;any&lt;/code&gt; 、およびそれぞれのタイプにのみ割り当てることができます（ &lt;code&gt;undefined&lt;/code&gt; も &lt;code&gt;void&lt;/code&gt; に割り当てることができるという1つの例外があります）。これにより、&lt;em&gt;多くの&lt;/em&gt;一般的なエラーを回避できます。 &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;null&lt;/code&gt; 、または &lt;code&gt;undefined&lt;/code&gt; いずれかを渡したい場合は、共用体型 &lt;code&gt;string | null | undefined&lt;/code&gt; 使用できます。 null |未定義。</target>
        </trans-unit>
        <trans-unit id="ac716fe1287c18ff224c30b0e3ef28c757beb2fe" translate="yes" xml:space="preserve">
          <source>However, you may have intended for &lt;code&gt;core&lt;/code&gt; to be part of the output directory structure. By setting &lt;code&gt;rootDir: &quot;.&quot;&lt;/code&gt; in &lt;code&gt;tsconfig.json&lt;/code&gt;, TypeScript would write this tree:</source>
          <target state="translated">ただし、 &lt;code&gt;core&lt;/code&gt; を出力ディレクトリ構造の一部にすることを意図している場合があります。 &lt;code&gt;rootDir: &quot;.&quot;&lt;/code&gt; 設定することにより： &quot;。&quot; で &lt;code&gt;tsconfig.json&lt;/code&gt; 、活字体は、このツリーを記述します。</target>
        </trans-unit>
        <trans-unit id="3a16fbd6d0aeace5fd6859531c3e68218d7a29dc" translate="yes" xml:space="preserve">
          <source>Hybrid Types</source>
          <target state="translated">ハイブリッドタイプ</target>
        </trans-unit>
        <trans-unit id="51fed45c4210870abf204ad077a177b04a015861" translate="yes" xml:space="preserve">
          <source>IIFEs as namespace declarations</source>
          <target state="translated">名前空間宣言としてのIIFE</target>
        </trans-unit>
        <trans-unit id="b0e5d24c6bc89831f1e2de048c03becf6f8a2dab" translate="yes" xml:space="preserve">
          <source>Ideally this should stay at 0 (the default), and &lt;code&gt;d.ts&lt;/code&gt; files should be used to explicitly define the shape of modules. However, there are cases where you may want to turn this on at the expense of speed and potential accuracy.</source>
          <target state="translated">理想的には、これは0（デフォルト）のままであり、 &lt;code&gt;d.ts&lt;/code&gt; ファイルを使用してモジュールの形状を明示的に定義する必要があります。ただし、速度と潜在的な精度を犠牲にして、これをオンにしたい場合があります。</target>
        </trans-unit>
        <trans-unit id="aacc04465943461c4401f154c73b82378a7e907a" translate="yes" xml:space="preserve">
          <source>Ideally, we may want &lt;code&gt;zoo&lt;/code&gt; to be inferred as an &lt;code&gt;Animal[]&lt;/code&gt;, but because there is no object that is strictly of type &lt;code&gt;Animal&lt;/code&gt; in the array, we make no inference about the array element type. To correct this, instead explicitly provide the type when no one type is a super type of all other candidates:</source>
          <target state="translated">理想的には、 &lt;code&gt;zoo&lt;/code&gt; を &lt;code&gt;Animal[]&lt;/code&gt; として推論したい場合がありますが、配列内に厳密に &lt;code&gt;Animal&lt;/code&gt; タイプのオブジェクトがないため、配列要素のタイプについて推論しません。これを修正するには、1つのタイプが他のすべての候補のスーパータイプではないときに、代わりに明示的にタイプを指定します。</target>
        </trans-unit>
        <trans-unit id="3fb44df7e96b3c06b0f62dc3d3bf658dd46e932c" translate="yes" xml:space="preserve">
          <source>Ideally, we&amp;rsquo;d just import the React module from within the browser, but most browsers still don&amp;rsquo;t quite support modules yet. Instead libraries have traditionally made themselves available using a single global variable like &lt;code&gt;jQuery&lt;/code&gt; or &lt;code&gt;_&lt;/code&gt;. This is called the &amp;ldquo;namespace pattern&amp;rdquo;, and webpack allows us to continue leveraging libraries written that way. With our entry for &lt;code&gt;&quot;react&quot;: &quot;React&quot;&lt;/code&gt;, webpack will work its magic to make any import of &lt;code&gt;&quot;react&quot;&lt;/code&gt; load from the &lt;code&gt;React&lt;/code&gt; variable.</source>
          <target state="translated">理想的には、ブラウザー内からReactモジュールをインポートするだけですが、ほとんどのブラウザーはまだモジュールを完全にはサポートしていません。代わりに、ライブラリは従来、 &lt;code&gt;jQuery&lt;/code&gt; や &lt;code&gt;_&lt;/code&gt; などの単一のグローバル変数を使用して、ライブラリを利用できるようにしていました。これは「名前空間パターン」と呼ばれ、webpackを使用すると、そのように記述されたライブラリを引き続き活用できます。 &lt;code&gt;&quot;react&quot;: &quot;React&quot;&lt;/code&gt; エントリである「React」を使用すると、webpackはその魔法を働かせて、 &lt;code&gt;React&lt;/code&gt; 変数から &lt;code&gt;&quot;react&quot;&lt;/code&gt; ロードをインポートします。</target>
        </trans-unit>
        <trans-unit id="0f435dc0d9d21e95947646e4a4aa314593787165" translate="yes" xml:space="preserve">
          <source>Identical Types</source>
          <target state="translated">同一のタイプ</target>
        </trans-unit>
        <trans-unit id="7e95984082de67338b2c7ddbc538f64e016c8d48" translate="yes" xml:space="preserve">
          <source>Identifying Kinds of Libraries</source>
          <target state="translated">図書館の種類を見極める</target>
        </trans-unit>
        <trans-unit id="e5eb14c632b87d0c6ad5e592a44a1a8fee7f0639" translate="yes" xml:space="preserve">
          <source>Identifying a Global Library from Code</source>
          <target state="translated">コードからグローバルライブラリを識別する</target>
        </trans-unit>
        <trans-unit id="a2ba79579e03b8f78ffd87dd47a547b41065fc1e" translate="yes" xml:space="preserve">
          <source>Identifying a Module Library from Code</source>
          <target state="translated">コードからモジュールライブラリを識別する</target>
        </trans-unit>
        <trans-unit id="96a39992ddd95916928039e6a01815883f0054ca" translate="yes" xml:space="preserve">
          <source>Identifying a UMD library</source>
          <target state="translated">UMD図書館を特定する</target>
        </trans-unit>
        <trans-unit id="88076b9c11713a1d1df3ba70daf4f6393c85d874" translate="yes" xml:space="preserve">
          <source>Identifying global plugins</source>
          <target state="translated">グローバルプラグインの識別</target>
        </trans-unit>
        <trans-unit id="7d0b0dbee7bf8c6735a82b5f8993e432ee3b5ca1" translate="yes" xml:space="preserve">
          <source>Identifying global-modifying modules</source>
          <target state="translated">グローバル修飾モジュールの識別</target>
        </trans-unit>
        <trans-unit id="75c608e5e061dd97d023874171193ba0dedb0879" translate="yes" xml:space="preserve">
          <source>Identifying the structure of a library is the first step in writing its declaration file. We&amp;rsquo;ll give hints on how to identify structure both based on its &lt;em&gt;usage&lt;/em&gt; and its &lt;em&gt;code&lt;/em&gt;. Depending on the library&amp;rsquo;s documentation and organization, one might be easier than the other. We recommend using whichever is more comfortable to you.</source>
          <target state="translated">ライブラリの構造を識別することは、その宣言ファイルを作成する最初のステップです。&lt;em&gt;使用法&lt;/em&gt;と&lt;em&gt;コードの&lt;/em&gt;両方に基づいて構造を識別する方法のヒントを示し&lt;em&gt;ます&lt;/em&gt;。ライブラリのドキュメントと構成によっては、一方が他方よりも簡単な場合があります。どちらか使いやすい方をお勧めします。</target>
        </trans-unit>
        <trans-unit id="8bd1ece9a873c798fd3b2f187514a3f9ff53eeee" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;default&amp;rsquo; and &amp;lsquo;clean&amp;rsquo; tasks don&amp;rsquo;t show up, refresh the explorer:</source>
          <target state="translated">「デフォルト」タスクと「クリーン」タスクが表示されない場合は、エクスプローラーを更新します。</target>
        </trans-unit>
        <trans-unit id="b398aaa2e3e793e66c0386971a0fcc7d95fd4011" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TypeScriptToolsVersion&lt;/code&gt; is not specified, the latest compiler version installed on the machine will be used to build.</source>
          <target state="translated">&lt;code&gt;TypeScriptToolsVersion&lt;/code&gt; が指定されていない場合、マシンにインストールされている最新のコンパイラバージョンがビルドに使用されます。</target>
        </trans-unit>
        <trans-unit id="1a66bd888ae761260069cb56ba3782c6cb9f2948" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; contains a numeric index signature, &lt;code&gt;keyof X&lt;/code&gt; is a union of &lt;code&gt;number&lt;/code&gt; and the literal types representing string-like and symbol-like properties, otherwise</source>
          <target state="translated">場合 &lt;code&gt;X&lt;/code&gt; は、数値インデックスの署名を含む &lt;code&gt;keyof X&lt;/code&gt; の組合で &lt;code&gt;number&lt;/code&gt; さもなければ、及び紐状及びシンボル様の特性を表すリテラルタイプ</target>
        </trans-unit>
        <trans-unit id="6616ffdf1f61f5f170f5695d095b28464311066e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; contains a string index signature, &lt;code&gt;keyof X&lt;/code&gt; is a union of &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, and the literal types representing symbol-like properties, otherwise</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; に文字列インデックスシグネチャが含まれる場合、 &lt;code&gt;keyof X&lt;/code&gt; は &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;number&lt;/code&gt; 、およびシンボルのようなプロパティを表すリテラルタイプの和集合です。それ以外の場合は</target>
        </trans-unit>
        <trans-unit id="f0343e4e3ae4fdd7375e56cd9c4d11af9cc6df5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isolatedModules&lt;/code&gt; is set, all implementation files must be &lt;em&gt;modules&lt;/em&gt; (which means it has some form of &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;export&lt;/code&gt;). An error occurs if any file isn&amp;rsquo;t a module:</source>
          <target state="translated">&lt;code&gt;isolatedModules&lt;/code&gt; が設定されている場合、すべての実装ファイルは&lt;em&gt;モジュールである&lt;/em&gt;必要があり&lt;em&gt;ます&lt;/em&gt;（つまり、何らかの形式の &lt;code&gt;import&lt;/code&gt; / &lt;code&gt;export&lt;/code&gt; ）。いずれかのファイルがモジュールでない場合、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="71c3593112427fc1b30c2239c25266a482dc1c35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;module&lt;/code&gt; is &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;amd&lt;/code&gt;, all module files will also be concatenated into this file after all global content.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; が &lt;code&gt;system&lt;/code&gt; または &lt;code&gt;amd&lt;/code&gt; の場合、すべてのグローバルコンテンツの後に、すべてのモジュールファイルもこのファイルに連結されます。</target>
        </trans-unit>
        <trans-unit id="67882abab18e10cbd606e356f6ed753bf2457955" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;noResolve&lt;/code&gt; is set, this process doesn&amp;rsquo;t happen. However, &lt;code&gt;import&lt;/code&gt; statements are still checked to see if they resolve to a valid module, so you&amp;rsquo;ll need to make sure this is satisfied by some other means.</source>
          <target state="translated">&lt;code&gt;noResolve&lt;/code&gt; が設定されている場合、このプロセスは実行されません。ただし、 &lt;code&gt;import&lt;/code&gt; ステートメントは、有効なモジュールに解決されるかどうかを確認するために引き続きチェックされるため、他の方法でこれが満たされていることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="2f946b4318e41dbe69a87cd5f88e67367fd6d44f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typeRoots&lt;/code&gt; is specified, &lt;em&gt;only&lt;/em&gt; packages under &lt;code&gt;typeRoots&lt;/code&gt; will be included. For example:</source>
          <target state="translated">場合 &lt;code&gt;typeRoots&lt;/code&gt; が指定されている、&lt;em&gt;唯一&lt;/em&gt;の下のパッケージ &lt;code&gt;typeRoots&lt;/code&gt; が含まれます。例えば：</target>
        </trans-unit>
        <trans-unit id="76e7b062f347c8ed5beb7e6e8b7549983806fc75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, only packages listed will be included in the global scope. For instance:</source>
          <target state="translated">&lt;code&gt;types&lt;/code&gt; が指定されている場合、リストされているパッケージのみがグローバルスコープに含まれます。例えば：</target>
        </trans-unit>
        <trans-unit id="99b6d90008fb9649958f2be05e76b1dd9a5961c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, only packages listed will be included. For instance:</source>
          <target state="translated">&lt;code&gt;types&lt;/code&gt; が指定されている場合、リストされているパッケージのみが含まれます。例えば：</target>
        </trans-unit>
        <trans-unit id="6fbac6cb9d3b7de97e789cbb5b4510b49f088657" translate="yes" xml:space="preserve">
          <source>If a decision ever comes down to &lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt;, you should prefer &lt;code&gt;{}&lt;/code&gt;. While they are mostly the same, technically &lt;code&gt;{}&lt;/code&gt; is a more general type than &lt;code&gt;Object&lt;/code&gt; in certain esoteric cases.</source>
          <target state="translated">決定は、これまでに降りてきた場合は &lt;code&gt;Object&lt;/code&gt; と &lt;code&gt;{}&lt;/code&gt; 、あなたが選ぶべき &lt;code&gt;{}&lt;/code&gt; 。それらはほとんど同じですが、技術的には、 &lt;code&gt;{}&lt;/code&gt; は特定の難解なケースでは &lt;code&gt;Object&lt;/code&gt; よりも一般的な型です。</target>
        </trans-unit>
        <trans-unit id="2ac2b4a6a24acc5fecb490e99fb16cab96cc3bf4" translate="yes" xml:space="preserve">
          <source>If a default type is specified and inference cannot choose a candidate, the default type is inferred.</source>
          <target state="translated">デフォルト型が指定されていて、推論で候補を選択できない場合は、デフォルト型を推論します。</target>
        </trans-unit>
        <trans-unit id="c71457b71cd95a1cb2a171eb57463a371dcaec7c" translate="yes" xml:space="preserve">
          <source>If a glob pattern doesn&amp;rsquo;t include a file extension, then only files with supported extensions are included (e.g. &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and &lt;code&gt;.d.ts&lt;/code&gt; by default, with &lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; if &lt;code&gt;allowJs&lt;/code&gt; is set to true).</source>
          <target state="translated">グロブパターンは、ファイルの拡張子が含まれていない場合は、唯一サポートされている拡張子を持つファイル（例えば含まれている &lt;code&gt;.ts&lt;/code&gt; 、 &lt;code&gt;.tsx&lt;/code&gt; 、および &lt;code&gt;.d.ts&lt;/code&gt; と、デフォルトでは、 &lt;code&gt;.js&lt;/code&gt; ファイルと &lt;code&gt;.jsx&lt;/code&gt; のを場合 &lt;code&gt;allowJs&lt;/code&gt; がtrueに設定されています）。</target>
        </trans-unit>
        <trans-unit id="75f219ce45668d5a735796fec9609c181f98317e" translate="yes" xml:space="preserve">
          <source>If a module should not be automatically acquired, for example if the library is available in your &lt;code&gt;node_modules&lt;/code&gt; but your team has agreed to not use it:</source>
          <target state="translated">モジュールを自動的に取得する必要がない場合、たとえば、ライブラリが &lt;code&gt;node_modules&lt;/code&gt; で使用可能であるが、チームがそれを使用しないことに同意した場合：</target>
        </trans-unit>
        <trans-unit id="8fbc86845e0d24c360aaf1bfbc58393acef68624" translate="yes" xml:space="preserve">
          <source>If a segment of a glob pattern includes only &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;.*&lt;/code&gt;, then only files with supported extensions are included (e.g. &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and &lt;code&gt;.d.ts&lt;/code&gt; by default with &lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; if &lt;code&gt;allowJs&lt;/code&gt; is set to true).</source>
          <target state="translated">グロブパターンのセグメントが含まれている場合のみ、 &lt;code&gt;*&lt;/code&gt; または &lt;code&gt;.*&lt;/code&gt; （例えば、だけ含まれているサポートの拡張子を持つファイル &lt;code&gt;.ts&lt;/code&gt; 、 &lt;code&gt;.tsx&lt;/code&gt; 、および &lt;code&gt;.d.ts&lt;/code&gt; と、デフォルトで &lt;code&gt;.js&lt;/code&gt; と &lt;code&gt;.jsx&lt;/code&gt; の場合 &lt;code&gt;allowJs&lt;/code&gt; が trueに設定されています） 。</target>
        </trans-unit>
        <trans-unit id="bec2b2f64a8b9ad3998bf7f229a2fbb020be7798" translate="yes" xml:space="preserve">
          <source>If absent, then &amp;ldquo;main&amp;rdquo; is used</source>
          <target state="translated">存在しない場合は、「メイン」が使用されます</target>
        </trans-unit>
        <trans-unit id="54daf0bb0e7d1bcc3df23442a6dc487446e709b6" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, or &lt;code&gt;in&lt;/code&gt; operator is nullable.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;=&lt;/code&gt; 、または &lt;code&gt;in&lt;/code&gt; 演算子のいずれかのオペランドがNULL可能である場合。</target>
        </trans-unit>
        <trans-unit id="ea5b35d5abd4cbfb9f096e8d991dcb47c08f66f4" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;+&lt;/code&gt; operator is nullable, and neither operand is of type &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 演算子のいずれかのオペランドがNULL可能で、どちらのオペランド &lt;code&gt;any&lt;/code&gt; または &lt;code&gt;string&lt;/code&gt; 型でない場合。</target>
        </trans-unit>
        <trans-unit id="d883272b1b0531d98de565e92423069ee2248d62" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, or &lt;code&gt;^&lt;/code&gt; operator is nullable.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;**&lt;/code&gt; 、 &lt;code&gt;/&lt;/code&gt; 、 &lt;code&gt;%&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; のいずれかのオペランドの場合 、または &lt;code&gt;^&lt;/code&gt; 演算子はNULL可能です。</target>
        </trans-unit>
        <trans-unit id="b999341c4d2107c29465088a4be729def05702d7" translate="yes" xml:space="preserve">
          <source>If environment variable &lt;code&gt;TSC_NONPOLLING_WATCHER&lt;/code&gt; is set to true, watches parent directory of files (just like &lt;code&gt;UseFsEventsOnParentDirectory&lt;/code&gt;). Otherwise watch files using &lt;code&gt;fs.watchFile&lt;/code&gt; with &lt;code&gt;250ms&lt;/code&gt; as the timeout for any file</source>
          <target state="translated">環境変数 &lt;code&gt;TSC_NONPOLLING_WATCHER&lt;/code&gt; がtrueに設定されている場合は、ファイルの親ディレクトリを監視します（ &lt;code&gt;UseFsEventsOnParentDirectory&lt;/code&gt; と同様）。そうでなければ使用してファイルを見 &lt;code&gt;fs.watchFile&lt;/code&gt; をして &lt;code&gt;250ms&lt;/code&gt; の任意のファイルのタイムアウトとして</target>
        </trans-unit>
        <trans-unit id="d06262f17b6e967b3001fc6098e3202e17df154f" translate="yes" xml:space="preserve">
          <source>If not specified, &lt;code&gt;.js&lt;/code&gt; files will be emitted in the same directory as the &lt;code&gt;.ts&lt;/code&gt; files they were generated from:</source>
          <target state="translated">指定しない場合、 &lt;code&gt;.js&lt;/code&gt; ファイルはそれらが生成された &lt;code&gt;.ts&lt;/code&gt; ファイルと同じディレクトリに出力されます。</target>
        </trans-unit>
        <trans-unit id="d23e16bdfbddee4b25eaec4b1d684282e726836a" translate="yes" xml:space="preserve">
          <source>If properties are never set in the class body, they are considered unknown. If your class has properties that are only read from, add and then annotate a declaration in the constructor with JSDoc to specify the type. You don&amp;rsquo;t even have to give a value if it will be initialised later:</source>
          <target state="translated">プロパティがクラス本体で設定されていない場合、それらは不明と見なされます。クラスに読み取り専用のプロパティがある場合は、JSDocを使用してコンストラクターの宣言を追加し、注釈を付けて型を指定します。後で初期化する場合は、値を指定する必要もありません。</target>
        </trans-unit>
        <trans-unit id="5a4ad169ba84bf7c2bddecab5b752919e9c60ee2" translate="yes" xml:space="preserve">
          <source>If specified, &lt;code&gt;.js&lt;/code&gt; (as well as &lt;code&gt;.d.ts&lt;/code&gt;, &lt;code&gt;.js.map&lt;/code&gt;, etc.) files will be emitted into this directory. The directory structure of the original source files is preserved; see &lt;a href=&quot;#rootDir&quot;&gt;rootDir&lt;/a&gt; if the computed root is not what you intended.</source>
          <target state="translated">指定した場合、 &lt;code&gt;.js&lt;/code&gt; （および &lt;code&gt;.d.ts&lt;/code&gt; 、 &lt;code&gt;.js.map&lt;/code&gt; など）ファイルがこのディレクトリに出力されます。元のソースファイルのディレクトリ構造は保持されます。計算されたルートが意図したものでない場合は、&lt;a href=&quot;#rootDir&quot;&gt;rootDirを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4c82e3245bf395bde8ad50d56147266b35e02cbd" translate="yes" xml:space="preserve">
          <source>If specified, all &lt;em&gt;global&lt;/em&gt; (non-module) files will be concatenated into the single output file specified.</source>
          <target state="translated">指定した場合、すべての&lt;em&gt;グローバル&lt;/em&gt;（非モジュール）ファイルは、指定した単一の出力ファイルに連結されます。</target>
        </trans-unit>
        <trans-unit id="cf548e316f27cc773ad61fba2e4a76543f3bb1ce" translate="yes" xml:space="preserve">
          <source>If that didn&amp;rsquo;t work and if the module name is non-relative (and in the case of &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt;, it is), then the compiler will attempt to locate an &lt;a href=&quot;modules#ambient-modules&quot;&gt;ambient module declaration&lt;/a&gt;. We&amp;rsquo;ll cover non-relative imports next.</source>
          <target state="translated">それが機能せず、モジュール名が非相対である場合（そして &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; 場合は、そうです）、コンパイラーは&lt;a href=&quot;modules#ambient-modules&quot;&gt;アンビエントモジュール宣言&lt;/a&gt;を見つけようとします。次に、非相対インポートについて説明します。</target>
        </trans-unit>
        <trans-unit id="5fc6ba7853747447fab7e2b09e476e794d7eaf75" translate="yes" xml:space="preserve">
          <source>If that sounds too lax for you, you can tighten that behavior up. If, for instance, you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; want TypeScript to compile to JavaScript in the face of errors, you can use the &lt;code&gt;noEmitOnError&lt;/code&gt; option. In that sense, TypeScript has a dial on its strictness, and you can turn that knob up as high as you want.</source>
          <target state="translated">それがあまりにも緩く聞こえる場合は、その動作を引き締めることができます。たとえば、エラーが発生した場合にTypeScriptをJavaScriptにコンパイルしたく&lt;em&gt;ない&lt;/em&gt;場合は、 &lt;code&gt;noEmitOnError&lt;/code&gt; オプションを使用できます。その意味で、TypeScriptの厳密さにはダイヤルがあり、ノブを必要なだけ高く上げることができます。</target>
        </trans-unit>
        <trans-unit id="80562a30b2229fad8a6df690b031de0355afd589" translate="yes" xml:space="preserve">
          <source>If that&amp;rsquo;s the case, the files that you&amp;rsquo;ve written are going to be used as inputs to TypeScript, and you&amp;rsquo;ll run the outputs it produces. During our JS to TS migration, we&amp;rsquo;ll need to separate our input files to prevent TypeScript from overwriting them. If your output files need to reside in a specific directory, then that will be your output directory.</source>
          <target state="translated">その場合、作成したファイルはTypeScriptへの入力として使用され、生成された出力を実行します。JSからTSへの移行中、TypeScriptによる上書きを防ぐために、入力ファイルを分離する必要があります。出力ファイルを特定のディレクトリに置く必要がある場合は、それが出力ディレクトリになります。</target>
        </trans-unit>
        <trans-unit id="2fcbcd9f558fa8a3faacb1b7e2f2cc6f3c7dd80a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; and &lt;code&gt;&quot;include&quot;&lt;/code&gt; are both left unspecified, the compiler defaults to including all TypeScript (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt;) files in the containing directory and subdirectories except those excluded using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. JS files (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt;) are also included if &lt;code&gt;allowJs&lt;/code&gt; is set to true.</source>
          <target state="translated">もし &lt;code&gt;&quot;files&quot;&lt;/code&gt; と &lt;code&gt;&quot;include&quot;&lt;/code&gt; の両方のすべての活字体（含むとコンパイラのデフォルトは、未指定のままにしている &lt;code&gt;.ts&lt;/code&gt; 、 &lt;code&gt;.d.ts&lt;/code&gt; と &lt;code&gt;.tsx&lt;/code&gt; 使用して除外されたものを除く含むディレクトリおよびサブディレクトリ内）のファイルを &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; プロパティを。 JSファイル（ &lt;code&gt;.js&lt;/code&gt; および &lt;code&gt;.jsx&lt;/code&gt; ）も、 &lt;code&gt;allowJs&lt;/code&gt; がtrueに設定されている場合に含まれます。</target>
        </trans-unit>
        <trans-unit id="477c8cbe4706878c16fb156bd723ab8f217099e9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; and &lt;code&gt;&quot;include&quot;&lt;/code&gt; are both left unspecified, the compiler defaults to including all TypeScript (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt;) files in the containing directory and subdirectories except those excluded using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. JS files (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt;) are also included if &lt;code&gt;allowJs&lt;/code&gt; is set to true. If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; compiler option are excluded as long as &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property is not specified.</source>
          <target state="translated">もし &lt;code&gt;&quot;files&quot;&lt;/code&gt; と &lt;code&gt;&quot;include&quot;&lt;/code&gt; の両方のすべての活字体（含むとコンパイラのデフォルトは、未指定のままにしている &lt;code&gt;.ts&lt;/code&gt; 、 &lt;code&gt;.d.ts&lt;/code&gt; と &lt;code&gt;.tsx&lt;/code&gt; 使用して除外されたものを除く含むディレクトリおよびサブディレクトリ内）のファイルを &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; プロパティを。 JSファイル（ &lt;code&gt;.js&lt;/code&gt; および &lt;code&gt;.jsx&lt;/code&gt; ）も、 &lt;code&gt;allowJs&lt;/code&gt; がtrueに設定されている場合に含まれます。場合は &lt;code&gt;&quot;files&quot;&lt;/code&gt; または &lt;code&gt;&quot;include&quot;&lt;/code&gt; プロパティが指定されている、コンパイラは代わりに、これらの二つの特性によって含まれるファイルの結合が含まれます。 &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; を使用して指定されたディレクトリ内のファイル &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; プロパティが指定されていない限り、コンパイラオプションは除外されます。</target>
        </trans-unit>
        <trans-unit id="d6b124b086b760cf9eb1864e544665757f5217f3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; compiler option are always excluded unless explicitly included via the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property (even when the &amp;ldquo;&lt;code&gt;exclude&lt;/code&gt;&amp;rdquo; property is specified).</source>
          <target state="translated">場合は &lt;code&gt;&quot;files&quot;&lt;/code&gt; または &lt;code&gt;&quot;include&quot;&lt;/code&gt; プロパティが指定されている、コンパイラは代わりに、これらの二つの特性によって含まれるファイルの結合が含まれます。 &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; コンパイラー・オプションを使用して指定されたディレクトリー内のファイルは、 &lt;code&gt;&quot;files&quot;&lt;/code&gt; プロパティーを介して明示的に含まれていない限り（「 &lt;code&gt;exclude&lt;/code&gt; 」プロパティーが指定されている場合でも）、常に除外されます。</target>
        </trans-unit>
        <trans-unit id="d9d1e0016c3b073e477b87823fb48c212a972f04" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;importHelpers&lt;/code&gt; flag is on, these helper functions are instead imported from the &lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt;tslib&lt;/a&gt; module. You will need to ensure that the &lt;code&gt;tslib&lt;/code&gt; module is able to be imported at runtime. This only affects modules; global script files will not attempt to import modules.</source>
          <target state="translated">&lt;code&gt;importHelpers&lt;/code&gt; フラグがオンの場合、これらのヘルパー関数は代わりに&lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt;tslib&lt;/a&gt;モジュールからインポートされます。 &lt;code&gt;tslib&lt;/code&gt; モジュールが実行時にインポートできることを確認する必要があります。これはモジュールにのみ影響します。グローバルスクリプトファイルはモジュールのインポートを試みません。</target>
        </trans-unit>
        <trans-unit id="9fce1a983a1219926f1f38bab0bfb60ec3fd4b5c" translate="yes" xml:space="preserve">
          <source>If the accessor decorator returns a value, it will be used as the &lt;em&gt;Property Descriptor&lt;/em&gt; for the member.</source>
          <target state="translated">アクセサーデコレーターが値を返す場合、その値はメンバーの&lt;em&gt;プロパティ記述子&lt;/em&gt;として使用されます。</target>
        </trans-unit>
        <trans-unit id="757bf2cd851a721420b759b576fc525ad4b2e255" translate="yes" xml:space="preserve">
          <source>If the class decorator returns a value, it will replace the class declaration with the provided constructor function.</source>
          <target state="translated">クラスデコレータが値を返す場合は、クラス宣言を提供されたコンストラクタ関数に置き換えます。</target>
        </trans-unit>
        <trans-unit id="dcdc136ee9d606ac3aebb0a12ffa90330d056cbb" translate="yes" xml:space="preserve">
          <source>If the compiler flag &lt;code&gt;--noResolve&lt;/code&gt; is specified, triple-slash references are ignored; they neither result in adding new files, nor change the order of the files provided.</source>
          <target state="translated">コンパイラフラグ &lt;code&gt;--noResolve&lt;/code&gt; が指定されている場合、トリプルスラッシュ参照は無視されます。新しいファイルを追加することも、提供されるファイルの順序を変更することもありません。</target>
        </trans-unit>
        <trans-unit id="6404fc019a0ea10b80a74ad6d4f189ca7a5e6cf0" translate="yes" xml:space="preserve">
          <source>If the factory is defined as &lt;code&gt;React.createElement&lt;/code&gt; (the default), the compiler will check for &lt;code&gt;React.JSX&lt;/code&gt; before checking for a global &lt;code&gt;JSX&lt;/code&gt;. If the factory is defined as &lt;code&gt;h&lt;/code&gt;, it will check for &lt;code&gt;h.JSX&lt;/code&gt; before a global &lt;code&gt;JSX&lt;/code&gt;.</source>
          <target state="translated">ファクトリが &lt;code&gt;React.createElement&lt;/code&gt; （デフォルト）として定義されている場合、コンパイラはグローバル &lt;code&gt;JSX&lt;/code&gt; をチェックする前に &lt;code&gt;React.JSX&lt;/code&gt; をチェックします。ファクトリが &lt;code&gt;h&lt;/code&gt; として定義されている場合、グローバル &lt;code&gt;JSX&lt;/code&gt; の前に &lt;code&gt;h.JSX&lt;/code&gt; をチェックします。</target>
        </trans-unit>
        <trans-unit id="64760e36eb2b3cf9f6dce25e269af13108cbb2ff" translate="yes" xml:space="preserve">
          <source>If the method decorator returns a value, it will be used as the &lt;em&gt;Property Descriptor&lt;/em&gt; for the method.</source>
          <target state="translated">メソッドデコレータが値を返す場合、その値はメソッドの&lt;em&gt;プロパティ記述子&lt;/em&gt;として使用されます。</target>
        </trans-unit>
        <trans-unit id="5e2ec078a41809b3ea00769455fcd98c66227dc0" translate="yes" xml:space="preserve">
          <source>If the object or class has all the required properties, TypeScript will say they match, regardless of the implementation details.</source>
          <target state="translated">オブジェクトやクラスが必要なプロパティをすべて持っている場合、実装の詳細にかかわらず、TypeScript はそれらが一致していると言います。</target>
        </trans-unit>
        <trans-unit id="c5f107d97fba869cf2daf87a931e54a8895ed1bc" translate="yes" xml:space="preserve">
          <source>If the operand of a &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt;, or &lt;code&gt;--&lt;/code&gt; unary operator is nullable.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;~&lt;/code&gt; 、 &lt;code&gt;++&lt;/code&gt; 、または &lt;code&gt;--&lt;/code&gt; 単項演算子のオペランドがNULL可能である場合。</target>
        </trans-unit>
        <trans-unit id="a35de86d636b3f4498ca4f03ae3386c7c6c3cc94" translate="yes" xml:space="preserve">
          <source>If the referenced project produces an &lt;code&gt;outFile&lt;/code&gt;, the output file &lt;code&gt;.d.ts&lt;/code&gt; file&amp;rsquo;s declarations will be visible in this project</source>
          <target state="translated">参照プロジェクトが &lt;code&gt;outFile&lt;/code&gt; を生成する場合、出力ファイル &lt;code&gt;.d.ts&lt;/code&gt; ファイルの宣言はこのプロジェクトで表示されます</target>
        </trans-unit>
        <trans-unit id="dd06f92d40ce76202d5611a64daad24f2a1feac2" translate="yes" xml:space="preserve">
          <source>If the right operand of an &lt;code&gt;instanceof&lt;/code&gt; operator is nullable.</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; 演算子の右側のオペランドがNULL可能である場合。</target>
        </trans-unit>
        <trans-unit id="bb788c0916122fd9a75b33b92aa45518eb1b4e5a" translate="yes" xml:space="preserve">
          <source>If this function were not in a contextually typed position, the function&amp;rsquo;s argument would implicitly have type &lt;code&gt;any&lt;/code&gt;, and no error would be issued (unless you are using the &lt;code&gt;--noImplicitAny&lt;/code&gt; option):</source>
          <target state="translated">この関数がコンテキストで型付けされた位置にない場合、関数の引数は暗黙的に &lt;code&gt;any&lt;/code&gt; 型になり、エラーは発行されません（ &lt;code&gt;--noImplicitAny&lt;/code&gt; オプションを使用している場合を除く）。</target>
        </trans-unit>
        <trans-unit id="d3ba6383ac88848a0ef4f846d3fe4de2bef1cab6" translate="yes" xml:space="preserve">
          <source>If we have a value that has a union type, we can only access members that are common to all types in the union.</source>
          <target state="translated">ユニオン型を持つ値を持っている場合、ユニオン内のすべての型に共通するメンバにしかアクセスできません。</target>
        </trans-unit>
        <trans-unit id="935377e4091dae4bb943432ee7eeb7b9ff3cef2c" translate="yes" xml:space="preserve">
          <source>If we have a value that is a union type, we can only access members that are common to all types in the union.</source>
          <target state="translated">ユニオン型である値を持っている場合、ユニオン内のすべての型に共通するメンバにしかアクセスできません。</target>
        </trans-unit>
        <trans-unit id="a1d377830062aff369f8dab5df851e9080561624" translate="yes" xml:space="preserve">
          <source>If we want to customize how a decorator is applied to a declaration, we can write a decorator factory. A &lt;em&gt;Decorator Factory&lt;/em&gt; is simply a function that returns the expression that will be called by the decorator at runtime.</source>
          <target state="translated">デコレータを宣言に適用する方法をカスタマイズする場合は、デコレータファクトリを作成できます。A &lt;em&gt;デコレータ工場は&lt;/em&gt;、単純に、実行時にデコレータによって呼び出される表現を返す関数です。</target>
        </trans-unit>
        <trans-unit id="d0a73f363bdb39ad6e23dfd5f55548093ac466d2" translate="yes" xml:space="preserve">
          <source>If we wanted, we could leave off the initializers entirely:</source>
          <target state="translated">その気になれば、イニシャライザを完全に削除することができます。</target>
        </trans-unit>
        <trans-unit id="83df15e4cf413e10be414506c047c7618a0d3d89" translate="yes" xml:space="preserve">
          <source>If we were to use &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factories&lt;/a&gt;, we can observe this evaluation order with the following example:</source>
          <target state="translated">&lt;a href=&quot;#decorator-factories&quot;&gt;デコレータファクトリ&lt;/a&gt;を使用する場合、次の例でこの評価順序を確認できます。</target>
        </trans-unit>
        <trans-unit id="89a7882773e333f0676bc25954729647144846fe" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;tsconfig.json&lt;/code&gt; file, TypeScript files that are not considered part of that context are not compiled.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを追加すると、そのコンテキストの一部とは見なされないTypeScriptファイルはコンパイルされません。</target>
        </trans-unit>
        <trans-unit id="776111b439c21b6cb775099faee4d16246e9ab8d" translate="yes" xml:space="preserve">
          <source>If you are coming to TypeScript without a JavaScript background, with the intention of TypeScript being your first language, we recommend you first start reading the documentation &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Guide&quot;&gt;on JavaScript at the Mozilla Web Docs&lt;/a&gt;. If you have experience in other languages, you should be able to pick up JavaScript syntax quite quickly by reading the handbook.</source>
          <target state="translated">TypeScriptを最初の言語にすることを目的として、JavaScriptのバックグラウンドなしでTypeScriptを使用する場合は、最初&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Guide&quot;&gt;にMozilla WebDocsでJavaScript&lt;/a&gt;に関するドキュメントを読み始めることをお勧めします。他の言語の経験がある場合は、ハンドブックを読むことでJavaScript構文をすぐに理解できるはずです。</target>
        </trans-unit>
        <trans-unit id="085d3fb970c36076b70083b38db4b956effc131e" translate="yes" xml:space="preserve">
          <source>If you are planning on submitting these changes to DefinitelyTyped for everyone to also use, then we recommend you:</source>
          <target state="translated">もしあなたがこれらの変更点をDefinitelyTypedに投稿して、みんなにも使ってもらうことを計画しているのであれば、あなたが投稿することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="4c6633882fd2cbc849cc78df7098cdbc11e0f7c9" translate="yes" xml:space="preserve">
          <source>If you are using a different build tool to build your project (e.g. gulp, grunt , etc.) and VS for the development and debugging experience, set &lt;code&gt;&amp;lt;TypeScriptCompileBlocked&amp;gt;true&amp;lt;/TypeScriptCompileBlocked&amp;gt;&lt;/code&gt; in your project. This should give you all the editing support, but not the build when you hit F5.</source>
          <target state="translated">別のビルドツールを使用してプロジェクト（gulp、gruntなど）とVSを開発およびデバッグする &lt;code&gt;&amp;lt;TypeScriptCompileBlocked&amp;gt;true&amp;lt;/TypeScriptCompileBlocked&amp;gt;&lt;/code&gt; は、プロジェクトで&amp;lt;TypeScriptCompileBlocked&amp;gt; true &amp;lt;/ TypeScriptCompileBlocked&amp;gt;を設定します。これにより、すべての編集サポートが提供されますが、F5を押したときのビルドは提供されません。</target>
        </trans-unit>
        <trans-unit id="5cd9012eef954c07679b23981cd46180ffa74948" translate="yes" xml:space="preserve">
          <source>If you check in any build outputs (&lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt;, &lt;code&gt;.d.ts.map&lt;/code&gt;, etc.), you may need to run a &lt;code&gt;--force&lt;/code&gt; build after certain source control operations depending on whether your source control tool preserves timestamps between the local copy and the remote copy.</source>
          <target state="translated">ビルド出力（ &lt;code&gt;.js&lt;/code&gt; 、 &lt;code&gt;.d.ts&lt;/code&gt; 、 &lt;code&gt;.d.ts.map&lt;/code&gt; など）をチェックインする場合、ソース管理ツールが保持するかどうかに応じて、特定のソース管理操作の後に &lt;code&gt;--force&lt;/code&gt; ビルドを実行する必要がある場合があります。ローカルコピーとリモートコピー間のタイムスタンプ。</target>
        </trans-unit>
        <trans-unit id="6a349b11b7d0ef239663304628dfd9c61e8381c6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to take the time to write out declarations before using a new module, you can now just use a shorthand declaration to get started quickly.</source>
          <target state="translated">新しいモジュールを使用する前に、時間をかけて宣言を書きたくない場合は、簡単な宣言を使用してすばやく開始できます。</target>
        </trans-unit>
        <trans-unit id="fae05d77b88c64d5e95a8ef1a5541f4907ad6f4f" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to take the time to write out declarations before using a new module, you can use a shorthand declaration to get started quickly.</source>
          <target state="translated">新しいモジュールを使用する前に宣言を書き出すのに時間をかけたくない場合は、簡単な宣言を使用してすばやく開始できます。</target>
        </trans-unit>
        <trans-unit id="b6d64531eb1511551180721cfd80f278a3113a79" translate="yes" xml:space="preserve">
          <source>If you ever have a value that TypeScript thinks is possibly &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt;, but you know better, you can use the postfix &lt;code&gt;!&lt;/code&gt; operator to tell it otherwise.</source>
          <target state="translated">TypeScriptが &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; 可能性があると考える値がある場合でも、よく知っている場合は、接尾辞を使用できます &lt;code&gt;!&lt;/code&gt; それ以外の場合はそれを伝える演算子。</target>
        </trans-unit>
        <trans-unit id="23d58bbe6abf7e68dae13856af53d691d0dfa849" translate="yes" xml:space="preserve">
          <source>If you find yourself searching for something like &amp;ldquo;how to sort a list in TypeScript&amp;rdquo;, remember: &lt;strong&gt;TypeScript is JavaScript&amp;rsquo;s runtime with a compile-time type checker&lt;/strong&gt;. The way you sort a list in TypeScript is the same way you do so in JavaScript. If you find a resource that uses TypeScript directly, that&amp;rsquo;s great too, but don&amp;rsquo;t limit yourself to thinking you need TypeScript-specific answers for everyday questions about how to accomplish runtime tasks.</source>
          <target state="translated">「TypeScriptでリストをソートする方法」のようなものを探していることに&lt;strong&gt;気付いた場合は&lt;/strong&gt;、覚えておいてください&lt;strong&gt;。TypeScriptは、コンパイル時の型チェッカーを備えたJavaScriptのランタイム&lt;/strong&gt;です。TypeScriptでリストを並べ替える方法は、JavaScriptで並べ替える方法と同じです。TypeScriptを直接使用するリソースを見つけた場合、それも素晴らしいことですが、ランタイムタスクを実行する方法に関する日常の質問に対してTypeScript固有の回答が必要だと思うことに限定しないでください。</target>
        </trans-unit>
        <trans-unit id="33efe22b92b7f2005e7eb656f1a76dbf3fcbc9bb" translate="yes" xml:space="preserve">
          <source>If you get tired of imports always looking like &lt;code&gt;&quot;../&quot;&lt;/code&gt; or &lt;code&gt;&quot;./&quot;&lt;/code&gt;. Or needing to change as you move files, this is a great way to fix that.</source>
          <target state="translated">インポートに飽きたら、常に &lt;code&gt;&quot;../&quot;&lt;/code&gt; または &lt;code&gt;&quot;./&quot;&lt;/code&gt; ます。または、ファイルを移動するときに変更する必要がある場合、これはそれを修正するための優れた方法です。</target>
        </trans-unit>
        <trans-unit id="3c329b002b75ec8975f18054725c2bf4040952e7" translate="yes" xml:space="preserve">
          <source>If you had the following Node/CommonJS code:</source>
          <target state="translated">以下のNode/CommonJSのコードを持っていたとします。</target>
        </trans-unit>
        <trans-unit id="dc04d34dfcaac9afb16dfcca2506c06bccfa00d4" translate="yes" xml:space="preserve">
          <source>If you have a &lt;code&gt;tests&lt;/code&gt; folder outside of your &lt;code&gt;src&lt;/code&gt; directory, you might have one &lt;code&gt;tsconfig.json&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt;, and one in &lt;code&gt;tests&lt;/code&gt; as well.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; ディレクトリの外側に &lt;code&gt;tests&lt;/code&gt; フォルダーがある場合、 &lt;code&gt;src&lt;/code&gt; に1つの &lt;code&gt;tsconfig.json&lt;/code&gt; があり、 &lt;code&gt;tests&lt;/code&gt; にも1つある可能性があります。</target>
        </trans-unit>
        <trans-unit id="37eded98e17f199e9a0f317e547c4692b3b985a7" translate="yes" xml:space="preserve">
          <source>If you have a lot of JavaScript files you want to add errors to then you can switch to using a &lt;a href=&quot;tsconfig-json&quot;&gt;&lt;code&gt;jsconfig.json&lt;/code&gt;&lt;/a&gt;. You can skip checking some files by adding a &lt;code&gt;// @ts-nocheck&lt;/code&gt; comment to files.</source>
          <target state="translated">エラーを追加したいJavaScriptファイルがたくさんある場合は、&lt;a href=&quot;tsconfig-json&quot;&gt; &lt;code&gt;jsconfig.json&lt;/code&gt; の&lt;/a&gt;使用に切り替えることができます。 &lt;code&gt;// @ts-nocheck&lt;/code&gt; コメントをファイルに追加することで、一部のファイルのチェックをスキップできます。</target>
        </trans-unit>
        <trans-unit id="5daacb30eeb58b2f2dd8eeb43af27c13d0f6e359" translate="yes" xml:space="preserve">
          <source>If you have a module which when imported, makes changes to other modules use template &lt;a href=&quot;templates/module-plugin-d-ts&quot;&gt;&lt;code&gt;module-plugin.d.ts&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">インポート時に他のモジュールに変更を加えるモジュールがある場合は、テンプレート&lt;a href=&quot;templates/module-plugin-d-ts&quot;&gt; &lt;code&gt;module-plugin.d.ts&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="e25661d3416deb409f63475049ffc70db498f494" translate="yes" xml:space="preserve">
          <source>If you have a specific module which should be included (but isn&amp;rsquo;t in &lt;code&gt;node_modules&lt;/code&gt;):</source>
          <target state="translated">含める必要のある特定のモジュールがある場合（ただし、 &lt;code&gt;node_modules&lt;/code&gt; には含まれていません）：</target>
        </trans-unit>
        <trans-unit id="1c080c78e7a69573dae8c2024c9d66a13c40bf94" translate="yes" xml:space="preserve">
          <source>If you have a type with a number index signature, &lt;code&gt;keyof T&lt;/code&gt; will just be &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">番号インデックスシグネチャを持つ型がある場合、 &lt;code&gt;keyof T&lt;/code&gt; は単に &lt;code&gt;number&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="036ed4bc42cb6365f2fcac60d2ef2dafe759c7d5" translate="yes" xml:space="preserve">
          <source>If you have a variable with an unknown type, you can narrow it to something more specific by doing &lt;code&gt;typeof&lt;/code&gt; checks, comparison checks, or more advanced type guards that will be discussed in a later chapter:</source>
          <target state="translated">タイプが不明な変数がある場合は、 &lt;code&gt;typeof&lt;/code&gt; チェック、比較チェック、または後の章で説明するより高度なタイプガードを実行することで、より具体的な変数に絞り込むことができます。</target>
        </trans-unit>
        <trans-unit id="bad1becd57096ef1e33ba9bd0ebbac35bc9622bd" translate="yes" xml:space="preserve">
          <source>If you have an msbuild project, you can enable build mode by adding</source>
          <target state="translated">msbuild プロジェクトがある場合、ビルドモードを有効にするには</target>
        </trans-unit>
        <trans-unit id="29f75b30082c5ae8c9dd501dc68ec9c17ab2e182" translate="yes" xml:space="preserve">
          <source>If you have been asked by a TypeScript compiler engineer to give the results using this flag in a compile, in which there is no harm in using &lt;a href=&quot;#extendedDiagnostics&quot;&gt;&lt;code&gt;--extendedDiagnostics&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">TypeScriptコンパイラエンジニアから、コンパイルでこのフラグを使用して結果を提供するように求められた場合。代わりに&lt;a href=&quot;#extendedDiagnostics&quot;&gt; &lt;code&gt;--extendedDiagnostics&lt;/code&gt; &lt;/a&gt;を使用しても害はありません。</target>
        </trans-unit>
        <trans-unit id="9958ebfa05a47b2e603ba5d2a6dfd282d81623dc" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t already, you should read the &lt;a href=&quot;../basic-types&quot;&gt;TypeScript Handbook&lt;/a&gt; to familiarize yourself with basic concepts, especially types and modules.</source>
          <target state="translated">まだ読んでいない場合は、&lt;a href=&quot;../basic-types&quot;&gt;TypeScriptハンドブック&lt;/a&gt;を読んで、基本的な概念、特にタイプとモジュールについて理解しておく必要があります。</target>
        </trans-unit>
        <trans-unit id="88dba7da91434766a3c79f38e44d7fef30aa351c" translate="yes" xml:space="preserve">
          <source>If you intended to test the function without calling it, you can correct the definition of it to include &lt;code&gt;undefined&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt;, or use &lt;code&gt;!!&lt;/code&gt; to write something like &lt;code&gt;if (!!user.isAdministrator)&lt;/code&gt; to indicate that the coercion is intentional.</source>
          <target state="translated">関数を呼び出さずにテストする場合は、その定義を修正して &lt;code&gt;undefined&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; を含めるか、または &lt;code&gt;!!&lt;/code&gt; &lt;code&gt;if (!!user.isAdministrator)&lt;/code&gt; ように記述して、強制が意図的なものであることを示します。</target>
        </trans-unit>
        <trans-unit id="5a96d27a06b8980e6a4f2196b4ba66f129bc78de" translate="yes" xml:space="preserve">
          <source>If you move some code from a JavaScript file to a TypeScript file, you might see &lt;em&gt;type errors&lt;/em&gt; depending on how the code is written. These may be legitimate problems with the code, or TypeScript being overly conservative. Throughout this guide we&amp;rsquo;ll demonstrate how to add various TypeScript syntax to eliminate such errors.</source>
          <target state="translated">一部のコードをJavaScriptファイルからTypeScriptファイルに移動すると、コードの記述方法によっては&lt;em&gt;タイプエラーが発生&lt;/em&gt;する場合があります。これらは、コードに関する正当な問題であるか、TypeScriptが過度に保守的である可能性があります。このガイド全体を通して、このようなエラーを排除するためにさまざまなTypeScript構文を追加する方法を示します。</target>
        </trans-unit>
        <trans-unit id="ba807eb4e0eaeb772cb84988d65f758637aa63a7" translate="yes" xml:space="preserve">
          <source>If you need to learn the good parts of JavaScript, read &lt;a href=&quot;http://shop.oreilly.com/product/9780596517748.do&quot;&gt;JavaScript: The Good Parts&lt;/a&gt;. You may be able to skip the book if you know how to write programs in a call-by-value lexically scoped language with lots of mutability and not much else. &lt;a href=&quot;https://people.csail.mit.edu/jaffer/r4rs.pdf&quot;&gt;R&lt;sup&gt;4&lt;/sup&gt;RS Scheme&lt;/a&gt; is a good example.</source>
          <target state="translated">JavaScriptの優れた部分を学ぶ必要がある場合は、&lt;a href=&quot;http://shop.oreilly.com/product/9780596517748.do&quot;&gt;JavaScript：The&lt;/a&gt; GoodPartsをお読みください。可変性が多く、他にはあまりない、値による呼び出しの字句スコープの言語でプログラムを作成する方法を知っている場合は、この本をスキップできる可能性があります。&lt;a href=&quot;https://people.csail.mit.edu/jaffer/r4rs.pdf&quot;&gt;R &lt;sup&gt;4つの&lt;/sup&gt;RSスキームは&lt;/a&gt;良い例です。</target>
        </trans-unit>
        <trans-unit id="ed97452c7f7269f74ea84e8195f99486afcc62bd" translate="yes" xml:space="preserve">
          <source>If you plan on using the stricter settings that are available, it&amp;rsquo;s best to turn them on now (see &lt;a href=&quot;#getting-stricter-checks&quot;&gt;Getting Stricter Checks&lt;/a&gt; below). For instance, if you never want TypeScript to silently infer &lt;code&gt;any&lt;/code&gt; for a type without you explicitly saying so, you can use &lt;code&gt;noImplicitAny&lt;/code&gt; before you start modifying your files. While it might feel somewhat overwhelming, the long-term gains become apparent much more quickly.</source>
          <target state="translated">利用可能なより厳しい設定を使用する予定の場合は、今すぐ有効にすることをお&lt;a href=&quot;#getting-stricter-checks&quot;&gt;勧め&lt;/a&gt;します（以下の「厳密なチェックの取得」を参照）。たとえば、明示的にそう言わない限り、TypeScriptが型の &lt;code&gt;any&lt;/code&gt; を暗黙的に推測しないようにする場合は、ファイルの変更を開始する前に &lt;code&gt;noImplicitAny&lt;/code&gt; を使用できます。それはやや圧倒的に感じるかもしれませんが、長期的な利益ははるかに迅速に明らかになります。</target>
        </trans-unit>
        <trans-unit id="5184246af95057dfb4d9aaab56132b936756e920" translate="yes" xml:space="preserve">
          <source>If you provide an object that doesn&amp;rsquo;t match the interface you have provided, TypeScript will warn you:</source>
          <target state="translated">指定したインターフェースと一致しないオブジェクトを指定すると、TypeScriptは次のように警告します。</target>
        </trans-unit>
        <trans-unit id="d704dd727aa16026d03295d60e4fd6bd0f450b47" translate="yes" xml:space="preserve">
          <source>If you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have. In our &lt;code&gt;loggingIdentity&lt;/code&gt; example, we wanted to be able to access the &lt;code&gt;.length&lt;/code&gt; property of &lt;code&gt;arg&lt;/code&gt;, but the compiler could not prove that every type had a &lt;code&gt;.length&lt;/code&gt; property, so it warns us that we can&amp;rsquo;t make this assumption.</source>
          <target state="translated">以前の例を覚えている場合は、型のセットが持つ機能についてある程度の知識がある場合、型のセットで機能するジェネリック関数を作成したい場合があります。私たちの &lt;code&gt;loggingIdentity&lt;/code&gt; の例では、 &lt;code&gt;arg&lt;/code&gt; の &lt;code&gt;.length&lt;/code&gt; プロパティにアクセスできるようにしたかったのですが、コンパイラはすべての型が &lt;code&gt;.length&lt;/code&gt; プロパティを持つことを証明できなかったため、この仮定を行うことができないことを警告しています。</target>
        </trans-unit>
        <trans-unit id="f2f60b10d440544ea9c56ee6406205dc250ac35c" translate="yes" xml:space="preserve">
          <source>If you see tests for &lt;code&gt;typeof define&lt;/code&gt;, &lt;code&gt;typeof window&lt;/code&gt;, or &lt;code&gt;typeof module&lt;/code&gt; in the code of a library, especially at the top of the file, it&amp;rsquo;s almost always a UMD library.</source>
          <target state="translated">ライブラリのコードの &lt;code&gt;typeof define&lt;/code&gt; 、 &lt;code&gt;typeof window&lt;/code&gt; 、または &lt;code&gt;typeof module&lt;/code&gt; のテストが特にファイルの先頭にある場合、それはほとんど常にUMDライブラリです。</target>
        </trans-unit>
        <trans-unit id="c25089b3bb720ad8bf4d7033bc03403e6d851984" translate="yes" xml:space="preserve">
          <source>If you started converting over to TypeScript imports, you&amp;rsquo;ll probably run into errors like &lt;code&gt;Cannot find module 'foo'.&lt;/code&gt;. The issue here is that you likely don&amp;rsquo;t have &lt;em&gt;declaration files&lt;/em&gt; to describe your library. Luckily this is pretty easy. If TypeScript complains about a package like &lt;code&gt;lodash&lt;/code&gt;, you can just write</source>
          <target state="translated">TypeScriptインポートへの変換を開始した場合は、 &lt;code&gt;Cannot find module 'foo'.&lt;/code&gt; などのエラーが発生する可能性があります。。ここでの問題は、ライブラリを説明する&lt;em&gt;宣言ファイル&lt;/em&gt;がない可能性が高いことです。幸い、これはかなり簡単です。TypeScriptが &lt;code&gt;lodash&lt;/code&gt; のようなパッケージについて不平を言ったら、次のように書くことができます</target>
        </trans-unit>
        <trans-unit id="b4fea75c265155bd6df0203787b647e915b7efa9" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;y&lt;/code&gt; in a way that the type parameter&amp;rsquo;s constraint doesn&amp;rsquo;t support, you&amp;rsquo;ll correctly get an error. In this case, the constraint of &lt;code&gt;T&lt;/code&gt; was (implicitly) &lt;code&gt;{}&lt;/code&gt;, so the last example will appropriately fail.</source>
          <target state="translated">タイプパラメータの制約がサポートしていない方法で &lt;code&gt;y&lt;/code&gt; を使用すると、正しくエラーが発生します。この場合、 &lt;code&gt;T&lt;/code&gt; の制約は（暗黙的に） &lt;code&gt;{}&lt;/code&gt; だったので、最後の例は適切に失敗します。</target>
        </trans-unit>
        <trans-unit id="5e5165e11849a0b5581c2dad31e4b0f7f73cb5bb" translate="yes" xml:space="preserve">
          <source>If you would like to disable or customize this feature, create a &lt;code&gt;jsconfig.json&lt;/code&gt; in the root of your project:</source>
          <target state="translated">この機能を無効化またはカスタマイズする場合は、プロジェクトのルートに &lt;code&gt;jsconfig.json&lt;/code&gt; を作成します。</target>
        </trans-unit>
        <trans-unit id="87cb46c60d30559d817b085b18b7cb967b9fe7cd" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to write tests for your .d.ts files, try &lt;a href=&quot;https://github.com/SamVerschueren/tsd&quot;&gt;tsd&lt;/a&gt;.</source>
          <target state="translated">.d.tsファイルのテストを作成する場合は、&lt;a href=&quot;https://github.com/SamVerschueren/tsd&quot;&gt;tsdを&lt;/a&gt;試してください。</target>
        </trans-unit>
        <trans-unit id="e6bd2cecc096e05874940061ada8a05394b1dbd5" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d prefer to be explicit, you can also enforce the type of values that can be returned, yielded, and evaluated from &lt;code&gt;yield&lt;/code&gt; expressions using an explicit return type. Below, &lt;code&gt;next()&lt;/code&gt; can only be called with &lt;code&gt;boolean&lt;/code&gt;s, and depending on the value of &lt;code&gt;done&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is either a &lt;code&gt;string&lt;/code&gt; or a &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">明示的にしたい場合は、明示的な戻り値の型を使用して、 &lt;code&gt;yield&lt;/code&gt; 式から返され、生成され、評価できる値の型を強制することもできます。以下、 &lt;code&gt;next()&lt;/code&gt; だけで呼び出すことができる &lt;code&gt;boolean&lt;/code&gt; S、及びの値に応じて &lt;code&gt;done&lt;/code&gt; 、 &lt;code&gt;value&lt;/code&gt; のいずれかである &lt;code&gt;string&lt;/code&gt; または &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="342b7134b6ae686fafbfd59ad7d6e4b1867ceab4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a Java or C# programmer that is new to JavaScript in general, we recommend learning a little bit of JavaScript &lt;em&gt;without&lt;/em&gt; types first to understand JavaScript&amp;rsquo;s runtime behaviors. Because TypeScript doesn&amp;rsquo;t change how your code &lt;em&gt;runs&lt;/em&gt;, you&amp;rsquo;ll still have to learn how JavaScript works in order to write code that actually does something!</source>
          <target state="translated">一般にJavaScript&lt;em&gt;を&lt;/em&gt;初めて使用するJavaまたはC＃プログラマーの場合は、JavaScriptの実行時の動作を理解するために、最初に型&lt;em&gt;なし&lt;/em&gt;でJavaScript&lt;em&gt;を&lt;/em&gt;少し学ぶことをお勧めします。TypeScriptはコードの&lt;em&gt;実行&lt;/em&gt;方法を変更しないため、実際に何かを実行するコードを作成するには、JavaScriptがどのように機能するかを学ぶ必要があります。</target>
        </trans-unit>
        <trans-unit id="25c9ec1976e4df8a2ef8c0b469042e5f520617b9" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re converting a program from namespaces to modules, it can be easy to end up with a file that looks like this:</source>
          <target state="translated">プログラムを名前空間からモジュールに変換する場合、次のようなファイルが作成されるのは簡単です。</target>
        </trans-unit>
        <trans-unit id="513d665d33a30074384ac54ddb0be0edac2c6bbf" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re exporting multiple objects, put them all at top-level</source>
          <target state="translated">複数のオブジェクトをエクスポートする場合は、すべてを最上位に配置します</target>
        </trans-unit>
        <trans-unit id="d824a46b68a6c563ea08418e176071b76786c629" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re familiar with JavaScript already but are primarily a Java or C# programmer, this introductory page can help explain some of the common misconceptions and pitfalls you might be susceptible to. Some of the ways that TypeScript models types are quite different from Java or C#, and it&amp;rsquo;s important to keep these in mind when learning TypeScript.</source>
          <target state="translated">すでにJavaScriptに精通しているが、主にJavaまたはC＃プログラマーである場合、この紹介ページは、起こりやすい一般的な誤解や落とし穴のいくつかを説明するのに役立ちます。TypeScriptが型をモデル化する方法のいくつかはJavaやC＃とはかなり異なり、TypeScriptを学習するときはこれらを覚えておくことが重要です。</target>
        </trans-unit>
        <trans-unit id="e6a9291b44ab09ee343d0c813d7995f1938982dd" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re looking to convert a React project, we recommend looking at the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide&quot;&gt;React Conversion Guide&lt;/a&gt; first.</source>
          <target state="translated">Reactプロジェクトを変換する場合は、最初に&lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide&quot;&gt;React変換ガイドを参照&lt;/a&gt;することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6b3d86758d6ba06b2c6d545d9e0ad1ace8a4b070" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re only exporting a single &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;function&lt;/code&gt;, use &lt;code&gt;export default&lt;/code&gt;</source>
          <target state="translated">単一の &lt;code&gt;class&lt;/code&gt; または &lt;code&gt;function&lt;/code&gt; のみをエクスポートする場合は、 &lt;code&gt;export default&lt;/code&gt; 使用します</target>
        </trans-unit>
        <trans-unit id="2f70d23b3b33808540611f0c15d2283c4e323059" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re reading this guide, you probably already roughly know what a type in TypeScript is. To be more explicit, though, a &lt;em&gt;type&lt;/em&gt; is introduced with:</source>
          <target state="translated">このガイドを読んでいる方なら、おそらくTypeScriptの型がおおざっぱにわかっているでしょう。ただし、より明確にするために、&lt;em&gt;型&lt;/em&gt;は次のように導入されています。</target>
        </trans-unit>
        <trans-unit id="b934c40448796bd9edae2d68f2dcee6ad19754ce" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re starting a brand new project, take a look at the &lt;a href=&quot;https://create-react-app.dev/docs/adding-typescript&quot;&gt;React Quick Start guide&lt;/a&gt; first.</source>
          <target state="translated">まったく新しいプロジェクトを開始する場合は、まず&lt;a href=&quot;https://create-react-app.dev/docs/adding-typescript&quot;&gt;Reactクイックスタートガイドをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cff1c0146ace654a504313182db4a173a9b3388c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Gulp in some fashion, we have a tutorial on &lt;a href=&quot;gulp&quot;&gt;using Gulp&lt;/a&gt; with TypeScript, and integrating with common build tools like Browserify, Babelify, and Uglify. You can read more there.</source>
          <target state="translated">あなたには、いくつかの方法でがぶ飲みを使用している場合、我々は上のチュートリアル持って&lt;a href=&quot;gulp&quot;&gt;がぶ飲みを使用して&lt;/a&gt;活字体で、そしてBrowserify、Babelify、およびUglifyのような一般的なビルドツールとの統合を。もっと読むことができます。</target>
        </trans-unit>
        <trans-unit id="cafdaaff5d59cc2c2f1205e3709213e65336f377" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a module option other than &lt;code&gt;commonjs&lt;/code&gt;, you&amp;rsquo;ll need to set your &lt;code&gt;moduleResolution&lt;/code&gt; option to &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;commonjs&lt;/code&gt; 以外のモジュールオプションを使用している場合は、 &lt;code&gt;moduleResolution&lt;/code&gt; オプションを &lt;code&gt;node&lt;/code&gt; に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="0aafe02ccb06b6d197194a0b7f3d99641d791f0b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing in plain JavaScript, it&amp;rsquo;s likely that you&amp;rsquo;re running your JavaScript directly, where your &lt;code&gt;.js&lt;/code&gt; files are in a &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;lib&lt;/code&gt;, or &lt;code&gt;dist&lt;/code&gt; directory, and then ran as desired.</source>
          <target state="translated">プレーンJavaScriptで記述している場合、JavaScriptを直接実行している可能性があります。ここで、 &lt;code&gt;.js&lt;/code&gt; ファイルは &lt;code&gt;src&lt;/code&gt; 、 &lt;code&gt;lib&lt;/code&gt; 、または &lt;code&gt;dist&lt;/code&gt; ディレクトリにあり、必要に応じて実行されます。</target>
        </trans-unit>
        <trans-unit id="fdfba1223ac1da9db70e78da0daf0187962aac1a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve read about &lt;code&gt;typeof&lt;/code&gt; type guards and are familiar with the &lt;code&gt;instanceof&lt;/code&gt; operator in JavaScript, you probably have some idea of what this section is about.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; タイプガードについて読み、JavaScript の &lt;code&gt;instanceof&lt;/code&gt; 演算子に精通している場合は、おそらくこのセクションの内容を理解していることでしょう。</target>
        </trans-unit>
        <trans-unit id="ba89c0b592333fdedc6dea3af514c7a63cd66e0b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve used JavaScript offhandedly, the next section might be a good way to refresh your memory. If you&amp;rsquo;re intimately familiar with all the quirks of &lt;code&gt;var&lt;/code&gt; declarations in JavaScript, you might find it easier to skip ahead.</source>
          <target state="translated">JavaScriptを手軽に使用したことがある場合は、次のセクションでメモリをリフレッシュすることをお勧めします。JavaScript の &lt;code&gt;var&lt;/code&gt; 宣言のすべての癖に精通し​​ている場合は、先にスキップする方が簡単な場合があります。</target>
        </trans-unit>
        <trans-unit id="f2e114215a3320f3e8d3e8f7df80ee0813862362" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;outDir&lt;/code&gt; was &lt;code&gt;dist&lt;/code&gt;, TypeScript would write this tree:</source>
          <target state="translated">&lt;code&gt;outDir&lt;/code&gt; が &lt;code&gt;dist&lt;/code&gt; の場合、TypeScriptは次のツリーを記述します。</target>
        </trans-unit>
        <trans-unit id="7f637065274f76d0b1f9c68b24c257b06ecca8b9" translate="yes" xml:space="preserve">
          <source>If your functions are only able to handle string named property keys, use &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; in the declaration:</source>
          <target state="translated">関数がプロパティキーという名前の文字列のみを処理できる場合は、宣言で &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="d510aeb4b1e7484eea0e856138d74440b24ca0d1" translate="yes" xml:space="preserve">
          <source>If your functions are open to handling all property keys, then the changes should be done down-stream:</source>
          <target state="translated">関数がすべてのプロパティキーを扱うためにオープンになっている場合は、変更はダウンストリームで行うべきです。</target>
        </trans-unit>
        <trans-unit id="f902e411cb6ca33234031133f35364e8839ccd53" translate="yes" xml:space="preserve">
          <source>If your global library depends on a UMD module, use a &lt;code&gt;/// &amp;lt;reference types&lt;/code&gt; directive:</source>
          <target state="translated">グローバルライブラリがUMDモジュールに依存している場合は、 &lt;code&gt;/// &amp;lt;reference types&lt;/code&gt; ディレクティブを使用します。</target>
        </trans-unit>
        <trans-unit id="f7345e0903abc9ae4ad2adfd269b38c296742fa6" translate="yes" xml:space="preserve">
          <source>If your library depends on a global library, use a &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive:</source>
          <target state="translated">ライブラリがグローバルライブラリに依存している場合は、 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; ディレクティブを使用します。</target>
        </trans-unit>
        <trans-unit id="b2e55a3a3ef94d5068ad16150d23ae196cc87947" translate="yes" xml:space="preserve">
          <source>If your library depends on a module, use an &lt;code&gt;import&lt;/code&gt; statement:</source>
          <target state="translated">ライブラリがモジュールに依存している場合は、 &lt;code&gt;import&lt;/code&gt; ステートメントを使用します。</target>
        </trans-unit>
        <trans-unit id="4d7e714b624bcbe3efa868c9a33be75efd1d5cd0" translate="yes" xml:space="preserve">
          <source>If your module is not callable or constructable, use the &lt;a href=&quot;module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">モジュールが呼び出し可能または構築可能でない場合は、&lt;a href=&quot;module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt;ファイルを使用してください。</target>
        </trans-unit>
        <trans-unit id="39f14e77085a3e6f94f80d3a5737a97256584f64" translate="yes" xml:space="preserve">
          <source>If your module is not callable or constructable, use the &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">モジュールが呼び出し可能でも構築可能でもない場合は、&lt;a href=&quot;templates/module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt;ファイルを使用してください。</target>
        </trans-unit>
        <trans-unit id="708b87e0f5ca75919f8732aead8eedddc9c8eae8" translate="yes" xml:space="preserve">
          <source>If your module or UMD library depends on a UMD library, use an &lt;code&gt;import&lt;/code&gt; statement:</source>
          <target state="translated">モジュールまたはUMDライブラリがUMDライブラリに依存している場合は、 &lt;code&gt;import&lt;/code&gt; ステートメントを使用します。</target>
        </trans-unit>
        <trans-unit id="b502ac0f72d569709af646c5ae02325abd8bb700" translate="yes" xml:space="preserve">
          <source>If your package has a main &lt;code&gt;.js&lt;/code&gt; file, you will need to indicate the main declaration file in your &lt;code&gt;package.json&lt;/code&gt; file as well. Set the &lt;code&gt;types&lt;/code&gt; property to point to your bundled declaration file. For example:</source>
          <target state="translated">パッケージにメインの &lt;code&gt;.js&lt;/code&gt; ファイルがある場合、 &lt;code&gt;package.json&lt;/code&gt; ファイルでもメインの宣言ファイルを指定する必要があります。バンドルされた宣言ファイルを指すように &lt;code&gt;types&lt;/code&gt; プロパティを設定します。例えば：</target>
        </trans-unit>
        <trans-unit id="8809cc04677d076884fe6edcda034b008be7ba2b" translate="yes" xml:space="preserve">
          <source>If your package is not written in TypeScript then the second is the preferred approach.</source>
          <target state="translated">パッケージがTypeScriptで書かれていない場合は、2番目の方法が好ましいです。</target>
        </trans-unit>
        <trans-unit id="3a45948f03090d8097a2e93bad2b6d30f82543a2" translate="yes" xml:space="preserve">
          <source>If your package is written in TypeScript then the first approach is favored. Use the &lt;code&gt;--declaration&lt;/code&gt; flag to generate declaration files. This way, your declarations and JavaScript will always be in sync.</source>
          <target state="translated">パッケージがTypeScriptで記述されている場合は、最初のアプローチが推奨されます。 &lt;code&gt;--declaration&lt;/code&gt; フラグを使用して宣言ファイルを生成します。このようにして、宣言とJavaScriptは常に同期されます。</target>
        </trans-unit>
        <trans-unit id="557fe20ea364d4b85526f359a785f2b91d2a48b9" translate="yes" xml:space="preserve">
          <source>If your project is large, you can use the flag &lt;code&gt;disableReferencedProjectLoad&lt;/code&gt; to disable the automatic loading of all projects. Instead, projects are loaded dynamically as you open files through your editor.</source>
          <target state="translated">プロジェクトが大きい場合は、フラグ &lt;code&gt;disableReferencedProjectLoad&lt;/code&gt; を使用して、すべてのプロジェクトの自動ロードを無効にすることができます。代わりに、エディターでファイルを開くと、プロジェクトが動的に読み込まれます。</target>
        </trans-unit>
        <trans-unit id="490e3c77ca2e4322ada004a6ddfd9a7799557dcc" translate="yes" xml:space="preserve">
          <source>If your type definitions depend on another package:</source>
          <target state="translated">型定義が他のパッケージに依存している場合。</target>
        </trans-unit>
        <trans-unit id="55d1f300034ec5a2f0ab70c4ab7606f20472a2c0" translate="yes" xml:space="preserve">
          <source>If your types are generated by your source code, publish the types with your source code. Both TypeScript and JavaScript projects can generate types via &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#declaration&quot;&gt;&lt;code&gt;--declaration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">タイプがソースコードによって生成されている場合は、ソースコードとともにタイプを公開します。TypeScriptプロジェクトとJavaScriptプロジェクトはどちらも、&lt;a href=&quot;https://www.typescriptlang.org/tsconfig#declaration&quot;&gt; &lt;code&gt;--declaration&lt;/code&gt; &lt;/a&gt;を介して型を生成できます。</target>
        </trans-unit>
        <trans-unit id="f5dd23741ab01d47a9d58ca45645a4ccefbbd8f1" translate="yes" xml:space="preserve">
          <source>Implementing an interface</source>
          <target state="translated">インターフェースの実装</target>
        </trans-unit>
        <trans-unit id="0aba642bf4d637216b8d72e2f4ad7c9560d9798e" translate="yes" xml:space="preserve">
          <source>Implicit any errors</source>
          <target state="translated">暗黙のエラー</target>
        </trans-unit>
        <trans-unit id="7d52fc0e48ad6e0d6c8f5245ccb19f1dd538a022" translate="yes" xml:space="preserve">
          <source>Implicit index signatures</source>
          <target state="translated">暗黙のインデックス署名</target>
        </trans-unit>
        <trans-unit id="c8c4c307ff84c0f8c706629a70179c01013c51e4" translate="yes" xml:space="preserve">
          <source>Implicit returns</source>
          <target state="translated">暗黙のリターン</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="e388bb159f67517527bff80832c050cc9caf92f8" translate="yes" xml:space="preserve">
          <source>Import Helpers - &lt;code&gt;importHelpers&lt;/code&gt;</source>
          <target state="translated">インポートヘルパー &lt;code&gt;importHelpers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac42b7771deabcf8b9b301382d1ce7966a14ab50" translate="yes" xml:space="preserve">
          <source>Import a module for side-effects only</source>
          <target state="translated">副作用のみのモジュールをインポートする</target>
        </trans-unit>
        <trans-unit id="c5b568ec8548086b4de521e5d8033aec1c934aac" translate="yes" xml:space="preserve">
          <source>Import a single export from a module</source>
          <target state="translated">モジュールから単一のエクスポートをインポートする</target>
        </trans-unit>
        <trans-unit id="7830f060b13276e33e83c28a73aa77da5e486098" translate="yes" xml:space="preserve">
          <source>Import declarations, as well, can optionally use &lt;code&gt;as&lt;/code&gt; clauses to specify different local names for the imports. For example:</source>
          <target state="translated">インポート宣言でも、オプションで &lt;code&gt;as&lt;/code&gt; 句を使用して、インポートに異なるローカル名を指定できます。例えば：</target>
        </trans-unit>
        <trans-unit id="9914e368d228c16ed67283b9e88ab7f396d147f6" translate="yes" xml:space="preserve">
          <source>Import emit helpers (e.g. &lt;code&gt;__extends&lt;/code&gt;, &lt;code&gt;__rest&lt;/code&gt;, etc..) from &lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt;から &lt;code&gt;__rest&lt;/code&gt; ヘルパー（例： &lt;code&gt;__extends&lt;/code&gt; 、__restなど）をインポートします。</target>
        </trans-unit>
        <trans-unit id="d44d2976c5175c70409be4c97c0352850c0e7940" translate="yes" xml:space="preserve">
          <source>Import the entire module into a single variable, and use it to access the module exports</source>
          <target state="translated">モジュール全体を単一の変数にインポートし、モジュールのエクスポートにアクセスするために使用します。</target>
        </trans-unit>
        <trans-unit id="f908ff98948cecb3646ddcfb8cfb7d6851889ec0" translate="yes" xml:space="preserve">
          <source>Import types</source>
          <target state="translated">インポートタイプ</target>
        </trans-unit>
        <trans-unit id="104faef181cd8882668103e771e8eba923a2dcd8" translate="yes" xml:space="preserve">
          <source>Importantly, &lt;code&gt;rootDir&lt;/code&gt;&lt;strong&gt;does not affect which files become part of the compilation&lt;/strong&gt;. It has no interaction with the &lt;code&gt;include&lt;/code&gt;, &lt;code&gt;exclude&lt;/code&gt;, or &lt;code&gt;files&lt;/code&gt;&lt;code&gt;tsconfig.json&lt;/code&gt; settings.</source>
          <target state="translated">重要なことに、 &lt;code&gt;rootDir&lt;/code&gt; &lt;strong&gt;は、どのファイルがコンパイルの一部になるかに影響しません&lt;/strong&gt;。 &lt;code&gt;include&lt;/code&gt; 、 &lt;code&gt;exclude&lt;/code&gt; 、または &lt;code&gt;files&lt;/code&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; 設定との相互作用はありません。</target>
        </trans-unit>
        <trans-unit id="aa34d39c6555134662f510867cd143b4479edd11" translate="yes" xml:space="preserve">
          <source>Importing Types</source>
          <target state="translated">インポートタイプ</target>
        </trans-unit>
        <trans-unit id="a60647122c766cfb16cfd3672d6ea4130dbed5fe" translate="yes" xml:space="preserve">
          <source>Importing from Modules</source>
          <target state="translated">モジュールからのインポート</target>
        </trans-unit>
        <trans-unit id="f3c938e48f51fc9b9d8d6906d41005ba5ef033c7" translate="yes" xml:space="preserve">
          <source>Importing is just about as easy as exporting from a module. Importing an exported declaration is done through using one of the &lt;code&gt;import&lt;/code&gt; forms below:</source>
          <target state="translated">インポートは、モジュールからのエクスポートとほぼ同じくらい簡単です。エクスポートされた宣言の &lt;code&gt;import&lt;/code&gt; は、以下のインポートフォームのいずれかを使用して行われます。</target>
        </trans-unit>
        <trans-unit id="9f780bafb7678e0e4bc2ed60d39928e72d6363d4" translate="yes" xml:space="preserve">
          <source>Importing modules from a referenced project will instead load its &lt;em&gt;output&lt;/em&gt; declaration file (&lt;code&gt;.d.ts&lt;/code&gt;)</source>
          <target state="translated">参照プロジェクトからモジュールをインポートすると、代わりにその&lt;em&gt;出力&lt;/em&gt;宣言ファイル（ &lt;code&gt;.d.ts&lt;/code&gt; ）がロードされます</target>
        </trans-unit>
        <trans-unit id="1493dcf2543fd7025bb0dc28504a88da052081ce" translate="yes" xml:space="preserve">
          <source>Importing none-code resources using module loaders extension (e.g. &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt; or &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/creating-plugins.html&quot;&gt;SystemJS&lt;/a&gt;) has not been easy before; previously an ambient module declaration had to be defined for each resource.</source>
          <target state="translated">モジュールローダー拡張機能（&lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt;や&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/creating-plugins.html&quot;&gt;SystemJSなど&lt;/a&gt;）を使用してコードを含まないリソースをインポートすることは、以前は簡単ではありませんでした。以前は、各リソースに対してアンビエントモジュール宣言を定義する必要がありました。</target>
        </trans-unit>
        <trans-unit id="c444c4e966092782432f42e431dba46820d67082" translate="yes" xml:space="preserve">
          <source>Imports Not Used As Values - &lt;code&gt;importsNotUsedAsValues&lt;/code&gt;</source>
          <target state="translated">値として使用されないインポート &lt;code&gt;importsNotUsedAsValues&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe0a4c588d4f7e13fddfb1185a854f0eb29bd646" translate="yes" xml:space="preserve">
          <source>Imports fine with &lt;code&gt;allowJs&lt;/code&gt; enabled:</source>
          <target state="translated">&lt;code&gt;allowJs&lt;/code&gt; を有効にすると、正常にインポートされます。</target>
        </trans-unit>
        <trans-unit id="352d94d7b6ad5d2d2dd80449838c2cf319556903" translate="yes" xml:space="preserve">
          <source>Improved &lt;code&gt;any&lt;/code&gt; Inference</source>
          <target state="translated">改善された &lt;code&gt;any&lt;/code&gt; 推論</target>
        </trans-unit>
        <trans-unit id="400b56a2fe294d586033d28165229215531d4f5f" translate="yes" xml:space="preserve">
          <source>Improved &lt;code&gt;keyof&lt;/code&gt; with intersection types</source>
          <target state="translated">交差タイプによる改善された &lt;code&gt;keyof&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5db53c8c85f119e50fb4fddb0515ec92c8d14cae" translate="yes" xml:space="preserve">
          <source>Improved UX Around Promises</source>
          <target state="translated">プロミス周辺のUXの改善</target>
        </trans-unit>
        <trans-unit id="39095ed614c976a48a5edd3ac9559249a5bcafb9" translate="yes" xml:space="preserve">
          <source>Improved behavior for calling union types</source>
          <target state="translated">ユニオン型を呼び出す際の動作が改善されました。</target>
        </trans-unit>
        <trans-unit id="3aed2d7ad51f292dd55e2c452dc2f9d916f9f348" translate="yes" xml:space="preserve">
          <source>Improved checking for &lt;code&gt;for..in&lt;/code&gt; statements</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; ステートメントのチェックの改善</target>
        </trans-unit>
        <trans-unit id="c02cdcb0697c02f23de76b9402b3ffb5de18ea5a" translate="yes" xml:space="preserve">
          <source>Improved checking for destructuring object literal</source>
          <target state="translated">オブジェクトリテラルの破壊チェックを改善</target>
        </trans-unit>
        <trans-unit id="55bbe6a04eaea70e8654bdf75776576f97a9d374" translate="yes" xml:space="preserve">
          <source>Improved control over mapped type modifiers</source>
          <target state="translated">マップされた型修飾子の制御を改善</target>
        </trans-unit>
        <trans-unit id="be88c1fb8d146d0b9d876f22a0754323c60b7258" translate="yes" xml:space="preserve">
          <source>Improved excess property checks in union types</source>
          <target state="translated">組合型での余剰財産チェックを改善</target>
        </trans-unit>
        <trans-unit id="f0d6c8d205edfb92cb01f19342a7ad56a1cfd004" translate="yes" xml:space="preserve">
          <source>Improved handling of structurally identical classes and &lt;code&gt;instanceof&lt;/code&gt; expressions</source>
          <target state="translated">構造的に同一のクラスと &lt;code&gt;instanceof&lt;/code&gt; 式の処理の改善</target>
        </trans-unit>
        <trans-unit id="79046527e77a08d10c738b0d3678766e68083dfb" translate="yes" xml:space="preserve">
          <source>Improved inference for generics</source>
          <target state="translated">ジェネリックのための改良された推論</target>
        </trans-unit>
        <trans-unit id="9902b64afde9c77bb740ee885857e65ab81753ae" translate="yes" xml:space="preserve">
          <source>Improved support for &lt;code&gt;tsconfig.json&lt;/code&gt; in Visual Studio 2015</source>
          <target state="translated">Visual Studio 2015 での &lt;code&gt;tsconfig.json&lt;/code&gt; のサポートの改善</target>
        </trans-unit>
        <trans-unit id="cc966416a9eb70b531ccdaadbbaafa22d9349454" translate="yes" xml:space="preserve">
          <source>Improved type inference for object literals</source>
          <target state="translated">オブジェクトリテラルの型推論の改良</target>
        </trans-unit>
        <trans-unit id="b87ca7b1554d820cbb558e72b3dc2dd9bb2048e0" translate="yes" xml:space="preserve">
          <source>Improved union/intersection type inference</source>
          <target state="translated">ユニオン/交差点型の推論を改善しました。</target>
        </trans-unit>
        <trans-unit id="73d903d34db6a7a7623b02e31683adc136bd1806" translate="yes" xml:space="preserve">
          <source>Improvements for &lt;code&gt;ReadonlyArray&lt;/code&gt; and &lt;code&gt;readonly&lt;/code&gt; tuples</source>
          <target state="translated">&lt;code&gt;ReadonlyArray&lt;/code&gt; および &lt;code&gt;readonly&lt;/code&gt; タプルの改善</target>
        </trans-unit>
        <trans-unit id="75cc15f25fc2ae5d077c25f2e3c6ed80c124c408" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;templates&quot;&gt;Templates&lt;/a&gt; you&amp;rsquo;ll find a number of declaration files that serve as a useful starting point when writing a new file. Refer to the documentation in &lt;a href=&quot;library-structures&quot;&gt;Library Structures&lt;/a&gt; to figure out which template file to use.</source>
          <target state="translated">では&lt;a href=&quot;templates&quot;&gt;テンプレート&lt;/a&gt;新しいファイルを書くときに便利な出発点となる宣言ファイルの数を見つけることができます。使用するテンプレートファイルを確認するには、&lt;a href=&quot;library-structures&quot;&gt;ライブラリ構造&lt;/a&gt;のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="053ea35eb45b9803ab97bdc192cb5d0db843884b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, a &lt;code&gt;?&lt;/code&gt; modifier automatically includes &lt;code&gt;undefined&lt;/code&gt; in the element type, similar to optional parameters.</source>
          <target state="translated">では &lt;code&gt;--strictNullChecks&lt;/code&gt; のモードでは、 &lt;code&gt;?&lt;/code&gt; 修飾子は、オプションのパラメータと同様に、要素タイプに &lt;code&gt;undefined&lt;/code&gt; を自動的に含めます。</target>
        </trans-unit>
        <trans-unit id="c75d3751acc8527d062926da04731cafe2436c23" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;getProperty&lt;/code&gt;, &lt;code&gt;o: T&lt;/code&gt; and &lt;code&gt;propertyName: K&lt;/code&gt;, so that means &lt;code&gt;o[propertyName]: T[K]&lt;/code&gt;. Once you return the &lt;code&gt;T[K]&lt;/code&gt; result, the compiler will instantiate the actual type of the key, so the return type of &lt;code&gt;getProperty&lt;/code&gt; will vary according to which property you request.</source>
          <target state="translated">&lt;code&gt;getProperty&lt;/code&gt; 、 &lt;code&gt;o: T&lt;/code&gt; および &lt;code&gt;propertyName: K&lt;/code&gt; 、その結果手段 &lt;code&gt;o[propertyName]: T[K]&lt;/code&gt; 。もし返されると &lt;code&gt;T[K]&lt;/code&gt; 結果の戻り値の型には、コンパイラは、キーの実際の型をインスタンス化します &lt;code&gt;getProperty&lt;/code&gt; メソッドは、リクエストれる性質に応じて変化するであろう。</target>
        </trans-unit>
        <trans-unit id="0dd13518438c7329cf2fbf854c20974ad59ee4e1" translate="yes" xml:space="preserve">
          <source>In C# or Java, any given value or object has one exact type - either &lt;code&gt;null&lt;/code&gt;, a primitive, or a known class type. We can call methods like &lt;code&gt;value.GetType()&lt;/code&gt; or &lt;code&gt;value.getClass()&lt;/code&gt; to query the exact type at runtime. The definition of this type will reside in a class somewhere with some name, and we can&amp;rsquo;t use two classes with similar shapes in lieu of each other unless there&amp;rsquo;s an explicit inheritance relationship or commonly-implemented interface.</source>
          <target state="translated">C＃またはJavaでは、任意の値またはオブジェクトには、 &lt;code&gt;null&lt;/code&gt; 、プリミティブ、または既知のクラスタイプのいずれかの正確なタイプが1つあります。 &lt;code&gt;value.GetType()&lt;/code&gt; や &lt;code&gt;value.getClass()&lt;/code&gt; などのメソッドを呼び出して、実行時に正確な型を照会できます。この型の定義は、ある名前のクラスに存在します。明示的な継承関係または一般的に実装されているインターフェイスがない限り、同じような形の2つのクラスを互いに代わりに使用することはできません。</target>
        </trans-unit>
        <trans-unit id="e6827479b1d6256b64a352469a1cd16d7c9ad22a" translate="yes" xml:space="preserve">
          <source>In C# or Java, it&amp;rsquo;s meaningful to think of a one-to-one correspondence between runtime types and their compile-time declarations.</source>
          <target state="translated">C＃またはJavaでは、ランタイムタイプとそれらのコンパイル時宣言の間の1対1の対応を考えることは意味があります。</target>
        </trans-unit>
        <trans-unit id="34c08d2e6fe05992c2156e08cd3c91dcc0de0788" translate="yes" xml:space="preserve">
          <source>In CommonJS you can export any value as the default export, for example here is a regular expression module:</source>
          <target state="translated">CommonJSでは、任意の値をデフォルトのエクスポートとしてエクスポートすることができます。</target>
        </trans-unit>
        <trans-unit id="cac8a395d23bb271c0a5b1d7324f422027c11b0c" translate="yes" xml:space="preserve">
          <source>In ES2015, constructors which return an object implicitly substitute the value of &lt;code&gt;this&lt;/code&gt; for any callers of &lt;code&gt;super()&lt;/code&gt;. As a result, it is necessary to capture any potential return value of &lt;code&gt;super()&lt;/code&gt; and replace it with &lt;code&gt;this&lt;/code&gt;. This change enables working with &lt;a href=&quot;https://w3c.github.io/webcomponents/spec/custom/#htmlelement-constructor&quot;&gt;Custom Elements&lt;/a&gt;, which takes advantage of this to initialize browser-allocated elements with user-written constructors.</source>
          <target state="translated">ES2015では、オブジェクトを返すコンストラクターが &lt;code&gt;this&lt;/code&gt; の値を &lt;code&gt;super()&lt;/code&gt; の呼び出し元に暗黙的に置き換えます。その結果、 &lt;code&gt;super()&lt;/code&gt; の戻り値の可能性をキャプチャして、 &lt;code&gt;this&lt;/code&gt; に置き換える必要があります。この変更により、&lt;a href=&quot;https://w3c.github.io/webcomponents/spec/custom/#htmlelement-constructor&quot;&gt;カスタム要素の操作が&lt;/a&gt;可能になり、これを利用して、ブラウザーで割り当てられた要素をユーザー作成のコンストラクターで初期化します。</target>
        </trans-unit>
        <trans-unit id="367fc6bebb59a7cbd1d7db58cf0d02857ed175b8" translate="yes" xml:space="preserve">
          <source>In ES6 module loaders, the top-level object (here imported as &lt;code&gt;exp&lt;/code&gt;) can only have properties; the top-level module object is &lt;em&gt;never&lt;/em&gt; callable. The most common solution here is to define a &lt;code&gt;default&lt;/code&gt; export for a callable/constructable object; some module loader shims will automatically detect this situation and replace the top-level object with the &lt;code&gt;default&lt;/code&gt; export.</source>
          <target state="translated">ES6モジュールローダーでは、トップレベルのオブジェクト（ここでは &lt;code&gt;exp&lt;/code&gt; としてインポートされます）はプロパティのみを持つことができます。トップレベルのモジュールオブジェクトが呼び出される&lt;em&gt;こと&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。ここで最も一般的な解決策は、呼び出し可能/構築可能なオブジェクトの &lt;code&gt;default&lt;/code&gt; エクスポートを定義することです。一部のモジュールローダーシムは、この状況を自動的に検出し、最上位のオブジェクトを &lt;code&gt;default&lt;/code&gt; エクスポートに置き換えます。</target>
        </trans-unit>
        <trans-unit id="73164a9f408dbb559f1ff8a82aed1d6f3a2cf1a3" translate="yes" xml:space="preserve">
          <source>In ES6-compl module loaders, the top-level object (here imported as &lt;code&gt;exp&lt;/code&gt;) can only have properties; the top-level module object can &lt;em&gt;never&lt;/em&gt; be callable.</source>
          <target state="translated">ES6-complモジュールローダーでは、トップレベルオブジェクト（ここでは &lt;code&gt;exp&lt;/code&gt; としてインポートされます）はプロパティのみを持つことができます。トップレベルのモジュールオブジェクトを呼び出すこと&lt;em&gt;は&lt;/em&gt;でき&lt;em&gt;ませ&lt;/em&gt;ん。</target>
        </trans-unit>
        <trans-unit id="f9178ac7270dcc05dceadc49b3f02c9dc7dcbddb" translate="yes" xml:space="preserve">
          <source>In Edge, press F12 and click the Debugger tab.</source>
          <target state="translated">EdgeでF12キーを押してデバッガタブをクリックします。</target>
        </trans-unit>
        <trans-unit id="54dc2fcbcb0f1f6b32f8968730c12d2717aff252" translate="yes" xml:space="preserve">
          <source>In JSDoc references</source>
          <target state="translated">JSDoc リファレンスでは</target>
        </trans-unit>
        <trans-unit id="6fdb267749a0a65e58ebbcd5a8e1c2849232fca7" translate="yes" xml:space="preserve">
          <source>In JavaScript it is fairly common to have APIs that expect property names as parameters, but so far it hasn&amp;rsquo;t been possible to express the type relationships that occur in those APIs.</source>
          <target state="translated">JavaScriptでは、プロパティ名をパラメータとして期待するAPIを使用することはかなり一般的ですが、これまでのところ、これらのAPIで発生する型の関係を表現することはできませんでした。</target>
        </trans-unit>
        <trans-unit id="9d68eb64db15f82423559857fcf4d5a5356cdcf0" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;code&gt;this&lt;/code&gt; is a variable that&amp;rsquo;s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This is notoriously confusing, especially when returning a function or passing a function as an argument.</source>
          <target state="translated">JavaScriptでは、 &lt;code&gt;this&lt;/code&gt; は関数が呼び出されたときに設定される変数です。これは非常に強力で柔軟な機能になりますが、関数が実行されているコンテキストを常に知る必要があるという犠牲を伴います。これは、特に関数を返すときや、関数を引数として渡すときに、混乱することで有名です。</target>
        </trans-unit>
        <trans-unit id="484bfab743be72776c5e3700ec9d551efe4c463b" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;code&gt;var&lt;/code&gt; declarations are &amp;ldquo;hoisted&amp;rdquo; to the top of their enclosing scope. This can result in confusing bugs:</source>
          <target state="translated">JavaScriptでは、 &lt;code&gt;var&lt;/code&gt; 宣言はそれらを囲むスコープの最上部に「巻き上げ」られます。これにより、バグが混乱する可能性があります。</target>
        </trans-unit>
        <trans-unit id="a721d5f467ada10610bec48c19e76c798ba0faad" translate="yes" xml:space="preserve">
          <source>In JavaScript, every parameter is optional, and users may leave them off as they see fit. When they do, their value is &lt;code&gt;undefined&lt;/code&gt;. We can get this functionality in TypeScript by adding a &lt;code&gt;?&lt;/code&gt; to the end of parameters we want to be optional. For example, let&amp;rsquo;s say we want the last name parameter from above to be optional:</source>
          <target state="translated">JavaScriptでは、すべてのパラメーターはオプションであり、ユーザーは必要に応じてパラメーターを省略できます。その場合、その値は &lt;code&gt;undefined&lt;/code&gt; です。TypeScriptで &lt;code&gt;?&lt;/code&gt; を追加することにより、この機能を取得できます。オプションにしたいパラメータの最後に。たとえば、上記の姓パラメーターをオプションにしたいとします。</target>
        </trans-unit>
        <trans-unit id="67651f3f892a0de5974b0da9cae101fc0f274b31" translate="yes" xml:space="preserve">
          <source>In JavaScript, functions can live anywhere, and data can be passed around freely without being inside a pre-defined &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt;. This flexibility is extremely powerful. &amp;ldquo;Free&amp;rdquo; functions (those not associated with a class) working over data without an implied OOP hierarchy tends to be the preferred model for writing programs in JavaScript.</source>
          <target state="translated">JavaScriptでは、関数はどこにでも存在でき、データは事前​​定義された &lt;code&gt;class&lt;/code&gt; や &lt;code&gt;struct&lt;/code&gt; 中にいなくても自由に渡すことができます。この柔軟性は非常に強力です。暗黙のOOP階層なしでデータを処理する「無料」関数（クラスに関連付けられていない関数）は、JavaScriptでプログラムを作成するための推奨モデルになる傾向があります。</target>
        </trans-unit>
        <trans-unit id="1a818fdd28b569608ea92c5b8fbf2223393403d4" translate="yes" xml:space="preserve">
          <source>In JavaScript, mutability is the default, although it allows variable declarations with &lt;code&gt;const&lt;/code&gt; to declare that the &lt;em&gt;reference&lt;/em&gt; is immutable. The referent is still mutable:</source>
          <target state="translated">JavaScriptでは、可変性がデフォルトですが、 &lt;code&gt;const&lt;/code&gt; を使用した変数宣言では、&lt;em&gt;参照&lt;/em&gt;が不変であることを宣言できます。指示対象はまだ変更可能です：</target>
        </trans-unit>
        <trans-unit id="cd949f14dcd3d1c680cfa42bdf9a32c9f564e9cb" translate="yes" xml:space="preserve">
          <source>In Node.js, most tasks are accomplished by loading one or more modules. We could define each module in its own &lt;code&gt;.d.ts&lt;/code&gt; file with top-level export declarations, but it&amp;rsquo;s more convenient to write them as one larger &lt;code&gt;.d.ts&lt;/code&gt; file. To do so, we use a construct similar to ambient namespaces, but we use the &lt;code&gt;module&lt;/code&gt; keyword and the quoted name of the module which will be available to a later import. For example:</source>
          <target state="translated">Node.jsでは、ほとんどのタスクは1つ以上のモジュールをロードすることで実行されます。最上位のエクスポート宣言を使用して、各モジュールを独自の &lt;code&gt;.d.ts&lt;/code&gt; ファイルで定義することもできますが、1つの大きな &lt;code&gt;.d.ts&lt;/code&gt; ファイルとして記述する方が便利です。これを行うには、アンビエント名前空間に類似した構成を使用し &lt;code&gt;module&lt;/code&gt; が、モジュールキーワードと、後でインポートするときに使用できるモジュールの引用符で囲まれた名前を使用します。例えば：</target>
        </trans-unit>
        <trans-unit id="9a8e105ae7200ecea675173edd80960ba967b794" translate="yes" xml:space="preserve">
          <source>In TypeScript 1.4, we added support for template strings for all targets, and tagged templates for just ES6. Thanks to some considerable work done by &lt;a href=&quot;https://github.com/ivogabe&quot;&gt;@ivogabe&lt;/a&gt;, we bridged the gap for for tagged templates in ES3 and ES5.</source>
          <target state="translated">TypeScript 1.4では、すべてのターゲットのテンプレート文字列と、ES6のみのタグ付きテンプレートのサポートが追加されました。&lt;a href=&quot;https://github.com/ivogabe&quot;&gt;@ivogabe&lt;/a&gt;によるかなりの作業のおかげで、ES3とES5でタグ付きテンプレートのギャップを埋めました。</target>
        </trans-unit>
        <trans-unit id="c136c2bbed32677bb7335ad748e3d5ef230b3921" translate="yes" xml:space="preserve">
          <source>In TypeScript 1.8 with the latest version of react.d.ts (see above), we&amp;rsquo;ve also greatly simplified the declaration of &lt;code&gt;props&lt;/code&gt; types.</source>
          <target state="translated">最新バージョンのreact.d.tsを備えたTypeScript 1.8（上記を参照）では、 &lt;code&gt;props&lt;/code&gt; 型の宣言も大幅に簡素化されました。</target>
        </trans-unit>
        <trans-unit id="51239dcf9cd000d42b9c40712065d5e3ac4e06b5" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.0, it has become significantly easier to consume declaration files, in acquiring, using, and finding them. This page details exactly how to do all three.</source>
          <target state="translated">TypeScript 2.0では、宣言ファイルの取得、使用、検索が非常に簡単になりました。このページでは、この3つの方法について詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="280fed62c426cb333df0ac98e6eabc689470726c" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.3, TS introduced type checking of &lt;em&gt;children&lt;/em&gt;. &lt;em&gt;children&lt;/em&gt; is a special property in an &lt;em&gt;element attributes type&lt;/em&gt; where child &lt;em&gt;JSXExpression&lt;/em&gt;s are taken to be inserted into the attributes. Similar to how TS uses &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; to determine the name of &lt;em&gt;props&lt;/em&gt;, TS uses &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; to determine the name of &lt;em&gt;children&lt;/em&gt; within those props. &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; should be declared with a single property.</source>
          <target state="translated">TypeScript 2.3では、TSは&lt;em&gt;子の&lt;/em&gt;型チェックを導入しました。&lt;em&gt;子&lt;/em&gt;は、&lt;em&gt;要素の属性タイプの&lt;/em&gt;特別なプロパティであり、子の&lt;em&gt;JSXExpression&lt;/em&gt;が属性に挿入されます。TSが &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; を使用して&lt;em&gt;小道具&lt;/em&gt;の名前を決定する方法と同様に、TSは &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; を使用してそれらの小道具内の&lt;em&gt;子&lt;/em&gt;の名前を決定します。 &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; は単一のプロパティで宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="21bf9c2a83b6910226d6caf86b85a5fe927e4d3f" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.4, it&amp;rsquo;s now an error to assign anything to a weak type when there&amp;rsquo;s no overlap in properties. For example:</source>
          <target state="translated">TypeScript 2.4では、プロパティに重複がない場合、弱い型に何かを割り当てるとエラーになります。例えば：</target>
        </trans-unit>
        <trans-unit id="0d04812c896e54873be22b5061fb98c356d962e4" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.4, the function on the right side implicitly &lt;em&gt;gains&lt;/em&gt; type parameters, and &lt;code&gt;y&lt;/code&gt; is inferred to have the type of that type-parameter.</source>
          <target state="translated">TypeScript 2.4では、右側の関数が暗黙的に型パラメーターを&lt;em&gt;取得し&lt;/em&gt;、 &lt;code&gt;y&lt;/code&gt; はその型パラメーターの型を持つと推測されます。</target>
        </trans-unit>
        <trans-unit id="fcec71f6bd5ce7d77407d547d676e3be6ddf7295" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.6 and earlier, &lt;code&gt;[number, string, string]&lt;/code&gt; was considered a subtype of &lt;code&gt;[number, string]&lt;/code&gt;. This was motivated by TypeScript&amp;rsquo;s structural nature; the first and second elements of a &lt;code&gt;[number, string, string]&lt;/code&gt; are respectively subtypes of the first and second elements of &lt;code&gt;[number, string]&lt;/code&gt;. However, after examining real world usage of tuples, we noticed that most situations in which this was permitted was typically undesirable.</source>
          <target state="translated">TypeScript 2.6以前では、 &lt;code&gt;[number, string, string]&lt;/code&gt; は &lt;code&gt;[number, string]&lt;/code&gt; サブタイプと見なされていました。これはTypeScriptの構造的な性質によって動機付けられました。第一及び第二の要素 &lt;code&gt;[number, string, string]&lt;/code&gt; 、それぞれの第一及び第二の要素のサブタイプである &lt;code&gt;[number, string]&lt;/code&gt; 。ただし、タプルの実際の使用状況を調べたところ、これが許可されているほとんどの状況は通常望ましくないことがわかりました。</target>
        </trans-unit>
        <trans-unit id="649188580014293e883a71ef51c9fad716c1836d" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.7, tuples of different arities are no longer assignable to each other. Thanks to a pull request from &lt;a href=&quot;https://github.com/tycho01&quot;&gt;Tycho Grouwstra&lt;/a&gt;, tuple types now encode their arity into the type of their respective &lt;code&gt;length&lt;/code&gt; property. This is accomplished by leveraging numeric literal types, which now allow tuples to be distinct from tuples of different arities.</source>
          <target state="translated">TypeScript 2.7では、異なるアリティのタプルを互いに割り当てることができなくなりました。&lt;a href=&quot;https://github.com/tycho01&quot;&gt;Tycho Grouwstra&lt;/a&gt;からのプルリクエストのおかげで、タプルタイプはアリティをそれぞれの &lt;code&gt;length&lt;/code&gt; プロパティのタイプにエンコードするようになりました。これは、数値リテラル型を活用することで実現され、タプルを異なるアリティのタプルと区別できるようになりました。</target>
        </trans-unit>
        <trans-unit id="e924e834ba371b237a2fd89703ad1fd92c349cc6" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.1, mapped object types&lt;sup&gt;&lt;a href=&quot;#ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; over tuples and arrays now produce new tuples/arrays, rather than creating a new type where members like &lt;code&gt;push()&lt;/code&gt;, &lt;code&gt;pop()&lt;/code&gt;, and &lt;code&gt;length&lt;/code&gt; are converted. For example:</source>
          <target state="translated">TypeScript 3.1では、タプルと配列にマッピングされたオブジェクトタイプ&lt;sup&gt;&lt;a href=&quot;#ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;は、 &lt;code&gt;push()&lt;/code&gt; 、 &lt;code&gt;pop()&lt;/code&gt; 、および &lt;code&gt;length&lt;/code&gt; などのメンバーが変換される新しいタイプを作成するのではなく、新しいタプル/配列を生成するようになりました。例えば：</target>
        </trans-unit>
        <trans-unit id="39f9c3f02fd56ead96678ac1ba450ac3cd68bf5e" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.2, object literals now allow generic spread expressions which now produce intersection types, similar to the &lt;code&gt;Object.assign&lt;/code&gt; function and JSX literals. For example:</source>
          <target state="translated">TypeScript 3.2では、オブジェクトリテラルは、 &lt;code&gt;Object.assign&lt;/code&gt; 関数やJSXリテラルと同様に、交差タイプを生成する一般的なスプレッド式を許可するようになりました。例えば：</target>
        </trans-unit>
        <trans-unit id="2b164e3a6dff9d3898d7cd8f7babad021ca8339a" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, &lt;code&gt;--build&lt;/code&gt; mode&amp;rsquo;s &lt;code&gt;--watch&lt;/code&gt; flag &lt;em&gt;does&lt;/em&gt; leverage incremental file watching as well. That can mean signficantly faster builds under &lt;code&gt;--build --watch&lt;/code&gt;. In our testing, this functionality has resulted in &lt;strong&gt;a reduction of 50% to 75% in build times&lt;/strong&gt; of the original &lt;code&gt;--build --watch&lt;/code&gt; times. &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29161&quot;&gt;You can read more on the original pull request for the change&lt;/a&gt; to see specific numbers, but we believe most composite project users will see significant wins here.</source>
          <target state="translated">活字体3.3では、 &lt;code&gt;--build&lt;/code&gt; モードの &lt;code&gt;--watch&lt;/code&gt; フラグ&lt;em&gt;ん&lt;/em&gt;レバレッジ増分ファイルも同様に見ています。つまり、-- &lt;code&gt;--build --watch&lt;/code&gt; ビルドが大幅に高速化されます。テストでは、この機能により、元の &lt;code&gt;--build --watch&lt;/code&gt; 時間の&lt;strong&gt;ビルド時間&lt;/strong&gt;を&lt;strong&gt;50％から75％&lt;/strong&gt;削減しました。&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29161&quot;&gt;変更の元のプルリクエストで&lt;/a&gt;詳細を確認して特定の数値を確認できますが、ほとんどの複合プロジェクトユーザーはここで大きな成功を収めると信じています。</target>
        </trans-unit>
        <trans-unit id="0ff72425a74a94e8f866efe98b24a9a23e691d20" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, the parameters of these signatures are &lt;em&gt;intersected&lt;/em&gt; together to create a new signature.</source>
          <target state="translated">TypeScript 3.3では、これらの署名のパラメーターが互いに&lt;em&gt;交差&lt;/em&gt;して、新しい署名が作成されます。</target>
        </trans-unit>
        <trans-unit id="a91f7b680f1b740f03303f6aa85f432e9ad8efa8" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, this is no longer an error.</source>
          <target state="translated">TypeScript 3.3では、これはもはやエラーではありません。</target>
        </trans-unit>
        <trans-unit id="5341077b6a3de5130003da3230dc62974ee76806" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4 and earlier, certain excess properties were allowed in situations where they really shouldn&amp;rsquo;t have been. For instance, TypeScript 3.4 permitted the incorrect &lt;code&gt;name&lt;/code&gt; property in the object literal even though its types don&amp;rsquo;t match between &lt;code&gt;Point&lt;/code&gt; and &lt;code&gt;Label&lt;/code&gt;.</source>
          <target state="translated">TypeScript 3.4以前では、本来あるべきではない状況で、特定の過剰なプロパティが許可されていました。たとえば、TypeScript 3.4では、 &lt;code&gt;Point&lt;/code&gt; と &lt;code&gt;Label&lt;/code&gt; の間で型が一致していなくても、オブジェクトリテラルの不正な &lt;code&gt;name&lt;/code&gt; プロパティが許可されていました。</target>
        </trans-unit>
        <trans-unit id="eb163ddc0e2f8f1dc49a15fee6ec555fb1d31fba" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4 and prior, the following example would fail:</source>
          <target state="translated">TypeScript 3.4以前のバージョンでは、以下の例は失敗します。</target>
        </trans-unit>
        <trans-unit id="09356337029d3d047ed37351c9cbc0dd0318ec54" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4, the &lt;code&gt;readonly&lt;/code&gt; modifier in a mapped type will automatically convert array-like types to their corresponding &lt;code&gt;readonly&lt;/code&gt; counterparts.</source>
          <target state="translated">TypeScript 3.4では、マップされた型の &lt;code&gt;readonly&lt;/code&gt; 修飾子は、配列のような型を対応する &lt;code&gt;readonly&lt;/code&gt; 対応する型に自動的に変換します。</target>
        </trans-unit>
        <trans-unit id="e962c6d8bea6e7e5e00083a65a632b1e6809958d" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4, we improved inference for when generic functions that return functions like so:</source>
          <target state="translated">TypeScript 3.4では、「so」のような関数を返す汎用関数がある場合の推論を改善しました。</target>
        </trans-unit>
        <trans-unit id="8398d8557226d4dcf61ef0d2d8e32afa0789a488" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, the type-checker at least verifies that all the provided properties belong to &lt;em&gt;some&lt;/em&gt; union member and have the appropriate type, meaning that the sample above correctly issues an error.</source>
          <target state="translated">活字体3.5では、少なくとも検証の型チェッカはすべて提供されるプロパティはに属していることを&lt;em&gt;いくつかの&lt;/em&gt;サンプルは上記正しくエラーを発行することを意味し、組合員と適切なタイプを持っています。</target>
        </trans-unit>
        <trans-unit id="6bd78304e8ab95ec78b59e840c5e6980b10bd2ff" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, when assigning to types with discriminant properties like in &lt;code&gt;T&lt;/code&gt;, the language actually &lt;em&gt;will&lt;/em&gt; go further and decompose types like &lt;code&gt;S&lt;/code&gt; into a union of every possible inhabitant type. In this case, since &lt;code&gt;boolean&lt;/code&gt; is a union of &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; will be viewed as a union of &lt;code&gt;{ done: false, value: number }&lt;/code&gt; and &lt;code&gt;{ done: true, value: number }&lt;/code&gt;.</source>
          <target state="translated">以下のように判別特性を持つタイプに割り当てる場合活字体3.5では、 &lt;code&gt;T&lt;/code&gt; 、言語が実際に&lt;em&gt;なります&lt;/em&gt;よう更なると分解し種類行く &lt;code&gt;S&lt;/code&gt; を可能なすべての住民のタイプの労働組合へ。この場合、 &lt;code&gt;boolean&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; と &lt;code&gt;false&lt;/code&gt; の和集合であるため、 &lt;code&gt;S&lt;/code&gt; は &lt;code&gt;{ done: false, value: number }&lt;/code&gt; および &lt;code&gt;{ done: true, value: number }&lt;/code&gt; 和集合と見なされます。</target>
        </trans-unit>
        <trans-unit id="d94a96c27cb9468cb91f9314627e1075ad63df4c" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, you can now reference UMD global declarations like</source>
          <target state="translated">TypeScript 3.5 では、以下のような UMD グローバル宣言を参照できるようになりました。</target>
        </trans-unit>
        <trans-unit id="ebce4ccb31849685f27f521710646fdd135799f4" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.6, the checker now knows that the correct type for &lt;code&gt;curr.value&lt;/code&gt; should be &lt;code&gt;string&lt;/code&gt; in our first example, and will correctly error on our call to &lt;code&gt;next()&lt;/code&gt; in our last example. This is thanks to some changes in the &lt;code&gt;Iterator&lt;/code&gt; and &lt;code&gt;IteratorResult&lt;/code&gt; type declarations to include a few new type parameters, and to a new type that TypeScript uses to represent generators called the &lt;code&gt;Generator&lt;/code&gt; type.</source>
          <target state="translated">TypeScript 3.6では、チェッカーは最初の例では &lt;code&gt;curr.value&lt;/code&gt; の正しい型が &lt;code&gt;string&lt;/code&gt; であることを認識し、最後の例での &lt;code&gt;next()&lt;/code&gt; の呼び出しで正しくエラーになります。これは、いくつかの新しい型パラメーターを含めるための &lt;code&gt;Iterator&lt;/code&gt; および &lt;code&gt;IteratorResult&lt;/code&gt; 型宣言のいくつかの変更と、TypeScriptが &lt;code&gt;Generator&lt;/code&gt; 型と呼ばれるジェネレーターを表すために使用する新しい型のおかげです。</target>
        </trans-unit>
        <trans-unit id="0905562c8006d5cf59d0f711433ed32656adf580" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31231&quot;&gt;this is now correctly identified as a duplicate identifier error&lt;/a&gt;. The correct fix depends on the original intent of the author and should be addressed on a case-by-case basis. Usually, the naming conflict is unintentional and the best fix is to rename the imported type. If the intent was to augment the imported type, a proper module augmentation should be written instead.</source>
          <target state="translated">TypeScript 3.7では、&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31231&quot;&gt;これは重複識別子エラーとして正しく識別されるようになりました&lt;/a&gt;。正しい修正は、作成者の元の意図によって異なり、ケースバイケースで対処する必要があります。通常、名前の競合は意図的なものではなく、インポートされたタイプの名前を変更することをお勧めします。インポートした型を拡張することが目的である場合は、適切なモジュール拡張を代わりに作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="3d966bc481353f4c45fe41960daf87445589baab" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, the compiler itself will take advantage of this feature so that generated &lt;code&gt;.d.ts&lt;/code&gt; files will also emit &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors.</source>
          <target state="translated">TypeScript 3.7では、コンパイラー自体がこの機能を利用するため、生成された &lt;code&gt;.d.ts&lt;/code&gt; ファイルも &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; アクセサーを発行します。</target>
        </trans-unit>
        <trans-unit id="867e1064d30d0ee6d5ae66e30b7de9d7c76047ce" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, the compiler will take advantage of this feature so that &lt;code&gt;.d.ts&lt;/code&gt; files generated from &lt;code&gt;.js&lt;/code&gt; files can appropriately capture both the callability and constructability of a class-like function.</source>
          <target state="translated">TypeScript 3.7では、コンパイラはこの機能を利用して、 &lt;code&gt;.js&lt;/code&gt; ファイルから生成された &lt;code&gt;.d.ts&lt;/code&gt; ファイルが、クラスのような関数の呼び出し可能性と構成可能性の両方を適切にキャプチャできるようにします。</target>
        </trans-unit>
        <trans-unit id="12c564a00c60c29478392ba0894da5e9c08182a8" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, this is identified as a likely error:</source>
          <target state="translated">TypeScript 3.7では、これがエラーになる可能性が高いとされています。</target>
        </trans-unit>
        <trans-unit id="4164a94a4712ff430d4d9a46e1e26ed5ff082a55" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, when opening a project with dependencies, TypeScript will automatically use the source &lt;code&gt;.ts&lt;/code&gt;/&lt;code&gt;.tsx&lt;/code&gt; files instead. This means projects using project references will now see an improved editing experience where semantic operations are up-to-date and &amp;ldquo;just work&amp;rdquo;. You can disable this behavior with the compiler option &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt; which may be appropriate when working in very large projects where this change may impact editing performance.</source>
          <target state="translated">TypeScript 3.7では、依存関係のあるプロジェクトを開くと、TypeScriptは代わりにソースの &lt;code&gt;.ts&lt;/code&gt; / &lt;code&gt;.tsx&lt;/code&gt; ファイルを自動的に使用します。つまり、プロジェクト参照を使用するプロジェクトでは、セマンティック操作が最新で「正しく動作」している編集エクスペリエンスが向上します。この動作を無効にするには、コンパイラオプション &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt; を使用します。これは、この変更が編集パフォーマンスに影響を与える可能性がある非常に大きなプロジェクトで作業する場合に適しています。</target>
        </trans-unit>
        <trans-unit id="f35647c7752475abd065982be5bc1b280eb87d72" translate="yes" xml:space="preserve">
          <source>In TypeScript 4.1, we added the ability to disable the special-casing where a filename would trigger type acquisition:</source>
          <target state="translated">TypeScript 4.1では、ファイル名が型取得のトリガーとなる特殊なケースを無効にする機能が追加されました。</target>
        </trans-unit>
        <trans-unit id="38698da453e7ee13579d517a8684b98de7bc1513" translate="yes" xml:space="preserve">
          <source>In TypeScript or ES6, the &lt;code&gt;import&lt;/code&gt; keyword serves the same purpose:</source>
          <target state="translated">TypeScriptまたはES6では、 &lt;code&gt;import&lt;/code&gt; キーワードは同じ目的を果たします。</target>
        </trans-unit>
        <trans-unit id="82d214ccb1ea5cf33bc755b464edc62ce95d4e1d" translate="yes" xml:space="preserve">
          <source>In TypeScript, a declaration creates entities in at least one of three groups: namespace, type, or value. Namespace-creating declarations create a namespace, which contains names that are accessed using a dotted notation. Type-creating declarations do just that: they create a type that is visible with the declared shape and bound to the given name. Lastly, value-creating declarations create values that are visible in the output JavaScript.</source>
          <target state="translated">TypeScriptでは、宣言は、名前空間、型、値の3つのグループのうち少なくとも1つにエンティティを作成します。名前空間を作成する宣言は名前空間を作成します。型作成宣言は、宣言された形状で表示され、指定された名前にバインドされた型を作成します。最後に、値作成宣言は、出力 JavaScript で表示される値を作成します。</target>
        </trans-unit>
        <trans-unit id="f59c1f1ad017a0e2538bcd6ec781579714841dc0" translate="yes" xml:space="preserve">
          <source>In TypeScript, both &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; actually have their own types named &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; respectively. Much like &lt;code&gt;void&lt;/code&gt;, they&amp;rsquo;re not extremely useful on their own:</source>
          <target state="translated">TypeScriptでは、 &lt;code&gt;undefined&lt;/code&gt; と &lt;code&gt;null&lt;/code&gt; の両方に、実際にはそれぞれ &lt;code&gt;undefined&lt;/code&gt; と &lt;code&gt;null&lt;/code&gt; という名前の独自の型があります。 &lt;code&gt;void&lt;/code&gt; と同じように、それ自体ではあまり有用ではありません。</target>
        </trans-unit>
        <trans-unit id="376a74b14286aaed0718f841b6819ef69ddf714d" translate="yes" xml:space="preserve">
          <source>In TypeScript, both &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; actually have their types named &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; respectively. Much like &lt;code&gt;void&lt;/code&gt;, they&amp;rsquo;re not extremely useful on their own:</source>
          <target state="translated">TypeScriptでは、 &lt;code&gt;undefined&lt;/code&gt; と &lt;code&gt;null&lt;/code&gt; の両方に、実際にはそれぞれ &lt;code&gt;undefined&lt;/code&gt; と &lt;code&gt;null&lt;/code&gt; という名前のタイプがあります。 &lt;code&gt;void&lt;/code&gt; と同じように、それらはそれ自体では非常に有用ではありません。</target>
        </trans-unit>
        <trans-unit id="a1389ac175cd87f93511a411a3c43d05c85ede09" translate="yes" xml:space="preserve">
          <source>In TypeScript, every parameter is assumed to be required by the function. This doesn&amp;rsquo;t mean that it can&amp;rsquo;t be given &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, but rather, when the function is called, the compiler will check that the user has provided a value for each parameter. The compiler also assumes that these parameters are the only parameters that will be passed to the function. In short, the number of arguments given to a function has to match the number of parameters the function expects.</source>
          <target state="translated">TypeScriptでは、すべてのパラメーターが関数に必要であると想定されています。これは、 &lt;code&gt;null&lt;/code&gt; や &lt;code&gt;undefined&lt;/code&gt; を指定できないことを意味するのではなく、関数が呼び出されると、コンパイラーはユーザーが各パラメーターに値を提供したことを確認します。コンパイラーは、これらのパラメーターが関数に渡される唯一のパラメーターであることも前提としています。要するに、関数に与えられる引数の数は、関数が期待するパラメーターの数と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="740a107698ee1408e32efe4710e0a388e20d2757" translate="yes" xml:space="preserve">
          <source>In TypeScript, it&amp;rsquo;s better to think of a type as a &lt;em&gt;set of values&lt;/em&gt; that share something in common. Because types are just sets, a particular value can belong to &lt;em&gt;many&lt;/em&gt; sets at the same time.</source>
          <target state="translated">TypeScriptでは、タイプを、何かを共有する&lt;em&gt;値のセット&lt;/em&gt;と考える方がよいでしょう。タイプは単なるセットであるため、特定の値は同時に&lt;em&gt;多くの&lt;/em&gt;セットに属することができます。</target>
        </trans-unit>
        <trans-unit id="a24475a2eada62cf03ff9dfea85139d779f1476f" translate="yes" xml:space="preserve">
          <source>In TypeScript, just as in ECMAScript 2015, any file containing a top-level &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; is considered a module. Conversely, a file without any top-level &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).</source>
          <target state="translated">TypeScriptでは、ECMAScript 2015と同様に、最上位の &lt;code&gt;import&lt;/code&gt; または &lt;code&gt;export&lt;/code&gt; を含むファイルはすべてモジュールと見なされます。逆に、トップレベルの &lt;code&gt;import&lt;/code&gt; または &lt;code&gt;export&lt;/code&gt; 宣言のないファイルは、その内容がグローバルスコープで（したがって、モジュールでも）利用可能なスクリプトとして扱われます。</target>
        </trans-unit>
        <trans-unit id="5a8756023ca1bc1f9c910f749b9c017f2449d68f" translate="yes" xml:space="preserve">
          <source>In TypeScript, objects are &lt;em&gt;not&lt;/em&gt; of a single exact type. For example, if we construct an object that satisfies an interface, we can use that object where that interface is expected even though there was no declarative relationship between the two.</source>
          <target state="translated">TypeScriptでは、オブジェクトは単一の正確なタイプではあり&lt;em&gt;ません&lt;/em&gt;。たとえば、インターフェイスを満たすオブジェクトを作成する場合、2つの間に宣言的な関係がなくても、そのインターフェイスが期待される場所でそのオブジェクトを使用できます。</target>
        </trans-unit>
        <trans-unit id="1ed5374d91892c7ddbb0f4d810f43603226252a7" translate="yes" xml:space="preserve">
          <source>In TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation. For example, in this code</source>
          <target state="translated">TypeScriptでは、明示的な型アノテーションがない場合に型推論を使って型情報を提供する場所がいくつかあります。例えば、このコードでは</target>
        </trans-unit>
        <trans-unit id="f94b6ab9fb3640d8233848ba38c368f3d8f60f94" translate="yes" xml:space="preserve">
          <source>In TypeScript, this becomes very natural once you realize that every type is just a set. How do you describe a value that either belongs in the &lt;code&gt;string&lt;/code&gt; set or the &lt;code&gt;number&lt;/code&gt; set? It simply belongs to the &lt;em&gt;union&lt;/em&gt; of those sets: &lt;code&gt;string | number&lt;/code&gt;.</source>
          <target state="translated">TypeScriptでは、すべての型が単なるセットであることに気付くと、これは非常に自然になります。 &lt;code&gt;string&lt;/code&gt; セットまたは &lt;code&gt;number&lt;/code&gt; セットのいずれかに属する値をどのように説明しますか？それは単にそれらのセットの&lt;em&gt;和集合&lt;/em&gt;に属します： &lt;code&gt;string | number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01387e736054bef643d83587b4cbec5e0463e320" translate="yes" xml:space="preserve">
          <source>In TypeScript, union types are untagged. In other words, they are not discriminated unions like &lt;code&gt;data&lt;/code&gt; in Haskell. However, you can often discriminate types in a union using built-in tags or other properties.</source>
          <target state="translated">TypeScriptでは、共用体型はタグなしです。言い換えれば、Haskellの &lt;code&gt;data&lt;/code&gt; ように区別された共用体ではありません。ただし、多くの場合、組み込みのタグやその他のプロパティを使用して、共用体の型を区別できます。</target>
        </trans-unit>
        <trans-unit id="ee7d94eb215257ba5c8ab795047cbaba376a919d" translate="yes" xml:space="preserve">
          <source>In TypeScript, we can also set a value that a parameter will be assigned if the user does not provide one, or if the user passes &lt;code&gt;undefined&lt;/code&gt; in its place. These are called default-initialized parameters. Let&amp;rsquo;s take the previous example and default the last name to &lt;code&gt;&quot;Smith&quot;&lt;/code&gt;.</source>
          <target state="translated">TypeScriptでは、ユーザーが値を指定しなかった場合、またはユーザーがその場所に &lt;code&gt;undefined&lt;/code&gt; を渡した場合にパラメーターに割り当てられる値を設定することもできます。これらは、デフォルトで初期化されたパラメーターと呼ばれます。前の例で、姓のデフォルトを &lt;code&gt;&quot;Smith&quot;&lt;/code&gt; にしましょう。</target>
        </trans-unit>
        <trans-unit id="9b2996a620036d35453f4c7abf1fb3f20ef36789" translate="yes" xml:space="preserve">
          <source>In TypeScript, we can use common object-oriented patterns. One of the most fundamental patterns in class-based programming is being able to extend existing classes to create new ones using inheritance.</source>
          <target state="translated">TypeScriptでは、一般的なオブジェクト指向のパターンを使うことができます。クラスベースのプログラミングにおける最も基本的なパターンの一つは、継承を使って既存のクラスを拡張して新しいクラスを作成できることです。</target>
        </trans-unit>
        <trans-unit id="e8e346034f4b9c87e315e751122dc5fbf7c51de0" translate="yes" xml:space="preserve">
          <source>In TypeScript, when you reference a &lt;code&gt;const enum&lt;/code&gt; member, the reference is replaced by its actual value in the emitted JavaScript. Changing this TypeScript:</source>
          <target state="translated">TypeScriptでは、 &lt;code&gt;const enum&lt;/code&gt; メンバーを参照すると、その参照は、発行されたJavaScriptの実際の値に置き換えられます。このTypeScriptの変更：</target>
        </trans-unit>
        <trans-unit id="f733ba5e652ea7387ab081ac7b355a5f8b8f5005" translate="yes" xml:space="preserve">
          <source>In TypeScript, you can gather these arguments together into a variable:</source>
          <target state="translated">TypeScriptでは、これらの引数を変数にまとめることができます。</target>
        </trans-unit>
        <trans-unit id="a2921849633d9d452ad28f4123936c20449f9b7e" translate="yes" xml:space="preserve">
          <source>In TypeScript, you can import a &lt;em&gt;type&lt;/em&gt; and then subsequently export it:</source>
          <target state="translated">TypeScriptでは、&lt;em&gt;タイプ&lt;/em&gt;をインポートしてからエクスポートできます。</target>
        </trans-unit>
        <trans-unit id="55204c277d20a924ef143d3605b8feaf73f1f390" translate="yes" xml:space="preserve">
          <source>In TypeScript, you can model this with the &lt;code&gt;export =&lt;/code&gt; construct.</source>
          <target state="translated">TypeScriptでは、これを &lt;code&gt;export =&lt;/code&gt; 構文でモデル化できます。</target>
        </trans-unit>
        <trans-unit id="27303aa11138b00840e8f1322a88fdb13ab539ac" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, TypeScript understands the CommonJS module format. Assignments to &lt;code&gt;exports&lt;/code&gt; and &lt;code&gt;module.exports&lt;/code&gt; are recognized as export declarations. Similarly, &lt;code&gt;require&lt;/code&gt; function calls are recognized as module imports. For example:</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; ファイルに、活字体はCommonJSモジュール形式を理解しています。 &lt;code&gt;exports&lt;/code&gt; および &lt;code&gt;module.exports&lt;/code&gt; への割り当ては、エクスポート宣言として認識されます。同様に、 &lt;code&gt;require&lt;/code&gt; 関数呼び出しはモジュールインポートとして認識されます。例えば：</target>
        </trans-unit>
        <trans-unit id="82c14892013104e9e43fd9bdca12513d567a243f" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, Typescript understands the CommonJS module format. Assignments to &lt;code&gt;exports&lt;/code&gt; and &lt;code&gt;module.exports&lt;/code&gt; are recognized as export declarations. Similarly, &lt;code&gt;require&lt;/code&gt; function calls are recognized as module imports. For example:</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; は、.jsファイルでCommonJSモジュール形式を理解します。 &lt;code&gt;exports&lt;/code&gt; および &lt;code&gt;module.exports&lt;/code&gt; への割り当ては、エクスポート宣言として認識されます。同様に、 &lt;code&gt;require&lt;/code&gt; 関数呼び出しはモジュールのインポートとして認識されます。例えば：</target>
        </trans-unit>
        <trans-unit id="b54a4161a63a1b96ee32a30fced932fa18ccb0eb" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, the compiler infers properties from property assignments inside the class body. The type of a property is the type given in the constructor, unless it&amp;rsquo;s not defined there, or the type in the constructor is undefined or null. In that case, the type is the union of the types of all the right-hand values in these assignments. Properties defined in the constructor are always assumed to exist, whereas ones defined just in methods, getters, or setters are considered optional.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; ファイル、クラス本体内部のプロパティの割り当てからコンパイラの推論のプロパティ。プロパティのタイプは、そこで定義されていないか、コンストラクターのタイプが未定義またはnullでない限り、コンストラクターで指定されたタイプです。その場合、型はこれらの割り当てのすべての右辺値の型の和集合です。コンストラクタで定義されたプロパティは常に存在すると見なされますが、メソッド、ゲッター、セッターでのみ定義されたプロパティはオプションと見なされます。</target>
        </trans-unit>
        <trans-unit id="b1aec57e38f0bba34cdcf5755b6607c4fa3eaad1" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, types can often be inferred just like in &lt;code&gt;.ts&lt;/code&gt; files. Likewise, when types can&amp;rsquo;t be inferred, they can be specified using JSDoc the same way that type annotations are used in a &lt;code&gt;.ts&lt;/code&gt; file. Just like Typescript, &lt;code&gt;--noImplicitAny&lt;/code&gt; will give you errors on the places that the compiler could not infer a type. (With the exception of open-ended object literals; see below for details.)</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; ファイル、種類は多くの場合、ちょうどのように推測できる &lt;code&gt;.ts&lt;/code&gt; ファイル。同様に、型が推論できない場合、型注釈を &lt;code&gt;.ts&lt;/code&gt; ファイルで使用するのと同じ方法で、JSDocを使用して型を指定できます。 &lt;code&gt;--noImplicitAny&lt;/code&gt; と同様に、-noImplicitAnyは、コンパイラが型を推測できなかった場所でエラーを表示します。 （オープンエンドオブジェクトリテラルを除いて、詳細については以下を参照してください。）</target>
        </trans-unit>
        <trans-unit id="25a5bd4d9bac97fbf88351aa757a14e4470bc35e" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, types can often be inferred. When types can&amp;rsquo;t be inferred, they can be specified using JSDoc syntax.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; ファイル、種類は多くの場合、推測することができます。型を推測できない場合は、JSDoc構文を使用して指定できます。</target>
        </trans-unit>
        <trans-unit id="499d42e07e1a5b7dd4bdd55bbff5c492132e6ecc" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.ts&lt;/code&gt; file, an object literal that initializes a variable declaration gives its type to the declaration. No new members can be added that were not specified in the original literal. This rule is relaxed in a &lt;code&gt;.js&lt;/code&gt; file; object literals have an open-ended type (an index signature) that allows adding and looking up properties that were not defined originally. For instance:</source>
          <target state="translated">&lt;code&gt;.ts&lt;/code&gt; ファイル、変数宣言を初期化するオブジェクトリテラルは、宣言にその型を与えます。元のリテラルで指定されていなかった新しいメンバーを追加することはできません。このルールは &lt;code&gt;.js&lt;/code&gt; ファイルで緩和されています。オブジェクトリテラルには、元々定義されていなかったプロパティを追加および検索できる、制限のない型（インデックスシグネチャ）があります。例えば：</target>
        </trans-unit>
        <trans-unit id="faa28e2f1cd18a9e6940ea8f152a75b8bef80372" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;for...in&lt;/code&gt; statement for an object of a generic type &lt;code&gt;T&lt;/code&gt;, the inferred type of the iteration variable was previously &lt;code&gt;keyof T&lt;/code&gt; but is now &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt;. (In other words, the subset of &lt;code&gt;keyof T&lt;/code&gt; that includes only string-like values.)</source>
          <target state="translated">&lt;code&gt;for...in&lt;/code&gt; ジェネリック型のオブジェクトに対する声明 &lt;code&gt;T&lt;/code&gt; 、反復変数の推論された型が以前いた &lt;code&gt;keyof T&lt;/code&gt; が、現在され &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; 。（つまり、文字列のような値のみを含む &lt;code&gt;keyof T&lt;/code&gt; のサブセットです。）</target>
        </trans-unit>
        <trans-unit id="94a6c7abfee16098b91b6afd7d77f2cffbbb0188" translate="yes" xml:space="preserve">
          <source>In a function expression or arrow function with no return type annotation, if the function has no &lt;code&gt;return&lt;/code&gt; statements, or only &lt;code&gt;return&lt;/code&gt; statements with expressions of type &lt;code&gt;never&lt;/code&gt;, and if the end point of the function is not reachable (as determined by control flow analysis), the inferred return type for the function is &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">戻り値の型注釈のない関数式または矢印関数で、関数に &lt;code&gt;return&lt;/code&gt; ステートメントがないか、 &lt;code&gt;never&lt;/code&gt; 型の式を持つ &lt;code&gt;return&lt;/code&gt; ステートメントのみであり、関数のエンドポイントに到達できない場合（制御フロー分析により決定） 、関数の推定戻り型は &lt;code&gt;never&lt;/code&gt; ありません。</target>
        </trans-unit>
        <trans-unit id="a98314a0bada662b45a18394f388ee15a3db9842" translate="yes" xml:space="preserve">
          <source>In a function with an explicit &lt;code&gt;never&lt;/code&gt; return type annotation, all &lt;code&gt;return&lt;/code&gt; statements (if any) must have expressions of type &lt;code&gt;never&lt;/code&gt; and the end point of the function must not be reachable.</source>
          <target state="translated">明示的な「 &lt;code&gt;never&lt;/code&gt; 戻り値を返さない」型の注釈を持つ関数では、すべての &lt;code&gt;return&lt;/code&gt; ステートメント（存在する場合）に「 &lt;code&gt;never&lt;/code&gt; 型の式」が含まれている必要があり、関数のエンドポイントに到達できてはなりません。</target>
        </trans-unit>
        <trans-unit id="f21005b5571e17a92c2f4c810bdd49f11c28d379" translate="yes" xml:space="preserve">
          <source>In a mapped type &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt;, each string literal type in &lt;code&gt;K&lt;/code&gt; introduces a property with a string name, each numeric literal type in &lt;code&gt;K&lt;/code&gt; introduces a property with a numeric name, and each unique symbol type in &lt;code&gt;K&lt;/code&gt; introduces a property with a unique symbol name. Furthermore, if &lt;code&gt;K&lt;/code&gt; includes type &lt;code&gt;string&lt;/code&gt;, a string index signature is introduced, and if &lt;code&gt;K&lt;/code&gt; includes type &lt;code&gt;number&lt;/code&gt;, a numeric index signature is introduced.</source>
          <target state="translated">マッピングされたタイプで &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt; 、の各文字列リテラルタイプ &lt;code&gt;K&lt;/code&gt; は、文字列名を持つプロパティを導入し、各数値リテラルタイプ &lt;code&gt;K&lt;/code&gt; は、数値名とプロパティを導入し、そして内の各一意シンボルタイプ &lt;code&gt;K&lt;/code&gt; の紹介一意のシンボル名を持つプロパティ。さらに、 &lt;code&gt;K&lt;/code&gt; が &lt;code&gt;string&lt;/code&gt; 型を含む場合、文字列インデックスシグネチャが導入され、 &lt;code&gt;K&lt;/code&gt; が &lt;code&gt;number&lt;/code&gt; 含む場合、数値インデックスシグネチャが導入されます。</target>
        </trans-unit>
        <trans-unit id="c902ce3f09f34d229a3e2897a358abb3f93aff0a" translate="yes" xml:space="preserve">
          <source>In a sense, the definite assignment assertion operator is the dual of the non-null assertion operator (in which &lt;em&gt;expressions&lt;/em&gt; are post-fixed with a &lt;code&gt;!&lt;/code&gt;), which we could also have used in the example.</source>
          <target state="translated">ある意味では、明確な代入アサーション演算子は、nullでないアサーション演算子（&lt;em&gt;式&lt;/em&gt;が &lt;code&gt;!&lt;/code&gt; で後置修飾されている）の双対であり、この例でも使用できます。</target>
        </trans-unit>
        <trans-unit id="51dd880d34f252e0aeb77f1d88f4eba9a15ee3cc" translate="yes" xml:space="preserve">
          <source>In a similar example, we may want to move the generic parameter to be a parameter of the whole interface. This lets us see what type(s) we&amp;rsquo;re generic over (e.g. &lt;code&gt;Dictionary&amp;lt;string&amp;gt;&lt;/code&gt; rather than just &lt;code&gt;Dictionary&lt;/code&gt;). This makes the type parameter visible to all the other members of the interface.</source>
          <target state="translated">同様の例で、ジェネリックパラメーターをインターフェイス全体のパラメーターに移動することができます。これは、私たちはどのようなタイプ（S）我々している一般的なオーバー（例えば見ることができます &lt;code&gt;Dictionary&amp;lt;string&amp;gt;&lt;/code&gt; というだけよりも &lt;code&gt;Dictionary&lt;/code&gt; ）。これにより、typeパラメータがインターフェイスの他のすべてのメンバーに表示されます。</target>
        </trans-unit>
        <trans-unit id="f73ef161e383c012e8b216e70c23095705c0088c" translate="yes" xml:space="preserve">
          <source>In a structural type system, if two objects have the same shape, they are considered to be of the same type.</source>
          <target state="translated">構造型システムでは、2つのオブジェクトが同じ形をしている場合、それらは同じ型であると考えられます。</target>
        </trans-unit>
        <trans-unit id="7aae1c23f28d25359f684353160aa338cdad63b7" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;AMD&lt;/code&gt; and &lt;code&gt;CommonJS&lt;/code&gt; module loaders, TypeScript now supports emitting modules &lt;code&gt;UMD&lt;/code&gt; (&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;Universal Module Definition&lt;/a&gt;) and &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;&lt;code&gt;System&lt;/code&gt;&lt;/a&gt; module formats.</source>
          <target state="translated">&lt;code&gt;AMD&lt;/code&gt; および &lt;code&gt;CommonJS&lt;/code&gt; モジュールローダーに加えて、TypeScriptはモジュール &lt;code&gt;UMD&lt;/code&gt; （&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;Universal Module Definition&lt;/a&gt;）と&lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt; &lt;code&gt;System&lt;/code&gt; &lt;/a&gt;モジュール形式の出力をサポートするようになりました。</target>
        </trans-unit>
        <trans-unit id="5006f44bee52625a6ab0a4a313b0d7e2fc88612c" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;Partial&lt;/code&gt;, Mapped Types can express many useful transformations on types:</source>
          <target state="translated">&lt;code&gt;Partial&lt;/code&gt; に加えて、マップされたタイプは、タイプに対する多くの有用な変換を表現できます。</target>
        </trans-unit>
        <trans-unit id="191adf935ed2ac18958fb4641280ef26e69e454d" translate="yes" xml:space="preserve">
          <source>In addition to compositional patterns like the above, this new inference on generic constructors means that functions that operate on class components in certain UI libraries like React can more correctly operate on generic class components.</source>
          <target state="translated">上記のような構成パターンに加えて、ジェネリックなコンストラクタに関するこの新しい推論は、Reactのような特定のUIライブラリのクラスコンポーネント上で動作する関数が、ジェネリックなクラスコンポーネント上でより正しく動作することを意味します。</target>
        </trans-unit>
        <trans-unit id="1a90a08e2836eebeca011762ffd80aadcf5c05eb" translate="yes" xml:space="preserve">
          <source>In addition to creating an object with property names for members, numeric enums members also get a &lt;em&gt;reverse mapping&lt;/em&gt; from enum values to enum names. For example, in this example:</source>
          <target state="translated">メンバーのプロパティ名を持つオブジェクトを作成することに加えて、数値列挙メンバーは列挙値から列挙名への&lt;em&gt;逆マッピング&lt;/em&gt;も取得します。たとえば、この例では：</target>
        </trans-unit>
        <trans-unit id="9ed91b41f41b6bffe64ebf951bfee935b8c06725" translate="yes" xml:space="preserve">
          <source>In addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and namespaces.</source>
          <target state="translated">一般的なインターフェースに加えて、一般的なクラスを作成することもできます。ジェネリックな列挙型や名前空間を作成することはできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="ca19e30943988803be9117e262453a87e81dfc67" translate="yes" xml:space="preserve">
          <source>In addition to that, Babel cannot create &lt;code&gt;.d.ts&lt;/code&gt; files for your TypeScript which can make it harder to work with your project if it is a library.</source>
          <target state="translated">それに加えて、BabelはTypeScript用の &lt;code&gt;.d.ts&lt;/code&gt; ファイルを作成できないため、プロジェクトがライブラリの場合、プロジェクトの操作が難しくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="d1e90cce3e41b4e86a90a13f73336c6deb38037e" translate="yes" xml:space="preserve">
          <source>In addition to the existing TypeScript support for decorating declarations with &lt;code&gt;export&lt;/code&gt;, module members can also be exported using separate export declarations, optionally specifying different names for exports using &lt;code&gt;as&lt;/code&gt; clauses.</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; を使用して宣言を装飾するための既存のTypeScriptサポートに加えて、モジュールメンバーは個別のエクスポート宣言を使用してエクスポートすることもでき、オプションで &lt;code&gt;as&lt;/code&gt; 句を使用してエクスポートに異なる名前を指定できます。</target>
        </trans-unit>
        <trans-unit id="5fc2368a23b5c630c12625ea45cc7ece18d41984" translate="yes" xml:space="preserve">
          <source>In addition to the pattern of inner classes, you may also be familiar with the JavaScript practice of creating a function and then extending the function further by adding properties onto the function. TypeScript uses declaration merging to build up definitions like this in a type-safe way.</source>
          <target state="translated">インナークラスのパターンに加えて、関数を作成し、その関数にプロパティを追加してさらに関数を拡張するという JavaScript の慣習にも精通しているかもしれません。TypeScriptでは、このような定義を型安全な方法で構築するために宣言のマージを使用しています。</target>
        </trans-unit>
        <trans-unit id="87ddb0a5f5f96059703ab579dd4aebc339c8a186" translate="yes" xml:space="preserve">
          <source>In addition to unions, TypeScript also has intersections:</source>
          <target state="translated">ユニオンに加えて、TypeScriptには交点もあります。</target>
        </trans-unit>
        <trans-unit id="64dd39fbc1176fa7cb78d499e27b42f425e4f288" translate="yes" xml:space="preserve">
          <source>In addition to user-defined symbols, there are well-known built-in symbols. Built-in symbols are used to represent internal language behaviors.</source>
          <target state="translated">ユーザー定義のシンボルに加えて、よく知られている組み込みシンボルがあります。組み込みシンボルは、内部の言語動作を表現するために使用されます。</target>
        </trans-unit>
        <trans-unit id="af6dc8ce595252f91c362798795d00c0d72386ed" translate="yes" xml:space="preserve">
          <source>In addition, entities are &lt;em&gt;implicitly&lt;/em&gt; read-only in several situations:</source>
          <target state="translated">さらに、エンティティはいくつかの状況で&lt;em&gt;暗黙的に&lt;/em&gt;読み取り専用になります。</target>
        </trans-unit>
        <trans-unit id="f13cadd149f177816bfcd1f47e7199c8a2dd824c" translate="yes" xml:space="preserve">
          <source>In all other cases enum member is considered computed.</source>
          <target state="translated">それ以外のすべての場合、enum メンバは計算されたものとみなされます。</target>
        </trans-unit>
        <trans-unit id="afe27faa913e56241e9fef79caeefb4719b9d97b" translate="yes" xml:space="preserve">
          <source>In cases where the compiler can&amp;rsquo;t eliminate &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the type assertion operator to manually remove them. The syntax is postfix &lt;code&gt;!&lt;/code&gt;: &lt;code&gt;identifier!&lt;/code&gt; removes &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from the type of &lt;code&gt;identifier&lt;/code&gt;:</source>
          <target state="translated">コンパイラーが &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; を削除できない場合は、型アサーション演算子を使用して手動で削除できます。構文は後置 &lt;code&gt;!&lt;/code&gt; ： &lt;code&gt;identifier!&lt;/code&gt; &lt;code&gt;identifier&lt;/code&gt; のタイプから &lt;code&gt;null&lt;/code&gt; および &lt;code&gt;undefined&lt;/code&gt; を削除します。</target>
        </trans-unit>
        <trans-unit id="772971872a07a06b821a02e99558860d312742f3" translate="yes" xml:space="preserve">
          <source>In cases where you don&amp;rsquo;t know what type you want to accept, or when you want to accept anything because you will be blindly passing it through without interacting with it, you can use &lt;a href=&quot;https://www.typescriptlang.org/play/#example/unknown-and-never&quot;&gt;&lt;code&gt;unknown&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">受け入れたいタイプがわからない場合や、対話せずに盲目的に通過するために何かを受け入れたい場合は、&lt;a href=&quot;https://www.typescriptlang.org/play/#example/unknown-and-never&quot;&gt; &lt;code&gt;unknown&lt;/code&gt; &lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="46e7cfaa389b12ae897eb1224615c0bd3a3a74e0" translate="yes" xml:space="preserve">
          <source>In earlier versions of TypeScript, we generalized mapped types to operate differently on array-like types. This meant that a mapped type like &lt;code&gt;Boxify&lt;/code&gt; could work on arrays and tuples alike.</source>
          <target state="translated">TypeScriptの以前のバージョンでは、配列のような型に対して異なる動作をするようにマップ型を一般化しました。これは、 &lt;code&gt;Boxify&lt;/code&gt; のようなマップされた型が配列とタプルで同様に機能することを意味しました。</target>
        </trans-unit>
        <trans-unit id="d3125ad49c86be35f677e4c8afe1f401c2f39f09" translate="yes" xml:space="preserve">
          <source>In exact terms, the &lt;code&gt;--strict&lt;/code&gt; option sets the &lt;em&gt;default&lt;/em&gt; value for the compiler options listed above. This means it is still possible to individually control the options. For example,</source>
          <target state="translated">正確に言えば、 &lt;code&gt;--strict&lt;/code&gt; オプションは、上記のコンパイラオプションの&lt;em&gt;デフォルト&lt;/em&gt;値を設定し&lt;em&gt;ます&lt;/em&gt;。つまり、オプションを個別に制御することは可能です。例えば、</target>
        </trans-unit>
        <trans-unit id="f8bbd9b4c8e18d955c59e1b9bb4bd269b6054dc3" translate="yes" xml:space="preserve">
          <source>In extends clause</source>
          <target state="translated">拡張句では</target>
        </trans-unit>
        <trans-unit id="317805e6e63ca60bc3ca9fd2d268f7e654b8cbb1" translate="yes" xml:space="preserve">
          <source>In function calls</source>
          <target state="translated">関数呼び出しでは</target>
        </trans-unit>
        <trans-unit id="c33d3561ce65af4351cdeaf45173b07c0b043d0d" translate="yes" xml:space="preserve">
          <source>In general, not much is needed to transition a repo using relative modules. Simply place a &lt;code&gt;tsconfig.json&lt;/code&gt; file in each subdirectory of a given parent folder, and add &lt;code&gt;reference&lt;/code&gt;s to these config files to match the intended layering of the program. You will need to either set the &lt;code&gt;outDir&lt;/code&gt; to an explicit subfolder of the output folder, or set the &lt;code&gt;rootDir&lt;/code&gt; to the common root of all project folders.</source>
          <target state="translated">一般に、相対モジュールを使用してリポジトリを移行するために必要なものはそれほど多くありません。単に置く &lt;code&gt;tsconfig.json&lt;/code&gt; の指定された親フォルダの各サブディレクトリ内のファイルを、そして追加 &lt;code&gt;reference&lt;/code&gt; プログラムの積層意図と一致するようにこれらの設定ファイルに複数可。あなたはどちらかに設定する必要があります &lt;code&gt;outDir&lt;/code&gt; 出力フォルダの明示的なサブフォルダに、または設定 &lt;code&gt;rootDir&lt;/code&gt; すべてのプロジェクトのフォルダの共通のルートに。</target>
        </trans-unit>
        <trans-unit id="b1625c54a8a7392317454ab8180d6577f1b9ae1b" translate="yes" xml:space="preserve">
          <source>In instantiations of a distributive conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt;, references to &lt;code&gt;T&lt;/code&gt; within the conditional type are resolved to individual constituents of the union type (i.e. &lt;code&gt;T&lt;/code&gt; refers to the individual constituents &lt;em&gt;after&lt;/em&gt; the conditional type is distributed over the union type). Furthermore, references to &lt;code&gt;T&lt;/code&gt; within &lt;code&gt;X&lt;/code&gt; have an additional type parameter constraint &lt;code&gt;U&lt;/code&gt; (i.e. &lt;code&gt;T&lt;/code&gt; is considered assignable to &lt;code&gt;U&lt;/code&gt; within &lt;code&gt;X&lt;/code&gt;).</source>
          <target state="translated">分布条件型のインスタンス化では、 &lt;code&gt;T extends U ? X : Y&lt;/code&gt; 、条件タイプ内の &lt;code&gt;T&lt;/code&gt; への参照は、共用体タイプの個々の構成要素に解決されます（つまり、 &lt;code&gt;T&lt;/code&gt; は、条件タイプが共用体タイプに分散された&lt;em&gt;後&lt;/em&gt;の個々の構成要素を指します）。さらに、 &lt;code&gt;X&lt;/code&gt; 内の &lt;code&gt;T&lt;/code&gt; への参照には、追加の型パラメーター制約 &lt;code&gt;U&lt;/code&gt; があります（つまり、 &lt;code&gt;T&lt;/code&gt; は &lt;code&gt;X&lt;/code&gt; 内の &lt;code&gt;U&lt;/code&gt; に割り当て可能と見なされます）。</target>
        </trans-unit>
        <trans-unit id="ade42fc57c0936ec5b4a222b5c45022a1c4760c5" translate="yes" xml:space="preserve">
          <source>In languages like C# and Java, one of the main tools in the toolbox for creating reusable components is &lt;em&gt;generics&lt;/em&gt;, that is, being able to create a component that can work over a variety of types rather than a single one. This allows users to consume these components and use their own types.</source>
          <target state="translated">C＃やJavaなどの言語では、再利用可能なコンポーネントを作成するためのツールボックスの主要なツールの1つが&lt;em&gt;ジェネリックです&lt;/em&gt;。つまり、単一のコンポーネントではなく、さまざまなタイプで機能するコンポーネントを作成できます。これにより、ユーザーはこれらのコンポーネントを使用し、独自のタイプを使用できます。</target>
        </trans-unit>
        <trans-unit id="5c5505a3474915f4cc4c566956af416ee322aa67" translate="yes" xml:space="preserve">
          <source>In most cases, enums are a perfectly valid solution. However sometimes requirements are tighter. To avoid paying the cost of extra generated code and additional indirection when accessing enum values, it&amp;rsquo;s possible to use &lt;code&gt;const&lt;/code&gt; enums. Const enums are defined using the &lt;code&gt;const&lt;/code&gt; modifier on our enums:</source>
          <target state="translated">ほとんどの場合、列挙型は完全に有効なソリューションです。ただし、要件が厳しい場合もあります。enum値にアクセスするときに追加の生成コードと追加の間接参照のコストを支払うことを避けるために、 &lt;code&gt;const&lt;/code&gt; enum を使用することが可能です。 &lt;code&gt;const&lt;/code&gt; 列挙型は、列挙型のconst修飾子を使用して定義されます。</target>
        </trans-unit>
        <trans-unit id="9977fd8d646f7ee47ce74c49df2a1398accb087c" translate="yes" xml:space="preserve">
          <source>In most cases, type inference is straightforward. In the following sections, we&amp;rsquo;ll explore some of the nuances in how types are inferred.</source>
          <target state="translated">ほとんどの場合、型推論は簡単です。次のセクションでは、型がどのように推論されるかについて、いくつかのニュアンスを探ります。</target>
        </trans-unit>
        <trans-unit id="8275babe4b4f5b3a44f6ddcca26a506ab31a4496" translate="yes" xml:space="preserve">
          <source>In multi-project TypeScript programs, TypeScript will load all of the available projects into memory in order to provide accurate results for editor responses which require a full knowledge graph like &amp;lsquo;Find All References&amp;rsquo;.</source>
          <target state="translated">マルチプロジェクトTypeScriptプログラムでは、TypeScriptは、「すべての参照を検索」などの完全な知識グラフを必要とするエディターの応答に対して正確な結果を提供するために、使用可能なすべてのプロジェクトをメモリにロードします。</target>
        </trans-unit>
        <trans-unit id="49e5eb0fe073a6b366d084def4b417b2dc17ba91" translate="yes" xml:space="preserve">
          <source>In nominally-typed languages like C# or Java, the equivalent code would be an error because the &lt;code&gt;Person&lt;/code&gt; class does not explicitly describe itself as being an implementer of the &lt;code&gt;Named&lt;/code&gt; interface.</source>
          <target state="translated">C＃やJavaなどの名目上型付けされた言語では、 &lt;code&gt;Person&lt;/code&gt; クラスは自身を &lt;code&gt;Named&lt;/code&gt; インターフェイスの実装者として明示的に記述しないため、同等のコードはエラーになります。</target>
        </trans-unit>
        <trans-unit id="6cd6a1cda7b4b6dafff0249316846cd737bb057b" translate="yes" xml:space="preserve">
          <source>In older versions of TypeScript, type aliases couldn&amp;rsquo;t be extended or implemented from (nor could they extend/implement other types). As of version 2.7, type aliases can be extended by creating a new intersection type e.g. &lt;code&gt;type Cat = Animal &amp;amp; { purrs: true }&lt;/code&gt;.</source>
          <target state="translated">TypeScriptの古いバージョンでは、型エイリアスを拡張または実装することはできませんでした（他の型を拡張/実装することもできませんでした）。バージョン2.7以降、タイプエイリアスは、新しい交差タイプを作成することで拡張できます。たとえば、 &lt;code&gt;type Cat = Animal &amp;amp; { purrs: true }&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4485cefc41070d0508c8ae3601f889e0c3ca550d" translate="yes" xml:space="preserve">
          <source>In older versions, TypeScript would infer the empty object type (&lt;code&gt;{}&lt;/code&gt;) when inferring from other type variables like &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">古いバージョンでは、TypeScriptは &lt;code&gt;T&lt;/code&gt; や &lt;code&gt;U&lt;/code&gt; などの他の型変数から推論するときに、空のオブジェクト型（ &lt;code&gt;{}&lt;/code&gt; ）を推論していました。</target>
        </trans-unit>
        <trans-unit id="3becc57b3af3b6f00aff1c308abe30fb09b363bc" translate="yes" xml:space="preserve">
          <source>In order for the compiler to pick the correct type check, it follows a similar process to the underlying JavaScript. It looks at the overload list and, proceeding with the first overload, attempts to call the function with the provided parameters. If it finds a match, it picks this overload as the correct overload. For this reason, it&amp;rsquo;s customary to order overloads from most specific to least specific.</source>
          <target state="translated">コンパイラーが正しい型チェックを選択するために、基礎となるJavaScriptと同様のプロセスに従います。オーバーロードリストを確認し、最初のオーバーロードに進み、指定されたパラメーターを使用して関数を呼び出そうとします。一致が見つかると、このオーバーロードが正しいオーバーロードとして選択されます。このため、通常は、オーバーロードを最も具体的なものから最も具体的でないものへと並べます。</target>
        </trans-unit>
        <trans-unit id="ec884edde65bedd374e2043ee3584a67f5dd3d21" translate="yes" xml:space="preserve">
          <source>In order to ensure that a function never potentially returned &lt;code&gt;undefined&lt;/code&gt; or effectively returned from all code paths, TypeScript needed some syntactic signal - either a &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;throw&lt;/code&gt; at the end of a function. So users found themselves &lt;code&gt;return&lt;/code&gt;-ing their failure functions.</source>
          <target state="translated">関数が &lt;code&gt;undefined&lt;/code&gt; またはすべてのコードパスから効果的に返されない可能性があることを確実にするために、TypeScriptには、関数の最後での &lt;code&gt;return&lt;/code&gt; または &lt;code&gt;throw&lt;/code&gt; のような構文信号が必要でした。したがって、ユーザーは自分の失敗関数を &lt;code&gt;return&lt;/code&gt; 気づきました。</target>
        </trans-unit>
        <trans-unit id="a5553c9db2df72c8e161b64c0bb7751b40bdbd3c" translate="yes" xml:space="preserve">
          <source>In order to provide rich debugging tools and crash reports which make sense to developers, TypeScript supports emitting additional files which conform to the JavaScript Source Map standards.</source>
          <target state="translated">開発者にとって意味のある豊富なデバッグツールやクラッシュレポートを提供するために、TypeScriptはJavaScriptのソースマップ標準に準拠した追加ファイルの発行をサポートしています。</target>
        </trans-unit>
        <trans-unit id="7a30e2c325b4e7b632ea33292d372bb91480fbed" translate="yes" xml:space="preserve">
          <source>In order to understand type checking with JSX, you must first understand the difference between intrinsic elements and value-based elements. Given a JSX expression &lt;code&gt;&amp;lt;expr /&amp;gt;&lt;/code&gt;, &lt;code&gt;expr&lt;/code&gt; may either refer to something intrinsic to the environment (e.g. a &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;span&lt;/code&gt; in a DOM environment) or to a custom component that you&amp;rsquo;ve created. This is important for two reasons:</source>
          <target state="translated">JSXでの型チェックを理解するには、最初に組み込み要素と値ベースの要素の違いを理解する必要があります。JSX式 &lt;code&gt;&amp;lt;expr /&amp;gt;&lt;/code&gt; を指定すると、 &lt;code&gt;expr&lt;/code&gt; は環境に固有の何か（たとえば、DOM環境の &lt;code&gt;div&lt;/code&gt; または &lt;code&gt;span&lt;/code&gt; ）、または作成したカスタムコンポーネントのいずれかを参照できます。これは2つの理由で重要です。</target>
        </trans-unit>
        <trans-unit id="2c6b1f2bc59ac8b4cd64d29de8b2d3e100cb6d4f" translate="yes" xml:space="preserve">
          <source>In order to use JSX you must do two things.</source>
          <target state="translated">JSXを使うためには、次の2つのことをしなければなりません。</target>
        </trans-unit>
        <trans-unit id="2425b2f241ed01dc603f0c439b76c219ccaf89d0" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;x&lt;/code&gt; must be &lt;code&gt;1&lt;/code&gt; when it gets compared to &lt;code&gt;2&lt;/code&gt;, meaning that the above check is making an invalid comparison.</source>
          <target state="translated">言い換えると、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;2&lt;/code&gt; と比較されるときに &lt;code&gt;1&lt;/code&gt; でなければなりません。これは、上記のチェックが無効な比較を行っていることを意味します。</target>
        </trans-unit>
        <trans-unit id="7e1538e5dd442871789cc5ecc7783750fa78d9ea" translate="yes" xml:space="preserve">
          <source>In other words, TypeScript now catches the above bug, which may be a breaking change for some users, but will largely be helpful.</source>
          <target state="translated">言い換えれば、TypeScript は上記のバグをキャッチするようになったので、一部のユーザにとっては画期的な変更かもしれませんが、大部分は役に立つでしょう。</target>
        </trans-unit>
        <trans-unit id="93e13237760bfc497efa3e019beaf296fba0f599" translate="yes" xml:space="preserve">
          <source>In other words, hitting go-to-definition on a declaration from a &lt;code&gt;.d.ts&lt;/code&gt; file generated with &lt;code&gt;--declarationMap&lt;/code&gt; will take you to the source file (&lt;code&gt;.ts&lt;/code&gt;) location where that declaration was defined, and not to the &lt;code&gt;.d.ts&lt;/code&gt;.</source>
          <target state="translated">つまり、 &lt;code&gt;.d.ts&lt;/code&gt; 生成された.d.tsファイルからの宣言でgo-to-definition を &lt;code&gt;--declarationMap&lt;/code&gt; と、その宣言が定義されたソースファイル（ &lt;code&gt;.ts&lt;/code&gt; ）の場所に移動し、 &lt;code&gt;.d.ts&lt;/code&gt; ではありません。 ts。</target>
        </trans-unit>
        <trans-unit id="4c2ced57a304d01037d71bbb4f8dbc6d272f4c53" translate="yes" xml:space="preserve">
          <source>In other words, instead of producing the type</source>
          <target state="translated">つまり、型を生成するのではなく</target>
        </trans-unit>
        <trans-unit id="13c9723a82ddbb23b59c0ac5eb80038fe61fb8ae" translate="yes" xml:space="preserve">
          <source>In our example, we knew that all uses of &lt;code&gt;x&lt;/code&gt; would be initialized so it makes more sense to use definite assignment assertions than non-null assertions.</source>
          <target state="translated">この例では、 &lt;code&gt;x&lt;/code&gt; のすべての使用が初期化されることがわかっているため、null以外のアサーションよりも明確な代入アサーションを使用する方が理にかなっています。</target>
        </trans-unit>
        <trans-unit id="e09a40d13c5b9150cdb7cb04b404685efc24c2e1" translate="yes" xml:space="preserve">
          <source>In our examples, we&amp;rsquo;ve been able to freely access the members that we declared throughout our programs. If you&amp;rsquo;re familiar with classes in other languages, you may have noticed in the above examples we haven&amp;rsquo;t had to use the word &lt;code&gt;public&lt;/code&gt; to accomplish this; for instance, C# requires that each member be explicitly labeled &lt;code&gt;public&lt;/code&gt; to be visible. In TypeScript, each member is &lt;code&gt;public&lt;/code&gt; by default.</source>
          <target state="translated">私たちの例では、プログラム全体で宣言したメンバーに自由にアクセスできました。他の言語のクラスに精通している場合は、上記の例で、これを実現するために &lt;code&gt;public&lt;/code&gt; という単語を使用する必要がないことに気付いたかもしれません。たとえば、C＃では、各メンバーを表示するために明示的に &lt;code&gt;public&lt;/code&gt; とラベル付けする必要があります。TypeScriptでは、各メンバーはデフォルトで &lt;code&gt;public&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="077f32db3171bafea36c02345fca8439c23de1f0" translate="yes" xml:space="preserve">
          <source>In our first example using interfaces, TypeScript lets us pass &lt;code&gt;{ size: number; label: string; }&lt;/code&gt; to something that only expected a &lt;code&gt;{ label: string; }&lt;/code&gt;. We also just learned about optional properties, and how they&amp;rsquo;re useful when describing so-called &amp;ldquo;option bags&amp;rdquo;.</source>
          <target state="translated">インターフェイスを使用する最初の例では、TypeScriptを使用して &lt;code&gt;{ size: number; label: string; }&lt;/code&gt; 、 &lt;code&gt;{ label: string; }&lt;/code&gt; のみを期待するものに変更します。}。また、オプションのプロパティと、いわゆる「オプションバッグ」を説明するときにそれらがどのように役立つかについても学びました。</target>
        </trans-unit>
        <trans-unit id="b5509d814ae50a61b30f1663160809aaacc3c863" translate="yes" xml:space="preserve">
          <source>In our last example, we had to declare a readonly member &lt;code&gt;name&lt;/code&gt; and a constructor parameter &lt;code&gt;theName&lt;/code&gt; in the &lt;code&gt;Octopus&lt;/code&gt; class. This is needed in order to have the value of &lt;code&gt;theName&lt;/code&gt; accessible after the &lt;code&gt;Octopus&lt;/code&gt; constructor is executed. &lt;em&gt;Parameter properties&lt;/em&gt; let you create and initialize a member in one place. Here&amp;rsquo;s a further revision of the previous &lt;code&gt;Octopus&lt;/code&gt; class using a parameter property:</source>
          <target state="translated">最後の例では、 &lt;code&gt;Octopus&lt;/code&gt; クラスで読み取り専用のメンバー &lt;code&gt;name&lt;/code&gt; とコンストラクターパラメータ &lt;code&gt;theName&lt;/code&gt; を宣言する必要がありました。これは、 &lt;code&gt;Octopus&lt;/code&gt; コンストラクターの実行後に &lt;code&gt;theName&lt;/code&gt; の値にアクセスできるようにするために必要です。&lt;em&gt;パラメータプロパティ&lt;/em&gt;を使用すると、メンバーを1か所で作成および初期化できます。以下は、パラメータプロパティを使用した以前の &lt;code&gt;Octopus&lt;/code&gt; クラスのさらなるリビジョンです。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2a7cf3a706d3a1af3a4cb37abf72ef77d6e4707" translate="yes" xml:space="preserve">
          <source>In playing with the example, you may notice that the TypeScript compiler can figure out the type even if you only have types on one side of the equation:</source>
          <target state="translated">この例で遊んでいると、式の片側にしか型がなくても、TypeScript コンパイラが型を把握できることに気づくかもしれません。</target>
        </trans-unit>
        <trans-unit id="9c1b4684fb04512e6c7b40289668510482450dd8" translate="yes" xml:space="preserve">
          <source>In practical terms, strict null checking mode requires that all files in a compilation are null- and undefined-aware.</source>
          <target state="translated">実用的には、厳密なヌルチェックモードでは、コンパイル中のすべてのファイルがヌルと未定義を認識している必要があります。</target>
        </trans-unit>
        <trans-unit id="948caf57846c2d397905854f03d5c34bfc0a420b" translate="yes" xml:space="preserve">
          <source>In practice string literal types combine nicely with union types, type guards, and type aliases. You can use these features together to get enum-like behavior with strings.</source>
          <target state="translated">実際には、文字列リテラル型はユニオン型、型ガード、型エイリアスとうまく結合します。これらの機能を併用することで、文字列で列挙型のような振る舞いを得ることができます。</target>
        </trans-unit>
        <trans-unit id="6bafe310667e5e4e7564369b651bf5008fd49779" translate="yes" xml:space="preserve">
          <source>In pre-ES2015 targets, the most faithful emit for constructs like &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;of&lt;/code&gt; loops and array spreads can be a bit heavy. For this reason, TypeScript uses a simpler emit by default that only supports array types, and supports iterating on other types using the &lt;code&gt;--downlevelIteration&lt;/code&gt; flag. The looser default without &lt;code&gt;--downlevelIteration&lt;/code&gt; works fairly well; however, there were some common cases where the transformation of array spreads had observable differences. For example, the following array containing a spread</source>
          <target state="translated">ES2015より前のターゲットでは、 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;of&lt;/code&gt; ループや配列の広がりなどの構造に対して最も忠実な出力が少し重くなる場合があります。このため、TypeScriptはデフォルトでより単純な出力を使用し、配列タイプのみをサポートし、 &lt;code&gt;--downlevelIteration&lt;/code&gt; フラグを使用して他のタイプの反復をサポートします。 &lt;code&gt;--downlevelIteration&lt;/code&gt; のない緩いデフォルトはかなりうまく機能します。ただし、配列スプレッドの変換に観察可能な違いがあるいくつかの一般的なケースがありました。たとえば、スプレッドを含む次の配列</target>
        </trans-unit>
        <trans-unit id="d8dc065deb2345b3fc2204f90ad4ee7eedf78bff" translate="yes" xml:space="preserve">
          <source>In previous sections, we created generic identity functions that worked over a range of types. In this section, we&amp;rsquo;ll explore the type of the functions themselves and how to create generic interfaces.</source>
          <target state="translated">前のセクションでは、さまざまなタイプで機能する一般的な識別関数を作成しました。このセクションでは、関数自体のタイプと、一般的なインターフェースの作成方法について説明します。</target>
        </trans-unit>
        <trans-unit id="f628a9f7456d28c2ae0af03d23563c657fc921e2" translate="yes" xml:space="preserve">
          <source>In previous versions of TypeScript, it was an error to merge classes and functions under any circumstances. Now, ambient classes and functions (classes/functions with the &lt;code&gt;declare&lt;/code&gt; modifier, or in &lt;code&gt;.d.ts&lt;/code&gt; files) can merge. This means that now you can write the following:</source>
          <target state="translated">TypeScriptの以前のバージョンでは、どのような状況でもクラスと関数をマージするのはエラーでした。これで、アンビエントクラスと関数（ &lt;code&gt;declare&lt;/code&gt; 修飾子を含むクラス/関数、または &lt;code&gt;.d.ts&lt;/code&gt; ファイル内）をマージできます。つまり、次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="f22c95046aa4c7055bed172e8f2f4e6828c3f4e5" translate="yes" xml:space="preserve">
          <source>In previous versions of TypeScript, the language didn&amp;rsquo;t allow &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessors in ambient contexts (like in &lt;code&gt;declare&lt;/code&gt;-d classes, or in &lt;code&gt;.d.ts&lt;/code&gt; files in general). The rationale was that accessors weren&amp;rsquo;t distinct from properties as far as writing and reading to these properties; however, &lt;a href=&quot;https://github.com/tc39/proposal-class-fields/issues/248&quot;&gt;because ECMAScript&amp;rsquo;s class fields proposal may have differing behavior from in existing versions of TypeScript&lt;/a&gt;, we realized we needed a way to communicate this different behavior to provide appropriate errors in subclasses.</source>
          <target state="translated">TypeScriptの以前のバージョンでは、この言語はアンビエントコンテキスト（ &lt;code&gt;declare&lt;/code&gt; -dクラスや一般的な &lt;code&gt;.d.ts&lt;/code&gt; ファイルなど）で &lt;code&gt;get&lt;/code&gt; および &lt;code&gt;set&lt;/code&gt; アクセサーを許可していませんでした。理論的根拠は、これらのプロパティへの書き込みと読み取りに関する限り、アクセサはプロパティと区別されていなかったということです。ただし、&lt;a href=&quot;https://github.com/tc39/proposal-class-fields/issues/248&quot;&gt;ECMAScriptのクラスフィールドの提案はTypeScriptの既存のバージョンとは動作が異なる場合がある&lt;/a&gt;ため、サブクラスで適切なエラーを提供するために、この異なる動作を伝える方法が必要であることに気付きました。</target>
        </trans-unit>
        <trans-unit id="d06dc1f53a697259b064554b5aae5fbdd8fa0f1e" translate="yes" xml:space="preserve">
          <source>In prior versions of TypeScript, this controlled what encoding was used when reading text files from disk. Today, TypeScript assumes UTF-8 encoding, but will correctly detect UTF-16 (BE and LE) or UTF-8 BOMs.</source>
          <target state="translated">以前のバージョンのTypeScriptでは、ディスクからテキストファイルを読み込む際に使用するエンコーディングを制御していました。現在では、TypeScript は UTF-8 エンコーディングを前提としていますが、UTF-16 (BE と LE)や UTF-8 BOM を正しく検出するようになっています。</target>
        </trans-unit>
        <trans-unit id="3cd7367e12bf3be0daca8711d8c00eca9148e271" translate="yes" xml:space="preserve">
          <source>In prior versions of TypeScript, unions of callable types could &lt;em&gt;only&lt;/em&gt; be invoked if they had identical parameter lists.</source>
          <target state="translated">TypeScriptの以前のバージョンでは、呼び出し可能な型の共用体は、それらが同一のパラメーターリストを持っている場合に&lt;em&gt;のみ&lt;/em&gt;呼び出すことができました。</target>
        </trans-unit>
        <trans-unit id="6c9fb325d7fa06659600b395394db2f6b03b95fa" translate="yes" xml:space="preserve">
          <source>In regular type checking mode the inferred type of &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;any&lt;/code&gt; because of widening, but in strict null checking mode the inferred type of &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; (and therefore, absent a type annotation, &lt;code&gt;null&lt;/code&gt; is the only possible value for &lt;code&gt;z&lt;/code&gt;).</source>
          <target state="translated">レギュラータイプチェックモードでの推論タイプ &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;any&lt;/code&gt; 理由広げるが、厳密ヌルチェックモードでの推論タイプ &lt;code&gt;z&lt;/code&gt; で &lt;code&gt;null&lt;/code&gt; （および型注釈が存在しない、したがって、 &lt;code&gt;null&lt;/code&gt; ための唯一の可能な値である &lt;code&gt;z&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7f54adc2fc21b0868ad3536236db9c436bfd98c6" translate="yes" xml:space="preserve">
          <source>In short using this general type, we can model React&amp;rsquo;s specific behavior for things like &lt;code&gt;defaultProps&lt;/code&gt; and, to some extent, &lt;code&gt;propTypes&lt;/code&gt;.</source>
          <target state="translated">つまり、この一般的なタイプを使用すると、 &lt;code&gt;defaultProps&lt;/code&gt; やある程度、 &lt;code&gt;propTypes&lt;/code&gt; などのReactの特定の動作をモデル化できます。</target>
        </trans-unit>
        <trans-unit id="3e40e3de53767b82c408d32adbf7faeb04be447e" translate="yes" xml:space="preserve">
          <source>In short, what this means is that you&amp;rsquo;ll be able to appropriately narrow down values from iterators when dealing with them directly.</source>
          <target state="translated">つまり、これは、イテレータを直接処理するときに、イテレータから値を適切に絞り込むことができるということです。</target>
        </trans-unit>
        <trans-unit id="24b474a2b5b3fe83952a8beed2dac6888a114bac" translate="yes" xml:space="preserve">
          <source>In some cases where no type annotations are present, TypeScript will fall back to a type of &lt;code&gt;any&lt;/code&gt; for a variable when it cannot infer the type.</source>
          <target state="translated">型注釈が存在しない場合、TypeScriptは、型を推測できないときに、変数の &lt;code&gt;any&lt;/code&gt; 型にフォールバックします。</target>
        </trans-unit>
        <trans-unit id="d6cb0b5b618417fb0993aeb5137486599cc6a685" translate="yes" xml:space="preserve">
          <source>In some cases, you may want to only load a module under some conditions. In TypeScript, we can use the pattern shown below to implement this and other advanced loading scenarios to directly invoke the module loaders without losing type safety.</source>
          <target state="translated">場合によっては、いくつかの条件でモジュールだけをロードしたい場合もあるでしょう。TypeScript では、以下に示すパターンを使って、型の安全性を失うことなくモジュールローダを直接呼び出すことができるように、このような高度なロードシナリオを実装することができます。</target>
        </trans-unit>
        <trans-unit id="e8107f519ee938815a808bcba6bd65a28adcacb9" translate="yes" xml:space="preserve">
          <source>In some situations, not all type information is available or its declaration would take an inappropriate amount of effort. These may occur for values from code that has been written without TypeScript or a 3rd party library. In these cases, we might want to opt-out of type checking. To do so, we label these values with the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target state="translated">状況によっては、すべての型情報が利用できるわけではないか、その宣言に不適切な量の労力がかかります。これらは、TypeScriptまたはサードパーティライブラリなしで記述されたコードの値で発生する可能性があります。このような場合、型チェックをオプトアウトしたい場合があります。そのために、これらの値に &lt;code&gt;any&lt;/code&gt; タイプのラベルを付けます。</target>
        </trans-unit>
        <trans-unit id="c99a1ed58829ceab5559116a15c7379e705e9cf2" translate="yes" xml:space="preserve">
          <source>In strict null checking mode the compiler requires every reference to a local variable of a type that doesn&amp;rsquo;t include &lt;code&gt;undefined&lt;/code&gt; to be preceded by an assignment to that variable in every possible preceding code path.</source>
          <target state="translated">厳密なnullチェックモードでは、コンパイラは、 &lt;code&gt;undefined&lt;/code&gt; を含まないタイプのローカル変数へのすべての参照の前に、可能なすべての先行コードパスでその変数への割り当てを要求します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
