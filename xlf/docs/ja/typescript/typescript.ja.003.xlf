<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="830f0ed9d3be32844d496bfeb9d33c2f9dea7d6a" translate="yes" xml:space="preserve">
          <source>Numeric separators</source>
          <target state="translated">数値セパレータ</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="7a98263bb62cd83a74dc00c8238d597167506261" translate="yes" xml:space="preserve">
          <source>Object Spread and Rest</source>
          <target state="translated">オブジェクトの広がりと残り</target>
        </trans-unit>
        <trans-unit id="cbf147d445453a6660add525598d56066b954b1c" translate="yes" xml:space="preserve">
          <source>Object Types</source>
          <target state="translated">オブジェクトの種類</target>
        </trans-unit>
        <trans-unit id="a7dc9622d9872b2041ea4b92f628450cd8b88097" translate="yes" xml:space="preserve">
          <source>Object destructuring</source>
          <target state="translated">オブジェクトの破壊</target>
        </trans-unit>
        <trans-unit id="7cd3db8976f376a1f019b5d0fed0df37b11861ba" translate="yes" xml:space="preserve">
          <source>Object literals are open-ended</source>
          <target state="translated">オブジェクトリテラルはオープンエンド</target>
        </trans-unit>
        <trans-unit id="b3c62e15831841090f5476450b68b035ffba0566" translate="yes" xml:space="preserve">
          <source>Object literals behave as if they have an index signature &lt;code&gt;[x:string]: any&lt;/code&gt; that allows them to be treated as open maps instead of closed objects.</source>
          <target state="translated">オブジェクトリテラルは、インデックスシグネチャ &lt;code&gt;[x:string]: any&lt;/code&gt; を持つかのように動作します。これらは、閉じたオブジェクトではなく開いたマップとして扱うことができるものです。</target>
        </trans-unit>
        <trans-unit id="74365de67eba166395b7f2ad380a09c31367e923" translate="yes" xml:space="preserve">
          <source>Object rests are the dual of object spreads, in that they can extract any extra properties that don&amp;rsquo;t get picked up when destructuring an element:</source>
          <target state="translated">オブジェクトレストは、要素を構造化するときに取得されない余分なプロパティを抽出できるという点で、オブジェクトスプレッドのデュアルです。</target>
        </trans-unit>
        <trans-unit id="5eeac8ca658c85a10aefd3ffe0bf35ef9f80485c" translate="yes" xml:space="preserve">
          <source>Object spread also has a couple of other surprising limits. First, it only includes an objects&amp;rsquo; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;own, enumerable properties&lt;/a&gt;. Basically, that means you lose methods when you spread instances of an object:</source>
          <target state="translated">オブジェクトの拡散には、他にもいくつかの驚くべき制限があります。まず、オブジェクト&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;自身の列挙可能なプロパティ&lt;/a&gt;のみが含まれます。基本的に、それはオブジェクトのインスタンスを広げるとメソッドを失うことを意味します：</target>
        </trans-unit>
        <trans-unit id="132f0e2906b1a9d29d3142065e0490a0c7b00912" translate="yes" xml:space="preserve">
          <source>Objects with Properties</source>
          <target state="translated">プロパティを持つオブジェクト</target>
        </trans-unit>
        <trans-unit id="896953fcb00b0eb5b0ba4da3b193100a1b6c1094" translate="yes" xml:space="preserve">
          <source>Of course, any of these types can be declared using Typescript syntax in a single-line &lt;code&gt;@typedef&lt;/code&gt;:</source>
          <target state="translated">もちろん、これらのタイプはいずれも、1行の &lt;code&gt;@typedef&lt;/code&gt; でTypescript構文を使用して宣言できます。</target>
        </trans-unit>
        <trans-unit id="2a729d408f1e41978ee6a94cb932a7977199d3c0" translate="yes" xml:space="preserve">
          <source>Of course, since this is JavaScript, you can just ignore trailing elements you don&amp;rsquo;t care about:</source>
          <target state="translated">もちろん、これはJavaScriptなので、気にしない末尾の要素は無視できます。</target>
        </trans-unit>
        <trans-unit id="b9ca67ed45e73556a1cbb12d34b79f3e95210af4" translate="yes" xml:space="preserve">
          <source>Of course, that might not feel right. If you open that file in an editor with TypeScript support (or if you run &lt;code&gt;tsc --pretty&lt;/code&gt;), you might see red squiggles on certain lines. You should think of these the same way you&amp;rsquo;d think of red squiggles in an editor like Microsoft Word. TypeScript will still translate your code, just like Word will still let you print your documents.</source>
          <target state="translated">もちろん、それは正しくないと感じるかもしれません。TypeScriptをサポートするエディターでそのファイルを開くと（または &lt;code&gt;tsc --pretty&lt;/code&gt; を実行すると）、特定の行に赤い波線が表示されることがあります。これらは、Microsoft Wordのようなエディターで赤い波線と同じように考える必要があります。TypeScriptは、Wordでドキュメントを印刷できるように、コードを変換します。</target>
        </trans-unit>
        <trans-unit id="33b53cf1b820a2734ec0c25dc3f2c29570965d4b" translate="yes" xml:space="preserve">
          <source>Of note, only the parameters and the return type make up the function type. Captured variables are not reflected in the type. In effect, captured variables are part of the &amp;ldquo;hidden state&amp;rdquo; of any function and do not make up its API.</source>
          <target state="translated">注目に値するのは、パラメーターと戻り値の型だけが関数型を構成することです。キャプチャされた変数はタイプに反映されません。実際には、キャプチャされた変数は関数の「隠された状態」の一部であり、そのAPIを構成しません。</target>
        </trans-unit>
        <trans-unit id="4d23057a19f87b1d7a3f861f468248c8e5a5974a" translate="yes" xml:space="preserve">
          <source>Official TypeScript NuGet package</source>
          <target state="translated">公式TypeScript NuGetパッケージ</target>
        </trans-unit>
        <trans-unit id="a342b6bea0bb720b9577de62cca20c2743aa540e" translate="yes" xml:space="preserve">
          <source>Often a project has multiple output targets, e.g. &lt;code&gt;ES5&lt;/code&gt; and &lt;code&gt;ES2015&lt;/code&gt;, debug and production or &lt;code&gt;CommonJS&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt;; Just a few configuration options change between these two targets, and maintaining multiple &lt;code&gt;tsconfig.json&lt;/code&gt; files can be a hassle.</source>
          <target state="translated">多くの場合、プロジェクトには、 &lt;code&gt;ES5&lt;/code&gt; や &lt;code&gt;ES2015&lt;/code&gt; などの複数の出力ターゲット、デバッグと本番、または &lt;code&gt;CommonJS&lt;/code&gt; と &lt;code&gt;System&lt;/code&gt; があります。これら2つのターゲット間で変更される構成オプションはほんのわずかであり、複数の &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを維持するのは面倒な場合があります。</target>
        </trans-unit>
        <trans-unit id="0d6fe7c72174392511bd9351eaea580b26d61ce5" translate="yes" xml:space="preserve">
          <source>Often in Node.js applications a &lt;code&gt;.json&lt;/code&gt; is needed. With TypeScript 2.9, &lt;code&gt;--resolveJsonModule&lt;/code&gt; allows for importing, extracting types from and generating &lt;code&gt;.json&lt;/code&gt; files.</source>
          <target state="translated">多くの場合、Node.jsアプリケーションでは &lt;code&gt;.json&lt;/code&gt; が必要です。TypeScript 2.9では、 &lt;code&gt;--resolveJsonModule&lt;/code&gt; 使用して、 &lt;code&gt;.json&lt;/code&gt; ファイルのインポート、タイプの抽出、および.jsonファイルの生成を行うことができます。</target>
        </trans-unit>
        <trans-unit id="c504b6f49a2c17cd30c9562020e80d82bcb972da" translate="yes" xml:space="preserve">
          <source>Often modules extend other modules, and partially expose some of their features. A re-export does not import it locally, or introduce a local variable.</source>
          <target state="translated">多くの場合、モジュールは他のモジュールを拡張し、その機能の一部を部分的に公開しています。再エクスポートでは、ローカルにインポートしたり、ローカル変数を導入したりすることはありません。</target>
        </trans-unit>
        <trans-unit id="7ca1979392492f5b243f43458b409b3671c295fb" translate="yes" xml:space="preserve">
          <source>Often there are external source files in your project that may not be authored in TypeScript. Alternatively, you might be in the middle of converting a JS code base into TS, but still want to bundle all your JS code into a single file with the output of your new TS code.</source>
          <target state="translated">プロジェクト内には、TypeScriptでオーサリングされていない外部ソースファイルが存在することがよくあります。あるいは、JS コードベースを TS に変換している最中であっても、すべての JS コードを 1 つのファイルにまとめて、新しい TS コードの出力と一緒に出力したい場合もあるでしょう。</target>
        </trans-unit>
        <trans-unit id="5dd8eb55cce46da17a5fd56794f37ca6d1bdbaaf" translate="yes" xml:space="preserve">
          <source>Often you will need to extend functionality on a module. A common JS pattern is to augment the original object with &lt;em&gt;extensions&lt;/em&gt;, similar to how JQuery extensions work. As we&amp;rsquo;ve mentioned before, modules do not &lt;em&gt;merge&lt;/em&gt; like global namespace objects would. The recommended solution is to &lt;em&gt;not&lt;/em&gt; mutate the original object, but rather export a new entity that provides the new functionality.</source>
          <target state="translated">多くの場合、モジュールの機能を拡張する必要があります。一般的なJSパターンは、JQuery拡張機能の動作と同様に、元のオブジェクトを&lt;em&gt;拡張機能&lt;/em&gt;で拡張することです。前に述べたように、モジュールはグローバル名前空間オブジェクトのように&lt;em&gt;マージされ&lt;/em&gt;ません。推奨される解決策は、元のオブジェクトを変更&lt;em&gt;せず&lt;/em&gt;、新しい機能を提供する新しいエンティティをエクスポートすることです。</target>
        </trans-unit>
        <trans-unit id="3cd64adc89519f486491a6325593966cd9fc3e61" translate="yes" xml:space="preserve">
          <source>Omit&amp;lt;T,K&amp;gt;</source>
          <target state="translated">Omit&amp;lt;T,K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="92df791023a2af27d1199c4ac1986b7a67686b3d" translate="yes" xml:space="preserve">
          <source>OmitThisParameter</source>
          <target state="translated">OmitThisParameter</target>
        </trans-unit>
        <trans-unit id="a82c9a0a2eb97497a86656e3460a340f586d18ec" translate="yes" xml:space="preserve">
          <source>On a single line:</source>
          <target state="translated">単線で。</target>
        </trans-unit>
        <trans-unit id="82aef786e3f0d107d8d394b8c34887545af6ea56" translate="yes" xml:space="preserve">
          <source>On multiple lines:</source>
          <target state="translated">複数行で</target>
        </trans-unit>
        <trans-unit id="74944d3dcee80b1604d42865751a7ceaa698e35d" translate="yes" xml:space="preserve">
          <source>On the last line of the snippet you can see that even assigning the entire &lt;code&gt;ReadonlyArray&lt;/code&gt; back to a normal array is illegal. You can still override it with a type assertion, though:</source>
          <target state="translated">最後の行に、あなたも全体に割り当てることがわかりますスニペット &lt;code&gt;ReadonlyArray&lt;/code&gt; の通常の配列に戻すことは違法です。ただし、型アサーションを使用してオーバーライドすることもできます。</target>
        </trans-unit>
        <trans-unit id="50c6272b337ca96a2387d10cc66c11dc4b62bb58" translate="yes" xml:space="preserve">
          <source>On the organization front, namespaces are handy for grouping together logically-related objects and types in the global scope. For example, in C#, you&amp;rsquo;re going to find all the collection types in System.Collections. By organizing our types into hierarchical namespaces, we provide a good &amp;ldquo;discovery&amp;rdquo; experience for users of those types. Modules, on the other hand, are already present in a file system, necessarily. We have to resolve them by path and filename, so there&amp;rsquo;s a logical organization scheme for us to use. We can have a /collections/generic/ folder with a list module in it.</source>
          <target state="translated">組織の面では、名前空間は、論理的に関連するオブジェクトとタイプをグローバルスコープでグループ化するのに便利です。たとえば、C＃では、System.Collectionsですべてのコレクション型を検索します。タイプを階層的な名前空間に編成することにより、これらのタイプのユーザーに優れた「発見」エクスペリエンスを提供します。一方、モジュールはすでにファイルシステムにすでに存在しています。それらをパスとファイル名で解決する必要があるため、使用する論理的な編成スキームがあります。/ collections / generic /フォルダーにリストモジュールを含めることができます。</target>
        </trans-unit>
        <trans-unit id="b64cb02da6becca0ce8ee30f0556e39a4da2ddd8" translate="yes" xml:space="preserve">
          <source>On the other hand, if you can&amp;rsquo;t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.</source>
          <target state="translated">一方、インターフェースで形状を表現できず、共用体またはタプル型を使用する必要がある場合は、通常、型エイリアスが適しています。</target>
        </trans-unit>
        <trans-unit id="c26cd5caaa2a12259da3b89ce4e19ad33c03509f" translate="yes" xml:space="preserve">
          <source>On the other hand, methods like &lt;code&gt;forEach&lt;/code&gt; will now be callable, but under &lt;code&gt;noImplicitAny&lt;/code&gt; there may be some issues.</source>
          <target state="translated">一方、 &lt;code&gt;forEach&lt;/code&gt; などのメソッドは呼び出し可能になりますが、 &lt;code&gt;noImplicitAny&lt;/code&gt; ではいくつかの問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="5e243af120900864262b36ccd9ddf3da385c8c6b" translate="yes" xml:space="preserve">
          <source>Once defined, we can use this function type interface like we would other interfaces. Here, we show how you can create a variable of a function type and assign it a function value of the same type.</source>
          <target state="translated">一度定義してしまえば、この関数型インターフェースを他のインターフェースと同じように使うことができます。ここでは、関数型の変数を作成し、同じ型の関数値を代入する方法を示します。</target>
        </trans-unit>
        <trans-unit id="92950c589178fe64abd972f4ad963eddae26cb96" translate="yes" xml:space="preserve">
          <source>Once the class type is established, the instance type is determined by the union of the return types of the class type&amp;rsquo;s construct or call signatures (whichever is present). So again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function.</source>
          <target state="translated">クラスタイプが確立されると、インスタンスタイプは、クラスタイプのコンストラクトまたはコールシグネチャ（存在する方）の戻りタイプの和集合によって決定されます。つまり、ES6クラスの場合、インスタンスタイプはそのクラスのインスタンスのタイプであり、ファクトリ関数の場合は、関数から返される値のタイプになります。</target>
        </trans-unit>
        <trans-unit id="b659e74e17ccfc36ea3671d29e4bcfb99bcddcac" translate="yes" xml:space="preserve">
          <source>Once there are multiple files involved, we&amp;rsquo;ll need to make sure all of the compiled code gets loaded. There are two ways of doing this.</source>
          <target state="translated">複数のファイルが含まれるようになったら、コンパイルされたすべてのコードが読み込まれるようにする必要があります。これを行うには2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="1344250aecff00dcfaf8dcd7ebd24a106e1cf310" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:</source>
          <target state="translated">汎用的な識別関数を作成したら、2つの方法のいずれかで呼び出すことができます。最初の方法は、type引数を含むすべての引数を関数に渡すことです。</target>
        </trans-unit>
        <trans-unit id="1f601e0447efc6c6f5c004e85bc2178722596428" translate="yes" xml:space="preserve">
          <source>One advantage of this is that the callable constructor pattern can be easily expressed while also allowing namespaces to merge with these declarations (since &lt;code&gt;var&lt;/code&gt; declarations can&amp;rsquo;t merge with &lt;code&gt;namespace&lt;/code&gt;s).</source>
          <target state="translated">これの利点の1つは、呼び出し可能なコンストラクターパターンを簡単に表現できると同時に、名前空間をこれらの宣言とマージできることです（ &lt;code&gt;var&lt;/code&gt; 宣言は &lt;code&gt;namespace&lt;/code&gt; s とマージできないため）。</target>
        </trans-unit>
        <trans-unit id="07140e34d3c9cf651017285b583d3f868d3d8fae" translate="yes" xml:space="preserve">
          <source>One common task is to take an existing type and make each of its properties entirely optional. Let&amp;rsquo;s say we have a &lt;code&gt;Person&lt;/code&gt;:</source>
          <target state="translated">一般的なタスクの1つは、既存の型を取り、その各プロパティを完全にオプションにすることです。 &lt;code&gt;Person&lt;/code&gt; があるとしましょう：</target>
        </trans-unit>
        <trans-unit id="11091369cf849b83900d010b927727e1dc480d7a" translate="yes" xml:space="preserve">
          <source>One difference from the prior example is that each derived class that contains a constructor function &lt;em&gt;must&lt;/em&gt; call &lt;code&gt;super()&lt;/code&gt; which will execute the constructor of the base class. What&amp;rsquo;s more, before we &lt;em&gt;ever&lt;/em&gt; access a property on &lt;code&gt;this&lt;/code&gt; in a constructor body, we &lt;em&gt;have&lt;/em&gt; to call &lt;code&gt;super()&lt;/code&gt;. This is an important rule that TypeScript will enforce.</source>
          <target state="translated">前の例との1つの違いは、コンストラクター関数を含む各派生クラスは、基本クラスのコンストラクターを実行する &lt;code&gt;super()&lt;/code&gt; を呼び出す&lt;em&gt;必要&lt;/em&gt;があることです。私たちは前に、より多くの何&lt;em&gt;これまで&lt;/em&gt;のプロパティにアクセス &lt;code&gt;this&lt;/code&gt; コンストラクタ本体に、私たちが&lt;em&gt;持って&lt;/em&gt;コールする &lt;code&gt;super()&lt;/code&gt; 。これはTypeScriptが適用する重要なルールです。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e676ef27b983655b305e7201bc44df325b250ac1" translate="yes" xml:space="preserve">
          <source>One difference is that interfaces create a new name that is used everywhere. Type aliases don&amp;rsquo;t create a new name &amp;mdash; for instance, error messages won&amp;rsquo;t use the alias name. In the code below, hovering over &lt;code&gt;interfaced&lt;/code&gt; in an editor will show that it returns an &lt;code&gt;Interface&lt;/code&gt;, but will show that &lt;code&gt;aliased&lt;/code&gt; returns object literal type.</source>
          <target state="translated">1つの違いは、インターフェイスはどこでも使用される新しい名前を作成することです。タイプエイリアスは新しい名前を作成しません&amp;mdash;たとえば、エラーメッセージはエイリアス名を使用しません。以下のコードでは、カーソルを合わせる &lt;code&gt;interfaced&lt;/code&gt; が返されることを示すであろうエディタに &lt;code&gt;Interface&lt;/code&gt; が、その表示され &lt;code&gt;aliased&lt;/code&gt; 戻るリテラル型オブジェクト。</target>
        </trans-unit>
        <trans-unit id="4a3dab7aa9f91e5908fc981f84a1f4366d2c7377" translate="yes" xml:space="preserve">
          <source>One exception to this rule is specialized signatures. If a signature has a parameter whose type is a &lt;em&gt;single&lt;/em&gt; string literal type (e.g. not a union of string literals), then it will be bubbled toward the top of its merged overload list.</source>
          <target state="translated">このルールの1つの例外は、特殊な署名です。シグネチャのタイプが&lt;em&gt;単一の&lt;/em&gt;文字列リテラルタイプ（たとえば、文字列リテラルの和集合ではない）のパラメーターがある場合、マージされたオーバーロードリストの先頭に向かってバブリングされます。</target>
        </trans-unit>
        <trans-unit id="344276576132d21b818f4ba76034843580074fbf" translate="yes" xml:space="preserve">
          <source>One final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since &lt;code&gt;squareOptions&lt;/code&gt; won&amp;rsquo;t undergo excess property checks, the compiler won&amp;rsquo;t give you an error.</source>
          <target state="translated">少し意外かもしれませんが、これらのチェックを回避する最後の方法の1つは、オブジェクトを別の変数に割り当てることです &lt;code&gt;squareOptions&lt;/code&gt; は過剰なプロパティチェックを受けないため、コンパイラーはエラーを出しません。</target>
        </trans-unit>
        <trans-unit id="42cbeda6b484653b931fc5901c6ad7cbbe7d3da4" translate="yes" xml:space="preserve">
          <source>One great benefit of this is that you&amp;rsquo;ll see &lt;em&gt;way fewer&lt;/em&gt; implicit &lt;code&gt;any&lt;/code&gt; errors when running with &lt;code&gt;--noImplicitAny&lt;/code&gt;. Implicit &lt;code&gt;any&lt;/code&gt; errors are only reported when the compiler is unable to know the type of a variable without a type annotation.</source>
          <target state="translated">これの一つの大きな利点は、あなたが見るだろうということで&lt;em&gt;仕方少ない&lt;/em&gt;暗黙の &lt;code&gt;any&lt;/code&gt; と実行しているときにエラー &lt;code&gt;--noImplicitAny&lt;/code&gt; 。暗黙的 &lt;code&gt;any&lt;/code&gt; エラーは、コンパイラーが型注釈なしで変数の型を認識できない場合にのみ報告されます。</target>
        </trans-unit>
        <trans-unit id="0e93e8c643fb4e61579636fbf572b596e0286726" translate="yes" xml:space="preserve">
          <source>One important difference between ambient and non-ambient enums is that, in regular enums, members that don&amp;rsquo;t have an initializer will be considered constant if its preceding enum member is considered constant. In contrast, an ambient (and non-const) enum member that does not have initializer is &lt;em&gt;always&lt;/em&gt; considered computed.</source>
          <target state="translated">アンビエント列挙型と非アンビエント列挙型の重要な違いの1つは、通常の列挙型では、初期化子を持たないメンバーは、先行する列挙型メンバーが定数と見なされた場合、定数と見なされることです。対照的に、初期化子を持たないアンビエント（および非const）列挙型メンバーは&lt;em&gt;常に&lt;/em&gt;計算されたと見なされます。</target>
        </trans-unit>
        <trans-unit id="82aa3486d66599c6818535555fcde271410599f0" translate="yes" xml:space="preserve">
          <source>One of TypeScript&amp;rsquo;s core principles is that type checking focuses on the &lt;em&gt;shape&lt;/em&gt; that values have. This is sometimes called &amp;ldquo;duck typing&amp;rdquo; or &amp;ldquo;structural subtyping&amp;rdquo;. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.</source>
          <target state="translated">TypeScriptのコア原則の1つは、型チェックが値の&lt;em&gt;形に&lt;/em&gt;焦点を当てることです。これは、「ダックタイピング」または「構造サブタイピング」と呼ばれることもあります。TypeScriptでは、インターフェイスはこれらの型に名前を付ける役割を果たし、コード内のコントラクトやプロジェクト外のコードとのコントラクトを定義する強力な方法です。</target>
        </trans-unit>
        <trans-unit id="5aea8e823173035ff216b848c6b0d54b8b96fd4c" translate="yes" xml:space="preserve">
          <source>One of the most common uses of interfaces in languages like C# and Java, that of explicitly enforcing that a class meets a particular contract, is also possible in TypeScript.</source>
          <target state="translated">C#やJavaのような言語で最も一般的に使用されているインターフェースの1つである、クラスが特定の契約を満たすことを明示的に強制することは、TypeScriptでも可能です。</target>
        </trans-unit>
        <trans-unit id="bd4f8dfdb26e810e57f23fff74f292ac4a329c2e" translate="yes" xml:space="preserve">
          <source>One or more assignments to &lt;code&gt;window.someName&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window.someName&lt;/code&gt; への1つ以上の割り当て</target>
        </trans-unit>
        <trans-unit id="7eacbc50348f5b3ec9e3e6415d394dd711448525" translate="yes" xml:space="preserve">
          <source>One such example is an object that acts as both a function and an object, with additional properties:</source>
          <target state="translated">そのような例として、関数とオブジェクトの両方として動作し、追加のプロパティを持つオブジェクトがあります。</target>
        </trans-unit>
        <trans-unit id="10e4a65d9bb07088ca61418abc5f5490d598fa30" translate="yes" xml:space="preserve">
          <source>One thing to note is that &lt;code&gt;const&lt;/code&gt; assertions can only be applied immediately on simple literal expressions.</source>
          <target state="translated">注意すべきことの1つは、 &lt;code&gt;const&lt;/code&gt; アサーションは単純なリテラル式にすぐにのみ適用できることです。</target>
        </trans-unit>
        <trans-unit id="165c72846ed1b6318be8972010ccbd2b184d8eb7" translate="yes" xml:space="preserve">
          <source>OneTwoThree.ts</source>
          <target state="translated">OneTwoThree.ts</target>
        </trans-unit>
        <trans-unit id="e8b21c7e76c250574a2ed991e3f5c20b47bb2111" translate="yes" xml:space="preserve">
          <source>Only emit &amp;lsquo;.d.ts&amp;rsquo; declaration files.</source>
          <target state="translated">「.d.ts」宣言ファイルのみを発行します。</target>
        </trans-unit>
        <trans-unit id="9c4c4f095c25b9e726d79098915a46e4ea92ff63" translate="yes" xml:space="preserve">
          <source>Open &lt;code&gt;greeter.html&lt;/code&gt; in the browser to run your first simple TypeScript web application!</source>
          <target state="translated">ブラウザで &lt;code&gt;greeter.html&lt;/code&gt; を開いて、最初のシンプルなTypeScript Webアプリケーションを実行します。</target>
        </trans-unit>
        <trans-unit id="e55b8e4dc396172c8a0dbddfe6ab0a7debd51fb3" translate="yes" xml:space="preserve">
          <source>Open &lt;strong&gt;Dependencies &amp;gt; Manage NuGet Packages &amp;gt; Browse.&lt;/strong&gt; Search and install &lt;code&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt; and &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;:</source>
          <target state="translated">[ &lt;strong&gt;依存関係]&amp;gt; [NuGetパッケージの管理]&amp;gt; [参照]を&lt;/strong&gt;開き&lt;strong&gt;ます。&lt;/strong&gt; &lt;code&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt; および &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt; を検索してインストールします。</target>
        </trans-unit>
        <trans-unit id="064cf8a9bba6348e155ce9b3a0d85c1b0a8dcab6" translate="yes" xml:space="preserve">
          <source>Open up your &lt;code&gt;Startup.cs&lt;/code&gt; file and edit your &lt;code&gt;Configure&lt;/code&gt; function to look like this:</source>
          <target state="translated">&lt;code&gt;Startup.cs&lt;/code&gt; ファイルを開き、 &lt;code&gt;Configure&lt;/code&gt; 関数を次のように編集します。</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="e623b1194b11521281fe95cf75df232d30616550" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;--outDir&lt;/code&gt; duplicates the input hierarchy in the output. The compiler computes the root of the input files as the longest common path of all input files; and then uses that to replicate all its substructure in the output.</source>
          <target state="translated">オプション &lt;code&gt;--outDir&lt;/code&gt; は、入力階層を出力に複製します。コンパイラーは、入力ファイルのルートを、すべての入力ファイルの最長共通パスとして計算します。そして、それを使用して、出力内のすべてのサブ構造を複製します。</target>
        </trans-unit>
        <trans-unit id="02e5818137a6801351663f03a49db2886b267ce5" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;catch&lt;/code&gt; clause variables</source>
          <target state="translated">オプションの &lt;code&gt;catch&lt;/code&gt; 句変数</target>
        </trans-unit>
        <trans-unit id="e1a89356c2e4a69562083736c16549a15a67afd8" translate="yes" xml:space="preserve">
          <source>Optional Chaining</source>
          <target state="translated">オプションのチェイニング</target>
        </trans-unit>
        <trans-unit id="f7c6bcdff008088c9ae3335f40deda7169b35c83" translate="yes" xml:space="preserve">
          <source>Optional Module Loading and Other Advanced Loading Scenarios</source>
          <target state="translated">オプションのモジュールローディングとその他の高度なローディングシナリオ</target>
        </trans-unit>
        <trans-unit id="ccaa37d283bc30bfac0d5a680eadb38cfbad3c49" translate="yes" xml:space="preserve">
          <source>Optional Parameters and Rest Parameters</source>
          <target state="translated">オプションパラメータと残りのパラメータ</target>
        </trans-unit>
        <trans-unit id="b5c1d49a9a0ded62373bc3f019e8b6f2da7391b2" translate="yes" xml:space="preserve">
          <source>Optional Parameters in Callbacks</source>
          <target state="translated">コールバックのオプションパラメータ</target>
        </trans-unit>
        <trans-unit id="17315c7bb52dfa3c7be7c978a030acc2e38d91c1" translate="yes" xml:space="preserve">
          <source>Optional Properties</source>
          <target state="translated">オプションのプロパティ</target>
        </trans-unit>
        <trans-unit id="8daa3a8272df293fc9da3c3073a118094fb29854" translate="yes" xml:space="preserve">
          <source>Optional and Default Parameters</source>
          <target state="translated">オプションとデフォルトのパラメータ</target>
        </trans-unit>
        <trans-unit id="f4d845ae294ad2b99077aef2b25fd789eac70078" translate="yes" xml:space="preserve">
          <source>Optional chaining also includes two other operations. First there&amp;rsquo;s the &lt;em&gt;optional element access&lt;/em&gt; which acts similarly to optional property accesses, but allows us to access non-identifier properties (e.g. arbitrary strings, numbers, and symbols):</source>
          <target state="translated">オプションの連鎖には、他に2つの操作が含まれます。最初に、&lt;em&gt;オプションの&lt;/em&gt;プロパティアクセスと同様に機能する&lt;em&gt;オプションの要素アクセスが&lt;/em&gt;ありますが、識別子以外のプロパティ（たとえば、任意の文字列、数値、記号）にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="e5f644471c553673cd2548869c093cbfbd2425d1" translate="yes" xml:space="preserve">
          <source>Optional chaining is &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/16&quot;&gt;issue #16&lt;/a&gt; on our issue tracker. For context, there have been over 23,000 issues on the TypeScript issue tracker since then.</source>
          <target state="translated">オプションの連鎖は、課題トラッカーの&lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/16&quot;&gt;課題＃16&lt;/a&gt;です。コンテキストに関しては、それ以来、TypeScript Issue Trackerには23,000を超える問題があります。</target>
        </trans-unit>
        <trans-unit id="53581f6f206bad7094e8261bd030109f9d53f1b0" translate="yes" xml:space="preserve">
          <source>Optional class properties</source>
          <target state="translated">オプションのクラスプロパティ</target>
        </trans-unit>
        <trans-unit id="d957ddf6e5b65d75752d19d7a9dab595722e5998" translate="yes" xml:space="preserve">
          <source>Optional elements in tuple types</source>
          <target state="translated">タプル型のオプション要素</target>
        </trans-unit>
        <trans-unit id="d86b65de7272239d11bfd100dd6563cfd8eb06e5" translate="yes" xml:space="preserve">
          <source>Optional elements in tuple types.</source>
          <target state="translated">タプル型のオプション要素。</target>
        </trans-unit>
        <trans-unit id="05631f6c888f7c7fded4cab4a643205c9c4a8938" translate="yes" xml:space="preserve">
          <source>Optional parameters and properties</source>
          <target state="translated">オプションのパラメータとプロパティ</target>
        </trans-unit>
        <trans-unit id="a160146910ad98552a493b375e35d6abcb550597" translate="yes" xml:space="preserve">
          <source>Optional parameters and properties automatically have &lt;code&gt;undefined&lt;/code&gt; added to their types, even when their type annotations don&amp;rsquo;t specifically include &lt;code&gt;undefined&lt;/code&gt;. For example, the following two types are identical:</source>
          <target state="translated">オプションのパラメーターとプロパティは、型注釈に特に &lt;code&gt;undefined&lt;/code&gt; が含まれていない場合でも、自動的に &lt;code&gt;undefined&lt;/code&gt; が型に追加されます。たとえば、次の2つのタイプは同じです。</target>
        </trans-unit>
        <trans-unit id="f00301f27003ef54c63e41fcdd1c3d98832e9617" translate="yes" xml:space="preserve">
          <source>Optional properties and methods can now be declared in classes, similar to what is already permitted in interfaces.</source>
          <target state="translated">オプションのプロパティとメソッドは、すでにインターフェイスで許可されているものと同様に、クラスで宣言できるようになりました。</target>
        </trans-unit>
        <trans-unit id="c20ef3af584d28ff7405e7586b97956e1fd873af" translate="yes" xml:space="preserve">
          <source>Optional: Open &lt;code&gt;greeter.ts&lt;/code&gt; in Visual Studio, or copy the code into the TypeScript playground. You can hover over identifiers to see their types. Notice that in some cases these types are inferred automatically for you. Re-type the last line, and see completion lists and parameter help based on the types of the DOM elements. Put your cursor on the reference to the greeter function, and hit F12 to go to its definition. Notice, too, that you can right-click on a symbol and use refactoring to rename it.</source>
          <target state="translated">オプション：Visual Studioで &lt;code&gt;greeter.ts&lt;/code&gt; を開くか、コードをTypeScriptプレイグラウンドにコピーします。識別子にカーソルを合わせると、そのタイプを確認できます。場合によっては、これらのタイプが自動的に推測されることに注意してください。最後の行を再入力し、DOM要素のタイプに基づいて補完リストとパラメーターのヘルプを参照してください。greeter関数への参照にカーソルを置き、F12キーを押してその定義に移動します。また、シンボルを右クリックし、リファクタリングを使用して名前を変更できることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="591ef5ad63bd713e79f598100ad5e204c2091ef1" translate="yes" xml:space="preserve">
          <source>Optionally, a module can wrap one or more modules and combine all their exports using &lt;code&gt;export * from &quot;module&quot;&lt;/code&gt; syntax.</source>
          <target state="translated">オプションで、モジュールは1つ以上のモジュールをラップし、 &lt;code&gt;export * from &quot;module&quot;&lt;/code&gt; 構文を使用してすべてのエクスポートを組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="81b391e677894347f3d7eaa5c625ce0c39681863" translate="yes" xml:space="preserve">
          <source>Or ignore trailing elements, or other elements:</source>
          <target state="translated">または、末尾の要素などは無視してください。</target>
        </trans-unit>
        <trans-unit id="107058d564aa8aab6bd22eaa786593d0b18cee3f" translate="yes" xml:space="preserve">
          <source>Or other elements:</source>
          <target state="translated">または他の要素。</target>
        </trans-unit>
        <trans-unit id="7896cec1b378bbc6409139052737322d415d7652" translate="yes" xml:space="preserve">
          <source>Or we might want a readonly version:</source>
          <target state="translated">もしくは読み切り版が欲しいかもしれません。</target>
        </trans-unit>
        <trans-unit id="6d64af183927ab37ad7e32252f098d1cc8ff662b" translate="yes" xml:space="preserve">
          <source>Or you can just use the unspecified &lt;code&gt;Function&lt;/code&gt; type:</source>
          <target state="translated">または、未指定の &lt;code&gt;Function&lt;/code&gt; タイプを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="f1ea4c6e412df1aa6cd8260f35271c01fcb8e8a0" translate="yes" xml:space="preserve">
          <source>Or, even manually set all the values in the enum:</source>
          <target state="translated">あるいは、列挙されているすべての値を手動で設定することもできます。</target>
        </trans-unit>
        <trans-unit id="a7041e24ae17e49fcab38c7bb31f06d031308b3f" translate="yes" xml:space="preserve">
          <source>Or, we could describe the identity function using the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target state="translated">または、 &lt;code&gt;any&lt;/code&gt; 型を使用して恒等関数を記述することもできます。</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="bf83d365be04a72bc8a349cc7a86cd0845dccf80" translate="yes" xml:space="preserve">
          <source>Organizing Types</source>
          <target state="translated">整理の種類</target>
        </trans-unit>
        <trans-unit id="62510ab9b0c9768adbae646ef408d2a62b45617c" translate="yes" xml:space="preserve">
          <source>Other types from Closure also work:</source>
          <target state="translated">クロージャーの他のタイプも動作します。</target>
        </trans-unit>
        <trans-unit id="6c40d3319358591a02a91d9e7d4783872ba163d5" translate="yes" xml:space="preserve">
          <source>Other variants are allowed as well:</source>
          <target state="translated">他の亜種も同様に許可されています。</target>
        </trans-unit>
        <trans-unit id="b3fdc1e6ff5294bca808cf4bfb8838d0fec37709" translate="yes" xml:space="preserve">
          <source>Otherwise use &lt;code&gt;--keyofStringsOnly&lt;/code&gt; compiler option to disable the new behavior.</source>
          <target state="translated">それ以外の場合は、 &lt;code&gt;--keyofStringsOnly&lt;/code&gt; コンパイラオプションを使用して、新しい動作を無効にします。</target>
        </trans-unit>
        <trans-unit id="7336f1cc92c408cb13dba362d46361683cd3d12c" translate="yes" xml:space="preserve">
          <source>Otherwise, the condition depends on one or more type variables and the conditional type is deferred.</source>
          <target state="translated">そうでなければ、条件は1つ以上の型変数に依存しており、条件型は延期されます。</target>
        </trans-unit>
        <trans-unit id="9fd652f329cdb87b5184f532624c12babcba184a" translate="yes" xml:space="preserve">
          <source>Otherwise, we assume that you&amp;rsquo;re already using &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; with &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">それ以外の場合は、&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npmで&lt;/a&gt;&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;をすでに使用していると想定します。</target>
        </trans-unit>
        <trans-unit id="784cfa9d141a3fe82c06f16ad3a9456778056b89" translate="yes" xml:space="preserve">
          <source>Our First Interface</source>
          <target state="translated">最初のインターフェイス</target>
        </trans-unit>
        <trans-unit id="59c2ed6506b42cf80836ee63241f17d49a77bfd7" translate="yes" xml:space="preserve">
          <source>Our package exposes declarations from each of those, so any user of our &lt;code&gt;browserify-typescript-extension&lt;/code&gt; package needs to have these dependencies as well. For that reason, we used &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; and not &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt;, because otherwise our consumers would have needed to manually install those packages. If we had just written a command line application and not expected our package to be used as a library, we might have used &lt;code&gt;devDependencies&lt;/code&gt;.</source>
          <target state="translated">私たちのパッケージはそれらのそれぞれからの宣言を公開しているので、 &lt;code&gt;browserify-typescript-extension&lt;/code&gt; パッケージのすべてのユーザーはこれらの依存関係も持つ必要があります。そのため、 &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; ではなく &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; を使用しました。それ以外の場合、コンシューマーはこれらのパッケージを手動でインストールする必要があったためです。コマンドラインアプリケーションを作成したばかりで、パッケージがライブラリとして使用されることを期待していない場合は、 &lt;code&gt;devDependencies&lt;/code&gt; を使用した可能性があります。</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="914f3908b7a344c5f4fb4fdf698695b9d2d20039" translate="yes" xml:space="preserve">
          <source>Output File Extension</source>
          <target state="translated">出力ファイル拡張子</target>
        </trans-unit>
        <trans-unit id="b1a5505b0f802d6cf6a89204887e3eae4eb65f9a" translate="yes" xml:space="preserve">
          <source>Output directory for generated declaration files.</source>
          <target state="translated">生成された宣言ファイルの出力ディレクトリ。</target>
        </trans-unit>
        <trans-unit id="174bd26cf8c350d1ca94d82023ef88cff0353faa" translate="yes" xml:space="preserve">
          <source>Output generation</source>
          <target state="translated">出力生成</target>
        </trans-unit>
        <trans-unit id="564d5d5acb36c72c6328a222a0d5721ff6fd4eb9" translate="yes" xml:space="preserve">
          <source>Outside of &lt;code&gt;.tsx&lt;/code&gt; files, the angle bracket assertion syntax can also be used.</source>
          <target state="translated">&lt;code&gt;.tsx&lt;/code&gt; ファイルの外では、山かっこアサーション構文も使用できます。</target>
        </trans-unit>
        <trans-unit id="fcc1811db5df29bd6fe9b10089bc778dd03521da" translate="yes" xml:space="preserve">
          <source>Overall Structure</source>
          <target state="translated">全体構造</target>
        </trans-unit>
        <trans-unit id="0774d17a127371d4945391cdeb1d6747883f0446" translate="yes" xml:space="preserve">
          <source>Overloaded Function</source>
          <target state="translated">オーバーロード機能</target>
        </trans-unit>
        <trans-unit id="b8ed2ea3bd4ec728b7aa2051fa7a407dc7fb10f0" translate="yes" xml:space="preserve">
          <source>Overloaded Functions</source>
          <target state="translated">過負荷機能</target>
        </trans-unit>
        <trans-unit id="ec5878dd8d899636943fffee6342d476f6713cb3" translate="yes" xml:space="preserve">
          <source>Overloads</source>
          <target state="translated">Overloads</target>
        </trans-unit>
        <trans-unit id="cc20e1a304c06340ae63ba26a34364808dafd65d" translate="yes" xml:space="preserve">
          <source>Overloads and Callbacks</source>
          <target state="translated">オーバーロードとコールバック</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="0577f98176563373436836dd571634165655bf7e" translate="yes" xml:space="preserve">
          <source>Packages under the &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt; organization are published automatically from &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; using the &lt;a href=&quot;https://github.com/Microsoft/types-publisher&quot;&gt;types-publisher tool&lt;/a&gt;. To get your declarations published as an @types package, please submit a pull request to &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;https://github.com/DefinitelyTyped/DefinitelyTyped&lt;/a&gt;. You can find more details in the &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;組織のパッケージは、&lt;a href=&quot;https://github.com/Microsoft/types-publisher&quot;&gt;types-publisherツール&lt;/a&gt;を使用して&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;から自動的に公開されます。宣言を@typesパッケージとして公開するには、プルリクエストを&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;https://github.com/DefinitelyTyped/DefinitelyTypedに&lt;/a&gt;送信してください。詳細については、&lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;投稿ガイドラインページをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c05990a1953dff830b4e694fd34e78ad2c4e758" translate="yes" xml:space="preserve">
          <source>Packaging dependent declarations</source>
          <target state="translated">パッケージ化依存宣言</target>
        </trans-unit>
        <trans-unit id="f6dd7817ec1cd36abd644cfdc46d670053a1cd83" translate="yes" xml:space="preserve">
          <source>Parameter Decorators</source>
          <target state="translated">パラメータデコレーター</target>
        </trans-unit>
        <trans-unit id="2952d35fe7891ee81c4489bd1bb320a48758d659" translate="yes" xml:space="preserve">
          <source>Parameter properties</source>
          <target state="translated">パラメータのプロパティ</target>
        </trans-unit>
        <trans-unit id="23d76447f27a661de3ededbf433067f3b57aada4" translate="yes" xml:space="preserve">
          <source>Parameter properties are declared by prefixing a constructor parameter with an accessibility modifier or &lt;code&gt;readonly&lt;/code&gt;, or both. Using &lt;code&gt;private&lt;/code&gt; for a parameter property declares and initializes a private member; likewise, the same is done for &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, and &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target state="translated">パラメータプロパティは、コンストラクタパラメータの前にアクセシビリティ修飾子または &lt;code&gt;readonly&lt;/code&gt; 、あるいはその両方を付けることによって宣言されます。パラメータプロパティに &lt;code&gt;private&lt;/code&gt; を使用すると、プライベートメンバーが宣言および初期化されます。同様に、同じことが &lt;code&gt;public&lt;/code&gt; 、 &lt;code&gt;protected&lt;/code&gt; 、および &lt;code&gt;readonly&lt;/code&gt; でも行われます。</target>
        </trans-unit>
        <trans-unit id="a5861a8dac7bb4d916bedc720f28896beb64d2da" translate="yes" xml:space="preserve">
          <source>Parameters declaration with names starting with &lt;code&gt;_&lt;/code&gt; are exempt from the unused parameter checking. e.g.:</source>
          <target state="translated">名前が &lt;code&gt;_&lt;/code&gt; で始まるパラメーター宣言は、未使用のパラメーターチェックから除外されます。例えば：</target>
        </trans-unit>
        <trans-unit id="1d5eb18b61aab05bdced59d235a80d553895747d" translate="yes" xml:space="preserve">
          <source>Parameters&amp;lt;T&amp;gt;</source>
          <target state="translated">Parameters&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="671f3fae2448bb236314a1b80701d38996bd864d" translate="yes" xml:space="preserve">
          <source>Parse in strict mode and emit &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; for each source file</source>
          <target state="translated">strictモードで解析し、各ソースファイルに対して &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; を発行します</target>
        </trans-unit>
        <trans-unit id="fb8f88af978dfcbfd9d18606d5785e56e50c08a4" translate="yes" xml:space="preserve">
          <source>ParseIntBasedZipCodeValidator.ts</source>
          <target state="translated">ParseIntBasedZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="81409c19eb37440fe5909d317bb07700285e2cd5" translate="yes" xml:space="preserve">
          <source>Parses all the code in strict mode.</source>
          <target state="translated">すべてのコードを strict モードで解析します。</target>
        </trans-unit>
        <trans-unit id="f6713be85ff8a869b13ef23f83e9e25ec5b50fe4" translate="yes" xml:space="preserve">
          <source>Part of the intent with composite projects (&lt;code&gt;tsconfig.json&lt;/code&gt;s with &lt;code&gt;composite&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;) is that references between different projects can be built incrementally. As such, composite projects will &lt;strong&gt;always&lt;/strong&gt; produce &lt;code&gt;.tsbuildinfo&lt;/code&gt; files.</source>
          <target state="translated">複合プロジェクト（ &lt;code&gt;tsconfig.json&lt;/code&gt; で &lt;code&gt;composite&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定）の目的の一部は、異なるプロジェクト間の参照を段階的に構築できることです。そのため、複合プロジェクトは&lt;strong&gt;常に&lt;/strong&gt; &lt;code&gt;.tsbuildinfo&lt;/code&gt; ファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="9baf9fd34f2159270424fe0e47e69d1f478939e6" translate="yes" xml:space="preserve">
          <source>Partial&amp;lt;T&amp;gt;</source>
          <target state="translated">Partial&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1acacf2ed7601dbe25241b7869667be2f4398d94" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;--reactNamespace &amp;lt;JSX factory Name&amp;gt;&lt;/code&gt; along with &lt;code&gt;--jsx react&lt;/code&gt; allows for using a different JSX factory from the default &lt;code&gt;React&lt;/code&gt;.</source>
          <target state="translated">渡す &lt;code&gt;--reactNamespace &amp;lt;JSX factory Name&amp;gt;&lt;/code&gt; に沿って &lt;code&gt;--jsx react&lt;/code&gt; デフォルトが異なるJSXファクトリを使用することができます &lt;code&gt;React&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b536ca4bd24891bd16797247b74cf70cb1d7af1" translate="yes" xml:space="preserve">
          <source>Path mapping</source>
          <target state="translated">パスマッピング</target>
        </trans-unit>
        <trans-unit id="08f69b52b9788ae6bcf8bfd7c8d5cd0f9c96b35d" translate="yes" xml:space="preserve">
          <source>Patterns that are known NOT to be supported</source>
          <target state="translated">サポートされていないことが知られているパターン</target>
        </trans-unit>
        <trans-unit id="3ba5e04e0fb30f6bbbfe6f30b3c6d01934f1ea14" translate="yes" xml:space="preserve">
          <source>Per-file JSX factories</source>
          <target state="translated">ファイル単位の JSX ファクトリ</target>
        </trans-unit>
        <trans-unit id="b69b8b40e240a5b2dde72c51f503be50a498cd27" translate="yes" xml:space="preserve">
          <source>Perform additional checks to ensure that separate compilation (such as with &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function&quot;&gt;&lt;code&gt;transpileModule&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-typescript&quot;&gt;@babel/plugin-transform-typescript&lt;/a&gt;) would be safe.</source>
          <target state="translated">追加のチェックを実行して、個別のコンパイル（&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function&quot;&gt; &lt;code&gt;transpileModule&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-typescript&quot;&gt;@ babel / plugin-transform-typescriptなど&lt;/a&gt;）が安全であることを確認します。</target>
        </trans-unit>
        <trans-unit id="f1dabf49a10166e79b1f29fd393e4de4f943c1fd" translate="yes" xml:space="preserve">
          <source>Performance Improvements</source>
          <target state="translated">パフォーマンスの向上</target>
        </trans-unit>
        <trans-unit id="967f5cced0c55dd5104813d8b961e3e82073447f" translate="yes" xml:space="preserve">
          <source>Pick&amp;lt;T,K&amp;gt;</source>
          <target state="translated">Pick&amp;lt;T,K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7dee95ba04b4d77fd014972959587737b540740a" translate="yes" xml:space="preserve">
          <source>Pitfalls of Namespaces and Modules</source>
          <target state="translated">名前空間とモジュールの落とし穴</target>
        </trans-unit>
        <trans-unit id="a68eb230823a2defe94e6d3f9718ef2ec069c259" translate="yes" xml:space="preserve">
          <source>Playground</source>
          <target state="translated">Playground</target>
        </trans-unit>
        <trans-unit id="120335d270554865b243af6b51ed8c05b0d29c22" translate="yes" xml:space="preserve">
          <source>Please note that the compiler does not include files that can be possible outputs; e.g. if the input includes &lt;code&gt;index.ts&lt;/code&gt;, then &lt;code&gt;index.d.ts&lt;/code&gt; and &lt;code&gt;index.js&lt;/code&gt; are excluded. In general, having files that differ only in extension next to each other is not recommended.</source>
          <target state="translated">コンパイラには出力の可能性があるファイルは含まれていないことに注意してください。入力が含まれている場合、たとえば &lt;code&gt;index.ts&lt;/code&gt; を、その後、 &lt;code&gt;index.d.ts&lt;/code&gt; と &lt;code&gt;index.js&lt;/code&gt; が除外されています。一般に、拡張子のみが異なるファイルを隣り合わせに配置することはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="4463cb7b6e22fa9c87c1b09f8e8ea07ce2c6475b" translate="yes" xml:space="preserve">
          <source>Please note that this comment only suppresses the error reporting, and we recommend you use this comments &lt;em&gt;very sparingly&lt;/em&gt;.</source>
          <target state="translated">このコメントはエラー報告を抑制するだけであり、このコメントは&lt;em&gt;慎重に&lt;/em&gt;使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0468af199e7e628b9833d4c2499a87be9fef2421" translate="yes" xml:space="preserve">
          <source>Please note that this requires a native &lt;code&gt;Symbol.iterator&lt;/code&gt; or &lt;code&gt;Symbol.iterator&lt;/code&gt; shim at runtime for any non-array values.</source>
          <target state="translated">これには、実行時に配列以外の値のネイティブ &lt;code&gt;Symbol.iterator&lt;/code&gt; または &lt;code&gt;Symbol.iterator&lt;/code&gt; シムが必要であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="562837321f7a755d6cd24864fe1ca99abed6c53c" translate="yes" xml:space="preserve">
          <source>Please note that ts-loader is not the only loader for typescript.</source>
          <target state="translated">ts-loader は typescript 用の唯一のローダーではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="e4743356c30ff06ccc2c2b0526d63f34b220283d" translate="yes" xml:space="preserve">
          <source>Please notice that &lt;code&gt;&quot;paths&quot;&lt;/code&gt; are resolved relative to &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt;. When setting &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; to another value than &lt;code&gt;&quot;.&quot;&lt;/code&gt;, i.e. the directory of &lt;code&gt;tsconfig.json&lt;/code&gt;, the mappings must be changed accordingly. Say, you set &lt;code&gt;&quot;baseUrl&quot;: &quot;./src&quot;&lt;/code&gt; in the above example, then jquery should be mapped to &lt;code&gt;&quot;../node_modules/jquery/dist/jquery&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;paths&quot;&lt;/code&gt; は &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; 基準に解決されることに注意してください。 &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; を &lt;code&gt;&quot;.&quot;&lt;/code&gt; 以外の値に設定する場合。、つまり &lt;code&gt;tsconfig.json&lt;/code&gt; のディレクトリ、それに応じてマッピングを変更する必要があります。たとえば、上記の例で &lt;code&gt;&quot;baseUrl&quot;: &quot;./src&quot;&lt;/code&gt; を設定すると、jqueryは &lt;code&gt;&quot;../node_modules/jquery/dist/jquery&quot;&lt;/code&gt; にマップされます。</target>
        </trans-unit>
        <trans-unit id="ead1b84f2b03206f8601dd6f8465bb1307c87f49" translate="yes" xml:space="preserve">
          <source>Polymorphic &lt;code&gt;this&lt;/code&gt; types</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; タイプの多態性</target>
        </trans-unit>
        <trans-unit id="b7ea292a6c4159dcd9f22585ce812663d7d16f67" translate="yes" xml:space="preserve">
          <source>Polymorphic this types</source>
          <target state="translated">多相的なこのタイプ</target>
        </trans-unit>
        <trans-unit id="7280aa9b126e519bb5acdcab7417841a30bb930a" translate="yes" xml:space="preserve">
          <source>Possible values are:</source>
          <target state="translated">可能な値は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="554e31701ddcf7160047ee9c5af3bc8fa8c6a72a" translate="yes" xml:space="preserve">
          <source>Postfix equals on a property type in an object literal type doesn&amp;rsquo;t specify an optional property:</source>
          <target state="translated">オブジェクトリテラルタイプのプロパティタイプでPostfix equalsはオプションプロパティを指定しません：</target>
        </trans-unit>
        <trans-unit id="ab664bc802e07259299c0ace87c0d6fb9adaa06b" translate="yes" xml:space="preserve">
          <source>Predefined conditional types</source>
          <target state="translated">定義済みの条件タイプ</target>
        </trans-unit>
        <trans-unit id="0ca66f1be438badc25b8b5752ef03c58e504484d" translate="yes" xml:space="preserve">
          <source>Prepending a project will include the project&amp;rsquo;s output above the output of the current project. This works for both &lt;code&gt;.js&lt;/code&gt; files and &lt;code&gt;.d.ts&lt;/code&gt; files, and source map files will also be emitted correctly.</source>
          <target state="translated">プロジェクトの先頭に追加すると、現在のプロジェクトの出力の上にプロジェクトの出力が含まれます。これは &lt;code&gt;.js&lt;/code&gt; ファイルと &lt;code&gt;.d.ts&lt;/code&gt; ファイルの両方で機能し、ソースマップファイルも正しく出力されます。</target>
        </trans-unit>
        <trans-unit id="250b55e25eefbff70773c9389bd85b37a64c1d61" translate="yes" xml:space="preserve">
          <source>Preprocessing input files</source>
          <target state="translated">入力ファイルの前処理</target>
        </trans-unit>
        <trans-unit id="7cb4715a3e34715298728de107fabd8f250241bb" translate="yes" xml:space="preserve">
          <source>Prettier &lt;code&gt;--pretty&lt;/code&gt; output</source>
          <target state="translated">Prettier- &lt;code&gt;--pretty&lt;/code&gt; 出力</target>
        </trans-unit>
        <trans-unit id="8875ea5f28b04a1dba3fc41f80791c76ff0b7712" translate="yes" xml:space="preserve">
          <source>Prettier error messages from &lt;code&gt;tsc&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; からのよりきれいなエラーメッセージ</target>
        </trans-unit>
        <trans-unit id="0b0889dea75b7bf162c4dd45848c6ca53d9ef522" translate="yes" xml:space="preserve">
          <source>Preventing Name Conflicts</source>
          <target state="translated">名前の衝突を防ぐ</target>
        </trans-unit>
        <trans-unit id="d3f367a0268c7a11de846832dd78b1be0177bcf5" translate="yes" xml:space="preserve">
          <source>Previously CommonJS/AMD/UMD modules were treated in the same way as ES6 modules, resulting in a couple of problems. Namely:</source>
          <target state="translated">以前のCommonJS/AMD/UMDモジュールは、ES6モジュールと同じように扱われていたため、いくつかの問題が発生していました。すなわち</target>
        </trans-unit>
        <trans-unit id="1d4fe4dbc591edaa8152b6ee157716dc7c7a69dd" translate="yes" xml:space="preserve">
          <source>Previously an error, now supported in TypeScript 1.8. &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; declarations within loops and captured in functions are now emitted to correctly match &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; freshness semantics.</source>
          <target state="translated">以前はエラーでしたが、TypeScript 1.8でサポートされるようになりました。ループ内の &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; 宣言と関数でキャプチャされたものが &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; freshnessセマンティクスに正しく一致するように発行されるようになりました。</target>
        </trans-unit>
        <trans-unit id="d61f97a853643acc2132dd407bb52c28293cf6e2" translate="yes" xml:space="preserve">
          <source>Previously flagged as an invalid flag combination, &lt;code&gt;target: es5&lt;/code&gt; and &amp;lsquo;module: es6&amp;rsquo; is now supported. This should facilitate using ES2015-based tree shakers like &lt;a href=&quot;https://github.com/rollup/rollup&quot;&gt;rollup&lt;/a&gt;.</source>
          <target state="translated">以前は無効なフラグの組み合わせとしてフラグが付けられていましたが、 &lt;code&gt;target: es5&lt;/code&gt; および 'module：es6'がサポートされるようになりました。これは次のようにES2015ベースのツリーシェーカーを使用して促進すべきである&lt;a href=&quot;https://github.com/rollup/rollup&quot;&gt;ロールアップ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="faa74f7ad7771f21799b2755f15db749aa0b46e9" translate="yes" xml:space="preserve">
          <source>Previously generators were only supported if the target is ES6/ES2015 or later. Moreover, constructs that operate on the Iterator protocol, e.g. &lt;code&gt;for..of&lt;/code&gt; were only supported if they operate on arrays for targets below ES6/ES2015.</source>
          <target state="translated">以前のジェネレーターは、ターゲットがES6 / ES2015以降の場合にのみサポートされていました。さらに、 &lt;code&gt;for..of&lt;/code&gt; などのIteratorプロトコルで動作する構成体は、ES6 / ES2015以下のターゲットのアレイで動作する場合にのみサポートされていました。</target>
        </trans-unit>
        <trans-unit id="8d6c2a15e3d095aa407d66625a136a8551aa98ed" translate="yes" xml:space="preserve">
          <source>Previously the type of a &lt;code&gt;for..in&lt;/code&gt; variable is inferred to &lt;code&gt;any&lt;/code&gt;; that allowed the compiler to ignore invalid uses within the &lt;code&gt;for..in&lt;/code&gt; body.</source>
          <target state="translated">以前は、 &lt;code&gt;for..in&lt;/code&gt; 変数の型はanyに推論され &lt;code&gt;any&lt;/code&gt; 。これにより、コンパイラは &lt;code&gt;for..in&lt;/code&gt; 本文内の無効な使用を無視できました。</target>
        </trans-unit>
        <trans-unit id="ebaf09b657b780c25626ff17cb194ecb5fc7de40" translate="yes" xml:space="preserve">
          <source>Previously there were two options:</source>
          <target state="translated">以前は2つの選択肢がありました。</target>
        </trans-unit>
        <trans-unit id="23e202efb0fd224642346517ba263b85cbcde129" translate="yes" xml:space="preserve">
          <source>Previously type &lt;code&gt;{}&lt;/code&gt; was inferred for &lt;code&gt;obj&lt;/code&gt; and the second line subsequently caused an error because &lt;code&gt;obj&lt;/code&gt; would appear to have no properties. That obviously wasn&amp;rsquo;t ideal.</source>
          <target state="translated">以前にタイプ &lt;code&gt;{}&lt;/code&gt; のために推定された &lt;code&gt;obj&lt;/code&gt; 及びため2行目は、その後、エラーの原因となった &lt;code&gt;obj&lt;/code&gt; がない特性を有していないように見えます。それは明らかに理想的ではありませんでした。</target>
        </trans-unit>
        <trans-unit id="6904fbec6e39643bc5d34a20c1cf3e6eba117f94" translate="yes" xml:space="preserve">
          <source>Previously, a non-disciminated union wouldn&amp;rsquo;t have &lt;em&gt;any&lt;/em&gt; excess property checking done on its members, and as a result, the incorrectly typed &lt;code&gt;name&lt;/code&gt; property slipped by.</source>
          <target state="translated">以前は、差別化されていない共用体では、そのメンバー&lt;em&gt;に対して&lt;/em&gt;過剰なプロパティチェックが行われず、その結果、誤って入力された &lt;code&gt;name&lt;/code&gt; プロパティがずれていました。</target>
        </trans-unit>
        <trans-unit id="b72465fae7e40823511074b9719794d968033526" translate="yes" xml:space="preserve">
          <source>Previously, if TypeScript couldn&amp;rsquo;t figure out the type of a variable, it would choose the &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">以前は、TypeScriptが変数の型を判別できなかった場合、 &lt;code&gt;any&lt;/code&gt; 型を選択していました。</target>
        </trans-unit>
        <trans-unit id="9db6c336a1faa6c435e85a6b4d2c798009098564" translate="yes" xml:space="preserve">
          <source>Previously, this structure was rather awkward to work with if you used a single tsconfig file:</source>
          <target state="translated">以前は、単一のtsconfigファイルを使用している場合、この構造は作業しづらいものでした。</target>
        </trans-unit>
        <trans-unit id="4ca4680280d5d8dfe7b7cb9edd9e85d1751a8dc5" translate="yes" xml:space="preserve">
          <source>Print help message.</source>
          <target state="translated">ヘルプメッセージを印刷します。</target>
        </trans-unit>
        <trans-unit id="ae5d509d63bcd9fdd20c4fe9f09a64383b22ba2a" translate="yes" xml:space="preserve">
          <source>Print names of files part of the compilation.</source>
          <target state="translated">コンパイルに含まれるファイル名を表示します。</target>
        </trans-unit>
        <trans-unit id="220c873ce1ef6bbe0f0ef43fc4cd6015a80b747a" translate="yes" xml:space="preserve">
          <source>Print names of generated files part of the compilation.</source>
          <target state="translated">コンパイルの一部として生成されたファイルの名前を表示します。</target>
        </trans-unit>
        <trans-unit id="e11fa3aee584489ac6535e0339f143acea43fb5c" translate="yes" xml:space="preserve">
          <source>Print the compiler&amp;rsquo;s version.</source>
          <target state="translated">コンパイラのバージョンを出力します。</target>
        </trans-unit>
        <trans-unit id="23bb025493ad52ae749fb36ab7d38c5792fcafeb" translate="yes" xml:space="preserve">
          <source>Prior to 3.3, building composite projects using &lt;code&gt;--build --watch&lt;/code&gt; actually didn&amp;rsquo;t use this incremental file watching infrastructure. An update in one project under &lt;code&gt;--build --watch&lt;/code&gt; mode would force a full build of that project, rather than determining which files within that project were affected.</source>
          <target state="translated">3.3より前の &lt;code&gt;--build --watch&lt;/code&gt; を使用して複合プロジェクトをビルドする場合、実際にはこの増分ファイル監視インフラストラクチャは使用されませんでした。 &lt;code&gt;--build --watch&lt;/code&gt; モードでの1つのプロジェクトの更新は、そのプロジェクト内のどのファイルが影響を受けたかを判断するのではなく、そのプロジェクトの完全ビルドを強制します。</target>
        </trans-unit>
        <trans-unit id="6a5128736476603248154c428e88c700f0590e6b" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 2.4, in the following example</source>
          <target state="translated">TypeScript 2.4以前では、以下の例では</target>
        </trans-unit>
        <trans-unit id="480d4967754d83dbb3e8d2828c5c21cd16621298" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 2.4, this example would succeed. When relating the types of &lt;code&gt;map&lt;/code&gt;, TypeScript would bidirectionally relate their parameters (i.e. the type of &lt;code&gt;f&lt;/code&gt;). When relating each &lt;code&gt;f&lt;/code&gt;, TypeScript would also bidirectionally relate the type of &lt;em&gt;those&lt;/em&gt; parameters.</source>
          <target state="translated">TypeScript 2.4以前では、この例は成功していました。 &lt;code&gt;map&lt;/code&gt; のタイプを関連付ける場合、TypeScriptはそれらのパラメータを双方向に関連付けます（つまり、 &lt;code&gt;f&lt;/code&gt; のタイプ）。TypeScriptは、各 &lt;code&gt;f&lt;/code&gt; を関連付けるときに、&lt;em&gt;これらの&lt;/em&gt;パラメーターの型を双方向に関連付けます。</target>
        </trans-unit>
        <trans-unit id="d2ca142f68efb0104a146fa7d73e2068d50895f3" translate="yes" xml:space="preserve">
          <source>Private and Protected Constructors</source>
          <target state="translated">民間および保護された建設業者</target>
        </trans-unit>
        <trans-unit id="f4b81a5cab787b4701243c836cb9e4bed8b1e31d" translate="yes" xml:space="preserve">
          <source>Private and protected members in a class affect their compatibility. When an instance of a class is checked for compatibility, if the target type contains a private member, then the source type must also contain a private member that originated from the same class. Likewise, the same applies for an instance with a protected member. This allows a class to be assignment compatible with its super class, but &lt;em&gt;not&lt;/em&gt; with classes from a different inheritance hierarchy which otherwise have the same shape.</source>
          <target state="translated">クラスのプライベートおよび保護されたメンバーは、それらの互換性に影響します。クラスのインスタンスの互換性をチェックするときに、ターゲットタイプにプライベートメンバーが含まれている場合、ソースタイプには、同じクラスから派生したプライベートメンバーも含まれている必要があります。同様に、保護されたメンバーを持つインスタンスにも同じことが当てはまります。これにより、クラスはそのスーパークラスとの割り当て互換性を持つことが&lt;em&gt;でき&lt;/em&gt;ますが、それ以外の点では同じ形状を持つ継承階層のクラスとは互換性があり&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e91301edc2c04ca7b2fe236a0af7531759595434" translate="yes" xml:space="preserve">
          <source>Private and protected members in classes</source>
          <target state="translated">クラスのプライベートと保護されたメンバー</target>
        </trans-unit>
        <trans-unit id="15fd0634ed725b1581380519d93db35711d918e3" translate="yes" xml:space="preserve">
          <source>ProgrammerCalculator.ts</source>
          <target state="translated">ProgrammerCalculator.ts</target>
        </trans-unit>
        <trans-unit id="567585a6d21c8b924898dbfb1c1f5b51255b4838" translate="yes" xml:space="preserve">
          <source>Project Configuration</source>
          <target state="translated">プロジェクトの構成</target>
        </trans-unit>
        <trans-unit id="7793a73613168871bf96397b630c7423c4486ca5" translate="yes" xml:space="preserve">
          <source>Project References</source>
          <target state="translated">プロジェクトのリファレンス</target>
        </trans-unit>
        <trans-unit id="88f5397c06a7b7e37512d16b9ab11703488d260e" translate="yes" xml:space="preserve">
          <source>Project References: Build Mode for TypeScript</source>
          <target state="translated">プロジェクトのリファレンス。TypeScript のビルドモード</target>
        </trans-unit>
        <trans-unit id="754b3c7e71d4817f7d2fea3c257de1bdf3f58125" translate="yes" xml:space="preserve">
          <source>Project References: Caveats</source>
          <target state="translated">プロジェクトの参考文献。警告</target>
        </trans-unit>
        <trans-unit id="f6929baa8a0f682ca9e2d3784d0cff5d27cdab03" translate="yes" xml:space="preserve">
          <source>Project References: Caveats for Project References</source>
          <target state="translated">プロジェクトリファレンス。プロジェクトの参考文献に関する注意事項</target>
        </trans-unit>
        <trans-unit id="d0bd4d6b0aa124935089e5a1a6357f47ce88863d" translate="yes" xml:space="preserve">
          <source>Project References: MSBuild</source>
          <target state="translated">プロジェクトの参照先。MSBuild</target>
        </trans-unit>
        <trans-unit id="2d88f084a46bb059f7acb5d62832e90394777d3f" translate="yes" xml:space="preserve">
          <source>Project References: Overall Structure</source>
          <target state="translated">プロジェクトの参考資料。全体構造</target>
        </trans-unit>
        <trans-unit id="a0c2677e3090197b68e74d61303c68e7ddf04e66" translate="yes" xml:space="preserve">
          <source>Project References: Structuring for outFiles</source>
          <target state="translated">プロジェクトのリファレンス。outFilesの構造化</target>
        </trans-unit>
        <trans-unit id="810687c4e3229aa8caaccaa1985884772dfd3c9a" translate="yes" xml:space="preserve">
          <source>Project References: Structuring for relative modules</source>
          <target state="translated">プロジェクトのリファレンス。相対モジュールの構造化</target>
        </trans-unit>
        <trans-unit id="692d23787c48f3266c6f90679b8a1de2796d67f6" translate="yes" xml:space="preserve">
          <source>Project References: What is a Project Reference?</source>
          <target state="translated">プロジェクトリファレンス。プロジェクトリファレンスとは?</target>
        </trans-unit>
        <trans-unit id="394f18fdbb76c8acbdccddfc544deb4de35c052d" translate="yes" xml:space="preserve">
          <source>Project References: composite</source>
          <target state="translated">プロジェクトの参照先:複合材</target>
        </trans-unit>
        <trans-unit id="6d41bc9c0f6a331071fce870316ec281371a0d75" translate="yes" xml:space="preserve">
          <source>Project References: declarationMaps</source>
          <target state="translated">プロジェクトの参照先:declarationMaps</target>
        </trans-unit>
        <trans-unit id="908cd420bcb700a967b280f8a7dff581392527b2" translate="yes" xml:space="preserve">
          <source>Project References: prepend with outFile</source>
          <target state="translated">プロジェクトのリファレンス:outFileの前に</target>
        </trans-unit>
        <trans-unit id="64e335b1c5f861587f8782361a5af32ae20dcd21" translate="yes" xml:space="preserve">
          <source>Project References: tsc -b Commandline</source>
          <target state="translated">プロジェクトリファレンス:tsc -b コマンドライン</target>
        </trans-unit>
        <trans-unit id="fd7a6c05d7b3d7052f1c042cfc959322d90b11a4" translate="yes" xml:space="preserve">
          <source>Project references are a new feature in TypeScript 3.0 that allow you to structure your TypeScript programs into smaller pieces.</source>
          <target state="translated">プロジェクト参照は、TypeScript 3.0の新機能であり、TypeScriptプログラムをより小さなピースで構成することができます。</target>
        </trans-unit>
        <trans-unit id="4c6c967b1595e112d0adf09d5676eb35634edcb7" translate="yes" xml:space="preserve">
          <source>Project references can solve all of these problems and more.</source>
          <target state="translated">プロジェクトの参照は、これらの問題などをすべて解決することができます。</target>
        </trans-unit>
        <trans-unit id="1b126f1d1bec5fc383003c78a666ee84f0286aac" translate="yes" xml:space="preserve">
          <source>Project references have a few trade-offs you should be aware of.</source>
          <target state="translated">プロジェクトのリファレンスには、知っておくべきトレードオフがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="d846e8e5c61d018f2fdaece28ac3df9b54800862" translate="yes" xml:space="preserve">
          <source>Project support through &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; によるプロジェクトのサポート</target>
        </trans-unit>
        <trans-unit id="3d66fcc6f48609ad7f0ccc3524762b07b0fb5050" translate="yes" xml:space="preserve">
          <source>Properties are inferred from assignments in class bodies</source>
          <target state="translated">プロパティは、クラス本体の代入から推測されます。</target>
        </trans-unit>
        <trans-unit id="33bbcb8beed2dadd8ed7e8a6d283214d6efdf708" translate="yes" xml:space="preserve">
          <source>Properties declarations on functions</source>
          <target state="translated">関数のプロパティ宣言</target>
        </trans-unit>
        <trans-unit id="2e110b7b4893d92d3e7aa88aa3a301b45ead4967" translate="yes" xml:space="preserve">
          <source>Properties in the object binding pattern that have no match in the object literal are required to have a default value in the object binding pattern and are automatically added to the object literal type.</source>
          <target state="translated">オブジェクトリテラルに一致しないオブジェクトバインディングパターンのプロパティは、オブジェクトバインディングパターンでデフォルト値を持つ必要があり、オブジェクトリテラル型に自動的に追加されます。</target>
        </trans-unit>
        <trans-unit id="c8c07940eda3231c047d293da9f37f7834dd40cb" translate="yes" xml:space="preserve">
          <source>Properties in the object literal that have no match in the object binding pattern are an error.</source>
          <target state="translated">オブジェクト・リテラル内のプロパティで、オブジェクト・バインディング・パターンに一致しないものはエラーです。</target>
        </trans-unit>
        <trans-unit id="f8cc4919fcb9285716ac09c9df472748a0cd6f09" translate="yes" xml:space="preserve">
          <source>Properties with default values in the object binding pattern become optional in the object literal.</source>
          <target state="translated">オブジェクト・バインディング・パターンのデフォルト値を持つプロパティは、オブジェクト・リテラルではオプションになります。</target>
        </trans-unit>
        <trans-unit id="3cbcb3278bdf5d0340f45b88be40ef4d53f50ba6" translate="yes" xml:space="preserve">
          <source>Property Decorators</source>
          <target state="translated">プロパティデコレーター</target>
        </trans-unit>
        <trans-unit id="ce5358cfe7c2a6843f2919f24e964b409bffae5b" translate="yes" xml:space="preserve">
          <source>Property assignments and non-generic spread expressions are merged to the greatest extent possible on either side of a generic spread expression. For example:</source>
          <target state="translated">プロパティの割り当てと非ジェネリックな広がり表現は、ジェネリックな広がり表現の両側で可能な限りマージされます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="832f7d76da1eb3d3ed83c2498cd0b5b699ea5efe" translate="yes" xml:space="preserve">
          <source>Property renaming</source>
          <target state="translated">プロパティの名称変更</target>
        </trans-unit>
        <trans-unit id="28531336563e1f3883b87d858af447e561471bd7" translate="yes" xml:space="preserve">
          <source>Protected</source>
          <target state="translated">Protected</target>
        </trans-unit>
        <trans-unit id="f0e692539cb524363ffe3c3313543515de8c4424" translate="yes" xml:space="preserve">
          <source>Prototype assignment</source>
          <target state="translated">プロトタイプの割り当て</target>
        </trans-unit>
        <trans-unit id="001b7307089ddcafb90fad2dff22ffc7a1e3c62c" translate="yes" xml:space="preserve">
          <source>Provide full support for iterables in &lt;code&gt;for..of&lt;/code&gt;, spread and destructuring when targeting ES5 or ES3.</source>
          <target state="translated">ES5またはES3を対象とする場合、 &lt;code&gt;for..of&lt;/code&gt; 、spread、およびdestructuringの反復可能オブジェクトを完全にサポートします。</target>
        </trans-unit>
        <trans-unit id="a1146ed26ee333eed6d3996e25afdde504ab9e9b" translate="yes" xml:space="preserve">
          <source>Public by default</source>
          <target state="translated">デフォルトではパブリック</target>
        </trans-unit>
        <trans-unit id="df1e7a58b300fcd2018db41d09e99c76f51ccd9c" translate="yes" xml:space="preserve">
          <source>Public, private, and protected modifiers</source>
          <target state="translated">パブリック、プライベート、保護された修飾子</target>
        </trans-unit>
        <trans-unit id="4aeb4ef1d8df7836057d41c034dc834be57b173f" translate="yes" xml:space="preserve">
          <source>Publish to &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@typesに&lt;/a&gt;公開</target>
        </trans-unit>
        <trans-unit id="b1aa195e794b4f66b923622c595d29c04615285a" translate="yes" xml:space="preserve">
          <source>Publish to npm</source>
          <target state="translated">npmへの公開</target>
        </trans-unit>
        <trans-unit id="338b45a6751558a0e49cb2d757f64736adc58f12" translate="yes" xml:space="preserve">
          <source>Publishing</source>
          <target state="translated">Publishing</target>
        </trans-unit>
        <trans-unit id="be0e9506d0fd3f0204f58e0f5b06282be66a0f23" translate="yes" xml:space="preserve">
          <source>Publishing: Dependencies</source>
          <target state="translated">出版:依存関係</target>
        </trans-unit>
        <trans-unit id="ed87f3075dc9e52018557fb97c9010a8f00d2af8" translate="yes" xml:space="preserve">
          <source>Publishing: Publish to @types</source>
          <target state="translated">パブリッシング:@typesにパブリッシュ</target>
        </trans-unit>
        <trans-unit id="c25e21d552520e10e91602755603035ee2dc11de" translate="yes" xml:space="preserve">
          <source>Publishing: Red flags</source>
          <target state="translated">出版:レッドフラッグ</target>
        </trans-unit>
        <trans-unit id="322bb8d07bb59be9606da97b40f86a36058152ee" translate="yes" xml:space="preserve">
          <source>Put a breakpoint on the line with return.</source>
          <target state="translated">リターンでラインにブレークポイントを置く。</target>
        </trans-unit>
        <trans-unit id="a1b752d5b588559d3c1ab9de849d0678ef2991f1" translate="yes" xml:space="preserve">
          <source>Putting all of the above rules together in an example</source>
          <target state="translated">上記のルールをすべて例に挙げると</target>
        </trans-unit>
        <trans-unit id="c148aded3d47eba6bad059e92b2038d207b0a750" translate="yes" xml:space="preserve">
          <source>Putting it all together</source>
          <target state="translated">まとめてみると</target>
        </trans-unit>
        <trans-unit id="ab61ee9bc98f1490cb74d9856a2bcfdb903bd123" translate="yes" xml:space="preserve">
          <source>Quick introductions based on your background or preference.</source>
          <target state="translated">経歴や好みに応じて、簡単な紹介をします。</target>
        </trans-unit>
        <trans-unit id="224762d86a9baf2c769b2d7a923fbcab59d453ee" translate="yes" xml:space="preserve">
          <source>Raise error on &lt;code&gt;this&lt;/code&gt; expressions with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">暗黙の &lt;code&gt;any&lt;/code&gt; タイプを使用して、 &lt;code&gt;this&lt;/code&gt; 式のエラーを発生させます。</target>
        </trans-unit>
        <trans-unit id="36eec16ea1bf9722ff825e6c1dfe6c84e5ad8600" translate="yes" xml:space="preserve">
          <source>Raise error on expressions and declarations with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">暗黙の &lt;code&gt;any&lt;/code&gt; タイプの式と宣言でエラーを発生させます。</target>
        </trans-unit>
        <trans-unit id="374e9f700483653b29a58cc7f00cdaf51ae907b5" translate="yes" xml:space="preserve">
          <source>Rather than actually execute a build with the other input options and config files, show the final implied config file in the output.</source>
          <target state="translated">他の入力オプションとコンフィグファイルを使って実際にビルドを実行するのではなく、最終的なインプライドされたコンフィグファイルを出力に表示します。</target>
        </trans-unit>
        <trans-unit id="8b1872d78c17fd0391a92cf444a735ee5e6bae28" translate="yes" xml:space="preserve">
          <source>Re-compiling, you&amp;rsquo;ll now see an error:</source>
          <target state="translated">再コンパイルすると、エラーが表示されます。</target>
        </trans-unit>
        <trans-unit id="6c315f12f77496f53aa14fdb148faec85d5b7486" translate="yes" xml:space="preserve">
          <source>Re-declarations and Shadowing</source>
          <target state="translated">再宣言とシャドーイング</target>
        </trans-unit>
        <trans-unit id="fdc685fb106414cf637a1b38813a53d910b18ec9" translate="yes" xml:space="preserve">
          <source>Re-export to extend</source>
          <target state="translated">拡張するための再エクスポート</target>
        </trans-unit>
        <trans-unit id="648cfabc9a420f1e968be9f4f509254b2ab2cbc0" translate="yes" xml:space="preserve">
          <source>Re-exporting</source>
          <target state="translated">Re-exporting</target>
        </trans-unit>
        <trans-unit id="eda2bfe47f1cfbe6424bba7d3a76f901f6b42466" translate="yes" xml:space="preserve">
          <source>Re-exports</source>
          <target state="translated">Re-exports</target>
        </trans-unit>
        <trans-unit id="eb5bcada059371623621a43a8e7c9b5feeb2c5ef" translate="yes" xml:space="preserve">
          <source>Re-run &lt;code&gt;tsc greeter.ts&lt;/code&gt; and you&amp;rsquo;ll see the generated JavaScript is the same as the earlier code. Classes in TypeScript are just a shorthand for the same prototype-based OO that is frequently used in JavaScript.</source>
          <target state="translated">&lt;code&gt;tsc greeter.ts&lt;/code&gt; を再実行すると、生成されたJavaScriptが以前のコードと同じであることがわかります。TypeScriptのクラスは、JavaScriptで頻繁に使用される同じプロトタイプベースのOOの省略形にすぎません。</target>
        </trans-unit>
        <trans-unit id="0800d078d61e87e277eaae4d8414a88253e82cf4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack</source>
          <target state="translated">React＆Webpack</target>
        </trans-unit>
        <trans-unit id="c6ad73159db4fbc79a9e826240d2405491564ef3" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Add a TypeScript configuration file</source>
          <target state="translated">React＆Webpack：TypeScript構成ファイルを追加する</target>
        </trans-unit>
        <trans-unit id="328cdad5c6c6e56604b6063e3fdaca83a43aa289" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Create a webpack configuration file</source>
          <target state="translated">React＆Webpack：Webpack構成ファイルを作成する</target>
        </trans-unit>
        <trans-unit id="b99e8dd71da2d3b5ad0aa22f4c73bf525f613bf7" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Initialize the project</source>
          <target state="translated">React＆Webpack：プロジェクトを初期化する</target>
        </trans-unit>
        <trans-unit id="e79de56f4434ed0a6e8d586e225decedd4a4b91a" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Install our dependencies</source>
          <target state="translated">React＆Webpack：依存関係をインストールする</target>
        </trans-unit>
        <trans-unit id="a6f634b484a857760fd1fe0c0b8caa1f4ad1a7a4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Lay out the project</source>
          <target state="translated">React＆Webpack：プロジェクトをレイアウトする</target>
        </trans-unit>
        <trans-unit id="70d16f67e5b10f58dde0039090fa1f15716caaa4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Putting it all together</source>
          <target state="translated">React＆Webpack：すべてをまとめる</target>
        </trans-unit>
        <trans-unit id="c1326a95c630b81552ae15e8939b25927eca9f30" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Write some code</source>
          <target state="translated">React＆Webpack：コードを書く</target>
        </trans-unit>
        <trans-unit id="58842bd13325c48a2698202bdb55d3b757360943" translate="yes" xml:space="preserve">
          <source>React integration</source>
          <target state="translated">リアクト統合</target>
        </trans-unit>
        <trans-unit id="3ce4f7210a5cf94a25154fce20154f3f93c9f258" translate="yes" xml:space="preserve">
          <source>React-native build pipeline expects all files to have a &lt;code&gt;.js&lt;/code&gt; extensions even if the file contains JSX syntax. The new &lt;code&gt;--jsx&lt;/code&gt; value &lt;code&gt;react-native&lt;/code&gt; will persevere the JSX syntax in the output file, but give it a &lt;code&gt;.js&lt;/code&gt; extension.</source>
          <target state="translated">Reactネイティブのビルドパイプラインは、ファイルにJSX構文が含まれている場合でも、すべてのファイルに &lt;code&gt;.js&lt;/code&gt; 拡張子が付いていることを想定しています。新しい &lt;code&gt;--jsx&lt;/code&gt; 値 &lt;code&gt;react-native&lt;/code&gt; は、出力ファイルのJSX構文を保持しますが、 &lt;code&gt;.js&lt;/code&gt; 拡張子を付けます。</target>
        </trans-unit>
        <trans-unit id="91699c24f2e0a9b9e92adecd16c0b3f7f436f6cb" translate="yes" xml:space="preserve">
          <source>Read in any files it understands in the &lt;code&gt;src&lt;/code&gt; directory (with &lt;code&gt;include&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; ディレクトリで理解できるファイルを読み込みます（ &lt;code&gt;include&lt;/code&gt; を使用）。</target>
        </trans-unit>
        <trans-unit id="2a5eba8a5ad07b0a44f5a4a457fdc20c1b7dbf7f" translate="yes" xml:space="preserve">
          <source>Read-only properties and index signatures</source>
          <target state="translated">読み取り専用のプロパティとインデックス署名</target>
        </trans-unit>
        <trans-unit id="98f4c7227b38a0bf0e16a93bbf9b95c02d029667" translate="yes" xml:space="preserve">
          <source>Read-only properties may have initializers and may be assigned to in constructors within the same class declaration, but otherwise assignments to read-only properties are disallowed.</source>
          <target state="translated">読み取り専用プロパティはイニシャライザを持つことができ、同じクラス宣言内のコンストラクタに代入することができますが、それ以外の場合は読み取り専用プロパティへの代入は禁止されています。</target>
        </trans-unit>
        <trans-unit id="7386588f18988cfe9593c3202dc16be85d972e3f" translate="yes" xml:space="preserve">
          <source>Readonly modifier</source>
          <target state="translated">読み取り専用修飾子</target>
        </trans-unit>
        <trans-unit id="097c59114ca50eec3cf0a821be259c50e9b74d04" translate="yes" xml:space="preserve">
          <source>Readonly properties</source>
          <target state="translated">読み取り専用プロパティ</target>
        </trans-unit>
        <trans-unit id="6d74bc61c8b8b435782687890427a863cef761e7" translate="yes" xml:space="preserve">
          <source>Readonly&amp;lt;T&amp;gt;</source>
          <target state="translated">Readonly&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4699a4a521bfdbbfcae804201e013659f911e1a8" translate="yes" xml:space="preserve">
          <source>Ready? Take a look:</source>
          <target state="translated">準備はいいですか?見てみろ</target>
        </trans-unit>
        <trans-unit id="0cbc39f65d2c6c44eebf7ed41f07d520bd81bbe9" translate="yes" xml:space="preserve">
          <source>Real applications, however, look like &lt;code&gt;Readonly&lt;/code&gt; or &lt;code&gt;Partial&lt;/code&gt; above. They&amp;rsquo;re based on some existing type, and they transform the properties in some way. That&amp;rsquo;s where &lt;code&gt;keyof&lt;/code&gt; and indexed access types come in:</source>
          <target state="translated">ただし、実際のアプリケーションは、上記の &lt;code&gt;Readonly&lt;/code&gt; または &lt;code&gt;Partial&lt;/code&gt; ように見えます。これらは既存のタイプに基づいており、プロパティを何らかの方法で変換します。そこで &lt;code&gt;keyof&lt;/code&gt; のがkeyofとインデックス付きのアクセスタイプです。</target>
        </trans-unit>
        <trans-unit id="f1d90148c2f9c29ea449489201d6864609117f05" translate="yes" xml:space="preserve">
          <source>Recall how to write a type assertion:</source>
          <target state="translated">型アサーションの書き方を思い出してください。</target>
        </trans-unit>
        <trans-unit id="c5d97500640d6a0752241e63626a067412fd2a00" translate="yes" xml:space="preserve">
          <source>Recall that Node.js looked for a file named &lt;code&gt;moduleB.js&lt;/code&gt;, then an applicable &lt;code&gt;package.json&lt;/code&gt;, and then for an &lt;code&gt;index.js&lt;/code&gt;.</source>
          <target state="translated">Node.jsのが名前のファイルを探したことを思い出し &lt;code&gt;moduleB.js&lt;/code&gt; 適用、その後、 &lt;code&gt;package.json&lt;/code&gt; 、その後のための &lt;code&gt;index.js&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af653faed29a78b35af6aadab7ff219a754ccd8b" translate="yes" xml:space="preserve">
          <source>Recall that with our earlier &lt;code&gt;setTimeout&lt;/code&gt; example, we ended up needing to use an IIFE to capture the state of a variable for every iteration of the &lt;code&gt;for&lt;/code&gt; loop. In effect, what we were doing was creating a new variable environment for our captured variables. That was a bit of a pain, but luckily, you&amp;rsquo;ll never have to do that again in TypeScript.</source>
          <target state="translated">以前の &lt;code&gt;setTimeout&lt;/code&gt; の例では、IIFEを使用して &lt;code&gt;for&lt;/code&gt; ループの反復ごとに変数の状態をキャプチャする必要があったことを思い出してください。実際、私たちが行っていたのは、取得した変数用の新しい変数環境を作成することでした。これは少し苦痛でしたが、幸いなことに、TypeScriptでこれを再度行う必要はありません。</target>
        </trans-unit>
        <trans-unit id="4faa65b556f68207d69cb14bcae4acb71980a036" translate="yes" xml:space="preserve">
          <source>Recommendations</source>
          <target state="translated">Recommendations</target>
        </trans-unit>
        <trans-unit id="5838e1d2256d8060aa1b3a66e780f5f99fa40b5e" translate="yes" xml:space="preserve">
          <source>Record&amp;lt;K,T&amp;gt;</source>
          <target state="translated">Record&amp;lt;K,T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4a41add58030e39fbaf51db74fe2dbb02e5e4ab1" translate="yes" xml:space="preserve">
          <source>Red Flags</source>
          <target state="translated">赤旗</target>
        </trans-unit>
        <trans-unit id="34d53f3ab50503026ac59429b75482fa11e6a5b9" translate="yes" xml:space="preserve">
          <source>Red flags</source>
          <target state="translated">赤旗</target>
        </trans-unit>
        <trans-unit id="9103e88842d8a8fd8fdef77a63d0bed96f6e7b8c" translate="yes" xml:space="preserve">
          <source>Redirect output structure to the directory.</source>
          <target state="translated">出力構造体をディレクトリにリダイレクトします。</target>
        </trans-unit>
        <trans-unit id="4712f8dca718bd28253a5790647646c3533841da" translate="yes" xml:space="preserve">
          <source>Referenced projects must have the new &lt;code&gt;composite&lt;/code&gt; setting enabled. This setting is needed to ensure TypeScript can quickly determine where to find the outputs of the referenced project. Enabling the &lt;code&gt;composite&lt;/code&gt; flag changes a few things:</source>
          <target state="translated">参照されるプロジェクトでは、新しい &lt;code&gt;composite&lt;/code&gt; 設定を有効にする必要があります。この設定は、TypeScriptが参照プロジェクトの出力を見つける場所をすばやく決定できるようにするために必要です。 &lt;code&gt;composite&lt;/code&gt; フラグを有効にすると、いくつかの変更があります。</target>
        </trans-unit>
        <trans-unit id="f716fe211e8cbfb1b5ac185fb3d6bbbbc2b34ab2" translate="yes" xml:space="preserve">
          <source>Referring to objects in the value space as types doesn&amp;rsquo;t work unless the object also creates a type, like a constructor function.</source>
          <target state="translated">値スペース内のオブジェクトをタイプとして参照することは、オブジェクトがコンストラクター関数のようにタイプも作成しない限り機能しません。</target>
        </trans-unit>
        <trans-unit id="917df91e1730cb55ff8aba76f721651a6b54a840" translate="yes" xml:space="preserve">
          <source>Related</source>
          <target state="translated">Related</target>
        </trans-unit>
        <trans-unit id="0d61ba1d171892a4a7567647b72650543ee4275d" translate="yes" xml:space="preserve">
          <source>Relative paths are fairly straightforward. As an example, let&amp;rsquo;s consider a file located at &lt;code&gt;/root/src/moduleA.js&lt;/code&gt;, which contains the import &lt;code&gt;var x = require(&quot;./moduleB&quot;);&lt;/code&gt; Node.js resolves that import in the following order:</source>
          <target state="translated">相対パスはかなり単純です。一例として、のがにあるファイルを検討してみましょう &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; 輸入が含まれ、 &lt;code&gt;var x = require(&quot;./moduleB&quot;);&lt;/code&gt; Node.jsは、次の順序でインポートを解決します。</target>
        </trans-unit>
        <trans-unit id="227f526e9deba436f5046f9ae5ceb4b3a9053811" translate="yes" xml:space="preserve">
          <source>Relative vs. Non-relative module imports</source>
          <target state="translated">相対的なモジュールのインポートと非相対的なモジュールのインポート</target>
        </trans-unit>
        <trans-unit id="2ff253f328340904e6aa7b404e19bda3c645fe78" translate="yes" xml:space="preserve">
          <source>Relaxing declaration emit visiblity rules</source>
          <target state="translated">緩和宣言は可視性のルールを放出する</target>
        </trans-unit>
        <trans-unit id="1d3768a1e142e6e3ef4c29558ba7b7010322ddb0" translate="yes" xml:space="preserve">
          <source>Remember what we mentioned earlier about variable capturing? Every function expression we pass to &lt;code&gt;setTimeout&lt;/code&gt; actually refers to the same &lt;code&gt;i&lt;/code&gt; from the same scope.</source>
          <target state="translated">変数のキャプチャについて前述したことを覚えていますか？ &lt;code&gt;setTimeout&lt;/code&gt; に渡すすべての関数式は、実際には同じスコープの同じ &lt;code&gt;i&lt;/code&gt; を参照します。</target>
        </trans-unit>
        <trans-unit id="f11d0e5af8f40be276413a0572f57b6d8abf9e52" translate="yes" xml:space="preserve">
          <source>Remove all comments except copy-right header comments beginning with &lt;code&gt;/*!&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;/*!&lt;/code&gt; 始まるコピーライトヘッダーコメントを除くすべてのコメントを削除します。</target>
        </trans-unit>
        <trans-unit id="64f0b6609e1215f1c7351fcea7e64bd711ee68cd" translate="yes" xml:space="preserve">
          <source>Removes the &amp;lsquo;this&amp;rsquo; parameter from a function type.</source>
          <target state="translated">関数タイプから「this」パラメーターを削除します。</target>
        </trans-unit>
        <trans-unit id="458347c4b08c20b7988b89261e9a532ec566adc1" translate="yes" xml:space="preserve">
          <source>Replace the contents of the &lt;code&gt;tsconfig.json&lt;/code&gt; file with:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; ファイルの内容を以下に置き換えます。</target>
        </trans-unit>
        <trans-unit id="bf9bdd295fb0df2de64ff2a20d94e74886937c45" translate="yes" xml:space="preserve">
          <source>Report an error when not all code paths in function return a value.</source>
          <target state="translated">関数内のすべてのコードパスが値を返すわけではない場合にエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="4bfcecd38bfeff6fffc3ecafa503fe73a31b3529" translate="yes" xml:space="preserve">
          <source>Report errors for fallthrough cases in switch statement.</source>
          <target state="translated">switch文のフォールスルーケースのエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="f8c20651b90e6cd8477684950f963b02e2099736" translate="yes" xml:space="preserve">
          <source>Report errors in &lt;code&gt;.js&lt;/code&gt; files. Use in conjunction with &lt;code&gt;--allowJs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; ファイルのエラーを報告します。 &lt;code&gt;--allowJs&lt;/code&gt; と組み合わせて使用​​します。</target>
        </trans-unit>
        <trans-unit id="c2375f497601629902de6816b8348dc646a011d3" translate="yes" xml:space="preserve">
          <source>Report errors on unused locals.</source>
          <target state="translated">未使用のローカルのエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="4e4da7a34ece0e23f3bacbbf60ec3ad07461c31d" translate="yes" xml:space="preserve">
          <source>Report errors on unused parameters.</source>
          <target state="translated">使用されていないパラメータのエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="d1c09f6c73919c0ebd1abbfd86f69d2cd3437aeb" translate="yes" xml:space="preserve">
          <source>Report module resolution log messages.</source>
          <target state="translated">モジュールの解決ログメッセージを報告します。</target>
        </trans-unit>
        <trans-unit id="99bc390ff55a2eb33efc222d7c8bb02d1504d6e7" translate="yes" xml:space="preserve">
          <source>Required type parameters must not follow optional type parameters.</source>
          <target state="translated">必須の型パラメータは、オプションの型パラメータの後に続いてはいけません。</target>
        </trans-unit>
        <trans-unit id="6b52890a8d8bb281f971e8b6c6fc68eebe6bbc98" translate="yes" xml:space="preserve">
          <source>Required&amp;lt;T&amp;gt;</source>
          <target state="translated">Required&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cdc1d535ad72977d21e2597085ca79e9eac4c98a" translate="yes" xml:space="preserve">
          <source>Required, optional, and default parameters all have one thing in common: they talk about one parameter at a time. Sometimes, you want to work with multiple parameters as a group, or you may not know how many parameters a function will ultimately take. In JavaScript, you can work with the arguments directly using the &lt;code&gt;arguments&lt;/code&gt; variable that is visible inside every function body.</source>
          <target state="translated">必須、オプション、およびデフォルトのパラメーターはすべて、1つの共通点があります。つまり、一度に1つのパラメーターについて話します。場合によっては、複数のパラメーターをグループとして操作したい場合や、関数が最終的に取るパラメーターの数がわからない場合があります。JavaScriptでは、すべての関数本体内に表示される &lt;code&gt;arguments&lt;/code&gt; 変数を使用して、引数を直接操作できます。</target>
        </trans-unit>
        <trans-unit id="bb59a7085d1d1d9d3f072f5c7166cfdbf3c3fa4d" translate="yes" xml:space="preserve">
          <source>Resolve &lt;code&gt;keyof&lt;/code&gt; to string valued property names only (no numbers or symbols).</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; を文字列値のプロパティ名のみに解決します（数値や記号は不可）。</target>
        </trans-unit>
        <trans-unit id="3e884a460b4d82c0f0401e11f902d2d3991a0a50" translate="yes" xml:space="preserve">
          <source>Rest Parameters</source>
          <target state="translated">休息パラメータ</target>
        </trans-unit>
        <trans-unit id="beeb7a77ad3e842a8cb47b5d6131631a494608b1" translate="yes" xml:space="preserve">
          <source>Rest elements in tuple types</source>
          <target state="translated">タプル型のレスト要素</target>
        </trans-unit>
        <trans-unit id="50be0fe30fc10dc88af852c9cb7c36370f77be27" translate="yes" xml:space="preserve">
          <source>Rest elements in tuple types.</source>
          <target state="translated">タプル型のレスト要素。</target>
        </trans-unit>
        <trans-unit id="387816de015267e69071ea349b674f6e1d757b14" translate="yes" xml:space="preserve">
          <source>Rest parameters with tuple types</source>
          <target state="translated">タプル型を持つ残りのパラメータ</target>
        </trans-unit>
        <trans-unit id="191ff62bcfa7d34e1a815740c74afda07b8c1e33" translate="yes" xml:space="preserve">
          <source>Results in an output such as:</source>
          <target state="translated">のような出力になります。</target>
        </trans-unit>
        <trans-unit id="69fa7005e9e1a4d2f5ae93f2373b3b809a4f2af9" translate="yes" xml:space="preserve">
          <source>Results in the following generated code:</source>
          <target state="translated">結果として、以下のようなコードが生成されます。</target>
        </trans-unit>
        <trans-unit id="02d55b2baf2725bcbe0634735b4de01c005aa3e5" translate="yes" xml:space="preserve">
          <source>Results in:</source>
          <target state="translated">結果が出ています。</target>
        </trans-unit>
        <trans-unit id="642d8f2cc4c0bf44f7ec4417fc288bf230277121" translate="yes" xml:space="preserve">
          <source>Return Types of Callbacks</source>
          <target state="translated">コールバックの戻り値の種類</target>
        </trans-unit>
        <trans-unit id="d87cabec32902153d1d79b8b11bc188472a6cc03" translate="yes" xml:space="preserve">
          <source>Return types as inference targets</source>
          <target state="translated">推論対象としての戻り値の型</target>
        </trans-unit>
        <trans-unit id="af8759585cf2cfe7a7c8a45a7ecabdbfd11cd2db" translate="yes" xml:space="preserve">
          <source>ReturnType&amp;lt;T&amp;gt;</source>
          <target state="translated">ReturnType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="251cfcc8db7eb197ba54907567e2b369dc7b23af" translate="yes" xml:space="preserve">
          <source>Reusable Types (Interfaces)</source>
          <target state="translated">再利用可能なタイプ(インターフェース)</target>
        </trans-unit>
        <trans-unit id="d6640a4d11aa6f54309d2fb5c213135e2c58c777" translate="yes" xml:space="preserve">
          <source>Reusable Types (Type Aliases)</source>
          <target state="translated">再利用可能なタイプ(タイプエイリアス</target>
        </trans-unit>
        <trans-unit id="221e6da1276e8997b6b6f436b2f947172bae0726" translate="yes" xml:space="preserve">
          <source>Reverse mappings</source>
          <target state="translated">逆マッピング</target>
        </trans-unit>
        <trans-unit id="9a135d61c072a9901e22aab7a06796f5a0db008c" translate="yes" xml:space="preserve">
          <source>Right click on &lt;code&gt;scripts&lt;/code&gt; and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;TypeScript File&lt;/strong&gt; and name the file &lt;code&gt;app.ts&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;scripts&lt;/code&gt; を右クリックし、[ &lt;strong&gt;新しいアイテム&lt;/strong&gt; ]をクリックします。次に、&lt;strong&gt;TypeScriptファイル&lt;/strong&gt;を選択し、ファイルに &lt;code&gt;app.ts&lt;/code&gt; という名前を付けます。</target>
        </trans-unit>
        <trans-unit id="46718d1e29791accf85fa69e3063268fff2968e4" translate="yes" xml:space="preserve">
          <source>Right click on the &lt;code&gt;wwwroot&lt;/code&gt; folder (if you don&amp;rsquo;t see the folder try building the project) and add a New Item named &lt;code&gt;index.html&lt;/code&gt; inside. Use the following code for &lt;code&gt;index.html &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;wwwroot&lt;/code&gt; フォルダーを右クリックし（フォルダーが表示されない場合は、プロジェクトをビルドしてみてください）、内部に &lt;code&gt;index.html&lt;/code&gt; という名前の新しいアイテムを追加します。 &lt;code&gt;index.html &lt;/code&gt; には次のコードを使用します</target>
        </trans-unit>
        <trans-unit id="f52ba130a82d88fb66ffcaad9e4d91c2445da38b" translate="yes" xml:space="preserve">
          <source>Right click on the project and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;JavaScript File&lt;/strong&gt; and use the name of &lt;code&gt;gulpfile.js&lt;/code&gt;</source>
          <target state="translated">プロジェクトを右クリックし、[ &lt;strong&gt;新しいアイテム&lt;/strong&gt; ]をクリックします。次に、&lt;strong&gt;JavaScriptファイル&lt;/strong&gt;を選択し、 &lt;code&gt;gulpfile.js&lt;/code&gt; の名前を使用します</target>
        </trans-unit>
        <trans-unit id="7e501a41bf28a9903be39bc35a602a8ca106603f" translate="yes" xml:space="preserve">
          <source>Right-Click -&amp;gt; Manage NuGet Packages</source>
          <target state="translated">右クリック-&amp;gt; NuGetパッケージの管理</target>
        </trans-unit>
        <trans-unit id="c8a67c2b7fee671c0d27e33fbdf91828d8346fc3" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;tsc --init&lt;/code&gt; in a directory to create an initial &lt;code&gt;tsconfig.json&lt;/code&gt; in this directory with preset defaults. Optionally pass command line arguments along with &lt;code&gt;--init&lt;/code&gt; to be stored in your initial tsconfig.json on creation.</source>
          <target state="translated">ディレクトリで &lt;code&gt;tsc --init&lt;/code&gt; を実行して、デフォルトのプリセットでこのディレクトリに初期 &lt;code&gt;tsconfig.json&lt;/code&gt; を作成します。オプションで、コマンドライン引数を &lt;code&gt;--init&lt;/code&gt; とともに渡して、作成時に最初のtsconfig.jsonに保存します。</target>
        </trans-unit>
        <trans-unit id="7418ce51bc901e2c720b082e836bfd88f7024c62" translate="yes" xml:space="preserve">
          <source>Run the application and make sure that it works.</source>
          <target state="translated">アプリケーションを実行して、動作することを確認してください。</target>
        </trans-unit>
        <trans-unit id="7e0fc2451d2efaadd8b864a6b91ae00ff2dca3ac" translate="yes" xml:space="preserve">
          <source>Run the compiler in watch mode. Watch input files and trigger recompilation on changes. The implementation of watching files and directories can be configured using environment variable. See &lt;a href=&quot;configuring-watch&quot;&gt;configuring watch&lt;/a&gt; for more details.</source>
          <target state="translated">監視モードでコンパイラを実行します。入力ファイルを監視し、変更時に再コンパイルをトリガーします。ファイルとディレクトリの監視の実装は、環境変数を使用して構成できます。詳細については、&lt;a href=&quot;configuring-watch&quot;&gt;ウォッチの設定を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="541995e6de639764055cf456f41bfe89e00d49e7" translate="yes" xml:space="preserve">
          <source>Run the project</source>
          <target state="translated">プロジェクトの実行</target>
        </trans-unit>
        <trans-unit id="5ea024956a0df9ff6595fe749c1eb6c02cc2dc2f" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;tsc --build&lt;/code&gt; (&lt;code&gt;tsc -b&lt;/code&gt; for short) will do the following:</source>
          <target state="translated">実行 &lt;code&gt;tsc --build&lt;/code&gt; （ &lt;code&gt;tsc -b&lt;/code&gt; 略して）次の操作を行います：</target>
        </trans-unit>
        <trans-unit id="88a02590b48e29c8ee3a28ec7ba7ee167b44c09c" translate="yes" xml:space="preserve">
          <source>Running your TypeScript web app</source>
          <target state="translated">TypeScript ウェブアプリを実行する</target>
        </trans-unit>
        <trans-unit id="e2a41db8c3523e88ee5980c0cbd2788f6889d1f9" translate="yes" xml:space="preserve">
          <source>Sample: Dynamic Module Loading in System.js</source>
          <target state="translated">サンプル。System.jsでの動的モジュールロード</target>
        </trans-unit>
        <trans-unit id="c66144bb0d8421e5d08ae6900d1c0163e2522d70" translate="yes" xml:space="preserve">
          <source>Sample: Dynamic Module Loading in require.js</source>
          <target state="translated">サンプル。require.jsでの動的モジュールロード</target>
        </trans-unit>
        <trans-unit id="b5230ecdf4e78f0dd162281a0a78c6cdc853cbe8" translate="yes" xml:space="preserve">
          <source>Schema</source>
          <target state="translated">Schema</target>
        </trans-unit>
        <trans-unit id="1e96c4caea76817edca1b37676caff140bf67580" translate="yes" xml:space="preserve">
          <source>Schema can be found at: &lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;http://json.schemastore.org/tsconfig&lt;/a&gt;</source>
          <target state="translated">スキーマは&lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;http://json.schemastore.org/tsconfigにあります。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0b92d418e654bbd5c2c48b78244ecce9fb91d09" translate="yes" xml:space="preserve">
          <source>Scoping rules</source>
          <target state="translated">スコーピングルール</target>
        </trans-unit>
        <trans-unit id="aa7841d9d246c3e95a5b8f479b5b2166bbcd3d3d" translate="yes" xml:space="preserve">
          <source>Search for &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt; を検索します</target>
        </trans-unit>
        <trans-unit id="120e80cbcdda984e634ee6ea60b988e7bdcd424d" translate="yes" xml:space="preserve">
          <source>Search for &lt;strong&gt;.NET Core&lt;/strong&gt; in the project search bar</source>
          <target state="translated">プロジェクト検索バーで&lt;strong&gt;.NET Core&lt;/strong&gt;を検索します</target>
        </trans-unit>
        <trans-unit id="98cc363c0119e35d1c8070755fc4d4c2387aad71" translate="yes" xml:space="preserve">
          <source>Searching</source>
          <target state="translated">Searching</target>
        </trans-unit>
        <trans-unit id="f28a160d3aeb79cc4e72b1bcf1f1cea3eed98229" translate="yes" xml:space="preserve">
          <source>Second, compile your files using &lt;code&gt;--importHelpers&lt;/code&gt;:</source>
          <target state="translated">次に、-- &lt;code&gt;--importHelpers&lt;/code&gt; を使用してファイルをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="f8a01008852da0be0cb83fb18c9ca0f90e85ba52" translate="yes" xml:space="preserve">
          <source>Second, the Typescript compiler doesn&amp;rsquo;t allow spreads of type parameters from generic functions. That feature is expected in future versions of the language.</source>
          <target state="translated">第二に、Typescriptコンパイラは、ジェネリック関数からの型パラメーターの分散を許可しません。この機能は、言語の将来のバージョンで期待されています。</target>
        </trans-unit>
        <trans-unit id="f5628af6cbb5e50d058efc6cdab3cec58a0d83b9" translate="yes" xml:space="preserve">
          <source>Secondly, using class fields to specialize properties from base classes also won&amp;rsquo;t work.</source>
          <target state="translated">次に、クラスフィールドを使用して基本クラスのプロパティを特殊化することもできません。</target>
        </trans-unit>
        <trans-unit id="7ff5a6dafd806f6d95302657c480d07703b64604" translate="yes" xml:space="preserve">
          <source>Sections</source>
          <target state="translated">Sections</target>
        </trans-unit>
        <trans-unit id="834c69b9d98efc1c3cec6d026570d3df634c7666" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../project-references&quot;&gt;Project References handbook page&lt;/a&gt; for more documentation.</source>
          <target state="translated">その他のドキュメントについては、&lt;a href=&quot;../project-references&quot;&gt;プロジェクトリファレンスハンドブックページ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="187875e55767d20df483d2fe4602ec06611fda25" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/module-resolution.html&quot;&gt;Module Resolution&lt;/a&gt; documentation for more details.</source>
          <target state="translated">詳細については、&lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/module-resolution.html&quot;&gt;モジュール解決の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="62fc6fcffeeb4b12902ccd59524362dbcce28787" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1256&quot;&gt;issue #1256&lt;/a&gt; for more information.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1256&quot;&gt;問題＃1256&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4c1f9292006cbb6b615fc48854ee208dde437f57" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files&quot;&gt;Type checking JavaScript Files documentation&lt;/a&gt; for more details.</source>
          <target state="translated">詳しくは、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files&quot;&gt;JavaScriptファイルのタイプチェックのドキュメント&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="fc473e27d9a7d29475aee306accd60b759bc0b30" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;more details on ts-loader here&lt;/a&gt;.</source>
          <target state="translated">参照してください。&lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ここでは、TS-ローダーの詳細を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b638ae7ad48e00c44c5cd48eb83e81ecbbf0a3c9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.json&lt;/a&gt; documentation for more details.</source>
          <target state="translated">詳細については、&lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.jsonの&lt;/a&gt;ドキュメントをご覧ください。</target>
        </trans-unit>
        <trans-unit id="73a908746ad2d70ca1399fea9bcf57e61da44b2f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/tsconfig.json&quot;&gt;tsconfig.json wiki page&lt;/a&gt; for more details.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/tsconfig.json&quot;&gt;tsconfig.json wikiページ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="077567d6271296de8ad4bd173bc8a26e4ff5d0f2" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; documentation for more information about modules. See the &lt;a href=&quot;namespaces&quot;&gt;Namespaces&lt;/a&gt; documentation for more information about namespaces.</source>
          <target state="translated">&lt;a href=&quot;modules&quot;&gt;モジュールの&lt;/a&gt;詳細については、モジュールのドキュメントを参照してください。&lt;a href=&quot;namespaces&quot;&gt;名前空間の&lt;/a&gt;詳細については、名前空間のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="64f2c787a02cbb7afa18cb007db73ea2664f916b" translate="yes" xml:space="preserve">
          <source>See the [[JSX]] wiki page for more information on using JSX in TypeScript.</source>
          <target state="translated">TypeScriptでのJSXの使用方法については、[[JSX]]wikiページを参照してください。</target>
        </trans-unit>
        <trans-unit id="cba80f4302feeb955dc9a7f866e6030dfdf9aef8" translate="yes" xml:space="preserve">
          <source>Select &lt;strong&gt;ASP.NET Core Web Application&lt;/strong&gt; and press the &lt;em&gt;Next&lt;/em&gt; button</source>
          <target state="translated">&lt;strong&gt;ASP.NET Core Web Application&lt;/strong&gt;を選択し、&lt;em&gt;Next&lt;/em&gt;ボタンを押します</target>
        </trans-unit>
        <trans-unit id="ed8feffbb3830d15b62b683a32f847857e90712a" translate="yes" xml:space="preserve">
          <source>Semicolon Formatter Option</source>
          <target state="translated">セミコロンフォーマッターオプション</target>
        </trans-unit>
        <trans-unit id="0f34f77f18943b88ab52ee5b7292da7cf41c6f44" translate="yes" xml:space="preserve">
          <source>Semicolon-Aware Code Edits</source>
          <target state="translated">セミコロンを意識したコード編集</target>
        </trans-unit>
        <trans-unit id="bcd9a6570954b6e91fefb181f3610d2793b5661b" translate="yes" xml:space="preserve">
          <source>Sequentially Added Properties</source>
          <target state="translated">順次追加されるプロパティ</target>
        </trans-unit>
        <trans-unit id="7f05ebe6c7a2fc5869cacffec6b784fde7b8f889" translate="yes" xml:space="preserve">
          <source>Set up the build</source>
          <target state="translated">ビルドの設定</target>
        </trans-unit>
        <trans-unit id="40f24e0504d1b14397453f62baee68453ad2fba2" translate="yes" xml:space="preserve">
          <source>Set up the server</source>
          <target state="translated">サーバーの設定</target>
        </trans-unit>
        <trans-unit id="c4f87dbe5e7d0d324c8530cef57ba653425df0e3" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;baseUrl&lt;/code&gt; informs the compiler where to find modules. All module imports with non-relative names are assumed to be relative to the &lt;code&gt;baseUrl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;baseUrl&lt;/code&gt; を設定すると、モジュールの検索場所がコンパイラに通知されます。非相対名でのすべてのモジュールのインポートは、 &lt;code&gt;baseUrl&lt;/code&gt; に関連していると見なされます。</target>
        </trans-unit>
        <trans-unit id="51341becf9d4b848eec8afc734c39a0799738e80" translate="yes" xml:space="preserve">
          <source>Setting a top-level property &lt;code&gt;compileOnSave&lt;/code&gt; signals to the IDE to generate all files for a given tsconfig.json upon saving.</source>
          <target state="translated">最上位のプロパティ &lt;code&gt;compileOnSave&lt;/code&gt; をIDEに設定して、保存時に特定のtsconfig.jsonのすべてのファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="53989c11f338fd824665321c75b617ecdf354fe7" translate="yes" xml:space="preserve">
          <source>Setting compiler options in &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuild projects&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuildプロジェクトでの&lt;/a&gt;コンパイラオプションの設定。</target>
        </trans-unit>
        <trans-unit id="90b8ab6e9c58f23f02ac47d035bce949bcd397b5" translate="yes" xml:space="preserve">
          <source>Setting compiler options in &lt;a href=&quot;tsconfig-json&quot;&gt;&lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; files.</source>
          <target state="translated">&lt;a href=&quot;tsconfig-json&quot;&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; &lt;/a&gt;ファイルでコンパイラオプションを設定します。</target>
        </trans-unit>
        <trans-unit id="7a6795689bb9ea8c8cb6764f05c1f6f935ee04dc" translate="yes" xml:space="preserve">
          <source>Setting the new compiler flag &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; indicates that the module loader performs some kind of synthetic default import member creation not indicated in the imported .ts or .d.ts. The compiler will infer the existence of a &lt;code&gt;default&lt;/code&gt; export that has the shape of the entire module itself.</source>
          <target state="translated">新しいコンパイラフラグ &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; を設定すると、モジュールローダーは、インポートされた.tsまたは.d.tsに示されていない、ある種の合成デフォルトインポートメンバーの作成を実行します。コンパイラーは、モジュール全体の形状を持つ &lt;code&gt;default&lt;/code&gt; エクスポートの存在を推測します。</target>
        </trans-unit>
        <trans-unit id="2e71f746315f905d8f4bde8180b1dba0027a8422" translate="yes" xml:space="preserve">
          <source>Setting up your Directories</source>
          <target state="translated">ディレクトリの設定</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="ba3a6a9b6d048ac70a293087f03215c195461fd9" translate="yes" xml:space="preserve">
          <source>Shadowing should &lt;em&gt;usually&lt;/em&gt; be avoided in the interest of writing clearer code. While there are some scenarios where it may be fitting to take advantage of it, you should use your best judgement.</source>
          <target state="translated">より明確なコードを作成するために、&lt;em&gt;通常は&lt;/em&gt;シャドウイングを回避する必要があります。それを利用するのに適しているシナリオがいくつかありますが、最善の判断をする必要があります。</target>
        </trans-unit>
        <trans-unit id="274d75123478b9323ff5c010c5717e0dad76caf9" translate="yes" xml:space="preserve">
          <source>Shorthand ambient module declarations</source>
          <target state="translated">省略可能なアンビエントモジュール宣言</target>
        </trans-unit>
        <trans-unit id="8f46f045bb2fdc1956a2f236cfedf0e1e227f9e8" translate="yes" xml:space="preserve">
          <source>Shorthand ambient modules</source>
          <target state="translated">短縮型アンビエントモジュール</target>
        </trans-unit>
        <trans-unit id="d63965efaf94e11d119af70827afc578c1c99dd9" translate="yes" xml:space="preserve">
          <source>Show diagnostic information.</source>
          <target state="translated">診断情報を表示します。</target>
        </trans-unit>
        <trans-unit id="ea62715d57491630afc7339cce6c9e3316b090c6" translate="yes" xml:space="preserve">
          <source>Show verbose diagnostic information</source>
          <target state="translated">冗長な診断情報を表示</target>
        </trans-unit>
        <trans-unit id="cd0e108f1f4412f32e9c055f41ef6dfdceb42a42" translate="yes" xml:space="preserve">
          <source>Similar to a &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive, which serves as a declaration of &lt;em&gt;dependency&lt;/em&gt;, a &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive declares a dependency on a package.</source>
          <target state="translated">類似 &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; の宣言として機能指令、&lt;em&gt;依存性&lt;/em&gt;、 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; ディレクティブは、パッケージの依存関係を宣言する。</target>
        </trans-unit>
        <trans-unit id="7ee4acd9eb753cecdb4b91f99daa97963b128504" translate="yes" xml:space="preserve">
          <source>Similar to array spread, spreading an object can be handy to get a shallow copy:</source>
          <target state="translated">配列のスプレッドと同様に、オブジェクトのスプレッドは浅いコピーを取得するのに便利です。</target>
        </trans-unit>
        <trans-unit id="d647d33af76ba25c85ee64e3adf6ff361ad569ea" translate="yes" xml:space="preserve">
          <source>Similar to union and intersection types, conditional types are not permitted to reference themselves recursively. For example the following is an error.</source>
          <target state="translated">ユニオン型やインターセクション型と同様に、条件付き型も再帰的に自分自身を参照することは許されていません。例えば、次のようなエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="ea6e185bb85cecc9661d326572fea7b76b1b1495" translate="yes" xml:space="preserve">
          <source>Similarly a default import (i.e. &lt;code&gt;import d from &quot;foo&quot;&lt;/code&gt;) for a CommonJS/AMD/UMD module as equivalent to &lt;code&gt;const d = require(&quot;foo&quot;).default&lt;/code&gt;.Most of the CommonJS/AMD/UMD modules available today do not have a &lt;code&gt;default&lt;/code&gt; export, making this import pattern practically unusable to import non-ES modules (i.e. CommonJS/AMD/UMD). For instance &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; or &lt;code&gt;import express from &quot;express&quot;&lt;/code&gt; are not allowed.</source>
          <target state="translated">同様に、 &lt;code&gt;const d = require(&quot;foo&quot;).default&lt;/code&gt; 同等のCommonJS / AMD / UMDモジュールのデフォルトのインポート（つまり &lt;code&gt;import d from &quot;foo&quot;&lt;/code&gt; ）。デフォルト。今日利用できるほとんどのCommonJS / AMD / UMDモジュールには、 &lt;code&gt;default&lt;/code&gt; 非ESモジュールをインポートすることは事実上使用できないこのインポートパターンを作り、輸出、（すなわちCommonJS / AMD / UMD）。たとえば &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; または &lt;code&gt;import express from &quot;express&quot;&lt;/code&gt; は許可されていません。</target>
        </trans-unit>
        <trans-unit id="d85b3b71be4bb5105a2a383a357dfdd56066b345" translate="yes" xml:space="preserve">
          <source>Similarly to how we can use interfaces to describe function types, we can also describe types that we can &amp;ldquo;index into&amp;rdquo; like &lt;code&gt;a[10]&lt;/code&gt;, or &lt;code&gt;ageMap[&quot;daniel&quot;]&lt;/code&gt;. Indexable types have an &lt;em&gt;index signature&lt;/em&gt; that describes the types we can use to index into the object, along with the corresponding return types when indexing. Let&amp;rsquo;s take an example:</source>
          <target state="translated">インターフェイスを使用して関数タイプを記述する方法と同様に &lt;code&gt;a[10]&lt;/code&gt; や &lt;code&gt;ageMap[&quot;daniel&quot;]&lt;/code&gt; ように「インデックス付け」できるタイプを記述することもできます。&lt;em&gt;インデックス&lt;/em&gt;可能な型には、オブジェクトにインデックスを付けるために使用できる型と、インデックス作成時に対応する戻り値の型を説明する&lt;em&gt;インデックスシグネチャ&lt;/em&gt;があり&lt;em&gt;ます&lt;/em&gt;。例を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="adb395172c71ccd54b1326d899f4d06456ede0c1" translate="yes" xml:space="preserve">
          <source>Similarly to interfaces, namespaces of the same name will also merge their members. Since namespaces create both a namespace and a value, we need to understand how both merge.</source>
          <target state="translated">インタフェースと同様に、同じ名前の名前空間もメンバをマージします。名前空間は名前空間と値の両方を作成するので、両方がどのようにマージされるかを理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="59a8554ef56814f4114354c3cfa0c5ed809a9eaa" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;--target ES2017&lt;/code&gt; will instruct the compiler not to transform ES2017-specific features like &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;.</source>
          <target state="translated">同様に、-- &lt;code&gt;--target ES2017&lt;/code&gt; は、 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; などのES2017固有の機能を変換しないようにコンパイラーに指示します。</target>
        </trans-unit>
        <trans-unit id="ebb6eff56def1e9c8faa2f831e045e194b4e3480" translate="yes" xml:space="preserve">
          <source>Similarly, a non-relative import will follow the Node.js resolution logic, first looking up a file, then looking up an applicable folder. So &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt; in source file &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; would result in the following lookups:</source>
          <target state="translated">同様に、非相対インポートはNode.js解決ロジックに従い、最初にファイルを検索し、次に適切なフォルダーを検索します。したがって、ソースファイル &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; の &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt; すると、次のルックアップが行われます。</target>
        </trans-unit>
        <trans-unit id="8e9295d32c7a26ac7fc56081bcf2d7aa9d700307" translate="yes" xml:space="preserve">
          <source>Similarly, destructuring can be used in function parameter declarations:</source>
          <target state="translated">同様に、関数のパラメータ宣言でもデストラクチャリングを使用することができます。</target>
        </trans-unit>
        <trans-unit id="034cda522b7de683abd945b4a3cdbb3d70d9b104" translate="yes" xml:space="preserve">
          <source>Similarly, namespaces can be used to extend enums with static members:</source>
          <target state="translated">同様に、名前空間を使用して、静的メンバを持つ列挙型を拡張することができます。</target>
        </trans-unit>
        <trans-unit id="15a650d9a4ea0756304f469dcbad9a5ff7886ae3" translate="yes" xml:space="preserve">
          <source>Similarly, the global scope can be augmented from modules using a &lt;code&gt;declare global&lt;/code&gt; declarations:</source>
          <target state="translated">同様に、グローバルスコープは、 &lt;code&gt;declare global&lt;/code&gt; 宣言を使用してモジュールから拡張できます。</target>
        </trans-unit>
        <trans-unit id="44c459aed9d0d7b781bc8721c975f3ccca45175e" translate="yes" xml:space="preserve">
          <source>Similarly, try removing all the arguments to the greeter call. TypeScript will let you know that you have called this function with an unexpected number of parameters. In both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations you provide.</source>
          <target state="translated">同様に、グリーターの呼び出しの引数をすべて削除してみてください。TypeScript は、予想外の数のパラメータを使ってこの関数を呼び出したことを知らせてくれます。どちらの場合も、TypeScript はコードの構造と提供された型のアノテーションの両方に基づいて静的な解析を行うことができます。</target>
        </trans-unit>
        <trans-unit id="a96df9471d886c6a3944738c14a4e817cb32e52e" translate="yes" xml:space="preserve">
          <source>Similarly, you can merge several different objects. In the following example, &lt;code&gt;merged&lt;/code&gt; will have properties from &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;baz&lt;/code&gt;.</source>
          <target state="translated">同様に、いくつかの異なるオブジェクトをマージできます。次の例では、 &lt;code&gt;merged&lt;/code&gt; には &lt;code&gt;foo&lt;/code&gt; 、 &lt;code&gt;bar&lt;/code&gt; 、および &lt;code&gt;baz&lt;/code&gt; のプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="0e344fea73da74bac69381f07e6bac9722af29f9" translate="yes" xml:space="preserve">
          <source>Similarly, you could write a utility type like &lt;code&gt;Writable&lt;/code&gt; mapped type that strips away &lt;code&gt;readonly&lt;/code&gt;-ness, and that would convert &lt;code&gt;readonly&lt;/code&gt; array containers back to their mutable equivalents.</source>
          <target state="translated">同様に、 &lt;code&gt;readonly&lt;/code&gt; -ness を取り除き、読み取り &lt;code&gt;readonly&lt;/code&gt; 配列コンテナーを変更可能な同等のものに変換する &lt;code&gt;Writable&lt;/code&gt; マップタイプのようなユーティリティタイプを書くことができます。</target>
        </trans-unit>
        <trans-unit id="8aacbc2fc90c4a9233935fa887158e588886b733" translate="yes" xml:space="preserve">
          <source>Simple Combinations: One name, multiple meanings</source>
          <target state="translated">シンプルな組み合わせ。一つの名前に複数の意味</target>
        </trans-unit>
        <trans-unit id="c15fa4b758d35cc97d9959bcc45edd294156d605" translate="yes" xml:space="preserve">
          <source>Simple Example</source>
          <target state="translated">簡単な例</target>
        </trans-unit>
        <trans-unit id="1c315460161fd9403852d4c74317febae46bf2d2" translate="yes" xml:space="preserve">
          <source>SimpleModule.ts</source>
          <target state="translated">SimpleModule.ts</target>
        </trans-unit>
        <trans-unit id="b2ce6f775436f49655c281cba1ff8bd7971a0459" translate="yes" xml:space="preserve">
          <source>Simplified &lt;code&gt;props&lt;/code&gt; type management in React</source>
          <target state="translated">Reactでの &lt;code&gt;props&lt;/code&gt; タイプ管理の簡素化</target>
        </trans-unit>
        <trans-unit id="e0d662efaa9ae2f635437fd38e1b30b750f5eb5c" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;keyof&lt;/code&gt; now reflects the presence of a numeric index signature by including type &lt;code&gt;number&lt;/code&gt; in the key type, mapped types such as &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; work correctly when applied to object types with numeric index signatures:</source>
          <target state="translated">以来 &lt;code&gt;keyof&lt;/code&gt; 今タイプなどによって数値インデックス署名の存在反映 &lt;code&gt;number&lt;/code&gt; 、などのマッピングされたタイプのキータイプを &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; と &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; 数値インデックス署名とオブジェクト・タイプに適用されたときに正しく作業：</target>
        </trans-unit>
        <trans-unit id="3d0a96b99fe271899593be449688b7fa5ea47eef" translate="yes" xml:space="preserve">
          <source>Since JavaScript automatically terminates the &lt;code&gt;return&lt;/code&gt; statement at the end of the line, the object literal becomes a block.</source>
          <target state="translated">JavaScriptは &lt;code&gt;return&lt;/code&gt; ステートメントを行の終わりで自動的に終了するため、オブジェクトリテラルはブロックになります。</target>
        </trans-unit>
        <trans-unit id="cce35890852819c246c89e64575a83cc751e8c48" translate="yes" xml:space="preserve">
          <source>Since declarations in one file can affect type checking in other files, some errors may not be detected when &lt;code&gt;--skipLibCheck&lt;/code&gt; is specified. For example, if a non-declaration file augments a type declared in a declaration file, errors may result that are only reported when the declaration file is checked. However, in practice such situations are rare.</source>
          <target state="translated">1つのファイルでの宣言は他のファイルでの型チェックに影響を与える可能性があるため、 &lt;code&gt;--skipLibCheck&lt;/code&gt; が指定されていると、一部のエラーが検出されない場合があります。たとえば、非宣言ファイルが宣言ファイルで宣言された型を補強する場合、宣言ファイルがチェックされたときにのみ報告されるエラーが発生する可能性があります。ただし、実際にはそのような状況はまれです。</target>
        </trans-unit>
        <trans-unit id="91fd691cb7cba41ab5d488469fc7cd906ef14a39" translate="yes" xml:space="preserve">
          <source>Since nullable types are implemented with a union, you need to use a type guard to get rid of the &lt;code&gt;null&lt;/code&gt;. Fortunately, this is the same code you&amp;rsquo;d write in JavaScript:</source>
          <target state="translated">null許容型はunionで実装されているため、 &lt;code&gt;null&lt;/code&gt; を取り除くには型ガードを使用する必要があります。さいわい、これはJavaScriptで作成するコードと同じです。</target>
        </trans-unit>
        <trans-unit id="d7d710dcc7a9a1a3a0ae270f066743ad193628a1" translate="yes" xml:space="preserve">
          <source>Since ranges have the potential to overlap, determining which redirect applies is order-specific. That means in the above example, even though both the &lt;code&gt;&amp;gt;=3.2&lt;/code&gt; and the &lt;code&gt;&amp;gt;=3.1&lt;/code&gt; matchers support TypeScript 3.2 and above, reversing the order could have different behavior, so the above sample would not be equivalent to the following.</source>
          <target state="translated">範囲は重複する可能性があるため、適用されるリダイレクトの決定は順序に固有です。つまり、上記の例では、 &lt;code&gt;&amp;gt;=3.2&lt;/code&gt; と &lt;code&gt;&amp;gt;=3.1&lt;/code&gt; の両方のマッチャーがTypeScript 3.2以上をサポートしていますが、順序を逆にすると動作が異なる可能性があるため、上記のサンプルは次のコードと同等ではありません。</target>
        </trans-unit>
        <trans-unit id="4f878058a9de82078d9e40fb2687f87811aefbf7" translate="yes" xml:space="preserve">
          <source>Since the above syntax cannot be used in &lt;code&gt;.tsx&lt;/code&gt; files, an alternate type assertion operator should be used: &lt;code&gt;as&lt;/code&gt;. The example can easily be rewritten with the &lt;code&gt;as&lt;/code&gt; operator.</source>
          <target state="translated">上記の構文は &lt;code&gt;.tsx&lt;/code&gt; ファイルでは使用できないため、別のタイプのアサーション演算子を使用する必要があります： &lt;code&gt;as&lt;/code&gt; 。この例は、 &lt;code&gt;as&lt;/code&gt; 演算子を使用して簡単に書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="c94167207ee9c90316742f73b6eca79827716dff" translate="yes" xml:space="preserve">
          <source>Since the class uses &lt;code&gt;this&lt;/code&gt; types, you can extend it and the new class can use the old methods with no changes.</source>
          <target state="translated">クラスは &lt;code&gt;this&lt;/code&gt; タイプを使用するため、クラスを拡張でき、新しいクラスは変更なしで古いメソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="3f878409b3dc13d4ef49d4cf4543cf7848bae266" translate="yes" xml:space="preserve">
          <source>Since the stricter checks may uncover previously unreported errors, this is a breaking change in &lt;code&gt;--strict&lt;/code&gt; mode.</source>
          <target state="translated">より厳密なチェックでは、以前に報告されていないエラーが見つかる可能性があるため、これは &lt;code&gt;--strict&lt;/code&gt; モードでの重大な変更です。</target>
        </trans-unit>
        <trans-unit id="21d47d51fa3ee1bdfdfae971aec4e563a10a3e93" translate="yes" xml:space="preserve">
          <source>Since there is no natural syntax for specifying generic type parameters in Javascript, an unspecified type parameter defaults to &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Javascriptでジェネリック型パラメーターを指定するための自然な構文はないため、未指定の型パラメーターはデフォルトで &lt;code&gt;any&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="b322b635e697fa374578b14cb6639ca067a1c956" translate="yes" xml:space="preserve">
          <source>Since there is no way to specify optionality on parameters in pre-ES2015 Javascript, all function parameters in &lt;code&gt;.js&lt;/code&gt; file are considered optional. Calls with fewer arguments than the declared number of parameters are allowed.</source>
          <target state="translated">ES2015より前のJavaScriptではパラメーターにオプションを指定する方法がないため、 &lt;code&gt;.js&lt;/code&gt; ファイル内のすべての関数パラメーターはオプションと見なされます。宣言されたパラメーター数よりも引数の少ない呼び出しが許可されます。</target>
        </trans-unit>
        <trans-unit id="1bb189160ac70073ac7ebfc075b0fbe0a1f9844a" translate="yes" xml:space="preserve">
          <source>Since this is a breaking change, you may need to know about the workarounds which are the same as those for strict object literal checks:</source>
          <target state="translated">これはブレークする変更なので、厳密なオブジェクトリテラルチェックと同じ回避策を知っておく必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="0c990fd202f278ef0f0d7845a5a9243bf4d29dd3" translate="yes" xml:space="preserve">
          <source>Skip type checking of &lt;a href=&quot;triple-slash-directives#-reference-no-default-libtrue&quot;&gt;default library declaration files&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;triple-slash-directives#-reference-no-default-libtrue&quot;&gt;デフォルトのライブラリ宣言ファイルの&lt;/a&gt;型チェックをスキップします。</target>
        </trans-unit>
        <trans-unit id="12501fd6f728bd1473ea7478cbc5c3dcd63db265" translate="yes" xml:space="preserve">
          <source>Skip type checking of all declaration files (&lt;code&gt;*.d.ts&lt;/code&gt;).</source>
          <target state="translated">すべての宣言ファイル（ &lt;code&gt;*.d.ts&lt;/code&gt; ）の型チェックをスキップします。</target>
        </trans-unit>
        <trans-unit id="65491f46fdafeaf0b665cd04a110e111c9391e5e" translate="yes" xml:space="preserve">
          <source>Smarter Auto-Import Syntax</source>
          <target state="translated">よりスマートな自動インポート構文</target>
        </trans-unit>
        <trans-unit id="bb1eae075750d4a174787dc1c2252c01719c35af" translate="yes" xml:space="preserve">
          <source>Smarter union type checking</source>
          <target state="translated">よりスマートなユニオンタイプのチェック</target>
        </trans-unit>
        <trans-unit id="679bf06653c38306e3510cb4091b394d4e625ab8" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve used &amp;ldquo;compatible&amp;rdquo;, which is not a term defined in the language spec. In TypeScript, there are two kinds of compatibility: subtype and assignment. These differ only in that assignment extends subtype compatibility with rules to allow assignment to and from &lt;code&gt;any&lt;/code&gt;, and to and from &lt;code&gt;enum&lt;/code&gt; with corresponding numeric values.</source>
          <target state="translated">これまでは、「互換性」を使用してきましたが、これは言語仕様で定義された用語ではありません。TypeScriptには、サブタイプと割り当ての2種類の互換性があります。これらは、代入がルールとのサブタイプの互換性を拡張する点でのみ異なり、 &lt;code&gt;any&lt;/code&gt; との間、および対応する数値を持つ &lt;code&gt;enum&lt;/code&gt; との間の代入を許可します。</target>
        </trans-unit>
        <trans-unit id="67ef5716ef1d4255fdfc3266bf74a100eaaddc5f" translate="yes" xml:space="preserve">
          <source>So given the following input, the resulting &lt;code&gt;.js&lt;/code&gt; file will include an import to &lt;code&gt;tslib&lt;/code&gt; and use the &lt;code&gt;__assign&lt;/code&gt; helper from it instead of inlining it.</source>
          <target state="translated">したがって、次の入力を指定すると、結果の &lt;code&gt;.js&lt;/code&gt; ファイルには &lt;code&gt;tslib&lt;/code&gt; へのインポートが含まれ、インライン化する代わりに、そこから &lt;code&gt;__assign&lt;/code&gt; ヘルパーを使用します。</target>
        </trans-unit>
        <trans-unit id="186ee8ceb588d6a258ee6dbb023a30a68c051a54" translate="yes" xml:space="preserve">
          <source>So in the above example, if we&amp;rsquo;re importing from &lt;code&gt;&quot;package-name&quot;&lt;/code&gt;, we&amp;rsquo;ll try to resolve from &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; (and other relevant paths) when running in TypeScript 3.1. If we import from &lt;code&gt;package-name/foo&lt;/code&gt;, we&amp;rsquo;ll try to look for &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; and &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt;.</source>
          <target state="translated">したがって、上記の例では、 &lt;code&gt;&quot;package-name&quot;&lt;/code&gt; からインポートする場合、 &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; （およびその他の関連するもの）から解決しようとしますパス）TypeScript 3.1で実行する場合。 &lt;code&gt;package-name/foo&lt;/code&gt; からインポートする場合、 &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; および &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0d35f3444ee195674f39dbd3f6a1e50ed4c2a4e" translate="yes" xml:space="preserve">
          <source>So to exclude a file from the compilation, you need to exclude it and &lt;strong&gt;all&lt;/strong&gt; files that have an &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive to it.</source>
          <target state="translated">そのため、コンパイルからファイルを除外するには、&lt;strong&gt;その&lt;/strong&gt;ファイルと、 &lt;code&gt;import&lt;/code&gt; または &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; ディレクティブを持つ&lt;strong&gt;すべての&lt;/strong&gt;ファイルを除外する必要があります。</target>
        </trans-unit>
        <trans-unit id="e4bc2f7646ea9a289aefdb5e74620f8df8809b70" translate="yes" xml:space="preserve">
          <source>Some examples of functions returning &lt;code&gt;never&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 戻らない関数の例：</target>
        </trans-unit>
        <trans-unit id="dd8e2e31e759369daed94a0bdfbe83bde2d68c4a" translate="yes" xml:space="preserve">
          <source>Some examples of use of functions returning &lt;code&gt;never&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; を返す関数の使用例：</target>
        </trans-unit>
        <trans-unit id="ac3ff6970ef7ae26b60be3c11566e4ffed69c47e" translate="yes" xml:space="preserve">
          <source>Some examples use the &lt;code&gt;reflect-metadata&lt;/code&gt; library which adds a polyfill for an &lt;a href=&quot;https://github.com/rbuckton/ReflectDecorators&quot;&gt;experimental metadata API&lt;/a&gt;. This library is not yet part of the ECMAScript (JavaScript) standard. However, once decorators are officially adopted as part of the ECMAScript standard these extensions will be proposed for adoption.</source>
          <target state="translated">一部の例では、&lt;a href=&quot;https://github.com/rbuckton/ReflectDecorators&quot;&gt;試験的なメタデータAPIに&lt;/a&gt;ポリフィルを追加するReflect &lt;code&gt;reflect-metadata&lt;/code&gt; ライブラリを使用しています。このライブラリはまだECMAScript（JavaScript）標準の一部ではありません。ただし、ECMAScript標準の一部としてデコレータが正式に採用されると、これらの拡張機能の採用が提案されます。</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">いくつかの例を紹介します。</target>
        </trans-unit>
        <trans-unit id="7d3c07f60789aec8bf6b6718acaa48138f0167f9" translate="yes" xml:space="preserve">
          <source>Some kinds of declarations can be combined across multiple declarations. For example, &lt;code&gt;class C { }&lt;/code&gt; and &lt;code&gt;interface C { }&lt;/code&gt; can co-exist and both contribute properties to the &lt;code&gt;C&lt;/code&gt; types.</source>
          <target state="translated">いくつかの種類の宣言は、複数の宣言にわたって組み合わせることができます。たとえば、 &lt;code&gt;class C { }&lt;/code&gt; と &lt;code&gt;interface C { }&lt;/code&gt; は共存でき、どちらも &lt;code&gt;C&lt;/code&gt; 型にプロパティを提供します。</target>
        </trans-unit>
        <trans-unit id="7a1a6bb7e5995629cd2728c008f6bd029c77d013" translate="yes" xml:space="preserve">
          <source>Some libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; modules. These libraries can be accessed through either an import or a global variable. For example:</source>
          <target state="translated">一部のライブラリは、多くのモジュールローダーで使用するように設計されているか、モジュールをロードしない（グローバル変数）ように設計されています。これらは&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;モジュールとして知られています。これらのライブラリには、インポートまたはグローバル変数のいずれかを介してアクセスできます。例えば：</target>
        </trans-unit>
        <trans-unit id="2bd424c5780b5812c140ab0c2b98f3a8f43528b7" translate="yes" xml:space="preserve">
          <source>Some libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; or &lt;a href=&quot;http://isomorphic.net&quot;&gt;Isomorphic&lt;/a&gt; modules. These libraries can be accessed through either an import or a global variable.</source>
          <target state="translated">一部のライブラリは、多くのモジュールローダーで使用するように設計されているか、モジュールをロードしない（グローバル変数）ように設計されています。これらは&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;または&lt;a href=&quot;http://isomorphic.net&quot;&gt;同形&lt;/a&gt;モジュールとして知られています。これらのライブラリには、インポートまたはグローバル変数のいずれかを介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="6d579c1b603ba9bdb7b036601db29274335578ec" translate="yes" xml:space="preserve">
          <source>Some libraries only work in a module loader environment. For example, &lt;code&gt;express&lt;/code&gt; only works in Node.js and must be loaded using the CommonJS &lt;code&gt;require&lt;/code&gt; function.</source>
          <target state="translated">一部のライブラリは、モジュールローダー環境でのみ機能します。たとえば、 &lt;code&gt;express&lt;/code&gt; はNode.jsでのみ機能し、CommonJSの &lt;code&gt;require&lt;/code&gt; 関数を使用してロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="6e9585e6951e2664b628f35bed4a5c31cb046a11" translate="yes" xml:space="preserve">
          <source>Some module loaders such as &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt; and &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt; allow non-JavaScript content to be imported. These typically use a prefix or suffix to indicate the special loading semantics. Wildcard module declarations can be used to cover these cases.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt;や&lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt;などの一部のモジュールローダーでは、JavaScript以外のコンテンツをインポートできます。通常、これらは接頭辞または接尾辞を使用して、特別な読み込みセマンティクスを示します。ワイルドカードモジュール宣言を使用して、これらのケースをカバーできます。</target>
        </trans-unit>
        <trans-unit id="57331e67e5143af4a00330fcd39cdc3c6aaaac4d" translate="yes" xml:space="preserve">
          <source>Some of the unique concepts in TypeScript describe the shape of JavaScript objects at the type level. One example that is especially unique to TypeScript is the concept of &amp;lsquo;declaration merging&amp;rsquo;. Understanding this concept will give you an advantage when working with existing JavaScript. It also opens the door to more advanced abstraction concepts.</source>
          <target state="translated">TypeScriptのユニークな概念のいくつかは、型レベルでのJavaScriptオブジェクトの形状を説明しています。TypeScriptに固有の1つの例は、「宣言のマージ」の概念です。この概念を理解すると、既存のJavaScriptを操作するときに利点が得られます。また、より高度な抽象概念への扉も開きます。</target>
        </trans-unit>
        <trans-unit id="1e812a000ccfcbfb77656cc54a6fedc23b3ae782" translate="yes" xml:space="preserve">
          <source>Some people find it more aesthetically pleasing to create an object and add properties immediately after like so:</source>
          <target state="translated">このように、オブジェクトを作成してすぐにプロパティを追加した方が、より審美性が高いと感じる人もいます。</target>
        </trans-unit>
        <trans-unit id="61d584a25fe1d72715546564a21bd344b92d47a9" translate="yes" xml:space="preserve">
          <source>Some plugins add or modify top-level exports on existing modules. While this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible. Because TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this.</source>
          <target state="translated">一部のプラグインでは、既存のモジュールにトップレベルのエクスポートを追加したり、変更したりしています。これは CommonJS や他のローダーでは合法ですが、ES6 モジュールは不変とみなされており、このパターンは不可能です。TypeScript はローダに依存しないため、コンパイル時にこのポリシーを適用することはできませんが、ES6 モジュールローダに移行しようとしている開発者はこの点に注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="f160ec637dc65ea96bb1d06f7025c1b36e3fe866" translate="yes" xml:space="preserve">
          <source>Some properties should only be modifiable when an object is first created. You can specify this by putting &lt;code&gt;readonly&lt;/code&gt; before the name of the property:</source>
          <target state="translated">一部のプロパティは、オブジェクトが最初に作成されたときにのみ変更可能である必要があります。プロパティの名前の前に &lt;code&gt;readonly&lt;/code&gt; を置くことでこれを指定できます。</target>
        </trans-unit>
        <trans-unit id="14f44373480b1e220dbd6f17d34a63ec1dd688dd" translate="yes" xml:space="preserve">
          <source>Some readers might do a double-take at this example. The variable &lt;code&gt;x&lt;/code&gt; was declared &lt;em&gt;within the &lt;code&gt;if&lt;/code&gt; block&lt;/em&gt;, and yet we were able to access it from outside that block. That&amp;rsquo;s because &lt;code&gt;var&lt;/code&gt; declarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we&amp;rsquo;ll go over later on - regardless of the containing block. Some people call this &lt;em&gt;&lt;code&gt;var&lt;/code&gt;-scoping&lt;/em&gt; or &lt;em&gt;function-scoping&lt;/em&gt;. Parameters are also function scoped.</source>
          <target state="translated">一部の読者は、この例でダブルテイクを行う可能性があります。変数 &lt;code&gt;x&lt;/code&gt; は&lt;em&gt; &lt;code&gt;if&lt;/code&gt; &lt;/em&gt;&lt;em&gt;ブロック&lt;/em&gt;&lt;em&gt;内&lt;/em&gt;で宣言さ&lt;em&gt;れましたが、&lt;/em&gt;そのブロックの外部からアクセスすることができました。これは、含まれているブロックに関係なく、 &lt;code&gt;var&lt;/code&gt; 宣言が含まれている関数、モジュール、名前空間、またはグローバルスコープ内のどこからでもアクセスできるためです。これを&lt;em&gt; &lt;code&gt;var&lt;/code&gt; -scoping&lt;/em&gt;または&lt;em&gt;function- &lt;/em&gt;&lt;em&gt;scoping&lt;/em&gt;と呼ぶ人もい&lt;em&gt;ます&lt;/em&gt;。パラメータも関数スコープです。</target>
        </trans-unit>
        <trans-unit id="44fb74208e19d5dbb2c363c2964c86574d508b8b" translate="yes" xml:space="preserve">
          <source>Some teams have set up msbuild-based workflows wherein tsconfig files have the same &lt;em&gt;implicit&lt;/em&gt; graph ordering as the managed projects they are paired with. If your solution is like this, you can continue to use &lt;code&gt;msbuild&lt;/code&gt; with &lt;code&gt;tsc -p&lt;/code&gt; along with project references; these are fully interoperable.</source>
          <target state="translated">一部のチームはmsbuildベースのワークフローをセットアップしており、tsconfigファイルには、ペアになっている管理対象プロジェクトと同じ&lt;em&gt;暗黙の&lt;/em&gt;グラフ順序があります。ソリューションがこのようなものである場合は、プロジェクト参照とともに &lt;code&gt;tsc -p&lt;/code&gt; を指定して &lt;code&gt;msbuild&lt;/code&gt; を引き続き使用できます。これらは完全に相互運用可能です。</target>
        </trans-unit>
        <trans-unit id="7941e42acfe32f9735cd477a7822e4200f3733d0" translate="yes" xml:space="preserve">
          <source>Something to note is that you can still &lt;em&gt;capture&lt;/em&gt; a block-scoped variable before it&amp;rsquo;s declared. The only catch is that it&amp;rsquo;s illegal to call that function before the declaration. If targeting ES2015, a modern runtime will throw an error; however, right now TypeScript is permissive and won&amp;rsquo;t report this as an error.</source>
          <target state="translated">注意すべき点は、宣言する前にブロックスコープの変数を&lt;em&gt;キャプチャ&lt;/em&gt;できることです。唯一の問題は、宣言の前にその関数を呼び出すことは違法であることです。ES2015を対象とする場合、最新のランタイムはエラーをスローします。ただし、現時点ではTypeScriptは許容範囲内であり、これをエラーとして報告しません。</target>
        </trans-unit>
        <trans-unit id="f134bb2233aae7cfa93968aca5ea244823125b9e" translate="yes" xml:space="preserve">
          <source>Sometimes modules are not directly located under &lt;em&gt;baseUrl&lt;/em&gt;. For instance, an import to a module &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; would be translated at runtime to &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt;. Loaders use a mapping configuration to map module names to files at run-time, see &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs documentation&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#paths&quot;&gt;SystemJS documentation&lt;/a&gt;.</source>
          <target state="translated">モジュールが&lt;em&gt;baseUrlの&lt;/em&gt;直下にない場合があります。たとえば、モジュール &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; へのインポートは、実行時に &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt; 変換されます。ローダーは、マッピング構成を使用して、実行時にモジュール名をファイルにマップします&lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;。RequireJsのドキュメント&lt;/a&gt;と&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#paths&quot;&gt;SystemJSのドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d6951e5cd812b979ec00d7377ad9486c476e4ffe" translate="yes" xml:space="preserve">
          <source>Sometimes modules are not directly located under &lt;em&gt;baseUrl&lt;/em&gt;. Loaders use a mapping configuration to map module names to files at run-time, see &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs documentation&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#map-config&quot;&gt;SystemJS documentation&lt;/a&gt;.</source>
          <target state="translated">モジュールが&lt;em&gt;baseUrlの&lt;/em&gt;直下にない場合があります。ローダーは、マッピング構成を使用して、実行時にモジュール名をファイルにマップします&lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;。RequireJsのドキュメント&lt;/a&gt;と&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#map-config&quot;&gt;SystemJSのドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c2126d1615e0f1485e19b5a56e2155fedd9cc145" translate="yes" xml:space="preserve">
          <source>Sometimes the project sources from multiple directories at compile time are all combined to generate a single output directory. This can be viewed as a set of source directories create a &amp;ldquo;virtual&amp;rdquo; directory.</source>
          <target state="translated">コンパイル時に複数のディレクトリからのプロジェクトソースがすべて結合されて、単一の出力ディレクトリが生成される場合があります。これは、一連のソースディレクトリが「仮想」ディレクトリを作成すると見なすことができます。</target>
        </trans-unit>
        <trans-unit id="57ffb77d1046760098ea81054624979437671ba8" translate="yes" xml:space="preserve">
          <source>Sometimes this is not desirable, for instance inputs &lt;code&gt;FolderA\FolderB\1.ts&lt;/code&gt; and &lt;code&gt;FolderA\FolderB\2.ts&lt;/code&gt; would result in output structure mirroring &lt;code&gt;FolderA\FolderB\&lt;/code&gt;. Now if a new file &lt;code&gt;FolderA\3.ts&lt;/code&gt; is added to the input, the output structure will pop out to mirror &lt;code&gt;FolderA\&lt;/code&gt;.</source>
          <target state="translated">これは望ましくない場合があります。たとえば、入力 &lt;code&gt;FolderA\FolderB\1.ts&lt;/code&gt; および &lt;code&gt;FolderA\FolderB\2.ts&lt;/code&gt; は、出力構造が &lt;code&gt;FolderA\FolderB\&lt;/code&gt; ミラーリングする結果になります。ここで、新しいファイル &lt;code&gt;FolderA\3.ts&lt;/code&gt; が入力に追加されると、出力構造がポップアウトして &lt;code&gt;FolderA\&lt;/code&gt; をミラーリングします。</target>
        </trans-unit>
        <trans-unit id="1373cee6ce1e5c912f9c7dad28055e7d5d1067f6" translate="yes" xml:space="preserve">
          <source>Sometimes you&amp;rsquo;ll end up in a situation where you&amp;rsquo;ll know more about a value than TypeScript does. Usually this will happen when you know the type of some entity could be more specific than its current type.</source>
          <target state="translated">TypeScriptが行うよりも、値について多くのことを知っているような状況になる場合があります。通常、これは、エンティティのタイプが現在のタイプよりも具体的であることがわかっている場合に発生します。</target>
        </trans-unit>
        <trans-unit id="55d18b2ee923c4bc6bb19412ab2b08a75f6ca271" translate="yes" xml:space="preserve">
          <source>Sometimes you&amp;rsquo;ll entirely overwrite the exports object. This is a common pattern people use to make their modules immediately callable like in this snippet:</source>
          <target state="translated">場合によっては、exportsオブジェクトを完全に上書きします。これは、次のスニペットのように、モジュールをすぐに呼び出し可能にするために使用される一般的なパターンです。</target>
        </trans-unit>
        <trans-unit id="d9ff7d39e693899b2fb01c2af7e0b9aad8efd43b" translate="yes" xml:space="preserve">
          <source>Specifically:</source>
          <target state="translated">Specifically:</target>
        </trans-unit>
        <trans-unit id="a641ebcd0020283fedd21072f7904f9b73d7b789" translate="yes" xml:space="preserve">
          <source>Specifies the location where debugger should locate TypeScript files instead of source locations. Use this flag if the sources will be located at run-time in a different location than that at design-time. The location specified will be embedded in the sourceMap to direct the debugger where the source files will be located.</source>
          <target state="translated">デバッガがソースの場所ではなく、TypeScript ファイルを配置する場所を指定します。実行時にデザイン時とは異なる場所にソースが配置される場合は、このフラグを使用します。指定された場所は sourceMap に埋め込まれ、デバッガにソースファイルが配置される場所を指示します。</target>
        </trans-unit>
        <trans-unit id="1c2da7a5fc698b5da97db9b13fe3154907aad09d" translate="yes" xml:space="preserve">
          <source>Specifies the location where debugger should locate map files instead of generated locations. Use this flag if the .map files will be located at run-time in a different location than the .js files. The location specified will be embedded in the sourceMap to direct the debugger where the map files will be located. This flag will not create the specified path and generate the map files in that location. Instead, create a post build step that moves the files to the specified path.</source>
          <target state="translated">デバッガーが生成された場所ではなく、マップファイルを配置する場所を指定します。.map ファイルが実行時に .js ファイルとは異なる場所に配置される場合は、このフラグを使用します。指定された場所は sourceMap に埋め込まれ、マップ ファイルが配置される場所をデバッガに指示します。このフラグは、指定されたパスを作成してその場所にマップファイルを生成することはありません。代わりに、指定したパスにファイルを移動させるポストビルドステップを作成します。</target>
        </trans-unit>
        <trans-unit id="794dd3dcf9665f5b582a96a912c3cb49b4c72f8a" translate="yes" xml:space="preserve">
          <source>Specifies the object invoked for &lt;code&gt;createElement&lt;/code&gt; and &lt;code&gt;__spread&lt;/code&gt; when targeting &lt;code&gt;&quot;react&quot;&lt;/code&gt; JSX emit.</source>
          <target state="translated">&lt;code&gt;&quot;react&quot;&lt;/code&gt; JSX &lt;code&gt;__spread&lt;/code&gt; をターゲットとするときに &lt;code&gt;createElement&lt;/code&gt; および__spreadに対して呼び出されるオブジェクトを指定します。</target>
        </trans-unit>
        <trans-unit id="87746b728ea4f460f7202426ccc6c557238e85b3" translate="yes" xml:space="preserve">
          <source>Specifies the root directory of input files. Only use to control the output directory structure with &lt;code&gt;--outDir&lt;/code&gt;.</source>
          <target state="translated">入力ファイルのルートディレクトリを指定します。 &lt;code&gt;--outDir&lt;/code&gt; で出力ディレクトリ構造を制御するためにのみ使用します。</target>
        </trans-unit>
        <trans-unit id="6f3b79249d834c08c2bb8f8527cca3825f4ecc15" translate="yes" xml:space="preserve">
          <source>Specify &lt;code&gt;&quot;types&quot;: []&lt;/code&gt; to disable automatic inclusion of &lt;code&gt;@types&lt;/code&gt; packages.</source>
          <target state="translated">&lt;code&gt;&quot;types&quot;: []&lt;/code&gt; を指定して、 &lt;code&gt;@types&lt;/code&gt; パッケージの自動インクルードを無効にします。</target>
        </trans-unit>
        <trans-unit id="04e339988f7084fdc3b9871407ec6d486b9796f2" translate="yes" xml:space="preserve">
          <source>Specify ECMAScript target version:</source>
          <target state="translated">ECMAScript のターゲットバージョンを指定します。</target>
        </trans-unit>
        <trans-unit id="22bae6477e590560d376f1ca2a920f0f7137f9ff" translate="yes" xml:space="preserve">
          <source>Specify module code generation: &lt;code&gt;&quot;None&quot;&lt;/code&gt;, &lt;code&gt;&quot;CommonJS&quot;&lt;/code&gt;, &lt;code&gt;&quot;AMD&quot;&lt;/code&gt;, &lt;code&gt;&quot;System&quot;&lt;/code&gt;, &lt;code&gt;&quot;UMD&quot;&lt;/code&gt;, &lt;code&gt;&quot;ES6&quot;&lt;/code&gt;, &lt;code&gt;&quot;ES2015&quot;&lt;/code&gt; or &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt;.</source>
          <target state="translated">モジュールコード生成を指定します： &lt;code&gt;&quot;None&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;CommonJS&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;AMD&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;System&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;UMD&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;ES6&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;ES2015&quot;&lt;/code&gt; または &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f17fc5b5e06de09269af8bc9bf5322fe97b5fb06" translate="yes" xml:space="preserve">
          <source>Specify the JSX factory function to use when targeting react JSX emit, e.g. &lt;code&gt;React.createElement&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;React.createElement&lt;/code&gt; や &lt;code&gt;h&lt;/code&gt; など、react JSX エミットをターゲットにするときに使用するJSXファクトリ関数を指定します。</target>
        </trans-unit>
        <trans-unit id="26252f00b41f16be2c212af5b97551e657c2f43c" translate="yes" xml:space="preserve">
          <source>Specify what file to store incremental build information in.</source>
          <target state="translated">インクリメンタルビルド情報を保存するファイルを指定します。</target>
        </trans-unit>
        <trans-unit id="5b0ffc462bd014144a57832b75b37bec6b627992" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;--outFile&lt;/code&gt; in conjunction with &lt;code&gt;--module amd&lt;/code&gt; or &lt;code&gt;--module system&lt;/code&gt; will concatenate all modules in the compilation into a single output file containing multiple module closures.</source>
          <target state="translated">指定 &lt;code&gt;--outFile&lt;/code&gt; と併せて &lt;code&gt;--module amd&lt;/code&gt; または &lt;code&gt;--module system&lt;/code&gt; 複数のモジュールの閉鎖を含む単一の出力ファイルにコンパイル内のすべてのモジュールを連結します。</target>
        </trans-unit>
        <trans-unit id="ecac73aab16df45bc37442b177ade411f7d911ae" translate="yes" xml:space="preserve">
          <source>Specifying the type of &lt;code&gt;this&lt;/code&gt; for functions</source>
          <target state="translated">関数の &lt;code&gt;this&lt;/code&gt; タイプを指定する</target>
        </trans-unit>
        <trans-unit id="076b62c1c3d09beab9691ee6f442faa2e62ef7a7" translate="yes" xml:space="preserve">
          <source>Speed improvements</source>
          <target state="translated">スピードの向上</target>
        </trans-unit>
        <trans-unit id="57c7cf9d2a0cafdf74f389b4d473eed903a50706" translate="yes" xml:space="preserve">
          <source>Splitting Across Files</source>
          <target state="translated">ファイル間の分割</target>
        </trans-unit>
        <trans-unit id="2bde101117a83786a9fe359d813c1badf4a6b2ee" translate="yes" xml:space="preserve">
          <source>Spread</source>
          <target state="translated">Spread</target>
        </trans-unit>
        <trans-unit id="e52ae13e940c439690285391dab1a0051b0c2e04" translate="yes" xml:space="preserve">
          <source>Spread expressions with tuple types</source>
          <target state="translated">タプル型を使った展開式</target>
        </trans-unit>
        <trans-unit id="d6ace75d8be9881329b05b54b6dc429938f458c6" translate="yes" xml:space="preserve">
          <source>Stable packages are available here:</source>
          <target state="translated">安定したパッケージはこちらでご用意しています。</target>
        </trans-unit>
        <trans-unit id="457a8825cdb8efe6f8ed3954625c3f151b370bc9" translate="yes" xml:space="preserve">
          <source>Starting TypeScript 2.9 errors are displayed under &lt;code&gt;--pretty&lt;/code&gt; by default if the output device is applicable for colorful text. TypeScript will check if the output steam has &lt;a href=&quot;https://nodejs.org/api/tty.html&quot;&gt;&lt;code&gt;isTty&lt;/code&gt;&lt;/a&gt; property set.</source>
          <target state="translated">出力デバイスがカラフルなテキストに適用できる場合、TypeScript 2.9の開始エラーはデフォルトで &lt;code&gt;--pretty&lt;/code&gt; の下に表示されます。TypeScriptは、出力&lt;a href=&quot;https://nodejs.org/api/tty.html&quot;&gt; &lt;code&gt;isTty&lt;/code&gt; &lt;/a&gt;プロパティが設定されているかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="e1bd71f28dac9f8b9839f2877d980ac89846a470" translate="yes" xml:space="preserve">
          <source>Starting from release 1.6 TypeScript compiler will use different set of rules to resolve module names when targeting &amp;lsquo;commonjs&amp;rsquo;. These &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2338&quot;&gt;rules&lt;/a&gt; attempted to model module lookup procedure used by Node. This effectively mean that node modules can include information about its typings and TypeScript compiler will be able to find it. User however can override module resolution rules picked by the compiler by using &lt;code&gt;--moduleResolution&lt;/code&gt; command line option. Possible values are:</source>
          <target state="translated">リリース1.6以降、TypeScriptコンパイラは、「commonjs」をターゲットとする場合、異なるルールセットを使用してモジュール名を解決します。これらの&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2338&quot;&gt;ルール&lt;/a&gt;は、Nodeが使用するモジュール検索手順をモデル化しようとしました。これは事実上、ノードモジュールに型付けに関する情報を含めることができ、TypeScriptコンパイラがそれを見つけられることを意味します。ただし、ユーザーは &lt;code&gt;--moduleResolution&lt;/code&gt; コマンドラインオプションを使用して、コンパイラーが選択したモジュール解決ルールをオーバーライドできます。可能な値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e863c718db915f2f4b58c523e97d4f07d5237232" translate="yes" xml:space="preserve">
          <source>Starting out</source>
          <target state="translated">スタートアップ</target>
        </trans-unit>
        <trans-unit id="27ba7e115de3bfd5bf5dc01034bb164d0740a437" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, &lt;code&gt;symbol&lt;/code&gt; is a primitive data type, just like &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">ECMAScript 2015以降、 &lt;code&gt;symbol&lt;/code&gt; は、 &lt;code&gt;number&lt;/code&gt; や &lt;code&gt;string&lt;/code&gt; と同様に、プリミティブデータ型です。</target>
        </trans-unit>
        <trans-unit id="f7d9af76ba0d605e072032df04742ab0cf02228b" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, JavaScript has a concept of modules. TypeScript shares this concept.</source>
          <target state="translated">ECMAScript 2015から、JavaScriptにはモジュールという概念があります。TypeScriptもこの概念を共有しています。</target>
        </trans-unit>
        <trans-unit id="afc8e56cf364b15c88268122ccbfe29a39ca7ca5" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations. Thus, for new projects modules would be the recommended code organization mechanism.</source>
          <target state="translated">ECMAScript 2015 以降、モジュールは言語のネイティブな部分であり、すべての準拠したエンジンの実装でサポートされるべきです。したがって、新しいプロジェクトでは、モジュールが推奨されるコード編成メカニズムとなります。</target>
        </trans-unit>
        <trans-unit id="51e38a40604a0a2de5e2d000abadb800295b34df" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 1.8, official NuGet packages are available for the Typescript Compiler (&lt;code&gt;tsc.exe&lt;/code&gt;) as well as the MSBuild integration (&lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; and &lt;code&gt;Microsoft.TypeScript.Tasks.dll&lt;/code&gt;).</source>
          <target state="translated">TypeScript 1.8以降、公式のNuGetパッケージが &lt;code&gt;tsc.exe&lt;/code&gt; コンパイラ（tsc.exe）およびMSBuild統合（ &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; および &lt;code&gt;Microsoft.TypeScript.Tasks.dll&lt;/code&gt; ）で利用できます。</target>
        </trans-unit>
        <trans-unit id="fe907641294d4a842173702363c42ee105d23f56" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 1.8:</source>
          <target state="translated">TypeScript 1.8からスタート。</target>
        </trans-unit>
        <trans-unit id="667eaed082674a988c7fa4d7c4bc04735599c26c" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 2.3, the default &lt;code&gt;tsconfig.json&lt;/code&gt; generated by &lt;code&gt;tsc --init&lt;/code&gt; includes a &lt;code&gt;&quot;strict&quot;: true&lt;/code&gt; setting in the &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; section. Thus, new projects started with &lt;code&gt;tsc --init&lt;/code&gt; will by default have the highest level of type safety enabled.</source>
          <target state="translated">活字体2.3以降では、デフォルトの &lt;code&gt;tsconfig.json&lt;/code&gt; によって生成された &lt;code&gt;tsc --init&lt;/code&gt; 含まれ &lt;code&gt;&quot;strict&quot;: true&lt;/code&gt; の設定 &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; セクションを。したがって、 &lt;code&gt;tsc --init&lt;/code&gt; で開始された新しいプロジェクトでは、デフォルトで最高レベルのタイプセーフが有効になります。</target>
        </trans-unit>
        <trans-unit id="3b2ba1ad0dec7805611669102a4687a54df4fb4a" translate="yes" xml:space="preserve">
          <source>Statements guaranteed to not be executed at run time are now correctly flagged as unreachable code errors. For instance, statements following unconditional &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt; statements are considered unreachable. Use &lt;code&gt;--allowUnreachableCode&lt;/code&gt; to disable unreachable code detection and reporting.</source>
          <target state="translated">実行時に実行されないことが保証されているステートメントは、到達不能コードエラーとして正しくフラグ付けされるようになりました。たとえば、無条件の &lt;code&gt;return&lt;/code&gt; 、 &lt;code&gt;throw&lt;/code&gt; 、 &lt;code&gt;break&lt;/code&gt; または &lt;code&gt;continue&lt;/code&gt; ステートメントに続くステートメントは到達不可能と見なされます。使用は &lt;code&gt;--allowUnreachableCode&lt;/code&gt; 無効到達不能コード検出および報告に。</target>
        </trans-unit>
        <trans-unit id="5dd52f62e1be6f918ab77a38268c4534241ce617" translate="yes" xml:space="preserve">
          <source>Static Properties</source>
          <target state="translated">静的なプロパティ</target>
        </trans-unit>
        <trans-unit id="8c4de2a053d6fce41e20676b11e60a8bda4be893" translate="yes" xml:space="preserve">
          <source>Static methods on an exported class have a similar problem - the class itself adds a layer of nesting. Unless it increases expressivity or intent in a clearly useful way, consider simply exporting a helper function.</source>
          <target state="translated">エクスポートされたクラスのスタティックメソッドにも同様の問題があります。明らかに有用な方法で表現力や意図を高めるのでなければ、単にヘルパー関数をエクスポートすることを検討してください。</target>
        </trans-unit>
        <trans-unit id="e056817fe3841123d274840f9970929fd1661955" translate="yes" xml:space="preserve">
          <source>StaticZipCodeValidator.ts</source>
          <target state="translated">StaticZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="876f3e0202ca40dedf2e5ab6577eba1ae637fb53" translate="yes" xml:space="preserve">
          <source>Strategies</source>
          <target state="translated">Strategies</target>
        </trans-unit>
        <trans-unit id="b24ced1a6bde1cad399359d1809b17476b8956ce" translate="yes" xml:space="preserve">
          <source>Strict &lt;code&gt;null&lt;/code&gt; &amp;amp; &lt;code&gt;undefined&lt;/code&gt; Checks</source>
          <target state="translated">厳密な &lt;code&gt;null&lt;/code&gt; および &lt;code&gt;undefined&lt;/code&gt; チェック</target>
        </trans-unit>
        <trans-unit id="ba990120d287758ccaffce7420f0d37783310854" translate="yes" xml:space="preserve">
          <source>Strict Class Initialization</source>
          <target state="translated">厳格なクラス初期化</target>
        </trans-unit>
        <trans-unit id="e8a4e48ac15ba59cbf4a0e834cf82e7a56d1dc79" translate="yes" xml:space="preserve">
          <source>Strict contravariance for callback parameters</source>
          <target state="translated">コールバックパラメータの厳密な矛盾</target>
        </trans-unit>
        <trans-unit id="8236c998ec2e20c7b6ba2fbd2308a5a59e458fff" translate="yes" xml:space="preserve">
          <source>Strict function types</source>
          <target state="translated">厳密な関数型</target>
        </trans-unit>
        <trans-unit id="503ce04e3c451abd56d5c6cc0eeb1f004a6a9b01" translate="yes" xml:space="preserve">
          <source>Stricter Generators</source>
          <target state="translated">厳格化されたジェネレーター</target>
        </trans-unit>
        <trans-unit id="ac111df4e339d358e1192621e12afb377c50ec08" translate="yes" xml:space="preserve">
          <source>Stricter Generics</source>
          <target state="translated">より厳格なジェネリック</target>
        </trans-unit>
        <trans-unit id="7c1c37e677884ed5162824f92bf4ac0323765899" translate="yes" xml:space="preserve">
          <source>Stricter checking for generic functions</source>
          <target state="translated">汎用関数のチェックを厳格化</target>
        </trans-unit>
        <trans-unit id="59d7c0445a12d3c38c6410a065795f30dedb9910" translate="yes" xml:space="preserve">
          <source>Stricter object literal assignment checks</source>
          <target state="translated">より厳格なオブジェクトリテラルの代入チェック</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="d38945e9d63e72217f1ff6e3be1ea79fbfff3091" translate="yes" xml:space="preserve">
          <source>String Enums</source>
          <target state="translated">文字列列列挙</target>
        </trans-unit>
        <trans-unit id="b9ee8e1a51d8d2f14d5767f34ddd3e68f008e59a" translate="yes" xml:space="preserve">
          <source>String Literal Types</source>
          <target state="translated">文字列リテラル型</target>
        </trans-unit>
        <trans-unit id="ffa12823a95532beb06727f353cfba4e754b5e99" translate="yes" xml:space="preserve">
          <source>String enums</source>
          <target state="translated">文字列列列挙</target>
        </trans-unit>
        <trans-unit id="135b4e07f53722d425681f40b44219a30c502379" translate="yes" xml:space="preserve">
          <source>String enums are a similar concept, but have some subtle &lt;a href=&quot;#enums-at-runtime&quot;&gt;runtime differences&lt;/a&gt; as documented below. In a string enum, each member has to be constant-initialized with a string literal, or with another string enum member.</source>
          <target state="translated">文字列列挙型も同様の概念ですが、以下で説明するように、&lt;a href=&quot;#enums-at-runtime&quot;&gt;実行時に&lt;/a&gt;わずかな違いがあります。文字列列挙では、各メンバーを文字列リテラルまたは別の文字列列挙メンバーで定数初期化する必要があります。</target>
        </trans-unit>
        <trans-unit id="97ca47845b6de917d6acef338327258499a5fa14" translate="yes" xml:space="preserve">
          <source>String literal types</source>
          <target state="translated">文字列リテラル型</target>
        </trans-unit>
        <trans-unit id="3094f1d45b3a85252ec82b4f2621aa324f1df082" translate="yes" xml:space="preserve">
          <source>String literal types allow you to specify the exact value a string must have. In practice string literal types combine nicely with union types, type guards, and type aliases. You can use these features together to get enum-like behavior with strings.</source>
          <target state="translated">文字列リテラル型では、文字列が持つべき値を正確に指定することができます。実際には、文字列リテラル型はユニオン型、型ガード、型エイリアスとうまく組み合わせます。これらの機能を併用することで、文字列で列挙型のような動作を得ることができます。</target>
        </trans-unit>
        <trans-unit id="b874e7e8ff440bab9b01a84543e1af14d5b4bb4b" translate="yes" xml:space="preserve">
          <source>String literal types can be used in the same way to distinguish overloads:</source>
          <target state="translated">文字列リテラル型は、オーバーロードを区別するために同じように使用することができます。</target>
        </trans-unit>
        <trans-unit id="46e91541a55f18468fd6b067383aaa97a9e64cd2" translate="yes" xml:space="preserve">
          <source>String, numeric and boolean literal types (e.g. &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt;) were previously inferred only in the presence of an explicit type annotation. Starting with TypeScript 2.1, literal types are &lt;em&gt;always&lt;/em&gt; inferred for &lt;code&gt;const&lt;/code&gt; variables and &lt;code&gt;readonly&lt;/code&gt; properties.</source>
          <target state="translated">文字列、数値、ブールのリテラル型（例： &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 、 &lt;code&gt;1&lt;/code&gt; 、 &lt;code&gt;true&lt;/code&gt; ）は、以前は明示的な型注釈が存在する場合にのみ推定されていました。TypeScript 2.1以降、リテラル型は&lt;em&gt;常に&lt;/em&gt; &lt;code&gt;const&lt;/code&gt; 変数と &lt;code&gt;readonly&lt;/code&gt; プロパティに対して推論されます。</target>
        </trans-unit>
        <trans-unit id="2d8fecbc84175a2cda5fcb984cf28bdb9e9fe54b" translate="yes" xml:space="preserve">
          <source>String-like properties of an object type are those declared using an identifier, a string literal, or a computed property name of a string literal type.</source>
          <target state="translated">オブジェクト型の文字列ライクなプロパティは、識別子、文字列リテラル、または文字列リテラル型の計算されたプロパティ名を使用して宣言されたものです。</target>
        </trans-unit>
        <trans-unit id="f44c134a9d7c63d1a602a14744e321854b363720" translate="yes" xml:space="preserve">
          <source>StringValidator.ts</source>
          <target state="translated">StringValidator.ts</target>
        </trans-unit>
        <trans-unit id="e9e5d94110d726b2fb48e7030cec7299992b6e0c" translate="yes" xml:space="preserve">
          <source>Structurally identical, but distinct, class types are now preserved in union types (instead of eliminating all but one).</source>
          <target state="translated">構造的には同じですが、異なるクラス型がユニオン型に保存されるようになりました (1つを除いてすべてを削除するのではなく)。</target>
        </trans-unit>
        <trans-unit id="f188cd9e1081421f05e7530e5be35f73639cddfb" translate="yes" xml:space="preserve">
          <source>Structuring for outFiles</source>
          <target state="translated">outFiles の構造化</target>
        </trans-unit>
        <trans-unit id="9790ea759cfc56e0057f75d2b47d5dd9230cb97d" translate="yes" xml:space="preserve">
          <source>Structuring for relative modules</source>
          <target state="translated">相対モジュールの構造化</target>
        </trans-unit>
        <trans-unit id="28a732981a8711b19d230aaecb27b43ddf871667" translate="yes" xml:space="preserve">
          <source>Structuring modules to give the exact API shape you want can be tricky. For example, we might want a module that can be invoked with or without &lt;code&gt;new&lt;/code&gt; to produce different types, has a variety of named types exposed in a hierarchy, and has some properties on the module object as well.</source>
          <target state="translated">必要な正確なAPI形状を提供するためにモジュールを構造化するのは、難しい場合があります。たとえば、 &lt;code&gt;new&lt;/code&gt; を使用して、または使用せずに呼び出して、さまざまなタイプを生成し、階層内にさまざまな名前付きタイプを公開し、モジュールオブジェクトにいくつかのプロパティを備えたモジュールが必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="426c20ffe12820a1c17c8b53aa917b10b06fc64e" translate="yes" xml:space="preserve">
          <source>Stylize errors and messages using color and context.</source>
          <target state="translated">色とコンテキストを使ってエラーやメッセージをスタイリングします。</target>
        </trans-unit>
        <trans-unit id="9ce6ba148fe8d9ab4a1efa44f043d11727e7f6ee" translate="yes" xml:space="preserve">
          <source>Sublime Text</source>
          <target state="translated">崇高なテキスト</target>
        </trans-unit>
        <trans-unit id="89f541951e4630b0519550eb0b55d466b60ae9d9" translate="yes" xml:space="preserve">
          <source>Subtype vs Assignment</source>
          <target state="translated">サブタイプと割り当て</target>
        </trans-unit>
        <trans-unit id="18532a66f85c71ab4aec069080bab114bcb593de" translate="yes" xml:space="preserve">
          <source>Support &amp;lsquo;target : es5&amp;rsquo; with &amp;lsquo;module: es6&amp;rsquo;</source>
          <target state="translated">「モジュール：es6」で「ターゲット：es5」をサポート</target>
        </trans-unit>
        <trans-unit id="cf4b3d9e87de6d08216090fd0a299f43489307ab" translate="yes" xml:space="preserve">
          <source>Support &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named properties with &lt;code&gt;keyof&lt;/code&gt; and mapped types</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; とマップされた型で &lt;code&gt;number&lt;/code&gt; と &lt;code&gt;symbol&lt;/code&gt; 名前付きプロパティをサポート</target>
        </trans-unit>
        <trans-unit id="6d6731f9d93089d17da6ccec6778d165fccc26c7" translate="yes" xml:space="preserve">
          <source>Support JSX in &lt;code&gt;.tsx&lt;/code&gt; files: &lt;code&gt;&quot;react&quot;&lt;/code&gt;, &lt;code&gt;&quot;preserve&quot;&lt;/code&gt;, &lt;code&gt;&quot;react-native&quot;&lt;/code&gt;. See &lt;a href=&quot;jsx&quot;&gt;JSX&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.tsx&lt;/code&gt; ファイルでのJSXのサポート： &lt;code&gt;&quot;react&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;preserve&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;react-native&quot;&lt;/code&gt; 。&lt;a href=&quot;jsx&quot;&gt;JSXを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="05b310d45d1a230630edd11c6875345ecb5c8f86" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;--target ES2016&lt;/code&gt;, &lt;code&gt;--target ES2017&lt;/code&gt; and &lt;code&gt;--target ESNext&lt;/code&gt;</source>
          <target state="translated">サポート &lt;code&gt;--target ES2016&lt;/code&gt; 、 &lt;code&gt;--target ES2017&lt;/code&gt; と &lt;code&gt;--target ESNext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1b4ca504fdd62c03cb94726f4bcaf5058e435b4" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;--target ES6&lt;/code&gt; with &lt;code&gt;--module&lt;/code&gt;</source>
          <target state="translated">サポート &lt;code&gt;--target ES6&lt;/code&gt; と &lt;code&gt;--module&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34617739aff3f3e46b1e4ba3a7911e40d6c81ab3" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;UMD&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt; module output</source>
          <target state="translated">&lt;code&gt;UMD&lt;/code&gt; および &lt;code&gt;System&lt;/code&gt; モジュール出力のサポート</target>
        </trans-unit>
        <trans-unit id="28e272a817a6f695cb0b07fe3c763c51df093f79" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;default&lt;/code&gt; import interop with SystemJS</source>
          <target state="translated">SystemJSとの &lt;code&gt;default&lt;/code&gt; インポート相互運用のサポート</target>
        </trans-unit>
        <trans-unit id="d6916bf8e4e9fcc67b553b85f533341a04a63081" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;defaultProps&lt;/code&gt; in JSX</source>
          <target state="translated">JSX での &lt;code&gt;defaultProps&lt;/code&gt; のサポート</target>
        </trans-unit>
        <trans-unit id="bddb6099cc8b06729d2beaa2fa82e1cb4963256d" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;import d from &quot;cjs&quot;&lt;/code&gt; from CommonJS modules with &lt;code&gt;--esModuleInterop&lt;/code&gt;</source>
          <target state="translated">サポート &lt;code&gt;import d from &quot;cjs&quot;&lt;/code&gt; とCommonJSモジュールから &lt;code&gt;--esModuleInterop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2447881f3dbb81c3d00bf540954383e26e79f16a" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;import.meta&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;import.meta&lt;/code&gt; のサポート</target>
        </trans-unit>
        <trans-unit id="b85ac71ca924b44b00a2baf8d735c1f5146eae50" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;new.target&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new.target&lt;/code&gt; のサポート</target>
        </trans-unit>
        <trans-unit id="73d8dfa99384426433e9eb5bd0a25014a68b93dd" translate="yes" xml:space="preserve">
          <source>Support for Mix-in classes</source>
          <target state="translated">ミックスインクラスへの対応</target>
        </trans-unit>
        <trans-unit id="4cd188d2034c82b0cb13c97514a09e1296c575c1" translate="yes" xml:space="preserve">
          <source>Support for UMD module definitions</source>
          <target state="translated">UMDモジュール定義のサポート</target>
        </trans-unit>
        <trans-unit id="3f9527e099215a371571a39ed0291c0f01e1252f" translate="yes" xml:space="preserve">
          <source>Support for decorators when targeting ES3</source>
          <target state="translated">ES3をターゲットにした場合のデコレータのサポート</target>
        </trans-unit>
        <trans-unit id="773f4a6085e5e29b6090e773de66d818050ad310" translate="yes" xml:space="preserve">
          <source>Support for external helpers library (&lt;code&gt;tslib&lt;/code&gt;)</source>
          <target state="translated">外部ヘルパーライブラリ（ &lt;code&gt;tslib&lt;/code&gt; ）のサポート</target>
        </trans-unit>
        <trans-unit id="90086da7e4d9c7c72a78d492416302a2bce77eea" translate="yes" xml:space="preserve">
          <source>Support for plain JavaScript files (using &lt;code&gt;allowJS&lt;/code&gt; and optionally &lt;code&gt;checkJs&lt;/code&gt;)</source>
          <target state="translated">プレーンJavaScriptファイルのサポート（ &lt;code&gt;allowJS&lt;/code&gt; およびオプションで &lt;code&gt;checkJs&lt;/code&gt; を使用）</target>
        </trans-unit>
        <trans-unit id="db578fdb1495d83a80100aad5eef2fff1a254e97" translate="yes" xml:space="preserve">
          <source>Support for spread operator on JSX element children</source>
          <target state="translated">JSX要素の子要素でのスプレッド演算子のサポート</target>
        </trans-unit>
        <trans-unit id="2653012ad53a3216b4b35967a5d2774aa99160ca" translate="yes" xml:space="preserve">
          <source>Support output to IPC-driven files</source>
          <target state="translated">IPC駆動のファイルへの出力をサポート</target>
        </trans-unit>
        <trans-unit id="620a93c5c9f58f502218f8fc7b12158f1027565c" translate="yes" xml:space="preserve">
          <source>Supported JSDoc</source>
          <target state="translated">サポートされているJSDoc</target>
        </trans-unit>
        <trans-unit id="6ec78feed2dab45d29186124c86cf373749a2a02" translate="yes" xml:space="preserve">
          <source>Suppress &lt;code&gt;--noImplicitAny&lt;/code&gt; errors for indexing objects lacking index signatures. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362&quot;&gt;issue #1232&lt;/a&gt; for more details.</source>
          <target state="translated">インデックスシグネチャが不足しているインデックスオブジェクトの &lt;code&gt;--noImplicitAny&lt;/code&gt; エラーを抑制します。詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362&quot;&gt;問題＃1232&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="338998f043c7ad5149421a96548321599b5d11bd" translate="yes" xml:space="preserve">
          <source>Suppress errors in .ts files using &amp;lsquo;// @ts-ignore&amp;rsquo; comments</source>
          <target state="translated">'// @ ts-ignore'コメントを使用して.tsファイルのエラーを抑制</target>
        </trans-unit>
        <trans-unit id="8973ef81aed840ec50c9cd093b51f775080b1cf7" translate="yes" xml:space="preserve">
          <source>Suppress excess property checks for object literals.</source>
          <target state="translated">オブジェクトリテラルの過剰なプロパティチェックを抑制します。</target>
        </trans-unit>
        <trans-unit id="3585e72f4611a04509e6e0fc987893b8915a495f" translate="yes" xml:space="preserve">
          <source>Symbol-like properties of an object type are those declared using a computed property name of a unique symbol type.</source>
          <target state="translated">オブジェクト型のシンボルライクなプロパティは、ユニークなシンボル型の計算されたプロパティ名を使用して宣言されたものです。</target>
        </trans-unit>
        <trans-unit id="22ad664e9eb98b75a73333b2b2395fc4b52e6fc9" translate="yes" xml:space="preserve">
          <source>Symbols</source>
          <target state="translated">Symbols</target>
        </trans-unit>
        <trans-unit id="53fd75a5e5e2b34489476f4ecd50211e84205baf" translate="yes" xml:space="preserve">
          <source>Symbols are immutable, and unique.</source>
          <target state="translated">シンボルは不変であり、唯一無二のものです。</target>
        </trans-unit>
        <trans-unit id="0bed88fc8e0305dee9b7427dfb28c60dd6df7d7b" translate="yes" xml:space="preserve">
          <source>Symbols can also be combined with computed property declarations to declare object properties and class members.</source>
          <target state="translated">シンボルは、オブジェクトのプロパティやクラスのメンバを宣言するために、計算されたプロパティ宣言と組み合わせることもできます。</target>
        </trans-unit>
        <trans-unit id="7c6dc245d5de42731e89891927ee10ddf6d43590" translate="yes" xml:space="preserve">
          <source>Symbols: match</source>
          <target state="translated">シンボル:一致</target>
        </trans-unit>
        <trans-unit id="43536b93399f1c157500ef28d7217046b25bc3c7" translate="yes" xml:space="preserve">
          <source>Symbols: split</source>
          <target state="translated">シンボル:スプリット</target>
        </trans-unit>
        <trans-unit id="57405c7f4b3b71908ae936ac8bf9b21de6ae98b8" translate="yes" xml:space="preserve">
          <source>System SimpleModule.js</source>
          <target state="translated">システムSimpleModule.js</target>
        </trans-unit>
        <trans-unit id="058f3d3687346d631d12546d9aade907ff39e99c" translate="yes" xml:space="preserve">
          <source>System modules have this flag on by default.</source>
          <target state="translated">システムモジュールはデフォルトでこのフラグをオンにしています。</target>
        </trans-unit>
        <trans-unit id="ab624ca73eb89a17acc6188413b3be19da770c27" translate="yes" xml:space="preserve">
          <source>TS for Functional Programmers</source>
          <target state="translated">機能プログラマー向けTS</target>
        </trans-unit>
        <trans-unit id="07673a3de2879cfe1db52c3e95c21b5cff20a04e" translate="yes" xml:space="preserve">
          <source>TS for Java/C# Programmers</source>
          <target state="translated">Java/C#プログラマのためのTS</target>
        </trans-unit>
        <trans-unit id="e5625ebb46a7cebb6fe457d6cbe88c67e28246af" translate="yes" xml:space="preserve">
          <source>TS for the New Programmer</source>
          <target state="translated">新人プログラマのためのTS</target>
        </trans-unit>
        <trans-unit id="e3faa3a6af48373d85bf84403340df39a4e0870f" translate="yes" xml:space="preserve">
          <source>TSConfig Reference</source>
          <target state="translated">TSConfig リファレンス</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">目次</target>
        </trans-unit>
        <trans-unit id="1a428989bd13dceabd89b698d9fa38eb8a0d175c" translate="yes" xml:space="preserve">
          <source>Table of contents</source>
          <target state="translated">目次</target>
        </trans-unit>
        <trans-unit id="f228b75e57f130e745a665c5ce1b42328c6dfd98" translate="yes" xml:space="preserve">
          <source>Tagged template strings in ES3/ES5</source>
          <target state="translated">タグ付けされたES3/ES5のテンプレート文字列</target>
        </trans-unit>
        <trans-unit id="fab887d80b08c2be61de81a5b5b7c7f5fa4679ed" translate="yes" xml:space="preserve">
          <source>Tagged templates are a form of invocation introduced in ECMAScript 2015. Like call expressions, generic functions may be used in a tagged template and TypeScript will infer the type arguments utilized.</source>
          <target state="translated">タグ付きテンプレートは、ECMAScript 2015で導入された呼び出しの一形態です。呼び出し式と同様に、汎用関数はタグ付きテンプレートで使用することができ、TypeScriptは利用される型引数を推論します。</target>
        </trans-unit>
        <trans-unit id="2b4f32e1493a8fa164f90de2c9603dab9f3396aa" translate="yes" xml:space="preserve">
          <source>Tagged union types</source>
          <target state="translated">タグ付けされたユニオンタイプ</target>
        </trans-unit>
        <trans-unit id="ef15d77ea17c2fa0aa9a4dc5193a61bfca293a68" translate="yes" xml:space="preserve">
          <source>Take a quick second to guess what the output of the following snippet is:</source>
          <target state="translated">次のスニペットの出力が何であるかを推測してみてください。</target>
        </trans-unit>
        <trans-unit id="62ec74968326eeada16e680490be28b9d097cf14" translate="yes" xml:space="preserve">
          <source>Targeting ECMAScript 2015 and higher</source>
          <target state="translated">ECMAScript 2015以上が対象</target>
        </trans-unit>
        <trans-unit id="2bb2a353dcf3f98e351b8a5bd43ad7b5855fbf44" translate="yes" xml:space="preserve">
          <source>Targeting ES5 and ES3</source>
          <target state="translated">ES5とES3をターゲットに</target>
        </trans-unit>
        <trans-unit id="8ebc171caef41add998a541b54fac3e9f04d8a0f" translate="yes" xml:space="preserve">
          <source>Technically enums can be mixed with string and numeric members, but it&amp;rsquo;s not clear why you would ever want to do so:</source>
          <target state="translated">技術的には列挙型は文字列と数値のメンバーと組み合わせることができますが、なぜそうしたいのかは明確ではありません：</target>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="dc68610743d7021a571f80b8ceb084cbd65c3e6a" translate="yes" xml:space="preserve">
          <source>Template strings</source>
          <target state="translated">テンプレート文字列</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="c2e85441e7a65630aa9248ad72623a3bd8be6e63" translate="yes" xml:space="preserve">
          <source>Test the page by running gulp and then opening &lt;code&gt;dist/index.html&lt;/code&gt; in a browser. You should see &amp;ldquo;Hello from TypeScript&amp;rdquo; on the page.</source>
          <target state="translated">gulpを実行してから、ブラウザーで &lt;code&gt;dist/index.html&lt;/code&gt; を開き、ページをテストします。ページに「Hello from TypeScript」と表示されます。</target>
        </trans-unit>
        <trans-unit id="516512568426629f66efb194dad6577cd22670ee" translate="yes" xml:space="preserve">
          <source>Test the resulting app</source>
          <target state="translated">結果のアプリをテストする</target>
        </trans-unit>
        <trans-unit id="96936a34c6da56cc40a32168338d905fe8a635c6" translate="yes" xml:space="preserve">
          <source>Test.ts</source>
          <target state="translated">Test.ts</target>
        </trans-unit>
        <trans-unit id="13197620f3528b6ac6188ce141c50ce0cda7fc64" translate="yes" xml:space="preserve">
          <source>TestCalculator.ts</source>
          <target state="translated">TestCalculator.ts</target>
        </trans-unit>
        <trans-unit id="cfaf8455cd86f64e0270da345fff974aff74f2d4" translate="yes" xml:space="preserve">
          <source>TestProgrammerCalculator.ts</source>
          <target state="translated">TestProgrammerCalculator.ts</target>
        </trans-unit>
        <trans-unit id="aa824f1aa0454aaae79a599c4caec36b1aa0a833" translate="yes" xml:space="preserve">
          <source>Thanks to work done by &lt;a href=&quot;https://github.com/tinganho&quot;&gt;@tinganho&lt;/a&gt;, TypeScript 2.5 implements a new ECMAScript feature that allows users to omit the variable in &lt;code&gt;catch&lt;/code&gt; clauses. For example, when using &lt;code&gt;JSON.parse&lt;/code&gt; you may need to wrap calls to the function with a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;, but you may not end up using the &lt;code&gt;SyntaxError&lt;/code&gt; that gets thrown when input is erroneous.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tinganho&quot;&gt;Typeting&lt;/a&gt; 2.5は、@tinganhoによって行われた作業のおかげで、ユーザーが &lt;code&gt;catch&lt;/code&gt; 句で変数を省略できる新しいECMAScript機能を実装しています。たとえば、 &lt;code&gt;JSON.parse&lt;/code&gt; を使用する場合、関数の呼び出しを &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; でラップする必要があるかもしれませんが、入力が誤っている場合にスローされる &lt;code&gt;SyntaxError&lt;/code&gt; を使用することにはならない場合があります。</target>
        </trans-unit>
        <trans-unit id="e9dd082930f9a8388911a09a5116d64645cb5117" translate="yes" xml:space="preserve">
          <source>That &lt;code&gt;@types/&lt;/code&gt; prefix means that we also want to get the declaration files for React and React-DOM. Usually when you import a path like &lt;code&gt;&quot;react&quot;&lt;/code&gt;, it will look inside of the &lt;code&gt;react&lt;/code&gt; package itself; however, not all packages include declaration files, so TypeScript also looks in the &lt;code&gt;@types/react&lt;/code&gt; package as well. You&amp;rsquo;ll see that we won&amp;rsquo;t even have to think about this later on.</source>
          <target state="translated">その &lt;code&gt;@types/&lt;/code&gt; 私たちも反応し-DOMを反応させるのための宣言ファイルを取得したいという接頭手段。通常、 &lt;code&gt;&quot;react&quot;&lt;/code&gt; のようなパスをインポートすると、それは &lt;code&gt;react&lt;/code&gt; パッケージ自体の内部を調べます。ただし、すべてのパッケージに宣言ファイルが含まれているわけではないため、TypeScriptは &lt;code&gt;@types/react&lt;/code&gt; パッケージも検索します。後でこれについて考える必要もないことがわかります。</target>
        </trans-unit>
        <trans-unit id="25b9871704aecadb7cf39ba9a43b9edb9f462ecd" translate="yes" xml:space="preserve">
          <source>That is, in the example:</source>
          <target state="translated">つまり、例の中では</target>
        </trans-unit>
        <trans-unit id="679400f47462964a9c86c95a36308380ba51cbe6" translate="yes" xml:space="preserve">
          <source>That last example isn&amp;rsquo;t actually type-safe.</source>
          <target state="translated">その最後の例は、実際にはタイプセーフではありません。</target>
        </trans-unit>
        <trans-unit id="f3dd652958b97aac01bd3e5a584afa623f93a34e" translate="yes" xml:space="preserve">
          <source>That might result in dividing &lt;code&gt;undefined&lt;/code&gt;, which is why in &lt;code&gt;strictNullChecks&lt;/code&gt;, the following is an error.</source>
          <target state="translated">その結果、 &lt;code&gt;undefined&lt;/code&gt; が除算される可能性があります。そのため、 &lt;code&gt;strictNullChecks&lt;/code&gt; では、次のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="47f396705024ea00097d673c1c7caf3642c168b2" translate="yes" xml:space="preserve">
          <source>That was &lt;code&gt;tsconfig.json&lt;/code&gt; automatic inclusion. That does not embed module resolution as discussed above. If the compiler identified a file as a target of a module import, it will be included in the compilation regardless if it was excluded in the previous steps.</source>
          <target state="translated">それは &lt;code&gt;tsconfig.json&lt;/code&gt; の自動インクルードでした。上記で説明したように、モジュールの解決は埋め込まれません。コンパイラがファイルをモジュールインポートのターゲットとして識別した場合、前の手順で除外されたかどうかに関係なく、そのファイルはコンパイルに含まれます。</target>
        </trans-unit>
        <trans-unit id="fa532e4a22d2340a4675cbed4b144ee69c29ecb7" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s because &lt;code&gt;S&lt;/code&gt; isn&amp;rsquo;t assignable to &lt;code&gt;{ done: false, value: number }&lt;/code&gt; nor &lt;code&gt;{ done: true, value: number }&lt;/code&gt;. Why? Because the &lt;code&gt;done&lt;/code&gt; property in &lt;code&gt;S&lt;/code&gt; isn&amp;rsquo;t specific enough - it&amp;rsquo;s &lt;code&gt;boolean&lt;/code&gt; whereas each constituent of &lt;code&gt;T&lt;/code&gt; has a &lt;code&gt;done&lt;/code&gt; property that&amp;rsquo;s specifically &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. That&amp;rsquo;s what we meant by each constituent type being checked in isolation: TypeScript doesn&amp;rsquo;t just union each property together and see if &lt;code&gt;S&lt;/code&gt; is assignable to that. If it did, some bad code could get through like the following:</source>
          <target state="translated">これは、 &lt;code&gt;S&lt;/code&gt; が &lt;code&gt;{ done: false, value: number }&lt;/code&gt; も &lt;code&gt;{ done: true, value: number }&lt;/code&gt; も割り当てられないためです。どうして？ &lt;code&gt;S&lt;/code&gt; の &lt;code&gt;done&lt;/code&gt; プロパティは十分に具体的ではないため、 &lt;code&gt;boolean&lt;/code&gt; が、 &lt;code&gt;T&lt;/code&gt; の各構成要素には、 &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; である &lt;code&gt;done&lt;/code&gt; プロパティがあります。これは、構成要素の各タイプを個別にチェックすることで意味しました。TypeScriptは、各プロパティを結合して、 &lt;code&gt;S&lt;/code&gt; が割り当て可能かどうかを確認するだけではありません。もしそうなら、いくつかの悪いコードが次のように通り抜けることができます：</target>
        </trans-unit>
        <trans-unit id="ae1a2d3d73ce13174294793215ee52d989a7c794" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s exactly what TypeScript 3.7 introduces. At the &amp;ldquo;top level&amp;rdquo; of a type alias, TypeScript will defer resolving type arguments to permit these patterns.</source>
          <target state="translated">TypeScript 3.7はまさにそれを導入しています。型エイリアスの「トップレベル」では、TypeScriptは型引数の解決を延期して、これらのパターンを許可します。</target>
        </trans-unit>
        <trans-unit id="4335f12ef785a4f02d33cbf4fd5c8f14a1000242" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s not to say that block-scoped variable can never be declared with a function-scoped variable. The block-scoped variable just needs to be declared within a distinctly different block.</source>
          <target state="translated">それは、ブロックスコープの変数が関数スコープの変数で宣言されることが決してできないということではありません。ブロックスコープの変数は、明確に異なるブロック内で宣言する必要があるだけです。</target>
        </trans-unit>
        <trans-unit id="f54fb341f70cf02ca8c9aeedc3f161af36941bc9" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;short-circuiting&amp;rdquo; behavior that optional chains have is limited property accesses, calls, element accesses - it doesn&amp;rsquo;t expand any further out from these expressions. In other words,</source>
          <target state="translated">オプションのチェーンの「短絡」動作は、プロパティへのアクセス、呼び出し、要素へのアクセスが制限されているため、これらの式から拡張されることはありません。言い換えると、</target>
        </trans-unit>
        <trans-unit id="279685a1fb5d36562f5b58508949f5e1e76e1bfb" translate="yes" xml:space="preserve">
          <source>The 1.1 compiler is typically around 4x faster than any previous release. See &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx&quot;&gt;this blog post for some impressive charts.&lt;/a&gt;</source>
          <target state="translated">1.1コンパイラは通常、以前のどのリリースよりも約4倍高速です。&lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx&quot;&gt;いくつかの印象的なチャート&lt;/a&gt;については、このブログ投稿を参照してください。</target>
        </trans-unit>
        <trans-unit id="bb3c43076a9f8e3e7ef5a2ac0f5c12ab3be00750" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;Async Iteration proposal&lt;/a&gt; introduces &amp;ldquo;Async Generators&amp;rdquo;, which are async functions that also can be used to yield partial computation results. Async Generators can also delegate calls via &lt;code&gt;yield*&lt;/code&gt; to either an iterable or async iterable:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;非同期反復提案&lt;/a&gt;も部分的計算結果を得るために使用することができる非同期関数で発表「非同期ジェネレータ」。また、非同期ジェネレーターは、 &lt;code&gt;yield*&lt;/code&gt; を介して呼び出しを反復可能または非同期反復可能に委任することもできます。</target>
        </trans-unit>
        <trans-unit id="7f1ed30131b8220c2729612ebb193d0d769356ff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;library-structures&quot;&gt;Library Structures&lt;/a&gt; guide helps you understand common library formats and how to write a correct declaration file for each format. If you&amp;rsquo;re editing an existing file, you probably don&amp;rsquo;t need to read this section. Authors of new declaration files must read this section to properly understand how the format of the library influences the writing of the declaration file.</source>
          <target state="translated">&lt;a href=&quot;library-structures&quot;&gt;ライブラリの構造の&lt;/a&gt;ガイドでは、共通ライブラリの形式を理解し、どのように各フォーマットの正しい宣言ファイルを書き込むのに役立ちます。既存のファイルを編集している場合は、おそらくこのセクションを読む必要はありません。新しい宣言ファイルの作成者は、このセクションを読んで、ライブラリの形式が宣言ファイルの書き込みにどのように影響するかを正しく理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="168fd27f48806216cef1b28e300e7429c8509f10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;publishing&quot;&gt;Publishing&lt;/a&gt; section explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages.</source>
          <target state="translated">&lt;a href=&quot;publishing&quot;&gt;公開&lt;/a&gt;セクションは、NPMパッケージにあなたの宣言ファイルを公開する方法を説明し、あなたの依存パッケージを管理する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="ce97eb39054abf8cf82837da2071a640fc60351d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; property can be omitted, in which case the compiler&amp;rsquo;s defaults are used. See our full list of supported &lt;a href=&quot;compiler-options&quot;&gt;Compiler Options&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; プロパティは、コンパイラのデフォルト値が使用される場合には、省略することができます。サポートされている&lt;a href=&quot;compiler-options&quot;&gt;コンパイラオプションの&lt;/a&gt;一覧をご覧ください。</target>
        </trans-unit>
        <trans-unit id="8e8ffdb01927e70146bd53bb542f82c73b284a32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;files&quot;&lt;/code&gt; property takes a list of relative or absolute file paths. The &lt;code&gt;&quot;include&quot;&lt;/code&gt; and &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; properties take a list of glob-like file patterns. The supported glob wildcards are:</source>
          <target state="translated">&lt;code&gt;&quot;files&quot;&lt;/code&gt; プロパティは、相対または絶対ファイルパスのリストを取ります。 &lt;code&gt;&quot;include&quot;&lt;/code&gt; と &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; プロパティはグロブのようなファイルのパターンのリストを取ります。サポートされているglobワイルドカードは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5722d93ed96ab9d91793fbf0f2e4a3ba0ddbc777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator adds &lt;code&gt;null&lt;/code&gt; and/or &lt;code&gt;undefined&lt;/code&gt; to the type of the right operand depending on which are present in the type of the left operand, and the &lt;code&gt;||&lt;/code&gt; operator removes both &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from the type of the left operand in the resulting union type.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 演算子は、加算 &lt;code&gt;null&lt;/code&gt; 及び/又は &lt;code&gt;undefined&lt;/code&gt; 左オペランドの型で存在する応じた右オペランドの型に、そして &lt;code&gt;||&lt;/code&gt; 演算子は、結果の共用体型の左オペランドの型から &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; 両方を削除します。</target>
        </trans-unit>
        <trans-unit id="b4b79995af952725664d6d796fdff7040cdc711f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; flag</source>
          <target state="translated">&lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; フラグ</target>
        </trans-unit>
        <trans-unit id="dbed519ddc1c4c5224ed0885756fb408460d0e55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--declaration&lt;/code&gt; flag in TypeScript allows us to generate &lt;code&gt;.d.ts&lt;/code&gt; files (declaration files) from TypeScript source files (i.e. &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files). These &lt;code&gt;.d.ts&lt;/code&gt; files are important for a couple of reasons.</source>
          <target state="translated">TypeScript の &lt;code&gt;--declaration&lt;/code&gt; フラグを使用すると、TypeScriptソースファイル（つまり、 &lt;code&gt;.ts&lt;/code&gt; および &lt;code&gt;.tsx&lt;/code&gt; ファイル）から &lt;code&gt;.d.ts&lt;/code&gt; ファイル（宣言ファイル）を生成できます。これらの &lt;code&gt;.d.ts&lt;/code&gt; ファイルは、いくつかの理由で重要です。</target>
        </trans-unit>
        <trans-unit id="a0fb7dd8edc5f347ffbf928efce80d73f62bde6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--noResolve&lt;/code&gt; compiler options instructs the compiler not to &amp;ldquo;add&amp;rdquo; any files to the compilation that were not passed on the command line. It will still try to resolve the module to files, but if the file is not specified, it will not be included.</source>
          <target state="translated">&lt;code&gt;--noResolve&lt;/code&gt; コンパイラオプションは、コマンドラインに渡されませんでしたコンパイルに任意のファイルを「追加」しないようにコンパイラに指示します。モジュールをファイルに解決しようとしますが、ファイルが指定されていない場合は含まれません。</target>
        </trans-unit>
        <trans-unit id="9d5dd988f9131b75e837bf6bf95d2078c1309d5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--preserveSymlinks&lt;/code&gt; compiler flag</source>
          <target state="translated">&lt;code&gt;--preserveSymlinks&lt;/code&gt; コンパイラフラグ</target>
        </trans-unit>
        <trans-unit id="d292c9d31d759812ffbe643f5735affa1b872f39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--project&lt;/code&gt; (&lt;code&gt;-p&lt;/code&gt;) flag can now take any file path</source>
          <target state="translated">&lt;code&gt;--project&lt;/code&gt; （ &lt;code&gt;-p&lt;/code&gt; ）フラグは今、任意のファイルのパスを取ることができます</target>
        </trans-unit>
        <trans-unit id="a4255cfd03965e4b15ab5c96a185655e2dc5c33c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--project&lt;/code&gt; command line option originally could only take paths to a folder containing a &lt;code&gt;tsconfig.json&lt;/code&gt;. Given the different scenarios for build configurations, it made sense to allow &lt;code&gt;--project&lt;/code&gt; to point to any other compatible JSON file. For instance, a user might want to target ES2015 with CommonJS modules for Node 5, but ES5 with AMD modules for the browser. With this new work, users can easily manage two separate build targets using &lt;code&gt;tsc&lt;/code&gt; alone without having to perform hacky workarounds like placing &lt;code&gt;tsconfig.json&lt;/code&gt; files in separate directories.</source>
          <target state="translated">&lt;code&gt;--project&lt;/code&gt; コマンドラインオプションは、もともとだけ含まれているフォルダへのパスを取ることができる &lt;code&gt;tsconfig.json&lt;/code&gt; を。ビルド構成のさまざまなシナリオを考えると、 &lt;code&gt;--project&lt;/code&gt; が他の互換性のあるJSONファイルをポイントできるようにすることは理にかなっています。たとえば、ユーザーはノード5にはCommonJSモジュールを使用してES2015をターゲットにしたいが、ブラウザにはAMDモジュールを使用したES5をターゲットにすることができます。この新しい作業により、ユーザーは、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを個別のディレクトリに配置するなどのハックな回避策を実行する必要なく、 &lt;code&gt;tsc&lt;/code&gt; のみを使用して2つの個別のビルドターゲットを簡単に管理できます。</target>
        </trans-unit>
        <trans-unit id="b04bf272ea6b6bb26429cf5a5402059fbfa0a766" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--strictNullChecks&lt;/code&gt; flag fixes this: when you declare a variable, it doesn&amp;rsquo;t automatically include &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. You can include them explicitly using a union type:</source>
          <target state="translated">&lt;code&gt;--strictNullChecks&lt;/code&gt; のフラグの修正この：あなたは変数を宣言するとき、それは自動的に含まれていない &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; 。union型を使用して明示的に含めることができます。</target>
        </trans-unit>
        <trans-unit id="396ee46179af469e8ce6ffe938facf87a8ca3308" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive is the most common of this group. It serves as a declaration of &lt;em&gt;dependency&lt;/em&gt; between files.</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; ディレクティブは、このグループの中で最も一般的です。ファイル間の&lt;em&gt;依存関係の&lt;/em&gt;宣言として機能します。</target>
        </trans-unit>
        <trans-unit id="c5d5fa087679e905484eaa0544e66e00047a3587" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;??&lt;/code&gt; operator can replace uses of &lt;code&gt;||&lt;/code&gt; when trying to use a default value. For example, the following code snippet tries to fetch the volume that was last saved in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt;&lt;code&gt;localStorage&lt;/code&gt;&lt;/a&gt; (if it ever was); however, it has a bug because it uses &lt;code&gt;||&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;??&lt;/code&gt; オペレーターは &lt;code&gt;||&lt;/code&gt; の使用を置き換えることができます デフォルト値を使用しようとしたとき。たとえば、次のコードスニペットは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt; &lt;code&gt;localStorage&lt;/code&gt; &lt;/a&gt;に最後に保存されたボリュームをフェッチしようとします（ある場合）。ただし、 &lt;code&gt;||&lt;/code&gt; を使用しているため、バグがあります。。</target>
        </trans-unit>
        <trans-unit id="33ec4ccdd0a92f0fa626d1020e8655d8d52e57a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@enum&lt;/code&gt; tag allows you to create an object literal whose members are all of a specified type. Unlike most object literals in Javascript, it does not allow other members.</source>
          <target state="translated">&lt;code&gt;@enum&lt;/code&gt; のタグを使用すると、そのメンバーが指定されたタイプのすべてをあるオブジェクトリテラルを作成することができます。JavaScriptのほとんどのオブジェクトリテラルとは異なり、他のメンバーは許可されません。</target>
        </trans-unit>
        <trans-unit id="729d424ed3a9f5581bf724ec1a232c8c9d867325" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@enumerable(false)&lt;/code&gt; decorator here is a &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factory&lt;/a&gt;. When the &lt;code&gt;@enumerable(false)&lt;/code&gt; decorator is called, it modifies the &lt;code&gt;enumerable&lt;/code&gt; property of the property descriptor.</source>
          <target state="translated">ここの &lt;code&gt;@enumerable(false)&lt;/code&gt; デコレータは、&lt;a href=&quot;#decorator-factories&quot;&gt;デコレータファクトリ&lt;/a&gt;です。とき &lt;code&gt;@enumerable(false)&lt;/code&gt; デコレータが呼び出され、それが変更 &lt;code&gt;enumerable&lt;/code&gt; プロパティ記述子のプロパティを。</target>
        </trans-unit>
        <trans-unit id="2de9fb6766aab19221ef4c23a63fa9469054d5d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; decorator here is a &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factory&lt;/a&gt;. When &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; is called, it adds a metadata entry for the property using the &lt;code&gt;Reflect.metadata&lt;/code&gt; function from the &lt;code&gt;reflect-metadata&lt;/code&gt; library. When &lt;code&gt;getFormat&lt;/code&gt; is called, it reads the metadata value for the format.</source>
          <target state="translated">&lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; ここでのデコレータは、&lt;a href=&quot;#decorator-factories&quot;&gt;デコレータの工場&lt;/a&gt;。とき &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; と呼ばれ、それが使用して、プロパティのメタデータエントリを追加 &lt;code&gt;Reflect.metadata&lt;/code&gt; のから機能を &lt;code&gt;reflect-metadata&lt;/code&gt; ライブラリ。とき &lt;code&gt;getFormat&lt;/code&gt; 呼ばれ、それは形式のメタデータ値を読み取ります。</target>
        </trans-unit>
        <trans-unit id="19665d13a52211c67417591d8dd41380ae77c57c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@required&lt;/code&gt; decorator adds a metadata entry that marks the parameter as required. The &lt;code&gt;@validate&lt;/code&gt; decorator then wraps the existing &lt;code&gt;greet&lt;/code&gt; method in a function that validates the arguments before invoking the original method.</source>
          <target state="translated">&lt;code&gt;@required&lt;/code&gt; デコレータは、マークのパラメータが必要とされることをメタデータエントリを追加します。 &lt;code&gt;@validate&lt;/code&gt; のデコレータは、既存のラップ &lt;code&gt;greet&lt;/code&gt; 元のメソッドを呼び出す前に、引数を検証する機能のメソッドを。</target>
        </trans-unit>
        <trans-unit id="9608e5840a63db8f977864c74884f8b6002ea58a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ConstructorParameters&amp;lt;T&amp;gt;&lt;/code&gt; type lets us extract all parameter types of a constructor function type. It produces a tuple type with all the parameter types (or the type &lt;code&gt;never&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is not a function).</source>
          <target state="translated">&lt;code&gt;ConstructorParameters&amp;lt;T&amp;gt;&lt;/code&gt; 型は、私たちは、コンストラクタ関数のタイプのすべてのパラメータの種類を抽出することができます。これは、すべてのパラメーター型（または &lt;code&gt;T&lt;/code&gt; が関数でない場合は &lt;code&gt;never&lt;/code&gt; 型なし）のタプル型を生成します。</target>
        </trans-unit>
        <trans-unit id="e4d0252ee699e46769d5a622ff65ea37a30cb18c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; type now allows users to specify the yielded type, the returned type, and the type that &lt;code&gt;next&lt;/code&gt; can accept.</source>
          <target state="translated">&lt;code&gt;Iterator&lt;/code&gt; タイプは今、ユーザーが生成したタイプ、返さ種類、そのタイプを指定することができます &lt;code&gt;next&lt;/code&gt; 受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="7f41c5b21ee9dbf168d5ef4da903752f9e8d385c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Omit&lt;/code&gt; helper type</source>
          <target state="translated">&lt;code&gt;Omit&lt;/code&gt; ヘルパータイプ</target>
        </trans-unit>
        <trans-unit id="64a869fe08430ba63b8b26229df6154c69e8f8af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReadonlyArray&lt;/code&gt; type describes &lt;code&gt;Array&lt;/code&gt;s that can only be read from. Any variable with a reference to a &lt;code&gt;ReadonlyArray&lt;/code&gt; can&amp;rsquo;t add, remove, or replace any elements of the array.</source>
          <target state="translated">&lt;code&gt;ReadonlyArray&lt;/code&gt; のタイプは説明 &lt;code&gt;Array&lt;/code&gt; のみから読み取ることができるのを。 &lt;code&gt;ReadonlyArray&lt;/code&gt; への参照を持つ変数は、配列の要素を追加、削除、または置換できません。</target>
        </trans-unit>
        <trans-unit id="6368f607a56bb2c916a5b954c6dabe855ebf8589" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ThisType&amp;lt;T&amp;gt;&lt;/code&gt; marker interface is simply an empty interface declared in &lt;code&gt;lib.d.ts&lt;/code&gt;. Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface.</source>
          <target state="translated">&lt;code&gt;ThisType&amp;lt;T&amp;gt;&lt;/code&gt; マーカーインタフェースは、単純に宣言した空のインターフェースです &lt;code&gt;lib.d.ts&lt;/code&gt; 。オブジェクトリテラルのコンテキストタイプで認識される以外に、インターフェイスは空のインターフェイスのように動作します。</target>
        </trans-unit>
        <trans-unit id="eac98c87d76e62726c164fbe787eb6f8c34463c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amd-dependency&lt;/code&gt; directive can also have an optional &lt;code&gt;name&lt;/code&gt; property; this allows passing an optional name for an amd-dependency:</source>
          <target state="translated">&lt;code&gt;amd-dependency&lt;/code&gt; ディレクティブは、オプションのことができます &lt;code&gt;name&lt;/code&gt; プロパティを。これにより、amd-dependencyにオプションの名前を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="5e27299aa8a8890f9cedcc0ab41fbf05f07fd29d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amd-module&lt;/code&gt; directive allows passing an optional module name to the compiler:</source>
          <target state="translated">&lt;code&gt;amd-module&lt;/code&gt; ディレクティブは、コンパイラにオプションのモジュール名を渡すことができます：</target>
        </trans-unit>
        <trans-unit id="a057b54c00069469116e2e7ce7d79e2e760309d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; type is a powerful way to work with existing JavaScript, allowing you to gradually opt-in and opt-out of type checking during compilation. You might expect &lt;code&gt;Object&lt;/code&gt; to play a similar role, as it does in other languages. However, variables of type &lt;code&gt;Object&lt;/code&gt; only allow you to assign any value to them. You can&amp;rsquo;t call arbitrary methods on them, even ones that actually exist:</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; タイプができるように、JavaScriptを既存との仕事に強力な方法であるあなたに徐々にオプトインとオプトアウト型チェックのコンパイル中。他の言語と同様に、 &lt;code&gt;Object&lt;/code&gt; が同様の役割を果たすことを期待するかもしれません。ただし、 &lt;code&gt;Object&lt;/code&gt; 型の変数では、値を割り当てることしかできません。それらに対して任意のメソッドを呼び出すことはできません。実際に存在するものも含めます。</target>
        </trans-unit>
        <trans-unit id="c0017d222210d0ddb4e497a93705b0979da8a1a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; type is also handy if you know some part of the type, but perhaps not all of it. For example, you may have an array but the array has a mix of different types:</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; あなたがタイプの一部を知っているが、おそらくすべてではない、それの場合は種類も便利です。たとえば、配列がある場合でも、配列にはさまざまなタイプが混在しています。</target>
        </trans-unit>
        <trans-unit id="3e134f2fc8f2da81e48dedae85eec0c1c0994e99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; operator</source>
          <target state="translated">オペレータ &lt;code&gt;as&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3c73e06a99fdb1de9fb8c344fa7c098a7a03b56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; operator is available in both &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files, and is identical in behavior to the angle-bracket type assertion style.</source>
          <target state="translated">オペレータは、両方で利用可能です &lt;code&gt;.ts&lt;/code&gt; と &lt;code&gt;.tsx&lt;/code&gt; ファイル、およびアングルブラケット型アサーションスタイルに動作は同じです。 &lt;code&gt;as&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3a92cff5154e72c024dab414b5c117b995405f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exclude&lt;/code&gt; list does not support wilcards. It must simply be a list of files and/or directories.</source>
          <target state="translated">&lt;code&gt;exclude&lt;/code&gt; リストはwilcardsサポートしていません。単にファイルやディレクトリのリストでなければなりません。</target>
        </trans-unit>
        <trans-unit id="c3af89dee69149756441c4182df39cc8f0c3f4db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export =&lt;/code&gt; syntax specifies a single object that is exported from the module. This can be a class, interface, namespace, function, or enum.</source>
          <target state="translated">&lt;code&gt;export =&lt;/code&gt; 構文は、モジュールからエクスポートされた単一のオブジェクトを指定します。これは、クラス、インターフェース、名前空間、関数、または列挙型にすることができます。</target>
        </trans-unit>
        <trans-unit id="17738861fda178b7ad88eea31d19aa3f7764605b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extends&lt;/code&gt; clause of a class previously required a type reference to be specified. It now accepts an expression optionally followed by a type argument list. The type of the expression must be a constructor function type with at least one construct signature that has the same number of type parameters as the number of type arguments specified in the &lt;code&gt;extends&lt;/code&gt; clause. The return type of the matching construct signature(s) is the base type from which the class instance type inherits. Effectively, this allows both real classes and &amp;ldquo;class-like&amp;rdquo; expressions to be specified in the &lt;code&gt;extends&lt;/code&gt; clause.</source>
          <target state="translated">クラスの &lt;code&gt;extends&lt;/code&gt; 節では、以前は型参照を指定する必要がありました。これは、オプションで、その後に型引数リストが続く式を受け入れます。式の型は、 &lt;code&gt;extends&lt;/code&gt; 句で指定された型引数の数と同じ数の型パラメーターを持つ、少なくとも1つの構成シグニチャーを持つコンストラクター関数型でなければなりません。一致する構成シグニチャーの戻りタイプは、クラスインスタンスタイプが継承する基本タイプです。事実上、これにより、実際のクラスと「クラスのような」式の両方を &lt;code&gt;extends&lt;/code&gt; 節で指定できます。</target>
        </trans-unit>
        <trans-unit id="ba2b01f6262a247dc48cefc8edd8183caa3b6800" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extends&lt;/code&gt; is a top-level property in &lt;code&gt;tsconfig.json&lt;/code&gt; (alongside &lt;code&gt;compilerOptions&lt;/code&gt;, &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, and &lt;code&gt;exclude&lt;/code&gt;). &lt;code&gt;extends&lt;/code&gt;&amp;rsquo; value is a string containing a path to another configuration file to inherit from. The path may use Node.js style resolution.</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; でトップレベルのプロパティです &lt;code&gt;tsconfig.json&lt;/code&gt; （並んで &lt;code&gt;compilerOptions&lt;/code&gt; 、 &lt;code&gt;files&lt;/code&gt; 、 &lt;code&gt;include&lt;/code&gt; 、かつ &lt;code&gt;exclude&lt;/code&gt; ）。 &lt;code&gt;extends&lt;/code&gt; '値は、継承元の別の構成ファイルへのパスを含む文字列です。パスはNode.jsスタイルの解決を使用する場合があります。</target>
        </trans-unit>
        <trans-unit id="3017f557a2f328b58256e1eb412ef2360a4c4d18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for-await-of&lt;/code&gt; Statement</source>
          <target state="translated">&lt;code&gt;for-await-of&lt;/code&gt; 声明</target>
        </trans-unit>
        <trans-unit id="070a2aede6e683916dcd05d3af0a560d4036508a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for..await..of&lt;/code&gt; statement is only legal within an Async Function or Async Generator.</source>
          <target state="translated">&lt;code&gt;for..await..of&lt;/code&gt; 文は、非同期関数または非同期ジェネレータ内でのみ合法です。</target>
        </trans-unit>
        <trans-unit id="c1d7afbee8b4e917fda3b9d2fe2dbda01149f13f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getWidget&lt;/code&gt; function accepts a number and returns a Widget, or accepts a string and returns a Widget array.</source>
          <target state="translated">&lt;code&gt;getWidget&lt;/code&gt; の関数は、数値を受け入れ、ウィジェットを返す、または文字列を受け取り、ウィジェット配列を返します。</target>
        </trans-unit>
        <trans-unit id="b90a2540458db7fb3aef294d8c4559c6aab9f51d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;greeter&lt;/code&gt; object can log to a file or display an alert. You can provide LogOptions to &lt;code&gt;.log(...)&lt;/code&gt; and alert options to &lt;code&gt;.alert(...)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;greeter&lt;/code&gt; オブジェクトは、ファイルへのログまたはアラートを表示することができます。 &lt;code&gt;.log(...)&lt;/code&gt; に LogOptionsを、.alert （...）にアラートオプションを提供できます &lt;code&gt;.alert(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21c39d544da86c80cc2e6b131693af3e027fdc76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in&lt;/code&gt; operator now acts as a narrowing expression for types.</source>
          <target state="translated">作業は今のタイプの狭小化表現として機能します。 &lt;code&gt;in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1dd9f41eb7331354f03e6ddd8b1c9f2a64fbffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;length&lt;/code&gt; property of a tuple type with optional elements is a union of numeric literal types representing the possible lengths. For example, the type of the &lt;code&gt;length&lt;/code&gt; property in the tuple type &lt;code&gt;[number, string?, boolean?]&lt;/code&gt; is &lt;code&gt;1 | 2 | 3&lt;/code&gt;.</source>
          <target state="translated">オプションの要素を持つタプル型の &lt;code&gt;length&lt;/code&gt; プロパティは、可能な長さを表す数値リテラル型の和集合です。たとえば、タプルタイプ &lt;code&gt;[number, string?, boolean?]&lt;/code&gt; の &lt;code&gt;length&lt;/code&gt; プロパティのタイプは &lt;code&gt;1 | 2 | 3&lt;/code&gt; です。2 | ３。</target>
        </trans-unit>
        <trans-unit id="b63b4343498819e73c1335f4802dd4ecef55b161" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="a9f3d4cb7613ec649d53f0d74013eb6fa4569ec9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type has the following characteristics:</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 種類は、次の特性があります。</target>
        </trans-unit>
        <trans-unit id="1e1a0ee3128b4be96a4b23dc31c8ff4663ecbf13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type is a subtype of, and assignable to, every type; however, &lt;em&gt;no&lt;/em&gt; type is a subtype of, or assignable to, &lt;code&gt;never&lt;/code&gt; (except &lt;code&gt;never&lt;/code&gt; itself). Even &lt;code&gt;any&lt;/code&gt; isn&amp;rsquo;t assignable to &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 種類はのサブタイプ、および、すべてのタイプに割り当て可能です。しかし、&lt;em&gt;何の&lt;/em&gt;タイプはのサブタイプ、または、に割り当て可能ではありません &lt;code&gt;never&lt;/code&gt; （除く &lt;code&gt;never&lt;/code&gt; 自体が）。 &lt;code&gt;any&lt;/code&gt; も &lt;code&gt;never&lt;/code&gt; 割り当て可能ではありません。</target>
        </trans-unit>
        <trans-unit id="c32d1689d5690c0a84ea806da09f9080b457ae29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type represents the type of values that never occur. For instance, &lt;code&gt;never&lt;/code&gt; is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns; Variables also acquire the type &lt;code&gt;never&lt;/code&gt; when narrowed by any type guards that can never be true.</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 種類は発生しない値の種類を表します。たとえば、 &lt;code&gt;never&lt;/code&gt; は常に例外をスローする関数式またはアロー関数式の戻り値の型、または決して戻らないものです。また、変数は、真になることのないタイプガードによって狭められた場合、 &lt;code&gt;never&lt;/code&gt; 型を取得しません。</target>
        </trans-unit>
        <trans-unit id="415ee7bd886be7d1a3ff4410f75297e6f875a010" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new.target&lt;/code&gt; meta-property is new syntax introduced in ES2015. When an instance of a constructor is created via &lt;code&gt;new&lt;/code&gt;, the value of &lt;code&gt;new.target&lt;/code&gt; is set to be a reference to the constructor function initially used to allocate the instance. If a function is called rather than constructed via &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;new.target&lt;/code&gt; is set to &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new.target&lt;/code&gt; メタプロパティは、ES2015に導入された新しい構文です。 &lt;code&gt;new&lt;/code&gt; を介してコンストラクタのインスタンスが作成されると、 &lt;code&gt;new.target&lt;/code&gt; の値は、インスタンスを割り当てるために最初に使用されたコンストラクタ関数への参照になるように設定されます。 &lt;code&gt;new&lt;/code&gt; を介して構築されるのではなく関数が呼び出される場合、 &lt;code&gt;new.target&lt;/code&gt; は &lt;code&gt;undefined&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="19477c8f1cfa1e9c60356444eaaad7d0b42b9b97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; types are &lt;em&gt;not&lt;/em&gt; widened to &lt;code&gt;any&lt;/code&gt; in strict null checking mode.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; 種類はされて&lt;em&gt;いない&lt;/em&gt;に広がった &lt;code&gt;any&lt;/code&gt; 厳格なヌルチェックモードで。</target>
        </trans-unit>
        <trans-unit id="fa34aa7759f5de219e7583fd1dd7f008d517869c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;null&lt;/code&gt; elimination is pretty obvious here, but you can use terser operators too:</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 除去は、ここでかなり明白ですが、あまりにもterser演算子を使用することができます。</target>
        </trans-unit>
        <trans-unit id="3b9cc299e7f4d8fe545c9d49c0fc120f67d07f88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; property of each reference can point to a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file, or to the config file itself (which may have any name).</source>
          <target state="translated">各参照の &lt;code&gt;path&lt;/code&gt; プロパティは、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを含むディレクトリ、または構成ファイル自体（任意の名前を持つ可能性があります）を指すことができます。</target>
        </trans-unit>
        <trans-unit id="c5b3e36b4b2dc53fe86b3370909ee5fca3f8d695" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;preserve&lt;/code&gt; mode will keep JSX expressions as part of the output to be further consumed by another transform step. &lt;em&gt;Additionally the output will have a &lt;code&gt;.jsx&lt;/code&gt; file extension.&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;preserve&lt;/code&gt; モードは、さらに別の変換ステップによって消費される出力の一部としてJSX式を維持します。&lt;em&gt;さらに、出力には &lt;code&gt;.jsx&lt;/code&gt; ファイル拡張子が付きます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="854b44746f0abc418eff6be7c3fdd54bb19efc1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;protected&lt;/code&gt; modifier acts much like the &lt;code&gt;private&lt;/code&gt; modifier with the exception that members declared &lt;code&gt;protected&lt;/code&gt; can also be accessed within deriving classes. For example,</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; 修飾子はかなりのような役割を果たし &lt;code&gt;private&lt;/code&gt; メンバーが宣言ことを除いて、モディファイ &lt;code&gt;protected&lt;/code&gt; も派生クラス内でアクセスすることができます。例えば、</target>
        </trans-unit>
        <trans-unit id="f60b5b9402d0bcc5b53cc9b4ebead84ff4399b9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react&lt;/code&gt; mode will emit &lt;code&gt;React.createElement&lt;/code&gt;, does not need to go through a JSX transformation before use, and the output will have a &lt;code&gt;.js&lt;/code&gt; file extension.</source>
          <target state="translated">&lt;code&gt;react&lt;/code&gt; 発光するモード &lt;code&gt;React.createElement&lt;/code&gt; は、使用前にJSX変換を通過する必要はありません、と出力があります &lt;code&gt;.js&lt;/code&gt; ファイル拡張子を。</target>
        </trans-unit>
        <trans-unit id="731bfb54c9c710c3fddba0d525348937d618334a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; properties will appear with correct types on all components</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; と &lt;code&gt;key&lt;/code&gt; のプロパティは、すべてのコンポーネントの正しい種類が表示されます</target>
        </trans-unit>
        <trans-unit id="3ff4b0ed4771c56a90177b8d4ff4bd3f592871c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; property is correctly disallowed on instances of Stateless Function components</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; プロパティが正しくステートレス機能コンポーネントのインスタンスに許可されません</target>
        </trans-unit>
        <trans-unit id="afd948bd24859b80dd2610380a6c20a8cd87a044" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rootDir&lt;/code&gt; setting, if not explicitly set, defaults to the directory containing the &lt;code&gt;tsconfig&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;rootDir&lt;/code&gt; 設定、明示的に含むディレクトリに、デフォルト値を設定しない場合 &lt;code&gt;tsconfig&lt;/code&gt; ファイルを</target>
        </trans-unit>
        <trans-unit id="45854eb3beba23a865f9cbaa14a544abf02a43ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; option (allowing users to switch out of &lt;code&gt;es5&lt;/code&gt; to &lt;code&gt;es3&lt;/code&gt;, &lt;code&gt;es2015&lt;/code&gt;, &lt;code&gt;esnext&lt;/code&gt;, etc.)</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; オプション（ユーザがのうちの切り替えを可能にする &lt;code&gt;es5&lt;/code&gt; に &lt;code&gt;es3&lt;/code&gt; 、 &lt;code&gt;es2015&lt;/code&gt; 、 &lt;code&gt;esnext&lt;/code&gt; 等）</target>
        </trans-unit>
        <trans-unit id="13c27e388b6d0efef978313ee87f8dcb0b62e5dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; type is also useful with intersection types in describing libraries (e.g. Ember.js) that use mixin-style patterns to describe inheritance:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; タイプは、使用ミックスイン・スタイルのパターンは、継承を記述することも図書館を説明する交差点の種類（例えばEmber.js）と便利です。</target>
        </trans-unit>
        <trans-unit id="6a29d4a5cece065318dd327e82552a8345a8bff7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useDefineForClassFields&lt;/code&gt; Flag and The &lt;code&gt;declare&lt;/code&gt; Property Modifier</source>
          <target state="translated">&lt;code&gt;useDefineForClassFields&lt;/code&gt; 旗と &lt;code&gt;declare&lt;/code&gt; プロパティ修飾子</target>
        </trans-unit>
        <trans-unit id="787315c92fdd75d5b219d459cc175e222f5c560e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Property Descriptor&lt;/em&gt; for the member.</source>
          <target state="translated">メンバーの&lt;em&gt;プロパティ記述子&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7230f5ad07f661a74fc222478036dbea6b5acfa1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;nullish coalescing operator&lt;/em&gt; is another upcoming ECMAScript feature that goes hand-in-hand with optional chaining, and which our team has been involved with championing in TC39.</source>
          <target state="translated">&lt;em&gt;演算子を合体nullishは&lt;/em&gt;、オプションのチェーンと手に手を行く他、今後のECMAScript機能であり、これは私たちのチームはTC39に擁護に携わってきました。</target>
        </trans-unit>
        <trans-unit id="ffd20aedc2df50b541f11314e29e7f1054d730a5" translate="yes" xml:space="preserve">
          <source>The Async Iteration introduces an &lt;code&gt;AsyncIterator&lt;/code&gt;, which is similar to &lt;code&gt;Iterator&lt;/code&gt;. The difference lies in the fact that the &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;throw&lt;/code&gt; methods of an &lt;code&gt;AsyncIterator&lt;/code&gt; return a &lt;code&gt;Promise&lt;/code&gt; for the iteration result, rather than the result itself. This allows the caller to enlist in an asynchronous notification for the time at which the &lt;code&gt;AsyncIterator&lt;/code&gt; has advanced to the point of yielding a value. An &lt;code&gt;AsyncIterator&lt;/code&gt; has the following shape:</source>
          <target state="translated">非同期反復が導入 &lt;code&gt;AsyncIterator&lt;/code&gt; に類似して、 &lt;code&gt;Iterator&lt;/code&gt; 。違いは、 &lt;code&gt;AsyncIterator&lt;/code&gt; の &lt;code&gt;next&lt;/code&gt; 、 &lt;code&gt;return&lt;/code&gt; 、および &lt;code&gt;throw&lt;/code&gt; メソッドが、結果自体ではなく反復結果の &lt;code&gt;Promise&lt;/code&gt; を返すという点にあります。これにより、呼び出し元は、 &lt;code&gt;AsyncIterator&lt;/code&gt; が値を生成するポイントまで進んだ時点で非同期通知に参加できます。アン &lt;code&gt;AsyncIterator&lt;/code&gt; は、次のような形状があります。</target>
        </trans-unit>
        <trans-unit id="a093f7952b1838c4dd6aeda28ea5e1fc38030960" translate="yes" xml:space="preserve">
          <source>The Basics</source>
          <target state="translated">基本的なこと</target>
        </trans-unit>
        <trans-unit id="21db3b675c232e8c920fc5cc57777d2bb7e6f2db" translate="yes" xml:space="preserve">
          <source>The Examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae6a763c1fb39d689bcd8262575ee2c673da8154" translate="yes" xml:space="preserve">
          <source>The Impact of ES6 on Module Call Signatures</source>
          <target state="translated">ES6 のモジュールコールシグネチャへの影響</target>
        </trans-unit>
        <trans-unit id="4de6669622cba77a38976c0164e1dded39f35909" translate="yes" xml:space="preserve">
          <source>The Impact of ES6 on Module Plugins</source>
          <target state="translated">ES6のモジュールプラグインへの影響</target>
        </trans-unit>
        <trans-unit id="a90186b2913ce2a03f025ed1147a0c7a6b54234e" translate="yes" xml:space="preserve">
          <source>The Iterator protocol also defines the target of some of the ES2015 features like &lt;code&gt;for..of&lt;/code&gt; and spread operator and the array rest in destructuring assignmnets.</source>
          <target state="translated">Iteratorプロトコルは、 &lt;code&gt;for..of&lt;/code&gt; 、spread演算子などのES2015機能の一部のターゲットと、assignmnetの構造化における配列の残りも定義します。</target>
        </trans-unit>
        <trans-unit id="e2e893d7917d362f27f157a05f677c2dd16c5bb9" translate="yes" xml:space="preserve">
          <source>The JSX result type</source>
          <target state="translated">JSXの結果型</target>
        </trans-unit>
        <trans-unit id="7c164a656b844ad909a272419ed0cbe9548f88f5" translate="yes" xml:space="preserve">
          <source>The TypeScript Handbook</source>
          <target state="translated">TypeScriptハンドブック</target>
        </trans-unit>
        <trans-unit id="c3dc7b38b486965f74bd526d650143ae6a37e3aa" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler has a set of additional flags to &lt;em&gt;inform&lt;/em&gt; the compiler of transformations that are expected to happen to the sources to generate the final output.</source>
          <target state="translated">TypeScriptコンパイラーには、最終的な出力を生成するためにソースで発生することが予想される変換をコンパイラーに&lt;em&gt;通知&lt;/em&gt;する追加のフラグのセットがあります。</target>
        </trans-unit>
        <trans-unit id="bb370c8d075071406b52f5ac647fa7c9d121cf5a" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler supports the declaration of such mappings using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property in &lt;code&gt;tsconfig.json&lt;/code&gt; files.</source>
          <target state="translated">TypeScriptコンパイラは、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルの &lt;code&gt;&quot;paths&quot;&lt;/code&gt; プロパティを使用して、このようなマッピングの宣言をサポートしています。</target>
        </trans-unit>
        <trans-unit id="099c380e43d8e6d4992539e165d15f16ea81d572" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler supports the declaration of such mappings using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property in &lt;code&gt;tsconfig.json&lt;/code&gt; files. Here is an example for how to specify the &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property for &lt;code&gt;jquery&lt;/code&gt;.</source>
          <target state="translated">TypeScriptコンパイラは、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルの &lt;code&gt;&quot;paths&quot;&lt;/code&gt; プロパティを使用して、このようなマッピングの宣言をサポートしています。 &lt;code&gt;jquery&lt;/code&gt; の &lt;code&gt;&quot;paths&quot;&lt;/code&gt; プロパティを指定する方法の例を次に示します。</target>
        </trans-unit>
        <trans-unit id="bdf835f0a2221bc2f82e0e151055988a09c9c5cd" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler will inject design-time type information using the &lt;code&gt;@Reflect.metadata&lt;/code&gt; decorator. You could consider it the equivalent of the following TypeScript:</source>
          <target state="translated">TypeScriptコンパイラーは、 &lt;code&gt;@Reflect.metadata&lt;/code&gt; デコレーターを使用して設計時の型情報を挿入します。次のTypeScriptと同等と考えることができます。</target>
        </trans-unit>
        <trans-unit id="7a2537884fb59ac700d2d4b7e0b4045bf44ae0d3" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler will transpile for..of arrays to idiomatic ES3/ES5 JavaScript when targeting those versions:</source>
          <target state="translated">TypeScript コンパイラは、これらのバージョンをターゲットにした場合、配列の for...of 配列をイディオマティックな ES3/ES5 JavaScript にトランスパイルします。</target>
        </trans-unit>
        <trans-unit id="49b307cc503023513bc14bb0a27ac57aa8f44ce9" translate="yes" xml:space="preserve">
          <source>The TypeScript playground has received a much-needed refresh with handy new functionality! The new playground is largely a fork of &lt;a href=&quot;https://github.com/agentcooper&quot;&gt;Artem Tyurin&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;https://github.com/agentcooper/typescript-play&quot;&gt;TypeScript playground&lt;/a&gt; which community members have been using more and more. We owe Artem a big thanks for helping out here!</source>
          <target state="translated">TypeScriptプレイグラウンドは、便利な新機能を備えた待望の更新を受けました。新しい遊び場は、主に&lt;a href=&quot;https://github.com/agentcooper&quot;&gt;Artem Tyurin&lt;/a&gt;の&lt;a href=&quot;https://github.com/agentcooper/typescript-play&quot;&gt;TypeScript遊び場&lt;/a&gt;のフォークであり、コミュニティメンバーはますます使用しています。Artemはここで助けてくれて本当に感謝しています！</target>
        </trans-unit>
        <trans-unit id="2d3804fe18093dd09b93d92b9795e81df41c7624" translate="yes" xml:space="preserve">
          <source>The TypeSript compiler emits a few helpers like &lt;code&gt;__extends&lt;/code&gt; when needed. The helpers are emitted in every file they are referenced in. If you want to consolidate all helpers in one place, or override the default behavior, use &lt;code&gt;--noEmitHelpers&lt;/code&gt; to instructs the compiler not to emit them.</source>
          <target state="translated">TypeSriptコンパイラは、必要に応じて &lt;code&gt;__extends&lt;/code&gt; などのいくつかのヘルパーを発行します。ヘルパーは、参照されるすべてのファイルで出力されます。すべてのヘルパーを1か所に統合​​するか、デフォルトの動作をオーバーライドする場合は、 &lt;code&gt;--noEmitHelpers&lt;/code&gt; を使用して、コンパイラーに出力しないように指示します。</target>
        </trans-unit>
        <trans-unit id="bae3a8ac10b29ef5dcadb732d1773d84824f8b64" translate="yes" xml:space="preserve">
          <source>The above code will result in an error since you cannot divide a string by a number. The output, when using the &lt;code&gt;preserve&lt;/code&gt; option, looks like:</source>
          <target state="translated">上記のコードでは、文字列を数値で除算できないため、エラーが発生します。 &lt;code&gt;preserve&lt;/code&gt; オプションを使用すると、出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="973342201d3a8b874193050ad2e2e03771fa9182" translate="yes" xml:space="preserve">
          <source>The above workaround will work as long as you have a common property between &lt;code&gt;squareOptions&lt;/code&gt; and &lt;code&gt;SquareConfig&lt;/code&gt;. In this example, it was the property &lt;code&gt;width&lt;/code&gt;. It will however, fail if the variable does not have any common object property. For example:</source>
          <target state="translated">上記の回避策は、 &lt;code&gt;squareOptions&lt;/code&gt; と &lt;code&gt;SquareConfig&lt;/code&gt; の間に共通のプロパティがある限り機能します。この例では、プロパティの &lt;code&gt;width&lt;/code&gt; でした。ただし、変数に共通のオブジェクトプロパティがない場合は失敗します。例えば：</target>
        </trans-unit>
        <trans-unit id="977799dc5b2c7efb8ce07ce9dda596f71ce6d8c4" translate="yes" xml:space="preserve">
          <source>The act of introducing a new name in a more nested scope is called &lt;em&gt;shadowing&lt;/em&gt;. It is a bit of a double-edged sword in that it can introduce certain bugs on its own in the event of accidental shadowing, while also preventing certain bugs. For instance, imagine we had written our earlier &lt;code&gt;sumMatrix&lt;/code&gt; function using &lt;code&gt;let&lt;/code&gt; variables.</source>
          <target state="translated">よりネストされたスコープに新しい名前を導入することは、&lt;em&gt;シャドウイング&lt;/em&gt;と呼ばれます。偶発的なシャドウイングが発生した場合に特定のバグを単独で発生させ、特定のバグを防止できるという点で、両刃の剣のようです。たとえば、 &lt;code&gt;let&lt;/code&gt; 変数を使用して以前の &lt;code&gt;sumMatrix&lt;/code&gt; 関数を記述したとします。</target>
        </trans-unit>
        <trans-unit id="464744a1885e10900c594d16946298c68c765f22" translate="yes" xml:space="preserve">
          <source>The advantage of optional properties is that you can describe these possibly available properties while still also preventing use of properties that are not part of the interface. For example, had we mistyped the name of the &lt;code&gt;color&lt;/code&gt; property in &lt;code&gt;createSquare&lt;/code&gt;, we would get an error message letting us know:</source>
          <target state="translated">オプションのプロパティの利点は、これらの可能性のあるプロパティを記述できると同時に、インターフェイスの一部ではないプロパティの使用を防止できることです。たとえば、 &lt;code&gt;createSquare&lt;/code&gt; で &lt;code&gt;color&lt;/code&gt; プロパティの名前を誤って入力すると、次のエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="d900af77a95ccc3991b5cce004f6567adc959fc3" translate="yes" xml:space="preserve">
          <source>The alternative was to instead rewrite the code so that the language could analyze it, but this isn&amp;rsquo;t convenient.</source>
          <target state="translated">代わりに、言語がコードを分析できるようにコードを書き直すこともできましたが、これは便利ではありません。</target>
        </trans-unit>
        <trans-unit id="d7545e67ed0bf67fd6d8743f1b478c94a21cbf7b" translate="yes" xml:space="preserve">
          <source>The answer is to supply multiple function types for the same function as a list of overloads. This list is what the compiler will use to resolve function calls. Let&amp;rsquo;s create a list of overloads that describe what our &lt;code&gt;pickCard&lt;/code&gt; accepts and what it returns.</source>
          <target state="translated">答えは、オーバーロードのリストと同じ関数に複数の関数タイプを提供することです。このリストは、コンパイラが関数呼び出しを解決するために使用するものです。 &lt;code&gt;pickCard&lt;/code&gt; が受け入れるものと返すものを記述するオーバーロードのリストを作成してみましょう。</target>
        </trans-unit>
        <trans-unit id="d87ac95450f1e8dcfc394fcd59a9e3ae182cfb79" translate="yes" xml:space="preserve">
          <source>The argument can be a file path to a valid JSON configuration file, or a directory path to a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">引数には、有効なJSON構成ファイルへのファイルパス、または &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを含むディレクトリへのディレクトリパスを指定できます。</target>
        </trans-unit>
        <trans-unit id="8f45e116d7cf081dd6a210ca6310037f2aa66724" translate="yes" xml:space="preserve">
          <source>The as operator</source>
          <target state="translated">としての演算子</target>
        </trans-unit>
        <trans-unit id="9c9fa406955dab922d6a11f631e81ab8facc3e92" translate="yes" xml:space="preserve">
          <source>The basic rule for TypeScript&amp;rsquo;s structural type system is that &lt;code&gt;x&lt;/code&gt; is compatible with &lt;code&gt;y&lt;/code&gt; if &lt;code&gt;y&lt;/code&gt; has at least the same members as &lt;code&gt;x&lt;/code&gt;. For example:</source>
          <target state="translated">TypeScriptの構造型システムの基本的な規則は、 &lt;code&gt;y&lt;/code&gt; が少なくとも &lt;code&gt;x&lt;/code&gt; と同じメンバーを持っている場合、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;y&lt;/code&gt; と互換性があるということです。例えば：</target>
        </trans-unit>
        <trans-unit id="0570ba37489d38960ce7e63c3dda6e93bf075660" translate="yes" xml:space="preserve">
          <source>The caveat is that string-initialized enums can&amp;rsquo;t be reverse-mapped to get the original enum member name. In other words, you can&amp;rsquo;t write &lt;code&gt;Colors[&quot;RED&quot;]&lt;/code&gt; to get the string &lt;code&gt;&quot;Red&quot;&lt;/code&gt;.</source>
          <target state="translated">注意点は、文字列で初期化された列挙型を逆マッピングして、元の列挙型メンバー名を取得することはできないということです。つまり、 &lt;code&gt;Colors[&quot;RED&quot;]&lt;/code&gt; を記述して文字列 &lt;code&gt;&quot;Red&quot;&lt;/code&gt; を取得することはできません。</target>
        </trans-unit>
        <trans-unit id="658cc1f5d6e87940c9b68d75f7a3216b7965fa8f" translate="yes" xml:space="preserve">
          <source>The character set of the input files.</source>
          <target state="translated">入力ファイルの文字セット。</target>
        </trans-unit>
        <trans-unit id="0d767851eecc9dbc5567854c546874153b473aac" translate="yes" xml:space="preserve">
          <source>The classification can be further customized by changing the font and color settings for the &lt;code&gt;VB XML&lt;/code&gt; color and font settings through &lt;code&gt;Tools&lt;/code&gt;-&amp;gt;&lt;code&gt;Options&lt;/code&gt;-&amp;gt;&lt;code&gt;Environment&lt;/code&gt;-&amp;gt;&lt;code&gt;Fonts and Colors&lt;/code&gt; page.</source>
          <target state="translated">&lt;code&gt;VB XML&lt;/code&gt; の色とフォント設定のフォントと色の設定を[ &lt;code&gt;Tools&lt;/code&gt; -&amp;gt; [ &lt;code&gt;Options&lt;/code&gt; -&amp;gt; [ &lt;code&gt;Environment&lt;/code&gt; -&amp;gt; [ &lt;code&gt;Fonts and Colors&lt;/code&gt; ページで変更することにより、分類をさらにカスタマイズできます。</target>
        </trans-unit>
        <trans-unit id="9e4361985e949137fdbecccf199cbcbfd26cb095" translate="yes" xml:space="preserve">
          <source>The code sample starts with the two classes that will act as our mixins. You can see each one is focused on a particular activity or capability. We&amp;rsquo;ll later mix these together to form a new class from both capabilities.</source>
          <target state="translated">コードサンプルは、ミックスインとして機能する2つのクラスから始まります。それぞれが特定のアクティビティまたは機能に焦点を当てていることがわかります。これらを後で混合して、両方の機能から新しいクラスを形成します。</target>
        </trans-unit>
        <trans-unit id="44bfd585b7b25dece832164d759523816acacef3" translate="yes" xml:space="preserve">
          <source>The comment pragma version may be used like so (in TypeScript 2.8):</source>
          <target state="translated">コメントプラグマのバージョンは、このように使うことができます (TypeScript 2.8では)。</target>
        </trans-unit>
        <trans-unit id="94d8762ed85cb39d474ef4b32596ce47c7f9f61a" translate="yes" xml:space="preserve">
          <source>The compiler can usually figure out the type of &lt;code&gt;this&lt;/code&gt; when it has some context to work with. When it doesn&amp;rsquo;t, you can explicitly specify the type of &lt;code&gt;this&lt;/code&gt; with &lt;code&gt;@this&lt;/code&gt;:</source>
          <target state="translated">コンパイラーは通常、処理するコンテキストがある場合、 &lt;code&gt;this&lt;/code&gt; タイプを判別できます。そうでない場合は、 &lt;code&gt;this&lt;/code&gt; のタイプを &lt;code&gt;@this&lt;/code&gt; で明示的に指定できます。</target>
        </trans-unit>
        <trans-unit id="6ce225c2cdfc4fbbd52bf1bec496704ad8d2e300" translate="yes" xml:space="preserve">
          <source>The compiler checks that &lt;code&gt;manufacturer&lt;/code&gt; and &lt;code&gt;model&lt;/code&gt; are actually properties on &lt;code&gt;Car&lt;/code&gt;. The example introduces a couple of new type operators. First is &lt;code&gt;keyof T&lt;/code&gt;, the &lt;strong&gt;index type query operator&lt;/strong&gt;. For any type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;keyof T&lt;/code&gt; is the union of known, public property names of &lt;code&gt;T&lt;/code&gt;. For example:</source>
          <target state="translated">コンパイラは、 &lt;code&gt;manufacturer&lt;/code&gt; と &lt;code&gt;model&lt;/code&gt; が実際に &lt;code&gt;Car&lt;/code&gt; のプロパティであることを確認します。この例では、いくつかの新しい型演算子を紹介しています。最初は、&lt;strong&gt;インデックスタイプのクエリ演算子&lt;/strong&gt;である &lt;code&gt;keyof T&lt;/code&gt; です。いずれのタイプの場合は &lt;code&gt;T&lt;/code&gt; 、 &lt;code&gt;keyof T&lt;/code&gt; は、既知の、パブリックプロパティ名の労働組合である &lt;code&gt;T&lt;/code&gt; 。例えば：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b90080efac3089f68bf9198051529fb93927ad2d" translate="yes" xml:space="preserve">
          <source>The compiler checks that variables are definitely assigned by performing &lt;em&gt;control flow based type analysis&lt;/em&gt;. See later for further details on this topic.</source>
          <target state="translated">コンパイラーは、&lt;em&gt;制御フローベースの型分析を&lt;/em&gt;実行することにより、変数が確実に割り当てられていることを確認します。このトピックの詳細については、後で参照してください。</target>
        </trans-unit>
        <trans-unit id="709255e2bfcdfd8723f3b039260e513f6811cfd9" translate="yes" xml:space="preserve">
          <source>The compiler detects whether each module is used in the emitted JavaScript. If a module identifier is only ever used as part of a type annotations and never as an expression, then no &lt;code&gt;require&lt;/code&gt; call is emitted for that module. This elision of unused references is a good performance optimization, and also allows for optional loading of those modules.</source>
          <target state="translated">コンパイラは、発行されたJavaScriptで各モジュールが使用されているかどうかを検出します。モジュール識別子が型注釈の一部としてのみ使用され、式として決して使用されない &lt;code&gt;require&lt;/code&gt; 、そのモジュールのrequire呼び出しは発行されません。この未使用の参照の省略は、優れたパフォーマンスの最適化であり、これらのモジュールのオプションのロードも可能にします。</target>
        </trans-unit>
        <trans-unit id="2ee05054ac8f1f0d957bb3db6c7d04411ad1e817" translate="yes" xml:space="preserve">
          <source>The compiler infers constructor functions based on this-property assignments, but you can make checking stricter and suggestions better if you add a &lt;code&gt;@constructor&lt;/code&gt; tag:</source>
          <target state="translated">コンパイラーは、このプロパティの割り当てに基づいてコンストラクター関数を推測しますが、 &lt;code&gt;@constructor&lt;/code&gt; タグを追加すると、チェックをより厳密にして提案をより良くすることができます。</target>
        </trans-unit>
        <trans-unit id="af8cada3d73e6f631af13e152a9d5e9310d04109" translate="yes" xml:space="preserve">
          <source>The compiler performs a preprocessing pass on input files to resolve all triple-slash reference directives. During this process, additional files are added to the compilation.</source>
          <target state="translated">コンパイラは入力ファイルの前処理パスを実行して、すべてのトリプルスラッシュ参照ディレクティブを解決します。この処理の間に、追加のファイルがコンパイルに追加されます。</target>
        </trans-unit>
        <trans-unit id="e0152e415fb0baecefa82a34c08f802b9d756e5b" translate="yes" xml:space="preserve">
          <source>The compiler will automatically order the output file based on the reference tags present in the files. You can also specify each file individually:</source>
          <target state="translated">コンパイラは、ファイル内に存在する参照タグに基づいて出力ファイルを自動的に並べ替えます。また、各ファイルを個別に指定することもできます。</target>
        </trans-unit>
        <trans-unit id="51e223694a5a5e5b0c431a15c4a8fae647f211ab" translate="yes" xml:space="preserve">
          <source>The compiler will generate a simple &lt;code&gt;for&lt;/code&gt; loop for a &lt;code&gt;for..of&lt;/code&gt; loop, for instance:</source>
          <target state="translated">コンパイラーは、たとえば、 &lt;code&gt;for..of&lt;/code&gt; ループの単純な &lt;code&gt;for&lt;/code&gt; ループを生成します。</target>
        </trans-unit>
        <trans-unit id="6a0d000ecdfc1359aa72dab512a544de23b44f6d" translate="yes" xml:space="preserve">
          <source>The compiler will now resolve &lt;code&gt;import messages from './#{locale}/messages'&lt;/code&gt; to &lt;code&gt;import messages from './zh/messages'&lt;/code&gt; for tooling purposes, allowing development in a locale agnostic manner without compromising design time support.</source>
          <target state="translated">コンパイラーは、ツール目的で &lt;code&gt;import messages from './#{locale}/messages'&lt;/code&gt; 解決して './zh/messages'から &lt;code&gt;import messages from './zh/messages'&lt;/code&gt; をインポートし、設計時サポートを損なうことなくロケールにとらわれない方法で開発できるようにします。</target>
        </trans-unit>
        <trans-unit id="dededb8a14ae234f8b00237dd4d7d5520b09190d" translate="yes" xml:space="preserve">
          <source>The compiler will try to find a &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and then a &lt;code&gt;.d.ts&lt;/code&gt; with the appropriate path. If a specific file could not be found, then the compiler will look for an &lt;em&gt;ambient module declaration&lt;/em&gt;. Recall that these need to be declared in a &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="translated">コンパイラは見つけようとします &lt;code&gt;.ts&lt;/code&gt; 、 &lt;code&gt;.tsx&lt;/code&gt; 、その後、 &lt;code&gt;.d.ts&lt;/code&gt; の適切なパスを指定しています。特定のファイルが見つからなかった場合、コンパイラは&lt;em&gt;アンビエントモジュール宣言&lt;/em&gt;を探し&lt;em&gt;ます&lt;/em&gt;。これらは &lt;code&gt;.d.ts&lt;/code&gt; ファイルで宣言する必要があることを思い出してください。</target>
        </trans-unit>
        <trans-unit id="0ba06dc9850414ee8093ec4891b1423ed7c4b5a5" translate="yes" xml:space="preserve">
          <source>The configuration from the base file are loaded first, then overridden by those in the inheriting config file.</source>
          <target state="translated">ベースファイルの設定が最初に読み込まれ、次に継承する設定ファイルの設定が上書きされます。</target>
        </trans-unit>
        <trans-unit id="c7417a4c25a8da7c3b9339e33fd087465dbdf022" translate="yes" xml:space="preserve">
          <source>The configuration from the base file are loaded first, then overridden by those in the inheriting config file. If a circularity is encountered, we report an error.</source>
          <target state="translated">ベースファイルの設定が最初に読み込まれ、次に継承する設定ファイルの設定が上書きされます。サーキュラリティが発生した場合はエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="47cd6d852a954030c68d9ed9204072b9f5e61ecf" translate="yes" xml:space="preserve">
          <source>The constructor of a mixin class (if any) must have a single rest parameter of type &lt;code&gt;any[]&lt;/code&gt; and must use the spread operator to pass those parameters as arguments in a &lt;code&gt;super(...args)&lt;/code&gt; call.</source>
          <target state="translated">ミックスインクラスのコンストラクタ（存在する場合）には、タイプ &lt;code&gt;any[]&lt;/code&gt; 単一のレストパラメータが必要であり、spread &lt;code&gt;super(...args)&lt;/code&gt; 呼び出しの引数としてこれらのパラメータを渡すには、スプレッド演算子を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="c957312c57684bb0a68bd0033e5121474de252b4" translate="yes" xml:space="preserve">
          <source>The core idea of the pattern is that the &lt;code&gt;import id = require(&quot;...&quot;)&lt;/code&gt; statement gives us access to the types exposed by the module. The module loader is invoked (through &lt;code&gt;require&lt;/code&gt;) dynamically, as shown in the &lt;code&gt;if&lt;/code&gt; blocks below. This leverages the reference-elision optimization so that the module is only loaded when needed. For this pattern to work, it&amp;rsquo;s important that the symbol defined via an &lt;code&gt;import&lt;/code&gt; is only used in type positions (i.e. never in a position that would be emitted into the JavaScript).</source>
          <target state="translated">パターンの核となる考え方は、 &lt;code&gt;import id = require(&quot;...&quot;)&lt;/code&gt; ステートメントにより、モジュールによって公開される型へのアクセスが提供されるということです。以下の &lt;code&gt;if&lt;/code&gt; ブロックに示すように、モジュールローダーは（ &lt;code&gt;require&lt;/code&gt; を介して）動的に呼び出されます。これは、参照省略最適化を利用して、モジュールが必要なときにのみロードされるようにします。このパターンが機能するためには、 &lt;code&gt;import&lt;/code&gt; を介して定義されたシンボルがタイプの位置でのみ使用されることが重要です（つまり、JavaScriptに放出される位置では決して使用されません）。</target>
        </trans-unit>
        <trans-unit id="d0b027c450a1f923c0be026c0dfd8a83c77d2420" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;code&gt;tsconfig.json&lt;/code&gt; would look like:</source>
          <target state="translated">対応する &lt;code&gt;tsconfig.json&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="7eeeab936d5101dbe33556330a8a2f0e148d5a0c" translate="yes" xml:space="preserve">
          <source>The declaration merge of &lt;code&gt;Animals&lt;/code&gt; in this example:</source>
          <target state="translated">この例の &lt;code&gt;Animals&lt;/code&gt; の宣言のマージ：</target>
        </trans-unit>
        <trans-unit id="760e4e7cc5e42234f3bffea21b8ceac9a6ae4124" translate="yes" xml:space="preserve">
          <source>The default behavior for the TypeScript compiler is to still emit .js files if there were type errors (for example, an attempt to assign a &lt;code&gt;string&lt;/code&gt; to a &lt;code&gt;number&lt;/code&gt;). This can be undesirable on build servers or other scenarios where only output from a &amp;ldquo;clean&amp;rdquo; build is desired. The new flag &lt;code&gt;noEmitOnError&lt;/code&gt; prevents the compiler from emitting .js code if there were any errors.</source>
          <target state="translated">TypeScriptコンパイラのデフォルトの動作では、タイプエラー（たとえば、 &lt;code&gt;string&lt;/code&gt; を &lt;code&gt;number&lt;/code&gt; に割り当てようとしたなど）があった場合でも.jsファイルが出力されます。これは、ビルドサーバーまたは「クリーン」ビルドからの出力のみが必要なその他のシナリオでは望ましくない場合があります。新しいフラグ &lt;code&gt;noEmitOnError&lt;/code&gt; は、エラーが発生した場合にコンパイラーが.jsコードを発行しないようにします。</target>
        </trans-unit>
        <trans-unit id="ae976d467a2e0b5f5be1f916e987a9fd2c7d4327" translate="yes" xml:space="preserve">
          <source>The default-ed properties are inferred from the &lt;code&gt;defaultProps&lt;/code&gt; property type. If an explicit type annotation is added, e.g. &lt;code&gt;static defaultProps: Partial&amp;lt;Props&amp;gt;;&lt;/code&gt; the compiler will not be able to identify which properties have defaults (since the type of &lt;code&gt;defaultProps&lt;/code&gt; include all properties of &lt;code&gt;Props&lt;/code&gt;).</source>
          <target state="translated">default-edプロパティは、 &lt;code&gt;defaultProps&lt;/code&gt; プロパティタイプから推測されます。明示的な型注釈が追加された場合、たとえば &lt;code&gt;static defaultProps: Partial&amp;lt;Props&amp;gt;;&lt;/code&gt; コンパイラーは、デフォルトを持つプロパティを識別できません（ &lt;code&gt;defaultProps&lt;/code&gt; のタイプには &lt;code&gt;Props&lt;/code&gt; のすべてのプロパティが含まれるため）。</target>
        </trans-unit>
        <trans-unit id="d1317688dfc3d42fd33a72fadf087e54e0802397" translate="yes" xml:space="preserve">
          <source>The definite assignment assertion is a feature that allows a &lt;code&gt;!&lt;/code&gt; to be placed after instance property and variable declarations to relay to TypeScript that a variable is indeed assigned for all intents and purposes, even if TypeScript&amp;rsquo;s analyses cannot detect so.</source>
          <target state="translated">明確な割り当てアサーションは、 &lt;code&gt;!&lt;/code&gt; TypeScriptの分析で検出できない場合でも、変数が実際にすべての意図と目的に割り当てられていることをTypeScriptにリレーするために、インスタンスプロパティと変数の宣言の後に配置します。</target>
        </trans-unit>
        <trans-unit id="5951769f90ddf6ef86202b76f38e00c40c68074c" translate="yes" xml:space="preserve">
          <source>The distributive property of conditional types can conveniently be used to &lt;em&gt;filter&lt;/em&gt; union types:</source>
          <target state="translated">条件付きタイプの分布プロパティは、共用体タイプを&lt;em&gt;フィルタリング&lt;/em&gt;するために便利に使用できます。</target>
        </trans-unit>
        <trans-unit id="6701107cdd8245fa22b60649bbf93c094765f72c" translate="yes" xml:space="preserve">
          <source>The dual of this is &lt;em&gt;indexed access types&lt;/em&gt;, also called &lt;em&gt;lookup types&lt;/em&gt;. Syntactically, they look exactly like an element access, but are written as types:</source>
          <target state="translated">この2つは、&lt;em&gt;インデックス付きアクセスタイプ&lt;/em&gt;であり、&lt;em&gt;ルックアップタイプ&lt;/em&gt;とも呼ばれ&lt;em&gt;ます&lt;/em&gt;。構文的には、要素へのアクセスとまったく同じように見えますが、型として記述されています。</target>
        </trans-unit>
        <trans-unit id="f96a7965741a28dd3d210266390299a4c235d519" translate="yes" xml:space="preserve">
          <source>The easiest way to remember whether to use &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; is to ask whether you&amp;rsquo;re using it on a variable or a property. Variables use &lt;code&gt;const&lt;/code&gt; whereas properties use &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; と &lt;code&gt;const&lt;/code&gt; のどちらを使用するかを覚える最も簡単な方法は、変数またはプロパティのどちらで使用するかを尋ねることです。変数は &lt;code&gt;const&lt;/code&gt; を使用し、プロパティは &lt;code&gt;readonly&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="77d40241cfaf8a84ae6745611b0a0b930c4e9b68" translate="yes" xml:space="preserve">
          <source>The easiest way to see how interfaces work is to start with a simple example:</source>
          <target state="translated">インターフェイスがどのように動作するかを理解する最も簡単な方法は、簡単な例から始めることです。</target>
        </trans-unit>
        <trans-unit id="36fb664df37642968e73b47232d19c28eafce856" translate="yes" xml:space="preserve">
          <source>The element attribute type is used to type check the attributes in the JSX. Optional and required properties are supported.</source>
          <target state="translated">要素属性型は、JSXの属性をタイプチェックするために使用されます。オプションのプロパティと必須のプロパティがサポートされています。</target>
        </trans-unit>
        <trans-unit id="f2cb300f34919973f86bda71fcf4a1681bebb7a8" translate="yes" xml:space="preserve">
          <source>The element instance type is interesting because it must be assignable to &lt;code&gt;JSX.ElementClass&lt;/code&gt; or it will result in an error. By default &lt;code&gt;JSX.ElementClass&lt;/code&gt; is &lt;code&gt;{}&lt;/code&gt;, but it can be augmented to limit the use of JSX to only those types that conform to the proper interface.</source>
          <target state="translated">要素インスタンスタイプは、 &lt;code&gt;JSX.ElementClass&lt;/code&gt; に割り当て可能でなければならないため、興味深いものになります。そうしないと、エラーが発生します。デフォルトでは、 &lt;code&gt;JSX.ElementClass&lt;/code&gt; は &lt;code&gt;{}&lt;/code&gt; ですが、JSXの使用を適切なインターフェースに準拠するタイプのみに制限するように拡張できます。</target>
        </trans-unit>
        <trans-unit id="0d4e3187b0c64f392d45e58c9337389c5cb0b1e1" translate="yes" xml:space="preserve">
          <source>The ellipsis is also used in the type of the function with rest parameters:</source>
          <target state="translated">楕円は、残りのパラメータを持つ関数の型でも使用されています。</target>
        </trans-unit>
        <trans-unit id="d715b5fd0797da50802172129520b9973d9f2c77" translate="yes" xml:space="preserve">
          <source>The enum member is initialized with a constant enum expression. A constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time. An expression is a constant enum expression if it is:</source>
          <target state="translated">enum メンバは定数 enum 式で初期化されます。constant enum式は、コンパイル時に完全に評価できるTypeScript式のサブセットです。式は、以下の場合には定数enum式となります。</target>
        </trans-unit>
        <trans-unit id="d313bf4ae6661330b1b3ab28e64f56b35e82367c" translate="yes" xml:space="preserve">
          <source>The exact factory function used by the &lt;code&gt;jsx: react&lt;/code&gt; compiler option is configurable. It may be set using either the &lt;code&gt;jsxFactory&lt;/code&gt; command line option, or an inline &lt;code&gt;@jsx&lt;/code&gt; comment pragma to set it on a per-file basis. For example, if you set &lt;code&gt;jsxFactory&lt;/code&gt; to &lt;code&gt;createElement&lt;/code&gt;, &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; will emit as &lt;code&gt;createElement(&quot;div&quot;)&lt;/code&gt; instead of &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;jsx: react&lt;/code&gt; コンパイラー・オプションで使用される正確なファクトリー関数は構成可能です。 &lt;code&gt;jsxFactory&lt;/code&gt; コマンドラインオプションを使用して設定するか、インラインの &lt;code&gt;@jsx&lt;/code&gt; コメントプラグマを使用してファイルごとに設定できます。あなたが設定されている場合たとえば、 &lt;code&gt;jsxFactory&lt;/code&gt; をする &lt;code&gt;createElement&lt;/code&gt; 、 &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; として放出する &lt;code&gt;createElement(&quot;div&quot;)&lt;/code&gt; の代わりに、 &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be983dcb009cbaef6ee420c2ca6026b157bd7e0a" translate="yes" xml:space="preserve">
          <source>The example also shows how to override methods in the base class with methods that are specialized for the subclass. Here both &lt;code&gt;Snake&lt;/code&gt; and &lt;code&gt;Horse&lt;/code&gt; create a &lt;code&gt;move&lt;/code&gt; method that overrides the &lt;code&gt;move&lt;/code&gt; from &lt;code&gt;Animal&lt;/code&gt;, giving it functionality specific to each class. Note that even though &lt;code&gt;tom&lt;/code&gt; is declared as an &lt;code&gt;Animal&lt;/code&gt;, since its value is a &lt;code&gt;Horse&lt;/code&gt;, calling &lt;code&gt;tom.move(34)&lt;/code&gt; will call the overriding method in &lt;code&gt;Horse&lt;/code&gt;:</source>
          <target state="translated">この例では、基本クラスのメソッドを、サブクラスに特化したメソッドでオーバーライドする方法も示しています。ここでは &lt;code&gt;Snake&lt;/code&gt; と &lt;code&gt;Horse&lt;/code&gt; の両方 &lt;code&gt;move&lt;/code&gt; 、 &lt;code&gt;Animal&lt;/code&gt; からの移動をオーバーライドする &lt;code&gt;move&lt;/code&gt; メソッドを作成し、各クラスに固有の機能を提供しています。にもかかわらず注意 &lt;code&gt;tom&lt;/code&gt; として宣言されている &lt;code&gt;Animal&lt;/code&gt; 、その値があるので、 &lt;code&gt;Horse&lt;/code&gt; 、呼び出し &lt;code&gt;tom.move(34)&lt;/code&gt; にオーバーライドメソッドを呼び出します &lt;code&gt;Horse&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9309c4e757aa256b16a0bad58b5e33a98c76cbc2" translate="yes" xml:space="preserve">
          <source>The example uses a nested function here because the compiler can&amp;rsquo;t eliminate nulls inside a nested function (except immediately-invoked function expressions). That&amp;rsquo;s because it can&amp;rsquo;t track all calls to the nested function, especially if you return it from the outer function. Without knowing where the function is called, it can&amp;rsquo;t know what the type of &lt;code&gt;name&lt;/code&gt; will be at the time the body executes.</source>
          <target state="translated">コンパイラはネストされた関数内のnullを削除できないため、ここではネストされた関数を使用しています（即時に呼び出される関数式を除く）。それは、特に外側の関数からそれを返す場合、ネストされた関数へのすべての呼び出しを追跡できないためです。関数が呼び出される場所がわからなければ、本体が実行されるときに &lt;code&gt;name&lt;/code&gt; のタイプがどうなるかを知ることはできません。</target>
        </trans-unit>
        <trans-unit id="2521d541b8280fcd0c447ab0918ebaaed9adf402" translate="yes" xml:space="preserve">
          <source>The expression for the accessor decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">アクセサデコレータの式は、実行時に関数として呼び出され、以下の3つの引数を持ちます。</target>
        </trans-unit>
        <trans-unit id="0b14168e95c9d9a01df3680215e98fc982e341d6" translate="yes" xml:space="preserve">
          <source>The expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument.</source>
          <target state="translated">クラスデコレータの式は、実行時に関数として呼び出され、デコレーションされたクラスのコンストラクタが唯一の引数となります。</target>
        </trans-unit>
        <trans-unit id="0d60ee880be94f69fdd4585e45c1d4d2352936ea" translate="yes" xml:space="preserve">
          <source>The expression for the method decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">メソッドデコレータの式は、実行時に関数として呼び出され、以下の3つの引数を持ちます。</target>
        </trans-unit>
        <trans-unit id="5086d420edcd773ac6d732072618188585203199" translate="yes" xml:space="preserve">
          <source>The expression for the parameter decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">パラメータデコレータの式は、実行時に関数として呼び出され、以下の3つの引数を持ちます。</target>
        </trans-unit>
        <trans-unit id="edae3f3dc86e86b9a64d098ac85c40b60e98ad47" translate="yes" xml:space="preserve">
          <source>The expression for the property decorator will be called as a function at runtime, with the following two arguments:</source>
          <target state="translated">プロパティデコレータの式は、実行時に関数として呼び出され、以下の2つの引数を持ちます。</target>
        </trans-unit>
        <trans-unit id="3e0ed5b6c650314a8da3d7c5c7c625309c2ba4c4" translate="yes" xml:space="preserve">
          <source>The expressions for each decorator are evaluated top-to-bottom.</source>
          <target state="translated">各デコレータの式は上から下に評価されます。</target>
        </trans-unit>
        <trans-unit id="60727c2e253818c6e1394797bce9983cbcfb14d2" translate="yes" xml:space="preserve">
          <source>The factory chosen will also affect where the &lt;code&gt;JSX&lt;/code&gt; namespace is looked up (for type checking information) before falling back to the global one. If the factory is defined as &lt;code&gt;React.createElement&lt;/code&gt; (the default), the compiler will check for &lt;code&gt;React.JSX&lt;/code&gt; before checking for a global &lt;code&gt;JSX&lt;/code&gt;. If the factory is defined as &lt;code&gt;h&lt;/code&gt;, it will check for &lt;code&gt;h.JSX&lt;/code&gt; before a global &lt;code&gt;JSX&lt;/code&gt;.</source>
          <target state="translated">選択されたファクトリは、グローバルタイプにフォールバックする前に &lt;code&gt;JSX&lt;/code&gt; 名前空間が（タイプチェック情報のために）検索される場所にも影響します。ファクトリーが &lt;code&gt;React.createElement&lt;/code&gt; （デフォルト）として定義されている場合、コンパイラーはグローバル &lt;code&gt;JSX&lt;/code&gt; をチェックする前に &lt;code&gt;React.JSX&lt;/code&gt; をチェックします。ファクトリが &lt;code&gt;h&lt;/code&gt; として定義されている場合、ファクトリはグローバル &lt;code&gt;JSX&lt;/code&gt; の前に &lt;code&gt;h.JSX&lt;/code&gt; をチェックします。</target>
        </trans-unit>
        <trans-unit id="d8cbf6331553242a5f0e701d007b43692f6b7d55" translate="yes" xml:space="preserve">
          <source>The first assignment is now an error. Effectively, &lt;code&gt;T&lt;/code&gt; is contravariant in &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; because it is used only in function type parameter positions.</source>
          <target state="translated">最初の割り当てはエラーになりました。事実上、 &lt;code&gt;T&lt;/code&gt; は関数型パラメーターの位置でのみ使用されるため、 &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; では反変です。</target>
        </trans-unit>
        <trans-unit id="f83cf7bff16c656834b3e301df968baf4cd1ffca" translate="yes" xml:space="preserve">
          <source>The first assignment is permitted in default type checking mode, but flagged as an error in strict function types mode. Intuitively, the default mode permits the assignment because it is &lt;em&gt;possibly&lt;/em&gt; sound, whereas strict function types mode makes it an error because it isn&amp;rsquo;t &lt;em&gt;provably&lt;/em&gt; sound. In either mode the third assignment is an error because it is &lt;em&gt;never&lt;/em&gt; sound.</source>
          <target state="translated">最初の割り当てはデフォルトの型チェックモードで許可されていますが、厳密な関数型モードではエラーとしてフラグが立てられます。直感的には、デフォルトのモードではサウンドが割り当てられる&lt;em&gt;可能性&lt;/em&gt;が&lt;em&gt;ある&lt;/em&gt;ため、割り当てが許可されますが、厳密な関数タイプのモードでは、サウンドが&lt;em&gt;確実&lt;/em&gt;ではないためエラーが発生します。どちらのモードでも、3番目の割り当ては&lt;em&gt;決して&lt;/em&gt;健全では&lt;em&gt;ない&lt;/em&gt;ため、エラーになります。</target>
        </trans-unit>
        <trans-unit id="86d2c2eef081b9efd8e081cbfc7a2eb73c95a9bf" translate="yes" xml:space="preserve">
          <source>The first is that enum members also become types as well! For example, we can say that certain members can &lt;em&gt;only&lt;/em&gt; have the value of an enum member:</source>
          <target state="translated">1つ目は、列挙型メンバーも型になることです。たとえば、特定のメンバーは列挙型メンバーの値&lt;em&gt;しか&lt;/em&gt;持つことができ&lt;em&gt;ない&lt;/em&gt;と言えます。</target>
        </trans-unit>
        <trans-unit id="11b6104cea3d7fbf08969b5f72b6d05a84f6d569" translate="yes" xml:space="preserve">
          <source>The first line tells Visual Studio to run the task &amp;lsquo;default&amp;rsquo; after the build finishes. It will also run the &amp;lsquo;clean&amp;rsquo; task when you ask Visual Studio to clean the build.</source>
          <target state="translated">1行目は、ビルドの完了後にタスクを「デフォルト」で実行するようにVisual Studioに指示しています。また、Visual Studioにビルドのクリーンアップを要求すると、「クリーン」タスクも実行されます。</target>
        </trans-unit>
        <trans-unit id="f589b53519dab849472b770ba61a662532e94279" translate="yes" xml:space="preserve">
          <source>The first step to type checking attributes is to determine the &lt;em&gt;element attributes type&lt;/em&gt;. This is slightly different between intrinsic and value-based elements.</source>
          <target state="translated">タイプチェック属性の最初のステップは、&lt;em&gt;要素の属性タイプ&lt;/em&gt;を決定すること&lt;em&gt;です&lt;/em&gt;。これは、組み込み要素と値ベースの要素の間でわずかに異なります。</target>
        </trans-unit>
        <trans-unit id="58af75a63079336d3af143e1407bc44a6c44b6ef" translate="yes" xml:space="preserve">
          <source>The first thing you may notice in the above is that instead of trying to extend &lt;code&gt;Disposable&lt;/code&gt; and &lt;code&gt;Activatable&lt;/code&gt; in &lt;code&gt;SmartObject&lt;/code&gt; class, we extend them in &lt;code&gt;SmartObject&lt;/code&gt; interface. &lt;code&gt;SmartObject&lt;/code&gt; interface will be mixed into the &lt;code&gt;SmartObject&lt;/code&gt; class due to the &lt;a href=&quot;declaration-merging&quot;&gt;declaration merging&lt;/a&gt;.</source>
          <target state="translated">あなたは上記に気づくことが最初のものではなく、拡張しようとするということである &lt;code&gt;Disposable&lt;/code&gt; と &lt;code&gt;Activatable&lt;/code&gt; して &lt;code&gt;SmartObject&lt;/code&gt; のクラス、私たちはそれらを延長 &lt;code&gt;SmartObject&lt;/code&gt; のインターフェース。 &lt;code&gt;SmartObject&lt;/code&gt; インターフェイスは、&lt;a href=&quot;declaration-merging&quot;&gt;宣言のマージ&lt;/a&gt;により、 &lt;code&gt;SmartObject&lt;/code&gt; クラスに混在します。</target>
        </trans-unit>
        <trans-unit id="1598a89fa953ba70cfbbf99c377df16fd8ed251e" translate="yes" xml:space="preserve">
          <source>The first type of assertion signature models the way that Node&amp;rsquo;s &lt;code&gt;assert&lt;/code&gt; function works. It ensures that whatever condition is being checked must be true for the remainder of the containing scope.</source>
          <target state="translated">最初のタイプのアサーションシグネチャは、Nodeの &lt;code&gt;assert&lt;/code&gt; 機能の動作方法をモデル化しています。これにより、チェックされるすべての条件が、包含スコープの残りの部分でtrueになる必要があります。</target>
        </trans-unit>
        <trans-unit id="e7ac3fa8432f39d89d10777015cb56ae8fd93747" translate="yes" xml:space="preserve">
          <source>The flexibility of &lt;code&gt;rootDirs&lt;/code&gt; is not limited to specifying a list of physical source directories that are logically merged. The supplied array may include any number of ad hoc, arbitrary directory names, regardless of whether they exist or not. This allows the compiler to capture sophisticated bundling and runtime features such as conditional inclusion and project specific loader plugins in a type safe way.</source>
          <target state="translated">&lt;code&gt;rootDirs&lt;/code&gt; の柔軟性は、論理的にマージされる物理ソースディレクトリのリストを指定することに限定されません。提供される配列には、それらが存在するかどうかに関係なく、アドホックな任意のディレクトリ名をいくつでも含めることができます。これにより、コンパイラーは、条件付き組み込みやプロジェクト固有のローダープラグインなどの高度なバンドリングおよびランタイム機能をタイプセーフな方法でキャプチャできます。</target>
        </trans-unit>
        <trans-unit id="6ba8cf088bc4a62237fb1f09825df1931ceb84e4" translate="yes" xml:space="preserve">
          <source>The following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:</source>
          <target state="translated">以下の例は、共変数の位置にある同じ型変数の複数の候補が、どのようにして組合型を推論するかを示しています。</target>
        </trans-unit>
        <trans-unit id="aa5d6454fbf6bf730c8b327164f77ed6f69baf2e" translate="yes" xml:space="preserve">
          <source>The following is an example of a class decorator (&lt;code&gt;@sealed&lt;/code&gt;) applied to the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">以下は、 &lt;code&gt;Greeter&lt;/code&gt; クラスに適用されたクラスデコレータ（ &lt;code&gt;@sealed&lt;/code&gt; ）の例です。</target>
        </trans-unit>
        <trans-unit id="894306209d899f3f7794eaec540a57c394ffa6ed" translate="yes" xml:space="preserve">
          <source>The following is an example of a method decorator (&lt;code&gt;@enumerable&lt;/code&gt;) applied to a method on the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">以下は、 &lt;code&gt;Greeter&lt;/code&gt; クラスのメソッドに適用されるメソッドデコレータ（ &lt;code&gt;@enumerable&lt;/code&gt; ）の例です。</target>
        </trans-unit>
        <trans-unit id="56eb8bb77b4d8ce3acb0c50224bfb3b899067f94" translate="yes" xml:space="preserve">
          <source>The following is an example of a parameter decorator (&lt;code&gt;@required&lt;/code&gt;) applied to parameter of a member of the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">以下は、 &lt;code&gt;Greeter&lt;/code&gt; クラスのメンバーのパラメーターに適用されるパラメーターデコレーター（ &lt;code&gt;@required&lt;/code&gt; ）の例です。</target>
        </trans-unit>
        <trans-unit id="4c9599f42a20eb3b17874db9fbac592989bd9e8c" translate="yes" xml:space="preserve">
          <source>The following is an example of an accessor decorator (&lt;code&gt;@configurable&lt;/code&gt;) applied to a member of the &lt;code&gt;Point&lt;/code&gt; class:</source>
          <target state="translated">以下は、 &lt;code&gt;Point&lt;/code&gt; クラスのメンバーに適用されるアクセサーデコレーター（ &lt;code&gt;@configurable&lt;/code&gt; ）の例です。</target>
        </trans-unit>
        <trans-unit id="f1290f593b907ee11da2a865c78e736129d049be" translate="yes" xml:space="preserve">
          <source>The global variable &lt;code&gt;foo&lt;/code&gt; contains the number of widgets present.</source>
          <target state="translated">グローバル変数 &lt;code&gt;foo&lt;/code&gt; には、存在するウィジェットの数が含まれています。</target>
        </trans-unit>
        <trans-unit id="5cf5ea298d71b31d168d1d4cfd5dd7bf5304c883" translate="yes" xml:space="preserve">
          <source>The global variable &lt;code&gt;myLib&lt;/code&gt; has a function &lt;code&gt;makeGreeting&lt;/code&gt; for creating greetings, and a property &lt;code&gt;numberOfGreetings&lt;/code&gt; indicating the number of greetings made so far.</source>
          <target state="translated">グローバル変数 &lt;code&gt;myLib&lt;/code&gt; 関数がある &lt;code&gt;makeGreeting&lt;/code&gt; 挨拶を作成するために、プロパティ &lt;code&gt;numberOfGreetings&lt;/code&gt; 挨拶の数を示すが、これまでに作られました。</target>
        </trans-unit>
        <trans-unit id="fbf0d9abbae1382a841d6a20a7fd42f5f792dbfd" translate="yes" xml:space="preserve">
          <source>The guide is broken down into the following sections.</source>
          <target state="translated">ガイドは以下の項目に分かれています。</target>
        </trans-unit>
        <trans-unit id="152f8cc5510f46a1bacae33a53ef9b6ca874c1fb" translate="yes" xml:space="preserve">
          <source>The inference process is fairly straightforward here because &lt;code&gt;getDisplayName&lt;/code&gt; and &lt;code&gt;getLength&lt;/code&gt; use types that can easily be referenced. However, in TypeScript 3.3 and earlier, generic functions like &lt;code&gt;compose&lt;/code&gt; didn&amp;rsquo;t work so well when passed other generic functions.</source>
          <target state="translated">&lt;code&gt;getDisplayName&lt;/code&gt; と &lt;code&gt;getLength&lt;/code&gt; は簡単に参照できるタイプを使用するため、ここでは推論プロセスはかなり単純です。ただし、TypeScript 3.3以前では、 &lt;code&gt;compose&lt;/code&gt; などのジェネリック関数は、他のジェネリック関数を渡されたときにあまり機能しませんでした。</target>
        </trans-unit>
        <trans-unit id="2bd1d13df309ad7c445be96538c356e69d82dd45" translate="yes" xml:space="preserve">
          <source>The inferred return type of a function may be a type declared locally within the function. It is not possible for callers of the function to reference such a local type, but it can of course be matched structurally. For example:</source>
          <target state="translated">関数の推測される戻り値の型は、関数内でローカルに宣言された型である可能性があります。関数の呼び出し元がこのようなローカル型を参照することはできませんが、もちろん構造的にマッチさせることはできます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="47a1b4c14a30afe92145ea5aeaecb13f79bfbd9a" translate="yes" xml:space="preserve">
          <source>The instance side of an ambient class declaration can be extended using an interface declaration The class constructor object is unmodified. For example:</source>
          <target state="translated">アンビエントクラス宣言のインスタンス側は、インターフェース宣言を使って拡張できます。 クラスのコンストラクタオブジェクトは変更されません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0e67711effae647619fb03057e9603bedb94bf60" translate="yes" xml:space="preserve">
          <source>The intent of any function that returns &lt;code&gt;never&lt;/code&gt; is that it never returns. It indicates that an exception was thrown, a halting error condition occurred, or that the program exited. For example, &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874&quot;&gt;&lt;code&gt;process.exit(...)&lt;/code&gt; in &lt;code&gt;@types/node&lt;/code&gt;&lt;/a&gt; is specified to return &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 戻らない関数の意図は、決して戻らないことです。例外がスローされたか、停止エラー条件が発生したか、またはプログラムが終了したことを示しています。たとえば&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874&quot;&gt;、&lt;/a&gt; &lt;code&gt;@types/node&lt;/code&gt; &lt;code&gt;process.exit(...)&lt;/code&gt; は、 &lt;code&gt;never&lt;/code&gt; を返さないように指定されています。</target>
        </trans-unit>
        <trans-unit id="8083efa15c72562212b03ec1e7d929e3b1bfe6f0" translate="yes" xml:space="preserve">
          <source>The interface &lt;code&gt;LabeledValue&lt;/code&gt; is a name we can now use to describe the requirement in the previous example. It still represents having a single property called &lt;code&gt;label&lt;/code&gt; that is of type &lt;code&gt;string&lt;/code&gt;. Notice we didn&amp;rsquo;t have to explicitly say that the object we pass to &lt;code&gt;printLabel&lt;/code&gt; implements this interface like we might have to in other languages. Here, it&amp;rsquo;s only the shape that matters. If the object we pass to the function meets the requirements listed, then it&amp;rsquo;s allowed.</source>
          <target state="translated">インターフェイス &lt;code&gt;LabeledValue&lt;/code&gt; は、前の例の要件を説明するために使用できる名前です。それでも、 &lt;code&gt;string&lt;/code&gt; 型の &lt;code&gt;label&lt;/code&gt; という単一のプロパティを持つことを表します。他の言語で必要となる場合があるように、 &lt;code&gt;printLabel&lt;/code&gt; に渡すオブジェクトがこのインターフェイスを実装することを明示的に言う必要がなかったことに注意してください。ここで重要なのは形状だけです。関数に渡すオブジェクトがリストされた要件を満たしている場合、それは許可されます。</target>
        </trans-unit>
        <trans-unit id="cd1c38f5000220665076a2e98824f2dbc1f3584b" translate="yes" xml:space="preserve">
          <source>The key difference is not in the syntax, but in the semantics, which we&amp;rsquo;ll now dive into.</source>
          <target state="translated">主な違いは構文ではなく、セマンティクスにあります。これについては、これから詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="b1b9a12d68027688efebd6988d804e470eefcb75" translate="yes" xml:space="preserve">
          <source>The last element of a tuple type can be a rest element of the form &lt;code&gt;...X&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an array type. A rest element indicates that the tuple type is open-ended and may have zero or more additional elements of the array element type. For example, &lt;code&gt;[number, ...string[]]&lt;/code&gt; means tuples with a &lt;code&gt;number&lt;/code&gt; element followed by any number of &lt;code&gt;string&lt;/code&gt; elements.</source>
          <target state="translated">タプル型の最後の要素は、 &lt;code&gt;...X&lt;/code&gt; 形式の残りの要素にすることができます。ここで、 &lt;code&gt;X&lt;/code&gt; は配列型です。残りの要素は、タプルの型が無制限であり、配列要素型の0個以上の追加の要素を持つ可能性があることを示します。たとえば、 &lt;code&gt;[number, ...string[]]&lt;/code&gt; は、 &lt;code&gt;number&lt;/code&gt; 要素の後に任意の数の &lt;code&gt;string&lt;/code&gt; 要素が続くタプルを意味します。</target>
        </trans-unit>
        <trans-unit id="d4b0bc795023f6d40258c16a24c570ab3f6de281" translate="yes" xml:space="preserve">
          <source>The layout of your declaration files should mirror the layout of the library.</source>
          <target state="translated">宣言ファイルのレイアウトは、ライブラリのレイアウトを反映させてください。</target>
        </trans-unit>
        <trans-unit id="62c6720928ebff15b4528d428a66db79a0e91621" translate="yes" xml:space="preserve">
          <source>The library can then be used as an import within modules:</source>
          <target state="translated">このライブラリは、モジュール内のインポートとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="5c400cd4aab73c26b9cba5406e5bfac6b44dcde8" translate="yes" xml:space="preserve">
          <source>The list below outlines which constructs are currently supported when using JSDoc annotations to provide type information in JavaScript files.</source>
          <target state="translated">以下のリストは、JavaScriptファイルの型情報を提供するためにJSDocアノテーションを使用する際に、現在サポートされている構文の概要です。</target>
        </trans-unit>
        <trans-unit id="dfd2bc32d3b21a5f15921128bd3664a23c6123a7" translate="yes" xml:space="preserve">
          <source>The locale to use to show error messages, e.g. en-us.</source>
          <target state="translated">エラーメッセージを表示する際に使用するロケール。</target>
        </trans-unit>
        <trans-unit id="745d0c4fae6c29892a03fe80ac17ab71cddad006" translate="yes" xml:space="preserve">
          <source>The majority of this handbook uses &lt;code&gt;let&lt;/code&gt; declarations.</source>
          <target state="translated">このハンドブックの大部分は &lt;code&gt;let&lt;/code&gt; 宣言を使用しています。</target>
        </trans-unit>
        <trans-unit id="6da0134724ec18c2aa83421ac5856f5cd2ff92c3" translate="yes" xml:space="preserve">
          <source>The maximum dependency depth to search under node_modules and load JavaScript files. Only applicable with &lt;code&gt;--allowJs&lt;/code&gt;.</source>
          <target state="translated">node_modulesで検索してJavaScriptファイルをロードするための最大の依存関係の深さ。 &lt;code&gt;--allowJs&lt;/code&gt; でのみ適用されます。</target>
        </trans-unit>
        <trans-unit id="931a11093903bc4e1293ac6a3b67077bc77990a3" translate="yes" xml:space="preserve">
          <source>The meaning is usually the same, or a superset, of the meaning of the tag given at usejsdoc.org. The code below describes the differences and gives some example usage of each tag.</source>
          <target state="translated">その意味は通常、usejsdoc.orgで与えられたタグの意味と同じか、あるいはその上位のものです。以下のコードは違いを説明し、それぞれのタグの使用例を示しています。</target>
        </trans-unit>
        <trans-unit id="5ce56ea092f5ec509f61892542f58f563f4f1ba4" translate="yes" xml:space="preserve">
          <source>The module name is resolved the same way as module specifiers in &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;export&lt;/code&gt;. See &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; for more information. Then the declarations in an augmentation are merged as if they were declared in the same file as the original.</source>
          <target state="translated">モジュール名は、 &lt;code&gt;import&lt;/code&gt; / &lt;code&gt;export&lt;/code&gt; モジュール指定子と同じ方法で解決されます。詳細については、&lt;a href=&quot;modules&quot;&gt;モジュール&lt;/a&gt;を参照してください。次に、オーグメンテーション内の宣言は、元のファイルと同じファイルで宣言されているかのようにマージされます。</target>
        </trans-unit>
        <trans-unit id="07d6025a4d8631b7d86a3f44337b3b6ce6a9547d" translate="yes" xml:space="preserve">
          <source>The module support in Javascript is much more syntactically forgiving than Typescript&amp;rsquo;s module support. Most combinations of assignments and declarations are supported.</source>
          <target state="translated">Javascriptでのモジュールサポートは、Typescriptのモジュールサポートよりも構文的にはるかに寛容です。割り当てと宣言のほとんどの組み合わせがサポートされています。</target>
        </trans-unit>
        <trans-unit id="72abf6e26cd87e8f0de9628019db48b91ac42135" translate="yes" xml:space="preserve">
          <source>The most basic datatype is the simple true/false value, which JavaScript and TypeScript call a &lt;code&gt;boolean&lt;/code&gt; value.</source>
          <target state="translated">最も基本的なデータ型は、JavaScriptとTypeScriptが &lt;code&gt;boolean&lt;/code&gt; 値を呼び出す単純なtrue / false値です。</target>
        </trans-unit>
        <trans-unit id="79f9e1701395e49a979bcc38539774286a14204c" translate="yes" xml:space="preserve">
          <source>The most impactful outcome of this feature might a bit subtle: with TypeScript 3.7, users can write libraries in JSDoc annotated JavaScript and support TypeScript users.</source>
          <target state="translated">TypeScript 3.7では、JSDocの注釈付きJavaScriptにライブラリを書き込んだり、TypeScriptユーザーをサポートしたりすることができます。</target>
        </trans-unit>
        <trans-unit id="d479ce4d899b82dead8eec0f18d6751cfd1966b0" translate="yes" xml:space="preserve">
          <source>The motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:</source>
          <target state="translated">動機となる例は、コールバックを受け取り、(プログラマにとっては)予測可能だが(型システムにとっては)未知の数の引数を使ってコールバックを呼び出す関数の一般的なパターンです。</target>
        </trans-unit>
        <trans-unit id="a57329ec0396a0060bb3225032730f604a10bd46" translate="yes" xml:space="preserve">
          <source>The name of a module augmentation is resolved using the same set of rules as module specifiers in &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; declarations. The declarations in a module augmentation are merged with any existing declarations the same way they would if they were declared in the same file.</source>
          <target state="translated">モジュール拡張の名前は、 &lt;code&gt;import&lt;/code&gt; および &lt;code&gt;export&lt;/code&gt; 宣言のモジュール指定子と同じルールセットを使用して解決されます。モジュール拡張の宣言は、同じファイルで宣言された場合と同じように、既存の宣言とマージされます。</target>
        </trans-unit>
        <trans-unit id="89f93191caae9470e60a7d3f09f4c2434d9bcb48" translate="yes" xml:space="preserve">
          <source>The name of the member.</source>
          <target state="translated">メンバーの名前です。</target>
        </trans-unit>
        <trans-unit id="bf6a2b3b69a6eaafe919135aca00082a2b3c554f" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;--showConfig&lt;/code&gt; flag</source>
          <target state="translated">新しい &lt;code&gt;--showConfig&lt;/code&gt; フラグ</target>
        </trans-unit>
        <trans-unit id="b915c8b00bd04df204cf54cb79ae4b4967b8188e" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;--strict&lt;/code&gt; compiler option represents the recommended setting of a number of type checking options. Specifically, specifying &lt;code&gt;--strict&lt;/code&gt; corresponds to specifying all of the following options (and may in the future include more options):</source>
          <target state="translated">新しい &lt;code&gt;--strict&lt;/code&gt; コンパイラオプションは、いくつかのタイプチェックオプションの推奨設定を表します。具体的には、 &lt;code&gt;--strict&lt;/code&gt; を指定すると、以下のすべてのオプションを指定することになります（将来的には、さらに多くのオプションが含まれる可能性があります）。</target>
        </trans-unit>
        <trans-unit id="46ab9ac92f2751e3448564e3b2bbebba0803af30" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;amd-dependency name&lt;/code&gt; property allows passing an optional name for an amd-dependency:</source>
          <target state="translated">新しい &lt;code&gt;amd-dependency name&lt;/code&gt; プロパティにより、amd-dependencyのオプションの名前を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="b0b30ce72a1fbb86ba7cb09b3d3773b6f87269d1" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;amd-module name&lt;/code&gt; tag allows passing an optional module name to the compiler:</source>
          <target state="translated">新しい &lt;code&gt;amd-module name&lt;/code&gt; タグを使用すると、オプションのモジュール名をコンパイラに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="00c1dd0b1d0ca34ff1579a9b55a20060afb63f62" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;protected&lt;/code&gt; modifier in classes works like it does in familiar languages like C++, C#, and Java. A &lt;code&gt;protected&lt;/code&gt; member of a class is visible only inside subclasses of the class in which it is declared:</source>
          <target state="translated">クラス内の新しい &lt;code&gt;protected&lt;/code&gt; 修飾子は、C ++、C＃、Javaなどの使い慣れた言語でのように機能します。 &lt;code&gt;protected&lt;/code&gt; クラスのメンバーは、それが宣言されたクラスのサブクラスの内部に表示されています。</target>
        </trans-unit>
        <trans-unit id="4be0bd15099c0de30a7f92de365d0546b8ad473c" translate="yes" xml:space="preserve">
          <source>The new ES6 keyword &lt;code&gt;let&lt;/code&gt;, now supported in TypeScript, declares a variable with more intuitive &amp;ldquo;block&amp;rdquo; semantics. A &lt;code&gt;let&lt;/code&gt; variable can only be referred to after its declaration, and is scoped to the syntactic block where it is defined:</source>
          <target state="translated">TypeScriptでサポート &lt;code&gt;let&lt;/code&gt; になった新しいES6キーワードletは、より直感的な「ブロック」セマンティクスで変数を宣言します。 &lt;code&gt;let&lt;/code&gt; 変数は、その宣言の後に参照することができ、それが定義されている構文ブロックにスコープされます。</target>
        </trans-unit>
        <trans-unit id="631ad33334be4530d47703f4e1d29cda38f087ea" translate="yes" xml:space="preserve">
          <source>The new factory name will be used to call &lt;code&gt;createElement&lt;/code&gt; and &lt;code&gt;__spread&lt;/code&gt; functions.</source>
          <target state="translated">新しいファクトリー名は、 &lt;code&gt;createElement&lt;/code&gt; および &lt;code&gt;__spread&lt;/code&gt; 関数を呼び出すために使用されます。</target>
        </trans-unit>
        <trans-unit id="d61ddaaf04d8d0073ea020e3954c9d83ac5bd7ac" translate="yes" xml:space="preserve">
          <source>The new features are designed such that they can be used in both strict null checking mode and regular type checking mode. In particular, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; types are automatically erased from union types in regular type checking mode (because they are subtypes of all other types), and the &lt;code&gt;!&lt;/code&gt; non-null assertion expression operator is permitted but has no effect in regular type checking mode. Thus, declaration files that are updated to use null- and undefined-aware types can still be used in regular type checking mode for backwards compatibility.</source>
          <target state="translated">新機能は、厳密なnullチェックモードと通常の型チェックモードの両方で使用できるように設計されています。特に、 &lt;code&gt;null&lt;/code&gt; 型と &lt;code&gt;undefined&lt;/code&gt; 型は、通常の型チェックモードで共用体型から自動的に消去されます（他のすべての型のサブタイプであるため） &lt;code&gt;!&lt;/code&gt; null以外のアサーション式演算子は許可されていますが、通常の型チェックモードでは効果がありません。したがって、nullおよび未定義の型を使用するように更新された宣言ファイルは、下位互換性のために通常の型チェックモードで引き続き使用できます。</target>
        </trans-unit>
        <trans-unit id="c30cd7e33232b4d2a28f205e7ae9088fbd691c02" translate="yes" xml:space="preserve">
          <source>The new handbook which is a work in progress.</source>
          <target state="translated">作業を進めていく新手引書。</target>
        </trans-unit>
        <trans-unit id="b6846e96b454262c109940d0e55e3a4611d91414" translate="yes" xml:space="preserve">
          <source>The new implementation also brings performance enhancements to watching in tsserver. The watcher logic has been completely rewritten to respond faster to change events.</source>
          <target state="translated">新しい実装では、tsserver でのウォッチングにもパフォーマンスの向上がもたらされています。ウォッチャーのロジックが完全に書き換えられ、変更イベントに素早く反応するようになりました。</target>
        </trans-unit>
        <trans-unit id="5a00224be7961350e2a8ff419045fdd51b036e82" translate="yes" xml:space="preserve">
          <source>The new module &lt;code&gt;ProgrammerCalculator&lt;/code&gt; exports an API shape similar to that of the original &lt;code&gt;Calculator&lt;/code&gt; module, but does not augment any objects in the original module. Here is a test for our ProgrammerCalculator class:</source>
          <target state="translated">新しいモジュール &lt;code&gt;ProgrammerCalculator&lt;/code&gt; は、元の &lt;code&gt;Calculator&lt;/code&gt; モジュールと同様のAPI形状をエクスポートしますが、元のモジュールのオブジェクトを拡張しません。ProgrammerCalculatorクラスのテストは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="2225a57adb33f21d4ebaaf566df0e99ffcf91683" translate="yes" xml:space="preserve">
          <source>The new playground now supports many new options including:</source>
          <target state="translated">新しい遊び場では、以下のような多くの新しいオプションをサポートするようになりました。</target>
        </trans-unit>
        <trans-unit id="68e11c2fb3a7db4e23da7d9de3e1a26ceae03748" translate="yes" xml:space="preserve">
          <source>The nightlies are available on &lt;a href=&quot;https://www.myget.org/gallery/typescript-preview&quot;&gt;www.myget.org&lt;/a&gt;.</source>
          <target state="translated">ナイトリーはで利用可能である&lt;a href=&quot;https://www.myget.org/gallery/typescript-preview&quot;&gt;www.myget.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb8de4c955d33fe91a7e4cbce1b7361bd5b2b3a3" translate="yes" xml:space="preserve">
          <source>The nightly build currently does not include the full plugin setup, but we are working on publishing an installer on a nightly basis as well.</source>
          <target state="translated">現在のところ、毎晩のビルドには完全なプラグインのセットアップは含まれていませんが、インストーラーを毎晩のように公開する作業を行っています。</target>
        </trans-unit>
        <trans-unit id="cfcfc96df71a12a29b5ce210c72d3e03c563d868" translate="yes" xml:space="preserve">
          <source>The old behavior still remains the same if given a directory - the compiler will try to find a file in the directory named &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="translated">ディレクトリを指定した場合、以前の動作は同じままです-コンパイラは &lt;code&gt;tsconfig.json&lt;/code&gt; という名前のディレクトリでファイルを見つけようとします。</target>
        </trans-unit>
        <trans-unit id="8b20ba860bfef9c7687f7310f99a76fe76d3783b" translate="yes" xml:space="preserve">
          <source>The order of specifying spread operations determines what properties end up in the resulting object; properties in later spreads &amp;ldquo;win out&amp;rdquo; over previously created properties.</source>
          <target state="translated">スプレッド操作を指定する順序により、結果のオブジェクトに含まれるプロパティが決まります。後でのプロパティは、以前に作成されたプロパティに「勝ち」ます。</target>
        </trans-unit>
        <trans-unit id="e7c876e1891bde60e537d27b5754b63af03257e0" translate="yes" xml:space="preserve">
          <source>The ordinal index of the parameter in the function&amp;rsquo;s parameter list.</source>
          <target state="translated">関数のパラメーターリスト内のパラメーターの序数インデックス。</target>
        </trans-unit>
        <trans-unit id="fb4cf9f813aa96ef2c61a94ad9fdf59d13dba821" translate="yes" xml:space="preserve">
          <source>The other change is that enum types themselves effectively become a &lt;em&gt;union&lt;/em&gt; of each enum member. While we haven&amp;rsquo;t discussed &lt;a href=&quot;advanced-types#union-types&quot;&gt;union types&lt;/a&gt; yet, all that you need to know is that with union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself. Because of that, TypeScript can catch silly bugs where we might be comparing values incorrectly. For example:</source>
          <target state="translated">もう1つの変更点は、列挙型自体が実質的に各列挙型メンバーの&lt;em&gt;結合&lt;/em&gt;になることです。&lt;a href=&quot;advanced-types#union-types&quot;&gt;ユニオンタイプ&lt;/a&gt;についてはまだ説明していませんが、ユニオン列挙型を使用すると、型システムは列挙型自体に存在する値の正確なセットを知っているという事実を活用できることを知っておく必要があります。そのため、TypeScriptは、値を誤って比較している可能性がある愚かなバグをキャッチできます。例えば：</target>
        </trans-unit>
        <trans-unit id="87a6d3fa93df1a7b5718c28d49fe2488fc9f01eb" translate="yes" xml:space="preserve">
          <source>The other new ES6 declaration type supported in TypeScript is &lt;code&gt;const&lt;/code&gt;. A &lt;code&gt;const&lt;/code&gt; variable may not be assigned to, and must be initialized where it is declared. This is useful for declarations where you don&amp;rsquo;t want to change the value after its initialization:</source>
          <target state="translated">TypeScriptでサポートされているもう1つの新しいES6宣言型は &lt;code&gt;const&lt;/code&gt; です。 &lt;code&gt;const&lt;/code&gt; 変数をに割り当てることができず、それが宣言されている場所を初期化する必要があります。これは、初期化後に値を変更したくない宣言に役立ちます。</target>
        </trans-unit>
        <trans-unit id="e032670f94ed341d763142ae7b65b1fabd05bbb1" translate="yes" xml:space="preserve">
          <source>The other type of assertion signature doesn&amp;rsquo;t check for a condition, but instead tells TypeScript that a specific variable or property has a different type.</source>
          <target state="translated">他のタイプのアサーションシグネチャは条件をチェックせず、代わりに特定の変数またはプロパティが異なるタイプであることをTypeScriptに通知します。</target>
        </trans-unit>
        <trans-unit id="eda209051691c244644fa70c53c6b169301d940d" translate="yes" xml:space="preserve">
          <source>The popular library D3 defines its functionality in a global object called &lt;code&gt;d3&lt;/code&gt;. Because this library is loaded through a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag (instead of a module loader), its declaration uses namespaces to define its shape. For the TypeScript compiler to see this shape, we use an ambient namespace declaration. For example, we could begin writing it as follows:</source>
          <target state="translated">人気のライブラリD3は、 &lt;code&gt;d3&lt;/code&gt; と呼ばれるグローバルオブジェクトでその機能を定義します。このライブラリは（モジュールローダーではなく） &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグを介して読み込まれるため、その宣言では名前空間を使用して形状を定義します。TypeScriptコンパイラーがこの形を見るには、アンビエント名前空間宣言を使用します。たとえば、次のように書き始めることができます。</target>
        </trans-unit>
        <trans-unit id="38c72ee7b721075b6b228593c6729fd98fa3d861" translate="yes" xml:space="preserve">
          <source>The preceding two types are equivalent to the Typescript types &lt;code&gt;{ [x: string]: number }&lt;/code&gt; and &lt;code&gt;{ [x: number]: any }&lt;/code&gt;. The compiler understands both syntaxes.</source>
          <target state="translated">上記の2つのタイプは、Typescriptタイプ &lt;code&gt;{ [x: string]: number }&lt;/code&gt; および &lt;code&gt;{ [x: number]: any }&lt;/code&gt; と同等です。コンパイラは両方の構文を理解します。</target>
        </trans-unit>
        <trans-unit id="aa67059f742d5b7173801d752e91479969530cea" translate="yes" xml:space="preserve">
          <source>The presence of a &lt;code&gt;tsconfig.json&lt;/code&gt; file in a directory indicates that the directory is the root of a TypeScript project. The &lt;code&gt;tsconfig.json&lt;/code&gt; file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:</source>
          <target state="translated">ディレクトリに &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルが存在することは、そのディレクトリがTypeScriptプロジェクトのルートであることを示しています。 &lt;code&gt;tsconfig.json&lt;/code&gt; のファイルは、ルートファイルやプロジェクトをコンパイルするために必要なコンパイラオプションを指定します。プロジェクトは、次のいずれかの方法でコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="088fad3bfe9085a4bf306d60f92061feba8a8ef7" translate="yes" xml:space="preserve">
          <source>The problem with &lt;code&gt;padLeft&lt;/code&gt; is that its &lt;code&gt;padding&lt;/code&gt; parameter is typed as &lt;code&gt;any&lt;/code&gt;. That means that we can call it with an argument that&amp;rsquo;s neither a &lt;code&gt;number&lt;/code&gt; nor a &lt;code&gt;string&lt;/code&gt;, but TypeScript will be okay with it.</source>
          <target state="translated">&lt;code&gt;padLeft&lt;/code&gt; の問題は、その &lt;code&gt;padding&lt;/code&gt; パラメータが &lt;code&gt;any&lt;/code&gt; として型指定されることです。つまり、 &lt;code&gt;number&lt;/code&gt; も &lt;code&gt;string&lt;/code&gt; でもない引数で呼び出すことができますが、TypeScriptでは問題ありません。</target>
        </trans-unit>
        <trans-unit id="1bb7381db8810d933065e806b992cda45878627e" translate="yes" xml:space="preserve">
          <source>The process of resolving these package names is similar to the process of resolving module names in an &lt;code&gt;import&lt;/code&gt; statement. An easy way to think of triple-slash-reference-types directives are as an &lt;code&gt;import&lt;/code&gt; for declaration packages.</source>
          <target state="translated">これらのパッケージ名を解決するプロセスは、 &lt;code&gt;import&lt;/code&gt; ステートメントでモジュール名を解決するプロセスと似ています。トリプルスラッシュ参照タイプディレクティブを考える簡単な方法は、宣言パッケージの &lt;code&gt;import&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="aafd5dd1f8eca4eda75bcd1718aa421a44d595dd" translate="yes" xml:space="preserve">
          <source>The process starts with a set of &lt;em&gt;root files&lt;/em&gt;; these are the file names specified on the command-line or in the &lt;code&gt;&quot;files&quot;&lt;/code&gt; list in the &lt;code&gt;tsconfig.json&lt;/code&gt; file. These root files are preprocessed in the same order they are specified. Before a file is added to the list, all triple-slash references in it are processed, and their targets included. Triple-slash references are resolved in a depth first manner, in the order they have been seen in the file.</source>
          <target state="translated">プロセスは、&lt;em&gt;ルートファイルの&lt;/em&gt;セットから始まり&lt;em&gt;ます&lt;/em&gt;。これらは、コマンドラインまたは &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルの &lt;code&gt;&quot;files&quot;&lt;/code&gt; リストで指定されたファイル名です。これらのルートファイルは、指定された順序で前処理されます。ファイルがリストに追加される前に、ファイル内のすべてのトリプルスラッシュ参照が処理され、そのターゲットが含まれます。トリプルスラッシュ参照は、ファイル内で表示された順序で、深さ優先の方法で解決されます。</target>
        </trans-unit>
        <trans-unit id="17ce755b0cdb23dc9be9ae1982b9a584f1e51772" translate="yes" xml:space="preserve">
          <source>The program should print &amp;ldquo;Hello from TypeScript!&amp;rdquo;.</source>
          <target state="translated">プログラムは「Hello from TypeScript！」を出力するはずです。</target>
        </trans-unit>
        <trans-unit id="fad1dae24f8de6bb5ace45589ded1976d7ba9b1d" translate="yes" xml:space="preserve">
          <source>The purpose of this guide is to teach you how to write a high-quality definition file. This guide is structured by showing documentation for some API, along with sample usage of that API, and explaining how to write the corresponding declaration.</source>
          <target state="translated">このガイドの目的は、高品質な定義ファイルの書き方を教えることです。このガイドは、あるAPIのドキュメントと、そのAPIの使用例を示し、対応する宣言の書き方を説明することで構成されています。</target>
        </trans-unit>
        <trans-unit id="0eccb935e6264e79e73c70e81e21a7c090643b4a" translate="yes" xml:space="preserve">
          <source>The reference tag here allows us to locate the declaration file that contains the declaration for the ambient module. This is how the &lt;code&gt;node.d.ts&lt;/code&gt; file that several of the TypeScript samples use is consumed.</source>
          <target state="translated">ここの参照タグにより、アンビエントモジュールの宣言を含む宣言ファイルを見つけることができます。これは、いくつかのTypeScriptサンプルが使用する &lt;code&gt;node.d.ts&lt;/code&gt; ファイルの使用方法です。</target>
        </trans-unit>
        <trans-unit id="71056ddd9a7d7a3d2b766c4d6ec8f63ddc99ad7f" translate="yes" xml:space="preserve">
          <source>The rest of this section assumes &lt;code&gt;typescript@next&lt;/code&gt; is already installed.</source>
          <target state="translated">このセクションの残りの部分では、 &lt;code&gt;typescript@next&lt;/code&gt; がすでにインストールされていることを前提としています。</target>
        </trans-unit>
        <trans-unit id="f21084484972497bb17b43e1dd1639f1309df4de" translate="yes" xml:space="preserve">
          <source>The result will be a file &lt;code&gt;greeter.js&lt;/code&gt; which contains the same JavaScript that you fed in. We&amp;rsquo;re up and running using TypeScript in our JavaScript app!</source>
          <target state="translated">結果は、入力したのと同じJavaScriptを含む &lt;code&gt;greeter.js&lt;/code&gt; ファイルになります。JavaScriptアプリでTypeScriptを使用して実行しています。</target>
        </trans-unit>
        <trans-unit id="55cd4e9d5c07da56c2642a3c67f20fdea4efaf76" translate="yes" xml:space="preserve">
          <source>The resulting merged declaration of &lt;code&gt;Document&lt;/code&gt; will be the following:</source>
          <target state="translated">マージされた &lt;code&gt;Document&lt;/code&gt; 宣言は次のようになります。</target>
        </trans-unit>
        <trans-unit id="5a7ebfe9ca74c5339d3d3f99e13edb4401f1c213" translate="yes" xml:space="preserve">
          <source>The resulting type of the property.</source>
          <target state="translated">プロパティの結果の型。</target>
        </trans-unit>
        <trans-unit id="fb503a1aeb68c9cb323a5ced50b16d97adf33167" translate="yes" xml:space="preserve">
          <source>The results are then called as functions from bottom-to-top.</source>
          <target state="translated">そして、その結果を下から上へ関数として呼び出します。</target>
        </trans-unit>
        <trans-unit id="b9eb08a8c7770e6b9f8872c6109a3df7ec5c1b48" translate="yes" xml:space="preserve">
          <source>The return value of the parameter decorator is ignored.</source>
          <target state="translated">パラメータデコレータの戻り値は無視されます。</target>
        </trans-unit>
        <trans-unit id="ec62e92022db3b095789b1a8bc611f9661c25a8c" translate="yes" xml:space="preserve">
          <source>The right side of the &lt;code&gt;instanceof&lt;/code&gt; needs to be a constructor function, and TypeScript will narrow down to:</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; の右側はコンストラクタ関数である必要があり、TypeScriptは次のように絞り込みます。</target>
        </trans-unit>
        <trans-unit id="9bdcb387eac602c5c7979ebf6b526180243170a8" translate="yes" xml:space="preserve">
          <source>The same &lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;footnote&lt;/a&gt; applies to these modules.</source>
          <target state="translated">同じ&lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;脚注&lt;/a&gt;がこれらのモジュールに適用されます。</target>
        </trans-unit>
        <trans-unit id="f7fb9969f8be2dbbfcedab928e0115d7fa79657a" translate="yes" xml:space="preserve">
          <source>The same goes for &lt;a href=&quot;https://github.com/TypeStrong/ts-loader&quot;&gt;ts-loader&lt;/a&gt;, another TypeScript loader for Webpack. You can read more about the differences between the two &lt;a href=&quot;https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">同じことがのために行く&lt;a href=&quot;https://github.com/TypeStrong/ts-loader&quot;&gt;TS-ローダー&lt;/a&gt;、WebPACKのための別の活字体ローダー。2つの違いの詳細については、&lt;a href=&quot;https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader&quot;&gt;こちらをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00fc4820883d5fd03b19870a02ddabbb40e34c99" translate="yes" xml:space="preserve">
          <source>The same is true for optional properties:</source>
          <target state="translated">オプションのプロパティについても同様です。</target>
        </trans-unit>
        <trans-unit id="43f24dd384fa12ae0f07c7c778176cd12dddfc84" translate="yes" xml:space="preserve">
          <source>The same rule for assignment is used when checking function call arguments:</source>
          <target state="translated">関数呼び出しの引数をチェックする際には、代入と同じルールを使用します。</target>
        </trans-unit>
        <trans-unit id="addbe812d1672c5e4f322e5d5a3556adcb36610e" translate="yes" xml:space="preserve">
          <source>The same sort of tracking is now also done for empty arrays.</source>
          <target state="translated">空の配列に対しても同様のトラッキングが行われるようになりました。</target>
        </trans-unit>
        <trans-unit id="ccde6d73f9a8b313307d39b074524c1e2e182522" translate="yes" xml:space="preserve">
          <source>The same way that ordinary tuples are types that extend from &lt;code&gt;Array&lt;/code&gt; - a tuple with elements of type &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;, &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;, &amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; extends from &lt;code&gt;Array&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; \| ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; - &lt;code&gt;readonly&lt;/code&gt; tuples are types that extend from &lt;code&gt;ReadonlyArray&lt;/code&gt;. So a &lt;code&gt;readonly&lt;/code&gt; tuple with elements &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;, &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;, &amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; extends from &lt;code&gt;ReadonlyArray&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; | ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt;.</source>
          <target state="translated">通常のタプルが &lt;code&gt;Array&lt;/code&gt; から拡張されるタイプであるのと同じ方法-タイプ &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; 、 &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; 、&amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; 要素を持つタプルは &lt;code&gt;Array&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; \| ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; から拡張されます T &lt;sub&gt;2&lt;/sub&gt; \ | ... T &lt;sub&gt;N&lt;/sub&gt; &amp;gt; - &lt;code&gt;readonly&lt;/code&gt; タプルから拡張型である &lt;code&gt;ReadonlyArray&lt;/code&gt; 。したがって、要素 &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;1&lt;/sub&gt;、 &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;2&lt;/sub&gt;、&amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;nを&lt;/sub&gt;持つ &lt;code&gt;readonly&lt;/code&gt; タプルは、 &lt;code&gt;ReadonlyArray&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; | ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; &lt;sub&gt;1&lt;/sub&gt; \ |から拡張されます。T &lt;sub&gt;2&lt;/sub&gt; | ... T &lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="739a9969f90dca0e3b9321fb87d6ba49413bb58c" translate="yes" xml:space="preserve">
          <source>The second assignment is an error, because &lt;code&gt;y&lt;/code&gt; has a required second parameter that &lt;code&gt;x&lt;/code&gt; does not have, so the assignment is disallowed.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; には &lt;code&gt;x&lt;/code&gt; にはない2番目の必須パラメーターがあるため、2番目の割り当てはエラーとなり、割り当ては許可されません。</target>
        </trans-unit>
        <trans-unit id="3f4a4a115d577adebcffab99f90c2599ff896791" translate="yes" xml:space="preserve">
          <source>The second block creates the following name meanings:</source>
          <target state="translated">2 番目のブロックは、以下の名前の意味を作成します。</target>
        </trans-unit>
        <trans-unit id="e0467e5b0666d2b81ecc53a34087b88185a9207e" translate="yes" xml:space="preserve">
          <source>The second method uses the &lt;code&gt;never&lt;/code&gt; type that the compiler uses to check for exhaustiveness:</source>
          <target state="translated">2番目の方法は、コンパイラーが網羅性をチェックするために使用する &lt;code&gt;never&lt;/code&gt; タイプを使用します。</target>
        </trans-unit>
        <trans-unit id="49820d40f361e464b077d6cf772f08f976135fd0" translate="yes" xml:space="preserve">
          <source>The second operator is &lt;code&gt;T[K]&lt;/code&gt;, the &lt;strong&gt;indexed access operator&lt;/strong&gt;. Here, the type syntax reflects the expression syntax. That means that &lt;code&gt;person['name']&lt;/code&gt; has the type &lt;code&gt;Person['name']&lt;/code&gt; &amp;mdash; which in our example is just &lt;code&gt;string&lt;/code&gt;. However, just like index type queries, you can use &lt;code&gt;T[K]&lt;/code&gt; in a generic context, which is where its real power comes to life. You just have to make sure that the type variable &lt;code&gt;K extends keyof T&lt;/code&gt;. Here&amp;rsquo;s another example with a function named &lt;code&gt;getProperty&lt;/code&gt;.</source>
          <target state="translated">2番目の演算子は、&lt;strong&gt;インデックス付きアクセス演算&lt;/strong&gt;子である &lt;code&gt;T[K]&lt;/code&gt; です。ここで、型構文は式構文を反映しています。つまり、 &lt;code&gt;person['name']&lt;/code&gt; の型は &lt;code&gt;Person['name']&lt;/code&gt; です。これは、この例では単なる &lt;code&gt;string&lt;/code&gt; です。ただし、インデックスタイプのクエリと同様に、 &lt;code&gt;T[K]&lt;/code&gt; は一般的なコンテキストで使用できます。型変数 &lt;code&gt;K extends keyof T&lt;/code&gt; することを確認する必要があります。 &lt;code&gt;getProperty&lt;/code&gt; という名前の関数を使用した別の例を次に示します。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d22435f751c04c05b24d63f2b79d13b3746e4a00" translate="yes" xml:space="preserve">
          <source>The second part is the return type. We make it clear which is the return type by using a fat arrow (&lt;code&gt;=&amp;gt;&lt;/code&gt;) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn&amp;rsquo;t return a value, you would use &lt;code&gt;void&lt;/code&gt; instead of leaving it off.</source>
          <target state="translated">2番目の部分は戻り値の型です。パラメータと戻り値の型の間に太い矢印（ &lt;code&gt;=&amp;gt;&lt;/code&gt; ）を使用して、戻り値の型を明確にします。前述のように、これは関数タイプの必須部分であるため、関数が値を返さない場合は、 &lt;code&gt;void&lt;/code&gt; のままにする代わりにvoidを使用します。</target>
        </trans-unit>
        <trans-unit id="e07f825349d9c56d700585b88ad266691534c76a" translate="yes" xml:space="preserve">
          <source>The second reason is when a consumer uses the &amp;ldquo;strict null checking&amp;rdquo; feature of TypeScript. Because unspecified parameters appear as &lt;code&gt;undefined&lt;/code&gt; in JavaScript, it&amp;rsquo;s usually fine to pass an explicit &lt;code&gt;undefined&lt;/code&gt; to a function with optional arguments. This code, for example, should be OK under strict nulls:</source>
          <target state="translated">2番目の理由は、コンシューマがTypeScriptの「厳密なnullチェック」機能を使用する場合です。JavaScriptで &lt;code&gt;undefined&lt;/code&gt; 指定のパラメーターは未定義として表示されるため、通常、明示的な &lt;code&gt;undefined&lt;/code&gt; をオプションの引数を持つ関数に渡しても問題ありません。たとえば、このコードは厳密なnullのもとでは問題ありません。</target>
        </trans-unit>
        <trans-unit id="3fd4b2e06d8d3d430b175e5ddeea0b896410301c" translate="yes" xml:space="preserve">
          <source>The second way is also perhaps the most common. Here we use &lt;em&gt;type argument inference&lt;/em&gt; &amp;ndash; that is, we want the compiler to set the value of &lt;code&gt;T&lt;/code&gt; for us automatically based on the type of the argument we pass in:</source>
          <target state="translated">2番目の方法もおそらく最も一般的です。ここでは、&lt;em&gt;型引数の推論&lt;/em&gt;を使用します。つまり、コンパイラーに、渡す引数の型に基づいて &lt;code&gt;T&lt;/code&gt; の値を自動的に設定させます。</target>
        </trans-unit>
        <trans-unit id="4736ec61bf8078d3ad2a342c635cb7fc5c10d088" translate="yes" xml:space="preserve">
          <source>The second way uses a generic array type, &lt;code&gt;Array&amp;lt;elemType&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">2番目の方法では、ジェネリック配列タイプ &lt;code&gt;Array&amp;lt;elemType&amp;gt;&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="99b58ef085b8f5cfafe10b2f70b1c603ae679699" translate="yes" xml:space="preserve">
          <source>The simplest form of destructuring is array destructuring assignment:</source>
          <target state="translated">破壊の最も単純な形式は、配列破壊の代入です。</target>
        </trans-unit>
        <trans-unit id="81722fee1d2fb56b682b67ac28f4e353808fb7d3" translate="yes" xml:space="preserve">
          <source>The simplest, and perhaps most common, type of declaration merging is interface merging. At the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name.</source>
          <target state="translated">宣言のマージで最も単純で、おそらく最も一般的なタイプは、インターフェイスのマージです。最も基本的なレベルでは、両方の宣言のメンバを同じ名前の単一のインターフェイスに機械的に結合します。</target>
        </trans-unit>
        <trans-unit id="13408208368716d434a2faec6f70e98867378392" translate="yes" xml:space="preserve">
          <source>The snippet above is an example of type inference, explained later in the handbook.</source>
          <target state="translated">上のスニペットは、ハンドブックで後ほど説明する型推論の例です。</target>
        </trans-unit>
        <trans-unit id="f58e24702b78cd5b8941ef478b1489c1cd7b5d65" translate="yes" xml:space="preserve">
          <source>The spread operator also works:</source>
          <target state="translated">スプレッド演算子も効きます。</target>
        </trans-unit>
        <trans-unit id="306da80508d5bf827e829e72fb7591269adf0a66" translate="yes" xml:space="preserve">
          <source>The spread operator is the opposite of destructuring. It allows you to spread an array into another array, or an object into another object. For example:</source>
          <target state="translated">スプレッド演算子は、デストラクチャリングの反対語です。これにより、配列を別の配列に広げたり、オブジェクトを別のオブジェクトに広げたりすることができます。例えば、次のようになります。</target>
        </trans-unit>
        <trans-unit id="f885061b123a3fe063f3c9ed899b1d23df83d618" translate="yes" xml:space="preserve">
          <source>The strategy the compiler is following</source>
          <target state="translated">コンパイラは次のような戦略をとっています。</target>
        </trans-unit>
        <trans-unit id="c3d17817e55b210acd9bce6627aec4a4dd9620cb" translate="yes" xml:space="preserve">
          <source>The stricter checking applies to all function types, &lt;em&gt;except&lt;/em&gt; those originating in method or constructor declarations. Methods are excluded specifically to ensure generic classes and interfaces (such as &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;) continue to mostly relate covariantly.</source>
          <target state="translated">より厳密なチェックは、メソッドまたはコンストラクター宣言で発生したもの&lt;em&gt;を除い&lt;/em&gt;て、すべての関数タイプに適用されます。ジェネリッククラスとインターフェイス（ &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; ）がほぼ共変的に関連し続けることを保証するために、メソッドは特に除外されています。</target>
        </trans-unit>
        <trans-unit id="9257c34b0251760de9cf13098d8b8dab286b41c2" translate="yes" xml:space="preserve">
          <source>The string literal union &lt;code&gt;Keys&lt;/code&gt;, which contains the names of properties to iterate over.</source>
          <target state="translated">文字列リテラルのユニオン &lt;code&gt;Keys&lt;/code&gt; には、反復するプロパティの名前が含まれています。</target>
        </trans-unit>
        <trans-unit id="712aa4a776f92297417c2dad5e9739407277009b" translate="yes" xml:space="preserve">
          <source>The supported glob wildcards are:</source>
          <target state="translated">サポートされている glob ワイルドカードは以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="727e992e3d1e12337dc7c95d559ff4b4fccf59be" translate="yes" xml:space="preserve">
          <source>The syntax resembles the syntax for index signatures with a &lt;code&gt;for .. in&lt;/code&gt; inside. There are three parts:</source>
          <target state="translated">構文は、内部に &lt;code&gt;for .. in&lt;/code&gt; を含むインデックスシグネチャの構文に似ています。3つの部分があります。</target>
        </trans-unit>
        <trans-unit id="42212d0e88124e6c9e85e3c6d2679e2ebfc79e8e" translate="yes" xml:space="preserve">
          <source>The syntax should look familiar if you&amp;rsquo;ve used C# or Java before. We declare a new class &lt;code&gt;Greeter&lt;/code&gt;. This class has three members: a property called &lt;code&gt;greeting&lt;/code&gt;, a constructor, and a method &lt;code&gt;greet&lt;/code&gt;.</source>
          <target state="translated">以前にC＃またはJavaを使用したことがある場合、構文はおなじみのはずです。新しいクラス &lt;code&gt;Greeter&lt;/code&gt; を宣言します。このクラスには3つのメンバーがあります。 &lt;code&gt;greet&lt;/code&gt; 、 &lt;code&gt;greeting&lt;/code&gt; と呼ばれるプロパティー、コンストラクター、およびメソッドgreetです。</target>
        </trans-unit>
        <trans-unit id="04a97906fd0b03483a7f8d7138ad2f0a923a35cf" translate="yes" xml:space="preserve">
          <source>The template file &lt;a href=&quot;templates/global-d-ts&quot;&gt;&lt;code&gt;global.d.ts&lt;/code&gt;&lt;/a&gt; defines an example library &lt;code&gt;myLib&lt;/code&gt;. Be sure to read the &lt;a href=&quot;#preventing-name-conflicts&quot;&gt;&amp;ldquo;Preventing Name Conflicts&amp;rdquo; footnote&lt;/a&gt;.</source>
          <target state="translated">テンプレートファイル&lt;a href=&quot;templates/global-d-ts&quot;&gt; &lt;code&gt;global.d.ts&lt;/code&gt; &lt;/a&gt;は、サンプルライブラリ &lt;code&gt;myLib&lt;/code&gt; を定義します。&lt;a href=&quot;#preventing-name-conflicts&quot;&gt;「名前の競合の防止」脚注を&lt;/a&gt;必ずお読みください。</target>
        </trans-unit>
        <trans-unit id="5291791ebba8241b8df5e64ba1807928b332ea67" translate="yes" xml:space="preserve">
          <source>The test files import the implementation files and do some testing:</source>
          <target state="translated">テストファイルは実装ファイルをインポートしてテストを行います。</target>
        </trans-unit>
        <trans-unit id="1d502ba678972d16c080f4276cf5add29d80b7a4" translate="yes" xml:space="preserve">
          <source>The three interfaces will merge to create a single declaration as so:</source>
          <target state="translated">3つのインターフェイスをマージして、このように1つの宣言を作成します。</target>
        </trans-unit>
        <trans-unit id="ace0f93a6c178ee20b3542e125ca7fdce8f70590" translate="yes" xml:space="preserve">
          <source>The top-level module here &lt;code&gt;Shapes&lt;/code&gt; wraps up &lt;code&gt;Triangle&lt;/code&gt; and &lt;code&gt;Square&lt;/code&gt; for no reason. This is confusing and annoying for consumers of your module:</source>
          <target state="translated">ここのトップレベルのモジュール &lt;code&gt;Shapes&lt;/code&gt; は、理由もなく &lt;code&gt;Triangle&lt;/code&gt; と &lt;code&gt;Square&lt;/code&gt; をラップします。これは、モジュールのコンシューマーにとって混乱を招く煩わしいものです。</target>
        </trans-unit>
        <trans-unit id="7b5e597f445939620e293134a759f62224c6c2bd" translate="yes" xml:space="preserve">
          <source>The two biggest changes are the following:</source>
          <target state="translated">大きく変わったのは以下の2点です。</target>
        </trans-unit>
        <trans-unit id="d3d5cbb8071ba1e4008349316f8601cde19debcd" translate="yes" xml:space="preserve">
          <source>The two options left more to be desired; bundling the helpers in every file was a pain point for customers trying to keep their package size small. And not including helpers, meant customers had to maintain their own helpers library.</source>
          <target state="translated">ヘルパーをすべてのファイルにバンドルすることは、パッケージサイズを小さくしようとしている顧客にとって苦痛でした。また、ヘルパーを含まないということは、顧客が独自のヘルパーライブラリを維持しなければならないことを意味していました。</target>
        </trans-unit>
        <trans-unit id="a8a8ad0b07b6aeac0ba2a5e2ec35773596d69e43" translate="yes" xml:space="preserve">
          <source>The two samples are equivalent. Using one over the other is mostly a choice of preference; however, when using TypeScript with JSX, only &lt;code&gt;as&lt;/code&gt;-style assertions are allowed.</source>
          <target state="translated">2つのサンプルは同等です。どちらを使用するかは、主に好みの選択です。しかし、場合にのみ、JSXと活字体を使用し &lt;code&gt;as&lt;/code&gt; スタイルのアサーションが許可されています。</target>
        </trans-unit>
        <trans-unit id="9a2b71237e4b11c5e8ec290df36ff6e89dc1089c" translate="yes" xml:space="preserve">
          <source>The type above means when &lt;code&gt;T&lt;/code&gt; is assignable to &lt;code&gt;U&lt;/code&gt; the type is &lt;code&gt;X&lt;/code&gt;, otherwise the type is &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">上記のタイプは、 &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;U&lt;/code&gt; に割り当て可能な場合、タイプは &lt;code&gt;X&lt;/code&gt; であり、そうでない場合、タイプは &lt;code&gt;Y&lt;/code&gt; であることを意味します。</target>
        </trans-unit>
        <trans-unit id="c4716786bdfd77dd152da96b6dedb84b8495378a" translate="yes" xml:space="preserve">
          <source>The type checker checks the call to &lt;code&gt;printLabel&lt;/code&gt;. The &lt;code&gt;printLabel&lt;/code&gt; function has a single parameter that requires that the object passed in has a property called &lt;code&gt;label&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. Notice that our object actually has more properties than this, but the compiler only checks that &lt;em&gt;at least&lt;/em&gt; the ones required are present and match the types required. There are some cases where TypeScript isn&amp;rsquo;t as lenient, which we&amp;rsquo;ll cover in a bit.</source>
          <target state="translated">タイプチェッカーは、 &lt;code&gt;printLabel&lt;/code&gt; の呼び出しをチェックします。 &lt;code&gt;printLabel&lt;/code&gt; の機能は、渡されたオブジェクトは、というプロパティ持っている必要があり、単一のパラメータ &lt;code&gt;label&lt;/code&gt; タイプの &lt;code&gt;string&lt;/code&gt; 。オブジェクトには実際にはこれよりも多くのプロパティがありますが、コンパイラ&lt;em&gt;は少なくとも&lt;/em&gt;必要なプロパティが存在し、必要なタイプに一致することのみを確認すること&lt;em&gt;に&lt;/em&gt;注意してください。 TypeScriptがそれほど寛大でない場合がありますが、これについては後で説明します。</target>
        </trans-unit>
        <trans-unit id="498dccd8aaeaa75874785e3ff175fe7c0758db81" translate="yes" xml:space="preserve">
          <source>The type checker previously considered &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; assignable to anything. Effectively, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; were valid values of &lt;em&gt;every&lt;/em&gt; type and it wasn&amp;rsquo;t possible to specifically exclude them (and therefore not possible to detect erroneous use of them).</source>
          <target state="translated">以前に考えられて型チェッカー &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; ものに割り当て可能。事実上、 &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; は&lt;em&gt;すべての&lt;/em&gt;タイプの有効な値であり、それらを明確に除外することはできませんでした（したがって、それらの誤った使用を検出することはできませんでした）。</target>
        </trans-unit>
        <trans-unit id="86aac0e48da9aea5ed18bd94611504853bd15903" translate="yes" xml:space="preserve">
          <source>The type inferred for a &lt;code&gt;const&lt;/code&gt; variable or &lt;code&gt;readonly&lt;/code&gt; property without a type annotation is the type of the literal initializer. The type inferred for a &lt;code&gt;let&lt;/code&gt; variable, &lt;code&gt;var&lt;/code&gt; variable, parameter, or non-&lt;code&gt;readonly&lt;/code&gt; property with an initializer and no type annotation is the widened literal type of the initializer. Where the widened type for a string literal type is &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt; for numeric literal types, &lt;code&gt;boolean&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; and the containing enum for enum literal types.</source>
          <target state="translated">型注釈のない &lt;code&gt;const&lt;/code&gt; 変数または &lt;code&gt;readonly&lt;/code&gt; プロパティに対して推論される型は、リテラル初期化子の型です。イニシャライザがあり、タイプ注釈がない、 &lt;code&gt;let&lt;/code&gt; 変数、 &lt;code&gt;var&lt;/code&gt; 変数、パラメータ、または非 &lt;code&gt;readonly&lt;/code&gt; プロパティに対して推論されるタイプは、初期化子の拡張されたリテラルタイプです。文字列リテラルタイプの広がったタイプがある場合は &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;number&lt;/code&gt; 数値リテラルタイプのため、 &lt;code&gt;boolean&lt;/code&gt; のための &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; と列挙リテラルのタイプについて含むenum。</target>
        </trans-unit>
        <trans-unit id="22d8204ec0e93f58b5995cd3bb24de8809d04802" translate="yes" xml:space="preserve">
          <source>The type information provided works together with the tools to work with JavaScript at application scale. For more examples of what&amp;rsquo;s possible in TypeScript, see the Samples section of the website.</source>
          <target state="translated">提供されるタイプ情報は、アプリケーション規模でJavaScriptを操作するためのツールと連動します。TypeScriptで可能なことのその他の例については、Webサイトの「サンプル」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="3d4d8d8ec6a0364ae5c047afca600acdad689a11" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;import.meta&lt;/code&gt; is the global &lt;code&gt;ImportMeta&lt;/code&gt; type which is defined in &lt;code&gt;lib.es5.d.ts&lt;/code&gt;. This interface is extremely limited. Adding well-known properties for Node or browsers requires interface merging and possibly a global augmentation depending on the context.</source>
          <target state="translated">種類 &lt;code&gt;import.meta&lt;/code&gt; はグローバルである &lt;code&gt;ImportMeta&lt;/code&gt; の中で定義されているタイプ &lt;code&gt;lib.es5.d.ts&lt;/code&gt; 。このインターフェースは非常に制限されています。ノードまたはブラウザの既知のプロパティを追加するには、インターフェイスのマージと、状況に応じてグローバルな拡張が必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="d271ce4998727501be8284a249a40022d27f33d7" translate="yes" xml:space="preserve">
          <source>The type of a variable declared in a &lt;code&gt;for..in&lt;/code&gt; statement is implicitly &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; ステートメントで宣言された変数の型は、暗黙的に &lt;code&gt;string&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="5f07be8c188f5eaeef3ae763a9e934f23db56503" translate="yes" xml:space="preserve">
          <source>The type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:</source>
          <target state="translated">ジェネリック関数の型は非ジェネリック関数の型と同じで、関数宣言と同様に型パラメータが最初にリストアップされています。</target>
        </trans-unit>
        <trans-unit id="89b88412f516aaabf8ce78ad994c61d8ed26eb99" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;length&lt;/code&gt; property of a tuple type with a rest element is &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">種類 &lt;code&gt;length&lt;/code&gt; 休止要素とタプルタイプの特性である &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19df0d5bb97d9dc0679c13270f984f724378fbec" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;x&lt;/code&gt; variable is inferred to be &lt;code&gt;number&lt;/code&gt;. This kind of inference takes place when initializing variables and members, setting parameter default values, and determining function return types.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 変数の型は &lt;code&gt;number&lt;/code&gt; であると推測されます。この種の推論は、変数とメンバーの初期化、パラメーターのデフォルト値の設定、関数の戻り値の型の決定時に行われます。</target>
        </trans-unit>
        <trans-unit id="f6bd4bc2cdf6f5eae310eb7f350c21d93cc10ee9" translate="yes" xml:space="preserve">
          <source>The type parameter type of the &lt;code&gt;extends&lt;/code&gt; expression must be constrained to a mixin constructor type.</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; 式のタイプパラメータタイプは、ミックスインコンストラクタタイプに制限する必要があります。</target>
        </trans-unit>
        <trans-unit id="52c2a6f88c2385c5622c47c84c950cacbd843901" translate="yes" xml:space="preserve">
          <source>The type system enforces that the source function&amp;rsquo;s return type be a subtype of the target type&amp;rsquo;s return type.</source>
          <target state="translated">型システムは、ソース関数の戻り型がターゲット型の戻り型のサブタイプであることを強制します。</target>
        </trans-unit>
        <trans-unit id="b936c977ae4cffd22334d0707270bc09672639e5" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;K&lt;/code&gt;, which gets bound to each property in turn.</source>
          <target state="translated">型変数 &lt;code&gt;K&lt;/code&gt; 。各プロパティに順番にバインドされます。</target>
        </trans-unit>
        <trans-unit id="7709afd63729fd84f9c850e499018e8fd56d1bb3" translate="yes" xml:space="preserve">
          <source>The types of the attributes being passed in the JSX element should be looked up differently. Intrinsic element attributes should be known &lt;em&gt;intrinsically&lt;/em&gt; whereas components will likely want to specify their own set of attributes.</source>
          <target state="translated">JSX要素で渡される属性のタイプは、別の方法で検索する必要があります。コンポーネント&lt;em&gt;固有&lt;/em&gt;の属性セットを指定する可能性が高いのに対し、組み込み要素の属性は&lt;em&gt;本質的に&lt;/em&gt;認識されている必要があります。</target>
        </trans-unit>
        <trans-unit id="09675d7cd4f6ad417e59fbaf95c24d2d47c06712" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;TypeScriptToolsVersion&amp;gt;1.7&amp;lt;/TypeScriptToolsVersion&amp;gt;&lt;/code&gt; property in the project file identifies the compiler version to use to build (1.7 in this example). This allows a project to build against the same versions of the compiler on different machines.</source>
          <target state="translated">プロジェクトファイルの &lt;code&gt;&amp;lt;TypeScriptToolsVersion&amp;gt;1.7&amp;lt;/TypeScriptToolsVersion&amp;gt;&lt;/code&gt; プロパティの値は、ビルドに使用するコンパイラのバージョンを識別します（この例では1.7）。これにより、プロジェクトは異なるマシン上の同じバージョンのコンパイラーに対してビルドできます。</target>
        </trans-unit>
        <trans-unit id="7e5b2230b8d43ad8c0d99ac55f3f3b2a5f049234" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;extends&lt;/code&gt; must be a string containing a path to another configuration file to inherit from.</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; の値は、継承元の別の構成ファイルへのパスを含む文字列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="23c080d1f546c832664165ecef0024de9c538ba4" translate="yes" xml:space="preserve">
          <source>The variables don&amp;rsquo;t necessarily need to both be block-scoped for TypeScript to tell us that there&amp;rsquo;s a problem.</source>
          <target state="translated">TypeScriptが問題があることを通知するために、変数の両方を必ずしもブロックスコープにする必要はありません。</target>
        </trans-unit>
        <trans-unit id="0cd2fcb1497f2a79b74d282146de3e0947778826" translate="yes" xml:space="preserve">
          <source>The visibility rules for merged members is the same as described in the &amp;lsquo;Merging Namespaces&amp;rsquo; section, so we must export the &lt;code&gt;AlbumLabel&lt;/code&gt; class for the merged class to see it. The end result is a class managed inside of another class. You can also use namespaces to add more static members to an existing class.</source>
          <target state="translated">マージされたメンバーの可視性ルールは、「名前空間のマージ」セクションで説明されているものと同じであるため、マージされたクラスがそれを表示するには、 &lt;code&gt;AlbumLabel&lt;/code&gt; クラスをエクスポートする必要があります。最終結果は、別のクラス内で管理されるクラスです。名前空間を使用して、既存のクラスに静的メンバーを追加することもできます。</target>
        </trans-unit>
        <trans-unit id="ea042e37fe3dfdb85a33f2ea55e58e9f6f78eed8" translate="yes" xml:space="preserve">
          <source>The watching of directory on platforms that don&amp;rsquo;t support recursive directory watching natively in node, is supported through recursively creating directory watcher for the child directories using different options selected by &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;. Note that on platforms that support native recursive directory watching (e.g windows) the value of this environment variable is ignored.</source>
          <target state="translated">&lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt; で選択されたさまざまなオプションを使用して子ディレクトリのディレクトリウォッチャーを再帰的に作成することで、ノードでの再帰的なディレクトリウォッチングをサポートしないプラットフォームでのディレクトリのウォッチングがサポートされます。ネイティブの再帰的ディレクトリ監視をサポートするプラットフォーム（Windowsなど）では、この環境変数の値は無視されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4068ca96cef50a182f0293c35312e884e5d6ce44" translate="yes" xml:space="preserve">
          <source>The way that TypeScript decides on whether a version of the compiler &amp;amp; language matches is by using Node&amp;rsquo;s &lt;a href=&quot;https://github.com/npm/node-semver#ranges&quot;&gt;semver ranges&lt;/a&gt;.</source>
          <target state="translated">TypeScriptがコンパイラと言語のバージョンが一致するかどうかを判断する方法は、Nodeの&lt;a href=&quot;https://github.com/npm/node-semver#ranges&quot;&gt;サーバー範囲&lt;/a&gt;を使用することです。</target>
        </trans-unit>
        <trans-unit id="d504e46325644ee193380b78759d039584245b76" translate="yes" xml:space="preserve">
          <source>The way that this works is that when using &lt;code&gt;allowJs&lt;/code&gt;, TypeScript has some best-effort analyses to understand common JavaScript patterns; however, the way that some patterns are expressed in JavaScript don&amp;rsquo;t necessarily look like their equivalents in TypeScript. When &lt;code&gt;declaration&lt;/code&gt; emit is turned on, TypeScript figures out the best way to transform JSDoc comments and CommonJS exports into valid type declarations and the like in the output &lt;code&gt;.d.ts&lt;/code&gt; files.</source>
          <target state="translated">これが機能する方法は、 &lt;code&gt;allowJs&lt;/code&gt; を使用する場合、TypeScriptには一般的なJavaScriptパターンを理解するためのベストエフォート分析がいくつかあるということです。ただし、一部のパターンがJavaScriptで表現される方法は、TypeScriptでの同等のパターンに必ずしも似ているとは限りません。ときに &lt;code&gt;declaration&lt;/code&gt; EMITがオンになっている、活字体は、出力のように、有効な型宣言とにJSDocのコメントとCommonJSの輸出を変換するための最良の方法割り出し &lt;code&gt;.d.ts&lt;/code&gt; ファイルを。</target>
        </trans-unit>
        <trans-unit id="35913a132bcc3df8c56386f24253f0774dc172fa" translate="yes" xml:space="preserve">
          <source>Then consumed it:</source>
          <target state="translated">そして、それを消費した。</target>
        </trans-unit>
        <trans-unit id="47406e9f2861c5bd5131ac98ebd0257179f53e80" translate="yes" xml:space="preserve">
          <source>Then install &lt;code&gt;typescript&lt;/code&gt;, &lt;code&gt;gulp&lt;/code&gt; and &lt;code&gt;gulp-typescript&lt;/code&gt; in your project&amp;rsquo;s dev dependencies. &lt;a href=&quot;https://www.npmjs.com/package/gulp-typescript&quot;&gt;Gulp-typescript&lt;/a&gt; is a gulp plugin for Typescript.</source>
          <target state="translated">次に、プロジェクトの開発依存関係に &lt;code&gt;typescript&lt;/code&gt; 、 &lt;code&gt;gulp&lt;/code&gt; 、 &lt;code&gt;gulp-typescript&lt;/code&gt; をインストールします。&lt;a href=&quot;https://www.npmjs.com/package/gulp-typescript&quot;&gt;Gulp-typescript&lt;/a&gt;はTypescriptのgulpプラグインです。</target>
        </trans-unit>
        <trans-unit id="642ddc2143630564f6b4e561a7568f47369559e5" translate="yes" xml:space="preserve">
          <source>Then the &lt;code&gt;food&lt;/code&gt; property in &lt;code&gt;defaults&lt;/code&gt; overwrites &lt;code&gt;food: &quot;rich&quot;&lt;/code&gt;, which is not what we want in this case.</source>
          <target state="translated">次に、 &lt;code&gt;defaults&lt;/code&gt; の &lt;code&gt;food&lt;/code&gt; プロパティは &lt;code&gt;food: &quot;rich&quot;&lt;/code&gt; 上書きします。これは、この場合は必要ありません。</target>
        </trans-unit>
        <trans-unit id="de093b53d785ff2bef7478f5b3a5ab97f6181f86" translate="yes" xml:space="preserve">
          <source>Then, given a type &lt;code&gt;T''&lt;/code&gt; that is an instantiation of &lt;code&gt;T&lt;/code&gt; where all &lt;code&gt;infer&lt;/code&gt; type variables are replaced with the types inferred in the previous step, if &lt;code&gt;T''&lt;/code&gt; is &lt;em&gt;definitely assignable&lt;/em&gt; to &lt;code&gt;U&lt;/code&gt;, the conditional type is resolved to &lt;code&gt;X&lt;/code&gt;. The definitely assignable relation is the same as the regular assignable relation, except that type variable constraints are not considered. Intuitively, when a type is definitely assignable to another type, we know that it will be assignable for &lt;em&gt;all instantiations&lt;/em&gt; of those types.</source>
          <target state="translated">次いで、タイプ所与の &lt;code&gt;T''&lt;/code&gt; のインスタンスである &lt;code&gt;T&lt;/code&gt; すべての &lt;code&gt;infer&lt;/code&gt; 場合は型変数は、前のステップで推論タイプに置き換えられ、 &lt;code&gt;T''&lt;/code&gt; ある&lt;em&gt;確かに割り当て可能&lt;/em&gt;に &lt;code&gt;U&lt;/code&gt; 、条件タイプがに解決されている &lt;code&gt;X&lt;/code&gt; 。確実に割り当て可能な関係は、型変数の制約が考慮されないことを除いて、通常の割り当て可能な関係と同じです。直感的に、あるタイプが別のタイプに確実に割り当て可能である場合、それらのタイプの&lt;em&gt;すべてのインスタンス化&lt;/em&gt;に割り当て可能であることがわかります。</target>
        </trans-unit>
        <trans-unit id="177fd68b346fbae5c87bdcc2142e9f97d5a264b8" translate="yes" xml:space="preserve">
          <source>Then, you need to remember to give a default for optional properties on the destructured property instead of the main initializer. Remember that &lt;code&gt;C&lt;/code&gt; was defined with &lt;code&gt;b&lt;/code&gt; optional:</source>
          <target state="translated">次に、メインの初期化子ではなく、分解されたプロパティのオプションプロパティにデフォルトを指定することを忘れないでください。 &lt;code&gt;C&lt;/code&gt; は &lt;code&gt;b&lt;/code&gt; オプションで定義されたことを思い出してください：</target>
        </trans-unit>
        <trans-unit id="b08559581092c2fc068a4a49c020c235194dda9a" translate="yes" xml:space="preserve">
          <source>There are also some flags specific to &lt;code&gt;tsc -b&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tsc -b&lt;/code&gt; に固有のいくつかのフラグもあります。</target>
        </trans-unit>
        <trans-unit id="0d87487c8a7e09831fbc5025d0ad575e1d950bdf" translate="yes" xml:space="preserve">
          <source>There are basically three changes here, but they require you to refactor your code a bit.</source>
          <target state="translated">ここでは基本的に3つの変更点がありますが、コードを少しリファクタリングする必要があります。</target>
        </trans-unit>
        <trans-unit id="e6857c6b00d742af1ee133bd685d46d5cba15dc1" translate="yes" xml:space="preserve">
          <source>There are certain cases where TypeScript can&amp;rsquo;t figure out what certain types should be. To be as lenient as possible, it will decide to use the type &lt;code&gt;any&lt;/code&gt; in its place. While this is great for migration, using &lt;code&gt;any&lt;/code&gt; means that you&amp;rsquo;re not getting any type safety, and you won&amp;rsquo;t get the same tooling support you&amp;rsquo;d get elsewhere. You can tell TypeScript to flag these locations down and give an error with the &lt;code&gt;noImplicitAny&lt;/code&gt; option.</source>
          <target state="translated">TypeScriptが特定の型がどうあるべきかを理解できない場合があります。可能な限り寛大にするために、代わりに &lt;code&gt;any&lt;/code&gt; 型を使用することにします。これは移行に最適ですが、 &lt;code&gt;any&lt;/code&gt; 方法を使用しても型の安全性が得られず、他の場所で得られるのと同じツールのサポートを受けられません。TypeScriptにこれらの場所にフラグを立て、 &lt;code&gt;noImplicitAny&lt;/code&gt; オプションでエラーを出すように指示できます。</target>
        </trans-unit>
        <trans-unit id="cf3ad7a163a01d342f3e2b293eed57c09a62514b" translate="yes" xml:space="preserve">
          <source>There are certain scenarios where properties can be initialized indirectly (perhaps by a helper method or dependency injection library), in which case you can use the new &lt;em&gt;definite assignment assertion modifiers&lt;/em&gt; for your properties (discussed below).</source>
          <target state="translated">（おそらくヘルパーメソッドまたは依存関係注入ライブラリによって）プロパティを間接的に初期化できる特定のシナリオがあります。その場合、プロパティに新しい&lt;em&gt;明確な割り当てアサーション修飾子&lt;/em&gt;を使用できます（以下で説明します）。</target>
        </trans-unit>
        <trans-unit id="d8e46f31896dc086f90c6f67b6510c59fb5bf434" translate="yes" xml:space="preserve">
          <source>There are several kinds of dependencies your library might have. This section shows how to import them into the declaration file.</source>
          <target state="translated">ライブラリにはいくつかの種類の依存関係があります。このセクションでは、それらを宣言ファイルにインポートする方法を示します。</target>
        </trans-unit>
        <trans-unit id="f50947aa96622ea69cd6de3461bbbc3baf551e2b" translate="yes" xml:space="preserve">
          <source>There are three templates available for modules, &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;templates/module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;templates/module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">モジュールで使用可能な3つのテンプレートがあり&lt;a href=&quot;templates/module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;templates/module-class-d-ts&quot;&gt; &lt;code&gt;module-class.d.ts&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;templates/module-function-d-ts&quot;&gt; &lt;code&gt;module-function.d.ts&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af6a54de55d95dc1fa9a970327164b2697b39938" translate="yes" xml:space="preserve">
          <source>There are two main ways to get the TypeScript tools:</source>
          <target state="translated">TypeScriptツールを取得する方法は主に2つあります。</target>
        </trans-unit>
        <trans-unit id="f51afbc91104b11fd815c5a998b7fab8086c5610" translate="yes" xml:space="preserve">
          <source>There are two packages:</source>
          <target state="translated">パッケージは2つあります。</target>
        </trans-unit>
        <trans-unit id="b8b3a9273fe6c950960b5b0a5f42744f3ece318c" translate="yes" xml:space="preserve">
          <source>There are two possible module resolution strategies: &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; and &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt;. You can use the &lt;code&gt;--moduleResolution&lt;/code&gt; flag to specify the module resolution strategy. If not specified, the default is &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; for &lt;code&gt;--module AMD | System | ES2015&lt;/code&gt; or &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; otherwise.</source>
          <target state="translated">2つの可能なモジュール解決戦略があります。&lt;a href=&quot;#node&quot;&gt;ノード&lt;/a&gt;と&lt;a href=&quot;#classic&quot;&gt;クラシック&lt;/a&gt;です。 &lt;code&gt;--moduleResolution&lt;/code&gt; フラグを使用して、モジュール解決戦略を指定できます。指定しない場合、デフォルトは &lt;code&gt;--module AMD | System | ES2015&lt;/code&gt; &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt;です。システム|それ以外の場合はES2015または&lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d037836fd5889368e676cf82d021109751703c9" translate="yes" xml:space="preserve">
          <source>There are two types of supported index signatures: string and number. It is possible to support both types of indexers, but the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with a &lt;code&gt;number&lt;/code&gt;, JavaScript will actually convert that to a &lt;code&gt;string&lt;/code&gt; before indexing into an object. That means that indexing with &lt;code&gt;100&lt;/code&gt; (a &lt;code&gt;number&lt;/code&gt;) is the same thing as indexing with &lt;code&gt;&quot;100&quot;&lt;/code&gt; (a &lt;code&gt;string&lt;/code&gt;), so the two need to be consistent.</source>
          <target state="translated">サポートされるインデックスシグネチャには、文字列と数値の2つのタイプがあります。両方のタイプのインデクサーをサポートすることは可能ですが、数値インデクサーから返されるタイプは、文字列インデクサーから返されるタイプのサブタイプである必要があります。これは、 &lt;code&gt;number&lt;/code&gt; を使用してインデックスを作成する場合、JavaScriptは実際にそれを &lt;code&gt;string&lt;/code&gt; に変換してからオブジェクトにインデックスを作成するためです。つまり、 &lt;code&gt;100&lt;/code&gt; （ &lt;code&gt;number&lt;/code&gt; ）を使用したインデックス作成は、 &lt;code&gt;&quot;100&quot;&lt;/code&gt; （ &lt;code&gt;string&lt;/code&gt; ）を使用したインデックス作成と同じであるため、2つを一致させる必要があります。</target>
        </trans-unit>
        <trans-unit id="908cd031750feb81ec4d9c9d32a60c943d9995ba" translate="yes" xml:space="preserve">
          <source>There are two ways to define a value-based element:</source>
          <target state="translated">価値ベースの要素を定義するには、2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="26e25b640ababcffdfc4b06e185fa3e5e4e7f32b" translate="yes" xml:space="preserve">
          <source>There are two ways to do this. The first is to turn on &lt;code&gt;--strictNullChecks&lt;/code&gt; and specify a return type:</source>
          <target state="translated">これを行うには2つの方法があります。1つ目は、 &lt;code&gt;--strictNullChecks&lt;/code&gt; をオンにして、戻り値の型を指定することです。</target>
        </trans-unit>
        <trans-unit id="e7659fe4cc582ed4ad5cee6a5865f3aed8b3f631" translate="yes" xml:space="preserve">
          <source>There is a special subset of constant enum members that aren&amp;rsquo;t calculated: literal enum members. A literal enum member is a constant enum member with no initialized value, or with values that are initialized to</source>
          <target state="translated">計算されない定数列挙型メンバーの特別なサブセットがあります。リテラル列挙型メンバーです。リテラルenumメンバーは、初期化された値がない、または初期化された値を持つ定数enumメンバーです</target>
        </trans-unit>
        <trans-unit id="b3c75a37225472b5122690bb8c7852d356bbe63d" translate="yes" xml:space="preserve">
          <source>There is a well defined order to how decorators applied to various declarations inside of a class are applied:</source>
          <target state="translated">クラス内の様々な宣言に適用されるデコレータがどのように適用されるかについては、よく定義された順序があります。</target>
        </trans-unit>
        <trans-unit id="9b776dda290c6f5398f6b0885c60c8e056b32045" translate="yes" xml:space="preserve">
          <source>There is no template for &lt;code&gt;tsconfig.json&lt;/code&gt; in most project types.</source>
          <target state="translated">ほとんどのプロジェクトタイプには、 &lt;code&gt;tsconfig.json&lt;/code&gt; のテンプレートはありません。</target>
        </trans-unit>
        <trans-unit id="8504a07cb4ffd55d7fe6fdeea5cee63d290fd3d8" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a specific set of functions that &lt;code&gt;throw&lt;/code&gt; an error if something unexpected happened. They&amp;rsquo;re called &amp;ldquo;assertion&amp;rdquo; functions. As an example, Node.js has a dedicated function for this called &lt;code&gt;assert&lt;/code&gt;.</source>
          <target state="translated">予期しないことが起こった場合にエラーを &lt;code&gt;throw&lt;/code&gt; する特定の関数セットがあります。これらは「アサーション」関数と呼ばれます。例として、Node.jsには、 &lt;code&gt;assert&lt;/code&gt; と呼ばれるこれ専用の関数があります。</target>
        </trans-unit>
        <trans-unit id="6ea7b067283b1800f3cf1697d8801fcd2967972e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also &lt;em&gt;optional call&lt;/em&gt;, which allows us to conditionally call expressions if they&amp;rsquo;re not &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;オプションのcall&lt;/em&gt;もあり&lt;em&gt;ます&lt;/em&gt;。これにより、式が &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; でない場合に条件付きで呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="45675102fd5d070224d9ebb4b617e2cd2622b44e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no built-in up-to-date checking, so you end up always running &lt;code&gt;tsc&lt;/code&gt; twice</source>
          <target state="translated">組み込みの最新のチェック機能がないため、最終的には常に &lt;code&gt;tsc&lt;/code&gt; を 2回実行することになります</target>
        </trans-unit>
        <trans-unit id="d45edf5a42ca019d0d64af47b3ea8fd1b0b8bcb9" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;.tsbuildinfo&lt;/code&gt; files can be safely deleted and don&amp;rsquo;t have any impact on our code at runtime - they&amp;rsquo;re purely used to make compilations faster. We can also name them anything that we want, and place them anywhere we want using the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target state="translated">これらの &lt;code&gt;.tsbuildinfo&lt;/code&gt; ファイルは安全に削除でき、実行時にコードに影響を与えません。これらは純粋にコンパイルを高速化するために使用されます。また、任意の名前を付け、 &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; フラグを使用して任意の場所に配置することもできます。</target>
        </trans-unit>
        <trans-unit id="79dc017ea8ee6bb3f7c9fc491544134c877f20d3" translate="yes" xml:space="preserve">
          <source>These &lt;em&gt;&lt;code&gt;typeof&lt;/code&gt; type guards&lt;/em&gt; are recognized in two different forms: &lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; and &lt;code&gt;typeof v !== &quot;typename&quot;&lt;/code&gt;, where &lt;code&gt;&quot;typename&quot;&lt;/code&gt; must be &lt;code&gt;&quot;number&quot;&lt;/code&gt;, &lt;code&gt;&quot;string&quot;&lt;/code&gt;, &lt;code&gt;&quot;boolean&quot;&lt;/code&gt;, or &lt;code&gt;&quot;symbol&quot;&lt;/code&gt;. While TypeScript won&amp;rsquo;t stop you from comparing to other strings, the language won&amp;rsquo;t recognize those expressions as type guards.</source>
          <target state="translated">これらの&lt;em&gt; &lt;code&gt;typeof&lt;/code&gt; タイプガード&lt;/em&gt;は、 &lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; と &lt;code&gt;typeof v !== &quot;typename&quot;&lt;/code&gt; 2つの異なる形式で認識されます。ここで、 &lt;code&gt;&quot;typename&quot;&lt;/code&gt; は &lt;code&gt;&quot;number&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;string&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;boolean&quot;&lt;/code&gt; 、または &lt;code&gt;&quot;symbol&quot;&lt;/code&gt; &quot;である必要があります&quot;。TypeScriptは他の文字列との比較を妨げませんが、言語はそれらの式をタイプガードとして認識しません。</target>
        </trans-unit>
        <trans-unit id="c89cac30c0863c54c7e154b255e1a2a8a10af609" translate="yes" xml:space="preserve">
          <source>These are seldom written explicitly, but they can be useful when narrowing issues and can catch bugs:</source>
          <target state="translated">これらは明示的に書かれることはほとんどありませんが、課題を絞るときに便利ですし、バグをキャッチすることもできます。</target>
        </trans-unit>
        <trans-unit id="dae12b77565aa4d0e3a64c99a87302ba66d61702" translate="yes" xml:space="preserve">
          <source>These assertion signatures are very similar to writing type predicate signatures:</source>
          <target state="translated">これらのアサーション署名は、型述語署名を書くのと非常に似ています。</target>
        </trans-unit>
        <trans-unit id="2868190107b9e856775b903db102ff1ea2bbe264" translate="yes" xml:space="preserve">
          <source>These could be imported as</source>
          <target state="translated">これらは、以下のようにインポートすることができます。</target>
        </trans-unit>
        <trans-unit id="580c6c93a64a3803a22f4ceb17224a9f774727aa" translate="yes" xml:space="preserve">
          <source>These examples are ordered in approximately increasing order of complexity.</source>
          <target state="translated">これらの例は、およそ複雑度の高い順に並べられています。</target>
        </trans-unit>
        <trans-unit id="51753d058d70c80473068ff593cd4ffa3d3364fb" translate="yes" xml:space="preserve">
          <source>These options also persist when sharing links to playground samples, allowing users to more reliably share examples without having to tell the recipient &amp;ldquo;oh, don&amp;rsquo;t forget to turn on the &lt;code&gt;noImplicitAny&lt;/code&gt; option!&amp;rdquo;.</source>
          <target state="translated">これらのオプションは、プレイグラウンドサンプルへのリンクを共有するときにも保持されるため、ユーザーは受信者に「ああ、 &lt;code&gt;noImplicitAny&lt;/code&gt; オプションをオンにすることを忘れないでください！」と伝えなくても、サンプルをより確実に共有できます。</target>
        </trans-unit>
        <trans-unit id="405bb1f92dbe539fc19f70e7ed40ea0eb0528ce7" translate="yes" xml:space="preserve">
          <source>These scoping rules can cause several types of mistakes. One problem they exacerbate is the fact that it is not an error to declare the same variable multiple times:</source>
          <target state="translated">これらのスコーピングルールは、いくつかのタイプのミスを引き起こす可能性があります。これらが悪化させる問題の一つは、同じ変数を複数回宣言することはエラーではないという事実です。</target>
        </trans-unit>
        <trans-unit id="5d8c7bb7c664a99b3f99538dd86cbd5a15a993cd" translate="yes" xml:space="preserve">
          <source>They also serve as a method to order the output when using &lt;code&gt;--out&lt;/code&gt; or &lt;code&gt;--outFile&lt;/code&gt;. Files are emitted to the output file location in the same order as the input after preprocessing pass.</source>
          <target state="translated">彼らはまた、使用時に出力を注文する方法として役立つ &lt;code&gt;--out&lt;/code&gt; または &lt;code&gt;--outFile&lt;/code&gt; 。ファイルは、前処理パスの後、入力と同じ順序で出力ファイルの場所に出力されます。</target>
        </trans-unit>
        <trans-unit id="a1ff8d1f085eb2bf495023df7ad3553e1c32cab7" translate="yes" xml:space="preserve">
          <source>They also support replacing the &lt;code&gt;exports&lt;/code&gt; object with a custom single object. Default exports are meant to act as a replacement for this behavior; however, the two are incompatible. TypeScript supports &lt;code&gt;export =&lt;/code&gt; to model the traditional CommonJS and AMD workflow.</source>
          <target state="translated">また、 &lt;code&gt;exports&lt;/code&gt; オブジェクトをカスタムの単一オブジェクトに置き換えることもできます。デフォルトのエクスポートは、この動作の代わりとして機能することを意図しています。ただし、2つは互換性がありません。TypeScriptは &lt;code&gt;export =&lt;/code&gt; をサポートし、従来のCommonJSおよびAMDワークフローをモデル化します。</target>
        </trans-unit>
        <trans-unit id="7e47c0cafef6daabbdf34e9389714c2f70664891" translate="yes" xml:space="preserve">
          <source>They are like &lt;code&gt;let&lt;/code&gt; declarations but, as their name implies, their value cannot be changed once they are bound. In other words, they have the same scoping rules as &lt;code&gt;let&lt;/code&gt;, but you can&amp;rsquo;t re-assign to them.</source>
          <target state="translated">それらは &lt;code&gt;let&lt;/code&gt; 宣言に似ていますが、その名前が示すように、いったんバインドされるとその値は変更できません。言い換えると、それらには &lt;code&gt;let&lt;/code&gt; と同じスコープ規則がありますが、それらに再割り当てすることはできません。</target>
        </trans-unit>
        <trans-unit id="269cb00928fdbd9243a3c0e9855fdf73711ca39b" translate="yes" xml:space="preserve">
          <source>They will rarely have:</source>
          <target state="translated">彼らはほとんど持っていないでしょう。</target>
        </trans-unit>
        <trans-unit id="940ca9be4b3687b9409fbf0f5e6bf12d6da31f65" translate="yes" xml:space="preserve">
          <source>Things to look out for</source>
          <target state="translated">気をつけたいこと</target>
        </trans-unit>
        <trans-unit id="aba97e7fae57c949d932eff408211c64dbd34e1b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;package.json&lt;/code&gt; tells TypeScript to check whether the current version of TypeScript is running. If it&amp;rsquo;s 3.1 or later, it figures out the path you&amp;rsquo;ve imported relative to the package, and reads from the package&amp;rsquo;s &lt;code&gt;ts3.1&lt;/code&gt; folder. That&amp;rsquo;s what that &lt;code&gt;{ &quot;*&quot;: [&quot;ts3.1/*&quot;] }&lt;/code&gt; means - if you&amp;rsquo;re familiar with path mapping today, it works exactly like that.</source>
          <target state="translated">この &lt;code&gt;package.json&lt;/code&gt; は、TypeScriptに、現在のバージョンのTypeScriptが実行されているかどうかを確認するように指示します。それが3.1以降の場合、インポートしたパスはパッケージからの相対パスであり、パッケージの &lt;code&gt;ts3.1&lt;/code&gt; フォルダーから読み取ります。これが &lt;code&gt;{ &quot;*&quot;: [&quot;ts3.1/*&quot;] }&lt;/code&gt; 意味です。今日のパスマッピングに精通している場合は、まったく同じように機能します。</target>
        </trans-unit>
        <trans-unit id="9579349a7f6081ccc0cfa7ee1c3ba7cecdaeb554" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;tsconfig.json&lt;/code&gt; file will &lt;em&gt;only&lt;/em&gt; include &lt;code&gt;./node_modules/@types/node&lt;/code&gt;, &lt;code&gt;./node_modules/@types/lodash&lt;/code&gt; and &lt;code&gt;./node_modules/@types/express&lt;/code&gt;. Other packages under &lt;code&gt;node_modules/@types/*&lt;/code&gt; will not be included.</source>
          <target state="translated">この &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルには、. &lt;code&gt;./node_modules/@types/lodash&lt;/code&gt; / &lt;code&gt;./node_modules/@types/express&lt;/code&gt; types / node、 . /node_modules / @ &lt;code&gt;./node_modules/@types/node&lt;/code&gt; / lodashおよび./node_modules/@types/express &lt;em&gt;のみが&lt;/em&gt;含まれます。 &lt;code&gt;node_modules/@types/*&lt;/code&gt; 下の他のパッケージは含まれません。</target>
        </trans-unit>
        <trans-unit id="3d382992de7bc0c7358c5e70b64fbab9df6f3d2b" translate="yes" xml:space="preserve">
          <source>This adds the &lt;code&gt;copy-html&lt;/code&gt; task and adds it as a dependency of &lt;code&gt;default&lt;/code&gt;. That means any time &lt;code&gt;default&lt;/code&gt; is run, &lt;code&gt;copy-html&lt;/code&gt; has to run first. We&amp;rsquo;ve also changed &lt;code&gt;default&lt;/code&gt; to call Browserify with the tsify plugin instead of gulp-typescript. Conveniently, they both allow us to pass the same options object to the TypeScript compiler.</source>
          <target state="translated">これにより、 &lt;code&gt;copy-html&lt;/code&gt; タスクが追加され、 &lt;code&gt;default&lt;/code&gt; の依存関係として追加されます。つまり、 &lt;code&gt;default&lt;/code&gt; が実行されるときは常に、 &lt;code&gt;copy-html&lt;/code&gt; が最初に実行される必要があります。また、gulp-typescriptの代わりにtsifyプラグインを使用してBrowserifyを呼び出すように &lt;code&gt;default&lt;/code&gt; を変更しました。便利なことに、どちらも同じオプションオブジェクトをTypeScriptコンパイラに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="11d95bac2d09fc97059fde1a2be78410f1aaaa65" translate="yes" xml:space="preserve">
          <source>This also applies to numeric and string literals.</source>
          <target state="translated">これは、数値リテラルや文字列リテラルにも適用されます。</target>
        </trans-unit>
        <trans-unit id="adfedec845a057971771ae75a777e3b399a6fbc9" translate="yes" xml:space="preserve">
          <source>This also works in JSDoc comments to refer to types from other modules in &lt;code&gt;.js&lt;/code&gt;:</source>
          <target state="translated">これはJSDocコメントでも機能し、 &lt;code&gt;.js&lt;/code&gt; の他のモジュールの型を参照します。</target>
        </trans-unit>
        <trans-unit id="a19ba44e9cf17a28dc6b2832d656e62612a977fa" translate="yes" xml:space="preserve">
          <source>This also works with classes:</source>
          <target state="translated">これはクラスでも通用します。</target>
        </trans-unit>
        <trans-unit id="7a7e8768f821cc2763fea56792bd65a0c49d075d" translate="yes" xml:space="preserve">
          <source>This asserts the variable &lt;code&gt;bar&lt;/code&gt; to have the type &lt;code&gt;foo&lt;/code&gt;. Since TypeScript also uses angle brackets for type assertions, combining it with JSX&amp;rsquo;s syntax would introduce certain parsing difficulties. As a result, TypeScript disallows angle bracket type assertions in &lt;code&gt;.tsx&lt;/code&gt; files.</source>
          <target state="translated">これは、変数 &lt;code&gt;bar&lt;/code&gt; がタイプ &lt;code&gt;foo&lt;/code&gt; を持つことを表明します。TypeScriptもタイプアサーションに山かっこを使用するため、JSXの構文と組み合わせると特定の解析が困難になります。その結果、TypeScriptは &lt;code&gt;.tsx&lt;/code&gt; ファイルで山かっこ型のアサーションを許可しません。</target>
        </trans-unit>
        <trans-unit id="123d0f06d6b292d7403ffa347023235e01b1d1ba" translate="yes" xml:space="preserve">
          <source>This can be used to pipe output between commands as well.</source>
          <target state="translated">これは、コマンド間の出力をパイプするためにも使用できます。</target>
        </trans-unit>
        <trans-unit id="f4889f2abe4cb3d690ec344d9cb1060645946ee3" translate="yes" xml:space="preserve">
          <source>This can cause quite a bit of fallout for existing code that use inheritance. First of all, &lt;code&gt;set&lt;/code&gt; accessors from base classes won&amp;rsquo;t get triggered - they&amp;rsquo;ll be completely overwritten.</source>
          <target state="translated">これは、継承を使用する既存のコードにかなりの影響を与える可能性があります。まず、基本クラスからの &lt;code&gt;set&lt;/code&gt; アクセサーはトリガーされません-完全に上書きされます。</target>
        </trans-unit>
        <trans-unit id="2cf2abd7a18f1f7062668c3033dddcc6ad2c2d8e" translate="yes" xml:space="preserve">
          <source>This can even be used to enable &lt;code&gt;enum&lt;/code&gt;-like patterns in plain JavaScript code if you choose not to use TypeScript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt; construct.</source>
          <target state="translated">TypeScriptの &lt;code&gt;enum&lt;/code&gt; コンストラクトを使用しないことを選択した場合、これを使用して、プレーンJavaScriptコードで &lt;code&gt;enum&lt;/code&gt; のようなパターンを有効にすることもできます。</target>
        </trans-unit>
        <trans-unit id="13a6f89fe3172b6cbc2af9517a59da3931faf315" translate="yes" xml:space="preserve">
          <source>This can go beyond basic functions with &lt;code&gt;@param&lt;/code&gt; tags too, where the following example:</source>
          <target state="translated">これは、 &lt;code&gt;@param&lt;/code&gt; タグを使用した基本的な関数だけでなく、次の例でも使用できます。</target>
        </trans-unit>
        <trans-unit id="40d488fa879599b4c63bd3bca5b46fe16933b383" translate="yes" xml:space="preserve">
          <source>This change entails a break in the behavior of extending built-in classes like &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc.. Please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-changes.html#extending-built-ins-like-error-array-and-map-may-no-longer-work&quot;&gt;extending built-ins breaking change documentation&lt;/a&gt; for more details.</source>
          <target state="translated">この変更により、 &lt;code&gt;Error&lt;/code&gt; 、 &lt;code&gt;Array&lt;/code&gt; 、 &lt;code&gt;Map&lt;/code&gt; などの組み込みクラスを拡張する動作が壊れます。詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-changes.html#extending-built-ins-like-error-array-and-map-may-no-longer-work&quot;&gt;組み込み&lt;/a&gt;の拡張機能を壊す変更のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="0a82b6976a332dfa14dda6dd898339b3d9c8f2c3" translate="yes" xml:space="preserve">
          <source>This check is a breaking change, but for that reason the checks are very conservative. This error is only issued in &lt;code&gt;if&lt;/code&gt; conditions, and it is not issued on optional properties, if &lt;code&gt;strictNullChecks&lt;/code&gt; is off, or if the function is later called within the body of the &lt;code&gt;if&lt;/code&gt;:</source>
          <target state="translated">このチェックは重大な変更ですが、そのため、チェックは非常に保守的です。このエラーはのみで発行された &lt;code&gt;if&lt;/code&gt; の条件、それはオプションのプロパティで発行されていない、場合 &lt;code&gt;strictNullChecks&lt;/code&gt; がオフになっている、または機能が後の本体内で呼び出された場合 &lt;code&gt;if&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="776023497afd78ba896c5a8759ad07ba14168072" translate="yes" xml:space="preserve">
          <source>This comparison process proceeds recursively, exploring the type of each member and sub-member.</source>
          <target state="translated">この比較処理は、各メンバーとサブメンバーの種類を探りながら、再帰的に進行する。</target>
        </trans-unit>
        <trans-unit id="a70378c4e2e85fc0285bab20719f721947598d23" translate="yes" xml:space="preserve">
          <source>This config file will include &lt;em&gt;all&lt;/em&gt; packages under &lt;code&gt;./typings&lt;/code&gt;, and no packages from &lt;code&gt;./node_modules/@types&lt;/code&gt;.</source>
          <target state="translated">この設定ファイルには含まれています&lt;em&gt;すべて&lt;/em&gt;の下のパッケージ &lt;code&gt;./typings&lt;/code&gt; から、ノーパッケージを &lt;code&gt;./node_modules/@types&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d8fdc1796e3b4fc005d6e6e0a36a51b7eee8ba1" translate="yes" xml:space="preserve">
          <source>This creates a &lt;code&gt;package.json&lt;/code&gt; file with default values.</source>
          <target state="translated">これにより、デフォルト値を含む &lt;code&gt;package.json&lt;/code&gt; ファイルが作成されます。</target>
        </trans-unit>
        <trans-unit id="2651ac880cf2ead1dcccdb902c01397e29e5f2d0" translate="yes" xml:space="preserve">
          <source>This creates new variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from &lt;code&gt;o.a&lt;/code&gt; and &lt;code&gt;o.b&lt;/code&gt;. Notice that you can skip &lt;code&gt;c&lt;/code&gt; if you don&amp;rsquo;t need it.</source>
          <target state="translated">これにより、 &lt;code&gt;o.a&lt;/code&gt; および &lt;code&gt;o.b&lt;/code&gt; から新しい変数 &lt;code&gt;a&lt;/code&gt; および &lt;code&gt;b&lt;/code&gt; が作成されます。必要ない場合は、 &lt;code&gt;c&lt;/code&gt; をスキップできることに注意してください。</target>
        </trans-unit>
        <trans-unit id="cbec995fccd02fc21b46f9fd4af298cd4d2053ad" translate="yes" xml:space="preserve">
          <source>This creates two new variables named &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. This is equivalent to using indexing, but is much more convenient:</source>
          <target state="translated">これにより、 &lt;code&gt;first&lt;/code&gt; および &lt;code&gt;second&lt;/code&gt; という名前の2つの新しい変数が作成されます。これはインデックスを使用するのと同じですが、はるかに便利です。</target>
        </trans-unit>
        <trans-unit id="c3290579796b51867665bf805e46b6cb71dde74e" translate="yes" xml:space="preserve">
          <source>This directive allows a file to explicitly include an existing built-in &lt;em&gt;lib&lt;/em&gt; file.</source>
          <target state="translated">このディレクティブを使用すると、ファイルに既存の組み込み&lt;em&gt;lib&lt;/em&gt;ファイルを明示的に含めることができます。</target>
        </trans-unit>
        <trans-unit id="1a906b1f2cf088a2c6bf34b58e9c21658e73cc20" translate="yes" xml:space="preserve">
          <source>This directive instructs the compiler to &lt;em&gt;not&lt;/em&gt; include the default library (i.e. &lt;code&gt;lib.d.ts&lt;/code&gt;) in the compilation. The impact here is similar to passing &lt;code&gt;--noLib&lt;/code&gt; on the command line.</source>
          <target state="translated">このディレクティブは、デフォルトのライブラリー（つまり &lt;code&gt;lib.d.ts&lt;/code&gt; ）をコンパイルに含め&lt;em&gt;ない&lt;/em&gt;ようにコンパイラーに指示します。ここでの影響は、コマンドラインで &lt;code&gt;--noLib&lt;/code&gt; を渡すのと同じです。</target>
        </trans-unit>
        <trans-unit id="e85416c60d1e180f7e4e1a690b36612a078e4bd6" translate="yes" xml:space="preserve">
          <source>This directive marks a file as a &lt;em&gt;default library&lt;/em&gt;. You will see this comment at the top of &lt;code&gt;lib.d.ts&lt;/code&gt; and its different variants.</source>
          <target state="translated">このディレクティブは、ファイルを&lt;em&gt;デフォルトのライブラリ&lt;/em&gt;としてマークします。このコメントは &lt;code&gt;lib.d.ts&lt;/code&gt; とそのさまざまなバリアントの上部に表示されます。</target>
        </trans-unit>
        <trans-unit id="abd1b0ae2b28ffc07ff533b5aa3e34f0a7dbd996" translate="yes" xml:space="preserve">
          <source>This distinction is subtle and important &amp;ndash; here, &lt;code&gt;A.B&lt;/code&gt; is not necessarily a type or a value.</source>
          <target state="translated">この区別は微妙で重要です。ここでは、 &lt;code&gt;A.B&lt;/code&gt; は必ずしも型または値ではありません。</target>
        </trans-unit>
        <trans-unit id="1ff3a8b47ad881c651ae743e22e2477b1a56f987" translate="yes" xml:space="preserve">
          <source>This example covers a few other features we didn&amp;rsquo;t previously mention. Again, we see the &lt;code&gt;extends&lt;/code&gt; keywords used to create two new subclasses of &lt;code&gt;Animal&lt;/code&gt;: &lt;code&gt;Horse&lt;/code&gt; and &lt;code&gt;Snake&lt;/code&gt;.</source>
          <target state="translated">この例では、これまでに触れなかった他のいくつかの機能について説明します。ここでも、私たちは見 &lt;code&gt;extends&lt;/code&gt; の二つの新しいサブクラスを作成するために使用するキーワード &lt;code&gt;Animal&lt;/code&gt; ： &lt;code&gt;Horse&lt;/code&gt; と &lt;code&gt;Snake&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="151213ee16168c64e5b83bc91d8ae73927961489" translate="yes" xml:space="preserve">
          <source>This example shows the most basic inheritance feature: classes inherit properties and methods from base classes. Here, &lt;code&gt;Dog&lt;/code&gt; is a &lt;em&gt;derived&lt;/em&gt; class that derives from the &lt;code&gt;Animal&lt;/code&gt;&lt;em&gt;base&lt;/em&gt; class using the &lt;code&gt;extends&lt;/code&gt; keyword. Derived classes are often called &lt;em&gt;subclasses&lt;/em&gt;, and base classes are often called &lt;em&gt;superclasses&lt;/em&gt;.</source>
          <target state="translated">この例は、最も基本的な継承機能を示しています。クラスは、基本クラスからプロパティとメソッドを継承します。ここで、 &lt;code&gt;Dog&lt;/code&gt; は &lt;code&gt;extends&lt;/code&gt; キーワードを使用して &lt;code&gt;Animal&lt;/code&gt; &lt;em&gt;基本&lt;/em&gt;クラスから&lt;em&gt;派生し&lt;/em&gt;た&lt;em&gt;派生&lt;/em&gt;クラスです。派生クラスはしばしば&lt;em&gt;サブクラス&lt;/em&gt;と呼ばれ、基本クラスはしばしば&lt;em&gt;スーパークラス&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="80d233484614ac1a8184eec3cb1a1f5b233a8926" translate="yes" xml:space="preserve">
          <source>This feature can be extremely useful for bigger organizations, or projects with lots of distributed dependencies.</source>
          <target state="translated">この機能は、大規模な組織や、多くの分散依存関係を持つプロジェクトでは非常に便利です。</target>
        </trans-unit>
        <trans-unit id="145fabdb6e03da0d5218bdc18d27ee6b68f3aaae" translate="yes" xml:space="preserve">
          <source>This feature is currently supported in Visual Studio 2015 with TypeScript 1.8.4 and above, and &lt;a href=&quot;https://github.com/TypeStrong/atom-typescript#compile-on-save&quot;&gt;atom-typescript&lt;/a&gt; plugin.</source>
          <target state="translated">この機能は現在、Visual Studio 2015でTypeScript 1.8.4以降と&lt;a href=&quot;https://github.com/TypeStrong/atom-typescript#compile-on-save&quot;&gt;atom-typescript&lt;/a&gt;プラグインを使用してサポートされています。</target>
        </trans-unit>
        <trans-unit id="e14bf01780560294d3e709ab1eca2529b0526ee5" translate="yes" xml:space="preserve">
          <source>This feature means that types that would otherwise be used just to hint immutability to the compiler can often be omitted.</source>
          <target state="translated">この機能は、そうでなければコンパイラに不変性をほのめかすためだけに使用されていた型を省略できることが多いことを意味します。</target>
        </trans-unit>
        <trans-unit id="e0a1a44534d41eb6308a076407d6c354572ba0dd" translate="yes" xml:space="preserve">
          <source>This feature was supported before TypeScript 2.1, but only when targeting ES6/ES2015. TypeScript 2.1 brings the capability to ES3 and ES5 run-times, meaning you&amp;rsquo;ll be free to take advantage of it no matter what environment you&amp;rsquo;re using.</source>
          <target state="translated">この機能はTypeScript 2.1より前にサポートされていましたが、ES6 / ES2015を対象とする場合のみでした。TypeScript 2.1は、ES3およびES5ランタイムに機能を提供します。つまり、使用している環境に関係なく、それを自由に利用できます。</target>
        </trans-unit>
        <trans-unit id="4256b8036fc24344e27e1a2d98579274cc10c2e9" translate="yes" xml:space="preserve">
          <source>This gives bothPlus the value &lt;code&gt;[0, 1, 2, 3, 4, 5]&lt;/code&gt;. Spreading creates a shallow copy of &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. They are not changed by the spread.</source>
          <target state="translated">これにより、bothPlusに値 &lt;code&gt;[0, 1, 2, 3, 4, 5]&lt;/code&gt; 0、1、2、3、4、5]が与えられます。拡散すると、 &lt;code&gt;first&lt;/code&gt; と &lt;code&gt;second&lt;/code&gt; 浅いコピーが作成されます。スプレッドによって変更されることはありません。</target>
        </trans-unit>
        <trans-unit id="fe579196df9fee069d4bd852ac7c86cc2a13b998" translate="yes" xml:space="preserve">
          <source>This gives the user a way of describing inner classes.</source>
          <target state="translated">これにより、ユーザは内部クラスを記述する方法を得ることができます。</target>
        </trans-unit>
        <trans-unit id="386298615e90cceffaa57d2fad7dceaa3f784476" translate="yes" xml:space="preserve">
          <source>This guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.</source>
          <target state="translated">また、このガイダンスでは、宣言ファイルの利用者を壊すことなく、ライブラリをUMDに移行できるようにしています。</target>
        </trans-unit>
        <trans-unit id="c41bd8fce97e1f72ad86c3801d0c1855c4f2bfd0" translate="yes" xml:space="preserve">
          <source>This guide is designed to teach you how to write a high-quality TypeScript Declaration File.</source>
          <target state="translated">このガイドは、高品質なTypeScript宣言ファイルの書き方を教えることを目的としています。</target>
        </trans-unit>
        <trans-unit id="8afad13e48d5c317fc76b6fb0c7d091ef32c2108" translate="yes" xml:space="preserve">
          <source>This guide will teach you how to wire up TypeScript with &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; and &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;.</source>
          <target state="translated">このガイドでは、TypeScriptを&lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt;および&lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;と結び付ける方法について説明します。</target>
        </trans-unit>
        <trans-unit id="bb134067e9aa9299c18b8ce51100d390f03f98ca" translate="yes" xml:space="preserve">
          <source>This happens often enough in JavaScript that TypeScript provides a way to create new types based on old types &amp;mdash; &lt;strong&gt;mapped types&lt;/strong&gt;. In a mapped type, the new type transforms each property in the old type in the same way. For example, you can make all properties of a type &lt;code&gt;readonly&lt;/code&gt; or optional. Here are a couple of examples:</source>
          <target state="translated">これはJavaScriptで頻繁に発生し、TypeScriptは古い型に基づいて新しい型を作成する方法を提供します&amp;mdash; &lt;strong&gt;マップされた型&lt;/strong&gt;。マップされた型では、新しい型が古い型の各プロパティを同じ方法で変換します。たとえば、タイプのすべてのプロパティを &lt;code&gt;readonly&lt;/code&gt; またはオプションにすることができます。次に例をいくつか示します。</target>
        </trans-unit>
        <trans-unit id="a56075c1c437a8f7f7b75ea4c76282bd39cf7b1d" translate="yes" xml:space="preserve">
          <source>This has a very specific meaning: the &lt;code&gt;done&lt;/code&gt; callback might be invoked with 1 argument or might be invoked with 2 arguments. The author probably intended to say that the callback might not care about the &lt;code&gt;elapsedTime&lt;/code&gt; parameter, but there&amp;rsquo;s no need to make the parameter optional to accomplish this &amp;ndash; it&amp;rsquo;s always legal to provide a callback that accepts fewer arguments.</source>
          <target state="translated">これには非常に具体的な意味があります。 &lt;code&gt;done&lt;/code&gt; コールバックは1つの引数で呼び出される場合と、2つの引数で呼び出される場合があります。作成者はおそらく、コールバックが &lt;code&gt;elapsedTime&lt;/code&gt; パラメータを気にしないかもしれないと言うつもりでしたが、これを達成するためにパラメータをオプションにする必要はありません-より少ない引数を受け入れるコールバックを提供することは常に合法です。</target>
        </trans-unit>
        <trans-unit id="d47bf0bc67be092f1cae46d5237f049154597b89" translate="yes" xml:space="preserve">
          <source>This has been one common source of duplicate definition errors. Multiple declaration files defining the same members on interfaces.</source>
          <target state="translated">これは、重複した定義エラーの共通の原因の1つとなっています。インターフェース上で同じメンバを定義している複数の宣言ファイル。</target>
        </trans-unit>
        <trans-unit id="008c0c2cfe2dcafe3f531baa951507b0d1d186a6" translate="yes" xml:space="preserve">
          <source>This has the same problems we mentioned above - we could easily have misspelled &lt;code&gt;getDistance&lt;/code&gt; and not gotten an error. For this reason, TypeScript has the &lt;code&gt;noImplicitThis&lt;/code&gt; option. When that option is set, TypeScript will issue an error when &lt;code&gt;this&lt;/code&gt; is used without an explicit (or inferred) type. The fix is to use a &lt;code&gt;this&lt;/code&gt;-parameter to give an explicit type in the interface or in the function itself:</source>
          <target state="translated">これには、前述の問題と同じ問題があります &lt;code&gt;getDistance&lt;/code&gt; スペルを間違えても、エラーが発生することはありませんでした。このため、TypeScriptには &lt;code&gt;noImplicitThis&lt;/code&gt; オプションがあります。そのオプションが設定されている場合と、活字体はエラーを発行します &lt;code&gt;this&lt;/code&gt; 、明示的な（または推論）タイプなしで使用されています。修正は、 &lt;code&gt;this&lt;/code&gt; パラメータを使用して、インターフェイスまたは関数自体に明示的な型を与えることです。</target>
        </trans-unit>
        <trans-unit id="6ef37d4a82df716fb39c511922cd4fd9b3ab58c4" translate="yes" xml:space="preserve">
          <source>This is a breaking change; previously, the &lt;code&gt;keyof&lt;/code&gt; operator and mapped types only supported &lt;code&gt;string&lt;/code&gt; named properties. Code that assumed values typed with &lt;code&gt;keyof T&lt;/code&gt; were always &lt;code&gt;string&lt;/code&gt;s, will now be flagged as error.</source>
          <target state="translated">これは重大な変更です。以前は、 &lt;code&gt;keyof&lt;/code&gt; 演算子とマップされたタイプは、プロパティという名前の &lt;code&gt;string&lt;/code&gt; のみをサポートしていました。 &lt;code&gt;keyof T&lt;/code&gt; で入力された値を想定したコードは常に &lt;code&gt;string&lt;/code&gt; s でしたが、エラーとしてフラグが立てられるようになりました。</target>
        </trans-unit>
        <trans-unit id="37550d8cfccd82b7f09cb9ee94a9e55bd690b1de" translate="yes" xml:space="preserve">
          <source>This is a pretty literal use of the &lt;code&gt;GenericNumber&lt;/code&gt; class, but you may have noticed that nothing is restricting it to only use the &lt;code&gt;number&lt;/code&gt; type. We could have instead used &lt;code&gt;string&lt;/code&gt; or even more complex objects.</source>
          <target state="translated">これは &lt;code&gt;GenericNumber&lt;/code&gt; クラスのかなり文字どおりの使用法ですが、 &lt;code&gt;number&lt;/code&gt; 型のみを使用するように制限されているものがないことに気づいたかもしれません。代わりに、 &lt;code&gt;string&lt;/code&gt; またはさらに複雑なオブジェクトを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="0cbc708221291cf1aa363c4299a6de0178bc9f00" translate="yes" xml:space="preserve">
          <source>This is a reasonable restriction because any use of &lt;code&gt;Foo&lt;/code&gt; would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which&amp;hellip; well, hopefully you get the idea! In the end, there isn&amp;rsquo;t a type that makes sense in place of &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">これは、合理的な制限であるため、任意の使用 &lt;code&gt;Foo&lt;/code&gt; と交換する必要があります &lt;code&gt;Foo&lt;/code&gt; と交換する必要があると思われる &lt;code&gt;Foo&lt;/code&gt; と交換する必要があるだろう &lt;code&gt;Foo&lt;/code&gt; ...まあ、うまくいけばあなたのアイデアを得ます！結局、 &lt;code&gt;Foo&lt;/code&gt; の代わりに意味のある型はありません。</target>
        </trans-unit>
        <trans-unit id="b8060ed060d509f7038e676326653a9e51460e83" translate="yes" xml:space="preserve">
          <source>This is achieved by introducing two new types, &lt;code&gt;CallableFunction&lt;/code&gt; and &lt;code&gt;NewableFunction&lt;/code&gt;, in &lt;code&gt;lib.d.ts&lt;/code&gt;. These types contain specialized generic method declarations for &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; for regular functions and constructor functions, respectively. The declarations use generic rest parameters (see #24897) to capture and reflect parameter lists in a strongly typed manner. In &lt;code&gt;--strictBindCallApply&lt;/code&gt; mode these declarations are used in place of the (very permissive) declarations provided by type &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">これは、2基の新しい種類、導入することによって達成される &lt;code&gt;CallableFunction&lt;/code&gt; と &lt;code&gt;NewableFunction&lt;/code&gt; の中で、 &lt;code&gt;lib.d.ts&lt;/code&gt; 。これらの型には、 &lt;code&gt;bind&lt;/code&gt; 、 &lt;code&gt;call&lt;/code&gt; 、および通常の関数とコンストラクター関数のそれぞれに &lt;code&gt;apply&lt;/code&gt; れる特殊なジェネリックメソッド宣言が含まれています。宣言では、ジェネリックレストパラメーター（＃24897を参照）を使用して、厳密に型指定された方法でパラメーターリストをキャプチャおよび反映します。 &lt;code&gt;--strictBindCallApply&lt;/code&gt; モードこれらの宣言は、タイプによって提供される（非常に寛容な）宣言の代わりに使用される &lt;code&gt;Function&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6dbad74ad3287bbe68b69203c6f2782129725610" translate="yes" xml:space="preserve">
          <source>This is because when a class implements an interface, only the instance side of the class is checked. Since the constructor sits in the static side, it is not included in this check.</source>
          <target state="translated">これは、クラスがインターフェイスを実装したときに、そのクラスのインスタンス側だけをチェックするからです。コンストラクタは静的側にあるので、このチェックには含まれません。</target>
        </trans-unit>
        <trans-unit id="4b6c3dca4167679c5010d6f3fba2e9108213f5e9" translate="yes" xml:space="preserve">
          <source>This is called &amp;ldquo;contextual typing&amp;rdquo;, a form of type inference. This helps cut down on the amount of effort to keep your program typed.</source>
          <target state="translated">これは、型推論の一種である「コンテキストタイピング」と呼ばれます。これにより、プログラムの入力を維持するための労力を削減できます。</target>
        </trans-unit>
        <trans-unit id="3aa66e1a6cbac680bebe3f7aa3dc555a813d0306" translate="yes" xml:space="preserve">
          <source>This is equivalent to declaring &lt;code&gt;sentence&lt;/code&gt; like so:</source>
          <target state="translated">これは、次のように &lt;code&gt;sentence&lt;/code&gt; を宣言することと同じです。</target>
        </trans-unit>
        <trans-unit id="b92657e6155d73fb913bca9c2a7e95110494bb4c" translate="yes" xml:space="preserve">
          <source>This is fairly &lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Recursive_data_type&amp;amp;oldid=913091335#in_type_synonyms&quot;&gt;consistent with how other languages treat type aliases&lt;/a&gt;, but it does give rise to some slightly surprising scenarios for how users leverage the feature. For example, in TypeScript 3.6 and prior, the following causes an error.</source>
          <target state="translated">これは&lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Recursive_data_type&amp;amp;oldid=913091335#in_type_synonyms&quot;&gt;、他の言語が型エイリアスをどのように扱うか&lt;/a&gt;とほぼ一致していますが、ユーザーが機能を活用する方法について、少し意外なシナリオが発生します。たとえば、TypeScript 3.6以前では、次のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="723f96f4f031c1015e42839d7f70baaf5dc4dd7e" translate="yes" xml:space="preserve">
          <source>This is legal as long as it does not create a conflict. A general rule of thumb is that values always conflict with other values of the same name unless they are declared as &lt;code&gt;namespace&lt;/code&gt;s, types will conflict if they are declared with a type alias declaration (&lt;code&gt;type s = string&lt;/code&gt;), and namespaces never conflict.</source>
          <target state="translated">これは、衝突を引き起こさない限り合法です。一般的な経験則では、 &lt;code&gt;namespace&lt;/code&gt; s として宣言されていない限り、値は常に同じ名前の他の値と競合し、型エイリアス宣言（ &lt;code&gt;type s = string&lt;/code&gt; ）で宣言された型は競合し、名前空間は決して競合しません。</target>
        </trans-unit>
        <trans-unit id="b261fafdaf58d005a713f2cde7159a578a335b74" translate="yes" xml:space="preserve">
          <source>This is no longer the case - TypeScript now infers &lt;code&gt;this&lt;/code&gt; to have a special type called &lt;code&gt;this&lt;/code&gt; whenever inside an instance method of a class. The &lt;code&gt;this&lt;/code&gt; type is written as so, and basically means &amp;ldquo;the type of the left side of the dot in a method call&amp;rdquo;.</source>
          <target state="translated">これはもう当てはまりません-TypeScriptは &lt;code&gt;this&lt;/code&gt; を推論して、クラスのインスタンスメソッド内にあるときは常に &lt;code&gt;this&lt;/code&gt; と呼ばれる特別な型があると推測します。 &lt;code&gt;this&lt;/code&gt; タイプのように書かれており、基本的に「メソッド呼び出しのドットの左側のタイプ」を意味します。</target>
        </trans-unit>
        <trans-unit id="58590b20aaf8fc85de88a20890a72ce9479b5bd1" translate="yes" xml:space="preserve">
          <source>This is now the default for MSBuild projects; this allows MSBuild incremental build to work as expected, as outputs are only generated on clean builds.</source>
          <target state="translated">これはMSBuildプロジェクトのデフォルトとなりました。これにより、出力はクリーンビルド時にのみ生成されるため、MSBuildのインクリメンタルビルドが期待通りに動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="94d5f4a5616552cb256911b32b728b92d26e4819" translate="yes" xml:space="preserve">
          <source>This is only enabled if &lt;code&gt;--noImplicitAny&lt;/code&gt; is set.</source>
          <target state="translated">これは、 &lt;code&gt;--noImplicitAny&lt;/code&gt; が設定されている場合にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="d335ad9d283ed57e40045d0665963af63d3174d9" translate="yes" xml:space="preserve">
          <source>This is optimal for consumers. They can name your type whatever they want (&lt;code&gt;t&lt;/code&gt; in this case) and don&amp;rsquo;t have to do any excessive dotting to find your objects.</source>
          <target state="translated">これは消費者にとって最適です。彼らはあなたが望むようにあなたのタイプに名前を付けることができ（この場合は &lt;code&gt;t&lt;/code&gt; ）、あなたのオブジェクトを見つけるために過度の点数を行う必要はありません。</target>
        </trans-unit>
        <trans-unit id="98bb0c78662d4345a34d8056d87df00bb4d5a674" translate="yes" xml:space="preserve">
          <source>This is still strictly more capable in TypeScript 3.3, and adding an explicit type annotation will work.</source>
          <target state="translated">これは、TypeScript 3.3ではまだ厳密には可能であり、明示的な型アノテーションを追加することで機能します。</target>
        </trans-unit>
        <trans-unit id="a079a3a6734c4cd08da0e17c421a695ab213a09a" translate="yes" xml:space="preserve">
          <source>This is strange because there is technically nothing wrong with any use users could always write what was effectively the same code by introducing an interface.</source>
          <target state="translated">技術的には何の問題もないのに、インターフェイスを導入することで、ユーザーはいつでも事実上同じコードを書くことができるのですから、これは不思議です。</target>
        </trans-unit>
        <trans-unit id="14f1b6e0e05e87d37ff1f7dd8b578b6eb45b8f85" translate="yes" xml:space="preserve">
          <source>This is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing &lt;code&gt;undefined&lt;/code&gt; in that position is equivalent for most functions.</source>
          <target state="translated">これは型システムの観点からは適切ではありませんが、ランタイムの観点から見ると、オプションのパラメーターの概念は、その位置で &lt;code&gt;undefined&lt;/code&gt; を渡すことはほとんどの関数で同等であるため、一般に十分に適用されません。</target>
        </trans-unit>
        <trans-unit id="f1a4eb58dc966cceb7143e20830932600b5ea02f" translate="yes" xml:space="preserve">
          <source>This is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties. The subclasses don&amp;rsquo;t have to be related besides inheriting from the base class. For example:</source>
          <target state="translated">これは、継承階層が大きいが、特定のプロパティを持つサブクラスのみでコードが機能するように指定する場合に役立ちます。サブクラスは、基本クラスからの継承以外に関連している必要はありません。例えば：</target>
        </trans-unit>
        <trans-unit id="fbc601dd0ab93d792728208f62b2497f50e502de" translate="yes" xml:space="preserve">
          <source>This kind of iterator is useful for iterating over synchronously available values, such as the elements of an Array or the keys of a Map. An object that supports iteration is said to be &amp;ldquo;iterable&amp;rdquo; if it has a &lt;code&gt;Symbol.iterator&lt;/code&gt; method that returns an &lt;code&gt;Iterator&lt;/code&gt; object.</source>
          <target state="translated">この種のイテレータは、配列の要素やマップのキーなど、同期的に利用可能な値を反復するのに役立ちます。反復をサポートするオブジェクトは、 &lt;code&gt;Iterator&lt;/code&gt; オブジェクトを返す &lt;code&gt;Symbol.iterator&lt;/code&gt; メソッドがある場合、「反復可能」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="ee56cf9ba9542ce8a0312b6a94a0d6397c614c45" translate="yes" xml:space="preserve">
          <source>This may seem confusing, but it&amp;rsquo;s actually very convenient as long as we don&amp;rsquo;t excessively overload things. Let&amp;rsquo;s look at some useful aspects of this combining behavior.</source>
          <target state="translated">これは混乱を招くように見えるかもしれませんが、過度に負荷をかけすぎない限り、実際には非常に便利です。この組み合わせ動作のいくつかの有用な側面を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="242737969d68a63e3722770b6fdc0a0887aa17a9" translate="yes" xml:space="preserve">
          <source>This means that code like the following that was trying to represent JSON&amp;hellip;</source>
          <target state="translated">つまり、JSONを表現しようとしていた次のようなコードは&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="9e01eba045901bb9f42a3c7a52e17b1f10e058c3" translate="yes" xml:space="preserve">
          <source>This means that union types and &lt;code&gt;instanceof&lt;/code&gt; properly distinguish between structurally identical classes.</source>
          <target state="translated">つまり、共用体タイプと &lt;code&gt;instanceof&lt;/code&gt; は、構造的に同一のクラスを適切に区別します。</target>
        </trans-unit>
        <trans-unit id="944f762b99fb22d02c5865084d87d43b8946d4d0" translate="yes" xml:space="preserve">
          <source>This means that you can conditionally and lazily import other modules and libraries. For example, here&amp;rsquo;s an &lt;code&gt;async&lt;/code&gt; function that only imports a utility library when it&amp;rsquo;s needed:</source>
          <target state="translated">これは、他のモジュールやライブラリを条件付きで遅延してインポートできることを意味します。たとえば、次の &lt;code&gt;async&lt;/code&gt; 関数は、必要なときにのみユーティリティライブラリをインポートします。</target>
        </trans-unit>
        <trans-unit id="aa9a3a7f47b92be453ff0b6c4375f9ba7afa10b1" translate="yes" xml:space="preserve">
          <source>This mode adds flexibility for mixing and matching the way 3rd party libraries, where globals that libraries declare can always be consumed, even from within modules.</source>
          <target state="translated">このモードでは、サードパーティ製のライブラリを混合してマッチングさせるための柔軟性が追加され、ライブラリが宣言したグローバルは、モジュール内からでも常に消費することができます。</target>
        </trans-unit>
        <trans-unit id="7f33b0a22b86a2f41c336d65267df2bb8cf5e332" translate="yes" xml:space="preserve">
          <source>This model of namespace merging is a helpful starting place, but we also need to understand what happens with non-exported members. Non-exported members are only visible in the original (un-merged) namespace. This means that after merging, merged members that came from other declarations cannot see non-exported members.</source>
          <target state="translated">この名前空間マージのモデルは出発点として役立ちますが、エクスポートされないメンバについても理解しておく必要があります。非輸出メンバは、元の (マージされていない)名前空間でのみ表示されます。これは、マージ後、他の宣言から来たマージされたメンバは、エクスポートされないメンバを見ることができないことを意味します。</target>
        </trans-unit>
        <trans-unit id="5dae3ac251886a93244e214f8a5ad7364681d1d0" translate="yes" xml:space="preserve">
          <source>This new behavior only kicks in when at most one type in the union has multiple overloads, and at most one type in the union has a generic signature. That means methods on &lt;code&gt;number[] | string[]&lt;/code&gt; like &lt;code&gt;map&lt;/code&gt; (which is generic) still won&amp;rsquo;t be callable.</source>
          <target state="translated">この新しい動作は、ユニオン内の最大で1つのタイプに複数のオーバーロードがあり、ユニオン内の最大で1つのタイプにジェネリックシグネチャがある場合にのみ発生します。つまり、 &lt;code&gt;number[] | string[]&lt;/code&gt; ような &lt;code&gt;map&lt;/code&gt; （汎用）はまだ呼び出し可能ではありません。</target>
        </trans-unit>
        <trans-unit id="5b0887b7c0dc11302a46adcaa14cce74855a6095" translate="yes" xml:space="preserve">
          <source>This new relaxation also lets us recursively reference type aliases in tuples as well. The following code which used to error is now valid TypeScript code.</source>
          <target state="translated">この新しい緩和により、タプル内の型のエイリアスも再帰的に参照できるようになりました。これまでエラーになっていた以下のコードは、有効な TypeScript コードになりました。</target>
        </trans-unit>
        <trans-unit id="73d275a1e3784849d22fea2ec009273ed158e2df" translate="yes" xml:space="preserve">
          <source>This odd-looking pattern is actually pretty common. The &lt;code&gt;i&lt;/code&gt; in the parameter list actually shadows the &lt;code&gt;i&lt;/code&gt; declared in the &lt;code&gt;for&lt;/code&gt; loop, but since we named them the same, we didn&amp;rsquo;t have to modify the loop body too much.</source>
          <target state="translated">この奇妙に見えるパターンは実際にはかなり一般的です。パラメータリストの &lt;code&gt;i&lt;/code&gt; は、実際には &lt;code&gt;for&lt;/code&gt; ループで宣言された &lt;code&gt;i&lt;/code&gt; をシャドウしますが、同じ名前を付けたため、ループ本体をあまり変更する必要はありませんでした。</target>
        </trans-unit>
        <trans-unit id="5c7ee90113f636f43404e4d744fd715593d575c9" translate="yes" xml:space="preserve">
          <source>This often opens up very elegant ways of writing code; however, there was a problem for classes that wanted to extend from &lt;code&gt;BasicCalculator&lt;/code&gt;. Imagine a user wanted to start writing a &lt;code&gt;ScientificCalculator&lt;/code&gt;:</source>
          <target state="translated">これは、多くの場合、非常に洗練された方法でコードを記述します。ただし、 &lt;code&gt;BasicCalculator&lt;/code&gt; から拡張したいクラスには問題がありました。ユーザーが &lt;code&gt;ScientificCalculator&lt;/code&gt; の作成を開始したいと想像してください。</target>
        </trans-unit>
        <trans-unit id="93d9ec6cf3f9136de052694a0e5be31bcf80b6f6" translate="yes" xml:space="preserve">
          <source>This only apply to types with an &lt;em&gt;explicit&lt;/em&gt; string index signature. It is still an error to access unknown properties on a type using &lt;code&gt;.&lt;/code&gt; notation.</source>
          <target state="translated">これは、&lt;em&gt;明示的な&lt;/em&gt;文字列インデックスシグネチャを持つ型にのみ適用されます。を使用して型の不明なプロパティにアクセスすることは、まだエラー &lt;code&gt;.&lt;/code&gt; 表記。</target>
        </trans-unit>
        <trans-unit id="ac04689bd985aaff5480421363910106fc5c181c" translate="yes" xml:space="preserve">
          <source>This option is similar to &lt;code&gt;UseFsEvents&lt;/code&gt; except on failing to create watch using &lt;code&gt;fs.watch&lt;/code&gt;, the fallback watching happens through dynamic polling queues (as explained in &lt;code&gt;DynamicPriorityPolling&lt;/code&gt;)</source>
          <target state="translated">このオプションは、に似て &lt;code&gt;UseFsEvents&lt;/code&gt; 使用して時計を作成するために、失敗を除く &lt;code&gt;fs.watch&lt;/code&gt; を（で説明したように、フォールバックウォッチングは、動的なポーリング・キューを介して行わ &lt;code&gt;DynamicPriorityPolling&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="0aae93fe007c809a7e2e36db92dc9e5b379de835" translate="yes" xml:space="preserve">
          <source>This option watches parent directory of the file with &lt;code&gt;fs.watch&lt;/code&gt; (using file system events) thus being low on CPU but can compromise accuracy.</source>
          <target state="translated">このオプションは、ファイルシステムイベントを使用して &lt;code&gt;fs.watch&lt;/code&gt; でファイルの親ディレクトリを監視するため、CPUの負荷は低くなりますが、精度が低下する可能性があります。</target>
        </trans-unit>
        <trans-unit id="87694e596c33f73edc99c67b8848fbcbde1e4c9c" translate="yes" xml:space="preserve">
          <source>This post outlines the various ways to organize your code using namespaces (previously &amp;ldquo;internal modules&amp;rdquo;) in TypeScript. As we alluded in our note about terminology, &amp;ldquo;internal modules&amp;rdquo; are now referred to as &amp;ldquo;namespaces&amp;rdquo;. Additionally, anywhere the &lt;code&gt;module&lt;/code&gt; keyword was used when declaring an internal module, the &lt;code&gt;namespace&lt;/code&gt; keyword can and should be used instead. This avoids confusing new users by overloading them with similarly named terms.</source>
          <target state="translated">この投稿では、TypeScriptで名前空間（以前の「内部モジュール」）を使用してコードを整理するさまざまな方法の概要を説明します。用語に関する注記で触れたように、「内部モジュール」は「名前空間」と呼ばれるようになりました。さらに、内部モジュールを宣言するときに &lt;code&gt;module&lt;/code&gt; キーワードを使用した場合は、 &lt;code&gt;namespace&lt;/code&gt; キーワードを代わりに使用できます。これにより、同じような名前の用語でオーバーロードすることにより、新しいユーザーの混乱を防ぎます。</target>
        </trans-unit>
        <trans-unit id="67e03678783967eef2733d80436705f614849f7f" translate="yes" xml:space="preserve">
          <source>This post outlines the various ways to organize your code using namespaces and modules in TypeScript. We&amp;rsquo;ll also go over some advanced topics of how to use namespaces and modules, and address some common pitfalls when using them in TypeScript.</source>
          <target state="translated">この投稿では、TypeScriptで名前空間とモジュールを使用してコードを整理するさまざまな方法の概要を説明します。名前空間とモジュールの使用方法に関するいくつかの高度なトピックについても説明し、TypeScriptでそれらを使用する場合のいくつかの一般的な落とし穴に対処します。</target>
        </trans-unit>
        <trans-unit id="fd64220fbecc8854d60d2a4f4f20ca94bda2d4e7" translate="yes" xml:space="preserve">
          <source>This presents a simple entry point; e.g. in the TypeScript repo we simply run &lt;code&gt;tsc -b src&lt;/code&gt; to build all endpoints because we list all the subprojects in &lt;code&gt;src/tsconfig.json&lt;/code&gt;</source>
          <target state="translated">これは単純なエントリポイントを示しています。たとえば、TypeScriptリポジトリでは、 &lt;code&gt;tsc -b src&lt;/code&gt; を実行してすべてのエンドポイントを構築します。これは、 &lt;code&gt;src/tsconfig.json&lt;/code&gt; にすべてのサブプロジェクトをリストするためです。</target>
        </trans-unit>
        <trans-unit id="96c2c0f0e97743735b953a624ea594af85aaba20" translate="yes" xml:space="preserve">
          <source>This presents a very good opportunity for destructuring in the consuming code:</source>
          <target state="translated">これは、消費するコードを破壊するための非常に良い機会を提供します。</target>
        </trans-unit>
        <trans-unit id="90339bda9cc4062b63e151a5bde442af3f17fdf3" translate="yes" xml:space="preserve">
          <source>This quick start guide will teach you how to build TypeScript with &lt;a href=&quot;http://gulpjs.com&quot;&gt;gulp&lt;/a&gt; and then add &lt;a href=&quot;http://browserify.org&quot;&gt;Browserify&lt;/a&gt;, &lt;a href=&quot;http://lisperator.net/uglifyjs/&quot;&gt;uglify&lt;/a&gt;, or &lt;a href=&quot;https://github.com/substack/watchify&quot;&gt;Watchify&lt;/a&gt; to the gulp pipeline. This guide also shows how to add &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; functionality using &lt;a href=&quot;https://github.com/babel/babelify&quot;&gt;Babelify&lt;/a&gt;.</source>
          <target state="translated">このクイックスタートガイドでは、どのようにして活字体を構築することをお教えします&lt;a href=&quot;http://gulpjs.com&quot;&gt;一口&lt;/a&gt;、その後追加&lt;a href=&quot;http://browserify.org&quot;&gt;Browserify&lt;/a&gt;、&lt;a href=&quot;http://lisperator.net/uglifyjs/&quot;&gt;uglify&lt;/a&gt;、または&lt;a href=&quot;https://github.com/substack/watchify&quot;&gt;Watchifyを&lt;/a&gt;一気パイプラインに。このガイドでは、&lt;a href=&quot;https://github.com/babel/babelify&quot;&gt;Babelify&lt;/a&gt;を使用して&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;機能を追加する方法も示します。</target>
        </trans-unit>
        <trans-unit id="4771bc2bab27a199d772c4ea0beb5b94f1557d90" translate="yes" xml:space="preserve">
          <source>This resolution strategy attempts to mimic the &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; module resolution mechanism at runtime. The full Node.js resolution algorithm is outlined in &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_all_together&quot;&gt;Node.js module documentation&lt;/a&gt;.</source>
          <target state="translated">この解決戦略は、実行時に&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;モジュール解決メカニズムを模倣しようとします。完全なNode.js解決アルゴリズムの概要は、&lt;a href=&quot;https://nodejs.org/api/modules.html#modules_all_together&quot;&gt;Node.jsモジュールのドキュメントに&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="a4282404c916b4f4b5fe9e3d34bc8423764a9741" translate="yes" xml:space="preserve">
          <source>This results in the generated JS</source>
          <target state="translated">この結果、生成されたJS</target>
        </trans-unit>
        <trans-unit id="ef4b88dc9b6e4d599f0dfab38e9b347bbf2884ea" translate="yes" xml:space="preserve">
          <source>This section assumes some basic knowledge about modules. Please see the &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; documentation for more information.</source>
          <target state="translated">このセクションでは、モジュールに関する基本的な知識があることを前提としています。詳細については、&lt;a href=&quot;modules&quot;&gt;モジュールの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="f9fb839c0cccd09c3b2a3d1ab1913df898747ff9" translate="yes" xml:space="preserve">
          <source>This should not be confused with the idea that the values they refer to are &lt;em&gt;immutable&lt;/em&gt;.</source>
          <target state="translated">これを、それらが参照する値が&lt;em&gt;不変&lt;/em&gt;であるという考えと混同しないでください。</target>
        </trans-unit>
        <trans-unit id="a1f229269d84a6a8939b736e452446c28bdac1e5" translate="yes" xml:space="preserve">
          <source>This simple example shows how the names used during importing and exporting get translated into the module loading code.</source>
          <target state="translated">このシンプルな例では、インポートとエクスポートの際に使用される名前がどのようにモジュールの読み込みコードに変換されるかを示しています。</target>
        </trans-unit>
        <trans-unit id="c02e5a7acc21e96b7b427fe531770986b2a8029c" translate="yes" xml:space="preserve">
          <source>This tells the compiler for any module import that matches the pattern &lt;code&gt;&quot;*&quot;&lt;/code&gt; (i.e. all values), to look in two locations:</source>
          <target state="translated">これは、パターン &lt;code&gt;&quot;*&quot;&lt;/code&gt; （つまり、すべての値）に一致するモジュールインポートを2つの場所で探すようコンパイラーに指示します。</target>
        </trans-unit>
        <trans-unit id="e28988a9e9ef50dbc6082fe7ec51c8e202185991" translate="yes" xml:space="preserve">
          <source>This treats the classes as interfaces, and only mixes the types behind Disposable and Activatable into the SmartObject type rather than the implementation. This means that we&amp;rsquo;ll have to provide the implementation in class. Except, that&amp;rsquo;s exactly what we want to avoid by using mixins.</source>
          <target state="translated">これはクラスをインターフェースとして扱い、DisposableとActivatableの背後にある型を、実装ではなくSmartObject型にのみ混合します。つまり、実装をクラスで提供する必要があります。それ以外は、ミックスインを使用することで回避したいものです。</target>
        </trans-unit>
        <trans-unit id="9a9277b80c882b7208b460979a9bd488c375c6cf" translate="yes" xml:space="preserve">
          <source>This used to be TypeScript&amp;rsquo;s default resolution strategy. Nowadays, this strategy is mainly present for backward compatibility.</source>
          <target state="translated">これは、TypeScriptのデフォルトの解決戦略でした。現在、この戦略は主に下位互換性のために存在しています。</target>
        </trans-unit>
        <trans-unit id="93fddce73184becc8bb1dcac36b8151b2a00b289" translate="yes" xml:space="preserve">
          <source>This utility does not return a transformed type. Instead, it serves as a marker for a contextual &lt;code&gt;this&lt;/code&gt; type. Note that the &lt;code&gt;--noImplicitThis&lt;/code&gt; flag must be enabled to use this utility.</source>
          <target state="translated">このユーティリティは、変換された型を返しません。代わりに、 &lt;code&gt;this&lt;/code&gt; タイプのコンテキストのマーカーとして機能します。このユーティリティを使用するには、 &lt;code&gt;--noImplicitThis&lt;/code&gt; フラグを有効にする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="af2d32c38013b382c9d64510bcce20de81efb3be" translate="yes" xml:space="preserve">
          <source>This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;frozen object&lt;/a&gt;).</source>
          <target state="translated">このユーティリティは、実行時に失敗する割り当て式を表すのに役立ちます（つまり、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;凍結されたオブジェクトの&lt;/a&gt;プロパティを再割り当てしようとする場合）。</target>
        </trans-unit>
        <trans-unit id="eaff2ada45477df0b05b97a2def6303701764e4e" translate="yes" xml:space="preserve">
          <source>This version of the loop will actually perform the summation correctly because the inner loop&amp;rsquo;s &lt;code&gt;i&lt;/code&gt; shadows &lt;code&gt;i&lt;/code&gt; from the outer loop.</source>
          <target state="translated">ループのこのバージョンでは、実際に内部ループのため、正しく集計を行います &lt;code&gt;i&lt;/code&gt; の影 &lt;code&gt;i&lt;/code&gt; 外側のループから。</target>
        </trans-unit>
        <trans-unit id="9381442c6d6f687b278f6b0753897426078289bf" translate="yes" xml:space="preserve">
          <source>This works because arrow functions use the outer &lt;code&gt;this&lt;/code&gt;, so you can always pass them to something that expects &lt;code&gt;this: void&lt;/code&gt;. The downside is that one arrow function is created per object of type Handler. Methods, on the other hand, are only created once and attached to Handler&amp;rsquo;s prototype. They are shared between all objects of type Handler.</source>
          <target state="translated">これが機能するのは、矢印関数が外側の &lt;code&gt;this&lt;/code&gt; を使用するため、これを期待するものに常に渡すことができます &lt;code&gt;this: void&lt;/code&gt; 。欠点は、タイプHandlerのオブジェクトごとに1つの矢印関数が作成されることです。一方、メソッドは一度だけ作成され、ハンドラーのプロトタイプにアタッチされます。それらは、タイプHandlerのすべてのオブジェクト間で共有されます。</target>
        </trans-unit>
        <trans-unit id="a855814a311b76c2385f1f8fa0122f8b7cb5fd05" translate="yes" xml:space="preserve">
          <source>This works fine in TypeScript too, but the compiler doesn&amp;rsquo;t know about &lt;code&gt;Observable.prototype.map&lt;/code&gt;. You can use module augmentation to tell the compiler about it:</source>
          <target state="translated">これはTypeScriptでも正常に機能しますが、コンパイラーは &lt;code&gt;Observable.prototype.map&lt;/code&gt; を認識しません。モジュール拡張を使用して、コンパイラーにそれを伝えることができます。</target>
        </trans-unit>
        <trans-unit id="90afc95581c28b0ae5570b6d400541b7e8730c10" translate="yes" xml:space="preserve">
          <source>This works well enough, but we might imagine that &lt;code&gt;SomeType&lt;/code&gt; and &lt;code&gt;SomeVar&lt;/code&gt; were very closely related such that you&amp;rsquo;d like them to have the same name. We can use combining to present these two different objects (the value and the type) under the same name &lt;code&gt;Bar&lt;/code&gt;:</source>
          <target state="translated">これは十分に機能しますが、 &lt;code&gt;SomeType&lt;/code&gt; と &lt;code&gt;SomeVar&lt;/code&gt; が非常に密接に関連しているため、同じ名前にしたいと思うかもしれません。結合を使用して、これら2つの異なるオブジェクト（値とタイプ）を同じ名前 &lt;code&gt;Bar&lt;/code&gt; で表示できます。</target>
        </trans-unit>
        <trans-unit id="8fe51f943aa966ad44227ae1d5f6f6ffe2daa142" translate="yes" xml:space="preserve">
          <source>ThisParameterType</source>
          <target state="translated">ThisParameterType</target>
        </trans-unit>
        <trans-unit id="476185d9e02b1c2446403ce730e896811f7c5c6c" translate="yes" xml:space="preserve">
          <source>ThisType&amp;lt;T&amp;gt;</source>
          <target state="translated">ThisType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="141ee6a2eac7f3e80ad87c7204dbdc726776e142" translate="yes" xml:space="preserve">
          <source>Though not recommended practice, some modules set up some global state that can be used by other modules. These modules may not have any exports, or the consumer is not interested in any of their exports. To import these modules, use:</source>
          <target state="translated">推奨される実践ではありませんが、モジュールによっては、他のモジュールで使用できるグローバルな状態を設定しているものがあります。これらのモジュールはエクスポートを持っていないかもしれませんし、消費者がそのエクスポートに興味を持っていないかもしれません。これらのモジュールをインポートするには</target>
        </trans-unit>
        <trans-unit id="459af1bfbb68d7eb9e20b58d77f575123c077dc5" translate="yes" xml:space="preserve">
          <source>Thus, the following calls are equivalent:</source>
          <target state="translated">したがって、以下の呼び出しは等価です。</target>
        </trans-unit>
        <trans-unit id="c479684dc5713300c68d9b67d81ddc804c214909" translate="yes" xml:space="preserve">
          <source>To allow differentiation between returned values and yielded values, TypeScript 3.6 converts the &lt;code&gt;IteratorResult&lt;/code&gt; type to a discriminated union type:</source>
          <target state="translated">TypeScript 3.6は、戻り値と生成された値を区別できるように、 &lt;code&gt;IteratorResult&lt;/code&gt; 型を識別された共用体型に変換します。</target>
        </trans-unit>
        <trans-unit id="b4b29c56482897c2bcedcd82df10d23478983ef9" translate="yes" xml:space="preserve">
          <source>To begin, just as in JavaScript, TypeScript functions can be created both as a named function or as an anonymous function. This allows you to choose the most appropriate approach for your application, whether you&amp;rsquo;re building a list of functions in an API or a one-off function to hand off to another function.</source>
          <target state="translated">まず、JavaScriptと同様に、TypeScript関数は、名前付き関数または匿名関数の両方として作成できます。これにより、APIで関数のリストを作成する場合でも、別の関数に渡すための1回限りの関数で作成する場合でも、アプリケーションに最適なアプローチを選択できます。</target>
        </trans-unit>
        <trans-unit id="ed7d2301f55dd416668c23e26708f6625cc0b7df" translate="yes" xml:space="preserve">
          <source>To check if &lt;code&gt;x&lt;/code&gt; is assignable to &lt;code&gt;y&lt;/code&gt;, we first look at the parameter list. Each parameter in &lt;code&gt;x&lt;/code&gt; must have a corresponding parameter in &lt;code&gt;y&lt;/code&gt; with a compatible type. Note that the names of the parameters are not considered, only their types. In this case, every parameter of &lt;code&gt;x&lt;/code&gt; has a corresponding compatible parameter in &lt;code&gt;y&lt;/code&gt;, so the assignment is allowed.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; が &lt;code&gt;y&lt;/code&gt; に割り当て可能かどうかを確認するには、まずパラメーターリストを確認します。 &lt;code&gt;x&lt;/code&gt; の各パラメーターには、互換性のあるタイプの対応する &lt;code&gt;y&lt;/code&gt; のパラメーターが必要です。パラメータの名前は考慮されず、タイプのみが考慮されることに注意してください。この場合、 &lt;code&gt;x&lt;/code&gt; のすべてのパラメーターには &lt;code&gt;y&lt;/code&gt; に対応する互換パラメーターがあるため、割り当てが許可されます。</target>
        </trans-unit>
        <trans-unit id="5aa2d6b34ccb6e986760e69cce9eaf8d194e80e3" translate="yes" xml:space="preserve">
          <source>To check whether &lt;code&gt;y&lt;/code&gt; can be assigned to &lt;code&gt;x&lt;/code&gt;, the compiler checks each property of &lt;code&gt;x&lt;/code&gt; to find a corresponding compatible property in &lt;code&gt;y&lt;/code&gt;. In this case, &lt;code&gt;y&lt;/code&gt; must have a member called &lt;code&gt;name&lt;/code&gt; that is a string. It does, so the assignment is allowed.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; を &lt;code&gt;x&lt;/code&gt; に割り当てることができるかどうかを確認するために、コンパイラーは &lt;code&gt;x&lt;/code&gt; の各プロパティを確認して、 &lt;code&gt;y&lt;/code&gt; 内の対応する互換性のあるプロパティを見つけます。この場合、 &lt;code&gt;y&lt;/code&gt; には、文字列である &lt;code&gt;name&lt;/code&gt; と呼ばれるメンバーが必要です。そのため、割り当てが許可されます。</target>
        </trans-unit>
        <trans-unit id="75b4fbb1127914ceb3d21cad503d3f7fc1d4e3ca" translate="yes" xml:space="preserve">
          <source>To compile, we must specify a module target on the command line. For Node.js, use &lt;code&gt;--module commonjs&lt;/code&gt;; for require.js, use &lt;code&gt;--module amd&lt;/code&gt;. For example:</source>
          <target state="translated">コンパイルするには、コマンドラインでモジュールターゲットを指定する必要があります。Node.jsの場合、-- &lt;code&gt;--module commonjs&lt;/code&gt; 使用します。require.jsの場合は、-- &lt;code&gt;--module amd&lt;/code&gt; 使用します。例えば：</target>
        </trans-unit>
        <trans-unit id="5c92181f23fdc218d3e5f2c8e5c093d3e88dd341" translate="yes" xml:space="preserve">
          <source>To correctly represent the types that can be passed in to a generator from calls to &lt;code&gt;next()&lt;/code&gt;, TypeScript 3.6 also infers certain uses of &lt;code&gt;yield&lt;/code&gt; within the body of a generator function.</source>
          <target state="translated">&lt;code&gt;next()&lt;/code&gt; の呼び出しからジェネレーターに渡すことができる型を正しく表すために、TypeScript 3.6 はジェネレーター関数の本体内で特定の &lt;code&gt;yield&lt;/code&gt; の使用も推論します。</target>
        </trans-unit>
        <trans-unit id="4a85275c6424e7d3a9f548f3f9d3fe8015b36051" translate="yes" xml:space="preserve">
          <source>To define a type guard, we simply need to define a function whose return type is a &lt;em&gt;type predicate&lt;/em&gt;:</source>
          <target state="translated">型ガードを定義するには、戻り値の型が&lt;em&gt;型述語で&lt;/em&gt;ある関数を定義するだけです。</target>
        </trans-unit>
        <trans-unit id="509608b5d7a3db1a99b623edfaa3336bb28d3b8d" translate="yes" xml:space="preserve">
          <source>To describe a function type with an interface, we give the interface a call signature. This is like a function declaration with only the parameter list and return type given. Each parameter in the parameter list requires both name and type.</source>
          <target state="translated">関数型をインターフェースで記述するために、インターフェースにコールシグネチャを与えます。これは、パラメータリストと戻り値の型だけを与えた関数宣言のようなものです。パラメータリストの各パラメータは、名前と型の両方を必要とします。</target>
        </trans-unit>
        <trans-unit id="c07e6015d0cdce1868d861847dbd57c18c3fb7ac" translate="yes" xml:space="preserve">
          <source>To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes.</source>
          <target state="translated">TypeScriptで書かれていないライブラリの形を記述するには、ライブラリが公開しているAPIを宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="afcbeb02ce03509365825abf4caef8de00c49ba6" translate="yes" xml:space="preserve">
          <source>To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes. Because most JavaScript libraries expose only a few top-level objects, namespaces are a good way to represent them.</source>
          <target state="translated">TypeScriptで書かれていないライブラリの形を表現するには、そのライブラリが公開しているAPIを宣言する必要があります。ほとんどの JavaScript ライブラリが公開しているのは少数のトップレベルのオブジェクトだけなので、名前空間はそれらを表現するのに適した方法です。</target>
        </trans-unit>
        <trans-unit id="0300d21291d54245672afcd6c034804cd6d8f1af" translate="yes" xml:space="preserve">
          <source>To detect the issue around accessors, TypeScript 3.7 will now emit &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors in &lt;code&gt;.d.ts&lt;/code&gt; files so that in TypeScript can check for overridden accessors.</source>
          <target state="translated">TypeScript 3.7は、アクセサーに関する問題を検出するために、 &lt;code&gt;.d.ts&lt;/code&gt; ファイルで &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; アクセサーを発行し、TypeScriptでオーバーライドされたアクセサーをチェックできるようになりました。</target>
        </trans-unit>
        <trans-unit id="0105ab9a65a074ef9c63d082566ad7bd09908a6d" translate="yes" xml:space="preserve">
          <source>To do so, we&amp;rsquo;ll create an interface that describes our constraint. Here, we&amp;rsquo;ll create an interface that has a single &lt;code&gt;.length&lt;/code&gt; property and then we&amp;rsquo;ll use this interface and the &lt;code&gt;extends&lt;/code&gt; keyword to denote our constraint:</source>
          <target state="translated">そのために、制約を記述するインターフェースを作成します。ここでは、単一の &lt;code&gt;.length&lt;/code&gt; プロパティを持つインターフェースを作成し、このインターフェースと &lt;code&gt;extends&lt;/code&gt; キーワードを使用して制約を示します。</target>
        </trans-unit>
        <trans-unit id="a28ef11afcbe8d3d69c6a4bf7c61c5a049f90264" translate="yes" xml:space="preserve">
          <source>To do this, you&amp;rsquo;ll need to create a &lt;code&gt;tsconfig.json&lt;/code&gt; which contains a list of your input files as well as all your compilation settings. Simply create a new file in your project root named &lt;code&gt;tsconfig.json&lt;/code&gt; and fill it with the following contents:</source>
          <target state="translated">これを行うには、入力ファイルのリストとすべてのコンパイル設定を含む &lt;code&gt;tsconfig.json&lt;/code&gt; を作成する必要があります。プロジェクトのルートに &lt;code&gt;tsconfig.json&lt;/code&gt; という名前の新しいファイルを作成し、次の内容を入力するだけです。</target>
        </trans-unit>
        <trans-unit id="6a7b875dfeed7fc61c9681ef2adf2ce3963acdd1" translate="yes" xml:space="preserve">
          <source>To enable experimental support for decorators, you must enable the &lt;code&gt;experimentalDecorators&lt;/code&gt; compiler option either on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">デコレータのための実験的なサポートを有効にするには、有効にする必要があり &lt;code&gt;experimentalDecorators&lt;/code&gt; コマンドライン上または自分の中のいずれかのコンパイラオプション &lt;code&gt;tsconfig.json&lt;/code&gt; を：</target>
        </trans-unit>
        <trans-unit id="e91510089a97db0cb9eadcf3ab17449eabecd456" translate="yes" xml:space="preserve">
          <source>To enable the recursive type alias patterns described above, the &lt;code&gt;typeArguments&lt;/code&gt; property has been removed from the &lt;code&gt;TypeReference&lt;/code&gt; interface. Users should instead use the &lt;code&gt;getTypeArguments&lt;/code&gt; function on &lt;code&gt;TypeChecker&lt;/code&gt; instances.</source>
          <target state="translated">上記の再帰的な型エイリアスパターンを有効にするために、 &lt;code&gt;typeArguments&lt;/code&gt; プロパティが &lt;code&gt;TypeReference&lt;/code&gt; インターフェイスから削除されました。代わりに、ユーザーは &lt;code&gt;TypeChecker&lt;/code&gt; インスタンスで &lt;code&gt;getTypeArguments&lt;/code&gt; 関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e2363be8e6c6cb5a067aea3d8f64f3d22b30a1c7" translate="yes" xml:space="preserve">
          <source>To enable treating symbols as unique literals a new type &lt;code&gt;unique symbol&lt;/code&gt; is available. &lt;code&gt;unique symbol&lt;/code&gt; is a subtype of &lt;code&gt;symbol&lt;/code&gt;, and are produced only from calling &lt;code&gt;Symbol()&lt;/code&gt; or &lt;code&gt;Symbol.for()&lt;/code&gt;, or from explicit type annotations. The new type is only allowed on &lt;code&gt;const&lt;/code&gt; declarations and &lt;code&gt;readonly static&lt;/code&gt; properties, and in order to reference a specific unique symbol, you&amp;rsquo;ll have to use the &lt;code&gt;typeof&lt;/code&gt; operator. Each reference to a &lt;code&gt;unique symbol&lt;/code&gt; implies a completely unique identity that&amp;rsquo;s tied to a given declaration.</source>
          <target state="translated">シンボルを一意のリテラルとして扱うことを可能にするために、新しいタイプの &lt;code&gt;unique symbol&lt;/code&gt; が利用可能です。 &lt;code&gt;unique symbol&lt;/code&gt; はsymbolのサブタイプで &lt;code&gt;symbol&lt;/code&gt; 、 &lt;code&gt;Symbol()&lt;/code&gt; または &lt;code&gt;Symbol.for()&lt;/code&gt; の呼び出し、または明示的な型注釈からのみ生成されます。新しい型は &lt;code&gt;const&lt;/code&gt; 宣言と &lt;code&gt;readonly static&lt;/code&gt; プロパティでのみ許可され、特定の一意のシンボルを参照するには、 &lt;code&gt;typeof&lt;/code&gt; 演算子を使用する必要があります。 &lt;code&gt;unique symbol&lt;/code&gt; への参照はそれぞれ、特定の宣言に関連付けられた完全に一意のIDを意味します。</target>
        </trans-unit>
        <trans-unit id="cbf37d6416e66ab0ef9074eb1300931277b42ac8" translate="yes" xml:space="preserve">
          <source>To get more specific, let&amp;rsquo;s build up some motivation and consider the following &lt;code&gt;compose&lt;/code&gt; function:</source>
          <target state="translated">より具体的に説明するために、モチベーションを高めて、次の &lt;code&gt;compose&lt;/code&gt; 関数を検討してみましょう。</target>
        </trans-unit>
        <trans-unit id="7dd85227b3548e65f6da723dba0b86e37aa0dbf7" translate="yes" xml:space="preserve">
          <source>To get the same code working, we&amp;rsquo;ll need to use a type assertion:</source>
          <target state="translated">同じコードを機能させるには、型アサーションを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="51bcd2ee5a6a2dcd5ba1a0638fe26fb80525ff92" translate="yes" xml:space="preserve">
          <source>To help mitigate the second issue, you can either add an explicit initializer or add a &lt;code&gt;declare&lt;/code&gt; modifier to indicate that a property should have no emit.</source>
          <target state="translated">2番目の問題を軽減するために、明示的な初期化子を追加するか、プロパティに放出がないことを示す &lt;code&gt;declare&lt;/code&gt; 修飾子を追加できます。</target>
        </trans-unit>
        <trans-unit id="13ac7bef7c1c7e11ef81979db1c2f2a81cf19fc2" translate="yes" xml:space="preserve">
          <source>To infer the type of &lt;code&gt;x&lt;/code&gt; in the example above, we must consider the type of each array element. Here we are given two choices for the type of the array: &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt;. The best common type algorithm considers each candidate type, and picks the type that is compatible with all the other candidates.</source>
          <target state="translated">上記の例で &lt;code&gt;x&lt;/code&gt; の型を推測するには、各配列要素の型を考慮する必要があります。ここでは、配列のタイプとして、 &lt;code&gt;number&lt;/code&gt; と &lt;code&gt;null&lt;/code&gt; の 2つの選択肢があります。最も一般的なタイプアルゴリズムは、各候補タイプを考慮し、他のすべての候補と互換性のあるタイプを選択します。</target>
        </trans-unit>
        <trans-unit id="2cf2e12d1445d0aadb96f230e547df7611323dbd" translate="yes" xml:space="preserve">
          <source>To learn more, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31116&quot;&gt;check out the original pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">詳しくは、&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31116&quot;&gt;GitHubの元のプルリクエストを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="5f5f3e9b4e4a6af029b4267e885fa3ce255b1ecf" translate="yes" xml:space="preserve">
          <source>To maintain type safety, we can use the &lt;code&gt;typeof&lt;/code&gt; keyword. The &lt;code&gt;typeof&lt;/code&gt; keyword, when used in a type position, produces the type of a value, in this case the type of the module.</source>
          <target state="translated">タイプセーフを維持するために、 &lt;code&gt;typeof&lt;/code&gt; キーワードを使用できます。 &lt;code&gt;typeof&lt;/code&gt; 演算のタイプの位置で使用されるキーワードが、この場合、モジュールの種類に、値の種類を生成します。</target>
        </trans-unit>
        <trans-unit id="625fea5502d41397c32546a9a0ea50c65ae835db" translate="yes" xml:space="preserve">
          <source>To merge the namespace value, at each declaration site, if a namespace already exists with the given name, it is further extended by taking the existing namespace and adding the exported members of the second namespace to the first.</source>
          <target state="translated">名前空間の値をマージするために、各宣言サイトで、指定された名前の名前空間がすでに存在する場合は、既存の名前空間を取り、最初の名前空間に2番目の名前空間のエクスポートされたメンバを追加することで、さらに拡張されます。</target>
        </trans-unit>
        <trans-unit id="e313e5ed420f9f03b21861d0bbd9027ef02d9b32" translate="yes" xml:space="preserve">
          <source>To merge the namespaces, type definitions from exported interfaces declared in each namespace are themselves merged, forming a single namespace with merged interface definitions inside.</source>
          <target state="translated">名前空間をマージするには、各名前空間で宣言されたエクスポートされたインタフェースの型定義をマージし、マージされたインタフェース定義を内部に持つ単一の名前空間を形成します。</target>
        </trans-unit>
        <trans-unit id="22cc216e31611ca78f1d455f6fccc99b2815b93a" translate="yes" xml:space="preserve">
          <source>To preserve existing functionality, we also add a simple getter that retrieves &lt;code&gt;fullName&lt;/code&gt; unmodified.</source>
          <target state="translated">既存の機能を保持するために、 &lt;code&gt;fullName&lt;/code&gt; を変更せずに取得する単純なゲッターも追加します。</target>
        </trans-unit>
        <trans-unit id="f744a2110e26e2b8cb5b64d6c11b34abc0ac07e8" translate="yes" xml:space="preserve">
          <source>To prove to ourselves that our accessor is now checking the length of values, we can attempt to assign a name longer than 10 characters and verify that we get an error.</source>
          <target state="translated">アクセサが値の長さをチェックするようになったことを自分自身に証明するために、10文字よりも長い名前を代入してみて、エラーが出ることを確認することができます。</target>
        </trans-unit>
        <trans-unit id="d0b5bbb81ca0d263287358fac537a9ccf83a25cd" translate="yes" xml:space="preserve">
          <source>To quickly recap what these two approaches look like in JavaScript:</source>
          <target state="translated">この2つのアプローチがJavaScriptでどのようなものかを素早く復習するために。</target>
        </trans-unit>
        <trans-unit id="e294e29d961a6bb9b93ca330847244995e631e4c" translate="yes" xml:space="preserve">
          <source>To read up more about assertion signatures, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;check out the original pull request&lt;/a&gt;.</source>
          <target state="translated">アサーション署名の詳細について&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;は、元のプルリクエストを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="5032cc8bd0b8d34fd39729d94585dfdc34772a96" translate="yes" xml:space="preserve">
          <source>To reiterate why you shouldn&amp;rsquo;t try to namespace your module contents, the general idea of namespacing is to provide logical grouping of constructs and to prevent name collisions. Because the module file itself is already a logical grouping, and its top-level name is defined by the code that imports it, it&amp;rsquo;s unnecessary to use an additional module layer for exported objects.</source>
          <target state="translated">モジュールのコンテンツに名前空間を付けようとしない理由を繰り返すと、名前空間の一般的な考え方は、構成体の論理グループを提供し、名前の衝突を防ぐことです。モジュールファイル自体はすでに論理的なグループであり、その最上位の名前はそれをインポートするコードによって定義されているため、エクスポートされたオブジェクトに追加のモジュールレイヤーを使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="8f051c1386e5d7793a46792a39ce291a486c3239" translate="yes" xml:space="preserve">
          <source>To specify this relationship to the compiler, use&lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt;. &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; specify a list of &lt;em&gt;roots&lt;/em&gt; whose contents are expected to merge at run-time. So following our example, the &lt;code&gt;tsconfig.json&lt;/code&gt; file should look like:</source>
          <target state="translated">この関係をコンパイラーに指定するには、 &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; 使用します。 &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; は、実行時に内容がマージされることが予想される&lt;em&gt;ルートの&lt;/em&gt;リストを指定します。したがって、この例に &lt;code&gt;tsconfig.json&lt;/code&gt; と、tsconfig.jsonファイルは次のようになります。</target>
        </trans-unit>
        <trans-unit id="815547684a56e87f0f61f4eec10d3298c1894627" translate="yes" xml:space="preserve">
          <source>To start off, let&amp;rsquo;s do the &amp;ldquo;hello world&amp;rdquo; of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the &lt;code&gt;echo&lt;/code&gt; command.</source>
          <target state="translated">最初に、ジェネリックの「こんにちは世界」、アイデンティティ関数を実行してみましょう。アイデンティティ関数は、渡されたものを何でも返す関数です。これは、 &lt;code&gt;echo&lt;/code&gt; コマンドと同じように考えることができます。</target>
        </trans-unit>
        <trans-unit id="e5b9fe870e7f5bf7070c8d8bb27856dc22fe14ff" translate="yes" xml:space="preserve">
          <source>To start, we&amp;rsquo;re going to structure our project in the following way:</source>
          <target state="translated">まず、プロジェクトを次のように構成します。</target>
        </trans-unit>
        <trans-unit id="c6351bd2f28ea37dec03ce0f4f1566144d901482" translate="yes" xml:space="preserve">
          <source>To understand the full impact, read &lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;the section above on the &lt;code&gt;useDefineForClassFields&lt;/code&gt; flag&lt;/a&gt;.</source>
          <target state="translated">完全な影響を理解する&lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;には、 &lt;code&gt;useDefineForClassFields&lt;/code&gt; フラグに関する上記のセクションをお&lt;/a&gt;読みください。</target>
        </trans-unit>
        <trans-unit id="f47b632fb61682e3e1980ea8cfc2ca8c1262d2a4" translate="yes" xml:space="preserve">
          <source>To understand what steps the TS compiler will follow, it is important to shed some light on Node.js modules. Traditionally, imports in Node.js are performed by calling a function named &lt;code&gt;require&lt;/code&gt;. The behavior Node.js takes will differ depending on if &lt;code&gt;require&lt;/code&gt; is given a relative path or a non-relative path.</source>
          <target state="translated">TSコンパイラが実行する手順を理解するには、Node.jsモジュールに光を当てることが重要です。従来、Node.jsでのインポートは、 &lt;code&gt;require&lt;/code&gt; という名前の関数を呼び出すことで実行されていました。Node.jsの動作は、 &lt;code&gt;require&lt;/code&gt; に相対パスが指定されているか、非相対パスが指定されているかによって異なります。</target>
        </trans-unit>
        <trans-unit id="dfa2ee0b72c86bc53820792311112500d3168498" translate="yes" xml:space="preserve">
          <source>To use JSX with React you should use the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;React typings&lt;/a&gt;. These typings define the &lt;code&gt;JSX&lt;/code&gt; namespace appropriately for use with React.</source>
          <target state="translated">ReactでJSXを使用するには、&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;Reactタイピング&lt;/a&gt;を使用する必要があります。これらの型付けは、Reactで使用するために &lt;code&gt;JSX&lt;/code&gt; 名前空間を適切に定義します。</target>
        </trans-unit>
        <trans-unit id="4e99d36c2c814e6db91b56c7f1385a2856d73b4a" translate="yes" xml:space="preserve">
          <source>To use JSX-support with React you should use the &lt;a href=&quot;https://github.com/borisyankov/DefinitelyTyped/tree/master/react&quot;&gt;React typings&lt;/a&gt;. These typings define the &lt;code&gt;JSX&lt;/code&gt; namespace so that TypeScript can correctly check JSX expressions for React. For example:</source>
          <target state="translated">ReactでJSXサポートを使用するには、&lt;a href=&quot;https://github.com/borisyankov/DefinitelyTyped/tree/master/react&quot;&gt;Reactのタイピング&lt;/a&gt;を使用する必要があります。これらのタイピングは、TypeScriptがJSX式のReactを正しくチェックできるように、 &lt;code&gt;JSX&lt;/code&gt; 名前空間を定義します。例えば：</target>
        </trans-unit>
        <trans-unit id="8c8d5eec1e67cb76f8e5b9452d73b271fa703953" translate="yes" xml:space="preserve">
          <source>Today, most popular globally-accessible libraries are actually written as UMD libraries (see below). UMD library documentation is hard to distinguish from global library documentation. Before writing a global declaration file, make sure the library isn&amp;rsquo;t actually UMD.</source>
          <target state="translated">今日、最も人気のあるグローバルにアクセス可能なライブラリは、実際にはUMDライブラリとして記述されています（以下を参照）。UMDライブラリドキュメントは、グローバルライブラリドキュメントと区別が困難です。グローバル宣言ファイルを書き込む前に、ライブラリが実際にUMDではないことを確認してください。</target>
        </trans-unit>
        <trans-unit id="6fd792937ccf8cb9ce4609174a62036b37620b1a" translate="yes" xml:space="preserve">
          <source>Together (1) and (2) mean that we have to move our call to &lt;code&gt;browserify&lt;/code&gt; out of the &lt;code&gt;default&lt;/code&gt; task. And we have to give the function for &lt;code&gt;default&lt;/code&gt; a name since both Watchify and Gulp need to call it. Adding logging with (3) is optional but very useful for debugging your setup.</source>
          <target state="translated">一緒に（1）及び（2）私たちは私たちのために呼び出しを移動する必要があることを意味 &lt;code&gt;browserify&lt;/code&gt; のうち &lt;code&gt;default&lt;/code&gt; タスク。また、WatchifyとGulpの両方で呼び出す必要があるため、 &lt;code&gt;default&lt;/code&gt; の関数に名前を付ける必要があります。（3）を使用したロギングの追加はオプションですが、セットアップのデバッグに非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="90ffa057dee234ae14145ef7d88d4144f613ba98" translate="yes" xml:space="preserve">
          <source>Together with intersection types, we can make some pretty mind-bending types:</source>
          <target state="translated">交差点タイプと合わせて、かなり心を揺さぶるタイプを作ることができます。</target>
        </trans-unit>
        <trans-unit id="fc8a45a8bf9a321fc559be14ce628df7527276e1" translate="yes" xml:space="preserve">
          <source>Too many/too few arguments</source>
          <target state="translated">議論が多すぎる/少なすぎる</target>
        </trans-unit>
        <trans-unit id="d9b3553c61db15698937a8831d5f65646814ea45" translate="yes" xml:space="preserve">
          <source>ToolsVersion</source>
          <target state="translated">ToolsVersion</target>
        </trans-unit>
        <trans-unit id="2fcfbecfc781cdc6c205a4af08b389fbe5757349" translate="yes" xml:space="preserve">
          <source>Top-level &lt;code&gt;var&lt;/code&gt; statements or &lt;code&gt;function&lt;/code&gt; declarations</source>
          <target state="translated">トップレベルの &lt;code&gt;var&lt;/code&gt; ステートメントまたは &lt;code&gt;function&lt;/code&gt; 宣言</target>
        </trans-unit>
        <trans-unit id="d190cc42b7745bd9ac9a35c4f9aea03a1b699465" translate="yes" xml:space="preserve">
          <source>Tracing module resolution</source>
          <target state="translated">トレースモジュールの解像度</target>
        </trans-unit>
        <trans-unit id="23fcdfe71b99cac9d947ed514f12d8af78487a21" translate="yes" xml:space="preserve">
          <source>Trade-offs of Modules</source>
          <target state="translated">モジュールのトレードオフ</target>
        </trans-unit>
        <trans-unit id="53010e4ab65eb0ff069216401ae1c2dcb7276af7" translate="yes" xml:space="preserve">
          <source>Traditional JavaScript uses functions and prototype-based inheritance to build up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality and objects are built from these classes. Starting with ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers will be able to build their applications using this object-oriented class-based approach. In TypeScript, we allow developers to use these techniques now, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript.</source>
          <target state="translated">従来の JavaScript では、関数やプロトタイプベースの継承を使用して再利用可能なコンポーネントを構築していましたが、クラスが機能を継承し、そのクラスからオブジェクトが構築されるオブジェクト指向のアプローチに慣れているプログラマーにとっては、これは少し気まずいと感じるかもしれません。ECMAScript 2015(ECMAScript 6 としても知られている)から、JavaScript プログラマはこのオブジェクト指向のクラスベースのアプローチを使用してアプリケーションを構築できるようになります。TypeScriptでは、開発者がこれらの技術を今すぐに使用し、JavaScriptの次のバージョンを待つことなく、すべての主要なブラウザやプラットフォームで動作するJavaScriptにコンパイルできるようにしています。</target>
        </trans-unit>
        <trans-unit id="1539cd14df7b42b7daf67ab3a0fb1394a708ce8d" translate="yes" xml:space="preserve">
          <source>Trailing comma in function parameter and argument lists are now allowed. This is an implementation for a &lt;a href=&quot;https://jeffmo.github.io/es-trailing-function-commas/&quot;&gt;Stage-3 ECMAScript proposal&lt;/a&gt; that emits down to valid ES3/ES5/ES6.</source>
          <target state="translated">関数パラメーターと引数リストの末尾のコンマが許可されました。これは、有効なES3 / ES5 / ES6まで放出する&lt;a href=&quot;https://jeffmo.github.io/es-trailing-function-commas/&quot;&gt;Stage-3 ECMAScriptプロポーザルの&lt;/a&gt;実装です。</target>
        </trans-unit>
        <trans-unit id="676e9d1917b5b40fea52df91ac4e9afc970551cb" translate="yes" xml:space="preserve">
          <source>Trailing commas in function parameter and argument lists</source>
          <target state="translated">関数のパラメータおよび引数リストの末尾にあるカンマ</target>
        </trans-unit>
        <trans-unit id="346f219fb82d976707a1e387e3becf3823d4827c" translate="yes" xml:space="preserve">
          <source>Translate newer JavaScript constructs down to an older version like ECMAScript 5 (using &lt;code&gt;target&lt;/code&gt;).</source>
          <target state="translated">新しいJavaScriptコンストラクトをECMAScript 5などの古いバージョンに変換します（ &lt;code&gt;target&lt;/code&gt; を使用）。</target>
        </trans-unit>
        <trans-unit id="86523d66f5bea3f709bea059e7608d702a785b4a" translate="yes" xml:space="preserve">
          <source>Triple-Slash Directives</source>
          <target state="translated">トリプルスラッシュディレクティブ</target>
        </trans-unit>
        <trans-unit id="98c8afb6c3de9dfeb15ccf98245b5224564946da" translate="yes" xml:space="preserve">
          <source>Triple-slash directives are &lt;strong&gt;only&lt;/strong&gt; valid at the top of their containing file. A triple-slash directive can only be preceded by single or multi-line comments, including other triple-slash directives. If they are encountered following a statement or a declaration they are treated as regular single-line comments, and hold no special meaning.</source>
          <target state="translated">トリプルスラッシュディレクティブは、それらを含むファイルの先頭で&lt;strong&gt;のみ&lt;/strong&gt;有効です。トリプルスラッシュディレクティブの前には、他のトリプルスラッシュディレクティブを含め、1行または複数行のコメントのみを付けることができます。ステートメントまたは宣言の後に現れる場合は、通常の単一行​​コメントとして扱われ、特別な意味はありません。</target>
        </trans-unit>
        <trans-unit id="694056eae93e31824a823939ec9db90fae068479" translate="yes" xml:space="preserve">
          <source>Triple-slash directives are single-line comments containing a single XML tag. The contents of the comment are used as compiler directives.</source>
          <target state="translated">トリプルスラッシュディレクティブは、1 つの XML タグを含む 1 行コメントです。コメントの内容はコンパイラディレクティブとして使用されます。</target>
        </trans-unit>
        <trans-unit id="3c8912f7f0f56aa84a0690a0f86c344e802e0ceb" translate="yes" xml:space="preserve">
          <source>Triple-slash references instruct the compiler to include additional files in the compilation process.</source>
          <target state="translated">トリプルスラッシュ参照は、コンパイルプロセスに追加ファイルを含めるようにコンパイラに指示します。</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="a78911125d5984a872d05a288f51fc96a8c5d183" translate="yes" xml:space="preserve">
          <source>Tuple destructuring</source>
          <target state="translated">タプル破壊</target>
        </trans-unit>
        <trans-unit id="5501f69a4f42fb8e135b4df10c2273778be704fd" translate="yes" xml:space="preserve">
          <source>Tuple types</source>
          <target state="translated">タプル型</target>
        </trans-unit>
        <trans-unit id="f4c8d119fb4e608da43d1f1658b2fb16039d3ae4" translate="yes" xml:space="preserve">
          <source>Tuple types allow you to express an array with a fixed number of elements whose types are known, but need not be the same. For example, you may want to represent a value as a pair of a &lt;code&gt;string&lt;/code&gt; and a &lt;code&gt;number&lt;/code&gt;:</source>
          <target state="translated">タプル型を使用すると、型がわかっているが同じである必要がない要素の数が固定されている配列を表現できます。たとえば、値を &lt;code&gt;string&lt;/code&gt; と &lt;code&gt;number&lt;/code&gt; ペアとして表すことができます。</target>
        </trans-unit>
        <trans-unit id="b40c00912c71e3e2a5296ac9e1c04677483c24ca" translate="yes" xml:space="preserve">
          <source>Tuple types express an array where the type of certain elements is known, but need not be the same. For example, you may want to represent an array with a &lt;code&gt;string&lt;/code&gt; at position 0 and a &lt;code&gt;number&lt;/code&gt; at position 1:</source>
          <target state="translated">タプル型は、特定の要素の型がわかっている配列を表しますが、同じである必要はありません。たとえば、位置0に &lt;code&gt;string&lt;/code&gt; あり、位置1に &lt;code&gt;number&lt;/code&gt; ある配列を表すことができます。</target>
        </trans-unit>
        <trans-unit id="3e80f8a540a40c8de1af1a3e84fbfd7f02d4e041" translate="yes" xml:space="preserve">
          <source>Tuple types now permit a &lt;code&gt;?&lt;/code&gt; postfix on element types to indicate that the element is optional:</source>
          <target state="translated">タプル型で &lt;code&gt;?&lt;/code&gt; 要素がオプションであることを示す要素タイプの後置。</target>
        </trans-unit>
        <trans-unit id="670c49cda0efba0500f15dd982d4fa2aed2d3f11" translate="yes" xml:space="preserve">
          <source>Tuples in rest parameters and spread expressions</source>
          <target state="translated">残りのパラメータとスプレッド式のタプル</target>
        </trans-unit>
        <trans-unit id="20bb571234709f16dbeaea6bc15866de96b8321d" translate="yes" xml:space="preserve">
          <source>Tuples may be destructured like arrays; the destructuring variables get the types of the corresponding tuple elements:</source>
          <target state="translated">タプルは配列のように破壊することができます;破壊変数は対応するタプル要素の型を取得します。</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="96e00fe98faa413635ba213d31572b56fb6e2bb5" translate="yes" xml:space="preserve">
          <source>Type Alias</source>
          <target state="translated">タイプエイリアス</target>
        </trans-unit>
        <trans-unit id="353ce315d4b89d72fbf39db84d79fda4b261f3b6" translate="yes" xml:space="preserve">
          <source>Type Aliases</source>
          <target state="translated">型別名</target>
        </trans-unit>
        <trans-unit id="a6de4b535fedeaa8890bd890b60fe09f87b5f96a" translate="yes" xml:space="preserve">
          <source>Type Checking</source>
          <target state="translated">タイプチェック</target>
        </trans-unit>
        <trans-unit id="69fccbed8b512e180b2e56eec7bf36107d0fc4af" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files</source>
          <target state="translated">JavaScriptファイルをチェックするタイプ</target>
        </trans-unit>
        <trans-unit id="c9bb3cb2e0b8995f27923c9071e954a24b9a502b" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @enum</source>
          <target state="translated">JavaScriptファイルをチェックするタイプ。固有のファイル名</target>
        </trans-unit>
        <trans-unit id="e1907e29cdd514784f2fa3e5a5c0bdf2cc55da0a" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @this</source>
          <target state="translated">JavaScriptファイルをチェックするタイプ。この</target>
        </trans-unit>
        <trans-unit id="facd96a18391e3f3e7ddd9cef95660e1b7913914" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @type</source>
          <target state="translated">JavaScriptファイルをチェックするタイプ。タイプ</target>
        </trans-unit>
        <trans-unit id="9e95ef0e2279689ee3c96fd9dc0e3216f9ec17ae" translate="yes" xml:space="preserve">
          <source>Type Compatibility</source>
          <target state="translated">タイプの互換性</target>
        </trans-unit>
        <trans-unit id="e9dc1ea4bae0ebaf470542aca51daa44cdcc9111" translate="yes" xml:space="preserve">
          <source>Type Compatibility: Enums</source>
          <target state="translated">タイプの互換性。列挙型</target>
        </trans-unit>
        <trans-unit id="5ce9a2f030a10c54388849495b66d1858de81a97" translate="yes" xml:space="preserve">
          <source>Type Declarations</source>
          <target state="translated">タイプ宣言</target>
        </trans-unit>
        <trans-unit id="165b26b05bf5c16d49e5cf4d678908fdae6f68f4" translate="yes" xml:space="preserve">
          <source>Type Guards</source>
          <target state="translated">タイプガード</target>
        </trans-unit>
        <trans-unit id="400e9828133bab9e18749f6f036fd264029f1e6c" translate="yes" xml:space="preserve">
          <source>Type Guards and Differentiating Types</source>
          <target state="translated">タイプガードとタイプの違い</target>
        </trans-unit>
        <trans-unit id="79b8bfde654e6b575d1b453221740941f040398d" translate="yes" xml:space="preserve">
          <source>Type Inference</source>
          <target state="translated">型推論</target>
        </trans-unit>
        <trans-unit id="0e2e016dff9c3ffe6b4498005a639ca83394f86e" translate="yes" xml:space="preserve">
          <source>Type aliases are exactly the same as their original types; they are simply alternative names.</source>
          <target state="translated">型のエイリアスは元の型と全く同じです。</target>
        </trans-unit>
        <trans-unit id="04332612727d798a56e4c9adf1af2f0e95c39d60" translate="yes" xml:space="preserve">
          <source>Type aliases create a new name for a type. Type aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you&amp;rsquo;d otherwise have to write by hand.</source>
          <target state="translated">タイプエイリアスは、タイプの新しい名前を作成します。型のエイリアスはインターフェイスに似ている場合がありますが、プリミティブ、ユニオン、タプル、および手動で記述する必要があるその他の型に名前を付けることができます。</target>
        </trans-unit>
        <trans-unit id="74b2b8803d08ed1d0626e3ffe8a2182c1309b352" translate="yes" xml:space="preserve">
          <source>Type aliases have always had a limitation in how they could be &amp;ldquo;recursively&amp;rdquo; referenced. The reason is that any use of a type alias needs to be able to substitute itself with whatever it aliases. In some cases, that&amp;rsquo;s not possible, so the compiler rejects certain recursive aliases like the following:</source>
          <target state="translated">タイプエイリアスには、「再帰的に」参照できる方法に常に制限がありました。その理由は、型エイリアスを使用する場合は、それ自体をエイリアスで置き換えることができる必要があるためです。場合によってはそれが不可能なため、コンパイラーは次のような特定の再帰エイリアスを拒否します。</target>
        </trans-unit>
        <trans-unit id="ee5f3de7938afc6193f57957cf627bbf0b440e19" translate="yes" xml:space="preserve">
          <source>Type annotations</source>
          <target state="translated">型のアノテーション</target>
        </trans-unit>
        <trans-unit id="771c581ff30572b5e74a273ca4a6cfa2c2dd00e9" translate="yes" xml:space="preserve">
          <source>Type annotations in TypeScript are lightweight ways to record the intended contract of the function or variable. In this case, we intend the greeter function to be called with a single string parameter. We can try changing the call greeter to pass an array instead:</source>
          <target state="translated">TypeScriptの型アノテーションは、関数や変数の意図する契約を記録するための軽量な方法です。この例では、greeter関数が単一の文字列パラメータで呼び出されることを意図しています。代わりに配列を渡すように greeter の呼び出しを変更してみましょう。</target>
        </trans-unit>
        <trans-unit id="4c0bd0a7f58c36c032f4bebd542b40c8d83ddd62" translate="yes" xml:space="preserve">
          <source>Type assertion/cast syntax in &lt;code&gt;checkJs&lt;/code&gt;/&lt;code&gt;@ts-check&lt;/code&gt; mode</source>
          <target state="translated">&lt;code&gt;checkJs&lt;/code&gt; / &lt;code&gt;@ts-check&lt;/code&gt; モードでのアサーション/キャスト構文の入力</target>
        </trans-unit>
        <trans-unit id="8207094f90fa241c769cf714f68957046cb3e948" translate="yes" xml:space="preserve">
          <source>Type assertions</source>
          <target state="translated">型のアサーション</target>
        </trans-unit>
        <trans-unit id="9d46ff18751ffb41bab6a1e95fa3947ce8fb07c0" translate="yes" xml:space="preserve">
          <source>Type assertions have two forms. One is the &amp;ldquo;angle-bracket&amp;rdquo; syntax:</source>
          <target state="translated">型アサーションには2つの形式があります。1つは「山かっこ」構文です。</target>
        </trans-unit>
        <trans-unit id="252726c38b1deeaec7381a04cf0566bc59bbe5ae" translate="yes" xml:space="preserve">
          <source>Type checking of the &lt;code&gt;instanceof&lt;/code&gt; operator is now based on whether the type of the left operand &lt;em&gt;derives from&lt;/em&gt; the type indicated by the right operand (as opposed to a structural subtype check).</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; 演算子の型チェックは、（構造サブタイプチェックではなく）左のオペランドの型が右のオペランドで示される型&lt;em&gt;から派生&lt;/em&gt;するかどうかに基づいています。</target>
        </trans-unit>
        <trans-unit id="3986b509fdf26a1e0d932541d6bf318fa2f131c4" translate="yes" xml:space="preserve">
          <source>Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is in contrast with nominal typing. Consider the following code:</source>
          <target state="translated">TypeScript における型の互換性は、構造的なサブタイプに基づいています。構造的型付けとは、型のメンバのみに基づいて型を関連付ける方法です。これは名目型付けとは対照的です。次のコードを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="d40d6a67837031f0abaec956923830758108f84e" translate="yes" xml:space="preserve">
          <source>Type guards and type assertions</source>
          <target state="translated">タイプガードとタイプアサーション</target>
        </trans-unit>
        <trans-unit id="df0459267a3773c5f28373435d5ec35b5af11cce" translate="yes" xml:space="preserve">
          <source>Type guards for dotted names also work with user defined type guard functions and the &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt; operators and do not depend on the &lt;code&gt;--strictNullChecks&lt;/code&gt; compiler option.</source>
          <target state="translated">ドット表記名のタイプガードは、ユーザー定義のタイプガード関数、 &lt;code&gt;typeof&lt;/code&gt; および &lt;code&gt;instanceof&lt;/code&gt; 演算子でも機能し、 &lt;code&gt;--strictNullChecks&lt;/code&gt; コンパイラオプションに依存しません。</target>
        </trans-unit>
        <trans-unit id="df87981f3212072661057f255c1414c8249e617d" translate="yes" xml:space="preserve">
          <source>Type guards inferred from &lt;code&gt;in&lt;/code&gt; operator</source>
          <target state="translated">推測タイプのガード &lt;code&gt;in&lt;/code&gt; オペレータ</target>
        </trans-unit>
        <trans-unit id="5c04d68c075d1cf49c5039cfaf5a91d9a3af3583" translate="yes" xml:space="preserve">
          <source>Type guards on the common property.</source>
          <target state="translated">共用地にタイプガードを設置。</target>
        </trans-unit>
        <trans-unit id="4a16ed7f934fd06b2eab4f404c014b3aa9ede6e0" translate="yes" xml:space="preserve">
          <source>Type guards previously only supported checking local variables and parameters. Type guards now support checking &amp;ldquo;dotted names&amp;rdquo; consisting of a variable or parameter name followed one or more property accesses.</source>
          <target state="translated">タイプガードは、以前はローカル変数とパラメーターのチェックのみをサポートしていました。タイプガードは、変数またはパラメーター名とそれに続く1つ以上のプロパティアクセスで構成される「ドット表記名」のチェックをサポートするようになりました。</target>
        </trans-unit>
        <trans-unit id="a6fec2d2cb8ea42fc5e8b24e33871a744a3803c5" translate="yes" xml:space="preserve">
          <source>Type in the boxes and confirm that the breakpoint hits in TypeScript code and that inspection works correctly.</source>
          <target state="translated">ボックスに入力して、TypeScriptのコードでブレークポイントがヒットし、検査が正しく動作することを確認します。</target>
        </trans-unit>
        <trans-unit id="04a0aaa0033ce536b51805d3619fe260b178891e" translate="yes" xml:space="preserve">
          <source>Type inference also works in &amp;ldquo;the other direction&amp;rdquo; in some cases in TypeScript. This is known as &amp;ldquo;contextual typing&amp;rdquo;. Contextual typing occurs when the type of an expression is implied by its location. For example:</source>
          <target state="translated">型推論は、TypeScriptの場合によっては「反対方向」にも機能します。これは「コンテキストタイピング」と呼ばれます。コンテキストタイプは、式のタイプがその場所によって暗示されるときに発生します。例えば：</target>
        </trans-unit>
        <trans-unit id="5b50efd50f8efbd22bb877ea81f90fae7f14657c" translate="yes" xml:space="preserve">
          <source>Type inference in conditional types</source>
          <target state="translated">条件付き型の型推論</target>
        </trans-unit>
        <trans-unit id="34f7e0851caaf9f6232cdc334af3947615acc7f1" translate="yes" xml:space="preserve">
          <source>Type parameter inference from contextual types</source>
          <target state="translated">コンテキスト型からの型パラメータ推論</target>
        </trans-unit>
        <trans-unit id="866c38bce26d304928239997fc8fd61be65a48c4" translate="yes" xml:space="preserve">
          <source>Type parameters as constraints</source>
          <target state="translated">制約としての型パラメータ</target>
        </trans-unit>
        <trans-unit id="83cb868a19ad904f84bd14cae43f07e0e83d2688" translate="yes" xml:space="preserve">
          <source>Type widening</source>
          <target state="translated">タイプワイド化</target>
        </trans-unit>
        <trans-unit id="3e24ac06d77df39af05bd30d658cb57a3337ea7e" translate="yes" xml:space="preserve">
          <source>Type-checking for &lt;code&gt;globalThis&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;globalThis&lt;/code&gt; の型チェック</target>
        </trans-unit>
        <trans-unit id="132ee1e5890623f8c51b5d7832771ea869685cc0" translate="yes" xml:space="preserve">
          <source>Type-checking speed-ups</source>
          <target state="translated">タイプチェックのスピードアップ</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="51f19890936977049a98344a575f9d1393582141" translate="yes" xml:space="preserve">
          <source>TypeScript 1.1</source>
          <target state="translated">TypeScript 1.1</target>
        </trans-unit>
        <trans-unit id="b1d54818952af192cd88b3450b54f2603e4f7e6b" translate="yes" xml:space="preserve">
          <source>TypeScript 1.3</source>
          <target state="translated">TypeScript 1.3</target>
        </trans-unit>
        <trans-unit id="4e048202597f480e0a0a50251a2d17601a97331c" translate="yes" xml:space="preserve">
          <source>TypeScript 1.4</source>
          <target state="translated">TypeScript 1.4</target>
        </trans-unit>
        <trans-unit id="f1963162918ae8e217f030a5c747f80a58b5003c" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5</source>
          <target state="translated">TypeScript 1.5</target>
        </trans-unit>
        <trans-unit id="f1a5005d913327706c332f5d05905d598d513f83" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 adds support to ES6 destructuring declarations and assignments.</source>
          <target state="translated">TypeScript 1.5 では、ES6 のデストラクチャリング宣言と代入のサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="335ed14095b748ea23e413ca55e75e72c5f81c2f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 adds support to ES6 for..of loops on arrays for ES3/ES5 as well as full support for Iterator interfaces when targeting ES6.</source>
          <target state="translated">TypeScript 1.5 では、ES3/ES5 での配列上でのループのサポートに加え、ES6 をターゲットにした場合の Iterator インターフェイスのフルサポートが追加されています。</target>
        </trans-unit>
        <trans-unit id="147499580851a581c1ebc7b1eb35e61574c9455f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 supports ECMAScript 6 (ES6) modules. ES6 modules are effectively TypeScript external modules with a new syntax: ES6 modules are separately loaded source files that possibly import other modules and provide a number of externally accessible exports. ES6 modules feature several new export and import declarations. It is recommended that TypeScript libraries and applications be updated to use the new syntax, but this is not a requirement. The new ES6 module syntax coexists with TypeScript&amp;rsquo;s original internal and external module constructs and the constructs can be mixed and matched at will.</source>
          <target state="translated">TypeScript 1.5はECMAScript 6（ES6）モジュールをサポートしています。ES6モジュールは事実上、新しい構文のTypeScript外部モジュールです。ES6モジュールは、他のモジュールをインポートし、外部からアクセス可能な多数のエクスポートを提供する個別に読み込まれたソースファイルです。ES6モジュールは、いくつかの新しいエクスポートおよびインポート宣言を備えています。TypeScriptライブラリとアプリケーションを更新して新しい構文を使用することをお勧めしますが、これは必須ではありません。新しいES6モジュールの構文は、TypeScriptの元の内部および外部モジュール構成と共存し、構成は自由に組み合わせて組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="26a05cf740016ec03540fa113e60b6681f5d2b43" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6</source>
          <target state="translated">TypeScript 1.6</target>
        </trans-unit>
        <trans-unit id="257249ad75fda76652230e9b8ec23343f481d876" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds a new way to narrow a variable type inside an &lt;code&gt;if&lt;/code&gt; block, in addition to &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt;. A user-defined type guard functions is one with a return type annotation of the form &lt;code&gt;x is T&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is a declared parameter in the signature, and &lt;code&gt;T&lt;/code&gt; is any type. When a user-defined type guard function is invoked on a variable in an &lt;code&gt;if&lt;/code&gt; block, the type of the variable will be narrowed to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.6では、 &lt;code&gt;typeof&lt;/code&gt; および &lt;code&gt;instanceof&lt;/code&gt; に加えて、 &lt;code&gt;if&lt;/code&gt; ブロック内の変数の型を絞り込む新しい方法が追加されています。ユーザー定義のタイプガード関数は、 &lt;code&gt;x is T&lt;/code&gt; という形式の戻り値型注釈を持つ関数です。ここで、 &lt;code&gt;x&lt;/code&gt; はシグネチャの宣言されたパラメーターで、 &lt;code&gt;T&lt;/code&gt; は任意のタイプです。 &lt;code&gt;if&lt;/code&gt; ブロックの変数でユーザー定義型のガード関数が呼び出されると、変数の型は &lt;code&gt;T&lt;/code&gt; に狭められます。</target>
        </trans-unit>
        <trans-unit id="1f559afb4f11f75baf94b34b6c1d2a9f3ffb7db7" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for &lt;code&gt;abstract&lt;/code&gt; keyword for classes and their methods. An abstract class is allowed to have methods with no implementation, and cannot be constructed.</source>
          <target state="translated">TypeScript 1.6では、クラスとそのメソッドの &lt;code&gt;abstract&lt;/code&gt; キーワードのサポートが追加されています。抽象クラスは、実装のないメソッドを持つことが許可されており、構築することはできません。</target>
        </trans-unit>
        <trans-unit id="b5e601692f8167fd347befb7fc0e15d90de2b5e2" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for ES6 class expressions. In a class expression, the class name is optional and, if specified, is only in scope in the class expression itself. This is similar to the optional name of a function expression. It is not possible to refer to the class instance type of a class expression outside the class expression, but the type can of course be matched structurally. For example:</source>
          <target state="translated">TypeScript 1.6 では、ES6 のクラス式のサポートが追加されました。クラス式では、クラス名はオプションであり、指定された場合、クラス式自体のスコープ内にのみ存在します。これは関数式のオプション名と似ています。クラス式の外でクラス式のクラスインスタンス型を参照することはできませんが、もちろん型は構造的に一致させることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="d34db5c0571adb17d9dbb4e011e6ce7abf305442" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for classes extending arbitrary expression that computes a constructor function. This means that built-in types can now be extended in class declarations.</source>
          <target state="translated">TypeScript 1.6 では、コンストラクタ関数を計算する任意の式を拡張するクラスのサポートが追加されました。これは、組み込み型をクラス宣言で拡張できるようになったことを意味します。</target>
        </trans-unit>
        <trans-unit id="6dc2d923fb5094bd0e7c94f1ead891676ccf6b36" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for generators when targeting ES6.</source>
          <target state="translated">TypeScript 1.6では、ES6をターゲットにした場合のジェネレータのサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="c2708dce6a915f6b14074965fa09a0d65239987f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 enforces stricter object literal assignment checks for the purpose of catching excess or misspelled properties. Specifically, when a fresh object literal is assigned to a variable or passed as an argument for a non-empty target type, it is an error for the object literal to specify properties that don&amp;rsquo;t exist in the target type.</source>
          <target state="translated">TypeScript 1.6は、過剰なプロパティやスペルミスのあるプロパティをキャッチする目的で、より厳密なオブジェクトリテラル割り当てチェックを実施します。具体的には、新しいオブジェクトリテラルが変数に割り当てられているか、空でないターゲットタイプの引数として渡されている場合、オブジェクトリテラルがターゲットタイプに存在しないプロパティを指定するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="75bb78b9b873fbe1d3340640c97864da1f68f446" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces a new &lt;code&gt;.tsx&lt;/code&gt; file extension. This extension does two things: it enables JSX inside of TypeScript files, and it makes the new &lt;code&gt;as&lt;/code&gt; operator the default way to cast (removing any ambiguity between JSX expressions and the TypeScript prefix cast operator). For example:</source>
          <target state="translated">TypeScript 1.6では、新しい &lt;code&gt;.tsx&lt;/code&gt; ファイル拡張子が導入されています。この拡張機能は2つのことを行います。TypeScriptファイル内でJSXを有効にし、新しい &lt;code&gt;as&lt;/code&gt; 演算子をデフォルトのキャスト方法にします（JSX式とTypeScriptプレフィックスキャスト演算子のあいまいさを取り除く）。例えば：</target>
        </trans-unit>
        <trans-unit id="389c8891386ded2a5990a7399a0c8581f595589d" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces experimental support of &lt;code&gt;async&lt;/code&gt; functions when targeting ES6. Async functions are expected to invoke an asynchronous operation and await its result without blocking normal execution of the program. This accomplished through the use of an ES6-compatible &lt;code&gt;Promise&lt;/code&gt; implementation, and transposition of the function body into a compatible form to resume execution when the awaited asynchronous operation completes.</source>
          <target state="translated">TypeScript 1.6では、ES6を対象とする場合の &lt;code&gt;async&lt;/code&gt; 関数の実験的なサポートが導入されています。非同期関数は、非同期操作を呼び出し、プログラムの通常の実行をブロックせずに結果を待つことが期待されています。これは、ES6互換の &lt;code&gt;Promise&lt;/code&gt; 実装の使用と、待機中の非同期操作が完了したときに実行を再開するための互換性のある形式への関数本体の転置によって達成されました。</target>
        </trans-unit>
        <trans-unit id="6d3985068c5007795b0f129f437f0236376e44ee" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces intersection types, the logical complement of union types. A union type &lt;code&gt;A | B&lt;/code&gt; represents an entity that is either of type &lt;code&gt;A&lt;/code&gt; or type &lt;code&gt;B&lt;/code&gt;, whereas an intersection type &lt;code&gt;A &amp;amp; B&lt;/code&gt; represents an entity that is both of type &lt;code&gt;A&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; type &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.6では、共用体型の論理的な補完である交差型が導入されています。ユニオンタイプ &lt;code&gt;A | B&lt;/code&gt; はタイプ &lt;code&gt;A&lt;/code&gt; またはタイプ &lt;code&gt;B&lt;/code&gt; のいずれかのエンティティーを表し、交差タイプ &lt;code&gt;A &amp;amp; B&lt;/code&gt; はタイプ &lt;code&gt;A&lt;/code&gt; &lt;em&gt;と&lt;/em&gt;タイプ &lt;code&gt;B&lt;/code&gt; の両方のエンティティーを表します。</target>
        </trans-unit>
        <trans-unit id="5adb28b0e2ffb9129f1f8e6e88f1a6d027c82cfd" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7</source>
          <target state="translated">TypeScript 1.7</target>
        </trans-unit>
        <trans-unit id="b8049d25161330d1dbcbb77bfa401335476ed317" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 adds &lt;code&gt;ES6&lt;/code&gt; to the list of options available for the &lt;code&gt;--module&lt;/code&gt; flag and allows you to specify the module output when targeting &lt;code&gt;ES6&lt;/code&gt;. This provides more flexibility to target exactly the features you want in specific runtimes.</source>
          <target state="translated">活字体1.7が追加されます &lt;code&gt;ES6&lt;/code&gt; のために利用可能なオプションのリストに &lt;code&gt;--module&lt;/code&gt; フラグ、あなたがターゲットとする場合、モジュールの出力を指定することができます &lt;code&gt;ES6&lt;/code&gt; を。これにより、特定のランタイムで必要な機能を的確にターゲットにできる柔軟性が高まります。</target>
        </trans-unit>
        <trans-unit id="372cae9853890909499623bfc1859384ca77ae13" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 makes checking of destructuring patterns with an object literal or array literal initializers less rigid and more intuitive.</source>
          <target state="translated">TypeScript 1.7 では、オブジェクトリテラルや配列リテラルのイニシャライザを使った破壊パターンのチェックが、より堅苦しくなく、より直感的に行えるようになりました。</target>
        </trans-unit>
        <trans-unit id="3a8e0881b9f6a916c5d699f8a8930f131e755c61" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 supports upcoming &lt;a href=&quot;https://github.com/rwaldron/exponentiation-operator&quot;&gt;ES7/ES2016 exponentiation operators&lt;/a&gt;: &lt;code&gt;**&lt;/code&gt; and &lt;code&gt;**=&lt;/code&gt;. The operators will be transformed in the output to ES3/ES5 using &lt;code&gt;Math.pow&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.7は、次の&lt;a href=&quot;https://github.com/rwaldron/exponentiation-operator&quot;&gt;ES7 / ES2016指数演算子を&lt;/a&gt;サポートします： &lt;code&gt;**&lt;/code&gt; および &lt;code&gt;**=&lt;/code&gt; 。演算子は、 &lt;code&gt;Math.pow&lt;/code&gt; を使用して出力でES3 / ES5に変換されます。</target>
        </trans-unit>
        <trans-unit id="90324bee80eec2d37872bcfe8ebd584d982ffa5e" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8</source>
          <target state="translated">TypeScript 1.8</target>
        </trans-unit>
        <trans-unit id="bf434e8d29bed8fa2f0c97832e4f7465ceae4e51" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 allows &lt;code&gt;tsconfig.json&lt;/code&gt; files in all project types. This includes ASP.NET v4 projects, &lt;em&gt;Console Application&lt;/em&gt;, and the &lt;em&gt;Html Application with TypeScript&lt;/em&gt; project types. Further, you are no longer limited to a single &lt;code&gt;tsconfig.json&lt;/code&gt; file but can add multiple, and each will be built as part of the project. This allows you to separate the configuration for different parts of your application without having to use multiple different projects.</source>
          <target state="translated">TypeScript 1.8では、すべてのプロジェクトタイプで &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを使用できます。これには、ASP.NET v4プロジェクト、&lt;em&gt;コンソールアプリケーション&lt;/em&gt;、および&lt;em&gt;TypeScript&lt;/em&gt;プロジェクトタイプの&lt;em&gt;HTMLアプリケーションが&lt;/em&gt;含まれます。さらに、1つの &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルに制限されることはなくなりましたが、複数を追加でき、それぞれがプロジェクトの一部としてビルドされます。これにより、複数の異なるプロジェクトを使用せずに、アプリケーションのさまざまな部分の構成を分離できます。</target>
        </trans-unit>
        <trans-unit id="523ae0c6d720551553d08e322cbe5f48827a2f11" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 allows users to use the &lt;code&gt;--outFile&lt;/code&gt; argument with special file system entities like named pipes, devices, etc.</source>
          <target state="translated">TypeScript 1.8では、名前付きパイプやデバイスなどの特別なファイルシステムエンティティで &lt;code&gt;--outFile&lt;/code&gt; 引数を使用できます。</target>
        </trans-unit>
        <trans-unit id="c4f9c3f076e54a2df1c744ed292a1d25e9395f14" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 extends &lt;a href=&quot;typescript-1.6#user-defined-type-guard-functions&quot;&gt;user-defined type guard functions&lt;/a&gt; to class and interface methods.</source>
          <target state="translated">TypeScript 1.8は、&lt;a href=&quot;typescript-1.6#user-defined-type-guard-functions&quot;&gt;ユーザー定義のタイプガード関数&lt;/a&gt;をクラスおよびインターフェースメソッドに拡張します。</target>
        </trans-unit>
        <trans-unit id="c547a86975df477d786c26c38684de89346ada33" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 improves type inference involving source and target sides that are both union or intersection types. For example, when inferring from &lt;code&gt;string | string[]&lt;/code&gt; to &lt;code&gt;string | T&lt;/code&gt;, we reduce the types to &lt;code&gt;string[]&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt;, thus inferring &lt;code&gt;string[]&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.8は、和集合または交差型であるソース側とターゲット側を含む型推論を改善します。たとえば、 &lt;code&gt;string | string[]&lt;/code&gt; から推測する場合| string []から &lt;code&gt;string | T&lt;/code&gt; は、我々はに種類を減らす &lt;code&gt;string[]&lt;/code&gt; および &lt;code&gt;T&lt;/code&gt; ので推測、 &lt;code&gt;string[]&lt;/code&gt; のために &lt;code&gt;T&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="8f21f8b70d4093a0a0b9a977e3f5e108e10ca93f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 introduces control flow analysis to help catch common errors that users tend to run into. Read on to get more details, and check out these errors in action:</source>
          <target state="translated">TypeScript 1.8 では、ユーザーが遭遇しがちな一般的なエラーを検出するためのコントロールフロー解析が導入されました。詳細はこちらを読んで、これらのエラーを実際に確認してください。</target>
        </trans-unit>
        <trans-unit id="316c73dc14076f7eaec6a1b058acbdbcd6b03a9b" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0</source>
          <target state="translated">タイプスクリプト2.0</target>
        </trans-unit>
        <trans-unit id="7ed2b43586705d3525a6d00f06348de23a60d9e8" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 adds a new &lt;code&gt;--skipLibCheck&lt;/code&gt; compiler option that causes type checking of declaration files (files with extension &lt;code&gt;.d.ts&lt;/code&gt;) to be skipped. When a program includes large declaration files, the compiler spends a lot of time type checking declarations that are already known to not contain errors, and compile times may be significantly shortened by skipping declaration file type checks.</source>
          <target state="translated">TypeScript 2.0には、宣言ファイル（拡張子が &lt;code&gt;.d.ts&lt;/code&gt; のファイル）の型チェックをスキップする新しい &lt;code&gt;--skipLibCheck&lt;/code&gt; コンパイラオプションが追加されています。プログラムに大きな宣言ファイルが含まれている場合、コンパイラーは多くの時間を費やして、すでにエラーが含まれていないことがわかっている宣言の型検査を行い、宣言ファイルの型検査をスキップすることでコンパイル時間を大幅に短縮できます。</target>
        </trans-unit>
        <trans-unit id="5a7e5d59bd5cadb1929863b64869919254d9fa38" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 has two new flags to help you maintain a clean code base. &lt;code&gt;--noUnusedParameters&lt;/code&gt; flags any unused function or method parameters errors. &lt;code&gt;--noUnusedLocals&lt;/code&gt; flags any unused local (un-exported) declaration like variables, functions, classes, imports, etc&amp;hellip; Also, unused private members of a class would be flagged as errors under &lt;code&gt;--noUnusedLocals&lt;/code&gt;.</source>
          <target state="translated">TypeScript 2.0には、クリーンなコードベースを維持するのに役立つ2つの新しいフラグがあります。 &lt;code&gt;--noUnusedParameters&lt;/code&gt; は、未使用の関数またはメソッドパラメータのエラーにフラグを立てます。 &lt;code&gt;--noUnusedLocals&lt;/code&gt; は、変数、関数、クラス、インポートなどの未使用のローカル（エクスポートされていない）宣言にフラグを付けます。また、クラスの未使用のプライベートメンバーには、 &lt;code&gt;--noUnusedLocals&lt;/code&gt; でエラーのフラグが付けられます。</target>
        </trans-unit>
        <trans-unit id="cc8a687464d96e2157a2c30deb24a3363ed46e0d" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 implements a control flow-based type analysis for local variables and parameters. Previously, the type analysis performed for type guards was limited to &lt;code&gt;if&lt;/code&gt; statements and &lt;code&gt;?:&lt;/code&gt; conditional expressions and didn&amp;rsquo;t include effects of assignments and control flow constructs such as &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;break&lt;/code&gt; statements. With TypeScript 2.0, the type checker analyses all possible flows of control in statements and expressions to produce the most specific type possible (the &lt;em&gt;narrowed type&lt;/em&gt;) at any given location for a local variable or parameter that is declared to have a union type.</source>
          <target state="translated">TypeScript 2.0は、ローカル変数およびパラメーターの制御フローベースの型分析を実装します。以前は、タイプガードに対して実行されるタイプ分析は、 &lt;code&gt;if&lt;/code&gt; ステートメントと &lt;code&gt;?:&lt;/code&gt; 条件式に限定され、割り当ての影響や、 &lt;code&gt;return&lt;/code&gt; ステートメントや &lt;code&gt;break&lt;/code&gt; ステートメントなどの制御フロー構造は含まれていませんでした。 TypeScript 2.0では、型チェッカーがステートメントと式で考えられるすべての制御フローを分析し、union型を持つと宣言されているローカル変数またはパラメーターの任意の場所で、最も具体的な型（&lt;em&gt;ナロー型&lt;/em&gt;）を生成します。</target>
        </trans-unit>
        <trans-unit id="b991a7d51345ee804bcdb5d52051777fdcb20357" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 implements support for tagged (or discriminated) union types. Specifically, the TS compiler now support type guards that narrow union types based on tests of a discriminant property and furthermore extend that capability to &lt;code&gt;switch&lt;/code&gt; statements.</source>
          <target state="translated">TypeScript 2.0は、タグ付き（または識別された）共用体型のサポートを実装しています。具体的には、TSコンパイラは、判別特性のテストに基づいて共用体型を絞り込み、さらにその機能を拡張してステートメントを &lt;code&gt;switch&lt;/code&gt; タイプガードをサポートするようになりました。</target>
        </trans-unit>
        <trans-unit id="f541e32a97ad0b756a4e358c4745c3b45d62017f" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 introduces a new primitive type &lt;code&gt;never&lt;/code&gt;. The &lt;code&gt;never&lt;/code&gt; type represents the type of values that never occur. Specifically, &lt;code&gt;never&lt;/code&gt; is the return type for functions that never return and &lt;code&gt;never&lt;/code&gt; is the type of variables under type guards that are never true.</source>
          <target state="translated">TypeScript 2.0では、新しいプリミティブ型 &lt;code&gt;never&lt;/code&gt; 導入されていません。 &lt;code&gt;never&lt;/code&gt; 種類は発生しない値の種類を表します。具体的には、 &lt;code&gt;never&lt;/code&gt; 戻らない関数の戻り値の型ではありませんし、 &lt;code&gt;never&lt;/code&gt; 本当のことはありません型のガード下の変数のタイプです。</target>
        </trans-unit>
        <trans-unit id="c6947ff29cc72002ee0d4fa4f9ecea90ea690c25" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 provides a set of additional module resolution knops to &lt;em&gt;inform&lt;/em&gt; the compiler where to find declarations for a given module.</source>
          <target state="translated">TypeScript 2.0は、特定のモジュールの宣言を見つける場所をコンパイラーに&lt;em&gt;通知&lt;/em&gt;するための追加のモジュール解決ノブのセットを提供します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
