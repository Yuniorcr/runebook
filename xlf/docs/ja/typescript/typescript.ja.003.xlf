<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="90cda15a62a8aabc97010caa6808ab78ddacdf3d" translate="yes" xml:space="preserve">
          <source>In strict null checking mode, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values are &lt;em&gt;not&lt;/em&gt; in the domain of every type and are only assignable to themselves and &lt;code&gt;any&lt;/code&gt; (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). So, whereas &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;T | undefined&lt;/code&gt; are considered synonymous in regular type checking mode (because &lt;code&gt;undefined&lt;/code&gt; is considered a subtype of any &lt;code&gt;T&lt;/code&gt;), they are different types in strict type checking mode, and only &lt;code&gt;T | undefined&lt;/code&gt; permits &lt;code&gt;undefined&lt;/code&gt; values. The same is true for the relationship of &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;T | null&lt;/code&gt;.</source>
          <target state="translated">厳密なnullチェックモードでは、 &lt;code&gt;null&lt;/code&gt; 値と &lt;code&gt;undefined&lt;/code&gt; 値はすべての型のドメインに存在する&lt;em&gt;わけ&lt;/em&gt;では&lt;em&gt;なく&lt;/em&gt;、自分自身と &lt;code&gt;any&lt;/code&gt; にのみ割り当て可能です（ &lt;code&gt;undefined&lt;/code&gt; は &lt;code&gt;void&lt;/code&gt; にも割り当て可能です）。つまり、 &lt;code&gt;T&lt;/code&gt; と &lt;code&gt;T | undefined&lt;/code&gt; は、通常の型チェックモードでは同義語と見なされます（ &lt;code&gt;undefined&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; のサブタイプと見なされるため）。これらは、厳密な型チェックモードでは異なる型であり、 &lt;code&gt;T | undefined&lt;/code&gt; のみです。undefinedは &lt;code&gt;undefined&lt;/code&gt; 値を許可します。 &lt;code&gt;T&lt;/code&gt; とTの関係についても同様です。 &lt;code&gt;T | null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="864d1a7dd1f8dd603a28df5bb3a63874ccc5a6ed" translate="yes" xml:space="preserve">
          <source>In strict null checking mode, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values are not in the domain of every type and are only assignable to themselves and &lt;code&gt;any&lt;/code&gt; (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">厳密なnullチェックモードでは、 &lt;code&gt;null&lt;/code&gt; 値と &lt;code&gt;undefined&lt;/code&gt; 値はすべての型のドメイン内にあるわけではなく、自分自身と &lt;code&gt;any&lt;/code&gt; にのみ割り当て可能です（ &lt;code&gt;undefined&lt;/code&gt; は &lt;code&gt;void&lt;/code&gt; にも割り当て可能です）。</target>
        </trans-unit>
        <trans-unit id="1682f16f9b1d6f4b318f3d23665b6e6fd98e0061" translate="yes" xml:space="preserve">
          <source>In that example, we first checked whether &lt;code&gt;x&lt;/code&gt; was &lt;em&gt;not&lt;/em&gt;&lt;code&gt;E.Foo&lt;/code&gt;. If that check succeeds, then our &lt;code&gt;||&lt;/code&gt; will short-circuit, and the body of the &amp;lsquo;if&amp;rsquo; will run. However, if the check didn&amp;rsquo;t succeed, then &lt;code&gt;x&lt;/code&gt; can &lt;em&gt;only&lt;/em&gt; be &lt;code&gt;E.Foo&lt;/code&gt;, so it doesn&amp;rsquo;t make sense to see whether it&amp;rsquo;s equal to &lt;code&gt;E.Bar&lt;/code&gt;.</source>
          <target state="translated">その例では、最初に &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;E.Foo&lt;/code&gt; で&lt;em&gt;ない&lt;/em&gt;かどうかを確認しました。そのチェックが成功した場合、 &lt;code&gt;||&lt;/code&gt; 短絡し、「if」の本体が実行されます。ただし、チェックが成功しなかった場合、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;E.Foo&lt;/code&gt; に&lt;em&gt;しか&lt;/em&gt;なり得ないため、 &lt;code&gt;E.Bar&lt;/code&gt; と等しいかどうかを確認しても意味がありません。</target>
        </trans-unit>
        <trans-unit id="6bb5ff5bf0dceac10cc35060c81ee9faad7242ab" translate="yes" xml:space="preserve">
          <source>In the 20+ years since its standardization, JavaScript has come a very long way. While in 2020, JavaScript can be used on servers, in data science, and even on IoT devices, it is important to remember its most popular use case: web browsers.</source>
          <target state="translated">標準化されてからの20年以上の間に、JavaScriptは非常に長い道のりを歩んできました。2020年には、JavaScriptはサーバーやデータサイエンス、さらにはIoTデバイスでも使用できるようになっていますが、最も一般的なユースケースであるWebブラウザを覚えておくことが重要です。</target>
        </trans-unit>
        <trans-unit id="6db5a8c7126c3ff13b89dab79253baece66850d2" translate="yes" xml:space="preserve">
          <source>In the Template section you&amp;rsquo;ll find a number of declaration files that serve as a useful starting point when writing a new file. If you already know what your structure is, see the d.ts Template section in the sidebar.</source>
          <target state="translated">テンプレートセクションには、新しいファイルを作成するときに役立つ開始点として役立つ宣言ファイルがいくつかあります。構造が何であるかをすでに知っている場合は、サイドバーのd.tsテンプレートセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="548f3708a85b8745e47e7af1b59669e8ecf4cfa7" translate="yes" xml:space="preserve">
          <source>In the above case:</source>
          <target state="translated">上記のケースでは</target>
        </trans-unit>
        <trans-unit id="79540091a75f3fdf1fb7b3a682d8e9c3c45c75f2" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;&amp;lt;foo /&amp;gt;&lt;/code&gt; will work fine but &lt;code&gt;&amp;lt;bar /&amp;gt;&lt;/code&gt; will result in an error since it has not been specified on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;.</source>
          <target state="translated">上記の例では、 &lt;code&gt;&amp;lt;foo /&amp;gt;&lt;/code&gt; は正常に機能しますが、 &lt;code&gt;&amp;lt;bar /&amp;gt;&lt;/code&gt; は &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; で指定されていないため、エラーになります。</target>
        </trans-unit>
        <trans-unit id="99596fbea2ab9226b233fd913b5eb437d1c67537" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;SelectableControl&lt;/code&gt; contains all of the members of &lt;code&gt;Control&lt;/code&gt;, including the private &lt;code&gt;state&lt;/code&gt; property. Since &lt;code&gt;state&lt;/code&gt; is a private member it is only possible for descendants of &lt;code&gt;Control&lt;/code&gt; to implement &lt;code&gt;SelectableControl&lt;/code&gt;. This is because only descendants of &lt;code&gt;Control&lt;/code&gt; will have a &lt;code&gt;state&lt;/code&gt; private member that originates in the same declaration, which is a requirement for private members to be compatible.</source>
          <target state="translated">上記の例では、 &lt;code&gt;SelectableControl&lt;/code&gt; には、プライベート &lt;code&gt;state&lt;/code&gt; プロパティを含む &lt;code&gt;Control&lt;/code&gt; のすべてのメンバーが含まれています。以来 &lt;code&gt;state&lt;/code&gt; プライベートメンバであるの子孫のためにのみ可能である &lt;code&gt;Control&lt;/code&gt; 実装する &lt;code&gt;SelectableControl&lt;/code&gt; を。これは、 &lt;code&gt;Control&lt;/code&gt; の子孫だけが同じ宣言で始まる &lt;code&gt;state&lt;/code&gt; プライベートメンバーを持つためです。これは、プライベートメンバーが互換性を持つための要件です。</target>
        </trans-unit>
        <trans-unit id="6ed88f77aa26355727030898d3eda06664af6814" translate="yes" xml:space="preserve">
          <source>In the above example, all declarations of &lt;code&gt;x&lt;/code&gt; actually refer to the &lt;em&gt;same&lt;/em&gt;&lt;code&gt;x&lt;/code&gt;, and this is perfectly valid. This often ends up being a source of bugs. Thankfully, &lt;code&gt;let&lt;/code&gt; declarations are not as forgiving.</source>
          <target state="translated">上記の例では、 &lt;code&gt;x&lt;/code&gt; のすべての宣言が実際には&lt;em&gt;同じ&lt;/em&gt; &lt;code&gt;x&lt;/code&gt; を参照しており、これは完全に有効です。これは多くの場合、バグの原因となります。ありがたいことに &lt;code&gt;let&lt;/code&gt; 宣言は寛容ではありません。</target>
        </trans-unit>
        <trans-unit id="c61ebd05e2312c5e85ecc6cef6e59dba4f593f68" translate="yes" xml:space="preserve">
          <source>In the above example, if we&amp;rsquo;re importing from &lt;code&gt;&quot;package-name&quot;&lt;/code&gt;, TypeScript will try to resolve from &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; (and other relevant paths) when running in TypeScript 3.1. If we import from &lt;code&gt;package-name/foo&lt;/code&gt;, we&amp;rsquo;ll try to look for &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; and &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt;.</source>
          <target state="translated">上記の例では、 &lt;code&gt;&quot;package-name&quot;&lt;/code&gt; からインポートする場合、TypeScriptは &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; （およびその他の関連パス）から解決しようとします。 TypeScript3.1で実行している場合。 &lt;code&gt;package-name/foo&lt;/code&gt; からインポートする場合は、 &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; および &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt; を検索しようとします。/ts3.1/foo/index.d.ts。</target>
        </trans-unit>
        <trans-unit id="bf0ee9dcee21963bf1982f4a5b086175197a8510" translate="yes" xml:space="preserve">
          <source>In the above form, the mixin&amp;rsquo;s have no underlying knowledge of the class which can make it hard to create the design you want.</source>
          <target state="translated">上記の形式では、ミックスインにはクラスの基礎知識がないため、必要なデザインを作成するのが難しくなります。</target>
        </trans-unit>
        <trans-unit id="b37f0e6648f951eed9141c60cd7cf7e3ccaa9494" translate="yes" xml:space="preserve">
          <source>In the above, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are compatible because their structures do not use the type argument in a differentiating way. Changing this example by adding a member to &lt;code&gt;Empty&amp;lt;T&amp;gt;&lt;/code&gt; shows how this works:</source>
          <target state="translated">上記では、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は互換性があります。これらの構造は型引数を区別する方法で使用しないためです。メンバーを &lt;code&gt;Empty&amp;lt;T&amp;gt;&lt;/code&gt; 追加してこの例を変更すると、これがどのように機能するかがわかります。</target>
        </trans-unit>
        <trans-unit id="bcf8f6881cecc6ec19e3b84c191f76d8a00ed9f0" translate="yes" xml:space="preserve">
          <source>In the above, if we truly meant for &lt;code&gt;baz&lt;/code&gt; to potentially be &lt;code&gt;undefined&lt;/code&gt;, we should have declared it with the type &lt;code&gt;boolean | undefined&lt;/code&gt;.</source>
          <target state="translated">上記で、もし本当に &lt;code&gt;baz&lt;/code&gt; が &lt;code&gt;undefined&lt;/code&gt; になる可能性があることを意図しているなら、タイプ &lt;code&gt;boolean | undefined&lt;/code&gt; それを宣言するべきでした。未定義。</target>
        </trans-unit>
        <trans-unit id="ce3f57dfeaf54342e6e1919ab8d0e5f056d046b7" translate="yes" xml:space="preserve">
          <source>In the above, the variable &lt;code&gt;a&lt;/code&gt; has a conditional type that hasn&amp;rsquo;t yet chosen a branch. When another piece of code ends up calling &lt;code&gt;foo&lt;/code&gt;, it will substitute in &lt;code&gt;U&lt;/code&gt; with some other type, and TypeScript will re-evaluate the conditional type, deciding whether it can actually pick a branch.</source>
          <target state="translated">上記では、変数 &lt;code&gt;a&lt;/code&gt; はまだブランチを選択していない条件付きタイプを持っています。別のコードが &lt;code&gt;foo&lt;/code&gt; を呼び出すと、 &lt;code&gt;U&lt;/code&gt; は別のタイプに置き換えられ、TypeScriptは条件付きタイプを再評価して、実際にブランチを選択できるかどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="61a17b1c1f756acdcb3aa7db7732994bae993575" translate="yes" xml:space="preserve">
          <source>In the code below, we show how you can model mixins in TypeScript. After the code, we&amp;rsquo;ll break down how it works.</source>
          <target state="translated">以下のコードでは、TypeScriptでミックスインをモデル化する方法を示します。コードの後で、それがどのように機能するかを分析します。</target>
        </trans-unit>
        <trans-unit id="03d5f48ae796a4f0c523d1b9798d453b05171c1c" translate="yes" xml:space="preserve">
          <source>In the declaration of &lt;code&gt;f2&lt;/code&gt; above, type inference infers types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;[string, boolean]&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; respectively.</source>
          <target state="translated">上記の &lt;code&gt;f2&lt;/code&gt; の宣言では、型推論は &lt;code&gt;T&lt;/code&gt; 、 &lt;code&gt;U&lt;/code&gt; 、および &lt;code&gt;V&lt;/code&gt; の &lt;code&gt;number&lt;/code&gt; 、 &lt;code&gt;[string, boolean]&lt;/code&gt; および &lt;code&gt;void&lt;/code&gt; をそれぞれ推論します。</target>
        </trans-unit>
        <trans-unit id="8ab389301f78b38cc120b50ad55981dfdf9ab9b4" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;methods&lt;/code&gt; object in the argument to &lt;code&gt;makeObject&lt;/code&gt; has a contextual type that includes &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; and therefore the type of &lt;a href=&quot;functions#this&quot;&gt;this&lt;/a&gt; in methods within the &lt;code&gt;methods&lt;/code&gt; object is &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt;. Notice how the type of the &lt;code&gt;methods&lt;/code&gt; property simultaneously is an inference target and a source for the &lt;code&gt;this&lt;/code&gt; type in methods.</source>
          <target state="translated">上記の例では、 &lt;code&gt;makeObject&lt;/code&gt; の引数の &lt;code&gt;methods&lt;/code&gt; オブジェクトは、 &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; を含むコンテキスト型を持っているため、 &lt;code&gt;methods&lt;/code&gt; オブジェクト内のメソッドの&lt;a href=&quot;functions#this&quot;&gt;this&lt;/a&gt;の型は &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt; 。 &lt;code&gt;methods&lt;/code&gt; プロパティのタイプが、メソッド内の &lt;code&gt;this&lt;/code&gt; タイプの推論ターゲットとソースであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="95157007d65e1f4f235f4c91408fe5a0cb118ec2" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;methods&lt;/code&gt; object in the argument to &lt;code&gt;makeObject&lt;/code&gt; has a contextual type that includes &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; and therefore the type of &lt;code&gt;this&lt;/code&gt; in methods within the &lt;code&gt;methods&lt;/code&gt; object is &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt;. Notice how the type of the &lt;code&gt;methods&lt;/code&gt; property simultaneously is an inference target and a source for the &lt;code&gt;this&lt;/code&gt; type in methods.</source>
          <target state="translated">上記の例では、 &lt;code&gt;makeObject&lt;/code&gt; の引数の &lt;code&gt;methods&lt;/code&gt; オブジェクトは、 &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; を含むコンテキストタイプを持っているため、 &lt;code&gt;methods&lt;/code&gt; オブジェクト内のメソッドの &lt;code&gt;this&lt;/code&gt; のタイプは &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt; 。 &lt;code&gt;methods&lt;/code&gt; プロパティの型が、推論のターゲットであり、メソッド内の &lt;code&gt;this&lt;/code&gt; 型のソースであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6d5d9e4e961d95a62eff2086560d0f53e21c16be" translate="yes" xml:space="preserve">
          <source>In the example above, the parameters &lt;code&gt;fruit&lt;/code&gt; and &lt;code&gt;color&lt;/code&gt; are intersected together to a new parameter of type &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt;. &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; is really the same as &lt;code&gt;(&quot;apple&quot; | &quot;orange&quot;) &amp;amp; (&quot;red&quot; | &quot;orange&quot;)&lt;/code&gt; which is equivalent to &lt;code&gt;(&quot;apple&quot; &amp;amp; &quot;red&quot;) | (&quot;apple&quot; &amp;amp; &quot;orange&quot;) | (&quot;orange&quot; &amp;amp; &quot;red&quot;) | (&quot;orange&quot; &amp;amp; &quot;orange&quot;)&lt;/code&gt;. Each of those impossible intersections reduces to &lt;code&gt;never&lt;/code&gt;, and we&amp;rsquo;re left with &lt;code&gt;&quot;orange&quot; &amp;amp; &quot;orange&quot;&lt;/code&gt; which is just &lt;code&gt;&quot;orange&quot;&lt;/code&gt;.</source>
          <target state="translated">上記の例では、パラメーター &lt;code&gt;fruit&lt;/code&gt; と &lt;code&gt;color&lt;/code&gt; が交差して、タイプ &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; 新しいパラメーターになっています。 &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; は &lt;code&gt;(&quot;apple&quot; | &quot;orange&quot;) &amp;amp; (&quot;red&quot; | &quot;orange&quot;)&lt;/code&gt; と同じで、 &lt;code&gt;(&quot;apple&quot; &amp;amp; &quot;red&quot;) | (&quot;apple&quot; &amp;amp; &quot;orange&quot;) | (&quot;orange&quot; &amp;amp; &quot;red&quot;) | (&quot;orange&quot; &amp;amp; &quot;orange&quot;)&lt;/code&gt; と同等です。 （ &quot;リンゴ&quot;＆ &quot;オレンジ&quot;）| （ &quot;オレンジ&quot;＆ &quot;赤&quot;）| （ &quot;オレンジ&quot;＆ &quot;オレンジ&quot;）。これらのことは不可能交差点のそれぞれに減少し &lt;code&gt;never&lt;/code&gt; 、私たちがが残っている &lt;code&gt;&quot;orange&quot; &amp;amp; &quot;orange&quot;&lt;/code&gt; だけで &lt;code&gt;&quot;orange&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3d9dddab39b8eb943f3877822ffa8bdb3bae451" translate="yes" xml:space="preserve">
          <source>In the first &lt;code&gt;length&lt;/code&gt;, T is not necessary; notice that it&amp;rsquo;s only referenced once, so it&amp;rsquo;s not being used to constrain the type of the return value or other parameters.</source>
          <target state="translated">最初の &lt;code&gt;length&lt;/code&gt; では、Tは必要ありません。参照されるのは1回だけなので、戻り値やその他のパラメーターのタイプを制約するために使用されていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="e74ceca454671112b40bc5e5f6a4f738b5ff4300" translate="yes" xml:space="preserve">
          <source>In the following example, each input element will be printed out one at a time with a 400ms delay:</source>
          <target state="translated">以下の例では、各入力要素が400msの遅延で1つずつプリントアウトされます。</target>
        </trans-unit>
        <trans-unit id="d0896b9003166f205cee791b2a20d447c0e588fb" translate="yes" xml:space="preserve">
          <source>In the interests of clarity and brevity, the main content of the Handbook will not explore every edge case or minutiae of the features being covered. You can find more details on particular concepts in the reference articles.</source>
          <target state="translated">明快さと簡潔さのために、このハンドブックの主な内容は、カバーされている機能のすべてのエッジケースや細かな点を探求するものではありません。特定の概念についての詳細は、参考記事を参照してください。</target>
        </trans-unit>
        <trans-unit id="8c77483272b3e6dc467114f873247e6bedc0a970" translate="yes" xml:space="preserve">
          <source>In the last line we construct an instance of the &lt;code&gt;Greeter&lt;/code&gt; class using &lt;code&gt;new&lt;/code&gt;. This calls into the constructor we defined earlier, creating a new object with the &lt;code&gt;Greeter&lt;/code&gt; shape, and running the constructor to initialize it.</source>
          <target state="translated">最後の行では、 &lt;code&gt;new&lt;/code&gt; を使用して &lt;code&gt;Greeter&lt;/code&gt; クラスのインスタンスを作成します。これにより、前に定義したコンストラクターが呼び出され、 &lt;code&gt;Greeter&lt;/code&gt; シェイプを持つ新しいオブジェクトが作成され、コンストラクターが実行されて初期化されます。</target>
        </trans-unit>
        <trans-unit id="00dda950efe1878e4784a73323a690e1209928a7" translate="yes" xml:space="preserve">
          <source>In the last window, select the &lt;strong&gt;Empty&lt;/strong&gt; template and press the &lt;em&gt;Create&lt;/em&gt; button</source>
          <target state="translated">最後のウィンドウで、&lt;strong&gt;空の&lt;/strong&gt;テンプレートを選択し、&lt;em&gt;作成&lt;/em&gt;ボタンを押します</target>
        </trans-unit>
        <trans-unit id="730482750c8e706f4fdc3f8ccd811c5e5dd87860" translate="yes" xml:space="preserve">
          <source>In the meantime, we can assign a conditional type to any other target type as long as each branch of the conditional is assignable to that target. So in our example above we were able to assign &lt;code&gt;U extends Foo ? string : number&lt;/code&gt; to &lt;code&gt;string | number&lt;/code&gt; since no matter what the conditional evaluates to, it&amp;rsquo;s known to be either &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">その間、条件の各ブランチがそのターゲットに割り当て可能である限り、条件タイプを他のターゲットタイプに割り当てることができます。上記の例では、 &lt;code&gt;U extends Foo ? string : number&lt;/code&gt; を割り当てることができましたか？文字列：文字列への数値 &lt;code&gt;string | number&lt;/code&gt; 、どちらかであることが知られていますするものを、条件付き評価さに関係なく、以降の &lt;code&gt;string&lt;/code&gt; または &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fa79973a1fa7675ac6793a6ef6bc0254a0e6be8" translate="yes" xml:space="preserve">
          <source>In the near future, we&amp;rsquo;re going to be refreshing the playground samples, adding JSX support, and polishing automatic type acquisition, meaning that you&amp;rsquo;ll be able to see the same experience on the playground as you&amp;rsquo;d get in your personal editor.</source>
          <target state="translated">近い将来、遊び場のサンプルを更新し、JSXサポートを追加し、自動タイプ取得を改善する予定です。つまり、パーソナルエディターと同じように、遊び場で同じエクスペリエンスを見ることができます。 。</target>
        </trans-unit>
        <trans-unit id="b3d6d530b9dead34dd8c0b86ef1bb298c7054a3c" translate="yes" xml:space="preserve">
          <source>In the project root, &lt;code&gt;proj&lt;/code&gt;, create the file &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">プロジェクトルート &lt;code&gt;proj&lt;/code&gt; で、ファイル &lt;code&gt;tsconfig.json&lt;/code&gt; を作成します。</target>
        </trans-unit>
        <trans-unit id="709cd93c7870c32633ca0a9bee5820c6fc2cb1c9" translate="yes" xml:space="preserve">
          <source>In the project root, create the file &lt;code&gt;gulpfile.js&lt;/code&gt;:</source>
          <target state="translated">プロジェクトのルートで、ファイル &lt;code&gt;gulpfile.js&lt;/code&gt; を作成します。</target>
        </trans-unit>
        <trans-unit id="73b6e04bf922a9cb6a95afcfe0525fa94ba745bd" translate="yes" xml:space="preserve">
          <source>In the type of a module object, exported &lt;code&gt;const&lt;/code&gt; variables are considered read-only properties.</source>
          <target state="translated">モジュールオブジェクトのタイプでは、エクスポートされた &lt;code&gt;const&lt;/code&gt; 変数は読み取り専用プロパティと見なされます。</target>
        </trans-unit>
        <trans-unit id="755da82a78f6c2a7ac8e76c0724da8dab740a01c" translate="yes" xml:space="preserve">
          <source>In the type of an enum object, enum members are considered read-only properties.</source>
          <target state="translated">enumオブジェクトの型では、enumメンバは読み取り専用のプロパティとみなされます。</target>
        </trans-unit>
        <trans-unit id="637246693f4b6e39ecb694cc209862482bcc6694" translate="yes" xml:space="preserve">
          <source>In these examples, the properties list is &lt;code&gt;keyof T&lt;/code&gt; and the resulting type is some variant of &lt;code&gt;T[P]&lt;/code&gt;. This is a good template for any general use of mapped types. That&amp;rsquo;s because this kind of transformation is &lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphism&quot;&gt;homomorphic&lt;/a&gt;, which means that the mapping applies only to properties of &lt;code&gt;T&lt;/code&gt; and no others. The compiler knows that it can copy all the existing property modifiers before adding any new ones. For example, if &lt;code&gt;Person.name&lt;/code&gt; was readonly, &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; would be readonly and optional.</source>
          <target state="translated">これらの例では、プロパティリストは &lt;code&gt;keyof T&lt;/code&gt; あり、結果の型は &lt;code&gt;T[P]&lt;/code&gt; バリアントです。これは、マップされた型の一般的な使用に適したテンプレートです。これは、この種の変換が&lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphism&quot;&gt;準同型&lt;/a&gt;であるためです。つまり、マッピングは &lt;code&gt;T&lt;/code&gt; のプロパティにのみ適用され、他のプロパティには適用されません。コンパイラーは、新しいプロパティー修飾子を追加する前に、既存のすべてのプロパティー修飾子をコピーできることを知っています。たとえば、 &lt;code&gt;Person.name&lt;/code&gt; が読み取り専用の場合、 &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; は読み取り専用でオプションになります。</target>
        </trans-unit>
        <trans-unit id="9c7ec405a4a58ac2e2e3c9c60919a90fae57f264" translate="yes" xml:space="preserve">
          <source>In these examples, the properties list is &lt;code&gt;keyof T&lt;/code&gt; and the resulting type is some variant of &lt;code&gt;T[P]&lt;/code&gt;. This is a good template for any general use of mapped types. That&amp;rsquo;s because this kind of transformation is &lt;a href=&quot;https://wikipedia.org/wiki/Homomorphism&quot;&gt;homomorphic&lt;/a&gt;, which means that the mapping applies only to properties of &lt;code&gt;T&lt;/code&gt; and no others. The compiler knows that it can copy all the existing property modifiers before adding any new ones. For example, if &lt;code&gt;Person.name&lt;/code&gt; was readonly, &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; would be readonly and optional.</source>
          <target state="translated">これらの例では、プロパティリストは &lt;code&gt;keyof T&lt;/code&gt; であり、結果のタイプは &lt;code&gt;T[P]&lt;/code&gt; バリアントです。これは、マップされた型の一般的な使用に適したテンプレートです。これは、この種の変換が&lt;a href=&quot;https://wikipedia.org/wiki/Homomorphism&quot;&gt;準同型&lt;/a&gt;であるためです。つまり、マッピングは &lt;code&gt;T&lt;/code&gt; のプロパティにのみ適用され、他のプロパティには適用されません。コンパイラは、新しいプロパティ修飾子を追加する前に、既存のすべてのプロパティ修飾子をコピーできることを認識しています。たとえば、 &lt;code&gt;Person.name&lt;/code&gt; が読み取り専用の場合、 &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; は読み取り専用でオプションになります。</target>
        </trans-unit>
        <trans-unit id="ed7a5a445e563d2e25cbaa994041bb2fd2483e73" translate="yes" xml:space="preserve">
          <source>In this above example, &lt;code&gt;g&lt;/code&gt; captured the variable &lt;code&gt;a&lt;/code&gt; declared in &lt;code&gt;f&lt;/code&gt;. At any point that &lt;code&gt;g&lt;/code&gt; gets called, the value of &lt;code&gt;a&lt;/code&gt; will be tied to the value of &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;f&lt;/code&gt;. Even if &lt;code&gt;g&lt;/code&gt; is called once &lt;code&gt;f&lt;/code&gt; is done running, it will be able to access and modify &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">この上の例では、 &lt;code&gt;g&lt;/code&gt; は &lt;code&gt;f&lt;/code&gt; で宣言された変数 &lt;code&gt;a&lt;/code&gt; をキャプチャしました。ことを任意の時点で &lt;code&gt;g&lt;/code&gt; 呼び出される、の値の値に接続されるで &lt;code&gt;f&lt;/code&gt; 。場合でも &lt;code&gt;g&lt;/code&gt; 一度呼び出された &lt;code&gt;f&lt;/code&gt; が動作して行われ、それがアクセスできるようして修正します。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8516f6347c523b45eca06136cb8874b9907d612" translate="yes" xml:space="preserve">
          <source>In this case, we need to use TypeScript to tell any of our callers about the ways &lt;code&gt;myCoolFunction&lt;/code&gt; can be called using function overloads.</source>
          <target state="translated">この場合、TypeScriptを使用して、関数のオーバーロードを使用して &lt;code&gt;myCoolFunction&lt;/code&gt; を呼び出す方法を呼び出し元に通知する必要があります。</target>
        </trans-unit>
        <trans-unit id="ca269f81daa4e288c099aeabd210add3bf701ab7" translate="yes" xml:space="preserve">
          <source>In this case, you can tell the TypeScript file resolver to support a number of custom prefixes to find code. This pattern can be used to avoid long relative paths within your codebase.</source>
          <target state="translated">この場合、TypeScript ファイルリゾルバにコードを見つけるためのいくつかのカスタム接頭辞をサポートするように指示することができます。このパターンは、コードベース内の長い相対パスを避けるために使われます。</target>
        </trans-unit>
        <trans-unit id="e0ee66fa54ed1af4b6530c2bbfb39ea8c9308255" translate="yes" xml:space="preserve">
          <source>In this case, you can use a &lt;code&gt;switch&lt;/code&gt; statement to narrow down which type is represented at runtime:</source>
          <target state="translated">この場合、 &lt;code&gt;switch&lt;/code&gt; ステートメントを使用して、実行時に表されるタイプを絞り込むことができます。</target>
        </trans-unit>
        <trans-unit id="e82ac6e4567b6044965f051115c0822a64abe344" translate="yes" xml:space="preserve">
          <source>In this example if &lt;code&gt;someValue&lt;/code&gt; isn&amp;rsquo;t equal to &lt;code&gt;42&lt;/code&gt;, then &lt;code&gt;assert&lt;/code&gt; will throw an &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;someValue&lt;/code&gt; が &lt;code&gt;42&lt;/code&gt; に等しくない場合、 &lt;code&gt;assert&lt;/code&gt; は &lt;code&gt;AssertionError&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="e08fcd6cf022585dcfea9733e021155ec20b4944" translate="yes" xml:space="preserve">
          <source>In this example the &lt;code&gt;b?&lt;/code&gt; indicates that &lt;code&gt;b&lt;/code&gt; is optional, so it may be &lt;code&gt;undefined&lt;/code&gt;. &lt;code&gt;keepWholeObject&lt;/code&gt; now has a variable for &lt;code&gt;wholeObject&lt;/code&gt; as well as the properties &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, even if &lt;code&gt;b&lt;/code&gt; is undefined.</source>
          <target state="translated">この例では、 &lt;code&gt;b?&lt;/code&gt; ことを示し &lt;code&gt;b&lt;/code&gt; 、それがすることができるので、任意である &lt;code&gt;undefined&lt;/code&gt; 。 &lt;code&gt;keepWholeObject&lt;/code&gt; は今の変数がある &lt;code&gt;wholeObject&lt;/code&gt; などの特性と &lt;code&gt;b&lt;/code&gt; しても、 &lt;code&gt;b&lt;/code&gt; 定義されていません。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0117e5cd2d6305504464fa64c2596948182a60ec" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;greeter1&lt;/code&gt; works similarly to before. We instantiate the &lt;code&gt;Greeter&lt;/code&gt; class, and use this object. This we have seen before.</source>
          <target state="translated">この例では、 &lt;code&gt;greeter1&lt;/code&gt; は以前と同様に機能します。 &lt;code&gt;Greeter&lt;/code&gt; クラスをインスタンス化し、このオブジェクトを使用します。これは以前に見たことがあります。</target>
        </trans-unit>
        <trans-unit id="dbc3444b1d43d45eab0b74e1029b727531c4431d" translate="yes" xml:space="preserve">
          <source>In this example, best common type has a set of four candidates: &lt;code&gt;Animal&lt;/code&gt;, &lt;code&gt;Rhino&lt;/code&gt;, &lt;code&gt;Elephant&lt;/code&gt;, and &lt;code&gt;Snake&lt;/code&gt;. Of these, &lt;code&gt;Animal&lt;/code&gt; can be chosen by the best common type algorithm.</source>
          <target state="translated">この例では、最も一般的なタイプには、 &lt;code&gt;Animal&lt;/code&gt; 、 &lt;code&gt;Rhino&lt;/code&gt; 、 &lt;code&gt;Elephant&lt;/code&gt; 、 &lt;code&gt;Snake&lt;/code&gt; の4つの候補のセットがあります。これらのうち、 &lt;code&gt;Animal&lt;/code&gt; は最も一般的なタイプのアルゴリズムによって選択できます。</target>
        </trans-unit>
        <trans-unit id="bb24f11a568ad33b4fe399d85ff9d360b565ca4d" translate="yes" xml:space="preserve">
          <source>In this example, the first block creates the following name meanings:</source>
          <target state="translated">この例では、最初のブロックは以下の名前の意味を作成します。</target>
        </trans-unit>
        <trans-unit id="6e7043ef257b3c1ba5ae99cc4588d236122d0645" translate="yes" xml:space="preserve">
          <source>In this example, there wasn&amp;rsquo;t a namespace &lt;code&gt;C&lt;/code&gt; until we wrote the &lt;code&gt;namespace&lt;/code&gt; declaration for it. The meaning &lt;code&gt;C&lt;/code&gt; as a namespace doesn&amp;rsquo;t conflict with the value or type meanings of &lt;code&gt;C&lt;/code&gt; created by the class.</source>
          <target state="translated">この例では、 &lt;code&gt;namespace&lt;/code&gt; 宣言を記述するまで、名前空間 &lt;code&gt;C&lt;/code&gt; はありませんでした。つまり &lt;code&gt;C&lt;/code&gt; の名前空間としては、の値またはタイプの意味と競合しない &lt;code&gt;C&lt;/code&gt; はクラスによって作成されました。</target>
        </trans-unit>
        <trans-unit id="07eb43c9c23afe5a52badab0f998515ac89c2d2c" translate="yes" xml:space="preserve">
          <source>In this example, we have an &lt;code&gt;Animal&lt;/code&gt; and a &lt;code&gt;Rhino&lt;/code&gt;, with &lt;code&gt;Rhino&lt;/code&gt; being a subclass of &lt;code&gt;Animal&lt;/code&gt;. We also have a new class &lt;code&gt;Employee&lt;/code&gt; that looks identical to &lt;code&gt;Animal&lt;/code&gt; in terms of shape. We create some instances of these classes and then try to assign them to each other to see what will happen. Because &lt;code&gt;Animal&lt;/code&gt; and &lt;code&gt;Rhino&lt;/code&gt; share the &lt;code&gt;private&lt;/code&gt; side of their shape from the same declaration of &lt;code&gt;private name: string&lt;/code&gt; in &lt;code&gt;Animal&lt;/code&gt;, they are compatible. However, this is not the case for &lt;code&gt;Employee&lt;/code&gt;. When we try to assign from an &lt;code&gt;Employee&lt;/code&gt; to &lt;code&gt;Animal&lt;/code&gt; we get an error that these types are not compatible. Even though &lt;code&gt;Employee&lt;/code&gt; also has a &lt;code&gt;private&lt;/code&gt; member called &lt;code&gt;name&lt;/code&gt;, it&amp;rsquo;s not the one we declared in &lt;code&gt;Animal&lt;/code&gt;.</source>
          <target state="translated">この例では、我々は持っている &lt;code&gt;Animal&lt;/code&gt; や &lt;code&gt;Rhino&lt;/code&gt; して、 &lt;code&gt;Rhino&lt;/code&gt; はのサブクラスであること &lt;code&gt;Animal&lt;/code&gt; 。また、形が &lt;code&gt;Animal&lt;/code&gt; と同じに見える新しいクラスの &lt;code&gt;Employee&lt;/code&gt; もいます。これらのクラスのインスタンスをいくつか作成し、それらを互いに割り当てて、何が起こるかを確認します。ので &lt;code&gt;Animal&lt;/code&gt; と &lt;code&gt;Rhino&lt;/code&gt; が共有する &lt;code&gt;private&lt;/code&gt; の同じ宣言からその形状の側面を &lt;code&gt;private name: string&lt;/code&gt; 中 &lt;code&gt;Animal&lt;/code&gt; 、彼らは互換性があります。ただし、これは &lt;code&gt;Employee&lt;/code&gt; には当てはまりません。 &lt;code&gt;Employee&lt;/code&gt; から割り当てようとするとき &lt;code&gt;Animal&lt;/code&gt; たちは、これらの型に互換性がないというエラーが発生します。 &lt;code&gt;Employee&lt;/code&gt; には &lt;code&gt;name&lt;/code&gt; という &lt;code&gt;private&lt;/code&gt; メンバーもいますが、 &lt;code&gt;Animal&lt;/code&gt; で宣言したメンバーではありません。</target>
        </trans-unit>
        <trans-unit id="b1b93b10a4841edacda1facc2b60962e38ac6558" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ll move all validator-related entities into a namespace called &lt;code&gt;Validation&lt;/code&gt;. Because we want the interfaces and classes here to be visible outside the namespace, we preface them with &lt;code&gt;export&lt;/code&gt;. Conversely, the variables &lt;code&gt;lettersRegexp&lt;/code&gt; and &lt;code&gt;numberRegexp&lt;/code&gt; are implementation details, so they are left unexported and will not be visible to code outside the namespace. In the test code at the bottom of the file, we now need to qualify the names of the types when used outside the namespace, e.g. &lt;code&gt;Validation.LettersOnlyValidator&lt;/code&gt;.</source>
          <target state="translated">この例では、すべてのバリデーター関連エンティティを &lt;code&gt;Validation&lt;/code&gt; という名前空間に移動します。ここではインターフェースとクラスが名前空間の外から見えるようにしたいので、それらの前に &lt;code&gt;export&lt;/code&gt; を付けます。逆に、変数 &lt;code&gt;lettersRegexp&lt;/code&gt; および &lt;code&gt;numberRegexp&lt;/code&gt; は実装の詳細であるため、エクスポートされずに残り、名前空間の外のコードからは見えません。ファイルの下部にあるテストコードで、名前空間の外で使用する場合は型の名前を修飾する必要があります（例： &lt;code&gt;Validation.LettersOnlyValidator&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="21b24c391b92fb3d3163326a7abc4416dc6df6f4" translate="yes" xml:space="preserve">
          <source>In this generated code, an enum is compiled into an object that stores both forward (&lt;code&gt;name&lt;/code&gt; -&amp;gt; &lt;code&gt;value&lt;/code&gt;) and reverse (&lt;code&gt;value&lt;/code&gt; -&amp;gt; &lt;code&gt;name&lt;/code&gt;) mappings. References to other enum members are always emitted as property accesses and never inlined.</source>
          <target state="translated">（この生成されたコードでは、列挙を格納フォワード両方ことオブジェクトにコンパイルされている &lt;code&gt;name&lt;/code&gt; - &amp;gt; &lt;code&gt;value&lt;/code&gt; ）および（リバース &lt;code&gt;value&lt;/code&gt; - &amp;gt; &lt;code&gt;name&lt;/code&gt; マッピング）。他の列挙型メンバーへの参照は、常にプロパティアクセスとして発行され、インライン化されることはありません。</target>
        </trans-unit>
        <trans-unit id="bdc69a132c77ea1870143e272db1728193078fad" translate="yes" xml:space="preserve">
          <source>In this guide, we&amp;rsquo;ll assume basic familiarity with the TypeScript language. If you haven&amp;rsquo;t already, you should read the &lt;a href=&quot;../basic-types&quot;&gt;TypeScript Handbook&lt;/a&gt; to familiarize yourself with basic concepts, especially types and namespaces.</source>
          <target state="translated">このガイドでは、TypeScript言語の基本的な知識があることを前提としています。まだの場合は、&lt;a href=&quot;../basic-types&quot;&gt;TypeScriptハンドブック&lt;/a&gt;を読んで、基本的な概念、特に型と名前空間について理解してください。</target>
        </trans-unit>
        <trans-unit id="daba3c5117e7e15297eb31c7463a628f5e08b0ec" translate="yes" xml:space="preserve">
          <source>In this introduction, I assume you know the following:</source>
          <target state="translated">今回の紹介では、以下のようなことをご存知の方を想定しています。</target>
        </trans-unit>
        <trans-unit id="344769647b81b7e0305ef0d99ae5fb65a087fe6f" translate="yes" xml:space="preserve">
          <source>In this mode, references to modules and packages (e.g. &lt;code&gt;import&lt;/code&gt;s and &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to. For a more concrete example, we&amp;rsquo;ll defer to &lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;the documentation on the Node.js website&lt;/a&gt;.</source>
          <target state="translated">このモードでは、モジュールおよびパッケージへの参照（たとえば、 &lt;code&gt;import&lt;/code&gt; sおよび &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; ディレクティブ）はすべて、シンボリックリンクファイルの場所を基準にして解決されます。シンボリックリンクが解決されます。より具体的な例については&lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;、Node.js Webサイトのドキュメントに従います&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e80e58412d6afa0148bbe0431cb48a4186ad829b" translate="yes" xml:space="preserve">
          <source>In this section we&amp;rsquo;ll describe various common pitfalls in using namespaces and modules, and how to avoid them.</source>
          <target state="translated">このセクションでは、名前空間とモジュールを使用する際の一般的なさまざまな落とし穴、およびそれらを回避する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="1517fdb2153dd36963c7b932505762d1e99e7637" translate="yes" xml:space="preserve">
          <source>In this section, we will cover type inference in TypeScript. Namely, we&amp;rsquo;ll discuss where and how types are inferred.</source>
          <target state="translated">このセクションでは、TypeScriptでの型推論について説明します。つまり、型が推論される場所と方法について説明します。</target>
        </trans-unit>
        <trans-unit id="bf72d17da27b309b1e4973b2684904a5f12bc9b3" translate="yes" xml:space="preserve">
          <source>In this simple example, &lt;code&gt;Keys&lt;/code&gt; is a hard-coded list of property names and the property type is always &lt;code&gt;boolean&lt;/code&gt;, so this mapped type is equivalent to writing:</source>
          <target state="translated">この単純な例では、 &lt;code&gt;Keys&lt;/code&gt; はプロパティ名のハードコードされたリストであり、プロパティタイプは常に &lt;code&gt;boolean&lt;/code&gt; であるため、このマップタイプは次のように記述します。</target>
        </trans-unit>
        <trans-unit id="7836cdb9242f8e5048b5c13b75f69d0839c138b0" translate="yes" xml:space="preserve">
          <source>In this version, we add a setter that checks the length of the &lt;code&gt;newName&lt;/code&gt; to make sure it&amp;rsquo;s compatible with the max-length of our backing database field. If it isn&amp;rsquo;t we throw an error notifying client code that something went wrong.</source>
          <target state="translated">このバージョンでは、 &lt;code&gt;newName&lt;/code&gt; の長さをチェックするセッターを追加して、バッキングデータベースフィールドの最大長と互換性があることを確認します。そうでない場合は、エラーが発生してクライアントコードに問題が発生したことを通知します。</target>
        </trans-unit>
        <trans-unit id="2de95615256a6fbbdcec9fe7db708d237a429e35" translate="yes" xml:space="preserve">
          <source>In this way, a generic type that has its type arguments specified acts just like a non-generic type.</source>
          <target state="translated">このように、型の引数を指定した汎用型は、非汎用型と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="6f1aae5fbefc53fbec291cb812ed1e6d471e127d" translate="yes" xml:space="preserve">
          <source>In traditional object-oriented code, we might abstract over the two types by creating a hierarchy of types. While this is much more explicit, it&amp;rsquo;s also a little bit overkill. One of the nice things about the original version of &lt;code&gt;padLeft&lt;/code&gt; was that we were able to just pass in primitives. That meant that usage was simple and concise. This new approach also wouldn&amp;rsquo;t help if we were just trying to use a function that already exists elsewhere.</source>
          <target state="translated">従来のオブジェクト指向コードでは、型の階層を作成することにより、2つの型を抽象化する場合があります。これはもっと明白ですが、少しやり過ぎでもあります。 &lt;code&gt;padLeft&lt;/code&gt; の元のバージョンの優れた点の1つは、プリミティブを渡すことができたことです。つまり、使用方法はシンプルで簡潔でした。この新しいアプローチは、他の場所にすでに存在する関数を使用しようとしただけの場合にも役立ちません。</target>
        </trans-unit>
        <trans-unit id="3797c645e8a8c499cfcb7b4049e4893eece69214" translate="yes" xml:space="preserve">
          <source>In your editor, type the following JavaScript code in &lt;code&gt;greeter.ts&lt;/code&gt;:</source>
          <target state="translated">エディターで、次のJavaScriptコードを &lt;code&gt;greeter.ts&lt;/code&gt; に入力します。</target>
        </trans-unit>
        <trans-unit id="b2065108186f788b7e824c4d623ba210ab88b1c4" translate="yes" xml:space="preserve">
          <source>Include - &lt;code&gt;include&lt;/code&gt;</source>
          <target state="translated">含める- &lt;code&gt;include&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4dbe40d3f9dd76b0ebc598a2769c3f694b16d1ea" translate="yes" xml:space="preserve">
          <source>Include modules imported with &lt;code&gt;.json&lt;/code&gt; extension.</source>
          <target state="translated">&lt;code&gt;.json&lt;/code&gt; 拡張子でインポートされたモジュールを含めます。</target>
        </trans-unit>
        <trans-unit id="6898584222dc5329b65b711cc8ca941a2e824a68" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--allowJs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--allowJs&lt;/code&gt; を &lt;code&gt;.js&lt;/code&gt; ファイルを含める</target>
        </trans-unit>
        <trans-unit id="ab817f6003eff1222b8c915e012bd4827feb5c30" translate="yes" xml:space="preserve">
          <source>Including built-in type declarations with &lt;code&gt;--lib&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--lib&lt;/code&gt; による組み込み型宣言の組み込み</target>
        </trans-unit>
        <trans-unit id="c320930067fba589bb3a1d6786d55f841bf144ab" translate="yes" xml:space="preserve">
          <source>Including declarations in your npm package</source>
          <target state="translated">npm パッケージに宣言を含める</target>
        </trans-unit>
        <trans-unit id="67c5ad4060ac33b6d094ebba765d48e9ee51b0ef" translate="yes" xml:space="preserve">
          <source>Incremental - &lt;code&gt;incremental&lt;/code&gt;</source>
          <target state="translated">インクリメンタル- &lt;code&gt;incremental&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9bc53de5c2f8d2c282bf0578d8a05703182b23ad" translate="yes" xml:space="preserve">
          <source>Incremental file watching for composite projects in &lt;code&gt;--build --watch&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--build --watch&lt;/code&gt; での複合プロジェクトの増分ファイル監視</target>
        </trans-unit>
        <trans-unit id="7deed7a63ea26f03a02053b178171e4c34213f53" translate="yes" xml:space="preserve">
          <source>Incremental typing in JavaScript &lt;a href=&quot;jsdoc-supported-types&quot;&gt;via JSDoc&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;jsdoc-supported-types&quot;&gt;JSDocを介し&lt;/a&gt;たJavaScriptでのインクリメンタルタイピング</target>
        </trans-unit>
        <trans-unit id="5eccb92925bc3929eabb42f52bbdf91059031375" translate="yes" xml:space="preserve">
          <source>Index types</source>
          <target state="translated">インデックスの種類</target>
        </trans-unit>
        <trans-unit id="0b06669b4c136bdf3d1ec21cafd1d15df80fad00" translate="yes" xml:space="preserve">
          <source>Index types and index signatures</source>
          <target state="translated">インデックスの種類とインデックス署名</target>
        </trans-unit>
        <trans-unit id="aaf103e4bce1dd95f1b6e037cb4cf33238541524" translate="yes" xml:space="preserve">
          <source>Indexable Types</source>
          <target state="translated">インデックス可能なタイプ</target>
        </trans-unit>
        <trans-unit id="0adbe17edc35b59357a465c0c0744f9ea42fd3f6" translate="yes" xml:space="preserve">
          <source>Individual library components</source>
          <target state="translated">個々のライブラリコンポーネント</target>
        </trans-unit>
        <trans-unit id="3260fe038f2a1e9f4a6bf5d1a731cf910deb01de" translate="yes" xml:space="preserve">
          <source>Inference from mapped types</source>
          <target state="translated">マップされた型からの推論</target>
        </trans-unit>
        <trans-unit id="72e097bb1e3bc0e862f9bef6c7816dfc1cfe0932" translate="yes" xml:space="preserve">
          <source>Inferring the types</source>
          <target state="translated">タイプの推論</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="29c771a275b4fc168c6e9a9b4f16f9f866101cf5" translate="yes" xml:space="preserve">
          <source>Initialize the project</source>
          <target state="translated">プロジェクトの初期化</target>
        </trans-unit>
        <trans-unit id="0223edbd4b306241485da6ea36e04c5f73dc76b6" translate="yes" xml:space="preserve">
          <source>Initializes a TypeScript project and creates a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">TypeScriptプロジェクトを初期化し、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="d40721226c9107841a5c9b9ca80d5a8dfbb2c0d8" translate="yes" xml:space="preserve">
          <source>Initializing an object with dynamic properties can be a bit of a burden. Take the following example:</source>
          <target state="translated">動的なプロパティを持つオブジェクトを初期化するのは少し負担になります。次の例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="9c7561073b85798bf28e57100cdf96cfe8bdcf3e" translate="yes" xml:space="preserve">
          <source>Inline Source Map - &lt;code&gt;inlineSourceMap&lt;/code&gt;</source>
          <target state="translated">インラインソースマップ &lt;code&gt;inlineSourceMap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="424e6831576ffef65176196315c29ac68ac4bf21" translate="yes" xml:space="preserve">
          <source>Inline Sources - &lt;code&gt;inlineSources&lt;/code&gt;</source>
          <target state="translated">インラインソース &lt;code&gt;inlineSources&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="48ea5eb348b8b2f027b76b2af44bc6ce31c449b9" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; section of the &lt;code&gt;package.json&lt;/code&gt; file, add &lt;em&gt;gulp&lt;/em&gt; and &lt;em&gt;del&lt;/em&gt;</source>
          <target state="translated">インサイド &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; のセクション &lt;code&gt;package.json&lt;/code&gt; のファイル、追加&lt;em&gt;グッ&lt;/em&gt;と&lt;em&gt;デル&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fd6c3ebf7befca9f8208f86c76e4d4180303745c" translate="yes" xml:space="preserve">
          <source>Install</source>
          <target state="translated">Install</target>
        </trans-unit>
        <trans-unit id="e922164fa8e7b23fe5db7d0703923eff79dbef32" translate="yes" xml:space="preserve">
          <source>Install ASP.NET Core and TypeScript</source>
          <target state="translated">ASP.NET CoreとTypeScriptのインストール</target>
        </trans-unit>
        <trans-unit id="1e48e8ef34685eb17d478c13cfd199caadcb3708" translate="yes" xml:space="preserve">
          <source>Install our dependencies</source>
          <target state="translated">依存関係のインストール</target>
        </trans-unit>
        <trans-unit id="e371877bb54c12671888c28362c3b32432ec40a5" translate="yes" xml:space="preserve">
          <source>Installing TypeScript</source>
          <target state="translated">TypeScriptのインストール</target>
        </trans-unit>
        <trans-unit id="98a0fba8620f4d80c37344d00d25fe24a9d88fbd" translate="yes" xml:space="preserve">
          <source>InstanceType&amp;lt;T&amp;gt;</source>
          <target state="translated">InstanceType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ef07ef5ff526694802527d041e5b29af71c04bd8" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;Object&lt;/code&gt;, use the non-primitive &lt;code&gt;object&lt;/code&gt; type (&lt;a href=&quot;../release-notes/typescript-2-2#object-type&quot;&gt;added in TypeScript 2.2&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; の代わりに、非プリミティブ &lt;code&gt;object&lt;/code&gt; タイプ（&lt;a href=&quot;../release-notes/typescript-2-2#object-type&quot;&gt;TypeScript 2.2で追加&lt;/a&gt;）を使用します。</target>
        </trans-unit>
        <trans-unit id="481ebcf06d3a6af9b20dbe32b1d7d942a9bbaeef" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;Object&lt;/code&gt;, use the non-primitive &lt;code&gt;object&lt;/code&gt; type (&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type&quot;&gt;added in TypeScript 2.2&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; の代わりに、非プリミティブ &lt;code&gt;object&lt;/code&gt; タイプ（&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type&quot;&gt;TypeScript 2.2で追加&lt;/a&gt;）を使用します。</target>
        </trans-unit>
        <trans-unit id="ee6363c045a14fb760ecdd97fa1210a76455315e" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;any&lt;/code&gt;, we can use a &lt;em&gt;union type&lt;/em&gt; for the &lt;code&gt;padding&lt;/code&gt; parameter:</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; の代わりに、 &lt;code&gt;padding&lt;/code&gt; パラメータに&lt;em&gt;ユニオンタイプ&lt;/em&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="d1fdeb6abb8961fb107ac368ef09e36ad9963ee3" translate="yes" xml:space="preserve">
          <source>Instead of a relatively useless type like &lt;code&gt;(x: {}) =&amp;gt; Box&amp;lt;{}[]&amp;gt;&lt;/code&gt;, which older versions of the language would infer, TypeScript 3.4&amp;rsquo;s inference allows &lt;code&gt;newFn&lt;/code&gt; to be generic. Its new type is &lt;code&gt;&amp;lt;T&amp;gt;(x: T) =&amp;gt; Box&amp;lt;T[]&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(x: {}) =&amp;gt; Box&amp;lt;{}[]&amp;gt;&lt;/code&gt; ような比較的役に立たない型の代わりに、古いバージョンの言語が推測するTypeScript 3.4の推論では、 &lt;code&gt;newFn&lt;/code&gt; を汎用的にすることができます。新しいタイプは &lt;code&gt;&amp;lt;T&amp;gt;(x: T) =&amp;gt; Box&amp;lt;T[]&amp;gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7820345e86f733909d6d0cf768d7afc07da46bf5" translate="yes" xml:space="preserve">
          <source>Instead of importing helpers with &lt;a href=&quot;#importHelpers&quot;&gt;&lt;code&gt;importHelpers&lt;/code&gt;&lt;/a&gt;, you can provide implementations in the global scope for the helpers you use and completely turn off emitting of helper functions.</source>
          <target state="translated">&lt;a href=&quot;#importHelpers&quot;&gt; &lt;code&gt;importHelpers&lt;/code&gt; &lt;/a&gt;を使用してヘルパーをインポートする代わりに、使用するヘルパーのグローバルスコープで実装を提供し、ヘルパー関数の発行を完全にオフにすることができます。</target>
        </trans-unit>
        <trans-unit id="f41af89aee0ce0aa8f256c662d27ad424fd39973" translate="yes" xml:space="preserve">
          <source>Instead of working with any and all types, we&amp;rsquo;d like to constrain this function to work with any and all types that also have the &lt;code&gt;.length&lt;/code&gt; property. As long as the type has this member, we&amp;rsquo;ll allow it, but it&amp;rsquo;s required to have at least this member. To do so, we must list our requirement as a constraint on what T can be.</source>
          <target state="translated">すべてのタイプを操作する代わりに、 &lt;code&gt;.length&lt;/code&gt; プロパティも持つすべてのタイプを操作するようにこの関数を制約したいと思います。型にこのメンバーがある限り許可しますが、少なくともこのメンバーが必要です。そのためには、Tが何であるかの制約として要件をリストする必要があります。</target>
        </trans-unit>
        <trans-unit id="56c1302b0e9b5a2d049280773df6dd17a03e760a" translate="yes" xml:space="preserve">
          <source>Instead, use the types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt;.</source>
          <target state="translated">代わりに、タイプ &lt;code&gt;number&lt;/code&gt; 、 &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;boolean&lt;/code&gt; 、 &lt;code&gt;object&lt;/code&gt; 、 &lt;code&gt;symbol&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="9e88339b09438dc6ef45500af5364169862881c3" translate="yes" xml:space="preserve">
          <source>Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a &lt;em&gt;type variable&lt;/em&gt;, a special kind of variable that works on types rather than values.</source>
          <target state="translated">代わりに、引数のタイプを取得して、何が返されているかを示すこともできるようにする方法が必要です。ここでは、値ではなく型で機能する特殊な&lt;em&gt;変数&lt;/em&gt;である&lt;em&gt;型変数&lt;/em&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="877c391d483e3da8842226931c49930770980487" translate="yes" xml:space="preserve">
          <source>Instead, we need to pass in values whose type has all the required properties:</source>
          <target state="translated">代わりに、必要なプロパティをすべて持った型の値を渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="01593ae1a34a1c7e14f63f2874056a43c2031680" translate="yes" xml:space="preserve">
          <source>Instead, you would need to work with the static side of the class directly. In this example, we define two interfaces, &lt;code&gt;ClockConstructor&lt;/code&gt; for the constructor and &lt;code&gt;ClockInterface&lt;/code&gt; for the instance methods. Then, for convenience, we define a constructor function &lt;code&gt;createClock&lt;/code&gt; that creates instances of the type that is passed to it:</source>
          <target state="translated">代わりに、クラスの静的なサイドを直接操作する必要があります。この例では、コンストラクターの &lt;code&gt;ClockConstructor&lt;/code&gt; とインスタンスメソッドの &lt;code&gt;ClockInterface&lt;/code&gt; の 2つのインターフェイスを定義します。次に、便宜上、渡された型のインスタンスを作成するコンストラクター関数 &lt;code&gt;createClock&lt;/code&gt; を定義します。</target>
        </trans-unit>
        <trans-unit id="e3192428f7f4fc6017fd4b426dc0b119b5a30e14" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools</source>
          <target state="translated">ビルドツールとの統合</target>
        </trans-unit>
        <trans-unit id="22212097f0e33b11964a53f929fec73cee63a40c" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Babel</source>
          <target state="translated">ビルドツールとの統合。Babel</target>
        </trans-unit>
        <trans-unit id="9dbaa1369f5ee20cc334fa494b2df4b92581aa4c" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Browserify</source>
          <target state="translated">ビルドツールとの統合 Browserify</target>
        </trans-unit>
        <trans-unit id="3ec7ffbef629ea76ad15ce276ed9ecdb2cc592e5" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Duo</source>
          <target state="translated">ビルドツールとの統合。デュオ</target>
        </trans-unit>
        <trans-unit id="fbba0594dd61ce66de3d77f11bfcd50051321332" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Grunt</source>
          <target state="translated">ビルドツールとの統合 Grunt</target>
        </trans-unit>
        <trans-unit id="ffe5a64fcf1dd3fb7dd23d6ac3c6b86ef5e5925e" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Gulp</source>
          <target state="translated">ビルドツールとの統合。Gulp</target>
        </trans-unit>
        <trans-unit id="aa266b141c65598c72592d75b9246ecc79078e35" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Jspm</source>
          <target state="translated">ビルドツールとの統合 Jspm</target>
        </trans-unit>
        <trans-unit id="70482080c6efdc1c68f0832eaaf93423e1e5b273" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: MSBuild</source>
          <target state="translated">ビルドツールとの統合 MSBuild</target>
        </trans-unit>
        <trans-unit id="ab83f8abf8483dec13ed24ba6d2e9eb284f56ffa" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: NuGet</source>
          <target state="translated">ビルドツールとの統合 NuGet</target>
        </trans-unit>
        <trans-unit id="d40c6086bb9387a195dd8b229c344fef47424fa3" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Webpack</source>
          <target state="translated">ビルドツールとの統合 Webpack</target>
        </trans-unit>
        <trans-unit id="50c62dd2c72c526623cd3aa97cdf9e954ed24d3d" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA (Mac)</source>
          <target state="translated">IntelliJ IDEA (Mac)</target>
        </trans-unit>
        <trans-unit id="786f15960455f4c51ef85df82efd7a27a91dc1ba" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA (Windows)</source>
          <target state="translated">IntelliJ IDEA (Windows)</target>
        </trans-unit>
        <trans-unit id="a018a82309e992e850b9031373cff79ce1cccba4" translate="yes" xml:space="preserve">
          <source>Interested in learning more?</source>
          <target state="translated">もっと詳しく知りたいですか?</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="92daefb7ec0fc8b648c80aca28475265591e79ec" translate="yes" xml:space="preserve">
          <source>Interfaces Extending Classes</source>
          <target state="translated">インターフェース クラスを拡張する</target>
        </trans-unit>
        <trans-unit id="96e2b4ca11436e61acf1d8a96fcf247872f1b2ff" translate="yes" xml:space="preserve">
          <source>Interfaces are capable of describing the wide range of shapes that JavaScript objects can take. In addition to describing an object with properties, interfaces are also capable of describing function types.</source>
          <target state="translated">インターフェースは、JavaScriptのオブジェクトがとることのできる幅広い形を記述することができます。インターフェースは、オブジェクトをプロパティで記述するだけでなく、関数型を記述することもできます。</target>
        </trans-unit>
        <trans-unit id="1182e7a77aad9fb1ced581374b610320fa4806c8" translate="yes" xml:space="preserve">
          <source>Interfaces describe the public side of the class, rather than both the public and private side. This prohibits you from using them to check that a class also has particular types for the private side of the class instance.</source>
          <target state="translated">インターフェースは、パブリック側とプライベート側の両方ではなく、クラスのパブリック側を記述します。これは、クラスがクラスインスタンスのプライベート側にも特定の型を持っていることを確認するために使用することを禁止しています。</target>
        </trans-unit>
        <trans-unit id="296b5977caa1cbec518b7e75c1da7e2fd0eaa696" translate="yes" xml:space="preserve">
          <source>Interfaces vs. Type Aliases</source>
          <target state="translated">インターフェースとタイプエイリアス</target>
        </trans-unit>
        <trans-unit id="54fe00f4a20d8d06ce299185a910049d83b48bdd" translate="yes" xml:space="preserve">
          <source>Interfaces with optional properties are written similar to other interfaces, with each optional property denoted by a &lt;code&gt;?&lt;/code&gt; at the end of the property name in the declaration.</source>
          <target state="translated">オプションのプロパティを持つインターフェイスは、他のインターフェイスと同様に記述され、各オプションのプロパティは &lt;code&gt;?&lt;/code&gt; 宣言のプロパティ名の最後。</target>
        </trans-unit>
        <trans-unit id="ef35fc41614978724e53f8c707770be7d1309ab3" translate="yes" xml:space="preserve">
          <source>Intersection Types</source>
          <target state="translated">交差点の種類</target>
        </trans-unit>
        <trans-unit id="084148d39f0e6339840f9abce4a71b7b8a28568e" translate="yes" xml:space="preserve">
          <source>Intersection and Union types are one of the ways in which you can compose types.</source>
          <target state="translated">交差型と連合型は、型を構成する方法の一つです。</target>
        </trans-unit>
        <trans-unit id="b87d8878892520ebb9edc358d8dd9e3d44011f0c" translate="yes" xml:space="preserve">
          <source>Intersection types</source>
          <target state="translated">交差点の種類</target>
        </trans-unit>
        <trans-unit id="b78d51b88c1d1feb693e6d11fb2eab9417d88d2e" translate="yes" xml:space="preserve">
          <source>Intersection types are closely related to union types, but they are used very differently. An intersection type combines multiple types into one. This allows you to add together existing types to get a single type that has all the features you need. For example, &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; is a type which is all of &lt;code&gt;Person&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Serializable&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Loggable&lt;/code&gt;. That means an object of this type will have all members of all three types.</source>
          <target state="translated">交差型は共用体型と密接に関連していますが、使用方法は大きく異なります。交差タイプは、複数のタイプを1つに結合します。これにより、既存のタイプを合計して、必要なすべての機能を備えた単一のタイプを取得できます。例えば、 &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; すべてのあるタイプである &lt;code&gt;Person&lt;/code&gt; &lt;em&gt;と&lt;/em&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;em&gt;と&lt;/em&gt; &lt;code&gt;Loggable&lt;/code&gt; 。つまり、このタイプのオブジェクトには、3つのタイプすべてのすべてのメンバーが含まれます。</target>
        </trans-unit>
        <trans-unit id="564a9241fc2a9fe2599b22267f67a36231a5fd3e" translate="yes" xml:space="preserve">
          <source>Intersections</source>
          <target state="translated">Intersections</target>
        </trans-unit>
        <trans-unit id="024b4beab6775314e602953c2f94088fe4678bde" translate="yes" xml:space="preserve">
          <source>Intrinsic String Manipulation Types</source>
          <target state="translated">本質的な文字列操作の種類</target>
        </trans-unit>
        <trans-unit id="c8bf0e8c1ae3e60a82098f1409f6db85661db7a9" translate="yes" xml:space="preserve">
          <source>Intrinsic elements</source>
          <target state="translated">本質的な要素</target>
        </trans-unit>
        <trans-unit id="f97123626594d771751041a210b6256d26fd2930" translate="yes" xml:space="preserve">
          <source>Intrinsic elements are looked up on the special interface &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;. By default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked. However, if this interface &lt;em&gt;is&lt;/em&gt; present, then the name of the intrinsic element is looked up as a property on the &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; interface. For example:</source>
          <target state="translated">組み込み要素は、特別なインターフェース &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; で検索されます。デフォルトでは、このインターフェースが指定されていない場合、何も行われず、組み込み要素は型チェックされません。ただし、このインターフェース&lt;em&gt;が&lt;/em&gt;存在する場合、組み込み要素の名前は &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; インターフェースのプロパティとして検索されます。例えば：</target>
        </trans-unit>
        <trans-unit id="5929e5c75cee5abeee0333968fe15c20cd3d7eef" translate="yes" xml:space="preserve">
          <source>Intro to the TSConfig Reference</source>
          <target state="translated">TSConfig リファレンスの紹介</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="7f426c016099b5f664f1e39e6247678f1b9e5312" translate="yes" xml:space="preserve">
          <source>Introduction to the DOM</source>
          <target state="translated">DOMの紹介</target>
        </trans-unit>
        <trans-unit id="92a605a41a1bfb9eec6573b6d10084310be8afb9" translate="yes" xml:space="preserve">
          <source>Introduction: Deep Dive</source>
          <target state="translated">紹介します。ディープダイブ</target>
        </trans-unit>
        <trans-unit id="88ac7b281daf4911d47c89c86d34416225280141" translate="yes" xml:space="preserve">
          <source>Introduction: Find and Install Declaration Files</source>
          <target state="translated">はじめに 宣言ファイルの検索とインストール</target>
        </trans-unit>
        <trans-unit id="4f8abbfcfad58ab5902f7d7dad80570ab5c1e9de" translate="yes" xml:space="preserve">
          <source>Introduction: Library Structures</source>
          <target state="translated">はじめに 図書館の構造</target>
        </trans-unit>
        <trans-unit id="be4e2ac8a7225060bbaf50e88cd4c64bbb2b91e0" translate="yes" xml:space="preserve">
          <source>Introduction: Publish to npm</source>
          <target state="translated">ご紹介します。npmへの公開</target>
        </trans-unit>
        <trans-unit id="d9cf5daf5910fcc22fa06cac1c556299707a4e15" translate="yes" xml:space="preserve">
          <source>Introduction: Sections</source>
          <target state="translated">はじめに セクション</target>
        </trans-unit>
        <trans-unit id="9da99d0d81d3d8dfe82f617de62c7c013f3809b6" translate="yes" xml:space="preserve">
          <source>Introduction: Templates</source>
          <target state="translated">はじめに テンプレート</target>
        </trans-unit>
        <trans-unit id="4744b3b706d889422bd89021c824c3afa8c9a741" translate="yes" xml:space="preserve">
          <source>Introduction: “Do”s and “Don’t”s</source>
          <target state="translated">はじめに &quot;する」ことと「しない」こと</target>
        </trans-unit>
        <trans-unit id="3e7c599bec18d30837143fafc667da7bae8fb3ce" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;tsc&lt;/code&gt; twice incurs more startup time overhead</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; を 2回呼び出すと、起動時間のオーバーヘッドが増加します。</target>
        </trans-unit>
        <trans-unit id="580856a132ab9d88e4420d07722840d0bee558f0" translate="yes" xml:space="preserve">
          <source>Invoking the compiler with &lt;code&gt;--alwaysStrict&lt;/code&gt; causes:</source>
          <target state="translated">&lt;code&gt;--alwaysStrict&lt;/code&gt; を指定してコンパイラーを呼び出すと、以下が発生します。</target>
        </trans-unit>
        <trans-unit id="2aa2b4b449585e3cac683fe9949dde17f0c4900d" translate="yes" xml:space="preserve">
          <source>Invoking the compiler with &lt;code&gt;--traceResolution&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--traceResolution&lt;/code&gt; を使用してコンパイラーを呼び出す</target>
        </trans-unit>
        <trans-unit id="92c7543673d428591b536d245bf2f8a34c3f3bdf" translate="yes" xml:space="preserve">
          <source>Is your build output mostly the same as your source input files? Use &lt;code&gt;tsc&lt;/code&gt;</source>
          <target state="translated">ビルド出力はソース入力ファイルとほとんど同じですか？ &lt;code&gt;tsc&lt;/code&gt; を使用する</target>
        </trans-unit>
        <trans-unit id="8e2b2e48ddaed31be99cbca83c7b264785d54b10" translate="yes" xml:space="preserve">
          <source>Isolated Modules - &lt;code&gt;isolatedModules&lt;/code&gt;</source>
          <target state="translated">絶縁型モジュール- &lt;code&gt;isolatedModules&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54054e6683cbfd13efd0196ccd3001db60a01e75" translate="yes" xml:space="preserve">
          <source>It also ships with a mapped type &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; that makes all properties &lt;code&gt;readonly&lt;/code&gt;:</source>
          <target state="translated">また、すべてのプロパティを &lt;code&gt;readonly&lt;/code&gt; するマップ型 &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; も付属しています。</target>
        </trans-unit>
        <trans-unit id="95f0156bbb4c60fc06035b7f6f73dc250490e988" translate="yes" xml:space="preserve">
          <source>It can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports.)</source>
          <target state="translated">グローバル変数としても使用できますが、スクリプト内でのみ使用できます。(スクリプトとは、インポートもエクスポートもしないファイルのことです)。</target>
        </trans-unit>
        <trans-unit id="a4a4a00d6a8d5c101bf84b8d87236b25e876e72f" translate="yes" xml:space="preserve">
          <source>It can also be used to create simple namespaces:</source>
          <target state="translated">また、シンプルな名前空間を作成するために使用することもできます。</target>
        </trans-unit>
        <trans-unit id="683cf85c60231c18d1e9862199f167cc8ac3cdf5" translate="yes" xml:space="preserve">
          <source>It can be tempting to think that the types &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, or &lt;code&gt;Object&lt;/code&gt; are the same as the lowercase versions recommended above. These types do not refer to the language primitives however, and almost never should be used as a type.</source>
          <target state="translated">&lt;code&gt;Number&lt;/code&gt; 、 &lt;code&gt;String&lt;/code&gt; 、 &lt;code&gt;Boolean&lt;/code&gt; 、 &lt;code&gt;Symbol&lt;/code&gt; 、または &lt;code&gt;Object&lt;/code&gt; のタイプは、上記で推奨されている小文字のバージョンと同じであると考えたくなるかもしれません。ただし、これらの型は言語プリミティブを参照しないため、型として使用することはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="b38dbabfa59d50143ee85c5c345800b0f340110b" translate="yes" xml:space="preserve">
          <source>It does not change the behavior of your code, or otherwise change the behavior of TypeScript&amp;rsquo;s checking and emitting process.</source>
          <target state="translated">コードの動作を変更したり、TypeScriptのチェックおよび発行プロセスの動作を変更したりすることはありません。</target>
        </trans-unit>
        <trans-unit id="4806c2a5b8c0aca238175b098dcd2585b109419d" translate="yes" xml:space="preserve">
          <source>It does not have an initializer and the preceding enum member was a &lt;em&gt;numeric&lt;/em&gt; constant. In this case the value of the current enum member will be the value of the preceding enum member plus one.</source>
          <target state="translated">初期化子がなく、前の列挙型メンバーは&lt;em&gt;数値&lt;/em&gt;定数でした。この場合、現在の列挙型メンバーの値は、前の列挙型メンバーの値に1を加えたものになります。</target>
        </trans-unit>
        <trans-unit id="ae3a8ea5fd61fc3c908eab11fa4a4f9073d77d83" translate="yes" xml:space="preserve">
          <source>It is a common pattern to return the current object (i.e. &lt;code&gt;this&lt;/code&gt;) from a method to create &lt;a href=&quot;https://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;fluent-style APIs&lt;/a&gt;. For instance, consider the following &lt;code&gt;BasicCalculator&lt;/code&gt; module:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;FluentスタイルのAPI&lt;/a&gt;を作成するメソッドから現在のオブジェクト（つまり &lt;code&gt;this&lt;/code&gt; ）を返すのは一般的なパターンです。たとえば、次の &lt;code&gt;BasicCalculator&lt;/code&gt; モジュールを考えてみます。</target>
        </trans-unit>
        <trans-unit id="62ffe9a036a8fbf5b41aec16bc2aa0caa4f8a019" translate="yes" xml:space="preserve">
          <source>It is a compile time error for constant enum expressions to be evaluated to &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;Infinity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; または &lt;code&gt;Infinity&lt;/code&gt; に評価される定数列挙式のコンパイル時エラーです。</target>
        </trans-unit>
        <trans-unit id="c6c1d1a64c5c77319ef0ca3b0e9b3ec9e20641bd" translate="yes" xml:space="preserve">
          <source>It is also worth noting that, for Node.js applications, modules are the default and &lt;strong&gt;we recommended modules over namespaces in modern code&lt;/strong&gt;.</source>
          <target state="translated">Node.jsアプリケーションの場合、モジュールがデフォルトであり&lt;strong&gt;、最新のコードでは名前空間よりもモジュールを推奨&lt;/strong&gt;していることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="99b3cb57ca8b4b1d02c5836ced85b9301080e00f" translate="yes" xml:space="preserve">
          <source>It is also worth noting that, for Node.js applications, modules are the default and the recommended approach to structure your code.</source>
          <target state="translated">また、Node.jsアプリケーションでは、モジュールがデフォルトであり、コードを構造化するために推奨されるアプローチであることも注目に値します。</target>
        </trans-unit>
        <trans-unit id="f083343eb50dcd945be59c0708845b66b4753dc5" translate="yes" xml:space="preserve">
          <source>It is an error to reference a file that does not exist. It is an error for a file to have a triple-slash reference to itself.</source>
          <target state="translated">存在しないファイルを参照するのはエラーです。ファイルが自分自身へのトリプルスラッシュ参照を持つのはエラーです。</target>
        </trans-unit>
        <trans-unit id="3f74a022e24576b8bca3c7e9007ad3819041ef57" translate="yes" xml:space="preserve">
          <source>It is important to note that it is an error to call a function with too many arguments.</source>
          <target state="translated">注意したいのは、引数が多すぎる関数を呼び出すとエラーになることです。</target>
        </trans-unit>
        <trans-unit id="be67ce2203241cd9f4ea1e5b61ef39e52b2d569c" translate="yes" xml:space="preserve">
          <source>It is important to note that the compiler will &lt;em&gt;not&lt;/em&gt; perform any of these transformations; it just uses these pieces of information to guide the process of resolving a module import to its definition file.</source>
          <target state="translated">コンパイラはこれらの変換を実行し&lt;em&gt;ない&lt;/em&gt;ことに注意することが重要です。これらの情報を使用して、モジュールのインポートを定義ファイルに解決するプロセスをガイドします。</target>
        </trans-unit>
        <trans-unit id="3789f800d631595c74b86aed0db3fe5327908530" translate="yes" xml:space="preserve">
          <source>It is not a mechanism that &lt;strong&gt;prevents&lt;/strong&gt; a file from being included in the codebase - it simply changes what the &lt;code&gt;include&lt;/code&gt; setting finds.</source>
          <target state="translated">これは、ファイルがコードベースに含まれるのを&lt;strong&gt;防ぐ&lt;/strong&gt;メカニズムではありません。 &lt;code&gt;include&lt;/code&gt; 設定が検出する内容を変更するだけです。</target>
        </trans-unit>
        <trans-unit id="1efd3564ec8a22d45891c5ad072535fbd6663440" translate="yes" xml:space="preserve">
          <source>It is not possible to use &lt;code&gt;infer&lt;/code&gt; declarations in constraint clauses for regular type parameters:</source>
          <target state="translated">通常の型パラメーターの制約句で &lt;code&gt;infer&lt;/code&gt; 宣言を使用することはできません。</target>
        </trans-unit>
        <trans-unit id="78ecb7e98034ba8c6a31702e1802139e82a8abee" translate="yes" xml:space="preserve">
          <source>It is possible to define the type of a class component. However, to do so it is best to understand two new terms: the &lt;em&gt;element class type&lt;/em&gt; and the &lt;em&gt;element instance type&lt;/em&gt;.</source>
          <target state="translated">クラスコンポーネントのタイプを定義することが可能です。ただし、そのためには、&lt;em&gt;要素クラス型&lt;/em&gt;と&lt;em&gt;要素インスタンス型&lt;/em&gt;という2つの新しい用語を理解するのが最善です。</target>
        </trans-unit>
        <trans-unit id="3393d397de3e56585237bbbf12b74b296eb1e0ea" translate="yes" xml:space="preserve">
          <source>It is the first member in the enum and it has no initializer, in which case it&amp;rsquo;s assigned the value &lt;code&gt;0&lt;/code&gt;:</source>
          <target state="translated">これは、列挙内の最初のメンバーであり、それが割り当てられている値、その場合にない初期化子、持っていない &lt;code&gt;0&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1f0bcd520e9a01c5bb05819edfd82f1aa74077c5" translate="yes" xml:space="preserve">
          <source>It is worth noting that if the npm package already includes its declaration file as described in &lt;a href=&quot;publishing&quot;&gt;Publishing&lt;/a&gt;, downloading the corresponding &lt;code&gt;@types&lt;/code&gt; package is not needed.</source>
          <target state="translated">「&lt;a href=&quot;publishing&quot;&gt;パブリッシング」&lt;/a&gt;で説明されているようにnpmパッケージに宣言ファイルがすでに含まれている場合、対応する &lt;code&gt;@types&lt;/code&gt; パッケージをダウンロードする必要がないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="cf377c6233f3ae5de354c35e343aab9bdd355017" translate="yes" xml:space="preserve">
          <source>It just so happens that TypeScript has something called a &lt;em&gt;type guard&lt;/em&gt;. A type guard is some expression that performs a runtime check that guarantees the type in some scope.</source>
          <target state="translated">TypeScriptに&lt;em&gt;タイプガード&lt;/em&gt;と呼ばれるものがあるのは、たまたまです。タイプガードは、あるスコープのタイプを保証するランタイムチェックを実行する式です。</target>
        </trans-unit>
        <trans-unit id="63c224c58a227f7ca3d5c83c05a2c04331b2b180" translate="yes" xml:space="preserve">
          <source>It was possible for the implementation files to import the test files</source>
          <target state="translated">実装ファイルがテストファイルをインポートすることができました。</target>
        </trans-unit>
        <trans-unit id="32c6f037d7103d04bf695eff504eb483c338105a" translate="yes" xml:space="preserve">
          <source>It wasn&amp;rsquo;t possible to build &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; at the same time without having &lt;code&gt;src&lt;/code&gt; appear in the output folder name, which you probably don&amp;rsquo;t want</source>
          <target state="translated">出力フォルダ名に &lt;code&gt;src&lt;/code&gt; が表示されない限り、 &lt;code&gt;test&lt;/code&gt; と &lt;code&gt;src&lt;/code&gt; を同時にビルドすることはできませんでした。</target>
        </trans-unit>
        <trans-unit id="9c6a38098d06734f39da99f25d9ab37fea049fd8" translate="yes" xml:space="preserve">
          <source>It would be an error to specify &lt;code&gt;rootDir&lt;/code&gt; as &lt;code&gt;core&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;include&lt;/code&gt; as &lt;code&gt;*&lt;/code&gt; because it creates a file (&lt;code&gt;helpers.ts&lt;/code&gt;) that would need to be emitted &lt;em&gt;outside&lt;/em&gt; the &lt;code&gt;outDir&lt;/code&gt; (i.e. &lt;code&gt;../helpers.js&lt;/code&gt;).</source>
          <target state="translated">指定するとエラーになります &lt;code&gt;rootDir&lt;/code&gt; 通り &lt;code&gt;core&lt;/code&gt; &lt;em&gt;と&lt;/em&gt; &lt;code&gt;include&lt;/code&gt; て &lt;code&gt;*&lt;/code&gt; それはファイル（作成されますので、 &lt;code&gt;helpers.ts&lt;/code&gt; 放出される必要がある）&lt;em&gt;外&lt;/em&gt; &lt;code&gt;outDir&lt;/code&gt; （すなわち &lt;code&gt;../helpers.js&lt;/code&gt; を）。</target>
        </trans-unit>
        <trans-unit id="d57b32bfac61e19b63383ba6ca826d555cc838b5" translate="yes" xml:space="preserve">
          <source>It would be much better if once we performed the check, we could know the type of &lt;code&gt;pet&lt;/code&gt; within each branch.</source>
          <target state="translated">チェックを実行したら、各ブランチ内の &lt;code&gt;pet&lt;/code&gt; の種類を知ることができれば、はるかに良いでしょう。</target>
        </trans-unit>
        <trans-unit id="dae1101862749291ae4f393bc2ced9ae6e2e1e04" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also common to try to access a method before &lt;code&gt;await&lt;/code&gt;-ing or &lt;code&gt;.then()&lt;/code&gt;-ing a &lt;code&gt;Promise&lt;/code&gt;. This is another example, among many others, where we&amp;rsquo;re able to do better.</source>
          <target state="translated">これは、前の方法にアクセスしようとすることも一般的だ &lt;code&gt;await&lt;/code&gt; -ingまたは &lt;code&gt;.then()&lt;/code&gt; -ing &lt;code&gt;Promise&lt;/code&gt; 。これは、他の多くの例の中で、私たちがよりよくできる別の例です。</target>
        </trans-unit>
        <trans-unit id="cb42ff8fbd52b3c44d6730e6b6e080e1b24c9119" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also important to note that TypeScript doesn&amp;rsquo;t transform references to &lt;code&gt;globalThis&lt;/code&gt; when compiling to older versions of ECMAScript. As such, unless you&amp;rsquo;re targeting evergreen browsers (which already support &lt;code&gt;globalThis&lt;/code&gt;), you may want to &lt;a href=&quot;https://github.com/ljharb/globalThis&quot;&gt;use an appropriate polyfill&lt;/a&gt; instead.</source>
          <target state="translated">古いバージョンのECMAScriptにコンパイルする場合、TypeScriptが &lt;code&gt;globalThis&lt;/code&gt; への参照を変換しないことに注意することも重要です。そのため、（既に &lt;code&gt;globalThis&lt;/code&gt; をサポートしている）エバーグリーンブラウザーを対象としない限り、代わりに&lt;a href=&quot;https://github.com/ljharb/globalThis&quot;&gt;適切なポリフィル&lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="e464e560c1d455645701c6f4e6f1a57f254a2a8d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s always nice to be able to document your configuration! &lt;code&gt;tsconfig.json&lt;/code&gt; now accepts single and multi-line comments.</source>
          <target state="translated">あなたの設定を文書化できることは常に素晴らしいことです！ &lt;code&gt;tsconfig.json&lt;/code&gt; が単一行および複数行のコメントを受け入れるようになりました。</target>
        </trans-unit>
        <trans-unit id="4bd81a3c45eee4646f38cdbd9c1c1ad1a29861b2" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s an error to destructure a tuple beyond the range of its elements:</source>
          <target state="translated">要素の範囲を超えてタプルを分解するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="8a9920985b571f2cfef7325bc2d8544e7b54739d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important in this situation to not prepend at each reference, because you&amp;rsquo;ll end up with two copies of &lt;code&gt;A&lt;/code&gt; in the output of &lt;code&gt;D&lt;/code&gt; - this can lead to unexpected results.</source>
          <target state="translated">この状況では、各参照の前に付加しないことが重要です &lt;code&gt;D&lt;/code&gt; の出力に &lt;code&gt;A&lt;/code&gt; のコピーが2つになるためです。これにより、予期しない結果が生じる可能性があります。</target>
        </trans-unit>
        <trans-unit id="97ea9b1bc3713a2cc3d96cf61a87c436f5f16077" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that awesome-typescript-loader will need to run before any other loader that deals with &lt;code&gt;.js&lt;/code&gt; files.</source>
          <target state="translated">awesome-typescript-loaderは、 &lt;code&gt;.js&lt;/code&gt; ファイルを処理する他のローダーの前に実行する必要があることに注意することが重要です。</target>
        </trans-unit>
        <trans-unit id="a2ffa790ea2c3349ed046c358aae967ad51e1cec" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that ts-loader will need to run before any other loader that deals with &lt;code&gt;.js&lt;/code&gt; files.</source>
          <target state="translated">ts-loaderは、 &lt;code&gt;.js&lt;/code&gt; ファイルを処理する他のローダーの前に実行する必要があることに注意することが重要です。</target>
        </trans-unit>
        <trans-unit id="b692de3183276b518dabfb631757e7af1419f734" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to remember that TypeScript uses the same &lt;em&gt;runtime&lt;/em&gt; as JavaScript, so any resources about how to accomplish specific runtime behavior (converting a string to a number, displaying an alert, writing a file to disk, etc.) will always apply equally well to TypeScript programs. Don&amp;rsquo;t limit yourself to TypeScript-specific resources!</source>
          <target state="translated">TypeScriptはJavaScriptと同じ&lt;em&gt;ランタイム&lt;/em&gt;を使用するため、特定のランタイム動作（文字列の数値への変換、アラートの表示、ファイルのディスクへの書き込みなど）を実行する方法に関するリソースは、常に同じように適用されることを覚えておくことが重要です。 TypeScriptプログラム。TypeScript固有のリソースに限定しないでください！</target>
        </trans-unit>
        <trans-unit id="ad109c65e3188cac84e48f320d15d4fae5d7f0a7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not uncommon for an API to expect a specific set of strings for certain values. For instance, consider a UI library that can move elements across the screen while controlling the &lt;a href=&quot;https://en.wikipedia.org/wiki/Inbetweening&quot;&gt;&amp;ldquo;easing&amp;rdquo; of the animation.&lt;/a&gt;</source>
          <target state="translated">APIが特定の値に対して特定の文字列セットを期待することは珍しくありません。たとえば&lt;a href=&quot;https://en.wikipedia.org/wiki/Inbetweening&quot;&gt;、アニメーションの「イージング」&lt;/a&gt;を制御しながら要素を画面上で移動できるUIライブラリについて考えてみます。</target>
        </trans-unit>
        <trans-unit id="4b18ceff60d615281a03cf2a9ea16d87dd519931" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible you really &lt;em&gt;did&lt;/em&gt; intend to divide a number by an array, perhaps just to see what happens, but most of the time, though, this is a programming mistake. TypeScript&amp;rsquo;s type checker is designed to allow correct programs through while still catching as many common errors as possible. (Later, we&amp;rsquo;ll learn about settings you can use to configure how strictly TypeScript checks your code.)</source>
          <target state="translated">おそらく何が起こるかを見るために、実際に数値を配列で除算するつもりだっ&lt;em&gt;た&lt;/em&gt;可能性がありますが、ほとんどの場合、これはプログラミングの間違いです。TypeScriptのタイプチェッカーは、可能な限り多くの一般的なエラーをキャッチしながら、正しいプログラムを通過できるように設計されています。（後で、TypeScriptがコードを厳密にチェックする方法を構成するために使用できる設定について学習します。）</target>
        </trans-unit>
        <trans-unit id="c163602d3325175e90ecde073b2e8d099514998d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth noting that &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; from the inheriting config file &lt;em&gt;overwrite&lt;/em&gt; those from the base config file, and that circularity between configuration files is not allowed.</source>
          <target state="translated">継承する構成ファイルからの &lt;code&gt;files&lt;/code&gt; 、 &lt;code&gt;include&lt;/code&gt; および &lt;code&gt;exclude&lt;/code&gt; は、基本構成ファイルからのファイルを&lt;em&gt;上書き&lt;/em&gt;し、構成ファイル間の循環は許可されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="1423913ba24c08e5752678ce9b4d9c6bc28a43a2" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth pointing out that the type checker does not require that these properties come in any sort of order, only that the properties the interface requires are present and have the required type.</source>
          <target state="translated">型チェッカーでは、これらのプロパティが任意の順序で並んでいる必要はなく、インターフェイスに必要なプロパティが存在し、必要な型を持っていることだけを指摘しておく価値があります。</target>
        </trans-unit>
        <trans-unit id="4dd80eea3f6c51bf5b9c13a8a47609bd55b30e0e" translate="yes" xml:space="preserve">
          <source>Iterables</source>
          <target state="translated">Iterables</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="203e9155620464a525f901cb5421a31b901a89ef" translate="yes" xml:space="preserve">
          <source>Iterators &amp;amp; Generators</source>
          <target state="translated">イテレーターとジェネレーター</target>
        </trans-unit>
        <trans-unit id="99b5cd227ff34de634e9717a978834aba820bbe5" translate="yes" xml:space="preserve">
          <source>Iterators and Generators</source>
          <target state="translated">イテレータとジェネレータ</target>
        </trans-unit>
        <trans-unit id="36347e6c81d6767cb3d6230d14c1fc3fd3e5b4ee" translate="yes" xml:space="preserve">
          <source>JQuery.d.ts</source>
          <target state="translated">JQuery.d.ts</target>
        </trans-unit>
        <trans-unit id="7aec719645d59e0338990dc21d17c20ab20b5e3a" translate="yes" xml:space="preserve">
          <source>JS Class extensions</source>
          <target state="translated">JSクラスの拡張機能</target>
        </trans-unit>
        <trans-unit id="53889159f973b9fcdbf5533d3f8b2fee581e75e1" translate="yes" xml:space="preserve">
          <source>JS Projects Utilizing TypeScript</source>
          <target state="translated">TypeScriptを活用したJSプロジェクト</target>
        </trans-unit>
        <trans-unit id="cad13379ffbb44dfeef3669b43a6cf7eda0226c2" translate="yes" xml:space="preserve">
          <source>JSDoc Property Modifiers</source>
          <target state="translated">JSDocプロパティ修飾子</target>
        </trans-unit>
        <trans-unit id="196b2a7280a3752416773c234c6662e07ab87209" translate="yes" xml:space="preserve">
          <source>JSDoc Reference</source>
          <target state="translated">JSDoc リファレンス</target>
        </trans-unit>
        <trans-unit id="5d193b4e629fd62bb8a4297db587f6b30503894f" translate="yes" xml:space="preserve">
          <source>JSDoc annotated functions are excluded from this rule. Use JSDoc optional parameter syntax (&lt;code&gt;[&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;) to express optionality. e.g.:</source>
          <target state="translated">JSDocアノテーション付き関数はこのルールから除外されます。JSDocのオプションのパラメーター構文（ &lt;code&gt;[&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; ）を使用して、オプションを表現します。例えば：</target>
        </trans-unit>
        <trans-unit id="e3449392ff6bd7faf1750366c59ea9d2cae9f435" translate="yes" xml:space="preserve">
          <source>JSDoc annotated functions are excluded from this rule. Use JSDoc optional parameter syntax to express optionality. e.g.:</source>
          <target state="translated">JSDoc アノテーションされた関数は、この規則から除外されます。オプション性を表現するには、JSDocのオプションパラメータ構文を使用します。</target>
        </trans-unit>
        <trans-unit id="a992571945b4a5c87d6bf56acece269e2c17f9ae" translate="yes" xml:space="preserve">
          <source>JSDoc annotations adorning a declaration will be used to set the type of that declaration. For example:</source>
          <target state="translated">宣言の型を設定するために、宣言に付随するJSDocアノテーションが使用されます。例えば</target>
        </trans-unit>
        <trans-unit id="b57ab1e3e810539c8d1ec0a2a10337c1c2186c67" translate="yes" xml:space="preserve">
          <source>JSDoc annotations come before a declaration will be used to set the type of that declaration. For example:</source>
          <target state="translated">宣言の前に来るJSDocアノテーションは、その宣言の型を設定するために使用されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="56567b264de0a6e662152c49ade304ca30e42a64" translate="yes" xml:space="preserve">
          <source>JSDoc types are used for type information</source>
          <target state="translated">JSDocの型は型情報に使用されます。</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="200185b1255b1a221ca2903c5a111895d54bee5e" translate="yes" xml:space="preserve">
          <source>JSX - &lt;code&gt;jsx&lt;/code&gt;</source>
          <target state="translated">JSX - &lt;code&gt;jsx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3a12fc57c5b8ab36078ef438cd9ea85d576a140" translate="yes" xml:space="preserve">
          <source>JSX Factory - &lt;code&gt;jsxFactory&lt;/code&gt;</source>
          <target state="translated">JSXファクトリ &lt;code&gt;jsxFactory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9a7b3c3bca23e176771346061c84e126c239c19" translate="yes" xml:space="preserve">
          <source>JSX allows you to embed expressions between tags by surrounding the expressions with curly braces (&lt;code&gt;{ }&lt;/code&gt;).</source>
          <target state="translated">JSXでは、式を中括弧（ &lt;code&gt;{ }&lt;/code&gt; ）で囲むことにより、式をタグの間に埋め込むことができます。</target>
        </trans-unit>
        <trans-unit id="39068335c89e9baa8ee40bd585e128fbed44107c" translate="yes" xml:space="preserve">
          <source>JSX element names and properties are validated against the &lt;code&gt;JSX&lt;/code&gt; namespace. Please see the [[JSX]] wiki page for defining the &lt;code&gt;JSX&lt;/code&gt; namespace for your framework.</source>
          <target state="translated">JSX要素の名前とプロパティは、 &lt;code&gt;JSX&lt;/code&gt; 名前空間に対して検証されます。フレームワークの &lt;code&gt;JSX&lt;/code&gt; 名前空間の定義については、[[JSX]] wikiページを参照してください。</target>
        </trans-unit>
        <trans-unit id="c00129d0a4abfd5ac94250f0271eb16efd1bd3c7" translate="yes" xml:space="preserve">
          <source>JSX elements now allow passing type arguments to generic components.</source>
          <target state="translated">JSX要素では、ジェネリックコンポーネントに型引数を渡すことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="18de8f2d2e7d3ab6aeff186b905d5c34cc12e52a" translate="yes" xml:space="preserve">
          <source>JSX is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, but the semantics of that transformation are implementation-specific. JSX came to popularity with the React library but has since seen other applications. TypeScript 1.6 supports embedding, type checking, and optionally compiling JSX directly into JavaScript.</source>
          <target state="translated">JSX は埋め込み可能な XML ライクな構文です。これは有効な JavaScript に変換することを意図していますが、その変換のセマンティクスは実装固有です。JSXはReactライブラリで人気を博しましたが、それ以降は他のアプリケーションでも利用されるようになりました。TypeScript 1.6は、埋め込み、型チェック、オプションでJSXをJavaScriptに直接コンパイルすることをサポートしています。</target>
        </trans-unit>
        <trans-unit id="35be1251a23e865870550e0bb93b3a161d7ed6f9" translate="yes" xml:space="preserve">
          <source>JSX support</source>
          <target state="translated">JSX サポート</target>
        </trans-unit>
        <trans-unit id="96d35d103f80b8423a542d0896d9282bfecda177" translate="yes" xml:space="preserve">
          <source>JSX type checking is driven by definitions in a JSX namespace, for instance &lt;code&gt;JSX.Element&lt;/code&gt; for the type of a JSX element, and &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; for built-in elements. Before TypeScript 2.8 the &lt;code&gt;JSX&lt;/code&gt; namespace was expected to be in the global namespace, and thus only allowing one to be defined in a project. Starting with TypeScript 2.8 the &lt;code&gt;JSX&lt;/code&gt; namespace will be looked under the &lt;code&gt;jsxNamespace&lt;/code&gt; (e.g. &lt;code&gt;React&lt;/code&gt;) allowing for multiple jsx factories in one compilation. For backward compatibility the global &lt;code&gt;JSX&lt;/code&gt; namespace is used as a fallback if none was defined on the factory function. Combined with the per-file &lt;code&gt;@jsx&lt;/code&gt; pragma, each file can have a different JSX factory.</source>
          <target state="translated">JSXの型チェックは、例えば、JSX名前空間の定義により駆動さ &lt;code&gt;JSX.Element&lt;/code&gt; JSX要素のタイプに、及び &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 内蔵要素について。TypeScript 2.8より前の &lt;code&gt;JSX&lt;/code&gt; は、JSX名前空間はグローバル名前空間にあると想定されていたため、プロジェクトで定義できるのは1つだけでした。TypeScript 2.8以降、 &lt;code&gt;JSX&lt;/code&gt; 名前空間は &lt;code&gt;jsxNamespace&lt;/code&gt; （例： &lt;code&gt;React&lt;/code&gt; ）の下で検索され、1回のコンパイルで複数のjsxファクトリーを使用できるようになります。下位互換性のために、ファクトリ関数で何も定義されていない場合、グローバル &lt;code&gt;JSX&lt;/code&gt; 名前空間がフォールバックとして使用されます。ファイル &lt;code&gt;@jsx&lt;/code&gt; プラグマ、各ファイルは異なるJSXファクトリを持つことができます。</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="0a68962be09173771bec34eb689c44a3c96b2537" translate="yes" xml:space="preserve">
          <source>JavaScript (also known as ECMAScript) started its life as a simple scripting language for browsers. At the time it was invented, it was expected to be used for short snippets of code embedded in a web page &amp;mdash; writing more than a few dozen lines of code would have been somewhat unusual. Due to this, early web browsers executed such code pretty slowly. Over time, though, JS became more and more popular, and web developers started using it to create interactive experiences.</source>
          <target state="translated">JavaScript（ECMAScriptとも呼ばれます）は、ブラウザー用の単純なスクリプト言語として誕生しました。それが発明されたとき、それはウェブページに埋め込まれたコードの短い断片に使用されることが期待されていました&amp;mdash;数十行以上のコードを書くことは幾分珍しいことでした。このため、初期のWebブラウザはそのようなコードの実行にかなり時間がかかりました。しかし、時間が経つにつれて、JSはますます人気が高まり、Web開発者はJSを使用してインタラクティブなエクスペリエンスを作成し始めました。</target>
        </trans-unit>
        <trans-unit id="f9d9a3e1ce5dffeacdf5c830a6c6440a69613ddc" translate="yes" xml:space="preserve">
          <source>JavaScript also allows accessing properties which aren&amp;rsquo;t present:</source>
          <target state="translated">JavaScriptでは、存在しないプロパティにアクセスすることもできます。</target>
        </trans-unit>
        <trans-unit id="88b453322efee2df3d69cc86054aa88030b8bd03" translate="yes" xml:space="preserve">
          <source>JavaScript defines 8 built-in types:</source>
          <target state="translated">JavaScriptは8つの組み込み型を定義しています。</target>
        </trans-unit>
        <trans-unit id="21c885f8940580133691e264e6c024d89b341481" translate="yes" xml:space="preserve">
          <source>JavaScript does have some limited primitives like &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt;, but remember that these operators are still working on the values as they exist in the type-erased output code. For example, &lt;code&gt;typeof (new Car())&lt;/code&gt; will be &lt;code&gt;&quot;object&quot;&lt;/code&gt;, not &lt;code&gt;Car&lt;/code&gt; or &lt;code&gt;&quot;Car&quot;&lt;/code&gt;.</source>
          <target state="translated">JavaScriptには、 &lt;code&gt;typeof&lt;/code&gt; や &lt;code&gt;instanceof&lt;/code&gt; などの制限されたプリミティブがいくつかありますが、これらの演算子は、型が消去された出力コードに存在するため、値を処理していることに注意してください。たとえば、 &lt;code&gt;typeof (new Car())&lt;/code&gt; は、 &lt;code&gt;Car&lt;/code&gt; や &lt;code&gt;&quot;Car&quot;&lt;/code&gt; ではなく &lt;code&gt;&quot;object&quot;&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="5814b75aeb763bc1d09322412eaf957f2d26543e" translate="yes" xml:space="preserve">
          <source>JavaScript has a lot of different module syntaxes or conventions: the one in the ECMAScript standard, the one Node already supports (CommonJS), AMD, System.js, and more! For the most part, TypeScript would default to auto-importing using ECMAScript module syntax, which was often inappropriate in certain TypeScript projects with different compiler settings, or in Node projects with plain JavaScript and &lt;code&gt;require&lt;/code&gt; calls.</source>
          <target state="translated">JavaScriptには多くの異なるモジュール構文または規則があります。ECMAScript標準のもの、ノードがすでにサポートしているもの（CommonJS）、AMD、System.jsなどです！ほとんどの場合、TypeScriptはデフォルトでECMAScriptモジュール構文を使用して自動インポートします。これは、コンパイラ設定が異なる特定のTypeScriptプロジェクト、またはプレーンJavaScriptを使用するNodeプロジェクトではしばしば不適切であり &lt;code&gt;require&lt;/code&gt; 呼び出しが必要です。</target>
        </trans-unit>
        <trans-unit id="98cdb2f49473d8f457b2b983ae7b2e9569316471" translate="yes" xml:space="preserve">
          <source>JavaScript has boxed equivalents of primitive types that contain the methods that programmers associate with those types. TypeScript reflects this with, for example, the difference between the primitive type &lt;code&gt;number&lt;/code&gt; and the boxed type &lt;code&gt;Number&lt;/code&gt;. The boxed types are rarely needed, since their methods return primitives.</source>
          <target state="translated">JavaScriptには、プログラマーがそれらの型に関連付けるメソッドを含むプリミティブ型に相当するボックスがあります。TypeScriptはこれを反映しており、たとえば、プリミティブ型の &lt;code&gt;number&lt;/code&gt; とボックス化された型の &lt;code&gt;Number&lt;/code&gt; の違いがあります。ボックス化された型は、メソッドがプリミティブを返すため、ほとんど必要ありません。</target>
        </trans-unit>
        <trans-unit id="6de0d5c33105af7de987fd16c4c5f05a9230e4fc" translate="yes" xml:space="preserve">
          <source>JavaScript is inherently a very dynamic language. It&amp;rsquo;s not uncommon for a single JavaScript function to return different types of objects based on the shape of the arguments passed in.</source>
          <target state="translated">JavaScriptは本質的に非常に動的な言語です。単一のJavaScript関数が、渡された引数の形状に基づいて異なるタイプのオブジェクトを返すことは珍しくありません。</target>
        </trans-unit>
        <trans-unit id="3fa9627af8c315eed2d8a18ed7ec36d91039abb7" translate="yes" xml:space="preserve">
          <source>JavaScript projects can use a &lt;code&gt;jsconfig.json&lt;/code&gt; file instead, which acts almost the same but has some JavaScript-related compiler flags enabled by default.</source>
          <target state="translated">JavaScriptプロジェクトでは、代わりに &lt;code&gt;jsconfig.json&lt;/code&gt; ファイルを使用できます。このファイルはほぼ同じように機能しますが、JavaScript関連のコンパイラフラグがデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="da1195a91c56a7095e67e44a18fe31d7c0292fae" translate="yes" xml:space="preserve">
          <source>JavaScript&amp;rsquo;s equality operator (&lt;code&gt;==&lt;/code&gt;) &lt;em&gt;coerces&lt;/em&gt; its arguments, leading to unexpected behavior:</source>
          <target state="translated">JavaScriptの等式演算子（ &lt;code&gt;==&lt;/code&gt; ）&lt;em&gt;は&lt;/em&gt;引数を&lt;em&gt;強制&lt;/em&gt;し、予期しない動作を引き起こします。</target>
        </trans-unit>
        <trans-unit id="6db5a96d3e3aba783d7007c3a17e6f71e51a7e0e" translate="yes" xml:space="preserve">
          <source>JavaScript&amp;rsquo;s modern module syntax is a bit like Haskell&amp;rsquo;s, except that any file with &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; is implicitly a module:</source>
          <target state="translated">JavaScriptの最新のモジュール構文は、 &lt;code&gt;import&lt;/code&gt; または &lt;code&gt;export&lt;/code&gt; を含むファイルが暗黙的にモジュールであることを除いて、Haskellの構文に少し似ています。</target>
        </trans-unit>
        <trans-unit id="7196497deb2208abcd944f2734a4a8cd07bbe990" translate="yes" xml:space="preserve">
          <source>Jspm</source>
          <target state="translated">Jspm</target>
        </trans-unit>
        <trans-unit id="a2fb0be4963908fbe076c5e18c4d463d46dfdc5e" translate="yes" xml:space="preserve">
          <source>Just as &amp;ldquo;exporting near the top-level&amp;rdquo; reduces friction on your module&amp;rsquo;s consumers, so does introducing a default export. If a module&amp;rsquo;s primary purpose is to house one specific export, then you should consider exporting it as a default export. This makes both importing and actually using the import a little easier. For example:</source>
          <target state="translated">「トップレベル近くでエクスポートする」とモジュールのコンシューマーの摩擦が減るのと同じように、デフォルトのエクスポートが導入されます。モジュールの主な目的が1つの特定のエクスポートを格納することである場合、それをデフォルトのエクスポートとしてエクスポートすることを検討する必要があります。これにより、インポートと実際のインポートの両方が少し簡単になります。例えば：</target>
        </trans-unit>
        <trans-unit id="d035ba479610b88ab3f44fd6721d6d5b47bab897" translate="yes" xml:space="preserve">
          <source>Just as in JavaScript, functions can refer to variables outside of the function body. When they do so, they&amp;rsquo;re said to &lt;em&gt;capture&lt;/em&gt; these variables. While understanding how this works (and the trade-offs when using this technique) is outside of the scope of this article, having a firm understanding how this mechanic works is an important piece of working with JavaScript and TypeScript.</source>
          <target state="translated">JavaScriptと同様に、関数は関数本体の外部の変数を参照できます。彼らがそうするとき、彼らはこれらの変数を&lt;em&gt;捕らえる&lt;/em&gt;と言われ&lt;em&gt;て&lt;/em&gt;います。これがどのように機能するか（そしてこの手法を使用する場合のトレードオフ）を理解することはこの記事の範囲外ですが、このメカニズムがどのように機能するかをしっかりと理解することは、JavaScriptとTypeScriptを操作する重要な部分です。</target>
        </trans-unit>
        <trans-unit id="f568f7b7378d75e427e395efb94692dbc6539719" translate="yes" xml:space="preserve">
          <source>Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it&amp;rsquo;s not possible to concatenate multiple module source files depending on the module system you target. For instance, you can&amp;rsquo;t use the &lt;code&gt;outFile&lt;/code&gt; option while targeting &lt;code&gt;commonjs&lt;/code&gt; or &lt;code&gt;umd&lt;/code&gt;, but with TypeScript 1.8 and later, &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html#concatenate-amd-and-system-modules-with---outfile&quot;&gt;it&amp;rsquo;s possible&lt;/a&gt; to use &lt;code&gt;outFile&lt;/code&gt; when targeting &lt;code&gt;amd&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">JSファイルとモジュールの間に1対1の対応があるのと同様に、TypeScriptにはモジュールのソースファイルとそれらの発行されたJSファイルの間に1対1の対応があります。この効果の1つは、ターゲットとするモジュールシステムによっては、複数のモジュールソースファイルを連結できないことです。たとえば、 &lt;code&gt;commonjs&lt;/code&gt; または &lt;code&gt;umd&lt;/code&gt; をターゲットにしている間は &lt;code&gt;outFile&lt;/code&gt; オプションを使用できませんが、TypeScript 1.8以降では、 &lt;code&gt;amd&lt;/code&gt; または &lt;code&gt;system&lt;/code&gt; をターゲットにしているときに &lt;code&gt;outFile&lt;/code&gt; を使用&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html#concatenate-amd-and-system-modules-with---outfile&quot;&gt;でき&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="e42c4ea3c8c69c9835a8ffa699912e1dc17b476c" translate="yes" xml:space="preserve">
          <source>Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it&amp;rsquo;s not possible to concatenate multiple module source files depending on the module system you target. For instance, you can&amp;rsquo;t use the &lt;code&gt;outFile&lt;/code&gt; option while targeting &lt;code&gt;commonjs&lt;/code&gt; or &lt;code&gt;umd&lt;/code&gt;, but with TypeScript 1.8 and later, &lt;a href=&quot;release-notes/typescript-1-8#concatenate-amd-and-system-modules-with---outfile&quot;&gt;it&amp;rsquo;s possible&lt;/a&gt; to use &lt;code&gt;outFile&lt;/code&gt; when targeting &lt;code&gt;amd&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">JSファイルとモジュールが1対1で対応しているように、TypeScriptはモジュールのソースファイルと出力されたJSファイルが1対1で対応しています。この1つの効果は、対象のモジュールシステムによっては、複数のモジュールソースファイルを連結できないことです。たとえば、 &lt;code&gt;commonjs&lt;/code&gt; または &lt;code&gt;umd&lt;/code&gt; を対象とする場合は &lt;code&gt;outFile&lt;/code&gt; オプションを使用できませんが、TypeScript 1.8以降では、 &lt;code&gt;amd&lt;/code&gt; または &lt;code&gt;system&lt;/code&gt; を対象とする場合に &lt;code&gt;outFile&lt;/code&gt; を使用&lt;a href=&quot;release-notes/typescript-1-8#concatenate-amd-and-system-modules-with---outfile&quot;&gt;でき&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="d3ce9925cfd88bf773f747d79c2d2f37e043fb9f" translate="yes" xml:space="preserve">
          <source>Just as with &lt;code&gt;for / of&lt;/code&gt;, &lt;code&gt;downlevelIteration&lt;/code&gt; will use &lt;code&gt;Symbol.iterator&lt;/code&gt; (if present) to more accurately emulate ES 6 behavior.</source>
          <target state="translated">ちょうどと同様 &lt;code&gt;for / of&lt;/code&gt; 、 &lt;code&gt;downlevelIteration&lt;/code&gt; が使用されます &lt;code&gt;Symbol.iterator&lt;/code&gt; より正確ES 6の動作をエミュレートするために（存在する場合）を。</target>
        </trans-unit>
        <trans-unit id="f2ceed31b51e352f32e51cd21fbc2af5be43b412" translate="yes" xml:space="preserve">
          <source>Just as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type.</source>
          <target state="translated">インターフェースの場合と同様に、クラス自体に型パラメータを設定することで、クラスのすべてのプロパティが同じ型で動作していることを確認できます。</target>
        </trans-unit>
        <trans-unit id="3d37f6d0d224175d9c14bf98baa6ad7248f29798" translate="yes" xml:space="preserve">
          <source>Just like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application.</source>
          <target state="translated">すべてのグローバルな名前空間汚染と同様に、特に大規模なアプリケーションでは、コンポーネントの依存関係を特定するのが難しい場合があります。</target>
        </trans-unit>
        <trans-unit id="a2f08fadea784d51622be345d4e8e8eadd88d668" translate="yes" xml:space="preserve">
          <source>Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:</source>
          <target state="translated">インターフェースと同じように、型のエイリアスも汎用的なものにすることができます。</target>
        </trans-unit>
        <trans-unit id="025c330d74702a4acd5017db2925ef6790f2b67b" translate="yes" xml:space="preserve">
          <source>Just like namespaces, modules can contain both code and declarations. The main difference is that modules &lt;em&gt;declare&lt;/em&gt; their dependencies.</source>
          <target state="translated">名前空間と同様に、モジュールにはコードと宣言の両方を含めることができます。主な違いは、モジュールが依存関係を&lt;em&gt;宣言&lt;/em&gt;することです。</target>
        </trans-unit>
        <trans-unit id="40539a34306df46457893cadb44a5176185146b1" translate="yes" xml:space="preserve">
          <source>Just like strings, symbols can be used as keys for object properties.</source>
          <target state="translated">文字列と同様に、シンボルはオブジェクトのプロパティのキーとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="accadaa2de1d9b54d08912507fc259d22f1d0931" translate="yes" xml:space="preserve">
          <source>Just run:</source>
          <target state="translated">走れ</target>
        </trans-unit>
        <trans-unit id="125f418dffdfd3ad4877030138769ad27527fedf" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; will be turned on along with other &lt;code&gt;--strict&lt;/code&gt; mode flags, which can impact your project. You can set the &lt;code&gt;strictPropertyInitialization&lt;/code&gt; setting to &lt;code&gt;false&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt;&amp;rsquo;s &lt;code&gt;compilerOptions&lt;/code&gt;, or &lt;code&gt;--strictPropertyInitialization false&lt;/code&gt; on the command line to turn off this checking.</source>
          <target state="translated">ことを覚えておいてください &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; が他のと一緒にオンになります &lt;code&gt;--strict&lt;/code&gt; あなたのプロジェクトに影響を与えることができるモードフラグ、。あなたは、設定することができ &lt;code&gt;strictPropertyInitialization&lt;/code&gt; のに設定を &lt;code&gt;false&lt;/code&gt; あなたに &lt;code&gt;tsconfig.json&lt;/code&gt; の &lt;code&gt;compilerOptions&lt;/code&gt; 、または &lt;code&gt;--strictPropertyInitialization false&lt;/code&gt; このチェックをオフにするには、コマンドラインで。</target>
        </trans-unit>
        <trans-unit id="0abfd4d342104dbd9ec0e7580639c9a4652da4fe" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;?.&lt;/code&gt; acts differently than those &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operations since &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; will act specially on &amp;ldquo;falsy&amp;rdquo; values (e.g. the empty string, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt;, and, well, &lt;code&gt;false&lt;/code&gt;), but this is an intentional feature of the construct. It doesn&amp;rsquo;t short-circuit on valid data like &lt;code&gt;0&lt;/code&gt; or empty strings.</source>
          <target state="translated">覚えておいて &lt;code&gt;?.&lt;/code&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; は「偽の」値（たとえば、空の文字列、 &lt;code&gt;0&lt;/code&gt; 、 &lt;code&gt;NaN&lt;/code&gt; 、およびよく、 &lt;code&gt;false&lt;/code&gt; ）に特別に作用するため、これらの &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 演算とは異なる動作をしますが、これは構造の意図的な機能です。 &lt;code&gt;0&lt;/code&gt; や空の文字列などの有効なデータを短絡しません。</target>
        </trans-unit>
        <trans-unit id="e08badd7e94b5e92e8e60fc455f43139d018f482" translate="yes" xml:space="preserve">
          <source>Keep in mind that automatic inclusion is only important if you&amp;rsquo;re using files with global declarations (as opposed to files declared as modules). If you use an &lt;code&gt;import &quot;foo&quot;&lt;/code&gt; statement, for instance, TypeScript may still look through &lt;code&gt;node_modules&lt;/code&gt; &amp;amp; &lt;code&gt;node_modules/@types&lt;/code&gt; folders to find the &lt;code&gt;foo&lt;/code&gt; package.</source>
          <target state="translated">自動インクルードは、モジュールとして宣言されたファイルではなく、グローバル宣言を含むファイルを使用している場合にのみ重要であることを覚えておいてください。たとえば、 &lt;code&gt;import &quot;foo&quot;&lt;/code&gt; ステートメントを使用する場合、TypeScriptは &lt;code&gt;node_modules&lt;/code&gt; および &lt;code&gt;node_modules/@types&lt;/code&gt; フォルダーを調べて、 &lt;code&gt;foo&lt;/code&gt; パッケージを見つけることがあります。</target>
        </trans-unit>
        <trans-unit id="268830906a0177b0c9a669ca7e3cb1faf3ef7c1b" translate="yes" xml:space="preserve">
          <source>Keep in mind that for simple code like above, you probably shouldn&amp;rsquo;t be trying to &amp;ldquo;get around&amp;rdquo; these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs. That means if you&amp;rsquo;re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it&amp;rsquo;s okay to pass an object with both a &lt;code&gt;color&lt;/code&gt; or &lt;code&gt;colour&lt;/code&gt; property to &lt;code&gt;createSquare&lt;/code&gt;, you should fix up the definition of &lt;code&gt;SquareConfig&lt;/code&gt; to reflect that.</source>
          <target state="translated">上記のような単純なコードでは、おそらくこれらのチェックを「回避」しようとすべきではないことに注意してください。メソッドと保持状態を持つより複雑なオブジェクトリテラルの場合、これらの手法を念頭に置く必要があるかもしれませんが、過剰なプロパティエラーの大部分は実際にはバグです。つまり、オプションバッグなどのプロパティチェックで過剰な問題が発生している場合は、型宣言の一部を修正する必要があるかもしれません。この場合、 &lt;code&gt;color&lt;/code&gt; または &lt;code&gt;colour&lt;/code&gt; プロパティの両方を持つオブジェクトを &lt;code&gt;createSquare&lt;/code&gt; に渡してもよい場合は、 &lt;code&gt;SquareConfig&lt;/code&gt; を反映するようにSquareConfigの定義を修正する必要があります。</target>
        </trans-unit>
        <trans-unit id="f6bddc5a736f8d59d17afc0337ba7f62d7baf26b" translate="yes" xml:space="preserve">
          <source>Keep in mind that our support for async iterators relies on support for &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; to exist at runtime. You may need to polyfill &lt;code&gt;Symbol.asyncIterator&lt;/code&gt;, which for simple purposes can be as simple as: &lt;code&gt;(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for(&quot;Symbol.asyncIterator&quot;);&lt;/code&gt;</source>
          <target state="translated">非同期イテレータのサポートは、実行時に存在する &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; のサポートに依存していることに注意してください。Symbol.asyncIteratorを &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; する必要がある場合があります。これは、単純な目的の場合、次のように単純にすることができます &lt;code&gt;(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for(&quot;Symbol.asyncIterator&quot;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0ee6543e6ec698fd6b6185b09f38eac28c9b2e1" translate="yes" xml:space="preserve">
          <source>Keep in mind that string enum members &lt;em&gt;do not&lt;/em&gt; get a reverse mapping generated at all.</source>
          <target state="translated">文字列列挙型メンバー&lt;em&gt;は&lt;/em&gt;、逆マッピングをまったく生成し&lt;em&gt;ない&lt;/em&gt;ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="629873668f1873eae0d44964937115d6002d3f50" translate="yes" xml:space="preserve">
          <source>Keep outdated console output in watch mode instead of clearing the screen</source>
          <target state="translated">画面をクリアするのではなく、ウォッチモードで古いコンソール出力を維持する</target>
        </trans-unit>
        <trans-unit id="652c3d36f013f3eb41d356a2dc9496bad6b87cd2" translate="yes" xml:space="preserve">
          <source>Keeping the same runtime behavior as JavaScript is a foundational promise of TypeScript because it means you can easily transition between the two languages without worrying about subtle differences that might make your program stop working.</source>
          <target state="translated">JavaScriptと同じランタイム動作を維持することは、TypeScriptの基本的な約束であり、プログラムが動作しなくなるような微妙な違いを気にすることなく、2つの言語間で簡単に移行することができるからです。</target>
        </trans-unit>
        <trans-unit id="a22c16410dc4eafc94fbc317a11af2903d7b50a3" translate="yes" xml:space="preserve">
          <source>Key Concepts</source>
          <target state="translated">キーコンセプト</target>
        </trans-unit>
        <trans-unit id="e3f555e673324c6ef7fc096a52a9695768dbceba" translate="yes" xml:space="preserve">
          <source>Keyof Strings Only - &lt;code&gt;keyofStringsOnly&lt;/code&gt;</source>
          <target state="translated">Keyof Strings Only - &lt;code&gt;keyofStringsOnly&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="842ec99d82ed307bd84f2310114874cbd9666b4e" translate="yes" xml:space="preserve">
          <source>Labels are very rare in JavaScript and typically indicate an attempt to write an object literal:</source>
          <target state="translated">ラベルはJavaScriptでは非常に珍しく、通常はオブジェクトリテラルを書こうとしていることを示しています。</target>
        </trans-unit>
        <trans-unit id="3366a00a2d7b488f6edaccf084d0f236fe293734" translate="yes" xml:space="preserve">
          <source>Language service plugins are a way to provide additional information to a user based on existing TypeScript files. They can enhance existing messages between TypeScript and an editor, or to provide their own error messages.</source>
          <target state="translated">言語サービスプラグインは、既存の TypeScript ファイルに基づいてユーザーに追加情報を提供する方法です。これらのプラグインは、TypeScript とエディタ間の既存のメッセージを強化したり、独自のエラーメッセージを提供したりすることができます。</target>
        </trans-unit>
        <trans-unit id="eaf7e256a5a476287d569594d43c22027adc861c" translate="yes" xml:space="preserve">
          <source>Lastly, we create a helper function that will do the mixing for us. This will run through the properties of each of the mixins and copy them over to the target of the mixins, filling out the stand-in properties with their implementations.</source>
          <target state="translated">最後に、ミキシングを行ってくれるヘルパー関数を作成します。これは、それぞれのミックスインのプロパティを実行し、それらをミックスインのターゲットにコピーし、スタンドインのプロパティをその実装で埋めます。</target>
        </trans-unit>
        <trans-unit id="0deb513412e10426cc0e13efd7af25f69b12a4e1" translate="yes" xml:space="preserve">
          <source>Lay out the project</source>
          <target state="translated">プロジェクトをレイアウトする</target>
        </trans-unit>
        <trans-unit id="0fd2852022c2c1345c56213c485ff5c6c7b31b62" translate="yes" xml:space="preserve">
          <source>Layout for compilations using &lt;code&gt;outFile&lt;/code&gt; is more flexible because relative paths don&amp;rsquo;t matter as much. One thing to keep in mind is that you&amp;rsquo;ll generally want to not use &lt;code&gt;prepend&lt;/code&gt; until the &amp;ldquo;last&amp;rdquo; project - this will improve build times and reduce the amount of I/O needed in any given build. The TypeScript repo itself is a good reference here - we have some &amp;ldquo;library&amp;rdquo; projects and some &amp;ldquo;endpoint&amp;rdquo; projects; &amp;ldquo;endpoint&amp;rdquo; projects are kept as small as possible and pull in only the libraries they need.</source>
          <target state="translated">相対パスはそれほど重要ではないため、 &lt;code&gt;outFile&lt;/code&gt; を使用したコンパイルのレイアウトはより柔軟です。注意すべき点の1つは、通常、「最後の」プロジェクトまで &lt;code&gt;prepend&lt;/code&gt; 使用しないことです。これにより、ビルド時間が改善され、特定のビルドに必要なI / Oの量が減少します。 TypeScriptリポジトリ自体は、ここでの優れたリファレンスです。「ライブラリ」プロジェクトと「エンドポイント」プロジェクトがいくつかあります。 「エンドポイント」プロジェクトは可能な限り小さく維持され、必要なライブラリのみを取り込みます。</target>
        </trans-unit>
        <trans-unit id="a8ce8ab803d2f69beb12ecc965c63513d9c144ec" translate="yes" xml:space="preserve">
          <source>Learn how to use a &lt;a href=&quot;tsconfig-json&quot;&gt;&lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; files.</source>
          <target state="translated">&lt;a href=&quot;tsconfig-json&quot;&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; &lt;/a&gt;ファイルの使用方法を学びます。</target>
        </trans-unit>
        <trans-unit id="f574e7a40077551e582b33afc9de1c41b4ea1f26" translate="yes" xml:space="preserve">
          <source>Learn how to work in an &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuild project&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuildプロジェクトでの&lt;/a&gt;作業方法を学びます。</target>
        </trans-unit>
        <trans-unit id="c8a698431922622bdba500ba547874a9e36cb868" translate="yes" xml:space="preserve">
          <source>Learn how to write declaration files to describe existing JavaScript. Important for DefinitelyTyped contributions.</source>
          <target state="translated">既存の JavaScript を記述するための宣言ファイルの書き方を学びます。DefinitelyTypedでの貢献に重要です。</target>
        </trans-unit>
        <trans-unit id="c1f5cb90f300e2c9d89b461fd1882c4957ea2a20" translate="yes" xml:space="preserve">
          <source>Learning JavaScript and TypeScript</source>
          <target state="translated">JavaScriptとTypeScriptの学習</target>
        </trans-unit>
        <trans-unit id="6bb28e55ee1d62a9d6d258deae5c6e572957f877" translate="yes" xml:space="preserve">
          <source>Learning how to use &lt;code&gt;this&lt;/code&gt; in JavaScript is something of a rite of passage. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use &lt;code&gt;this&lt;/code&gt; and how to spot when it&amp;rsquo;s not being used correctly. Fortunately, TypeScript lets you catch incorrect uses of &lt;code&gt;this&lt;/code&gt; with a couple of techniques. If you need to learn how &lt;code&gt;this&lt;/code&gt; works in JavaScript, though, first read Yehuda Katz&amp;rsquo;s &lt;a href=&quot;http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;Understanding JavaScript Function Invocation and &amp;ldquo;this&amp;rdquo;&lt;/a&gt;. Yehuda&amp;rsquo;s article explains the inner workings of &lt;code&gt;this&lt;/code&gt; very well, so we&amp;rsquo;ll just cover the basics here.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; をJavaScriptで使用する方法を学ぶことは、通過儀礼のようなものです。 TypeScriptはJavaScriptのスーパーセットであるため、TypeScript開発者は、 &lt;code&gt;this&lt;/code&gt; を使用する方法と、正しく使用されていない場合を見つける方法も学ぶ必要があります。さいわい、TypeScriptを使用すると、いくつかのテクニックを使用して、 &lt;code&gt;this&lt;/code&gt; 不適切な使用を見つけることができます。ただし、 &lt;code&gt;this&lt;/code&gt; がJavaScriptでどのように機能するかを学習する必要がある場合は、まずYehuda Katzの&lt;a href=&quot;http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;「JavaScript関数の呼び出しについて」と「これ」を&lt;/a&gt;読んでください。イェフダの記事は、内部の仕組みを説明し &lt;code&gt;this&lt;/code&gt; 非常によく、私たちはちょうどここに基本をカバーします。</target>
        </trans-unit>
        <trans-unit id="d19ec9c75f791d8e76b8abbb3fa24159df758f91" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add a couple of interfaces to our example above, &lt;code&gt;Card&lt;/code&gt; and &lt;code&gt;Deck&lt;/code&gt;, to make the types clearer and easier to reuse:</source>
          <target state="translated">上記の例である &lt;code&gt;Card&lt;/code&gt; と &lt;code&gt;Deck&lt;/code&gt; にいくつかのインターフェイスを追加して、型をより明確にして再利用しやすくします。</target>
        </trans-unit>
        <trans-unit id="0810e0790bb570bb542897e9f00f0ff27a268b73" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add types to our simple examples from earlier:</source>
          <target state="translated">以前のシンプルな例にタイプを追加しましょう：</target>
        </trans-unit>
        <trans-unit id="2fbda1714e2bf191061f156921ed8a14ecb815d5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s convert a simple class to use &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;. First, let&amp;rsquo;s start with an example without getters and setters.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; と &lt;code&gt;set&lt;/code&gt; を使用するように単純なクラスを変換しましょう。まず、ゲッターとセッターのない例から始めましょう。</target>
        </trans-unit>
        <trans-unit id="71429700e5fe5c8713f8050f9d22fc5e71f408cf" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s develop our sample further. Here we use an interface that describes objects that have a firstName and lastName field. In TypeScript, two types are compatible if their internal structure is compatible. This allows us to implement an interface just by having the shape the interface requires, without an explicit &lt;code&gt;implements&lt;/code&gt; clause.</source>
          <target state="translated">サンプルをさらに開発しましょう。ここでは、firstNameおよびlastNameフィールドを持つオブジェクトを記述するインターフェースを使用します。TypeScriptでは、2つの型の内部構造に互換性があれば互換性があります。これにより、明示的な &lt;code&gt;implements&lt;/code&gt; 句なしで、インターフェイスに必要な形状を持たせるだけでインターフェイスを実装できます。</target>
        </trans-unit>
        <trans-unit id="65d0faf04337211735b15f8a5d34c2608e50c347" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get started by building a simple web application with TypeScript.</source>
          <target state="translated">TypeScriptを使用して単純なWebアプリケーションを作成することから始めましょう。</target>
        </trans-unit>
        <trans-unit id="31f50512e5bac716ad2127f4d6b19108bf103d8e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back and write the code for a version of &lt;code&gt;padLeft&lt;/code&gt; which uses union types. We could write it with type predicates as follows:</source>
          <target state="translated">戻って、共用 &lt;code&gt;padLeft&lt;/code&gt; を使用するバージョンのpadLeftのコードを書いてみましょう。次のように型述語でそれを書くことができます：</target>
        </trans-unit>
        <trans-unit id="b1e0b8ac0a49ba6917defbab6438fe121a7b57d4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back and write the code for the version of &lt;code&gt;padLeft&lt;/code&gt; that uses union types. We could write it with type predicates as follows:</source>
          <target state="translated">戻って、共用体タイプを使用する &lt;code&gt;padLeft&lt;/code&gt; のバージョンのコードを記述しましょう。次のように、型述語を使ってそれを書くことができます：</target>
        </trans-unit>
        <trans-unit id="a370033b626aeaa4b56b2ffa2c9b364f90cf9047" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a fairly normal program and see how project references can help us better organize it. Imagine you have a project with two modules, &lt;code&gt;converter&lt;/code&gt; and &lt;code&gt;units&lt;/code&gt;, and a corresponding test file for each:</source>
          <target state="translated">かなり普通のプログラムを見て、プロジェクトの参照がそれをどのように編成するのに役立つかを見てみましょう。 &lt;code&gt;converter&lt;/code&gt; と &lt;code&gt;units&lt;/code&gt; 2つのモジュールと、それぞれに対応するテストファイルを持つプロジェクトがあるとします。</target>
        </trans-unit>
        <trans-unit id="f36707930dcd360fc642c46ec4865e86294c552d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example to better see how this plays out in practice:</source>
          <target state="translated">例を見て、これが実際にどのように機能するかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="d172a231ad56188812168291eea6a5fd8742b6b4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example:</source>
          <target state="translated">例を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="eeeed955a225d9a00620ccdff1e785a00b797db0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s modify the example a bit to show this difference:</source>
          <target state="translated">この違いを示すために、例を少し変更してみましょう。</target>
        </trans-unit>
        <trans-unit id="b02e9aea645d47e4e6bf161ee47aada331ae51db" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now add React and React-DOM, along with their declaration files, as dependencies to your &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="translated">次に、ReactとReact-DOMを、それらの宣言ファイルとともに、 &lt;code&gt;package.json&lt;/code&gt; ファイルへの依存関係として追加してみましょう。</target>
        </trans-unit>
        <trans-unit id="83704a6507b28f550a9354f7a8254f0aa3c131e5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now look at a more complex example.</source>
          <target state="translated">次に、より複雑な例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="014bde7411db7919604626e4a814bd5fe5d15eef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say that we&amp;rsquo;ve actually intended this function to work on arrays of &lt;code&gt;T&lt;/code&gt; rather than &lt;code&gt;T&lt;/code&gt; directly. Since we&amp;rsquo;re working with arrays, the &lt;code&gt;.length&lt;/code&gt; member should be available. We can describe this just like we would create arrays of other types:</source>
          <target state="translated">私たちは、実際のアレイ上の仕事にこの機能を意図したことの言おう &lt;code&gt;T&lt;/code&gt; ではなく &lt;code&gt;T&lt;/code&gt; を直接。配列を使用しているので、 &lt;code&gt;.length&lt;/code&gt; メンバーが使用可能である必要があります。これは、他のタイプの配列を作成するのと同じように説明できます。</target>
        </trans-unit>
        <trans-unit id="0afa8a2c9e9ae086ac85d8e4851a50d094dc340f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we have a sample application that uses the &lt;code&gt;typescript&lt;/code&gt; module. &lt;code&gt;app.ts&lt;/code&gt; has an import like &lt;code&gt;import * as ts from &quot;typescript&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;typescript&lt;/code&gt; モジュールを使用するサンプルアプリケーションがあるとします。 &lt;code&gt;app.ts&lt;/code&gt; には、 &lt;code&gt;import * as ts from &quot;typescript&quot;&lt;/code&gt; ようなインポートがあります。</target>
        </trans-unit>
        <trans-unit id="b98ecb1cac8b86219be2530212acfb40004f6c82" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we wrote a module file &lt;code&gt;foo.d.ts&lt;/code&gt;:</source>
          <target state="translated">モジュールファイル &lt;code&gt;foo.d.ts&lt;/code&gt; を書いたとしましょう：</target>
        </trans-unit>
        <trans-unit id="bf265138b3f25556fefa76ca3b0b12725b0f86b1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s scaffold this out:</source>
          <target state="translated">これを足場にしてみましょう：</target>
        </trans-unit>
        <trans-unit id="aa591bb3c4e18fed63fab3f054ebcf47625b721d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this can be used.</source>
          <target state="translated">これがどのように使用されるか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="a2d4ab99ed2cfcd0bf4a97a7f9d646bc565fffa9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start out with a new directory. We&amp;rsquo;ll name it &lt;code&gt;proj&lt;/code&gt; for now, but you can change it to whatever you want.</source>
          <target state="translated">新しいディレクトリから始めましょう。ここでは、 &lt;code&gt;proj&lt;/code&gt; という名前にしますが、好きなように変更できます。</target>
        </trans-unit>
        <trans-unit id="55bbd8a0f85bfbe95c8b7cb6332b5825ff504f0e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with the program we&amp;rsquo;ll be using as our example throughout this page. We&amp;rsquo;ve written a small set of simplistic string validators, as you might write to check a user&amp;rsquo;s input on a form in a webpage or check the format of an externally-provided data file.</source>
          <target state="translated">このページ全体で例として使用するプログラムから始めましょう。Webページのフォームでのユーザー入力を確認したり、外部から提供されたデータファイルの形式を確認したりするために、単純な文字列バリデーターの小さなセットを作成しました。</target>
        </trans-unit>
        <trans-unit id="bf10a2b8087f57e53feead64793d541595e6996c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at a simple class-based example:</source>
          <target state="translated">簡単なクラスベースの例を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="3484d66cbe4a02744097aac7ef40e2f056cef65a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at an example:</source>
          <target state="translated">例を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="b54485584eecf2901825f4b3995651a7e60470f5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at the simplest mapped type and its parts:</source>
          <target state="translated">最も単純なマップされた型とその部分を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="388956de0f4c78ed65b63c815c68a779d593b807" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a minute to consider what that means. &lt;code&gt;setTimeout&lt;/code&gt; will run a function after some number of milliseconds, &lt;em&gt;but only&lt;/em&gt; after the &lt;code&gt;for&lt;/code&gt; loop has stopped executing; By the time the &lt;code&gt;for&lt;/code&gt; loop has stopped executing, the value of &lt;code&gt;i&lt;/code&gt; is &lt;code&gt;10&lt;/code&gt;. So each time the given function gets called, it will print out &lt;code&gt;10&lt;/code&gt;!</source>
          <target state="translated">その意味を考えてみましょう。 &lt;code&gt;setTimeout&lt;/code&gt; は、数ミリ秒後に関数を実行 &lt;code&gt;for&lt;/code&gt; ますが、forループの実行が停止した後に&lt;em&gt;のみ&lt;/em&gt;実行されます。時間だけ &lt;code&gt;for&lt;/code&gt; 、ループの実行を停止した、の値 &lt;code&gt;i&lt;/code&gt; がある &lt;code&gt;10&lt;/code&gt; 。したがって、指定された関数が呼び出されるたびに、 &lt;code&gt;10&lt;/code&gt; が出力されます。</target>
        </trans-unit>
        <trans-unit id="309b7fe3def1ff082c552cb81229fe971bbfb8b9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take our &lt;code&gt;identity&lt;/code&gt; function from earlier:</source>
          <target state="translated">以前の &lt;code&gt;identity&lt;/code&gt; 関数を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="c819787bed8495ecea9cfe18f716371127e40d52" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a Hello World program. In &lt;code&gt;src&lt;/code&gt;, create the file &lt;code&gt;main.ts&lt;/code&gt;:</source>
          <target state="translated">Hello Worldプログラムを書いてみましょう。では &lt;code&gt;src&lt;/code&gt; 、ファイルの作成 &lt;code&gt;main.ts&lt;/code&gt; を：</target>
        </trans-unit>
        <trans-unit id="4f861095293696b450d02c85427a11313836cd45" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write our first TypeScript file using React. First, create a file named &lt;code&gt;Hello.tsx&lt;/code&gt; in &lt;code&gt;src/components&lt;/code&gt; and write the following:</source>
          <target state="translated">Reactを使用して最初のTypeScriptファイルを作成しましょう。まず、名前のファイルを作成 &lt;code&gt;Hello.tsx&lt;/code&gt; 内 &lt;code&gt;src/components&lt;/code&gt; して、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="aae2739f68fb37ce086c5c2093758c62b36667b3" translate="yes" xml:space="preserve">
          <source>Lets explore a TypeScript script that adds a &lt;code&gt;&amp;lt;p&amp;gt;Hello, World&amp;lt;/p&amp;gt;&lt;/code&gt; element to the &lt;code&gt;#app&lt;/code&gt; element.</source>
          <target state="translated">&lt;code&gt;#app&lt;/code&gt; 要素に &lt;code&gt;&amp;lt;p&amp;gt;Hello, World&amp;lt;/p&amp;gt;&lt;/code&gt; 要素を追加するTypeScriptスクリプトを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="a7305992657ab0909fb4eb83c394c6114c9f6b07" translate="yes" xml:space="preserve">
          <source>Lets you set a base directory to resolve non-absolute module names.</source>
          <target state="translated">絶対的でないモジュール名を解決するためのベースディレクトリを設定します。</target>
        </trans-unit>
        <trans-unit id="166644bb8752dfdaa61026de73139cfde0a4a540" translate="yes" xml:space="preserve">
          <source>LettersOnlyValidator.ts</source>
          <target state="translated">LettersOnlyValidator.ts</target>
        </trans-unit>
        <trans-unit id="0282b6f4a590ade8d83152438864b31e1ed6a0e7" translate="yes" xml:space="preserve">
          <source>Lib - &lt;code&gt;lib&lt;/code&gt;</source>
          <target state="translated">Lib - &lt;code&gt;lib&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="875c3c9135ee949f84870492409833fc57642b20" translate="yes" xml:space="preserve">
          <source>Libraries can also use &lt;code&gt;this&lt;/code&gt; parameters to declare how callbacks will be invoked.</source>
          <target state="translated">ライブラリは、 &lt;code&gt;this&lt;/code&gt; パラメーターを使用して、コールバックが呼び出される方法を宣言することもできます。</target>
        </trans-unit>
        <trans-unit id="7c8d68bdf290b3650035c5dab105050f96236c14" translate="yes" xml:space="preserve">
          <source>Library Structures</source>
          <target state="translated">図書館の構造</target>
        </trans-unit>
        <trans-unit id="4e958d206e87dee6202602f12cba1d07ddc64591" translate="yes" xml:space="preserve">
          <source>Library Structures: Consuming Dependencies</source>
          <target state="translated">ライブラリの構造。依存関係の消費</target>
        </trans-unit>
        <trans-unit id="b96d274e68825ffb1cf50ff3a8842c7507fb9c61" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on Global Libraries</source>
          <target state="translated">図書館の構造.グローバルライブラリへの依存</target>
        </trans-unit>
        <trans-unit id="c7d79eff0a64c91827b34425186a057bf7eefed6" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on Modules</source>
          <target state="translated">ライブラリの構造。モジュールへの依存性</target>
        </trans-unit>
        <trans-unit id="0e5b4340018e06cc22410c43d8c05671e353f758" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on UMD libraries</source>
          <target state="translated">ライブラリの構造。UMDライブラリへの依存関係</target>
        </trans-unit>
        <trans-unit id="25679ea328e38a91aa99fd34521cab5334cfc5f6" translate="yes" xml:space="preserve">
          <source>Library Structures: Global Libraries</source>
          <target state="translated">図書館の構造.グローバルライブラリ</target>
        </trans-unit>
        <trans-unit id="583896dcdb93f9cebf804f97f952c1047d1b09e6" translate="yes" xml:space="preserve">
          <source>Library Structures: Global Plugin</source>
          <target state="translated">ライブラリの構造。グローバルプラグイン</target>
        </trans-unit>
        <trans-unit id="46852e3e51c98d1fbda888c84f0fd0b001bb9a75" translate="yes" xml:space="preserve">
          <source>Library Structures: Global-modifying Modules</source>
          <target state="translated">ライブラリの構造。グローバル修飾モジュール</target>
        </trans-unit>
        <trans-unit id="38fb731884bc1a45c091fe53bb4f59beacc5c010" translate="yes" xml:space="preserve">
          <source>Library Structures: Identifying Kinds of Libraries</source>
          <target state="translated">図書館の構造。図書館の種類の識別</target>
        </trans-unit>
        <trans-unit id="dd13ad9cf324101c470f4a966d00d41d7ab63505" translate="yes" xml:space="preserve">
          <source>Library Structures: Library file layout</source>
          <target state="translated">図書館の構造 ライブラリファイルのレイアウト</target>
        </trans-unit>
        <trans-unit id="c83378208463304e24be07d77ddfa86166dca09e" translate="yes" xml:space="preserve">
          <source>Library Structures: Modular Libraries</source>
          <target state="translated">ライブラリの構造.モジュラーライブラリ</target>
        </trans-unit>
        <trans-unit id="1fe937767fb28d22ee73b66129f61b0fe7d8aa7e" translate="yes" xml:space="preserve">
          <source>Library Structures: Module Plugin or UMD Plugin</source>
          <target state="translated">ライブラリの構造。モジュールプラグインまたはUMDプラグイン</target>
        </trans-unit>
        <trans-unit id="4f845580b5f18381f6fa82c3be48352cc4e140d3" translate="yes" xml:space="preserve">
          <source>Library Structures: Preventing Name Conflicts</source>
          <target state="translated">図書館の構造。名前の衝突を防ぐ</target>
        </trans-unit>
        <trans-unit id="f1c767319c72858af7a6896ba4967b323b7a1717" translate="yes" xml:space="preserve">
          <source>Library Structures: The Impact of ES6 on Module Plugins</source>
          <target state="translated">ライブラリ構造。ES6 のモジュールプラグインへの影響</target>
        </trans-unit>
        <trans-unit id="c4c82656844e89a1600df1de5a6196522c148102" translate="yes" xml:space="preserve">
          <source>Library Structures: UMD</source>
          <target state="translated">図書館の構造 UMD</target>
        </trans-unit>
        <trans-unit id="b914f6929708a78f5ebc7f6182f8d6dadfdf5520" translate="yes" xml:space="preserve">
          <source>Library file layout</source>
          <target state="translated">ライブラリファイルのレイアウト</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Apache License,Version 2.0の下でライセンスされています。</target>
        </trans-unit>
        <trans-unit id="614020e4b48ba41cbc8feb6a827a9777cf491e2e" translate="yes" xml:space="preserve">
          <source>Like array destructuring, you can have assignment without declaration:</source>
          <target state="translated">配列破壊と同様に、宣言せずに代入を持つことができます。</target>
        </trans-unit>
        <trans-unit id="8179c422e4946b3006e7ce0d9f1b27008179e0fd" translate="yes" xml:space="preserve">
          <source>Like classes, interfaces can extend each other. This allows you to copy the members of one interface into another, which gives you more flexibility in how you separate your interfaces into reusable components.</source>
          <target state="translated">クラスと同様に、インターフェースは互いに拡張することができます。これにより、あるインターフェイスのメンバを別のインターフェイスにコピーすることができ、インターフェイスを再利用可能なコンポーネントに分離する方法をより柔軟にすることができます。</target>
        </trans-unit>
        <trans-unit id="7d787f38e64660d964087ea17b902351795b7ef8" translate="yes" xml:space="preserve">
          <source>Like most C-descended languages, TypeScript requires declaration of type parameters:</source>
          <target state="translated">ほとんどのC言語と同様に、TypeScriptは型パラメータの宣言を必要とします。</target>
        </trans-unit>
        <trans-unit id="e100fe20d9c089d3990a58c235d7844235322341" translate="yes" xml:space="preserve">
          <source>Like other special JS checking behaviors, this behavior can be changed by specifying a JSDoc type for the variable. For example:</source>
          <target state="translated">他の特殊なJSチェック動作と同様に、この動作は変数にJSDoc型を指定することで変更することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="991d21c5bdd231b177d8dbce4a5a58935deb5866" translate="yes" xml:space="preserve">
          <source>Like we mentioned, it&amp;rsquo;s not unexpected to get error messages after conversion. The important thing is to actually go one by one through these and decide how to deal with the errors. Often these will be legitimate bugs, but sometimes you&amp;rsquo;ll have to explain what you&amp;rsquo;re trying to do a little better to TypeScript.</source>
          <target state="translated">前述のように、変換後にエラーメッセージが表示されるのは予期されることではありません。重要なことは、これらを実際に1つずつ実行して、エラーの処理方法を決定することです。多くの場合、これらは正当なバグですが、TypeScriptに対して少し改善しようとしていることを説明しなければならない場合があります。</target>
        </trans-unit>
        <trans-unit id="ad22df7237ec893f071e3a632c74d36af489349a" translate="yes" xml:space="preserve">
          <source>Likewise, for the return type of a function:</source>
          <target state="translated">同様に、関数の戻り値の型についても同様です。</target>
        </trans-unit>
        <trans-unit id="bbb07555ce6ca44b59035a2a319034782de9f8d0" translate="yes" xml:space="preserve">
          <source>Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:</source>
          <target state="translated">同様に、同じ型変数の複数の候補がコントラバリアント位置にある場合、交差型が推論されます。</target>
        </trans-unit>
        <trans-unit id="17904ff532be036b7cb87941e7bed2e100c68152" translate="yes" xml:space="preserve">
          <source>Linter Checks</source>
          <target state="translated">リンターチェック</target>
        </trans-unit>
        <trans-unit id="885980150a8aa23ee2581fde57cdd77e524c220a" translate="yes" xml:space="preserve">
          <source>List Emitted Files - &lt;code&gt;listEmittedFiles&lt;/code&gt;</source>
          <target state="translated">放出されたファイルのリスト &lt;code&gt;listEmittedFiles&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef72f198033a01dd1518070e6ebb3e26bd88d5da" translate="yes" xml:space="preserve">
          <source>List Files - &lt;code&gt;listFiles&lt;/code&gt;</source>
          <target state="translated">リストファイル &lt;code&gt;listFiles&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5359c0166343c48f9f035c401a1a6fd47a5d3c30" translate="yes" xml:space="preserve">
          <source>List of</source>
          <target state="translated">一覧表</target>
        </trans-unit>
        <trans-unit id="0a9f639b79fa294ae337e3e6ef448a4796481e4d" translate="yes" xml:space="preserve">
          <source>List of folders to include type definitions from. See &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#types&quot;&gt;@types, &amp;mdash;typeRoots and &amp;mdash;types&lt;/a&gt; for more details.</source>
          <target state="translated">タイプ定義を含めるフォルダーのリスト。詳細&lt;a href=&quot;https://www.typescriptlang.org/tsconfig#types&quot;&gt;については、@ types、&amp;mdash;typeRoots、および&amp;mdash;types&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="465c88588b5cdd41299c2edcb1468c48ae202ec0" translate="yes" xml:space="preserve">
          <source>List of folders to include type definitions from. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots and &amp;ndash;types&lt;/a&gt; for more details.</source>
          <target state="translated">タイプ定義を含めるフォルダーのリスト。詳細&lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;については、@ types、&amp;ndash;typeRoots、および&amp;ndash;types&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="dc93386b00a8c2f17516b547e96b3b9822dd074a" translate="yes" xml:space="preserve">
          <source>List of language service plugins to run inside the editor.</source>
          <target state="translated">エディタ内で実行する言語サービスプラグインのリスト。</target>
        </trans-unit>
        <trans-unit id="6ced5dd028928de0448e70e83b68d98333283e39" translate="yes" xml:space="preserve">
          <source>List of library files to be included in the compilation.</source>
          <target state="translated">コンパイルに含めるライブラリファイルのリスト。</target>
        </trans-unit>
        <trans-unit id="9230df08537df807ad2117d7fc0d39c84158a446" translate="yes" xml:space="preserve">
          <source>List of names of type definitions to include. See &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#types&quot;&gt;@types, &amp;mdash;typeRoots and &amp;mdash;types&lt;/a&gt; for more details.</source>
          <target state="translated">含めるタイプ定義の名前のリスト。詳細&lt;a href=&quot;https://www.typescriptlang.org/tsconfig#types&quot;&gt;については、@ types、&amp;mdash;typeRoots、および&amp;mdash;types&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="bcb7afa9aa95b8c02629a8477085e1d618f28bc0" translate="yes" xml:space="preserve">
          <source>List of names of type definitions to include. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots and &amp;ndash;types&lt;/a&gt; for more details.</source>
          <target state="translated">含めるタイプ定義の名前のリスト。詳細&lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;については、@ types、&amp;ndash;typeRoots、および&amp;ndash;types&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="653b9b02be1c90476a3ad618b040891655bf5f51" translate="yes" xml:space="preserve">
          <source>List of path mapping entries for module names to locations relative to the &lt;code&gt;baseUrl&lt;/code&gt;. See &lt;a href=&quot;module-resolution#path-mapping&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;baseUrl&lt;/code&gt; を基準にした場所へのモジュール名のパスマッピングエントリのリスト。詳細については、&lt;a href=&quot;module-resolution#path-mapping&quot;&gt;モジュール解決のドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="de64a9e9a2fea78c8d6ba63c5e5b1387423f2076" translate="yes" xml:space="preserve">
          <source>Literal Narrowing</source>
          <target state="translated">文字通りの絞り込み</target>
        </trans-unit>
        <trans-unit id="c5f9843abf3eea470a268920f6429a30a79e8c27" translate="yes" xml:space="preserve">
          <source>Literal Types</source>
          <target state="translated">リテラルタイプ</target>
        </trans-unit>
        <trans-unit id="bb25bc49f0293214d4dc209e4fc9026643313119" translate="yes" xml:space="preserve">
          <source>Literal type widening can be controlled through explicit type annotations. Specifically, when an expression of a literal type is inferred for a const location without a type annotation, that &lt;code&gt;const&lt;/code&gt; variable gets a widening literal type inferred. But when a &lt;code&gt;const&lt;/code&gt; location has an explicit literal type annotation, the &lt;code&gt;const&lt;/code&gt; variable gets a non-widening literal type.</source>
          <target state="translated">リテラル型の拡張は、明示的な型注釈によって制御できます。具体的には、リテラル型の式が型注釈のないconst位置で推論される場合、その &lt;code&gt;const&lt;/code&gt; 変数は拡張されたリテラル型を推論されます。ただし、 &lt;code&gt;const&lt;/code&gt; の場所に明示的なリテラルタイプの注釈がある場合、 &lt;code&gt;const&lt;/code&gt; 変数は拡張されないリテラルタイプを取得します。</target>
        </trans-unit>
        <trans-unit id="e7a432de388d59eb0330d3d1bf7924a86dc9fda9" translate="yes" xml:space="preserve">
          <source>Loading of types from npm packages</source>
          <target state="translated">npm パッケージからの型の読み込み</target>
        </trans-unit>
        <trans-unit id="7e4fa40194fa1599fc6410e0f480c52786bb6b60" translate="yes" xml:space="preserve">
          <source>Local and Imported Type Declarations Now Conflict</source>
          <target state="translated">ローカル型宣言と輸入型宣言が衝突するようになった</target>
        </trans-unit>
        <trans-unit id="dc901218db3c05e3ca7a85bfcded3b7a52e18ec2" translate="yes" xml:space="preserve">
          <source>Local class, interface, enum, and type alias declarations can now appear inside function declarations. Local types are block scoped, similar to variables declared with &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. For example:</source>
          <target state="translated">ローカルのクラス、インターフェース、列挙型、および型エイリアスの宣言を関数宣言の内部に表示できるようになりました。ローカル型はブロックスコープであり、 &lt;code&gt;let&lt;/code&gt; および &lt;code&gt;const&lt;/code&gt; で宣言された変数と同様です。例えば：</target>
        </trans-unit>
        <trans-unit id="d28868f17a046f8c9d0605670df6ffd291397586" translate="yes" xml:space="preserve">
          <source>Local type declarations</source>
          <target state="translated">ローカル型宣言</target>
        </trans-unit>
        <trans-unit id="25ce31967aab4a48e0accd8ada4e9c79a67d8e96" translate="yes" xml:space="preserve">
          <source>Local types may reference enclosing type parameters and local class and interfaces may themselves be generic. For example:</source>
          <target state="translated">ローカル型は、それを囲む型パラメータを参照することができ、ローカルクラスやインターフェイスはそれ自体が汎用的なものであることがあります。例えば</target>
        </trans-unit>
        <trans-unit id="d54f7840dd15f9efca1a3c2a835dba90f27406bb" translate="yes" xml:space="preserve">
          <source>Localized diagnostics on the command line</source>
          <target state="translated">コマンドラインでのローカライズされた診断</target>
        </trans-unit>
        <trans-unit id="dbc698b0052336839927b67e68ee8b808258468a" translate="yes" xml:space="preserve">
          <source>Locally scoped JSX namespaces</source>
          <target state="translated">ローカルにスコープされた JSX 名前空間</target>
        </trans-unit>
        <trans-unit id="f24374818cfbd2c002fceb8b97034ee88dd96257" translate="yes" xml:space="preserve">
          <source>Location of default .d.ts</source>
          <target state="translated">デフォルトの.d.tsの場所</target>
        </trans-unit>
        <trans-unit id="f34ec36309212ab4f733a475011c562c23d0e729" translate="yes" xml:space="preserve">
          <source>Log.ts</source>
          <target state="translated">Log.ts</target>
        </trans-unit>
        <trans-unit id="57f54137157041b8ae56134eceada37f0aaf7daf" translate="yes" xml:space="preserve">
          <source>Look in the first localhost folder, then scripts/app.ts</source>
          <target state="translated">最初のlocalhostフォルダ、次にscripts/app.tsを探します。</target>
        </trans-unit>
        <trans-unit id="8fdfcce162943820f24951cb2a2e053a7c7c3ec0" translate="yes" xml:space="preserve">
          <source>Look in your &lt;code&gt;C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets&lt;/code&gt; file. The authoritative mappings between MSBuild XML tags and &lt;code&gt;tsc&lt;/code&gt; compiler options live in there.</source>
          <target state="translated">あなたの探す場所 &lt;code&gt;C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets&lt;/code&gt; ファイル。MSBuild XMLタグと &lt;code&gt;tsc&lt;/code&gt; コンパイラオプション間の信頼できるマッピングがそこにあります。</target>
        </trans-unit>
        <trans-unit id="a6b0fb8ef6778ed02a7ae1ae513bbf8d954f0a94" translate="yes" xml:space="preserve">
          <source>MSBuild</source>
          <target state="translated">MSBuild</target>
        </trans-unit>
        <trans-unit id="2e00dde89c6a5b86d9cb21be7fbf224d7c22deec" translate="yes" xml:space="preserve">
          <source>MSBuild Property Name</source>
          <target state="translated">MSBuild 物件名</target>
        </trans-unit>
        <trans-unit id="6460830fa61cf6da70e79284adc64a8688cb9f06" translate="yes" xml:space="preserve">
          <source>MSG</source>
          <target state="translated">MSG</target>
        </trans-unit>
        <trans-unit id="528349fad89f8e558db9d5dd9f001d6ed4aceabc" translate="yes" xml:space="preserve">
          <source>Make sure that the modules work by running &lt;code&gt;gulp&lt;/code&gt; and then testing in Node:</source>
          <target state="translated">モジュールが &lt;code&gt;gulp&lt;/code&gt; を実行して動作することを確認してから、Nodeでテストします。</target>
        </trans-unit>
        <trans-unit id="06adecb648f1663461f793b6ad17375e5c241d45" translate="yes" xml:space="preserve">
          <source>Make sure to revisit the &lt;a href=&quot;library-structures#consuming-dependencies&quot;&gt;Consuming dependencies&lt;/a&gt; section for more information.</source>
          <target state="translated">詳細については、「&lt;a href=&quot;library-structures#consuming-dependencies&quot;&gt;依存関係&lt;/a&gt;の消費」セクションを再度参照してください。</target>
        </trans-unit>
        <trans-unit id="8dc73c8a520471a285c4dd9769e30a805d1f4ca3" translate="yes" xml:space="preserve">
          <source>Many JavaScript developers are intimately familiar with this behavior, but if you&amp;rsquo;re surprised, you&amp;rsquo;re certainly not alone. Most people expect the output to be</source>
          <target state="translated">多くのJavaScript開発者はこの動作に精通していますが、驚いたのはあなただけではありません。ほとんどの人は出力が</target>
        </trans-unit>
        <trans-unit id="fe4a673619fce4477eac837da092bcc0b04ae5cf" translate="yes" xml:space="preserve">
          <source>Many bundlers have support for automatically splitting output bundles based on these &lt;code&gt;import&lt;/code&gt; expressions, so consider using this new feature with the &lt;code&gt;esnext&lt;/code&gt; module target.</source>
          <target state="translated">多くのバンドラーは、これらの &lt;code&gt;import&lt;/code&gt; 式に基づいて出力バンドルを自動的に分割することをサポートしているため、この新しい機能を &lt;code&gt;esnext&lt;/code&gt; モジュールターゲットで使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="584c646b07ca217d5f7c1b61637d077ae1a5e971" translate="yes" xml:space="preserve">
          <source>Many common mistakes in declaration files can be easily avoided. The &lt;a href=&quot;do-s-and-don-ts&quot;&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt; section identifies common errors, describes how to detect them, and how to fix them. Everyone should read this section to help themselves avoid common mistakes.</source>
          <target state="translated">宣言ファイルの多くの一般的な間違いは簡単に回避できます。&lt;a href=&quot;do-s-and-don-ts&quot;&gt;ドゥのといけないこと&lt;/a&gt;セクションを識別一般的なエラーは、それらを検出する方法、およびそれらを修正する方法について説明します。誰もがこのセクションを読んで、よくある間違いを回避してください。</target>
        </trans-unit>
        <trans-unit id="eb06e5cbf12cdc30df47507b636fcce479ba328c" translate="yes" xml:space="preserve">
          <source>Many popular Node.js libraries are in the module family, such as &lt;a href=&quot;http://expressjs.com/&quot;&gt;&lt;code&gt;express&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://gulpjs.com/&quot;&gt;&lt;code&gt;gulp&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://github.com/request/request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">多くの一般的なNode.jsライブラリーは、モジュールファミリーに&lt;a href=&quot;http://gulpjs.com/&quot;&gt; &lt;code&gt;gulp&lt;/code&gt; &lt;/a&gt;ています（&lt;a href=&quot;http://expressjs.com/&quot;&gt; &lt;code&gt;express&lt;/code&gt; &lt;/a&gt;、gulp、&lt;a href=&quot;https://github.com/request/request&quot;&gt; &lt;code&gt;request&lt;/code&gt; など)&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63a6f8dd928db9783606b9b55a4d1e30673d97c7" translate="yes" xml:space="preserve">
          <source>Many popular libraries, such as Express, expose themselves as a callable function when imported. For example, the typical Express usage looks like this:</source>
          <target state="translated">Express のような多くの一般的なライブラリは、インポート時に呼び出し可能な関数として自分自身を公開します。例えば、典型的な Express の使い方は次のようになります。</target>
        </trans-unit>
        <trans-unit id="c6113dbcfc0c046c2e863aac93003dd4c0388bee" translate="yes" xml:space="preserve">
          <source>Many times, we are faced with writing a declaration file when we only have examples of the underlying library to guide us. The &lt;a href=&quot;by-example&quot;&gt;By Example&lt;/a&gt; section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.</source>
          <target state="translated">多くの場合、私たちをガイドするための基礎となるライブラリの例しかない場合、宣言ファイルを作成する必要があります。&lt;a href=&quot;by-example&quot;&gt;例&lt;/a&gt;のセクションを示し、多くの共通APIのパターンとどのようにそれらのそれぞれのための宣言を書き込みます。このガイドは、TypeScriptのすべての言語構成にまだ慣れていない場合があるTypeScript初心者を対象としています。</target>
        </trans-unit>
        <trans-unit id="e04dbd57e91d78d0c5bec01a4fe02f73a4ba1540" translate="yes" xml:space="preserve">
          <source>Map Root - &lt;code&gt;mapRoot&lt;/code&gt;</source>
          <target state="translated">マップルート &lt;code&gt;mapRoot&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b39eaaa138d38f75f9ba15b0ecb54217b1f43d1d" translate="yes" xml:space="preserve">
          <source>Mapped Types</source>
          <target state="translated">マップされたタイプ</target>
        </trans-unit>
        <trans-unit id="f5503e0acfd60752001069a9088cb22064b114de" translate="yes" xml:space="preserve">
          <source>Mapped types</source>
          <target state="translated">マップされたタイプ</target>
        </trans-unit>
        <trans-unit id="150ac025be99fedc0936df23f699d5432059212b" translate="yes" xml:space="preserve">
          <source>Mapped types are produced by taking a union of literal types, and computing a set of properties for a new object type. They&amp;rsquo;re like &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions&quot;&gt;list comprehensions in Python&lt;/a&gt;, but instead of producing new elements in a list, they produce new properties in a type.</source>
          <target state="translated">マップされた型は、リテラル型の和集合を取り、新しいオブジェクト型の一連のプロパティを計算することによって生成されます。それらは&lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions&quot;&gt;Pythonのリスト内包に&lt;/a&gt;似ていますが、リストに新しい要素を生成する代わりに、型に新しいプロパティを生成します。</target>
        </trans-unit>
        <trans-unit id="347c61475a676c2faf7ddbe772ebae4b5d598063" translate="yes" xml:space="preserve">
          <source>Mapped types on tuples and arrays</source>
          <target state="translated">タプルと配列にマッピングされた型</target>
        </trans-unit>
        <trans-unit id="8e8a7963f001150e8ed8e3c1be77a5be18c61c35" translate="yes" xml:space="preserve">
          <source>Mapped types support adding a &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; modifier to a mapped property, but they did not provide support the ability to &lt;em&gt;remove&lt;/em&gt; modifiers. This matters in &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/12563&quot;&gt;&lt;em&gt;homomorphic mapped types&lt;/em&gt;&lt;/a&gt; which by default preserve the modifiers of the underlying type.</source>
          <target state="translated">マップされたタイプは、 &lt;code&gt;readonly&lt;/code&gt; または &lt;code&gt;?&lt;/code&gt; マップされたプロパティへの修飾子ですが&lt;em&gt;、&lt;/em&gt;修飾子を&lt;em&gt;削除する&lt;/em&gt;機能をサポートしていませんでした。これは、デフォルトで基礎となる型の修飾子を保持する&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/12563&quot;&gt;&lt;em&gt;準同型のマッピングされた型&lt;/em&gt;&lt;/a&gt;で重要です。</target>
        </trans-unit>
        <trans-unit id="1cbcdd98d1b5744757244f463b7f939b4869f3e4" translate="yes" xml:space="preserve">
          <source>Mappings</source>
          <target state="translated">Mappings</target>
        </trans-unit>
        <trans-unit id="76afa4572a785cbf8909d66ab1eaf36ef69ba191" translate="yes" xml:space="preserve">
          <source>Matching behavior</source>
          <target state="translated">マッチング行動</target>
        </trans-unit>
        <trans-unit id="e877b2873e30b35f125ca0ad5fb9dc583519caa0" translate="yes" xml:space="preserve">
          <source>Max Node Module JS Depth - &lt;code&gt;maxNodeModuleJsDepth&lt;/code&gt;</source>
          <target state="translated">最大ノードモジュールJS深度 &lt;code&gt;maxNodeModuleJsDepth&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6746fd6ef4bdedacc9e255f7e5c953f3f9081507" translate="yes" xml:space="preserve">
          <source>Maybe it was easy to spot out for some experienced JavaScript developers, but the inner &lt;code&gt;for&lt;/code&gt;-loop will accidentally overwrite the variable &lt;code&gt;i&lt;/code&gt; because &lt;code&gt;i&lt;/code&gt; refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.</source>
          <target state="translated">経験豊富なJavaScript開発者にとっては簡単に見つけられるかもしれませんが、 &lt;code&gt;i&lt;/code&gt; が同じ関数スコープの変数を参照しているため、内部の &lt;code&gt;for&lt;/code&gt; ループが誤って変数 &lt;code&gt;i&lt;/code&gt; を上書きしてしまいます。経験豊富な開発者が今までに知っているように、同様の種類のバグがコードレビューをすり抜けて、フラストレーションの無限の原因になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="d61fb1c71d97cf23364513b6c042480baf71317b" translate="yes" xml:space="preserve">
          <source>Maybe it was easy to spot out for some, but the inner &lt;code&gt;for&lt;/code&gt;-loop will accidentally overwrite the variable &lt;code&gt;i&lt;/code&gt; because &lt;code&gt;i&lt;/code&gt; refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.</source>
          <target state="translated">多分いくつかのために見つけるのは簡単だったが、インナー &lt;code&gt;for&lt;/code&gt; -loopは偶然変数が上書きされます &lt;code&gt;i&lt;/code&gt; するので &lt;code&gt;i&lt;/code&gt; 同じ機能スコープ変数を参照します。経験豊富な開発者がすでに知っているように、同様の種類のバグがコードレビューをすり抜け、欲求不満の無限の原因になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="d8e319d394c7e9ed6ef1448bbdf219ff4e98198e" translate="yes" xml:space="preserve">
          <source>Merging Interfaces</source>
          <target state="translated">インターフェースのマージ</target>
        </trans-unit>
        <trans-unit id="87557ad474b3ea1cb7dc79b4a0a69cc3c542648b" translate="yes" xml:space="preserve">
          <source>Merging Namespaces</source>
          <target state="translated">名前空間のマージ</target>
        </trans-unit>
        <trans-unit id="d457feda7cc53bf9cc76dc59489863c6ef6d30dd" translate="yes" xml:space="preserve">
          <source>Merging Namespaces with Classes</source>
          <target state="translated">名前空間とクラスの結合</target>
        </trans-unit>
        <trans-unit id="78529d067c66e125c411afd44c6c212aea17fa3a" translate="yes" xml:space="preserve">
          <source>Merging Namespaces with Classes, Functions, and Enums</source>
          <target state="translated">名前空間をクラス、関数、および列挙型と結合する</target>
        </trans-unit>
        <trans-unit id="91bb6095ae597def81503d12e83651b39c84f4ab" translate="yes" xml:space="preserve">
          <source>Merging ambient class and interface declaration</source>
          <target state="translated">アンビエントクラスとインターフェイスの宣言をマージ</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="f70c71c1b2246c59d442015fb609b0bf48d83d56" translate="yes" xml:space="preserve">
          <source>Method Decorators</source>
          <target state="translated">メソッドデコレーター</target>
        </trans-unit>
        <trans-unit id="9adde04ca5b9eac1941dd0c91655d283d19fa1d1" translate="yes" xml:space="preserve">
          <source>Methods within an abstract class that are marked as abstract do not contain an implementation and must be implemented in derived classes. Abstract methods share a similar syntax to interface methods. Both define the signature of a method without including a method body. However, abstract methods must include the &lt;code&gt;abstract&lt;/code&gt; keyword and may optionally include access modifiers.</source>
          <target state="translated">抽象としてマークされている抽象クラス内のメソッドは実装を含まないため、派生クラスで実装する必要があります。抽象メソッドは、インターフェースメソッドと同様の構文を共有します。どちらも、メソッド本体を含めずにメソッドのシグネチャを定義します。ただし、抽象メソッドには、 &lt;code&gt;abstract&lt;/code&gt; キーワードを含める必要があり、オプションでアクセス修飾子を含めることができます。</target>
        </trans-unit>
        <trans-unit id="b6b88d2f7dec6e6507655392b41d6d66aa58943b" translate="yes" xml:space="preserve">
          <source>Microsoft.TypeScript.Compiler</source>
          <target state="translated">Microsoft.TypeScript.Compiler</target>
        </trans-unit>
        <trans-unit id="d6994e014929b9c9acadb4efcdd0d8898ec4998f" translate="yes" xml:space="preserve">
          <source>Microsoft.TypeScript.MSBuild</source>
          <target state="translated">Microsoft.TypeScript.MSBuild</target>
        </trans-unit>
        <trans-unit id="ecf39fd6186584cf8c46f851590e11d05b7c8704" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript</source>
          <target state="translated">JavaScriptからの移行</target>
        </trans-unit>
        <trans-unit id="006f2d2335563fb2900269f9b04adab236ac86ea" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Early Benefits</source>
          <target state="translated">JavaScriptからの移行。初期のメリット</target>
        </trans-unit>
        <trans-unit id="1fed3c879f3bb26b579690b94983582cf0edda15" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Getting Stricter Checks</source>
          <target state="translated">JavaScriptからの移行。より厳しいチェックを受ける</target>
        </trans-unit>
        <trans-unit id="1dc81892a9e5e97f6be65072af4047daf654e1d2" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Gulp</source>
          <target state="translated">JavaScriptからの移行。ガルプ</target>
        </trans-unit>
        <trans-unit id="7e19d5d40009a708d8b21bd446a6de963f361896" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Integrating with Build Tools</source>
          <target state="translated">JavaScriptからの移行。ビルドツールとの統合</target>
        </trans-unit>
        <trans-unit id="4ff2a610f7fca46011040ebfbaebde73fe2d0b89" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Moving to TypeScript Files</source>
          <target state="translated">JavaScriptからの移行。TypeScript ファイルへの移行</target>
        </trans-unit>
        <trans-unit id="9b91d79ea65c179b3144057c1b47e944dbe888c8" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Setting up your Directories</source>
          <target state="translated">JavaScriptからの移行。ディレクトリの設定</target>
        </trans-unit>
        <trans-unit id="47148fd07a568fa2a38d4ed900235994bd81cea2" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Webpack</source>
          <target state="translated">JavaScriptからの移行。Webpack</target>
        </trans-unit>
        <trans-unit id="49c6b428dbb35a643f704a1239347e7235a4958b" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Weeding out Errors</source>
          <target state="translated">JavaScriptからの移行。エラーを取り除く</target>
        </trans-unit>
        <trans-unit id="8ec1b6d66f7377a566796d605d898d7ac205f685" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Writing a Configuration File</source>
          <target state="translated">JavaScriptからの移行。設定ファイルを書く</target>
        </trans-unit>
        <trans-unit id="df5cb9211be987b98b3cea69592169ee4806d416" translate="yes" xml:space="preserve">
          <source>Minimal project</source>
          <target state="translated">最小限のプロジェクト</target>
        </trans-unit>
        <trans-unit id="656fbec7e4c8bcab6e3951b1194d9d3fdebdb947" translate="yes" xml:space="preserve">
          <source>Mixin classes can constrain the types of classes they can mix into by specifying a construct signature return type in the constraint for the type parameter. For example, the following &lt;code&gt;WithLocation&lt;/code&gt; function implements a subclass factory that adds a &lt;code&gt;getLocation&lt;/code&gt; method to any class that satisfies the &lt;code&gt;Point&lt;/code&gt; interface (i.e. that has &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; properties of type &lt;code&gt;number&lt;/code&gt;).</source>
          <target state="translated">Mixinクラスは、typeパラメータの制約で構成シグネチャの戻り値の型を指定することにより、混合できるクラスのタイプを制約できます。たとえば、次の &lt;code&gt;WithLocation&lt;/code&gt; 関数は、 &lt;code&gt;Point&lt;/code&gt; インターフェースを満たす任意のクラス（つまり、 &lt;code&gt;number&lt;/code&gt; 型の &lt;code&gt;x&lt;/code&gt; プロパティと &lt;code&gt;y&lt;/code&gt; プロパティを持つクラス）に &lt;code&gt;getLocation&lt;/code&gt; メソッドを追加するサブクラスファクトリを実装します。</target>
        </trans-unit>
        <trans-unit id="ed6542d9669951817ce6e0f5f573873a74bbcd94" translate="yes" xml:space="preserve">
          <source>Mixin sample</source>
          <target state="translated">ミキシンサンプル</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="a7b93d2128e820f861fc8dfccd9f5521e89ad21f" translate="yes" xml:space="preserve">
          <source>Mode</source>
          <target state="translated">Mode</target>
        </trans-unit>
        <trans-unit id="bf3760256feac6cc46ec45ef674425285cde51d6" translate="yes" xml:space="preserve">
          <source>Modern browsers support all ES6 features, so &lt;code&gt;ES6&lt;/code&gt; is a good choice. You might choose to set a lower target if your code is deployed to older environments, or a higher target if your code is guaranteed to run in newer environments.</source>
          <target state="translated">最新のブラウザはすべてのES6機能をサポートしているため、 &lt;code&gt;ES6&lt;/code&gt; が適しています。コードが古い環境にデプロイされている場合は低いターゲットを設定し、コードが新しい環境で実行されることが保証されている場合は高いターゲットを設定することを選択できます。</target>
        </trans-unit>
        <trans-unit id="a6b8e599868465369a62573e28c7d5b2c17c8067" translate="yes" xml:space="preserve">
          <source>Modify the html by removing one of the &lt;code&gt;p&lt;/code&gt; tags, but keep the text.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; タグの1つを削除してhtmlを変更しますが、テキストは保持します。</target>
        </trans-unit>
        <trans-unit id="8686e36f3c455dfff0e15750343932a50c4f9345" translate="yes" xml:space="preserve">
          <source>Modular Libraries</source>
          <target state="translated">モジュラーライブラリ</target>
        </trans-unit>
        <trans-unit id="e87eeaf0b3370593816d7faa70993da2a4c34bdc" translate="yes" xml:space="preserve">
          <source>Modular libraries will typically have at least some of the following:</source>
          <target state="translated">モジュラーライブラリは、通常、以下の少なくとも一部を備えています。</target>
        </trans-unit>
        <trans-unit id="680e2cdf724785f8d2fb8c99fb4ac60b980c1748" translate="yes" xml:space="preserve">
          <source>Module - &lt;code&gt;module&lt;/code&gt;</source>
          <target state="translated">モジュール- &lt;code&gt;module&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="679935999c06d0d64c305facc48d71ad3d62a359" translate="yes" xml:space="preserve">
          <source>Module Augmentation</source>
          <target state="translated">モジュールの拡張</target>
        </trans-unit>
        <trans-unit id="288e4a8c6676ea4eb83392ffcf2395bf08c232ab" translate="yes" xml:space="preserve">
          <source>Module Resolution</source>
          <target state="translated">モジュールの解像度</target>
        </trans-unit>
        <trans-unit id="3f1f355f5558be61bf0295855b4e35d7e9e193c7" translate="yes" xml:space="preserve">
          <source>Module Resolution - &lt;code&gt;moduleResolution&lt;/code&gt;</source>
          <target state="translated">モジュールの解像度 &lt;code&gt;moduleResolution&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e38eacd064c21c297854627bdac879933ce99fef" translate="yes" xml:space="preserve">
          <source>Module Resolution Strategies</source>
          <target state="translated">モジュールの解決策</target>
        </trans-unit>
        <trans-unit id="4cd56198bb579b9f107f6cea74de7d094276eb7a" translate="yes" xml:space="preserve">
          <source>Module identifiers allow for &lt;code&gt;.js&lt;/code&gt; extension</source>
          <target state="translated">モジュール識別子は &lt;code&gt;.js&lt;/code&gt; 拡張子を許可します</target>
        </trans-unit>
        <trans-unit id="a00b56b003050bea7431d876a345583f047b820c" translate="yes" xml:space="preserve">
          <source>Module imports are resolved differently based on whether the module reference is relative or non-relative.</source>
          <target state="translated">モジュールのインポートは、モジュールの参照が相対的なものか非相対的なものかによって解決方法が異なります。</target>
        </trans-unit>
        <trans-unit id="79dbe4a4af0851fd89a5e09eccc010e3219dbe7b" translate="yes" xml:space="preserve">
          <source>Module loaders like SystemJS wrap CommonJS modules and expose then as a &lt;code&gt;default&lt;/code&gt; ES6 import. This makes it impossible to share the definition files between the SystemJS and CommonJS implementation of the module as the module shape looks different based on the loader.</source>
          <target state="translated">SystemJSのようなモジュールローダーはCommonJSモジュールをラップし、 &lt;code&gt;default&lt;/code&gt; ES6インポートとして公開します。これにより、ローダーに基づいてモジュールの形状が異なるため、モジュールのSystemJS実装とCommonJS実装の間で定義ファイルを共有できなくなります。</target>
        </trans-unit>
        <trans-unit id="8706260383ba3213edb052d2ee2093acb606b380" translate="yes" xml:space="preserve">
          <source>Module resolution enhancements: BaseUrl, Path mapping, rootDirs and tracing</source>
          <target state="translated">モジュールの解像度を強化しました。BaseUrl、パスマッピング、rootDirs、トレース</target>
        </trans-unit>
        <trans-unit id="47f28156d69593c826cc9c4bbfcf281e3d6aa9d7" translate="yes" xml:space="preserve">
          <source>Module resolution kind is not specified, using &lt;strong&gt;&amp;lsquo;NodeJs&amp;rsquo;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;'NodeJs'&lt;/strong&gt;を使用して、モジュール解決の種類が指定されていません。</target>
        </trans-unit>
        <trans-unit id="de70d79767a9e812db99a7c477172374c0a8abe1" translate="yes" xml:space="preserve">
          <source>Module system</source>
          <target state="translated">モジュールシステム</target>
        </trans-unit>
        <trans-unit id="0e1df43e7e9f83fc7173a7334ad19fcc3cc8e8bc" translate="yes" xml:space="preserve">
          <source>Module: Class</source>
          <target state="translated">モジュール クラス</target>
        </trans-unit>
        <trans-unit id="f261737e777673d28880af66138654486e39e3bc" translate="yes" xml:space="preserve">
          <source>Module: Function</source>
          <target state="translated">モジュール 機能</target>
        </trans-unit>
        <trans-unit id="3b2f8f319a1e5fc06c98c20b985a907aed2cafd5" translate="yes" xml:space="preserve">
          <source>Module: Plugin</source>
          <target state="translated">モジュール。プラグイン</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="48e09f525757a351dfe7b299e6750c6d122d7d38" translate="yes" xml:space="preserve">
          <source>Modules .d.ts</source>
          <target state="translated">モジュール .d.ts</target>
        </trans-unit>
        <trans-unit id="12d8406349015ac16eed554df9f310ef31446573" translate="yes" xml:space="preserve">
          <source>Modules also have a dependency on a module loader (such as CommonJs/Require.js) or a runtime which supports ES Modules. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.</source>
          <target state="translated">また、モジュールはモジュールローダー(CommonJs/Require.jsなど)やESモジュールをサポートするランタイムに依存しています。モジュールは、コードの再利用性を高め、分離を強化し、バンドルのためのツールのサポートを向上させます。</target>
        </trans-unit>
        <trans-unit id="a30c7f6e8f418488e99ab172a19da443b4fdc2aa" translate="yes" xml:space="preserve">
          <source>Modules also have a dependency on a module loader (such as CommonJs/Require.js). For a small JS application this might not be optimal, but for larger applications, the cost comes with long term modularity and maintainability benefits. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.</source>
          <target state="translated">また、モジュールはモジュールローダー(CommonJs/Require.jsなど)に依存しています。小規模な JS アプリケーションでは最適ではないかもしれませんが、大規模なアプリケーションでは、長期的なモジュール性と保守性の利点がコストに反映されます。モジュールは、コードの再利用性を高め、分離性を高め、バンドル化のためのツールのサポートを強化します。</target>
        </trans-unit>
        <trans-unit id="78a50e79f8142b8f5f0f90d0fa7d14efea7d1c2f" translate="yes" xml:space="preserve">
          <source>Modules are declarative; the relationships between modules are specified in terms of imports and exports at the file level.</source>
          <target state="translated">モジュールは宣言的なもので、モジュール間の関係はファイルレベルでインポートとエクスポートの観点から指定されます。</target>
        </trans-unit>
        <trans-unit id="675dd99631ed01c0f9ec0b8b2aaed9ef0a2c4dfd" translate="yes" xml:space="preserve">
          <source>Modules are executed within their own scope, not in the global scope; this means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the &lt;a href=&quot;#export&quot;&gt;&lt;code&gt;export&lt;/code&gt; forms&lt;/a&gt;. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the &lt;a href=&quot;#import&quot;&gt;&lt;code&gt;import&lt;/code&gt; forms&lt;/a&gt;.</source>
          <target state="translated">モジュールは、グローバルスコープではなく、独自のスコープ内で実行されます。つまり、モジュールで宣言された変数、関数、クラスなどは、&lt;a href=&quot;#export&quot;&gt; &lt;code&gt;export&lt;/code&gt; フォームの&lt;/a&gt; 1つを使用して明示的にエクスポートしない限り、モジュールの外部からは見えません。逆に、別のモジュールからエクスポートされた変数、関数、クラス、インターフェースなどを使用するには、いずれかの&lt;a href=&quot;#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; フォーム&lt;/a&gt;を使用してインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="cf0193704c9e50ad766367f6e68a7b531b34d65e" translate="yes" xml:space="preserve">
          <source>Modules are now emitted with a &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; prologue</source>
          <target state="translated">モジュールは &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; 発行されるようになりました。プロローグ</target>
        </trans-unit>
        <trans-unit id="e2a4a37826bb3f0f9a97d6eaca31fecba95d357a" translate="yes" xml:space="preserve">
          <source>Modules are parsed automatically in strict mode. The new flag is recommended for non-module code.</source>
          <target state="translated">モジュールは厳密なモードで自動的に解析されます。この新しいフラグは、モジュール以外のコードに推奨されます。</target>
        </trans-unit>
        <trans-unit id="eb465684cf64b809ea4e18738ce52c8fd9a32f30" translate="yes" xml:space="preserve">
          <source>Modules can contain both code and declarations.</source>
          <target state="translated">モジュールにはコードと宣言の両方を含めることができます。</target>
        </trans-unit>
        <trans-unit id="5b28d96858ba2eea0c5a37016b2613ff4945fbf0" translate="yes" xml:space="preserve">
          <source>Modules can import types declared in other modules. But non-module global scripts cannot access types declared in modules. Enter &lt;code&gt;import&lt;/code&gt; types.</source>
          <target state="translated">モジュールは、他のモジュールで宣言された型をインポートできます。ただし、モジュール以外のグローバルスクリプトは、モジュールで宣言された型にアクセスできません。 &lt;code&gt;import&lt;/code&gt; タイプを入力します。</target>
        </trans-unit>
        <trans-unit id="f37a7873a73994ccdd158807226796e74f617880" translate="yes" xml:space="preserve">
          <source>Modules import one another using a module loader. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. Well-known module loaders used in JavaScript are Node.js&amp;rsquo;s loader for &lt;a href=&quot;https://en.wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; modules and the &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; loader for &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/amd.html&quot;&gt;AMD&lt;/a&gt; modules in Web applications.</source>
          <target state="translated">モジュールはモジュールローダーを使用して互いにインポートします。実行時、モジュールローダーは、モジュールを実行する前に、モジュールのすべての依存関係を見つけて実行する責任があります。 JavaScriptで使用されるよく知られたモジュールローダーは、&lt;a href=&quot;https://en.wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt;モジュール用のNode.jsローダーと、Webアプリケーションの&lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/amd.html&quot;&gt;AMD&lt;/a&gt;モジュール用の&lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt;ローダーです。</target>
        </trans-unit>
        <trans-unit id="252a052c9420d6ecb6b140e66b5a6e193c6c9859" translate="yes" xml:space="preserve">
          <source>Modules import one another using a module loader. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. Well-known module loaders used in JavaScript are Node.js&amp;rsquo;s loader for &lt;a href=&quot;https://wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; modules and the &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; loader for &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/AMD.md&quot;&gt;AMD&lt;/a&gt; modules in Web applications.</source>
          <target state="translated">モジュールは、モジュールローダーを使用して相互にインポートします。実行時に、モジュールローダーはモジュールを実行する前にモジュールのすべての依存関係を見つけて実行する責任があります。JavaScriptで使用されるよく知られたモジュールローダーは、&lt;a href=&quot;https://wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt;モジュール用のNode.jsのローダーと、Webアプリケーションの&lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/AMD.md&quot;&gt;AMD&lt;/a&gt;モジュール用の&lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt;ローダーです。</target>
        </trans-unit>
        <trans-unit id="f58764143073eae1cd29c9babec8bc1672b59332" translate="yes" xml:space="preserve">
          <source>Modules were always parsed in strict mode as per ES6, but for non-ES6 targets this was not respected in the generated code. Starting with TypeScript 1.8, emitted modules are always in strict mode. This shouldn&amp;rsquo;t have any visible changes in most code as TS considers most strict mode errors as errors at compile time, but it means that some things which used to silently fail at runtime in your TS code, like assigning to &lt;code&gt;NaN&lt;/code&gt;, will now loudly fail. You can reference the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;MDN Article&lt;/a&gt; on strict mode for a detailed list of the differences between strict mode and non-strict mode.</source>
          <target state="translated">モジュールは常にES6に従って厳密モードで解析されましたが、非ES6ターゲットの場合、これは生成されたコードでは考慮されませんでした。TypeScript 1.8以降、発行されたモジュールは常に厳密モードになります。TSはコンパイル時の最も厳密なモードエラーをエラーと見なすため、これはほとんどのコードに目に見える変化はないはずですが、これは、 &lt;code&gt;NaN&lt;/code&gt; への割り当てなど、TSコードの実行時に暗黙的に失敗するものを大声で不合格。厳格モードと非厳格モードの違いの詳細なリストについては、厳格モードの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;MDN記事&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="69245e47778546d5b4d8c60a97c075633036ce67" translate="yes" xml:space="preserve">
          <source>More Accurate Array Spread</source>
          <target state="translated">より正確なアレイの広がり</target>
        </trans-unit>
        <trans-unit id="867951121618b22e94ac0ddd378f75a352293d4f" translate="yes" xml:space="preserve">
          <source>More details about defining MSBuild compiler options: &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;Setting Compiler Options in MSBuild projects&lt;/a&gt;</source>
          <target state="translated">MSBuildコンパイラオプションの定義に関する詳細：&lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuildプロジェクトでのコンパイラオプションの設定&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="341a196acd33aea44262f80c4074a8f29f17eab0" translate="yes" xml:space="preserve">
          <source>More details can be found at &lt;a href=&quot;http://docs.nuget.org/Consume/Package-Manager-Dialog&quot;&gt;Package Manager Dialog&lt;/a&gt; and &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild&quot;&gt;using nightly builds with NuGet&lt;/a&gt;</source>
          <target state="translated">詳細については、&lt;a href=&quot;http://docs.nuget.org/Consume/Package-Manager-Dialog&quot;&gt;パッケージマネージャーダイアログ&lt;/a&gt;および&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild&quot;&gt;NuGetでのナイトリービルドの使用を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="53846a07e48104da9e41b5b1360721c3ad76cfc9" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm&quot;&gt;TypeScriptSamples/jspm&lt;/a&gt;</source>
          <target state="translated">詳細：&lt;a href=&quot;https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm&quot;&gt;TypeScriptSamples / jspm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f54abbf20043f5f79ba176f97dcafaab83a262d" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/TypeStrong/grunt-ts&quot;&gt;TypeStrong/grunt-ts&lt;/a&gt;</source>
          <target state="translated">詳細：&lt;a href=&quot;https://github.com/TypeStrong/grunt-ts&quot;&gt;TypeStrong / grunt-ts&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4be1d9cace5494e189a22e68f895ee7cf9cddcd" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/frankwallis/duo-typescript&quot;&gt;frankwallis/duo-typescript&lt;/a&gt;</source>
          <target state="translated">詳細：&lt;a href=&quot;https://github.com/frankwallis/duo-typescript&quot;&gt;frankwallis / duo-typescript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9288db5f93cb0d64c4598820b26040518ce475e5" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/ivogabe/gulp-typescript&quot;&gt;ivogabe/gulp-typescript&lt;/a&gt;</source>
          <target state="translated">詳細：&lt;a href=&quot;https://github.com/ivogabe/gulp-typescript&quot;&gt;ivogabe / gulp-typescript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c2859a3239620cafb1098f30753d17591c86749" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/smrq/tsify&quot;&gt;smrq/tsify&lt;/a&gt;</source>
          <target state="translated">詳細：&lt;a href=&quot;https://github.com/smrq/tsify&quot;&gt;smrq / tsify&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="383f0e0e882a4dc2683b66372e6aa52e3a75f04b" translate="yes" xml:space="preserve">
          <source>More examples</source>
          <target state="translated">その他の例</target>
        </trans-unit>
        <trans-unit id="d6f53e513aa21c7609698b66494f900516f1e524" translate="yes" xml:space="preserve">
          <source>More information is available at &lt;a href=&quot;https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions&quot;&gt;VSCode documentation&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions&quot;&gt;VSCodeのドキュメント&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="3ebf7c56cc3c7e6470d4e988436ec5ba45710c59" translate="yes" xml:space="preserve">
          <source>More information is available at the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation&quot;&gt;TypeScript Plugin for Sublime Text installation documentation&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation&quot;&gt;TypeScript Plugin for Sublime Textのインストールドキュメントを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f1fd24b8a3a7e494a8b827fe826c345c6c39fc7" translate="yes" xml:space="preserve">
          <source>More more details, you can &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining/&quot;&gt;read up on the proposal&lt;/a&gt; and &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33294&quot;&gt;view the original pull request&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining/&quot;&gt;提案&lt;/a&gt;を読んで&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33294&quot;&gt;、元のプルリクエストを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="752dbfdfe70e9a653727ad54bd026e4e1adbb672" translate="yes" xml:space="preserve">
          <source>More of a gotcha than a constraint. The class expression pattern creates singletons, so they can&amp;rsquo;t be mapped at the type system to support different variable types.</source>
          <target state="translated">制約というよりは落とし穴です。クラス式パターンはシングルトンを作成するため、異なる変数タイプをサポートするために型システムにマッピングすることはできません。</target>
        </trans-unit>
        <trans-unit id="87404c3db1a136e631f5512bc31b4108095e74c7" translate="yes" xml:space="preserve">
          <source>More on Functions</source>
          <target state="translated">関数の詳細</target>
        </trans-unit>
        <trans-unit id="2090b67c917ff081773b34229e30e6990c49b179" translate="yes" xml:space="preserve">
          <source>More plainly, that code snippet is the same as writing the following.</source>
          <target state="translated">もっとわかりやすく言うと、そのコードスニペットは以下のように書くのと同じです。</target>
        </trans-unit>
        <trans-unit id="e65b8445ad886f1be93458429fb5dd37c90a50bb" translate="yes" xml:space="preserve">
          <source>More than this, JS has become popular enough to be used outside the context of browsers, such as implementing JS servers using node.js. The &amp;ldquo;run anywhere&amp;rdquo; nature of JS makes it an attractive choice for cross-platform development. There are many developers these days that use &lt;em&gt;only&lt;/em&gt; JavaScript to program their entire stack!</source>
          <target state="translated">これ以上に、JSは、node.jsを使用してJSサーバーを実装するなど、ブラウザーのコンテキスト外で使用できるほど普及しています。JSの「どこでも実行」の性質により、クロスプラットフォーム開発にとって魅力的な選択肢となっています。最近では&lt;em&gt;、&lt;/em&gt; JavaScript&lt;em&gt;のみを&lt;/em&gt;使用してスタック全体をプログラムする開発者がたくさんいます。</target>
        </trans-unit>
        <trans-unit id="ba3ba120356f7dea7aa61a6e3ef6b6565d3edcce" translate="yes" xml:space="preserve">
          <source>Most popular libraries are now available as UMD packages. Examples include &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt;, &lt;a href=&quot;https://lodash.com/&quot;&gt;lodash&lt;/a&gt;, and many more.</source>
          <target state="translated">最も人気のあるライブラリがUMDパッケージとして利用できるようになりました。例としては、&lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;、&lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt;、&lt;a href=&quot;https://lodash.com/&quot;&gt;lodash&lt;/a&gt;などがあります。</target>
        </trans-unit>
        <trans-unit id="94b01864f5579af47acd49be012292e69db8aa02" translate="yes" xml:space="preserve">
          <source>Most programming languages would throw an error when these sorts of errors occur, some would do so during compilation &amp;mdash; before any code is running. When writing small programs, such quirks are annoying but manageable; when writing applications with hundreds or thousands of lines of code, these constant surprises are a serious problem.</source>
          <target state="translated">ほとんどのプログラミング言語は、これらの種類のエラーが発生するとエラーをスローしますが、コンパイル中、つまりコードが実行される前にエラーをスローするものもあります。小さなプログラムを書くとき、そのような癖は迷惑ですが扱いやすいです。数百行または数千行のコードでアプリケーションを作成する場合、これらの絶え間ない驚きは深刻な問題です。</target>
        </trans-unit>
        <trans-unit id="638f05be2eca8814a76fc1ca76ad8fd857366420" translate="yes" xml:space="preserve">
          <source>Moving to TypeScript Files</source>
          <target state="translated">TypeScriptファイルへの移動</target>
        </trans-unit>
        <trans-unit id="43621334a2a23b4d5d4b6053efcc9a2d2b0aab17" translate="yes" xml:space="preserve">
          <source>Much of the time when we talk about &amp;ldquo;singleton types&amp;rdquo;, we&amp;rsquo;re referring to both enum member types as well as numeric/string literal types, though many users will use &amp;ldquo;singleton types&amp;rdquo; and &amp;ldquo;literal types&amp;rdquo; interchangeably.</source>
          <target state="translated">多くのユーザーが「シングルトン型」と「リテラル型」を互換的に使用しますが、「シングルトン型」について話すときは、多くの場合、列挙型メンバー型と数値/文字列リテラル型の両方を指します。</target>
        </trans-unit>
        <trans-unit id="17529a071acaf46e503733acf690f3a9c40c2a13" translate="yes" xml:space="preserve">
          <source>Multi-file namespaces</source>
          <target state="translated">複数のファイル名空間</target>
        </trans-unit>
        <trans-unit id="6a46449eba494ccdd3d50009ef86e5514ea905cd" translate="yes" xml:space="preserve">
          <source>Multiple decorators can be applied to a declaration, as in the following examples:</source>
          <target state="translated">以下の例のように、複数のデコレータを宣言に適用することができます。</target>
        </trans-unit>
        <trans-unit id="c84cbd92065cb5c6f658fb4c2b736202ca88a094" translate="yes" xml:space="preserve">
          <source>Multiple fields</source>
          <target state="translated">複数のフィールド</target>
        </trans-unit>
        <trans-unit id="e64884c573469c4403ae3581451fc7bb26479d03" translate="yes" xml:space="preserve">
          <source>Multiple files that have the same &lt;code&gt;export namespace Foo {&lt;/code&gt; at top-level (don&amp;rsquo;t think that these are going to combine into one &lt;code&gt;Foo&lt;/code&gt;!)</source>
          <target state="translated">最上位に同じ &lt;code&gt;export namespace Foo {&lt;/code&gt; を持つ複数のファイル（これらが1つの &lt;code&gt;Foo&lt;/code&gt; に結合されるとは考えないでください！）</target>
        </trans-unit>
        <trans-unit id="c9a109a97c148517f646b23952e44c0d2099a11f" translate="yes" xml:space="preserve">
          <source>Multiple object literal type inferences for the same type parameter are similarly collapsed into a single normalized union type:</source>
          <target state="translated">同じ型パラメータに対する複数のオブジェクトリテラル型推論は、同様に単一の正規化されたユニオン型に畳み込まれます。</target>
        </trans-unit>
        <trans-unit id="aede1800680b8eed7745689bb8cd192726458952" translate="yes" xml:space="preserve">
          <source>Mutually exclusive with &lt;a href=&quot;#sourceMap&quot;&gt;&lt;code&gt;sourceMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sourceMap&quot;&gt; &lt;code&gt;sourceMap&lt;/code&gt; &lt;/a&gt;と相互に排他的です。</target>
        </trans-unit>
        <trans-unit id="2e944fe6e675e7e28c8ee6b40790b0f75443bf77" translate="yes" xml:space="preserve">
          <source>MyClass.ts</source>
          <target state="translated">MyClass.ts</target>
        </trans-unit>
        <trans-unit id="9d75928f38872b5fba12d9e28028ca42f4f74a7f" translate="yes" xml:space="preserve">
          <source>MyFunc.ts</source>
          <target state="translated">MyFunc.ts</target>
        </trans-unit>
        <trans-unit id="6a6cd093331d4efd7bda9e1eec1f6de5f0b888e7" translate="yes" xml:space="preserve">
          <source>MyLargeModule.ts</source>
          <target state="translated">MyLargeModule.ts</target>
        </trans-unit>
        <trans-unit id="d4689856a3bbc2e7a56c851bfc734afc822d4050" translate="yes" xml:space="preserve">
          <source>MyTestPage.html (excerpt)</source>
          <target state="translated">マイテストページ.html(抜粋</target>
        </trans-unit>
        <trans-unit id="5621ae759c74cfb2dde7856d9cb911d0824e1648" translate="yes" xml:space="preserve">
          <source>MyThings.ts</source>
          <target state="translated">MyThings.ts</target>
        </trans-unit>
        <trans-unit id="4e93c1eccd779026bfe9421435d57abbf755af58" translate="yes" xml:space="preserve">
          <source>NOTE A &lt;em&gt;Property Descriptor&lt;/em&gt; is not provided as an argument to a property decorator due to how property decorators are initialized in TypeScript. This is because there is currently no mechanism to describe an instance property when defining members of a prototype, and no way to observe or modify the initializer for a property. The return value is ignored too. As such, a property decorator can only be used to observe that a property of a specific name has been declared for a class.</source>
          <target state="translated">NOTE A &lt;em&gt;プロパティ記述子が&lt;/em&gt;原因プロパティのデコレータは活字体で初期化されているかにプロパティデコレータへの引数として提供されていません。これは、現在、プロトタイプのメンバーを定義するときにインスタンスプロパティを記述するメカニズムがなく、プロパティの初期化子を監視または変更する方法がないためです。戻り値も無視されます。そのため、プロパティデコレータは、特定の名前のプロパティがクラスに対して宣言されていることを確認するためにのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="9845c4ce119ecd689f1dfdba7ee10411216b49e9" translate="yes" xml:space="preserve">
          <source>NOTE A parameter decorator can only be used to observe that a parameter has been declared on a method.</source>
          <target state="translated">注釈 パラメータ・デコレータは、パラメータがメソッドで宣言されていることを監視するためにのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="8b79455e774377963b080298d153feef0d875163" translate="yes" xml:space="preserve">
          <source>NOTE Decorator metadata is an experimental feature and may introduce breaking changes in future releases.</source>
          <target state="translated">NOTE デコレータのメタデータは実験的な機能であり、将来のリリースでは画期的な変更が導入される可能性があります。</target>
        </trans-unit>
        <trans-unit id="2285b393e7b504af0a81971d53ea0b3d317886cd" translate="yes" xml:space="preserve">
          <source>NOTE Decorators are an experimental feature that may change in future releases.</source>
          <target state="translated">NOTE Decoratorsは実験的な機能であり、今後のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="a60eb9bd0a4289a1fdb762b911bc6c4ca3667c6d" translate="yes" xml:space="preserve">
          <source>NOTE Should you choose to return a new constructor function, you must take care to maintain the original prototype. The logic that applies decorators at runtime will &lt;strong&gt;not&lt;/strong&gt; do this for you.</source>
          <target state="translated">注新しいコンストラクタ関数を返すことを選択した場合、元のプロトタイプを維持するように注意する必要があります。実行時にデコレータを適用するロジックはなり&lt;strong&gt;ません&lt;/strong&gt;あなたのためにこれを行います。</target>
        </trans-unit>
        <trans-unit id="60bdff9d3b04677acbffa7e2cc622c91f6a36bb2" translate="yes" xml:space="preserve">
          <source>NOTE The &lt;em&gt;Property Descriptor&lt;/em&gt; will be &lt;code&gt;undefined&lt;/code&gt; if your script target is less than &lt;code&gt;ES5&lt;/code&gt;.</source>
          <target state="translated">注スクリプトターゲットが &lt;code&gt;ES5&lt;/code&gt; 未満の場合、&lt;em&gt;プロパティ記述子&lt;/em&gt;は &lt;code&gt;undefined&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="3819f97fdfb5b90ae474745720dbbf7bdc58c9e6" translate="yes" xml:space="preserve">
          <source>NOTE The return value is ignored if your script target is less than &lt;code&gt;ES5&lt;/code&gt;.</source>
          <target state="translated">注スクリプトターゲットが &lt;code&gt;ES5&lt;/code&gt; 未満の場合、戻り値は無視されます。</target>
        </trans-unit>
        <trans-unit id="195da41da17e46986e65163a2bd1160b912d7429" translate="yes" xml:space="preserve">
          <source>NOTE This example requires the &lt;code&gt;reflect-metadata&lt;/code&gt; library. See &lt;a href=&quot;#metadata&quot;&gt;Metadata&lt;/a&gt; for more information about the &lt;code&gt;reflect-metadata&lt;/code&gt; library.</source>
          <target state="translated">注この例では、 &lt;code&gt;reflect-metadata&lt;/code&gt; ライブラリが必要です。 &lt;code&gt;reflect-metadata&lt;/code&gt; ライブラリの詳細については、&lt;a href=&quot;#metadata&quot;&gt;メタデータ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a10f30aafff5360ca16967a3e15b058ca9402455" translate="yes" xml:space="preserve">
          <source>NOTE TypeScript disallows decorating both the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessor for a single member. Instead, all decorators for the member must be applied to the first accessor specified in document order. This is because decorators apply to a &lt;em&gt;Property Descriptor&lt;/em&gt;, which combines both the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessor, not each declaration separately.</source>
          <target state="translated">注TypeScript では、単一のメンバーに対して &lt;code&gt;get&lt;/code&gt; アクセサーと &lt;code&gt;set&lt;/code&gt; アクセサーの両方を装飾することはできません。代わりに、メンバーのすべてのデコレーターを、ドキュメントの順序で指定された最初のアクセサーに適用する必要があります。これは、デコレータが&lt;em&gt;プロパティ記述子に&lt;/em&gt;適用されるためです。これは、各宣言を個別にではなく、 &lt;code&gt;get&lt;/code&gt; アクセサと &lt;code&gt;set&lt;/code&gt; アクセサの両方を組み合わせたものです。</target>
        </trans-unit>
        <trans-unit id="45308d86614845d7f3bb84b8a20942a74d48e6a9" translate="yes" xml:space="preserve">
          <source>NOTE You can see a more detailed example of a decorator factory in &lt;a href=&quot;#method-decorators&quot;&gt;Method Decorators&lt;/a&gt;, below.</source>
          <target state="translated">注デコレータファクトリのより詳細な例は、以下の&lt;a href=&quot;#method-decorators&quot;&gt;メソッドデコレータ&lt;/a&gt;で確認できます。</target>
        </trans-unit>
        <trans-unit id="77a213401e1d655ca6ce67ccac1b595b83f6a49a" translate="yes" xml:space="preserve">
          <source>NOTE You can see a more detailed example of a decorator in &lt;a href=&quot;#class-decorators&quot;&gt;Class Decorators&lt;/a&gt;, below.</source>
          <target state="translated">注デコレータのより詳細な例は、以下の&lt;a href=&quot;#class-decorators&quot;&gt;クラスデコレータ&lt;/a&gt;で確認できます。</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="3bfed306b0b8464442bdb1711257fd81e5104011" translate="yes" xml:space="preserve">
          <source>Name and location of the import</source>
          <target state="translated">インポートの名前と場所</target>
        </trans-unit>
        <trans-unit id="c4e900249c06ced551414f6dbfecd4345fbf0964" translate="yes" xml:space="preserve">
          <source>Name your files with a &lt;code&gt;.tsx&lt;/code&gt; extension</source>
          <target state="translated">ファイルに &lt;code&gt;.tsx&lt;/code&gt; 拡張子を付けます</target>
        </trans-unit>
        <trans-unit id="f1e1fdc0047ebce963af46e324aa0bb6cc3cd40b" translate="yes" xml:space="preserve">
          <source>Name your project and solution. After select the &lt;em&gt;Create&lt;/em&gt; button</source>
          <target state="translated">プロジェクトとソリューションに名前を付けます。&lt;em&gt;作成&lt;/em&gt;ボタンを選択した後</target>
        </trans-unit>
        <trans-unit id="b69558e9b061498c09673bf8df0b367bf33694fd" translate="yes" xml:space="preserve">
          <source>Named types just give a name to a type; for assignability purposes there&amp;rsquo;s no difference between the type alias &lt;code&gt;One&lt;/code&gt; and the interface type &lt;code&gt;Two&lt;/code&gt; below. They both have a property &lt;code&gt;p: string&lt;/code&gt;. (Type aliases behave differently from interfaces with respect to recursive definitions and type parameters, however.)</source>
          <target state="translated">名前付きタイプは、タイプに名前を付けるだけです。割り当て可能性のために、以下のタイプエイリアス &lt;code&gt;One&lt;/code&gt; とインターフェイスタイプ &lt;code&gt;Two&lt;/code&gt; 間に違いはありません。それらは両方ともプロパティ &lt;code&gt;p: string&lt;/code&gt; 持っています。（ただし、型エイリアスは、再帰的定義と型パラメーターに関して、インターフェースとは異なる動作をします。）</target>
        </trans-unit>
        <trans-unit id="0449e1003dd0cdd92ab163e844540614258e8b38" translate="yes" xml:space="preserve">
          <source>Namespace</source>
          <target state="translated">Namespace</target>
        </trans-unit>
        <trans-unit id="62936894b0ebe54f16bb9d18daac6e4b06cda0b2" translate="yes" xml:space="preserve">
          <source>Namespaced Validators</source>
          <target state="translated">名前空間バリデータ</target>
        </trans-unit>
        <trans-unit id="be09a63bd1995e99cd22064cdc39a4bae464033d" translate="yes" xml:space="preserve">
          <source>Namespaces</source>
          <target state="translated">Namespaces</target>
        </trans-unit>
        <trans-unit id="6f67c77b8db69b7cbbe81780dca2a3cd93d34c20" translate="yes" xml:space="preserve">
          <source>Namespaces &amp;amp; Modules</source>
          <target state="translated">名前空間とモジュール</target>
        </trans-unit>
        <trans-unit id="9b1e65cb7124596d09d4502bbe02b71fb8a3d882" translate="yes" xml:space="preserve">
          <source>Namespaces and Modules</source>
          <target state="translated">名前空間とモジュール</target>
        </trans-unit>
        <trans-unit id="0b0a6e9c59b25d6d7bd54387d9652cfedae85b49" translate="yes" xml:space="preserve">
          <source>Namespaces are a TypeScript-specific way to organize code.</source>
          <target state="translated">名前空間は、コードを整理するためのTypeScript特有の方法です。</target>
        </trans-unit>
        <trans-unit id="13339d851d51b5c81981062cf249473168c678ea" translate="yes" xml:space="preserve">
          <source>Namespaces are flexible enough to also merge with other types of declarations. To do so, the namespace declaration must follow the declaration it will merge with. The resulting declaration has properties of both declaration types. TypeScript uses this capability to model some of the patterns in JavaScript as well as other programming languages.</source>
          <target state="translated">名前空間は、他のタイプの宣言とのマージも可能な柔軟性を持っています。そのためには、名前空間宣言は、マージする宣言に従わなければなりません。結果として得られる宣言は、両方の宣言タイプのプロパティを持ちます。TypeScript は、JavaScript や他のプログラミング言語と同様に、この機能を使っていくつかのパターンをモデル化しています。</target>
        </trans-unit>
        <trans-unit id="3952a1181de40dbd2a06ce80db7e580384e74ec9" translate="yes" xml:space="preserve">
          <source>Namespaces are important to avoid naming collisions in the global scope. For example, you might have &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; and &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; &amp;mdash; two types with the same name, but a different namespace. This, however, is not an issue with modules. Within a module, there&amp;rsquo;s no plausible reason to have two objects with the same name. From the consumption side, the consumer of any given module gets to pick the name that they will use to refer to the module, so accidental naming conflicts are impossible.</source>
          <target state="translated">名前空間は、グローバルスコープでの名前の衝突を回避するために重要です。たとえば、 &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; と &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; があります。名前は同じですが名前空間が異なる2つのタイプです。ただし、これはモジュールの問題ではありません。モジュール内に、同じ名前の2つのオブジェクトがあるというもっともらしい理由はありません。消費側からは、特定のモジュールの消費者は、モジュールを参照するために使用する名前を選択できるため、誤って名前が競合することはありません。</target>
        </trans-unit>
        <trans-unit id="0fd9b6444054278bf7680e4f8067f50258da5add" translate="yes" xml:space="preserve">
          <source>Namespaces are important to avoid naming collisions in the global scope. For example, you might have &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; and &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; &amp;ndash; two types with the same name, but a different namespace. This, however, is not an issue with modules. Within a module, there&amp;rsquo;s no plausible reason to have two objects with the same name. From the consumption side, the consumer of any given module gets to pick the name that they will use to refer to the module, so accidental naming conflicts are impossible.</source>
          <target state="translated">名前空間は、グローバルスコープでの名前の衝突を回避するために重要です。たとえば、 &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; と &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; &amp;ndash;同じ名前で名前空間が異なる2つのタイプがあるとします。ただし、これはモジュールの問題ではありません。モジュール内で、同じ名前の2つのオブジェクトが存在するもっともらしい理由はありません。消費側から、特定のモジュールのコンシューマーは、モジュールを参照するために使用する名前を選択できるため、誤って名前が競合することはありません。</target>
        </trans-unit>
        <trans-unit id="5e4e7df3860290d042f9971740a7d47d81a9f02b" translate="yes" xml:space="preserve">
          <source>Namespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. They can span multiple files, and can be concatenated using &lt;code&gt;--outFile&lt;/code&gt;. Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags in your HTML page.</source>
          <target state="translated">ネームスペースは、グローバルネームスペース内の単純に名前が付けられたJavaScriptオブジェクトです。これにより、名前空間は非常にシンプルな構造になります。それらは複数のファイルにまたがることができ、-- &lt;code&gt;--outFile&lt;/code&gt; を使用して連結することができます。名前空間は、すべての依存関係をHTMLページの &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグとして含めて、Webアプリケーションでコードを構造化するための良い方法です。</target>
        </trans-unit>
        <trans-unit id="558fb2926bc952cf7a6b78aa83d90ef0f04f4eb8" translate="yes" xml:space="preserve">
          <source>Namespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. Unlike modules, they can span multiple files, and can be concatenated using &lt;code&gt;--outFile&lt;/code&gt;. Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags in your HTML page.</source>
          <target state="translated">名前空間は、グローバル名前空間内のJavaScriptオブジェクトという名前です。これにより、名前空間は非常に簡単に使用できるようになります。モジュールとは異なり、複数のファイルにまたがることができ、 &lt;code&gt;--outFile&lt;/code&gt; を使用して連結できます。名前空間は、すべての依存関係をHTMLページの &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグとして含めて、Webアプリケーションでコードを構造化するための優れた方法です。</target>
        </trans-unit>
        <trans-unit id="abfc41609e10694546f23e6fe8ec31d3b441731d" translate="yes" xml:space="preserve">
          <source>Namespaces in Module Code</source>
          <target state="translated">モジュールコードの名前空間</target>
        </trans-unit>
        <trans-unit id="362b423baafd1e7b201b94eb4694146a945d2f27" translate="yes" xml:space="preserve">
          <source>Namespacing</source>
          <target state="translated">Namespacing</target>
        </trans-unit>
        <trans-unit id="8ecb67c30433187282f082e25e52e62490e245cc" translate="yes" xml:space="preserve">
          <source>Narrowing</source>
          <target state="translated">Narrowing</target>
        </trans-unit>
        <trans-unit id="166846adfb9918dc66f0055635e2541ff9496d41" translate="yes" xml:space="preserve">
          <source>Native ECMAScript 2015 modules SimpleModule.js</source>
          <target state="translated">ネイティブECMAScript 2015モジュール SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="fe8c21145c9261ff78e4961a2b85ef9086d1cb41" translate="yes" xml:space="preserve">
          <source>Needless Namespacing</source>
          <target state="translated">不要な名前のスペーシング</target>
        </trans-unit>
        <trans-unit id="e41b56abbcfdf8901dfab715d721b400cec7b1fc" translate="yes" xml:space="preserve">
          <source>Neither module augmentations nor global augmentations can add new items to the top level scope - they can only &amp;ldquo;patch&amp;rdquo; existing declarations.</source>
          <target state="translated">モジュール拡張もグローバル拡張も、最上位のスコープに新しいアイテムを追加することはできません。既存の宣言に「パッチ」することしかできません。</target>
        </trans-unit>
        <trans-unit id="e6bef57bae5c0e8838a79a353fc36602b74e1fc1" translate="yes" xml:space="preserve">
          <source>Nested and merged declarations</source>
          <target state="translated">入れ子になった宣言とマージされた宣言</target>
        </trans-unit>
        <trans-unit id="4d4cd8fe398e6e096cb8030f584f4c402cf52fc5" translate="yes" xml:space="preserve">
          <source>Nesting works to any level now, and merges correctly across files. Previously neither was the case.</source>
          <target state="translated">ネスティングはどのレベルでも動作し、ファイル間で正しくマージされるようになりました。以前はどちらもありませんでした。</target>
        </trans-unit>
        <trans-unit id="80c3052d33ccdee15ffaaa110c5c39072495fe63" translate="yes" xml:space="preserve">
          <source>Never</source>
          <target state="translated">Never</target>
        </trans-unit>
        <trans-unit id="1acaa361d7e585d276debdfd60f55c71408418be" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--alwaysStrict&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;--alwaysStrict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ac644d9fe3dbb3ac2dccc6d1b53a6bed2b697fc" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--declarationDir&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;--declarationDir&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="720d98b2f44f4640d6cfec4c055ef03a55e5d548" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--declarationMap&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;--declarationMap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b89c753438c197bdc13cb6ed610b532eff5723f" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--downlevelIteration&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;--downlevelIteration&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a00d32452ace95eaef3db016e18a1198fbb4791b" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--emitDeclarationOnly&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;--emitDeclarationOnly&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8227c234e0daa0aaa18b885af7157a89a55e5b26" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--resolveJsonModule&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;--resolveJsonModule&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="805477b1e825abe5eda721395ad4816c0fd064db" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--skipLibCheck&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;--skipLibCheck&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fcbfed49c3a6bd382d5f91b01c13c2352408ca8e" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--strict&lt;/code&gt; master option</source>
          <target state="translated">新しい &lt;code&gt;--strict&lt;/code&gt; マスターオプション</target>
        </trans-unit>
        <trans-unit id="d911d8e68bbe08754a7470249f09d0d73ac4db62" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;.tsx&lt;/code&gt; file extension and &lt;code&gt;as&lt;/code&gt; operator</source>
          <target state="translated">新しい &lt;code&gt;.tsx&lt;/code&gt; ファイル拡張子および演算子 &lt;code&gt;as&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84261bdb966ed15a62fb8f6e8d19c7f9f2c38198" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;jsx: react-native&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;jsx: react-native&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1306ec7c0fb90964d3f3b400158133f1b7d16572" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;unknown&lt;/code&gt; top type</source>
          <target state="translated">新しい &lt;code&gt;unknown&lt;/code&gt; トップタイプ</target>
        </trans-unit>
        <trans-unit id="3249cca6099abd4cca11ff2add4d8cce20a25fa1" translate="yes" xml:space="preserve">
          <source>New Line - &lt;code&gt;newLine&lt;/code&gt;</source>
          <target state="translated">ニューライン- &lt;code&gt;newLine&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70bbb8ec99677d5bef2d3951d16be6268f24f3eb" translate="yes" xml:space="preserve">
          <source>New TypeScript Playground</source>
          <target state="translated">新しいTypeScriptの遊び場</target>
        </trans-unit>
        <trans-unit id="6de3d5b36312b21832416e8730475cc96c42db45" translate="yes" xml:space="preserve">
          <source>New checks added to TypeScript are often off by default to avoid breaking existing projects. While avoiding breakage is a good thing, this strategy has the drawback of making it increasingly complex to choose the highest level of type safety, and doing so requires explicit opt-in action on every TypeScript release. With the &lt;code&gt;--strict&lt;/code&gt; option it becomes possible to choose maximum type safety with the understanding that additional errors might be reported by newer versions of the compiler as improved type checking features are added.</source>
          <target state="translated">TypeScriptに追加された新しいチェックは、既存のプロジェクトを壊さないように、デフォルトでオフになっていることがよくあります。破損を回避することは良いことですが、この戦略には、最高レベルのタイプセーフティを選択することがますます複雑になるという欠点があり、そのためにはすべてのTypeScriptリリースで明示的なオプトインアクションが必要です。 &lt;code&gt;--strict&lt;/code&gt; オプションには、改善型チェック機能が追加された追加のエラーは、コンパイラの新しいバージョンによって報告されるかもしれないことを理解した上で、最大型の安全性を選択することが可能となります。</target>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">次のステップ</target>
        </trans-unit>
        <trans-unit id="7ba10c954271506a3bcae23fd68b8232b3e4e8de" translate="yes" xml:space="preserve">
          <source>Next we have an example of how to override the constructor.</source>
          <target state="translated">次に、コンストラクタをオーバーライドする例を示します。</target>
        </trans-unit>
        <trans-unit id="b330ca07a7da236f37925657529d467d0a58f857" translate="yes" xml:space="preserve">
          <source>Next we will add a new folder and call it &lt;code&gt;scripts&lt;/code&gt;.</source>
          <target state="translated">次に、新しいフォルダを追加して、 &lt;code&gt;scripts&lt;/code&gt; と呼びます。</target>
        </trans-unit>
        <trans-unit id="b62c3108bc37dfcdf96234518498c091954b4711" translate="yes" xml:space="preserve">
          <source>Next, for each type variable introduced by an &lt;code&gt;infer&lt;/code&gt; (more later) declaration within &lt;code&gt;U&lt;/code&gt; collect a set of candidate types by inferring from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;U&lt;/code&gt; (using the same inference algorithm as type inference for generic functions). For a given &lt;code&gt;infer&lt;/code&gt; type variable &lt;code&gt;V&lt;/code&gt;, if any candidates were inferred from co-variant positions, the type inferred for &lt;code&gt;V&lt;/code&gt; is a union of those candidates. Otherwise, if any candidates were inferred from contra-variant positions, the type inferred for &lt;code&gt;V&lt;/code&gt; is an intersection of those candidates. Otherwise, the type inferred for &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">次に、 &lt;code&gt;U&lt;/code&gt; 内の &lt;code&gt;infer&lt;/code&gt; （後で説明）宣言によって導入された各型変数について、 &lt;code&gt;T&lt;/code&gt; から &lt;code&gt;U&lt;/code&gt; に推論することによって候補型のセットを収集します（ジェネリック関数の型推論と同じ推論アルゴリズムを使用）。特定の &lt;code&gt;infer&lt;/code&gt; 型変数 &lt;code&gt;V&lt;/code&gt; について、共変位置から推定された候補がある場合、 &lt;code&gt;V&lt;/code&gt; に対して推定された型はそれらの候補の和集合です。それ以外の場合、候補が反変位置から推論された場合、 &lt;code&gt;V&lt;/code&gt; に対して推論される型はそれらの候補の共通部分です。それ以外の場合、 &lt;code&gt;V&lt;/code&gt; に対して推論される型はにはなり &lt;code&gt;never&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="149d602ff05c96e06423dc39ea5d234017f2a784" translate="yes" xml:space="preserve">
          <source>Next, if your version of Visual Studio does not already have the latest TypeScript, you can &lt;a href=&quot;https://www.typescriptlang.org/index.html#download-links&quot;&gt;install it&lt;/a&gt;.</source>
          <target state="translated">次に、お使いのVisual Studioのバージョンにまだ最新のTypeScriptがない場合は、それを&lt;a href=&quot;https://www.typescriptlang.org/index.html#download-links&quot;&gt;インストール&lt;/a&gt;できます。</target>
        </trans-unit>
        <trans-unit id="074954ffe368a9f868383848acfd3ad865a34cf0" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s create an &lt;code&gt;index.tsx&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt; with the following source:</source>
          <target state="translated">次に、次のソースを &lt;code&gt;index.tsx&lt;/code&gt; して &lt;code&gt;src&lt;/code&gt; にindex.tsxを作成します。</target>
        </trans-unit>
        <trans-unit id="56492bdb624437d084cf97ce29f5755c9355f32f" translate="yes" xml:space="preserve">
          <source>Next, we then use the class directly. Here we create a new variable called &lt;code&gt;greeterMaker&lt;/code&gt;. This variable will hold the class itself, or said another way its constructor function. Here we use &lt;code&gt;typeof Greeter&lt;/code&gt;, that is &amp;ldquo;give me the type of the &lt;code&gt;Greeter&lt;/code&gt; class itself&amp;rdquo; rather than the instance type. Or, more precisely, &amp;ldquo;give me the type of the symbol called &lt;code&gt;Greeter&lt;/code&gt;,&amp;rdquo; which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the &lt;code&gt;Greeter&lt;/code&gt; class. We show this by using &lt;code&gt;new&lt;/code&gt; on &lt;code&gt;greeterMaker&lt;/code&gt;, creating new instances of &lt;code&gt;Greeter&lt;/code&gt; and invoking them as before.</source>
          <target state="translated">次に、クラスを直接使用します。ここでは、 &lt;code&gt;greeterMaker&lt;/code&gt; という新しい変数を作成します。この変数はクラス自体を保持するか、コンストラクター関数の別の言い方をします。ここでは、 &lt;code&gt;typeof Greeter&lt;/code&gt; を使用します。つまり、インスタンスタイプではなく、「 &lt;code&gt;Greeter&lt;/code&gt; クラス自体のタイプを指定」します。または、より正確には、コンストラクター関数のタイプである「 &lt;code&gt;Greeter&lt;/code&gt; と呼ばれるシンボルのタイプを教えてください」。この型には、 &lt;code&gt;Greeter&lt;/code&gt; クラスのインスタンスを作成するコンストラクターとともに、Greeterのすべての静的メンバーが含まれます。 &lt;code&gt;greeterMaker&lt;/code&gt; の &lt;code&gt;new&lt;/code&gt; を使用してこれを示し、 &lt;code&gt;Greeter&lt;/code&gt; の新しいインスタンスを作成します 以前と同じように呼び出します。</target>
        </trans-unit>
        <trans-unit id="d23baf839f3be80e72847391d0e91cd097e57246" translate="yes" xml:space="preserve">
          <source>Next, we then use the class directly. Here we create a new variable called &lt;code&gt;greeterMaker&lt;/code&gt;. This variable will hold the class itself, or said another way its constructor function. Here we use &lt;code&gt;typeof Greeter&lt;/code&gt;, that is &amp;ldquo;give me the type of the &lt;code&gt;Greeter&lt;/code&gt; class itself&amp;rdquo; rather than the instance type. Or, more precisely, &amp;ldquo;give me the type of the symbol called &lt;code&gt;Greeter&lt;/code&gt;,&amp;rdquo; which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the &lt;code&gt;Greeter&lt;/code&gt; class. We show this by using &lt;code&gt;new&lt;/code&gt; on &lt;code&gt;greeterMaker&lt;/code&gt;, creating new instances of &lt;code&gt;Greeter&lt;/code&gt; and invoking them as before. It is also good to mention that changing static property is frowned upon, here &lt;code&gt;greeter3&lt;/code&gt; has &lt;code&gt;&quot;Hey there!&quot;&lt;/code&gt; instead of &lt;code&gt;&quot;Hello, there&quot;&lt;/code&gt; on &lt;code&gt;standardGreeting&lt;/code&gt;.</source>
          <target state="translated">次に、クラスを直接使用します。ここでは、 &lt;code&gt;greeterMaker&lt;/code&gt; という新しい変数を作成します。この変数はクラス自体を保持するか、別の言い方をすればそのコンストラクター関数を保持します。ここでは、インスタンスタイプではなく、「 &lt;code&gt;Greeter&lt;/code&gt; クラス自体のタイプを教えてください」という &lt;code&gt;typeof Greeter&lt;/code&gt; を使用します。または、より正確には、コンストラクター関数の型である「 &lt;code&gt;Greeter&lt;/code&gt; と呼ばれる記号の型を教えてください」。このタイプには、 &lt;code&gt;Greeter&lt;/code&gt; クラスのインスタンスを作成するコンストラクターとともに、Greeterのすべての静的メンバーが含まれます。 &lt;code&gt;greeterMaker&lt;/code&gt; で &lt;code&gt;new&lt;/code&gt; を使用してこれを示し、 &lt;code&gt;Greeter&lt;/code&gt; の新しいインスタンスを作成します以前と同じようにそれらを呼び出します。静的プロパティの変更は嫌われていることにも言及しておくとよいでしょう。ここで &lt;code&gt;greeter3&lt;/code&gt; には &lt;code&gt;&quot;Hey there!&quot;&lt;/code&gt; Heythere ！」があります。代わりに &lt;code&gt;&quot;Hello, there&quot;&lt;/code&gt; 上 &lt;code&gt;standardGreeting&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48fd249b15120ba7e0e8c493ff3db4c13ad95d86" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll add development-time dependencies on the &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ts-loader&lt;/a&gt; and &lt;a href=&quot;https://www.npmjs.com/package/source-map-loader&quot;&gt;source-map-loader&lt;/a&gt;.</source>
          <target state="translated">次に、&lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ts-loader&lt;/a&gt;と&lt;a href=&quot;https://www.npmjs.com/package/source-map-loader&quot;&gt;source-map-loaderに&lt;/a&gt;開発時の依存関係を追加します。</target>
        </trans-unit>
        <trans-unit id="dc79aea4b8183b17aa2b08058010210e82ecc955" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create the class that will handle the combination of the two mixins. Let&amp;rsquo;s look at this in more detail to see how it does this:</source>
          <target state="translated">次に、2つのミックスインの組み合わせを処理するクラスを作成します。これを詳細に見て、それがどのように行われるかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="65015e14839407ce052eab7ebecff46c96ec532e" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ve also added the &lt;code&gt;@readonly&lt;/code&gt; modifier to ensure that a property is only ever written to during initialization.</source>
          <target state="translated">次に、 &lt;code&gt;@readonly&lt;/code&gt; 修飾子も追加して、プロパティが初期化中にのみ書き込まれるようにしました。</target>
        </trans-unit>
        <trans-unit id="3da6f66c39205de12c1b0ea85576f12a60c67429" translate="yes" xml:space="preserve">
          <source>Nightly Builds</source>
          <target state="translated">毎晩のビルド</target>
        </trans-unit>
        <trans-unit id="cb01bbc0b3a89a2f95960449dd66e5b7ab419b0c" translate="yes" xml:space="preserve">
          <source>Nightly Builds: Using NuGet with MSBuild</source>
          <target state="translated">ナイトリービルド。MSBuildでNuGetを使う</target>
        </trans-unit>
        <trans-unit id="269472362c2cb3218dea4a230801c99606e84281" translate="yes" xml:space="preserve">
          <source>Nightly Builds: Using npm</source>
          <target state="translated">ナイトリービルド。npm の使用</target>
        </trans-unit>
        <trans-unit id="d29bc0fc428d8dd325a7aa22de797acf39705506" translate="yes" xml:space="preserve">
          <source>Nightly builds</source>
          <target state="translated">毎晩のビルド</target>
        </trans-unit>
        <trans-unit id="137f56df766041937e987c0af9dc02adfcc4755b" translate="yes" xml:space="preserve">
          <source>No &amp;ldquo;main&amp;rdquo; field</source>
          <target state="translated">「メイン」フィールドはありません</target>
        </trans-unit>
        <trans-unit id="7f2bbc3e501b46e56dd329eeeb31b55fa0b1f266" translate="yes" xml:space="preserve">
          <source>No &amp;ldquo;types&amp;rdquo; field</source>
          <target state="translated">「タイプ」フィールドはありません</target>
        </trans-unit>
        <trans-unit id="947828c2d274f8a21e38e5dd1c59c5dea679fff4" translate="yes" xml:space="preserve">
          <source>No Emit - &lt;code&gt;noEmit&lt;/code&gt;</source>
          <target state="translated">放出なし &lt;code&gt;noEmit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="517bdc2dcead288c404ef1a218dadda3060ef0b5" translate="yes" xml:space="preserve">
          <source>No Emit Helpers - &lt;code&gt;noEmitHelpers&lt;/code&gt;</source>
          <target state="translated">Emitヘルパーなし &lt;code&gt;noEmitHelpers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03f8de53c793590eccee3c9ce2ed4caeb14a5452" translate="yes" xml:space="preserve">
          <source>No Emit On Error - &lt;code&gt;noEmitOnError&lt;/code&gt;</source>
          <target state="translated">エラー時にエミットなし &lt;code&gt;noEmitOnError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b1eb323a13015b5221c0cd99fda83cbd652752c" translate="yes" xml:space="preserve">
          <source>No Error Truncation - &lt;code&gt;noErrorTruncation&lt;/code&gt;</source>
          <target state="translated">エラーの切り捨てなし &lt;code&gt;noErrorTruncation&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8026bb65899345422d9472e2fb88c6be373e8549" translate="yes" xml:space="preserve">
          <source>No Fallthrough Cases In Switch - &lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt;</source>
          <target state="translated">スイッチではありませんFALLTHROUGHケース- &lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d7957143496bc3e4f3d8bec258d34ddbf9a66c00" translate="yes" xml:space="preserve">
          <source>No Implicit &lt;code&gt;any&lt;/code&gt;</source>
          <target state="translated">暗黙の &lt;code&gt;any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a2211d43130f5295a9f394d970fa79e1787ca90" translate="yes" xml:space="preserve">
          <source>No Implicit &lt;code&gt;any&lt;/code&gt; for &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">暗黙のない &lt;code&gt;any&lt;/code&gt; ため &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa3c1c5d879a76450e09d3b73229dae5a7fb02f8" translate="yes" xml:space="preserve">
          <source>No Implicit Any - &lt;code&gt;noImplicitAny&lt;/code&gt;</source>
          <target state="translated">暗黙的なものはありません &lt;code&gt;noImplicitAny&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10c71f4c5d6c858e8b215dbb144dbf6d05414836" translate="yes" xml:space="preserve">
          <source>No Implicit Returns - &lt;code&gt;noImplicitReturns&lt;/code&gt;</source>
          <target state="translated">暗黙のリターンなし &lt;code&gt;noImplicitReturns&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5134182dd86f7b3181089a2100da25c6c0bc7cf4" translate="yes" xml:space="preserve">
          <source>No Implicit This - &lt;code&gt;noImplicitThis&lt;/code&gt;</source>
          <target state="translated">暗黙のこれはありません &lt;code&gt;noImplicitThis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="763fcaff914bd4c20f0951a9a84eab99aa002c2b" translate="yes" xml:space="preserve">
          <source>No Implicit Use Strict - &lt;code&gt;noImplicitUseStrict&lt;/code&gt;</source>
          <target state="translated">暗黙的な使用の厳密さはありません &lt;code&gt;noImplicitUseStrict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00b77ce03e2df58d71af1d4f405d9bf1ac7e9005" translate="yes" xml:space="preserve">
          <source>No Lib - &lt;code&gt;noLib&lt;/code&gt;</source>
          <target state="translated">Libなし &lt;code&gt;noLib&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="592cae7a1118d335c8f2c20593f693616662691c" translate="yes" xml:space="preserve">
          <source>No Resolve - &lt;code&gt;noResolve&lt;/code&gt;</source>
          <target state="translated">解決なし &lt;code&gt;noResolve&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="675ae146fc17269a9c7ab5f87fa461ad1c19cf8e" translate="yes" xml:space="preserve">
          <source>No Strict Generic Checks - &lt;code&gt;noStrictGenericChecks&lt;/code&gt;</source>
          <target state="translated">厳密なジェネリックチェックなし &lt;code&gt;noStrictGenericChecks&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36e5a62628a8609c8c2ea29d4e598862499087d1" translate="yes" xml:space="preserve">
          <source>No Unused Locals - &lt;code&gt;noUnusedLocals&lt;/code&gt;</source>
          <target state="translated">未使用のローカルはありません &lt;code&gt;noUnusedLocals&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="56c92a5c1d34b1db353f920c96e229f154407160" translate="yes" xml:space="preserve">
          <source>No Unused Parameters - &lt;code&gt;noUnusedParameters&lt;/code&gt;</source>
          <target state="translated">未使用のパラメータなし &lt;code&gt;noUnusedParameters&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b9fbfb21cfa0b34035ba18cef71091f735deb52" translate="yes" xml:space="preserve">
          <source>No type is a subtype of or assignable to &lt;code&gt;never&lt;/code&gt; (except &lt;code&gt;never&lt;/code&gt; itself).</source>
          <target state="translated">いいえタイプはへのサブタイプまたはアサインされていない &lt;code&gt;never&lt;/code&gt; （を除いて &lt;code&gt;never&lt;/code&gt; 自分自身）。</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
        <trans-unit id="5c47793ac8ba8a46e72ec2594c5dca3b16c44344" translate="yes" xml:space="preserve">
          <source>Node 10</source>
          <target state="translated">ノード10</target>
        </trans-unit>
        <trans-unit id="1c07c40cb823fe2596e38b4e3bb579fa72706bed" translate="yes" xml:space="preserve">
          <source>Node 12</source>
          <target state="translated">ノード12</target>
        </trans-unit>
        <trans-unit id="1f07679d61eb1484f3fbb7f03c094ced47df3b09" translate="yes" xml:space="preserve">
          <source>Nominal Reified Type Systems</source>
          <target state="translated">名目麗化型システム</target>
        </trans-unit>
        <trans-unit id="05004c27291ee5258d4639719f948e95da6af52b" translate="yes" xml:space="preserve">
          <source>Non-Goals</source>
          <target state="translated">Non-Goals</target>
        </trans-unit>
        <trans-unit id="116d53de6ee6ef67d2d4805314ad0787f638003a" translate="yes" xml:space="preserve">
          <source>Non-Module Files</source>
          <target state="translated">非モジュールファイル</target>
        </trans-unit>
        <trans-unit id="0dc5564786f44ffe5d739e06a70c0a346cb415f8" translate="yes" xml:space="preserve">
          <source>Non-function members of the interfaces should be unique. If they are not unique, they must be of the same type. The compiler will issue an error if the interfaces both declare a non-function member of the same name, but of different types.</source>
          <target state="translated">インターフェースの非関数メンバは一意でなければなりません。固有でない場合は、同じ型でなければなりません。両方のインタフェースが同じ名前の非関数メンバを宣言していても、型が異なる場合、コンパイラはエラーを発行します。</target>
        </trans-unit>
        <trans-unit id="1494b169c26da2fba5af5bb24c5a642f24c6c749" translate="yes" xml:space="preserve">
          <source>Non-generic spread expressions continue to be processed as before: Call and construct signatures are stripped, only non-method properties are preserved, and for properties with the same name, the type of the rightmost property is used. This contrasts with intersection types which concatenate call and construct signatures, preserve all properties, and intersect the types of properties with the same name. Thus, spreads of the same types may produce different results when they are created through instantiation of generic types:</source>
          <target state="translated">非一般的な広がり式は、以前と同様に処理されます。呼び出しシグネチャとコンストラクタシグネチャは削除され、非メソッド・プロパティのみが保存され、同じ名前のプロパティについては、右端のプロパティの型が使用されます。これは、コールシグネチャとコンストラクタシグネチャを連結し、すべてのプロパティを保存し、同じ名前のプロパティの型を交差させる交差型とは対照的です。このように、同じ型のスプレッドは、汎用型のインスタンス化によって作成された場合には、異なる結果をもたらす可能性があります。</target>
        </trans-unit>
        <trans-unit id="3f0cc9ae44503c7a979e12906895cd156851a3f6" translate="yes" xml:space="preserve">
          <source>Non-homomorphic types are essentially creating new properties, so they can&amp;rsquo;t copy property modifiers from anywhere.</source>
          <target state="translated">非同型の型は基本的に新しいプロパティを作成するため、どこからでもプロパティ修飾子をコピーできません。</target>
        </trans-unit>
        <trans-unit id="67964b3d04ccfc686f4aea422e7f8a00b96d652b" translate="yes" xml:space="preserve">
          <source>Non-null and non-undefined type guards</source>
          <target state="translated">非 null および非定義型のガード</target>
        </trans-unit>
        <trans-unit id="6dfb137ece21865c79297ea685dd84ed857ee8cd" translate="yes" xml:space="preserve">
          <source>Non-null and non-undefined type guards may use the &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;===&lt;/code&gt;, or &lt;code&gt;!==&lt;/code&gt; operator to compare to &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, as in &lt;code&gt;x != null&lt;/code&gt; or &lt;code&gt;x === undefined&lt;/code&gt;. The effects on subject variable types accurately reflect JavaScript semantics (e.g. double-equals operators check for both values no matter which one is specified whereas triple-equals only checks for the specified value).</source>
          <target state="translated">非nullおよび非未定義のタイプガードでは、 &lt;code&gt;==&lt;/code&gt; 、 &lt;code&gt;!=&lt;/code&gt; 、 &lt;code&gt;===&lt;/code&gt; 、または &lt;code&gt;!==&lt;/code&gt; 演算子を使用して、 &lt;code&gt;x != null&lt;/code&gt; または &lt;code&gt;x === undefined&lt;/code&gt; ように &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; と比較できます。サブジェクト変数タイプへの影響は、JavaScriptセマンティクスを正確に反映します（たとえば、二重等号演算子はどちらが指定されていても両方の値をチェックしますが、三重等号は指定された値のみをチェックします）。</target>
        </trans-unit>
        <trans-unit id="1429182fce7f9a8560f2257cc03417f636cfd4e4" translate="yes" xml:space="preserve">
          <source>Non-null assertion operator</source>
          <target state="translated">非ヌルアサーション演算子</target>
        </trans-unit>
        <trans-unit id="8c77d1fe01b3d6b896e59e7ad679a030f98eb254" translate="yes" xml:space="preserve">
          <source>Non-nullable types have no meaning and are treated just as their original type:</source>
          <target state="translated">非ヌル化可能な型は意味を持たず、元の型と同じように扱われます。</target>
        </trans-unit>
        <trans-unit id="eac50a4571700d4b796b3f2c2c60e4c14af40f6f" translate="yes" xml:space="preserve">
          <source>Non-unit types as union discriminants</source>
          <target state="translated">組合差別者としての非ユニットタイプ</target>
        </trans-unit>
        <trans-unit id="80660f063a6440a3a7e05a18a3ba076eeaf007e6" translate="yes" xml:space="preserve">
          <source>NonNullable&amp;lt;T&amp;gt;</source>
          <target state="translated">NonNullable&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9e8dd4dc111ded7b2320e89d0f31eaa58c3daeae" translate="yes" xml:space="preserve">
          <source>Normally the compiler will attempt to resolve all module imports before it starts the compilation process. Every time it successfully resolves an &lt;code&gt;import&lt;/code&gt; to a file, the file is added to the set of files the compiler will process later on.</source>
          <target state="translated">通常、コンパイラは、コンパイルプロセスを開始する前に、すべてのモジュールインポートを解決しようとします。ファイルへの &lt;code&gt;import&lt;/code&gt; が正常に解決されるたびに、ファイルはコンパイラが後で処理する一連のファイルに追加されます。</target>
        </trans-unit>
        <trans-unit id="fa102d6a31f636b67a2c1043b2e52c1f1dd3e13e" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;tsc&lt;/code&gt; will produce outputs (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.d.ts&lt;/code&gt;) in the presence of syntax or type errors, unless &lt;code&gt;noEmitOnError&lt;/code&gt; is on. Doing this in an incremental build system would be very bad - if one of your out-of-date dependencies had a new error, you&amp;rsquo;d only see it &lt;em&gt;once&lt;/em&gt; because a subsequent build would skip building the now up-to-date project. For this reason, &lt;code&gt;tsc -b&lt;/code&gt; effectively acts as if &lt;code&gt;noEmitOnError&lt;/code&gt; is enabled for all projects.</source>
          <target state="translated">通常、 &lt;code&gt;tsc&lt;/code&gt; がオンになっていない限り、 &lt;code&gt;noEmitOnError&lt;/code&gt; は構文エラーまたはタイプエラーがある場合に出力（ &lt;code&gt;.js&lt;/code&gt; および &lt;code&gt;.d.ts&lt;/code&gt; ）を生成します。インクリメンタルビルドシステムでこれを行うのは非常に悪いことです。古い依存関係の1つに新しいエラーが発生した場合、その後のビルドでは最新のプロジェクトのビルドがスキップされるため、&lt;em&gt;一度&lt;/em&gt;しか表示されません。このため、 &lt;code&gt;tsc -b&lt;/code&gt; は、すべてのプロジェクトで &lt;code&gt;noEmitOnError&lt;/code&gt; が有効になっているかのように機能します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9fd029d8465bd91c3c7282b62d1066fe73ce0eee" translate="yes" xml:space="preserve">
          <source>Normally, TypeScript would return silently on success.</source>
          <target state="translated">通常、TypeScriptは成功すると無音で返ってきます。</target>
        </trans-unit>
        <trans-unit id="3d901c000076266c2726be52567eee3a9e906da5" translate="yes" xml:space="preserve">
          <source>Not all merges are allowed in TypeScript. Currently, classes can not merge with other classes or with variables. For information on mimicking class merging, see the &lt;a href=&quot;mixins&quot;&gt;Mixins in TypeScript&lt;/a&gt; section.</source>
          <target state="translated">TypeScriptではすべてのマージが許可されるわけではありません。現在、クラスは他のクラスや変数とマージできません。クラスのマージの模倣については&lt;a href=&quot;mixins&quot;&gt;、TypeScriptのMixins&lt;/a&gt;セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="0fecf4145f603258529bada9dcd0bcbc05978112" translate="yes" xml:space="preserve">
          <source>Not all properties of an interface may be required. Some exist under certain conditions or may not be there at all. These optional properties are popular when creating patterns like &amp;ldquo;option bags&amp;rdquo; where you pass an object to a function that only has a couple of properties filled in.</source>
          <target state="translated">インターフェイスのすべてのプロパティが必要なわけではありません。一部は特定の条件下で存在するか、まったく存在しない場合があります。これらのオプションプロパティは、「オプションバッグ」のようなパターンを作成するときによく使用されます。ここでは、いくつかのプロパティのみが入力されている関数にオブジェクトを渡します。</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="4738934001095b56c8ba017549da8753b92711d7" translate="yes" xml:space="preserve">
          <source>Note any tags which are not explicitly listed below (such as &lt;code&gt;@async&lt;/code&gt;) are not yet supported.</source>
          <target state="translated">以下に明示的にリストされていないタグ（ &lt;code&gt;@async&lt;/code&gt; など）はまだサポートされていません。</target>
        </trans-unit>
        <trans-unit id="9f5feea3e404674922df60252466104fa5c5fc9e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@enum&lt;/code&gt; is quite different from, and much simpler than, TypeScript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt;. However, unlike TypeScript&amp;rsquo;s enums, &lt;code&gt;@enum&lt;/code&gt; can have any type:</source>
          <target state="translated">&lt;code&gt;@enum&lt;/code&gt; は、TypeScriptの &lt;code&gt;enum&lt;/code&gt; とはかなり異なり、はるかに単純であることに注意してください。ただし、TypeScriptの列挙型とは異なり、 &lt;code&gt;@enum&lt;/code&gt; enumは任意のタイプを持つことができます。</target>
        </trans-unit>
        <trans-unit id="034f4525d05999ff963000183c0ac076ec562336" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@enum&lt;/code&gt; is quite different from, and much simpler than, Typescript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt;. However, unlike Typescript&amp;rsquo;s enums, &lt;code&gt;@enum&lt;/code&gt; can have any type:</source>
          <target state="translated">&lt;code&gt;@enum&lt;/code&gt; はTypescriptの &lt;code&gt;enum&lt;/code&gt; とはかなり異なり、はるかに単純であることに注意してください。ただし、 &lt;code&gt;@enum&lt;/code&gt; の列挙型とは異なり、@ enum は任意の型を持つことができます。</target>
        </trans-unit>
        <trans-unit id="a50c9eb18039f11d764d2dd9c6139bfa5f2ed615" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@extends&lt;/code&gt; only works with classes. Currently, there is no way for a constructor function extend a class.</source>
          <target state="translated">&lt;code&gt;@extends&lt;/code&gt; はクラスでのみ機能することに注意してください。現在、コンストラクター関数がクラスを拡張する方法はありません。</target>
        </trans-unit>
        <trans-unit id="8a0526a2b13316a828fc44ba4c43a0a7de6c3d55" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; are so useful, they are included in TypeScript&amp;rsquo;s standard library along with &lt;code&gt;Pick&lt;/code&gt; and &lt;code&gt;Record&lt;/code&gt;:</source>
          <target state="translated">なお、 &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; と &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; とても便利です、彼らは一緒に活字体の標準ライブラリに含まれている &lt;code&gt;Pick&lt;/code&gt; と &lt;code&gt;Record&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a8635b5b3c1a94603cc953231075f37144a428de" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;keyof any&lt;/code&gt; represents the type of any value that can be used as an index to an object. In otherwords, &lt;code&gt;keyof any&lt;/code&gt; is currently equal to &lt;code&gt;string | number | symbol&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;keyof any&lt;/code&gt; は、オブジェクトのインデックスとして使用できる任意の値のタイプを表すことに注意してください。 &lt;code&gt;keyof any&lt;/code&gt; 、keyofanyは現在 &lt;code&gt;string | number | symbol&lt;/code&gt; 等しい| 番号| シンボル。</target>
        </trans-unit>
        <trans-unit id="1258e6d6b1a495d8e56ed02d68cc95af53525487" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;y&lt;/code&gt; has an extra &lt;code&gt;location&lt;/code&gt; property, but this does not create an error. Only members of the target type (&lt;code&gt;Named&lt;/code&gt; in this case) are considered when checking for compatibility.</source>
          <target state="translated">なお、 &lt;code&gt;y&lt;/code&gt; は余分に持っている &lt;code&gt;location&lt;/code&gt; プロパティを、これはエラーを作成しません。互換性をチェックするときは、ターゲットタイプ（この場合は &lt;code&gt;Named&lt;/code&gt; ）のメンバーのみが考慮されます。</target>
        </trans-unit>
        <trans-unit id="52de29b3288a647d26453cfca4097defc33488b8" translate="yes" xml:space="preserve">
          <source>Note that TypeScript treats &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; differently in order to match JavaScript semantics. &lt;code&gt;string | null&lt;/code&gt; is a different type than &lt;code&gt;string | undefined&lt;/code&gt; and &lt;code&gt;string | undefined | null&lt;/code&gt;.</source>
          <target state="translated">TypeScriptは、JavaScriptセマンティクスと一致させるために、 &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; を異なる方法で処理することに注意してください。 &lt;code&gt;string | null&lt;/code&gt; は &lt;code&gt;string | undefined&lt;/code&gt; とは異なる型です| 未定義および &lt;code&gt;string | undefined | null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d964565fed797b8fe69da21280237178f8dd90d" translate="yes" xml:space="preserve">
          <source>Note that TypeScript will never write an output file to a directory outside of &lt;code&gt;outDir&lt;/code&gt;, and will never skip emitting a file. For this reason, &lt;code&gt;rootDir&lt;/code&gt; also enforces that all files which need to be emitted are underneath the &lt;code&gt;rootDir&lt;/code&gt; path.</source>
          <target state="translated">TypeScriptが &lt;code&gt;outDir&lt;/code&gt; の外部のディレクトリに出力ファイルを書き込むことはなく、ファイルの発行をスキップすることもないことに注意してください。このため、 &lt;code&gt;rootDir&lt;/code&gt; は、発行する必要のあるすべてのファイルが &lt;code&gt;rootDir&lt;/code&gt; パスの下にあることも強制します。</target>
        </trans-unit>
        <trans-unit id="fad3fa5b17d28ad4ad1296cea04ea7aae98a3e8a" translate="yes" xml:space="preserve">
          <source>Note that as with &lt;code&gt;tsconfig.json&lt;/code&gt; / &lt;code&gt;-p&lt;/code&gt;, existing TypeScript project properties will not be respected - all settings should be managed using your tsconfig file.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; / &lt;code&gt;-p&lt;/code&gt; と同様に、既存のTypeScriptプロジェクトプロパティは尊重されないことに注意してください。すべての設定は、tsconfigファイルを使用して管理する必要があります。</target>
        </trans-unit>
        <trans-unit id="49f454e4294f1faa6bdcf0d5b1903082b8d7d4af" translate="yes" xml:space="preserve">
          <source>Note that calling a method on a numeric literal requires it to be in parentheses to aid the parser.</source>
          <target state="translated">数値リテラルでメソッドを呼び出す場合は、パーサを助けるために括弧で囲む必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="af06da8b751f486668f66523aec780426d9aaf88" translate="yes" xml:space="preserve">
          <source>Note that functions and arrays are objects at runtime, but have their own predicates.</source>
          <target state="translated">関数と配列は実行時にはオブジェクトですが、独自の述語を持っていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b588c9ab272861e6d668b1d11af54118f839ddd3" translate="yes" xml:space="preserve">
          <source>Note that global variables declared with &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; don&amp;rsquo;t show up on &lt;code&gt;globalThis&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; および &lt;code&gt;const&lt;/code&gt; で宣言されたグローバル変数は &lt;code&gt;globalThis&lt;/code&gt; に表示されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f628326a2f77697a922d2fe82dda47c7b50dda0f" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;bar&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, our code will still hit an error accessing &lt;code&gt;baz&lt;/code&gt;. Likewise, if &lt;code&gt;baz&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, we&amp;rsquo;ll hit an error at the call site. &lt;code&gt;?.&lt;/code&gt; only checks for whether the value on the &lt;em&gt;left&lt;/em&gt; of it is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; - not any of the subsequent properties.</source>
          <target state="translated">&lt;code&gt;bar&lt;/code&gt; が &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; 場合でも、コードは &lt;code&gt;baz&lt;/code&gt; へのアクセスでエラーを発生することに注意してください。同様に、 &lt;code&gt;baz&lt;/code&gt; が &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; の場合、呼び出しサイトでエラーが発生します。 &lt;code&gt;?.&lt;/code&gt; &lt;em&gt;左側&lt;/em&gt;の値が &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; であるかどうかのみをチェックします。後続のプロパティはチェックしません。</target>
        </trans-unit>
        <trans-unit id="9bc1e2dc91d339a1731d988771c4e0964ee425ef" translate="yes" xml:space="preserve">
          <source>Note that in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, when a homomorphic mapped type removes a &lt;code&gt;?&lt;/code&gt; modifier from a property in the underlying type it also removes &lt;code&gt;undefined&lt;/code&gt; from the type of that property:</source>
          <target state="translated">中にいることを注意 &lt;code&gt;--strictNullChecks&lt;/code&gt; モード、準同型マッピングされたタイプが削除されますか &lt;code&gt;?&lt;/code&gt; 基になる型のプロパティの修飾子は、そのプロパティの型から &lt;code&gt;undefined&lt;/code&gt; も削除します。</target>
        </trans-unit>
        <trans-unit id="eea4e2c81bc66e020338b949c3e934f29a66e808" translate="yes" xml:space="preserve">
          <source>Note that in TypeScript 1.4, when accessing an element outside the set of known indices, a union type is used instead:</source>
          <target state="translated">TypeScript 1.4では、既知のインデックスの集合外の要素にアクセスする場合、代わりにユニオン型が使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="739942391df257a53a10ec2f75e3c9725103c615" translate="yes" xml:space="preserve">
          <source>Note that in this example, we added a value to the &lt;em&gt;static&lt;/em&gt; side of &lt;code&gt;C&lt;/code&gt; (its constructor function). This is because we added a &lt;em&gt;value&lt;/em&gt;, and the container for all values is another value (types are contained by namespaces, and namespaces are contained by other namespaces).</source>
          <target state="translated">この例では、 &lt;code&gt;C&lt;/code&gt; （そのコンストラクター関数）の&lt;em&gt;静的&lt;/em&gt;側に値を追加したことに注意してください。これは、&lt;em&gt;値&lt;/em&gt;を追加し、すべての値のコンテナーが別の値であるためです（型は名前空間に含まれ、名前空間は他の名前空間に含まれます）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4521e5d9ffa1f2a7a2398a1ba71b06034b84ba66" translate="yes" xml:space="preserve">
          <source>Note that inference will work in any order, but intellisense will only work left-to-right, so TypeScript prefers to declare &lt;code&gt;map&lt;/code&gt; with the array first:</source>
          <target state="translated">推論は任意の順序で機能しますが、インテリセンスは左から右にしか機能しないため、TypeScriptは最初に配列を使用して &lt;code&gt;map&lt;/code&gt; を宣言することを好みます。</target>
        </trans-unit>
        <trans-unit id="d0af180e34bef9f30805628b530dfa3020972dea" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s possible to define many types in the global scope when writing a global declaration file. We strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project.</source>
          <target state="translated">グローバル宣言ファイルを作成するときに、グローバルスコープで多くの型を定義できることに注意してください。多くの宣言ファイルがプロジェクト内にある場合、解決できない名前の競合が発生する可能性があるため、これはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="907347b9fd2f8faa12df54e188fdcc427177ea81" translate="yes" xml:space="preserve">
          <source>Note that parentheses are optional for union types.</source>
          <target state="translated">括弧はユニオン型の場合はオプションであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4fabbe755152dc7983d25e5f9f36d98457b37c5e" translate="yes" xml:space="preserve">
          <source>Note that partial overlap is still permitted as long as the property types are valid.</source>
          <target state="translated">プロパティ・タイプが有効である限り、部分的なオーバーラップは許可されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="cc68887371a320bc99d4047b11fa95c7b5bed915" translate="yes" xml:space="preserve">
          <source>Note that relative module imports are not impacted by setting the baseUrl, as they are always resolved relative to their importing files.</source>
          <target state="translated">相対的なモジュールのインポートは、常にインポート先のファイルから相対的に解決されるため、baseUrlを設定しても影響を受けないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="7f7166fe564b0ad642ff41fe82fc874132e2ab74" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&quot;typings&quot;&lt;/code&gt; field is synonymous with &lt;code&gt;&quot;types&quot;&lt;/code&gt;, and could be used as well.</source>
          <target state="translated">ことを注意 &lt;code&gt;&quot;typings&quot;&lt;/code&gt; フィールドはと同義である &lt;code&gt;&quot;types&quot;&lt;/code&gt; 、および同様に使用することができます。</target>
        </trans-unit>
        <trans-unit id="4b2efe58a5ebfdb3d94ff74e3c4e2bfaf07628f5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;function pickCard(x): any&lt;/code&gt; piece is not part of the overload list, so it only has two overloads: one that takes an object and one that takes a number. Calling &lt;code&gt;pickCard&lt;/code&gt; with any other parameter types would cause an error.</source>
          <target state="translated">なお、 &lt;code&gt;function pickCard(x): any&lt;/code&gt; オブジェクトを取り一方と数をとる1：それは2つだけのオーバーロードを有するように片が、過負荷リストの一部ではありません。他のパラメータタイプで &lt;code&gt;pickCard&lt;/code&gt; を呼び出すと、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="8e52a12186dadc57595c17ea6c93216559c79848" translate="yes" xml:space="preserve">
          <source>Note that the return type of &lt;code&gt;area&lt;/code&gt; is inferred to be &lt;code&gt;number&lt;/code&gt; because TypeScript knows the function is total. If some variant is not covered, the return type of &lt;code&gt;area&lt;/code&gt; will be &lt;code&gt;number | undefined&lt;/code&gt; instead.</source>
          <target state="translated">TypeScriptは関数が合計であることを認識しているため、戻り値の型の &lt;code&gt;area&lt;/code&gt; は &lt;code&gt;number&lt;/code&gt; あると推測されることに注意してください。一部のバリアントがカバーされていない場合、 &lt;code&gt;area&lt;/code&gt; の戻り値の型は &lt;code&gt;number | undefined&lt;/code&gt; なります。代わりに未定義。</target>
        </trans-unit>
        <trans-unit id="d805d68393f371b58b5632620fd80bca6ffff116" translate="yes" xml:space="preserve">
          <source>Note that this collapsing should only occur when all overloads have the same return type.</source>
          <target state="translated">この崩れは、すべてのオーバーロードが同じ戻り値型を持っている場合にのみ発生することに注意してください。</target>
        </trans-unit>
        <trans-unit id="067bba3132c520df5de825dbb6713533d577f153" translate="yes" xml:space="preserve">
          <source>Note that this does not imply tuples represent immutable arrays, but it is an implied convention.</source>
          <target state="translated">これはタプルが不変配列を表すことを暗示しているわけではなく、暗黙の慣習であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="00c87ccc96ac44dfdeaad5b5ee7925bc2c9a2141" translate="yes" xml:space="preserve">
          <source>Note that this is a breaking change for some code. If you need to resort to the original behavior in which tuples only enforce a minimum length, you can use a similar declaration that does not explicitly define a &lt;code&gt;length&lt;/code&gt; property, falling back to &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">これは一部のコードの重大な変更であることに注意してください。タプルが最小長のみを強制するという元の動作に頼る必要がある場合は、 &lt;code&gt;length&lt;/code&gt; プロパティを明示的に定義しない同様の宣言を使用して、 &lt;code&gt;number&lt;/code&gt; にフォールバックできます。</target>
        </trans-unit>
        <trans-unit id="2da7ac7b1000043c557ae42f5143ae70cebcc452" translate="yes" xml:space="preserve">
          <source>Note that this syntax describes a type rather than a member. If you want to add members, you can use an intersection type:</source>
          <target state="translated">この構文は、メンバーではなく型を記述していることに注意してください。メンバを追加したい場合は、インターセクション型を使用します。</target>
        </trans-unit>
        <trans-unit id="24ee265701152c1f723e8f2dfcc2a5432fb8e8f0" translate="yes" xml:space="preserve">
          <source>Note that this unwrapping inference only works on homomorphic mapped types. If the mapped type is not homomorphic you&amp;rsquo;ll have to give an explicit type parameter to your unwrapping function.</source>
          <target state="translated">このアンラップの推論は、準同型のマップされた型でのみ機能することに注意してください。マップされた型が準同型でない場合は、ラップ解除関数に明示的な型パラメーターを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="ca498eaf7012359010349b6f8e9e80f634eacb51" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;export default&lt;/code&gt; in your .d.ts files requires &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#esModuleInterop&quot;&gt;&lt;code&gt;esModuleInterop: true&lt;/code&gt;&lt;/a&gt; to work. If you can&amp;rsquo;t have &lt;code&gt;esModuleInterop: true&lt;/code&gt; in your project, such as when you&amp;rsquo;re submitting a PR to Definitely Typed, you&amp;rsquo;ll have to use the &lt;code&gt;export=&lt;/code&gt; syntax instead. This older syntax is harder to use but works everywhere. Here&amp;rsquo;s how the above example would have to be written using &lt;code&gt;export=&lt;/code&gt;:</source>
          <target state="translated">使用していることを注意 &lt;code&gt;export default&lt;/code&gt; ご.d.tsファイルにする必要があり&lt;a href=&quot;https://www.typescriptlang.org/tsconfig#esModuleInterop&quot;&gt; &lt;code&gt;esModuleInterop: true&lt;/code&gt; &lt;/a&gt;仕事に。プロジェクトで &lt;code&gt;esModuleInterop: true&lt;/code&gt; を設定できない場合（Definitely TypeedにPRを送信する場合など）、代わりに &lt;code&gt;export=&lt;/code&gt; 構文を使用する必要があります。この古い構文は使いにくいですが、どこでも機能します。上記の例は、 &lt;code&gt;export=&lt;/code&gt; ：を使用して作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="eead77930da9ed7756b7450464191e29579bb786" translate="yes" xml:space="preserve">
          <source>Note that we cannot add to type aliases (&lt;code&gt;type s = string;&lt;/code&gt;) using an interface.</source>
          <target state="translated">インターフェイスを使用してタイプエイリアス（ &lt;code&gt;type s = string;&lt;/code&gt; ）を追加することはできません。</target>
        </trans-unit>
        <trans-unit id="a04a128b4126a71144c52f15a922d0f362febded" translate="yes" xml:space="preserve">
          <source>Note that we currently only support discriminant properties of string literal types. We intend to later add support for boolean and numeric literal types.</source>
          <target state="translated">現在のところ、文字列リテラル型の判別プロパティのみをサポートしていることに注意してください。将来的には、ブーリアン型と数値リテラル型のサポートを追加する予定です。</target>
        </trans-unit>
        <trans-unit id="8866bd22d60ec16a512c3e18fc8883ee9088f218" translate="yes" xml:space="preserve">
          <source>Note that we didn&amp;rsquo;t make &lt;code&gt;b&lt;/code&gt; optional here because the return types of the signatures differ.</source>
          <target state="translated">シグネチャの戻り値の型が異なるため、ここでは &lt;code&gt;b&lt;/code&gt; をオプションにしていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="94ec1d6aab212f5e757f0e4659331e046f79564c" translate="yes" xml:space="preserve">
          <source>Note that when a tuple type is inferred from a sequence of parameters and later expanded into a parameter list, as is the case for &lt;code&gt;U&lt;/code&gt;, the original parameter names are used in the expansion (however, the names have no semantic meaning and are not otherwise observable).</source>
          <target state="translated">タプル型がパラメーターのシーケンスから推測され、後でパラメーターリストに展開される場合、 &lt;code&gt;U&lt;/code&gt; の場合と同様に、元のパラメーター名が展開で使用されます（ただし、名前には意味的な意味がなく、それ以外の場合はありません）観測可能）。</target>
        </trans-unit>
        <trans-unit id="71b62ae2aa2aff8c7c71bbad8ff17968c2580e86" translate="yes" xml:space="preserve">
          <source>Note that when using these flags together, TypeScript doesn&amp;rsquo;t necessarily have to downlevel &lt;code&gt;.js&lt;/code&gt; files. If you simply want TypeScript to create &lt;code&gt;.d.ts&lt;/code&gt; files, you can use the &lt;code&gt;--emitDeclarationOnly&lt;/code&gt; compiler option.</source>
          <target state="translated">これらのフラグを一緒に使用する場合、TypeScriptは必ずしも &lt;code&gt;.js&lt;/code&gt; ファイルをダウンレベルにする必要がないことに注意してください。TypeScriptで &lt;code&gt;.d.ts&lt;/code&gt; ファイルを作成するだけの場合は、 &lt;code&gt;--emitDeclarationOnly&lt;/code&gt; コンパイラオプションを使用できます。</target>
        </trans-unit>
        <trans-unit id="d88437440fe56ffd946a572ef7fc0f549aafede2" translate="yes" xml:space="preserve">
          <source>Note that while this example uses &lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;function components&lt;/a&gt;, we could also make our example a little &lt;em&gt;classier&lt;/em&gt; as well.</source>
          <target state="translated">この例では&lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;関数コンポーネントを&lt;/a&gt;使用していますが、この例を少し&lt;em&gt;上品に&lt;/em&gt;することもできます。</target>
        </trans-unit>
        <trans-unit id="f4126eba79591c06a88ec80a2218d901b6a7fced" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; targets latest supported</source>
          <target state="translated">注： &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; は最新のサポート対象をターゲットにしています</target>
        </trans-unit>
        <trans-unit id="00f6312a7e060d93f44452f049fdc1698e20c055" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; targets latest supported &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES proposed features&lt;/a&gt;.</source>
          <target state="translated">注： &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; は、サポート&lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;されている&lt;/a&gt;最新のES提案機能を対象としています。</target>
        </trans-unit>
        <trans-unit id="9d7cb6b652ecb3fc440c1897098d4132f67f5630" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;node&lt;/code&gt; module resolution is the most-commonly used in the TypeScript community and is recommended for most projects. If you are having resolution problems with &lt;code&gt;import&lt;/code&gt;s and &lt;code&gt;export&lt;/code&gt;s in TypeScript, try setting &lt;code&gt;moduleResolution: &quot;node&quot;&lt;/code&gt; to see if it fixes the issue.</source>
          <target state="translated">注： &lt;code&gt;node&lt;/code&gt; モジュールの解決は、TypeScriptコミュニティで最も一般的に使用されており、ほとんどのプロジェクトで推奨されています。TypeScriptでの &lt;code&gt;import&lt;/code&gt; と &lt;code&gt;export&lt;/code&gt; 解決の問題が発生している場合は、 &lt;code&gt;moduleResolution: &quot;node&quot;&lt;/code&gt; を設定して、問題が解決するかどうかを確認してください。</target>
        </trans-unit>
        <trans-unit id="b385aa9974c78d1114e7d19ac34ae3cecb189cbb" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;outFile&lt;/code&gt; cannot be used unless &lt;code&gt;module&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;System&lt;/code&gt;, or &lt;code&gt;AMD&lt;/code&gt;. This option &lt;em&gt;cannot&lt;/em&gt; be used to bundle CommonJS or ES6 modules.</source>
          <target state="translated">注： &lt;code&gt;module&lt;/code&gt; が &lt;code&gt;None&lt;/code&gt; 、 &lt;code&gt;System&lt;/code&gt; 、または &lt;code&gt;AMD&lt;/code&gt; でない限り、 &lt;code&gt;outFile&lt;/code&gt; は使用できません。このオプション&lt;em&gt;を&lt;/em&gt;使用して、CommonJSまたはES6モジュールをバンドルする&lt;em&gt;ことはできません&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eff587a71ddbf90b7c884baa1aa1a82827ace5dd" translate="yes" xml:space="preserve">
          <source>Note: Avoid using &lt;code&gt;Object&lt;/code&gt; in favor of the non-primitive &lt;code&gt;object&lt;/code&gt; type as described in our &lt;a href=&quot;declaration-files/do-s-and-don-ts#general-types&quot;&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt; section.</source>
          <target state="translated">注：「&lt;a href=&quot;declaration-files/do-s-and-don-ts#general-types&quot;&gt;すべきこととすべきでないこと」の&lt;/a&gt;セクションで説明されているように、プリミティブでない &lt;code&gt;object&lt;/code&gt; タイプを優先して &lt;code&gt;Object&lt;/code&gt; を使用しないでください。</target>
        </trans-unit>
        <trans-unit id="93a51f16eac9cd871496fa3f38f5e48ecd5fea51" translate="yes" xml:space="preserve">
          <source>Note: Error messages only show up in JS codebases with &lt;a href=&quot;tsconfig-json&quot;&gt;a JSConfig&lt;/a&gt; and &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#checkJs&quot;&gt;&lt;code&gt;checkJs&lt;/code&gt;&lt;/a&gt; enabled.</source>
          <target state="translated">注：エラーメッセージは&lt;a href=&quot;tsconfig-json&quot;&gt;、JSConfig&lt;/a&gt;と&lt;a href=&quot;https://www.typescriptlang.org/tsconfig#checkJs&quot;&gt; &lt;code&gt;checkJs&lt;/code&gt; が&lt;/a&gt;有効になっているJSコードベースにのみ表示されます。</target>
        </trans-unit>
        <trans-unit id="c1444747b0861651e319b205e1c59d9ae374ba31" translate="yes" xml:space="preserve">
          <source>Note: Function Components were formerly known as Stateless Function Components (SFC). As Function Components can no longer be considered stateless in recent versions of react, the type &lt;code&gt;SFC&lt;/code&gt; and its alias &lt;code&gt;StatelessComponent&lt;/code&gt; were deprecated.</source>
          <target state="translated">注：関数コンポーネントは、以前はステートレス関数コンポーネント（SFC）と呼ばれていました。関数コンポーネントは、最近のバージョンのreactではステートレスと見なされなくなったため、タイプ &lt;code&gt;SFC&lt;/code&gt; とそのエイリアスである &lt;code&gt;StatelessComponent&lt;/code&gt; は非推奨になりました。</target>
        </trans-unit>
        <trans-unit id="2167c13fca90fe94989b38585bc930d77ebf1308" translate="yes" xml:space="preserve">
          <source>Note: If &lt;code&gt;--lib&lt;/code&gt; is not specified a default list of libraries are injected. The default libraries injected are:</source>
          <target state="translated">注：-- &lt;code&gt;--lib&lt;/code&gt; が指定されていない場合、デフォルトのライブラリリストが挿入されます。注入されるデフォルトのライブラリは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="284acafdfa85eadac42feff0fa8aca15b6a97293" translate="yes" xml:space="preserve">
          <source>Note: If an attribute name is not a valid JS identifier (like a &lt;code&gt;data-*&lt;/code&gt; attribute), it is not considered to be an error if it is not found in the element attributes type.</source>
          <target state="translated">注：属性名が有効なJS識別子ではない場合（ &lt;code&gt;data-*&lt;/code&gt; 属性など）、要素の属性タイプに見つからない場合、エラーとは見なされません。</target>
        </trans-unit>
        <trans-unit id="019f04b9d1d907c729221ba8c0d3f15ea3b9e489" translate="yes" xml:space="preserve">
          <source>Note: In &lt;em&gt;very&lt;/em&gt; old versions of TypeScript namespaces were called &amp;lsquo;Internal Modules&amp;rsquo;, these pre-date JavaScript module systems.</source>
          <target state="translated">注：TypeScript名前空間の&lt;em&gt;非常に&lt;/em&gt;古いバージョンでは、「内部モジュール」と呼ばれていました。これらは、JavaScriptモジュールシステムよりも前のものです。</target>
        </trans-unit>
        <trans-unit id="e941b79a012efff59ecdd0cbaa4fcd9aa032b565" translate="yes" xml:space="preserve">
          <source>Note: Most changes do not require you to install a new version of the VS TypeScript plugin.</source>
          <target state="translated">注:ほとんどの変更は、VS TypeScript プラグインの新しいバージョンをインストールする必要はありません。</target>
        </trans-unit>
        <trans-unit id="70970313d46e20ac27b9140a27eba7644c3d73af" translate="yes" xml:space="preserve">
          <source>Note: Previous syntax defining internal modules are still supported.</source>
          <target state="translated">注意:内部モジュールを定義する以前の構文はまだサポートされています。</target>
        </trans-unit>
        <trans-unit id="98d80fe98cbbdfa6ce68828aed81191aecaa3aa8" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;Exclude&lt;/code&gt; type is a proper implementation of the &lt;code&gt;Diff&lt;/code&gt; type suggested &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;here&lt;/a&gt;. We&amp;rsquo;ve used the name &lt;code&gt;Exclude&lt;/code&gt; to avoid breaking existing code that defines a &lt;code&gt;Diff&lt;/code&gt;, plus we feel that name better conveys the semantics of the type.</source>
          <target state="translated">注： &lt;code&gt;Exclude&lt;/code&gt; タイプは、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;ここで&lt;/a&gt;提案されている &lt;code&gt;Diff&lt;/code&gt; タイプの適切な実装です。 &lt;code&gt;Diff&lt;/code&gt; を定義する既存のコードを壊さないようにするために &lt;code&gt;Exclude&lt;/code&gt; という名前を使用しました。さらに、この名前は型のセマンティクスをよりよく伝えると感じています。</target>
        </trans-unit>
        <trans-unit id="3b301e8bc42764dd4dd4644d5e8e453ac7e989ae" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;Exclude&lt;/code&gt; type is a proper implementation of the &lt;code&gt;Diff&lt;/code&gt; type suggested &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;here&lt;/a&gt;. We&amp;rsquo;ve used the name &lt;code&gt;Exclude&lt;/code&gt; to avoid breaking existing code that defines a &lt;code&gt;Diff&lt;/code&gt;, plus we feel that name better conveys the semantics of the type. We did not include the &lt;code&gt;Omit&amp;lt;T, K&amp;gt;&lt;/code&gt; type because it is trivially written as &lt;code&gt;Pick&amp;lt;T, Exclude&amp;lt;keyof T, K&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">注： &lt;code&gt;Exclude&lt;/code&gt; タイプは、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;ここで&lt;/a&gt;提案されている &lt;code&gt;Diff&lt;/code&gt; タイプの適切な実装です。 &lt;code&gt;Diff&lt;/code&gt; を定義する既存のコードを壊さないようにするために &lt;code&gt;Exclude&lt;/code&gt; という名前を使用しました。さらに、この名前は型のセマンティクスをよりよく伝えると感じています。 &lt;code&gt;Omit&amp;lt;T, K&amp;gt;&lt;/code&gt; タイプは、 &lt;code&gt;Pick&amp;lt;T, Exclude&amp;lt;keyof T, K&amp;gt;&amp;gt;&lt;/code&gt; として簡単に記述されているため、含めませんでした。</target>
        </trans-unit>
        <trans-unit id="890949cc49cb65675bbdc6a302bba418a9f75399" translate="yes" xml:space="preserve">
          <source>Note: The new behavior is added under a flag to avoid unwarranted breaks to existing code bases. &lt;strong&gt;We highly recommend applying it both to new and existing projects.&lt;/strong&gt; For existing projects, namespace imports (&lt;code&gt;import * as express from &quot;express&quot;; express();&lt;/code&gt;) will need to be converted to default imports (&lt;code&gt;import express from &quot;express&quot;; express();&lt;/code&gt;).</source>
          <target state="translated">注：フラグの下に新しい動作が追加され、既存のコードベースが不当に壊れないようにしています。&lt;strong&gt;新規および既存のプロジェクトの両方に適用することを強くお勧めします。&lt;/strong&gt;既存のプロジェクトの場合、名前空間のインポート（ &lt;code&gt;import * as express from &quot;express&quot;; express();&lt;/code&gt; ）をデフォルトのインポートに変換する必要があります（ &lt;code&gt;import express from &quot;express&quot;; express();&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1ed11ffc3601c3d16f34bfee2955149b8374ad13" translate="yes" xml:space="preserve">
          <source>Note: This change brings a new emit helper, &lt;code&gt;__makeTemplateObject&lt;/code&gt;; if you are using &lt;code&gt;--importHelpers&lt;/code&gt; with &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt;, an updated to version 1.8 or later.</source>
          <target state="translated">注：この変更により、新しい &lt;code&gt;__makeTemplateObject&lt;/code&gt; ヘルパー__makeTemplateObjectが提供されます。&lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt;で &lt;code&gt;--importHelpers&lt;/code&gt; を使用している場合は、バージョン1.8以降に更新されます。</target>
        </trans-unit>
        <trans-unit id="f9c2b580006a52af1ed6b77bbd97ca85b4b1524b" translate="yes" xml:space="preserve">
          <source>Note: This type only works correctly if &lt;code&gt;--strictFunctionTypes&lt;/code&gt; is enabled. See &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/32964&quot;&gt;#32964&lt;/a&gt;.</source>
          <target state="translated">注：このタイプは、 &lt;code&gt;--strictFunctionTypes&lt;/code&gt; が有効になっている場合にのみ正しく機能します。&lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/32964&quot;&gt;＃32964を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="df7f583105fdd881893e583d6f13dbb72c16aa47" translate="yes" xml:space="preserve">
          <source>Note: You can also specify a catch-all string indexer on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; as follows:</source>
          <target state="translated">注：次のように、 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; でキャッチオール文字列インデクサーを指定することもできます。</target>
        </trans-unit>
        <trans-unit id="86b84c8f5ebae0249a61b0e8be7e70f077917ea7" translate="yes" xml:space="preserve">
          <source>Note: You&amp;rsquo;ll need to configure your project to use the NuGet packages. Please see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Configuring-MSBuild-projects-to-use-NuGet&quot;&gt;Configuring MSBuild projects to use NuGet&lt;/a&gt; for more information.</source>
          <target state="translated">注：NuGetパッケージを使用するには、プロジェクトを構成する必要があります。詳細について&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Configuring-MSBuild-projects-to-use-NuGet&quot;&gt;は、NuGetを使用するためのMSBuildプロジェクトの構成を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="428e262209f33a2ca2447240e01cc6cf696d81da" translate="yes" xml:space="preserve">
          <source>Note: first, we need to make sure our run-time has an ECMAScript-compliant &lt;code&gt;Promise&lt;/code&gt; available globally. That might involve grabbing &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;a polyfill&lt;/a&gt; for &lt;code&gt;Promise&lt;/code&gt;, or relying on one that you might have in the run-time that you&amp;rsquo;re targeting. We also need to make sure that TypeScript knows &lt;code&gt;Promise&lt;/code&gt; exists by setting your &lt;code&gt;lib&lt;/code&gt; flag to something like &lt;code&gt;&quot;dom&quot;, &quot;es2015&quot;&lt;/code&gt; or &lt;code&gt;&quot;dom&quot;, &quot;es2015.promise&quot;, &quot;es5&quot;&lt;/code&gt;</source>
          <target state="translated">注：最初に、ランタイムがECMAScript準拠の &lt;code&gt;Promise&lt;/code&gt; をグローバルに利用できるようにする必要があります。これには、 &lt;code&gt;Promise&lt;/code&gt; の&lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;ポリフィル&lt;/a&gt;を取得するか、ターゲットとするランタイムにある可能性があるポリフィルに依存することが含まれる場合があります。TypeScriptは、 &lt;code&gt;lib&lt;/code&gt; フラグを &lt;code&gt;&quot;dom&quot;, &quot;es2015&quot;&lt;/code&gt; または &lt;code&gt;&quot;dom&quot;, &quot;es2015.promise&quot;, &quot;es5&quot;&lt;/code&gt; ようなものに設定して、 &lt;code&gt;Promise&lt;/code&gt; が存在することを確実に認識する必要もあります。</target>
        </trans-unit>
        <trans-unit id="8ccce25f4f717ae800fc16f144d50c248273d87f" translate="yes" xml:space="preserve">
          <source>Note: if the declaration file you are searching for is not present, you can always contribute one back and help out the next developer looking for it. Please see the DefinitelyTyped &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt; for details.</source>
          <target state="translated">注：検索している宣言ファイルが存在しない場合は、いつでも1つ投稿して、次の開発者がファイルを探す手助けをすることができます。詳細については、DefinitelyTypedコント&lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;リビュー&lt;/a&gt;ションガイドラインのページをご覧ください。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="7e6e74755e762c4957a748b815736bf13786cbb4" translate="yes" xml:space="preserve">
          <source>Notice how we dropped &lt;code&gt;theName&lt;/code&gt; altogether and just use the shortened &lt;code&gt;readonly name: string&lt;/code&gt; parameter on the constructor to create and initialize the &lt;code&gt;name&lt;/code&gt; member. We&amp;rsquo;ve consolidated the declarations and assignment into one location.</source>
          <target state="translated">&lt;code&gt;theName&lt;/code&gt; を完全に削除し、コンストラクターで短縮された &lt;code&gt;readonly name: string&lt;/code&gt; パラメーターを使用して、 &lt;code&gt;name&lt;/code&gt; メンバーを作成および初期化する方法に注意してください。宣言と割り当てを1つの場所に統合しました。</target>
        </trans-unit>
        <trans-unit id="6a85b01a3af32d42a46518c09152775637f852de" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;T&lt;/code&gt; has been propagated from &lt;code&gt;makeArray&lt;/code&gt; into the resulting type&amp;rsquo;s type parameter list. This means that genericity from &lt;code&gt;compose&lt;/code&gt;&amp;rsquo;s arguments has been preserved and our &lt;code&gt;makeBoxedArray&lt;/code&gt; sample will just work!</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;makeArray&lt;/code&gt; から結果の型の型パラメーターリストに伝達されていることに注意してください。これは、 &lt;code&gt;compose&lt;/code&gt; の引数の総称性が保持され、 &lt;code&gt;makeBoxedArray&lt;/code&gt; サンプルが機能することを意味します！</target>
        </trans-unit>
        <trans-unit id="a26aafd348bc0fd9af2fe643fb8a471bed279231" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;T&lt;/code&gt; has the additional constraint &lt;code&gt;any[]&lt;/code&gt; within the true branch of &lt;code&gt;Boxed&amp;lt;T&amp;gt;&lt;/code&gt; and it is therefore possible to refer to the element type of the array as &lt;code&gt;T[number]&lt;/code&gt;. Also, notice how the conditional type is distributed over the union type in the last example.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; には &lt;code&gt;Boxed&amp;lt;T&amp;gt;&lt;/code&gt; 真の分岐内に追加の制約 &lt;code&gt;any[]&lt;/code&gt; があるため、配列の要素型を &lt;code&gt;T[number]&lt;/code&gt; として参照できることに注意してください。また、最後の例では、条件付きタイプが共用体タイプにどのように分布しているかに注意してください。</target>
        </trans-unit>
        <trans-unit id="10af1f3e49765726e808fd41e23133e1c2a4e7ed" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;createCardPicker&lt;/code&gt; is a function that itself returns a function. If we tried to run the example, we would get an error instead of the expected alert box. This is because the &lt;code&gt;this&lt;/code&gt; being used in the function created by &lt;code&gt;createCardPicker&lt;/code&gt; will be set to &lt;code&gt;window&lt;/code&gt; instead of our &lt;code&gt;deck&lt;/code&gt; object. That&amp;rsquo;s because we call &lt;code&gt;cardPicker()&lt;/code&gt; on its own. A top-level non-method syntax call like this will use &lt;code&gt;window&lt;/code&gt; for &lt;code&gt;this&lt;/code&gt;. (Note: under strict mode, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; rather than &lt;code&gt;window&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;createCardPicker&lt;/code&gt; は、それ自体が関数を返す関数であることに注意してください。この例を実行しようとすると、予期されたアラートボックスの代わりにエラーが発生します。これは、 &lt;code&gt;this&lt;/code&gt; ことにより、作成された関数で使用されている &lt;code&gt;createCardPicker&lt;/code&gt; がに設定されます &lt;code&gt;window&lt;/code&gt; の代わりに、私たちの &lt;code&gt;deck&lt;/code&gt; オブジェクト。これは、 &lt;code&gt;cardPicker()&lt;/code&gt; を独自に呼び出すためです。このようなトップレベルの非メソッドの構文の呼び出しが使用する &lt;code&gt;window&lt;/code&gt; するために &lt;code&gt;this&lt;/code&gt; 。 （注：厳密モードでは、 &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;window&lt;/code&gt; ではなく &lt;code&gt;undefined&lt;/code&gt; になります）。</target>
        </trans-unit>
        <trans-unit id="763a205d6a7b4e6716dbfe0467c7193103f61a5d" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;uglify&lt;/code&gt; itself has just one call &amp;mdash; the calls to &lt;code&gt;buffer&lt;/code&gt; and &lt;code&gt;sourcemaps&lt;/code&gt; exist to make sure sourcemaps keep working. These calls give us a separate sourcemap file instead of using inline sourcemaps like before. Now you can run Gulp and check that &lt;code&gt;bundle.js&lt;/code&gt; does get minified into an unreadable mess:</source>
          <target state="translated">ことに注意してください &lt;code&gt;uglify&lt;/code&gt; の呼び出し-それ自体がひとつの呼び出した &lt;code&gt;buffer&lt;/code&gt; と &lt;code&gt;sourcemaps&lt;/code&gt; sourcemapsが動作し続けることを確認するために存在します。これらの呼び出しにより、以前のようにインラインソースマップを使用する代わりに、個別のソースマップファイルが提供されます。これで、 &lt;code&gt;bundle.js&lt;/code&gt; 実行して、bundle.jsが読み取り不能な混乱に縮小されることを確認できます。</target>
        </trans-unit>
        <trans-unit id="9840073ae62b539ce3e1ebbfd27d812a30288a78" translate="yes" xml:space="preserve">
          <source>Notice that Node.js jumped up a directory in steps (4) and (7).</source>
          <target state="translated">(4)と(7)のステップでNode.jsがディレクトリをジャンプアップしたことに注目してください。</target>
        </trans-unit>
        <trans-unit id="ab4bf996704c0896075b225907ab9de7984c49ba" translate="yes" xml:space="preserve">
          <source>Notice that TypeScript not only knows that &lt;code&gt;pet&lt;/code&gt; is a &lt;code&gt;Fish&lt;/code&gt; in the &lt;code&gt;if&lt;/code&gt; branch; it also knows that in the &lt;code&gt;else&lt;/code&gt; branch, you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; have a &lt;code&gt;Fish&lt;/code&gt;, so you must have a &lt;code&gt;Bird&lt;/code&gt;.</source>
          <target state="translated">TypeScript は、 &lt;code&gt;pet&lt;/code&gt; が &lt;code&gt;if&lt;/code&gt; ブランチの &lt;code&gt;Fish&lt;/code&gt; であることを知っているだけではないことに注意してください。それはまた、中にいることを知っている &lt;code&gt;else&lt;/code&gt; 支店、あなたは&lt;em&gt;していない&lt;/em&gt;持っている &lt;code&gt;Fish&lt;/code&gt; 、あなたが持っている必要がありますので、 &lt;code&gt;Bird&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb0aa408a6fabdf5fe7f3f24ac365f674b565f27" translate="yes" xml:space="preserve">
          <source>Notice that although there were errors, the &lt;code&gt;greeter.js&lt;/code&gt; file is still created. You can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected.</source>
          <target state="translated">エラーはありましたが、 &lt;code&gt;greeter.js&lt;/code&gt; ファイルはまだ作成されています。コードにエラーがある場合でも、TypeScriptを使用できます。ただし、この場合、TypeScriptはコードが期待どおりに実行されない可能性があることを警告しています。</target>
        </trans-unit>
        <trans-unit id="f262e26dd39e3b5a66a391868d3fb9f6d6e5738f" translate="yes" xml:space="preserve">
          <source>Notice that even though we used ES2015 module syntax, TypeScript emitted CommonJS modules that Node uses. We&amp;rsquo;ll stick with CommonJS for this tutorial, but you could set &lt;code&gt;module&lt;/code&gt; in the options object to change this.</source>
          <target state="translated">ES2015モジュールの構文を使用していても、TypeScriptはNodeが使用するCommonJSモジュールを生成したことに注意してください。このチュートリアルではCommonJSを使い &lt;code&gt;module&lt;/code&gt; が、オプションオブジェクトにモジュールを設定してこれを変更できます。</target>
        </trans-unit>
        <trans-unit id="6426330771f7083cfd35796802456c49f5b66b69" translate="yes" xml:space="preserve">
          <source>Notice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use &lt;code&gt;GenericIdentityFn&lt;/code&gt;, we now will also need to specify the corresponding type argument (here: &lt;code&gt;number&lt;/code&gt;), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic.</source>
          <target state="translated">例が少し異なるように変更されていることに注意してください。ジェネリック関数を記述する代わりに、ジェネリック型の一部である非ジェネリック関数のシグネチャを用意しました。 &lt;code&gt;GenericIdentityFn&lt;/code&gt; を使用する場合、対応する型引数（ここでは： &lt;code&gt;number&lt;/code&gt; ）も指定する必要があります。これにより、基になる呼び出し署名が使用するものを効果的にロックします。型パラメーターを呼び出し署名に直接配置するタイミングとそれをインターフェイス自体に配置するタイミングを理解すると、型のどの側面が一般的であるかを説明するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="9bb1da98b82bb82ebbe555bd6d19c0a036a3fa15" translate="yes" xml:space="preserve">
          <source>Notice that the elements of each group maintains the same order, but the groups themselves are merged with later overload sets ordered first.</source>
          <target state="translated">各グループの要素は同じ順序を維持していますが、グループ自体は最初に順序付けられた後のオーバーロードセットとマージされていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="765da565a7c17cfcf3312a5eda7111c42ee0f02e" translate="yes" xml:space="preserve">
          <source>Notice that we didn&amp;rsquo;t have to explicitly pass the type in the angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;); the compiler just looked at the value &lt;code&gt;&quot;myString&quot;&lt;/code&gt;, and set &lt;code&gt;T&lt;/code&gt; to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.</source>
          <target state="translated">山かっこ（ &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ）で型を明示的に渡す必要がないことに注意してください。コンパイラーは値 &lt;code&gt;&quot;myString&quot;&lt;/code&gt; を調べ、 &lt;code&gt;T&lt;/code&gt; をそのタイプに設定しました。型引数の推論は、コードを短く読みやすくするのに役立つツールですが、より複雑な例で発生する可能性があるように、コンパイラが型を推測できない場合は、前の例で行ったように型引数を明示的に渡す必要がある場合があります。 。</target>
        </trans-unit>
        <trans-unit id="e2786dc0fc7753238adaa3b182c5756666dbd537" translate="yes" xml:space="preserve">
          <source>Notice that we don&amp;rsquo;t use the &lt;code&gt;require&lt;/code&gt; keyword; instead we assign directly from the qualified name of the symbol we&amp;rsquo;re importing. This is similar to using &lt;code&gt;var&lt;/code&gt;, but also works on the type and namespace meanings of the imported symbol. Importantly, for values, &lt;code&gt;import&lt;/code&gt; is a distinct reference from the original symbol, so changes to an aliased &lt;code&gt;var&lt;/code&gt; will not be reflected in the original variable.</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; キーワードを使用していないことに注意してください。代わりに、インポートするシンボルの修飾名から直接割り当てます。これは &lt;code&gt;var&lt;/code&gt; の使用に似ていますが、インポートされたシンボルのタイプと名前空間の意味でも機能します。重要なことに、値に対して、 &lt;code&gt;import&lt;/code&gt; 、元のシンボルとは異なる基準であるので、エイリアスに変化 &lt;code&gt;var&lt;/code&gt; 元の変数には反映されません。</target>
        </trans-unit>
        <trans-unit id="5474e3c4f0295fff5cf94b925d396e756aa6518e" translate="yes" xml:space="preserve">
          <source>Notice that we had to surround this statement with parentheses. JavaScript normally parses a &lt;code&gt;{&lt;/code&gt; as the start of block.</source>
          <target state="translated">このステートメントを括弧で囲む必要があることに注意してください。JavaScriptは通常、ブロックの開始として &lt;code&gt;{&lt;/code&gt; を解析します。</target>
        </trans-unit>
        <trans-unit id="f3a80c95c92964743c3a7674b186fd203447952a" translate="yes" xml:space="preserve">
          <source>Notice that we had to use type assertions several times. It would be much better if once we performed the check, we could know the type of &lt;code&gt;pet&lt;/code&gt; within each branch.</source>
          <target state="translated">型アサーションを数回使用する必要があることに注意してください。チェックを実行したら、各ブランチ内の &lt;code&gt;pet&lt;/code&gt; のタイプを知ることができれば、はるかに良いでしょう。</target>
        </trans-unit>
        <trans-unit id="f1d22a5b64c25dc62cca8b1fc9ad531fb98be848" translate="yes" xml:space="preserve">
          <source>Notice that we installed TypeScript as a development dependency. We could also have linked TypeScript to a global copy with &lt;code&gt;npm link typescript&lt;/code&gt;, but this is a less common scenario.</source>
          <target state="translated">TypeScriptを開発依存関係としてインストールしたことに注意してください。TypeScriptを &lt;code&gt;npm link typescript&lt;/code&gt; を使用してグローバルコピーにリンクすることもできますが、これはあまり一般的ではありません。</target>
        </trans-unit>
        <trans-unit id="e83cd308da6a35cefd1d54ccc96691cc920beea5" translate="yes" xml:space="preserve">
          <source>Notice that we specified &lt;code&gt;debug: true&lt;/code&gt; to Browserify. This causes tsify to emit source maps inside the bundled JavaScript file. Source maps let you debug your original TypeScript code in the browser instead of the bundled JavaScript. You can test that source maps are working by opening the debugger for your browser and putting a breakpoint inside &lt;code&gt;main.ts&lt;/code&gt;. When you refresh the page the breakpoint should pause the page and let you debug &lt;code&gt;greet.ts&lt;/code&gt;.</source>
          <target state="translated">Browserifyに &lt;code&gt;debug: true&lt;/code&gt; を指定したことに注意してください。これにより、tsifyはバンドルされたJavaScriptファイル内にソースマップを発行します。ソースマップを使用すると、バンドルされているJavaScriptではなく、ブラウザで元のTypeScriptコードをデバッグできます。ブラウザーのデバッガーを開き、 &lt;code&gt;main.ts&lt;/code&gt; 内にブレークポイントを置くことにより、ソースマップが機能していることをテストできます。ページを更新すると、ブレークポイントによってページが一時停止し、 &lt;code&gt;greet.ts&lt;/code&gt; をデバッグできるようになります。</target>
        </trans-unit>
        <trans-unit id="67d48d2666a5c7a992a5ba5ca0e49f58d31d4a07" translate="yes" xml:space="preserve">
          <source>Notice that we&amp;rsquo;re including files from within &lt;code&gt;node_modules&lt;/code&gt;. React and React-DOM&amp;rsquo;s npm packages include standalone &lt;code&gt;.js&lt;/code&gt; files that you can include in a web page, and we&amp;rsquo;re referencing them directly to get things moving faster. Feel free to copy these files to another directory, or alternatively, host them on a content delivery network (CDN). Facebook makes CDN-hosted versions of React available, and you can &lt;a href=&quot;http://facebook.github.io/react/downloads.html#development-vs.-production-builds&quot;&gt;read more about that here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;node_modules&lt;/code&gt; 内のファイルを含めていることに注意してください。ReactとReact-DOMのnpmパッケージには、Webページに含めることができるスタンドアロンの &lt;code&gt;.js&lt;/code&gt; ファイルが含まれています。これらのファイルを別のディレクトリにコピーするか、コンテンツ配信ネットワーク（CDN）でホストしてください。Facebookは、ReactのCDNでホストされたバージョンを利用可能にします。&lt;a href=&quot;http://facebook.github.io/react/downloads.html#development-vs.-production-builds&quot;&gt;その詳細については、こちらをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b09f5734b53cfac68ac359e515430d1247899638" translate="yes" xml:space="preserve">
          <source>Notice that while we can&amp;rsquo;t use &lt;code&gt;name&lt;/code&gt; from outside of &lt;code&gt;Person&lt;/code&gt;, we can still use it from within an instance method of &lt;code&gt;Employee&lt;/code&gt; because &lt;code&gt;Employee&lt;/code&gt; derives from &lt;code&gt;Person&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Person&lt;/code&gt; の外部から &lt;code&gt;name&lt;/code&gt; を使用することはできませんが、 &lt;code&gt;Employee&lt;/code&gt; は &lt;code&gt;Person&lt;/code&gt; から派生しているため、 &lt;code&gt;Employee&lt;/code&gt; のインスタンスメソッド内からでも使用できます。</target>
        </trans-unit>
        <trans-unit id="057539fc62c3a3433f309ba4576e4667a469ea4a" translate="yes" xml:space="preserve">
          <source>Notice the above needed no type annotations. The &lt;code&gt;const&lt;/code&gt; assertion allowed TypeScript to take the most specific type of the expression.</source>
          <target state="translated">上記は型注釈を必要としないことに注意してください。 &lt;code&gt;const&lt;/code&gt; の主張は活字体は、表現の最も具体的なタイプを取ることができました。</target>
        </trans-unit>
        <trans-unit id="f321483ba4f94eea3586e9078b133451c9b94b14" translate="yes" xml:space="preserve">
          <source>Notice the given argument to &lt;code&gt;createSquare&lt;/code&gt; is spelled &lt;em&gt;&lt;code&gt;colour&lt;/code&gt;&lt;/em&gt; instead of &lt;code&gt;color&lt;/code&gt;. In plain JavaScript, this sort of thing fails silently.</source>
          <target state="translated">与えられた引数に注目してください &lt;code&gt;createSquare&lt;/code&gt; が綴られている&lt;em&gt; &lt;code&gt;colour&lt;/code&gt; &lt;/em&gt;の代わりに、 &lt;code&gt;color&lt;/code&gt; 。単純なJavaScriptでは、この種のことは黙って失敗します。</target>
        </trans-unit>
        <trans-unit id="449041a6d7a9b6fc7d3b8e6410b5c6cd0fde878b" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;search&lt;/code&gt; is &lt;code&gt;{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }&lt;/code&gt;. Object spreading is more complex than array spreading. Like array spreading, it proceeds from left-to-right, but the result is still an object. This means that properties that come later in the spread object overwrite properties that come earlier. So if we modify the previous example to spread at the end:</source>
          <target state="translated">現在、 &lt;code&gt;search&lt;/code&gt; は &lt;code&gt;{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }&lt;/code&gt; です。オブジェクトの分散は、配列の分散よりも複雑です。配列拡散と同様に、左から右に進みますが、結果は依然としてオブジェクトです。つまり、spreadオブジェクトで後から来るプロパティは、先に来るプロパティを上書きします。したがって、前の例を最後に拡散するように変更すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="db8e5588d2d1057026cfc4a79854c4482517ae14" translate="yes" xml:space="preserve">
          <source>Now TypeScript knows that &lt;code&gt;createCardPicker&lt;/code&gt; expects to be called on a &lt;code&gt;Deck&lt;/code&gt; object. That means that &lt;code&gt;this&lt;/code&gt; is of type &lt;code&gt;Deck&lt;/code&gt; now, not &lt;code&gt;any&lt;/code&gt;, so &lt;code&gt;--noImplicitThis&lt;/code&gt; will not cause any errors.</source>
          <target state="translated">TypeScriptは、 &lt;code&gt;createCardPicker&lt;/code&gt; が &lt;code&gt;Deck&lt;/code&gt; オブジェクトで呼び出されることを想定していることを認識しました。ことを意味し &lt;code&gt;this&lt;/code&gt; 型のある &lt;code&gt;Deck&lt;/code&gt; ではない、今 &lt;code&gt;any&lt;/code&gt; ように &lt;code&gt;--noImplicitThis&lt;/code&gt; は何らかのエラーが発生することはありません。</target>
        </trans-unit>
        <trans-unit id="1bb4e738e148009f79ea8206746e9d01e2ac6c80" translate="yes" xml:space="preserve">
          <source>Now change &lt;code&gt;main.ts&lt;/code&gt; to update the page:</source>
          <target state="translated">今すぐ変更 &lt;code&gt;main.ts&lt;/code&gt; をページを更新します：</target>
        </trans-unit>
        <trans-unit id="19f45556bb4ffb06e428f0775fa838cee98426d1" translate="yes" xml:space="preserve">
          <source>Now change the code in &lt;code&gt;src/main.ts&lt;/code&gt; to import &lt;code&gt;sayHello&lt;/code&gt; from &lt;code&gt;greet.ts&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;src/main.ts&lt;/code&gt; のコードを変更して、greet.tsから &lt;code&gt;sayHello&lt;/code&gt; をインポートし &lt;code&gt;greet.ts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc972ac7f876ddb230eb09fff1d371c82cba09d1" translate="yes" xml:space="preserve">
          <source>Now change your gulpfile to the following:</source>
          <target state="translated">これでgulpfileを以下のように変更します。</target>
        </trans-unit>
        <trans-unit id="d5e91337836080850365ec1adb6a6e22456b494f" translate="yes" xml:space="preserve">
          <source>Now if you annotate calling code with &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">今、あなたが使ってコードを呼び出す注釈を付ける場合は &lt;code&gt;this&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ce21fbd716cb22501e3b77ae211a67a20a5b69a6" translate="yes" xml:space="preserve">
          <source>Now imports to &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; would be looked up in &lt;code&gt;./modules/moduleA&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; へのインポートは &lt;code&gt;./modules/moduleA&lt;/code&gt; で検索されます</target>
        </trans-unit>
        <trans-unit id="7bb24a6d01809ab25d994975acd19c2bdf7782ca" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at how return types are treated, using two functions that differ only by their return type:</source>
          <target state="translated">次に、戻り値の型のみが異なる2つの関数を使用して、戻り値の型がどのように扱われるかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="cfc81a9edf6b5df21e2f8d967d810f4429dddd90" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s move this project from Node to the browser. To do this, we&amp;rsquo;d like to bundle all our modules into one JavaScript file. Fortunately, that&amp;rsquo;s exactly what Browserify does. Even better, it lets us use the CommonJS module system used by Node, which is the default TypeScript emit. That means our TypeScript and Node setup will transfer to the browser basically unchanged.</source>
          <target state="translated">次に、このプロジェクトをノードからブラウザーに移動します。これを行うには、すべてのモジュールを1つのJavaScriptファイルにバンドルします。さいわい、それがBrowserifyの機能です。さらに良いことに、Nodeが使用するCommonJSモジュールシステムを使用できます。これは、デフォルトのTypeScriptエミットです。つまり、TypeScriptとNodeの設定は、基本的に変更されずにブラウザーに転送されます。</target>
        </trans-unit>
        <trans-unit id="f2ff6a3f3742717cb814ea8ff8b733c8987d4bca" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s use the discriminated union:</source>
          <target state="translated">次に、差別化されたユニオンを使用します。</target>
        </trans-unit>
        <trans-unit id="ff37331bf4adb180113ce3c6cbbb96618f575e44" translate="yes" xml:space="preserve">
          <source>Now open up &lt;code&gt;index.html&lt;/code&gt; in your favorite browser and everything should be ready to use! You should see a page that says &amp;ldquo;Hello from TypeScript and React!&amp;rdquo;</source>
          <target state="translated">次に、お気に入りのブラウザーで &lt;code&gt;index.html&lt;/code&gt; を開き、すべてを使用できるようにします。「Hello from TypeScript and React！」というページが表示されます。</target>
        </trans-unit>
        <trans-unit id="b64ae89f2b2c42dc4bb6323281704d7232b3bc08" translate="yes" xml:space="preserve">
          <source>Now right-click on &lt;code&gt;gulpfile.js&lt;/code&gt; and click Task Runner Explorer.</source>
          <target state="translated">ここで &lt;code&gt;gulpfile.js&lt;/code&gt; を右クリックして、Task Runner Explorerをクリックします。</target>
        </trans-unit>
        <trans-unit id="016beaf6be9be172cdeebc211faf5982d24125cf" translate="yes" xml:space="preserve">
          <source>Now that we are bundling our code with Browserify and tsify, we can add various features to our build with browserify plugins.</source>
          <target state="translated">Browserify と tsify でコードをバンドルしているので、browserify プラグインを使ってビルドに様々な機能を追加することができます。</target>
        </trans-unit>
        <trans-unit id="3572b0fda28e71add853bf4afaed6b354c007b3b" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve typed the function, let&amp;rsquo;s write the full type of the function out by looking at each piece of the function type.</source>
          <target state="translated">関数を入力したので、関数の型の各部分を調べて、関数の完全な型を書きましょう。</target>
        </trans-unit>
        <trans-unit id="2966203d51ca9197ed946ae5160c527e0fb03c59" translate="yes" xml:space="preserve">
          <source>Now that you have authored a declaration file following the steps of this guide, it is time to publish it to npm. There are two main ways you can publish your declaration files to npm:</source>
          <target state="translated">このガイドの手順に従って宣言ファイルをオーサリングしたら、いよいよ npm に公開しましょう。宣言ファイルを npm に公開するには、主に 2 つの方法があります。</target>
        </trans-unit>
        <trans-unit id="8c3e6c78d4bb8682924668ec470406f5a06e700d" translate="yes" xml:space="preserve">
          <source>Now that you know how to wrap the properties of a type, the next thing you&amp;rsquo;ll want to do is unwrap them. Fortunately, that&amp;rsquo;s pretty easy:</source>
          <target state="translated">型のプロパティをラップする方法を理解したので、次に行うことは、それらをラップ解除することです。幸い、それはとても簡単です。</target>
        </trans-unit>
        <trans-unit id="6f30ea04179dac8c71c16f96f3f1582920ec3fad" translate="yes" xml:space="preserve">
          <source>Now the type of the array propagates into the &lt;code&gt;ArrayMetadata&lt;/code&gt; type.</source>
          <target state="translated">これで、配列の型が &lt;code&gt;ArrayMetadata&lt;/code&gt; 型に伝播します。</target>
        </trans-unit>
        <trans-unit id="586d73d271314d06733d1c62bea37895a7824b97" translate="yes" xml:space="preserve">
          <source>Now to extend this to add support for input with numbers in bases other than 10, let&amp;rsquo;s create &lt;code&gt;ProgrammerCalculator.ts&lt;/code&gt;</source>
          <target state="translated">これを拡張して、基数が10以外の数値の入力のサポートを追加するには、 &lt;code&gt;ProgrammerCalculator.ts&lt;/code&gt; を作成しましょう</target>
        </trans-unit>
        <trans-unit id="54df9cc661a5983b5f51492bea457bb95cb0f212" translate="yes" xml:space="preserve">
          <source>Now type the following in &lt;code&gt;greeter.html&lt;/code&gt;:</source>
          <target state="translated">次に、 &lt;code&gt;greeter.html&lt;/code&gt; に次のように入力します。</target>
        </trans-unit>
        <trans-unit id="0aedf42a298e6637bb4289e35235553f17c5d827" translate="yes" xml:space="preserve">
          <source>Now we can &lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt;&lt;code&gt;node.d.ts&lt;/code&gt; and then load the modules using &lt;code&gt;import url = require(&quot;url&quot;);&lt;/code&gt; or &lt;code&gt;import * as URL from &quot;url&quot;&lt;/code&gt;.</source>
          <target state="translated">今、我々はできる &lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt; &lt;code&gt;node.d.ts&lt;/code&gt; してから使用してモジュールをロードする &lt;code&gt;import url = require(&quot;url&quot;);&lt;/code&gt; または &lt;code&gt;import * as URL from &quot;url&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2993564eab76d9b635f5473fb0c79d7180499112" translate="yes" xml:space="preserve">
          <source>Now we can start taking advantage of some of the new tools TypeScript offers. Add a &lt;code&gt;: string&lt;/code&gt; type annotation to the &amp;lsquo;person&amp;rsquo; function argument as shown here:</source>
          <target state="translated">TypeScriptが提供する新しいツールのいくつかを利用できるようになりました。次のように、「person」関数の引数に &lt;code&gt;: string&lt;/code&gt; 型注釈を追加します。</target>
        </trans-unit>
        <trans-unit id="a9ba4be9a993e3629ea4a24cf3ff116ae3e0a325" translate="yes" xml:space="preserve">
          <source>Now we can use &lt;code&gt;npm install&lt;/code&gt; to install packages. First install &lt;code&gt;gulp-cli&lt;/code&gt; globally (if you use a Unix system, you may need to prefix the &lt;code&gt;npm install&lt;/code&gt; commands in this guide with &lt;code&gt;sudo&lt;/code&gt;).</source>
          <target state="translated">これで、 &lt;code&gt;npm install&lt;/code&gt; を使用してパッケージをインストールできます。最初に &lt;code&gt;gulp-cli&lt;/code&gt; をグローバルにインストールします（Unixシステムを使用している場合は、このガイドの &lt;code&gt;npm install&lt;/code&gt; コマンドの前に &lt;code&gt;sudo&lt;/code&gt; を付ける必要がある場合があります）。</target>
        </trans-unit>
        <trans-unit id="a7d081445a246b0f99f5a3375693fd0bead88a94" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll turn this folder into an npm package.</source>
          <target state="translated">次に、このフォルダーをnpmパッケージに変換します。</target>
        </trans-unit>
        <trans-unit id="798f21b6ccc1b472b81074260cf839e73de6d419" translate="yes" xml:space="preserve">
          <source>Now when these &lt;code&gt;never&lt;/code&gt;-returning functions are called, TypeScript recognizes that they affect the control flow graph and accounts for them.</source>
          <target state="translated">これらの &lt;code&gt;never&lt;/code&gt; 戻らない関数が呼び出されると、TypeScriptは、それらが制御フローグラフに影響を与え、それらを説明することを認識します。</target>
        </trans-unit>
        <trans-unit id="4fec837a26b514bcf683dcfc0bc3cc7b47c80376" translate="yes" xml:space="preserve">
          <source>Now when you run Gulp, it should start and stay running. Try changing the code for &lt;code&gt;showHello&lt;/code&gt; in &lt;code&gt;main.ts&lt;/code&gt; and saving it. You should see output that looks like this:</source>
          <target state="translated">これでGulpを実行すると、Gulpが起動して実行を続けるはずです。以下のためのコード変更してみてください &lt;code&gt;showHello&lt;/code&gt; をして &lt;code&gt;main.ts&lt;/code&gt; し、それを保存します。次のような出力が表示されます。</target>
        </trans-unit>
        <trans-unit id="5ab194637a92c49cdda73412d946249336784333" translate="yes" xml:space="preserve">
          <source>Now you can import things that match &lt;code&gt;&quot;*!text&quot;&lt;/code&gt; or &lt;code&gt;&quot;json!*&quot;&lt;/code&gt;.</source>
          <target state="translated">これで、 &lt;code&gt;&quot;*!text&quot;&lt;/code&gt; または &lt;code&gt;&quot;json!*&quot;&lt;/code&gt; 一致するものをインポートできます。</target>
        </trans-unit>
        <trans-unit id="0b80d5fe66868146461ed39d9590423def0cc437" translate="yes" xml:space="preserve">
          <source>Now, for the remainder of the &lt;code&gt;createElement&lt;/code&gt; definition: &lt;code&gt;(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]&lt;/code&gt;. The first argument &lt;code&gt;tagName&lt;/code&gt; is defined as the generic parameter &lt;code&gt;K&lt;/code&gt; . The TypeScript interpreter is smart enough to &lt;em&gt;infer&lt;/em&gt; the generic parameter from this argument. This means that the developer does not actually have to specify the generic parameter when using the method; whatever value is passed to the &lt;code&gt;tagName&lt;/code&gt; argument will be inferred as &lt;code&gt;K&lt;/code&gt; and thus can be used throughout the remainder of the definition. Which is exactly what happens; the return value &lt;code&gt;HTMLElementTagNameMap[K]&lt;/code&gt; takes the &lt;code&gt;tagName&lt;/code&gt; argument and uses it to return the corresponding type. This definition is how the &lt;code&gt;p&lt;/code&gt; variable from the code snippet gets a type of &lt;code&gt;HTMLParagraphElement&lt;/code&gt;. And if the code was &lt;code&gt;document.createElement('a')&lt;/code&gt;, then it would be an element of type &lt;code&gt;HTMLAnchorElement&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;createElement&lt;/code&gt; 定義の残りの部分について： &lt;code&gt;(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]&lt;/code&gt; 。最初の引数 &lt;code&gt;tagName&lt;/code&gt; は、ジェネリックパラメーター &lt;code&gt;K&lt;/code&gt; として定義されています。 TypeScriptインタープリターは、この引数からジェネリックパラメーターを&lt;em&gt;推測する&lt;/em&gt;のに十分賢いです。これは、開発者がメソッドを使用するときに実際にジェネリックパラメーターを指定する必要がないことを意味します。 &lt;code&gt;tagName&lt;/code&gt; 引数に渡された値はすべて、 &lt;code&gt;K&lt;/code&gt; として推測されるため、定義の残りの部分全体で使用できます。それがまさに起こることです。戻り値 &lt;code&gt;HTMLElementTagNameMap[K]&lt;/code&gt; は &lt;code&gt;tagName&lt;/code&gt; を取ります引数を取り、それを使用して対応する型を返します。この定義は、コードスニペットの &lt;code&gt;p&lt;/code&gt; 変数が &lt;code&gt;HTMLParagraphElement&lt;/code&gt; のタイプを取得する方法です。また、コードが &lt;code&gt;document.createElement('a')&lt;/code&gt; の場合、 &lt;code&gt;HTMLAnchorElement&lt;/code&gt; 型の要素になります。</target>
        </trans-unit>
        <trans-unit id="32b6a0eecd0bd91b730d6782f43f8351f9e8957b" translate="yes" xml:space="preserve">
          <source>NuGet</source>
          <target state="translated">NuGet</target>
        </trans-unit>
        <trans-unit id="3fd953c33b944413003ce7910b6fafa75556a775" translate="yes" xml:space="preserve">
          <source>Null and Undefined</source>
          <target state="translated">ヌルと未定義</target>
        </trans-unit>
        <trans-unit id="0ba35c721cc86f9e03aa8786b08aba75ab337b54" translate="yes" xml:space="preserve">
          <source>Null- and undefined-aware types</source>
          <target state="translated">ヌルおよび未定義を意識した型</target>
        </trans-unit>
        <trans-unit id="4235ec51572e6a2ff85027b7b1a8ce199c7cf8fd" translate="yes" xml:space="preserve">
          <source>Nullable types</source>
          <target state="translated">ヌル可能な型</target>
        </trans-unit>
        <trans-unit id="a75b78680034aa8db560e36a8c2208c5c33aa012" translate="yes" xml:space="preserve">
          <source>Nullable types only have meaning if &lt;code&gt;strictNullChecks&lt;/code&gt; is on:</source>
          <target state="translated">&lt;code&gt;strictNullChecks&lt;/code&gt; は、strictNullChecksがオンの場合にのみ意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="961f4d441aaa81cdea02877b88e051c0d6fe0b64" translate="yes" xml:space="preserve">
          <source>Nullish Coalescing</source>
          <target state="translated">ヌルい合体</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="c3e5f2be0a6baf4d94beda8d9cf3d891411658e7" translate="yes" xml:space="preserve">
          <source>Number-like properties of an object type are those declared using a numeric literal or computed property name of a numeric literal type.</source>
          <target state="translated">オブジェクト型の数値ライクなプロパティは、数値リテラル型の数値リテラルまたは計算されたプロパティ名を使用して宣言されたものです。</target>
        </trans-unit>
        <trans-unit id="6be519964a1d39fca2eb603fe581121e0fee9182" translate="yes" xml:space="preserve">
          <source>Numeric Literal Types</source>
          <target state="translated">数値リテラル型</target>
        </trans-unit>
        <trans-unit id="87f1897cf6e443b573ef4632ce2ba3620162bbc7" translate="yes" xml:space="preserve">
          <source>Numeric enums</source>
          <target state="translated">数値列挙</target>
        </trans-unit>
        <trans-unit id="9587a80bbfa80632e8af306b43edbc1e13077c08" translate="yes" xml:space="preserve">
          <source>Numeric enums can be mixed in &lt;a href=&quot;#computed-and-constant-members&quot;&gt;computed and constant members (see below)&lt;/a&gt;. The short story is, enums without initializers either need to be first, or have to come after numeric enums initialized with numeric constants or other constant enum members. In other words, the following isn&amp;rsquo;t allowed:</source>
          <target state="translated">数値の列挙型は、&lt;a href=&quot;#computed-and-constant-members&quot;&gt;計算されたメンバーと定数メンバーに&lt;/a&gt;混在させることができます（以下を参照）。簡単に言えば、初期化子のない列挙型は最初にする必要があるか、数値定数またはその他の定数列挙型メンバーで初期化された数値列挙型の後に来る必要があります。つまり、以下は許可されていません。</target>
        </trans-unit>
        <trans-unit id="830f0ed9d3be32844d496bfeb9d33c2f9dea7d6a" translate="yes" xml:space="preserve">
          <source>Numeric separators</source>
          <target state="translated">数値セパレータ</target>
        </trans-unit>
        <trans-unit id="8ec915a9d6271aa88a6e6bab3fe9b7a8d9dc2808" translate="yes" xml:space="preserve">
          <source>OOP in TypeScript</source>
          <target state="translated">TypeScript の OOP</target>
        </trans-unit>
        <trans-unit id="54e96ab681e7258c80946a74a514f141957d53b7" translate="yes" xml:space="preserve">
          <source>OOP programmers are accustomed to being able to query the type of any value, even a generic one:</source>
          <target state="translated">OOPプログラマは、一般的なものであっても、任意の値の型を問い合わせることができることに慣れています。</target>
        </trans-unit>
        <trans-unit id="adeb8baadb7619ed1ee71c0d637100cf68745ddb" translate="yes" xml:space="preserve">
          <source>OOP programmers are often surprised by two particular aspects of structural typing.</source>
          <target state="translated">OOPプログラマは、構造的な型付けの2つの特殊な側面にしばしば驚かされます。</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="7a98263bb62cd83a74dc00c8238d597167506261" translate="yes" xml:space="preserve">
          <source>Object Spread and Rest</source>
          <target state="translated">オブジェクトの広がりと残り</target>
        </trans-unit>
        <trans-unit id="cbf147d445453a6660add525598d56066b954b1c" translate="yes" xml:space="preserve">
          <source>Object Types</source>
          <target state="translated">オブジェクトの種類</target>
        </trans-unit>
        <trans-unit id="a7dc9622d9872b2041ea4b92f628450cd8b88097" translate="yes" xml:space="preserve">
          <source>Object destructuring</source>
          <target state="translated">オブジェクトの破壊</target>
        </trans-unit>
        <trans-unit id="1ccb033a21e86f3dd077314deacc164caf7a1572" translate="yes" xml:space="preserve">
          <source>Object literal type syntax closely mirrors object literal value syntax:</source>
          <target state="translated">オブジェクトリテラル型の構文は、オブジェクトリテラル値の構文を密接に反映しています。</target>
        </trans-unit>
        <trans-unit id="7cd3db8976f376a1f019b5d0fed0df37b11861ba" translate="yes" xml:space="preserve">
          <source>Object literals are open-ended</source>
          <target state="translated">オブジェクトリテラルはオープンエンド</target>
        </trans-unit>
        <trans-unit id="b3c62e15831841090f5476450b68b035ffba0566" translate="yes" xml:space="preserve">
          <source>Object literals behave as if they have an index signature &lt;code&gt;[x:string]: any&lt;/code&gt; that allows them to be treated as open maps instead of closed objects.</source>
          <target state="translated">オブジェクトリテラルは、インデックスシグネチャ &lt;code&gt;[x:string]: any&lt;/code&gt; を持つかのように動作します。これらは、閉じたオブジェクトではなく開いたマップとして扱うことができるものです。</target>
        </trans-unit>
        <trans-unit id="74365de67eba166395b7f2ad380a09c31367e923" translate="yes" xml:space="preserve">
          <source>Object rests are the dual of object spreads, in that they can extract any extra properties that don&amp;rsquo;t get picked up when destructuring an element:</source>
          <target state="translated">オブジェクトレストは、要素を構造化するときに取得されない余分なプロパティを抽出できるという点で、オブジェクトスプレッドのデュアルです。</target>
        </trans-unit>
        <trans-unit id="e39aafc54b41f807d4c66cedbf76e1c69bb09f15" translate="yes" xml:space="preserve">
          <source>Object spread also has a couple of other surprising limits. First, it only includes an objects&amp;rsquo; &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;own, enumerable properties&lt;/a&gt;. Basically, that means you lose methods when you spread instances of an object:</source>
          <target state="translated">オブジェクトの拡散には、他にもいくつかの驚くべき制限があります。まず、オブジェクト&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;自体の列挙可能なプロパティ&lt;/a&gt;のみが含まれます。基本的に、これは、オブジェクトのインスタンスを拡散するとメソッドが失われることを意味します。</target>
        </trans-unit>
        <trans-unit id="5eeac8ca658c85a10aefd3ffe0bf35ef9f80485c" translate="yes" xml:space="preserve">
          <source>Object spread also has a couple of other surprising limits. First, it only includes an objects&amp;rsquo; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;own, enumerable properties&lt;/a&gt;. Basically, that means you lose methods when you spread instances of an object:</source>
          <target state="translated">オブジェクトの拡散には、他にもいくつかの驚くべき制限があります。まず、オブジェクト&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;自身の列挙可能なプロパティ&lt;/a&gt;のみが含まれます。基本的に、それはオブジェクトのインスタンスを広げるとメソッドを失うことを意味します：</target>
        </trans-unit>
        <trans-unit id="132f0e2906b1a9d29d3142065e0490a0c7b00912" translate="yes" xml:space="preserve">
          <source>Objects with Properties</source>
          <target state="translated">プロパティを持つオブジェクト</target>
        </trans-unit>
        <trans-unit id="e74f2b06a5fbe1c04ad866d78d3e98d6af48f45f" translate="yes" xml:space="preserve">
          <source>Occasionally, you&amp;rsquo;ll run into a library that expects a parameter to be either a &lt;code&gt;number&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;. For instance, take the following function:</source>
          <target state="translated">場合によっては、パラメータが &lt;code&gt;number&lt;/code&gt; または &lt;code&gt;string&lt;/code&gt; いずれかであることを期待するライブラリに遭遇することがあります。たとえば、次の関数を使用します。</target>
        </trans-unit>
        <trans-unit id="6b8b413b8349b0d2cda00f56b58728dca71d8f18" translate="yes" xml:space="preserve">
          <source>Of course, any of these types can be declared using TypeScript syntax in a single-line &lt;code&gt;@typedef&lt;/code&gt;:</source>
          <target state="translated">もちろん、これらのタイプはいずれも、TypeScript構文を使用して1行の &lt;code&gt;@typedef&lt;/code&gt; で宣言できます。</target>
        </trans-unit>
        <trans-unit id="896953fcb00b0eb5b0ba4da3b193100a1b6c1094" translate="yes" xml:space="preserve">
          <source>Of course, any of these types can be declared using Typescript syntax in a single-line &lt;code&gt;@typedef&lt;/code&gt;:</source>
          <target state="translated">もちろん、これらのタイプはいずれも、1行の &lt;code&gt;@typedef&lt;/code&gt; でTypescript構文を使用して宣言できます。</target>
        </trans-unit>
        <trans-unit id="2a729d408f1e41978ee6a94cb932a7977199d3c0" translate="yes" xml:space="preserve">
          <source>Of course, since this is JavaScript, you can just ignore trailing elements you don&amp;rsquo;t care about:</source>
          <target state="translated">もちろん、これはJavaScriptなので、気にしない末尾の要素は無視できます。</target>
        </trans-unit>
        <trans-unit id="b9ca67ed45e73556a1cbb12d34b79f3e95210af4" translate="yes" xml:space="preserve">
          <source>Of course, that might not feel right. If you open that file in an editor with TypeScript support (or if you run &lt;code&gt;tsc --pretty&lt;/code&gt;), you might see red squiggles on certain lines. You should think of these the same way you&amp;rsquo;d think of red squiggles in an editor like Microsoft Word. TypeScript will still translate your code, just like Word will still let you print your documents.</source>
          <target state="translated">もちろん、それは正しくないと感じるかもしれません。TypeScriptをサポートするエディターでそのファイルを開くと（または &lt;code&gt;tsc --pretty&lt;/code&gt; を実行すると）、特定の行に赤い波線が表示されることがあります。これらは、Microsoft Wordのようなエディターで赤い波線と同じように考える必要があります。TypeScriptは、Wordでドキュメントを印刷できるように、コードを変換します。</target>
        </trans-unit>
        <trans-unit id="33b53cf1b820a2734ec0c25dc3f2c29570965d4b" translate="yes" xml:space="preserve">
          <source>Of note, only the parameters and the return type make up the function type. Captured variables are not reflected in the type. In effect, captured variables are part of the &amp;ldquo;hidden state&amp;rdquo; of any function and do not make up its API.</source>
          <target state="translated">注目に値するのは、パラメーターと戻り値の型だけが関数型を構成することです。キャプチャされた変数はタイプに反映されません。実際には、キャプチャされた変数は関数の「隠された状態」の一部であり、そのAPIを構成しません。</target>
        </trans-unit>
        <trans-unit id="58d8c4b2203739a560ee5629e213ae51b2e9cc9a" translate="yes" xml:space="preserve">
          <source>Offers a way to configure the root directory for where declaration files are emitted.</source>
          <target state="translated">宣言ファイルを出力するルートディレクトリを設定する方法を提供します。</target>
        </trans-unit>
        <trans-unit id="4d23057a19f87b1d7a3f861f468248c8e5a5974a" translate="yes" xml:space="preserve">
          <source>Official TypeScript NuGet package</source>
          <target state="translated">公式TypeScript NuGetパッケージ</target>
        </trans-unit>
        <trans-unit id="a342b6bea0bb720b9577de62cca20c2743aa540e" translate="yes" xml:space="preserve">
          <source>Often a project has multiple output targets, e.g. &lt;code&gt;ES5&lt;/code&gt; and &lt;code&gt;ES2015&lt;/code&gt;, debug and production or &lt;code&gt;CommonJS&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt;; Just a few configuration options change between these two targets, and maintaining multiple &lt;code&gt;tsconfig.json&lt;/code&gt; files can be a hassle.</source>
          <target state="translated">多くの場合、プロジェクトには、 &lt;code&gt;ES5&lt;/code&gt; や &lt;code&gt;ES2015&lt;/code&gt; などの複数の出力ターゲット、デバッグと本番、または &lt;code&gt;CommonJS&lt;/code&gt; と &lt;code&gt;System&lt;/code&gt; があります。これら2つのターゲット間で変更される構成オプションはほんのわずかであり、複数の &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを維持するのは面倒な場合があります。</target>
        </trans-unit>
        <trans-unit id="0d6fe7c72174392511bd9351eaea580b26d61ce5" translate="yes" xml:space="preserve">
          <source>Often in Node.js applications a &lt;code&gt;.json&lt;/code&gt; is needed. With TypeScript 2.9, &lt;code&gt;--resolveJsonModule&lt;/code&gt; allows for importing, extracting types from and generating &lt;code&gt;.json&lt;/code&gt; files.</source>
          <target state="translated">多くの場合、Node.jsアプリケーションでは &lt;code&gt;.json&lt;/code&gt; が必要です。TypeScript 2.9では、 &lt;code&gt;--resolveJsonModule&lt;/code&gt; 使用して、 &lt;code&gt;.json&lt;/code&gt; ファイルのインポート、タイプの抽出、および.jsonファイルの生成を行うことができます。</target>
        </trans-unit>
        <trans-unit id="c504b6f49a2c17cd30c9562020e80d82bcb972da" translate="yes" xml:space="preserve">
          <source>Often modules extend other modules, and partially expose some of their features. A re-export does not import it locally, or introduce a local variable.</source>
          <target state="translated">多くの場合、モジュールは他のモジュールを拡張し、その機能の一部を部分的に公開しています。再エクスポートでは、ローカルにインポートしたり、ローカル変数を導入したりすることはありません。</target>
        </trans-unit>
        <trans-unit id="7ca1979392492f5b243f43458b409b3671c295fb" translate="yes" xml:space="preserve">
          <source>Often there are external source files in your project that may not be authored in TypeScript. Alternatively, you might be in the middle of converting a JS code base into TS, but still want to bundle all your JS code into a single file with the output of your new TS code.</source>
          <target state="translated">プロジェクト内には、TypeScriptでオーサリングされていない外部ソースファイルが存在することがよくあります。あるいは、JS コードベースを TS に変換している最中であっても、すべての JS コードを 1 つのファイルにまとめて、新しい TS コードの出力と一緒に出力したい場合もあるでしょう。</target>
        </trans-unit>
        <trans-unit id="5dd8eb55cce46da17a5fd56794f37ca6d1bdbaaf" translate="yes" xml:space="preserve">
          <source>Often you will need to extend functionality on a module. A common JS pattern is to augment the original object with &lt;em&gt;extensions&lt;/em&gt;, similar to how JQuery extensions work. As we&amp;rsquo;ve mentioned before, modules do not &lt;em&gt;merge&lt;/em&gt; like global namespace objects would. The recommended solution is to &lt;em&gt;not&lt;/em&gt; mutate the original object, but rather export a new entity that provides the new functionality.</source>
          <target state="translated">多くの場合、モジュールの機能を拡張する必要があります。一般的なJSパターンは、JQuery拡張機能の動作と同様に、元のオブジェクトを&lt;em&gt;拡張機能&lt;/em&gt;で拡張することです。前に述べたように、モジュールはグローバル名前空間オブジェクトのように&lt;em&gt;マージされ&lt;/em&gt;ません。推奨される解決策は、元のオブジェクトを変更&lt;em&gt;せず&lt;/em&gt;、新しい機能を提供する新しいエンティティをエクスポートすることです。</target>
        </trans-unit>
        <trans-unit id="3cd64adc89519f486491a6325593966cd9fc3e61" translate="yes" xml:space="preserve">
          <source>Omit&amp;lt;T,K&amp;gt;</source>
          <target state="translated">Omit&amp;lt;T,K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="92df791023a2af27d1199c4ac1986b7a67686b3d" translate="yes" xml:space="preserve">
          <source>OmitThisParameter</source>
          <target state="translated">OmitThisParameter</target>
        </trans-unit>
        <trans-unit id="a82c9a0a2eb97497a86656e3460a340f586d18ec" translate="yes" xml:space="preserve">
          <source>On a single line:</source>
          <target state="translated">単線で。</target>
        </trans-unit>
        <trans-unit id="82aef786e3f0d107d8d394b8c34887545af6ea56" translate="yes" xml:space="preserve">
          <source>On multiple lines:</source>
          <target state="translated">複数行で</target>
        </trans-unit>
        <trans-unit id="b121f75269ef9070c6142e71c944032a79d56440" translate="yes" xml:space="preserve">
          <source>On operating systems like Linux, TypeScript installs directory watchers (as opposed to file watchers) on &lt;code&gt;node_modules&lt;/code&gt; and many of its subdirectories to detect changes in dependencies. This is because the number of available file watchers is often eclipsed by the of files in &lt;code&gt;node_modules&lt;/code&gt;, whereas there are way fewer directories to track.</source>
          <target state="translated">Linuxなどのオペレーティングシステムでは、TypeScriptは（ファイルウォッチャーではなく）ディレクトリウォッチャーを &lt;code&gt;node_modules&lt;/code&gt; とそのサブディレクトリの多くにインストールして、依存関係の変化を検出します。これは、使用可能なファイルウォッチャーの数が、 &lt;code&gt;node_modules&lt;/code&gt; 内のファイルの数によって上回っていることが多いのに対し、追跡するディレクトリがはるかに少ないためです。</target>
        </trans-unit>
        <trans-unit id="74944d3dcee80b1604d42865751a7ceaa698e35d" translate="yes" xml:space="preserve">
          <source>On the last line of the snippet you can see that even assigning the entire &lt;code&gt;ReadonlyArray&lt;/code&gt; back to a normal array is illegal. You can still override it with a type assertion, though:</source>
          <target state="translated">最後の行に、あなたも全体に割り当てることがわかりますスニペット &lt;code&gt;ReadonlyArray&lt;/code&gt; の通常の配列に戻すことは違法です。ただし、型アサーションを使用してオーバーライドすることもできます。</target>
        </trans-unit>
        <trans-unit id="50c6272b337ca96a2387d10cc66c11dc4b62bb58" translate="yes" xml:space="preserve">
          <source>On the organization front, namespaces are handy for grouping together logically-related objects and types in the global scope. For example, in C#, you&amp;rsquo;re going to find all the collection types in System.Collections. By organizing our types into hierarchical namespaces, we provide a good &amp;ldquo;discovery&amp;rdquo; experience for users of those types. Modules, on the other hand, are already present in a file system, necessarily. We have to resolve them by path and filename, so there&amp;rsquo;s a logical organization scheme for us to use. We can have a /collections/generic/ folder with a list module in it.</source>
          <target state="translated">組織の面では、名前空間は、論理的に関連するオブジェクトとタイプをグローバルスコープでグループ化するのに便利です。たとえば、C＃では、System.Collectionsですべてのコレクション型を検索します。タイプを階層的な名前空間に編成することにより、これらのタイプのユーザーに優れた「発見」エクスペリエンスを提供します。一方、モジュールはすでにファイルシステムにすでに存在しています。それらをパスとファイル名で解決する必要があるため、使用する論理的な編成スキームがあります。/ collections / generic /フォルダーにリストモジュールを含めることができます。</target>
        </trans-unit>
        <trans-unit id="b64cb02da6becca0ce8ee30f0556e39a4da2ddd8" translate="yes" xml:space="preserve">
          <source>On the other hand, if you can&amp;rsquo;t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.</source>
          <target state="translated">一方、インターフェースで形状を表現できず、共用体またはタプル型を使用する必要がある場合は、通常、型エイリアスが適しています。</target>
        </trans-unit>
        <trans-unit id="c26cd5caaa2a12259da3b89ce4e19ad33c03509f" translate="yes" xml:space="preserve">
          <source>On the other hand, methods like &lt;code&gt;forEach&lt;/code&gt; will now be callable, but under &lt;code&gt;noImplicitAny&lt;/code&gt; there may be some issues.</source>
          <target state="translated">一方、 &lt;code&gt;forEach&lt;/code&gt; などのメソッドは呼び出し可能になりますが、 &lt;code&gt;noImplicitAny&lt;/code&gt; ではいくつかの問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="5e243af120900864262b36ccd9ddf3da385c8c6b" translate="yes" xml:space="preserve">
          <source>Once defined, we can use this function type interface like we would other interfaces. Here, we show how you can create a variable of a function type and assign it a function value of the same type.</source>
          <target state="translated">一度定義してしまえば、この関数型インターフェースを他のインターフェースと同じように使うことができます。ここでは、関数型の変数を作成し、同じ型の関数値を代入する方法を示します。</target>
        </trans-unit>
        <trans-unit id="92950c589178fe64abd972f4ad963eddae26cb96" translate="yes" xml:space="preserve">
          <source>Once the class type is established, the instance type is determined by the union of the return types of the class type&amp;rsquo;s construct or call signatures (whichever is present). So again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function.</source>
          <target state="translated">クラスタイプが確立されると、インスタンスタイプは、クラスタイプのコンストラクトまたはコールシグネチャ（存在する方）の戻りタイプの和集合によって決定されます。つまり、ES6クラスの場合、インスタンスタイプはそのクラスのインスタンスのタイプであり、ファクトリ関数の場合は、関数から返される値のタイプになります。</target>
        </trans-unit>
        <trans-unit id="b659e74e17ccfc36ea3671d29e4bcfb99bcddcac" translate="yes" xml:space="preserve">
          <source>Once there are multiple files involved, we&amp;rsquo;ll need to make sure all of the compiled code gets loaded. There are two ways of doing this.</source>
          <target state="translated">複数のファイルが含まれるようになったら、コンパイルされたすべてのコードが読み込まれるようにする必要があります。これを行うには2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="1344250aecff00dcfaf8dcd7ebd24a106e1cf310" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:</source>
          <target state="translated">汎用的な識別関数を作成したら、2つの方法のいずれかで呼び出すことができます。最初の方法は、type引数を含むすべての引数を関数に渡すことです。</target>
        </trans-unit>
        <trans-unit id="efd9fd3ef569813fe54f40f7a5348da23bd676a1" translate="yes" xml:space="preserve">
          <source>Once you start thinking of types as sets, certain operations become very natural. For example, in C#, it&amp;rsquo;s awkward to pass around a value that is &lt;em&gt;either&lt;/em&gt; a &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt;, because there isn&amp;rsquo;t a single type that represents this sort of value.</source>
          <target state="translated">タイプをセットとして考え始めると、特定の操作は非常に自然になります。たとえば、C＃では、この種の値を表す単一の型がないため、 &lt;code&gt;string&lt;/code&gt; または &lt;code&gt;int&lt;/code&gt; の&lt;em&gt;いずれかで&lt;/em&gt;ある値を渡すのは厄介です。</target>
        </trans-unit>
        <trans-unit id="cd09b9672aef2e12094c6286dae7bf22bea682c2" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;re feeling comfortable, you can come back to read &lt;a href=&quot;typescript-in-5-minutes&quot;&gt;TypeScript for JavaScript Programmers&lt;/a&gt;, then start on &lt;a href=&quot;intro&quot;&gt;the handbook&lt;/a&gt; or explore the &lt;a href=&quot;https://www.typescriptlang.org/play#show-examples&quot;&gt;Playground examples&lt;/a&gt;.</source>
          <target state="translated">快適になったら&lt;a href=&quot;typescript-in-5-minutes&quot;&gt;、JavaScriptプログラマー向けのTypeScript&lt;/a&gt;を読んでから&lt;a href=&quot;intro&quot;&gt;、ハンドブック&lt;/a&gt;から始めるか、&lt;a href=&quot;https://www.typescriptlang.org/play#show-examples&quot;&gt;Playgroundの例を&lt;/a&gt;調べてください。</target>
        </trans-unit>
        <trans-unit id="1f601e0447efc6c6f5c004e85bc2178722596428" translate="yes" xml:space="preserve">
          <source>One advantage of this is that the callable constructor pattern can be easily expressed while also allowing namespaces to merge with these declarations (since &lt;code&gt;var&lt;/code&gt; declarations can&amp;rsquo;t merge with &lt;code&gt;namespace&lt;/code&gt;s).</source>
          <target state="translated">これの利点の1つは、呼び出し可能なコンストラクターパターンを簡単に表現できると同時に、名前空間をこれらの宣言とマージできることです（ &lt;code&gt;var&lt;/code&gt; 宣言は &lt;code&gt;namespace&lt;/code&gt; s とマージできないため）。</target>
        </trans-unit>
        <trans-unit id="07140e34d3c9cf651017285b583d3f868d3d8fae" translate="yes" xml:space="preserve">
          <source>One common task is to take an existing type and make each of its properties entirely optional. Let&amp;rsquo;s say we have a &lt;code&gt;Person&lt;/code&gt;:</source>
          <target state="translated">一般的なタスクの1つは、既存の型を取り、その各プロパティを完全にオプションにすることです。 &lt;code&gt;Person&lt;/code&gt; があるとしましょう：</target>
        </trans-unit>
        <trans-unit id="11091369cf849b83900d010b927727e1dc480d7a" translate="yes" xml:space="preserve">
          <source>One difference from the prior example is that each derived class that contains a constructor function &lt;em&gt;must&lt;/em&gt; call &lt;code&gt;super()&lt;/code&gt; which will execute the constructor of the base class. What&amp;rsquo;s more, before we &lt;em&gt;ever&lt;/em&gt; access a property on &lt;code&gt;this&lt;/code&gt; in a constructor body, we &lt;em&gt;have&lt;/em&gt; to call &lt;code&gt;super()&lt;/code&gt;. This is an important rule that TypeScript will enforce.</source>
          <target state="translated">前の例との1つの違いは、コンストラクター関数を含む各派生クラスは、基本クラスのコンストラクターを実行する &lt;code&gt;super()&lt;/code&gt; を呼び出す&lt;em&gt;必要&lt;/em&gt;があることです。私たちは前に、より多くの何&lt;em&gt;これまで&lt;/em&gt;のプロパティにアクセス &lt;code&gt;this&lt;/code&gt; コンストラクタ本体に、私たちが&lt;em&gt;持って&lt;/em&gt;コールする &lt;code&gt;super()&lt;/code&gt; 。これはTypeScriptが適用する重要なルールです。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e676ef27b983655b305e7201bc44df325b250ac1" translate="yes" xml:space="preserve">
          <source>One difference is that interfaces create a new name that is used everywhere. Type aliases don&amp;rsquo;t create a new name &amp;mdash; for instance, error messages won&amp;rsquo;t use the alias name. In the code below, hovering over &lt;code&gt;interfaced&lt;/code&gt; in an editor will show that it returns an &lt;code&gt;Interface&lt;/code&gt;, but will show that &lt;code&gt;aliased&lt;/code&gt; returns object literal type.</source>
          <target state="translated">1つの違いは、インターフェイスはどこでも使用される新しい名前を作成することです。タイプエイリアスは新しい名前を作成しません&amp;mdash;たとえば、エラーメッセージはエイリアス名を使用しません。以下のコードでは、カーソルを合わせる &lt;code&gt;interfaced&lt;/code&gt; が返されることを示すであろうエディタに &lt;code&gt;Interface&lt;/code&gt; が、その表示され &lt;code&gt;aliased&lt;/code&gt; 戻るリテラル型オブジェクト。</target>
        </trans-unit>
        <trans-unit id="4a3dab7aa9f91e5908fc981f84a1f4366d2c7377" translate="yes" xml:space="preserve">
          <source>One exception to this rule is specialized signatures. If a signature has a parameter whose type is a &lt;em&gt;single&lt;/em&gt; string literal type (e.g. not a union of string literals), then it will be bubbled toward the top of its merged overload list.</source>
          <target state="translated">このルールの1つの例外は、特殊な署名です。シグネチャのタイプが&lt;em&gt;単一の&lt;/em&gt;文字列リテラルタイプ（たとえば、文字列リテラルの和集合ではない）のパラメーターがある場合、マージされたオーバーロードリストの先頭に向かってバブリングされます。</target>
        </trans-unit>
        <trans-unit id="344276576132d21b818f4ba76034843580074fbf" translate="yes" xml:space="preserve">
          <source>One final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since &lt;code&gt;squareOptions&lt;/code&gt; won&amp;rsquo;t undergo excess property checks, the compiler won&amp;rsquo;t give you an error.</source>
          <target state="translated">少し意外かもしれませんが、これらのチェックを回避する最後の方法の1つは、オブジェクトを別の変数に割り当てることです &lt;code&gt;squareOptions&lt;/code&gt; は過剰なプロパティチェックを受けないため、コンパイラーはエラーを出しません。</target>
        </trans-unit>
        <trans-unit id="42cbeda6b484653b931fc5901c6ad7cbbe7d3da4" translate="yes" xml:space="preserve">
          <source>One great benefit of this is that you&amp;rsquo;ll see &lt;em&gt;way fewer&lt;/em&gt; implicit &lt;code&gt;any&lt;/code&gt; errors when running with &lt;code&gt;--noImplicitAny&lt;/code&gt;. Implicit &lt;code&gt;any&lt;/code&gt; errors are only reported when the compiler is unable to know the type of a variable without a type annotation.</source>
          <target state="translated">これの一つの大きな利点は、あなたが見るだろうということで&lt;em&gt;仕方少ない&lt;/em&gt;暗黙の &lt;code&gt;any&lt;/code&gt; と実行しているときにエラー &lt;code&gt;--noImplicitAny&lt;/code&gt; 。暗黙的 &lt;code&gt;any&lt;/code&gt; エラーは、コンパイラーが型注釈なしで変数の型を認識できない場合にのみ報告されます。</target>
        </trans-unit>
        <trans-unit id="0e93e8c643fb4e61579636fbf572b596e0286726" translate="yes" xml:space="preserve">
          <source>One important difference between ambient and non-ambient enums is that, in regular enums, members that don&amp;rsquo;t have an initializer will be considered constant if its preceding enum member is considered constant. In contrast, an ambient (and non-const) enum member that does not have initializer is &lt;em&gt;always&lt;/em&gt; considered computed.</source>
          <target state="translated">アンビエント列挙型と非アンビエント列挙型の重要な違いの1つは、通常の列挙型では、初期化子を持たないメンバーは、先行する列挙型メンバーが定数と見なされた場合、定数と見なされることです。対照的に、初期化子を持たないアンビエント（および非const）列挙型メンバーは&lt;em&gt;常に&lt;/em&gt;計算されたと見なされます。</target>
        </trans-unit>
        <trans-unit id="7b053fca39618dd4a858f60861664a6e5ed2adab" translate="yes" xml:space="preserve">
          <source>One is the &lt;code&gt;as&lt;/code&gt;-syntax:</source>
          <target state="translated">1つは &lt;code&gt;as&lt;/code&gt; -syntaxです。</target>
        </trans-unit>
        <trans-unit id="82aa3486d66599c6818535555fcde271410599f0" translate="yes" xml:space="preserve">
          <source>One of TypeScript&amp;rsquo;s core principles is that type checking focuses on the &lt;em&gt;shape&lt;/em&gt; that values have. This is sometimes called &amp;ldquo;duck typing&amp;rdquo; or &amp;ldquo;structural subtyping&amp;rdquo;. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.</source>
          <target state="translated">TypeScriptのコア原則の1つは、型チェックが値の&lt;em&gt;形に&lt;/em&gt;焦点を当てることです。これは、「ダックタイピング」または「構造サブタイピング」と呼ばれることもあります。TypeScriptでは、インターフェイスはこれらの型に名前を付ける役割を果たし、コード内のコントラクトやプロジェクト外のコードとのコントラクトを定義する強力な方法です。</target>
        </trans-unit>
        <trans-unit id="c757d0f6603eddb47aa6c55cbe608a6509f704fb" translate="yes" xml:space="preserve">
          <source>One of TypeScript&amp;rsquo;s core principles is that type checking focuses on the &lt;em&gt;shape&lt;/em&gt; that values have. This is sometimes called &amp;ldquo;duck typing&amp;rdquo; or &amp;ldquo;structural typing&amp;rdquo;.</source>
          <target state="translated">TypeScriptのコア原則の1つは、タイプチェックが値の&lt;em&gt;形状に&lt;/em&gt;焦点を当てることです。これは、「ダックタイピング」または「構造型タイピング」と呼ばれることもあります。</target>
        </trans-unit>
        <trans-unit id="5aea8e823173035ff216b848c6b0d54b8b96fd4c" translate="yes" xml:space="preserve">
          <source>One of the most common uses of interfaces in languages like C# and Java, that of explicitly enforcing that a class meets a particular contract, is also possible in TypeScript.</source>
          <target state="translated">C#やJavaのような言語で最も一般的に使用されているインターフェースの1つである、クラスが特定の契約を満たすことを明示的に強制することは、TypeScriptでも可能です。</target>
        </trans-unit>
        <trans-unit id="bd4f8dfdb26e810e57f23fff74f292ac4a329c2e" translate="yes" xml:space="preserve">
          <source>One or more assignments to &lt;code&gt;window.someName&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window.someName&lt;/code&gt; への1つ以上の割り当て</target>
        </trans-unit>
        <trans-unit id="48a39bde8026af120315f595a3ebaf87946a36c6" translate="yes" xml:space="preserve">
          <source>One style of exporting in CommonJS is to export a function. Because a function is also an object, then extra fields can be added are included in the export.</source>
          <target state="translated">CommonJSでのエクスポートのスタイルの1つは、関数をエクスポートすることです。関数はオブジェクトでもあるので、追加できるフィールドはエクスポートに含まれています。</target>
        </trans-unit>
        <trans-unit id="7eacbc50348f5b3ec9e3e6415d394dd711448525" translate="yes" xml:space="preserve">
          <source>One such example is an object that acts as both a function and an object, with additional properties:</source>
          <target state="translated">そのような例として、関数とオブジェクトの両方として動作し、追加のプロパティを持つオブジェクトがあります。</target>
        </trans-unit>
        <trans-unit id="10e4a65d9bb07088ca61418abc5f5490d598fa30" translate="yes" xml:space="preserve">
          <source>One thing to note is that &lt;code&gt;const&lt;/code&gt; assertions can only be applied immediately on simple literal expressions.</source>
          <target state="translated">注意すべきことの1つは、 &lt;code&gt;const&lt;/code&gt; アサーションは単純なリテラル式にすぐにのみ適用できることです。</target>
        </trans-unit>
        <trans-unit id="165c72846ed1b6318be8972010ccbd2b184d8eb7" translate="yes" xml:space="preserve">
          <source>OneTwoThree.ts</source>
          <target state="translated">OneTwoThree.ts</target>
        </trans-unit>
        <trans-unit id="e8b21c7e76c250574a2ed991e3f5c20b47bb2111" translate="yes" xml:space="preserve">
          <source>Only emit &amp;lsquo;.d.ts&amp;rsquo; declaration files.</source>
          <target state="translated">「.d.ts」宣言ファイルのみを発行します。</target>
        </trans-unit>
        <trans-unit id="7c44d3d53fcf28280aed7f275c80df87912e368d" translate="yes" xml:space="preserve">
          <source>Only emit &lt;code&gt;.d.ts&lt;/code&gt; declaration files.</source>
          <target state="translated">&lt;code&gt;.d.ts&lt;/code&gt; 宣言ファイルのみを発行します。</target>
        </trans-unit>
        <trans-unit id="9c4c4f095c25b9e726d79098915a46e4ea92ff63" translate="yes" xml:space="preserve">
          <source>Open &lt;code&gt;greeter.html&lt;/code&gt; in the browser to run your first simple TypeScript web application!</source>
          <target state="translated">ブラウザで &lt;code&gt;greeter.html&lt;/code&gt; を開いて、最初のシンプルなTypeScript Webアプリケーションを実行します。</target>
        </trans-unit>
        <trans-unit id="e55b8e4dc396172c8a0dbddfe6ab0a7debd51fb3" translate="yes" xml:space="preserve">
          <source>Open &lt;strong&gt;Dependencies &amp;gt; Manage NuGet Packages &amp;gt; Browse.&lt;/strong&gt; Search and install &lt;code&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt; and &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;:</source>
          <target state="translated">[ &lt;strong&gt;依存関係]&amp;gt; [NuGetパッケージの管理]&amp;gt; [参照]を&lt;/strong&gt;開き&lt;strong&gt;ます。&lt;/strong&gt; &lt;code&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt; および &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt; を検索してインストールします。</target>
        </trans-unit>
        <trans-unit id="064cf8a9bba6348e155ce9b3a0d85c1b0a8dcab6" translate="yes" xml:space="preserve">
          <source>Open up your &lt;code&gt;Startup.cs&lt;/code&gt; file and edit your &lt;code&gt;Configure&lt;/code&gt; function to look like this:</source>
          <target state="translated">&lt;code&gt;Startup.cs&lt;/code&gt; ファイルを開き、 &lt;code&gt;Configure&lt;/code&gt; 関数を次のように編集します。</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="e623b1194b11521281fe95cf75df232d30616550" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;--outDir&lt;/code&gt; duplicates the input hierarchy in the output. The compiler computes the root of the input files as the longest common path of all input files; and then uses that to replicate all its substructure in the output.</source>
          <target state="translated">オプション &lt;code&gt;--outDir&lt;/code&gt; は、入力階層を出力に複製します。コンパイラーは、入力ファイルのルートを、すべての入力ファイルの最長共通パスとして計算します。そして、それを使用して、出力内のすべてのサブ構造を複製します。</target>
        </trans-unit>
        <trans-unit id="02e5818137a6801351663f03a49db2886b267ce5" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;catch&lt;/code&gt; clause variables</source>
          <target state="translated">オプションの &lt;code&gt;catch&lt;/code&gt; 句変数</target>
        </trans-unit>
        <trans-unit id="e1a89356c2e4a69562083736c16549a15a67afd8" translate="yes" xml:space="preserve">
          <source>Optional Chaining</source>
          <target state="translated">オプションのチェイニング</target>
        </trans-unit>
        <trans-unit id="7639a6c68ad000bff451144276aba49f18f3a141" translate="yes" xml:space="preserve">
          <source>Optional Global Usage</source>
          <target state="translated">オプションのグローバル使用法</target>
        </trans-unit>
        <trans-unit id="f7c6bcdff008088c9ae3335f40deda7169b35c83" translate="yes" xml:space="preserve">
          <source>Optional Module Loading and Other Advanced Loading Scenarios</source>
          <target state="translated">オプションのモジュールローディングとその他の高度なローディングシナリオ</target>
        </trans-unit>
        <trans-unit id="ccaa37d283bc30bfac0d5a680eadb38cfbad3c49" translate="yes" xml:space="preserve">
          <source>Optional Parameters and Rest Parameters</source>
          <target state="translated">オプションパラメータと残りのパラメータ</target>
        </trans-unit>
        <trans-unit id="b5c1d49a9a0ded62373bc3f019e8b6f2da7391b2" translate="yes" xml:space="preserve">
          <source>Optional Parameters in Callbacks</source>
          <target state="translated">コールバックのオプションパラメータ</target>
        </trans-unit>
        <trans-unit id="17315c7bb52dfa3c7be7c978a030acc2e38d91c1" translate="yes" xml:space="preserve">
          <source>Optional Properties</source>
          <target state="translated">オプションのプロパティ</target>
        </trans-unit>
        <trans-unit id="8daa3a8272df293fc9da3c3073a118094fb29854" translate="yes" xml:space="preserve">
          <source>Optional and Default Parameters</source>
          <target state="translated">オプションとデフォルトのパラメータ</target>
        </trans-unit>
        <trans-unit id="f4d845ae294ad2b99077aef2b25fd789eac70078" translate="yes" xml:space="preserve">
          <source>Optional chaining also includes two other operations. First there&amp;rsquo;s the &lt;em&gt;optional element access&lt;/em&gt; which acts similarly to optional property accesses, but allows us to access non-identifier properties (e.g. arbitrary strings, numbers, and symbols):</source>
          <target state="translated">オプションの連鎖には、他に2つの操作が含まれます。最初に、&lt;em&gt;オプションの&lt;/em&gt;プロパティアクセスと同様に機能する&lt;em&gt;オプションの要素アクセスが&lt;/em&gt;ありますが、識別子以外のプロパティ（たとえば、任意の文字列、数値、記号）にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="e5f644471c553673cd2548869c093cbfbd2425d1" translate="yes" xml:space="preserve">
          <source>Optional chaining is &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/16&quot;&gt;issue #16&lt;/a&gt; on our issue tracker. For context, there have been over 23,000 issues on the TypeScript issue tracker since then.</source>
          <target state="translated">オプションの連鎖は、課題トラッカーの&lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/16&quot;&gt;課題＃16&lt;/a&gt;です。コンテキストに関しては、それ以来、TypeScript Issue Trackerには23,000を超える問題があります。</target>
        </trans-unit>
        <trans-unit id="53581f6f206bad7094e8261bd030109f9d53f1b0" translate="yes" xml:space="preserve">
          <source>Optional class properties</source>
          <target state="translated">オプションのクラスプロパティ</target>
        </trans-unit>
        <trans-unit id="d957ddf6e5b65d75752d19d7a9dab595722e5998" translate="yes" xml:space="preserve">
          <source>Optional elements in tuple types</source>
          <target state="translated">タプル型のオプション要素</target>
        </trans-unit>
        <trans-unit id="d86b65de7272239d11bfd100dd6563cfd8eb06e5" translate="yes" xml:space="preserve">
          <source>Optional elements in tuple types.</source>
          <target state="translated">タプル型のオプション要素。</target>
        </trans-unit>
        <trans-unit id="05631f6c888f7c7fded4cab4a643205c9c4a8938" translate="yes" xml:space="preserve">
          <source>Optional parameters and properties</source>
          <target state="translated">オプションのパラメータとプロパティ</target>
        </trans-unit>
        <trans-unit id="a160146910ad98552a493b375e35d6abcb550597" translate="yes" xml:space="preserve">
          <source>Optional parameters and properties automatically have &lt;code&gt;undefined&lt;/code&gt; added to their types, even when their type annotations don&amp;rsquo;t specifically include &lt;code&gt;undefined&lt;/code&gt;. For example, the following two types are identical:</source>
          <target state="translated">オプションのパラメーターとプロパティは、型注釈に特に &lt;code&gt;undefined&lt;/code&gt; が含まれていない場合でも、自動的に &lt;code&gt;undefined&lt;/code&gt; が型に追加されます。たとえば、次の2つのタイプは同じです。</target>
        </trans-unit>
        <trans-unit id="f00301f27003ef54c63e41fcdd1c3d98832e9617" translate="yes" xml:space="preserve">
          <source>Optional properties and methods can now be declared in classes, similar to what is already permitted in interfaces.</source>
          <target state="translated">オプションのプロパティとメソッドは、すでにインターフェイスで許可されているものと同様に、クラスで宣言できるようになりました。</target>
        </trans-unit>
        <trans-unit id="c20ef3af584d28ff7405e7586b97956e1fd873af" translate="yes" xml:space="preserve">
          <source>Optional: Open &lt;code&gt;greeter.ts&lt;/code&gt; in Visual Studio, or copy the code into the TypeScript playground. You can hover over identifiers to see their types. Notice that in some cases these types are inferred automatically for you. Re-type the last line, and see completion lists and parameter help based on the types of the DOM elements. Put your cursor on the reference to the greeter function, and hit F12 to go to its definition. Notice, too, that you can right-click on a symbol and use refactoring to rename it.</source>
          <target state="translated">オプション：Visual Studioで &lt;code&gt;greeter.ts&lt;/code&gt; を開くか、コードをTypeScriptプレイグラウンドにコピーします。識別子にカーソルを合わせると、そのタイプを確認できます。場合によっては、これらのタイプが自動的に推測されることに注意してください。最後の行を再入力し、DOM要素のタイプに基づいて補完リストとパラメーターのヘルプを参照してください。greeter関数への参照にカーソルを置き、F12キーを押してその定義に移動します。また、シンボルを右クリックし、リファクタリングを使用して名前を変更できることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="591ef5ad63bd713e79f598100ad5e204c2091ef1" translate="yes" xml:space="preserve">
          <source>Optionally, a module can wrap one or more modules and combine all their exports using &lt;code&gt;export * from &quot;module&quot;&lt;/code&gt; syntax.</source>
          <target state="translated">オプションで、モジュールは1つ以上のモジュールをラップし、 &lt;code&gt;export * from &quot;module&quot;&lt;/code&gt; 構文を使用してすべてのエクスポートを組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="df58492b3818e56d4c38cba029dab1a47423cc16" translate="yes" xml:space="preserve">
          <source>Or a number:</source>
          <target state="translated">もしくは数字。</target>
        </trans-unit>
        <trans-unit id="c98dcc822443a4b856eb1d3e76f5a1ef879a05c5" translate="yes" xml:space="preserve">
          <source>Or by marking each export individually:</source>
          <target state="translated">または、各エクスポートを個別にマークすることで</target>
        </trans-unit>
        <trans-unit id="81b391e677894347f3d7eaa5c625ce0c39681863" translate="yes" xml:space="preserve">
          <source>Or ignore trailing elements, or other elements:</source>
          <target state="translated">または、末尾の要素などは無視してください。</target>
        </trans-unit>
        <trans-unit id="107058d564aa8aab6bd22eaa786593d0b18cee3f" translate="yes" xml:space="preserve">
          <source>Or other elements:</source>
          <target state="translated">または他の要素。</target>
        </trans-unit>
        <trans-unit id="7896cec1b378bbc6409139052737322d415d7652" translate="yes" xml:space="preserve">
          <source>Or we might want a readonly version:</source>
          <target state="translated">もしくは読み切り版が欲しいかもしれません。</target>
        </trans-unit>
        <trans-unit id="6d64af183927ab37ad7e32252f098d1cc8ff662b" translate="yes" xml:space="preserve">
          <source>Or you can just use the unspecified &lt;code&gt;Function&lt;/code&gt; type:</source>
          <target state="translated">または、未指定の &lt;code&gt;Function&lt;/code&gt; タイプを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="f1ea4c6e412df1aa6cd8260f35271c01fcb8e8a0" translate="yes" xml:space="preserve">
          <source>Or, even manually set all the values in the enum:</source>
          <target state="translated">あるいは、列挙されているすべての値を手動で設定することもできます。</target>
        </trans-unit>
        <trans-unit id="a7041e24ae17e49fcab38c7bb31f06d031308b3f" translate="yes" xml:space="preserve">
          <source>Or, we could describe the identity function using the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target state="translated">または、 &lt;code&gt;any&lt;/code&gt; 型を使用して恒等関数を記述することもできます。</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="bf83d365be04a72bc8a349cc7a86cd0845dccf80" translate="yes" xml:space="preserve">
          <source>Organizing Types</source>
          <target state="translated">整理の種類</target>
        </trans-unit>
        <trans-unit id="62cda73390e4d48b545b79bfcdb477a68054f2e3" translate="yes" xml:space="preserve">
          <source>Other important TypeScript types</source>
          <target state="translated">その他の重要な TypeScript の型</target>
        </trans-unit>
        <trans-unit id="62510ab9b0c9768adbae646ef408d2a62b45617c" translate="yes" xml:space="preserve">
          <source>Other types from Closure also work:</source>
          <target state="translated">クロージャーの他のタイプも動作します。</target>
        </trans-unit>
        <trans-unit id="6c40d3319358591a02a91d9e7d4783872ba163d5" translate="yes" xml:space="preserve">
          <source>Other variants are allowed as well:</source>
          <target state="translated">他の亜種も同様に許可されています。</target>
        </trans-unit>
        <trans-unit id="9840b9a741b28ca4c8860ce6d87a0177a3a2e4c4" translate="yes" xml:space="preserve">
          <source>Otherwise</source>
          <target state="translated">Otherwise</target>
        </trans-unit>
        <trans-unit id="f12741a8f50c8d0742198f4cc7b9b0054355cfbe" translate="yes" xml:space="preserve">
          <source>Otherwise &lt;code&gt;Node&lt;/code&gt;</source>
          <target state="translated">それ以外の場合は &lt;code&gt;Node&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3fdc1e6ff5294bca808cf4bfb8838d0fec37709" translate="yes" xml:space="preserve">
          <source>Otherwise use &lt;code&gt;--keyofStringsOnly&lt;/code&gt; compiler option to disable the new behavior.</source>
          <target state="translated">それ以外の場合は、 &lt;code&gt;--keyofStringsOnly&lt;/code&gt; コンパイラオプションを使用して、新しい動作を無効にします。</target>
        </trans-unit>
        <trans-unit id="7336f1cc92c408cb13dba362d46361683cd3d12c" translate="yes" xml:space="preserve">
          <source>Otherwise, the condition depends on one or more type variables and the conditional type is deferred.</source>
          <target state="translated">そうでなければ、条件は1つ以上の型変数に依存しており、条件型は延期されます。</target>
        </trans-unit>
        <trans-unit id="2fe09ba85c2f62b83a765f71cc1cff43f6cbaef7" translate="yes" xml:space="preserve">
          <source>Otherwise, these functions accept any arguments and will return &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">それ以外の場合、これらの関数は任意の引数を受け入れ、次を返し &lt;code&gt;any&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9fd652f329cdb87b5184f532624c12babcba184a" translate="yes" xml:space="preserve">
          <source>Otherwise, we assume that you&amp;rsquo;re already using &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; with &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">それ以外の場合は、&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npmで&lt;/a&gt;&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;をすでに使用していると想定します。</target>
        </trans-unit>
        <trans-unit id="6a8d8f3092b4cff717b9df2b61723845c6880cb0" translate="yes" xml:space="preserve">
          <source>Otherwise, we recommend submitting the types to DefinitelyTyped, which will publish them to the &lt;code&gt;@types&lt;/code&gt; organization on npm.</source>
          <target state="translated">それ以外の場合は、タイプをDefinitelyTypedに送信することをお勧めします。これにより、npmで &lt;code&gt;@types&lt;/code&gt; 組織にタイプが公開されます。</target>
        </trans-unit>
        <trans-unit id="784cfa9d141a3fe82c06f16ad3a9456778056b89" translate="yes" xml:space="preserve">
          <source>Our First Interface</source>
          <target state="translated">最初のインターフェイス</target>
        </trans-unit>
        <trans-unit id="59c2ed6506b42cf80836ee63241f17d49a77bfd7" translate="yes" xml:space="preserve">
          <source>Our package exposes declarations from each of those, so any user of our &lt;code&gt;browserify-typescript-extension&lt;/code&gt; package needs to have these dependencies as well. For that reason, we used &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; and not &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt;, because otherwise our consumers would have needed to manually install those packages. If we had just written a command line application and not expected our package to be used as a library, we might have used &lt;code&gt;devDependencies&lt;/code&gt;.</source>
          <target state="translated">私たちのパッケージはそれらのそれぞれからの宣言を公開しているので、 &lt;code&gt;browserify-typescript-extension&lt;/code&gt; パッケージのすべてのユーザーはこれらの依存関係も持つ必要があります。そのため、 &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; ではなく &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; を使用しました。それ以外の場合、コンシューマーはこれらのパッケージを手動でインストールする必要があったためです。コマンドラインアプリケーションを作成したばかりで、パッケージがライブラリとして使用されることを期待していない場合は、 &lt;code&gt;devDependencies&lt;/code&gt; を使用した可能性があります。</target>
        </trans-unit>
        <trans-unit id="9be54203007d8d30f26947bb7d7851872869089d" translate="yes" xml:space="preserve">
          <source>Out - &lt;code&gt;out&lt;/code&gt;</source>
          <target state="translated">アウト- &lt;code&gt;out&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcdf8d59b6859bfc492a315ea8318c5d9803cadf" translate="yes" xml:space="preserve">
          <source>Out Dir - &lt;code&gt;outDir&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;outDir&lt;/code&gt; - outDir</target>
        </trans-unit>
        <trans-unit id="27a751e953fed78cf12f40a39506ec48371ed775" translate="yes" xml:space="preserve">
          <source>Out File - &lt;code&gt;outFile&lt;/code&gt;</source>
          <target state="translated">アウトファイル &lt;code&gt;outFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="914f3908b7a344c5f4fb4fdf698695b9d2d20039" translate="yes" xml:space="preserve">
          <source>Output File Extension</source>
          <target state="translated">出力ファイル拡張子</target>
        </trans-unit>
        <trans-unit id="b1a5505b0f802d6cf6a89204887e3eae4eb65f9a" translate="yes" xml:space="preserve">
          <source>Output directory for generated declaration files.</source>
          <target state="translated">生成された宣言ファイルの出力ディレクトリ。</target>
        </trans-unit>
        <trans-unit id="174bd26cf8c350d1ca94d82023ef88cff0353faa" translate="yes" xml:space="preserve">
          <source>Output generation</source>
          <target state="translated">出力生成</target>
        </trans-unit>
        <trans-unit id="564d5d5acb36c72c6328a222a0d5721ff6fd4eb9" translate="yes" xml:space="preserve">
          <source>Outside of &lt;code&gt;.tsx&lt;/code&gt; files, the angle bracket assertion syntax can also be used.</source>
          <target state="translated">&lt;code&gt;.tsx&lt;/code&gt; ファイルの外では、山かっこアサーション構文も使用できます。</target>
        </trans-unit>
        <trans-unit id="c9668372e49b3da9f21e77e4a98e554bc74a9a36" translate="yes" xml:space="preserve">
          <source>Over 20 years after its introduction to the programming community, JavaScript is now one of the most widespread cross-platform languages ever created. Starting as a small scripting language for adding trivial interactivity to webpages, JavaScript has grown to be a language of choice for both frontend and backend applications of every size. While the size, scope, and complexity of programs written in JavaScript has grown exponentially, the ability of the JavaScript language to express the relationships between different units of code has not. Combined with JavaScript&amp;rsquo;s rather peculiar runtime semantics, this mismatch between language and program complexity has made JavaScript development a difficult task to manage at scale.</source>
          <target state="translated">プログラミングコミュニティに導入されてから20年以上が経ち、JavaScriptは現在、これまでに作成された中で最も普及しているクロスプラットフォーム言語の1つです。JavaScriptは、Webページに簡単な双方向性を追加するための小さなスクリプト言語として始まり、あらゆるサイズのフロントエンドアプリケーションとバックエンドアプリケーションの両方に最適な言語に成長しました。JavaScriptで記述されたプログラムのサイズ、範囲、および複雑さは指数関数的に増加しましたが、JavaScript言語が異なるコード単位間の関係を表現する能力は増加していません。JavaScriptのかなり独特なランタイムセマンティクスと組み合わせると、言語とプログラムの複雑さの間のこの不一致により、JavaScript開発を大規模に管理するのが困難なタスクになりました。</target>
        </trans-unit>
        <trans-unit id="fcc1811db5df29bd6fe9b10089bc778dd03521da" translate="yes" xml:space="preserve">
          <source>Overall Structure</source>
          <target state="translated">全体構造</target>
        </trans-unit>
        <trans-unit id="0774d17a127371d4945391cdeb1d6747883f0446" translate="yes" xml:space="preserve">
          <source>Overloaded Function</source>
          <target state="translated">オーバーロード機能</target>
        </trans-unit>
        <trans-unit id="b8ed2ea3bd4ec728b7aa2051fa7a407dc7fb10f0" translate="yes" xml:space="preserve">
          <source>Overloaded Functions</source>
          <target state="translated">過負荷機能</target>
        </trans-unit>
        <trans-unit id="ec5878dd8d899636943fffee6342d476f6713cb3" translate="yes" xml:space="preserve">
          <source>Overloads</source>
          <target state="translated">Overloads</target>
        </trans-unit>
        <trans-unit id="cc20e1a304c06340ae63ba26a34364808dafd65d" translate="yes" xml:space="preserve">
          <source>Overloads and Callbacks</source>
          <target state="translated">オーバーロードとコールバック</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="3db8119e7d2abacd7ddc5a64f7223117366fcdc7" translate="yes" xml:space="preserve">
          <source>Package.json</source>
          <target state="translated">Package.json</target>
        </trans-unit>
        <trans-unit id="0577f98176563373436836dd571634165655bf7e" translate="yes" xml:space="preserve">
          <source>Packages under the &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt; organization are published automatically from &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; using the &lt;a href=&quot;https://github.com/Microsoft/types-publisher&quot;&gt;types-publisher tool&lt;/a&gt;. To get your declarations published as an @types package, please submit a pull request to &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;https://github.com/DefinitelyTyped/DefinitelyTyped&lt;/a&gt;. You can find more details in the &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;組織のパッケージは、&lt;a href=&quot;https://github.com/Microsoft/types-publisher&quot;&gt;types-publisherツール&lt;/a&gt;を使用して&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;から自動的に公開されます。宣言を@typesパッケージとして公開するには、プルリクエストを&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;https://github.com/DefinitelyTyped/DefinitelyTypedに&lt;/a&gt;送信してください。詳細については、&lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;投稿ガイドラインページをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="84bd5a555866968aa5aa6d7b7d92dc740334b9d1" translate="yes" xml:space="preserve">
          <source>Packages under the &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt; organization are published automatically from &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; using the &lt;a href=&quot;https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/publisher&quot;&gt;types-publisher tool&lt;/a&gt;. To get your declarations published as an @types package, please submit a pull request to &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;. You can find more details in the &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;組織のパッケージは、&lt;a href=&quot;https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/publisher&quot;&gt;types-publisherツール&lt;/a&gt;を使用して&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;から自動的に公開されます。宣言を@typesパッケージとして公開するには、&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTypedに&lt;/a&gt;プルリクエストを送信してください。詳細については、&lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;投稿ガイドラインのページをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c05990a1953dff830b4e694fd34e78ad2c4e758" translate="yes" xml:space="preserve">
          <source>Packaging dependent declarations</source>
          <target state="translated">パッケージ化依存宣言</target>
        </trans-unit>
        <trans-unit id="f6dd7817ec1cd36abd644cfdc46d670053a1cd83" translate="yes" xml:space="preserve">
          <source>Parameter Decorators</source>
          <target state="translated">パラメータデコレーター</target>
        </trans-unit>
        <trans-unit id="2952d35fe7891ee81c4489bd1bb320a48758d659" translate="yes" xml:space="preserve">
          <source>Parameter properties</source>
          <target state="translated">パラメータのプロパティ</target>
        </trans-unit>
        <trans-unit id="23d76447f27a661de3ededbf433067f3b57aada4" translate="yes" xml:space="preserve">
          <source>Parameter properties are declared by prefixing a constructor parameter with an accessibility modifier or &lt;code&gt;readonly&lt;/code&gt;, or both. Using &lt;code&gt;private&lt;/code&gt; for a parameter property declares and initializes a private member; likewise, the same is done for &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, and &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target state="translated">パラメータプロパティは、コンストラクタパラメータの前にアクセシビリティ修飾子または &lt;code&gt;readonly&lt;/code&gt; 、あるいはその両方を付けることによって宣言されます。パラメータプロパティに &lt;code&gt;private&lt;/code&gt; を使用すると、プライベートメンバーが宣言および初期化されます。同様に、同じことが &lt;code&gt;public&lt;/code&gt; 、 &lt;code&gt;protected&lt;/code&gt; 、および &lt;code&gt;readonly&lt;/code&gt; でも行われます。</target>
        </trans-unit>
        <trans-unit id="a5861a8dac7bb4d916bedc720f28896beb64d2da" translate="yes" xml:space="preserve">
          <source>Parameters declaration with names starting with &lt;code&gt;_&lt;/code&gt; are exempt from the unused parameter checking. e.g.:</source>
          <target state="translated">名前が &lt;code&gt;_&lt;/code&gt; で始まるパラメーター宣言は、未使用のパラメーターチェックから除外されます。例えば：</target>
        </trans-unit>
        <trans-unit id="1d5eb18b61aab05bdced59d235a80d553895747d" translate="yes" xml:space="preserve">
          <source>Parameters&amp;lt;T&amp;gt;</source>
          <target state="translated">Parameters&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="671f3fae2448bb236314a1b80701d38996bd864d" translate="yes" xml:space="preserve">
          <source>Parse in strict mode and emit &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; for each source file</source>
          <target state="translated">strictモードで解析し、各ソースファイルに対して &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; を発行します</target>
        </trans-unit>
        <trans-unit id="fb8f88af978dfcbfd9d18606d5785e56e50c08a4" translate="yes" xml:space="preserve">
          <source>ParseIntBasedZipCodeValidator.ts</source>
          <target state="translated">ParseIntBasedZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="81409c19eb37440fe5909d317bb07700285e2cd5" translate="yes" xml:space="preserve">
          <source>Parses all the code in strict mode.</source>
          <target state="translated">すべてのコードを strict モードで解析します。</target>
        </trans-unit>
        <trans-unit id="f6713be85ff8a869b13ef23f83e9e25ec5b50fe4" translate="yes" xml:space="preserve">
          <source>Part of the intent with composite projects (&lt;code&gt;tsconfig.json&lt;/code&gt;s with &lt;code&gt;composite&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;) is that references between different projects can be built incrementally. As such, composite projects will &lt;strong&gt;always&lt;/strong&gt; produce &lt;code&gt;.tsbuildinfo&lt;/code&gt; files.</source>
          <target state="translated">複合プロジェクト（ &lt;code&gt;tsconfig.json&lt;/code&gt; で &lt;code&gt;composite&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定）の目的の一部は、異なるプロジェクト間の参照を段階的に構築できることです。そのため、複合プロジェクトは&lt;strong&gt;常に&lt;/strong&gt; &lt;code&gt;.tsbuildinfo&lt;/code&gt; ファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="9baf9fd34f2159270424fe0e47e69d1f478939e6" translate="yes" xml:space="preserve">
          <source>Partial&amp;lt;T&amp;gt;</source>
          <target state="translated">Partial&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b5be6f8582750be194de793f18c152404f2f31a1" translate="yes" xml:space="preserve">
          <source>Pass it an element id string and it will return either &lt;code&gt;HTMLElement&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; . This method introduces one of the most important types, &lt;code&gt;HTMLElement&lt;/code&gt;. It serves as the base interface for every other element interface. For example, the &lt;code&gt;p&lt;/code&gt; variable in the code example is of type &lt;code&gt;HTMLParagraphElement&lt;/code&gt;. Also take note that this method can return &lt;code&gt;null&lt;/code&gt;. This is because the method can&amp;rsquo;t be certain pre-runtime if it will be able to actually find the specified element or not. In the last line of the code snippet, the new &lt;em&gt;optional chaining&lt;/em&gt; operator is used in order to call &lt;code&gt;appendChild&lt;/code&gt;.</source>
          <target state="translated">要素ID文字列を渡すと、 &lt;code&gt;HTMLElement&lt;/code&gt; または &lt;code&gt;null&lt;/code&gt; のいずれかが返されます。このメソッドは、最も重要なタイプの1つである &lt;code&gt;HTMLElement&lt;/code&gt; を導入します。これは、他のすべての要素インターフェイスの基本インターフェイスとして機能します。たとえば、コード例の &lt;code&gt;p&lt;/code&gt; 変数は &lt;code&gt;HTMLParagraphElement&lt;/code&gt; 型です。また、このメソッドは &lt;code&gt;null&lt;/code&gt; を返す可能性があることに注意してください。これは、指定された要素を実際に見つけることができるかどうかをメソッドが実行前に特定できないためです。コードスニペットの最後の行では、 &lt;code&gt;appendChild&lt;/code&gt; を呼び出すために新しい&lt;em&gt;オプションの連鎖&lt;/em&gt;演算子が使用されています。</target>
        </trans-unit>
        <trans-unit id="1acacf2ed7601dbe25241b7869667be2f4398d94" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;--reactNamespace &amp;lt;JSX factory Name&amp;gt;&lt;/code&gt; along with &lt;code&gt;--jsx react&lt;/code&gt; allows for using a different JSX factory from the default &lt;code&gt;React&lt;/code&gt;.</source>
          <target state="translated">渡す &lt;code&gt;--reactNamespace &amp;lt;JSX factory Name&amp;gt;&lt;/code&gt; に沿って &lt;code&gt;--jsx react&lt;/code&gt; デフォルトが異なるJSXファクトリを使用することができます &lt;code&gt;React&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b536ca4bd24891bd16797247b74cf70cb1d7af1" translate="yes" xml:space="preserve">
          <source>Path mapping</source>
          <target state="translated">パスマッピング</target>
        </trans-unit>
        <trans-unit id="a3a3e9569fa3eb5fb1f186e97032bcfd280061ac" translate="yes" xml:space="preserve">
          <source>Paths - &lt;code&gt;paths&lt;/code&gt;</source>
          <target state="translated">パス- &lt;code&gt;paths&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08f69b52b9788ae6bcf8bfd7c8d5cd0f9c96b35d" translate="yes" xml:space="preserve">
          <source>Patterns that are known NOT to be supported</source>
          <target state="translated">サポートされていないことが知られているパターン</target>
        </trans-unit>
        <trans-unit id="3ba5e04e0fb30f6bbbfe6f30b3c6d01934f1ea14" translate="yes" xml:space="preserve">
          <source>Per-file JSX factories</source>
          <target state="translated">ファイル単位の JSX ファクトリ</target>
        </trans-unit>
        <trans-unit id="b69b8b40e240a5b2dde72c51f503be50a498cd27" translate="yes" xml:space="preserve">
          <source>Perform additional checks to ensure that separate compilation (such as with &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function&quot;&gt;&lt;code&gt;transpileModule&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-typescript&quot;&gt;@babel/plugin-transform-typescript&lt;/a&gt;) would be safe.</source>
          <target state="translated">追加のチェックを実行して、個別のコンパイル（&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function&quot;&gt; &lt;code&gt;transpileModule&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-typescript&quot;&gt;@ babel / plugin-transform-typescriptなど&lt;/a&gt;）が安全であることを確認します。</target>
        </trans-unit>
        <trans-unit id="f1dabf49a10166e79b1f29fd393e4de4f943c1fd" translate="yes" xml:space="preserve">
          <source>Performance Improvements</source>
          <target state="translated">パフォーマンスの向上</target>
        </trans-unit>
        <trans-unit id="967f5cced0c55dd5104813d8b961e3e82073447f" translate="yes" xml:space="preserve">
          <source>Pick&amp;lt;T,K&amp;gt;</source>
          <target state="translated">Pick&amp;lt;T,K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7dee95ba04b4d77fd014972959587737b540740a" translate="yes" xml:space="preserve">
          <source>Pitfalls of Namespaces and Modules</source>
          <target state="translated">名前空間とモジュールの落とし穴</target>
        </trans-unit>
        <trans-unit id="b9fa3258f08647142ce462aa1c6002ef1e1b8662" translate="yes" xml:space="preserve">
          <source>Platform specific</source>
          <target state="translated">プラットフォームに特化した</target>
        </trans-unit>
        <trans-unit id="a68eb230823a2defe94e6d3f9718ef2ec069c259" translate="yes" xml:space="preserve">
          <source>Playground</source>
          <target state="translated">Playground</target>
        </trans-unit>
        <trans-unit id="120335d270554865b243af6b51ed8c05b0d29c22" translate="yes" xml:space="preserve">
          <source>Please note that the compiler does not include files that can be possible outputs; e.g. if the input includes &lt;code&gt;index.ts&lt;/code&gt;, then &lt;code&gt;index.d.ts&lt;/code&gt; and &lt;code&gt;index.js&lt;/code&gt; are excluded. In general, having files that differ only in extension next to each other is not recommended.</source>
          <target state="translated">コンパイラには出力の可能性があるファイルは含まれていないことに注意してください。入力が含まれている場合、たとえば &lt;code&gt;index.ts&lt;/code&gt; を、その後、 &lt;code&gt;index.d.ts&lt;/code&gt; と &lt;code&gt;index.js&lt;/code&gt; が除外されています。一般に、拡張子のみが異なるファイルを隣り合わせに配置することはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="4463cb7b6e22fa9c87c1b09f8e8ea07ce2c6475b" translate="yes" xml:space="preserve">
          <source>Please note that this comment only suppresses the error reporting, and we recommend you use this comments &lt;em&gt;very sparingly&lt;/em&gt;.</source>
          <target state="translated">このコメントはエラー報告を抑制するだけであり、このコメントは&lt;em&gt;慎重に&lt;/em&gt;使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0468af199e7e628b9833d4c2499a87be9fef2421" translate="yes" xml:space="preserve">
          <source>Please note that this requires a native &lt;code&gt;Symbol.iterator&lt;/code&gt; or &lt;code&gt;Symbol.iterator&lt;/code&gt; shim at runtime for any non-array values.</source>
          <target state="translated">これには、実行時に配列以外の値のネイティブ &lt;code&gt;Symbol.iterator&lt;/code&gt; または &lt;code&gt;Symbol.iterator&lt;/code&gt; シムが必要であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="562837321f7a755d6cd24864fe1ca99abed6c53c" translate="yes" xml:space="preserve">
          <source>Please note that ts-loader is not the only loader for typescript.</source>
          <target state="translated">ts-loader は typescript 用の唯一のローダーではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="e4743356c30ff06ccc2c2b0526d63f34b220283d" translate="yes" xml:space="preserve">
          <source>Please notice that &lt;code&gt;&quot;paths&quot;&lt;/code&gt; are resolved relative to &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt;. When setting &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; to another value than &lt;code&gt;&quot;.&quot;&lt;/code&gt;, i.e. the directory of &lt;code&gt;tsconfig.json&lt;/code&gt;, the mappings must be changed accordingly. Say, you set &lt;code&gt;&quot;baseUrl&quot;: &quot;./src&quot;&lt;/code&gt; in the above example, then jquery should be mapped to &lt;code&gt;&quot;../node_modules/jquery/dist/jquery&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;paths&quot;&lt;/code&gt; は &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; 基準に解決されることに注意してください。 &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; を &lt;code&gt;&quot;.&quot;&lt;/code&gt; 以外の値に設定する場合。、つまり &lt;code&gt;tsconfig.json&lt;/code&gt; のディレクトリ、それに応じてマッピングを変更する必要があります。たとえば、上記の例で &lt;code&gt;&quot;baseUrl&quot;: &quot;./src&quot;&lt;/code&gt; を設定すると、jqueryは &lt;code&gt;&quot;../node_modules/jquery/dist/jquery&quot;&lt;/code&gt; にマップされます。</target>
        </trans-unit>
        <trans-unit id="1ee1de1fe598e71ad53be227754dfcb283d7c826" translate="yes" xml:space="preserve">
          <source>Plugins - &lt;code&gt;plugins&lt;/code&gt;</source>
          <target state="translated">プラグイン- &lt;code&gt;plugins&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d901da355d2ea7de032bab6160e7791b0cc0d9bd" translate="yes" xml:space="preserve">
          <source>Point-free programming</source>
          <target state="translated">ポイントフリープログラミング</target>
        </trans-unit>
        <trans-unit id="9a6adebfdf8f61c41e82811b81640f526a81d347" translate="yes" xml:space="preserve">
          <source>Point-free programming &amp;mdash; heavy use of currying and function composition &amp;mdash; is possible in JavaScript, but can be verbose. In TypeScript, type inference often fails for point-free programs, so you&amp;rsquo;ll end up specifying type parameters instead of value parameters. The result is so verbose that it&amp;rsquo;s usually better to avoid point-free programming.</source>
          <target state="translated">ポイントフリープログラミング（カリー化と関数合成の多用）はJavaScriptで可能ですが、冗長になる可能性があります。TypeScriptでは、ポイントフリープログラムでは型推論が失敗することが多いため、値パラメーターの代わりに型パラメーターを指定することになります。結果は非常に冗長であるため、通常はポイントフリープログラミングを避ける方がよいでしょう。</target>
        </trans-unit>
        <trans-unit id="ead1b84f2b03206f8601dd6f8465bb1307c87f49" translate="yes" xml:space="preserve">
          <source>Polymorphic &lt;code&gt;this&lt;/code&gt; types</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; タイプの多態性</target>
        </trans-unit>
        <trans-unit id="b7ea292a6c4159dcd9f22585ce812663d7d16f67" translate="yes" xml:space="preserve">
          <source>Polymorphic this types</source>
          <target state="translated">多相的なこのタイプ</target>
        </trans-unit>
        <trans-unit id="7280aa9b126e519bb5acdcab7417841a30bb930a" translate="yes" xml:space="preserve">
          <source>Possible values are:</source>
          <target state="translated">可能な値は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="554e31701ddcf7160047ee9c5af3bc8fa8c6a72a" translate="yes" xml:space="preserve">
          <source>Postfix equals on a property type in an object literal type doesn&amp;rsquo;t specify an optional property:</source>
          <target state="translated">オブジェクトリテラルタイプのプロパティタイプでPostfix equalsはオプションプロパティを指定しません：</target>
        </trans-unit>
        <trans-unit id="ab664bc802e07259299c0ace87c0d6fb9adaa06b" translate="yes" xml:space="preserve">
          <source>Predefined conditional types</source>
          <target state="translated">定義済みの条件タイプ</target>
        </trans-unit>
        <trans-unit id="9eee28bfd739e1debf4d3b892d013537ae16da9f" translate="yes" xml:space="preserve">
          <source>Predicate</source>
          <target state="translated">Predicate</target>
        </trans-unit>
        <trans-unit id="0ca66f1be438badc25b8b5752ef03c58e504484d" translate="yes" xml:space="preserve">
          <source>Prepending a project will include the project&amp;rsquo;s output above the output of the current project. This works for both &lt;code&gt;.js&lt;/code&gt; files and &lt;code&gt;.d.ts&lt;/code&gt; files, and source map files will also be emitted correctly.</source>
          <target state="translated">プロジェクトの先頭に追加すると、現在のプロジェクトの出力の上にプロジェクトの出力が含まれます。これは &lt;code&gt;.js&lt;/code&gt; ファイルと &lt;code&gt;.d.ts&lt;/code&gt; ファイルの両方で機能し、ソースマップファイルも正しく出力されます。</target>
        </trans-unit>
        <trans-unit id="250b55e25eefbff70773c9389bd85b37a64c1d61" translate="yes" xml:space="preserve">
          <source>Preprocessing input files</source>
          <target state="translated">入力ファイルの前処理</target>
        </trans-unit>
        <trans-unit id="eed036e414a34a0c245858652e6d88f14c3faefb" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">Prerequisites</target>
        </trans-unit>
        <trans-unit id="3718a89b87a1c09f9d2b2ab9ae6694d53dd18a75" translate="yes" xml:space="preserve">
          <source>Preserve Const Enums - &lt;code&gt;preserveConstEnums&lt;/code&gt;</source>
          <target state="translated">Const列挙型の &lt;code&gt;preserveConstEnums&lt;/code&gt; -preserveConstEnums</target>
        </trans-unit>
        <trans-unit id="144537ff5fbb1fe2e7112d7a59fca5f0abb8a715" translate="yes" xml:space="preserve">
          <source>Preserve Symlinks - &lt;code&gt;preserveSymlinks&lt;/code&gt;</source>
          <target state="translated">シンボリックリンクを保持- &lt;code&gt;preserveSymlinks&lt;/code&gt; を</target>
        </trans-unit>
        <trans-unit id="43e1ce16ca2c523a57cb24a6559708ada861d29c" translate="yes" xml:space="preserve">
          <source>Preserve Watch Output - &lt;code&gt;preserveWatchOutput&lt;/code&gt;</source>
          <target state="translated">ウォッチ出力の &lt;code&gt;preserveWatchOutput&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1f0d63b565582e80417d45fc9ee92a490e7a966" translate="yes" xml:space="preserve">
          <source>Preserve: &lt;code&gt;&quot;preserve&quot;&lt;/code&gt;</source>
          <target state="translated">保存： &lt;code&gt;&quot;preserve&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7cb4715a3e34715298728de107fabd8f250241bb" translate="yes" xml:space="preserve">
          <source>Prettier &lt;code&gt;--pretty&lt;/code&gt; output</source>
          <target state="translated">Prettier- &lt;code&gt;--pretty&lt;/code&gt; 出力</target>
        </trans-unit>
        <trans-unit id="8875ea5f28b04a1dba3fc41f80791c76ff0b7712" translate="yes" xml:space="preserve">
          <source>Prettier error messages from &lt;code&gt;tsc&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; からのよりきれいなエラーメッセージ</target>
        </trans-unit>
        <trans-unit id="7570791dbea8739420c045a800b27168c94bfd74" translate="yes" xml:space="preserve">
          <source>Pretty - &lt;code&gt;pretty&lt;/code&gt;</source>
          <target state="translated">かなり- &lt;code&gt;pretty&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b0889dea75b7bf162c4dd45848c6ca53d9ef522" translate="yes" xml:space="preserve">
          <source>Preventing Name Conflicts</source>
          <target state="translated">名前の衝突を防ぐ</target>
        </trans-unit>
        <trans-unit id="f3be47e0536b2f1e3942d188698143c3820e4e15" translate="yes" xml:space="preserve">
          <source>Previous versions of this document recommended a way to write mixins where you created both the runtime and type hierarchies separately, then merged them at the end:</source>
          <target state="translated">このドキュメントの以前のバージョンでは、ランタイム階層と型階層を別々に作成し、最後にそれらをマージするというMixinsの書き方を推奨していました。</target>
        </trans-unit>
        <trans-unit id="d3f367a0268c7a11de846832dd78b1be0177bcf5" translate="yes" xml:space="preserve">
          <source>Previously CommonJS/AMD/UMD modules were treated in the same way as ES6 modules, resulting in a couple of problems. Namely:</source>
          <target state="translated">以前のCommonJS/AMD/UMDモジュールは、ES6モジュールと同じように扱われていたため、いくつかの問題が発生していました。すなわち</target>
        </trans-unit>
        <trans-unit id="1d4fe4dbc591edaa8152b6ee157716dc7c7a69dd" translate="yes" xml:space="preserve">
          <source>Previously an error, now supported in TypeScript 1.8. &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; declarations within loops and captured in functions are now emitted to correctly match &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; freshness semantics.</source>
          <target state="translated">以前はエラーでしたが、TypeScript 1.8でサポートされるようになりました。ループ内の &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; 宣言と関数でキャプチャされたものが &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; freshnessセマンティクスに正しく一致するように発行されるようになりました。</target>
        </trans-unit>
        <trans-unit id="d61f97a853643acc2132dd407bb52c28293cf6e2" translate="yes" xml:space="preserve">
          <source>Previously flagged as an invalid flag combination, &lt;code&gt;target: es5&lt;/code&gt; and &amp;lsquo;module: es6&amp;rsquo; is now supported. This should facilitate using ES2015-based tree shakers like &lt;a href=&quot;https://github.com/rollup/rollup&quot;&gt;rollup&lt;/a&gt;.</source>
          <target state="translated">以前は無効なフラグの組み合わせとしてフラグが付けられていましたが、 &lt;code&gt;target: es5&lt;/code&gt; および 'module：es6'がサポートされるようになりました。これは次のようにES2015ベースのツリーシェーカーを使用して促進すべきである&lt;a href=&quot;https://github.com/rollup/rollup&quot;&gt;ロールアップ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="faa74f7ad7771f21799b2755f15db749aa0b46e9" translate="yes" xml:space="preserve">
          <source>Previously generators were only supported if the target is ES6/ES2015 or later. Moreover, constructs that operate on the Iterator protocol, e.g. &lt;code&gt;for..of&lt;/code&gt; were only supported if they operate on arrays for targets below ES6/ES2015.</source>
          <target state="translated">以前のジェネレーターは、ターゲットがES6 / ES2015以降の場合にのみサポートされていました。さらに、 &lt;code&gt;for..of&lt;/code&gt; などのIteratorプロトコルで動作する構成体は、ES6 / ES2015以下のターゲットのアレイで動作する場合にのみサポートされていました。</target>
        </trans-unit>
        <trans-unit id="8d6c2a15e3d095aa407d66625a136a8551aa98ed" translate="yes" xml:space="preserve">
          <source>Previously the type of a &lt;code&gt;for..in&lt;/code&gt; variable is inferred to &lt;code&gt;any&lt;/code&gt;; that allowed the compiler to ignore invalid uses within the &lt;code&gt;for..in&lt;/code&gt; body.</source>
          <target state="translated">以前は、 &lt;code&gt;for..in&lt;/code&gt; 変数の型はanyに推論され &lt;code&gt;any&lt;/code&gt; 。これにより、コンパイラは &lt;code&gt;for..in&lt;/code&gt; 本文内の無効な使用を無視できました。</target>
        </trans-unit>
        <trans-unit id="ebaf09b657b780c25626ff17cb194ecb5fc7de40" translate="yes" xml:space="preserve">
          <source>Previously there were two options:</source>
          <target state="translated">以前は2つの選択肢がありました。</target>
        </trans-unit>
        <trans-unit id="23e202efb0fd224642346517ba263b85cbcde129" translate="yes" xml:space="preserve">
          <source>Previously type &lt;code&gt;{}&lt;/code&gt; was inferred for &lt;code&gt;obj&lt;/code&gt; and the second line subsequently caused an error because &lt;code&gt;obj&lt;/code&gt; would appear to have no properties. That obviously wasn&amp;rsquo;t ideal.</source>
          <target state="translated">以前にタイプ &lt;code&gt;{}&lt;/code&gt; のために推定された &lt;code&gt;obj&lt;/code&gt; 及びため2行目は、その後、エラーの原因となった &lt;code&gt;obj&lt;/code&gt; がない特性を有していないように見えます。それは明らかに理想的ではありませんでした。</target>
        </trans-unit>
        <trans-unit id="6904fbec6e39643bc5d34a20c1cf3e6eba117f94" translate="yes" xml:space="preserve">
          <source>Previously, a non-disciminated union wouldn&amp;rsquo;t have &lt;em&gt;any&lt;/em&gt; excess property checking done on its members, and as a result, the incorrectly typed &lt;code&gt;name&lt;/code&gt; property slipped by.</source>
          <target state="translated">以前は、差別化されていない共用体では、そのメンバー&lt;em&gt;に対して&lt;/em&gt;過剰なプロパティチェックが行われず、その結果、誤って入力された &lt;code&gt;name&lt;/code&gt; プロパティがずれていました。</target>
        </trans-unit>
        <trans-unit id="b72465fae7e40823511074b9719794d968033526" translate="yes" xml:space="preserve">
          <source>Previously, if TypeScript couldn&amp;rsquo;t figure out the type of a variable, it would choose the &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">以前は、TypeScriptが変数の型を判別できなかった場合、 &lt;code&gt;any&lt;/code&gt; 型を選択していました。</target>
        </trans-unit>
        <trans-unit id="ebc73e847f1b3cd8d1dfb14f901fe12098f69eb7" translate="yes" xml:space="preserve">
          <source>Previously, this document details the &lt;code&gt;HTMLElement&lt;/code&gt; interface extends from &lt;code&gt;Element&lt;/code&gt; which extends from &lt;code&gt;Node&lt;/code&gt;. In the DOM API there is a concept of &lt;em&gt;children&lt;/em&gt; elements. For example in the following HTML, the &lt;code&gt;p&lt;/code&gt; tags are children of the &lt;code&gt;div&lt;/code&gt; element</source>
          <target state="translated">以前、このドキュメントでは、 &lt;code&gt;Node&lt;/code&gt; から拡張された &lt;code&gt;Element&lt;/code&gt; から拡張された &lt;code&gt;HTMLElement&lt;/code&gt; インターフェイスについて詳しく説明しました。DOM APIには、&lt;em&gt;子&lt;/em&gt;要素の概念があります。たとえば、次のHTMLでは、 &lt;code&gt;p&lt;/code&gt; タグは &lt;code&gt;div&lt;/code&gt; 要素の子です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9db6c336a1faa6c435e85a6b4d2c798009098564" translate="yes" xml:space="preserve">
          <source>Previously, this structure was rather awkward to work with if you used a single tsconfig file:</source>
          <target state="translated">以前は、単一のtsconfigファイルを使用している場合、この構造は作業しづらいものでした。</target>
        </trans-unit>
        <trans-unit id="4ca4680280d5d8dfe7b7cb9edd9e85d1751a8dc5" translate="yes" xml:space="preserve">
          <source>Print help message.</source>
          <target state="translated">ヘルプメッセージを印刷します。</target>
        </trans-unit>
        <trans-unit id="ae5d509d63bcd9fdd20c4fe9f09a64383b22ba2a" translate="yes" xml:space="preserve">
          <source>Print names of files part of the compilation.</source>
          <target state="translated">コンパイルに含まれるファイル名を表示します。</target>
        </trans-unit>
        <trans-unit id="2c60c8260c586544fdf204a6918f732b286ae58d" translate="yes" xml:space="preserve">
          <source>Print names of files part of the compilation. This is useful when you are not sure that TypeScript has included a file you expected.</source>
          <target state="translated">コンパイルの一部であるファイルの名前を表示します。これは、TypeScriptに期待したファイルが含まれているかどうかわからない場合に便利です。</target>
        </trans-unit>
        <trans-unit id="b896feedfc6257fcbba34c3460737798c67b71a9" translate="yes" xml:space="preserve">
          <source>Print names of generated files part of the compilation to the terminal.</source>
          <target state="translated">コンパイルの一部として生成されたファイル名をターミナルに表示します。</target>
        </trans-unit>
        <trans-unit id="220c873ce1ef6bbe0f0ef43fc4cd6015a80b747a" translate="yes" xml:space="preserve">
          <source>Print names of generated files part of the compilation.</source>
          <target state="translated">コンパイルの一部として生成されたファイルの名前を表示します。</target>
        </trans-unit>
        <trans-unit id="e11fa3aee584489ac6535e0339f143acea43fb5c" translate="yes" xml:space="preserve">
          <source>Print the compiler&amp;rsquo;s version.</source>
          <target state="translated">コンパイラのバージョンを出力します。</target>
        </trans-unit>
        <trans-unit id="23bb025493ad52ae749fb36ab7d38c5792fcafeb" translate="yes" xml:space="preserve">
          <source>Prior to 3.3, building composite projects using &lt;code&gt;--build --watch&lt;/code&gt; actually didn&amp;rsquo;t use this incremental file watching infrastructure. An update in one project under &lt;code&gt;--build --watch&lt;/code&gt; mode would force a full build of that project, rather than determining which files within that project were affected.</source>
          <target state="translated">3.3より前の &lt;code&gt;--build --watch&lt;/code&gt; を使用して複合プロジェクトをビルドする場合、実際にはこの増分ファイル監視インフラストラクチャは使用されませんでした。 &lt;code&gt;--build --watch&lt;/code&gt; モードでの1つのプロジェクトの更新は、そのプロジェクト内のどのファイルが影響を受けたかを判断するのではなく、そのプロジェクトの完全ビルドを強制します。</target>
        </trans-unit>
        <trans-unit id="6a5128736476603248154c428e88c700f0590e6b" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 2.4, in the following example</source>
          <target state="translated">TypeScript 2.4以前では、以下の例では</target>
        </trans-unit>
        <trans-unit id="480d4967754d83dbb3e8d2828c5c21cd16621298" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 2.4, this example would succeed. When relating the types of &lt;code&gt;map&lt;/code&gt;, TypeScript would bidirectionally relate their parameters (i.e. the type of &lt;code&gt;f&lt;/code&gt;). When relating each &lt;code&gt;f&lt;/code&gt;, TypeScript would also bidirectionally relate the type of &lt;em&gt;those&lt;/em&gt; parameters.</source>
          <target state="translated">TypeScript 2.4以前では、この例は成功していました。 &lt;code&gt;map&lt;/code&gt; のタイプを関連付ける場合、TypeScriptはそれらのパラメータを双方向に関連付けます（つまり、 &lt;code&gt;f&lt;/code&gt; のタイプ）。TypeScriptは、各 &lt;code&gt;f&lt;/code&gt; を関連付けるときに、&lt;em&gt;これらの&lt;/em&gt;パラメーターの型を双方向に関連付けます。</target>
        </trans-unit>
        <trans-unit id="9c8599d61f9484e744e8b2658bec61eec3a61688" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 3.8, you can import a type using &lt;code&gt;import&lt;/code&gt;. With TypeScript 3.8, you can import a type using the &lt;code&gt;import&lt;/code&gt; statement, or using &lt;code&gt;import type&lt;/code&gt;.</source>
          <target state="translated">TypeScript 3.8より前は、importを使用して型を &lt;code&gt;import&lt;/code&gt; 。活字体3.8を使用すると、使用してタイプをインポートでき &lt;code&gt;import&lt;/code&gt; 文を、または使用した &lt;code&gt;import type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2ca142f68efb0104a146fa7d73e2068d50895f3" translate="yes" xml:space="preserve">
          <source>Private and Protected Constructors</source>
          <target state="translated">民間および保護された建設業者</target>
        </trans-unit>
        <trans-unit id="f4b81a5cab787b4701243c836cb9e4bed8b1e31d" translate="yes" xml:space="preserve">
          <source>Private and protected members in a class affect their compatibility. When an instance of a class is checked for compatibility, if the target type contains a private member, then the source type must also contain a private member that originated from the same class. Likewise, the same applies for an instance with a protected member. This allows a class to be assignment compatible with its super class, but &lt;em&gt;not&lt;/em&gt; with classes from a different inheritance hierarchy which otherwise have the same shape.</source>
          <target state="translated">クラスのプライベートおよび保護されたメンバーは、それらの互換性に影響します。クラスのインスタンスの互換性をチェックするときに、ターゲットタイプにプライベートメンバーが含まれている場合、ソースタイプには、同じクラスから派生したプライベートメンバーも含まれている必要があります。同様に、保護されたメンバーを持つインスタンスにも同じことが当てはまります。これにより、クラスはそのスーパークラスとの割り当て互換性を持つことが&lt;em&gt;でき&lt;/em&gt;ますが、それ以外の点では同じ形状を持つ継承階層のクラスとは互換性があり&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e91301edc2c04ca7b2fe236a0af7531759595434" translate="yes" xml:space="preserve">
          <source>Private and protected members in classes</source>
          <target state="translated">クラスのプライベートと保護されたメンバー</target>
        </trans-unit>
        <trans-unit id="15fd0634ed725b1581380519d93db35711d918e3" translate="yes" xml:space="preserve">
          <source>ProgrammerCalculator.ts</source>
          <target state="translated">ProgrammerCalculator.ts</target>
        </trans-unit>
        <trans-unit id="567585a6d21c8b924898dbfb1c1f5b51255b4838" translate="yes" xml:space="preserve">
          <source>Project Configuration</source>
          <target state="translated">プロジェクトの構成</target>
        </trans-unit>
        <trans-unit id="dff8cdae331a987352af975febbbf5bf3497c075" translate="yes" xml:space="preserve">
          <source>Project Options</source>
          <target state="translated">プロジェクトオプション</target>
        </trans-unit>
        <trans-unit id="7793a73613168871bf96397b630c7423c4486ca5" translate="yes" xml:space="preserve">
          <source>Project References</source>
          <target state="translated">プロジェクトのリファレンス</target>
        </trans-unit>
        <trans-unit id="88f5397c06a7b7e37512d16b9ab11703488d260e" translate="yes" xml:space="preserve">
          <source>Project References: Build Mode for TypeScript</source>
          <target state="translated">プロジェクトのリファレンス。TypeScript のビルドモード</target>
        </trans-unit>
        <trans-unit id="754b3c7e71d4817f7d2fea3c257de1bdf3f58125" translate="yes" xml:space="preserve">
          <source>Project References: Caveats</source>
          <target state="translated">プロジェクトの参考文献。警告</target>
        </trans-unit>
        <trans-unit id="f6929baa8a0f682ca9e2d3784d0cff5d27cdab03" translate="yes" xml:space="preserve">
          <source>Project References: Caveats for Project References</source>
          <target state="translated">プロジェクトリファレンス。プロジェクトの参考文献に関する注意事項</target>
        </trans-unit>
        <trans-unit id="d0bd4d6b0aa124935089e5a1a6357f47ce88863d" translate="yes" xml:space="preserve">
          <source>Project References: MSBuild</source>
          <target state="translated">プロジェクトの参照先。MSBuild</target>
        </trans-unit>
        <trans-unit id="2d88f084a46bb059f7acb5d62832e90394777d3f" translate="yes" xml:space="preserve">
          <source>Project References: Overall Structure</source>
          <target state="translated">プロジェクトの参考資料。全体構造</target>
        </trans-unit>
        <trans-unit id="a0c2677e3090197b68e74d61303c68e7ddf04e66" translate="yes" xml:space="preserve">
          <source>Project References: Structuring for outFiles</source>
          <target state="translated">プロジェクトのリファレンス。outFilesの構造化</target>
        </trans-unit>
        <trans-unit id="810687c4e3229aa8caaccaa1985884772dfd3c9a" translate="yes" xml:space="preserve">
          <source>Project References: Structuring for relative modules</source>
          <target state="translated">プロジェクトのリファレンス。相対モジュールの構造化</target>
        </trans-unit>
        <trans-unit id="692d23787c48f3266c6f90679b8a1de2796d67f6" translate="yes" xml:space="preserve">
          <source>Project References: What is a Project Reference?</source>
          <target state="translated">プロジェクトリファレンス。プロジェクトリファレンスとは?</target>
        </trans-unit>
        <trans-unit id="394f18fdbb76c8acbdccddfc544deb4de35c052d" translate="yes" xml:space="preserve">
          <source>Project References: composite</source>
          <target state="translated">プロジェクトの参照先:複合材</target>
        </trans-unit>
        <trans-unit id="6d41bc9c0f6a331071fce870316ec281371a0d75" translate="yes" xml:space="preserve">
          <source>Project References: declarationMaps</source>
          <target state="translated">プロジェクトの参照先:declarationMaps</target>
        </trans-unit>
        <trans-unit id="908cd420bcb700a967b280f8a7dff581392527b2" translate="yes" xml:space="preserve">
          <source>Project References: prepend with outFile</source>
          <target state="translated">プロジェクトのリファレンス:outFileの前に</target>
        </trans-unit>
        <trans-unit id="64e335b1c5f861587f8782361a5af32ae20dcd21" translate="yes" xml:space="preserve">
          <source>Project References: tsc -b Commandline</source>
          <target state="translated">プロジェクトリファレンス:tsc -b コマンドライン</target>
        </trans-unit>
        <trans-unit id="fd7a6c05d7b3d7052f1c042cfc959322d90b11a4" translate="yes" xml:space="preserve">
          <source>Project references are a new feature in TypeScript 3.0 that allow you to structure your TypeScript programs into smaller pieces.</source>
          <target state="translated">プロジェクトリファレンスは、TypeScript 3.0の新機能であり、TypeScriptプログラムをより小さな単位で構成することができます。</target>
        </trans-unit>
        <trans-unit id="c138392855d638ba9e2bf29899810a7e57e84035" translate="yes" xml:space="preserve">
          <source>Project references are a way to structure your TypeScript programs into smaller pieces. Using Project References can greatly improve build and editor interaction times, enforce logical separation between components, and organize your code in new and improved ways.</source>
          <target state="translated">プロジェクト参照は、TypeScript プログラムをより小さな断片に構造化する方法です。プロジェクト参照を使用することで、ビルドとエディタのインタラクション時間を大幅に改善し、コンポーネント間の論理的な分離を強制し、新しい改良された方法でコードを整理することができます。</target>
        </trans-unit>
        <trans-unit id="4c6c967b1595e112d0adf09d5676eb35634edcb7" translate="yes" xml:space="preserve">
          <source>Project references can solve all of these problems and more.</source>
          <target state="translated">プロジェクトの参照は、これらの問題などをすべて解決することができます。</target>
        </trans-unit>
        <trans-unit id="1b126f1d1bec5fc383003c78a666ee84f0286aac" translate="yes" xml:space="preserve">
          <source>Project references have a few trade-offs you should be aware of.</source>
          <target state="translated">プロジェクトのリファレンスには、知っておくべきトレードオフがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="d846e8e5c61d018f2fdaece28ac3df9b54800862" translate="yes" xml:space="preserve">
          <source>Project support through &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; によるプロジェクトのサポート</target>
        </trans-unit>
        <trans-unit id="3d66fcc6f48609ad7f0ccc3524762b07b0fb5050" translate="yes" xml:space="preserve">
          <source>Properties are inferred from assignments in class bodies</source>
          <target state="translated">プロパティは、クラス本体の代入から推測されます。</target>
        </trans-unit>
        <trans-unit id="33bbcb8beed2dadd8ed7e8a6d283214d6efdf708" translate="yes" xml:space="preserve">
          <source>Properties declarations on functions</source>
          <target state="translated">関数のプロパティ宣言</target>
        </trans-unit>
        <trans-unit id="2e110b7b4893d92d3e7aa88aa3a301b45ead4967" translate="yes" xml:space="preserve">
          <source>Properties in the object binding pattern that have no match in the object literal are required to have a default value in the object binding pattern and are automatically added to the object literal type.</source>
          <target state="translated">オブジェクトリテラルに一致しないオブジェクトバインディングパターンのプロパティは、オブジェクトバインディングパターンでデフォルト値を持つ必要があり、オブジェクトリテラル型に自動的に追加されます。</target>
        </trans-unit>
        <trans-unit id="c8c07940eda3231c047d293da9f37f7834dd40cb" translate="yes" xml:space="preserve">
          <source>Properties in the object literal that have no match in the object binding pattern are an error.</source>
          <target state="translated">オブジェクト・リテラル内のプロパティで、オブジェクト・バインディング・パターンに一致しないものはエラーです。</target>
        </trans-unit>
        <trans-unit id="f8cc4919fcb9285716ac09c9df472748a0cd6f09" translate="yes" xml:space="preserve">
          <source>Properties with default values in the object binding pattern become optional in the object literal.</source>
          <target state="translated">オブジェクト・バインディング・パターンのデフォルト値を持つプロパティは、オブジェクト・リテラルではオプションになります。</target>
        </trans-unit>
        <trans-unit id="1af723998a3965fbd8fb5f43c4ba52d973f2b4be" translate="yes" xml:space="preserve">
          <source>Properties with relative paths found in the configuration file, which aren&amp;rsquo;t excluded from inheritance, will be resolved relative to the configuration file they originated in.</source>
          <target state="translated">継承から除外されていない、構成ファイルで見つかった相対パスを持つプロパティは、元の構成ファイルに関連して解決されます。</target>
        </trans-unit>
        <trans-unit id="3cbcb3278bdf5d0340f45b88be40ef4d53f50ba6" translate="yes" xml:space="preserve">
          <source>Property Decorators</source>
          <target state="translated">プロパティデコレーター</target>
        </trans-unit>
        <trans-unit id="ce5358cfe7c2a6843f2919f24e964b409bffae5b" translate="yes" xml:space="preserve">
          <source>Property assignments and non-generic spread expressions are merged to the greatest extent possible on either side of a generic spread expression. For example:</source>
          <target state="translated">プロパティの割り当てと非ジェネリックな広がり表現は、ジェネリックな広がり表現の両側で可能な限りマージされます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="832f7d76da1eb3d3ed83c2498cd0b5b699ea5efe" translate="yes" xml:space="preserve">
          <source>Property renaming</source>
          <target state="translated">プロパティの名称変更</target>
        </trans-unit>
        <trans-unit id="28531336563e1f3883b87d858af447e561471bd7" translate="yes" xml:space="preserve">
          <source>Protected</source>
          <target state="translated">Protected</target>
        </trans-unit>
        <trans-unit id="f0e692539cb524363ffe3c3313543515de8c4424" translate="yes" xml:space="preserve">
          <source>Prototype assignment</source>
          <target state="translated">プロトタイプの割り当て</target>
        </trans-unit>
        <trans-unit id="001b7307089ddcafb90fad2dff22ffc7a1e3c62c" translate="yes" xml:space="preserve">
          <source>Provide full support for iterables in &lt;code&gt;for..of&lt;/code&gt;, spread and destructuring when targeting ES5 or ES3.</source>
          <target state="translated">ES5またはES3を対象とする場合、 &lt;code&gt;for..of&lt;/code&gt; 、spread、およびdestructuringの反復可能オブジェクトを完全にサポートします。</target>
        </trans-unit>
        <trans-unit id="d26fd4d0603b6fec3f71df5845863025dd055f63" translate="yes" xml:space="preserve">
          <source>Providing Type Hints in JS via JSDoc</source>
          <target state="translated">JSDocによるJSでの型ヒントの提供</target>
        </trans-unit>
        <trans-unit id="a1146ed26ee333eed6d3996e25afdde504ab9e9b" translate="yes" xml:space="preserve">
          <source>Public by default</source>
          <target state="translated">デフォルトではパブリック</target>
        </trans-unit>
        <trans-unit id="df1e7a58b300fcd2018db41d09e99c76f51ccd9c" translate="yes" xml:space="preserve">
          <source>Public, private, and protected modifiers</source>
          <target state="translated">パブリック、プライベート、保護された修飾子</target>
        </trans-unit>
        <trans-unit id="51ca411182511e3fdf77719b4e3e0c22adc6e606" translate="yes" xml:space="preserve">
          <source>Publish to</source>
          <target state="translated">発行先</target>
        </trans-unit>
        <trans-unit id="4aeb4ef1d8df7836057d41c034dc834be57b173f" translate="yes" xml:space="preserve">
          <source>Publish to &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@typesに&lt;/a&gt;公開</target>
        </trans-unit>
        <trans-unit id="b1aa195e794b4f66b923622c595d29c04615285a" translate="yes" xml:space="preserve">
          <source>Publish to npm</source>
          <target state="translated">npmへの公開</target>
        </trans-unit>
        <trans-unit id="338b45a6751558a0e49cb2d757f64736adc58f12" translate="yes" xml:space="preserve">
          <source>Publishing</source>
          <target state="translated">Publishing</target>
        </trans-unit>
        <trans-unit id="be0e9506d0fd3f0204f58e0f5b06282be66a0f23" translate="yes" xml:space="preserve">
          <source>Publishing: Dependencies</source>
          <target state="translated">出版:依存関係</target>
        </trans-unit>
        <trans-unit id="ed87f3075dc9e52018557fb97c9010a8f00d2af8" translate="yes" xml:space="preserve">
          <source>Publishing: Publish to @types</source>
          <target state="translated">パブリッシング:@typesにパブリッシュ</target>
        </trans-unit>
        <trans-unit id="c25e21d552520e10e91602755603035ee2dc11de" translate="yes" xml:space="preserve">
          <source>Publishing: Red flags</source>
          <target state="translated">出版:レッドフラッグ</target>
        </trans-unit>
        <trans-unit id="322bb8d07bb59be9606da97b40f86a36058152ee" translate="yes" xml:space="preserve">
          <source>Put a breakpoint on the line with return.</source>
          <target state="translated">リターンでラインにブレークポイントを置く。</target>
        </trans-unit>
        <trans-unit id="a1b752d5b588559d3c1ab9de849d0678ef2991f1" translate="yes" xml:space="preserve">
          <source>Putting all of the above rules together in an example</source>
          <target state="translated">上記のルールをすべて例に挙げると</target>
        </trans-unit>
        <trans-unit id="c148aded3d47eba6bad059e92b2038d207b0a750" translate="yes" xml:space="preserve">
          <source>Putting it all together</source>
          <target state="translated">まとめてみると</target>
        </trans-unit>
        <trans-unit id="c25bd9f882a3a8b49796dbe73c56bf10103c4152" translate="yes" xml:space="preserve">
          <source>Question to ask yourself while looking at a library you are trying to type.</source>
          <target state="translated">タイプしようとしている図書館を見ながら自問自答する質問</target>
        </trans-unit>
        <trans-unit id="ab61ee9bc98f1490cb74d9856a2bcfdb903bd123" translate="yes" xml:space="preserve">
          <source>Quick introductions based on your background or preference.</source>
          <target state="translated">経歴や好みに応じて、簡単な紹介をします。</target>
        </trans-unit>
        <trans-unit id="d8f6fe9f8c69850190c5d7fab3738cc93bedaed0" translate="yes" xml:space="preserve">
          <source>Raise error on &amp;lsquo;this&amp;rsquo; expressions with an implied &amp;lsquo;any&amp;rsquo; type.</source>
          <target state="translated">暗黙の「any」タイプを使用して「this」式でエラーを発生させます。</target>
        </trans-unit>
        <trans-unit id="224762d86a9baf2c769b2d7a923fbcab59d453ee" translate="yes" xml:space="preserve">
          <source>Raise error on &lt;code&gt;this&lt;/code&gt; expressions with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">暗黙の &lt;code&gt;any&lt;/code&gt; タイプを使用して、 &lt;code&gt;this&lt;/code&gt; 式のエラーを発生させます。</target>
        </trans-unit>
        <trans-unit id="36eec16ea1bf9722ff825e6c1dfe6c84e5ad8600" translate="yes" xml:space="preserve">
          <source>Raise error on expressions and declarations with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">暗黙の &lt;code&gt;any&lt;/code&gt; タイプの式と宣言でエラーを発生させます。</target>
        </trans-unit>
        <trans-unit id="374e9f700483653b29a58cc7f00cdaf51ae907b5" translate="yes" xml:space="preserve">
          <source>Rather than actually execute a build with the other input options and config files, show the final implied config file in the output.</source>
          <target state="translated">他の入力オプションとコンフィグファイルを使って実際にビルドを実行するのではなく、最終的なインプライドされたコンフィグファイルを出力に表示します。</target>
        </trans-unit>
        <trans-unit id="8b1872d78c17fd0391a92cf444a735ee5e6bae28" translate="yes" xml:space="preserve">
          <source>Re-compiling, you&amp;rsquo;ll now see an error:</source>
          <target state="translated">再コンパイルすると、エラーが表示されます。</target>
        </trans-unit>
        <trans-unit id="6c315f12f77496f53aa14fdb148faec85d5b7486" translate="yes" xml:space="preserve">
          <source>Re-declarations and Shadowing</source>
          <target state="translated">再宣言とシャドーイング</target>
        </trans-unit>
        <trans-unit id="fdc685fb106414cf637a1b38813a53d910b18ec9" translate="yes" xml:space="preserve">
          <source>Re-export to extend</source>
          <target state="translated">拡張するための再エクスポート</target>
        </trans-unit>
        <trans-unit id="648cfabc9a420f1e968be9f4f509254b2ab2cbc0" translate="yes" xml:space="preserve">
          <source>Re-exporting</source>
          <target state="translated">Re-exporting</target>
        </trans-unit>
        <trans-unit id="eda2bfe47f1cfbe6424bba7d3a76f901f6b42466" translate="yes" xml:space="preserve">
          <source>Re-exports</source>
          <target state="translated">Re-exports</target>
        </trans-unit>
        <trans-unit id="eb5bcada059371623621a43a8e7c9b5feeb2c5ef" translate="yes" xml:space="preserve">
          <source>Re-run &lt;code&gt;tsc greeter.ts&lt;/code&gt; and you&amp;rsquo;ll see the generated JavaScript is the same as the earlier code. Classes in TypeScript are just a shorthand for the same prototype-based OO that is frequently used in JavaScript.</source>
          <target state="translated">&lt;code&gt;tsc greeter.ts&lt;/code&gt; を再実行すると、生成されたJavaScriptが以前のコードと同じであることがわかります。TypeScriptのクラスは、JavaScriptで頻繁に使用される同じプロトタイプベースのOOの省略形にすぎません。</target>
        </trans-unit>
        <trans-unit id="0800d078d61e87e277eaae4d8414a88253e82cf4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack</source>
          <target state="translated">React＆Webpack</target>
        </trans-unit>
        <trans-unit id="c6ad73159db4fbc79a9e826240d2405491564ef3" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Add a TypeScript configuration file</source>
          <target state="translated">React＆Webpack：TypeScript構成ファイルを追加する</target>
        </trans-unit>
        <trans-unit id="328cdad5c6c6e56604b6063e3fdaca83a43aa289" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Create a webpack configuration file</source>
          <target state="translated">React＆Webpack：Webpack構成ファイルを作成する</target>
        </trans-unit>
        <trans-unit id="b99e8dd71da2d3b5ad0aa22f4c73bf525f613bf7" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Initialize the project</source>
          <target state="translated">React＆Webpack：プロジェクトを初期化する</target>
        </trans-unit>
        <trans-unit id="e79de56f4434ed0a6e8d586e225decedd4a4b91a" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Install our dependencies</source>
          <target state="translated">React＆Webpack：依存関係をインストールする</target>
        </trans-unit>
        <trans-unit id="a6f634b484a857760fd1fe0c0b8caa1f4ad1a7a4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Lay out the project</source>
          <target state="translated">React＆Webpack：プロジェクトをレイアウトする</target>
        </trans-unit>
        <trans-unit id="70d16f67e5b10f58dde0039090fa1f15716caaa4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Putting it all together</source>
          <target state="translated">React＆Webpack：すべてをまとめる</target>
        </trans-unit>
        <trans-unit id="c1326a95c630b81552ae15e8939b25927eca9f30" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Write some code</source>
          <target state="translated">React＆Webpack：コードを書く</target>
        </trans-unit>
        <trans-unit id="7f185bfe20f1f619f8c9bb6aa99786b71328866a" translate="yes" xml:space="preserve">
          <source>React 17 dev transform: &lt;code&gt;&quot;react-jsxdev&quot;&lt;/code&gt;&lt;sup&gt;&lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">React 17 devトランスフォーム： &lt;code&gt;&quot;react-jsxdev&quot;&lt;/code&gt; &lt;sup&gt;&lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7d97070f74a67941c76e5ea64885d0e08627efa5" translate="yes" xml:space="preserve">
          <source>React 17 transform: &lt;code&gt;&quot;react-jsx&quot;&lt;/code&gt;&lt;sup&gt;&lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">React 17変換： &lt;code&gt;&quot;react-jsx&quot;&lt;/code&gt; &lt;sup&gt;&lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ae4b21d845bd34b4e6b6216731b5271028fb8f60" translate="yes" xml:space="preserve">
          <source>React Namespace - &lt;code&gt;reactNamespace&lt;/code&gt;</source>
          <target state="translated">React名前空間 &lt;code&gt;reactNamespace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee67e7a559cad7f7f0016ea4240d3102eab0e39c" translate="yes" xml:space="preserve">
          <source>React Native</source>
          <target state="translated">リアクトネイティブ</target>
        </trans-unit>
        <trans-unit id="fa58cb746f54f27aa90a8d689bba8023af13c2bb" translate="yes" xml:space="preserve">
          <source>React Native: &lt;code&gt;&quot;react-native&quot;&lt;/code&gt;</source>
          <target state="translated">React Native: &lt;code&gt;&quot;react-native&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58842bd13325c48a2698202bdb55d3b757360943" translate="yes" xml:space="preserve">
          <source>React integration</source>
          <target state="translated">リアクト統合</target>
        </trans-unit>
        <trans-unit id="3ce4f7210a5cf94a25154fce20154f3f93c9f258" translate="yes" xml:space="preserve">
          <source>React-native build pipeline expects all files to have a &lt;code&gt;.js&lt;/code&gt; extensions even if the file contains JSX syntax. The new &lt;code&gt;--jsx&lt;/code&gt; value &lt;code&gt;react-native&lt;/code&gt; will persevere the JSX syntax in the output file, but give it a &lt;code&gt;.js&lt;/code&gt; extension.</source>
          <target state="translated">Reactネイティブのビルドパイプラインは、ファイルにJSX構文が含まれている場合でも、すべてのファイルに &lt;code&gt;.js&lt;/code&gt; 拡張子が付いていることを想定しています。新しい &lt;code&gt;--jsx&lt;/code&gt; 値 &lt;code&gt;react-native&lt;/code&gt; は、出力ファイルのJSX構文を保持しますが、 &lt;code&gt;.js&lt;/code&gt; 拡張子を付けます。</target>
        </trans-unit>
        <trans-unit id="0ab19aed84f407a0ba739f934e0edb923766280c" translate="yes" xml:space="preserve">
          <source>Read and understand commonly-used TypeScript syntax and patterns</source>
          <target state="translated">一般的に使用されている TypeScript の構文とパターンを読み、理解します。</target>
        </trans-unit>
        <trans-unit id="91699c24f2e0a9b9e92adecd16c0b3f7f436f6cb" translate="yes" xml:space="preserve">
          <source>Read in any files it understands in the &lt;code&gt;src&lt;/code&gt; directory (with &lt;code&gt;include&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; ディレクトリで理解できるファイルを読み込みます（ &lt;code&gt;include&lt;/code&gt; を使用）。</target>
        </trans-unit>
        <trans-unit id="bc4702822c3373e5ee67caa1dc26cc74db6df18f" translate="yes" xml:space="preserve">
          <source>Read the full Handbook &lt;a href=&quot;intro&quot;&gt;from start to finish&lt;/a&gt; (30m)</source>
          <target state="translated">ハンドブック全体&lt;a href=&quot;intro&quot;&gt;を最初から最後まで&lt;/a&gt;読む（30m）</target>
        </trans-unit>
        <trans-unit id="2a5eba8a5ad07b0a44f5a4a457fdc20c1b7dbf7f" translate="yes" xml:space="preserve">
          <source>Read-only properties and index signatures</source>
          <target state="translated">読み取り専用のプロパティとインデックス署名</target>
        </trans-unit>
        <trans-unit id="98f4c7227b38a0bf0e16a93bbf9b95c02d029667" translate="yes" xml:space="preserve">
          <source>Read-only properties may have initializers and may be assigned to in constructors within the same class declaration, but otherwise assignments to read-only properties are disallowed.</source>
          <target state="translated">読み取り専用プロパティはイニシャライザを持つことができ、同じクラス宣言内のコンストラクタに代入することができますが、それ以外の場合は読み取り専用プロパティへの代入は禁止されています。</target>
        </trans-unit>
        <trans-unit id="7386588f18988cfe9593c3202dc16be85d972e3f" translate="yes" xml:space="preserve">
          <source>Readonly modifier</source>
          <target state="translated">読み取り専用修飾子</target>
        </trans-unit>
        <trans-unit id="097c59114ca50eec3cf0a821be259c50e9b74d04" translate="yes" xml:space="preserve">
          <source>Readonly properties</source>
          <target state="translated">読み取り専用プロパティ</target>
        </trans-unit>
        <trans-unit id="6d74bc61c8b8b435782687890427a863cef761e7" translate="yes" xml:space="preserve">
          <source>Readonly&amp;lt;T&amp;gt;</source>
          <target state="translated">Readonly&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4699a4a521bfdbbfcae804201e013659f911e1a8" translate="yes" xml:space="preserve">
          <source>Ready? Take a look:</source>
          <target state="translated">準備はいいですか?見てみろ</target>
        </trans-unit>
        <trans-unit id="0cbc39f65d2c6c44eebf7ed41f07d520bd81bbe9" translate="yes" xml:space="preserve">
          <source>Real applications, however, look like &lt;code&gt;Readonly&lt;/code&gt; or &lt;code&gt;Partial&lt;/code&gt; above. They&amp;rsquo;re based on some existing type, and they transform the properties in some way. That&amp;rsquo;s where &lt;code&gt;keyof&lt;/code&gt; and indexed access types come in:</source>
          <target state="translated">ただし、実際のアプリケーションは、上記の &lt;code&gt;Readonly&lt;/code&gt; または &lt;code&gt;Partial&lt;/code&gt; ように見えます。これらは既存のタイプに基づいており、プロパティを何らかの方法で変換します。そこで &lt;code&gt;keyof&lt;/code&gt; のがkeyofとインデックス付きのアクセスタイプです。</target>
        </trans-unit>
        <trans-unit id="f1d90148c2f9c29ea449489201d6864609117f05" translate="yes" xml:space="preserve">
          <source>Recall how to write a type assertion:</source>
          <target state="translated">型アサーションの書き方を思い出してください。</target>
        </trans-unit>
        <trans-unit id="c5d97500640d6a0752241e63626a067412fd2a00" translate="yes" xml:space="preserve">
          <source>Recall that Node.js looked for a file named &lt;code&gt;moduleB.js&lt;/code&gt;, then an applicable &lt;code&gt;package.json&lt;/code&gt;, and then for an &lt;code&gt;index.js&lt;/code&gt;.</source>
          <target state="translated">Node.jsのが名前のファイルを探したことを思い出し &lt;code&gt;moduleB.js&lt;/code&gt; 適用、その後、 &lt;code&gt;package.json&lt;/code&gt; 、その後のための &lt;code&gt;index.js&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af653faed29a78b35af6aadab7ff219a754ccd8b" translate="yes" xml:space="preserve">
          <source>Recall that with our earlier &lt;code&gt;setTimeout&lt;/code&gt; example, we ended up needing to use an IIFE to capture the state of a variable for every iteration of the &lt;code&gt;for&lt;/code&gt; loop. In effect, what we were doing was creating a new variable environment for our captured variables. That was a bit of a pain, but luckily, you&amp;rsquo;ll never have to do that again in TypeScript.</source>
          <target state="translated">以前の &lt;code&gt;setTimeout&lt;/code&gt; の例では、IIFEを使用して &lt;code&gt;for&lt;/code&gt; ループの反復ごとに変数の状態をキャプチャする必要があったことを思い出してください。実際、私たちが行っていたのは、取得した変数用の新しい変数環境を作成することでした。これは少し苦痛でしたが、幸いなことに、TypeScriptでこれを再度行う必要はありません。</target>
        </trans-unit>
        <trans-unit id="4faa65b556f68207d69cb14bcae4acb71980a036" translate="yes" xml:space="preserve">
          <source>Recommendations</source>
          <target state="translated">Recommendations</target>
        </trans-unit>
        <trans-unit id="9ef937556efe782b8e9bf8ef16e540c185c5bf00" translate="yes" xml:space="preserve">
          <source>Recommended</source>
          <target state="translated">Recommended</target>
        </trans-unit>
        <trans-unit id="2d40a3d4b23c33dba91182fa7193e3bc8d084647" translate="yes" xml:space="preserve">
          <source>Recommended:</source>
          <target state="translated">Recommended:</target>
        </trans-unit>
        <trans-unit id="5838e1d2256d8060aa1b3a66e780f5f99fa40b5e" translate="yes" xml:space="preserve">
          <source>Record&amp;lt;K,T&amp;gt;</source>
          <target state="translated">Record&amp;lt;K,T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4a41add58030e39fbaf51db74fe2dbb02e5e4ab1" translate="yes" xml:space="preserve">
          <source>Red Flags</source>
          <target state="translated">赤旗</target>
        </trans-unit>
        <trans-unit id="34d53f3ab50503026ac59429b75482fa11e6a5b9" translate="yes" xml:space="preserve">
          <source>Red flags</source>
          <target state="translated">赤旗</target>
        </trans-unit>
        <trans-unit id="9103e88842d8a8fd8fdef77a63d0bed96f6e7b8c" translate="yes" xml:space="preserve">
          <source>Redirect output structure to the directory.</source>
          <target state="translated">出力構造体をディレクトリにリダイレクトします。</target>
        </trans-unit>
        <trans-unit id="f70cca9ad50ad5b8ed87a8010b088c10db5dda71" translate="yes" xml:space="preserve">
          <source>Reference Example</source>
          <target state="translated">参考例</target>
        </trans-unit>
        <trans-unit id="4712f8dca718bd28253a5790647646c3533841da" translate="yes" xml:space="preserve">
          <source>Referenced projects must have the new &lt;code&gt;composite&lt;/code&gt; setting enabled. This setting is needed to ensure TypeScript can quickly determine where to find the outputs of the referenced project. Enabling the &lt;code&gt;composite&lt;/code&gt; flag changes a few things:</source>
          <target state="translated">参照されるプロジェクトでは、新しい &lt;code&gt;composite&lt;/code&gt; 設定を有効にする必要があります。この設定は、TypeScriptが参照プロジェクトの出力を見つける場所をすばやく決定できるようにするために必要です。 &lt;code&gt;composite&lt;/code&gt; フラグを有効にすると、いくつかの変更があります。</target>
        </trans-unit>
        <trans-unit id="4d6f89c160b09f2d6743dec6ea31f5aef184e7a5" translate="yes" xml:space="preserve">
          <source>References - &lt;code&gt;references&lt;/code&gt;</source>
          <target state="translated">参照- &lt;code&gt;references&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2e7e105e2839b4e1b747e4c6dae363b4ac3c64d8" translate="yes" xml:space="preserve">
          <source>References to &lt;code&gt;const enum&lt;/code&gt; members</source>
          <target state="translated">&lt;code&gt;const enum&lt;/code&gt; メンバーへの参照</target>
        </trans-unit>
        <trans-unit id="f716fe211e8cbfb1b5ac185fb3d6bbbbc2b34ab2" translate="yes" xml:space="preserve">
          <source>Referring to objects in the value space as types doesn&amp;rsquo;t work unless the object also creates a type, like a constructor function.</source>
          <target state="translated">値スペース内のオブジェクトをタイプとして参照することは、オブジェクトがコンストラクター関数のようにタイプも作成しない限り機能しません。</target>
        </trans-unit>
        <trans-unit id="fda05af620d8f7d239d3f6e8e81b4403108f221e" translate="yes" xml:space="preserve">
          <source>Reflection</source>
          <target state="translated">Reflection</target>
        </trans-unit>
        <trans-unit id="917df91e1730cb55ff8aba76f721651a6b54a840" translate="yes" xml:space="preserve">
          <source>Related</source>
          <target state="translated">Related</target>
        </trans-unit>
        <trans-unit id="39c788876858d9fdd3ed2ab494830cb7baca1db1" translate="yes" xml:space="preserve">
          <source>Related:</source>
          <target state="translated">Related:</target>
        </trans-unit>
        <trans-unit id="0d61ba1d171892a4a7567647b72650543ee4275d" translate="yes" xml:space="preserve">
          <source>Relative paths are fairly straightforward. As an example, let&amp;rsquo;s consider a file located at &lt;code&gt;/root/src/moduleA.js&lt;/code&gt;, which contains the import &lt;code&gt;var x = require(&quot;./moduleB&quot;);&lt;/code&gt; Node.js resolves that import in the following order:</source>
          <target state="translated">相対パスはかなり単純です。一例として、のがにあるファイルを検討してみましょう &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; 輸入が含まれ、 &lt;code&gt;var x = require(&quot;./moduleB&quot;);&lt;/code&gt; Node.jsは、次の順序でインポートを解決します。</target>
        </trans-unit>
        <trans-unit id="227f526e9deba436f5046f9ae5ceb4b3a9053811" translate="yes" xml:space="preserve">
          <source>Relative vs. Non-relative module imports</source>
          <target state="translated">相対的なモジュールのインポートと非相対的なモジュールのインポート</target>
        </trans-unit>
        <trans-unit id="2ff253f328340904e6aa7b404e19bda3c645fe78" translate="yes" xml:space="preserve">
          <source>Relaxing declaration emit visiblity rules</source>
          <target state="translated">緩和宣言は可視性のルールを放出する</target>
        </trans-unit>
        <trans-unit id="9811fea8059729e6e608294e42cacce36d4ff09d" translate="yes" xml:space="preserve">
          <source>Released:</source>
          <target state="translated">Released:</target>
        </trans-unit>
        <trans-unit id="1d3768a1e142e6e3ef4c29558ba7b7010322ddb0" translate="yes" xml:space="preserve">
          <source>Remember what we mentioned earlier about variable capturing? Every function expression we pass to &lt;code&gt;setTimeout&lt;/code&gt; actually refers to the same &lt;code&gt;i&lt;/code&gt; from the same scope.</source>
          <target state="translated">変数のキャプチャについて前述したことを覚えていますか？ &lt;code&gt;setTimeout&lt;/code&gt; に渡すすべての関数式は、実際には同じスコープの同じ &lt;code&gt;i&lt;/code&gt; を参照します。</target>
        </trans-unit>
        <trans-unit id="4ae2f2f99c6da082f0672c95b34c59cd80c40a24" translate="yes" xml:space="preserve">
          <source>Remove Comments - &lt;code&gt;removeComments&lt;/code&gt;</source>
          <target state="translated">コメントの削除 &lt;code&gt;removeComments&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f11d0e5af8f40be276413a0572f57b6d8abf9e52" translate="yes" xml:space="preserve">
          <source>Remove all comments except copy-right header comments beginning with &lt;code&gt;/*!&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;/*!&lt;/code&gt; 始まるコピーライトヘッダーコメントを除くすべてのコメントを削除します。</target>
        </trans-unit>
        <trans-unit id="64f0b6609e1215f1c7351fcea7e64bd711ee68cd" translate="yes" xml:space="preserve">
          <source>Removes the &amp;lsquo;this&amp;rsquo; parameter from a function type.</source>
          <target state="translated">関数タイプから「this」パラメーターを削除します。</target>
        </trans-unit>
        <trans-unit id="d619a6862a4f7b32d4a58f285cc5c61b509d1673" translate="yes" xml:space="preserve">
          <source>Removes the &lt;a href=&quot;functions#this-parameters&quot;&gt;&lt;code&gt;this&lt;/code&gt;&lt;/a&gt; parameter from &lt;code&gt;Type&lt;/code&gt;. If &lt;code&gt;Type&lt;/code&gt; has no explicitly declared &lt;code&gt;this&lt;/code&gt; parameter, the result is simply &lt;code&gt;Type&lt;/code&gt;. Otherwise, a new function type with no &lt;code&gt;this&lt;/code&gt; parameter is created from &lt;code&gt;Type&lt;/code&gt;. Generics are erased and only the last overload signature is propagated into the new function type.</source>
          <target state="translated">&lt;a href=&quot;functions#this-parameters&quot;&gt; &lt;code&gt;this&lt;/code&gt; &lt;/a&gt;パラメータを &lt;code&gt;Type&lt;/code&gt; から削除します。 &lt;code&gt;Type&lt;/code&gt; が &lt;code&gt;this&lt;/code&gt; パラメーターを明示的に宣言していない場合、結果は単に &lt;code&gt;Type&lt;/code&gt; になります。それ以外の場合は、 &lt;code&gt;this&lt;/code&gt; パラメーターのない新しい関数タイプが &lt;code&gt;Type&lt;/code&gt; から作成されます。ジェネリックスは消去され、最後のオーバーロードシグネチャのみが新しい関数型に伝播されます。</target>
        </trans-unit>
        <trans-unit id="458347c4b08c20b7988b89261e9a532ec566adc1" translate="yes" xml:space="preserve">
          <source>Replace the contents of the &lt;code&gt;tsconfig.json&lt;/code&gt; file with:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; ファイルの内容を以下に置き換えます。</target>
        </trans-unit>
        <trans-unit id="bf9bdd295fb0df2de64ff2a20d94e74886937c45" translate="yes" xml:space="preserve">
          <source>Report an error when not all code paths in function return a value.</source>
          <target state="translated">関数内のすべてのコードパスが値を返すわけではない場合にエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="4bfcecd38bfeff6fffc3ecafa503fe73a31b3529" translate="yes" xml:space="preserve">
          <source>Report errors for fallthrough cases in switch statement.</source>
          <target state="translated">switch文のフォールスルーケースのエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="28ff576f8c9a47a52a73ccec4dfa5490f20abc5a" translate="yes" xml:space="preserve">
          <source>Report errors for fallthrough cases in switch statements. Ensures that any non-empty case inside a switch statement includes either &lt;code&gt;break&lt;/code&gt; or &lt;code&gt;return&lt;/code&gt;. This means you won&amp;rsquo;t accidentally ship a case fallthrough bug.</source>
          <target state="translated">switchステートメントでフォールスルーケースのエラーを報告します。switchステートメント内の空でないケースに &lt;code&gt;break&lt;/code&gt; または &lt;code&gt;return&lt;/code&gt; が含まれていることを確認します。これは、ケースのフォールスルーバグを誤って出荷しないことを意味します。</target>
        </trans-unit>
        <trans-unit id="f8c20651b90e6cd8477684950f963b02e2099736" translate="yes" xml:space="preserve">
          <source>Report errors in &lt;code&gt;.js&lt;/code&gt; files. Use in conjunction with &lt;code&gt;--allowJs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; ファイルのエラーを報告します。 &lt;code&gt;--allowJs&lt;/code&gt; と組み合わせて使用​​します。</target>
        </trans-unit>
        <trans-unit id="9859c2bfd11829e29389ef6176aef839ff246a67" translate="yes" xml:space="preserve">
          <source>Report errors on unused local variables.</source>
          <target state="translated">未使用のローカル変数のエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="c2375f497601629902de6816b8348dc646a011d3" translate="yes" xml:space="preserve">
          <source>Report errors on unused locals.</source>
          <target state="translated">未使用のローカルのエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="c070f2ba00c2432442f5870f3f9104c630e23e08" translate="yes" xml:space="preserve">
          <source>Report errors on unused parameters in functions.</source>
          <target state="translated">関数内の未使用パラメータのエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="4e4da7a34ece0e23f3bacbbf60ec3ad07461c31d" translate="yes" xml:space="preserve">
          <source>Report errors on unused parameters.</source>
          <target state="translated">使用されていないパラメータのエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="d1c09f6c73919c0ebd1abbfd86f69d2cd3437aeb" translate="yes" xml:space="preserve">
          <source>Report module resolution log messages.</source>
          <target state="translated">モジュールの解決ログメッセージを報告します。</target>
        </trans-unit>
        <trans-unit id="99bc390ff55a2eb33efc222d7c8bb02d1504d6e7" translate="yes" xml:space="preserve">
          <source>Required type parameters must not follow optional type parameters.</source>
          <target state="translated">必須の型パラメータは、オプションの型パラメータの後に続いてはいけません。</target>
        </trans-unit>
        <trans-unit id="6b52890a8d8bb281f971e8b6c6fc68eebe6bbc98" translate="yes" xml:space="preserve">
          <source>Required&amp;lt;T&amp;gt;</source>
          <target state="translated">Required&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cdc1d535ad72977d21e2597085ca79e9eac4c98a" translate="yes" xml:space="preserve">
          <source>Required, optional, and default parameters all have one thing in common: they talk about one parameter at a time. Sometimes, you want to work with multiple parameters as a group, or you may not know how many parameters a function will ultimately take. In JavaScript, you can work with the arguments directly using the &lt;code&gt;arguments&lt;/code&gt; variable that is visible inside every function body.</source>
          <target state="translated">必須、オプション、およびデフォルトのパラメーターはすべて、1つの共通点があります。つまり、一度に1つのパラメーターについて話します。場合によっては、複数のパラメーターをグループとして操作したい場合や、関数が最終的に取るパラメーターの数がわからない場合があります。JavaScriptでは、すべての関数本体内に表示される &lt;code&gt;arguments&lt;/code&gt; 変数を使用して、引数を直接操作できます。</target>
        </trans-unit>
        <trans-unit id="6f3ece0cdbc888dc6e6e500ee3d259d041d3cdae" translate="yes" xml:space="preserve">
          <source>Requires either &lt;code&gt;sourceMap&lt;/code&gt; or &lt;code&gt;inlineSourceMap&lt;/code&gt; to be set.</source>
          <target state="translated">&lt;code&gt;sourceMap&lt;/code&gt; または &lt;code&gt;inlineSourceMap&lt;/code&gt; のいずれかを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="bb59a7085d1d1d9d3f072f5c7166cfdbf3c3fa4d" translate="yes" xml:space="preserve">
          <source>Resolve &lt;code&gt;keyof&lt;/code&gt; to string valued property names only (no numbers or symbols).</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; を文字列値のプロパティ名のみに解決します（数値や記号は不可）。</target>
        </trans-unit>
        <trans-unit id="6500c452861f317427f27ca99511d2efa2c4566a" translate="yes" xml:space="preserve">
          <source>Resolve JSON Module - &lt;code&gt;resolveJsonModule&lt;/code&gt;</source>
          <target state="translated">JSONモジュールを解決する &lt;code&gt;resolveJsonModule&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e884a460b4d82c0f0401e11f902d2d3991a0a50" translate="yes" xml:space="preserve">
          <source>Rest Parameters</source>
          <target state="translated">休息パラメータ</target>
        </trans-unit>
        <trans-unit id="beeb7a77ad3e842a8cb47b5d6131631a494608b1" translate="yes" xml:space="preserve">
          <source>Rest elements in tuple types</source>
          <target state="translated">タプル型のレスト要素</target>
        </trans-unit>
        <trans-unit id="50be0fe30fc10dc88af852c9cb7c36370f77be27" translate="yes" xml:space="preserve">
          <source>Rest elements in tuple types.</source>
          <target state="translated">タプル型のレスト要素。</target>
        </trans-unit>
        <trans-unit id="387816de015267e69071ea349b674f6e1d757b14" translate="yes" xml:space="preserve">
          <source>Rest parameters with tuple types</source>
          <target state="translated">タプル型を持つ残りのパラメータ</target>
        </trans-unit>
        <trans-unit id="191ff62bcfa7d34e1a815740c74afda07b8c1e33" translate="yes" xml:space="preserve">
          <source>Results in an output such as:</source>
          <target state="translated">のような出力になります。</target>
        </trans-unit>
        <trans-unit id="69fa7005e9e1a4d2f5ae93f2373b3b809a4f2af9" translate="yes" xml:space="preserve">
          <source>Results in the following generated code:</source>
          <target state="translated">結果として、以下のようなコードが生成されます。</target>
        </trans-unit>
        <trans-unit id="02d55b2baf2725bcbe0634735b4de01c005aa3e5" translate="yes" xml:space="preserve">
          <source>Results in:</source>
          <target state="translated">結果が出ています。</target>
        </trans-unit>
        <trans-unit id="acde6ca95b6974ed08c6f806127b9ecb63b7289c" translate="yes" xml:space="preserve">
          <source>Rethinking Types</source>
          <target state="translated">タイプの再考</target>
        </trans-unit>
        <trans-unit id="854f4c1b2de1f042fed1a2f43dfb41e328c62875" translate="yes" xml:space="preserve">
          <source>Rethinking the Class</source>
          <target state="translated">クラスの再考</target>
        </trans-unit>
        <trans-unit id="642d8f2cc4c0bf44f7ec4417fc288bf230277121" translate="yes" xml:space="preserve">
          <source>Return Types of Callbacks</source>
          <target state="translated">コールバックの戻り値の種類</target>
        </trans-unit>
        <trans-unit id="d87cabec32902153d1d79b8b11bc188472a6cc03" translate="yes" xml:space="preserve">
          <source>Return types as inference targets</source>
          <target state="translated">推論対象としての戻り値の型</target>
        </trans-unit>
        <trans-unit id="af8759585cf2cfe7a7c8a45a7ecabdbfd11cd2db" translate="yes" xml:space="preserve">
          <source>ReturnType&amp;lt;T&amp;gt;</source>
          <target state="translated">ReturnType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="251cfcc8db7eb197ba54907567e2b369dc7b23af" translate="yes" xml:space="preserve">
          <source>Reusable Types (Interfaces)</source>
          <target state="translated">再利用可能なタイプ(インターフェース)</target>
        </trans-unit>
        <trans-unit id="d6640a4d11aa6f54309d2fb5c213135e2c58c777" translate="yes" xml:space="preserve">
          <source>Reusable Types (Type Aliases)</source>
          <target state="translated">再利用可能なタイプ(タイプエイリアス</target>
        </trans-unit>
        <trans-unit id="221e6da1276e8997b6b6f436b2f947172bae0726" translate="yes" xml:space="preserve">
          <source>Reverse mappings</source>
          <target state="translated">逆マッピング</target>
        </trans-unit>
        <trans-unit id="9a135d61c072a9901e22aab7a06796f5a0db008c" translate="yes" xml:space="preserve">
          <source>Right click on &lt;code&gt;scripts&lt;/code&gt; and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;TypeScript File&lt;/strong&gt; and name the file &lt;code&gt;app.ts&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;scripts&lt;/code&gt; を右クリックし、[ &lt;strong&gt;新しいアイテム&lt;/strong&gt; ]をクリックします。次に、&lt;strong&gt;TypeScriptファイル&lt;/strong&gt;を選択し、ファイルに &lt;code&gt;app.ts&lt;/code&gt; という名前を付けます。</target>
        </trans-unit>
        <trans-unit id="46718d1e29791accf85fa69e3063268fff2968e4" translate="yes" xml:space="preserve">
          <source>Right click on the &lt;code&gt;wwwroot&lt;/code&gt; folder (if you don&amp;rsquo;t see the folder try building the project) and add a New Item named &lt;code&gt;index.html&lt;/code&gt; inside. Use the following code for &lt;code&gt;index.html &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;wwwroot&lt;/code&gt; フォルダーを右クリックし（フォルダーが表示されない場合は、プロジェクトをビルドしてみてください）、内部に &lt;code&gt;index.html&lt;/code&gt; という名前の新しいアイテムを追加します。 &lt;code&gt;index.html &lt;/code&gt; には次のコードを使用します</target>
        </trans-unit>
        <trans-unit id="77c4e77f51ec4dad132664992b8975f2dfbe92c9" translate="yes" xml:space="preserve">
          <source>Right click on the &lt;code&gt;wwwroot&lt;/code&gt; folder (if you don&amp;rsquo;t see the folder try building the project) and add a New Item named &lt;code&gt;index.html&lt;/code&gt; inside. Use the following code for &lt;code&gt;index.html&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;wwwroot&lt;/code&gt; フォルダーを右クリックし（フォルダーが表示されない場合は、プロジェクトをビルドしてみてください）、 &lt;code&gt;index.html&lt;/code&gt; という名前の新しいアイテムを中に追加します。 &lt;code&gt;index.html&lt;/code&gt; には次のコードを使用します</target>
        </trans-unit>
        <trans-unit id="f52ba130a82d88fb66ffcaad9e4d91c2445da38b" translate="yes" xml:space="preserve">
          <source>Right click on the project and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;JavaScript File&lt;/strong&gt; and use the name of &lt;code&gt;gulpfile.js&lt;/code&gt;</source>
          <target state="translated">プロジェクトを右クリックし、[ &lt;strong&gt;新しいアイテム&lt;/strong&gt; ]をクリックします。次に、&lt;strong&gt;JavaScriptファイル&lt;/strong&gt;を選択し、 &lt;code&gt;gulpfile.js&lt;/code&gt; の名前を使用します</target>
        </trans-unit>
        <trans-unit id="7e501a41bf28a9903be39bc35a602a8ca106603f" translate="yes" xml:space="preserve">
          <source>Right-Click -&amp;gt; Manage NuGet Packages</source>
          <target state="translated">右クリック-&amp;gt; NuGetパッケージの管理</target>
        </trans-unit>
        <trans-unit id="4404226825fd8913da119eed59015272595b178d" translate="yes" xml:space="preserve">
          <source>Root Dir - &lt;code&gt;rootDir&lt;/code&gt;</source>
          <target state="translated">ルートディレクトリ &lt;code&gt;rootDir&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46607474e45e56af8b5a3efd5baf9b86a8244110" translate="yes" xml:space="preserve">
          <source>Root Dirs - &lt;code&gt;rootDirs&lt;/code&gt;</source>
          <target state="translated">ルートDirs- &lt;code&gt;rootDirs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5045f031d11028d3e898f4dd9c0e8f030ca21936" translate="yes" xml:space="preserve">
          <source>Root Fields</source>
          <target state="translated">ルート分野</target>
        </trans-unit>
        <trans-unit id="a49cce94f7aee86f9844fd38022767d62fef80bd" translate="yes" xml:space="preserve">
          <source>Roughly speaking, once TypeScript&amp;rsquo;s compiler is done with checking your code, it &lt;em&gt;erases&lt;/em&gt; the types to produce the resulting &amp;ldquo;compiled&amp;rdquo; code. This means that once your code is compiled, the resulting plain JS code has no type information.</source>
          <target state="translated">大まかに言えば、TypeScriptのコンパイラがコードのチェックを完了すると、型が&lt;em&gt;消去&lt;/em&gt;され、結果の「コンパイルされた」コードが生成されます。これは、コードがコンパイルされると、結果のプレーンJSコードには型情報がないことを意味します。</target>
        </trans-unit>
        <trans-unit id="c8a67c2b7fee671c0d27e33fbdf91828d8346fc3" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;tsc --init&lt;/code&gt; in a directory to create an initial &lt;code&gt;tsconfig.json&lt;/code&gt; in this directory with preset defaults. Optionally pass command line arguments along with &lt;code&gt;--init&lt;/code&gt; to be stored in your initial tsconfig.json on creation.</source>
          <target state="translated">ディレクトリで &lt;code&gt;tsc --init&lt;/code&gt; を実行して、デフォルトのプリセットでこのディレクトリに初期 &lt;code&gt;tsconfig.json&lt;/code&gt; を作成します。オプションで、コマンドライン引数を &lt;code&gt;--init&lt;/code&gt; とともに渡して、作成時に最初のtsconfig.jsonに保存します。</target>
        </trans-unit>
        <trans-unit id="9aa34d67108614684377b79ebc1738ed47fa9c79" translate="yes" xml:space="preserve">
          <source>Run the TypeScript compiler to generate the corresponding d.ts files for JS files</source>
          <target state="translated">TypeScript コンパイラを実行して、JS ファイルに対応する d.ts ファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="7418ce51bc901e2c720b082e836bfd88f7024c62" translate="yes" xml:space="preserve">
          <source>Run the application and make sure that it works.</source>
          <target state="translated">アプリケーションを実行して、動作することを確認してください。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
