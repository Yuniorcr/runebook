<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="7ac670e2b8d400f3afe02add218c2edb8400544b" translate="yes" xml:space="preserve">
          <source>Run the compiler</source>
          <target state="translated">コンパイラを実行する</target>
        </trans-unit>
        <trans-unit id="7e0fc2451d2efaadd8b864a6b91ae00ff2dca3ac" translate="yes" xml:space="preserve">
          <source>Run the compiler in watch mode. Watch input files and trigger recompilation on changes. The implementation of watching files and directories can be configured using environment variable. See &lt;a href=&quot;configuring-watch&quot;&gt;configuring watch&lt;/a&gt; for more details.</source>
          <target state="translated">監視モードでコンパイラを実行します。入力ファイルを監視し、変更時に再コンパイルをトリガーします。ファイルとディレクトリの監視の実装は、環境変数を使用して構成できます。詳細については、&lt;a href=&quot;configuring-watch&quot;&gt;ウォッチの設定を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="541995e6de639764055cf456f41bfe89e00d49e7" translate="yes" xml:space="preserve">
          <source>Run the project</source>
          <target state="translated">プロジェクトの実行</target>
        </trans-unit>
        <trans-unit id="5ea024956a0df9ff6595fe749c1eb6c02cc2dc2f" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;tsc --build&lt;/code&gt; (&lt;code&gt;tsc -b&lt;/code&gt; for short) will do the following:</source>
          <target state="translated">実行 &lt;code&gt;tsc --build&lt;/code&gt; （ &lt;code&gt;tsc -b&lt;/code&gt; 略して）次の操作を行います：</target>
        </trans-unit>
        <trans-unit id="e7c0aa1e021efe3fc4486d609d25246d6751785f" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;tsc&lt;/code&gt; locally will compile the closest project defined by a &lt;code&gt;tsconfig.json&lt;/code&gt;, you can compile a set of TypeScript files by passing in a glob of files you want.</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; をローカルで実行すると、 &lt;code&gt;tsconfig.json&lt;/code&gt; で定義された最も近いプロジェクトがコンパイルされます。必要なファイルのグロブを渡すことで、TypeScriptファイルのセットをコンパイルできます。</target>
        </trans-unit>
        <trans-unit id="7a53f5887ae342b4a1cd086cadce904823bf70ae" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;tsc&lt;/code&gt; with these settings moves the files into the specified &lt;code&gt;dist&lt;/code&gt; folder:</source>
          <target state="translated">これらの設定で &lt;code&gt;tsc&lt;/code&gt; を実行すると、ファイルが指定された &lt;code&gt;dist&lt;/code&gt; フォルダーに移動します。</target>
        </trans-unit>
        <trans-unit id="88a02590b48e29c8ee3a28ec7ba7ee167b44c09c" translate="yes" xml:space="preserve">
          <source>Running your TypeScript web app</source>
          <target state="translated">TypeScript ウェブアプリを実行する</target>
        </trans-unit>
        <trans-unit id="2ccf2f0429535a5298f720be36cb9ea9f08e1bc4" translate="yes" xml:space="preserve">
          <source>Runtime Behavior</source>
          <target state="translated">ランタイム動作</target>
        </trans-unit>
        <trans-unit id="e2a41db8c3523e88ee5980c0cbd2788f6889d1f9" translate="yes" xml:space="preserve">
          <source>Sample: Dynamic Module Loading in System.js</source>
          <target state="translated">サンプル。System.jsでの動的モジュールロード</target>
        </trans-unit>
        <trans-unit id="c66144bb0d8421e5d08ae6900d1c0163e2522d70" translate="yes" xml:space="preserve">
          <source>Sample: Dynamic Module Loading in require.js</source>
          <target state="translated">サンプル。require.jsでの動的モジュールロード</target>
        </trans-unit>
        <trans-unit id="b5230ecdf4e78f0dd162281a0a78c6cdc853cbe8" translate="yes" xml:space="preserve">
          <source>Schema</source>
          <target state="translated">Schema</target>
        </trans-unit>
        <trans-unit id="1e96c4caea76817edca1b37676caff140bf67580" translate="yes" xml:space="preserve">
          <source>Schema can be found at: &lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;http://json.schemastore.org/tsconfig&lt;/a&gt;</source>
          <target state="translated">スキーマは&lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;http://json.schemastore.org/tsconfigにあります。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0b92d418e654bbd5c2c48b78244ecce9fb91d09" translate="yes" xml:space="preserve">
          <source>Scoping rules</source>
          <target state="translated">スコーピングルール</target>
        </trans-unit>
        <trans-unit id="aa7841d9d246c3e95a5b8f479b5b2166bbcd3d3d" translate="yes" xml:space="preserve">
          <source>Search for &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt; を検索します</target>
        </trans-unit>
        <trans-unit id="120e80cbcdda984e634ee6ea60b988e7bdcd424d" translate="yes" xml:space="preserve">
          <source>Search for &lt;strong&gt;.NET Core&lt;/strong&gt; in the project search bar</source>
          <target state="translated">プロジェクト検索バーで&lt;strong&gt;.NET Core&lt;/strong&gt;を検索します</target>
        </trans-unit>
        <trans-unit id="98cc363c0119e35d1c8070755fc4d4c2387aad71" translate="yes" xml:space="preserve">
          <source>Searching</source>
          <target state="translated">Searching</target>
        </trans-unit>
        <trans-unit id="f28a160d3aeb79cc4e72b1bcf1f1cea3eed98229" translate="yes" xml:space="preserve">
          <source>Second, compile your files using &lt;code&gt;--importHelpers&lt;/code&gt;:</source>
          <target state="translated">次に、-- &lt;code&gt;--importHelpers&lt;/code&gt; を使用してファイルをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="bcf02982afce00389878abc0de341f295e01470c" translate="yes" xml:space="preserve">
          <source>Second, the TypeScript compiler doesn&amp;rsquo;t allow spreads of type parameters from generic functions. That feature is expected in future versions of the language.</source>
          <target state="translated">次に、TypeScriptコンパイラは、ジェネリック関数からの型パラメータの拡散を許可しません。この機能は、言語の将来のバージョンで期待されています。</target>
        </trans-unit>
        <trans-unit id="f8a01008852da0be0cb83fb18c9ca0f90e85ba52" translate="yes" xml:space="preserve">
          <source>Second, the Typescript compiler doesn&amp;rsquo;t allow spreads of type parameters from generic functions. That feature is expected in future versions of the language.</source>
          <target state="translated">第二に、Typescriptコンパイラは、ジェネリック関数からの型パラメーターの分散を許可しません。この機能は、言語の将来のバージョンで期待されています。</target>
        </trans-unit>
        <trans-unit id="f5628af6cbb5e50d058efc6cdab3cec58a0d83b9" translate="yes" xml:space="preserve">
          <source>Secondly, using class fields to specialize properties from base classes also won&amp;rsquo;t work.</source>
          <target state="translated">次に、クラスフィールドを使用して基本クラスのプロパティを特殊化することもできません。</target>
        </trans-unit>
        <trans-unit id="7ff5a6dafd806f6d95302657c480d07703b64604" translate="yes" xml:space="preserve">
          <source>Sections</source>
          <target state="translated">Sections</target>
        </trans-unit>
        <trans-unit id="834c69b9d98efc1c3cec6d026570d3df634c7666" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../project-references&quot;&gt;Project References handbook page&lt;/a&gt; for more documentation.</source>
          <target state="translated">その他のドキュメントについては、&lt;a href=&quot;../project-references&quot;&gt;プロジェクトリファレンスハンドブックページ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="187875e55767d20df483d2fe4602ec06611fda25" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/module-resolution.html&quot;&gt;Module Resolution&lt;/a&gt; documentation for more details.</source>
          <target state="translated">詳細については、&lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/module-resolution.html&quot;&gt;モジュール解決の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="62fc6fcffeeb4b12902ccd59524362dbcce28787" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1256&quot;&gt;issue #1256&lt;/a&gt; for more information.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1256&quot;&gt;問題＃1256&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4c1f9292006cbb6b615fc48854ee208dde437f57" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files&quot;&gt;Type checking JavaScript Files documentation&lt;/a&gt; for more details.</source>
          <target state="translated">詳しくは、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files&quot;&gt;JavaScriptファイルのタイプチェックのドキュメント&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="fc473e27d9a7d29475aee306accd60b759bc0b30" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;more details on ts-loader here&lt;/a&gt;.</source>
          <target state="translated">参照してください。&lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ここでは、TS-ローダーの詳細を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0aaee337bc1d3ed089284b88a7fb251a773a6ed9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.typescriptlang.org/5bc00d38ab2cd134cf9690e7a4343bf5/module-function.d.ts.md&quot;&gt;Module: Functions&lt;/a&gt; for details of how that works, and the &lt;a href=&quot;../../modules&quot;&gt;Modules reference&lt;/a&gt; page.</source>
          <target state="translated">参照&lt;a href=&quot;https://www.typescriptlang.org/5bc00d38ab2cd134cf9690e7a4343bf5/module-function.d.ts.md&quot;&gt;モジュール：機能&lt;/a&gt;どのように作品の詳細については、および&lt;a href=&quot;../../modules&quot;&gt;モジュールのリファレンス&lt;/a&gt;ページ。</target>
        </trans-unit>
        <trans-unit id="b638ae7ad48e00c44c5cd48eb83e81ecbbf0a3c9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.json&lt;/a&gt; documentation for more details.</source>
          <target state="translated">詳細については、&lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.jsonの&lt;/a&gt;ドキュメントをご覧ください。</target>
        </trans-unit>
        <trans-unit id="d47a58ff1cef92314017a04dfa6b2492cbc2ccce" translate="yes" xml:space="preserve">
          <source>See how both lists change. &lt;code&gt;children&lt;/code&gt; now only contains the &lt;code&gt;&amp;lt;p&amp;gt;Hello, World&amp;lt;/p&amp;gt;&lt;/code&gt; element, and the &lt;code&gt;childNodes&lt;/code&gt; contains a &lt;code&gt;text&lt;/code&gt; node rather than two &lt;code&gt;p&lt;/code&gt; nodes. The &lt;code&gt;text&lt;/code&gt; part of the &lt;code&gt;NodeList&lt;/code&gt; is the literal &lt;code&gt;Node&lt;/code&gt; containing the text &lt;code&gt;TypeScript!&lt;/code&gt;. The &lt;code&gt;children&lt;/code&gt; list does not contain this &lt;code&gt;Node&lt;/code&gt; because it is not considered an &lt;code&gt;HTMLElement&lt;/code&gt;.</source>
          <target state="translated">両方のリストがどのように変化するかをご覧ください。 &lt;code&gt;children&lt;/code&gt; には &lt;code&gt;&amp;lt;p&amp;gt;Hello, World&amp;lt;/p&amp;gt;&lt;/code&gt; 要素のみが含まれ、 &lt;code&gt;childNodes&lt;/code&gt; には2つの &lt;code&gt;p&lt;/code&gt; ノードではなく &lt;code&gt;text&lt;/code&gt; ノードが含まれるようになりました。 &lt;code&gt;NodeList&lt;/code&gt; の &lt;code&gt;text&lt;/code&gt; 部分は、テキスト &lt;code&gt;TypeScript!&lt;/code&gt; を含むリテラル &lt;code&gt;Node&lt;/code&gt; です。。 &lt;code&gt;children&lt;/code&gt; リストは、この含まれていない &lt;code&gt;Node&lt;/code&gt; 、それが考慮されていないため &lt;code&gt;HTMLElement&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd93541328dd959138d1a2b853dfd1eceeacb71d" translate="yes" xml:space="preserve">
          <source>See main content</source>
          <target state="translated">主な内容を見る</target>
        </trans-unit>
        <trans-unit id="73a908746ad2d70ca1399fea9bcf57e61da44b2f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/tsconfig.json&quot;&gt;tsconfig.json wiki page&lt;/a&gt; for more details.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/tsconfig.json&quot;&gt;tsconfig.json wikiページ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6b065cbab34dec1a1806260f05403e1952398509" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; documentation for more information about ES Modules. See the &lt;a href=&quot;namespaces&quot;&gt;Namespaces&lt;/a&gt; documentation for more information about TypeScript namespaces.</source>
          <target state="translated">ESモジュールの詳細については、&lt;a href=&quot;modules&quot;&gt;モジュールの&lt;/a&gt;ドキュメントを参照してください。TypeScript名前空間の詳細については、&lt;a href=&quot;namespaces&quot;&gt;名前空間の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="077567d6271296de8ad4bd173bc8a26e4ff5d0f2" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; documentation for more information about modules. See the &lt;a href=&quot;namespaces&quot;&gt;Namespaces&lt;/a&gt; documentation for more information about namespaces.</source>
          <target state="translated">&lt;a href=&quot;modules&quot;&gt;モジュールの&lt;/a&gt;詳細については、モジュールのドキュメントを参照してください。&lt;a href=&quot;namespaces&quot;&gt;名前空間の&lt;/a&gt;詳細については、名前空間のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="64f2c787a02cbb7afa18cb007db73ea2664f916b" translate="yes" xml:space="preserve">
          <source>See the [[JSX]] wiki page for more information on using JSX in TypeScript.</source>
          <target state="translated">TypeScriptでのJSXの使用方法については、[[JSX]]wikiページを参照してください。</target>
        </trans-unit>
        <trans-unit id="2260a25895164f2770eb15c55e0e16389d6b104b" translate="yes" xml:space="preserve">
          <source>See where your usage of the module breaks, and start to fill out the index.d.ts</source>
          <target state="translated">モジュールの使用法のどこが壊れているかを確認して、index.d.ts を記入し始めます。</target>
        </trans-unit>
        <trans-unit id="cba80f4302feeb955dc9a7f866e6030dfdf9aef8" translate="yes" xml:space="preserve">
          <source>Select &lt;strong&gt;ASP.NET Core Web Application&lt;/strong&gt; and press the &lt;em&gt;Next&lt;/em&gt; button</source>
          <target state="translated">&lt;strong&gt;ASP.NET Core Web Application&lt;/strong&gt;を選択し、&lt;em&gt;Next&lt;/em&gt;ボタンを押します</target>
        </trans-unit>
        <trans-unit id="ed8feffbb3830d15b62b683a32f847857e90712a" translate="yes" xml:space="preserve">
          <source>Semicolon Formatter Option</source>
          <target state="translated">セミコロンフォーマッターオプション</target>
        </trans-unit>
        <trans-unit id="0f34f77f18943b88ab52ee5b7292da7cf41c6f44" translate="yes" xml:space="preserve">
          <source>Semicolon-Aware Code Edits</source>
          <target state="translated">セミコロンを意識したコード編集</target>
        </trans-unit>
        <trans-unit id="bcd9a6570954b6e91fefb181f3610d2793b5661b" translate="yes" xml:space="preserve">
          <source>Sequentially Added Properties</source>
          <target state="translated">順次追加されるプロパティ</target>
        </trans-unit>
        <trans-unit id="1676c891c1accface87dfecc3ee263cbd0629e6e" translate="yes" xml:space="preserve">
          <source>Set to false to disable warnings about unused labels.</source>
          <target state="translated">false に設定すると、未使用のラベルに関する警告を無効にします。</target>
        </trans-unit>
        <trans-unit id="7f05ebe6c7a2fc5869cacffec6b784fde7b8f889" translate="yes" xml:space="preserve">
          <source>Set up the build</source>
          <target state="translated">ビルドの設定</target>
        </trans-unit>
        <trans-unit id="40f24e0504d1b14397453f62baee68453ad2fba2" translate="yes" xml:space="preserve">
          <source>Set up the server</source>
          <target state="translated">サーバーの設定</target>
        </trans-unit>
        <trans-unit id="c027e79283f2d26edaa3eee382f8854c8daded5d" translate="yes" xml:space="preserve">
          <source>Sets the module system for the program. See the &lt;a href=&quot;docs/handbook/modules&quot;&gt;Modules&lt;/a&gt; reference page for more information. You very likely want &lt;code&gt;&quot;CommonJS&quot;&lt;/code&gt; for node projects.</source>
          <target state="translated">プログラムのモジュールシステムを設定します。詳細については、&lt;a href=&quot;docs/handbook/modules&quot;&gt;モジュールの&lt;/a&gt;リファレンスページを参照してください。ノードプロジェクトには &lt;code&gt;&quot;CommonJS&quot;&lt;/code&gt; が必要になる可能性が非常に高くなります。</target>
        </trans-unit>
        <trans-unit id="c4f87dbe5e7d0d324c8530cef57ba653425df0e3" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;baseUrl&lt;/code&gt; informs the compiler where to find modules. All module imports with non-relative names are assumed to be relative to the &lt;code&gt;baseUrl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;baseUrl&lt;/code&gt; を設定すると、モジュールの検索場所がコンパイラに通知されます。非相対名でのすべてのモジュールのインポートは、 &lt;code&gt;baseUrl&lt;/code&gt; に関連していると見なされます。</target>
        </trans-unit>
        <trans-unit id="f2b91c337f2f0946708a5154da2e0832a39c7b5b" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;strictNullChecks&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; will raise an error that you have not made a guarantee that the &lt;code&gt;loggedInUser&lt;/code&gt; exists before trying to use it.</source>
          <target state="translated">&lt;code&gt;strictNullChecks&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定すると、 &lt;code&gt;loggedInUser&lt;/code&gt; が使用される前に存在することを保証していないというエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="51341becf9d4b848eec8afc734c39a0799738e80" translate="yes" xml:space="preserve">
          <source>Setting a top-level property &lt;code&gt;compileOnSave&lt;/code&gt; signals to the IDE to generate all files for a given tsconfig.json upon saving.</source>
          <target state="translated">最上位のプロパティ &lt;code&gt;compileOnSave&lt;/code&gt; をIDEに設定して、保存時に特定のtsconfig.jsonのすべてのファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="53989c11f338fd824665321c75b617ecdf354fe7" translate="yes" xml:space="preserve">
          <source>Setting compiler options in &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuild projects&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuildプロジェクトでの&lt;/a&gt;コンパイラオプションの設定。</target>
        </trans-unit>
        <trans-unit id="90b8ab6e9c58f23f02ac47d035bce949bcd397b5" translate="yes" xml:space="preserve">
          <source>Setting compiler options in &lt;a href=&quot;tsconfig-json&quot;&gt;&lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; files.</source>
          <target state="translated">&lt;a href=&quot;tsconfig-json&quot;&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; &lt;/a&gt;ファイルでコンパイラオプションを設定します。</target>
        </trans-unit>
        <trans-unit id="7a6795689bb9ea8c8cb6764f05c1f6f935ee04dc" translate="yes" xml:space="preserve">
          <source>Setting the new compiler flag &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; indicates that the module loader performs some kind of synthetic default import member creation not indicated in the imported .ts or .d.ts. The compiler will infer the existence of a &lt;code&gt;default&lt;/code&gt; export that has the shape of the entire module itself.</source>
          <target state="translated">新しいコンパイラフラグ &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; を設定すると、モジュールローダーは、インポートされた.tsまたは.d.tsに示されていない、ある種の合成デフォルトインポートメンバーの作成を実行します。コンパイラーは、モジュール全体の形状を持つ &lt;code&gt;default&lt;/code&gt; エクスポートの存在を推測します。</target>
        </trans-unit>
        <trans-unit id="2e71f746315f905d8f4bde8180b1dba0027a8422" translate="yes" xml:space="preserve">
          <source>Setting up your Directories</source>
          <target state="translated">ディレクトリの設定</target>
        </trans-unit>
        <trans-unit id="62cd1351e8c4eaed3d7e33f00093319c1143b315" translate="yes" xml:space="preserve">
          <source>Setting up your Project to emit .d.ts files</source>
          <target state="translated">.d.tsファイルを出力するようにプロジェクトを設定する</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="ba3a6a9b6d048ac70a293087f03215c195461fd9" translate="yes" xml:space="preserve">
          <source>Shadowing should &lt;em&gt;usually&lt;/em&gt; be avoided in the interest of writing clearer code. While there are some scenarios where it may be fitting to take advantage of it, you should use your best judgement.</source>
          <target state="translated">より明確なコードを作成するために、&lt;em&gt;通常は&lt;/em&gt;シャドウイングを回避する必要があります。それを利用するのに適しているシナリオがいくつかありますが、最善の判断をする必要があります。</target>
        </trans-unit>
        <trans-unit id="274d75123478b9323ff5c010c5717e0dad76caf9" translate="yes" xml:space="preserve">
          <source>Shorthand ambient module declarations</source>
          <target state="translated">省略可能なアンビエントモジュール宣言</target>
        </trans-unit>
        <trans-unit id="8f46f045bb2fdc1956a2f236cfedf0e1e227f9e8" translate="yes" xml:space="preserve">
          <source>Shorthand ambient modules</source>
          <target state="translated">短縮型アンビエントモジュール</target>
        </trans-unit>
        <trans-unit id="d63965efaf94e11d119af70827afc578c1c99dd9" translate="yes" xml:space="preserve">
          <source>Show diagnostic information.</source>
          <target state="translated">診断情報を表示します。</target>
        </trans-unit>
        <trans-unit id="ea62715d57491630afc7339cce6c9e3316b090c6" translate="yes" xml:space="preserve">
          <source>Show verbose diagnostic information</source>
          <target state="translated">冗長な診断情報を表示</target>
        </trans-unit>
        <trans-unit id="cd0e108f1f4412f32e9c055f41ef6dfdceb42a42" translate="yes" xml:space="preserve">
          <source>Similar to a &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive, which serves as a declaration of &lt;em&gt;dependency&lt;/em&gt;, a &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive declares a dependency on a package.</source>
          <target state="translated">類似 &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; の宣言として機能指令、&lt;em&gt;依存性&lt;/em&gt;、 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; ディレクティブは、パッケージの依存関係を宣言する。</target>
        </trans-unit>
        <trans-unit id="7ee4acd9eb753cecdb4b91f99daa97963b128504" translate="yes" xml:space="preserve">
          <source>Similar to array spread, spreading an object can be handy to get a shallow copy:</source>
          <target state="translated">配列のスプレッドと同様に、オブジェクトのスプレッドは浅いコピーを取得するのに便利です。</target>
        </trans-unit>
        <trans-unit id="d647d33af76ba25c85ee64e3adf6ff361ad569ea" translate="yes" xml:space="preserve">
          <source>Similar to union and intersection types, conditional types are not permitted to reference themselves recursively. For example the following is an error.</source>
          <target state="translated">ユニオン型やインターセクション型と同様に、条件付き型も再帰的に自分自身を参照することは許されていません。例えば、次のようなエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="ea6e185bb85cecc9661d326572fea7b76b1b1495" translate="yes" xml:space="preserve">
          <source>Similarly a default import (i.e. &lt;code&gt;import d from &quot;foo&quot;&lt;/code&gt;) for a CommonJS/AMD/UMD module as equivalent to &lt;code&gt;const d = require(&quot;foo&quot;).default&lt;/code&gt;.Most of the CommonJS/AMD/UMD modules available today do not have a &lt;code&gt;default&lt;/code&gt; export, making this import pattern practically unusable to import non-ES modules (i.e. CommonJS/AMD/UMD). For instance &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; or &lt;code&gt;import express from &quot;express&quot;&lt;/code&gt; are not allowed.</source>
          <target state="translated">同様に、 &lt;code&gt;const d = require(&quot;foo&quot;).default&lt;/code&gt; 同等のCommonJS / AMD / UMDモジュールのデフォルトのインポート（つまり &lt;code&gt;import d from &quot;foo&quot;&lt;/code&gt; ）。デフォルト。今日利用できるほとんどのCommonJS / AMD / UMDモジュールには、 &lt;code&gt;default&lt;/code&gt; 非ESモジュールをインポートすることは事実上使用できないこのインポートパターンを作り、輸出、（すなわちCommonJS / AMD / UMD）。たとえば &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; または &lt;code&gt;import express from &quot;express&quot;&lt;/code&gt; は許可されていません。</target>
        </trans-unit>
        <trans-unit id="d85b3b71be4bb5105a2a383a357dfdd56066b345" translate="yes" xml:space="preserve">
          <source>Similarly to how we can use interfaces to describe function types, we can also describe types that we can &amp;ldquo;index into&amp;rdquo; like &lt;code&gt;a[10]&lt;/code&gt;, or &lt;code&gt;ageMap[&quot;daniel&quot;]&lt;/code&gt;. Indexable types have an &lt;em&gt;index signature&lt;/em&gt; that describes the types we can use to index into the object, along with the corresponding return types when indexing. Let&amp;rsquo;s take an example:</source>
          <target state="translated">インターフェイスを使用して関数タイプを記述する方法と同様に &lt;code&gt;a[10]&lt;/code&gt; や &lt;code&gt;ageMap[&quot;daniel&quot;]&lt;/code&gt; ように「インデックス付け」できるタイプを記述することもできます。&lt;em&gt;インデックス&lt;/em&gt;可能な型には、オブジェクトにインデックスを付けるために使用できる型と、インデックス作成時に対応する戻り値の型を説明する&lt;em&gt;インデックスシグネチャ&lt;/em&gt;があり&lt;em&gt;ます&lt;/em&gt;。例を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="adb395172c71ccd54b1326d899f4d06456ede0c1" translate="yes" xml:space="preserve">
          <source>Similarly to interfaces, namespaces of the same name will also merge their members. Since namespaces create both a namespace and a value, we need to understand how both merge.</source>
          <target state="translated">インタフェースと同様に、同じ名前の名前空間もメンバをマージします。名前空間は名前空間と値の両方を作成するので、両方がどのようにマージされるかを理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="59a8554ef56814f4114354c3cfa0c5ed809a9eaa" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;--target ES2017&lt;/code&gt; will instruct the compiler not to transform ES2017-specific features like &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;.</source>
          <target state="translated">同様に、-- &lt;code&gt;--target ES2017&lt;/code&gt; は、 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; などのES2017固有の機能を変換しないようにコンパイラーに指示します。</target>
        </trans-unit>
        <trans-unit id="ebb6eff56def1e9c8faa2f831e045e194b4e3480" translate="yes" xml:space="preserve">
          <source>Similarly, a non-relative import will follow the Node.js resolution logic, first looking up a file, then looking up an applicable folder. So &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt; in source file &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; would result in the following lookups:</source>
          <target state="translated">同様に、非相対インポートはNode.js解決ロジックに従い、最初にファイルを検索し、次に適切なフォルダーを検索します。したがって、ソースファイル &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; の &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt; すると、次のルックアップが行われます。</target>
        </trans-unit>
        <trans-unit id="8e9295d32c7a26ac7fc56081bcf2d7aa9d700307" translate="yes" xml:space="preserve">
          <source>Similarly, destructuring can be used in function parameter declarations:</source>
          <target state="translated">同様に、関数のパラメータ宣言でもデストラクチャリングを使用することができます。</target>
        </trans-unit>
        <trans-unit id="034cda522b7de683abd945b4a3cdbb3d70d9b104" translate="yes" xml:space="preserve">
          <source>Similarly, namespaces can be used to extend enums with static members:</source>
          <target state="translated">同様に、名前空間を使用して、静的メンバを持つ列挙型を拡張することができます。</target>
        </trans-unit>
        <trans-unit id="15a650d9a4ea0756304f469dcbad9a5ff7886ae3" translate="yes" xml:space="preserve">
          <source>Similarly, the global scope can be augmented from modules using a &lt;code&gt;declare global&lt;/code&gt; declarations:</source>
          <target state="translated">同様に、グローバルスコープは、 &lt;code&gt;declare global&lt;/code&gt; 宣言を使用してモジュールから拡張できます。</target>
        </trans-unit>
        <trans-unit id="44c459aed9d0d7b781bc8721c975f3ccca45175e" translate="yes" xml:space="preserve">
          <source>Similarly, try removing all the arguments to the greeter call. TypeScript will let you know that you have called this function with an unexpected number of parameters. In both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations you provide.</source>
          <target state="translated">同様に、グリーターの呼び出しの引数をすべて削除してみてください。TypeScript は、予想外の数のパラメータを使ってこの関数を呼び出したことを知らせてくれます。どちらの場合も、TypeScript はコードの構造と提供された型のアノテーションの両方に基づいて静的な解析を行うことができます。</target>
        </trans-unit>
        <trans-unit id="a96df9471d886c6a3944738c14a4e817cb32e52e" translate="yes" xml:space="preserve">
          <source>Similarly, you can merge several different objects. In the following example, &lt;code&gt;merged&lt;/code&gt; will have properties from &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;baz&lt;/code&gt;.</source>
          <target state="translated">同様に、いくつかの異なるオブジェクトをマージできます。次の例では、 &lt;code&gt;merged&lt;/code&gt; には &lt;code&gt;foo&lt;/code&gt; 、 &lt;code&gt;bar&lt;/code&gt; 、および &lt;code&gt;baz&lt;/code&gt; のプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="0e344fea73da74bac69381f07e6bac9722af29f9" translate="yes" xml:space="preserve">
          <source>Similarly, you could write a utility type like &lt;code&gt;Writable&lt;/code&gt; mapped type that strips away &lt;code&gt;readonly&lt;/code&gt;-ness, and that would convert &lt;code&gt;readonly&lt;/code&gt; array containers back to their mutable equivalents.</source>
          <target state="translated">同様に、 &lt;code&gt;readonly&lt;/code&gt; -ness を取り除き、読み取り &lt;code&gt;readonly&lt;/code&gt; 配列コンテナーを変更可能な同等のものに変換する &lt;code&gt;Writable&lt;/code&gt; マップタイプのようなユーティリティタイプを書くことができます。</target>
        </trans-unit>
        <trans-unit id="8aacbc2fc90c4a9233935fa887158e588886b733" translate="yes" xml:space="preserve">
          <source>Simple Combinations: One name, multiple meanings</source>
          <target state="translated">シンプルな組み合わせ。一つの名前に複数の意味</target>
        </trans-unit>
        <trans-unit id="c15fa4b758d35cc97d9959bcc45edd294156d605" translate="yes" xml:space="preserve">
          <source>Simple Example</source>
          <target state="translated">簡単な例</target>
        </trans-unit>
        <trans-unit id="1c315460161fd9403852d4c74317febae46bf2d2" translate="yes" xml:space="preserve">
          <source>SimpleModule.ts</source>
          <target state="translated">SimpleModule.ts</target>
        </trans-unit>
        <trans-unit id="b2ce6f775436f49655c281cba1ff8bd7971a0459" translate="yes" xml:space="preserve">
          <source>Simplified &lt;code&gt;props&lt;/code&gt; type management in React</source>
          <target state="translated">Reactでの &lt;code&gt;props&lt;/code&gt; タイプ管理の簡素化</target>
        </trans-unit>
        <trans-unit id="e0d662efaa9ae2f635437fd38e1b30b750f5eb5c" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;keyof&lt;/code&gt; now reflects the presence of a numeric index signature by including type &lt;code&gt;number&lt;/code&gt; in the key type, mapped types such as &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; work correctly when applied to object types with numeric index signatures:</source>
          <target state="translated">以来 &lt;code&gt;keyof&lt;/code&gt; 今タイプなどによって数値インデックス署名の存在反映 &lt;code&gt;number&lt;/code&gt; 、などのマッピングされたタイプのキータイプを &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; と &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; 数値インデックス署名とオブジェクト・タイプに適用されたときに正しく作業：</target>
        </trans-unit>
        <trans-unit id="3d0a96b99fe271899593be449688b7fa5ea47eef" translate="yes" xml:space="preserve">
          <source>Since JavaScript automatically terminates the &lt;code&gt;return&lt;/code&gt; statement at the end of the line, the object literal becomes a block.</source>
          <target state="translated">JavaScriptは &lt;code&gt;return&lt;/code&gt; ステートメントを行の終わりで自動的に終了するため、オブジェクトリテラルはブロックになります。</target>
        </trans-unit>
        <trans-unit id="e7f102f64416cbc39d1e3262772e0a216eb7ce37" translate="yes" xml:space="preserve">
          <source>Since JavaScript supports classes and object-oriented programming, so does TypeScript. You can use an interface declaration with classes:</source>
          <target state="translated">JavaScript はクラスやオブジェクト指向プログラミングをサポートしているので、TypeScript も同様です。クラスを使ったインターフェース宣言を使うことができます。</target>
        </trans-unit>
        <trans-unit id="cce35890852819c246c89e64575a83cc751e8c48" translate="yes" xml:space="preserve">
          <source>Since declarations in one file can affect type checking in other files, some errors may not be detected when &lt;code&gt;--skipLibCheck&lt;/code&gt; is specified. For example, if a non-declaration file augments a type declared in a declaration file, errors may result that are only reported when the declaration file is checked. However, in practice such situations are rare.</source>
          <target state="translated">1つのファイルでの宣言は他のファイルでの型チェックに影響を与える可能性があるため、 &lt;code&gt;--skipLibCheck&lt;/code&gt; が指定されていると、一部のエラーが検出されない場合があります。たとえば、非宣言ファイルが宣言ファイルで宣言された型を補強する場合、宣言ファイルがチェックされたときにのみ報告されるエラーが発生する可能性があります。ただし、実際にはそのような状況はまれです。</target>
        </trans-unit>
        <trans-unit id="91fd691cb7cba41ab5d488469fc7cd906ef14a39" translate="yes" xml:space="preserve">
          <source>Since nullable types are implemented with a union, you need to use a type guard to get rid of the &lt;code&gt;null&lt;/code&gt;. Fortunately, this is the same code you&amp;rsquo;d write in JavaScript:</source>
          <target state="translated">null許容型はunionで実装されているため、 &lt;code&gt;null&lt;/code&gt; を取り除くには型ガードを使用する必要があります。さいわい、これはJavaScriptで作成するコードと同じです。</target>
        </trans-unit>
        <trans-unit id="d7d710dcc7a9a1a3a0ae270f066743ad193628a1" translate="yes" xml:space="preserve">
          <source>Since ranges have the potential to overlap, determining which redirect applies is order-specific. That means in the above example, even though both the &lt;code&gt;&amp;gt;=3.2&lt;/code&gt; and the &lt;code&gt;&amp;gt;=3.1&lt;/code&gt; matchers support TypeScript 3.2 and above, reversing the order could have different behavior, so the above sample would not be equivalent to the following.</source>
          <target state="translated">範囲は重複する可能性があるため、適用されるリダイレクトの決定は順序に固有です。つまり、上記の例では、 &lt;code&gt;&amp;gt;=3.2&lt;/code&gt; と &lt;code&gt;&amp;gt;=3.1&lt;/code&gt; の両方のマッチャーがTypeScript 3.2以上をサポートしていますが、順序を逆にすると動作が異なる可能性があるため、上記のサンプルは次のコードと同等ではありません。</target>
        </trans-unit>
        <trans-unit id="4f878058a9de82078d9e40fb2687f87811aefbf7" translate="yes" xml:space="preserve">
          <source>Since the above syntax cannot be used in &lt;code&gt;.tsx&lt;/code&gt; files, an alternate type assertion operator should be used: &lt;code&gt;as&lt;/code&gt;. The example can easily be rewritten with the &lt;code&gt;as&lt;/code&gt; operator.</source>
          <target state="translated">上記の構文は &lt;code&gt;.tsx&lt;/code&gt; ファイルでは使用できないため、別のタイプのアサーション演算子を使用する必要があります： &lt;code&gt;as&lt;/code&gt; 。この例は、 &lt;code&gt;as&lt;/code&gt; 演算子を使用して簡単に書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="c94167207ee9c90316742f73b6eca79827716dff" translate="yes" xml:space="preserve">
          <source>Since the class uses &lt;code&gt;this&lt;/code&gt; types, you can extend it and the new class can use the old methods with no changes.</source>
          <target state="translated">クラスは &lt;code&gt;this&lt;/code&gt; タイプを使用するため、クラスを拡張でき、新しいクラスは変更なしで古いメソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="3f878409b3dc13d4ef49d4cf4543cf7848bae266" translate="yes" xml:space="preserve">
          <source>Since the stricter checks may uncover previously unreported errors, this is a breaking change in &lt;code&gt;--strict&lt;/code&gt; mode.</source>
          <target state="translated">より厳密なチェックでは、以前に報告されていないエラーが見つかる可能性があるため、これは &lt;code&gt;--strict&lt;/code&gt; モードでの重大な変更です。</target>
        </trans-unit>
        <trans-unit id="21d47d51fa3ee1bdfdfae971aec4e563a10a3e93" translate="yes" xml:space="preserve">
          <source>Since there is no natural syntax for specifying generic type parameters in Javascript, an unspecified type parameter defaults to &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Javascriptでジェネリック型パラメーターを指定するための自然な構文はないため、未指定の型パラメーターはデフォルトで &lt;code&gt;any&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="b322b635e697fa374578b14cb6639ca067a1c956" translate="yes" xml:space="preserve">
          <source>Since there is no way to specify optionality on parameters in pre-ES2015 Javascript, all function parameters in &lt;code&gt;.js&lt;/code&gt; file are considered optional. Calls with fewer arguments than the declared number of parameters are allowed.</source>
          <target state="translated">ES2015より前のJavaScriptではパラメーターにオプションを指定する方法がないため、 &lt;code&gt;.js&lt;/code&gt; ファイル内のすべての関数パラメーターはオプションと見なされます。宣言されたパラメーター数よりも引数の少ない呼び出しが許可されます。</target>
        </trans-unit>
        <trans-unit id="1bb189160ac70073ac7ebfc075b0fbe0a1f9844a" translate="yes" xml:space="preserve">
          <source>Since this is a breaking change, you may need to know about the workarounds which are the same as those for strict object literal checks:</source>
          <target state="translated">これはブレークする変更なので、厳密なオブジェクトリテラルチェックと同じ回避策を知っておく必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="29a785f99454f565683fe81e09a33e40c8e76702" translate="yes" xml:space="preserve">
          <source>Single-file transpilers don&amp;rsquo;t know whether &lt;code&gt;someType&lt;/code&gt; produces a value or not, so it&amp;rsquo;s an error to export a name that only refers to a type.</source>
          <target state="translated">単一ファイルのトランス &lt;code&gt;someType&lt;/code&gt; は、someTypeが値を生成するかどうかを認識しないため、型のみを参照する名前をエクスポートするのはエラーです。</target>
        </trans-unit>
        <trans-unit id="3e13335331cc080e9ba88a13ad1230b8a0576896" translate="yes" xml:space="preserve">
          <source>Skip Default Lib Check - &lt;code&gt;skipDefaultLibCheck&lt;/code&gt;</source>
          <target state="translated">デフォルトの &lt;code&gt;skipDefaultLibCheck&lt;/code&gt; チェックをスキップ-skipDefaultLibCheck</target>
        </trans-unit>
        <trans-unit id="234395dee2758492ba2797c4d5cd3f566645aff3" translate="yes" xml:space="preserve">
          <source>Skip Lib Check - &lt;code&gt;skipLibCheck&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;skipLibCheck&lt;/code&gt; スキップ-skipLibCheck</target>
        </trans-unit>
        <trans-unit id="0c990fd202f278ef0f0d7845a5a9243bf4d29dd3" translate="yes" xml:space="preserve">
          <source>Skip type checking of &lt;a href=&quot;triple-slash-directives#-reference-no-default-libtrue&quot;&gt;default library declaration files&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;triple-slash-directives#-reference-no-default-libtrue&quot;&gt;デフォルトのライブラリ宣言ファイルの&lt;/a&gt;型チェックをスキップします。</target>
        </trans-unit>
        <trans-unit id="12501fd6f728bd1473ea7478cbc5c3dcd63db265" translate="yes" xml:space="preserve">
          <source>Skip type checking of all declaration files (&lt;code&gt;*.d.ts&lt;/code&gt;).</source>
          <target state="translated">すべての宣言ファイル（ &lt;code&gt;*.d.ts&lt;/code&gt; ）の型チェックをスキップします。</target>
        </trans-unit>
        <trans-unit id="d66051d7634cd7ff52bac26aa8397aa830ebea55" translate="yes" xml:space="preserve">
          <source>Skip type checking of declaration files.</source>
          <target state="translated">宣言ファイルの型チェックをスキップします。</target>
        </trans-unit>
        <trans-unit id="597c64f117d2aa2c1f26f6d20a44dfe498e5769f" translate="yes" xml:space="preserve">
          <source>Smaller samples for different types of libraries</source>
          <target state="translated">さまざまなタイプのライブラリに対応するため、サンプル数を少なくしています。</target>
        </trans-unit>
        <trans-unit id="65491f46fdafeaf0b665cd04a110e111c9391e5e" translate="yes" xml:space="preserve">
          <source>Smarter Auto-Import Syntax</source>
          <target state="translated">よりスマートな自動インポート構文</target>
        </trans-unit>
        <trans-unit id="bb1eae075750d4a174787dc1c2252c01719c35af" translate="yes" xml:space="preserve">
          <source>Smarter union type checking</source>
          <target state="translated">よりスマートなユニオンタイプのチェック</target>
        </trans-unit>
        <trans-unit id="4597cc07c4a8e366226dba892e751bcdcaed8c3c" translate="yes" xml:space="preserve">
          <source>So far, the handbook has covered types which are atomic objects. However, as you model more types you find yourself looking for tools which let you compose or combine existing types instead of creating them from scratch.</source>
          <target state="translated">これまでのところ、このハンドブックではアトミックオブジェクトである型を扱ってきました。しかし、より多くの型をモデル化していくうちに、ゼロから型を作成するのではなく、既存の型を合成したり組み合わせたりできるツールを探していることに気づくでしょう。</target>
        </trans-unit>
        <trans-unit id="679bf06653c38306e3510cb4091b394d4e625ab8" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve used &amp;ldquo;compatible&amp;rdquo;, which is not a term defined in the language spec. In TypeScript, there are two kinds of compatibility: subtype and assignment. These differ only in that assignment extends subtype compatibility with rules to allow assignment to and from &lt;code&gt;any&lt;/code&gt;, and to and from &lt;code&gt;enum&lt;/code&gt; with corresponding numeric values.</source>
          <target state="translated">これまでは、「互換性」を使用してきましたが、これは言語仕様で定義された用語ではありません。TypeScriptには、サブタイプと割り当ての2種類の互換性があります。これらは、代入がルールとのサブタイプの互換性を拡張する点でのみ異なり、 &lt;code&gt;any&lt;/code&gt; との間、および対応する数値を持つ &lt;code&gt;enum&lt;/code&gt; との間の代入を許可します。</target>
        </trans-unit>
        <trans-unit id="67ef5716ef1d4255fdfc3266bf74a100eaaddc5f" translate="yes" xml:space="preserve">
          <source>So given the following input, the resulting &lt;code&gt;.js&lt;/code&gt; file will include an import to &lt;code&gt;tslib&lt;/code&gt; and use the &lt;code&gt;__assign&lt;/code&gt; helper from it instead of inlining it.</source>
          <target state="translated">したがって、次の入力を指定すると、結果の &lt;code&gt;.js&lt;/code&gt; ファイルには &lt;code&gt;tslib&lt;/code&gt; へのインポートが含まれ、インライン化する代わりに、そこから &lt;code&gt;__assign&lt;/code&gt; ヘルパーを使用します。</target>
        </trans-unit>
        <trans-unit id="186ee8ceb588d6a258ee6dbb023a30a68c051a54" translate="yes" xml:space="preserve">
          <source>So in the above example, if we&amp;rsquo;re importing from &lt;code&gt;&quot;package-name&quot;&lt;/code&gt;, we&amp;rsquo;ll try to resolve from &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; (and other relevant paths) when running in TypeScript 3.1. If we import from &lt;code&gt;package-name/foo&lt;/code&gt;, we&amp;rsquo;ll try to look for &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; and &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt;.</source>
          <target state="translated">したがって、上記の例では、 &lt;code&gt;&quot;package-name&quot;&lt;/code&gt; からインポートする場合、 &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; （およびその他の関連するもの）から解決しようとしますパス）TypeScript 3.1で実行する場合。 &lt;code&gt;package-name/foo&lt;/code&gt; からインポートする場合、 &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; および &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0d35f3444ee195674f39dbd3f6a1e50ed4c2a4e" translate="yes" xml:space="preserve">
          <source>So to exclude a file from the compilation, you need to exclude it and &lt;strong&gt;all&lt;/strong&gt; files that have an &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive to it.</source>
          <target state="translated">そのため、コンパイルからファイルを除外するには、&lt;strong&gt;その&lt;/strong&gt;ファイルと、 &lt;code&gt;import&lt;/code&gt; または &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; ディレクティブを持つ&lt;strong&gt;すべての&lt;/strong&gt;ファイルを除外する必要があります。</target>
        </trans-unit>
        <trans-unit id="d182650064f5464ef393db53c7c8e6d35c2c988e" translate="yes" xml:space="preserve">
          <source>Some elements do not exhibit unique properties and so they just return &lt;code&gt;HTMLElement&lt;/code&gt;, but other types do have unique properties and methods so they return their specific interface (which will extend from or implement &lt;code&gt;HTMLElement&lt;/code&gt;).</source>
          <target state="translated">一部の要素は一意のプロパティを示さないため、 &lt;code&gt;HTMLElement&lt;/code&gt; を返すだけですが、他のタイプは一意のプロパティとメソッドを持っているため、特定のインターフェイス（ &lt;code&gt;HTMLElement&lt;/code&gt; から拡張または実装されます）を返します。</target>
        </trans-unit>
        <trans-unit id="70e17d206c518dbadda1af7b806ce18ec461ecfb" translate="yes" xml:space="preserve">
          <source>Some examples of code which does not work when &lt;code&gt;isolatedModules&lt;/code&gt; is enabled.</source>
          <target state="translated">&lt;code&gt;isolatedModules&lt;/code&gt; が有効になっていると機能しないコードの例。</target>
        </trans-unit>
        <trans-unit id="e4bc2f7646ea9a289aefdb5e74620f8df8809b70" translate="yes" xml:space="preserve">
          <source>Some examples of functions returning &lt;code&gt;never&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 戻らない関数の例：</target>
        </trans-unit>
        <trans-unit id="dd8e2e31e759369daed94a0bdfbe83bde2d68c4a" translate="yes" xml:space="preserve">
          <source>Some examples of use of functions returning &lt;code&gt;never&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; を返す関数の使用例：</target>
        </trans-unit>
        <trans-unit id="ac3ff6970ef7ae26b60be3c11566e4ffed69c47e" translate="yes" xml:space="preserve">
          <source>Some examples use the &lt;code&gt;reflect-metadata&lt;/code&gt; library which adds a polyfill for an &lt;a href=&quot;https://github.com/rbuckton/ReflectDecorators&quot;&gt;experimental metadata API&lt;/a&gt;. This library is not yet part of the ECMAScript (JavaScript) standard. However, once decorators are officially adopted as part of the ECMAScript standard these extensions will be proposed for adoption.</source>
          <target state="translated">一部の例では、&lt;a href=&quot;https://github.com/rbuckton/ReflectDecorators&quot;&gt;試験的なメタデータAPIに&lt;/a&gt;ポリフィルを追加するReflect &lt;code&gt;reflect-metadata&lt;/code&gt; ライブラリを使用しています。このライブラリはまだECMAScript（JavaScript）標準の一部ではありません。ただし、ECMAScript標準の一部としてデコレータが正式に採用されると、これらの拡張機能の採用が提案されます。</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">いくつかの例を紹介します。</target>
        </trans-unit>
        <trans-unit id="7d3c07f60789aec8bf6b6718acaa48138f0167f9" translate="yes" xml:space="preserve">
          <source>Some kinds of declarations can be combined across multiple declarations. For example, &lt;code&gt;class C { }&lt;/code&gt; and &lt;code&gt;interface C { }&lt;/code&gt; can co-exist and both contribute properties to the &lt;code&gt;C&lt;/code&gt; types.</source>
          <target state="translated">いくつかの種類の宣言は、複数の宣言にわたって組み合わせることができます。たとえば、 &lt;code&gt;class C { }&lt;/code&gt; と &lt;code&gt;interface C { }&lt;/code&gt; は共存でき、どちらも &lt;code&gt;C&lt;/code&gt; 型にプロパティを提供します。</target>
        </trans-unit>
        <trans-unit id="7a1a6bb7e5995629cd2728c008f6bd029c77d013" translate="yes" xml:space="preserve">
          <source>Some libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; modules. These libraries can be accessed through either an import or a global variable. For example:</source>
          <target state="translated">一部のライブラリは、多くのモジュールローダーで使用するように設計されているか、モジュールをロードしない（グローバル変数）ように設計されています。これらは&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;モジュールとして知られています。これらのライブラリには、インポートまたはグローバル変数のいずれかを介してアクセスできます。例えば：</target>
        </trans-unit>
        <trans-unit id="2bd424c5780b5812c140ab0c2b98f3a8f43528b7" translate="yes" xml:space="preserve">
          <source>Some libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; or &lt;a href=&quot;http://isomorphic.net&quot;&gt;Isomorphic&lt;/a&gt; modules. These libraries can be accessed through either an import or a global variable.</source>
          <target state="translated">一部のライブラリは、多くのモジュールローダーで使用するように設計されているか、モジュールをロードしない（グローバル変数）ように設計されています。これらは&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;または&lt;a href=&quot;http://isomorphic.net&quot;&gt;同形&lt;/a&gt;モジュールとして知られています。これらのライブラリには、インポートまたはグローバル変数のいずれかを介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="6d579c1b603ba9bdb7b036601db29274335578ec" translate="yes" xml:space="preserve">
          <source>Some libraries only work in a module loader environment. For example, &lt;code&gt;express&lt;/code&gt; only works in Node.js and must be loaded using the CommonJS &lt;code&gt;require&lt;/code&gt; function.</source>
          <target state="translated">一部のライブラリは、モジュールローダー環境でのみ機能します。たとえば、 &lt;code&gt;express&lt;/code&gt; はNode.jsでのみ機能し、CommonJSの &lt;code&gt;require&lt;/code&gt; 関数を使用してロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="6e9585e6951e2664b628f35bed4a5c31cb046a11" translate="yes" xml:space="preserve">
          <source>Some module loaders such as &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt; and &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt; allow non-JavaScript content to be imported. These typically use a prefix or suffix to indicate the special loading semantics. Wildcard module declarations can be used to cover these cases.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt;や&lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt;などの一部のモジュールローダーでは、JavaScript以外のコンテンツをインポートできます。通常、これらは接頭辞または接尾辞を使用して、特別な読み込みセマンティクスを示します。ワイルドカードモジュール宣言を使用して、これらのケースをカバーできます。</target>
        </trans-unit>
        <trans-unit id="b9daed87f8143d8fb1626c2d066b5622304dcdba" translate="yes" xml:space="preserve">
          <source>Some module loaders such as &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.md#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt; and &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md&quot;&gt;AMD&lt;/a&gt; allow non-JavaScript content to be imported. These typically use a prefix or suffix to indicate the special loading semantics. Wildcard module declarations can be used to cover these cases.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.md#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt;や&lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md&quot;&gt;AMD&lt;/a&gt;などの一部のモジュールローダーでは、JavaScript以外のコンテンツをインポートできます。これらは通常、接頭辞または接尾辞を使用して、特別なロードセマンティクスを示します。ワイルドカードモジュール宣言を使用して、これらのケースをカバーできます。</target>
        </trans-unit>
        <trans-unit id="57331e67e5143af4a00330fcd39cdc3c6aaaac4d" translate="yes" xml:space="preserve">
          <source>Some of the unique concepts in TypeScript describe the shape of JavaScript objects at the type level. One example that is especially unique to TypeScript is the concept of &amp;lsquo;declaration merging&amp;rsquo;. Understanding this concept will give you an advantage when working with existing JavaScript. It also opens the door to more advanced abstraction concepts.</source>
          <target state="translated">TypeScriptのユニークな概念のいくつかは、型レベルでのJavaScriptオブジェクトの形状を説明しています。TypeScriptに固有の1つの例は、「宣言のマージ」の概念です。この概念を理解すると、既存のJavaScriptを操作するときに利点が得られます。また、より高度な抽象概念への扉も開きます。</target>
        </trans-unit>
        <trans-unit id="1e812a000ccfcbfb77656cc54a6fedc23b3ae782" translate="yes" xml:space="preserve">
          <source>Some people find it more aesthetically pleasing to create an object and add properties immediately after like so:</source>
          <target state="translated">このように、オブジェクトを作成してすぐにプロパティを追加した方が、より審美性が高いと感じる人もいます。</target>
        </trans-unit>
        <trans-unit id="61d584a25fe1d72715546564a21bd344b92d47a9" translate="yes" xml:space="preserve">
          <source>Some plugins add or modify top-level exports on existing modules. While this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible. Because TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this.</source>
          <target state="translated">一部のプラグインでは、既存のモジュールにトップレベルのエクスポートを追加したり、変更したりしています。これは CommonJS や他のローダーでは合法ですが、ES6 モジュールは不変とみなされており、このパターンは不可能です。TypeScript はローダに依存しないため、コンパイル時にこのポリシーを適用することはできませんが、ES6 モジュールローダに移行しようとしている開発者はこの点に注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="f160ec637dc65ea96bb1d06f7025c1b36e3fe866" translate="yes" xml:space="preserve">
          <source>Some properties should only be modifiable when an object is first created. You can specify this by putting &lt;code&gt;readonly&lt;/code&gt; before the name of the property:</source>
          <target state="translated">一部のプロパティは、オブジェクトが最初に作成されたときにのみ変更可能である必要があります。プロパティの名前の前に &lt;code&gt;readonly&lt;/code&gt; を置くことでこれを指定できます。</target>
        </trans-unit>
        <trans-unit id="14f44373480b1e220dbd6f17d34a63ec1dd688dd" translate="yes" xml:space="preserve">
          <source>Some readers might do a double-take at this example. The variable &lt;code&gt;x&lt;/code&gt; was declared &lt;em&gt;within the &lt;code&gt;if&lt;/code&gt; block&lt;/em&gt;, and yet we were able to access it from outside that block. That&amp;rsquo;s because &lt;code&gt;var&lt;/code&gt; declarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we&amp;rsquo;ll go over later on - regardless of the containing block. Some people call this &lt;em&gt;&lt;code&gt;var&lt;/code&gt;-scoping&lt;/em&gt; or &lt;em&gt;function-scoping&lt;/em&gt;. Parameters are also function scoped.</source>
          <target state="translated">一部の読者は、この例でダブルテイクを行う可能性があります。変数 &lt;code&gt;x&lt;/code&gt; は&lt;em&gt; &lt;code&gt;if&lt;/code&gt; &lt;/em&gt;&lt;em&gt;ブロック&lt;/em&gt;&lt;em&gt;内&lt;/em&gt;で宣言さ&lt;em&gt;れましたが、&lt;/em&gt;そのブロックの外部からアクセスすることができました。これは、含まれているブロックに関係なく、 &lt;code&gt;var&lt;/code&gt; 宣言が含まれている関数、モジュール、名前空間、またはグローバルスコープ内のどこからでもアクセスできるためです。これを&lt;em&gt; &lt;code&gt;var&lt;/code&gt; -scoping&lt;/em&gt;または&lt;em&gt;function- &lt;/em&gt;&lt;em&gt;scoping&lt;/em&gt;と呼ぶ人もい&lt;em&gt;ます&lt;/em&gt;。パラメータも関数スコープです。</target>
        </trans-unit>
        <trans-unit id="44fb74208e19d5dbb2c363c2964c86574d508b8b" translate="yes" xml:space="preserve">
          <source>Some teams have set up msbuild-based workflows wherein tsconfig files have the same &lt;em&gt;implicit&lt;/em&gt; graph ordering as the managed projects they are paired with. If your solution is like this, you can continue to use &lt;code&gt;msbuild&lt;/code&gt; with &lt;code&gt;tsc -p&lt;/code&gt; along with project references; these are fully interoperable.</source>
          <target state="translated">一部のチームはmsbuildベースのワークフローをセットアップしており、tsconfigファイルには、ペアになっている管理対象プロジェクトと同じ&lt;em&gt;暗黙の&lt;/em&gt;グラフ順序があります。ソリューションがこのようなものである場合は、プロジェクト参照とともに &lt;code&gt;tsc -p&lt;/code&gt; を指定して &lt;code&gt;msbuild&lt;/code&gt; を引き続き使用できます。これらは完全に相互運用可能です。</target>
        </trans-unit>
        <trans-unit id="7941e42acfe32f9735cd477a7822e4200f3733d0" translate="yes" xml:space="preserve">
          <source>Something to note is that you can still &lt;em&gt;capture&lt;/em&gt; a block-scoped variable before it&amp;rsquo;s declared. The only catch is that it&amp;rsquo;s illegal to call that function before the declaration. If targeting ES2015, a modern runtime will throw an error; however, right now TypeScript is permissive and won&amp;rsquo;t report this as an error.</source>
          <target state="translated">注意すべき点は、宣言する前にブロックスコープの変数を&lt;em&gt;キャプチャ&lt;/em&gt;できることです。唯一の問題は、宣言の前にその関数を呼び出すことは違法であることです。ES2015を対象とする場合、最新のランタイムはエラーをスローします。ただし、現時点ではTypeScriptは許容範囲内であり、これをエラーとして報告しません。</target>
        </trans-unit>
        <trans-unit id="f134bb2233aae7cfa93968aca5ea244823125b9e" translate="yes" xml:space="preserve">
          <source>Sometimes modules are not directly located under &lt;em&gt;baseUrl&lt;/em&gt;. For instance, an import to a module &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; would be translated at runtime to &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt;. Loaders use a mapping configuration to map module names to files at run-time, see &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs documentation&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#paths&quot;&gt;SystemJS documentation&lt;/a&gt;.</source>
          <target state="translated">モジュールが&lt;em&gt;baseUrlの&lt;/em&gt;直下にない場合があります。たとえば、モジュール &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; へのインポートは、実行時に &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt; 変換されます。ローダーは、マッピング構成を使用して、実行時にモジュール名をファイルにマップします&lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;。RequireJsのドキュメント&lt;/a&gt;と&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#paths&quot;&gt;SystemJSのドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="37b66ff014eda83e2b1e8f0a114fdd628d5f0100" translate="yes" xml:space="preserve">
          <source>Sometimes modules are not directly located under &lt;em&gt;baseUrl&lt;/em&gt;. For instance, an import to a module &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; would be translated at runtime to &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt;. Loaders use a mapping configuration to map module names to files at run-time, see &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs documentation&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#paths&quot;&gt;SystemJS documentation&lt;/a&gt;.</source>
          <target state="translated">モジュールが&lt;em&gt;baseUrlの&lt;/em&gt;直下に配置されていない場合があります。たとえば、モジュール &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; へのインポートは、実行時に &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt; 変換されます。ローダーは、マッピング構成を使用して、実行時にモジュール名をファイルにマップします&lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;。RequireJsのドキュメント&lt;/a&gt;および&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#paths&quot;&gt;SystemJSのドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d6951e5cd812b979ec00d7377ad9486c476e4ffe" translate="yes" xml:space="preserve">
          <source>Sometimes modules are not directly located under &lt;em&gt;baseUrl&lt;/em&gt;. Loaders use a mapping configuration to map module names to files at run-time, see &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs documentation&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#map-config&quot;&gt;SystemJS documentation&lt;/a&gt;.</source>
          <target state="translated">モジュールが&lt;em&gt;baseUrlの&lt;/em&gt;直下にない場合があります。ローダーは、マッピング構成を使用して、実行時にモジュール名をファイルにマップします&lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;。RequireJsのドキュメント&lt;/a&gt;と&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#map-config&quot;&gt;SystemJSのドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c2126d1615e0f1485e19b5a56e2155fedd9cc145" translate="yes" xml:space="preserve">
          <source>Sometimes the project sources from multiple directories at compile time are all combined to generate a single output directory. This can be viewed as a set of source directories create a &amp;ldquo;virtual&amp;rdquo; directory.</source>
          <target state="translated">コンパイル時に複数のディレクトリからのプロジェクトソースがすべて結合されて、単一の出力ディレクトリが生成される場合があります。これは、一連のソースディレクトリが「仮想」ディレクトリを作成すると見なすことができます。</target>
        </trans-unit>
        <trans-unit id="57ffb77d1046760098ea81054624979437671ba8" translate="yes" xml:space="preserve">
          <source>Sometimes this is not desirable, for instance inputs &lt;code&gt;FolderA\FolderB\1.ts&lt;/code&gt; and &lt;code&gt;FolderA\FolderB\2.ts&lt;/code&gt; would result in output structure mirroring &lt;code&gt;FolderA\FolderB\&lt;/code&gt;. Now if a new file &lt;code&gt;FolderA\3.ts&lt;/code&gt; is added to the input, the output structure will pop out to mirror &lt;code&gt;FolderA\&lt;/code&gt;.</source>
          <target state="translated">これは望ましくない場合があります。たとえば、入力 &lt;code&gt;FolderA\FolderB\1.ts&lt;/code&gt; および &lt;code&gt;FolderA\FolderB\2.ts&lt;/code&gt; は、出力構造が &lt;code&gt;FolderA\FolderB\&lt;/code&gt; ミラーリングする結果になります。ここで、新しいファイル &lt;code&gt;FolderA\3.ts&lt;/code&gt; が入力に追加されると、出力構造がポップアウトして &lt;code&gt;FolderA\&lt;/code&gt; をミラーリングします。</target>
        </trans-unit>
        <trans-unit id="1373cee6ce1e5c912f9c7dad28055e7d5d1067f6" translate="yes" xml:space="preserve">
          <source>Sometimes you&amp;rsquo;ll end up in a situation where you&amp;rsquo;ll know more about a value than TypeScript does. Usually this will happen when you know the type of some entity could be more specific than its current type.</source>
          <target state="translated">TypeScriptが行うよりも、値について多くのことを知っているような状況になる場合があります。通常、これは、エンティティのタイプが現在のタイプよりも具体的であることがわかっている場合に発生します。</target>
        </trans-unit>
        <trans-unit id="db9ad13d4e098d7519b16265367b7512e89b4d5d" translate="yes" xml:space="preserve">
          <source>Sometimes you&amp;rsquo;ll end up in a situation where you&amp;rsquo;ll know more about a value than TypeScript does. Usually, this will happen when you know the type of some entity could be more specific than its current type.</source>
          <target state="translated">TypeScriptよりも値について詳しく知っている状況に陥ることがあります。通常、これは、エンティティのタイプが現在のタイプよりも具体的である可能性があることがわかっている場合に発生します。</target>
        </trans-unit>
        <trans-unit id="55d18b2ee923c4bc6bb19412ab2b08a75f6ca271" translate="yes" xml:space="preserve">
          <source>Sometimes you&amp;rsquo;ll entirely overwrite the exports object. This is a common pattern people use to make their modules immediately callable like in this snippet:</source>
          <target state="translated">場合によっては、exportsオブジェクトを完全に上書きします。これは、次のスニペットのように、モジュールをすぐに呼び出し可能にするために使用される一般的なパターンです。</target>
        </trans-unit>
        <trans-unit id="d728f725e5c3a9034a8a3fe4df81013d14f602c4" translate="yes" xml:space="preserve">
          <source>Source Map - &lt;code&gt;sourceMap&lt;/code&gt;</source>
          <target state="translated">ソースマップ &lt;code&gt;sourceMap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5774da7b802f7af9150c4273aaf57f7387c8eb1d" translate="yes" xml:space="preserve">
          <source>Source Maps</source>
          <target state="translated">ソースマップ</target>
        </trans-unit>
        <trans-unit id="cfa38cdf5131675218c181d7b11184e4109a5125" translate="yes" xml:space="preserve">
          <source>Source Root - &lt;code&gt;sourceRoot&lt;/code&gt;</source>
          <target state="translated">ソースルート &lt;code&gt;sourceRoot&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ada52d888ccf16d2711b8a6377768a782af5c30e" translate="yes" xml:space="preserve">
          <source>Sources:</source>
          <target state="translated">Sources:</target>
        </trans-unit>
        <trans-unit id="48eef677f8e006bcedd3e0792da013d963078bac" translate="yes" xml:space="preserve">
          <source>Specifically, the Handbook does not fully introduce core JavaScript basics like functions, classes, and closures. Where appropriate, we&amp;rsquo;ll include links to background reading that you can use to read up on those concepts.</source>
          <target state="translated">具体的には、ハンドブックでは、関数、クラス、クロージャなどのコアJavaScriptの基本を完全には紹介していません。必要に応じて、これらの概念を読むために使用できる背景資料へのリンクを含めます。</target>
        </trans-unit>
        <trans-unit id="d9ff7d39e693899b2fb01c2af7e0b9aad8efd43b" translate="yes" xml:space="preserve">
          <source>Specifically:</source>
          <target state="translated">Specifically:</target>
        </trans-unit>
        <trans-unit id="efbbb58a99e1f76d9d3034bd2b5e0e968683bf5a" translate="yes" xml:space="preserve">
          <source>Specifies an allowlist of files to include in the program. An error occurs if any of the files can&amp;rsquo;t be found.</source>
          <target state="translated">プログラムに含めるファイルの許可リストを指定します。いずれかのファイルが見つからない場合、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="c74f7553e5ec8cdb8bab2e09b9d4de6b751389a2" translate="yes" xml:space="preserve">
          <source>Specifies an array of filenames or patterns that should be skipped when resolving &lt;code&gt;include&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; を解決するときにスキップする必要があるファイル名またはパターンの配列を指定します。</target>
        </trans-unit>
        <trans-unit id="a89dfbe46f3600605d13d83998972af673fa40e0" translate="yes" xml:space="preserve">
          <source>Specifies an array of filenames or patterns to include in the program. These filenames are resolved relative to the directory containing the &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">プログラムに含めるファイル名またはパターンの配列を指定します。これらのファイル名は、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを含むディレクトリを基準にして解決されます。</target>
        </trans-unit>
        <trans-unit id="a641ebcd0020283fedd21072f7904f9b73d7b789" translate="yes" xml:space="preserve">
          <source>Specifies the location where debugger should locate TypeScript files instead of source locations. Use this flag if the sources will be located at run-time in a different location than that at design-time. The location specified will be embedded in the sourceMap to direct the debugger where the source files will be located.</source>
          <target state="translated">デバッガがソースの場所ではなく、TypeScript ファイルを配置する場所を指定します。実行時にデザイン時とは異なる場所にソースが配置される場合は、このフラグを使用します。指定された場所は sourceMap に埋め込まれ、デバッガにソースファイルが配置される場所を指示します。</target>
        </trans-unit>
        <trans-unit id="1c2da7a5fc698b5da97db9b13fe3154907aad09d" translate="yes" xml:space="preserve">
          <source>Specifies the location where debugger should locate map files instead of generated locations. Use this flag if the .map files will be located at run-time in a different location than the .js files. The location specified will be embedded in the sourceMap to direct the debugger where the map files will be located. This flag will not create the specified path and generate the map files in that location. Instead, create a post build step that moves the files to the specified path.</source>
          <target state="translated">デバッガーが生成された場所ではなく、マップファイルを配置する場所を指定します。.map ファイルが実行時に .js ファイルとは異なる場所に配置される場合は、このフラグを使用します。指定された場所は sourceMap に埋め込まれ、マップ ファイルが配置される場所をデバッガに指示します。このフラグは、指定されたパスを作成してその場所にマップファイルを生成することはありません。代わりに、指定したパスにファイルを移動させるポストビルドステップを作成します。</target>
        </trans-unit>
        <trans-unit id="794dd3dcf9665f5b582a96a912c3cb49b4c72f8a" translate="yes" xml:space="preserve">
          <source>Specifies the object invoked for &lt;code&gt;createElement&lt;/code&gt; and &lt;code&gt;__spread&lt;/code&gt; when targeting &lt;code&gt;&quot;react&quot;&lt;/code&gt; JSX emit.</source>
          <target state="translated">&lt;code&gt;&quot;react&quot;&lt;/code&gt; JSX &lt;code&gt;__spread&lt;/code&gt; をターゲットとするときに &lt;code&gt;createElement&lt;/code&gt; および__spreadに対して呼び出されるオブジェクトを指定します。</target>
        </trans-unit>
        <trans-unit id="87746b728ea4f460f7202426ccc6c557238e85b3" translate="yes" xml:space="preserve">
          <source>Specifies the root directory of input files. Only use to control the output directory structure with &lt;code&gt;--outDir&lt;/code&gt;.</source>
          <target state="translated">入力ファイルのルートディレクトリを指定します。 &lt;code&gt;--outDir&lt;/code&gt; で出力ディレクトリ構造を制御するためにのみ使用します。</target>
        </trans-unit>
        <trans-unit id="6f3b79249d834c08c2bb8f8527cca3825f4ecc15" translate="yes" xml:space="preserve">
          <source>Specify &lt;code&gt;&quot;types&quot;: []&lt;/code&gt; to disable automatic inclusion of &lt;code&gt;@types&lt;/code&gt; packages.</source>
          <target state="translated">&lt;code&gt;&quot;types&quot;: []&lt;/code&gt; を指定して、 &lt;code&gt;@types&lt;/code&gt; パッケージの自動インクルードを無効にします。</target>
        </trans-unit>
        <trans-unit id="04e339988f7084fdc3b9871407ec6d486b9796f2" translate="yes" xml:space="preserve">
          <source>Specify ECMAScript target version:</source>
          <target state="translated">ECMAScript のターゲットバージョンを指定します。</target>
        </trans-unit>
        <trans-unit id="22bae6477e590560d376f1ca2a920f0f7137f9ff" translate="yes" xml:space="preserve">
          <source>Specify module code generation: &lt;code&gt;&quot;None&quot;&lt;/code&gt;, &lt;code&gt;&quot;CommonJS&quot;&lt;/code&gt;, &lt;code&gt;&quot;AMD&quot;&lt;/code&gt;, &lt;code&gt;&quot;System&quot;&lt;/code&gt;, &lt;code&gt;&quot;UMD&quot;&lt;/code&gt;, &lt;code&gt;&quot;ES6&quot;&lt;/code&gt;, &lt;code&gt;&quot;ES2015&quot;&lt;/code&gt; or &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt;.</source>
          <target state="translated">モジュールコード生成を指定します： &lt;code&gt;&quot;None&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;CommonJS&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;AMD&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;System&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;UMD&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;ES6&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;ES2015&quot;&lt;/code&gt; または &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f17fc5b5e06de09269af8bc9bf5322fe97b5fb06" translate="yes" xml:space="preserve">
          <source>Specify the JSX factory function to use when targeting react JSX emit, e.g. &lt;code&gt;React.createElement&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;React.createElement&lt;/code&gt; や &lt;code&gt;h&lt;/code&gt; など、react JSX エミットをターゲットにするときに使用するJSXファクトリ関数を指定します。</target>
        </trans-unit>
        <trans-unit id="94543a650f9ea4384e3c9b4aac1aeb2ec999debb" translate="yes" xml:space="preserve">
          <source>Specify the JSX fragment factory function to use when targeting react JSX emit with &lt;code&gt;jsxFactory&lt;/code&gt; compiler option is specified, e.g. &lt;code&gt;Fragment&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;jsxFactory&lt;/code&gt; コンパイラオプションで反応するJSXエミットをターゲットにするときに使用するJSXフラグメントファクトリ関数を指定します（例： &lt;code&gt;Fragment&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="78e9087ffaa1788a738669c2468f437d80a3e672" translate="yes" xml:space="preserve">
          <source>Specify the JSX fragment factory function to use when targeting react JSX emit, e.g. &lt;code&gt;Fragment&lt;/code&gt;.</source>
          <target state="translated">反応JSXエミットをターゲットにするときに使用するJSXフラグメントファクトリ関数を指定します（例： &lt;code&gt;Fragment&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="006fc315897b9c6dedc4127db9dec8f57c88bcec" translate="yes" xml:space="preserve">
          <source>Specify the end of line sequence to be used when emitting files: &amp;lsquo;CRLF&amp;rsquo; (dos) or &amp;lsquo;LF&amp;rsquo; (unix).</source>
          <target state="translated">ファイルを発行するときに使用する行末シーケンスを指定します：「CRLF」（dos）または「LF」（unix）。</target>
        </trans-unit>
        <trans-unit id="2563c439e791b9170655cc14e7d00ffe51b0db65" translate="yes" xml:space="preserve">
          <source>Specify the location where a debugger should locate TypeScript files instead of relative source locations. This string is treated verbatim inside the source-map where you can use a path or a URL:</source>
          <target state="translated">デバッガが相対的なソースの場所ではなく、TypeScript ファイルを配置する場所を指定します。この文字列は、パスや URL を使用することができるソースマップの中では、逐語的に扱われます。</target>
        </trans-unit>
        <trans-unit id="e93da90b91643eb92c65e310443608e67c5f5f30" translate="yes" xml:space="preserve">
          <source>Specify the location where debugger should locate map files instead of generated locations. This string is treated verbatim inside the source-map, for example:</source>
          <target state="translated">生成された場所ではなく、デバッガがマップファイルを配置する場所を指定します。この文字列は、例えばソースマップの内部でそのまま扱われます。</target>
        </trans-unit>
        <trans-unit id="33c04e27a5ae61b1904c200b896f04e66fb3130e" translate="yes" xml:space="preserve">
          <source>Specify the module resolution strategy: &lt;code&gt;'node'&lt;/code&gt; (Node.js) or &lt;code&gt;'classic'&lt;/code&gt; (used in TypeScript before the release of 1.6). You probably won&amp;rsquo;t need to use &lt;code&gt;classic&lt;/code&gt; in modern code.</source>
          <target state="translated">モジュール解決戦略を指定します： &lt;code&gt;'node'&lt;/code&gt; （Node.js）または &lt;code&gt;'classic'&lt;/code&gt; （1.6のリリース前にTypeScriptで使用されていました）。おそらく、現代のコードでは &lt;code&gt;classic&lt;/code&gt; を使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="26252f00b41f16be2c212af5b97551e657c2f43c" translate="yes" xml:space="preserve">
          <source>Specify what file to store incremental build information in.</source>
          <target state="translated">インクリメンタルビルド情報を保存するファイルを指定します。</target>
        </trans-unit>
        <trans-unit id="5b0ffc462bd014144a57832b75b37bec6b627992" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;--outFile&lt;/code&gt; in conjunction with &lt;code&gt;--module amd&lt;/code&gt; or &lt;code&gt;--module system&lt;/code&gt; will concatenate all modules in the compilation into a single output file containing multiple module closures.</source>
          <target state="translated">指定 &lt;code&gt;--outFile&lt;/code&gt; と併せて &lt;code&gt;--module amd&lt;/code&gt; または &lt;code&gt;--module system&lt;/code&gt; 複数のモジュールの閉鎖を含む単一の出力ファイルにコンパイル内のすべてのモジュールを連結します。</target>
        </trans-unit>
        <trans-unit id="ecac73aab16df45bc37442b177ade411f7d911ae" translate="yes" xml:space="preserve">
          <source>Specifying the type of &lt;code&gt;this&lt;/code&gt; for functions</source>
          <target state="translated">関数の &lt;code&gt;this&lt;/code&gt; タイプを指定する</target>
        </trans-unit>
        <trans-unit id="076b62c1c3d09beab9691ee6f442faa2e62ef7a7" translate="yes" xml:space="preserve">
          <source>Speed improvements</source>
          <target state="translated">スピードの向上</target>
        </trans-unit>
        <trans-unit id="57c7cf9d2a0cafdf74f389b4d473eed903a50706" translate="yes" xml:space="preserve">
          <source>Splitting Across Files</source>
          <target state="translated">ファイル間の分割</target>
        </trans-unit>
        <trans-unit id="2bde101117a83786a9fe359d813c1badf4a6b2ee" translate="yes" xml:space="preserve">
          <source>Spread</source>
          <target state="translated">Spread</target>
        </trans-unit>
        <trans-unit id="e52ae13e940c439690285391dab1a0051b0c2e04" translate="yes" xml:space="preserve">
          <source>Spread expressions with tuple types</source>
          <target state="translated">タプル型を使った展開式</target>
        </trans-unit>
        <trans-unit id="d6ace75d8be9881329b05b54b6dc429938f458c6" translate="yes" xml:space="preserve">
          <source>Stable packages are available here:</source>
          <target state="translated">安定したパッケージはこちらでご用意しています。</target>
        </trans-unit>
        <trans-unit id="457a8825cdb8efe6f8ed3954625c3f151b370bc9" translate="yes" xml:space="preserve">
          <source>Starting TypeScript 2.9 errors are displayed under &lt;code&gt;--pretty&lt;/code&gt; by default if the output device is applicable for colorful text. TypeScript will check if the output steam has &lt;a href=&quot;https://nodejs.org/api/tty.html&quot;&gt;&lt;code&gt;isTty&lt;/code&gt;&lt;/a&gt; property set.</source>
          <target state="translated">出力デバイスがカラフルなテキストに適用できる場合、TypeScript 2.9の開始エラーはデフォルトで &lt;code&gt;--pretty&lt;/code&gt; の下に表示されます。TypeScriptは、出力&lt;a href=&quot;https://nodejs.org/api/tty.html&quot;&gt; &lt;code&gt;isTty&lt;/code&gt; &lt;/a&gt;プロパティが設定されているかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="e1bd71f28dac9f8b9839f2877d980ac89846a470" translate="yes" xml:space="preserve">
          <source>Starting from release 1.6 TypeScript compiler will use different set of rules to resolve module names when targeting &amp;lsquo;commonjs&amp;rsquo;. These &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2338&quot;&gt;rules&lt;/a&gt; attempted to model module lookup procedure used by Node. This effectively mean that node modules can include information about its typings and TypeScript compiler will be able to find it. User however can override module resolution rules picked by the compiler by using &lt;code&gt;--moduleResolution&lt;/code&gt; command line option. Possible values are:</source>
          <target state="translated">リリース1.6以降、TypeScriptコンパイラは、「commonjs」をターゲットとする場合、異なるルールセットを使用してモジュール名を解決します。これらの&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2338&quot;&gt;ルール&lt;/a&gt;は、Nodeが使用するモジュール検索手順をモデル化しようとしました。これは事実上、ノードモジュールに型付けに関する情報を含めることができ、TypeScriptコンパイラがそれを見つけられることを意味します。ただし、ユーザーは &lt;code&gt;--moduleResolution&lt;/code&gt; コマンドラインオプションを使用して、コンパイラーが選択したモジュール解決ルールをオーバーライドできます。可能な値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e863c718db915f2f4b58c523e97d4f07d5237232" translate="yes" xml:space="preserve">
          <source>Starting out</source>
          <target state="translated">スタートアップ</target>
        </trans-unit>
        <trans-unit id="b8e934aecb8f4ca462a04840430ac40704a0da90" translate="yes" xml:space="preserve">
          <source>Starting up are the root options in the TSConfig - these options relate to how your TypeScript or JavaScript project is set up.</source>
          <target state="translated">起動時のオプションは TSConfig のルートオプションです-これらのオプションは TypeScript や JavaScript プロジェクトの設定方法に関連しています。</target>
        </trans-unit>
        <trans-unit id="27ba7e115de3bfd5bf5dc01034bb164d0740a437" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, &lt;code&gt;symbol&lt;/code&gt; is a primitive data type, just like &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">ECMAScript 2015以降、 &lt;code&gt;symbol&lt;/code&gt; は、 &lt;code&gt;number&lt;/code&gt; や &lt;code&gt;string&lt;/code&gt; と同様に、プリミティブデータ型です。</target>
        </trans-unit>
        <trans-unit id="f7d9af76ba0d605e072032df04742ab0cf02228b" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, JavaScript has a concept of modules. TypeScript shares this concept.</source>
          <target state="translated">ECMAScript 2015から、JavaScriptにはモジュールという概念があります。TypeScriptもこの概念を共有しています。</target>
        </trans-unit>
        <trans-unit id="afc8e56cf364b15c88268122ccbfe29a39ca7ca5" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations. Thus, for new projects modules would be the recommended code organization mechanism.</source>
          <target state="translated">ECMAScript 2015 以降、モジュールは言語のネイティブな部分であり、すべての準拠したエンジンの実装でサポートされるべきです。したがって、新しいプロジェクトでは、モジュールが推奨されるコード編成メカニズムとなります。</target>
        </trans-unit>
        <trans-unit id="51e38a40604a0a2de5e2d000abadb800295b34df" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 1.8, official NuGet packages are available for the Typescript Compiler (&lt;code&gt;tsc.exe&lt;/code&gt;) as well as the MSBuild integration (&lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; and &lt;code&gt;Microsoft.TypeScript.Tasks.dll&lt;/code&gt;).</source>
          <target state="translated">TypeScript 1.8以降、公式のNuGetパッケージが &lt;code&gt;tsc.exe&lt;/code&gt; コンパイラ（tsc.exe）およびMSBuild統合（ &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; および &lt;code&gt;Microsoft.TypeScript.Tasks.dll&lt;/code&gt; ）で利用できます。</target>
        </trans-unit>
        <trans-unit id="fe907641294d4a842173702363c42ee105d23f56" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 1.8:</source>
          <target state="translated">TypeScript 1.8からスタート。</target>
        </trans-unit>
        <trans-unit id="667eaed082674a988c7fa4d7c4bc04735599c26c" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 2.3, the default &lt;code&gt;tsconfig.json&lt;/code&gt; generated by &lt;code&gt;tsc --init&lt;/code&gt; includes a &lt;code&gt;&quot;strict&quot;: true&lt;/code&gt; setting in the &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; section. Thus, new projects started with &lt;code&gt;tsc --init&lt;/code&gt; will by default have the highest level of type safety enabled.</source>
          <target state="translated">活字体2.3以降では、デフォルトの &lt;code&gt;tsconfig.json&lt;/code&gt; によって生成された &lt;code&gt;tsc --init&lt;/code&gt; 含まれ &lt;code&gt;&quot;strict&quot;: true&lt;/code&gt; の設定 &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; セクションを。したがって、 &lt;code&gt;tsc --init&lt;/code&gt; で開始された新しいプロジェクトでは、デフォルトで最高レベルのタイプセーフが有効になります。</target>
        </trans-unit>
        <trans-unit id="3b2ba1ad0dec7805611669102a4687a54df4fb4a" translate="yes" xml:space="preserve">
          <source>Statements guaranteed to not be executed at run time are now correctly flagged as unreachable code errors. For instance, statements following unconditional &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt; statements are considered unreachable. Use &lt;code&gt;--allowUnreachableCode&lt;/code&gt; to disable unreachable code detection and reporting.</source>
          <target state="translated">実行時に実行されないことが保証されているステートメントは、到達不能コードエラーとして正しくフラグ付けされるようになりました。たとえば、無条件の &lt;code&gt;return&lt;/code&gt; 、 &lt;code&gt;throw&lt;/code&gt; 、 &lt;code&gt;break&lt;/code&gt; または &lt;code&gt;continue&lt;/code&gt; ステートメントに続くステートメントは到達不可能と見なされます。使用は &lt;code&gt;--allowUnreachableCode&lt;/code&gt; 無効到達不能コード検出および報告に。</target>
        </trans-unit>
        <trans-unit id="4834b04199e24094cfa37dc3df47bc9740ccc20d" translate="yes" xml:space="preserve">
          <source>Static Classes</source>
          <target state="translated">静的クラス</target>
        </trans-unit>
        <trans-unit id="5dd52f62e1be6f918ab77a38268c4534241ce617" translate="yes" xml:space="preserve">
          <source>Static Properties</source>
          <target state="translated">静的なプロパティ</target>
        </trans-unit>
        <trans-unit id="1e94b9fe73132ea714175037fe0cd997356ca7ce" translate="yes" xml:space="preserve">
          <source>Static Property Mixins &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/17829&quot;&gt;&lt;code&gt;#17829&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">静的プロパティミックスイン&lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/17829&quot;&gt; &lt;code&gt;#17829&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8c4de2a053d6fce41e20676b11e60a8bda4be893" translate="yes" xml:space="preserve">
          <source>Static methods on an exported class have a similar problem - the class itself adds a layer of nesting. Unless it increases expressivity or intent in a clearly useful way, consider simply exporting a helper function.</source>
          <target state="translated">エクスポートされたクラスのスタティックメソッドにも同様の問題があります。明らかに有用な方法で表現力や意図を高めるのでなければ、単にヘルパー関数をエクスポートすることを検討してください。</target>
        </trans-unit>
        <trans-unit id="e056817fe3841123d274840f9970929fd1661955" translate="yes" xml:space="preserve">
          <source>StaticZipCodeValidator.ts</source>
          <target state="translated">StaticZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="11dc9e1952928d4ca947651277656b4d8b55fffc" translate="yes" xml:space="preserve">
          <source>Status:</source>
          <target state="translated">Status:</target>
        </trans-unit>
        <trans-unit id="876f3e0202ca40dedf2e5ab6577eba1ae637fb53" translate="yes" xml:space="preserve">
          <source>Strategies</source>
          <target state="translated">Strategies</target>
        </trans-unit>
        <trans-unit id="c5a651c6a5ca45d3200e3822a71c808cfc9ddee0" translate="yes" xml:space="preserve">
          <source>Strict - &lt;code&gt;strict&lt;/code&gt;</source>
          <target state="translated">厳格- &lt;code&gt;strict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b24ced1a6bde1cad399359d1809b17476b8956ce" translate="yes" xml:space="preserve">
          <source>Strict &lt;code&gt;null&lt;/code&gt; &amp;amp; &lt;code&gt;undefined&lt;/code&gt; Checks</source>
          <target state="translated">厳密な &lt;code&gt;null&lt;/code&gt; および &lt;code&gt;undefined&lt;/code&gt; チェック</target>
        </trans-unit>
        <trans-unit id="7db7be7d078caf461b753e0214a03c98e722bffe" translate="yes" xml:space="preserve">
          <source>Strict Bind Call Apply - &lt;code&gt;strictBindCallApply&lt;/code&gt;</source>
          <target state="translated">厳密なバインド呼び出しの適用 &lt;code&gt;strictBindCallApply&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d933d28761202efe8959a2abfc0ee0653e25ea29" translate="yes" xml:space="preserve">
          <source>Strict Checks</source>
          <target state="translated">厳格なチェック</target>
        </trans-unit>
        <trans-unit id="ba990120d287758ccaffce7420f0d37783310854" translate="yes" xml:space="preserve">
          <source>Strict Class Initialization</source>
          <target state="translated">厳格なクラス初期化</target>
        </trans-unit>
        <trans-unit id="117936c45339446360a285051720e74fb1e1a712" translate="yes" xml:space="preserve">
          <source>Strict Function Types - &lt;code&gt;strictFunctionTypes&lt;/code&gt;</source>
          <target state="translated">厳密な関数タイプ &lt;code&gt;strictFunctionTypes&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="138584497ea8db53d6fe3a0d2d6a889f35fd24b1" translate="yes" xml:space="preserve">
          <source>Strict Null Checks - &lt;code&gt;strictNullChecks&lt;/code&gt;</source>
          <target state="translated">厳密なヌルチェック &lt;code&gt;strictNullChecks&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73209b516ae52a149a4f72b4ba6803dd3a89c92b" translate="yes" xml:space="preserve">
          <source>Strict Property Initialization - &lt;code&gt;strictPropertyInitialization&lt;/code&gt;</source>
          <target state="translated">厳密なプロパティの初期化 &lt;code&gt;strictPropertyInitialization&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8a4e48ac15ba59cbf4a0e834cf82e7a56d1dc79" translate="yes" xml:space="preserve">
          <source>Strict contravariance for callback parameters</source>
          <target state="translated">コールバックパラメータの厳密な矛盾</target>
        </trans-unit>
        <trans-unit id="8236c998ec2e20c7b6ba2fbd2308a5a59e458fff" translate="yes" xml:space="preserve">
          <source>Strict function types</source>
          <target state="translated">厳密な関数型</target>
        </trans-unit>
        <trans-unit id="503ce04e3c451abd56d5c6cc0eeb1f004a6a9b01" translate="yes" xml:space="preserve">
          <source>Stricter Generators</source>
          <target state="translated">厳格化されたジェネレーター</target>
        </trans-unit>
        <trans-unit id="ac111df4e339d358e1192621e12afb377c50ec08" translate="yes" xml:space="preserve">
          <source>Stricter Generics</source>
          <target state="translated">より厳格なジェネリック</target>
        </trans-unit>
        <trans-unit id="7c1c37e677884ed5162824f92bf4ac0323765899" translate="yes" xml:space="preserve">
          <source>Stricter checking for generic functions</source>
          <target state="translated">汎用関数のチェックを厳格化</target>
        </trans-unit>
        <trans-unit id="59d7c0445a12d3c38c6410a065795f30dedb9910" translate="yes" xml:space="preserve">
          <source>Stricter object literal assignment checks</source>
          <target state="translated">より厳格なオブジェクトリテラルの代入チェック</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="d38945e9d63e72217f1ff6e3be1ea79fbfff3091" translate="yes" xml:space="preserve">
          <source>String Enums</source>
          <target state="translated">文字列列列挙</target>
        </trans-unit>
        <trans-unit id="b9ee8e1a51d8d2f14d5767f34ddd3e68f008e59a" translate="yes" xml:space="preserve">
          <source>String Literal Types</source>
          <target state="translated">文字列リテラル型</target>
        </trans-unit>
        <trans-unit id="ffa12823a95532beb06727f353cfba4e754b5e99" translate="yes" xml:space="preserve">
          <source>String enums</source>
          <target state="translated">文字列列列挙</target>
        </trans-unit>
        <trans-unit id="135b4e07f53722d425681f40b44219a30c502379" translate="yes" xml:space="preserve">
          <source>String enums are a similar concept, but have some subtle &lt;a href=&quot;#enums-at-runtime&quot;&gt;runtime differences&lt;/a&gt; as documented below. In a string enum, each member has to be constant-initialized with a string literal, or with another string enum member.</source>
          <target state="translated">文字列列挙型も同様の概念ですが、以下で説明するように、&lt;a href=&quot;#enums-at-runtime&quot;&gt;実行時に&lt;/a&gt;わずかな違いがあります。文字列列挙では、各メンバーを文字列リテラルまたは別の文字列列挙メンバーで定数初期化する必要があります。</target>
        </trans-unit>
        <trans-unit id="97ca47845b6de917d6acef338327258499a5fa14" translate="yes" xml:space="preserve">
          <source>String literal types</source>
          <target state="translated">文字列リテラル型</target>
        </trans-unit>
        <trans-unit id="3094f1d45b3a85252ec82b4f2621aa324f1df082" translate="yes" xml:space="preserve">
          <source>String literal types allow you to specify the exact value a string must have. In practice string literal types combine nicely with union types, type guards, and type aliases. You can use these features together to get enum-like behavior with strings.</source>
          <target state="translated">文字列リテラル型では、文字列が持つべき値を正確に指定することができます。実際には、文字列リテラル型はユニオン型、型ガード、型エイリアスとうまく組み合わせます。これらの機能を併用することで、文字列で列挙型のような動作を得ることができます。</target>
        </trans-unit>
        <trans-unit id="b874e7e8ff440bab9b01a84543e1af14d5b4bb4b" translate="yes" xml:space="preserve">
          <source>String literal types can be used in the same way to distinguish overloads:</source>
          <target state="translated">文字列リテラル型は、オーバーロードを区別するために同じように使用することができます。</target>
        </trans-unit>
        <trans-unit id="46e91541a55f18468fd6b067383aaa97a9e64cd2" translate="yes" xml:space="preserve">
          <source>String, numeric and boolean literal types (e.g. &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt;) were previously inferred only in the presence of an explicit type annotation. Starting with TypeScript 2.1, literal types are &lt;em&gt;always&lt;/em&gt; inferred for &lt;code&gt;const&lt;/code&gt; variables and &lt;code&gt;readonly&lt;/code&gt; properties.</source>
          <target state="translated">文字列、数値、ブールのリテラル型（例： &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 、 &lt;code&gt;1&lt;/code&gt; 、 &lt;code&gt;true&lt;/code&gt; ）は、以前は明示的な型注釈が存在する場合にのみ推定されていました。TypeScript 2.1以降、リテラル型は&lt;em&gt;常に&lt;/em&gt; &lt;code&gt;const&lt;/code&gt; 変数と &lt;code&gt;readonly&lt;/code&gt; プロパティに対して推論されます。</target>
        </trans-unit>
        <trans-unit id="2d8fecbc84175a2cda5fcb984cf28bdb9e9fe54b" translate="yes" xml:space="preserve">
          <source>String-like properties of an object type are those declared using an identifier, a string literal, or a computed property name of a string literal type.</source>
          <target state="translated">オブジェクト型の文字列ライクなプロパティは、識別子、文字列リテラル、または文字列リテラル型の計算されたプロパティ名を使用して宣言されたものです。</target>
        </trans-unit>
        <trans-unit id="f44c134a9d7c63d1a602a14744e321854b363720" translate="yes" xml:space="preserve">
          <source>StringValidator.ts</source>
          <target state="translated">StringValidator.ts</target>
        </trans-unit>
        <trans-unit id="67a09ff3eda42cceb49c2b8ebb950c7b003be45b" translate="yes" xml:space="preserve">
          <source>Strip Internal - &lt;code&gt;stripInternal&lt;/code&gt;</source>
          <target state="translated">内部ストリップ &lt;code&gt;stripInternal&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dfbdcec4c2b576f7ec50907da018377d2da918dc" translate="yes" xml:space="preserve">
          <source>Strips all comments from TypeScript files when converting into JavaScript. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">JavaScriptに変換するときに、TypeScriptファイルからすべてのコメントを取り除きます。デフォルトは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="9844396a455fe52a669fba664343368aae3a4790" translate="yes" xml:space="preserve">
          <source>Structural Type System</source>
          <target state="translated">構造式システム</target>
        </trans-unit>
        <trans-unit id="fad0aefa729b2e3f757e7d3a4090cd9f7990d889" translate="yes" xml:space="preserve">
          <source>Structural typing</source>
          <target state="translated">構造的なタイピング</target>
        </trans-unit>
        <trans-unit id="03e7907c7ea5243abaf83cc6cc7257a835787796" translate="yes" xml:space="preserve">
          <source>Structural typing is a familiar concept to most functional programmers, although Haskell and most MLs are not structurally typed. Its basic form is pretty simple:</source>
          <target state="translated">構造型付けはほとんどの関数型付けプログラマには馴染みのある概念ですが、HaskellやほとんどのMLは構造型付けされていません。基本的な形式は非常にシンプルです。</target>
        </trans-unit>
        <trans-unit id="e9e5d94110d726b2fb48e7030cec7299992b6e0c" translate="yes" xml:space="preserve">
          <source>Structurally identical, but distinct, class types are now preserved in union types (instead of eliminating all but one).</source>
          <target state="translated">構造的には同じですが、異なるクラス型がユニオン型に保存されるようになりました (1つを除いてすべてを削除するのではなく)。</target>
        </trans-unit>
        <trans-unit id="f188cd9e1081421f05e7530e5be35f73639cddfb" translate="yes" xml:space="preserve">
          <source>Structuring for outFiles</source>
          <target state="translated">outFiles の構造化</target>
        </trans-unit>
        <trans-unit id="9790ea759cfc56e0057f75d2b47d5dd9230cb97d" translate="yes" xml:space="preserve">
          <source>Structuring for relative modules</source>
          <target state="translated">相対モジュールの構造化</target>
        </trans-unit>
        <trans-unit id="28a732981a8711b19d230aaecb27b43ddf871667" translate="yes" xml:space="preserve">
          <source>Structuring modules to give the exact API shape you want can be tricky. For example, we might want a module that can be invoked with or without &lt;code&gt;new&lt;/code&gt; to produce different types, has a variety of named types exposed in a hierarchy, and has some properties on the module object as well.</source>
          <target state="translated">必要な正確なAPI形状を提供するためにモジュールを構造化するのは、難しい場合があります。たとえば、 &lt;code&gt;new&lt;/code&gt; を使用して、または使用せずに呼び出して、さまざまなタイプを生成し、階層内にさまざまな名前付きタイプを公開し、モジュールオブジェクトにいくつかのプロパティを備えたモジュールが必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="1d1df78833ce77fa7da034e63ad69c3819501b68" translate="yes" xml:space="preserve">
          <source>Stylize errors and messages using color and context, this is on by default &amp;mdash; offers you a chance to have less terse, single colored messages from the compiler.</source>
          <target state="translated">色とコンテキストを使用してエラーとメッセージのスタイルを設定します。これはデフォルトでオンになっています&amp;mdash;コンパイラからの簡潔な単色のメッセージを少なくする機会を提供します。</target>
        </trans-unit>
        <trans-unit id="426c20ffe12820a1c17c8b53aa917b10b06fc64e" translate="yes" xml:space="preserve">
          <source>Stylize errors and messages using color and context.</source>
          <target state="translated">色とコンテキストを使ってエラーやメッセージをスタイリングします。</target>
        </trans-unit>
        <trans-unit id="9ce6ba148fe8d9ab4a1efa44f043d11727e7f6ee" translate="yes" xml:space="preserve">
          <source>Sublime Text</source>
          <target state="translated">崇高なテキスト</target>
        </trans-unit>
        <trans-unit id="89f541951e4630b0519550eb0b55d466b60ae9d9" translate="yes" xml:space="preserve">
          <source>Subtype vs Assignment</source>
          <target state="translated">サブタイプと割り当て</target>
        </trans-unit>
        <trans-unit id="18532a66f85c71ab4aec069080bab114bcb593de" translate="yes" xml:space="preserve">
          <source>Support &amp;lsquo;target : es5&amp;rsquo; with &amp;lsquo;module: es6&amp;rsquo;</source>
          <target state="translated">「モジュール：es6」で「ターゲット：es5」をサポート</target>
        </trans-unit>
        <trans-unit id="cf4b3d9e87de6d08216090fd0a299f43489307ab" translate="yes" xml:space="preserve">
          <source>Support &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named properties with &lt;code&gt;keyof&lt;/code&gt; and mapped types</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; とマップされた型で &lt;code&gt;number&lt;/code&gt; と &lt;code&gt;symbol&lt;/code&gt; 名前付きプロパティをサポート</target>
        </trans-unit>
        <trans-unit id="6d6731f9d93089d17da6ccec6778d165fccc26c7" translate="yes" xml:space="preserve">
          <source>Support JSX in &lt;code&gt;.tsx&lt;/code&gt; files: &lt;code&gt;&quot;react&quot;&lt;/code&gt;, &lt;code&gt;&quot;preserve&quot;&lt;/code&gt;, &lt;code&gt;&quot;react-native&quot;&lt;/code&gt;. See &lt;a href=&quot;jsx&quot;&gt;JSX&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.tsx&lt;/code&gt; ファイルでのJSXのサポート： &lt;code&gt;&quot;react&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;preserve&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;react-native&quot;&lt;/code&gt; 。&lt;a href=&quot;jsx&quot;&gt;JSXを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="05b310d45d1a230630edd11c6875345ecb5c8f86" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;--target ES2016&lt;/code&gt;, &lt;code&gt;--target ES2017&lt;/code&gt; and &lt;code&gt;--target ESNext&lt;/code&gt;</source>
          <target state="translated">サポート &lt;code&gt;--target ES2016&lt;/code&gt; 、 &lt;code&gt;--target ES2017&lt;/code&gt; と &lt;code&gt;--target ESNext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1b4ca504fdd62c03cb94726f4bcaf5058e435b4" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;--target ES6&lt;/code&gt; with &lt;code&gt;--module&lt;/code&gt;</source>
          <target state="translated">サポート &lt;code&gt;--target ES6&lt;/code&gt; と &lt;code&gt;--module&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34617739aff3f3e46b1e4ba3a7911e40d6c81ab3" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;UMD&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt; module output</source>
          <target state="translated">&lt;code&gt;UMD&lt;/code&gt; および &lt;code&gt;System&lt;/code&gt; モジュール出力のサポート</target>
        </trans-unit>
        <trans-unit id="28e272a817a6f695cb0b07fe3c763c51df093f79" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;default&lt;/code&gt; import interop with SystemJS</source>
          <target state="translated">SystemJSとの &lt;code&gt;default&lt;/code&gt; インポート相互運用のサポート</target>
        </trans-unit>
        <trans-unit id="d6916bf8e4e9fcc67b553b85f533341a04a63081" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;defaultProps&lt;/code&gt; in JSX</source>
          <target state="translated">JSX での &lt;code&gt;defaultProps&lt;/code&gt; のサポート</target>
        </trans-unit>
        <trans-unit id="bddb6099cc8b06729d2beaa2fa82e1cb4963256d" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;import d from &quot;cjs&quot;&lt;/code&gt; from CommonJS modules with &lt;code&gt;--esModuleInterop&lt;/code&gt;</source>
          <target state="translated">サポート &lt;code&gt;import d from &quot;cjs&quot;&lt;/code&gt; とCommonJSモジュールから &lt;code&gt;--esModuleInterop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2447881f3dbb81c3d00bf540954383e26e79f16a" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;import.meta&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;import.meta&lt;/code&gt; のサポート</target>
        </trans-unit>
        <trans-unit id="b85ac71ca924b44b00a2baf8d735c1f5146eae50" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;new.target&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new.target&lt;/code&gt; のサポート</target>
        </trans-unit>
        <trans-unit id="73d8dfa99384426433e9eb5bd0a25014a68b93dd" translate="yes" xml:space="preserve">
          <source>Support for Mix-in classes</source>
          <target state="translated">ミックスインクラスへの対応</target>
        </trans-unit>
        <trans-unit id="4cd188d2034c82b0cb13c97514a09e1296c575c1" translate="yes" xml:space="preserve">
          <source>Support for UMD module definitions</source>
          <target state="translated">UMDモジュール定義のサポート</target>
        </trans-unit>
        <trans-unit id="3f9527e099215a371571a39ed0291c0f01e1252f" translate="yes" xml:space="preserve">
          <source>Support for decorators when targeting ES3</source>
          <target state="translated">ES3をターゲットにした場合のデコレータのサポート</target>
        </trans-unit>
        <trans-unit id="773f4a6085e5e29b6090e773de66d818050ad310" translate="yes" xml:space="preserve">
          <source>Support for external helpers library (&lt;code&gt;tslib&lt;/code&gt;)</source>
          <target state="translated">外部ヘルパーライブラリ（ &lt;code&gt;tslib&lt;/code&gt; ）のサポート</target>
        </trans-unit>
        <trans-unit id="90086da7e4d9c7c72a78d492416302a2bce77eea" translate="yes" xml:space="preserve">
          <source>Support for plain JavaScript files (using &lt;code&gt;allowJS&lt;/code&gt; and optionally &lt;code&gt;checkJs&lt;/code&gt;)</source>
          <target state="translated">プレーンJavaScriptファイルのサポート（ &lt;code&gt;allowJS&lt;/code&gt; およびオプションで &lt;code&gt;checkJs&lt;/code&gt; を使用）</target>
        </trans-unit>
        <trans-unit id="db578fdb1495d83a80100aad5eef2fff1a254e97" translate="yes" xml:space="preserve">
          <source>Support for spread operator on JSX element children</source>
          <target state="translated">JSX要素の子要素でのスプレッド演算子のサポート</target>
        </trans-unit>
        <trans-unit id="2653012ad53a3216b4b35967a5d2774aa99160ca" translate="yes" xml:space="preserve">
          <source>Support output to IPC-driven files</source>
          <target state="translated">IPC駆動のファイルへの出力をサポート</target>
        </trans-unit>
        <trans-unit id="620a93c5c9f58f502218f8fc7b12158f1027565c" translate="yes" xml:space="preserve">
          <source>Supported JSDoc</source>
          <target state="translated">サポートされているJSDoc</target>
        </trans-unit>
        <trans-unit id="6ec78feed2dab45d29186124c86cf373749a2a02" translate="yes" xml:space="preserve">
          <source>Suppress &lt;code&gt;--noImplicitAny&lt;/code&gt; errors for indexing objects lacking index signatures. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362&quot;&gt;issue #1232&lt;/a&gt; for more details.</source>
          <target state="translated">インデックスシグネチャが不足しているインデックスオブジェクトの &lt;code&gt;--noImplicitAny&lt;/code&gt; エラーを抑制します。詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362&quot;&gt;問題＃1232&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="73191a43587818ef0ca4822c9bcaeab0705aafe7" translate="yes" xml:space="preserve">
          <source>Suppress Excess Property Errors - &lt;code&gt;suppressExcessPropertyErrors&lt;/code&gt;</source>
          <target state="translated">抑制過剰プロパティエラー- &lt;code&gt;suppressExcessPropertyErrors&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77daf91d977b3d49eec9b3c6d5f3a69ff849e689" translate="yes" xml:space="preserve">
          <source>Suppress Implicit Any Index Errors - &lt;code&gt;suppressImplicitAnyIndexErrors&lt;/code&gt;</source>
          <target state="translated">抑制暗黙の任意の索引エラー- &lt;code&gt;suppressImplicitAnyIndexErrors&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="338998f043c7ad5149421a96548321599b5d11bd" translate="yes" xml:space="preserve">
          <source>Suppress errors in .ts files using &amp;lsquo;// @ts-ignore&amp;rsquo; comments</source>
          <target state="translated">'// @ ts-ignore'コメントを使用して.tsファイルのエラーを抑制</target>
        </trans-unit>
        <trans-unit id="8973ef81aed840ec50c9cd093b51f775080b1cf7" translate="yes" xml:space="preserve">
          <source>Suppress excess property checks for object literals.</source>
          <target state="translated">オブジェクトリテラルの過剰なプロパティチェックを抑制します。</target>
        </trans-unit>
        <trans-unit id="9e53c6e8e58d38245a243cf6a1ed6b86dd7097bc" translate="yes" xml:space="preserve">
          <source>Svelte</source>
          <target state="translated">Svelte</target>
        </trans-unit>
        <trans-unit id="3585e72f4611a04509e6e0fc987893b8915a495f" translate="yes" xml:space="preserve">
          <source>Symbol-like properties of an object type are those declared using a computed property name of a unique symbol type.</source>
          <target state="translated">オブジェクト型のシンボルライクなプロパティは、ユニークなシンボル型の計算されたプロパティ名を使用して宣言されたものです。</target>
        </trans-unit>
        <trans-unit id="22ad664e9eb98b75a73333b2b2395fc4b52e6fc9" translate="yes" xml:space="preserve">
          <source>Symbols</source>
          <target state="translated">Symbols</target>
        </trans-unit>
        <trans-unit id="53fd75a5e5e2b34489476f4ecd50211e84205baf" translate="yes" xml:space="preserve">
          <source>Symbols are immutable, and unique.</source>
          <target state="translated">シンボルは不変であり、唯一無二のものです。</target>
        </trans-unit>
        <trans-unit id="0bed88fc8e0305dee9b7427dfb28c60dd6df7d7b" translate="yes" xml:space="preserve">
          <source>Symbols can also be combined with computed property declarations to declare object properties and class members.</source>
          <target state="translated">シンボルは、オブジェクトのプロパティやクラスのメンバを宣言するために、計算されたプロパティ宣言と組み合わせることもできます。</target>
        </trans-unit>
        <trans-unit id="7c6dc245d5de42731e89891927ee10ddf6d43590" translate="yes" xml:space="preserve">
          <source>Symbols: match</source>
          <target state="translated">シンボル:一致</target>
        </trans-unit>
        <trans-unit id="43536b93399f1c157500ef28d7217046b25bc3c7" translate="yes" xml:space="preserve">
          <source>Symbols: split</source>
          <target state="translated">シンボル:スプリット</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="57405c7f4b3b71908ae936ac8bf9b21de6ae98b8" translate="yes" xml:space="preserve">
          <source>System SimpleModule.js</source>
          <target state="translated">システムSimpleModule.js</target>
        </trans-unit>
        <trans-unit id="058f3d3687346d631d12546d9aade907ff39e99c" translate="yes" xml:space="preserve">
          <source>System modules have this flag on by default.</source>
          <target state="translated">システムモジュールはデフォルトでこのフラグをオンにしています。</target>
        </trans-unit>
        <trans-unit id="fc1f7c12fc55ff47463b0071310d36fbecc062ae" translate="yes" xml:space="preserve">
          <source>TS Build Info File - &lt;code&gt;tsBuildInfoFile&lt;/code&gt;</source>
          <target state="translated">TSビルド情報ファイル &lt;code&gt;tsBuildInfoFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab624ca73eb89a17acc6188413b3be19da770c27" translate="yes" xml:space="preserve">
          <source>TS for Functional Programmers</source>
          <target state="translated">機能プログラマー向けTS</target>
        </trans-unit>
        <trans-unit id="07673a3de2879cfe1db52c3e95c21b5cff20a04e" translate="yes" xml:space="preserve">
          <source>TS for Java/C# Programmers</source>
          <target state="translated">Java/C#プログラマのためのTS</target>
        </trans-unit>
        <trans-unit id="e5625ebb46a7cebb6fe457d6cbe88c67e28246af" translate="yes" xml:space="preserve">
          <source>TS for the New Programmer</source>
          <target state="translated">新人プログラマのためのTS</target>
        </trans-unit>
        <trans-unit id="db6b15580278437277b53f9bfd85bf02c341afd0" translate="yes" xml:space="preserve">
          <source>TSConfig</source>
          <target state="translated">TSConfig</target>
        </trans-unit>
        <trans-unit id="f0d1d3519955d1c177014af7b8de56104426d555" translate="yes" xml:space="preserve">
          <source>TSConfig Bases</source>
          <target state="translated">TSConfig ベース</target>
        </trans-unit>
        <trans-unit id="e3faa3a6af48373d85bf84403340df39a4e0870f" translate="yes" xml:space="preserve">
          <source>TSConfig Reference</source>
          <target state="translated">TSConfig リファレンス</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">目次</target>
        </trans-unit>
        <trans-unit id="1a428989bd13dceabd89b698d9fa38eb8a0d175c" translate="yes" xml:space="preserve">
          <source>Table of contents</source>
          <target state="translated">目次</target>
        </trans-unit>
        <trans-unit id="f228b75e57f130e745a665c5ce1b42328c6dfd98" translate="yes" xml:space="preserve">
          <source>Tagged template strings in ES3/ES5</source>
          <target state="translated">タグ付けされたES3/ES5のテンプレート文字列</target>
        </trans-unit>
        <trans-unit id="fab887d80b08c2be61de81a5b5b7c7f5fa4679ed" translate="yes" xml:space="preserve">
          <source>Tagged templates are a form of invocation introduced in ECMAScript 2015. Like call expressions, generic functions may be used in a tagged template and TypeScript will infer the type arguments utilized.</source>
          <target state="translated">タグ付きテンプレートは、ECMAScript 2015で導入された呼び出しの一形態です。呼び出し式と同様に、汎用関数はタグ付きテンプレートで使用することができ、TypeScriptは利用される型引数を推論します。</target>
        </trans-unit>
        <trans-unit id="2b4f32e1493a8fa164f90de2c9603dab9f3396aa" translate="yes" xml:space="preserve">
          <source>Tagged union types</source>
          <target state="translated">タグ付けされたユニオンタイプ</target>
        </trans-unit>
        <trans-unit id="ef15d77ea17c2fa0aa9a4dc5193a61bfca293a68" translate="yes" xml:space="preserve">
          <source>Take a quick second to guess what the output of the following snippet is:</source>
          <target state="translated">次のスニペットの出力が何であるかを推測してみてください。</target>
        </trans-unit>
        <trans-unit id="f7a6cee3faadf5126dbb6508921d3788cba5ee9b" translate="yes" xml:space="preserve">
          <source>Target - &lt;code&gt;target&lt;/code&gt;</source>
          <target state="translated">ターゲット- &lt;code&gt;target&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="62ec74968326eeada16e680490be28b9d097cf14" translate="yes" xml:space="preserve">
          <source>Targeting ECMAScript 2015 and higher</source>
          <target state="translated">ECMAScript 2015以上が対象</target>
        </trans-unit>
        <trans-unit id="2bb2a353dcf3f98e351b8a5bd43ad7b5855fbf44" translate="yes" xml:space="preserve">
          <source>Targeting ES5 and ES3</source>
          <target state="translated">ES5とES3をターゲットに</target>
        </trans-unit>
        <trans-unit id="8ebc171caef41add998a541b54fac3e9f04d8a0f" translate="yes" xml:space="preserve">
          <source>Technically enums can be mixed with string and numeric members, but it&amp;rsquo;s not clear why you would ever want to do so:</source>
          <target state="translated">技術的には列挙型は文字列と数値のメンバーと組み合わせることができますが、なぜそうしたいのかは明確ではありません：</target>
        </trans-unit>
        <trans-unit id="426c95cfc85b6cd93af3f2a51c05fff5f6d8d622" translate="yes" xml:space="preserve">
          <source>Tells TypeScript to save information about the project graph from the last compilation to files stored on disk. This creates a series of &lt;code&gt;.tsbuildinfo&lt;/code&gt; files in the same folder as your compilation output. They are not used by your JavaScript at runtime and can be safely deleted. You can read more about the flag in the &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#faster-subsequent-builds-with-the---incremental-flag&quot;&gt;3.4 release notes&lt;/a&gt;.</source>
          <target state="translated">最後のコンパイルからディスクに保存されたファイルにプロジェクトグラフに関する情報を保存するようにTypeScriptに指示します。これにより、コンパイル出力と同じフォルダーに一連の &lt;code&gt;.tsbuildinfo&lt;/code&gt; ファイルが作成されます。これらは実行時にJavaScriptによって使用されず、安全に削除できます。フラグの詳細については、&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#faster-subsequent-builds-with-the---incremental-flag&quot;&gt;3.4リリースノートを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="dc68610743d7021a571f80b8ceb084cbd65c3e6a" translate="yes" xml:space="preserve">
          <source>Template strings</source>
          <target state="translated">テンプレート文字列</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="8988c52340753c090a90538d2331c181cc676927" translate="yes" xml:space="preserve">
          <source>Templates For Modules</source>
          <target state="translated">モジュールのテンプレート</target>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="c2e85441e7a65630aa9248ad72623a3bd8be6e63" translate="yes" xml:space="preserve">
          <source>Test the page by running gulp and then opening &lt;code&gt;dist/index.html&lt;/code&gt; in a browser. You should see &amp;ldquo;Hello from TypeScript&amp;rdquo; on the page.</source>
          <target state="translated">gulpを実行してから、ブラウザーで &lt;code&gt;dist/index.html&lt;/code&gt; を開き、ページをテストします。ページに「Hello from TypeScript」と表示されます。</target>
        </trans-unit>
        <trans-unit id="516512568426629f66efb194dad6577cd22670ee" translate="yes" xml:space="preserve">
          <source>Test the resulting app</source>
          <target state="translated">結果のアプリをテストする</target>
        </trans-unit>
        <trans-unit id="96936a34c6da56cc40a32168338d905fe8a635c6" translate="yes" xml:space="preserve">
          <source>Test.ts</source>
          <target state="translated">Test.ts</target>
        </trans-unit>
        <trans-unit id="13197620f3528b6ac6188ce141c50ce0cda7fc64" translate="yes" xml:space="preserve">
          <source>TestCalculator.ts</source>
          <target state="translated">TestCalculator.ts</target>
        </trans-unit>
        <trans-unit id="cfaf8455cd86f64e0270da345fff974aff74f2d4" translate="yes" xml:space="preserve">
          <source>TestProgrammerCalculator.ts</source>
          <target state="translated">TestProgrammerCalculator.ts</target>
        </trans-unit>
        <trans-unit id="b57f29315e481e12c1ed5e16efc76553f50ab9b4" translate="yes" xml:space="preserve">
          <source>Testing your types</source>
          <target state="translated">タイプのテスト</target>
        </trans-unit>
        <trans-unit id="aa824f1aa0454aaae79a599c4caec36b1aa0a833" translate="yes" xml:space="preserve">
          <source>Thanks to work done by &lt;a href=&quot;https://github.com/tinganho&quot;&gt;@tinganho&lt;/a&gt;, TypeScript 2.5 implements a new ECMAScript feature that allows users to omit the variable in &lt;code&gt;catch&lt;/code&gt; clauses. For example, when using &lt;code&gt;JSON.parse&lt;/code&gt; you may need to wrap calls to the function with a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;, but you may not end up using the &lt;code&gt;SyntaxError&lt;/code&gt; that gets thrown when input is erroneous.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tinganho&quot;&gt;Typeting&lt;/a&gt; 2.5は、@tinganhoによって行われた作業のおかげで、ユーザーが &lt;code&gt;catch&lt;/code&gt; 句で変数を省略できる新しいECMAScript機能を実装しています。たとえば、 &lt;code&gt;JSON.parse&lt;/code&gt; を使用する場合、関数の呼び出しを &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; でラップする必要があるかもしれませんが、入力が誤っている場合にスローされる &lt;code&gt;SyntaxError&lt;/code&gt; を使用することにはならない場合があります。</target>
        </trans-unit>
        <trans-unit id="e9dd082930f9a8388911a09a5116d64645cb5117" translate="yes" xml:space="preserve">
          <source>That &lt;code&gt;@types/&lt;/code&gt; prefix means that we also want to get the declaration files for React and React-DOM. Usually when you import a path like &lt;code&gt;&quot;react&quot;&lt;/code&gt;, it will look inside of the &lt;code&gt;react&lt;/code&gt; package itself; however, not all packages include declaration files, so TypeScript also looks in the &lt;code&gt;@types/react&lt;/code&gt; package as well. You&amp;rsquo;ll see that we won&amp;rsquo;t even have to think about this later on.</source>
          <target state="translated">その &lt;code&gt;@types/&lt;/code&gt; 私たちも反応し-DOMを反応させるのための宣言ファイルを取得したいという接頭手段。通常、 &lt;code&gt;&quot;react&quot;&lt;/code&gt; のようなパスをインポートすると、それは &lt;code&gt;react&lt;/code&gt; パッケージ自体の内部を調べます。ただし、すべてのパッケージに宣言ファイルが含まれているわけではないため、TypeScriptは &lt;code&gt;@types/react&lt;/code&gt; パッケージも検索します。後でこれについて考える必要もないことがわかります。</target>
        </trans-unit>
        <trans-unit id="25b9871704aecadb7cf39ba9a43b9edb9f462ecd" translate="yes" xml:space="preserve">
          <source>That is, in the example:</source>
          <target state="translated">つまり、例の中では</target>
        </trans-unit>
        <trans-unit id="679400f47462964a9c86c95a36308380ba51cbe6" translate="yes" xml:space="preserve">
          <source>That last example isn&amp;rsquo;t actually type-safe.</source>
          <target state="translated">その最後の例は、実際にはタイプセーフではありません。</target>
        </trans-unit>
        <trans-unit id="f3dd652958b97aac01bd3e5a584afa623f93a34e" translate="yes" xml:space="preserve">
          <source>That might result in dividing &lt;code&gt;undefined&lt;/code&gt;, which is why in &lt;code&gt;strictNullChecks&lt;/code&gt;, the following is an error.</source>
          <target state="translated">その結果、 &lt;code&gt;undefined&lt;/code&gt; が除算される可能性があります。そのため、 &lt;code&gt;strictNullChecks&lt;/code&gt; では、次のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="f0f467baf30c5d87a58b511c11bcb6972b602339" translate="yes" xml:space="preserve">
          <source>That said, you can still use classes if you like! Some problems are well-suited to being solved by a traditional OOP hierarchy, and TypeScript&amp;rsquo;s support for JavaScript classes will make these models even more powerful. TypeScript supports many common patterns such as implementing interfaces, inheritance, and static methods.</source>
          <target state="translated">とはいえ、必要に応じてクラスを使用することもできます。一部の問題は、従来のOOP階層で解決するのに適しています。また、TypeScriptがJavaScriptクラスをサポートしているため、これらのモデルはさらに強力になります。TypeScriptは、インターフェイスの実装、継承、静的メソッドなど、多くの一般的なパターンをサポートしています。</target>
        </trans-unit>
        <trans-unit id="47f396705024ea00097d673c1c7caf3642c168b2" translate="yes" xml:space="preserve">
          <source>That was &lt;code&gt;tsconfig.json&lt;/code&gt; automatic inclusion. That does not embed module resolution as discussed above. If the compiler identified a file as a target of a module import, it will be included in the compilation regardless if it was excluded in the previous steps.</source>
          <target state="translated">それは &lt;code&gt;tsconfig.json&lt;/code&gt; の自動インクルードでした。上記で説明したように、モジュールの解決は埋め込まれません。コンパイラがファイルをモジュールインポートのターゲットとして識別した場合、前の手順で除外されたかどうかに関係なく、そのファイルはコンパイルに含まれます。</target>
        </trans-unit>
        <trans-unit id="fa532e4a22d2340a4675cbed4b144ee69c29ecb7" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s because &lt;code&gt;S&lt;/code&gt; isn&amp;rsquo;t assignable to &lt;code&gt;{ done: false, value: number }&lt;/code&gt; nor &lt;code&gt;{ done: true, value: number }&lt;/code&gt;. Why? Because the &lt;code&gt;done&lt;/code&gt; property in &lt;code&gt;S&lt;/code&gt; isn&amp;rsquo;t specific enough - it&amp;rsquo;s &lt;code&gt;boolean&lt;/code&gt; whereas each constituent of &lt;code&gt;T&lt;/code&gt; has a &lt;code&gt;done&lt;/code&gt; property that&amp;rsquo;s specifically &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. That&amp;rsquo;s what we meant by each constituent type being checked in isolation: TypeScript doesn&amp;rsquo;t just union each property together and see if &lt;code&gt;S&lt;/code&gt; is assignable to that. If it did, some bad code could get through like the following:</source>
          <target state="translated">これは、 &lt;code&gt;S&lt;/code&gt; が &lt;code&gt;{ done: false, value: number }&lt;/code&gt; も &lt;code&gt;{ done: true, value: number }&lt;/code&gt; も割り当てられないためです。どうして？ &lt;code&gt;S&lt;/code&gt; の &lt;code&gt;done&lt;/code&gt; プロパティは十分に具体的ではないため、 &lt;code&gt;boolean&lt;/code&gt; が、 &lt;code&gt;T&lt;/code&gt; の各構成要素には、 &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; である &lt;code&gt;done&lt;/code&gt; プロパティがあります。これは、構成要素の各タイプを個別にチェックすることで意味しました。TypeScriptは、各プロパティを結合して、 &lt;code&gt;S&lt;/code&gt; が割り当て可能かどうかを確認するだけではありません。もしそうなら、いくつかの悪いコードが次のように通り抜けることができます：</target>
        </trans-unit>
        <trans-unit id="ae1a2d3d73ce13174294793215ee52d989a7c794" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s exactly what TypeScript 3.7 introduces. At the &amp;ldquo;top level&amp;rdquo; of a type alias, TypeScript will defer resolving type arguments to permit these patterns.</source>
          <target state="translated">TypeScript 3.7はまさにそれを導入しています。型エイリアスの「トップレベル」では、TypeScriptは型引数の解決を延期して、これらのパターンを許可します。</target>
        </trans-unit>
        <trans-unit id="caa5997b70498ef9dc82ab15a96dfd070e25828b" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s not to say that a block-scoped variable can never be declared with a function-scoped variable. The block-scoped variable just needs to be declared within a distinctly different block.</source>
          <target state="translated">それは、ブロックスコープの変数が関数スコープの変数で宣言できないということではありません。ブロックスコープ変数は、明確に異なるブロック内で宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="4335f12ef785a4f02d33cbf4fd5c8f14a1000242" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s not to say that block-scoped variable can never be declared with a function-scoped variable. The block-scoped variable just needs to be declared within a distinctly different block.</source>
          <target state="translated">それは、ブロックスコープの変数が関数スコープの変数で宣言されることが決してできないということではありません。ブロックスコープの変数は、明確に異なるブロック内で宣言する必要があるだけです。</target>
        </trans-unit>
        <trans-unit id="f54fb341f70cf02ca8c9aeedc3f161af36941bc9" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;short-circuiting&amp;rdquo; behavior that optional chains have is limited property accesses, calls, element accesses - it doesn&amp;rsquo;t expand any further out from these expressions. In other words,</source>
          <target state="translated">オプションのチェーンの「短絡」動作は、プロパティへのアクセス、呼び出し、要素へのアクセスが制限されているため、これらの式から拡張されることはありません。言い換えると、</target>
        </trans-unit>
        <trans-unit id="279685a1fb5d36562f5b58508949f5e1e76e1bfb" translate="yes" xml:space="preserve">
          <source>The 1.1 compiler is typically around 4x faster than any previous release. See &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx&quot;&gt;this blog post for some impressive charts.&lt;/a&gt;</source>
          <target state="translated">1.1コンパイラは通常、以前のどのリリースよりも約4倍高速です。&lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx&quot;&gt;いくつかの印象的なチャート&lt;/a&gt;については、このブログ投稿を参照してください。</target>
        </trans-unit>
        <trans-unit id="bb3c43076a9f8e3e7ef5a2ac0f5c12ab3be00750" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;Async Iteration proposal&lt;/a&gt; introduces &amp;ldquo;Async Generators&amp;rdquo;, which are async functions that also can be used to yield partial computation results. Async Generators can also delegate calls via &lt;code&gt;yield*&lt;/code&gt; to either an iterable or async iterable:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;非同期反復提案&lt;/a&gt;も部分的計算結果を得るために使用することができる非同期関数で発表「非同期ジェネレータ」。また、非同期ジェネレーターは、 &lt;code&gt;yield*&lt;/code&gt; を介して呼び出しを反復可能または非同期反復可能に委任することもできます。</target>
        </trans-unit>
        <trans-unit id="f02cc7fd88e051d39dd94c7b8ad656951cb0464f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#strictNullChecks&quot;&gt;&lt;code&gt;--strictNullChecks&lt;/code&gt;&lt;/a&gt; flag fixes this: when you declare a variable, it doesn&amp;rsquo;t automatically include &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. You can include them explicitly using a union type:</source>
          <target state="translated">&lt;a href=&quot;https://www.typescriptlang.org/tsconfig#strictNullChecks&quot;&gt; &lt;code&gt;--strictNullChecks&lt;/code&gt; の&lt;/a&gt;フラグの修正この：あなたは変数を宣言するとき、それは自動的に含まれていない &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; 。共用体タイプを使用して、それらを明示的に含めることができます。</target>
        </trans-unit>
        <trans-unit id="7f1ed30131b8220c2729612ebb193d0d769356ff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;library-structures&quot;&gt;Library Structures&lt;/a&gt; guide helps you understand common library formats and how to write a correct declaration file for each format. If you&amp;rsquo;re editing an existing file, you probably don&amp;rsquo;t need to read this section. Authors of new declaration files must read this section to properly understand how the format of the library influences the writing of the declaration file.</source>
          <target state="translated">&lt;a href=&quot;library-structures&quot;&gt;ライブラリの構造の&lt;/a&gt;ガイドでは、共通ライブラリの形式を理解し、どのように各フォーマットの正しい宣言ファイルを書き込むのに役立ちます。既存のファイルを編集している場合は、おそらくこのセクションを読む必要はありません。新しい宣言ファイルの作成者は、このセクションを読んで、ライブラリの形式が宣言ファイルの書き込みにどのように影響するかを正しく理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="227e047dd56cbfa40dd19f72261ee33cba429b50" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;library-structures&quot;&gt;Library Structures&lt;/a&gt; guide helps you understand common library formats and how to write a proper declaration file for each format. If you&amp;rsquo;re editing an existing file, you probably don&amp;rsquo;t need to read this section. Authors of new declaration files are strongly encouraged to read this section to properly understand how the format of the library influences the writing of the declaration file.</source>
          <target state="translated">&lt;a href=&quot;library-structures&quot;&gt;ライブラリの構造の&lt;/a&gt;ガイドでは、共通ライブラリの形式を理解し、どのように各フォーマットのための適切な宣言ファイルを書き込むのに役立ちます。既存のファイルを編集している場合は、おそらくこのセクションを読む必要はありません。新しい宣言ファイルの作成者は、このセクションを読んで、ライブラリの形式が宣言ファイルの書き込みにどのように影響するかを正しく理解することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="168fd27f48806216cef1b28e300e7429c8509f10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;publishing&quot;&gt;Publishing&lt;/a&gt; section explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages.</source>
          <target state="translated">&lt;a href=&quot;publishing&quot;&gt;公開&lt;/a&gt;セクションは、NPMパッケージにあなたの宣言ファイルを公開する方法を説明し、あなたの依存パッケージを管理する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="ce97eb39054abf8cf82837da2071a640fc60351d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; property can be omitted, in which case the compiler&amp;rsquo;s defaults are used. See our full list of supported &lt;a href=&quot;compiler-options&quot;&gt;Compiler Options&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; プロパティは、コンパイラのデフォルト値が使用される場合には、省略することができます。サポートされている&lt;a href=&quot;compiler-options&quot;&gt;コンパイラオプションの&lt;/a&gt;一覧をご覧ください。</target>
        </trans-unit>
        <trans-unit id="0001ea5843eb39fe0b55fd06eada6c514b9a65f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; property can be omitted, in which case the compiler&amp;rsquo;s defaults are used. See our full list of supported &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;Compiler Options&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; プロパティは、コンパイラのデフォルト値が使用される場合には、省略することができます。サポートされている&lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;コンパイラオプションの&lt;/a&gt;完全なリストを参照してください。</target>
        </trans-unit>
        <trans-unit id="8e8ffdb01927e70146bd53bb542f82c73b284a32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;files&quot;&lt;/code&gt; property takes a list of relative or absolute file paths. The &lt;code&gt;&quot;include&quot;&lt;/code&gt; and &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; properties take a list of glob-like file patterns. The supported glob wildcards are:</source>
          <target state="translated">&lt;code&gt;&quot;files&quot;&lt;/code&gt; プロパティは、相対または絶対ファイルパスのリストを取ります。 &lt;code&gt;&quot;include&quot;&lt;/code&gt; と &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; プロパティはグロブのようなファイルのパターンのリストを取ります。サポートされているglobワイルドカードは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5722d93ed96ab9d91793fbf0f2e4a3ba0ddbc777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator adds &lt;code&gt;null&lt;/code&gt; and/or &lt;code&gt;undefined&lt;/code&gt; to the type of the right operand depending on which are present in the type of the left operand, and the &lt;code&gt;||&lt;/code&gt; operator removes both &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from the type of the left operand in the resulting union type.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 演算子は、加算 &lt;code&gt;null&lt;/code&gt; 及び/又は &lt;code&gt;undefined&lt;/code&gt; 左オペランドの型で存在する応じた右オペランドの型に、そして &lt;code&gt;||&lt;/code&gt; 演算子は、結果の共用体型の左オペランドの型から &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; 両方を削除します。</target>
        </trans-unit>
        <trans-unit id="b4b79995af952725664d6d796fdff7040cdc711f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; flag</source>
          <target state="translated">&lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; フラグ</target>
        </trans-unit>
        <trans-unit id="dbed519ddc1c4c5224ed0885756fb408460d0e55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--declaration&lt;/code&gt; flag in TypeScript allows us to generate &lt;code&gt;.d.ts&lt;/code&gt; files (declaration files) from TypeScript source files (i.e. &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files). These &lt;code&gt;.d.ts&lt;/code&gt; files are important for a couple of reasons.</source>
          <target state="translated">TypeScript の &lt;code&gt;--declaration&lt;/code&gt; フラグを使用すると、TypeScriptソースファイル（つまり、 &lt;code&gt;.ts&lt;/code&gt; および &lt;code&gt;.tsx&lt;/code&gt; ファイル）から &lt;code&gt;.d.ts&lt;/code&gt; ファイル（宣言ファイル）を生成できます。これらの &lt;code&gt;.d.ts&lt;/code&gt; ファイルは、いくつかの理由で重要です。</target>
        </trans-unit>
        <trans-unit id="a0fb7dd8edc5f347ffbf928efce80d73f62bde6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--noResolve&lt;/code&gt; compiler options instructs the compiler not to &amp;ldquo;add&amp;rdquo; any files to the compilation that were not passed on the command line. It will still try to resolve the module to files, but if the file is not specified, it will not be included.</source>
          <target state="translated">&lt;code&gt;--noResolve&lt;/code&gt; コンパイラオプションは、コマンドラインに渡されませんでしたコンパイルに任意のファイルを「追加」しないようにコンパイラに指示します。モジュールをファイルに解決しようとしますが、ファイルが指定されていない場合は含まれません。</target>
        </trans-unit>
        <trans-unit id="9d5dd988f9131b75e837bf6bf95d2078c1309d5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--preserveSymlinks&lt;/code&gt; compiler flag</source>
          <target state="translated">&lt;code&gt;--preserveSymlinks&lt;/code&gt; コンパイラフラグ</target>
        </trans-unit>
        <trans-unit id="d292c9d31d759812ffbe643f5735affa1b872f39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--project&lt;/code&gt; (&lt;code&gt;-p&lt;/code&gt;) flag can now take any file path</source>
          <target state="translated">&lt;code&gt;--project&lt;/code&gt; （ &lt;code&gt;-p&lt;/code&gt; ）フラグは今、任意のファイルのパスを取ることができます</target>
        </trans-unit>
        <trans-unit id="a4255cfd03965e4b15ab5c96a185655e2dc5c33c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--project&lt;/code&gt; command line option originally could only take paths to a folder containing a &lt;code&gt;tsconfig.json&lt;/code&gt;. Given the different scenarios for build configurations, it made sense to allow &lt;code&gt;--project&lt;/code&gt; to point to any other compatible JSON file. For instance, a user might want to target ES2015 with CommonJS modules for Node 5, but ES5 with AMD modules for the browser. With this new work, users can easily manage two separate build targets using &lt;code&gt;tsc&lt;/code&gt; alone without having to perform hacky workarounds like placing &lt;code&gt;tsconfig.json&lt;/code&gt; files in separate directories.</source>
          <target state="translated">&lt;code&gt;--project&lt;/code&gt; コマンドラインオプションは、もともとだけ含まれているフォルダへのパスを取ることができる &lt;code&gt;tsconfig.json&lt;/code&gt; を。ビルド構成のさまざまなシナリオを考えると、 &lt;code&gt;--project&lt;/code&gt; が他の互換性のあるJSONファイルをポイントできるようにすることは理にかなっています。たとえば、ユーザーはノード5にはCommonJSモジュールを使用してES2015をターゲットにしたいが、ブラウザにはAMDモジュールを使用したES5をターゲットにすることができます。この新しい作業により、ユーザーは、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを個別のディレクトリに配置するなどのハックな回避策を実行する必要なく、 &lt;code&gt;tsc&lt;/code&gt; のみを使用して2つの個別のビルドターゲットを簡単に管理できます。</target>
        </trans-unit>
        <trans-unit id="b04bf272ea6b6bb26429cf5a5402059fbfa0a766" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--strictNullChecks&lt;/code&gt; flag fixes this: when you declare a variable, it doesn&amp;rsquo;t automatically include &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. You can include them explicitly using a union type:</source>
          <target state="translated">&lt;code&gt;--strictNullChecks&lt;/code&gt; のフラグの修正この：あなたは変数を宣言するとき、それは自動的に含まれていない &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; 。union型を使用して明示的に含めることができます。</target>
        </trans-unit>
        <trans-unit id="55039ea9d10371eccc73bd4e7f114e096aeca2ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--watch&lt;/code&gt; implementation of the compiler relies on using &lt;code&gt;fs.watch&lt;/code&gt; and &lt;code&gt;fs.watchFile&lt;/code&gt; which are provided by node, both of these methods have pros and cons.</source>
          <target state="translated">コンパイラの &lt;code&gt;--watch&lt;/code&gt; 実装は、ノードによって提供される &lt;code&gt;fs.watch&lt;/code&gt; と &lt;code&gt;fs.watchFile&lt;/code&gt; の使用に依存しています。これらのメソッドには、どちらも長所と短所があります。</target>
        </trans-unit>
        <trans-unit id="d240e7152b3bafeb38e60b7f07cc2b34d2b2256a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.d.ts&lt;/code&gt; syntax intentionally looks like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;ES Modules&lt;/a&gt; syntax. ES Modules was ratified by TC39 in 2019, while it has been available via transpilers for a long time, however if you have a JavaScript codebase using ES Modules:</source>
          <target state="translated">&lt;code&gt;.d.ts&lt;/code&gt; は、意図的にのように見える構文&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;ESモジュールの&lt;/a&gt;構文を。ESモジュールは2019年にTC39によって承認されましたが、トランスパイラーを介して長い間利用可能でしたが、ESモジュールを使用するJavaScriptコードベースがある場合：</target>
        </trans-unit>
        <trans-unit id="a22cea6dc461395ba18169f7540ed681c6226e15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.js&lt;/code&gt; files will in turn contain a sourcemap comment to indicate to tools where the files are to external tools, for example:</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; ファイルは、順番にファイルには、例えば、外部ツールにあるツールに示すためにsourcemapコメントが含まれます。</target>
        </trans-unit>
        <trans-unit id="396ee46179af469e8ce6ffe938facf87a8ca3308" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive is the most common of this group. It serves as a declaration of &lt;em&gt;dependency&lt;/em&gt; between files.</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; ディレクティブは、このグループの中で最も一般的です。ファイル間の&lt;em&gt;依存関係の&lt;/em&gt;宣言として機能します。</target>
        </trans-unit>
        <trans-unit id="c5d5fa087679e905484eaa0544e66e00047a3587" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;??&lt;/code&gt; operator can replace uses of &lt;code&gt;||&lt;/code&gt; when trying to use a default value. For example, the following code snippet tries to fetch the volume that was last saved in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt;&lt;code&gt;localStorage&lt;/code&gt;&lt;/a&gt; (if it ever was); however, it has a bug because it uses &lt;code&gt;||&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;??&lt;/code&gt; オペレーターは &lt;code&gt;||&lt;/code&gt; の使用を置き換えることができます デフォルト値を使用しようとしたとき。たとえば、次のコードスニペットは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt; &lt;code&gt;localStorage&lt;/code&gt; &lt;/a&gt;に最後に保存されたボリュームをフェッチしようとします（ある場合）。ただし、 &lt;code&gt;||&lt;/code&gt; を使用しているため、バグがあります。。</target>
        </trans-unit>
        <trans-unit id="33ec4ccdd0a92f0fa626d1020e8655d8d52e57a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@enum&lt;/code&gt; tag allows you to create an object literal whose members are all of a specified type. Unlike most object literals in Javascript, it does not allow other members.</source>
          <target state="translated">&lt;code&gt;@enum&lt;/code&gt; のタグを使用すると、そのメンバーが指定されたタイプのすべてをあるオブジェクトリテラルを作成することができます。JavaScriptのほとんどのオブジェクトリテラルとは異なり、他のメンバーは許可されません。</target>
        </trans-unit>
        <trans-unit id="729d424ed3a9f5581bf724ec1a232c8c9d867325" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@enumerable(false)&lt;/code&gt; decorator here is a &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factory&lt;/a&gt;. When the &lt;code&gt;@enumerable(false)&lt;/code&gt; decorator is called, it modifies the &lt;code&gt;enumerable&lt;/code&gt; property of the property descriptor.</source>
          <target state="translated">ここの &lt;code&gt;@enumerable(false)&lt;/code&gt; デコレータは、&lt;a href=&quot;#decorator-factories&quot;&gt;デコレータファクトリ&lt;/a&gt;です。とき &lt;code&gt;@enumerable(false)&lt;/code&gt; デコレータが呼び出され、それが変更 &lt;code&gt;enumerable&lt;/code&gt; プロパティ記述子のプロパティを。</target>
        </trans-unit>
        <trans-unit id="2de9fb6766aab19221ef4c23a63fa9469054d5d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; decorator here is a &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factory&lt;/a&gt;. When &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; is called, it adds a metadata entry for the property using the &lt;code&gt;Reflect.metadata&lt;/code&gt; function from the &lt;code&gt;reflect-metadata&lt;/code&gt; library. When &lt;code&gt;getFormat&lt;/code&gt; is called, it reads the metadata value for the format.</source>
          <target state="translated">&lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; ここでのデコレータは、&lt;a href=&quot;#decorator-factories&quot;&gt;デコレータの工場&lt;/a&gt;。とき &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; と呼ばれ、それが使用して、プロパティのメタデータエントリを追加 &lt;code&gt;Reflect.metadata&lt;/code&gt; のから機能を &lt;code&gt;reflect-metadata&lt;/code&gt; ライブラリ。とき &lt;code&gt;getFormat&lt;/code&gt; 呼ばれ、それは形式のメタデータ値を読み取ります。</target>
        </trans-unit>
        <trans-unit id="19665d13a52211c67417591d8dd41380ae77c57c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@required&lt;/code&gt; decorator adds a metadata entry that marks the parameter as required. The &lt;code&gt;@validate&lt;/code&gt; decorator then wraps the existing &lt;code&gt;greet&lt;/code&gt; method in a function that validates the arguments before invoking the original method.</source>
          <target state="translated">&lt;code&gt;@required&lt;/code&gt; デコレータは、マークのパラメータが必要とされることをメタデータエントリを追加します。 &lt;code&gt;@validate&lt;/code&gt; のデコレータは、既存のラップ &lt;code&gt;greet&lt;/code&gt; 元のメソッドを呼び出す前に、引数を検証する機能のメソッドを。</target>
        </trans-unit>
        <trans-unit id="9608e5840a63db8f977864c74884f8b6002ea58a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ConstructorParameters&amp;lt;T&amp;gt;&lt;/code&gt; type lets us extract all parameter types of a constructor function type. It produces a tuple type with all the parameter types (or the type &lt;code&gt;never&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is not a function).</source>
          <target state="translated">&lt;code&gt;ConstructorParameters&amp;lt;T&amp;gt;&lt;/code&gt; 型は、私たちは、コンストラクタ関数のタイプのすべてのパラメータの種類を抽出することができます。これは、すべてのパラメーター型（または &lt;code&gt;T&lt;/code&gt; が関数でない場合は &lt;code&gt;never&lt;/code&gt; 型なし）のタプル型を生成します。</target>
        </trans-unit>
        <trans-unit id="83d02d02d5620960b36d464619c7937c85cc9171" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Document&lt;/code&gt; Interface</source>
          <target state="translated">&lt;code&gt;Document&lt;/code&gt; インターフェイス</target>
        </trans-unit>
        <trans-unit id="e4d0252ee699e46769d5a622ff65ea37a30cb18c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; type now allows users to specify the yielded type, the returned type, and the type that &lt;code&gt;next&lt;/code&gt; can accept.</source>
          <target state="translated">&lt;code&gt;Iterator&lt;/code&gt; タイプは今、ユーザーが生成したタイプ、返さ種類、そのタイプを指定することができます &lt;code&gt;next&lt;/code&gt; 受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="c806f2503a2c301fc142862aa6123f9229b59408" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; インタフェース</target>
        </trans-unit>
        <trans-unit id="7f41c5b21ee9dbf168d5ef4da903752f9e8d385c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Omit&lt;/code&gt; helper type</source>
          <target state="translated">&lt;code&gt;Omit&lt;/code&gt; ヘルパータイプ</target>
        </trans-unit>
        <trans-unit id="64a869fe08430ba63b8b26229df6154c69e8f8af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReadonlyArray&lt;/code&gt; type describes &lt;code&gt;Array&lt;/code&gt;s that can only be read from. Any variable with a reference to a &lt;code&gt;ReadonlyArray&lt;/code&gt; can&amp;rsquo;t add, remove, or replace any elements of the array.</source>
          <target state="translated">&lt;code&gt;ReadonlyArray&lt;/code&gt; のタイプは説明 &lt;code&gt;Array&lt;/code&gt; のみから読み取ることができるのを。 &lt;code&gt;ReadonlyArray&lt;/code&gt; への参照を持つ変数は、配列の要素を追加、削除、または置換できません。</target>
        </trans-unit>
        <trans-unit id="6368f607a56bb2c916a5b954c6dabe855ebf8589" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ThisType&amp;lt;T&amp;gt;&lt;/code&gt; marker interface is simply an empty interface declared in &lt;code&gt;lib.d.ts&lt;/code&gt;. Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface.</source>
          <target state="translated">&lt;code&gt;ThisType&amp;lt;T&amp;gt;&lt;/code&gt; マーカーインタフェースは、単純に宣言した空のインターフェースです &lt;code&gt;lib.d.ts&lt;/code&gt; 。オブジェクトリテラルのコンテキストタイプで認識される以外に、インターフェイスは空のインターフェイスのように動作します。</target>
        </trans-unit>
        <trans-unit id="eac98c87d76e62726c164fbe787eb6f8c34463c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amd-dependency&lt;/code&gt; directive can also have an optional &lt;code&gt;name&lt;/code&gt; property; this allows passing an optional name for an amd-dependency:</source>
          <target state="translated">&lt;code&gt;amd-dependency&lt;/code&gt; ディレクティブは、オプションのことができます &lt;code&gt;name&lt;/code&gt; プロパティを。これにより、amd-dependencyにオプションの名前を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="5e27299aa8a8890f9cedcc0ab41fbf05f07fd29d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amd-module&lt;/code&gt; directive allows passing an optional module name to the compiler:</source>
          <target state="translated">&lt;code&gt;amd-module&lt;/code&gt; ディレクティブは、コンパイラにオプションのモジュール名を渡すことができます：</target>
        </trans-unit>
        <trans-unit id="3a42e83d7ce322bb05576e69237c913e674e94ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; type is a powerful way to work with existing JavaScript, allowing you to gradually opt-in and opt-out of type checking during compilation.</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; タイプができるように、JavaScriptを既存との仕事に強力な方法であるあなたに徐々にオプトインとオプトアウト型チェックのコンパイル中。</target>
        </trans-unit>
        <trans-unit id="a057b54c00069469116e2e7ce7d79e2e760309d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; type is a powerful way to work with existing JavaScript, allowing you to gradually opt-in and opt-out of type checking during compilation. You might expect &lt;code&gt;Object&lt;/code&gt; to play a similar role, as it does in other languages. However, variables of type &lt;code&gt;Object&lt;/code&gt; only allow you to assign any value to them. You can&amp;rsquo;t call arbitrary methods on them, even ones that actually exist:</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; タイプができるように、JavaScriptを既存との仕事に強力な方法であるあなたに徐々にオプトインとオプトアウト型チェックのコンパイル中。他の言語と同様に、 &lt;code&gt;Object&lt;/code&gt; が同様の役割を果たすことを期待するかもしれません。ただし、 &lt;code&gt;Object&lt;/code&gt; 型の変数では、値を割り当てることしかできません。それらに対して任意のメソッドを呼び出すことはできません。実際に存在するものも含めます。</target>
        </trans-unit>
        <trans-unit id="c0017d222210d0ddb4e497a93705b0979da8a1a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; type is also handy if you know some part of the type, but perhaps not all of it. For example, you may have an array but the array has a mix of different types:</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; あなたがタイプの一部を知っているが、おそらくすべてではない、それの場合は種類も便利です。たとえば、配列がある場合でも、配列にはさまざまなタイプが混在しています。</target>
        </trans-unit>
        <trans-unit id="d1d41de80e1caf6129e3e280267f6e09abe3bf99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; will continue to propagate through your objects:</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; あなたのオブジェクトを介して伝播していきます。</target>
        </trans-unit>
        <trans-unit id="3e134f2fc8f2da81e48dedae85eec0c1c0994e99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; operator</source>
          <target state="translated">オペレータ &lt;code&gt;as&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3c73e06a99fdb1de9fb8c344fa7c098a7a03b56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; operator is available in both &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files, and is identical in behavior to the angle-bracket type assertion style.</source>
          <target state="translated">オペレータは、両方で利用可能です &lt;code&gt;.ts&lt;/code&gt; と &lt;code&gt;.tsx&lt;/code&gt; ファイル、およびアングルブラケット型アサーションスタイルに動作は同じです。 &lt;code&gt;as&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3eeb3c7a58b8f984aa019a2e9e3c1db1552b14c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;composite&lt;/code&gt; option enforces certain constraints which make it possible for build tools (including TypeScript itself, under &lt;code&gt;--build&lt;/code&gt; mode) to quickly determine if a project has been built yet.</source>
          <target state="translated">&lt;code&gt;composite&lt;/code&gt; オプションは（下、活字体自体を含むビルドツールのことを可能にする特定の制約強制 &lt;code&gt;--build&lt;/code&gt; プロジェクトがまだ構築されているかどうかを迅速に判定するモード）。</target>
        </trans-unit>
        <trans-unit id="dec99f693ec8e29469547cb939cd2051d5a6580d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;document.getElementById&lt;/code&gt; function returns an &lt;code&gt;HTMLElement&lt;/code&gt;. &lt;code&gt;HTMLElement&lt;/code&gt; interface extends the &lt;code&gt;Element&lt;/code&gt; interface which extends the &lt;code&gt;Node&lt;/code&gt; interface. This prototypal extension allows for all &lt;code&gt;HTMLElements&lt;/code&gt; to utilize a subset of standard methods. In the code snippet, we use a property defined on the &lt;code&gt;Node&lt;/code&gt; interface to append the new &lt;code&gt;p&lt;/code&gt; element to the website.</source>
          <target state="translated">&lt;code&gt;document.getElementById&lt;/code&gt; の関数は返し &lt;code&gt;HTMLElement&lt;/code&gt; 。 &lt;code&gt;HTMLElement&lt;/code&gt; インターフェースは、 &lt;code&gt;Node&lt;/code&gt; インターフェースを拡張する &lt;code&gt;Element&lt;/code&gt; インターフェースを拡張します。このプロトタイプ拡張により、すべての &lt;code&gt;HTMLElements&lt;/code&gt; が標準メソッドのサブセットを利用できるようになります。コードスニペットでは、 &lt;code&gt;Node&lt;/code&gt; インターフェイスで定義されたプロパティを使用して、新しい &lt;code&gt;p&lt;/code&gt; 要素をWebサイトに追加します。</target>
        </trans-unit>
        <trans-unit id="a3a92cff5154e72c024dab414b5c117b995405f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exclude&lt;/code&gt; list does not support wilcards. It must simply be a list of files and/or directories.</source>
          <target state="translated">&lt;code&gt;exclude&lt;/code&gt; リストはwilcardsサポートしていません。単にファイルやディレクトリのリストでなければなりません。</target>
        </trans-unit>
        <trans-unit id="c3af89dee69149756441c4182df39cc8f0c3f4db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export =&lt;/code&gt; syntax specifies a single object that is exported from the module. This can be a class, interface, namespace, function, or enum.</source>
          <target state="translated">&lt;code&gt;export =&lt;/code&gt; 構文は、モジュールからエクスポートされた単一のオブジェクトを指定します。これは、クラス、インターフェース、名前空間、関数、または列挙型にすることができます。</target>
        </trans-unit>
        <trans-unit id="17738861fda178b7ad88eea31d19aa3f7764605b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extends&lt;/code&gt; clause of a class previously required a type reference to be specified. It now accepts an expression optionally followed by a type argument list. The type of the expression must be a constructor function type with at least one construct signature that has the same number of type parameters as the number of type arguments specified in the &lt;code&gt;extends&lt;/code&gt; clause. The return type of the matching construct signature(s) is the base type from which the class instance type inherits. Effectively, this allows both real classes and &amp;ldquo;class-like&amp;rdquo; expressions to be specified in the &lt;code&gt;extends&lt;/code&gt; clause.</source>
          <target state="translated">クラスの &lt;code&gt;extends&lt;/code&gt; 節では、以前は型参照を指定する必要がありました。これは、オプションで、その後に型引数リストが続く式を受け入れます。式の型は、 &lt;code&gt;extends&lt;/code&gt; 句で指定された型引数の数と同じ数の型パラメーターを持つ、少なくとも1つの構成シグニチャーを持つコンストラクター関数型でなければなりません。一致する構成シグニチャーの戻りタイプは、クラスインスタンスタイプが継承する基本タイプです。事実上、これにより、実際のクラスと「クラスのような」式の両方を &lt;code&gt;extends&lt;/code&gt; 節で指定できます。</target>
        </trans-unit>
        <trans-unit id="ba2b01f6262a247dc48cefc8edd8183caa3b6800" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extends&lt;/code&gt; is a top-level property in &lt;code&gt;tsconfig.json&lt;/code&gt; (alongside &lt;code&gt;compilerOptions&lt;/code&gt;, &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, and &lt;code&gt;exclude&lt;/code&gt;). &lt;code&gt;extends&lt;/code&gt;&amp;rsquo; value is a string containing a path to another configuration file to inherit from. The path may use Node.js style resolution.</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; でトップレベルのプロパティです &lt;code&gt;tsconfig.json&lt;/code&gt; （並んで &lt;code&gt;compilerOptions&lt;/code&gt; 、 &lt;code&gt;files&lt;/code&gt; 、 &lt;code&gt;include&lt;/code&gt; 、かつ &lt;code&gt;exclude&lt;/code&gt; ）。 &lt;code&gt;extends&lt;/code&gt; '値は、継承元の別の構成ファイルへのパスを含む文字列です。パスはNode.jsスタイルの解決を使用する場合があります。</target>
        </trans-unit>
        <trans-unit id="3017f557a2f328b58256e1eb412ef2360a4c4d18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for-await-of&lt;/code&gt; Statement</source>
          <target state="translated">&lt;code&gt;for-await-of&lt;/code&gt; 声明</target>
        </trans-unit>
        <trans-unit id="070a2aede6e683916dcd05d3af0a560d4036508a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for..await..of&lt;/code&gt; statement is only legal within an Async Function or Async Generator.</source>
          <target state="translated">&lt;code&gt;for..await..of&lt;/code&gt; 文は、非同期関数または非同期ジェネレータ内でのみ合法です。</target>
        </trans-unit>
        <trans-unit id="c1d7afbee8b4e917fda3b9d2fe2dbda01149f13f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getWidget&lt;/code&gt; function accepts a number and returns a Widget, or accepts a string and returns a Widget array.</source>
          <target state="translated">&lt;code&gt;getWidget&lt;/code&gt; の関数は、数値を受け入れ、ウィジェットを返す、または文字列を受け取り、ウィジェット配列を返します。</target>
        </trans-unit>
        <trans-unit id="b90a2540458db7fb3aef294d8c4559c6aab9f51d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;greeter&lt;/code&gt; object can log to a file or display an alert. You can provide LogOptions to &lt;code&gt;.log(...)&lt;/code&gt; and alert options to &lt;code&gt;.alert(...)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;greeter&lt;/code&gt; オブジェクトは、ファイルへのログまたはアラートを表示することができます。 &lt;code&gt;.log(...)&lt;/code&gt; に LogOptionsを、.alert （...）にアラートオプションを提供できます &lt;code&gt;.alert(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="681ed2c77b2f124166709179044128a1509b2444" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in&lt;/code&gt; operator also acts as a narrowing expression for types.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; オペレータはまたタイプのための絞込み式として機能します。</target>
        </trans-unit>
        <trans-unit id="21c39d544da86c80cc2e6b131693af3e027fdc76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in&lt;/code&gt; operator now acts as a narrowing expression for types.</source>
          <target state="translated">作業は今のタイプの狭小化表現として機能します。 &lt;code&gt;in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1dd9f41eb7331354f03e6ddd8b1c9f2a64fbffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;length&lt;/code&gt; property of a tuple type with optional elements is a union of numeric literal types representing the possible lengths. For example, the type of the &lt;code&gt;length&lt;/code&gt; property in the tuple type &lt;code&gt;[number, string?, boolean?]&lt;/code&gt; is &lt;code&gt;1 | 2 | 3&lt;/code&gt;.</source>
          <target state="translated">オプションの要素を持つタプル型の &lt;code&gt;length&lt;/code&gt; プロパティは、可能な長さを表す数値リテラル型の和集合です。たとえば、タプルタイプ &lt;code&gt;[number, string?, boolean?]&lt;/code&gt; の &lt;code&gt;length&lt;/code&gt; プロパティのタイプは &lt;code&gt;1 | 2 | 3&lt;/code&gt; です。2 | ３。</target>
        </trans-unit>
        <trans-unit id="edc3cf84bfebfe901fb4d4669024b6fb12e9c7d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;moment&lt;/code&gt; import would be fully typed.</source>
          <target state="translated">&lt;code&gt;moment&lt;/code&gt; インポートが完全に入力されたことになります。</target>
        </trans-unit>
        <trans-unit id="b63b4343498819e73c1335f4802dd4ecef55b161" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="a9f3d4cb7613ec649d53f0d74013eb6fa4569ec9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type has the following characteristics:</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 種類は、次の特性があります。</target>
        </trans-unit>
        <trans-unit id="1e1a0ee3128b4be96a4b23dc31c8ff4663ecbf13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type is a subtype of, and assignable to, every type; however, &lt;em&gt;no&lt;/em&gt; type is a subtype of, or assignable to, &lt;code&gt;never&lt;/code&gt; (except &lt;code&gt;never&lt;/code&gt; itself). Even &lt;code&gt;any&lt;/code&gt; isn&amp;rsquo;t assignable to &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 種類はのサブタイプ、および、すべてのタイプに割り当て可能です。しかし、&lt;em&gt;何の&lt;/em&gt;タイプはのサブタイプ、または、に割り当て可能ではありません &lt;code&gt;never&lt;/code&gt; （除く &lt;code&gt;never&lt;/code&gt; 自体が）。 &lt;code&gt;any&lt;/code&gt; も &lt;code&gt;never&lt;/code&gt; 割り当て可能ではありません。</target>
        </trans-unit>
        <trans-unit id="f09dccd3b70d3efcf8ad49b20ad7c607d29406b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type represents the type of values that never occur. For instance, &lt;code&gt;never&lt;/code&gt; is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns. Variables also acquire the type &lt;code&gt;never&lt;/code&gt; when narrowed by any type guards that can never be true.</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 種類は発生しない値の種類を表します。例えば、 &lt;code&gt;never&lt;/code&gt; 関数式か、常に例外または1決してリターンをスロー矢印関数式の戻り値の型ではありません。また、変数は、真になることのないタイプガードによって狭められたときに、 &lt;code&gt;never&lt;/code&gt; タイプを取得しません。</target>
        </trans-unit>
        <trans-unit id="c32d1689d5690c0a84ea806da09f9080b457ae29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type represents the type of values that never occur. For instance, &lt;code&gt;never&lt;/code&gt; is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns; Variables also acquire the type &lt;code&gt;never&lt;/code&gt; when narrowed by any type guards that can never be true.</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 種類は発生しない値の種類を表します。たとえば、 &lt;code&gt;never&lt;/code&gt; は常に例外をスローする関数式またはアロー関数式の戻り値の型、または決して戻らないものです。また、変数は、真になることのないタイプガードによって狭められた場合、 &lt;code&gt;never&lt;/code&gt; 型を取得しません。</target>
        </trans-unit>
        <trans-unit id="415ee7bd886be7d1a3ff4410f75297e6f875a010" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new.target&lt;/code&gt; meta-property is new syntax introduced in ES2015. When an instance of a constructor is created via &lt;code&gt;new&lt;/code&gt;, the value of &lt;code&gt;new.target&lt;/code&gt; is set to be a reference to the constructor function initially used to allocate the instance. If a function is called rather than constructed via &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;new.target&lt;/code&gt; is set to &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new.target&lt;/code&gt; メタプロパティは、ES2015に導入された新しい構文です。 &lt;code&gt;new&lt;/code&gt; を介してコンストラクタのインスタンスが作成されると、 &lt;code&gt;new.target&lt;/code&gt; の値は、インスタンスを割り当てるために最初に使用されたコンストラクタ関数への参照になるように設定されます。 &lt;code&gt;new&lt;/code&gt; を介して構築されるのではなく関数が呼び出される場合、 &lt;code&gt;new.target&lt;/code&gt; は &lt;code&gt;undefined&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="19477c8f1cfa1e9c60356444eaaad7d0b42b9b97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; types are &lt;em&gt;not&lt;/em&gt; widened to &lt;code&gt;any&lt;/code&gt; in strict null checking mode.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; 種類はされて&lt;em&gt;いない&lt;/em&gt;に広がった &lt;code&gt;any&lt;/code&gt; 厳格なヌルチェックモードで。</target>
        </trans-unit>
        <trans-unit id="fa34aa7759f5de219e7583fd1dd7f008d517869c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;null&lt;/code&gt; elimination is pretty obvious here, but you can use terser operators too:</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 除去は、ここでかなり明白ですが、あまりにもterser演算子を使用することができます。</target>
        </trans-unit>
        <trans-unit id="ce2eedc44ab0659afbd8a1934f33562f60e3a770" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;out&lt;/code&gt; option computes the final file location in a way that is not predictable or consistent. This option is retained for backward compatibility only and is deprecated.</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; オプションは、予測可能か一貫性がないように、最終的なファイルの場所を計算します。このオプションは下位互換性のためにのみ保持されており、非推奨です。</target>
        </trans-unit>
        <trans-unit id="3b9cc299e7f4d8fe545c9d49c0fc120f67d07f88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; property of each reference can point to a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file, or to the config file itself (which may have any name).</source>
          <target state="translated">各参照の &lt;code&gt;path&lt;/code&gt; プロパティは、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを含むディレクトリ、または構成ファイル自体（任意の名前を持つ可能性があります）を指すことができます。</target>
        </trans-unit>
        <trans-unit id="2afabb5c4140f687a8b8b854febbb675c40d2812" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;point&lt;/code&gt; variable is never declared to be a &lt;code&gt;Point&lt;/code&gt; type. However, TypeScript compares the shape of &lt;code&gt;point&lt;/code&gt; to the shape of &lt;code&gt;Point&lt;/code&gt; in the type-check. They have the same shape, so the code passes.</source>
          <target state="translated">&lt;code&gt;point&lt;/code&gt; 変数があると宣言されることはありません &lt;code&gt;Point&lt;/code&gt; タイプ。しかし、活字体は、形状比較 &lt;code&gt;point&lt;/code&gt; の形状に &lt;code&gt;Point&lt;/code&gt; タイプチェックします。それらは同じ形状であるため、コードは合格です。</target>
        </trans-unit>
        <trans-unit id="c5b3e36b4b2dc53fe86b3370909ee5fca3f8d695" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;preserve&lt;/code&gt; mode will keep JSX expressions as part of the output to be further consumed by another transform step. &lt;em&gt;Additionally the output will have a &lt;code&gt;.jsx&lt;/code&gt; file extension.&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;preserve&lt;/code&gt; モードは、さらに別の変換ステップによって消費される出力の一部としてJSX式を維持します。&lt;em&gt;さらに、出力には &lt;code&gt;.jsx&lt;/code&gt; ファイル拡張子が付きます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="854b44746f0abc418eff6be7c3fdd54bb19efc1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;protected&lt;/code&gt; modifier acts much like the &lt;code&gt;private&lt;/code&gt; modifier with the exception that members declared &lt;code&gt;protected&lt;/code&gt; can also be accessed within deriving classes. For example,</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; 修飾子はかなりのような役割を果たし &lt;code&gt;private&lt;/code&gt; メンバーが宣言ことを除いて、モディファイ &lt;code&gt;protected&lt;/code&gt; も派生クラス内でアクセスすることができます。例えば、</target>
        </trans-unit>
        <trans-unit id="6d895e4e8795254dd65da4c62b6624de0640eaf1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;querySelector&lt;/code&gt; and &lt;code&gt;querySelectorAll&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;querySelector&lt;/code&gt; と &lt;code&gt;querySelectorAll&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="6fb559dc4cb94749b099fdff9ab41761d1224d04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;querySelectorAll&lt;/code&gt; definition is similar to &lt;code&gt;getElementsByTagName&lt;/code&gt;, except it returns a new type: &lt;code&gt;NodeListOf&lt;/code&gt;. This return type is essentially a custom implementation of the standard JavaScript list element. Arguably, replacing &lt;code&gt;NodeListOf&amp;lt;E&amp;gt;&lt;/code&gt; with &lt;code&gt;E[]&lt;/code&gt; would result in a very similar user experience. &lt;code&gt;NodeListOf&lt;/code&gt; only implements the following properties and methods: &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;item(index)&lt;/code&gt;, &lt;code&gt;forEach((value, key, parent) =&amp;gt; void)&lt;/code&gt; , and numeric indexing. Additionally, this method returns a list of &lt;em&gt;elements&lt;/em&gt;, not &lt;em&gt;nodes&lt;/em&gt;, which is what &lt;code&gt;NodeList&lt;/code&gt; was returning from the &lt;code&gt;.childNodes&lt;/code&gt; method. While this may appear as a discrepancy, take note that interface &lt;code&gt;Element&lt;/code&gt; extends from &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;querySelectorAll&lt;/code&gt; の定義は次のようにある &lt;code&gt;getElementsByTagName&lt;/code&gt; のそれは新しい型を返す以外、： &lt;code&gt;NodeListOf&lt;/code&gt; 。この戻り値の型は、基本的に標準のJavaScriptリスト要素のカスタム実装です。間違いなく、 &lt;code&gt;NodeListOf&amp;lt;E&amp;gt;&lt;/code&gt; を &lt;code&gt;E[]&lt;/code&gt; に置き換えると、非常によく似たユーザーエクスペリエンスが得られます。 &lt;code&gt;NodeListOf&lt;/code&gt; は、次のプロパティとメソッドのみを実装します： &lt;code&gt;length&lt;/code&gt; 、 &lt;code&gt;item(index)&lt;/code&gt; 、 &lt;code&gt;forEach((value, key, parent) =&amp;gt; void)&lt;/code&gt; 、および数値インデックス。さらに、このメソッドは&lt;em&gt;ノード&lt;/em&gt;ではなく&lt;em&gt;要素の&lt;/em&gt;リストを返します。これは &lt;code&gt;NodeList&lt;/code&gt; です。&lt;em&gt;&lt;/em&gt; &lt;code&gt;.childNodes&lt;/code&gt; メソッドから戻っていました。これは不一致として表示される場合がありますが、インターフェイス &lt;code&gt;Element&lt;/code&gt; が &lt;code&gt;Node&lt;/code&gt; から拡張されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f60b5b9402d0bcc5b53cc9b4ebead84ff4399b9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react&lt;/code&gt; mode will emit &lt;code&gt;React.createElement&lt;/code&gt;, does not need to go through a JSX transformation before use, and the output will have a &lt;code&gt;.js&lt;/code&gt; file extension.</source>
          <target state="translated">&lt;code&gt;react&lt;/code&gt; 発光するモード &lt;code&gt;React.createElement&lt;/code&gt; は、使用前にJSX変換を通過する必要はありません、と出力があります &lt;code&gt;.js&lt;/code&gt; ファイル拡張子を。</target>
        </trans-unit>
        <trans-unit id="731bfb54c9c710c3fddba0d525348937d618334a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; properties will appear with correct types on all components</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; と &lt;code&gt;key&lt;/code&gt; のプロパティは、すべてのコンポーネントの正しい種類が表示されます</target>
        </trans-unit>
        <trans-unit id="3ff4b0ed4771c56a90177b8d4ff4bd3f592871c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; property is correctly disallowed on instances of Stateless Function components</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; プロパティが正しくステートレス機能コンポーネントのインスタンスに許可されません</target>
        </trans-unit>
        <trans-unit id="ac59872f32d7b3a719d54a776ba1d5030bee34ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rootDir&lt;/code&gt; setting, if not explicitly set, defaults to the directory containing the &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;rootDir&lt;/code&gt; 設定、明示的に設定されていない場合、あるディレクトリにデフォルト &lt;code&gt;tsconfig.json&lt;/code&gt; のファイルを。</target>
        </trans-unit>
        <trans-unit id="afd948bd24859b80dd2610380a6c20a8cd87a044" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rootDir&lt;/code&gt; setting, if not explicitly set, defaults to the directory containing the &lt;code&gt;tsconfig&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;rootDir&lt;/code&gt; 設定、明示的に含むディレクトリに、デフォルト値を設定しない場合 &lt;code&gt;tsconfig&lt;/code&gt; ファイルを</target>
        </trans-unit>
        <trans-unit id="e8756ccc79f64c7c4f7907edf57709c722c3dc27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict&lt;/code&gt; flag enables a wide range of type checking behavior that results in stronger guarantees of program correctness. Turning this on is equivalent to enabling all of the &lt;em&gt;strict mode family&lt;/em&gt; options, which are outlined below. You can then turn off individual strict mode family checks as needed.</source>
          <target state="translated">&lt;code&gt;strict&lt;/code&gt; フラグは、プログラムの正確の強い保証をもたらすこと型チェックの動作の広い範囲を可能にします。これをオンにすることは、以下に概説するすべての&lt;em&gt;厳密モードファミリ&lt;/em&gt;オプションを有効にすることと同じです。その後、必要に応じて、個々の厳密モードのファミリチェックをオフにすることができます。</target>
        </trans-unit>
        <trans-unit id="45854eb3beba23a865f9cbaa14a544abf02a43ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; option (allowing users to switch out of &lt;code&gt;es5&lt;/code&gt; to &lt;code&gt;es3&lt;/code&gt;, &lt;code&gt;es2015&lt;/code&gt;, &lt;code&gt;esnext&lt;/code&gt;, etc.)</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; オプション（ユーザがのうちの切り替えを可能にする &lt;code&gt;es5&lt;/code&gt; に &lt;code&gt;es3&lt;/code&gt; 、 &lt;code&gt;es2015&lt;/code&gt; 、 &lt;code&gt;esnext&lt;/code&gt; 等）</target>
        </trans-unit>
        <trans-unit id="d58e04ff8c5c532dba7b8207798261684e83b514" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; setting changes which JS features are downleveled and which are left intact. For example, an arrow function &lt;code&gt;() =&amp;gt; this&lt;/code&gt; will be turned into an equivalent &lt;code&gt;function&lt;/code&gt; expression if &lt;code&gt;target&lt;/code&gt; is ES5 or lower.</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; JS機能がdownleveledとされている設定変更がそのまま残されています。たとえば、矢印関数 &lt;code&gt;() =&amp;gt; this&lt;/code&gt; は、 &lt;code&gt;target&lt;/code&gt; がES5以下の場合、同等の &lt;code&gt;function&lt;/code&gt; 式に変換されます。</target>
        </trans-unit>
        <trans-unit id="13c27e388b6d0efef978313ee87f8dcb0b62e5dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; type is also useful with intersection types in describing libraries (e.g. Ember.js) that use mixin-style patterns to describe inheritance:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; タイプは、使用ミックスイン・スタイルのパターンは、継承を記述することも図書館を説明する交差点の種類（例えばEmber.js）と便利です。</target>
        </trans-unit>
        <trans-unit id="22032c123849dac540221c1f0c198bc84d0e5030" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsconfig.json&lt;/code&gt; Schema can be found at &lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;the JSON Schema Store&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; スキーマで発見することができます&lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;JSON Schemaの店&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a29d4a5cece065318dd327e82552a8345a8bff7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useDefineForClassFields&lt;/code&gt; Flag and The &lt;code&gt;declare&lt;/code&gt; Property Modifier</source>
          <target state="translated">&lt;code&gt;useDefineForClassFields&lt;/code&gt; 旗と &lt;code&gt;declare&lt;/code&gt; プロパティ修飾子</target>
        </trans-unit>
        <trans-unit id="787315c92fdd75d5b219d459cc175e222f5c560e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Property Descriptor&lt;/em&gt; for the member.</source>
          <target state="translated">メンバーの&lt;em&gt;プロパティ記述子&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7230f5ad07f661a74fc222478036dbea6b5acfa1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;nullish coalescing operator&lt;/em&gt; is another upcoming ECMAScript feature that goes hand-in-hand with optional chaining, and which our team has been involved with championing in TC39.</source>
          <target state="translated">&lt;em&gt;演算子を合体nullishは&lt;/em&gt;、オプションのチェーンと手に手を行く他、今後のECMAScript機能であり、これは私たちのチームはTC39に擁護に携わってきました。</target>
        </trans-unit>
        <trans-unit id="ffd20aedc2df50b541f11314e29e7f1054d730a5" translate="yes" xml:space="preserve">
          <source>The Async Iteration introduces an &lt;code&gt;AsyncIterator&lt;/code&gt;, which is similar to &lt;code&gt;Iterator&lt;/code&gt;. The difference lies in the fact that the &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;throw&lt;/code&gt; methods of an &lt;code&gt;AsyncIterator&lt;/code&gt; return a &lt;code&gt;Promise&lt;/code&gt; for the iteration result, rather than the result itself. This allows the caller to enlist in an asynchronous notification for the time at which the &lt;code&gt;AsyncIterator&lt;/code&gt; has advanced to the point of yielding a value. An &lt;code&gt;AsyncIterator&lt;/code&gt; has the following shape:</source>
          <target state="translated">非同期反復が導入 &lt;code&gt;AsyncIterator&lt;/code&gt; に類似して、 &lt;code&gt;Iterator&lt;/code&gt; 。違いは、 &lt;code&gt;AsyncIterator&lt;/code&gt; の &lt;code&gt;next&lt;/code&gt; 、 &lt;code&gt;return&lt;/code&gt; 、および &lt;code&gt;throw&lt;/code&gt; メソッドが、結果自体ではなく反復結果の &lt;code&gt;Promise&lt;/code&gt; を返すという点にあります。これにより、呼び出し元は、 &lt;code&gt;AsyncIterator&lt;/code&gt; が値を生成するポイントまで進んだ時点で非同期通知に参加できます。アン &lt;code&gt;AsyncIterator&lt;/code&gt; は、次のような形状があります。</target>
        </trans-unit>
        <trans-unit id="a093f7952b1838c4dd6aeda28ea5e1fc38030960" translate="yes" xml:space="preserve">
          <source>The Basics</source>
          <target state="translated">基本的なこと</target>
        </trans-unit>
        <trans-unit id="264fd8a4a9ece4731967069d64f52539be927716" translate="yes" xml:space="preserve">
          <source>The Declaration Files section is broken down into the following sections.</source>
          <target state="translated">宣言ファイルのセクションは、以下のセクションに分かれています。</target>
        </trans-unit>
        <trans-unit id="8f7ab3e11b9b6277a216f46b871ce84ce2b9abe1" translate="yes" xml:space="preserve">
          <source>The Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File. We need to assume basic familiarity with the TypeScript language in order to get started.</source>
          <target state="translated">宣言ファイルのセクションでは、高品質なTypeScript宣言ファイルの書き方を学びます。始めるためには、TypeScript 言語の基本的な知識が必要です。</target>
        </trans-unit>
        <trans-unit id="21db3b675c232e8c920fc5cc57777d2bb7e6f2db" translate="yes" xml:space="preserve">
          <source>The Examples</source>
          <target state="translated">例</target>
        </trans-unit>
        <trans-unit id="6e513416df8e3dfac45e1c52226655ef81089278" translate="yes" xml:space="preserve">
          <source>The Handbook also isn&amp;rsquo;t intended to be a replacement for a language specification. In some cases, edge cases or formal descriptions of behavior will be skipped in favor of high-level, easier-to-understand explanations. Instead, there are separate reference pages that more precisely and formally describe many aspects of TypeScript&amp;rsquo;s behavior. The reference pages are not intended for readers unfamiliar with TypeScript, so they may use advanced terminology or reference topics you haven&amp;rsquo;t read about yet.</source>
          <target state="translated">このハンドブックは、言語仕様に代わるものでもありません。場合によっては、エッジケースや動作の正式な説明がスキップされ、高レベルで理解しやすい説明が優先されます。代わりに、TypeScriptの動作の多くの側面をより正確かつ正式に説明する個別のリファレンスページがあります。リファレンスページは、TypeScriptに慣れていない読者を対象としていないため、高度な用語や、まだ読んでいないリファレンストピックを使用している場合があります。</target>
        </trans-unit>
        <trans-unit id="7d8fc72f4ed0ac1173879adc908fcb0666497c3e" translate="yes" xml:space="preserve">
          <source>The Handbook is also intended to be a concise document that can be comfortably read in a few hours. Certain topics won&amp;rsquo;t be covered in order to keep things short.</source>
          <target state="translated">ハンドブックは、数時間で快適に読める簡潔なドキュメントになることも目的としています。物事を短くするために、特定のトピックはカバーされません。</target>
        </trans-unit>
        <trans-unit id="ae6a763c1fb39d689bcd8262575ee2c673da8154" translate="yes" xml:space="preserve">
          <source>The Impact of ES6 on Module Call Signatures</source>
          <target state="translated">ES6 のモジュールコールシグネチャへの影響</target>
        </trans-unit>
        <trans-unit id="4de6669622cba77a38976c0164e1dded39f35909" translate="yes" xml:space="preserve">
          <source>The Impact of ES6 on Module Plugins</source>
          <target state="translated">ES6のモジュールプラグインへの影響</target>
        </trans-unit>
        <trans-unit id="a90186b2913ce2a03f025ed1147a0c7a6b54234e" translate="yes" xml:space="preserve">
          <source>The Iterator protocol also defines the target of some of the ES2015 features like &lt;code&gt;for..of&lt;/code&gt; and spread operator and the array rest in destructuring assignmnets.</source>
          <target state="translated">Iteratorプロトコルは、 &lt;code&gt;for..of&lt;/code&gt; 、spread演算子などのES2015機能の一部のターゲットと、assignmnetの構造化における配列の残りも定義します。</target>
        </trans-unit>
        <trans-unit id="e2e893d7917d362f27f157a05f677c2dd16c5bb9" translate="yes" xml:space="preserve">
          <source>The JSX result type</source>
          <target state="translated">JSXの結果型</target>
        </trans-unit>
        <trans-unit id="2d7cc01d800025ab217a381f554be9b732cc9fcf" translate="yes" xml:space="preserve">
          <source>The JavaScript output is still the same.</source>
          <target state="translated">JavaScriptの出力はそのままです。</target>
        </trans-unit>
        <trans-unit id="318584735a5f4a0cd6e19d4529dc37491fd1acf3" translate="yes" xml:space="preserve">
          <source>The TSConfig is a jsonc file which configures both your compiler flags, and declare where to find files. In this case, you will want a file like the following:</source>
          <target state="translated">TSConfig は jsonc ファイルで、コンパイラのフラグを設定し、ファイルをどこで見つけるかを宣言します。この場合、以下のようなファイルが必要になります。</target>
        </trans-unit>
        <trans-unit id="7c164a656b844ad909a272419ed0cbe9548f88f5" translate="yes" xml:space="preserve">
          <source>The TypeScript Handbook</source>
          <target state="translated">TypeScriptハンドブック</target>
        </trans-unit>
        <trans-unit id="2b5f2e3eae34731098e1b7b55bd45c047f7f4695" translate="yes" xml:space="preserve">
          <source>The TypeScript Handbook is intended to be a comprehensive document that explains TypeScript to everyday programmers. You can read the handbook by going from top to bottom in the left-hand navigation.</source>
          <target state="translated">TypeScriptハンドブックは、日常的なプログラマーに向けてTypeScriptを解説した総合的なドキュメントを目指しています。ハンドブックは、左側のナビゲーションから上から下に向かって読むことができます。</target>
        </trans-unit>
        <trans-unit id="c3dc7b38b486965f74bd526d650143ae6a37e3aa" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler has a set of additional flags to &lt;em&gt;inform&lt;/em&gt; the compiler of transformations that are expected to happen to the sources to generate the final output.</source>
          <target state="translated">TypeScriptコンパイラーには、最終的な出力を生成するためにソースで発生することが予想される変換をコンパイラーに&lt;em&gt;通知&lt;/em&gt;する追加のフラグのセットがあります。</target>
        </trans-unit>
        <trans-unit id="bb370c8d075071406b52f5ac647fa7c9d121cf5a" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler supports the declaration of such mappings using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property in &lt;code&gt;tsconfig.json&lt;/code&gt; files.</source>
          <target state="translated">TypeScriptコンパイラは、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルの &lt;code&gt;&quot;paths&quot;&lt;/code&gt; プロパティを使用して、このようなマッピングの宣言をサポートしています。</target>
        </trans-unit>
        <trans-unit id="099c380e43d8e6d4992539e165d15f16ea81d572" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler supports the declaration of such mappings using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property in &lt;code&gt;tsconfig.json&lt;/code&gt; files. Here is an example for how to specify the &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property for &lt;code&gt;jquery&lt;/code&gt;.</source>
          <target state="translated">TypeScriptコンパイラは、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルの &lt;code&gt;&quot;paths&quot;&lt;/code&gt; プロパティを使用して、このようなマッピングの宣言をサポートしています。 &lt;code&gt;jquery&lt;/code&gt; の &lt;code&gt;&quot;paths&quot;&lt;/code&gt; プロパティを指定する方法の例を次に示します。</target>
        </trans-unit>
        <trans-unit id="bdf835f0a2221bc2f82e0e151055988a09c9c5cd" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler will inject design-time type information using the &lt;code&gt;@Reflect.metadata&lt;/code&gt; decorator. You could consider it the equivalent of the following TypeScript:</source>
          <target state="translated">TypeScriptコンパイラーは、 &lt;code&gt;@Reflect.metadata&lt;/code&gt; デコレーターを使用して設計時の型情報を挿入します。次のTypeScriptと同等と考えることができます。</target>
        </trans-unit>
        <trans-unit id="7a2537884fb59ac700d2d4b7e0b4045bf44ae0d3" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler will transpile for..of arrays to idiomatic ES3/ES5 JavaScript when targeting those versions:</source>
          <target state="translated">TypeScript コンパイラは、これらのバージョンをターゲットにした場合、配列の for...of 配列をイディオマティックな ES3/ES5 JavaScript にトランスパイルします。</target>
        </trans-unit>
        <trans-unit id="7c695dd66f4a120dfae2df4de90b84e627a92bcc" translate="yes" xml:space="preserve">
          <source>The TypeScript playground can show you the &lt;code&gt;.d.ts&lt;/code&gt; equivalent for JavaScript code. You can &lt;a href=&quot;https://www.typescriptlang.org/play?useJavaScript=true#code/GYVwdgxgLglg9mABAcwKZQIICcsEMCeAMqmMlABYAUuOAlIgN6IBQiiW6IWSNWAdABsSZcswC+zCAgDOURAFtcADwAq5GKUQBeRAEYATM2by4AExBC+qJQAc4WKNO2NWKdNjxFhFADSvFquqk4sxAA&quot;&gt;try it yourself here&lt;/a&gt;.</source>
          <target state="translated">TypeScriptプレイグラウンドでは、JavaScriptコードに相当する &lt;code&gt;.d.ts&lt;/code&gt; を表示できます。&lt;a href=&quot;https://www.typescriptlang.org/play?useJavaScript=true#code/GYVwdgxgLglg9mABAcwKZQIICcsEMCeAMqmMlABYAUuOAlIgN6IBQiiW6IWSNWAdABsSZcswC+zCAgDOURAFtcADwAq5GKUQBeRAEYATM2by4AExBC+qJQAc4WKNO2NWKdNjxFhFADSvFquqk4sxAA&quot;&gt;ここで自分で試すこと&lt;/a&gt;ができます。</target>
        </trans-unit>
        <trans-unit id="49b307cc503023513bc14bb0a27ac57aa8f44ce9" translate="yes" xml:space="preserve">
          <source>The TypeScript playground has received a much-needed refresh with handy new functionality! The new playground is largely a fork of &lt;a href=&quot;https://github.com/agentcooper&quot;&gt;Artem Tyurin&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;https://github.com/agentcooper/typescript-play&quot;&gt;TypeScript playground&lt;/a&gt; which community members have been using more and more. We owe Artem a big thanks for helping out here!</source>
          <target state="translated">TypeScriptプレイグラウンドは、便利な新機能を備えた待望の更新を受けました。新しい遊び場は、主に&lt;a href=&quot;https://github.com/agentcooper&quot;&gt;Artem Tyurin&lt;/a&gt;の&lt;a href=&quot;https://github.com/agentcooper/typescript-play&quot;&gt;TypeScript遊び場&lt;/a&gt;のフォークであり、コミュニティメンバーはますます使用しています。Artemはここで助けてくれて本当に感謝しています！</target>
        </trans-unit>
        <trans-unit id="2d3804fe18093dd09b93d92b9795e81df41c7624" translate="yes" xml:space="preserve">
          <source>The TypeSript compiler emits a few helpers like &lt;code&gt;__extends&lt;/code&gt; when needed. The helpers are emitted in every file they are referenced in. If you want to consolidate all helpers in one place, or override the default behavior, use &lt;code&gt;--noEmitHelpers&lt;/code&gt; to instructs the compiler not to emit them.</source>
          <target state="translated">TypeSriptコンパイラは、必要に応じて &lt;code&gt;__extends&lt;/code&gt; などのいくつかのヘルパーを発行します。ヘルパーは、参照されるすべてのファイルで出力されます。すべてのヘルパーを1か所に統合​​するか、デフォルトの動作をオーバーライドする場合は、 &lt;code&gt;--noEmitHelpers&lt;/code&gt; を使用して、コンパイラーに出力しないように指示します。</target>
        </trans-unit>
        <trans-unit id="bae3a8ac10b29ef5dcadb732d1773d84824f8b64" translate="yes" xml:space="preserve">
          <source>The above code will result in an error since you cannot divide a string by a number. The output, when using the &lt;code&gt;preserve&lt;/code&gt; option, looks like:</source>
          <target state="translated">上記のコードでは、文字列を数値で除算できないため、エラーが発生します。 &lt;code&gt;preserve&lt;/code&gt; オプションを使用すると、出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="973342201d3a8b874193050ad2e2e03771fa9182" translate="yes" xml:space="preserve">
          <source>The above workaround will work as long as you have a common property between &lt;code&gt;squareOptions&lt;/code&gt; and &lt;code&gt;SquareConfig&lt;/code&gt;. In this example, it was the property &lt;code&gt;width&lt;/code&gt;. It will however, fail if the variable does not have any common object property. For example:</source>
          <target state="translated">上記の回避策は、 &lt;code&gt;squareOptions&lt;/code&gt; と &lt;code&gt;SquareConfig&lt;/code&gt; の間に共通のプロパティがある限り機能します。この例では、プロパティの &lt;code&gt;width&lt;/code&gt; でした。ただし、変数に共通のオブジェクトプロパティがない場合は失敗します。例えば：</target>
        </trans-unit>
        <trans-unit id="977799dc5b2c7efb8ce07ce9dda596f71ce6d8c4" translate="yes" xml:space="preserve">
          <source>The act of introducing a new name in a more nested scope is called &lt;em&gt;shadowing&lt;/em&gt;. It is a bit of a double-edged sword in that it can introduce certain bugs on its own in the event of accidental shadowing, while also preventing certain bugs. For instance, imagine we had written our earlier &lt;code&gt;sumMatrix&lt;/code&gt; function using &lt;code&gt;let&lt;/code&gt; variables.</source>
          <target state="translated">よりネストされたスコープに新しい名前を導入することは、&lt;em&gt;シャドウイング&lt;/em&gt;と呼ばれます。偶発的なシャドウイングが発生した場合に特定のバグを単独で発生させ、特定のバグを防止できるという点で、両刃の剣のようです。たとえば、 &lt;code&gt;let&lt;/code&gt; 変数を使用して以前の &lt;code&gt;sumMatrix&lt;/code&gt; 関数を記述したとします。</target>
        </trans-unit>
        <trans-unit id="464744a1885e10900c594d16946298c68c765f22" translate="yes" xml:space="preserve">
          <source>The advantage of optional properties is that you can describe these possibly available properties while still also preventing use of properties that are not part of the interface. For example, had we mistyped the name of the &lt;code&gt;color&lt;/code&gt; property in &lt;code&gt;createSquare&lt;/code&gt;, we would get an error message letting us know:</source>
          <target state="translated">オプションのプロパティの利点は、これらの可能性のあるプロパティを記述できると同時に、インターフェイスの一部ではないプロパティの使用を防止できることです。たとえば、 &lt;code&gt;createSquare&lt;/code&gt; で &lt;code&gt;color&lt;/code&gt; プロパティの名前を誤って入力すると、次のエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="d900af77a95ccc3991b5cce004f6567adc959fc3" translate="yes" xml:space="preserve">
          <source>The alternative was to instead rewrite the code so that the language could analyze it, but this isn&amp;rsquo;t convenient.</source>
          <target state="translated">代わりに、言語がコードを分析できるようにコードを書き直すこともできましたが、これは便利ではありません。</target>
        </trans-unit>
        <trans-unit id="99e538489907af6acf36979924fc373420776d09" translate="yes" xml:space="preserve">
          <source>The answer is that you can&amp;rsquo;t learn TypeScript without learning JavaScript! TypeScript shares syntax and runtime behavior with JavaScript, so anything you learn about JavaScript is helping you learn TypeScript at the same time.</source>
          <target state="translated">答えは、JavaScriptを学ばなければTypeScriptを学ぶことはできないということです！TypeScriptは構文と実行時の動作をJavaScriptと共有しているため、JavaScriptについて学んだことはすべて、TypeScriptを同時に学ぶのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="d7545e67ed0bf67fd6d8743f1b478c94a21cbf7b" translate="yes" xml:space="preserve">
          <source>The answer is to supply multiple function types for the same function as a list of overloads. This list is what the compiler will use to resolve function calls. Let&amp;rsquo;s create a list of overloads that describe what our &lt;code&gt;pickCard&lt;/code&gt; accepts and what it returns.</source>
          <target state="translated">答えは、オーバーロードのリストと同じ関数に複数の関数タイプを提供することです。このリストは、コンパイラが関数呼び出しを解決するために使用するものです。 &lt;code&gt;pickCard&lt;/code&gt; が受け入れるものと返すものを記述するオーバーロードのリストを作成してみましょう。</target>
        </trans-unit>
        <trans-unit id="d87ac95450f1e8dcfc394fcd59a9e3ae182cfb79" translate="yes" xml:space="preserve">
          <source>The argument can be a file path to a valid JSON configuration file, or a directory path to a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">引数には、有効なJSON構成ファイルへのファイルパス、または &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを含むディレクトリへのディレクトリパスを指定できます。</target>
        </trans-unit>
        <trans-unit id="8f45e116d7cf081dd6a210ca6310037f2aa66724" translate="yes" xml:space="preserve">
          <source>The as operator</source>
          <target state="translated">としての演算子</target>
        </trans-unit>
        <trans-unit id="9c9fa406955dab922d6a11f631e81ab8facc3e92" translate="yes" xml:space="preserve">
          <source>The basic rule for TypeScript&amp;rsquo;s structural type system is that &lt;code&gt;x&lt;/code&gt; is compatible with &lt;code&gt;y&lt;/code&gt; if &lt;code&gt;y&lt;/code&gt; has at least the same members as &lt;code&gt;x&lt;/code&gt;. For example:</source>
          <target state="translated">TypeScriptの構造型システムの基本的な規則は、 &lt;code&gt;y&lt;/code&gt; が少なくとも &lt;code&gt;x&lt;/code&gt; と同じメンバーを持っている場合、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;y&lt;/code&gt; と互換性があるということです。例えば：</target>
        </trans-unit>
        <trans-unit id="c55521452311c3ac39fa2cd2823a7857ecfdacde" translate="yes" xml:space="preserve">
          <source>The best part about the &lt;em&gt;lib.dom.d.ts&lt;/em&gt; type definitions is that they are reflective of the types annotated in the Mozilla Developer Network (MDN) documentation site. For example, the &lt;code&gt;HTMLElement&lt;/code&gt; interface is documented by this &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/HTMLElement&quot;&gt;HTMLElement page&lt;/a&gt; on MDN. These pages list all available properties, methods, and sometimes even examples. Another great aspect of the pages is that they provide links to the corresponding standard documents. Here is the link to the &lt;a href=&quot;https://www.w3.org/TR/html52/dom.html#htmlelement&quot;&gt;W3C Recommendation for HTMLElement&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;lib.dom.d.ts&lt;/em&gt;型定義の最も優れている点は、Mozilla Developer Network（MDN）ドキュメントサイトで注釈が付けられている型を反映していることです。たとえば、 &lt;code&gt;HTMLElement&lt;/code&gt; インターフェイスは、MDNのこの&lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/HTMLElement&quot;&gt;HTMLElementページ&lt;/a&gt;で文書化されています。これらのページには、使用可能なすべてのプロパティ、メソッド、場合によっては例がリストされています。ページのもう1つの優れた点は、対応する標準ドキュメントへのリンクを提供することです。&lt;a href=&quot;https://www.w3.org/TR/html52/dom.html#htmlelement&quot;&gt;HTMLElement&lt;/a&gt;のW3C勧告へのリンクは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="0570ba37489d38960ce7e63c3dda6e93bf075660" translate="yes" xml:space="preserve">
          <source>The caveat is that string-initialized enums can&amp;rsquo;t be reverse-mapped to get the original enum member name. In other words, you can&amp;rsquo;t write &lt;code&gt;Colors[&quot;RED&quot;]&lt;/code&gt; to get the string &lt;code&gt;&quot;Red&quot;&lt;/code&gt;.</source>
          <target state="translated">注意点は、文字列で初期化された列挙型を逆マッピングして、元の列挙型メンバー名を取得することはできないということです。つまり、 &lt;code&gt;Colors[&quot;RED&quot;]&lt;/code&gt; を記述して文字列 &lt;code&gt;&quot;Red&quot;&lt;/code&gt; を取得することはできません。</target>
        </trans-unit>
        <trans-unit id="658cc1f5d6e87940c9b68d75f7a3216b7965fa8f" translate="yes" xml:space="preserve">
          <source>The character set of the input files.</source>
          <target state="translated">入力ファイルの文字セット。</target>
        </trans-unit>
        <trans-unit id="0d767851eecc9dbc5567854c546874153b473aac" translate="yes" xml:space="preserve">
          <source>The classification can be further customized by changing the font and color settings for the &lt;code&gt;VB XML&lt;/code&gt; color and font settings through &lt;code&gt;Tools&lt;/code&gt;-&amp;gt;&lt;code&gt;Options&lt;/code&gt;-&amp;gt;&lt;code&gt;Environment&lt;/code&gt;-&amp;gt;&lt;code&gt;Fonts and Colors&lt;/code&gt; page.</source>
          <target state="translated">&lt;code&gt;VB XML&lt;/code&gt; の色とフォント設定のフォントと色の設定を[ &lt;code&gt;Tools&lt;/code&gt; -&amp;gt; [ &lt;code&gt;Options&lt;/code&gt; -&amp;gt; [ &lt;code&gt;Environment&lt;/code&gt; -&amp;gt; [ &lt;code&gt;Fonts and Colors&lt;/code&gt; ページで変更することにより、分類をさらにカスタマイズできます。</target>
        </trans-unit>
        <trans-unit id="1a2f1531f75511fb5bed9929c49deede45519a7c" translate="yes" xml:space="preserve">
          <source>The closest equivalent to &lt;code&gt;data&lt;/code&gt; is a union of types with discriminant properties, normally called discriminated unions in TypeScript:</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 最も近いものは、判別プロパティを持つ型の共用体であり、通常、TypeScriptでは判別式共用体と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="75bd7d1cbccc678687cdc4d4130a670d13f976d9" translate="yes" xml:space="preserve">
          <source>The closest equivalent to &lt;code&gt;newtype&lt;/code&gt; is a &lt;em&gt;tagged intersection&lt;/em&gt;:</source>
          <target state="translated">&lt;code&gt;newtype&lt;/code&gt; に最も近いものは、&lt;em&gt;タグ付き交差点&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="9e4361985e949137fdbecccf199cbcbfd26cb095" translate="yes" xml:space="preserve">
          <source>The code sample starts with the two classes that will act as our mixins. You can see each one is focused on a particular activity or capability. We&amp;rsquo;ll later mix these together to form a new class from both capabilities.</source>
          <target state="translated">コードサンプルは、ミックスインとして機能する2つのクラスから始まります。それぞれが特定のアクティビティまたは機能に焦点を当てていることがわかります。これらを後で混合して、両方の機能から新しいクラスを形成します。</target>
        </trans-unit>
        <trans-unit id="44bfd585b7b25dece832164d759523816acacef3" translate="yes" xml:space="preserve">
          <source>The comment pragma version may be used like so (in TypeScript 2.8):</source>
          <target state="translated">コメントプラグマのバージョンは、このように使うことができます (TypeScript 2.8では)。</target>
        </trans-unit>
        <trans-unit id="94d8762ed85cb39d474ef4b32596ce47c7f9f61a" translate="yes" xml:space="preserve">
          <source>The compiler can usually figure out the type of &lt;code&gt;this&lt;/code&gt; when it has some context to work with. When it doesn&amp;rsquo;t, you can explicitly specify the type of &lt;code&gt;this&lt;/code&gt; with &lt;code&gt;@this&lt;/code&gt;:</source>
          <target state="translated">コンパイラーは通常、処理するコンテキストがある場合、 &lt;code&gt;this&lt;/code&gt; タイプを判別できます。そうでない場合は、 &lt;code&gt;this&lt;/code&gt; のタイプを &lt;code&gt;@this&lt;/code&gt; で明示的に指定できます。</target>
        </trans-unit>
        <trans-unit id="6ce225c2cdfc4fbbd52bf1bec496704ad8d2e300" translate="yes" xml:space="preserve">
          <source>The compiler checks that &lt;code&gt;manufacturer&lt;/code&gt; and &lt;code&gt;model&lt;/code&gt; are actually properties on &lt;code&gt;Car&lt;/code&gt;. The example introduces a couple of new type operators. First is &lt;code&gt;keyof T&lt;/code&gt;, the &lt;strong&gt;index type query operator&lt;/strong&gt;. For any type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;keyof T&lt;/code&gt; is the union of known, public property names of &lt;code&gt;T&lt;/code&gt;. For example:</source>
          <target state="translated">コンパイラは、 &lt;code&gt;manufacturer&lt;/code&gt; と &lt;code&gt;model&lt;/code&gt; が実際に &lt;code&gt;Car&lt;/code&gt; のプロパティであることを確認します。この例では、いくつかの新しい型演算子を紹介しています。最初は、&lt;strong&gt;インデックスタイプのクエリ演算子&lt;/strong&gt;である &lt;code&gt;keyof T&lt;/code&gt; です。いずれのタイプの場合は &lt;code&gt;T&lt;/code&gt; 、 &lt;code&gt;keyof T&lt;/code&gt; は、既知の、パブリックプロパティ名の労働組合である &lt;code&gt;T&lt;/code&gt; 。例えば：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b90080efac3089f68bf9198051529fb93927ad2d" translate="yes" xml:space="preserve">
          <source>The compiler checks that variables are definitely assigned by performing &lt;em&gt;control flow based type analysis&lt;/em&gt;. See later for further details on this topic.</source>
          <target state="translated">コンパイラーは、&lt;em&gt;制御フローベースの型分析を&lt;/em&gt;実行することにより、変数が確実に割り当てられていることを確認します。このトピックの詳細については、後で参照してください。</target>
        </trans-unit>
        <trans-unit id="709255e2bfcdfd8723f3b039260e513f6811cfd9" translate="yes" xml:space="preserve">
          <source>The compiler detects whether each module is used in the emitted JavaScript. If a module identifier is only ever used as part of a type annotations and never as an expression, then no &lt;code&gt;require&lt;/code&gt; call is emitted for that module. This elision of unused references is a good performance optimization, and also allows for optional loading of those modules.</source>
          <target state="translated">コンパイラは、発行されたJavaScriptで各モジュールが使用されているかどうかを検出します。モジュール識別子が型注釈の一部としてのみ使用され、式として決して使用されない &lt;code&gt;require&lt;/code&gt; 、そのモジュールのrequire呼び出しは発行されません。この未使用の参照の省略は、優れたパフォーマンスの最適化であり、これらのモジュールのオプションのロードも可能にします。</target>
        </trans-unit>
        <trans-unit id="2ee05054ac8f1f0d957bb3db6c7d04411ad1e817" translate="yes" xml:space="preserve">
          <source>The compiler infers constructor functions based on this-property assignments, but you can make checking stricter and suggestions better if you add a &lt;code&gt;@constructor&lt;/code&gt; tag:</source>
          <target state="translated">コンパイラーは、このプロパティの割り当てに基づいてコンストラクター関数を推測しますが、 &lt;code&gt;@constructor&lt;/code&gt; タグを追加すると、チェックをより厳密にして提案をより良くすることができます。</target>
        </trans-unit>
        <trans-unit id="af8cada3d73e6f631af13e152a9d5e9310d04109" translate="yes" xml:space="preserve">
          <source>The compiler performs a preprocessing pass on input files to resolve all triple-slash reference directives. During this process, additional files are added to the compilation.</source>
          <target state="translated">コンパイラは入力ファイルの前処理パスを実行して、すべてのトリプルスラッシュ参照ディレクティブを解決します。この処理の間に、追加のファイルがコンパイルに追加されます。</target>
        </trans-unit>
        <trans-unit id="e0152e415fb0baecefa82a34c08f802b9d756e5b" translate="yes" xml:space="preserve">
          <source>The compiler will automatically order the output file based on the reference tags present in the files. You can also specify each file individually:</source>
          <target state="translated">コンパイラは、ファイル内に存在する参照タグに基づいて出力ファイルを自動的に並べ替えます。また、各ファイルを個別に指定することもできます。</target>
        </trans-unit>
        <trans-unit id="51e223694a5a5e5b0c431a15c4a8fae647f211ab" translate="yes" xml:space="preserve">
          <source>The compiler will generate a simple &lt;code&gt;for&lt;/code&gt; loop for a &lt;code&gt;for..of&lt;/code&gt; loop, for instance:</source>
          <target state="translated">コンパイラーは、たとえば、 &lt;code&gt;for..of&lt;/code&gt; ループの単純な &lt;code&gt;for&lt;/code&gt; ループを生成します。</target>
        </trans-unit>
        <trans-unit id="6a0d000ecdfc1359aa72dab512a544de23b44f6d" translate="yes" xml:space="preserve">
          <source>The compiler will now resolve &lt;code&gt;import messages from './#{locale}/messages'&lt;/code&gt; to &lt;code&gt;import messages from './zh/messages'&lt;/code&gt; for tooling purposes, allowing development in a locale agnostic manner without compromising design time support.</source>
          <target state="translated">コンパイラーは、ツール目的で &lt;code&gt;import messages from './#{locale}/messages'&lt;/code&gt; 解決して './zh/messages'から &lt;code&gt;import messages from './zh/messages'&lt;/code&gt; をインポートし、設計時サポートを損なうことなくロケールにとらわれない方法で開発できるようにします。</target>
        </trans-unit>
        <trans-unit id="dededb8a14ae234f8b00237dd4d7d5520b09190d" translate="yes" xml:space="preserve">
          <source>The compiler will try to find a &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and then a &lt;code&gt;.d.ts&lt;/code&gt; with the appropriate path. If a specific file could not be found, then the compiler will look for an &lt;em&gt;ambient module declaration&lt;/em&gt;. Recall that these need to be declared in a &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="translated">コンパイラは見つけようとします &lt;code&gt;.ts&lt;/code&gt; 、 &lt;code&gt;.tsx&lt;/code&gt; 、その後、 &lt;code&gt;.d.ts&lt;/code&gt; の適切なパスを指定しています。特定のファイルが見つからなかった場合、コンパイラは&lt;em&gt;アンビエントモジュール宣言&lt;/em&gt;を探し&lt;em&gt;ます&lt;/em&gt;。これらは &lt;code&gt;.d.ts&lt;/code&gt; ファイルで宣言する必要があることを思い出してください。</target>
        </trans-unit>
        <trans-unit id="0ba06dc9850414ee8093ec4891b1423ed7c4b5a5" translate="yes" xml:space="preserve">
          <source>The configuration from the base file are loaded first, then overridden by those in the inheriting config file.</source>
          <target state="translated">ベースファイルの設定が最初に読み込まれ、次に継承する設定ファイルの設定が上書きされます。</target>
        </trans-unit>
        <trans-unit id="c6ca65192f8fe43f587bc1a3d765c8a0613852b7" translate="yes" xml:space="preserve">
          <source>The configuration from the base file are loaded first, then overridden by those in the inheriting config file. All relative paths found in the configuration file will be resolved relative to the configuration file they originated in.</source>
          <target state="translated">ベースファイルの設定が最初に読み込まれ、その後、継承された設定ファイルの設定が上書きされます。設定ファイルで見つかったすべての相対パスは、それらが元になった設定ファイルからの相対パスとして解決されます。</target>
        </trans-unit>
        <trans-unit id="c7417a4c25a8da7c3b9339e33fd087465dbdf022" translate="yes" xml:space="preserve">
          <source>The configuration from the base file are loaded first, then overridden by those in the inheriting config file. If a circularity is encountered, we report an error.</source>
          <target state="translated">ベースファイルの設定が最初に読み込まれ、次に継承する設定ファイルの設定が上書きされます。サーキュラリティが発生した場合はエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="47cd6d852a954030c68d9ed9204072b9f5e61ecf" translate="yes" xml:space="preserve">
          <source>The constructor of a mixin class (if any) must have a single rest parameter of type &lt;code&gt;any[]&lt;/code&gt; and must use the spread operator to pass those parameters as arguments in a &lt;code&gt;super(...args)&lt;/code&gt; call.</source>
          <target state="translated">ミックスインクラスのコンストラクタ（存在する場合）には、タイプ &lt;code&gt;any[]&lt;/code&gt; 単一のレストパラメータが必要であり、spread &lt;code&gt;super(...args)&lt;/code&gt; 呼び出しの引数としてこれらのパラメータを渡すには、スプレッド演算子を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="c957312c57684bb0a68bd0033e5121474de252b4" translate="yes" xml:space="preserve">
          <source>The core idea of the pattern is that the &lt;code&gt;import id = require(&quot;...&quot;)&lt;/code&gt; statement gives us access to the types exposed by the module. The module loader is invoked (through &lt;code&gt;require&lt;/code&gt;) dynamically, as shown in the &lt;code&gt;if&lt;/code&gt; blocks below. This leverages the reference-elision optimization so that the module is only loaded when needed. For this pattern to work, it&amp;rsquo;s important that the symbol defined via an &lt;code&gt;import&lt;/code&gt; is only used in type positions (i.e. never in a position that would be emitted into the JavaScript).</source>
          <target state="translated">パターンの核となる考え方は、 &lt;code&gt;import id = require(&quot;...&quot;)&lt;/code&gt; ステートメントにより、モジュールによって公開される型へのアクセスが提供されるということです。以下の &lt;code&gt;if&lt;/code&gt; ブロックに示すように、モジュールローダーは（ &lt;code&gt;require&lt;/code&gt; を介して）動的に呼び出されます。これは、参照省略最適化を利用して、モジュールが必要なときにのみロードされるようにします。このパターンが機能するためには、 &lt;code&gt;import&lt;/code&gt; を介して定義されたシンボルがタイプの位置でのみ使用されることが重要です（つまり、JavaScriptに放出される位置では決して使用されません）。</target>
        </trans-unit>
        <trans-unit id="d0b027c450a1f923c0be026c0dfd8a83c77d2420" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;code&gt;tsconfig.json&lt;/code&gt; would look like:</source>
          <target state="translated">対応する &lt;code&gt;tsconfig.json&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="7eeeab936d5101dbe33556330a8a2f0e148d5a0c" translate="yes" xml:space="preserve">
          <source>The declaration merge of &lt;code&gt;Animals&lt;/code&gt; in this example:</source>
          <target state="translated">この例の &lt;code&gt;Animals&lt;/code&gt; の宣言のマージ：</target>
        </trans-unit>
        <trans-unit id="70be9c837970cfde212fa7a4b8b2cbb0b2ae3596" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;const enum&lt;/code&gt; behavior is to convert any &lt;code&gt;Album.Something&lt;/code&gt; to the corresponding number literal, and to remove a reference to the enum from the JavaScript completely.</source>
          <target state="translated">デフォルトの &lt;code&gt;const enum&lt;/code&gt; 動作は、 &lt;code&gt;Album.Something&lt;/code&gt; を対応する数値リテラルに変換し、JavaScriptから列挙型への参照を完全に削除することです。</target>
        </trans-unit>
        <trans-unit id="760e4e7cc5e42234f3bffea21b8ceac9a6ae4124" translate="yes" xml:space="preserve">
          <source>The default behavior for the TypeScript compiler is to still emit .js files if there were type errors (for example, an attempt to assign a &lt;code&gt;string&lt;/code&gt; to a &lt;code&gt;number&lt;/code&gt;). This can be undesirable on build servers or other scenarios where only output from a &amp;ldquo;clean&amp;rdquo; build is desired. The new flag &lt;code&gt;noEmitOnError&lt;/code&gt; prevents the compiler from emitting .js code if there were any errors.</source>
          <target state="translated">TypeScriptコンパイラのデフォルトの動作では、タイプエラー（たとえば、 &lt;code&gt;string&lt;/code&gt; を &lt;code&gt;number&lt;/code&gt; に割り当てようとしたなど）があった場合でも.jsファイルが出力されます。これは、ビルドサーバーまたは「クリーン」ビルドからの出力のみが必要なその他のシナリオでは望ましくない場合があります。新しいフラグ &lt;code&gt;noEmitOnError&lt;/code&gt; は、エラーが発生した場合にコンパイラーが.jsコードを発行しないようにします。</target>
        </trans-unit>
        <trans-unit id="ae976d467a2e0b5f5be1f916e987a9fd2c7d4327" translate="yes" xml:space="preserve">
          <source>The default-ed properties are inferred from the &lt;code&gt;defaultProps&lt;/code&gt; property type. If an explicit type annotation is added, e.g. &lt;code&gt;static defaultProps: Partial&amp;lt;Props&amp;gt;;&lt;/code&gt; the compiler will not be able to identify which properties have defaults (since the type of &lt;code&gt;defaultProps&lt;/code&gt; include all properties of &lt;code&gt;Props&lt;/code&gt;).</source>
          <target state="translated">default-edプロパティは、 &lt;code&gt;defaultProps&lt;/code&gt; プロパティタイプから推測されます。明示的な型注釈が追加された場合、たとえば &lt;code&gt;static defaultProps: Partial&amp;lt;Props&amp;gt;;&lt;/code&gt; コンパイラーは、デフォルトを持つプロパティを識別できません（ &lt;code&gt;defaultProps&lt;/code&gt; のタイプには &lt;code&gt;Props&lt;/code&gt; のすべてのプロパティが含まれるため）。</target>
        </trans-unit>
        <trans-unit id="d1317688dfc3d42fd33a72fadf087e54e0802397" translate="yes" xml:space="preserve">
          <source>The definite assignment assertion is a feature that allows a &lt;code&gt;!&lt;/code&gt; to be placed after instance property and variable declarations to relay to TypeScript that a variable is indeed assigned for all intents and purposes, even if TypeScript&amp;rsquo;s analyses cannot detect so.</source>
          <target state="translated">明確な割り当てアサーションは、 &lt;code&gt;!&lt;/code&gt; TypeScriptの分析で検出できない場合でも、変数が実際にすべての意図と目的に割り当てられていることをTypeScriptにリレーするために、インスタンスプロパティと変数の宣言の後に配置します。</target>
        </trans-unit>
        <trans-unit id="2f7101961a50144f9479602939dcc578c0e8ab45" translate="yes" xml:space="preserve">
          <source>The definition for &amp;ldquo;super-greeter&amp;rdquo;:</source>
          <target state="translated">「スーパーグリーター」の定義：</target>
        </trans-unit>
        <trans-unit id="c352ae274c34e758530bef83a57917473d389588" translate="yes" xml:space="preserve">
          <source>The definition for this method is (I have omitted the &lt;em&gt;deprecated&lt;/em&gt; definition):</source>
          <target state="translated">このメソッドの定義は次のとおりです（&lt;em&gt;非推奨の&lt;/em&gt;定義は省略しました）。</target>
        </trans-unit>
        <trans-unit id="259a9b27dc71c892950403f889ab6e29b1d0b36a" translate="yes" xml:space="preserve">
          <source>The definition for this method is as follows:</source>
          <target state="translated">この方法の定義は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="5951769f90ddf6ef86202b76f38e00c40c68074c" translate="yes" xml:space="preserve">
          <source>The distributive property of conditional types can conveniently be used to &lt;em&gt;filter&lt;/em&gt; union types:</source>
          <target state="translated">条件付きタイプの分布プロパティは、共用体タイプを&lt;em&gt;フィルタリング&lt;/em&gt;するために便利に使用できます。</target>
        </trans-unit>
        <trans-unit id="6d56b3f7891cbe61db5bb0920e006dd158d21b55" translate="yes" xml:space="preserve">
          <source>The downside to using babel is that you don&amp;rsquo;t get type checking during the transition from TS to JS. This can mean that type errors which you miss in your editor could sneak through into production code.</source>
          <target state="translated">babelを使用することの欠点は、TSからJSへの移行中に型チェックが行われないことです。これは、エディターで見逃したタイプエラーが本番コードに侵入する可能性があることを意味します。</target>
        </trans-unit>
        <trans-unit id="6701107cdd8245fa22b60649bbf93c094765f72c" translate="yes" xml:space="preserve">
          <source>The dual of this is &lt;em&gt;indexed access types&lt;/em&gt;, also called &lt;em&gt;lookup types&lt;/em&gt;. Syntactically, they look exactly like an element access, but are written as types:</source>
          <target state="translated">この2つは、&lt;em&gt;インデックス付きアクセスタイプ&lt;/em&gt;であり、&lt;em&gt;ルックアップタイプ&lt;/em&gt;とも呼ばれ&lt;em&gt;ます&lt;/em&gt;。構文的には、要素へのアクセスとまったく同じように見えますが、型として記述されています。</target>
        </trans-unit>
        <trans-unit id="f96a7965741a28dd3d210266390299a4c235d519" translate="yes" xml:space="preserve">
          <source>The easiest way to remember whether to use &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; is to ask whether you&amp;rsquo;re using it on a variable or a property. Variables use &lt;code&gt;const&lt;/code&gt; whereas properties use &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; と &lt;code&gt;const&lt;/code&gt; のどちらを使用するかを覚える最も簡単な方法は、変数またはプロパティのどちらで使用するかを尋ねることです。変数は &lt;code&gt;const&lt;/code&gt; を使用し、プロパティは &lt;code&gt;readonly&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="77d40241cfaf8a84ae6745611b0a0b930c4e9b68" translate="yes" xml:space="preserve">
          <source>The easiest way to see how interfaces work is to start with a simple example:</source>
          <target state="translated">インターフェイスがどのように動作するかを理解する最も簡単な方法は、簡単な例から始めることです。</target>
        </trans-unit>
        <trans-unit id="36fb664df37642968e73b47232d19c28eafce856" translate="yes" xml:space="preserve">
          <source>The element attribute type is used to type check the attributes in the JSX. Optional and required properties are supported.</source>
          <target state="translated">要素属性型は、JSXの属性をタイプチェックするために使用されます。オプションのプロパティと必須のプロパティがサポートされています。</target>
        </trans-unit>
        <trans-unit id="f2cb300f34919973f86bda71fcf4a1681bebb7a8" translate="yes" xml:space="preserve">
          <source>The element instance type is interesting because it must be assignable to &lt;code&gt;JSX.ElementClass&lt;/code&gt; or it will result in an error. By default &lt;code&gt;JSX.ElementClass&lt;/code&gt; is &lt;code&gt;{}&lt;/code&gt;, but it can be augmented to limit the use of JSX to only those types that conform to the proper interface.</source>
          <target state="translated">要素インスタンスタイプは、 &lt;code&gt;JSX.ElementClass&lt;/code&gt; に割り当て可能でなければならないため、興味深いものになります。そうしないと、エラーが発生します。デフォルトでは、 &lt;code&gt;JSX.ElementClass&lt;/code&gt; は &lt;code&gt;{}&lt;/code&gt; ですが、JSXの使用を適切なインターフェースに準拠するタイプのみに制限するように拡張できます。</target>
        </trans-unit>
        <trans-unit id="0d4e3187b0c64f392d45e58c9337389c5cb0b1e1" translate="yes" xml:space="preserve">
          <source>The ellipsis is also used in the type of the function with rest parameters:</source>
          <target state="translated">楕円は、残りのパラメータを持つ関数の型でも使用されています。</target>
        </trans-unit>
        <trans-unit id="4206f608291d0b44e696abdeb0d5bfe75f33351e" translate="yes" xml:space="preserve">
          <source>The emitted JavaScript from TypeScript is:</source>
          <target state="translated">TypeScriptから排出されるJavaScriptは</target>
        </trans-unit>
        <trans-unit id="d715b5fd0797da50802172129520b9973d9f2c77" translate="yes" xml:space="preserve">
          <source>The enum member is initialized with a constant enum expression. A constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time. An expression is a constant enum expression if it is:</source>
          <target state="translated">enum メンバは定数 enum 式で初期化されます。constant enum式は、コンパイル時に完全に評価できるTypeScript式のサブセットです。式は、以下の場合には定数enum式となります。</target>
        </trans-unit>
        <trans-unit id="d313bf4ae6661330b1b3ab28e64f56b35e82367c" translate="yes" xml:space="preserve">
          <source>The exact factory function used by the &lt;code&gt;jsx: react&lt;/code&gt; compiler option is configurable. It may be set using either the &lt;code&gt;jsxFactory&lt;/code&gt; command line option, or an inline &lt;code&gt;@jsx&lt;/code&gt; comment pragma to set it on a per-file basis. For example, if you set &lt;code&gt;jsxFactory&lt;/code&gt; to &lt;code&gt;createElement&lt;/code&gt;, &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; will emit as &lt;code&gt;createElement(&quot;div&quot;)&lt;/code&gt; instead of &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;jsx: react&lt;/code&gt; コンパイラー・オプションで使用される正確なファクトリー関数は構成可能です。 &lt;code&gt;jsxFactory&lt;/code&gt; コマンドラインオプションを使用して設定するか、インラインの &lt;code&gt;@jsx&lt;/code&gt; コメントプラグマを使用してファイルごとに設定できます。あなたが設定されている場合たとえば、 &lt;code&gt;jsxFactory&lt;/code&gt; をする &lt;code&gt;createElement&lt;/code&gt; 、 &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; として放出する &lt;code&gt;createElement(&quot;div&quot;)&lt;/code&gt; の代わりに、 &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be983dcb009cbaef6ee420c2ca6026b157bd7e0a" translate="yes" xml:space="preserve">
          <source>The example also shows how to override methods in the base class with methods that are specialized for the subclass. Here both &lt;code&gt;Snake&lt;/code&gt; and &lt;code&gt;Horse&lt;/code&gt; create a &lt;code&gt;move&lt;/code&gt; method that overrides the &lt;code&gt;move&lt;/code&gt; from &lt;code&gt;Animal&lt;/code&gt;, giving it functionality specific to each class. Note that even though &lt;code&gt;tom&lt;/code&gt; is declared as an &lt;code&gt;Animal&lt;/code&gt;, since its value is a &lt;code&gt;Horse&lt;/code&gt;, calling &lt;code&gt;tom.move(34)&lt;/code&gt; will call the overriding method in &lt;code&gt;Horse&lt;/code&gt;:</source>
          <target state="translated">この例では、基本クラスのメソッドを、サブクラスに特化したメソッドでオーバーライドする方法も示しています。ここでは &lt;code&gt;Snake&lt;/code&gt; と &lt;code&gt;Horse&lt;/code&gt; の両方 &lt;code&gt;move&lt;/code&gt; 、 &lt;code&gt;Animal&lt;/code&gt; からの移動をオーバーライドする &lt;code&gt;move&lt;/code&gt; メソッドを作成し、各クラスに固有の機能を提供しています。にもかかわらず注意 &lt;code&gt;tom&lt;/code&gt; として宣言されている &lt;code&gt;Animal&lt;/code&gt; 、その値があるので、 &lt;code&gt;Horse&lt;/code&gt; 、呼び出し &lt;code&gt;tom.move(34)&lt;/code&gt; にオーバーライドメソッドを呼び出します &lt;code&gt;Horse&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9309c4e757aa256b16a0bad58b5e33a98c76cbc2" translate="yes" xml:space="preserve">
          <source>The example uses a nested function here because the compiler can&amp;rsquo;t eliminate nulls inside a nested function (except immediately-invoked function expressions). That&amp;rsquo;s because it can&amp;rsquo;t track all calls to the nested function, especially if you return it from the outer function. Without knowing where the function is called, it can&amp;rsquo;t know what the type of &lt;code&gt;name&lt;/code&gt; will be at the time the body executes.</source>
          <target state="translated">コンパイラはネストされた関数内のnullを削除できないため、ここではネストされた関数を使用しています（即時に呼び出される関数式を除く）。それは、特に外側の関数からそれを返す場合、ネストされた関数へのすべての呼び出しを追跡できないためです。関数が呼び出される場所がわからなければ、本体が実行されるときに &lt;code&gt;name&lt;/code&gt; のタイプがどうなるかを知ることはできません。</target>
        </trans-unit>
        <trans-unit id="2521d541b8280fcd0c447ab0918ebaaed9adf402" translate="yes" xml:space="preserve">
          <source>The expression for the accessor decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">アクセサデコレータの式は、実行時に関数として呼び出され、以下の3つの引数を持ちます。</target>
        </trans-unit>
        <trans-unit id="0b14168e95c9d9a01df3680215e98fc982e341d6" translate="yes" xml:space="preserve">
          <source>The expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument.</source>
          <target state="translated">クラスデコレータの式は、実行時に関数として呼び出され、デコレーションされたクラスのコンストラクタが唯一の引数となります。</target>
        </trans-unit>
        <trans-unit id="0d60ee880be94f69fdd4585e45c1d4d2352936ea" translate="yes" xml:space="preserve">
          <source>The expression for the method decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">メソッドデコレータの式は、実行時に関数として呼び出され、以下の3つの引数を持ちます。</target>
        </trans-unit>
        <trans-unit id="5086d420edcd773ac6d732072618188585203199" translate="yes" xml:space="preserve">
          <source>The expression for the parameter decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">パラメータデコレータの式は、実行時に関数として呼び出され、以下の3つの引数を持ちます。</target>
        </trans-unit>
        <trans-unit id="edae3f3dc86e86b9a64d098ac85c40b60e98ad47" translate="yes" xml:space="preserve">
          <source>The expression for the property decorator will be called as a function at runtime, with the following two arguments:</source>
          <target state="translated">プロパティデコレータの式は、実行時に関数として呼び出され、以下の2つの引数を持ちます。</target>
        </trans-unit>
        <trans-unit id="3e0ed5b6c650314a8da3d7c5c7c625309c2ba4c4" translate="yes" xml:space="preserve">
          <source>The expressions for each decorator are evaluated top-to-bottom.</source>
          <target state="translated">各デコレータの式は上から下に評価されます。</target>
        </trans-unit>
        <trans-unit id="8ca9fb0afa1d2d7ae4017f7909cdf00932efdab7" translate="yes" xml:space="preserve">
          <source>The factory chosen will also affect where the &lt;code&gt;JSX&lt;/code&gt; namespace is looked up (for type checking information) before falling back to the global one.</source>
          <target state="translated">選択されたファクトリは、グローバル名前空間にフォールバックする前に、 &lt;code&gt;JSX&lt;/code&gt; 名前空間が（タイプチェック情報のために）検索される場所にも影響します。</target>
        </trans-unit>
        <trans-unit id="60727c2e253818c6e1394797bce9983cbcfb14d2" translate="yes" xml:space="preserve">
          <source>The factory chosen will also affect where the &lt;code&gt;JSX&lt;/code&gt; namespace is looked up (for type checking information) before falling back to the global one. If the factory is defined as &lt;code&gt;React.createElement&lt;/code&gt; (the default), the compiler will check for &lt;code&gt;React.JSX&lt;/code&gt; before checking for a global &lt;code&gt;JSX&lt;/code&gt;. If the factory is defined as &lt;code&gt;h&lt;/code&gt;, it will check for &lt;code&gt;h.JSX&lt;/code&gt; before a global &lt;code&gt;JSX&lt;/code&gt;.</source>
          <target state="translated">選択されたファクトリは、グローバルタイプにフォールバックする前に &lt;code&gt;JSX&lt;/code&gt; 名前空間が（タイプチェック情報のために）検索される場所にも影響します。ファクトリーが &lt;code&gt;React.createElement&lt;/code&gt; （デフォルト）として定義されている場合、コンパイラーはグローバル &lt;code&gt;JSX&lt;/code&gt; をチェックする前に &lt;code&gt;React.JSX&lt;/code&gt; をチェックします。ファクトリが &lt;code&gt;h&lt;/code&gt; として定義されている場合、ファクトリはグローバル &lt;code&gt;JSX&lt;/code&gt; の前に &lt;code&gt;h.JSX&lt;/code&gt; をチェックします。</target>
        </trans-unit>
        <trans-unit id="d8cbf6331553242a5f0e701d007b43692f6b7d55" translate="yes" xml:space="preserve">
          <source>The first assignment is now an error. Effectively, &lt;code&gt;T&lt;/code&gt; is contravariant in &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; because it is used only in function type parameter positions.</source>
          <target state="translated">最初の割り当てはエラーになりました。事実上、 &lt;code&gt;T&lt;/code&gt; は関数型パラメーターの位置でのみ使用されるため、 &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; では反変です。</target>
        </trans-unit>
        <trans-unit id="f83cf7bff16c656834b3e301df968baf4cd1ffca" translate="yes" xml:space="preserve">
          <source>The first assignment is permitted in default type checking mode, but flagged as an error in strict function types mode. Intuitively, the default mode permits the assignment because it is &lt;em&gt;possibly&lt;/em&gt; sound, whereas strict function types mode makes it an error because it isn&amp;rsquo;t &lt;em&gt;provably&lt;/em&gt; sound. In either mode the third assignment is an error because it is &lt;em&gt;never&lt;/em&gt; sound.</source>
          <target state="translated">最初の割り当てはデフォルトの型チェックモードで許可されていますが、厳密な関数型モードではエラーとしてフラグが立てられます。直感的には、デフォルトのモードではサウンドが割り当てられる&lt;em&gt;可能性&lt;/em&gt;が&lt;em&gt;ある&lt;/em&gt;ため、割り当てが許可されますが、厳密な関数タイプのモードでは、サウンドが&lt;em&gt;確実&lt;/em&gt;ではないためエラーが発生します。どちらのモードでも、3番目の割り当ては&lt;em&gt;決して&lt;/em&gt;健全では&lt;em&gt;ない&lt;/em&gt;ため、エラーになります。</target>
        </trans-unit>
        <trans-unit id="86d2c2eef081b9efd8e081cbfc7a2eb73c95a9bf" translate="yes" xml:space="preserve">
          <source>The first is that enum members also become types as well! For example, we can say that certain members can &lt;em&gt;only&lt;/em&gt; have the value of an enum member:</source>
          <target state="translated">1つ目は、列挙型メンバーも型になることです。たとえば、特定のメンバーは列挙型メンバーの値&lt;em&gt;しか&lt;/em&gt;持つことができ&lt;em&gt;ない&lt;/em&gt;と言えます。</target>
        </trans-unit>
        <trans-unit id="f1597b8ab64d75c9fce4d84614baa27283e2feea" translate="yes" xml:space="preserve">
          <source>The first is that the &lt;em&gt;empty type&lt;/em&gt; seems to defy expectation:</source>
          <target state="translated">1つ目は、&lt;em&gt;空の型が&lt;/em&gt;期待に反しているように見えることです。</target>
        </trans-unit>
        <trans-unit id="82698594e79b48b6fa7cb117ffc18b411c17a2c9" translate="yes" xml:space="preserve">
          <source>The first line of the TypeScript code uses a global variable &lt;code&gt;document&lt;/code&gt;. Inspecting the variable shows it is defined by the &lt;code&gt;Document&lt;/code&gt; interface from the &lt;em&gt;lib.dom.d.ts&lt;/em&gt; file. The code snippet contains calls to two methods, &lt;code&gt;getElementById&lt;/code&gt; and &lt;code&gt;createElement&lt;/code&gt;.</source>
          <target state="translated">TypeScriptコードの最初の行は、グローバル変数 &lt;code&gt;document&lt;/code&gt; 使用しています。変数を&lt;em&gt;調べると&lt;/em&gt;、&lt;em&gt;lib.dom.d.ts&lt;/em&gt;ファイルの &lt;code&gt;Document&lt;/code&gt; インターフェースによって定義されていることが&lt;em&gt;わかり&lt;/em&gt;ます。コードスニペットには、 &lt;code&gt;getElementById&lt;/code&gt; と &lt;code&gt;createElement&lt;/code&gt; の2つのメソッドへの呼び出しが含まれています。</target>
        </trans-unit>
        <trans-unit id="11b6104cea3d7fbf08969b5f72b6d05a84f6d569" translate="yes" xml:space="preserve">
          <source>The first line tells Visual Studio to run the task &amp;lsquo;default&amp;rsquo; after the build finishes. It will also run the &amp;lsquo;clean&amp;rsquo; task when you ask Visual Studio to clean the build.</source>
          <target state="translated">1行目は、ビルドの完了後にタスクを「デフォルト」で実行するようにVisual Studioに指示しています。また、Visual Studioにビルドのクリーンアップを要求すると、「クリーン」タスクも実行されます。</target>
        </trans-unit>
        <trans-unit id="f589b53519dab849472b770ba61a662532e94279" translate="yes" xml:space="preserve">
          <source>The first step to type checking attributes is to determine the &lt;em&gt;element attributes type&lt;/em&gt;. This is slightly different between intrinsic and value-based elements.</source>
          <target state="translated">タイプチェック属性の最初のステップは、&lt;em&gt;要素の属性タイプ&lt;/em&gt;を決定すること&lt;em&gt;です&lt;/em&gt;。これは、組み込み要素と値ベースの要素の間でわずかに異なります。</target>
        </trans-unit>
        <trans-unit id="58af75a63079336d3af143e1407bc44a6c44b6ef" translate="yes" xml:space="preserve">
          <source>The first thing you may notice in the above is that instead of trying to extend &lt;code&gt;Disposable&lt;/code&gt; and &lt;code&gt;Activatable&lt;/code&gt; in &lt;code&gt;SmartObject&lt;/code&gt; class, we extend them in &lt;code&gt;SmartObject&lt;/code&gt; interface. &lt;code&gt;SmartObject&lt;/code&gt; interface will be mixed into the &lt;code&gt;SmartObject&lt;/code&gt; class due to the &lt;a href=&quot;declaration-merging&quot;&gt;declaration merging&lt;/a&gt;.</source>
          <target state="translated">あなたは上記に気づくことが最初のものではなく、拡張しようとするということである &lt;code&gt;Disposable&lt;/code&gt; と &lt;code&gt;Activatable&lt;/code&gt; して &lt;code&gt;SmartObject&lt;/code&gt; のクラス、私たちはそれらを延長 &lt;code&gt;SmartObject&lt;/code&gt; のインターフェース。 &lt;code&gt;SmartObject&lt;/code&gt; インターフェイスは、&lt;a href=&quot;declaration-merging&quot;&gt;宣言のマージ&lt;/a&gt;により、 &lt;code&gt;SmartObject&lt;/code&gt; クラスに混在します。</target>
        </trans-unit>
        <trans-unit id="1598a89fa953ba70cfbbf99c377df16fd8ed251e" translate="yes" xml:space="preserve">
          <source>The first type of assertion signature models the way that Node&amp;rsquo;s &lt;code&gt;assert&lt;/code&gt; function works. It ensures that whatever condition is being checked must be true for the remainder of the containing scope.</source>
          <target state="translated">最初のタイプのアサーションシグネチャは、Nodeの &lt;code&gt;assert&lt;/code&gt; 機能の動作方法をモデル化しています。これにより、チェックされるすべての条件が、包含スコープの残りの部分でtrueになる必要があります。</target>
        </trans-unit>
        <trans-unit id="e7ac3fa8432f39d89d10777015cb56ae8fd93747" translate="yes" xml:space="preserve">
          <source>The flexibility of &lt;code&gt;rootDirs&lt;/code&gt; is not limited to specifying a list of physical source directories that are logically merged. The supplied array may include any number of ad hoc, arbitrary directory names, regardless of whether they exist or not. This allows the compiler to capture sophisticated bundling and runtime features such as conditional inclusion and project specific loader plugins in a type safe way.</source>
          <target state="translated">&lt;code&gt;rootDirs&lt;/code&gt; の柔軟性は、論理的にマージされる物理ソースディレクトリのリストを指定することに限定されません。提供される配列には、それらが存在するかどうかに関係なく、アドホックな任意のディレクトリ名をいくつでも含めることができます。これにより、コンパイラーは、条件付き組み込みやプロジェクト固有のローダープラグインなどの高度なバンドリングおよびランタイム機能をタイプセーフな方法でキャプチャできます。</target>
        </trans-unit>
        <trans-unit id="6ba8cf088bc4a62237fb1f09825df1931ceb84e4" translate="yes" xml:space="preserve">
          <source>The following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:</source>
          <target state="translated">以下の例は、共変数の位置にある同じ型変数の複数の候補が、どのようにして組合型を推論するかを示しています。</target>
        </trans-unit>
        <trans-unit id="aa5d6454fbf6bf730c8b327164f77ed6f69baf2e" translate="yes" xml:space="preserve">
          <source>The following is an example of a class decorator (&lt;code&gt;@sealed&lt;/code&gt;) applied to the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">以下は、 &lt;code&gt;Greeter&lt;/code&gt; クラスに適用されたクラスデコレータ（ &lt;code&gt;@sealed&lt;/code&gt; ）の例です。</target>
        </trans-unit>
        <trans-unit id="894306209d899f3f7794eaec540a57c394ffa6ed" translate="yes" xml:space="preserve">
          <source>The following is an example of a method decorator (&lt;code&gt;@enumerable&lt;/code&gt;) applied to a method on the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">以下は、 &lt;code&gt;Greeter&lt;/code&gt; クラスのメソッドに適用されるメソッドデコレータ（ &lt;code&gt;@enumerable&lt;/code&gt; ）の例です。</target>
        </trans-unit>
        <trans-unit id="56eb8bb77b4d8ce3acb0c50224bfb3b899067f94" translate="yes" xml:space="preserve">
          <source>The following is an example of a parameter decorator (&lt;code&gt;@required&lt;/code&gt;) applied to parameter of a member of the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">以下は、 &lt;code&gt;Greeter&lt;/code&gt; クラスのメンバーのパラメーターに適用されるパラメーターデコレーター（ &lt;code&gt;@required&lt;/code&gt; ）の例です。</target>
        </trans-unit>
        <trans-unit id="4c9599f42a20eb3b17874db9fbac592989bd9e8c" translate="yes" xml:space="preserve">
          <source>The following is an example of an accessor decorator (&lt;code&gt;@configurable&lt;/code&gt;) applied to a member of the &lt;code&gt;Point&lt;/code&gt; class:</source>
          <target state="translated">以下は、 &lt;code&gt;Point&lt;/code&gt; クラスのメンバーに適用されるアクセサーデコレーター（ &lt;code&gt;@configurable&lt;/code&gt; ）の例です。</target>
        </trans-unit>
        <trans-unit id="78b3414d6c6279a9a7d36fd763a26f60ecb80162" translate="yes" xml:space="preserve">
          <source>The following tags have open issues to support them:</source>
          <target state="translated">以下のタグには、それらをサポートするためのオープンな課題があります。</target>
        </trans-unit>
        <trans-unit id="fb147db5e9640faf772e0ff23a000f02eb6a9092" translate="yes" xml:space="preserve">
          <source>The following types have built-in predicates:</source>
          <target state="translated">以下の型には述語が組み込まれています。</target>
        </trans-unit>
        <trans-unit id="f1290f593b907ee11da2a865c78e736129d049be" translate="yes" xml:space="preserve">
          <source>The global variable &lt;code&gt;foo&lt;/code&gt; contains the number of widgets present.</source>
          <target state="translated">グローバル変数 &lt;code&gt;foo&lt;/code&gt; には、存在するウィジェットの数が含まれています。</target>
        </trans-unit>
        <trans-unit id="5cf5ea298d71b31d168d1d4cfd5dd7bf5304c883" translate="yes" xml:space="preserve">
          <source>The global variable &lt;code&gt;myLib&lt;/code&gt; has a function &lt;code&gt;makeGreeting&lt;/code&gt; for creating greetings, and a property &lt;code&gt;numberOfGreetings&lt;/code&gt; indicating the number of greetings made so far.</source>
          <target state="translated">グローバル変数 &lt;code&gt;myLib&lt;/code&gt; 関数がある &lt;code&gt;makeGreeting&lt;/code&gt; 挨拶を作成するために、プロパティ &lt;code&gt;numberOfGreetings&lt;/code&gt; 挨拶の数を示すが、これまでに作られました。</target>
        </trans-unit>
        <trans-unit id="fbf0d9abbae1382a841d6a20a7fd42f5f792dbfd" translate="yes" xml:space="preserve">
          <source>The guide is broken down into the following sections.</source>
          <target state="translated">ガイドは以下の項目に分かれています。</target>
        </trans-unit>
        <trans-unit id="a089c228c5ebe31ca69e3f47fd0070706f6094d2" translate="yes" xml:space="preserve">
          <source>The handbook is split into two sections:</source>
          <target state="translated">ハンドブックは2つのセクションに分かれています。</target>
        </trans-unit>
        <trans-unit id="604cbcf9b1655f8dee840e0d141897f7e64d6d7e" translate="yes" xml:space="preserve">
          <source>The handbook reference is built to provide a richer understanding of how a particular part of TypeScript works. You can read it top-to-bottom, but each section aims to provide a deeper explanation of a single concept - meaning there is no aim for continuity.</source>
          <target state="translated">ハンドブックリファレンスは、TypeScript の特定の部分がどのように機能するのかをより深く理解できるように作られています。上から下まで読むことができますが、各セクションは一つの概念についてより深い説明を提供することを目的としています-つまり、継続性を目的としたものではありません。</target>
        </trans-unit>
        <trans-unit id="152f8cc5510f46a1bacae33a53ef9b6ca874c1fb" translate="yes" xml:space="preserve">
          <source>The inference process is fairly straightforward here because &lt;code&gt;getDisplayName&lt;/code&gt; and &lt;code&gt;getLength&lt;/code&gt; use types that can easily be referenced. However, in TypeScript 3.3 and earlier, generic functions like &lt;code&gt;compose&lt;/code&gt; didn&amp;rsquo;t work so well when passed other generic functions.</source>
          <target state="translated">&lt;code&gt;getDisplayName&lt;/code&gt; と &lt;code&gt;getLength&lt;/code&gt; は簡単に参照できるタイプを使用するため、ここでは推論プロセスはかなり単純です。ただし、TypeScript 3.3以前では、 &lt;code&gt;compose&lt;/code&gt; などのジェネリック関数は、他のジェネリック関数を渡されたときにあまり機能しませんでした。</target>
        </trans-unit>
        <trans-unit id="2bd1d13df309ad7c445be96538c356e69d82dd45" translate="yes" xml:space="preserve">
          <source>The inferred return type of a function may be a type declared locally within the function. It is not possible for callers of the function to reference such a local type, but it can of course be matched structurally. For example:</source>
          <target state="translated">関数の推測される戻り値の型は、関数内でローカルに宣言された型である可能性があります。関数の呼び出し元がこのようなローカル型を参照することはできませんが、もちろん構造的にマッチさせることはできます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="78b1c8f9ed0f4d721027df616536d2627988df99" translate="yes" xml:space="preserve">
          <source>The inferred value for &lt;code&gt;rootDir&lt;/code&gt; is the longest common path of all non-declaration input files, which in this case is &lt;code&gt;core/&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rootDir&lt;/code&gt; の推定値は、すべての非宣言入力ファイル（この場合は &lt;code&gt;core/&lt;/code&gt; ）の最長の共通パスです。</target>
        </trans-unit>
        <trans-unit id="47a1b4c14a30afe92145ea5aeaecb13f79bfbd9a" translate="yes" xml:space="preserve">
          <source>The instance side of an ambient class declaration can be extended using an interface declaration The class constructor object is unmodified. For example:</source>
          <target state="translated">アンビエントクラス宣言のインスタンス側は、インターフェース宣言を使って拡張できます。 クラスのコンストラクタオブジェクトは変更されません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0e67711effae647619fb03057e9603bedb94bf60" translate="yes" xml:space="preserve">
          <source>The intent of any function that returns &lt;code&gt;never&lt;/code&gt; is that it never returns. It indicates that an exception was thrown, a halting error condition occurred, or that the program exited. For example, &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874&quot;&gt;&lt;code&gt;process.exit(...)&lt;/code&gt; in &lt;code&gt;@types/node&lt;/code&gt;&lt;/a&gt; is specified to return &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 戻らない関数の意図は、決して戻らないことです。例外がスローされたか、停止エラー条件が発生したか、またはプログラムが終了したことを示しています。たとえば&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874&quot;&gt;、&lt;/a&gt; &lt;code&gt;@types/node&lt;/code&gt; &lt;code&gt;process.exit(...)&lt;/code&gt; は、 &lt;code&gt;never&lt;/code&gt; を返さないように指定されています。</target>
        </trans-unit>
        <trans-unit id="8083efa15c72562212b03ec1e7d929e3b1bfe6f0" translate="yes" xml:space="preserve">
          <source>The interface &lt;code&gt;LabeledValue&lt;/code&gt; is a name we can now use to describe the requirement in the previous example. It still represents having a single property called &lt;code&gt;label&lt;/code&gt; that is of type &lt;code&gt;string&lt;/code&gt;. Notice we didn&amp;rsquo;t have to explicitly say that the object we pass to &lt;code&gt;printLabel&lt;/code&gt; implements this interface like we might have to in other languages. Here, it&amp;rsquo;s only the shape that matters. If the object we pass to the function meets the requirements listed, then it&amp;rsquo;s allowed.</source>
          <target state="translated">インターフェイス &lt;code&gt;LabeledValue&lt;/code&gt; は、前の例の要件を説明するために使用できる名前です。それでも、 &lt;code&gt;string&lt;/code&gt; 型の &lt;code&gt;label&lt;/code&gt; という単一のプロパティを持つことを表します。他の言語で必要となる場合があるように、 &lt;code&gt;printLabel&lt;/code&gt; に渡すオブジェクトがこのインターフェイスを実装することを明示的に言う必要がなかったことに注意してください。ここで重要なのは形状だけです。関数に渡すオブジェクトがリストされた要件を満たしている場合、それは許可されます。</target>
        </trans-unit>
        <trans-unit id="cd1c38f5000220665076a2e98824f2dbc1f3584b" translate="yes" xml:space="preserve">
          <source>The key difference is not in the syntax, but in the semantics, which we&amp;rsquo;ll now dive into.</source>
          <target state="translated">主な違いは構文ではなく、セマンティクスにあります。これについては、これから詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="b1b9a12d68027688efebd6988d804e470eefcb75" translate="yes" xml:space="preserve">
          <source>The last element of a tuple type can be a rest element of the form &lt;code&gt;...X&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an array type. A rest element indicates that the tuple type is open-ended and may have zero or more additional elements of the array element type. For example, &lt;code&gt;[number, ...string[]]&lt;/code&gt; means tuples with a &lt;code&gt;number&lt;/code&gt; element followed by any number of &lt;code&gt;string&lt;/code&gt; elements.</source>
          <target state="translated">タプル型の最後の要素は、 &lt;code&gt;...X&lt;/code&gt; 形式の残りの要素にすることができます。ここで、 &lt;code&gt;X&lt;/code&gt; は配列型です。残りの要素は、タプルの型が無制限であり、配列要素型の0個以上の追加の要素を持つ可能性があることを示します。たとえば、 &lt;code&gt;[number, ...string[]]&lt;/code&gt; は、 &lt;code&gt;number&lt;/code&gt; 要素の後に任意の数の &lt;code&gt;string&lt;/code&gt; 要素が続くタプルを意味します。</target>
        </trans-unit>
        <trans-unit id="ea7d1078a9be532038ef2deef32790daf490bb8c" translate="yes" xml:space="preserve">
          <source>The last line of the code snippet is &lt;code&gt;app?.appendChild(p)&lt;/code&gt;. The previous, &lt;code&gt;document.getElementById&lt;/code&gt; , section detailed that the &lt;em&gt;optional chaining&lt;/em&gt; operator is used here because &lt;code&gt;app&lt;/code&gt; can potentially be null at runtime. The &lt;code&gt;appendChild&lt;/code&gt; method is defined by:</source>
          <target state="translated">コードスニペットの最後の行は &lt;code&gt;app?.appendChild(p)&lt;/code&gt; です。前の &lt;code&gt;document.getElementById&lt;/code&gt; のセクションでは、 &lt;code&gt;app&lt;/code&gt; が実行時にnullになる可能性があるため、ここでは&lt;em&gt;オプションの連鎖&lt;/em&gt;演算子を使用する方法について詳しく説明しました。 &lt;code&gt;appendChild&lt;/code&gt; の方法は以下のように定義されています。</target>
        </trans-unit>
        <trans-unit id="5a1fa816d66a94a39a64dba4ddbbaa3fb384695f" translate="yes" xml:space="preserve">
          <source>The last line of the previous code sample would raise an error in TypeScript, but it doesn&amp;rsquo;t by default in a JS project. To enable errors in your JavaScript files add: &lt;code&gt;// @ts-check&lt;/code&gt; to the first line in your &lt;code&gt;.js&lt;/code&gt; files to have TypeScript raise it as an error.</source>
          <target state="translated">前のコードサンプルの最後の行では、TypeScriptでエラーが発生しますが、JSプロジェクトではデフォルトでは発生しません。JavaScriptファイルのエラーを有効にするには、次を追加します &lt;code&gt;.js&lt;/code&gt; &lt;code&gt;// @ts-check&lt;/code&gt; .jsファイルの最初の行をチェックして、TypeScriptにエラーとして発生させます。</target>
        </trans-unit>
        <trans-unit id="3425f6446014efd7d54ccc807ba0bd462046777c" translate="yes" xml:space="preserve">
          <source>The latter style is more common but both are allowed, even in the same file.</source>
          <target state="translated">後者のスタイルの方が一般的ですが、同じファイルでもどちらも許されています。</target>
        </trans-unit>
        <trans-unit id="d4b0bc795023f6d40258c16a24c570ab3f6de281" translate="yes" xml:space="preserve">
          <source>The layout of your declaration files should mirror the layout of the library.</source>
          <target state="translated">宣言ファイルのレイアウトは、ライブラリのレイアウトを反映させてください。</target>
        </trans-unit>
        <trans-unit id="62c6720928ebff15b4528d428a66db79a0e91621" translate="yes" xml:space="preserve">
          <source>The library can then be used as an import within modules:</source>
          <target state="translated">このライブラリは、モジュール内のインポートとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="5c400cd4aab73c26b9cba5406e5bfac6b44dcde8" translate="yes" xml:space="preserve">
          <source>The list below outlines which constructs are currently supported when using JSDoc annotations to provide type information in JavaScript files.</source>
          <target state="translated">以下のリストは、JavaScriptファイルの型情報を提供するためにJSDocアノテーションを使用する際に、現在サポートされている構文の概要です。</target>
        </trans-unit>
        <trans-unit id="dfd2bc32d3b21a5f15921128bd3664a23c6123a7" translate="yes" xml:space="preserve">
          <source>The locale to use to show error messages, e.g. en-us.</source>
          <target state="translated">エラーメッセージを表示する際に使用するロケール。</target>
        </trans-unit>
        <trans-unit id="745d0c4fae6c29892a03fe80ac17ab71cddad006" translate="yes" xml:space="preserve">
          <source>The majority of this handbook uses &lt;code&gt;let&lt;/code&gt; declarations.</source>
          <target state="translated">このハンドブックの大部分は &lt;code&gt;let&lt;/code&gt; 宣言を使用しています。</target>
        </trans-unit>
        <trans-unit id="d5361e797afb54e7fafd11ab7165d6157098d98b" translate="yes" xml:space="preserve">
          <source>The maximum dependency depth to search under &lt;code&gt;node_modules&lt;/code&gt; and load JavaScript files.</source>
          <target state="translated">&lt;code&gt;node_modules&lt;/code&gt; で検索し、JavaScriptファイルをロードするための最大依存関係の深さ。</target>
        </trans-unit>
        <trans-unit id="6da0134724ec18c2aa83421ac5856f5cd2ff92c3" translate="yes" xml:space="preserve">
          <source>The maximum dependency depth to search under node_modules and load JavaScript files. Only applicable with &lt;code&gt;--allowJs&lt;/code&gt;.</source>
          <target state="translated">node_modulesで検索してJavaScriptファイルをロードするための最大の依存関係の深さ。 &lt;code&gt;--allowJs&lt;/code&gt; でのみ適用されます。</target>
        </trans-unit>
        <trans-unit id="617a4a49e4615a56e38ae287aca4e940a80853ed" translate="yes" xml:space="preserve">
          <source>The meaning is usually the same, or a superset, of the meaning of the tag given at &lt;a href=&quot;https://jsdoc.app&quot;&gt;jsdoc.app&lt;/a&gt;. The code below describes the differences and gives some example usage of each tag.</source>
          <target state="translated">意味は通常、&lt;a href=&quot;https://jsdoc.app&quot;&gt;jsdoc.appで&lt;/a&gt;指定されたタグの意味と同じまたはスーパーセットです。以下のコードは、違いを説明し、各タグの使用例を示しています。</target>
        </trans-unit>
        <trans-unit id="931a11093903bc4e1293ac6a3b67077bc77990a3" translate="yes" xml:space="preserve">
          <source>The meaning is usually the same, or a superset, of the meaning of the tag given at usejsdoc.org. The code below describes the differences and gives some example usage of each tag.</source>
          <target state="translated">その意味は通常、usejsdoc.orgで与えられたタグの意味と同じか、あるいはその上位のものです。以下のコードは違いを説明し、それぞれのタグの使用例を示しています。</target>
        </trans-unit>
        <trans-unit id="942184e9d11609161fd758335e2cb598f79fd707" translate="yes" xml:space="preserve">
          <source>The mixin pattern is supported natively inside the TypeScript compiler by code flow analysis. There are a few cases where you can hit the edges of the native support.</source>
          <target state="translated">ミキシングパターンは、コードフロー解析によってTypeScriptコンパイラ内部でネイティブにサポートされています。ネイティブサポートのエッジに当たるケースがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="5ce56ea092f5ec509f61892542f58f563f4f1ba4" translate="yes" xml:space="preserve">
          <source>The module name is resolved the same way as module specifiers in &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;export&lt;/code&gt;. See &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; for more information. Then the declarations in an augmentation are merged as if they were declared in the same file as the original.</source>
          <target state="translated">モジュール名は、 &lt;code&gt;import&lt;/code&gt; / &lt;code&gt;export&lt;/code&gt; モジュール指定子と同じ方法で解決されます。詳細については、&lt;a href=&quot;modules&quot;&gt;モジュール&lt;/a&gt;を参照してください。次に、オーグメンテーション内の宣言は、元のファイルと同じファイルで宣言されているかのようにマージされます。</target>
        </trans-unit>
        <trans-unit id="e4ef072c2703c60524da107c05a2dfe78d02a391" translate="yes" xml:space="preserve">
          <source>The module support in Javascript is much more syntactically forgiving than TypeScript&amp;rsquo;s module support. Most combinations of assignments and declarations are supported.</source>
          <target state="translated">Javascriptでのモジュールのサポートは、TypeScriptのモジュールのサポートよりも構文的にはるかに寛容です。割り当てと宣言のほとんどの組み合わせがサポートされています。</target>
        </trans-unit>
        <trans-unit id="07d6025a4d8631b7d86a3f44337b3b6ce6a9547d" translate="yes" xml:space="preserve">
          <source>The module support in Javascript is much more syntactically forgiving than Typescript&amp;rsquo;s module support. Most combinations of assignments and declarations are supported.</source>
          <target state="translated">Javascriptでのモジュールサポートは、Typescriptのモジュールサポートよりも構文的にはるかに寛容です。割り当てと宣言のほとんどの組み合わせがサポートされています。</target>
        </trans-unit>
        <trans-unit id="72abf6e26cd87e8f0de9628019db48b91ac42135" translate="yes" xml:space="preserve">
          <source>The most basic datatype is the simple true/false value, which JavaScript and TypeScript call a &lt;code&gt;boolean&lt;/code&gt; value.</source>
          <target state="translated">最も基本的なデータ型は、JavaScriptとTypeScriptが &lt;code&gt;boolean&lt;/code&gt; 値を呼び出す単純なtrue / false値です。</target>
        </trans-unit>
        <trans-unit id="a03cd6c7e32b9f93ac936ffc0acd7964734f63ea" translate="yes" xml:space="preserve">
          <source>The most common case for learning how .d.ts files work is that you&amp;rsquo;re typing an npm package with no types. In that case, you can jump straight to &lt;a href=&quot;templates/module-d-ts&quot;&gt;Modules .d.ts&lt;/a&gt;.</source>
          <target state="translated">.d.tsファイルがどのように機能するかを学ぶための最も一般的なケースは、タイプのないnpmパッケージを入力していることです。その場合は、&lt;a href=&quot;templates/module-d-ts&quot;&gt;Modules.d.tsに直接&lt;/a&gt;ジャンプできます。</target>
        </trans-unit>
        <trans-unit id="e7640814a5033d876fc4ba4a5004fadadb312ca3" translate="yes" xml:space="preserve">
          <source>The most common kinds of errors that programmers write can be described as type errors: a certain kind of value was used where a different kind of value was expected. This could be due to simple typos, a failure to understand the API surface of a library, incorrect assumptions about runtime behavior, or other errors. The goal of TypeScript is to be a static typechecker for JavaScript programs - in other words, a tool that runs before your code runs (static) and ensures that the types of the program are correct (typechecked).</source>
          <target state="translated">プログラマーが書くエラーの中で最も一般的なものは、型エラーと表現できます。これは、単純なタイプミス、ライブラリのAPI面を理解していなかったこと、実行時の動作に関する誤った仮定、またはその他のエラーが原因である可能性があります。TypeScript の目標は、JavaScript プログラムの静的なタイプチェッカになることです。言い換えれば、コードが実行される前に実行され(静的)、プログラムの型が正しいことを保証する(タイプチェックされた)ツールです。</target>
        </trans-unit>
        <trans-unit id="a9f7f6f667f2904bbc6c5b01fab0ba1c74724d50" translate="yes" xml:space="preserve">
          <source>The most common solution here is to define a &lt;code&gt;default&lt;/code&gt; export for a callable/constructable object; module loaders commonly detect this situation automatically and replace the top-level object with the &lt;code&gt;default&lt;/code&gt; export. Typescript can handle this for you, if you have &lt;a href=&quot;https://www.typescriptlang.org/tsconfig/#esModuleInterop&quot;&gt;&lt;code&gt;&quot;esModuleInterop&quot;: true&lt;/code&gt;&lt;/a&gt; in tsconfig.json.</source>
          <target state="translated">ここでの最も一般的な解決策は、呼び出し可能/構築可能なオブジェクトの &lt;code&gt;default&lt;/code&gt; エクスポートを定義することです。モジュールローダーは通常、この状況を自動的に検出し、最上位のオブジェクトを &lt;code&gt;default&lt;/code&gt; エクスポートに置き換えます。&lt;a href=&quot;https://www.typescriptlang.org/tsconfig/#esModuleInterop&quot;&gt; &lt;code&gt;&quot;esModuleInterop&quot;: true&lt;/code&gt; &lt;/a&gt;、Typescriptでこれを処理できます。</target>
        </trans-unit>
        <trans-unit id="79f9e1701395e49a979bcc38539774286a14204c" translate="yes" xml:space="preserve">
          <source>The most impactful outcome of this feature might a bit subtle: with TypeScript 3.7, users can write libraries in JSDoc annotated JavaScript and support TypeScript users.</source>
          <target state="translated">TypeScript 3.7では、JSDocの注釈付きJavaScriptにライブラリを書き込んだり、TypeScriptユーザーをサポートしたりすることができます。</target>
        </trans-unit>
        <trans-unit id="d479ce4d899b82dead8eec0f18d6751cfd1966b0" translate="yes" xml:space="preserve">
          <source>The motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:</source>
          <target state="translated">動機となる例は、コールバックを受け取り、(プログラマにとっては)予測可能だが(型システムにとっては)未知の数の引数を使ってコールバックを呼び出す関数の一般的なパターンです。</target>
        </trans-unit>
        <trans-unit id="a57329ec0396a0060bb3225032730f604a10bd46" translate="yes" xml:space="preserve">
          <source>The name of a module augmentation is resolved using the same set of rules as module specifiers in &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; declarations. The declarations in a module augmentation are merged with any existing declarations the same way they would if they were declared in the same file.</source>
          <target state="translated">モジュール拡張の名前は、 &lt;code&gt;import&lt;/code&gt; および &lt;code&gt;export&lt;/code&gt; 宣言のモジュール指定子と同じルールセットを使用して解決されます。モジュール拡張の宣言は、同じファイルで宣言された場合と同じように、既存の宣言とマージされます。</target>
        </trans-unit>
        <trans-unit id="89f93191caae9470e60a7d3f09f4c2434d9bcb48" translate="yes" xml:space="preserve">
          <source>The name of the member.</source>
          <target state="translated">メンバーの名前です。</target>
        </trans-unit>
        <trans-unit id="bf6a2b3b69a6eaafe919135aca00082a2b3c554f" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;--showConfig&lt;/code&gt; flag</source>
          <target state="translated">新しい &lt;code&gt;--showConfig&lt;/code&gt; フラグ</target>
        </trans-unit>
        <trans-unit id="b915c8b00bd04df204cf54cb79ae4b4967b8188e" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;--strict&lt;/code&gt; compiler option represents the recommended setting of a number of type checking options. Specifically, specifying &lt;code&gt;--strict&lt;/code&gt; corresponds to specifying all of the following options (and may in the future include more options):</source>
          <target state="translated">新しい &lt;code&gt;--strict&lt;/code&gt; コンパイラオプションは、いくつかのタイプチェックオプションの推奨設定を表します。具体的には、 &lt;code&gt;--strict&lt;/code&gt; を指定すると、以下のすべてのオプションを指定することになります（将来的には、さらに多くのオプションが含まれる可能性があります）。</target>
        </trans-unit>
        <trans-unit id="46ab9ac92f2751e3448564e3b2bbebba0803af30" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;amd-dependency name&lt;/code&gt; property allows passing an optional name for an amd-dependency:</source>
          <target state="translated">新しい &lt;code&gt;amd-dependency name&lt;/code&gt; プロパティにより、amd-dependencyのオプションの名前を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="b0b30ce72a1fbb86ba7cb09b3d3773b6f87269d1" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;amd-module name&lt;/code&gt; tag allows passing an optional module name to the compiler:</source>
          <target state="translated">新しい &lt;code&gt;amd-module name&lt;/code&gt; タグを使用すると、オプションのモジュール名をコンパイラに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="00c1dd0b1d0ca34ff1579a9b55a20060afb63f62" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;protected&lt;/code&gt; modifier in classes works like it does in familiar languages like C++, C#, and Java. A &lt;code&gt;protected&lt;/code&gt; member of a class is visible only inside subclasses of the class in which it is declared:</source>
          <target state="translated">クラス内の新しい &lt;code&gt;protected&lt;/code&gt; 修飾子は、C ++、C＃、Javaなどの使い慣れた言語でのように機能します。 &lt;code&gt;protected&lt;/code&gt; クラスのメンバーは、それが宣言されたクラスのサブクラスの内部に表示されています。</target>
        </trans-unit>
        <trans-unit id="4be0bd15099c0de30a7f92de365d0546b8ad473c" translate="yes" xml:space="preserve">
          <source>The new ES6 keyword &lt;code&gt;let&lt;/code&gt;, now supported in TypeScript, declares a variable with more intuitive &amp;ldquo;block&amp;rdquo; semantics. A &lt;code&gt;let&lt;/code&gt; variable can only be referred to after its declaration, and is scoped to the syntactic block where it is defined:</source>
          <target state="translated">TypeScriptでサポート &lt;code&gt;let&lt;/code&gt; になった新しいES6キーワードletは、より直感的な「ブロック」セマンティクスで変数を宣言します。 &lt;code&gt;let&lt;/code&gt; 変数は、その宣言の後に参照することができ、それが定義されている構文ブロックにスコープされます。</target>
        </trans-unit>
        <trans-unit id="631ad33334be4530d47703f4e1d29cda38f087ea" translate="yes" xml:space="preserve">
          <source>The new factory name will be used to call &lt;code&gt;createElement&lt;/code&gt; and &lt;code&gt;__spread&lt;/code&gt; functions.</source>
          <target state="translated">新しいファクトリー名は、 &lt;code&gt;createElement&lt;/code&gt; および &lt;code&gt;__spread&lt;/code&gt; 関数を呼び出すために使用されます。</target>
        </trans-unit>
        <trans-unit id="d61ddaaf04d8d0073ea020e3954c9d83ac5bd7ac" translate="yes" xml:space="preserve">
          <source>The new features are designed such that they can be used in both strict null checking mode and regular type checking mode. In particular, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; types are automatically erased from union types in regular type checking mode (because they are subtypes of all other types), and the &lt;code&gt;!&lt;/code&gt; non-null assertion expression operator is permitted but has no effect in regular type checking mode. Thus, declaration files that are updated to use null- and undefined-aware types can still be used in regular type checking mode for backwards compatibility.</source>
          <target state="translated">新機能は、厳密なnullチェックモードと通常の型チェックモードの両方で使用できるように設計されています。特に、 &lt;code&gt;null&lt;/code&gt; 型と &lt;code&gt;undefined&lt;/code&gt; 型は、通常の型チェックモードで共用体型から自動的に消去されます（他のすべての型のサブタイプであるため） &lt;code&gt;!&lt;/code&gt; null以外のアサーション式演算子は許可されていますが、通常の型チェックモードでは効果がありません。したがって、nullおよび未定義の型を使用するように更新された宣言ファイルは、下位互換性のために通常の型チェックモードで引き続き使用できます。</target>
        </trans-unit>
        <trans-unit id="c30cd7e33232b4d2a28f205e7ae9088fbd691c02" translate="yes" xml:space="preserve">
          <source>The new handbook which is a work in progress.</source>
          <target state="translated">作業を進めていく新手引書。</target>
        </trans-unit>
        <trans-unit id="b6846e96b454262c109940d0e55e3a4611d91414" translate="yes" xml:space="preserve">
          <source>The new implementation also brings performance enhancements to watching in tsserver. The watcher logic has been completely rewritten to respond faster to change events.</source>
          <target state="translated">新しい実装では、tsserver でのウォッチングにもパフォーマンスの向上がもたらされています。ウォッチャーのロジックが完全に書き換えられ、変更イベントに素早く反応するようになりました。</target>
        </trans-unit>
        <trans-unit id="5a00224be7961350e2a8ff419045fdd51b036e82" translate="yes" xml:space="preserve">
          <source>The new module &lt;code&gt;ProgrammerCalculator&lt;/code&gt; exports an API shape similar to that of the original &lt;code&gt;Calculator&lt;/code&gt; module, but does not augment any objects in the original module. Here is a test for our ProgrammerCalculator class:</source>
          <target state="translated">新しいモジュール &lt;code&gt;ProgrammerCalculator&lt;/code&gt; は、元の &lt;code&gt;Calculator&lt;/code&gt; モジュールと同様のAPI形状をエクスポートしますが、元のモジュールのオブジェクトを拡張しません。ProgrammerCalculatorクラスのテストは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="2225a57adb33f21d4ebaaf566df0e99ffcf91683" translate="yes" xml:space="preserve">
          <source>The new playground now supports many new options including:</source>
          <target state="translated">新しい遊び場では、以下のような多くの新しいオプションをサポートするようになりました。</target>
        </trans-unit>
        <trans-unit id="68e11c2fb3a7db4e23da7d9de3e1a26ceae03748" translate="yes" xml:space="preserve">
          <source>The nightlies are available on &lt;a href=&quot;https://www.myget.org/gallery/typescript-preview&quot;&gt;www.myget.org&lt;/a&gt;.</source>
          <target state="translated">ナイトリーはで利用可能である&lt;a href=&quot;https://www.myget.org/gallery/typescript-preview&quot;&gt;www.myget.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb8de4c955d33fe91a7e4cbce1b7361bd5b2b3a3" translate="yes" xml:space="preserve">
          <source>The nightly build currently does not include the full plugin setup, but we are working on publishing an installer on a nightly basis as well.</source>
          <target state="translated">現在のところ、毎晩のビルドには完全なプラグインのセットアップは含まれていませんが、インストーラーを毎晩のように公開する作業を行っています。</target>
        </trans-unit>
        <trans-unit id="cfcfc96df71a12a29b5ce210c72d3e03c563d868" translate="yes" xml:space="preserve">
          <source>The old behavior still remains the same if given a directory - the compiler will try to find a file in the directory named &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="translated">ディレクトリを指定した場合、以前の動作は同じままです-コンパイラは &lt;code&gt;tsconfig.json&lt;/code&gt; という名前のディレクトリでファイルを見つけようとします。</target>
        </trans-unit>
        <trans-unit id="8b20ba860bfef9c7687f7310f99a76fe76d3783b" translate="yes" xml:space="preserve">
          <source>The order of specifying spread operations determines what properties end up in the resulting object; properties in later spreads &amp;ldquo;win out&amp;rdquo; over previously created properties.</source>
          <target state="translated">スプレッド操作を指定する順序により、結果のオブジェクトに含まれるプロパティが決まります。後でのプロパティは、以前に作成されたプロパティに「勝ち」ます。</target>
        </trans-unit>
        <trans-unit id="e7c876e1891bde60e537d27b5754b63af03257e0" translate="yes" xml:space="preserve">
          <source>The ordinal index of the parameter in the function&amp;rsquo;s parameter list.</source>
          <target state="translated">関数のパラメーターリスト内のパラメーターの序数インデックス。</target>
        </trans-unit>
        <trans-unit id="fb4cf9f813aa96ef2c61a94ad9fdf59d13dba821" translate="yes" xml:space="preserve">
          <source>The other change is that enum types themselves effectively become a &lt;em&gt;union&lt;/em&gt; of each enum member. While we haven&amp;rsquo;t discussed &lt;a href=&quot;advanced-types#union-types&quot;&gt;union types&lt;/a&gt; yet, all that you need to know is that with union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself. Because of that, TypeScript can catch silly bugs where we might be comparing values incorrectly. For example:</source>
          <target state="translated">もう1つの変更点は、列挙型自体が実質的に各列挙型メンバーの&lt;em&gt;結合&lt;/em&gt;になることです。&lt;a href=&quot;advanced-types#union-types&quot;&gt;ユニオンタイプ&lt;/a&gt;についてはまだ説明していませんが、ユニオン列挙型を使用すると、型システムは列挙型自体に存在する値の正確なセットを知っているという事実を活用できることを知っておく必要があります。そのため、TypeScriptは、値を誤って比較している可能性がある愚かなバグをキャッチできます。例えば：</target>
        </trans-unit>
        <trans-unit id="3a3f850fae27464de0a91f4fe484b577d056f476" translate="yes" xml:space="preserve">
          <source>The other change is that enum types themselves effectively become a &lt;em&gt;union&lt;/em&gt; of each enum member. With union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself. Because of that, TypeScript can catch bugs where we might be comparing values incorrectly. For example:</source>
          <target state="translated">もう1つの変更点は、列挙型自体が事実上各列挙メンバーの&lt;em&gt;和集合&lt;/em&gt;になることです。ユニオン列挙型を使用すると、型システムは、列挙型自体に存在する値の正確なセットを知っているという事実を活用できます。そのため、TypeScriptは、値を誤って比較している可能性があるバグを検出できます。例えば：</target>
        </trans-unit>
        <trans-unit id="87a6d3fa93df1a7b5718c28d49fe2488fc9f01eb" translate="yes" xml:space="preserve">
          <source>The other new ES6 declaration type supported in TypeScript is &lt;code&gt;const&lt;/code&gt;. A &lt;code&gt;const&lt;/code&gt; variable may not be assigned to, and must be initialized where it is declared. This is useful for declarations where you don&amp;rsquo;t want to change the value after its initialization:</source>
          <target state="translated">TypeScriptでサポートされているもう1つの新しいES6宣言型は &lt;code&gt;const&lt;/code&gt; です。 &lt;code&gt;const&lt;/code&gt; 変数をに割り当てることができず、それが宣言されている場所を初期化する必要があります。これは、初期化後に値を変更したくない宣言に役立ちます。</target>
        </trans-unit>
        <trans-unit id="e032670f94ed341d763142ae7b65b1fabd05bbb1" translate="yes" xml:space="preserve">
          <source>The other type of assertion signature doesn&amp;rsquo;t check for a condition, but instead tells TypeScript that a specific variable or property has a different type.</source>
          <target state="translated">他のタイプのアサーションシグネチャは条件をチェックせず、代わりに特定の変数またはプロパティが異なるタイプであることをTypeScriptに通知します。</target>
        </trans-unit>
        <trans-unit id="26c97f765ee648970cd74d22ecbbec1a076a2371" translate="yes" xml:space="preserve">
          <source>The other version is the &amp;ldquo;angle-bracket&amp;rdquo; syntax:</source>
          <target state="translated">もう1つのバージョンは、「山かっこ」構文です。</target>
        </trans-unit>
        <trans-unit id="3c65d0a0ca356ee8f50f381bfb9e081e37ee13c6" translate="yes" xml:space="preserve">
          <source>The pattern relies on using Generics with class inheritance to extend a base class. TypeScript&amp;rsquo;s best mixin support is done via the class expression pattern. You can read more about how this pattern works in &lt;a href=&quot;https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/&quot;&gt;JavaScript here&lt;/a&gt;.</source>
          <target state="translated">このパターンは、クラス継承を伴うジェネリックスを使用して基本クラスを拡張することに依存しています。TypeScriptの最高のミックスインサポートは、クラス式パターンを介して行われます。このパターンが&lt;a href=&quot;https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/&quot;&gt;JavaScriptで&lt;/a&gt;どのように機能するかについて詳しくは、こちらをご覧ください。</target>
        </trans-unit>
        <trans-unit id="eda209051691c244644fa70c53c6b169301d940d" translate="yes" xml:space="preserve">
          <source>The popular library D3 defines its functionality in a global object called &lt;code&gt;d3&lt;/code&gt;. Because this library is loaded through a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag (instead of a module loader), its declaration uses namespaces to define its shape. For the TypeScript compiler to see this shape, we use an ambient namespace declaration. For example, we could begin writing it as follows:</source>
          <target state="translated">人気のライブラリD3は、 &lt;code&gt;d3&lt;/code&gt; と呼ばれるグローバルオブジェクトでその機能を定義します。このライブラリは（モジュールローダーではなく） &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグを介して読み込まれるため、その宣言では名前空間を使用して形状を定義します。TypeScriptコンパイラーがこの形を見るには、アンビエント名前空間宣言を使用します。たとえば、次のように書き始めることができます。</target>
        </trans-unit>
        <trans-unit id="97b95eb4ae7f59dc40bbd1fbc533cb87a64d1c85" translate="yes" xml:space="preserve">
          <source>The preceding two types are equivalent to the TypeScript types &lt;code&gt;{ [x: string]: number }&lt;/code&gt; and &lt;code&gt;{ [x: number]: any }&lt;/code&gt;. The compiler understands both syntaxes.</source>
          <target state="translated">上記の2つのタイプは、TypeScriptタイプ &lt;code&gt;{ [x: string]: number }&lt;/code&gt; および &lt;code&gt;{ [x: number]: any }&lt;/code&gt; と同等です。コンパイラは両方の構文を理解します。</target>
        </trans-unit>
        <trans-unit id="38c72ee7b721075b6b228593c6729fd98fa3d861" translate="yes" xml:space="preserve">
          <source>The preceding two types are equivalent to the Typescript types &lt;code&gt;{ [x: string]: number }&lt;/code&gt; and &lt;code&gt;{ [x: number]: any }&lt;/code&gt;. The compiler understands both syntaxes.</source>
          <target state="translated">上記の2つのタイプは、Typescriptタイプ &lt;code&gt;{ [x: string]: number }&lt;/code&gt; および &lt;code&gt;{ [x: number]: any }&lt;/code&gt; と同等です。コンパイラは両方の構文を理解します。</target>
        </trans-unit>
        <trans-unit id="c60fafa2ef6625ee2c00e943de3aab278fabf81d" translate="yes" xml:space="preserve">
          <source>The presence of a &lt;code&gt;tsconfig.json&lt;/code&gt; file in a directory indicates that the directory is the root of a TypeScript project. The &lt;code&gt;tsconfig.json&lt;/code&gt; file specifies the root files and the compiler options required to compile the project.</source>
          <target state="translated">ディレクトリに &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルが存在する場合は、そのディレクトリがTypeScriptプロジェクトのルートであることを示しています。 &lt;code&gt;tsconfig.json&lt;/code&gt; のファイルは、ルートファイルやプロジェクトをコンパイルするために必要なコンパイラオプションを指定します。</target>
        </trans-unit>
        <trans-unit id="aa67059f742d5b7173801d752e91479969530cea" translate="yes" xml:space="preserve">
          <source>The presence of a &lt;code&gt;tsconfig.json&lt;/code&gt; file in a directory indicates that the directory is the root of a TypeScript project. The &lt;code&gt;tsconfig.json&lt;/code&gt; file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:</source>
          <target state="translated">ディレクトリに &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルが存在することは、そのディレクトリがTypeScriptプロジェクトのルートであることを示しています。 &lt;code&gt;tsconfig.json&lt;/code&gt; のファイルは、ルートファイルやプロジェクトをコンパイルするために必要なコンパイラオプションを指定します。プロジェクトは、次のいずれかの方法でコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="a2cfab90b0c3ba6c1eea59f4039e7816d4601aa6" translate="yes" xml:space="preserve">
          <source>The problem with &lt;code&gt;padLeft&lt;/code&gt; in the above example is that its &lt;code&gt;padding&lt;/code&gt; parameter is typed as &lt;code&gt;any&lt;/code&gt;. That means that we can call it with an argument that&amp;rsquo;s neither a &lt;code&gt;number&lt;/code&gt; nor a &lt;code&gt;string&lt;/code&gt;, but TypeScript will be okay with it.</source>
          <target state="translated">上記の例の &lt;code&gt;padLeft&lt;/code&gt; の問題は、その &lt;code&gt;padding&lt;/code&gt; パラメーターが &lt;code&gt;any&lt;/code&gt; として入力されることです。つまり、 &lt;code&gt;number&lt;/code&gt; も &lt;code&gt;string&lt;/code&gt; でもない引数を使用して呼び出すことができますが、TypeScriptは問題ありません。</target>
        </trans-unit>
        <trans-unit id="088fad3bfe9085a4bf306d60f92061feba8a8ef7" translate="yes" xml:space="preserve">
          <source>The problem with &lt;code&gt;padLeft&lt;/code&gt; is that its &lt;code&gt;padding&lt;/code&gt; parameter is typed as &lt;code&gt;any&lt;/code&gt;. That means that we can call it with an argument that&amp;rsquo;s neither a &lt;code&gt;number&lt;/code&gt; nor a &lt;code&gt;string&lt;/code&gt;, but TypeScript will be okay with it.</source>
          <target state="translated">&lt;code&gt;padLeft&lt;/code&gt; の問題は、その &lt;code&gt;padding&lt;/code&gt; パラメータが &lt;code&gt;any&lt;/code&gt; として型指定されることです。つまり、 &lt;code&gt;number&lt;/code&gt; も &lt;code&gt;string&lt;/code&gt; でもない引数で呼び出すことができますが、TypeScriptでは問題ありません。</target>
        </trans-unit>
        <trans-unit id="25342fc4c0a8b53d44f277b4df381a59c493566a" translate="yes" xml:space="preserve">
          <source>The process of going from an infinite number of potential cases (there are an infinite number of possible string values) to a smaller, finite number of potential case (in &lt;code&gt;helloWorld&lt;/code&gt;&amp;rsquo;s case: 1) is called narrowing.</source>
          <target state="translated">無限の数の潜在的なケース（無限の数の可能な文字列値があります）から、より小さく、有限の数の潜在的なケース（ &lt;code&gt;helloWorld&lt;/code&gt; の場合：1）に移行するプロセスは、ナローイングと呼ばれます。</target>
        </trans-unit>
        <trans-unit id="1bb7381db8810d933065e806b992cda45878627e" translate="yes" xml:space="preserve">
          <source>The process of resolving these package names is similar to the process of resolving module names in an &lt;code&gt;import&lt;/code&gt; statement. An easy way to think of triple-slash-reference-types directives are as an &lt;code&gt;import&lt;/code&gt; for declaration packages.</source>
          <target state="translated">これらのパッケージ名を解決するプロセスは、 &lt;code&gt;import&lt;/code&gt; ステートメントでモジュール名を解決するプロセスと似ています。トリプルスラッシュ参照タイプディレクティブを考える簡単な方法は、宣言パッケージの &lt;code&gt;import&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="aafd5dd1f8eca4eda75bcd1718aa421a44d595dd" translate="yes" xml:space="preserve">
          <source>The process starts with a set of &lt;em&gt;root files&lt;/em&gt;; these are the file names specified on the command-line or in the &lt;code&gt;&quot;files&quot;&lt;/code&gt; list in the &lt;code&gt;tsconfig.json&lt;/code&gt; file. These root files are preprocessed in the same order they are specified. Before a file is added to the list, all triple-slash references in it are processed, and their targets included. Triple-slash references are resolved in a depth first manner, in the order they have been seen in the file.</source>
          <target state="translated">プロセスは、&lt;em&gt;ルートファイルの&lt;/em&gt;セットから始まり&lt;em&gt;ます&lt;/em&gt;。これらは、コマンドラインまたは &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルの &lt;code&gt;&quot;files&quot;&lt;/code&gt; リストで指定されたファイル名です。これらのルートファイルは、指定された順序で前処理されます。ファイルがリストに追加される前に、ファイル内のすべてのトリプルスラッシュ参照が処理され、そのターゲットが含まれます。トリプルスラッシュ参照は、ファイル内で表示された順序で、深さ優先の方法で解決されます。</target>
        </trans-unit>
        <trans-unit id="1064046bee0ce7e01c8bf16c1b03dac0a5d9f8ee" translate="yes" xml:space="preserve">
          <source>The program should print &amp;ldquo;Hello from TypeScript!&amp;ldquo;.</source>
          <target state="translated">プログラムは「HellofromTypeScript！」を出力するはずです。</target>
        </trans-unit>
        <trans-unit id="17ce755b0cdb23dc9be9ae1982b9a584f1e51772" translate="yes" xml:space="preserve">
          <source>The program should print &amp;ldquo;Hello from TypeScript!&amp;rdquo;.</source>
          <target state="translated">プログラムは「Hello from TypeScript！」を出力するはずです。</target>
        </trans-unit>
        <trans-unit id="fad1dae24f8de6bb5ace45589ded1976d7ba9b1d" translate="yes" xml:space="preserve">
          <source>The purpose of this guide is to teach you how to write a high-quality definition file. This guide is structured by showing documentation for some API, along with sample usage of that API, and explaining how to write the corresponding declaration.</source>
          <target state="translated">このガイドの目的は、高品質な定義ファイルの書き方を教えることです。このガイドは、あるAPIのドキュメントと、そのAPIの使用例を示し、対応する宣言の書き方を説明することで構成されています。</target>
        </trans-unit>
        <trans-unit id="0eccb935e6264e79e73c70e81e21a7c090643b4a" translate="yes" xml:space="preserve">
          <source>The reference tag here allows us to locate the declaration file that contains the declaration for the ambient module. This is how the &lt;code&gt;node.d.ts&lt;/code&gt; file that several of the TypeScript samples use is consumed.</source>
          <target state="translated">ここの参照タグにより、アンビエントモジュールの宣言を含む宣言ファイルを見つけることができます。これは、いくつかのTypeScriptサンプルが使用する &lt;code&gt;node.d.ts&lt;/code&gt; ファイルの使用方法です。</target>
        </trans-unit>
        <trans-unit id="71056ddd9a7d7a3d2b766c4d6ec8f63ddc99ad7f" translate="yes" xml:space="preserve">
          <source>The rest of this section assumes &lt;code&gt;typescript@next&lt;/code&gt; is already installed.</source>
          <target state="translated">このセクションの残りの部分では、 &lt;code&gt;typescript@next&lt;/code&gt; がすでにインストールされていることを前提としています。</target>
        </trans-unit>
        <trans-unit id="f21084484972497bb17b43e1dd1639f1309df4de" translate="yes" xml:space="preserve">
          <source>The result will be a file &lt;code&gt;greeter.js&lt;/code&gt; which contains the same JavaScript that you fed in. We&amp;rsquo;re up and running using TypeScript in our JavaScript app!</source>
          <target state="translated">結果は、入力したのと同じJavaScriptを含む &lt;code&gt;greeter.js&lt;/code&gt; ファイルになります。JavaScriptアプリでTypeScriptを使用して実行しています。</target>
        </trans-unit>
        <trans-unit id="55cd4e9d5c07da56c2642a3c67f20fdea4efaf76" translate="yes" xml:space="preserve">
          <source>The resulting merged declaration of &lt;code&gt;Document&lt;/code&gt; will be the following:</source>
          <target state="translated">マージされた &lt;code&gt;Document&lt;/code&gt; 宣言は次のようになります。</target>
        </trans-unit>
        <trans-unit id="5a7ebfe9ca74c5339d3d3f99e13edb4401f1c213" translate="yes" xml:space="preserve">
          <source>The resulting type of the property.</source>
          <target state="translated">プロパティの結果の型。</target>
        </trans-unit>
        <trans-unit id="fb503a1aeb68c9cb323a5ced50b16d97adf33167" translate="yes" xml:space="preserve">
          <source>The results are then called as functions from bottom-to-top.</source>
          <target state="translated">そして、その結果を下から上へ関数として呼び出します。</target>
        </trans-unit>
        <trans-unit id="6d00e7101737114bac2225ce67379aba61f8af21" translate="yes" xml:space="preserve">
          <source>The return type of a call uses the contextual type for inferences, so the compiler infers that &lt;code&gt;T={ inference: string }&lt;/code&gt;.</source>
          <target state="translated">呼び出しの戻り値の型は推論にコンテキスト型を使用するため、コンパイラは &lt;code&gt;T={ inference: string }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9eb08a8c7770e6b9f8872c6109a3df7ec5c1b48" translate="yes" xml:space="preserve">
          <source>The return value of the parameter decorator is ignored.</source>
          <target state="translated">パラメータデコレータの戻り値は無視されます。</target>
        </trans-unit>
        <trans-unit id="ec62e92022db3b095789b1a8bc611f9661c25a8c" translate="yes" xml:space="preserve">
          <source>The right side of the &lt;code&gt;instanceof&lt;/code&gt; needs to be a constructor function, and TypeScript will narrow down to:</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; の右側はコンストラクタ関数である必要があり、TypeScriptは次のように絞り込みます。</target>
        </trans-unit>
        <trans-unit id="9bdcb387eac602c5c7979ebf6b526180243170a8" translate="yes" xml:space="preserve">
          <source>The same &lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;footnote&lt;/a&gt; applies to these modules.</source>
          <target state="translated">同じ&lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;脚注&lt;/a&gt;がこれらのモジュールに適用されます。</target>
        </trans-unit>
        <trans-unit id="e77f3244150969c173e8b081e427e7953f3f7fd4" translate="yes" xml:space="preserve">
          <source>The same goes for &lt;a href=&quot;https://github.com/TypeStrong/ts-loader&quot;&gt;awesome-typescript-loader&lt;/a&gt;, another TypeScript loader for Webpack. You can read more about the differences between the two &lt;a href=&quot;https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">同じことが、Webpack用の別のTypeScriptローダーである&lt;a href=&quot;https://github.com/TypeStrong/ts-loader&quot;&gt;awesome-typescript-loader&lt;/a&gt;にも当てはまります。2つの違いについて詳しくは、&lt;a href=&quot;https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader&quot;&gt;こちらをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f7fb9969f8be2dbbfcedab928e0115d7fa79657a" translate="yes" xml:space="preserve">
          <source>The same goes for &lt;a href=&quot;https://github.com/TypeStrong/ts-loader&quot;&gt;ts-loader&lt;/a&gt;, another TypeScript loader for Webpack. You can read more about the differences between the two &lt;a href=&quot;https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">同じことがのために行く&lt;a href=&quot;https://github.com/TypeStrong/ts-loader&quot;&gt;TS-ローダー&lt;/a&gt;、WebPACKのための別の活字体ローダー。2つの違いの詳細については、&lt;a href=&quot;https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader&quot;&gt;こちらをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00fc4820883d5fd03b19870a02ddabbb40e34c99" translate="yes" xml:space="preserve">
          <source>The same is true for optional properties:</source>
          <target state="translated">オプションのプロパティについても同様です。</target>
        </trans-unit>
        <trans-unit id="43f24dd384fa12ae0f07c7c778176cd12dddfc84" translate="yes" xml:space="preserve">
          <source>The same rule for assignment is used when checking function call arguments:</source>
          <target state="translated">関数呼び出しの引数をチェックする際には、代入と同じルールを使用します。</target>
        </trans-unit>
        <trans-unit id="addbe812d1672c5e4f322e5d5a3556adcb36610e" translate="yes" xml:space="preserve">
          <source>The same sort of tracking is now also done for empty arrays.</source>
          <target state="translated">空の配列に対しても同様のトラッキングが行われるようになりました。</target>
        </trans-unit>
        <trans-unit id="ccde6d73f9a8b313307d39b074524c1e2e182522" translate="yes" xml:space="preserve">
          <source>The same way that ordinary tuples are types that extend from &lt;code&gt;Array&lt;/code&gt; - a tuple with elements of type &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;, &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;, &amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; extends from &lt;code&gt;Array&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; \| ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; - &lt;code&gt;readonly&lt;/code&gt; tuples are types that extend from &lt;code&gt;ReadonlyArray&lt;/code&gt;. So a &lt;code&gt;readonly&lt;/code&gt; tuple with elements &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;, &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;, &amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; extends from &lt;code&gt;ReadonlyArray&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; | ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt;.</source>
          <target state="translated">通常のタプルが &lt;code&gt;Array&lt;/code&gt; から拡張されるタイプであるのと同じ方法-タイプ &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; 、 &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; 、&amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; 要素を持つタプルは &lt;code&gt;Array&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; \| ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; から拡張されます T &lt;sub&gt;2&lt;/sub&gt; \ | ... T &lt;sub&gt;N&lt;/sub&gt; &amp;gt; - &lt;code&gt;readonly&lt;/code&gt; タプルから拡張型である &lt;code&gt;ReadonlyArray&lt;/code&gt; 。したがって、要素 &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;1&lt;/sub&gt;、 &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;2&lt;/sub&gt;、&amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;nを&lt;/sub&gt;持つ &lt;code&gt;readonly&lt;/code&gt; タプルは、 &lt;code&gt;ReadonlyArray&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; | ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; &lt;sub&gt;1&lt;/sub&gt; \ |から拡張されます。T &lt;sub&gt;2&lt;/sub&gt; | ... T &lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="739a9969f90dca0e3b9321fb87d6ba49413bb58c" translate="yes" xml:space="preserve">
          <source>The second assignment is an error, because &lt;code&gt;y&lt;/code&gt; has a required second parameter that &lt;code&gt;x&lt;/code&gt; does not have, so the assignment is disallowed.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; には &lt;code&gt;x&lt;/code&gt; にはない2番目の必須パラメーターがあるため、2番目の割り当てはエラーとなり、割り当ては許可されません。</target>
        </trans-unit>
        <trans-unit id="3f4a4a115d577adebcffab99f90c2599ff896791" translate="yes" xml:space="preserve">
          <source>The second block creates the following name meanings:</source>
          <target state="translated">2 番目のブロックは、以下の名前の意味を作成します。</target>
        </trans-unit>
        <trans-unit id="bb7b2f9c2d9be074838810a47661fb544c2c7a54" translate="yes" xml:space="preserve">
          <source>The second example failed because the array&amp;rsquo;s &lt;code&gt;find&lt;/code&gt; function looks a bit like this simplification:</source>
          <target state="translated">2番目の例は、配列の &lt;code&gt;find&lt;/code&gt; 関数が次の単純化に少し似ているために失敗しました。</target>
        </trans-unit>
        <trans-unit id="e0467e5b0666d2b81ecc53a34087b88185a9207e" translate="yes" xml:space="preserve">
          <source>The second method uses the &lt;code&gt;never&lt;/code&gt; type that the compiler uses to check for exhaustiveness:</source>
          <target state="translated">2番目の方法は、コンパイラーが網羅性をチェックするために使用する &lt;code&gt;never&lt;/code&gt; タイプを使用します。</target>
        </trans-unit>
        <trans-unit id="49820d40f361e464b077d6cf772f08f976135fd0" translate="yes" xml:space="preserve">
          <source>The second operator is &lt;code&gt;T[K]&lt;/code&gt;, the &lt;strong&gt;indexed access operator&lt;/strong&gt;. Here, the type syntax reflects the expression syntax. That means that &lt;code&gt;person['name']&lt;/code&gt; has the type &lt;code&gt;Person['name']&lt;/code&gt; &amp;mdash; which in our example is just &lt;code&gt;string&lt;/code&gt;. However, just like index type queries, you can use &lt;code&gt;T[K]&lt;/code&gt; in a generic context, which is where its real power comes to life. You just have to make sure that the type variable &lt;code&gt;K extends keyof T&lt;/code&gt;. Here&amp;rsquo;s another example with a function named &lt;code&gt;getProperty&lt;/code&gt;.</source>
          <target state="translated">2番目の演算子は、&lt;strong&gt;インデックス付きアクセス演算&lt;/strong&gt;子である &lt;code&gt;T[K]&lt;/code&gt; です。ここで、型構文は式構文を反映しています。つまり、 &lt;code&gt;person['name']&lt;/code&gt; の型は &lt;code&gt;Person['name']&lt;/code&gt; です。これは、この例では単なる &lt;code&gt;string&lt;/code&gt; です。ただし、インデックスタイプのクエリと同様に、 &lt;code&gt;T[K]&lt;/code&gt; は一般的なコンテキストで使用できます。型変数 &lt;code&gt;K extends keyof T&lt;/code&gt; することを確認する必要があります。 &lt;code&gt;getProperty&lt;/code&gt; という名前の関数を使用した別の例を次に示します。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="395e59dd3d587260540f24beb9cdd8492f3b1ca0" translate="yes" xml:space="preserve">
          <source>The second operator is &lt;code&gt;T[K]&lt;/code&gt;, the &lt;strong&gt;indexed access operator&lt;/strong&gt;. Here, the type syntax reflects the expression syntax. That means that &lt;code&gt;taxi[&quot;manufacturer&quot;]&lt;/code&gt; has the type &lt;code&gt;Car[&quot;manufacturer&quot;]&lt;/code&gt; &amp;mdash; which in our example is just &lt;code&gt;string&lt;/code&gt;. However, just like index type queries, you can use &lt;code&gt;T[K]&lt;/code&gt; in a generic context, which is where its real power comes to life. You just have to make sure that the type variable &lt;code&gt;K extends keyof T&lt;/code&gt;. Here&amp;rsquo;s another example with a function named &lt;code&gt;getProperty&lt;/code&gt;.</source>
          <target state="translated">2番目の演算子は &lt;code&gt;T[K]&lt;/code&gt; で、&lt;strong&gt;インデックス付きアクセス演算子&lt;/strong&gt;です。ここで、型構文は式構文を反映しています。つまり、 &lt;code&gt;taxi[&quot;manufacturer&quot;]&lt;/code&gt; のタイプは &lt;code&gt;Car[&quot;manufacturer&quot;]&lt;/code&gt; あり、この例では単なる &lt;code&gt;string&lt;/code&gt; です。ただし、インデックスタイプのクエリと同様に、 &lt;code&gt;T[K]&lt;/code&gt; は一般的なコンテキストで使用できます。ここで、その真の力が発揮されます。型変数 &lt;code&gt;K extends keyof T&lt;/code&gt; していることを確認する必要があります。 &lt;code&gt;getProperty&lt;/code&gt; という名前の関数を使用した別の例を次に示します。</target>
        </trans-unit>
        <trans-unit id="d22435f751c04c05b24d63f2b79d13b3746e4a00" translate="yes" xml:space="preserve">
          <source>The second part is the return type. We make it clear which is the return type by using a fat arrow (&lt;code&gt;=&amp;gt;&lt;/code&gt;) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn&amp;rsquo;t return a value, you would use &lt;code&gt;void&lt;/code&gt; instead of leaving it off.</source>
          <target state="translated">2番目の部分は戻り値の型です。パラメータと戻り値の型の間に太い矢印（ &lt;code&gt;=&amp;gt;&lt;/code&gt; ）を使用して、戻り値の型を明確にします。前述のように、これは関数タイプの必須部分であるため、関数が値を返さない場合は、 &lt;code&gt;void&lt;/code&gt; のままにする代わりにvoidを使用します。</target>
        </trans-unit>
        <trans-unit id="ee75b3015ae814b5df851e6a3b58e1c66c58fec3" translate="yes" xml:space="preserve">
          <source>The second part is the return type. We make it clear which is the return type by using an arrow (&lt;code&gt;=&amp;gt;&lt;/code&gt;) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn&amp;rsquo;t return a value, you would use &lt;code&gt;void&lt;/code&gt; instead of leaving it off.</source>
          <target state="translated">2番目の部分は戻り値の型です。パラメータと戻り値の型の間に矢印（ &lt;code&gt;=&amp;gt;&lt;/code&gt; ）を使用して、どちらが戻り値の型であるかを明確にします。前述のように、これは関数型の必須部分であるため、関数が値を返さない場合は、省略せずに &lt;code&gt;void&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="e07f825349d9c56d700585b88ad266691534c76a" translate="yes" xml:space="preserve">
          <source>The second reason is when a consumer uses the &amp;ldquo;strict null checking&amp;rdquo; feature of TypeScript. Because unspecified parameters appear as &lt;code&gt;undefined&lt;/code&gt; in JavaScript, it&amp;rsquo;s usually fine to pass an explicit &lt;code&gt;undefined&lt;/code&gt; to a function with optional arguments. This code, for example, should be OK under strict nulls:</source>
          <target state="translated">2番目の理由は、コンシューマがTypeScriptの「厳密なnullチェック」機能を使用する場合です。JavaScriptで &lt;code&gt;undefined&lt;/code&gt; 指定のパラメーターは未定義として表示されるため、通常、明示的な &lt;code&gt;undefined&lt;/code&gt; をオプションの引数を持つ関数に渡しても問題ありません。たとえば、このコードは厳密なnullのもとでは問題ありません。</target>
        </trans-unit>
        <trans-unit id="ddaeafe60f623f16494e16010fd0027a89f657dc" translate="yes" xml:space="preserve">
          <source>The second way is also perhaps the most common. Here we use &lt;em&gt;type argument inference&lt;/em&gt; &amp;mdash; that is, we want the compiler to set the value of &lt;code&gt;T&lt;/code&gt; for us automatically based on the type of the argument we pass in:</source>
          <target state="translated">2番目の方法もおそらく最も一般的です。ここでは、&lt;em&gt;型引数の推論&lt;/em&gt;を使用します。つまり、渡す引数の型に基づいて、コンパイラが &lt;code&gt;T&lt;/code&gt; の値を自動的に設定するようにします。</target>
        </trans-unit>
        <trans-unit id="3fd4b2e06d8d3d430b175e5ddeea0b896410301c" translate="yes" xml:space="preserve">
          <source>The second way is also perhaps the most common. Here we use &lt;em&gt;type argument inference&lt;/em&gt; &amp;ndash; that is, we want the compiler to set the value of &lt;code&gt;T&lt;/code&gt; for us automatically based on the type of the argument we pass in:</source>
          <target state="translated">2番目の方法もおそらく最も一般的です。ここでは、&lt;em&gt;型引数の推論&lt;/em&gt;を使用します。つまり、コンパイラーに、渡す引数の型に基づいて &lt;code&gt;T&lt;/code&gt; の値を自動的に設定させます。</target>
        </trans-unit>
        <trans-unit id="4736ec61bf8078d3ad2a342c635cb7fc5c10d088" translate="yes" xml:space="preserve">
          <source>The second way uses a generic array type, &lt;code&gt;Array&amp;lt;elemType&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">2番目の方法では、ジェネリック配列タイプ &lt;code&gt;Array&amp;lt;elemType&amp;gt;&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="dc5448e0198755908cad47574593cb637412ed51" translate="yes" xml:space="preserve">
          <source>The shape-matching only requires a subset of the object&amp;rsquo;s fields to match.</source>
          <target state="translated">形状マッチングでは、オブジェクトのフィールドのサブセットのみをマッチングする必要があります。</target>
        </trans-unit>
        <trans-unit id="99b58ef085b8f5cfafe10b2f70b1c603ae679699" translate="yes" xml:space="preserve">
          <source>The simplest form of destructuring is array destructuring assignment:</source>
          <target state="translated">破壊の最も単純な形式は、配列破壊の代入です。</target>
        </trans-unit>
        <trans-unit id="81722fee1d2fb56b682b67ac28f4e353808fb7d3" translate="yes" xml:space="preserve">
          <source>The simplest, and perhaps most common, type of declaration merging is interface merging. At the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name.</source>
          <target state="translated">宣言のマージで最も単純で、おそらく最も一般的なタイプは、インターフェイスのマージです。最も基本的なレベルでは、両方の宣言のメンバを同じ名前の単一のインターフェイスに機械的に結合します。</target>
        </trans-unit>
        <trans-unit id="13408208368716d434a2faec6f70e98867378392" translate="yes" xml:space="preserve">
          <source>The snippet above is an example of type inference, explained later in the handbook.</source>
          <target state="translated">上のスニペットは、ハンドブックで後ほど説明する型推論の例です。</target>
        </trans-unit>
        <trans-unit id="ecda9eae0951be3e74181af1517711ce10156b9c" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;ESNext&lt;/code&gt; value refers to the highest version your version of TypeScript supports. This setting should be used with caution, since it doesn&amp;rsquo;t mean the same thing between different TypeScript versions and can make upgrades less predictable.</source>
          <target state="translated">特別な &lt;code&gt;ESNext&lt;/code&gt; 値は、TypeScriptのバージョンがサポートする最高バージョンを参照します。この設定は、異なるTypeScriptバージョン間で同じことを意味するわけではなく、アップグレードの予測が困難になる可能性があるため、注意して使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="f58e24702b78cd5b8941ef478b1489c1cd7b5d65" translate="yes" xml:space="preserve">
          <source>The spread operator also works:</source>
          <target state="translated">スプレッド演算子も効きます。</target>
        </trans-unit>
        <trans-unit id="306da80508d5bf827e829e72fb7591269adf0a66" translate="yes" xml:space="preserve">
          <source>The spread operator is the opposite of destructuring. It allows you to spread an array into another array, or an object into another object. For example:</source>
          <target state="translated">スプレッド演算子は、デストラクチャリングの反対語です。これにより、配列を別の配列に広げたり、オブジェクトを別のオブジェクトに広げたりすることができます。例えば、次のようになります。</target>
        </trans-unit>
        <trans-unit id="347a245a04ce2dd0b84ae05cdc6937a6bfd2e8ec" translate="yes" xml:space="preserve">
          <source>The strategy for how entire directory trees are watched under systems that lack recursive file-watching functionality.</source>
          <target state="translated">再帰的なファイルウォッチング機能を持たないシステムの下で、ディレクトリツリー全体がどのように監視されるかの戦略。</target>
        </trans-unit>
        <trans-unit id="ed87e7da393e9ebf4b65dddbe2b2c6508ed02ce5" translate="yes" xml:space="preserve">
          <source>The strategy for how individual files are watched.</source>
          <target state="translated">個々のファイルをどのように視聴するかの戦略。</target>
        </trans-unit>
        <trans-unit id="f885061b123a3fe063f3c9ed899b1d23df83d618" translate="yes" xml:space="preserve">
          <source>The strategy the compiler is following</source>
          <target state="translated">コンパイラは次のような戦略をとっています。</target>
        </trans-unit>
        <trans-unit id="c3d17817e55b210acd9bce6627aec4a4dd9620cb" translate="yes" xml:space="preserve">
          <source>The stricter checking applies to all function types, &lt;em&gt;except&lt;/em&gt; those originating in method or constructor declarations. Methods are excluded specifically to ensure generic classes and interfaces (such as &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;) continue to mostly relate covariantly.</source>
          <target state="translated">より厳密なチェックは、メソッドまたはコンストラクター宣言で発生したもの&lt;em&gt;を除い&lt;/em&gt;て、すべての関数タイプに適用されます。ジェネリッククラスとインターフェイス（ &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; ）がほぼ共変的に関連し続けることを保証するために、メソッドは特に除外されています。</target>
        </trans-unit>
        <trans-unit id="9257c34b0251760de9cf13098d8b8dab286b41c2" translate="yes" xml:space="preserve">
          <source>The string literal union &lt;code&gt;Keys&lt;/code&gt;, which contains the names of properties to iterate over.</source>
          <target state="translated">文字列リテラルのユニオン &lt;code&gt;Keys&lt;/code&gt; には、反復するプロパティの名前が含まれています。</target>
        </trans-unit>
        <trans-unit id="712aa4a776f92297417c2dad5e9739407277009b" translate="yes" xml:space="preserve">
          <source>The supported glob wildcards are:</source>
          <target state="translated">サポートされている glob ワイルドカードは以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="727e992e3d1e12337dc7c95d559ff4b4fccf59be" translate="yes" xml:space="preserve">
          <source>The syntax resembles the syntax for index signatures with a &lt;code&gt;for .. in&lt;/code&gt; inside. There are three parts:</source>
          <target state="translated">構文は、内部に &lt;code&gt;for .. in&lt;/code&gt; を含むインデックスシグネチャの構文に似ています。3つの部分があります。</target>
        </trans-unit>
        <trans-unit id="42212d0e88124e6c9e85e3c6d2679e2ebfc79e8e" translate="yes" xml:space="preserve">
          <source>The syntax should look familiar if you&amp;rsquo;ve used C# or Java before. We declare a new class &lt;code&gt;Greeter&lt;/code&gt;. This class has three members: a property called &lt;code&gt;greeting&lt;/code&gt;, a constructor, and a method &lt;code&gt;greet&lt;/code&gt;.</source>
          <target state="translated">以前にC＃またはJavaを使用したことがある場合、構文はおなじみのはずです。新しいクラス &lt;code&gt;Greeter&lt;/code&gt; を宣言します。このクラスには3つのメンバーがあります。 &lt;code&gt;greet&lt;/code&gt; 、 &lt;code&gt;greeting&lt;/code&gt; と呼ばれるプロパティー、コンストラクター、およびメソッドgreetです。</target>
        </trans-unit>
        <trans-unit id="04a97906fd0b03483a7f8d7138ad2f0a923a35cf" translate="yes" xml:space="preserve">
          <source>The template file &lt;a href=&quot;templates/global-d-ts&quot;&gt;&lt;code&gt;global.d.ts&lt;/code&gt;&lt;/a&gt; defines an example library &lt;code&gt;myLib&lt;/code&gt;. Be sure to read the &lt;a href=&quot;#preventing-name-conflicts&quot;&gt;&amp;ldquo;Preventing Name Conflicts&amp;rdquo; footnote&lt;/a&gt;.</source>
          <target state="translated">テンプレートファイル&lt;a href=&quot;templates/global-d-ts&quot;&gt; &lt;code&gt;global.d.ts&lt;/code&gt; &lt;/a&gt;は、サンプルライブラリ &lt;code&gt;myLib&lt;/code&gt; を定義します。&lt;a href=&quot;#preventing-name-conflicts&quot;&gt;「名前の競合の防止」脚注を&lt;/a&gt;必ずお読みください。</target>
        </trans-unit>
        <trans-unit id="4661397a216a4756287dc9945d770b9dd77b8574" translate="yes" xml:space="preserve">
          <source>The template file &lt;a href=&quot;templates/global-plugin-d-ts&quot;&gt;&lt;code&gt;global.d.ts&lt;/code&gt;&lt;/a&gt; defines an example library &lt;code&gt;myLib&lt;/code&gt;. Be sure to read the &lt;a href=&quot;#preventing-name-conflicts&quot;&gt;&amp;ldquo;Preventing Name Conflicts&amp;rdquo; footnote&lt;/a&gt;.</source>
          <target state="translated">テンプレートファイル&lt;a href=&quot;templates/global-plugin-d-ts&quot;&gt; &lt;code&gt;global.d.ts&lt;/code&gt; &lt;/a&gt;は、サンプルライブラリ &lt;code&gt;myLib&lt;/code&gt; を定義します。&lt;a href=&quot;#preventing-name-conflicts&quot;&gt;「名前の競合の防止」の脚注を&lt;/a&gt;必ずお読みください。</target>
        </trans-unit>
        <trans-unit id="5291791ebba8241b8df5e64ba1807928b332ea67" translate="yes" xml:space="preserve">
          <source>The test files import the implementation files and do some testing:</source>
          <target state="translated">テストファイルは実装ファイルをインポートしてテストを行います。</target>
        </trans-unit>
        <trans-unit id="1d502ba678972d16c080f4276cf5add29d80b7a4" translate="yes" xml:space="preserve">
          <source>The three interfaces will merge to create a single declaration as so:</source>
          <target state="translated">3つのインターフェイスをマージして、このように1つの宣言を作成します。</target>
        </trans-unit>
        <trans-unit id="ace0f93a6c178ee20b3542e125ca7fdce8f70590" translate="yes" xml:space="preserve">
          <source>The top-level module here &lt;code&gt;Shapes&lt;/code&gt; wraps up &lt;code&gt;Triangle&lt;/code&gt; and &lt;code&gt;Square&lt;/code&gt; for no reason. This is confusing and annoying for consumers of your module:</source>
          <target state="translated">ここのトップレベルのモジュール &lt;code&gt;Shapes&lt;/code&gt; は、理由もなく &lt;code&gt;Triangle&lt;/code&gt; と &lt;code&gt;Square&lt;/code&gt; をラップします。これは、モジュールのコンシューマーにとって混乱を招く煩わしいものです。</target>
        </trans-unit>
        <trans-unit id="7b5e597f445939620e293134a759f62224c6c2bd" translate="yes" xml:space="preserve">
          <source>The two biggest changes are the following:</source>
          <target state="translated">大きく変わったのは以下の2点です。</target>
        </trans-unit>
        <trans-unit id="d3d5cbb8071ba1e4008349316f8601cde19debcd" translate="yes" xml:space="preserve">
          <source>The two options left more to be desired; bundling the helpers in every file was a pain point for customers trying to keep their package size small. And not including helpers, meant customers had to maintain their own helpers library.</source>
          <target state="translated">ヘルパーをすべてのファイルにバンドルすることは、パッケージサイズを小さくしようとしている顧客にとって苦痛でした。また、ヘルパーを含まないということは、顧客が独自のヘルパーライブラリを維持しなければならないことを意味していました。</target>
        </trans-unit>
        <trans-unit id="a8a8ad0b07b6aeac0ba2a5e2ec35773596d69e43" translate="yes" xml:space="preserve">
          <source>The two samples are equivalent. Using one over the other is mostly a choice of preference; however, when using TypeScript with JSX, only &lt;code&gt;as&lt;/code&gt;-style assertions are allowed.</source>
          <target state="translated">2つのサンプルは同等です。どちらを使用するかは、主に好みの選択です。しかし、場合にのみ、JSXと活字体を使用し &lt;code&gt;as&lt;/code&gt; スタイルのアサーションが許可されています。</target>
        </trans-unit>
        <trans-unit id="9a2b71237e4b11c5e8ec290df36ff6e89dc1089c" translate="yes" xml:space="preserve">
          <source>The type above means when &lt;code&gt;T&lt;/code&gt; is assignable to &lt;code&gt;U&lt;/code&gt; the type is &lt;code&gt;X&lt;/code&gt;, otherwise the type is &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">上記のタイプは、 &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;U&lt;/code&gt; に割り当て可能な場合、タイプは &lt;code&gt;X&lt;/code&gt; であり、そうでない場合、タイプは &lt;code&gt;Y&lt;/code&gt; であることを意味します。</target>
        </trans-unit>
        <trans-unit id="c4716786bdfd77dd152da96b6dedb84b8495378a" translate="yes" xml:space="preserve">
          <source>The type checker checks the call to &lt;code&gt;printLabel&lt;/code&gt;. The &lt;code&gt;printLabel&lt;/code&gt; function has a single parameter that requires that the object passed in has a property called &lt;code&gt;label&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. Notice that our object actually has more properties than this, but the compiler only checks that &lt;em&gt;at least&lt;/em&gt; the ones required are present and match the types required. There are some cases where TypeScript isn&amp;rsquo;t as lenient, which we&amp;rsquo;ll cover in a bit.</source>
          <target state="translated">タイプチェッカーは、 &lt;code&gt;printLabel&lt;/code&gt; の呼び出しをチェックします。 &lt;code&gt;printLabel&lt;/code&gt; の機能は、渡されたオブジェクトは、というプロパティ持っている必要があり、単一のパラメータ &lt;code&gt;label&lt;/code&gt; タイプの &lt;code&gt;string&lt;/code&gt; 。オブジェクトには実際にはこれよりも多くのプロパティがありますが、コンパイラ&lt;em&gt;は少なくとも&lt;/em&gt;必要なプロパティが存在し、必要なタイプに一致することのみを確認すること&lt;em&gt;に&lt;/em&gt;注意してください。 TypeScriptがそれほど寛大でない場合がありますが、これについては後で説明します。</target>
        </trans-unit>
        <trans-unit id="498dccd8aaeaa75874785e3ff175fe7c0758db81" translate="yes" xml:space="preserve">
          <source>The type checker previously considered &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; assignable to anything. Effectively, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; were valid values of &lt;em&gt;every&lt;/em&gt; type and it wasn&amp;rsquo;t possible to specifically exclude them (and therefore not possible to detect erroneous use of them).</source>
          <target state="translated">以前に考えられて型チェッカー &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; ものに割り当て可能。事実上、 &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; は&lt;em&gt;すべての&lt;/em&gt;タイプの有効な値であり、それらを明確に除外することはできませんでした（したがって、それらの誤った使用を検出することはできませんでした）。</target>
        </trans-unit>
        <trans-unit id="86aac0e48da9aea5ed18bd94611504853bd15903" translate="yes" xml:space="preserve">
          <source>The type inferred for a &lt;code&gt;const&lt;/code&gt; variable or &lt;code&gt;readonly&lt;/code&gt; property without a type annotation is the type of the literal initializer. The type inferred for a &lt;code&gt;let&lt;/code&gt; variable, &lt;code&gt;var&lt;/code&gt; variable, parameter, or non-&lt;code&gt;readonly&lt;/code&gt; property with an initializer and no type annotation is the widened literal type of the initializer. Where the widened type for a string literal type is &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt; for numeric literal types, &lt;code&gt;boolean&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; and the containing enum for enum literal types.</source>
          <target state="translated">型注釈のない &lt;code&gt;const&lt;/code&gt; 変数または &lt;code&gt;readonly&lt;/code&gt; プロパティに対して推論される型は、リテラル初期化子の型です。イニシャライザがあり、タイプ注釈がない、 &lt;code&gt;let&lt;/code&gt; 変数、 &lt;code&gt;var&lt;/code&gt; 変数、パラメータ、または非 &lt;code&gt;readonly&lt;/code&gt; プロパティに対して推論されるタイプは、初期化子の拡張されたリテラルタイプです。文字列リテラルタイプの広がったタイプがある場合は &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;number&lt;/code&gt; 数値リテラルタイプのため、 &lt;code&gt;boolean&lt;/code&gt; のための &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; と列挙リテラルのタイプについて含むenum。</target>
        </trans-unit>
        <trans-unit id="22d8204ec0e93f58b5995cd3bb24de8809d04802" translate="yes" xml:space="preserve">
          <source>The type information provided works together with the tools to work with JavaScript at application scale. For more examples of what&amp;rsquo;s possible in TypeScript, see the Samples section of the website.</source>
          <target state="translated">提供されるタイプ情報は、アプリケーション規模でJavaScriptを操作するためのツールと連動します。TypeScriptで可能なことのその他の例については、Webサイトの「サンプル」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="3d4d8d8ec6a0364ae5c047afca600acdad689a11" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;import.meta&lt;/code&gt; is the global &lt;code&gt;ImportMeta&lt;/code&gt; type which is defined in &lt;code&gt;lib.es5.d.ts&lt;/code&gt;. This interface is extremely limited. Adding well-known properties for Node or browsers requires interface merging and possibly a global augmentation depending on the context.</source>
          <target state="translated">種類 &lt;code&gt;import.meta&lt;/code&gt; はグローバルである &lt;code&gt;ImportMeta&lt;/code&gt; の中で定義されているタイプ &lt;code&gt;lib.es5.d.ts&lt;/code&gt; 。このインターフェースは非常に制限されています。ノードまたはブラウザの既知のプロパティを追加するには、インターフェイスのマージと、状況に応じてグローバルな拡張が必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="8e56de6acd1d580bed0b7dbc97a0025ddbff4368" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;o&lt;/code&gt; is determined to be &lt;code&gt;{ inference: string }&lt;/code&gt; because</source>
          <target state="translated">&lt;code&gt;o&lt;/code&gt; のタイプは &lt;code&gt;{ inference: string }&lt;/code&gt; あると判断されます。</target>
        </trans-unit>
        <trans-unit id="d271ce4998727501be8284a249a40022d27f33d7" translate="yes" xml:space="preserve">
          <source>The type of a variable declared in a &lt;code&gt;for..in&lt;/code&gt; statement is implicitly &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; ステートメントで宣言された変数の型は、暗黙的に &lt;code&gt;string&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="5f07be8c188f5eaeef3ae763a9e934f23db56503" translate="yes" xml:space="preserve">
          <source>The type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:</source>
          <target state="translated">ジェネリック関数の型は非ジェネリック関数の型と同じで、関数宣言と同様に型パラメータが最初にリストアップされています。</target>
        </trans-unit>
        <trans-unit id="89b88412f516aaabf8ce78ad994c61d8ed26eb99" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;length&lt;/code&gt; property of a tuple type with a rest element is &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">種類 &lt;code&gt;length&lt;/code&gt; 休止要素とタプルタイプの特性である &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19df0d5bb97d9dc0679c13270f984f724378fbec" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;x&lt;/code&gt; variable is inferred to be &lt;code&gt;number&lt;/code&gt;. This kind of inference takes place when initializing variables and members, setting parameter default values, and determining function return types.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 変数の型は &lt;code&gt;number&lt;/code&gt; であると推測されます。この種の推論は、変数とメンバーの初期化、パラメーターのデフォルト値の設定、関数の戻り値の型の決定時に行われます。</target>
        </trans-unit>
        <trans-unit id="f6bd4bc2cdf6f5eae310eb7f350c21d93cc10ee9" translate="yes" xml:space="preserve">
          <source>The type parameter type of the &lt;code&gt;extends&lt;/code&gt; expression must be constrained to a mixin constructor type.</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; 式のタイプパラメータタイプは、ミックスインコンストラクタタイプに制限する必要があります。</target>
        </trans-unit>
        <trans-unit id="52c2a6f88c2385c5622c47c84c950cacbd843901" translate="yes" xml:space="preserve">
          <source>The type system enforces that the source function&amp;rsquo;s return type be a subtype of the target type&amp;rsquo;s return type.</source>
          <target state="translated">型システムは、ソース関数の戻り型がターゲット型の戻り型のサブタイプであることを強制します。</target>
        </trans-unit>
        <trans-unit id="80a0ca38923f448a6bc1a30ea77dea5fb6863b0e" translate="yes" xml:space="preserve">
          <source>The type system in TypeScript has different levels of strictness when working with a codebase:</source>
          <target state="translated">TypeScript の型システムは、コードベースで作業する際の厳密さのレベルが異なります。</target>
        </trans-unit>
        <trans-unit id="b936c977ae4cffd22334d0707270bc09672639e5" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;K&lt;/code&gt;, which gets bound to each property in turn.</source>
          <target state="translated">型変数 &lt;code&gt;K&lt;/code&gt; 。各プロパティに順番にバインドされます。</target>
        </trans-unit>
        <trans-unit id="7709afd63729fd84f9c850e499018e8fd56d1bb3" translate="yes" xml:space="preserve">
          <source>The types of the attributes being passed in the JSX element should be looked up differently. Intrinsic element attributes should be known &lt;em&gt;intrinsically&lt;/em&gt; whereas components will likely want to specify their own set of attributes.</source>
          <target state="translated">JSX要素で渡される属性のタイプは、別の方法で検索する必要があります。コンポーネント&lt;em&gt;固有&lt;/em&gt;の属性セットを指定する可能性が高いのに対し、組み込み要素の属性は&lt;em&gt;本質的に&lt;/em&gt;認識されている必要があります。</target>
        </trans-unit>
        <trans-unit id="fe3cafbbb2e988a60a62d633a3631e8dd7b2a154" translate="yes" xml:space="preserve">
          <source>The types which are exported can then be re-used by consumers of the modules using either &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;import type&lt;/code&gt; in TypeScript code or &lt;a href=&quot;../../jsdoc-supported-types#import-types&quot;&gt;JSDoc imports&lt;/a&gt;.</source>
          <target state="translated">エクスポートされた &lt;code&gt;import type&lt;/code&gt; は、TypeScriptコードまたは&lt;a href=&quot;../../jsdoc-supported-types#import-types&quot;&gt;JSDocインポート&lt;/a&gt;で &lt;code&gt;import&lt;/code&gt; またはインポートタイプを使用して、モジュールのコンシューマーが再利用できます。</target>
        </trans-unit>
        <trans-unit id="09675d7cd4f6ad417e59fbaf95c24d2d47c06712" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;TypeScriptToolsVersion&amp;gt;1.7&amp;lt;/TypeScriptToolsVersion&amp;gt;&lt;/code&gt; property in the project file identifies the compiler version to use to build (1.7 in this example). This allows a project to build against the same versions of the compiler on different machines.</source>
          <target state="translated">プロジェクトファイルの &lt;code&gt;&amp;lt;TypeScriptToolsVersion&amp;gt;1.7&amp;lt;/TypeScriptToolsVersion&amp;gt;&lt;/code&gt; プロパティの値は、ビルドに使用するコンパイラのバージョンを識別します（この例では1.7）。これにより、プロジェクトは異なるマシン上の同じバージョンのコンパイラーに対してビルドできます。</target>
        </trans-unit>
        <trans-unit id="ff912358477db4602c58e3b0cd86822e8bf58dbb" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;extends&lt;/code&gt; is a string which contains a path to another configuration file to inherit from. The path may use Node.js style resolution.</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; の値は、継承元の別の構成ファイルへのパスを含む文字列です。パスはNode.jsスタイルの解決を使用できます。</target>
        </trans-unit>
        <trans-unit id="7e5b2230b8d43ad8c0d99ac55f3f3b2a5f049234" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;extends&lt;/code&gt; must be a string containing a path to another configuration file to inherit from.</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; の値は、継承元の別の構成ファイルへのパスを含む文字列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="23c080d1f546c832664165ecef0024de9c538ba4" translate="yes" xml:space="preserve">
          <source>The variables don&amp;rsquo;t necessarily need to both be block-scoped for TypeScript to tell us that there&amp;rsquo;s a problem.</source>
          <target state="translated">TypeScriptが問題があることを通知するために、変数の両方を必ずしもブロックスコープにする必要はありません。</target>
        </trans-unit>
        <trans-unit id="0cd2fcb1497f2a79b74d282146de3e0947778826" translate="yes" xml:space="preserve">
          <source>The visibility rules for merged members is the same as described in the &amp;lsquo;Merging Namespaces&amp;rsquo; section, so we must export the &lt;code&gt;AlbumLabel&lt;/code&gt; class for the merged class to see it. The end result is a class managed inside of another class. You can also use namespaces to add more static members to an existing class.</source>
          <target state="translated">マージされたメンバーの可視性ルールは、「名前空間のマージ」セクションで説明されているものと同じであるため、マージされたクラスがそれを表示するには、 &lt;code&gt;AlbumLabel&lt;/code&gt; クラスをエクスポートする必要があります。最終結果は、別のクラス内で管理されるクラスです。名前空間を使用して、既存のクラスに静的メンバーを追加することもできます。</target>
        </trans-unit>
        <trans-unit id="243a2c277506b9bd8ad79e2eb6c0a571a75e9611" translate="yes" xml:space="preserve">
          <source>The visibility rules for merged members is the same as described in the &lt;a href=&quot;declaration-merging#merging-namespaces&quot;&gt;Merging Namespaces&lt;/a&gt; section, so we must export the &lt;code&gt;AlbumLabel&lt;/code&gt; class for the merged class to see it. The end result is a class managed inside of another class. You can also use namespaces to add more static members to an existing class.</source>
          <target state="translated">&lt;a href=&quot;declaration-merging#merging-namespaces&quot;&gt;マージ&lt;/a&gt;されたメンバーの表示ルールは、「名前空間のマージ」セクションで説明したものと同じであるため、マージされたクラスの &lt;code&gt;AlbumLabel&lt;/code&gt; クラスをエクスポートして表示する必要があります。最終結果は、別のクラス内で管理されるクラスです。名前空間を使用して、既存のクラスに静的メンバーを追加することもできます。</target>
        </trans-unit>
        <trans-unit id="ea042e37fe3dfdb85a33f2ea55e58e9f6f78eed8" translate="yes" xml:space="preserve">
          <source>The watching of directory on platforms that don&amp;rsquo;t support recursive directory watching natively in node, is supported through recursively creating directory watcher for the child directories using different options selected by &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;. Note that on platforms that support native recursive directory watching (e.g windows) the value of this environment variable is ignored.</source>
          <target state="translated">&lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt; で選択されたさまざまなオプションを使用して子ディレクトリのディレクトリウォッチャーを再帰的に作成することで、ノードでの再帰的なディレクトリウォッチングをサポートしないプラットフォームでのディレクトリのウォッチングがサポートされます。ネイティブの再帰的ディレクトリ監視をサポートするプラットフォーム（Windowsなど）では、この環境変数の値は無視されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4068ca96cef50a182f0293c35312e884e5d6ce44" translate="yes" xml:space="preserve">
          <source>The way that TypeScript decides on whether a version of the compiler &amp;amp; language matches is by using Node&amp;rsquo;s &lt;a href=&quot;https://github.com/npm/node-semver#ranges&quot;&gt;semver ranges&lt;/a&gt;.</source>
          <target state="translated">TypeScriptがコンパイラと言語のバージョンが一致するかどうかを判断する方法は、Nodeの&lt;a href=&quot;https://github.com/npm/node-semver#ranges&quot;&gt;サーバー範囲&lt;/a&gt;を使用することです。</target>
        </trans-unit>
        <trans-unit id="d504e46325644ee193380b78759d039584245b76" translate="yes" xml:space="preserve">
          <source>The way that this works is that when using &lt;code&gt;allowJs&lt;/code&gt;, TypeScript has some best-effort analyses to understand common JavaScript patterns; however, the way that some patterns are expressed in JavaScript don&amp;rsquo;t necessarily look like their equivalents in TypeScript. When &lt;code&gt;declaration&lt;/code&gt; emit is turned on, TypeScript figures out the best way to transform JSDoc comments and CommonJS exports into valid type declarations and the like in the output &lt;code&gt;.d.ts&lt;/code&gt; files.</source>
          <target state="translated">これが機能する方法は、 &lt;code&gt;allowJs&lt;/code&gt; を使用する場合、TypeScriptには一般的なJavaScriptパターンを理解するためのベストエフォート分析がいくつかあるということです。ただし、一部のパターンがJavaScriptで表現される方法は、TypeScriptでの同等のパターンに必ずしも似ているとは限りません。ときに &lt;code&gt;declaration&lt;/code&gt; EMITがオンになっている、活字体は、出力のように、有効な型宣言とにJSDocのコメントとCommonJSの輸出を変換するための最良の方法割り出し &lt;code&gt;.d.ts&lt;/code&gt; ファイルを。</target>
        </trans-unit>
        <trans-unit id="35913a132bcc3df8c56386f24253f0774dc172fa" translate="yes" xml:space="preserve">
          <source>Then consumed it:</source>
          <target state="translated">そして、それを消費した。</target>
        </trans-unit>
        <trans-unit id="b4e2cc009128e2db8e40c27a6eddddf19f0ce8db" translate="yes" xml:space="preserve">
          <source>Then enable building it with &lt;code&gt;inlineSourceMap&lt;/code&gt; enabled there is a comment at the bottom of the file which includes a source-map for the file.</source>
          <target state="translated">次に、 &lt;code&gt;inlineSourceMap&lt;/code&gt; を有効にしてビルドを有効にします。ファイルの下部に、ファイルのソースマップを含むコメントがあります。</target>
        </trans-unit>
        <trans-unit id="4e16808203379c44a60c8ea98dbc5730307f3ef5" translate="yes" xml:space="preserve">
          <source>Then enable building it with &lt;code&gt;inlineSources&lt;/code&gt; and &lt;code&gt;inlineSourceMap&lt;/code&gt; enabled there is a comment at the bottom of the file which includes a source-map for the file. Note that the end is different from the example in &lt;a href=&quot;#inlineSourceMap&quot;&gt;&lt;code&gt;inlineSourceMap&lt;/code&gt;&lt;/a&gt; because the source-map now contains the original source code also.</source>
          <target state="translated">次に、 &lt;code&gt;inlineSources&lt;/code&gt; と &lt;code&gt;inlineSourceMap&lt;/code&gt; を有効にしてビルドを有効にします。ファイルの下部に、ファイルのソースマップを含むコメントがあります。ソースマップには元のソースコードも含まれているため、最後は&lt;a href=&quot;#inlineSourceMap&quot;&gt; &lt;code&gt;inlineSourceMap&lt;/code&gt; &lt;/a&gt;の例とは異なることに注意してください。</target>
        </trans-unit>
        <trans-unit id="87bfce3f975bdf3b7775facbf050990abd13d246" translate="yes" xml:space="preserve">
          <source>Then install &lt;code&gt;typescript&lt;/code&gt;, &lt;code&gt;gulp&lt;/code&gt; and &lt;code&gt;gulp-typescript&lt;/code&gt; in your project&amp;rsquo;s dev dependencies. &lt;a href=&quot;https://www.npmjs.com/package/gulp-typescript&quot;&gt;Gulp-typescript&lt;/a&gt; is a gulp plugin for TypeScript.</source>
          <target state="translated">次に、プロジェクトの開発依存関係に &lt;code&gt;typescript&lt;/code&gt; 、 &lt;code&gt;gulp&lt;/code&gt; 、 &lt;code&gt;gulp-typescript&lt;/code&gt; をインストールします。&lt;a href=&quot;https://www.npmjs.com/package/gulp-typescript&quot;&gt;Gulp-typescript&lt;/a&gt;は、TypeScript用のgulpプラグインです。</target>
        </trans-unit>
        <trans-unit id="47406e9f2861c5bd5131ac98ebd0257179f53e80" translate="yes" xml:space="preserve">
          <source>Then install &lt;code&gt;typescript&lt;/code&gt;, &lt;code&gt;gulp&lt;/code&gt; and &lt;code&gt;gulp-typescript&lt;/code&gt; in your project&amp;rsquo;s dev dependencies. &lt;a href=&quot;https://www.npmjs.com/package/gulp-typescript&quot;&gt;Gulp-typescript&lt;/a&gt; is a gulp plugin for Typescript.</source>
          <target state="translated">次に、プロジェクトの開発依存関係に &lt;code&gt;typescript&lt;/code&gt; 、 &lt;code&gt;gulp&lt;/code&gt; 、 &lt;code&gt;gulp-typescript&lt;/code&gt; をインストールします。&lt;a href=&quot;https://www.npmjs.com/package/gulp-typescript&quot;&gt;Gulp-typescript&lt;/a&gt;はTypescriptのgulpプラグインです。</target>
        </trans-unit>
        <trans-unit id="642ddc2143630564f6b4e561a7568f47369559e5" translate="yes" xml:space="preserve">
          <source>Then the &lt;code&gt;food&lt;/code&gt; property in &lt;code&gt;defaults&lt;/code&gt; overwrites &lt;code&gt;food: &quot;rich&quot;&lt;/code&gt;, which is not what we want in this case.</source>
          <target state="translated">次に、 &lt;code&gt;defaults&lt;/code&gt; の &lt;code&gt;food&lt;/code&gt; プロパティは &lt;code&gt;food: &quot;rich&quot;&lt;/code&gt; 上書きします。これは、この場合は必要ありません。</target>
        </trans-unit>
        <trans-unit id="becbc2214d8bce0fa238270073a5869333572174" translate="yes" xml:space="preserve">
          <source>Then turning on both &lt;a href=&quot;#downlevelIteration&quot;&gt;&lt;code&gt;downlevelIteration&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;importHelpers&lt;/code&gt;:</source>
          <target state="translated">そして、両方をオンに&lt;a href=&quot;#downlevelIteration&quot;&gt; &lt;code&gt;downlevelIteration&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;importHelpers&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4b0de2b0a81fcb1c9fa6824131d9c2d4117e4121" translate="yes" xml:space="preserve">
          <source>Then use the template &lt;a href=&quot;templates/module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;called&lt;/em&gt; like a function:</source>
          <target state="translated">次に、&lt;a href=&quot;templates/module-function-d-ts&quot;&gt; &lt;code&gt;module-function.d.ts&lt;/code&gt; &lt;/a&gt;ように&lt;em&gt;呼び出す&lt;/em&gt;ことができる場合は、テンプレートmodule-function.d.tsを使用します。</target>
        </trans-unit>
        <trans-unit id="ee7e9ae9703590946457d53a865fb4cbb6b63b7c" translate="yes" xml:space="preserve">
          <source>Then you can create mixins which only work when you have a particular base to build on:</source>
          <target state="translated">そうすれば、特定のベースがある場合にのみ機能するミックスインを作成することができます。</target>
        </trans-unit>
        <trans-unit id="03b21ce8f02b992c174e280059fa4ec67556da04" translate="yes" xml:space="preserve">
          <source>Then you need a type and a factory function which returns a class expression extending the base class.</source>
          <target state="translated">次に、基底クラスを拡張したクラス式を返す型とファクトリ関数が必要になります。</target>
        </trans-unit>
        <trans-unit id="de093b53d785ff2bef7478f5b3a5ab97f6181f86" translate="yes" xml:space="preserve">
          <source>Then, given a type &lt;code&gt;T''&lt;/code&gt; that is an instantiation of &lt;code&gt;T&lt;/code&gt; where all &lt;code&gt;infer&lt;/code&gt; type variables are replaced with the types inferred in the previous step, if &lt;code&gt;T''&lt;/code&gt; is &lt;em&gt;definitely assignable&lt;/em&gt; to &lt;code&gt;U&lt;/code&gt;, the conditional type is resolved to &lt;code&gt;X&lt;/code&gt;. The definitely assignable relation is the same as the regular assignable relation, except that type variable constraints are not considered. Intuitively, when a type is definitely assignable to another type, we know that it will be assignable for &lt;em&gt;all instantiations&lt;/em&gt; of those types.</source>
          <target state="translated">次いで、タイプ所与の &lt;code&gt;T''&lt;/code&gt; のインスタンスである &lt;code&gt;T&lt;/code&gt; すべての &lt;code&gt;infer&lt;/code&gt; 場合は型変数は、前のステップで推論タイプに置き換えられ、 &lt;code&gt;T''&lt;/code&gt; ある&lt;em&gt;確かに割り当て可能&lt;/em&gt;に &lt;code&gt;U&lt;/code&gt; 、条件タイプがに解決されている &lt;code&gt;X&lt;/code&gt; 。確実に割り当て可能な関係は、型変数の制約が考慮されないことを除いて、通常の割り当て可能な関係と同じです。直感的に、あるタイプが別のタイプに確実に割り当て可能である場合、それらのタイプの&lt;em&gt;すべてのインスタンス化&lt;/em&gt;に割り当て可能であることがわかります。</target>
        </trans-unit>
        <trans-unit id="177fd68b346fbae5c87bdcc2142e9f97d5a264b8" translate="yes" xml:space="preserve">
          <source>Then, you need to remember to give a default for optional properties on the destructured property instead of the main initializer. Remember that &lt;code&gt;C&lt;/code&gt; was defined with &lt;code&gt;b&lt;/code&gt; optional:</source>
          <target state="translated">次に、メインの初期化子ではなく、分解されたプロパティのオプションプロパティにデフォルトを指定することを忘れないでください。 &lt;code&gt;C&lt;/code&gt; は &lt;code&gt;b&lt;/code&gt; オプションで定義されたことを思い出してください：</target>
        </trans-unit>
        <trans-unit id="6d2f25ea43cbbc9a4a4d0cca6420fdb8cc7a3eaa" translate="yes" xml:space="preserve">
          <source>There are already a small set of primitive types available in JavaScript: &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, and &lt;code&gt;undefined&lt;/code&gt;, which you can use in an interface. TypeScript extends this list with a few more, such as &lt;code&gt;any&lt;/code&gt; (allow anything), &lt;a href=&quot;https://www.typescriptlang.org/play#example/unknown-and-never&quot;&gt;&lt;code&gt;unknown&lt;/code&gt;&lt;/a&gt; (ensure someone using this type declares what the type is), &lt;a href=&quot;https://www.typescriptlang.org/play#example/unknown-and-never&quot;&gt;&lt;code&gt;never&lt;/code&gt;&lt;/a&gt; (it&amp;rsquo;s not possible that this type could happen), and &lt;code&gt;void&lt;/code&gt; (a function which returns &lt;code&gt;undefined&lt;/code&gt; or has no return value).</source>
          <target state="translated">JavaScriptで使用できるプリミティブ型の小さなセットがすでにあります： &lt;code&gt;boolean&lt;/code&gt; 、 &lt;code&gt;bigint&lt;/code&gt; 、 &lt;code&gt;null&lt;/code&gt; 、 &lt;code&gt;number&lt;/code&gt; 、 &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;symbol&lt;/code&gt; 、 &lt;code&gt;object&lt;/code&gt; 、および &lt;code&gt;undefined&lt;/code&gt; 。これらはインターフェースで使用できます。 TypeScriptは、このリストをさらにいくつ &lt;code&gt;any&lt;/code&gt; （any（何でも許可）、&lt;a href=&quot;https://www.typescriptlang.org/play#example/unknown-and-never&quot;&gt; &lt;code&gt;unknown&lt;/code&gt; &lt;/a&gt;（このタイプを使用している人がタイプを宣言することを確認）、&lt;a href=&quot;https://www.typescriptlang.org/play#example/unknown-and-never&quot;&gt; &lt;code&gt;never&lt;/code&gt; &lt;/a&gt;（このタイプが発生する可能性はない）、 &lt;code&gt;void&lt;/code&gt; （ &lt;code&gt;undefined&lt;/code&gt; または戻り値がありません）。</target>
        </trans-unit>
        <trans-unit id="b08559581092c2fc068a4a49c020c235194dda9a" translate="yes" xml:space="preserve">
          <source>There are also some flags specific to &lt;code&gt;tsc -b&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tsc -b&lt;/code&gt; に固有のいくつかのフラグもあります。</target>
        </trans-unit>
        <trans-unit id="0d87487c8a7e09831fbc5025d0ad575e1d950bdf" translate="yes" xml:space="preserve">
          <source>There are basically three changes here, but they require you to refactor your code a bit.</source>
          <target state="translated">ここでは基本的に3つの変更点がありますが、コードを少しリファクタリングする必要があります。</target>
        </trans-unit>
        <trans-unit id="e6857c6b00d742af1ee133bd685d46d5cba15dc1" translate="yes" xml:space="preserve">
          <source>There are certain cases where TypeScript can&amp;rsquo;t figure out what certain types should be. To be as lenient as possible, it will decide to use the type &lt;code&gt;any&lt;/code&gt; in its place. While this is great for migration, using &lt;code&gt;any&lt;/code&gt; means that you&amp;rsquo;re not getting any type safety, and you won&amp;rsquo;t get the same tooling support you&amp;rsquo;d get elsewhere. You can tell TypeScript to flag these locations down and give an error with the &lt;code&gt;noImplicitAny&lt;/code&gt; option.</source>
          <target state="translated">TypeScriptが特定の型がどうあるべきかを理解できない場合があります。可能な限り寛大にするために、代わりに &lt;code&gt;any&lt;/code&gt; 型を使用することにします。これは移行に最適ですが、 &lt;code&gt;any&lt;/code&gt; 方法を使用しても型の安全性が得られず、他の場所で得られるのと同じツールのサポートを受けられません。TypeScriptにこれらの場所にフラグを立て、 &lt;code&gt;noImplicitAny&lt;/code&gt; オプションでエラーを出すように指示できます。</target>
        </trans-unit>
        <trans-unit id="cf3ad7a163a01d342f3e2b293eed57c09a62514b" translate="yes" xml:space="preserve">
          <source>There are certain scenarios where properties can be initialized indirectly (perhaps by a helper method or dependency injection library), in which case you can use the new &lt;em&gt;definite assignment assertion modifiers&lt;/em&gt; for your properties (discussed below).</source>
          <target state="translated">（おそらくヘルパーメソッドまたは依存関係注入ライブラリによって）プロパティを間接的に初期化できる特定のシナリオがあります。その場合、プロパティに新しい&lt;em&gt;明確な割り当てアサーション修飾子&lt;/em&gt;を使用できます（以下で説明します）。</target>
        </trans-unit>
        <trans-unit id="eba634610df41341637e71be5bcbf8bb0ed87e8f" translate="yes" xml:space="preserve">
          <source>There are four templates available for modules, &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;templates/module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;templates/module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;templates/module-plugin-d-ts&quot;&gt;&lt;code&gt;module-plugin.d.ts&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">モジュールで使用可能な4つのテンプレートがあり&lt;a href=&quot;templates/module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;templates/module-class-d-ts&quot;&gt; &lt;code&gt;module-class.d.ts&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;templates/module-function-d-ts&quot;&gt; &lt;code&gt;module-function.d.ts&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;templates/module-plugin-d-ts&quot;&gt; &lt;code&gt;module-plugin.d.ts&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e36d4bfc03b98451d8b8eedb5746119736591728" translate="yes" xml:space="preserve">
          <source>There are many ways to import a module in modern consuming code:</source>
          <target state="translated">最近の消費型コードでモジュールをインポートする方法はたくさんあります。</target>
        </trans-unit>
        <trans-unit id="dea4fb6f37fc741965c275705e62ed0016df0d89" translate="yes" xml:space="preserve">
          <source>There are many, many resources available for programmers to learn JavaScript; you should &lt;em&gt;not&lt;/em&gt; ignore these resources if you&amp;rsquo;re writing TypeScript. For example, there are about 20 times more StackOverflow questions tagged &lt;code&gt;javascript&lt;/code&gt; than &lt;code&gt;typescript&lt;/code&gt;, but &lt;em&gt;all&lt;/em&gt; of the &lt;code&gt;javascript&lt;/code&gt; questions also apply to TypeScript.</source>
          <target state="translated">プログラマーがJavaScriptを学ぶために利用できるリソースはたくさんあります。あなたがすべき&lt;em&gt;ではない&lt;/em&gt;、あなたが活字を書いている場合は、これらのリソースを無視します。たとえば、 &lt;code&gt;javascript&lt;/code&gt; でタグ付けされたStackOverflowの質問は &lt;code&gt;typescript&lt;/code&gt; の約20倍ありますが、&lt;em&gt;すべて&lt;/em&gt;の &lt;code&gt;javascript&lt;/code&gt; の質問はTypeScriptにも当てはまります。</target>
        </trans-unit>
        <trans-unit id="f4b49ffaf8a00ef0b4948f5d604ea58ab037be14" translate="yes" xml:space="preserve">
          <source>There are multiple compiler flags which can be used to customize your JSX, which work as both a compiler flag and via inline per-file pragmas. To learn more see their tsconfig reference pages:</source>
          <target state="translated">JSX をカスタマイズするために使用できる複数のコンパイラフラグがあり、これらはコンパイラフラグとしても、インラインのファイル単位のプラグマとしても機能します。詳しくは tsconfig リファレンスページを参照してください。</target>
        </trans-unit>
        <trans-unit id="d8e46f31896dc086f90c6f67b6510c59fb5bf434" translate="yes" xml:space="preserve">
          <source>There are several kinds of dependencies your library might have. This section shows how to import them into the declaration file.</source>
          <target state="translated">ライブラリにはいくつかの種類の依存関係があります。このセクションでは、それらを宣言ファイルにインポートする方法を示します。</target>
        </trans-unit>
        <trans-unit id="54d5d5df37f41afa88246489b4794d1549724fce" translate="yes" xml:space="preserve">
          <source>There are three sets of literal types available in TypeScript today: strings, numbers, and booleans; by using literal types you can allow an exact value which a string, number, or boolean must have.</source>
          <target state="translated">現在のTypeScriptでは、文字列、数値、ブール値の3つのリテラル型が利用できます。リテラル型を使用することで、文字列、数値、ブール値が持つべき正確な値を許可することができます。</target>
        </trans-unit>
        <trans-unit id="5cb53f7de48cbccf0073a458e4977f8e2bef7683" translate="yes" xml:space="preserve">
          <source>There are three templates available for modules, &lt;a href=&quot;module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">モジュールで使用可能な3つのテンプレートがあり&lt;a href=&quot;module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;module-class-d-ts&quot;&gt; &lt;code&gt;module-class.d.ts&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;module-function-d-ts&quot;&gt; &lt;code&gt;module-function.d.ts&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f50947aa96622ea69cd6de3461bbbc3baf551e2b" translate="yes" xml:space="preserve">
          <source>There are three templates available for modules, &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;templates/module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;templates/module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">モジュールで使用可能な3つのテンプレートがあり&lt;a href=&quot;templates/module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;templates/module-class-d-ts&quot;&gt; &lt;code&gt;module-class.d.ts&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;templates/module-function-d-ts&quot;&gt; &lt;code&gt;module-function.d.ts&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3175acff50e94eb51400e6dbf17df6396ef9e4b3" translate="yes" xml:space="preserve">
          <source>There are two main ways to get the TypeScript available for your project:</source>
          <target state="translated">プロジェクトでTypeScriptを利用できるようにするには、主に2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="af6a54de55d95dc1fa9a970327164b2697b39938" translate="yes" xml:space="preserve">
          <source>There are two main ways to get the TypeScript tools:</source>
          <target state="translated">TypeScriptツールを取得する方法は主に2つあります。</target>
        </trans-unit>
        <trans-unit id="f51afbc91104b11fd815c5a998b7fab8086c5610" translate="yes" xml:space="preserve">
          <source>There are two packages:</source>
          <target state="translated">パッケージは2つあります。</target>
        </trans-unit>
        <trans-unit id="b8b3a9273fe6c950960b5b0a5f42744f3ece318c" translate="yes" xml:space="preserve">
          <source>There are two possible module resolution strategies: &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; and &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt;. You can use the &lt;code&gt;--moduleResolution&lt;/code&gt; flag to specify the module resolution strategy. If not specified, the default is &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; for &lt;code&gt;--module AMD | System | ES2015&lt;/code&gt; or &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; otherwise.</source>
          <target state="translated">2つの可能なモジュール解決戦略があります。&lt;a href=&quot;#node&quot;&gt;ノード&lt;/a&gt;と&lt;a href=&quot;#classic&quot;&gt;クラシック&lt;/a&gt;です。 &lt;code&gt;--moduleResolution&lt;/code&gt; フラグを使用して、モジュール解決戦略を指定できます。指定しない場合、デフォルトは &lt;code&gt;--module AMD | System | ES2015&lt;/code&gt; &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt;です。システム|それ以外の場合はES2015または&lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7bb5339d9e6a87194928e1205da42e556f4c0c78" translate="yes" xml:space="preserve">
          <source>There are two possible module resolution strategies: &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; and &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt;. You can use the &lt;code&gt;--moduleResolution&lt;/code&gt; flag to specify the module resolution strategy. If not specified, the default is &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; for &lt;code&gt;--module commonjs&lt;/code&gt;, and &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; otherwise (including when &lt;code&gt;--module&lt;/code&gt; is set to &lt;code&gt;amd&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, &lt;code&gt;umd&lt;/code&gt;, &lt;code&gt;es2015&lt;/code&gt;, &lt;code&gt;esnext&lt;/code&gt;, etc.).</source>
          <target state="translated">モジュール解決戦略には、&lt;a href=&quot;#node&quot;&gt;ノード&lt;/a&gt;と&lt;a href=&quot;#classic&quot;&gt;クラシックの&lt;/a&gt;2つがあります。 &lt;code&gt;--moduleResolution&lt;/code&gt; フラグを使用して、モジュール解決戦略を指定できます。指定しない場合、デフォルトは &lt;code&gt;--module commonjs&lt;/code&gt; の&lt;a href=&quot;#node&quot;&gt;ノード&lt;/a&gt;であり、それ以外の場合は&lt;a href=&quot;#classic&quot;&gt;クラシックです&lt;/a&gt;（ &lt;code&gt;--module&lt;/code&gt; が &lt;code&gt;amd&lt;/code&gt; 、 &lt;code&gt;system&lt;/code&gt; 、 &lt;code&gt;umd&lt;/code&gt; 、 &lt;code&gt;es2015&lt;/code&gt; 、 &lt;code&gt;esnext&lt;/code&gt; などに設定されている場合を含む）。</target>
        </trans-unit>
        <trans-unit id="6d037836fd5889368e676cf82d021109751703c9" translate="yes" xml:space="preserve">
          <source>There are two types of supported index signatures: string and number. It is possible to support both types of indexers, but the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with a &lt;code&gt;number&lt;/code&gt;, JavaScript will actually convert that to a &lt;code&gt;string&lt;/code&gt; before indexing into an object. That means that indexing with &lt;code&gt;100&lt;/code&gt; (a &lt;code&gt;number&lt;/code&gt;) is the same thing as indexing with &lt;code&gt;&quot;100&quot;&lt;/code&gt; (a &lt;code&gt;string&lt;/code&gt;), so the two need to be consistent.</source>
          <target state="translated">サポートされるインデックスシグネチャには、文字列と数値の2つのタイプがあります。両方のタイプのインデクサーをサポートすることは可能ですが、数値インデクサーから返されるタイプは、文字列インデクサーから返されるタイプのサブタイプである必要があります。これは、 &lt;code&gt;number&lt;/code&gt; を使用してインデックスを作成する場合、JavaScriptは実際にそれを &lt;code&gt;string&lt;/code&gt; に変換してからオブジェクトにインデックスを作成するためです。つまり、 &lt;code&gt;100&lt;/code&gt; （ &lt;code&gt;number&lt;/code&gt; ）を使用したインデックス作成は、 &lt;code&gt;&quot;100&quot;&lt;/code&gt; （ &lt;code&gt;string&lt;/code&gt; ）を使用したインデックス作成と同じであるため、2つを一致させる必要があります。</target>
        </trans-unit>
        <trans-unit id="908cd031750feb81ec4d9c9d32a60c943d9995ba" translate="yes" xml:space="preserve">
          <source>There are two ways to define a value-based element:</source>
          <target state="translated">価値ベースの要素を定義するには、2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="26e25b640ababcffdfc4b06e185fa3e5e4e7f32b" translate="yes" xml:space="preserve">
          <source>There are two ways to do this. The first is to turn on &lt;code&gt;--strictNullChecks&lt;/code&gt; and specify a return type:</source>
          <target state="translated">これを行うには2つの方法があります。1つ目は、 &lt;code&gt;--strictNullChecks&lt;/code&gt; をオンにして、戻り値の型を指定することです。</target>
        </trans-unit>
        <trans-unit id="cf2a0ce7bafc915c076e238a70bcad502f45e2dc" translate="yes" xml:space="preserve">
          <source>There have been cases where a feature is compelling enough to be an exception to that rule, and these live as experimental compiler flags. It is possible that a version of these features may be different when/if they are added to the JavaScript language, and thus are considered risky.</source>
          <target state="translated">ある機能がそのルールの例外となるほど説得力のある場合があり、これらの機能は実験的なコンパイラフラグとして生きています。これらの機能が JavaScript 言語に追加された場合、バージョンが変わる可能性があります。</target>
        </trans-unit>
        <trans-unit id="007f160b174984bad6b726d50666ccbaf286b22c" translate="yes" xml:space="preserve">
          <source>There is a handbook reference page on &lt;a href=&quot;docs/handbook/module-resolution&quot;&gt;Module Resolution&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;docs/handbook/module-resolution&quot;&gt;モジュール解決&lt;/a&gt;に関するハンドブックリファレンスページがあります</target>
        </trans-unit>
        <trans-unit id="e7659fe4cc582ed4ad5cee6a5865f3aed8b3f631" translate="yes" xml:space="preserve">
          <source>There is a special subset of constant enum members that aren&amp;rsquo;t calculated: literal enum members. A literal enum member is a constant enum member with no initialized value, or with values that are initialized to</source>
          <target state="translated">計算されない定数列挙型メンバーの特別なサブセットがあります。リテラル列挙型メンバーです。リテラルenumメンバーは、初期化された値がない、または初期化された値を持つ定数enumメンバーです</target>
        </trans-unit>
        <trans-unit id="b3c75a37225472b5122690bb8c7852d356bbe63d" translate="yes" xml:space="preserve">
          <source>There is a well defined order to how decorators applied to various declarations inside of a class are applied:</source>
          <target state="translated">クラス内の様々な宣言に適用されるデコレータがどのように適用されるかについては、よく定義された順序があります。</target>
        </trans-unit>
        <trans-unit id="c03a7a9feb4e16d6584fcc6c1888330ee99b47fa" translate="yes" xml:space="preserve">
          <source>There is no case requirement, but type parameters are conventionally single uppercase letters. Type parameters can also be constrained to a type, which behaves a bit like type class constraints:</source>
          <target state="translated">大文字小文字の要件はありませんが、型パラメータは慣習的に単一の大文字です。型パラメータは型に制約を与えることもできますが、これは型クラスの制約に少し似た挙動をします。</target>
        </trans-unit>
        <trans-unit id="59854d2178396e55e332123995b42b2847acef61" translate="yes" xml:space="preserve">
          <source>There is no difference between how classes and objects conform to shapes:</source>
          <target state="translated">クラスとオブジェクトがどのように形に適合しているかの違いはありません。</target>
        </trans-unit>
        <trans-unit id="9b776dda290c6f5398f6b0885c60c8e056b32045" translate="yes" xml:space="preserve">
          <source>There is no template for &lt;code&gt;tsconfig.json&lt;/code&gt; in most project types.</source>
          <target state="translated">ほとんどのプロジェクトタイプには、 &lt;code&gt;tsconfig.json&lt;/code&gt; のテンプレートはありません。</target>
        </trans-unit>
        <trans-unit id="8504a07cb4ffd55d7fe6fdeea5cee63d290fd3d8" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a specific set of functions that &lt;code&gt;throw&lt;/code&gt; an error if something unexpected happened. They&amp;rsquo;re called &amp;ldquo;assertion&amp;rdquo; functions. As an example, Node.js has a dedicated function for this called &lt;code&gt;assert&lt;/code&gt;.</source>
          <target state="translated">予期しないことが起こった場合にエラーを &lt;code&gt;throw&lt;/code&gt; する特定の関数セットがあります。これらは「アサーション」関数と呼ばれます。例として、Node.jsには、 &lt;code&gt;assert&lt;/code&gt; と呼ばれるこれ専用の関数があります。</target>
        </trans-unit>
        <trans-unit id="6ea7b067283b1800f3cf1697d8801fcd2967972e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also &lt;em&gt;optional call&lt;/em&gt;, which allows us to conditionally call expressions if they&amp;rsquo;re not &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;オプションのcall&lt;/em&gt;もあり&lt;em&gt;ます&lt;/em&gt;。これにより、式が &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; でない場合に条件付きで呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="45675102fd5d070224d9ebb4b617e2cd2622b44e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no built-in up-to-date checking, so you end up always running &lt;code&gt;tsc&lt;/code&gt; twice</source>
          <target state="translated">組み込みの最新のチェック機能がないため、最終的には常に &lt;code&gt;tsc&lt;/code&gt; を 2回実行することになります</target>
        </trans-unit>
        <trans-unit id="d45edf5a42ca019d0d64af47b3ea8fd1b0b8bcb9" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;.tsbuildinfo&lt;/code&gt; files can be safely deleted and don&amp;rsquo;t have any impact on our code at runtime - they&amp;rsquo;re purely used to make compilations faster. We can also name them anything that we want, and place them anywhere we want using the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target state="translated">これらの &lt;code&gt;.tsbuildinfo&lt;/code&gt; ファイルは安全に削除でき、実行時にコードに影響を与えません。これらは純粋にコンパイルを高速化するために使用されます。また、任意の名前を付け、 &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; フラグを使用して任意の場所に配置することもできます。</target>
        </trans-unit>
        <trans-unit id="4432967bf84b9c64e93637b08f3be2a8d76030ec" translate="yes" xml:space="preserve">
          <source>These &lt;em&gt;&lt;code&gt;typeof&lt;/code&gt; type guards&lt;/em&gt; are recognized in two different forms: &lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; and &lt;code&gt;typeof v !== &quot;typename&quot;&lt;/code&gt;, where &lt;code&gt;&quot;typename&quot;&lt;/code&gt; can be one of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#Description&quot;&gt;&lt;code&gt;typeof&lt;/code&gt; operator&amp;rsquo;s return values&lt;/a&gt; (&lt;code&gt;&quot;undefined&quot;&lt;/code&gt;, &lt;code&gt;&quot;number&quot;&lt;/code&gt;, &lt;code&gt;&quot;string&quot;&lt;/code&gt;, &lt;code&gt;&quot;boolean&quot;&lt;/code&gt;, &lt;code&gt;&quot;bigint&quot;&lt;/code&gt;, &lt;code&gt;&quot;symbol&quot;&lt;/code&gt;, &lt;code&gt;&quot;object&quot;&lt;/code&gt;, or &lt;code&gt;&quot;function&quot;&lt;/code&gt;). While TypeScript won&amp;rsquo;t stop you from comparing to other strings, the language won&amp;rsquo;t recognize those expressions as type guards.</source>
          <target state="translated">これらの&lt;em&gt; &lt;code&gt;typeof&lt;/code&gt; 型ガード&lt;/em&gt;は、 &lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; と &lt;code&gt;typeof v !== &quot;typename&quot;&lt;/code&gt; 2つの異なる形式で認識されます。ここで、 &lt;code&gt;&quot;typename&quot;&lt;/code&gt; は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#Description&quot;&gt; &lt;code&gt;typeof&lt;/code&gt; 演算子の戻り値&lt;/a&gt;（ &lt;code&gt;&quot;undefined&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;number&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;string&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;boolean&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;bigint&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;symbol&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;object&quot;&lt;/code&gt; 、または &lt;code&gt;&quot;function&quot;&lt;/code&gt; ）。 TypeScriptは他の文字列との比較を妨げることはありませんが、言語はそれらの式を型ガードとして認識しません。</target>
        </trans-unit>
        <trans-unit id="79dc017ea8ee6bb3f7c9fc491544134c877f20d3" translate="yes" xml:space="preserve">
          <source>These &lt;em&gt;&lt;code&gt;typeof&lt;/code&gt; type guards&lt;/em&gt; are recognized in two different forms: &lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; and &lt;code&gt;typeof v !== &quot;typename&quot;&lt;/code&gt;, where &lt;code&gt;&quot;typename&quot;&lt;/code&gt; must be &lt;code&gt;&quot;number&quot;&lt;/code&gt;, &lt;code&gt;&quot;string&quot;&lt;/code&gt;, &lt;code&gt;&quot;boolean&quot;&lt;/code&gt;, or &lt;code&gt;&quot;symbol&quot;&lt;/code&gt;. While TypeScript won&amp;rsquo;t stop you from comparing to other strings, the language won&amp;rsquo;t recognize those expressions as type guards.</source>
          <target state="translated">これらの&lt;em&gt; &lt;code&gt;typeof&lt;/code&gt; タイプガード&lt;/em&gt;は、 &lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; と &lt;code&gt;typeof v !== &quot;typename&quot;&lt;/code&gt; 2つの異なる形式で認識されます。ここで、 &lt;code&gt;&quot;typename&quot;&lt;/code&gt; は &lt;code&gt;&quot;number&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;string&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;boolean&quot;&lt;/code&gt; 、または &lt;code&gt;&quot;symbol&quot;&lt;/code&gt; &quot;である必要があります&quot;。TypeScriptは他の文字列との比較を妨げませんが、言語はそれらの式をタイプガードとして認識しません。</target>
        </trans-unit>
        <trans-unit id="6e2d65d5a90ac869c2cc90b8e3534ec2395fdf41" translate="yes" xml:space="preserve">
          <source>These are emitted as &lt;code&gt;.map&lt;/code&gt; files which live alongside the file they represent.</source>
          <target state="translated">これらは、それらが表すファイルと一緒に存在する &lt;code&gt;.map&lt;/code&gt; ファイルとして発行されます。</target>
        </trans-unit>
        <trans-unit id="c89cac30c0863c54c7e154b255e1a2a8a10af609" translate="yes" xml:space="preserve">
          <source>These are seldom written explicitly, but they can be useful when narrowing issues and can catch bugs:</source>
          <target state="translated">これらは明示的に書かれることはほとんどありませんが、課題を絞るときに便利ですし、バグをキャッチすることもできます。</target>
        </trans-unit>
        <trans-unit id="07491a8375f8e779f9a5bd9a9bd4a7fcc0120b03" translate="yes" xml:space="preserve">
          <source>These aspects describe a &lt;em&gt;reified, nominal&lt;/em&gt; type system. The types we wrote in the code are present at runtime, and the types are related via their declarations, not their structures.</source>
          <target state="translated">これらの側面は、&lt;em&gt;洗練&lt;/em&gt;された&lt;em&gt;名目&lt;/em&gt;型システムを表しています。コードで記述した型は実行時に存在し、型は構造ではなく宣言を介して関連付けられます。</target>
        </trans-unit>
        <trans-unit id="dae12b77565aa4d0e3a64c99a87302ba66d61702" translate="yes" xml:space="preserve">
          <source>These assertion signatures are very similar to writing type predicate signatures:</source>
          <target state="translated">これらのアサーション署名は、型述語署名を書くのと非常に似ています。</target>
        </trans-unit>
        <trans-unit id="2868190107b9e856775b903db102ff1ea2bbe264" translate="yes" xml:space="preserve">
          <source>These could be imported as</source>
          <target state="translated">これらは、以下のようにインポートすることができます。</target>
        </trans-unit>
        <trans-unit id="580c6c93a64a3803a22f4ceb17224a9f774727aa" translate="yes" xml:space="preserve">
          <source>These examples are ordered in approximately increasing order of complexity.</source>
          <target state="translated">これらの例は、およそ複雑度の高い順に並べられています。</target>
        </trans-unit>
        <trans-unit id="c149ccf644eec42a0be9ed6e4d8cf9bb1991cb19" translate="yes" xml:space="preserve">
          <source>These limitations can cause runtime problems with some TypeScript features like &lt;code&gt;const enum&lt;/code&gt;s and &lt;code&gt;namespace&lt;/code&gt;s. Setting the &lt;code&gt;isolatedModules&lt;/code&gt; flag tells TypeScript to warn you if you write certain code that can&amp;rsquo;t be correctly interpreted by a single-file transpilation process.</source>
          <target state="translated">これらの制限により、 &lt;code&gt;const enum&lt;/code&gt; や &lt;code&gt;namespace&lt;/code&gt; などの一部のTypeScript機能で実行時の問題が発生する可能性があります。 &lt;code&gt;isolatedModules&lt;/code&gt; フラグを設定すると、単一ファイルのトランスパイルプロセスでは正しく解釈できない特定のコードを記述した場合に警告するようにTypeScriptに指示されます。</target>
        </trans-unit>
        <trans-unit id="51753d058d70c80473068ff593cd4ffa3d3364fb" translate="yes" xml:space="preserve">
          <source>These options also persist when sharing links to playground samples, allowing users to more reliably share examples without having to tell the recipient &amp;ldquo;oh, don&amp;rsquo;t forget to turn on the &lt;code&gt;noImplicitAny&lt;/code&gt; option!&amp;rdquo;.</source>
          <target state="translated">これらのオプションは、プレイグラウンドサンプルへのリンクを共有するときにも保持されるため、ユーザーは受信者に「ああ、 &lt;code&gt;noImplicitAny&lt;/code&gt; オプションをオンにすることを忘れないでください！」と伝えなくても、サンプルをより確実に共有できます。</target>
        </trans-unit>
        <trans-unit id="1e044a651893f38dabaa6219c410c2660102bcf0" translate="yes" xml:space="preserve">
          <source>These options make up the bulk of TypeScript&amp;rsquo;s configuration and it covers how the language should work.</source>
          <target state="translated">これらのオプションはTypeScriptの構成の大部分を構成し、言語がどのように機能するかをカバーしています。</target>
        </trans-unit>
        <trans-unit id="405bb1f92dbe539fc19f70e7ed40ea0eb0528ce7" translate="yes" xml:space="preserve">
          <source>These scoping rules can cause several types of mistakes. One problem they exacerbate is the fact that it is not an error to declare the same variable multiple times:</source>
          <target state="translated">これらのスコーピングルールは、いくつかのタイプのミスを引き起こす可能性があります。これらが悪化させる問題の一つは、同じ変数を複数回宣言することはエラーではないという事実です。</target>
        </trans-unit>
        <trans-unit id="869e555c5337a018666cb0666e0939a7d84b21dd" translate="yes" xml:space="preserve">
          <source>These settings are used to define the runtime expectations of your project, how and where you want the JavaScript to be emitted and the level of integration you want with existing JavaScript code.</source>
          <target state="translated">これらの設定は、プロジェクトの実行時の期待値、JavaScriptをどのように、どこで実行するか、既存のJavaScriptコードとの統合のレベルを定義するために使用されます。</target>
        </trans-unit>
        <trans-unit id="5cfb58f6d95b6c9be936d843cbb719495c0847fb" translate="yes" xml:space="preserve">
          <source>These settings help you ensure that TypeScript picks up the right files.</source>
          <target state="translated">これらの設定は、TypeScriptが正しいファイルを確実に拾うようにするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="bed62e5cae7d2c803744fdf8f9b3ad988309267c" translate="yes" xml:space="preserve">
          <source>These warnings are only about code which is provably unreachable due to the use of JavaScript syntax, for example:</source>
          <target state="translated">これらの警告は、例えばJavaScriptの構文を使用しているために到達できないことが証明されているコードに関するものに過ぎません。</target>
        </trans-unit>
        <trans-unit id="5d8c7bb7c664a99b3f99538dd86cbd5a15a993cd" translate="yes" xml:space="preserve">
          <source>They also serve as a method to order the output when using &lt;code&gt;--out&lt;/code&gt; or &lt;code&gt;--outFile&lt;/code&gt;. Files are emitted to the output file location in the same order as the input after preprocessing pass.</source>
          <target state="translated">彼らはまた、使用時に出力を注文する方法として役立つ &lt;code&gt;--out&lt;/code&gt; または &lt;code&gt;--outFile&lt;/code&gt; 。ファイルは、前処理パスの後、入力と同じ順序で出力ファイルの場所に出力されます。</target>
        </trans-unit>
        <trans-unit id="a1ff8d1f085eb2bf495023df7ad3553e1c32cab7" translate="yes" xml:space="preserve">
          <source>They also support replacing the &lt;code&gt;exports&lt;/code&gt; object with a custom single object. Default exports are meant to act as a replacement for this behavior; however, the two are incompatible. TypeScript supports &lt;code&gt;export =&lt;/code&gt; to model the traditional CommonJS and AMD workflow.</source>
          <target state="translated">また、 &lt;code&gt;exports&lt;/code&gt; オブジェクトをカスタムの単一オブジェクトに置き換えることもできます。デフォルトのエクスポートは、この動作の代わりとして機能することを意図しています。ただし、2つは互換性がありません。TypeScriptは &lt;code&gt;export =&lt;/code&gt; をサポートし、従来のCommonJSおよびAMDワークフローをモデル化します。</target>
        </trans-unit>
        <trans-unit id="7e47c0cafef6daabbdf34e9389714c2f70664891" translate="yes" xml:space="preserve">
          <source>They are like &lt;code&gt;let&lt;/code&gt; declarations but, as their name implies, their value cannot be changed once they are bound. In other words, they have the same scoping rules as &lt;code&gt;let&lt;/code&gt;, but you can&amp;rsquo;t re-assign to them.</source>
          <target state="translated">それらは &lt;code&gt;let&lt;/code&gt; 宣言に似ていますが、その名前が示すように、いったんバインドされるとその値は変更できません。言い換えると、それらには &lt;code&gt;let&lt;/code&gt; と同じスコープ規則がありますが、それらに再割り当てすることはできません。</target>
        </trans-unit>
        <trans-unit id="3ba589ad465e9addde0a355ab070f5063bbe5659" translate="yes" xml:space="preserve">
          <source>They can also be declared as constructor functions, as described in the next section:</source>
          <target state="translated">また、次のセクションで説明するように、コンストラクタ関数として宣言することもできます。</target>
        </trans-unit>
        <trans-unit id="269cb00928fdbd9243a3c0e9855fdf73711ca39b" translate="yes" xml:space="preserve">
          <source>They will rarely have:</source>
          <target state="translated">彼らはほとんど持っていないでしょう。</target>
        </trans-unit>
        <trans-unit id="940ca9be4b3687b9409fbf0f5e6bf12d6da31f65" translate="yes" xml:space="preserve">
          <source>Things to look out for</source>
          <target state="translated">気をつけたいこと</target>
        </trans-unit>
        <trans-unit id="aba97e7fae57c949d932eff408211c64dbd34e1b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;package.json&lt;/code&gt; tells TypeScript to check whether the current version of TypeScript is running. If it&amp;rsquo;s 3.1 or later, it figures out the path you&amp;rsquo;ve imported relative to the package, and reads from the package&amp;rsquo;s &lt;code&gt;ts3.1&lt;/code&gt; folder. That&amp;rsquo;s what that &lt;code&gt;{ &quot;*&quot;: [&quot;ts3.1/*&quot;] }&lt;/code&gt; means - if you&amp;rsquo;re familiar with path mapping today, it works exactly like that.</source>
          <target state="translated">この &lt;code&gt;package.json&lt;/code&gt; は、TypeScriptに、現在のバージョンのTypeScriptが実行されているかどうかを確認するように指示します。それが3.1以降の場合、インポートしたパスはパッケージからの相対パスであり、パッケージの &lt;code&gt;ts3.1&lt;/code&gt; フォルダーから読み取ります。これが &lt;code&gt;{ &quot;*&quot;: [&quot;ts3.1/*&quot;] }&lt;/code&gt; 意味です。今日のパスマッピングに精通している場合は、まったく同じように機能します。</target>
        </trans-unit>
        <trans-unit id="2359d0122889cba1caee9c6fd11f3a61b8a57f14" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;tsconfig.json&lt;/code&gt; file will &lt;em&gt;only&lt;/em&gt; include &lt;code&gt;./node_modules/@types/node&lt;/code&gt;, &lt;code&gt;./node_modules/@types/jest&lt;/code&gt; and &lt;code&gt;./node_modules/@types/express&lt;/code&gt;. Other packages under &lt;code&gt;node_modules/@types/*&lt;/code&gt; will not be included.</source>
          <target state="translated">この &lt;code&gt;tsconfig.json&lt;/code&gt; のファイルがされます&lt;em&gt;のみ&lt;/em&gt;含ま &lt;code&gt;./node_modules/@types/node&lt;/code&gt; 、 &lt;code&gt;./node_modules/@types/jest&lt;/code&gt; と &lt;code&gt;./node_modules/@types/express&lt;/code&gt; を。 &lt;code&gt;node_modules/@types/*&lt;/code&gt; 下にある他のパッケージは含まれません。</target>
        </trans-unit>
        <trans-unit id="9579349a7f6081ccc0cfa7ee1c3ba7cecdaeb554" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;tsconfig.json&lt;/code&gt; file will &lt;em&gt;only&lt;/em&gt; include &lt;code&gt;./node_modules/@types/node&lt;/code&gt;, &lt;code&gt;./node_modules/@types/lodash&lt;/code&gt; and &lt;code&gt;./node_modules/@types/express&lt;/code&gt;. Other packages under &lt;code&gt;node_modules/@types/*&lt;/code&gt; will not be included.</source>
          <target state="translated">この &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルには、. &lt;code&gt;./node_modules/@types/lodash&lt;/code&gt; / &lt;code&gt;./node_modules/@types/express&lt;/code&gt; types / node、 . /node_modules / @ &lt;code&gt;./node_modules/@types/node&lt;/code&gt; / lodashおよび./node_modules/@types/express &lt;em&gt;のみが&lt;/em&gt;含まれます。 &lt;code&gt;node_modules/@types/*&lt;/code&gt; 下の他のパッケージは含まれません。</target>
        </trans-unit>
        <trans-unit id="0ee5dcc9ee441574b7eb98ac0562e02ba448d0a4" translate="yes" xml:space="preserve">
          <source>This TSX file:</source>
          <target state="translated">このTSXファイル。</target>
        </trans-unit>
        <trans-unit id="3d382992de7bc0c7358c5e70b64fbab9df6f3d2b" translate="yes" xml:space="preserve">
          <source>This adds the &lt;code&gt;copy-html&lt;/code&gt; task and adds it as a dependency of &lt;code&gt;default&lt;/code&gt;. That means any time &lt;code&gt;default&lt;/code&gt; is run, &lt;code&gt;copy-html&lt;/code&gt; has to run first. We&amp;rsquo;ve also changed &lt;code&gt;default&lt;/code&gt; to call Browserify with the tsify plugin instead of gulp-typescript. Conveniently, they both allow us to pass the same options object to the TypeScript compiler.</source>
          <target state="translated">これにより、 &lt;code&gt;copy-html&lt;/code&gt; タスクが追加され、 &lt;code&gt;default&lt;/code&gt; の依存関係として追加されます。つまり、 &lt;code&gt;default&lt;/code&gt; が実行されるときは常に、 &lt;code&gt;copy-html&lt;/code&gt; が最初に実行される必要があります。また、gulp-typescriptの代わりにtsifyプラグインを使用してBrowserifyを呼び出すように &lt;code&gt;default&lt;/code&gt; を変更しました。便利なことに、どちらも同じオプションオブジェクトをTypeScriptコンパイラに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="99d926e2aab031119cddb8cc6d74ab38f013eea1" translate="yes" xml:space="preserve">
          <source>This allows for creating classes which only work with constrained base classes:</source>
          <target state="translated">これにより、制約のある基底クラスのみで動作するクラスを作成することができます。</target>
        </trans-unit>
        <trans-unit id="11d95bac2d09fc97059fde1a2be78410f1aaaa65" translate="yes" xml:space="preserve">
          <source>This also applies to numeric and string literals.</source>
          <target state="translated">これは、数値リテラルや文字列リテラルにも適用されます。</target>
        </trans-unit>
        <trans-unit id="4819d75c2e64c6891ffbc7a26bcbfbdf36fb3616" translate="yes" xml:space="preserve">
          <source>This also means that TypeScript never changes the &lt;em&gt;behavior&lt;/em&gt; of your program based on the types it inferred. The bottom line is that while you might see type errors during compilation, the type system itself has no bearing on how your program works when it runs.</source>
          <target state="translated">これは、TypeScriptが推測したタイプに基づいてプログラムの&lt;em&gt;動作&lt;/em&gt;を変更しないことも意味します。要するに、コンパイル中に型エラーが発生する可能性はありますが、型システム自体は、プログラムの実行時の動作には関係ありません。</target>
        </trans-unit>
        <trans-unit id="adfedec845a057971771ae75a777e3b399a6fbc9" translate="yes" xml:space="preserve">
          <source>This also works in JSDoc comments to refer to types from other modules in &lt;code&gt;.js&lt;/code&gt;:</source>
          <target state="translated">これはJSDocコメントでも機能し、 &lt;code&gt;.js&lt;/code&gt; の他のモジュールの型を参照します。</target>
        </trans-unit>
        <trans-unit id="a19ba44e9cf17a28dc6b2832d656e62612a977fa" translate="yes" xml:space="preserve">
          <source>This also works with classes:</source>
          <target state="translated">これはクラスでも通用します。</target>
        </trans-unit>
        <trans-unit id="7a7e8768f821cc2763fea56792bd65a0c49d075d" translate="yes" xml:space="preserve">
          <source>This asserts the variable &lt;code&gt;bar&lt;/code&gt; to have the type &lt;code&gt;foo&lt;/code&gt;. Since TypeScript also uses angle brackets for type assertions, combining it with JSX&amp;rsquo;s syntax would introduce certain parsing difficulties. As a result, TypeScript disallows angle bracket type assertions in &lt;code&gt;.tsx&lt;/code&gt; files.</source>
          <target state="translated">これは、変数 &lt;code&gt;bar&lt;/code&gt; がタイプ &lt;code&gt;foo&lt;/code&gt; を持つことを表明します。TypeScriptもタイプアサーションに山かっこを使用するため、JSXの構文と組み合わせると特定の解析が困難になります。その結果、TypeScriptは &lt;code&gt;.tsx&lt;/code&gt; ファイルで山かっこ型のアサーションを許可しません。</target>
        </trans-unit>
        <trans-unit id="f85fb60fbb15b3106e3e22c3ddc01338d2c58122" translate="yes" xml:space="preserve">
          <source>This can be considered a &amp;lsquo;fast &amp;amp; loose&amp;rsquo; implementation of the watching algorithm, which can drastically reduce incremental rebuild times at the expense of having to run the full build occasionally to get all compiler error messages.</source>
          <target state="translated">これは、監視アルゴリズムの「高速で緩い」実装と見なすことができます。これにより、すべてのコンパイラエラーメッセージを取得するためにフルビルドを時々実行する必要がありますが、増分再構築時間を大幅に短縮できます。</target>
        </trans-unit>
        <trans-unit id="b5432dead64ccc9df023d2796e15b77df708ad37" translate="yes" xml:space="preserve">
          <source>This can be described by the following &lt;code&gt;.d.ts&lt;/code&gt;:</source>
          <target state="translated">これは、次の &lt;code&gt;.d.ts&lt;/code&gt; で説明できます。</target>
        </trans-unit>
        <trans-unit id="162b366ea578762d34bc51102f5149c7ad80c399" translate="yes" xml:space="preserve">
          <source>This can be described with:</source>
          <target state="translated">で記述することができます。</target>
        </trans-unit>
        <trans-unit id="123d0f06d6b292d7403ffa347023235e01b1d1ba" translate="yes" xml:space="preserve">
          <source>This can be used to pipe output between commands as well.</source>
          <target state="translated">これは、コマンド間の出力をパイプするためにも使用できます。</target>
        </trans-unit>
        <trans-unit id="f4889f2abe4cb3d690ec344d9cb1060645946ee3" translate="yes" xml:space="preserve">
          <source>This can cause quite a bit of fallout for existing code that use inheritance. First of all, &lt;code&gt;set&lt;/code&gt; accessors from base classes won&amp;rsquo;t get triggered - they&amp;rsquo;ll be completely overwritten.</source>
          <target state="translated">これは、継承を使用する既存のコードにかなりの影響を与える可能性があります。まず、基本クラスからの &lt;code&gt;set&lt;/code&gt; アクセサーはトリガーされません-完全に上書きされます。</target>
        </trans-unit>
        <trans-unit id="ec76fbaf129c54c7b42ac5e553e9239c220251e5" translate="yes" xml:space="preserve">
          <source>This can cause some errors to be missed, for example:</source>
          <target state="translated">これにより、例えば、いくつかのエラーを見逃してしまうことがあります。</target>
        </trans-unit>
        <trans-unit id="2cf2abd7a18f1f7062668c3033dddcc6ad2c2d8e" translate="yes" xml:space="preserve">
          <source>This can even be used to enable &lt;code&gt;enum&lt;/code&gt;-like patterns in plain JavaScript code if you choose not to use TypeScript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt; construct.</source>
          <target state="translated">TypeScriptの &lt;code&gt;enum&lt;/code&gt; コンストラクトを使用しないことを選択した場合、これを使用して、プレーンJavaScriptコードで &lt;code&gt;enum&lt;/code&gt; のようなパターンを有効にすることもできます。</target>
        </trans-unit>
        <trans-unit id="13a6f89fe3172b6cbc2af9517a59da3931faf315" translate="yes" xml:space="preserve">
          <source>This can go beyond basic functions with &lt;code&gt;@param&lt;/code&gt; tags too, where the following example:</source>
          <target state="translated">これは、 &lt;code&gt;@param&lt;/code&gt; タグを使用した基本的な関数だけでなく、次の例でも使用できます。</target>
        </trans-unit>
        <trans-unit id="608ec68b1f29faf0c91c96f151172e130a6c7a7f" translate="yes" xml:space="preserve">
          <source>This can save time during compilation at the expense of type-system accuracy. For example, two libraries could define two copies of the same &lt;code&gt;type&lt;/code&gt; in an inconsistent way. Rather than doing a full check of all &lt;code&gt;d.ts&lt;/code&gt; files, TypeScript will type check the code you specifically refer to in your app&amp;rsquo;s source code.</source>
          <target state="translated">これにより、型システムの精度を犠牲にして、コンパイル中の時間を節約できます。たとえば、2つのライブラリが、一貫性のない方法で同じ &lt;code&gt;type&lt;/code&gt; 2つのコピーを定義する可能性があります。TypeScriptは、すべての &lt;code&gt;d.ts&lt;/code&gt; ファイルを完全にチェックするのではなく、アプリのソースコードで具体的に参照しているコードをタイプチェックします。</target>
        </trans-unit>
        <trans-unit id="40d488fa879599b4c63bd3bca5b46fe16933b383" translate="yes" xml:space="preserve">
          <source>This change entails a break in the behavior of extending built-in classes like &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc.. Please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-changes.html#extending-built-ins-like-error-array-and-map-may-no-longer-work&quot;&gt;extending built-ins breaking change documentation&lt;/a&gt; for more details.</source>
          <target state="translated">この変更により、 &lt;code&gt;Error&lt;/code&gt; 、 &lt;code&gt;Array&lt;/code&gt; 、 &lt;code&gt;Map&lt;/code&gt; などの組み込みクラスを拡張する動作が壊れます。詳細については、&lt;a href=&quot;https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-changes.html#extending-built-ins-like-error-array-and-map-may-no-longer-work&quot;&gt;組み込み&lt;/a&gt;の拡張機能を壊す変更のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="0a82b6976a332dfa14dda6dd898339b3d9c8f2c3" translate="yes" xml:space="preserve">
          <source>This check is a breaking change, but for that reason the checks are very conservative. This error is only issued in &lt;code&gt;if&lt;/code&gt; conditions, and it is not issued on optional properties, if &lt;code&gt;strictNullChecks&lt;/code&gt; is off, or if the function is later called within the body of the &lt;code&gt;if&lt;/code&gt;:</source>
          <target state="translated">このチェックは重大な変更ですが、そのため、チェックは非常に保守的です。このエラーはのみで発行された &lt;code&gt;if&lt;/code&gt; の条件、それはオプションのプロパティで発行されていない、場合 &lt;code&gt;strictNullChecks&lt;/code&gt; がオフになっている、または機能が後の本体内で呼び出された場合 &lt;code&gt;if&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="374f1cb2ee64d2f9699be7c65dce331865c022ca" translate="yes" xml:space="preserve">
          <source>This code raises an error because there isn&amp;rsquo;t a &lt;code&gt;default&lt;/code&gt; object which you can import. Even though it feels like it should. For convenience, transpilers like Babel will automatically create a default if one isn&amp;rsquo;t created. Making the module look a bit more like:</source>
          <target state="translated">インポートできる &lt;code&gt;default&lt;/code&gt; オブジェクトがないため、このコードはエラーを発生させます。あるべきだと感じても。便宜上、Babelのようなトランスパイラーは、デフォルトが作成されていない場合、自動的にデフォルトを作成します。モジュールをもう少し次のように見せます。</target>
        </trans-unit>
        <trans-unit id="776023497afd78ba896c5a8759ad07ba14168072" translate="yes" xml:space="preserve">
          <source>This comparison process proceeds recursively, exploring the type of each member and sub-member.</source>
          <target state="translated">この比較処理は、各メンバーとサブメンバーの種類を探りながら、再帰的に進行する。</target>
        </trans-unit>
        <trans-unit id="afe60521b82bce04c80aea228c02c6ad2c6227cb" translate="yes" xml:space="preserve">
          <source>This config file will include &lt;em&gt;all&lt;/em&gt; packages under &lt;code&gt;./typings&lt;/code&gt; and &lt;code&gt;./vendor/types&lt;/code&gt;, and no packages from &lt;code&gt;./node_modules/@types&lt;/code&gt;. All paths are relative to the &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="translated">この構成ファイルには、。 &lt;code&gt;./typings&lt;/code&gt; および &lt;code&gt;./vendor/types&lt;/code&gt; の下にある&lt;em&gt;すべての&lt;/em&gt;パッケージが含まれ、。/ node_modules / @typesからのパッケージは &lt;code&gt;./node_modules/@types&lt;/code&gt; ません。すべてのパスは &lt;code&gt;tsconfig.json&lt;/code&gt; を基準にしています。</target>
        </trans-unit>
        <trans-unit id="a70378c4e2e85fc0285bab20719f721947598d23" translate="yes" xml:space="preserve">
          <source>This config file will include &lt;em&gt;all&lt;/em&gt; packages under &lt;code&gt;./typings&lt;/code&gt;, and no packages from &lt;code&gt;./node_modules/@types&lt;/code&gt;.</source>
          <target state="translated">この設定ファイルには含まれています&lt;em&gt;すべて&lt;/em&gt;の下のパッケージ &lt;code&gt;./typings&lt;/code&gt; から、ノーパッケージを &lt;code&gt;./node_modules/@types&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d8fdc1796e3b4fc005d6e6e0a36a51b7eee8ba1" translate="yes" xml:space="preserve">
          <source>This creates a &lt;code&gt;package.json&lt;/code&gt; file with default values.</source>
          <target state="translated">これにより、デフォルト値を含む &lt;code&gt;package.json&lt;/code&gt; ファイルが作成されます。</target>
        </trans-unit>
        <trans-unit id="2651ac880cf2ead1dcccdb902c01397e29e5f2d0" translate="yes" xml:space="preserve">
          <source>This creates new variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from &lt;code&gt;o.a&lt;/code&gt; and &lt;code&gt;o.b&lt;/code&gt;. Notice that you can skip &lt;code&gt;c&lt;/code&gt; if you don&amp;rsquo;t need it.</source>
          <target state="translated">これにより、 &lt;code&gt;o.a&lt;/code&gt; および &lt;code&gt;o.b&lt;/code&gt; から新しい変数 &lt;code&gt;a&lt;/code&gt; および &lt;code&gt;b&lt;/code&gt; が作成されます。必要ない場合は、 &lt;code&gt;c&lt;/code&gt; をスキップできることに注意してください。</target>
        </trans-unit>
        <trans-unit id="cbec995fccd02fc21b46f9fd4af298cd4d2053ad" translate="yes" xml:space="preserve">
          <source>This creates two new variables named &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. This is equivalent to using indexing, but is much more convenient:</source>
          <target state="translated">これにより、 &lt;code&gt;first&lt;/code&gt; および &lt;code&gt;second&lt;/code&gt; という名前の2つの新しい変数が作成されます。これはインデックスを使用するのと同じですが、はるかに便利です。</target>
        </trans-unit>
        <trans-unit id="a31ee5e23e03dea8a90fcb22ead8da9a4160723e" translate="yes" xml:space="preserve">
          <source>This defaults to &lt;code&gt;false&lt;/code&gt;, making it easier to work with TypeScript in a watch-like environment where you may want to see results of changes to your code in another environment before making sure all errors are resolved.</source>
          <target state="translated">これはデフォルトで &lt;code&gt;false&lt;/code&gt; に設定されているため、すべてのエラーが解決されたことを確認する前に、別の環境でコードへの変更の結果を確認したい時計のような環境でTypeScriptを簡単に操作できます。</target>
        </trans-unit>
        <trans-unit id="c3290579796b51867665bf805e46b6cb71dde74e" translate="yes" xml:space="preserve">
          <source>This directive allows a file to explicitly include an existing built-in &lt;em&gt;lib&lt;/em&gt; file.</source>
          <target state="translated">このディレクティブを使用すると、ファイルに既存の組み込み&lt;em&gt;lib&lt;/em&gt;ファイルを明示的に含めることができます。</target>
        </trans-unit>
        <trans-unit id="1a906b1f2cf088a2c6bf34b58e9c21658e73cc20" translate="yes" xml:space="preserve">
          <source>This directive instructs the compiler to &lt;em&gt;not&lt;/em&gt; include the default library (i.e. &lt;code&gt;lib.d.ts&lt;/code&gt;) in the compilation. The impact here is similar to passing &lt;code&gt;--noLib&lt;/code&gt; on the command line.</source>
          <target state="translated">このディレクティブは、デフォルトのライブラリー（つまり &lt;code&gt;lib.d.ts&lt;/code&gt; ）をコンパイルに含め&lt;em&gt;ない&lt;/em&gt;ようにコンパイラーに指示します。ここでの影響は、コマンドラインで &lt;code&gt;--noLib&lt;/code&gt; を渡すのと同じです。</target>
        </trans-unit>
        <trans-unit id="e85416c60d1e180f7e4e1a690b36612a078e4bd6" translate="yes" xml:space="preserve">
          <source>This directive marks a file as a &lt;em&gt;default library&lt;/em&gt;. You will see this comment at the top of &lt;code&gt;lib.d.ts&lt;/code&gt; and its different variants.</source>
          <target state="translated">このディレクティブは、ファイルを&lt;em&gt;デフォルトのライブラリ&lt;/em&gt;としてマークします。このコメントは &lt;code&gt;lib.d.ts&lt;/code&gt; とそのさまざまなバリアントの上部に表示されます。</target>
        </trans-unit>
        <trans-unit id="a4de1039913e973b35b634a72b6cbe6e6a97bca6" translate="yes" xml:space="preserve">
          <source>This disables reporting of excess property errors, such as the one shown in the following example:</source>
          <target state="translated">これにより、以下の例のような過剰なプロパティ・エラーの報告を無効にします。</target>
        </trans-unit>
        <trans-unit id="9d44ce0ab64cf8784d2c30b139d5f95c5d7e18fd" translate="yes" xml:space="preserve">
          <source>This distinction is subtle and important &amp;mdash; here, &lt;code&gt;A.B&lt;/code&gt; is not necessarily a type or a value.</source>
          <target state="translated">この区別は微妙で重要です。ここでは、 &lt;code&gt;A.B&lt;/code&gt; は必ずしもタイプまたは値ではありません。</target>
        </trans-unit>
        <trans-unit id="abd1b0ae2b28ffc07ff533b5aa3e34f0a7dbd996" translate="yes" xml:space="preserve">
          <source>This distinction is subtle and important &amp;ndash; here, &lt;code&gt;A.B&lt;/code&gt; is not necessarily a type or a value.</source>
          <target state="translated">この区別は微妙で重要です。ここでは、 &lt;code&gt;A.B&lt;/code&gt; は必ずしも型または値ではありません。</target>
        </trans-unit>
        <trans-unit id="a93e12d2539079ddf00741243f25ccfa0ea0beac" translate="yes" xml:space="preserve">
          <source>This doc is a high level overview of the syntax and types you would use in everyday code. From here you should:</source>
          <target state="translated">このドキュメントは、日常のコードで使用する構文と型についての高レベルの概要です。ここからは、あなたがすべきことです。</target>
        </trans-unit>
        <trans-unit id="9f2afe5428bad556646a3ee1b89d282383eef7d8" translate="yes" xml:space="preserve">
          <source>This does not affect errors on the basis of code which &lt;em&gt;appears&lt;/em&gt; to be unreachable due to type analysis.</source>
          <target state="translated">これは、型分析のために到達できないように&lt;em&gt;見える&lt;/em&gt;コードに基づくエラーには影響しません。</target>
        </trans-unit>
        <trans-unit id="235deb669a8da9c7c9faf57f9268bb2d8bdddfcd" translate="yes" xml:space="preserve">
          <source>This does not affect how TypeScript emits JavaScript, it only emulates the assumption that they will be able to work via those relative paths at runtime.</source>
          <target state="translated">これは TypeScript が JavaScript をどのようにエミュレートするかには影響しません。</target>
        </trans-unit>
        <trans-unit id="8238728f0c2b5909a1676078b8fa412e525129da" translate="yes" xml:space="preserve">
          <source>This essentially makes such &lt;code&gt;const enums&lt;/code&gt; a source-code feature only, with no runtime traces.</source>
          <target state="translated">これにより、基本的に、このような &lt;code&gt;const enums&lt;/code&gt; はソースコード機能のみになり、実行時のトレースはありません。</target>
        </trans-unit>
        <trans-unit id="1ff3a8b47ad881c651ae743e22e2477b1a56f987" translate="yes" xml:space="preserve">
          <source>This example covers a few other features we didn&amp;rsquo;t previously mention. Again, we see the &lt;code&gt;extends&lt;/code&gt; keywords used to create two new subclasses of &lt;code&gt;Animal&lt;/code&gt;: &lt;code&gt;Horse&lt;/code&gt; and &lt;code&gt;Snake&lt;/code&gt;.</source>
          <target state="translated">この例では、これまでに触れなかった他のいくつかの機能について説明します。ここでも、私たちは見 &lt;code&gt;extends&lt;/code&gt; の二つの新しいサブクラスを作成するために使用するキーワード &lt;code&gt;Animal&lt;/code&gt; ： &lt;code&gt;Horse&lt;/code&gt; と &lt;code&gt;Snake&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7234716f41fc7048658a32b671efefbe1e85d8e" translate="yes" xml:space="preserve">
          <source>This example is a good case for &lt;a href=&quot;../../generics#generic-types&quot;&gt;using generics&lt;/a&gt; to provide richer type information:</source>
          <target state="translated">この例は、&lt;a href=&quot;../../generics#generic-types&quot;&gt;ジェネリックス&lt;/a&gt;を使用してより豊富な型情報を提供するための良いケースです。</target>
        </trans-unit>
        <trans-unit id="151213ee16168c64e5b83bc91d8ae73927961489" translate="yes" xml:space="preserve">
          <source>This example shows the most basic inheritance feature: classes inherit properties and methods from base classes. Here, &lt;code&gt;Dog&lt;/code&gt; is a &lt;em&gt;derived&lt;/em&gt; class that derives from the &lt;code&gt;Animal&lt;/code&gt;&lt;em&gt;base&lt;/em&gt; class using the &lt;code&gt;extends&lt;/code&gt; keyword. Derived classes are often called &lt;em&gt;subclasses&lt;/em&gt;, and base classes are often called &lt;em&gt;superclasses&lt;/em&gt;.</source>
          <target state="translated">この例は、最も基本的な継承機能を示しています。クラスは、基本クラスからプロパティとメソッドを継承します。ここで、 &lt;code&gt;Dog&lt;/code&gt; は &lt;code&gt;extends&lt;/code&gt; キーワードを使用して &lt;code&gt;Animal&lt;/code&gt; &lt;em&gt;基本&lt;/em&gt;クラスから&lt;em&gt;派生し&lt;/em&gt;た&lt;em&gt;派生&lt;/em&gt;クラスです。派生クラスはしばしば&lt;em&gt;サブクラス&lt;/em&gt;と呼ばれ、基本クラスはしばしば&lt;em&gt;スーパークラス&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="80d233484614ac1a8184eec3cb1a1f5b233a8926" translate="yes" xml:space="preserve">
          <source>This feature can be extremely useful for bigger organizations, or projects with lots of distributed dependencies.</source>
          <target state="translated">この機能は、大規模な組織や、多くの分散依存関係を持つプロジェクトでは非常に便利です。</target>
        </trans-unit>
        <trans-unit id="be730b705da0032c97a8590e06766b7025ca507f" translate="yes" xml:space="preserve">
          <source>This feature differs from &lt;a href=&quot;#typeRoots&quot;&gt;&lt;code&gt;typeRoots&lt;/code&gt;&lt;/a&gt; in that it is about specifying only the exact types you want included, whereas &lt;a href=&quot;#typeRoots&quot;&gt;&lt;code&gt;typeRoots&lt;/code&gt;&lt;/a&gt; supports saying you want particular folders.</source>
          <target state="translated">この機能は&lt;a href=&quot;#typeRoots&quot;&gt; &lt;code&gt;typeRoots&lt;/code&gt; &lt;/a&gt;とは異なり、含めるタイプを正確に指定するだけですが、&lt;a href=&quot;#typeRoots&quot;&gt; &lt;code&gt;typeRoots&lt;/code&gt; &lt;/a&gt;は特定のフォルダーが必要であると言うことをサポートしています。</target>
        </trans-unit>
        <trans-unit id="145fabdb6e03da0d5218bdc18d27ee6b68f3aaae" translate="yes" xml:space="preserve">
          <source>This feature is currently supported in Visual Studio 2015 with TypeScript 1.8.4 and above, and &lt;a href=&quot;https://github.com/TypeStrong/atom-typescript#compile-on-save&quot;&gt;atom-typescript&lt;/a&gt; plugin.</source>
          <target state="translated">この機能は現在、Visual Studio 2015でTypeScript 1.8.4以降と&lt;a href=&quot;https://github.com/TypeStrong/atom-typescript#compile-on-save&quot;&gt;atom-typescript&lt;/a&gt;プラグインを使用してサポートされています。</target>
        </trans-unit>
        <trans-unit id="e14bf01780560294d3e709ab1eca2529b0526ee5" translate="yes" xml:space="preserve">
          <source>This feature means that types that would otherwise be used just to hint immutability to the compiler can often be omitted.</source>
          <target state="translated">この機能は、そうでなければコンパイラに不変性をほのめかすためだけに使用されていた型を省略できることが多いことを意味します。</target>
        </trans-unit>
        <trans-unit id="e0a1a44534d41eb6308a076407d6c354572ba0dd" translate="yes" xml:space="preserve">
          <source>This feature was supported before TypeScript 2.1, but only when targeting ES6/ES2015. TypeScript 2.1 brings the capability to ES3 and ES5 run-times, meaning you&amp;rsquo;ll be free to take advantage of it no matter what environment you&amp;rsquo;re using.</source>
          <target state="translated">この機能はTypeScript 2.1より前にサポートされていましたが、ES6 / ES2015を対象とする場合のみでした。TypeScript 2.1は、ES3およびES5ランタイムに機能を提供します。つまり、使用している環境に関係なく、それを自由に利用できます。</target>
        </trans-unit>
        <trans-unit id="9421d77a04111011ab6beef18cfeb6c8d63af606" translate="yes" xml:space="preserve">
          <source>This file can be opened in a chromium based browser like Chrome or Edge Developer in &lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution&quot;&gt;the CPU profiler&lt;/a&gt; section. You can learn more about understanding the compilers performance in the &lt;a href=&quot;https://github.com/microsoft/TypeScript/wiki/Performance&quot;&gt;TypeScript wiki section on performance&lt;/a&gt;.</source>
          <target state="translated">このファイルは&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution&quot;&gt;、CPUプロファイラー&lt;/a&gt;セクションのChromeやEdgeDeveloperなどのクロムベースのブラウザーで開くことができます。コンパイラのパフォーマンスの理解について詳しくは、パフォーマンス&lt;a href=&quot;https://github.com/microsoft/TypeScript/wiki/Performance&quot;&gt;に関するTypeScriptwikiセクションを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="03daf218ff5e7e04ba0dbd060b544935bee12587" translate="yes" xml:space="preserve">
          <source>This flag also exhibits the opposite behavior to Webpack&amp;rsquo;s &lt;code&gt;resolve.symlinks&lt;/code&gt; option (i.e. setting TypeScript&amp;rsquo;s &lt;code&gt;preserveSymlinks&lt;/code&gt; to true parallels setting Webpack&amp;rsquo;s &lt;code&gt;resolve.symlinks&lt;/code&gt; to false, and vice-versa).</source>
          <target state="translated">このフラグは、Webpackの &lt;code&gt;resolve.symlinks&lt;/code&gt; オプションとは逆の動作も示します（つまり、TypeScriptの &lt;code&gt;preserveSymlinks&lt;/code&gt; をtrueに設定すると、Webpackの &lt;code&gt;resolve.symlinks&lt;/code&gt; はfalseに設定され、その逆も同様です）。</target>
        </trans-unit>
        <trans-unit id="5b3c28c49643333e70e3aa93241b77d9ccca003c" translate="yes" xml:space="preserve">
          <source>This flag can be used as a way to incrementally add TypeScript files into JS projects by allowing the &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files to live along-side existing JavaScript files.</source>
          <target state="translated">このフラグは、インクリメンタルに可能にすることによって、JSプロジェクトに活字体のファイルを追加する方法として使用することができます &lt;code&gt;.ts&lt;/code&gt; と &lt;code&gt;.tsx&lt;/code&gt; 既存のJavaScriptファイル側に沿って生きるためにファイルを。</target>
        </trans-unit>
        <trans-unit id="beef474bfe013c43dfd3fc9834ca6f76a220aa71" translate="yes" xml:space="preserve">
          <source>This flag can be used to remove that check.</source>
          <target state="translated">このフラグは、そのチェックを削除するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="02550f5639d55abc97d434d6a95eabab62ce1e5d" translate="yes" xml:space="preserve">
          <source>This flag changes the &lt;code&gt;keyof&lt;/code&gt; type operator to return &lt;code&gt;string&lt;/code&gt; instead of &lt;code&gt;string | number&lt;/code&gt; when applied to a type with a string index signature.</source>
          <target state="translated">このフラグは、 &lt;code&gt;keyof&lt;/code&gt; type演算子を変更して &lt;code&gt;string | number&lt;/code&gt; ではなく &lt;code&gt;string&lt;/code&gt; を返します。文字列インデックスシグネチャを持つタイプに適用される場合の数値。</target>
        </trans-unit>
        <trans-unit id="92fdd70a602e988b83dd1c9ee9e588260d2cf64b" translate="yes" xml:space="preserve">
          <source>This flag controls how &lt;code&gt;import&lt;/code&gt; works, there are 3 different options:</source>
          <target state="translated">このフラグは、 &lt;code&gt;import&lt;/code&gt; 動作を制御します。3つの異なるオプションがあります。</target>
        </trans-unit>
        <trans-unit id="398bb4b75ca048c92726a3040a7e54918a529c96" translate="yes" xml:space="preserve">
          <source>This flag does not affect the JavaScript emitted by TypeScript, it only for the type checking. This option brings the behavior of TypeScript in-line with Babel, where extra code is emitted to make using a default export of a module more ergonomic.</source>
          <target state="translated">このフラグは TypeScript によって生成される JavaScript には影響を与えず、型チェックにのみ影響を与えます。このオプションは TypeScript の挙動を Babel と同列にします。</target>
        </trans-unit>
        <trans-unit id="1c54f09bdcf2f574ecdbd28c8e632480e1cbf37e" translate="yes" xml:space="preserve">
          <source>This flag is can only be used when &lt;a href=&quot;#allowJs&quot;&gt;&lt;code&gt;allowJs&lt;/code&gt;&lt;/a&gt; is enabled, and is used if you want to have TypeScript infer types for all of the JavaScript inside your &lt;code&gt;node_modules&lt;/code&gt;.</source>
          <target state="translated">このフラグは、&lt;a href=&quot;#allowJs&quot;&gt; &lt;code&gt;allowJs&lt;/code&gt; &lt;/a&gt;が有効になっている場合にのみ使用でき、 &lt;code&gt;node_modules&lt;/code&gt; 内のすべてのJavaScriptのタイプをTypeScriptで推測する場合に使用されます。</target>
        </trans-unit>
        <trans-unit id="abe930b46ead3b4863a06b153b429c72e1989bb9" translate="yes" xml:space="preserve">
          <source>This flag is something you can use to increase responsiveness in large composite projects.</source>
          <target state="translated">このフラグは、大規模な複合プロジェクトで応答性を高めるために使用することができます。</target>
        </trans-unit>
        <trans-unit id="26c5bbc71b97120a03c50e10dd688658f1a73436" translate="yes" xml:space="preserve">
          <source>This flag is used as part of migrating to the upcoming standard version of class fields. TypeScript introduced class fields many years before it was ratified in TC39. The latest version of the upcoming specification has a different runtime behavior to TypeScript&amp;rsquo;s implementation but the same syntax.</source>
          <target state="translated">このフラグは、クラスフィールドの今後の標準バージョンへの移行の一部として使用されます。TypeScriptは、TC39で承認される何年も前に、クラスフィールドを導入しました。今後の仕様の最新バージョンでは、TypeScriptの実装とは実行時の動作が異なりますが、構文は同じです。</target>
        </trans-unit>
        <trans-unit id="c7614651c915d92a89c51c2b71b121f1d197ef79" translate="yes" xml:space="preserve">
          <source>This flag is used to help people keep this behavior from &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#support-number-and-symbol-named-properties-with-keyof-and-mapped-types&quot;&gt;before TypeScript 2.9&amp;rsquo;s release&lt;/a&gt;.</source>
          <target state="translated">このフラグは、&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#support-number-and-symbol-named-properties-with-keyof-and-mapped-types&quot;&gt;TypeScript2.9のリリース前&lt;/a&gt;からこの動作を維持するために使用されます。</target>
        </trans-unit>
        <trans-unit id="2f97d0d2ab256285ee26208bdac4978420f77519" translate="yes" xml:space="preserve">
          <source>This flag is useful in two cases:</source>
          <target state="translated">このフラグは次の2つの場合に便利です。</target>
        </trans-unit>
        <trans-unit id="69247477a2922fa672b9ac6953e5f0f9de79aa95" translate="yes" xml:space="preserve">
          <source>This flag switches to the upcoming ECMA runtime behavior.</source>
          <target state="translated">このフラグは、今後のECMA実行時の動作を切り替えます。</target>
        </trans-unit>
        <trans-unit id="386f8e03fb6e0f7dc1ee712a3c5377db2629c8d3" translate="yes" xml:space="preserve">
          <source>This flag was added to help people migrate to the stricter checking of new object literals in &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html#stricter-object-literal-assignment-checks&quot;&gt;TypeScript 1.6&lt;/a&gt;.</source>
          <target state="translated">このフラグは、&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html#stricter-object-literal-assignment-checks&quot;&gt;TypeScript1.6の&lt;/a&gt;新しいオブジェクトリテラルのより厳密なチェックに移行できるようにするために追加されました。</target>
        </trans-unit>
        <trans-unit id="281c5c0d6057938bd9f41eb87fb85816e087f3c9" translate="yes" xml:space="preserve">
          <source>This flag works because you can use &lt;code&gt;import type&lt;/code&gt; to explicitly create an &lt;code&gt;import&lt;/code&gt; statement which should never be emitted into JavaScript.</source>
          <target state="translated">このフラグが機能するのは、 &lt;code&gt;import type&lt;/code&gt; を使用して、JavaScriptに出力されるべきではない &lt;code&gt;import&lt;/code&gt; ステートメントを明示的に作成できるためです。</target>
        </trans-unit>
        <trans-unit id="4256b8036fc24344e27e1a2d98579274cc10c2e9" translate="yes" xml:space="preserve">
          <source>This gives bothPlus the value &lt;code&gt;[0, 1, 2, 3, 4, 5]&lt;/code&gt;. Spreading creates a shallow copy of &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. They are not changed by the spread.</source>
          <target state="translated">これにより、bothPlusに値 &lt;code&gt;[0, 1, 2, 3, 4, 5]&lt;/code&gt; 0、1、2、3、4、5]が与えられます。拡散すると、 &lt;code&gt;first&lt;/code&gt; と &lt;code&gt;second&lt;/code&gt; 浅いコピーが作成されます。スプレッドによって変更されることはありません。</target>
        </trans-unit>
        <trans-unit id="fe579196df9fee069d4bd852ac7c86cc2a13b998" translate="yes" xml:space="preserve">
          <source>This gives the user a way of describing inner classes.</source>
          <target state="translated">これにより、ユーザは内部クラスを記述する方法を得ることができます。</target>
        </trans-unit>
        <trans-unit id="386298615e90cceffaa57d2fad7dceaa3f784476" translate="yes" xml:space="preserve">
          <source>This guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.</source>
          <target state="translated">また、このガイダンスでは、宣言ファイルの利用者を壊すことなく、ライブラリをUMDに移行できるようにしています。</target>
        </trans-unit>
        <trans-unit id="c41bd8fce97e1f72ad86c3801d0c1855c4f2bfd0" translate="yes" xml:space="preserve">
          <source>This guide is designed to teach you how to write a high-quality TypeScript Declaration File.</source>
          <target state="translated">このガイドは、高品質なTypeScript宣言ファイルの書き方を教えることを目的としています。</target>
        </trans-unit>
        <trans-unit id="8afad13e48d5c317fc76b6fb0c7d091ef32c2108" translate="yes" xml:space="preserve">
          <source>This guide will teach you how to wire up TypeScript with &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; and &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;.</source>
          <target state="translated">このガイドでは、TypeScriptを&lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt;および&lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;と結び付ける方法について説明します。</target>
        </trans-unit>
        <trans-unit id="bb134067e9aa9299c18b8ce51100d390f03f98ca" translate="yes" xml:space="preserve">
          <source>This happens often enough in JavaScript that TypeScript provides a way to create new types based on old types &amp;mdash; &lt;strong&gt;mapped types&lt;/strong&gt;. In a mapped type, the new type transforms each property in the old type in the same way. For example, you can make all properties of a type &lt;code&gt;readonly&lt;/code&gt; or optional. Here are a couple of examples:</source>
          <target state="translated">これはJavaScriptで頻繁に発生し、TypeScriptは古い型に基づいて新しい型を作成する方法を提供します&amp;mdash; &lt;strong&gt;マップされた型&lt;/strong&gt;。マップされた型では、新しい型が古い型の各プロパティを同じ方法で変換します。たとえば、タイプのすべてのプロパティを &lt;code&gt;readonly&lt;/code&gt; またはオプションにすることができます。次に例をいくつか示します。</target>
        </trans-unit>
        <trans-unit id="fc63d58d10daddcb3a784f47122524cdbfabe76f" translate="yes" xml:space="preserve">
          <source>This happens often enough in JavaScript that TypeScript provides a way to create new types based on old types &amp;mdash; &lt;strong&gt;mapped types&lt;/strong&gt;. In a mapped type, the new type transforms each property in the old type in the same way. For example, you can make all properties optional or of a type &lt;code&gt;readonly&lt;/code&gt;. Here are a couple of examples:</source>
          <target state="translated">これはJavaScriptで頻繁に発生するため、TypeScriptは、古い型（&lt;strong&gt;マップされた型）に&lt;/strong&gt;基づいて新しい型を作成する方法を提供し&lt;strong&gt;ます&lt;/strong&gt;。マップされたタイプでは、新しいタイプは同じ方法で古いタイプの各プロパティを変換します。たとえば、すべてのプロパティをオプションにしたり、 &lt;code&gt;readonly&lt;/code&gt; タイプにすることができます。次にいくつかの例を示します。</target>
        </trans-unit>
        <trans-unit id="b99783df1b2487790d2f6fc6e2f815d703f49e8c" translate="yes" xml:space="preserve">
          <source>This has a very specific meaning: the &lt;code&gt;done&lt;/code&gt; callback might be invoked with 1 argument or might be invoked with 2 arguments. The author probably intended to say that the callback might not care about the &lt;code&gt;elapsedTime&lt;/code&gt; parameter, but there&amp;rsquo;s no need to make the parameter optional to accomplish this &amp;mdash; it&amp;rsquo;s always legal to provide a callback that accepts fewer arguments.</source>
          <target state="translated">これは非常に特殊な意味を持つ： &lt;code&gt;done&lt;/code&gt; コールバックは1つの引数で呼び出されるか、または2つの引数で呼び出される可能性があります。著者はおそらく、コールバックが &lt;code&gt;elapsedTime&lt;/code&gt; パラメーターを気にしないかもしれないと言うつもりでしたが、これを達成するためにパラメーターをオプションにする必要はありません。より少ない引数を受け入れるコールバックを提供することは常に合法です。</target>
        </trans-unit>
        <trans-unit id="a56075c1c437a8f7f7b75ea4c76282bd39cf7b1d" translate="yes" xml:space="preserve">
          <source>This has a very specific meaning: the &lt;code&gt;done&lt;/code&gt; callback might be invoked with 1 argument or might be invoked with 2 arguments. The author probably intended to say that the callback might not care about the &lt;code&gt;elapsedTime&lt;/code&gt; parameter, but there&amp;rsquo;s no need to make the parameter optional to accomplish this &amp;ndash; it&amp;rsquo;s always legal to provide a callback that accepts fewer arguments.</source>
          <target state="translated">これには非常に具体的な意味があります。 &lt;code&gt;done&lt;/code&gt; コールバックは1つの引数で呼び出される場合と、2つの引数で呼び出される場合があります。作成者はおそらく、コールバックが &lt;code&gt;elapsedTime&lt;/code&gt; パラメータを気にしないかもしれないと言うつもりでしたが、これを達成するためにパラメータをオプションにする必要はありません-より少ない引数を受け入れるコールバックを提供することは常に合法です。</target>
        </trans-unit>
        <trans-unit id="d47bf0bc67be092f1cae46d5237f049154597b89" translate="yes" xml:space="preserve">
          <source>This has been one common source of duplicate definition errors. Multiple declaration files defining the same members on interfaces.</source>
          <target state="translated">これは、重複した定義エラーの共通の原因の1つとなっています。インターフェース上で同じメンバを定義している複数の宣言ファイル。</target>
        </trans-unit>
        <trans-unit id="008c0c2cfe2dcafe3f531baa951507b0d1d186a6" translate="yes" xml:space="preserve">
          <source>This has the same problems we mentioned above - we could easily have misspelled &lt;code&gt;getDistance&lt;/code&gt; and not gotten an error. For this reason, TypeScript has the &lt;code&gt;noImplicitThis&lt;/code&gt; option. When that option is set, TypeScript will issue an error when &lt;code&gt;this&lt;/code&gt; is used without an explicit (or inferred) type. The fix is to use a &lt;code&gt;this&lt;/code&gt;-parameter to give an explicit type in the interface or in the function itself:</source>
          <target state="translated">これには、前述の問題と同じ問題があります &lt;code&gt;getDistance&lt;/code&gt; スペルを間違えても、エラーが発生することはありませんでした。このため、TypeScriptには &lt;code&gt;noImplicitThis&lt;/code&gt; オプションがあります。そのオプションが設定されている場合と、活字体はエラーを発行します &lt;code&gt;this&lt;/code&gt; 、明示的な（または推論）タイプなしで使用されています。修正は、 &lt;code&gt;this&lt;/code&gt; パラメータを使用して、インターフェイスまたは関数自体に明示的な型を与えることです。</target>
        </trans-unit>
        <trans-unit id="7f4508bf6985c57eb5ac26662f4d0528d2a5b77d" translate="yes" xml:space="preserve">
          <source>This introduction does not cover object-oriented programming. In practice, object-oriented programs in TypeScript are similar to those in other popular languages with OO features.</source>
          <target state="translated">このイントロダクションでは、オブジェクト指向プログラミングについては触れません。実際には、TypeScript のオブジェクト指向プログラムは OO 機能を持つ他の一般的な言語のそれと似ています。</target>
        </trans-unit>
        <trans-unit id="83dcbc6c7495e940551fddfd7a52d3f6c2bfa958" translate="yes" xml:space="preserve">
          <source>This introduction is designed for working Haskell or ML programmers who want to learn TypeScript. It describes how the type system of TypeScript differs from Haskell&amp;rsquo;s type system. It also describes unique features of TypeScript&amp;rsquo;s type system that arise from its modelling of JavaScript code.</source>
          <target state="translated">この紹介は、TypeScriptを学びたいHaskellまたはMLプログラマーを対象としています。TypeScriptの型システムがHaskellの型システムとどのように異なるかを説明します。また、JavaScriptコードのモデリングから生じるTypeScriptの型システムの独自の機能についても説明します。</target>
        </trans-unit>
        <trans-unit id="6ef37d4a82df716fb39c511922cd4fd9b3ab58c4" translate="yes" xml:space="preserve">
          <source>This is a breaking change; previously, the &lt;code&gt;keyof&lt;/code&gt; operator and mapped types only supported &lt;code&gt;string&lt;/code&gt; named properties. Code that assumed values typed with &lt;code&gt;keyof T&lt;/code&gt; were always &lt;code&gt;string&lt;/code&gt;s, will now be flagged as error.</source>
          <target state="translated">これは重大な変更です。以前は、 &lt;code&gt;keyof&lt;/code&gt; 演算子とマップされたタイプは、プロパティという名前の &lt;code&gt;string&lt;/code&gt; のみをサポートしていました。 &lt;code&gt;keyof T&lt;/code&gt; で入力された値を想定したコードは常に &lt;code&gt;string&lt;/code&gt; s でしたが、エラーとしてフラグが立てられるようになりました。</target>
        </trans-unit>
        <trans-unit id="2c0826ad129c5fa63f6532465e3caa896ed6cad2" translate="yes" xml:space="preserve">
          <source>This is a common pattern for projects with existing build infrastructure which may have been ported from a JavaScript codebase to TypeScript.</source>
          <target state="translated">これは、JavaScriptのコードベースからTypeScriptに移植された可能性のある既存のビルドインフラストラクチャを持つプロジェクトでよく見られるパターンです。</target>
        </trans-unit>
        <trans-unit id="37550d8cfccd82b7f09cb9ee94a9e55bd690b1de" translate="yes" xml:space="preserve">
          <source>This is a pretty literal use of the &lt;code&gt;GenericNumber&lt;/code&gt; class, but you may have noticed that nothing is restricting it to only use the &lt;code&gt;number&lt;/code&gt; type. We could have instead used &lt;code&gt;string&lt;/code&gt; or even more complex objects.</source>
          <target state="translated">これは &lt;code&gt;GenericNumber&lt;/code&gt; クラスのかなり文字どおりの使用法ですが、 &lt;code&gt;number&lt;/code&gt; 型のみを使用するように制限されているものがないことに気づいたかもしれません。代わりに、 &lt;code&gt;string&lt;/code&gt; またはさらに複雑なオブジェクトを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="0cbc708221291cf1aa363c4299a6de0178bc9f00" translate="yes" xml:space="preserve">
          <source>This is a reasonable restriction because any use of &lt;code&gt;Foo&lt;/code&gt; would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which&amp;hellip; well, hopefully you get the idea! In the end, there isn&amp;rsquo;t a type that makes sense in place of &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">これは、合理的な制限であるため、任意の使用 &lt;code&gt;Foo&lt;/code&gt; と交換する必要があります &lt;code&gt;Foo&lt;/code&gt; と交換する必要があると思われる &lt;code&gt;Foo&lt;/code&gt; と交換する必要があるだろう &lt;code&gt;Foo&lt;/code&gt; ...まあ、うまくいけばあなたのアイデアを得ます！結局、 &lt;code&gt;Foo&lt;/code&gt; の代わりに意味のある型はありません。</target>
        </trans-unit>
        <trans-unit id="b8060ed060d509f7038e676326653a9e51460e83" translate="yes" xml:space="preserve">
          <source>This is achieved by introducing two new types, &lt;code&gt;CallableFunction&lt;/code&gt; and &lt;code&gt;NewableFunction&lt;/code&gt;, in &lt;code&gt;lib.d.ts&lt;/code&gt;. These types contain specialized generic method declarations for &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; for regular functions and constructor functions, respectively. The declarations use generic rest parameters (see #24897) to capture and reflect parameter lists in a strongly typed manner. In &lt;code&gt;--strictBindCallApply&lt;/code&gt; mode these declarations are used in place of the (very permissive) declarations provided by type &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">これは、2基の新しい種類、導入することによって達成される &lt;code&gt;CallableFunction&lt;/code&gt; と &lt;code&gt;NewableFunction&lt;/code&gt; の中で、 &lt;code&gt;lib.d.ts&lt;/code&gt; 。これらの型には、 &lt;code&gt;bind&lt;/code&gt; 、 &lt;code&gt;call&lt;/code&gt; 、および通常の関数とコンストラクター関数のそれぞれに &lt;code&gt;apply&lt;/code&gt; れる特殊なジェネリックメソッド宣言が含まれています。宣言では、ジェネリックレストパラメーター（＃24897を参照）を使用して、厳密に型指定された方法でパラメーターリストをキャプチャおよび反映します。 &lt;code&gt;--strictBindCallApply&lt;/code&gt; モードこれらの宣言は、タイプによって提供される（非常に寛容な）宣言の代わりに使用される &lt;code&gt;Function&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07d4ef20e57dcee6e52ef28b64c55fa254a3690c" translate="yes" xml:space="preserve">
          <source>This is an array spread:</source>
          <target state="translated">これは配列の広がりです。</target>
        </trans-unit>
        <trans-unit id="0babfe78fc11f36da1fdc5ec919d6b94975c4775" translate="yes" xml:space="preserve">
          <source>This is an overloaded function definition. The second overload is simplest and works a lot like the &lt;code&gt;getElementById&lt;/code&gt; method does. Pass it any &lt;code&gt;string&lt;/code&gt; and it will return a standard HTMLElement. This definition is what enables developers to create unique HTML element tags.</source>
          <target state="translated">これはオーバーロードされた関数定義です。2番目のオーバーロードは最も単純で、 &lt;code&gt;getElementById&lt;/code&gt; メソッドと同じように機能します。任意の &lt;code&gt;string&lt;/code&gt; を渡すと、標準のHTMLElementが返されます。この定義により、開発者は一意のHTML要素タグを作成できます。</target>
        </trans-unit>
        <trans-unit id="6e698f027e54b69d38b4a233c428be4f83585527" translate="yes" xml:space="preserve">
          <source>This is an overview, from here you should read &lt;a href=&quot;intro&quot;&gt;through the handbook&lt;/a&gt; or explore the &lt;a href=&quot;https://www.typescriptlang.org/play#show-examples&quot;&gt;Playground examples&lt;/a&gt;</source>
          <target state="translated">これは概要です。ここ&lt;a href=&quot;intro&quot;&gt;から、ハンドブック&lt;/a&gt;を読むか、&lt;a href=&quot;https://www.typescriptlang.org/play#show-examples&quot;&gt;プレイグラウンドの例を&lt;/a&gt;調べる必要があります。</target>
        </trans-unit>
        <trans-unit id="6dbad74ad3287bbe68b69203c6f2782129725610" translate="yes" xml:space="preserve">
          <source>This is because when a class implements an interface, only the instance side of the class is checked. Since the constructor sits in the static side, it is not included in this check.</source>
          <target state="translated">これは、クラスがインターフェイスを実装したときに、そのクラスのインスタンス側だけをチェックするからです。コンストラクタは静的側にあるので、このチェックには含まれません。</target>
        </trans-unit>
        <trans-unit id="4b6c3dca4167679c5010d6f3fba2e9108213f5e9" translate="yes" xml:space="preserve">
          <source>This is called &amp;ldquo;contextual typing&amp;rdquo;, a form of type inference. This helps cut down on the amount of effort to keep your program typed.</source>
          <target state="translated">これは、型推論の一種である「コンテキストタイピング」と呼ばれます。これにより、プログラムの入力を維持するための労力を削減できます。</target>
        </trans-unit>
        <trans-unit id="3aa66e1a6cbac680bebe3f7aa3dc555a813d0306" translate="yes" xml:space="preserve">
          <source>This is equivalent to declaring &lt;code&gt;sentence&lt;/code&gt; like so:</source>
          <target state="translated">これは、次のように &lt;code&gt;sentence&lt;/code&gt; を宣言することと同じです。</target>
        </trans-unit>
        <trans-unit id="b92657e6155d73fb913bca9c2a7e95110494bb4c" translate="yes" xml:space="preserve">
          <source>This is fairly &lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Recursive_data_type&amp;amp;oldid=913091335#in_type_synonyms&quot;&gt;consistent with how other languages treat type aliases&lt;/a&gt;, but it does give rise to some slightly surprising scenarios for how users leverage the feature. For example, in TypeScript 3.6 and prior, the following causes an error.</source>
          <target state="translated">これは&lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Recursive_data_type&amp;amp;oldid=913091335#in_type_synonyms&quot;&gt;、他の言語が型エイリアスをどのように扱うか&lt;/a&gt;とほぼ一致していますが、ユーザーが機能を活用する方法について、少し意外なシナリオが発生します。たとえば、TypeScript 3.6以前では、次のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="723f96f4f031c1015e42839d7f70baaf5dc4dd7e" translate="yes" xml:space="preserve">
          <source>This is legal as long as it does not create a conflict. A general rule of thumb is that values always conflict with other values of the same name unless they are declared as &lt;code&gt;namespace&lt;/code&gt;s, types will conflict if they are declared with a type alias declaration (&lt;code&gt;type s = string&lt;/code&gt;), and namespaces never conflict.</source>
          <target state="translated">これは、衝突を引き起こさない限り合法です。一般的な経験則では、 &lt;code&gt;namespace&lt;/code&gt; s として宣言されていない限り、値は常に同じ名前の他の値と競合し、型エイリアス宣言（ &lt;code&gt;type s = string&lt;/code&gt; ）で宣言された型は競合し、名前空間は決して競合しません。</target>
        </trans-unit>
        <trans-unit id="b261fafdaf58d005a713f2cde7159a578a335b74" translate="yes" xml:space="preserve">
          <source>This is no longer the case - TypeScript now infers &lt;code&gt;this&lt;/code&gt; to have a special type called &lt;code&gt;this&lt;/code&gt; whenever inside an instance method of a class. The &lt;code&gt;this&lt;/code&gt; type is written as so, and basically means &amp;ldquo;the type of the left side of the dot in a method call&amp;rdquo;.</source>
          <target state="translated">これはもう当てはまりません-TypeScriptは &lt;code&gt;this&lt;/code&gt; を推論して、クラスのインスタンスメソッド内にあるときは常に &lt;code&gt;this&lt;/code&gt; と呼ばれる特別な型があると推測します。 &lt;code&gt;this&lt;/code&gt; タイプのように書かれており、基本的に「メソッド呼び出しのドットの左側のタイプ」を意味します。</target>
        </trans-unit>
        <trans-unit id="58590b20aaf8fc85de88a20890a72ce9479b5bd1" translate="yes" xml:space="preserve">
          <source>This is now the default for MSBuild projects; this allows MSBuild incremental build to work as expected, as outputs are only generated on clean builds.</source>
          <target state="translated">これはMSBuildプロジェクトのデフォルトとなりました。これにより、出力はクリーンビルド時にのみ生成されるため、MSBuildのインクリメンタルビルドが期待通りに動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="17ee6c7a17ecddf72cfa4cd21d7420a20690b42c" translate="yes" xml:space="preserve">
          <source>This is often what people expect, but it&amp;rsquo;s not 100% compliant with ECMAScript iteration protocol. Certain strings, such as emoji (😜), have a &lt;code&gt;.length&lt;/code&gt; of 2 (or even more!), but should iterate as 1 unit in a &lt;code&gt;for-of&lt;/code&gt; loop. See &lt;a href=&quot;https://blog.jonnew.com/posts/poo-dot-length-equals-two&quot;&gt;this blog post by Jonathan New&lt;/a&gt; for a longer explanation.</source>
          <target state="translated">これは多くの場合人々が期待することですが、ECMAScript反復プロトコルに100％準拠しているわけではありません。絵文字（😜）などの特定の文字列の &lt;code&gt;.length&lt;/code&gt; は2（またはそれ以上！）ですが、 &lt;code&gt;for-of&lt;/code&gt; ループで1単位として繰り返す必要があります。詳細については&lt;a href=&quot;https://blog.jonnew.com/posts/poo-dot-length-equals-two&quot;&gt;、JonathanNewによるこのブログ投稿を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="94d5f4a5616552cb256911b32b728b92d26e4819" translate="yes" xml:space="preserve">
          <source>This is only enabled if &lt;code&gt;--noImplicitAny&lt;/code&gt; is set.</source>
          <target state="translated">これは、 &lt;code&gt;--noImplicitAny&lt;/code&gt; が設定されている場合にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="d335ad9d283ed57e40045d0665963af63d3174d9" translate="yes" xml:space="preserve">
          <source>This is optimal for consumers. They can name your type whatever they want (&lt;code&gt;t&lt;/code&gt; in this case) and don&amp;rsquo;t have to do any excessive dotting to find your objects.</source>
          <target state="translated">これは消費者にとって最適です。彼らはあなたが望むようにあなたのタイプに名前を付けることができ（この場合は &lt;code&gt;t&lt;/code&gt; ）、あなたのオブジェクトを見つけるために過度の点数を行う必要はありません。</target>
        </trans-unit>
        <trans-unit id="98bb0c78662d4345a34d8056d87df00bb4d5a674" translate="yes" xml:space="preserve">
          <source>This is still strictly more capable in TypeScript 3.3, and adding an explicit type annotation will work.</source>
          <target state="translated">これは、TypeScript 3.3ではまだ厳密には可能であり、明示的な型アノテーションを追加することで機能します。</target>
        </trans-unit>
        <trans-unit id="a079a3a6734c4cd08da0e17c421a695ab213a09a" translate="yes" xml:space="preserve">
          <source>This is strange because there is technically nothing wrong with any use users could always write what was effectively the same code by introducing an interface.</source>
          <target state="translated">技術的には何の問題もないのに、インターフェイスを導入することで、ユーザーはいつでも事実上同じコードを書くことができるのですから、これは不思議です。</target>
        </trans-unit>
        <trans-unit id="a85985f698519bc5006290fca9b3c770afc4331a" translate="yes" xml:space="preserve">
          <source>This is to reflect the same flag in Node.js; which does not resolve the real path of symlinks.</source>
          <target state="translated">これは、シンボリックリンクの実パスを解決しない Node.js の同じフラグを反映させるためです。</target>
        </trans-unit>
        <trans-unit id="14f1b6e0e05e87d37ff1f7dd8b578b6eb45b8f85" translate="yes" xml:space="preserve">
          <source>This is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing &lt;code&gt;undefined&lt;/code&gt; in that position is equivalent for most functions.</source>
          <target state="translated">これは型システムの観点からは適切ではありませんが、ランタイムの観点から見ると、オプションのパラメーターの概念は、その位置で &lt;code&gt;undefined&lt;/code&gt; を渡すことはほとんどの関数で同等であるため、一般に十分に適用されません。</target>
        </trans-unit>
        <trans-unit id="f1a4eb58dc966cceb7143e20830932600b5ea02f" translate="yes" xml:space="preserve">
          <source>This is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties. The subclasses don&amp;rsquo;t have to be related besides inheriting from the base class. For example:</source>
          <target state="translated">これは、継承階層が大きいが、特定のプロパティを持つサブクラスのみでコードが機能するように指定する場合に役立ちます。サブクラスは、基本クラスからの継承以外に関連している必要はありません。例えば：</target>
        </trans-unit>
        <trans-unit id="edfa7337b75e8a1603e456ce30e9130e6824a45e" translate="yes" xml:space="preserve">
          <source>This is useful when you only have a small number of files and don&amp;rsquo;t need to use a glob to reference many files. If you need that then use &lt;a href=&quot;#include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、ファイルの数が少なく、多くのファイルを参照するためにglobを使用する必要がない場合に役立ちます。それが必要な場合&lt;a href=&quot;#include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="c743dac20c102f17500a10837b687c3c8b807f9f" translate="yes" xml:space="preserve">
          <source>This is when you use an editor which uses TypeScript to provide tooling like auto-complete, jump to symbol and refactoring tools like rename. The &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;homepage&lt;/a&gt; has a list of editors which have TypeScript plugins.</source>
          <target state="translated">これは、TypeScriptを使用するエディターを使用して、オートコンプリート、シンボルへのジャンプ、名前変更などのリファクタリングツールなどのツールを提供する場合です。&lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;ホームページは&lt;/a&gt;活字体のプラグインを持っている編集者のリストを持っています。</target>
        </trans-unit>
        <trans-unit id="8f5993fdefbd1dda848027db50f46bbc6c1c3844" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the sort of code you would want in your codebase however.</source>
          <target state="translated">ただし、これはコードベースに必要な種類のコードではありません。</target>
        </trans-unit>
        <trans-unit id="fbc601dd0ab93d792728208f62b2497f50e502de" translate="yes" xml:space="preserve">
          <source>This kind of iterator is useful for iterating over synchronously available values, such as the elements of an Array or the keys of a Map. An object that supports iteration is said to be &amp;ldquo;iterable&amp;rdquo; if it has a &lt;code&gt;Symbol.iterator&lt;/code&gt; method that returns an &lt;code&gt;Iterator&lt;/code&gt; object.</source>
          <target state="translated">この種のイテレータは、配列の要素やマップのキーなど、同期的に利用可能な値を反復するのに役立ちます。反復をサポートするオブジェクトは、 &lt;code&gt;Iterator&lt;/code&gt; オブジェクトを返す &lt;code&gt;Symbol.iterator&lt;/code&gt; メソッドがある場合、「反復可能」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="b2e9d1d03b4a1362369564c77ee95ce233702dd8" translate="yes" xml:space="preserve">
          <source>This lets your &lt;code&gt;tsconfig.json&lt;/code&gt; focus on the unique choices for your project, and not all of the runtime mechanics. There are a few tsconfig bases already, and we&amp;rsquo;re hoping the community can add more for different environments.</source>
          <target state="translated">これにより、 &lt;code&gt;tsconfig.json&lt;/code&gt; は、すべてのランタイムメカニズムではなく、プロジェクトの一意の選択に集中できます。すでにいくつかのtsconfigベースがあり、コミュニティがさまざまな環境にさらに追加できることを望んでいます。</target>
        </trans-unit>
        <trans-unit id="5bd6b551c716ce479c9efb44f5745eec1d50b86b" translate="yes" xml:space="preserve">
          <source>This list may be out of date, you can see the full list in the &lt;a href=&quot;https://github.com/microsoft/TypeScript/tree/master/lib&quot;&gt;TypeScript source code&lt;/a&gt;.</source>
          <target state="translated">このリストは古くなっている可能性があり&lt;a href=&quot;https://github.com/microsoft/TypeScript/tree/master/lib&quot;&gt;ます&lt;/a&gt;。完全なリストはTypeScriptソースコードで確認できます。</target>
        </trans-unit>
        <trans-unit id="ffa1d11a7b7e51ebc3e166a5662abdb4c99a2fdc" translate="yes" xml:space="preserve">
          <source>This makes room for another tool like &lt;a href=&quot;https://babeljs.io&quot;&gt;Babel&lt;/a&gt;, or &lt;a href=&quot;https://github.com/swc-project/swc&quot;&gt;swc&lt;/a&gt; to handle converting the TypeScript file to a file which can run inside a JavaScript environment.</source>
          <target state="translated">これにより、&lt;a href=&quot;https://babeljs.io&quot;&gt;Babel&lt;/a&gt;や&lt;a href=&quot;https://github.com/swc-project/swc&quot;&gt;swc&lt;/a&gt;などの別のツールがTypeScriptファイルをJavaScript環境内で実行できるファイルに変換するためのスペースが確保されます。</target>
        </trans-unit>
        <trans-unit id="ee56cf9ba9542ce8a0312b6a94a0d6397c614c45" translate="yes" xml:space="preserve">
          <source>This may seem confusing, but it&amp;rsquo;s actually very convenient as long as we don&amp;rsquo;t excessively overload things. Let&amp;rsquo;s look at some useful aspects of this combining behavior.</source>
          <target state="translated">これは混乱を招くように見えるかもしれませんが、過度に負荷をかけすぎない限り、実際には非常に便利です。この組み合わせ動作のいくつかの有用な側面を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="acc607e6369c64f4e86ed2006f7e56509541116e" translate="yes" xml:space="preserve">
          <source>This may seem surprising, but it&amp;rsquo;s ultimately a very similar relationship to one enforced in nominal OOP languages. A subclass cannot &lt;em&gt;remove&lt;/em&gt; a property of its base class, because doing so would destroy the natural subtype relationship between the derived class and its base. Structural type systems simply identify this relationship implicitly by describing subtypes in terms of having properties of compatible types.</source>
          <target state="translated">これは意外に思えるかもしれませんが、最終的には、名目上のOOP言語で強制される関係と非常によく似た関係です。サブクラスは、その基本クラスのプロパティを&lt;em&gt;削除&lt;/em&gt;できません。&lt;em&gt;削除&lt;/em&gt;すると、派生クラスとその基本の間の自然なサブタイプの関係が破壊されるためです。構造型システムは、互換性のある型のプロパティを持つという観点からサブタイプを記述することにより、この関係を暗黙的に識別します。</target>
        </trans-unit>
        <trans-unit id="242737969d68a63e3722770b6fdc0a0887aa17a9" translate="yes" xml:space="preserve">
          <source>This means that code like the following that was trying to represent JSON&amp;hellip;</source>
          <target state="translated">つまり、JSONを表現しようとしていた次のようなコードは&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="935744b5a109e03d6e5fdd0bc4f2ed2b0d65c339" translate="yes" xml:space="preserve">
          <source>This means that having a file like &lt;code&gt;jquery.js&lt;/code&gt; in your project would not automatically download the types for JQuery from DefinitelyTyped.</source>
          <target state="translated">これは、プロジェクトに &lt;code&gt;jquery.js&lt;/code&gt; のようなファイルがあると、DefinitelyTypedからJQueryの型が自動的にダウンロードされないことを意味します。</target>
        </trans-unit>
        <trans-unit id="bbc1af0b95468e7c0be508ef7ed287acbbf8bf7a" translate="yes" xml:space="preserve">
          <source>This means that if you move code from JavaScript to TypeScript, it is &lt;strong&gt;guaranteed&lt;/strong&gt; to run the same way, even if TypeScript thinks that the code has type errors.</source>
          <target state="translated">つまり、コードをJavaScriptからTypeScriptに移動すると、TypeScriptがコードにタイプエラーがあると判断した場合でも、同じように実行&lt;strong&gt;さ&lt;/strong&gt;れることが&lt;strong&gt;保証さ&lt;/strong&gt;れます。</target>
        </trans-unit>
        <trans-unit id="9e01eba045901bb9f42a3c7a52e17b1f10e058c3" translate="yes" xml:space="preserve">
          <source>This means that union types and &lt;code&gt;instanceof&lt;/code&gt; properly distinguish between structurally identical classes.</source>
          <target state="translated">つまり、共用体タイプと &lt;code&gt;instanceof&lt;/code&gt; は、構造的に同一のクラスを適切に区別します。</target>
        </trans-unit>
        <trans-unit id="944f762b99fb22d02c5865084d87d43b8946d4d0" translate="yes" xml:space="preserve">
          <source>This means that you can conditionally and lazily import other modules and libraries. For example, here&amp;rsquo;s an &lt;code&gt;async&lt;/code&gt; function that only imports a utility library when it&amp;rsquo;s needed:</source>
          <target state="translated">これは、他のモジュールやライブラリを条件付きで遅延してインポートできることを意味します。たとえば、次の &lt;code&gt;async&lt;/code&gt; 関数は、必要なときにのみユーティリティライブラリをインポートします。</target>
        </trans-unit>
        <trans-unit id="43b4176bbe758e3980ce4c378a5b0c74800846b0" translate="yes" xml:space="preserve">
          <source>This means that your comments will show up in the JavaScript code.</source>
          <target state="translated">これは、あなたのコメントがJavaScriptのコードに表示されることを意味します。</target>
        </trans-unit>
        <trans-unit id="524598ce79eaafea873d07fe2c5f1daf5dd60c42" translate="yes" xml:space="preserve">
          <source>This means that your existing working JavaScript code is also TypeScript code. The main benefit of TypeScript is that it can highlight unexpected behavior in your code, lowering the chance of bugs.</source>
          <target state="translated">これは、既存の JavaScript コードが TypeScript コードになっていることを意味します。TypeScriptの主な利点は、コード内の予期せぬ動作をハイライトしてバグの可能性を減らすことができることです。</target>
        </trans-unit>
        <trans-unit id="33df278507c445ec5629c94f1025fbe3e4d0c772" translate="yes" xml:space="preserve">
          <source>This method works similarly to the &lt;code&gt;createElement&lt;/code&gt; method as the generic parameter &lt;code&gt;T&lt;/code&gt; is inferred from the &lt;code&gt;newChild&lt;/code&gt; argument. &lt;code&gt;T&lt;/code&gt; is &lt;em&gt;constrained&lt;/em&gt; to another base interface &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">このメソッドは、ジェネリックパラメーター &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;newChild&lt;/code&gt; 引数から推測されるため、 &lt;code&gt;createElement&lt;/code&gt; メソッドと同様に機能します。 &lt;code&gt;T&lt;/code&gt; は、別のベースインターフェイス &lt;code&gt;Node&lt;/code&gt; &lt;em&gt;制約さ&lt;/em&gt;れます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57b9c67d02646774dbf2986763ff463559dd77f1" translate="yes" xml:space="preserve">
          <source>This mis-match causes these two issues:</source>
          <target state="translated">このミスマッチにより、この2つの問題が発生します。</target>
        </trans-unit>
        <trans-unit id="aa9a3a7f47b92be453ff0b6c4375f9ba7afa10b1" translate="yes" xml:space="preserve">
          <source>This mode adds flexibility for mixing and matching the way 3rd party libraries, where globals that libraries declare can always be consumed, even from within modules.</source>
          <target state="translated">このモードでは、サードパーティ製のライブラリを混合してマッチングさせるための柔軟性が追加され、ライブラリが宣言したグローバルは、モジュール内からでも常に消費することができます。</target>
        </trans-unit>
        <trans-unit id="7f33b0a22b86a2f41c336d65267df2bb8cf5e332" translate="yes" xml:space="preserve">
          <source>This model of namespace merging is a helpful starting place, but we also need to understand what happens with non-exported members. Non-exported members are only visible in the original (un-merged) namespace. This means that after merging, merged members that came from other declarations cannot see non-exported members.</source>
          <target state="translated">この名前空間マージのモデルは出発点として役立ちますが、エクスポートされないメンバについても理解しておく必要があります。非輸出メンバは、元の (マージされていない)名前空間でのみ表示されます。これは、マージ後、他の宣言から来たマージされたメンバは、エクスポートされないメンバを見ることができないことを意味します。</target>
        </trans-unit>
        <trans-unit id="5dae3ac251886a93244e214f8a5ad7364681d1d0" translate="yes" xml:space="preserve">
          <source>This new behavior only kicks in when at most one type in the union has multiple overloads, and at most one type in the union has a generic signature. That means methods on &lt;code&gt;number[] | string[]&lt;/code&gt; like &lt;code&gt;map&lt;/code&gt; (which is generic) still won&amp;rsquo;t be callable.</source>
          <target state="translated">この新しい動作は、ユニオン内の最大で1つのタイプに複数のオーバーロードがあり、ユニオン内の最大で1つのタイプにジェネリックシグネチャがある場合にのみ発生します。つまり、 &lt;code&gt;number[] | string[]&lt;/code&gt; ような &lt;code&gt;map&lt;/code&gt; （汎用）はまだ呼び出し可能ではありません。</target>
        </trans-unit>
        <trans-unit id="5b0887b7c0dc11302a46adcaa14cce74855a6095" translate="yes" xml:space="preserve">
          <source>This new relaxation also lets us recursively reference type aliases in tuples as well. The following code which used to error is now valid TypeScript code.</source>
          <target state="translated">この新しい緩和により、タプル内の型のエイリアスも再帰的に参照できるようになりました。これまでエラーになっていた以下のコードは、有効な TypeScript コードになりました。</target>
        </trans-unit>
        <trans-unit id="73d275a1e3784849d22fea2ec009273ed158e2df" translate="yes" xml:space="preserve">
          <source>This odd-looking pattern is actually pretty common. The &lt;code&gt;i&lt;/code&gt; in the parameter list actually shadows the &lt;code&gt;i&lt;/code&gt; declared in the &lt;code&gt;for&lt;/code&gt; loop, but since we named them the same, we didn&amp;rsquo;t have to modify the loop body too much.</source>
          <target state="translated">この奇妙に見えるパターンは実際にはかなり一般的です。パラメータリストの &lt;code&gt;i&lt;/code&gt; は、実際には &lt;code&gt;for&lt;/code&gt; ループで宣言された &lt;code&gt;i&lt;/code&gt; をシャドウしますが、同じ名前を付けたため、ループ本体をあまり変更する必要はありませんでした。</target>
        </trans-unit>
        <trans-unit id="5c7ee90113f636f43404e4d744fd715593d575c9" translate="yes" xml:space="preserve">
          <source>This often opens up very elegant ways of writing code; however, there was a problem for classes that wanted to extend from &lt;code&gt;BasicCalculator&lt;/code&gt;. Imagine a user wanted to start writing a &lt;code&gt;ScientificCalculator&lt;/code&gt;:</source>
          <target state="translated">これは、多くの場合、非常に洗練された方法でコードを記述します。ただし、 &lt;code&gt;BasicCalculator&lt;/code&gt; から拡張したいクラスには問題がありました。ユーザーが &lt;code&gt;ScientificCalculator&lt;/code&gt; の作成を開始したいと想像してください。</target>
        </trans-unit>
        <trans-unit id="93d9ec6cf3f9136de052694a0e5be31bcf80b6f6" translate="yes" xml:space="preserve">
          <source>This only apply to types with an &lt;em&gt;explicit&lt;/em&gt; string index signature. It is still an error to access unknown properties on a type using &lt;code&gt;.&lt;/code&gt; notation.</source>
          <target state="translated">これは、&lt;em&gt;明示的な&lt;/em&gt;文字列インデックスシグネチャを持つ型にのみ適用されます。を使用して型の不明なプロパティにアクセスすることは、まだエラー &lt;code&gt;.&lt;/code&gt; 表記。</target>
        </trans-unit>
        <trans-unit id="8eb687938c9fb814d547d871195ddff75c8d4f13" translate="yes" xml:space="preserve">
          <source>This option can be used on a per-file basis too similar to &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#custom&quot;&gt;Babel&amp;rsquo;s &lt;code&gt;/** @jsx h */&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="translated">このオプションは、&lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#custom&quot;&gt;Babelの &lt;code&gt;/** @jsx h */&lt;/code&gt; ディレクティブ&lt;/a&gt;と同様に、ファイルごとに使用できます。</target>
        </trans-unit>
        <trans-unit id="fdba5f3f1154fdf39f0e94523953d163115e35ae" translate="yes" xml:space="preserve">
          <source>This option can be used on a per-file basis too similar to &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#fragments&quot;&gt;Babel&amp;rsquo;s &lt;code&gt;/* @jsxFrag h */&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="translated">このオプションは、&lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#fragments&quot;&gt;Babelの &lt;code&gt;/* @jsxFrag h */&lt;/code&gt; ディレクティブ&lt;/a&gt;と同様に、ファイルごとに使用できます。</target>
        </trans-unit>
        <trans-unit id="6106ecf0ac5a2b09e236e72c0e2cedcd5d1ae862" translate="yes" xml:space="preserve">
          <source>This option can only be used from the CLI via: &lt;code&gt;--generateCpuProfile tsc-output.cpuprofile&lt;/code&gt;.</source>
          <target state="translated">このオプションは、CLIから &lt;code&gt;--generateCpuProfile tsc-output.cpuprofile&lt;/code&gt; 介してのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="6c327bf1c9c3b71c013b7f4a7d7fedc6e7d7f8e7" translate="yes" xml:space="preserve">
          <source>This option does not affect how &lt;code&gt;@types/*&lt;/code&gt; are included in your application code, for example if you had the above &lt;code&gt;compilerOptions&lt;/code&gt; example with code like:</source>
          <target state="translated">このオプションは、 &lt;code&gt;@types/*&lt;/code&gt; がアプリケーションコードに含まれる方法には影響しません。たとえば、上記の &lt;code&gt;compilerOptions&lt;/code&gt; の例に次のようなコードがある場合です。</target>
        </trans-unit>
        <trans-unit id="57239aa523124655738236cda5cd80c7601972ef" translate="yes" xml:space="preserve">
          <source>This option gives you the chance to have TypeScript emit a v8 CPU profile during the compiler run. The CPU profile can provide insight into why your builds may be slow.</source>
          <target state="translated">このオプションを使用すると、コンパイラの実行中に TypeScript が v8 の CPU プロファイルを表示するようになります。CPU プロファイルは、ビルドが遅くなる原因を知ることができます。</target>
        </trans-unit>
        <trans-unit id="ac04689bd985aaff5480421363910106fc5c181c" translate="yes" xml:space="preserve">
          <source>This option is similar to &lt;code&gt;UseFsEvents&lt;/code&gt; except on failing to create watch using &lt;code&gt;fs.watch&lt;/code&gt;, the fallback watching happens through dynamic polling queues (as explained in &lt;code&gt;DynamicPriorityPolling&lt;/code&gt;)</source>
          <target state="translated">このオプションは、に似て &lt;code&gt;UseFsEvents&lt;/code&gt; 使用して時計を作成するために、失敗を除く &lt;code&gt;fs.watch&lt;/code&gt; を（で説明したように、フォールバックウォッチングは、動的なポーリング・キューを介して行わ &lt;code&gt;DynamicPriorityPolling&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="8d193ba5c4532991da9bb0f8500297f04dae9a97" translate="yes" xml:space="preserve">
          <source>This option offers a way to configure the place where TypeScript keeps track of the files it stores on the disk to indicate a project&amp;rsquo;s build state &amp;mdash; by default, they are in the same folder as your emitted JavaScript.</source>
          <target state="translated">このオプションは、TypeScriptがディスクに保存するファイルを追跡して、プロジェクトのビルド状態を示す場所を構成する方法を提供します。デフォルトでは、ファイルは発行されたJavaScriptと同じフォルダーにあります。</target>
        </trans-unit>
        <trans-unit id="0aae93fe007c809a7e2e36db92dc9e5b379de835" translate="yes" xml:space="preserve">
          <source>This option watches parent directory of the file with &lt;code&gt;fs.watch&lt;/code&gt; (using file system events) thus being low on CPU but can compromise accuracy.</source>
          <target state="translated">このオプションは、ファイルシステムイベントを使用して &lt;code&gt;fs.watch&lt;/code&gt; でファイルの親ディレクトリを監視するため、CPUの負荷は低くなりますが、精度が低下する可能性があります。</target>
        </trans-unit>
        <trans-unit id="bc504c6e0f3c053460e82d0c935b1ef42c4c0ed5" translate="yes" xml:space="preserve">
          <source>This page covers all of the different flags available inside a TSConfig file. It starts with an overview of every flag, then moves into the root attributes in the JSON file, then the &lt;code&gt;compilerOptions&lt;/code&gt; which are the bulk of the options and wraps up with &lt;code&gt;watchOptions&lt;/code&gt;.</source>
          <target state="translated">このページでは、TSConfigファイル内で使用可能なさまざまなフラグをすべてカバーしています。すべてのフラグの概要から始まり、JSONファイルのルート属性に移動し、次にオプションの大部分である &lt;code&gt;compilerOptions&lt;/code&gt; に移動し、 &lt;code&gt;watchOptions&lt;/code&gt; で終了します。</target>
        </trans-unit>
        <trans-unit id="0c7ae2cfaba7b6eecc420557a0116e17b9d17b15" translate="yes" xml:space="preserve">
          <source>This page lists some of the more advanced ways in which you can model types, it works in tandem with the &lt;a href=&quot;utility-types&quot;&gt;Utility Types&lt;/a&gt; doc which includes types which are included in TypeScript and available globally.</source>
          <target state="translated">このページには、タイプをモデル化するためのより高度な方法がいくつかリストされています。TypeScriptに含まれ、グローバルに利用できるタイプを含む&lt;a href=&quot;utility-types&quot;&gt;ユーティリティタイプの&lt;/a&gt;ドキュメントと連携して機能します。</target>
        </trans-unit>
        <trans-unit id="e58c92c51ad6f1ff869baee49d21faa7424e2034" translate="yes" xml:space="preserve">
          <source>This pattern relies less on the compiler, and more on your codebase to ensure both runtime and type-system are correctly kept in sync.</source>
          <target state="translated">このパターンはコンパイラへの依存度を下げ、コードベースへの依存度を上げることで、ランタイムと型システムの両方が正しく同期されていることを保証します。</target>
        </trans-unit>
        <trans-unit id="e01e7dba8069ec2ba7bcc3ad7e5d0d4b677661b1" translate="yes" xml:space="preserve">
          <source>This post outlines the various ways to organize your code using modules and namespaces in TypeScript. We&amp;rsquo;ll also go over some advanced topics of how to use namespaces and modules, and address some common pitfalls when using them in TypeScript.</source>
          <target state="translated">この投稿では、TypeScriptのモジュールと名前空間を使用してコードを整理するさまざまな方法の概要を説明します。また、名前空間とモジュールの使用方法に関するいくつかの高度なトピックについて説明し、TypeScriptでそれらを使用する際のいくつかの一般的な落とし穴に対処します。</target>
        </trans-unit>
        <trans-unit id="87694e596c33f73edc99c67b8848fbcbde1e4c9c" translate="yes" xml:space="preserve">
          <source>This post outlines the various ways to organize your code using namespaces (previously &amp;ldquo;internal modules&amp;rdquo;) in TypeScript. As we alluded in our note about terminology, &amp;ldquo;internal modules&amp;rdquo; are now referred to as &amp;ldquo;namespaces&amp;rdquo;. Additionally, anywhere the &lt;code&gt;module&lt;/code&gt; keyword was used when declaring an internal module, the &lt;code&gt;namespace&lt;/code&gt; keyword can and should be used instead. This avoids confusing new users by overloading them with similarly named terms.</source>
          <target state="translated">この投稿では、TypeScriptで名前空間（以前の「内部モジュール」）を使用してコードを整理するさまざまな方法の概要を説明します。用語に関する注記で触れたように、「内部モジュール」は「名前空間」と呼ばれるようになりました。さらに、内部モジュールを宣言するときに &lt;code&gt;module&lt;/code&gt; キーワードを使用した場合は、 &lt;code&gt;namespace&lt;/code&gt; キーワードを代わりに使用できます。これにより、同じような名前の用語でオーバーロードすることにより、新しいユーザーの混乱を防ぎます。</target>
        </trans-unit>
        <trans-unit id="67e03678783967eef2733d80436705f614849f7f" translate="yes" xml:space="preserve">
          <source>This post outlines the various ways to organize your code using namespaces and modules in TypeScript. We&amp;rsquo;ll also go over some advanced topics of how to use namespaces and modules, and address some common pitfalls when using them in TypeScript.</source>
          <target state="translated">この投稿では、TypeScriptで名前空間とモジュールを使用してコードを整理するさまざまな方法の概要を説明します。名前空間とモジュールの使用方法に関するいくつかの高度なトピックについても説明し、TypeScriptでそれらを使用する場合のいくつかの一般的な落とし穴に対処します。</target>
        </trans-unit>
        <trans-unit id="fd64220fbecc8854d60d2a4f4f20ca94bda2d4e7" translate="yes" xml:space="preserve">
          <source>This presents a simple entry point; e.g. in the TypeScript repo we simply run &lt;code&gt;tsc -b src&lt;/code&gt; to build all endpoints because we list all the subprojects in &lt;code&gt;src/tsconfig.json&lt;/code&gt;</source>
          <target state="translated">これは単純なエントリポイントを示しています。たとえば、TypeScriptリポジトリでは、 &lt;code&gt;tsc -b src&lt;/code&gt; を実行してすべてのエンドポイントを構築します。これは、 &lt;code&gt;src/tsconfig.json&lt;/code&gt; にすべてのサブプロジェクトをリストするためです。</target>
        </trans-unit>
        <trans-unit id="96c2c0f0e97743735b953a624ea594af85aaba20" translate="yes" xml:space="preserve">
          <source>This presents a very good opportunity for destructuring in the consuming code:</source>
          <target state="translated">これは、消費するコードを破壊するための非常に良い機会を提供します。</target>
        </trans-unit>
        <trans-unit id="90339bda9cc4062b63e151a5bde442af3f17fdf3" translate="yes" xml:space="preserve">
          <source>This quick start guide will teach you how to build TypeScript with &lt;a href=&quot;http://gulpjs.com&quot;&gt;gulp&lt;/a&gt; and then add &lt;a href=&quot;http://browserify.org&quot;&gt;Browserify&lt;/a&gt;, &lt;a href=&quot;http://lisperator.net/uglifyjs/&quot;&gt;uglify&lt;/a&gt;, or &lt;a href=&quot;https://github.com/substack/watchify&quot;&gt;Watchify&lt;/a&gt; to the gulp pipeline. This guide also shows how to add &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; functionality using &lt;a href=&quot;https://github.com/babel/babelify&quot;&gt;Babelify&lt;/a&gt;.</source>
          <target state="translated">このクイックスタートガイドでは、どのようにして活字体を構築することをお教えします&lt;a href=&quot;http://gulpjs.com&quot;&gt;一口&lt;/a&gt;、その後追加&lt;a href=&quot;http://browserify.org&quot;&gt;Browserify&lt;/a&gt;、&lt;a href=&quot;http://lisperator.net/uglifyjs/&quot;&gt;uglify&lt;/a&gt;、または&lt;a href=&quot;https://github.com/substack/watchify&quot;&gt;Watchifyを&lt;/a&gt;一気パイプラインに。このガイドでは、&lt;a href=&quot;https://github.com/babel/babelify&quot;&gt;Babelify&lt;/a&gt;を使用して&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;機能を追加する方法も示します。</target>
        </trans-unit>
        <trans-unit id="4771bc2bab27a199d772c4ea0beb5b94f1557d90" translate="yes" xml:space="preserve">
          <source>This resolution strategy attempts to mimic the &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; module resolution mechanism at runtime. The full Node.js resolution algorithm is outlined in &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_all_together&quot;&gt;Node.js module documentation&lt;/a&gt;.</source>
          <target state="translated">この解決戦略は、実行時に&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;モジュール解決メカニズムを模倣しようとします。完全なNode.js解決アルゴリズムの概要は、&lt;a href=&quot;https://nodejs.org/api/modules.html#modules_all_together&quot;&gt;Node.jsモジュールのドキュメントに&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="87bf34158eb20c72cb4fd37812305a408c19d43a" translate="yes" xml:space="preserve">
          <source>This restriction doesn&amp;rsquo;t apply to &lt;code&gt;.d.ts&lt;/code&gt; files</source>
          <target state="translated">この制限は &lt;code&gt;.d.ts&lt;/code&gt; ファイルには適用されません</target>
        </trans-unit>
        <trans-unit id="a4282404c916b4f4b5fe9e3d34bc8423764a9741" translate="yes" xml:space="preserve">
          <source>This results in the generated JS</source>
          <target state="translated">この結果、生成されたJS</target>
        </trans-unit>
        <trans-unit id="6111a68e7f42d3cedbb929558c29d3873d82bb3c" translate="yes" xml:space="preserve">
          <source>This sample code:</source>
          <target state="translated">このサンプルコード。</target>
        </trans-unit>
        <trans-unit id="ef4b88dc9b6e4d599f0dfab38e9b347bbf2884ea" translate="yes" xml:space="preserve">
          <source>This section assumes some basic knowledge about modules. Please see the &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; documentation for more information.</source>
          <target state="translated">このセクションでは、モジュールに関する基本的な知識があることを前提としています。詳細については、&lt;a href=&quot;modules&quot;&gt;モジュールの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="349a068c7f9dd73c8443e8d5def76fa3544a4bfe" translate="yes" xml:space="preserve">
          <source>This set up means you can own the editor experience of TypeScript-powered editors without porting your project to TypeScript, or having to maintain .d.ts files in your codebase. TypeScript supports most JSDoc tags, you can find &lt;a href=&quot;../type-checking-javascript-files#supported-jsdoc&quot;&gt;the reference here&lt;/a&gt;.</source>
          <target state="translated">この設定は、プロジェクトをTypeScriptに移植したり、コードベースで.d.tsファイルを維持したりすることなく、TypeScriptを利用したエディターのエディターエクスペリエンスを所有できることを意味します。TypeScriptはほとんどのJSDocタグをサポートし&lt;a href=&quot;../type-checking-javascript-files#supported-jsdoc&quot;&gt;ています&lt;/a&gt;。リファレンスはここにあります。</target>
        </trans-unit>
        <trans-unit id="b2e978dce6e27d24e2aafb780acc90f0cc8b6fb6" translate="yes" xml:space="preserve">
          <source>This setting is useful in two cases:</source>
          <target state="translated">この設定は以下の2つの場合に有効です。</target>
        </trans-unit>
        <trans-unit id="3bd3157d320740251f355d5814d6ffa211bfc011" translate="yes" xml:space="preserve">
          <source>This setting lets you specify a file for storing incremental compilation information as a part of composite projects which enables faster building of larger TypeScript codebases. You can read more about composite projects &lt;a href=&quot;docs/handbook/project-references&quot;&gt;in the handbook&lt;/a&gt;.</source>
          <target state="translated">この設定により、複合プロジェクトの一部としてインクリメンタルコンパイル情報を格納するファイルを指定できます。これにより、より大きなTypeScriptコードベースをより高速に構築できます。複合プロジェクトの詳細について&lt;a href=&quot;docs/handbook/project-references&quot;&gt;は、ハンドブックを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9fb839c0cccd09c3b2a3d1ab1913df898747ff9" translate="yes" xml:space="preserve">
          <source>This should not be confused with the idea that the values they refer to are &lt;em&gt;immutable&lt;/em&gt;.</source>
          <target state="translated">これを、それらが参照する値が&lt;em&gt;不変&lt;/em&gt;であるという考えと混同しないでください。</target>
        </trans-unit>
        <trans-unit id="a1f229269d84a6a8939b736e452446c28bdac1e5" translate="yes" xml:space="preserve">
          <source>This simple example shows how the names used during importing and exporting get translated into the module loading code.</source>
          <target state="translated">このシンプルな例では、インポートとエクスポートの際に使用される名前がどのようにモジュールの読み込みコードに変換されるかを示しています。</target>
        </trans-unit>
        <trans-unit id="acb7a478bd6024141f079e21fce02f772fec3fbc" translate="yes" xml:space="preserve">
          <source>This syntactically-legal program prints &lt;code&gt;Infinity&lt;/code&gt;. TypeScript, though, considers division of number by an array to be a nonsensical operation, and will issue an error:</source>
          <target state="translated">この構文的に合法的なプログラムは、 &lt;code&gt;Infinity&lt;/code&gt; を出力します。ただし、TypeScriptは、配列による数値の除算を無意味な操作と見なし、エラーを発行します。</target>
        </trans-unit>
        <trans-unit id="f0d828b3379cd2b4debebfb5ffcff651af177e54" translate="yes" xml:space="preserve">
          <source>This syntax is built into the JavaScript runtime and can have better guarantees about the isolation of each private field. Right now, the best documentation for these private fields is in the TypeScript 3.8 &lt;a href=&quot;https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#ecmascript-private-fields&quot;&gt;release notes&lt;/a&gt;.</source>
          <target state="translated">この構文はJavaScriptランタイムに組み込まれており、各プライベートフィールドの分離についてより適切に保証できます。現在、これらのプライベートフィールドの最適なドキュメントは、TypeScript3.8&lt;a href=&quot;https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#ecmascript-private-fields&quot;&gt;リリースノートにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a1008cf885d8164f0c0972e2e3403d26e6889f71" translate="yes" xml:space="preserve">
          <source>This takes all of the dependencies from a module and makes it an exported field, you could import it like this:</source>
          <target state="translated">これはモジュールからすべての依存関係を取得してエクスポートされたフィールドにします。</target>
        </trans-unit>
        <trans-unit id="2adafebdcb218187a19ac5c230d995b12afd1bc7" translate="yes" xml:space="preserve">
          <source>This technique is a hybrid approach, using Babel&amp;rsquo;s &lt;a href=&quot;https://babeljs.io/docs/en/babel-preset-typescript&quot;&gt;preset-typescript&lt;/a&gt; to generate your JS files, and then using TypeScript to do type checking and &lt;code&gt;.d.ts&lt;/code&gt; file generation.</source>
          <target state="translated">この手法はハイブリッドアプローチであり、Babelの &lt;code&gt;.d.ts&lt;/code&gt; &lt;a href=&quot;https://babeljs.io/docs/en/babel-preset-typescript&quot;&gt;-typescript&lt;/a&gt;を使用してJSファイルを生成し、TypeScriptを使用して型チェックと.d.tsファイルの生成を行います。</target>
        </trans-unit>
        <trans-unit id="83f579bee1621a210e4228f42fa55f672b307fc3" translate="yes" xml:space="preserve">
          <source>This technique lets you generate types ahead of time for the non-code source files. Imports then work naturally based off the source file&amp;rsquo;s location. For example &lt;code&gt;./src/index.ts&lt;/code&gt; can import the file &lt;code&gt;./src/css/main.css&lt;/code&gt; and TypeScript will be aware of the bundler&amp;rsquo;s behavior for that filetype via the corresponding generated declaration file.</source>
          <target state="translated">この手法を使用すると、コード以外のソースファイルの型を事前に生成できます。インポートは、ソースファイルの場所に基づいて自然に機能します。たとえば、。 &lt;code&gt;./src/index.ts&lt;/code&gt; はファイル &lt;code&gt;./src/css/main.css&lt;/code&gt; をインポートでき、TypeScriptは、対応する生成された宣言ファイルを介して、そのファイルタイプに対するバンドラーの動作を認識します。</target>
        </trans-unit>
        <trans-unit id="c02e5a7acc21e96b7b427fe531770986b2a8029c" translate="yes" xml:space="preserve">
          <source>This tells the compiler for any module import that matches the pattern &lt;code&gt;&quot;*&quot;&lt;/code&gt; (i.e. all values), to look in two locations:</source>
          <target state="translated">これは、パターン &lt;code&gt;&quot;*&quot;&lt;/code&gt; （つまり、すべての値）に一致するモジュールインポートを2つの場所で探すようコンパイラーに指示します。</target>
        </trans-unit>
        <trans-unit id="e28988a9e9ef50dbc6082fe7ec51c8e202185991" translate="yes" xml:space="preserve">
          <source>This treats the classes as interfaces, and only mixes the types behind Disposable and Activatable into the SmartObject type rather than the implementation. This means that we&amp;rsquo;ll have to provide the implementation in class. Except, that&amp;rsquo;s exactly what we want to avoid by using mixins.</source>
          <target state="translated">これはクラスをインターフェースとして扱い、DisposableとActivatableの背後にある型を、実装ではなくSmartObject型にのみ混合します。つまり、実装をクラスで提供する必要があります。それ以外は、ミックスインを使用することで回避したいものです。</target>
        </trans-unit>
        <trans-unit id="7c25450c61dcd13ee0d8fae944687b4f32fa002e" translate="yes" xml:space="preserve">
          <source>This tutorial provides a brief overview of TypeScript, focusing on its type system.</source>
          <target state="translated">このチュートリアルでは、TypeScriptの型システムに焦点を当てて、TypeScriptの概要を簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="9a9277b80c882b7208b460979a9bd488c375c6cf" translate="yes" xml:space="preserve">
          <source>This used to be TypeScript&amp;rsquo;s default resolution strategy. Nowadays, this strategy is mainly present for backward compatibility.</source>
          <target state="translated">これは、TypeScriptのデフォルトの解決戦略でした。現在、この戦略は主に下位互換性のために存在しています。</target>
        </trans-unit>
        <trans-unit id="93a8071076c50e947fcd54554c47e1e5fc4fac05" translate="yes" xml:space="preserve">
          <source>This uses &lt;a href=&quot;../../declaration-merging&quot;&gt;declaration merging&lt;/a&gt;</source>
          <target state="translated">これは&lt;a href=&quot;../../declaration-merging&quot;&gt;宣言のマージを&lt;/a&gt;使用します</target>
        </trans-unit>
        <trans-unit id="f1cd525962f56ec03ce869171a31b0c1c0befaf8" translate="yes" xml:space="preserve">
          <source>This utility does not return a transformed type. Instead, it serves as a marker for a contextual &lt;a href=&quot;functions#this&quot;&gt;&lt;code&gt;this&lt;/code&gt;&lt;/a&gt; type. Note that the &lt;code&gt;--noImplicitThis&lt;/code&gt; flag must be enabled to use this utility.</source>
          <target state="translated">このユーティリティは、変換された型を返しません。代わりに、&lt;a href=&quot;functions#this&quot;&gt; &lt;code&gt;this&lt;/code&gt; &lt;/a&gt;タイプのコンテキストのマーカーとして機能します。このユーティリティを使用するには、 &lt;code&gt;--noImplicitThis&lt;/code&gt; フラグを有効にする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="93fddce73184becc8bb1dcac36b8151b2a00b289" translate="yes" xml:space="preserve">
          <source>This utility does not return a transformed type. Instead, it serves as a marker for a contextual &lt;code&gt;this&lt;/code&gt; type. Note that the &lt;code&gt;--noImplicitThis&lt;/code&gt; flag must be enabled to use this utility.</source>
          <target state="translated">このユーティリティは、変換された型を返しません。代わりに、 &lt;code&gt;this&lt;/code&gt; タイプのコンテキストのマーカーとして機能します。このユーティリティを使用するには、 &lt;code&gt;--noImplicitThis&lt;/code&gt; フラグを有効にする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="84c1c214044cdc8f4303327fab0eacb4bcad4a14" translate="yes" xml:space="preserve">
          <source>This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;frozen object&lt;/a&gt;).</source>
          <target state="translated">このユーティリティは、実行時に失敗する割り当て式を表すのに役立ちます（つまり、&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;フリーズされたオブジェクトの&lt;/a&gt;プロパティを再割り当てしようとする場合）。</target>
        </trans-unit>
        <trans-unit id="af2d32c38013b382c9d64510bcce20de81efb3be" translate="yes" xml:space="preserve">
          <source>This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;frozen object&lt;/a&gt;).</source>
          <target state="translated">このユーティリティは、実行時に失敗する割り当て式を表すのに役立ちます（つまり、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;凍結されたオブジェクトの&lt;/a&gt;プロパティを再割り当てしようとする場合）。</target>
        </trans-unit>
        <trans-unit id="eaff2ada45477df0b05b97a2def6303701764e4e" translate="yes" xml:space="preserve">
          <source>This version of the loop will actually perform the summation correctly because the inner loop&amp;rsquo;s &lt;code&gt;i&lt;/code&gt; shadows &lt;code&gt;i&lt;/code&gt; from the outer loop.</source>
          <target state="translated">ループのこのバージョンでは、実際に内部ループのため、正しく集計を行います &lt;code&gt;i&lt;/code&gt; の影 &lt;code&gt;i&lt;/code&gt; 外側のループから。</target>
        </trans-unit>
        <trans-unit id="8382d7d850d9a5a4ffcaae61d648e575486c6e4e" translate="yes" xml:space="preserve">
          <source>This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:</source>
          <target state="translated">以上、普段のTypeScriptで使われている構文やツールの概要でした。ここからは</target>
        </trans-unit>
        <trans-unit id="9381442c6d6f687b278f6b0753897426078289bf" translate="yes" xml:space="preserve">
          <source>This works because arrow functions use the outer &lt;code&gt;this&lt;/code&gt;, so you can always pass them to something that expects &lt;code&gt;this: void&lt;/code&gt;. The downside is that one arrow function is created per object of type Handler. Methods, on the other hand, are only created once and attached to Handler&amp;rsquo;s prototype. They are shared between all objects of type Handler.</source>
          <target state="translated">これが機能するのは、矢印関数が外側の &lt;code&gt;this&lt;/code&gt; を使用するため、これを期待するものに常に渡すことができます &lt;code&gt;this: void&lt;/code&gt; 。欠点は、タイプHandlerのオブジェクトごとに1つの矢印関数が作成されることです。一方、メソッドは一度だけ作成され、ハンドラーのプロトタイプにアタッチされます。それらは、タイプHandlerのすべてのオブジェクト間で共有されます。</target>
        </trans-unit>
        <trans-unit id="a855814a311b76c2385f1f8fa0122f8b7cb5fd05" translate="yes" xml:space="preserve">
          <source>This works fine in TypeScript too, but the compiler doesn&amp;rsquo;t know about &lt;code&gt;Observable.prototype.map&lt;/code&gt;. You can use module augmentation to tell the compiler about it:</source>
          <target state="translated">これはTypeScriptでも正常に機能しますが、コンパイラーは &lt;code&gt;Observable.prototype.map&lt;/code&gt; を認識しません。モジュール拡張を使用して、コンパイラーにそれを伝えることができます。</target>
        </trans-unit>
        <trans-unit id="90afc95581c28b0ae5570b6d400541b7e8730c10" translate="yes" xml:space="preserve">
          <source>This works well enough, but we might imagine that &lt;code&gt;SomeType&lt;/code&gt; and &lt;code&gt;SomeVar&lt;/code&gt; were very closely related such that you&amp;rsquo;d like them to have the same name. We can use combining to present these two different objects (the value and the type) under the same name &lt;code&gt;Bar&lt;/code&gt;:</source>
          <target state="translated">これは十分に機能しますが、 &lt;code&gt;SomeType&lt;/code&gt; と &lt;code&gt;SomeVar&lt;/code&gt; が非常に密接に関連しているため、同じ名前にしたいと思うかもしれません。結合を使用して、これら2つの異なるオブジェクト（値とタイプ）を同じ名前 &lt;code&gt;Bar&lt;/code&gt; で表示できます。</target>
        </trans-unit>
        <trans-unit id="b919e153a19bd055003acaa3a57d606c66fa69e5" translate="yes" xml:space="preserve">
          <source>This would allow you to be able to write &lt;code&gt;import &quot;jquery&quot;&lt;/code&gt;, and get all of the correct typing locally.</source>
          <target state="translated">これにより、 &lt;code&gt;import &quot;jquery&quot;&lt;/code&gt; を記述して、すべての正しい入力をローカルで取得できるようになります。</target>
        </trans-unit>
        <trans-unit id="f57eefd52c82d3d36b6718a0eea84949e73f282d" translate="yes" xml:space="preserve">
          <source>This would have the following &lt;code&gt;.d.ts&lt;/code&gt; equivalent:</source>
          <target state="translated">これは、次の &lt;code&gt;.d.ts&lt;/code&gt; に相当します。</target>
        </trans-unit>
        <trans-unit id="8fe51f943aa966ad44227ae1d5f6f6ffe2daa142" translate="yes" xml:space="preserve">
          <source>ThisParameterType</source>
          <target state="translated">ThisParameterType</target>
        </trans-unit>
        <trans-unit id="476185d9e02b1c2446403ce730e896811f7c5c6c" translate="yes" xml:space="preserve">
          <source>ThisType&amp;lt;T&amp;gt;</source>
          <target state="translated">ThisType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="141ee6a2eac7f3e80ad87c7204dbdc726776e142" translate="yes" xml:space="preserve">
          <source>Though not recommended practice, some modules set up some global state that can be used by other modules. These modules may not have any exports, or the consumer is not interested in any of their exports. To import these modules, use:</source>
          <target state="translated">推奨される実践ではありませんが、モジュールによっては、他のモジュールで使用できるグローバルな状態を設定しているものがあります。これらのモジュールはエクスポートを持っていないかもしれませんし、消費者がそのエクスポートに興味を持っていないかもしれません。これらのモジュールをインポートするには</target>
        </trans-unit>
        <trans-unit id="459af1bfbb68d7eb9e20b58d77f575123c077dc5" translate="yes" xml:space="preserve">
          <source>Thus, the following calls are equivalent:</source>
          <target state="translated">したがって、以下の呼び出しは等価です。</target>
        </trans-unit>
        <trans-unit id="4cf1b54b003a59c279d1ba0b615a8a5f3459ca8c" translate="yes" xml:space="preserve">
          <source>Tips</source>
          <target state="translated">Tips</target>
        </trans-unit>
        <trans-unit id="789b874f65900275e1feb81853ccba2146efe3f2" translate="yes" xml:space="preserve">
          <source>To add creation of .d.ts files in your project, you will need to do up-to four steps:</source>
          <target state="translated">プロジェクトに.d.tsファイルの作成を追加するには、最大4つのステップを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="c479684dc5713300c68d9b67d81ddc804c214909" translate="yes" xml:space="preserve">
          <source>To allow differentiation between returned values and yielded values, TypeScript 3.6 converts the &lt;code&gt;IteratorResult&lt;/code&gt; type to a discriminated union type:</source>
          <target state="translated">TypeScript 3.6は、戻り値と生成された値を区別できるように、 &lt;code&gt;IteratorResult&lt;/code&gt; 型を識別された共用体型に変換します。</target>
        </trans-unit>
        <trans-unit id="dab773ebdeb56f5d4d302abac7504ce08a873ba8" translate="yes" xml:space="preserve">
          <source>To avoid a possible memory bloat issues when working with very large JavaScript projects, there is an upper limit to the amount of memory TypeScript will allocate. Turning this flag on will remove the limit.</source>
          <target state="translated">非常に大規模な JavaScript プロジェクトで作業をする際に起こりうるメモリの肥大化を避けるために、TypeScript が割り当てるメモリの量には上限があります。このフラグをオンにすると制限がなくなります。</target>
        </trans-unit>
        <trans-unit id="b4b29c56482897c2bcedcd82df10d23478983ef9" translate="yes" xml:space="preserve">
          <source>To begin, just as in JavaScript, TypeScript functions can be created both as a named function or as an anonymous function. This allows you to choose the most appropriate approach for your application, whether you&amp;rsquo;re building a list of functions in an API or a one-off function to hand off to another function.</source>
          <target state="translated">まず、JavaScriptと同様に、TypeScript関数は、名前付き関数または匿名関数の両方として作成できます。これにより、APIで関数のリストを作成する場合でも、別の関数に渡すための1回限りの関数で作成する場合でも、アプリケーションに最適なアプローチを選択できます。</target>
        </trans-unit>
        <trans-unit id="ed7d2301f55dd416668c23e26708f6625cc0b7df" translate="yes" xml:space="preserve">
          <source>To check if &lt;code&gt;x&lt;/code&gt; is assignable to &lt;code&gt;y&lt;/code&gt;, we first look at the parameter list. Each parameter in &lt;code&gt;x&lt;/code&gt; must have a corresponding parameter in &lt;code&gt;y&lt;/code&gt; with a compatible type. Note that the names of the parameters are not considered, only their types. In this case, every parameter of &lt;code&gt;x&lt;/code&gt; has a corresponding compatible parameter in &lt;code&gt;y&lt;/code&gt;, so the assignment is allowed.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; が &lt;code&gt;y&lt;/code&gt; に割り当て可能かどうかを確認するには、まずパラメーターリストを確認します。 &lt;code&gt;x&lt;/code&gt; の各パラメーターには、互換性のあるタイプの対応する &lt;code&gt;y&lt;/code&gt; のパラメーターが必要です。パラメータの名前は考慮されず、タイプのみが考慮されることに注意してください。この場合、 &lt;code&gt;x&lt;/code&gt; のすべてのパラメーターには &lt;code&gt;y&lt;/code&gt; に対応する互換パラメーターがあるため、割り当てが許可されます。</target>
        </trans-unit>
        <trans-unit id="5aa2d6b34ccb6e986760e69cce9eaf8d194e80e3" translate="yes" xml:space="preserve">
          <source>To check whether &lt;code&gt;y&lt;/code&gt; can be assigned to &lt;code&gt;x&lt;/code&gt;, the compiler checks each property of &lt;code&gt;x&lt;/code&gt; to find a corresponding compatible property in &lt;code&gt;y&lt;/code&gt;. In this case, &lt;code&gt;y&lt;/code&gt; must have a member called &lt;code&gt;name&lt;/code&gt; that is a string. It does, so the assignment is allowed.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; を &lt;code&gt;x&lt;/code&gt; に割り当てることができるかどうかを確認するために、コンパイラーは &lt;code&gt;x&lt;/code&gt; の各プロパティを確認して、 &lt;code&gt;y&lt;/code&gt; 内の対応する互換性のあるプロパティを見つけます。この場合、 &lt;code&gt;y&lt;/code&gt; には、文字列である &lt;code&gt;name&lt;/code&gt; と呼ばれるメンバーが必要です。そのため、割り当てが許可されます。</target>
        </trans-unit>
        <trans-unit id="75b4fbb1127914ceb3d21cad503d3f7fc1d4e3ca" translate="yes" xml:space="preserve">
          <source>To compile, we must specify a module target on the command line. For Node.js, use &lt;code&gt;--module commonjs&lt;/code&gt;; for require.js, use &lt;code&gt;--module amd&lt;/code&gt;. For example:</source>
          <target state="translated">コンパイルするには、コマンドラインでモジュールターゲットを指定する必要があります。Node.jsの場合、-- &lt;code&gt;--module commonjs&lt;/code&gt; 使用します。require.jsの場合は、-- &lt;code&gt;--module amd&lt;/code&gt; 使用します。例えば：</target>
        </trans-unit>
        <trans-unit id="5bd0f12b21d35f79d32b5a8c2a9e7ab064c0bb0a" translate="yes" xml:space="preserve">
          <source>To control which folders you want to the files to be built to, use the config option &lt;a href=&quot;#tsBuildInfoFile&quot;&gt;&lt;code&gt;tsBuildInfoFile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ファイルをビルドするフォルダーを制御するには、構成オプション&lt;a href=&quot;#tsBuildInfoFile&quot;&gt; &lt;code&gt;tsBuildInfoFile&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="5c92181f23fdc218d3e5f2c8e5c093d3e88dd341" translate="yes" xml:space="preserve">
          <source>To correctly represent the types that can be passed in to a generator from calls to &lt;code&gt;next()&lt;/code&gt;, TypeScript 3.6 also infers certain uses of &lt;code&gt;yield&lt;/code&gt; within the body of a generator function.</source>
          <target state="translated">&lt;code&gt;next()&lt;/code&gt; の呼び出しからジェネレーターに渡すことができる型を正しく表すために、TypeScript 3.6 はジェネレーター関数の本体内で特定の &lt;code&gt;yield&lt;/code&gt; の使用も推論します。</target>
        </trans-unit>
        <trans-unit id="4a85275c6424e7d3a9f548f3f9d3fe8015b36051" translate="yes" xml:space="preserve">
          <source>To define a type guard, we simply need to define a function whose return type is a &lt;em&gt;type predicate&lt;/em&gt;:</source>
          <target state="translated">型ガードを定義するには、戻り値の型が&lt;em&gt;型述語で&lt;/em&gt;ある関数を定義するだけです。</target>
        </trans-unit>
        <trans-unit id="509608b5d7a3db1a99b623edfaa3336bb28d3b8d" translate="yes" xml:space="preserve">
          <source>To describe a function type with an interface, we give the interface a call signature. This is like a function declaration with only the parameter list and return type given. Each parameter in the parameter list requires both name and type.</source>
          <target state="translated">関数型をインターフェースで記述するために、インターフェースにコールシグネチャを与えます。これは、パラメータリストと戻り値の型だけを与えた関数宣言のようなものです。パラメータリストの各パラメータは、名前と型の両方を必要とします。</target>
        </trans-unit>
        <trans-unit id="c07e6015d0cdce1868d861847dbd57c18c3fb7ac" translate="yes" xml:space="preserve">
          <source>To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes.</source>
          <target state="translated">TypeScriptで書かれていないライブラリの形を記述するには、ライブラリが公開しているAPIを宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="afcbeb02ce03509365825abf4caef8de00c49ba6" translate="yes" xml:space="preserve">
          <source>To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes. Because most JavaScript libraries expose only a few top-level objects, namespaces are a good way to represent them.</source>
          <target state="translated">TypeScriptで書かれていないライブラリの形を表現するには、そのライブラリが公開しているAPIを宣言する必要があります。ほとんどの JavaScript ライブラリが公開しているのは少数のトップレベルのオブジェクトだけなので、名前空間はそれらを表現するのに適した方法です。</target>
        </trans-unit>
        <trans-unit id="0300d21291d54245672afcd6c034804cd6d8f1af" translate="yes" xml:space="preserve">
          <source>To detect the issue around accessors, TypeScript 3.7 will now emit &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors in &lt;code&gt;.d.ts&lt;/code&gt; files so that in TypeScript can check for overridden accessors.</source>
          <target state="translated">TypeScript 3.7は、アクセサーに関する問題を検出するために、 &lt;code&gt;.d.ts&lt;/code&gt; ファイルで &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; アクセサーを発行し、TypeScriptでオーバーライドされたアクセサーをチェックできるようになりました。</target>
        </trans-unit>
        <trans-unit id="0105ab9a65a074ef9c63d082566ad7bd09908a6d" translate="yes" xml:space="preserve">
          <source>To do so, we&amp;rsquo;ll create an interface that describes our constraint. Here, we&amp;rsquo;ll create an interface that has a single &lt;code&gt;.length&lt;/code&gt; property and then we&amp;rsquo;ll use this interface and the &lt;code&gt;extends&lt;/code&gt; keyword to denote our constraint:</source>
          <target state="translated">そのために、制約を記述するインターフェースを作成します。ここでは、単一の &lt;code&gt;.length&lt;/code&gt; プロパティを持つインターフェースを作成し、このインターフェースと &lt;code&gt;extends&lt;/code&gt; キーワードを使用して制約を示します。</target>
        </trans-unit>
        <trans-unit id="a28ef11afcbe8d3d69c6a4bf7c61c5a049f90264" translate="yes" xml:space="preserve">
          <source>To do this, you&amp;rsquo;ll need to create a &lt;code&gt;tsconfig.json&lt;/code&gt; which contains a list of your input files as well as all your compilation settings. Simply create a new file in your project root named &lt;code&gt;tsconfig.json&lt;/code&gt; and fill it with the following contents:</source>
          <target state="translated">これを行うには、入力ファイルのリストとすべてのコンパイル設定を含む &lt;code&gt;tsconfig.json&lt;/code&gt; を作成する必要があります。プロジェクトのルートに &lt;code&gt;tsconfig.json&lt;/code&gt; という名前の新しいファイルを作成し、次の内容を入力するだけです。</target>
        </trans-unit>
        <trans-unit id="6a7b875dfeed7fc61c9681ef2adf2ce3963acdd1" translate="yes" xml:space="preserve">
          <source>To enable experimental support for decorators, you must enable the &lt;code&gt;experimentalDecorators&lt;/code&gt; compiler option either on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">デコレータのための実験的なサポートを有効にするには、有効にする必要があり &lt;code&gt;experimentalDecorators&lt;/code&gt; コマンドライン上または自分の中のいずれかのコンパイラオプション &lt;code&gt;tsconfig.json&lt;/code&gt; を：</target>
        </trans-unit>
        <trans-unit id="e91510089a97db0cb9eadcf3ab17449eabecd456" translate="yes" xml:space="preserve">
          <source>To enable the recursive type alias patterns described above, the &lt;code&gt;typeArguments&lt;/code&gt; property has been removed from the &lt;code&gt;TypeReference&lt;/code&gt; interface. Users should instead use the &lt;code&gt;getTypeArguments&lt;/code&gt; function on &lt;code&gt;TypeChecker&lt;/code&gt; instances.</source>
          <target state="translated">上記の再帰的な型エイリアスパターンを有効にするために、 &lt;code&gt;typeArguments&lt;/code&gt; プロパティが &lt;code&gt;TypeReference&lt;/code&gt; インターフェイスから削除されました。代わりに、ユーザーは &lt;code&gt;TypeChecker&lt;/code&gt; インスタンスで &lt;code&gt;getTypeArguments&lt;/code&gt; 関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e2363be8e6c6cb5a067aea3d8f64f3d22b30a1c7" translate="yes" xml:space="preserve">
          <source>To enable treating symbols as unique literals a new type &lt;code&gt;unique symbol&lt;/code&gt; is available. &lt;code&gt;unique symbol&lt;/code&gt; is a subtype of &lt;code&gt;symbol&lt;/code&gt;, and are produced only from calling &lt;code&gt;Symbol()&lt;/code&gt; or &lt;code&gt;Symbol.for()&lt;/code&gt;, or from explicit type annotations. The new type is only allowed on &lt;code&gt;const&lt;/code&gt; declarations and &lt;code&gt;readonly static&lt;/code&gt; properties, and in order to reference a specific unique symbol, you&amp;rsquo;ll have to use the &lt;code&gt;typeof&lt;/code&gt; operator. Each reference to a &lt;code&gt;unique symbol&lt;/code&gt; implies a completely unique identity that&amp;rsquo;s tied to a given declaration.</source>
          <target state="translated">シンボルを一意のリテラルとして扱うことを可能にするために、新しいタイプの &lt;code&gt;unique symbol&lt;/code&gt; が利用可能です。 &lt;code&gt;unique symbol&lt;/code&gt; はsymbolのサブタイプで &lt;code&gt;symbol&lt;/code&gt; 、 &lt;code&gt;Symbol()&lt;/code&gt; または &lt;code&gt;Symbol.for()&lt;/code&gt; の呼び出し、または明示的な型注釈からのみ生成されます。新しい型は &lt;code&gt;const&lt;/code&gt; 宣言と &lt;code&gt;readonly static&lt;/code&gt; プロパティでのみ許可され、特定の一意のシンボルを参照するには、 &lt;code&gt;typeof&lt;/code&gt; 演算子を使用する必要があります。 &lt;code&gt;unique symbol&lt;/code&gt; への参照はそれぞれ、特定の宣言に関連付けられた完全に一意のIDを意味します。</target>
        </trans-unit>
        <trans-unit id="a2a8ede1fa38a59757413a66a422de02420747b4" translate="yes" xml:space="preserve">
          <source>To fix these issues, you would probably want to set up a command to type check your project using TSC. This likely means duplicating some of your babel config into a corresponding &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;&lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; and ensuring these flags are enabled:</source>
          <target state="translated">これらの問題を修正するには、TSCを使用してプロジェクトをタイプチェックするコマンドを設定することをお勧めします。これはおそらく、babel設定の一部を対応する&lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; に複製し&lt;/a&gt;、これらのフラグが有効になっていることを確認することを意味します。</target>
        </trans-unit>
        <trans-unit id="2ca735a8b247a6d501055cf55a7c32e4798d2f35" translate="yes" xml:space="preserve">
          <source>To get an error when TypeScript produces an &lt;code&gt;any&lt;/code&gt;, use &lt;code&gt;&quot;noImplicitAny&quot;: true&lt;/code&gt;, or &lt;code&gt;&quot;strict&quot;: true&lt;/code&gt; in &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="translated">活字体が生成するときにエラーを取得するには &lt;code&gt;any&lt;/code&gt; 、使用 &lt;code&gt;&quot;noImplicitAny&quot;: true&lt;/code&gt; 、または &lt;code&gt;&quot;strict&quot;: true&lt;/code&gt; で &lt;code&gt;tsconfig.json&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbf37d6416e66ab0ef9074eb1300931277b42ac8" translate="yes" xml:space="preserve">
          <source>To get more specific, let&amp;rsquo;s build up some motivation and consider the following &lt;code&gt;compose&lt;/code&gt; function:</source>
          <target state="translated">より具体的に説明するために、モチベーションを高めて、次の &lt;code&gt;compose&lt;/code&gt; 関数を検討してみましょう。</target>
        </trans-unit>
        <trans-unit id="45a47ec78d51136ebeb7c0035a7c5da00cc87248" translate="yes" xml:space="preserve">
          <source>To get started, we&amp;rsquo;ll need a class which will have the mixin&amp;rsquo;s applied on top of:</source>
          <target state="translated">開始するには、以下の上にミックスインを適用するクラスが必要です。</target>
        </trans-unit>
        <trans-unit id="d66869d0f99755ea08df36056766e3e90f0cd610" translate="yes" xml:space="preserve">
          <source>To get the same code working via property accessors, we&amp;rsquo;ll need to use a type assertion:</source>
          <target state="translated">プロパティアクセサーを介して同じコードを機能させるには、型アサーションを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="7dd85227b3548e65f6da723dba0b86e37aa0dbf7" translate="yes" xml:space="preserve">
          <source>To get the same code working, we&amp;rsquo;ll need to use a type assertion:</source>
          <target state="translated">同じコードを機能させるには、型アサーションを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="35beccf47f973d38e356b224393b06f7953333cd" translate="yes" xml:space="preserve">
          <source>To give you an idea of how all these pieces can come together, here is a reference &lt;code&gt;.d.ts&lt;/code&gt; to start with when making a new module</source>
          <target state="translated">これらすべての要素をどのように &lt;code&gt;.d.ts&lt;/code&gt; ことができるかを理解するために、新しいモジュールを作成するときに開始するリファレンス.d.tsを次に示します。</target>
        </trans-unit>
        <trans-unit id="5fec9382d2cac44b5a2760a5f5fd406c2cf32f49" translate="yes" xml:space="preserve">
          <source>To handle both importing via UMD and modules:</source>
          <target state="translated">UMD経由でのインポートとモジュール経由でのインポートの両方に対応します。</target>
        </trans-unit>
        <trans-unit id="51bcd2ee5a6a2dcd5ba1a0638fe26fb80525ff92" translate="yes" xml:space="preserve">
          <source>To help mitigate the second issue, you can either add an explicit initializer or add a &lt;code&gt;declare&lt;/code&gt; modifier to indicate that a property should have no emit.</source>
          <target state="translated">2番目の問題を軽減するために、明示的な初期化子を追加するか、プロパティに放出がないことを示す &lt;code&gt;declare&lt;/code&gt; 修飾子を追加できます。</target>
        </trans-unit>
        <trans-unit id="e6a579a27d8288d6f9fa099e50e47bee7c5f5359" translate="yes" xml:space="preserve">
          <source>To help with string manipulation around template string literals, TypeScript includes a set of types which can be used in string manipulation within the type system. You can</source>
          <target state="translated">テンプレート文字列リテラル周辺の文字列操作を支援するために、TypeScriptには、型システム内の文字列操作に使用できる型のセットが含まれています。以下のようなことができます。</target>
        </trans-unit>
        <trans-unit id="13ac7bef7c1c7e11ef81979db1c2f2a81cf19fc2" translate="yes" xml:space="preserve">
          <source>To infer the type of &lt;code&gt;x&lt;/code&gt; in the example above, we must consider the type of each array element. Here we are given two choices for the type of the array: &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt;. The best common type algorithm considers each candidate type, and picks the type that is compatible with all the other candidates.</source>
          <target state="translated">上記の例で &lt;code&gt;x&lt;/code&gt; の型を推測するには、各配列要素の型を考慮する必要があります。ここでは、配列のタイプとして、 &lt;code&gt;number&lt;/code&gt; と &lt;code&gt;null&lt;/code&gt; の 2つの選択肢があります。最も一般的なタイプアルゴリズムは、各候補タイプを考慮し、他のすべての候補と互換性のあるタイプを選択します。</target>
        </trans-unit>
        <trans-unit id="c3a042083562f94184f2e9a526e92d4624f7a75c" translate="yes" xml:space="preserve">
          <source>To learn all of the features available in JSDoc, see &lt;a href=&quot;jsdoc-supported-types&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="translated">JSDocで利用可能なすべての機能について&lt;a href=&quot;jsdoc-supported-types&quot;&gt;は、リファレンスを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2e2445c46ae38decbdcceb4e18f8e4d29d8ec207" translate="yes" xml:space="preserve">
          <source>To learn more about how JavaScript is interpreted by TypeScript read &lt;a href=&quot;type-checking-javascript-files&quot;&gt;How TS Type Checks JS&lt;/a&gt;</source>
          <target state="translated">JavaScriptがTypeScriptによってどのように解釈されるかについて詳しくは、&lt;a href=&quot;type-checking-javascript-files&quot;&gt;TSタイプがJSをチェックする方法&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="808177508af689c394e654a499a68e6b1a4ab02a" translate="yes" xml:space="preserve">
          <source>To learn more about the hundreds of configuration options in the &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;TSConfig Reference&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;TSConfigリファレンスの&lt;/a&gt;何百もの構成オプションの詳細については。</target>
        </trans-unit>
        <trans-unit id="2cf2e12d1445d0aadb96f230e547df7611323dbd" translate="yes" xml:space="preserve">
          <source>To learn more, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31116&quot;&gt;check out the original pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">詳しくは、&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31116&quot;&gt;GitHubの元のプルリクエストを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="d48e164ebf0706bbeef6b8d4d1ffab98e9301fa2" translate="yes" xml:space="preserve">
          <source>To learn the type of a variable, use &lt;code&gt;typeof&lt;/code&gt;:</source>
          <target state="translated">変数のタイプを学習するには、 &lt;code&gt;typeof&lt;/code&gt; ：を使用します。</target>
        </trans-unit>
        <trans-unit id="5f5f3e9b4e4a6af029b4267e885fa3ce255b1ecf" translate="yes" xml:space="preserve">
          <source>To maintain type safety, we can use the &lt;code&gt;typeof&lt;/code&gt; keyword. The &lt;code&gt;typeof&lt;/code&gt; keyword, when used in a type position, produces the type of a value, in this case the type of the module.</source>
          <target state="translated">タイプセーフを維持するために、 &lt;code&gt;typeof&lt;/code&gt; キーワードを使用できます。 &lt;code&gt;typeof&lt;/code&gt; 演算のタイプの位置で使用されるキーワードが、この場合、モジュールの種類に、値の種類を生成します。</target>
        </trans-unit>
        <trans-unit id="625fea5502d41397c32546a9a0ea50c65ae835db" translate="yes" xml:space="preserve">
          <source>To merge the namespace value, at each declaration site, if a namespace already exists with the given name, it is further extended by taking the existing namespace and adding the exported members of the second namespace to the first.</source>
          <target state="translated">名前空間の値をマージするために、各宣言サイトで、指定された名前の名前空間がすでに存在する場合は、既存の名前空間を取り、最初の名前空間に2番目の名前空間のエクスポートされたメンバを追加することで、さらに拡張されます。</target>
        </trans-unit>
        <trans-unit id="e313e5ed420f9f03b21861d0bbd9027ef02d9b32" translate="yes" xml:space="preserve">
          <source>To merge the namespaces, type definitions from exported interfaces declared in each namespace are themselves merged, forming a single namespace with merged interface definitions inside.</source>
          <target state="translated">名前空間をマージするには、各名前空間で宣言されたエクスポートされたインタフェースの型定義をマージし、マージされたインタフェース定義を内部に持つ単一の名前空間を形成します。</target>
        </trans-unit>
        <trans-unit id="601f6a1ad7b275eaa55ff8112b05048d0ec9e5bc" translate="yes" xml:space="preserve">
          <source>To model this, we modify the original constructor type to accept a generic argument.</source>
          <target state="translated">これをモデル化するために、元のコンストラクタの型を変更して、一般的な引数を受け入れるようにします。</target>
        </trans-unit>
        <trans-unit id="22cc216e31611ca78f1d455f6fccc99b2815b93a" translate="yes" xml:space="preserve">
          <source>To preserve existing functionality, we also add a simple getter that retrieves &lt;code&gt;fullName&lt;/code&gt; unmodified.</source>
          <target state="translated">既存の機能を保持するために、 &lt;code&gt;fullName&lt;/code&gt; を変更せずに取得する単純なゲッターも追加します。</target>
        </trans-unit>
        <trans-unit id="f744a2110e26e2b8cb5b64d6c11b34abc0ac07e8" translate="yes" xml:space="preserve">
          <source>To prove to ourselves that our accessor is now checking the length of values, we can attempt to assign a name longer than 10 characters and verify that we get an error.</source>
          <target state="translated">アクセサが値の長さをチェックするようになったことを自分自身に証明するために、10文字よりも長い名前を代入してみて、エラーが出ることを確認することができます。</target>
        </trans-unit>
        <trans-unit id="d0b5bbb81ca0d263287358fac537a9ccf83a25cd" translate="yes" xml:space="preserve">
          <source>To quickly recap what these two approaches look like in JavaScript:</source>
          <target state="translated">この2つのアプローチがJavaScriptでどのようなものかを素早く復習するために。</target>
        </trans-unit>
        <trans-unit id="e294e29d961a6bb9b93ca330847244995e631e4c" translate="yes" xml:space="preserve">
          <source>To read up more about assertion signatures, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;check out the original pull request&lt;/a&gt;.</source>
          <target state="translated">アサーション署名の詳細について&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;は、元のプルリクエストを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="5032cc8bd0b8d34fd39729d94585dfdc34772a96" translate="yes" xml:space="preserve">
          <source>To reiterate why you shouldn&amp;rsquo;t try to namespace your module contents, the general idea of namespacing is to provide logical grouping of constructs and to prevent name collisions. Because the module file itself is already a logical grouping, and its top-level name is defined by the code that imports it, it&amp;rsquo;s unnecessary to use an additional module layer for exported objects.</source>
          <target state="translated">モジュールのコンテンツに名前空間を付けようとしない理由を繰り返すと、名前空間の一般的な考え方は、構成体の論理グループを提供し、名前の衝突を防ぐことです。モジュールファイル自体はすでに論理的なグループであり、その最上位の名前はそれをインポートするコードによって定義されているため、エクスポートされたオブジェクトに追加のモジュールレイヤーを使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="1ea09d0dcf7792b419d55f46f04da3421ddf5acc" translate="yes" xml:space="preserve">
          <source>To see these methods in action modify the existing code to:</source>
          <target state="translated">これらのメソッドの動作を見るには、既存のコードを変更してください。</target>
        </trans-unit>
        <trans-unit id="8f051c1386e5d7793a46792a39ce291a486c3239" translate="yes" xml:space="preserve">
          <source>To specify this relationship to the compiler, use&lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt;. &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; specify a list of &lt;em&gt;roots&lt;/em&gt; whose contents are expected to merge at run-time. So following our example, the &lt;code&gt;tsconfig.json&lt;/code&gt; file should look like:</source>
          <target state="translated">この関係をコンパイラーに指定するには、 &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; 使用します。 &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; は、実行時に内容がマージされることが予想される&lt;em&gt;ルートの&lt;/em&gt;リストを指定します。したがって、この例に &lt;code&gt;tsconfig.json&lt;/code&gt; と、tsconfig.jsonファイルは次のようになります。</target>
        </trans-unit>
        <trans-unit id="815547684a56e87f0f61f4eec10d3298c1894627" translate="yes" xml:space="preserve">
          <source>To start off, let&amp;rsquo;s do the &amp;ldquo;hello world&amp;rdquo; of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the &lt;code&gt;echo&lt;/code&gt; command.</source>
          <target state="translated">最初に、ジェネリックの「こんにちは世界」、アイデンティティ関数を実行してみましょう。アイデンティティ関数は、渡されたものを何でも返す関数です。これは、 &lt;code&gt;echo&lt;/code&gt; コマンドと同じように考えることができます。</target>
        </trans-unit>
        <trans-unit id="e5b9fe870e7f5bf7070c8d8bb27856dc22fe14ff" translate="yes" xml:space="preserve">
          <source>To start, we&amp;rsquo;re going to structure our project in the following way:</source>
          <target state="translated">まず、プロジェクトを次のように構成します。</target>
        </trans-unit>
        <trans-unit id="3c02e0a11dcbbd64ac3f3d468a0774d3ea7e3a4b" translate="yes" xml:space="preserve">
          <source>To summarize, we have a language that was designed for quick uses, and then grew to a full-fledged tool to write applications with millions of lines. Every language has its own &lt;em&gt;quirks&lt;/em&gt; &amp;mdash; oddities and surprises, and JavaScript&amp;rsquo;s humble beginning makes it have &lt;em&gt;many&lt;/em&gt; of these. Some examples:</source>
          <target state="translated">要約すると、すぐに使用できるように設計された言語があり、その後、数百万行のアプリケーションを作成するための本格的なツールに成長しました。すべての言語には独自の&lt;em&gt;癖があります&lt;/em&gt;&amp;mdash;奇妙なことと驚きです。JavaScriptの謙虚な始まりにより、これらの&lt;em&gt;多くが&lt;/em&gt;あります。いくつかの例：</target>
        </trans-unit>
        <trans-unit id="ae9fedcb5b02e069b5600cc79446eace7ee0e944" translate="yes" xml:space="preserve">
          <source>To this JavaScript:</source>
          <target state="translated">このJavaScriptへ</target>
        </trans-unit>
        <trans-unit id="cff04291bfbc2b0841bede7f6b8fa3e70667afd9" translate="yes" xml:space="preserve">
          <source>To understand how namespaces work in &lt;code&gt;.d.ts&lt;/code&gt; files read the &lt;a href=&quot;../deep-dive&quot;&gt;&lt;code&gt;.d.ts&lt;/code&gt; deep dive&lt;/a&gt;.</source>
          <target state="translated">名前空間がでどのように機能するかを理解するために &lt;code&gt;.d.ts&lt;/code&gt; ファイルが読み込ま&lt;a href=&quot;../deep-dive&quot;&gt; &lt;code&gt;.d.ts&lt;/code&gt; に深いダイビングを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6351bd2f28ea37dec03ce0f4f1566144d901482" translate="yes" xml:space="preserve">
          <source>To understand the full impact, read &lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;the section above on the &lt;code&gt;useDefineForClassFields&lt;/code&gt; flag&lt;/a&gt;.</source>
          <target state="translated">完全な影響を理解する&lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;には、 &lt;code&gt;useDefineForClassFields&lt;/code&gt; フラグに関する上記のセクションをお&lt;/a&gt;読みください。</target>
        </trans-unit>
        <trans-unit id="f47b632fb61682e3e1980ea8cfc2ca8c1262d2a4" translate="yes" xml:space="preserve">
          <source>To understand what steps the TS compiler will follow, it is important to shed some light on Node.js modules. Traditionally, imports in Node.js are performed by calling a function named &lt;code&gt;require&lt;/code&gt;. The behavior Node.js takes will differ depending on if &lt;code&gt;require&lt;/code&gt; is given a relative path or a non-relative path.</source>
          <target state="translated">TSコンパイラが実行する手順を理解するには、Node.jsモジュールに光を当てることが重要です。従来、Node.jsでのインポートは、 &lt;code&gt;require&lt;/code&gt; という名前の関数を呼び出すことで実行されていました。Node.jsの動作は、 &lt;code&gt;require&lt;/code&gt; に相対パスが指定されているか、非相対パスが指定されているかによって異なります。</target>
        </trans-unit>
        <trans-unit id="dfa2ee0b72c86bc53820792311112500d3168498" translate="yes" xml:space="preserve">
          <source>To use JSX with React you should use the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;React typings&lt;/a&gt;. These typings define the &lt;code&gt;JSX&lt;/code&gt; namespace appropriately for use with React.</source>
          <target state="translated">ReactでJSXを使用するには、&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;Reactタイピング&lt;/a&gt;を使用する必要があります。これらの型付けは、Reactで使用するために &lt;code&gt;JSX&lt;/code&gt; 名前空間を適切に定義します。</target>
        </trans-unit>
        <trans-unit id="4e99d36c2c814e6db91b56c7f1385a2856d73b4a" translate="yes" xml:space="preserve">
          <source>To use JSX-support with React you should use the &lt;a href=&quot;https://github.com/borisyankov/DefinitelyTyped/tree/master/react&quot;&gt;React typings&lt;/a&gt;. These typings define the &lt;code&gt;JSX&lt;/code&gt; namespace so that TypeScript can correctly check JSX expressions for React. For example:</source>
          <target state="translated">ReactでJSXサポートを使用するには、&lt;a href=&quot;https://github.com/borisyankov/DefinitelyTyped/tree/master/react&quot;&gt;Reactのタイピング&lt;/a&gt;を使用する必要があります。これらのタイピングは、TypeScriptがJSX式のReactを正しくチェックできるように、 &lt;code&gt;JSX&lt;/code&gt; 名前空間を定義します。例えば：</target>
        </trans-unit>
        <trans-unit id="8c8d5eec1e67cb76f8e5b9452d73b271fa703953" translate="yes" xml:space="preserve">
          <source>Today, most popular globally-accessible libraries are actually written as UMD libraries (see below). UMD library documentation is hard to distinguish from global library documentation. Before writing a global declaration file, make sure the library isn&amp;rsquo;t actually UMD.</source>
          <target state="translated">今日、最も人気のあるグローバルにアクセス可能なライブラリは、実際にはUMDライブラリとして記述されています（以下を参照）。UMDライブラリドキュメントは、グローバルライブラリドキュメントと区別が困難です。グローバル宣言ファイルを書き込む前に、ライブラリが実際にUMDではないことを確認してください。</target>
        </trans-unit>
        <trans-unit id="6fd792937ccf8cb9ce4609174a62036b37620b1a" translate="yes" xml:space="preserve">
          <source>Together (1) and (2) mean that we have to move our call to &lt;code&gt;browserify&lt;/code&gt; out of the &lt;code&gt;default&lt;/code&gt; task. And we have to give the function for &lt;code&gt;default&lt;/code&gt; a name since both Watchify and Gulp need to call it. Adding logging with (3) is optional but very useful for debugging your setup.</source>
          <target state="translated">一緒に（1）及び（2）私たちは私たちのために呼び出しを移動する必要があることを意味 &lt;code&gt;browserify&lt;/code&gt; のうち &lt;code&gt;default&lt;/code&gt; タスク。また、WatchifyとGulpの両方で呼び出す必要があるため、 &lt;code&gt;default&lt;/code&gt; の関数に名前を付ける必要があります。（3）を使用したロギングの追加はオプションですが、セットアップのデバッグに非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="eff2d319ea219f2ac59917c5f301c263edd3b652" translate="yes" xml:space="preserve">
          <source>Together with &lt;a href=&quot;unions-and-intersections&quot;&gt;intersection&lt;/a&gt; types, we can make some pretty mind-bending types:</source>
          <target state="translated">&lt;a href=&quot;unions-and-intersections&quot;&gt;交差&lt;/a&gt;型と一緒に、私たちはいくつかのかなり心を曲げる型を作ることができます：</target>
        </trans-unit>
        <trans-unit id="90ffa057dee234ae14145ef7d88d4144f613ba98" translate="yes" xml:space="preserve">
          <source>Together with intersection types, we can make some pretty mind-bending types:</source>
          <target state="translated">交差点タイプと合わせて、かなり心を揺さぶるタイプを作ることができます。</target>
        </trans-unit>
        <trans-unit id="fc8a45a8bf9a321fc559be14ce628df7527276e1" translate="yes" xml:space="preserve">
          <source>Too many/too few arguments</source>
          <target state="translated">議論が多すぎる/少なすぎる</target>
        </trans-unit>
        <trans-unit id="d9b3553c61db15698937a8831d5f65646814ea45" translate="yes" xml:space="preserve">
          <source>ToolsVersion</source>
          <target state="translated">ToolsVersion</target>
        </trans-unit>
        <trans-unit id="2fcfbecfc781cdc6c205a4af08b389fbe5757349" translate="yes" xml:space="preserve">
          <source>Top-level &lt;code&gt;var&lt;/code&gt; statements or &lt;code&gt;function&lt;/code&gt; declarations</source>
          <target state="translated">トップレベルの &lt;code&gt;var&lt;/code&gt; ステートメントまたは &lt;code&gt;function&lt;/code&gt; 宣言</target>
        </trans-unit>
        <trans-unit id="bfe242d3ed392dcc4dc72844403f2e430bfe4d50" translate="yes" xml:space="preserve">
          <source>Trace Resolution - &lt;code&gt;traceResolution&lt;/code&gt;</source>
          <target state="translated">トレース解像度 &lt;code&gt;traceResolution&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d190cc42b7745bd9ac9a35c4f9aea03a1b699465" translate="yes" xml:space="preserve">
          <source>Tracing module resolution</source>
          <target state="translated">トレースモジュールの解像度</target>
        </trans-unit>
        <trans-unit id="23fcdfe71b99cac9d947ed514f12d8af78487a21" translate="yes" xml:space="preserve">
          <source>Trade-offs of Modules</source>
          <target state="translated">モジュールのトレードオフ</target>
        </trans-unit>
        <trans-unit id="b8db22bc5c87c60fca81d73b716c1fab4571ecab" translate="yes" xml:space="preserve">
          <source>Traditional JavaScript uses functions and prototype-based inheritance to build up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality and objects are built from these classes. Starting with ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers can build their applications using this object-oriented class-based approach. In TypeScript, we allow developers to use these techniques now, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript.</source>
          <target state="translated">従来の JavaScript は関数とプロトタイプベースの継承を使用して再利用可能なコンポーネントを構築していましたが、クラスが機能を継承し、それらのクラスからオブジェクトが構築されるオブジェクト指向のアプローチに慣れているプログラマーにとっては、これは少し気まずいと感じるかもしれません。ECMAScript 2015(ECMAScript 6としても知られている)から、JavaScriptプログラマはこのオブジェクト指向のクラスベースのアプローチを使用してアプリケーションを構築できるようになりました。TypeScriptでは、開発者がこれらの技術を今すぐに使用できるようにし、JavaScriptの次のバージョンを待つことなく、すべての主要なブラウザやプラットフォームで動作するJavaScriptにコンパイルできるようにしています。</target>
        </trans-unit>
        <trans-unit id="53010e4ab65eb0ff069216401ae1c2dcb7276af7" translate="yes" xml:space="preserve">
          <source>Traditional JavaScript uses functions and prototype-based inheritance to build up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality and objects are built from these classes. Starting with ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers will be able to build their applications using this object-oriented class-based approach. In TypeScript, we allow developers to use these techniques now, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript.</source>
          <target state="translated">従来の JavaScript では、関数やプロトタイプベースの継承を使用して再利用可能なコンポーネントを構築していましたが、クラスが機能を継承し、そのクラスからオブジェクトが構築されるオブジェクト指向のアプローチに慣れているプログラマーにとっては、これは少し気まずいと感じるかもしれません。ECMAScript 2015(ECMAScript 6 としても知られている)から、JavaScript プログラマはこのオブジェクト指向のクラスベースのアプローチを使用してアプリケーションを構築できるようになります。TypeScriptでは、開発者がこれらの技術を今すぐに使用し、JavaScriptの次のバージョンを待つことなく、すべての主要なブラウザやプラットフォームで動作するJavaScriptにコンパイルできるようにしています。</target>
        </trans-unit>
        <trans-unit id="1539cd14df7b42b7daf67ab3a0fb1394a708ce8d" translate="yes" xml:space="preserve">
          <source>Trailing comma in function parameter and argument lists are now allowed. This is an implementation for a &lt;a href=&quot;https://jeffmo.github.io/es-trailing-function-commas/&quot;&gt;Stage-3 ECMAScript proposal&lt;/a&gt; that emits down to valid ES3/ES5/ES6.</source>
          <target state="translated">関数パラメーターと引数リストの末尾のコンマが許可されました。これは、有効なES3 / ES5 / ES6まで放出する&lt;a href=&quot;https://jeffmo.github.io/es-trailing-function-commas/&quot;&gt;Stage-3 ECMAScriptプロポーザルの&lt;/a&gt;実装です。</target>
        </trans-unit>
        <trans-unit id="676e9d1917b5b40fea52df91ac4e9afc970551cb" translate="yes" xml:space="preserve">
          <source>Trailing commas in function parameter and argument lists</source>
          <target state="translated">関数のパラメータおよび引数リストの末尾にあるカンマ</target>
        </trans-unit>
        <trans-unit id="346f219fb82d976707a1e387e3becf3823d4827c" translate="yes" xml:space="preserve">
          <source>Translate newer JavaScript constructs down to an older version like ECMAScript 5 (using &lt;code&gt;target&lt;/code&gt;).</source>
          <target state="translated">新しいJavaScriptコンストラクトをECMAScript 5などの古いバージョンに変換します（ &lt;code&gt;target&lt;/code&gt; を使用）。</target>
        </trans-unit>
        <trans-unit id="86523d66f5bea3f709bea059e7608d702a785b4a" translate="yes" xml:space="preserve">
          <source>Triple-Slash Directives</source>
          <target state="translated">トリプルスラッシュディレクティブ</target>
        </trans-unit>
        <trans-unit id="98c8afb6c3de9dfeb15ccf98245b5224564946da" translate="yes" xml:space="preserve">
          <source>Triple-slash directives are &lt;strong&gt;only&lt;/strong&gt; valid at the top of their containing file. A triple-slash directive can only be preceded by single or multi-line comments, including other triple-slash directives. If they are encountered following a statement or a declaration they are treated as regular single-line comments, and hold no special meaning.</source>
          <target state="translated">トリプルスラッシュディレクティブは、それらを含むファイルの先頭で&lt;strong&gt;のみ&lt;/strong&gt;有効です。トリプルスラッシュディレクティブの前には、他のトリプルスラッシュディレクティブを含め、1行または複数行のコメントのみを付けることができます。ステートメントまたは宣言の後に現れる場合は、通常の単一行​​コメントとして扱われ、特別な意味はありません。</target>
        </trans-unit>
        <trans-unit id="694056eae93e31824a823939ec9db90fae068479" translate="yes" xml:space="preserve">
          <source>Triple-slash directives are single-line comments containing a single XML tag. The contents of the comment are used as compiler directives.</source>
          <target state="translated">トリプルスラッシュディレクティブは、1 つの XML タグを含む 1 行コメントです。コメントの内容はコンパイラディレクティブとして使用されます。</target>
        </trans-unit>
        <trans-unit id="3c8912f7f0f56aa84a0690a0f86c344e802e0ceb" translate="yes" xml:space="preserve">
          <source>Triple-slash references instruct the compiler to include additional files in the compilation process.</source>
          <target state="translated">トリプルスラッシュ参照は、コンパイルプロセスに追加ファイルを含めるようにコンパイラに指示します。</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="209d1157417fde29537d214407cbb04f2fb26b89" translate="yes" xml:space="preserve">
          <source>Trying to describe the runtime relationship of JavaScript code can be tricky. When the ES Module-like syntax doesn&amp;rsquo;t provide enough tools to describe the exports then you can use &lt;code&gt;namespaces&lt;/code&gt;.</source>
          <target state="translated">JavaScriptコードの実行時の関係を説明しようとすると、注意が必要になる場合があります。ESモジュールのような構文では、エクスポートを記述するのに十分なツールが提供されない場合は、 &lt;code&gt;namespaces&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="a78911125d5984a872d05a288f51fc96a8c5d183" translate="yes" xml:space="preserve">
          <source>Tuple destructuring</source>
          <target state="translated">タプル破壊</target>
        </trans-unit>
        <trans-unit id="5501f69a4f42fb8e135b4df10c2273778be704fd" translate="yes" xml:space="preserve">
          <source>Tuple types</source>
          <target state="translated">タプル型</target>
        </trans-unit>
        <trans-unit id="f4c8d119fb4e608da43d1f1658b2fb16039d3ae4" translate="yes" xml:space="preserve">
          <source>Tuple types allow you to express an array with a fixed number of elements whose types are known, but need not be the same. For example, you may want to represent a value as a pair of a &lt;code&gt;string&lt;/code&gt; and a &lt;code&gt;number&lt;/code&gt;:</source>
          <target state="translated">タプル型を使用すると、型がわかっているが同じである必要がない要素の数が固定されている配列を表現できます。たとえば、値を &lt;code&gt;string&lt;/code&gt; と &lt;code&gt;number&lt;/code&gt; ペアとして表すことができます。</target>
        </trans-unit>
        <trans-unit id="b40c00912c71e3e2a5296ac9e1c04677483c24ca" translate="yes" xml:space="preserve">
          <source>Tuple types express an array where the type of certain elements is known, but need not be the same. For example, you may want to represent an array with a &lt;code&gt;string&lt;/code&gt; at position 0 and a &lt;code&gt;number&lt;/code&gt; at position 1:</source>
          <target state="translated">タプル型は、特定の要素の型がわかっている配列を表しますが、同じである必要はありません。たとえば、位置0に &lt;code&gt;string&lt;/code&gt; あり、位置1に &lt;code&gt;number&lt;/code&gt; ある配列を表すことができます。</target>
        </trans-unit>
        <trans-unit id="3e80f8a540a40c8de1af1a3e84fbfd7f02d4e041" translate="yes" xml:space="preserve">
          <source>Tuple types now permit a &lt;code&gt;?&lt;/code&gt; postfix on element types to indicate that the element is optional:</source>
          <target state="translated">タプル型で &lt;code&gt;?&lt;/code&gt; 要素がオプションであることを示す要素タイプの後置。</target>
        </trans-unit>
        <trans-unit id="670c49cda0efba0500f15dd982d4fa2aed2d3f11" translate="yes" xml:space="preserve">
          <source>Tuples in rest parameters and spread expressions</source>
          <target state="translated">残りのパラメータとスプレッド式のタプル</target>
        </trans-unit>
        <trans-unit id="20bb571234709f16dbeaea6bc15866de96b8321d" translate="yes" xml:space="preserve">
          <source>Tuples may be destructured like arrays; the destructuring variables get the types of the corresponding tuple elements:</source>
          <target state="translated">タプルは配列のように破壊することができます;破壊変数は対応するタプル要素の型を取得します。</target>
        </trans-unit>
        <trans-unit id="13179f7189ca168af29df9bd58b2fd52c0614eb0" translate="yes" xml:space="preserve">
          <source>Turning &lt;code&gt;suppressImplicitAnyIndexErrors&lt;/code&gt; on suppresses reporting the error about implicit anys when indexing into objects, as shown in the following example:</source>
          <target state="translated">ターニング &lt;code&gt;suppressImplicitAnyIndexErrors&lt;/code&gt; をオブジェクトにインデックスを付ける場合は、次の例に示すように、暗黙のanysに関するエラーを報告抑制する上：</target>
        </trans-unit>
        <trans-unit id="1a6db2244dd129bbdb09e4163ada76293caa34a3" translate="yes" xml:space="preserve">
          <source>Turning on &lt;a href=&quot;#downlevelIteration&quot;&gt;&lt;code&gt;downlevelIteration&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;importHelpers&lt;/code&gt; is still false:</source>
          <target state="translated">オンに&lt;a href=&quot;#downlevelIteration&quot;&gt; &lt;code&gt;downlevelIteration&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;importHelpers&lt;/code&gt; はまだfalseです。</target>
        </trans-unit>
        <trans-unit id="0352b1bc1bd302b11a3202f8ca77b3b6a6074227" translate="yes" xml:space="preserve">
          <source>Turning on &lt;code&gt;esModuleInterop&lt;/code&gt; will fix both of these problems in the code transpiled by TypeScript. The first changes the behavior in the compiler,the second is fixed by two new helper functions which provide a shim to ensure compatibility in the emitted JavaScript:</source>
          <target state="translated">オンに &lt;code&gt;esModuleInterop&lt;/code&gt; は活字体でtranspiledコードでこれらの問題の両方を解決します。1つ目はコンパイラーの動作を変更し、2つ目は発行されたJavaScriptの互換性を確保するためのシムを提供する2つの新しいヘルパー関数によって修正されます。</target>
        </trans-unit>
        <trans-unit id="9f09cc50104b5125d833de6822dd696f449bdb66" translate="yes" xml:space="preserve">
          <source>Turning on &lt;code&gt;noImplicitAny&lt;/code&gt; however TypeScript will issue an error whenever it would have inferred &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">ただし、 &lt;code&gt;noImplicitAny&lt;/code&gt; をオンにすると、TypeScriptは次の &lt;code&gt;any&lt;/code&gt; を推測するたびにエラーを発行します。</target>
        </trans-unit>
        <trans-unit id="5dda13edded0b19f61e1d98b9a246afd41365ec8" translate="yes" xml:space="preserve">
          <source>Turning on &lt;code&gt;noUncheckedIndexedAccess&lt;/code&gt; will add &lt;code&gt;undefined&lt;/code&gt; to any un-declared field in the type.</source>
          <target state="translated">オンに &lt;code&gt;noUncheckedIndexedAccess&lt;/code&gt; して追加されます &lt;code&gt;undefined&lt;/code&gt; 型では任意の非宣言したフィールドに。</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="0bdb148b80769233155853c95838bff4924234bc" translate="yes" xml:space="preserve">
          <source>Type Acquisition - &lt;code&gt;typeAcquisition&lt;/code&gt;</source>
          <target state="translated">タイプ取得 &lt;code&gt;typeAcquisition&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96e00fe98faa413635ba213d31572b56fb6e2bb5" translate="yes" xml:space="preserve">
          <source>Type Alias</source>
          <target state="translated">タイプエイリアス</target>
        </trans-unit>
        <trans-unit id="353ce315d4b89d72fbf39db84d79fda4b261f3b6" translate="yes" xml:space="preserve">
          <source>Type Aliases</source>
          <target state="translated">型別名</target>
        </trans-unit>
        <trans-unit id="a6de4b535fedeaa8890bd890b60fe09f87b5f96a" translate="yes" xml:space="preserve">
          <source>Type Checking</source>
          <target state="translated">タイプチェック</target>
        </trans-unit>
        <trans-unit id="69fccbed8b512e180b2e56eec7bf36107d0fc4af" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files</source>
          <target state="translated">JavaScriptファイルをチェックするタイプ</target>
        </trans-unit>
        <trans-unit id="c9bb3cb2e0b8995f27923c9071e954a24b9a502b" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @enum</source>
          <target state="translated">JavaScriptファイルをチェックするタイプ。固有のファイル名</target>
        </trans-unit>
        <trans-unit id="e1907e29cdd514784f2fa3e5a5c0bdf2cc55da0a" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @this</source>
          <target state="translated">JavaScriptファイルをチェックするタイプ。この</target>
        </trans-unit>
        <trans-unit id="facd96a18391e3f3e7ddd9cef95660e1b7913914" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @type</source>
          <target state="translated">JavaScriptファイルをチェックするタイプ。タイプ</target>
        </trans-unit>
        <trans-unit id="e19333b8380c7528aa2f3c6afed5b2505d7443bf" translate="yes" xml:space="preserve">
          <source>Type Checking and d.ts file generation</source>
          <target state="translated">タイプチェックとd.tsファイルの生成</target>
        </trans-unit>
        <trans-unit id="9e95ef0e2279689ee3c96fd9dc0e3216f9ec17ae" translate="yes" xml:space="preserve">
          <source>Type Compatibility</source>
          <target state="translated">タイプの互換性</target>
        </trans-unit>
        <trans-unit id="e9dc1ea4bae0ebaf470542aca51daa44cdcc9111" translate="yes" xml:space="preserve">
          <source>Type Compatibility: Enums</source>
          <target state="translated">タイプの互換性。列挙型</target>
        </trans-unit>
        <trans-unit id="5ce9a2f030a10c54388849495b66d1858de81a97" translate="yes" xml:space="preserve">
          <source>Type Declarations</source>
          <target state="translated">タイプ宣言</target>
        </trans-unit>
        <trans-unit id="165b26b05bf5c16d49e5cf4d678908fdae6f68f4" translate="yes" xml:space="preserve">
          <source>Type Guards</source>
          <target state="translated">タイプガード</target>
        </trans-unit>
        <trans-unit id="400e9828133bab9e18749f6f036fd264029f1e6c" translate="yes" xml:space="preserve">
          <source>Type Guards and Differentiating Types</source>
          <target state="translated">タイプガードとタイプの違い</target>
        </trans-unit>
        <trans-unit id="79b8bfde654e6b575d1b453221740941f040398d" translate="yes" xml:space="preserve">
          <source>Type Inference</source>
          <target state="translated">型推論</target>
        </trans-unit>
        <trans-unit id="c50d144660c5c67e814a21e78a048bb4d4c2ec30" translate="yes" xml:space="preserve">
          <source>Type Parameters</source>
          <target state="translated">タイプパラメータ</target>
        </trans-unit>
        <trans-unit id="b024dbff803f7c06dae7d9c5ea0e61258a676b0c" translate="yes" xml:space="preserve">
          <source>Type Roots - &lt;code&gt;typeRoots&lt;/code&gt;</source>
          <target state="translated">タイプルーツ &lt;code&gt;typeRoots&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58cf557846d7f65d34e8a92739eef2665164fad4" translate="yes" xml:space="preserve">
          <source>Type aliases</source>
          <target state="translated">タイプエイリアス</target>
        </trans-unit>
        <trans-unit id="0e2e016dff9c3ffe6b4498005a639ca83394f86e" translate="yes" xml:space="preserve">
          <source>Type aliases are exactly the same as their original types; they are simply alternative names.</source>
          <target state="translated">型のエイリアスは元の型と全く同じです。</target>
        </trans-unit>
        <trans-unit id="0a723dcef74bc94a2959e3631f83bac96553dbc6" translate="yes" xml:space="preserve">
          <source>Type aliases are mere aliases, just like &lt;code&gt;type&lt;/code&gt; in Haskell. The compiler will attempt to use the alias name wherever it was used in the source code, but does not always succeed.</source>
          <target state="translated">型エイリアスは、Haskellの &lt;code&gt;type&lt;/code&gt; と同じように、単なるエイリアスです。コンパイラは、ソースコードで使用されているエイリアス名を使用しようとしますが、常に成功するとは限りません。</target>
        </trans-unit>
        <trans-unit id="04332612727d798a56e4c9adf1af2f0e95c39d60" translate="yes" xml:space="preserve">
          <source>Type aliases create a new name for a type. Type aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you&amp;rsquo;d otherwise have to write by hand.</source>
          <target state="translated">タイプエイリアスは、タイプの新しい名前を作成します。型のエイリアスはインターフェイスに似ている場合がありますが、プリミティブ、ユニオン、タプル、および手動で記述する必要があるその他の型に名前を付けることができます。</target>
        </trans-unit>
        <trans-unit id="74b2b8803d08ed1d0626e3ffe8a2182c1309b352" translate="yes" xml:space="preserve">
          <source>Type aliases have always had a limitation in how they could be &amp;ldquo;recursively&amp;rdquo; referenced. The reason is that any use of a type alias needs to be able to substitute itself with whatever it aliases. In some cases, that&amp;rsquo;s not possible, so the compiler rejects certain recursive aliases like the following:</source>
          <target state="translated">タイプエイリアスには、「再帰的に」参照できる方法に常に制限がありました。その理由は、型エイリアスを使用する場合は、それ自体をエイリアスで置き換えることができる必要があるためです。場合によってはそれが不可能なため、コンパイラーは次のような特定の再帰エイリアスを拒否します。</target>
        </trans-unit>
        <trans-unit id="ee5f3de7938afc6193f57957cf627bbf0b440e19" translate="yes" xml:space="preserve">
          <source>Type annotations</source>
          <target state="translated">型のアノテーション</target>
        </trans-unit>
        <trans-unit id="771c581ff30572b5e74a273ca4a6cfa2c2dd00e9" translate="yes" xml:space="preserve">
          <source>Type annotations in TypeScript are lightweight ways to record the intended contract of the function or variable. In this case, we intend the greeter function to be called with a single string parameter. We can try changing the call greeter to pass an array instead:</source>
          <target state="translated">TypeScriptの型アノテーションは、関数や変数の意図する契約を記録するための軽量な方法です。この例では、greeter関数が単一の文字列パラメータで呼び出されることを意図しています。代わりに配列を渡すように greeter の呼び出しを変更してみましょう。</target>
        </trans-unit>
        <trans-unit id="4c0bd0a7f58c36c032f4bebd542b40c8d83ddd62" translate="yes" xml:space="preserve">
          <source>Type assertion/cast syntax in &lt;code&gt;checkJs&lt;/code&gt;/&lt;code&gt;@ts-check&lt;/code&gt; mode</source>
          <target state="translated">&lt;code&gt;checkJs&lt;/code&gt; / &lt;code&gt;@ts-check&lt;/code&gt; モードでのアサーション/キャスト構文の入力</target>
        </trans-unit>
        <trans-unit id="8207094f90fa241c769cf714f68957046cb3e948" translate="yes" xml:space="preserve">
          <source>Type assertions</source>
          <target state="translated">型のアサーション</target>
        </trans-unit>
        <trans-unit id="e17ca89e78f9f5ce2baa8b85a25ab01c83ae36fb" translate="yes" xml:space="preserve">
          <source>Type assertions have two forms.</source>
          <target state="translated">型アサーションには2つの形式があります。</target>
        </trans-unit>
        <trans-unit id="9d46ff18751ffb41bab6a1e95fa3947ce8fb07c0" translate="yes" xml:space="preserve">
          <source>Type assertions have two forms. One is the &amp;ldquo;angle-bracket&amp;rdquo; syntax:</source>
          <target state="translated">型アサーションには2つの形式があります。1つは「山かっこ」構文です。</target>
        </trans-unit>
        <trans-unit id="252726c38b1deeaec7381a04cf0566bc59bbe5ae" translate="yes" xml:space="preserve">
          <source>Type checking of the &lt;code&gt;instanceof&lt;/code&gt; operator is now based on whether the type of the left operand &lt;em&gt;derives from&lt;/em&gt; the type indicated by the right operand (as opposed to a structural subtype check).</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; 演算子の型チェックは、（構造サブタイプチェックではなく）左のオペランドの型が右のオペランドで示される型&lt;em&gt;から派生&lt;/em&gt;するかどうかに基づいています。</target>
        </trans-unit>
        <trans-unit id="3986b509fdf26a1e0d932541d6bf318fa2f131c4" translate="yes" xml:space="preserve">
          <source>Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is in contrast with nominal typing. Consider the following code:</source>
          <target state="translated">TypeScript における型の互換性は、構造的なサブタイプに基づいています。構造的型付けとは、型のメンバのみに基づいて型を関連付ける方法です。これは名目型付けとは対照的です。次のコードを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="d40d6a67837031f0abaec956923830758108f84e" translate="yes" xml:space="preserve">
          <source>Type guards and type assertions</source>
          <target state="translated">タイプガードとタイプアサーション</target>
        </trans-unit>
        <trans-unit id="df0459267a3773c5f28373435d5ec35b5af11cce" translate="yes" xml:space="preserve">
          <source>Type guards for dotted names also work with user defined type guard functions and the &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt; operators and do not depend on the &lt;code&gt;--strictNullChecks&lt;/code&gt; compiler option.</source>
          <target state="translated">ドット表記名のタイプガードは、ユーザー定義のタイプガード関数、 &lt;code&gt;typeof&lt;/code&gt; および &lt;code&gt;instanceof&lt;/code&gt; 演算子でも機能し、 &lt;code&gt;--strictNullChecks&lt;/code&gt; コンパイラオプションに依存しません。</target>
        </trans-unit>
        <trans-unit id="df87981f3212072661057f255c1414c8249e617d" translate="yes" xml:space="preserve">
          <source>Type guards inferred from &lt;code&gt;in&lt;/code&gt; operator</source>
          <target state="translated">推測タイプのガード &lt;code&gt;in&lt;/code&gt; オペレータ</target>
        </trans-unit>
        <trans-unit id="5c04d68c075d1cf49c5039cfaf5a91d9a3af3583" translate="yes" xml:space="preserve">
          <source>Type guards on the common property.</source>
          <target state="translated">共用地にタイプガードを設置。</target>
        </trans-unit>
        <trans-unit id="4a16ed7f934fd06b2eab4f404c014b3aa9ede6e0" translate="yes" xml:space="preserve">
          <source>Type guards previously only supported checking local variables and parameters. Type guards now support checking &amp;ldquo;dotted names&amp;rdquo; consisting of a variable or parameter name followed one or more property accesses.</source>
          <target state="translated">タイプガードは、以前はローカル変数とパラメーターのチェックのみをサポートしていました。タイプガードは、変数またはパラメーター名とそれに続く1つ以上のプロパティアクセスで構成される「ドット表記名」のチェックをサポートするようになりました。</target>
        </trans-unit>
        <trans-unit id="a6fec2d2cb8ea42fc5e8b24e33871a744a3803c5" translate="yes" xml:space="preserve">
          <source>Type in the boxes and confirm that the breakpoint hits in TypeScript code and that inspection works correctly.</source>
          <target state="translated">ボックスに入力して、TypeScriptのコードでブレークポイントがヒットし、検査が正しく動作することを確認します。</target>
        </trans-unit>
        <trans-unit id="04a0aaa0033ce536b51805d3619fe260b178891e" translate="yes" xml:space="preserve">
          <source>Type inference also works in &amp;ldquo;the other direction&amp;rdquo; in some cases in TypeScript. This is known as &amp;ldquo;contextual typing&amp;rdquo;. Contextual typing occurs when the type of an expression is implied by its location. For example:</source>
          <target state="translated">型推論は、TypeScriptの場合によっては「反対方向」にも機能します。これは「コンテキストタイピング」と呼ばれます。コンテキストタイプは、式のタイプがその場所によって暗示されるときに発生します。例えば：</target>
        </trans-unit>
        <trans-unit id="5b50efd50f8efbd22bb877ea81f90fae7f14657c" translate="yes" xml:space="preserve">
          <source>Type inference in conditional types</source>
          <target state="translated">条件付き型の型推論</target>
        </trans-unit>
        <trans-unit id="34f7e0851caaf9f6232cdc334af3947615acc7f1" translate="yes" xml:space="preserve">
          <source>Type parameter inference from contextual types</source>
          <target state="translated">コンテキスト型からの型パラメータ推論</target>
        </trans-unit>
        <trans-unit id="866c38bce26d304928239997fc8fd61be65a48c4" translate="yes" xml:space="preserve">
          <source>Type parameters as constraints</source>
          <target state="translated">制約としての型パラメータ</target>
        </trans-unit>
        <trans-unit id="638d8954b09678865ded4d60dc34a31605942b14" translate="yes" xml:space="preserve">
          <source>Type syntax of a C-descended language.</source>
          <target state="translated">C言語の型降順言語の型構文。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
