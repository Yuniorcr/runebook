<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="redis">
    <body>
      <group id="redis">
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="5a4574a1a3d9728a0a89d6b1668d9c8dc4ec0634" translate="yes" xml:space="preserve">
          <source>Notes on published config epochs</source>
          <target state="translated">公開されている設定エポックに関する注意事項</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="20be3b7a30a9bb9f7caa52a82e339d86765a7b3b" translate="yes" xml:space="preserve">
          <source>Number of commands processed</source>
          <target state="translated">処理されたコマンド数</target>
        </trans-unit>
        <trans-unit id="6567d67fead3b983bf0dd26e46b199bad4736caf" translate="yes" xml:space="preserve">
          <source>Number of connections received</source>
          <target state="translated">受信した接続数</target>
        </trans-unit>
        <trans-unit id="c0e73dd590dc420faea4c4ac9906ba30e0259e37" translate="yes" xml:space="preserve">
          <source>Number of elements returned at every SCAN call</source>
          <target state="translated">SCAN 呼び出しごとに返される要素の数</target>
        </trans-unit>
        <trans-unit id="f4702f3357a94e0b51c79789087a3eb454b1e296" translate="yes" xml:space="preserve">
          <source>Number of expired keys</source>
          <target state="translated">有効期限切れの鍵の数</target>
        </trans-unit>
        <trans-unit id="8e0e833a8bbaf63a540fadb74be8461319161578" translate="yes" xml:space="preserve">
          <source>Number of rejected connections</source>
          <target state="translated">拒否された接続数</target>
        </trans-unit>
        <trans-unit id="828f2a22520c1086f191a7adfcf910b96f4fe93b" translate="yes" xml:space="preserve">
          <source>OBJECT</source>
          <target state="translated">OBJECT</target>
        </trans-unit>
        <trans-unit id="9d8ec388e13faad9823f64e9acce4e1451d4eabf" translate="yes" xml:space="preserve">
          <source>OBJECT  subcommand [arguments [arguments ...]]   Inspect the internals of Redis objects</source>
          <target state="translated">OBJECTサブコマンド [引数 [引数 ....]Redisオブジェクトの内部を検査する</target>
        </trans-unit>
        <trans-unit id="77ba3ba2dc482ece5e336da9db6f45f553748e64" translate="yes" xml:space="preserve">
          <source>Objects can be encoded in different ways:</source>
          <target state="translated">オブジェクトは、さまざまな方法でエンコードすることができます。</target>
        </trans-unit>
        <trans-unit id="179e9e8b9188e3e0f2e120735c4089249f586f43" translate="yes" xml:space="preserve">
          <source>Obtaining the current length of the slow log</source>
          <target state="translated">スローログの現在の長さの取得</target>
        </trans-unit>
        <trans-unit id="5f6babf24c9404230c05a01781cf0ff83f2a099c" translate="yes" xml:space="preserve">
          <source>Of course it is also possible to use any other valid ID. If the specified consumer group already exists, the command returns a &lt;code&gt;-BUSYGROUP&lt;/code&gt; error. Otherwise the operation is performed and OK is returned. There are no hard limits to the number of consumer groups you can associate to a given stream.</source>
          <target state="translated">もちろん、他の有効なIDを使用することもできます。指定したコンシューマグループが既に存在する場合、コマンドは &lt;code&gt;-BUSYGROUP&lt;/code&gt; エラーを返します。それ以外の場合、操作が実行され、OKが返されます。特定のストリームに関連付けることができるコンシューマグループの数に厳しい制限はありません。</target>
        </trans-unit>
        <trans-unit id="fdc97913b5ee5e2b94550a726affb680e5e4737b" translate="yes" xml:space="preserve">
          <source>Of course the &quot;5&quot; above is an example. Each LOLWUT version takes a different set of arguments in order to change the output. The user is encouraged to play with it to discover how the output changes adding more numerical arguments.</source>
          <target state="translated">もちろん上の「5」は一例です。LOLWUTの各バージョンは、出力を変更するために異なる引数のセットを取ります。ユーザーは、より多くの数値引数を追加することで、出力がどのように変化するかを発見するために、これを使って遊ぶことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ff1bb1ff7a105fafca313a10f02e72dc891fbcf4" translate="yes" xml:space="preserve">
          <source>Of course this is not enough as there are expired keys that will never be accessed again. These keys should be expired anyway, so periodically Redis tests a few keys at random among keys with an expire set. All the keys that are already expired are deleted from the keyspace.</source>
          <target state="translated">もちろん、二度とアクセスできないような期限切れの鍵もあるので、これだけでは十分ではない。これらの鍵はいずれにせよ有効期限が切れているはずなので、Redisは定期的に有効期限が設定されている鍵の中からランダムにいくつかの鍵をテストします。すでに有効期限が切れている鍵はすべて鍵空間から削除される。</target>
        </trans-unit>
        <trans-unit id="e1291438828df902dd44c789d43575a9bce5c968" translate="yes" xml:space="preserve">
          <source>On the other hand, defining commands using a special command or via &lt;code&gt;redis.conf&lt;/code&gt; would be a problem for a few reasons:</source>
          <target state="translated">一方、特別なコマンドまたは &lt;code&gt;redis.conf&lt;/code&gt; を使用してコマンドを定義すると、いくつかの理由で問題が発生します。</target>
        </trans-unit>
        <trans-unit id="9bcf11babeeb88215faca3f25a089c7e21ce30f5" translate="yes" xml:space="preserve">
          <source>Once a consumer &lt;em&gt;succesfully&lt;/em&gt; processes a message, it should call &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; so that such message does not get processed again, and as a side effect, the PEL entry about this message is also purged, releasing memory from the Redis server.</source>
          <target state="translated">コンシューマーがメッセージの処理に&lt;em&gt;成功し&lt;/em&gt;たら、&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;を呼び出して、そのようなメッセージが再度処理されないようにする必要があります。また、副作用として、このメッセージに関するPELエントリも消去され、Redisサーバーからメモリが解放されます。</target>
        </trans-unit>
        <trans-unit id="b17fd51767d49ce5f7f1a0550bff325504d720d8" translate="yes" xml:space="preserve">
          <source>Once a consumer &lt;em&gt;successfully&lt;/em&gt; processes a message, it should call &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; so that such message does not get processed again, and as a side effect, the PEL entry about this message is also purged, releasing memory from the Redis server.</source>
          <target state="translated">コンシューマーがメッセージを&lt;em&gt;正常に&lt;/em&gt;処理したら、そのようなメッセージが再度処理されないように&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;を呼び出す必要があります。副作用として、このメッセージに関するPELエントリも削除され、Redisサーバーからメモリが解放されます。</target>
        </trans-unit>
        <trans-unit id="452b455cbf1a2a31d7d4b5005050bf4551fb3def" translate="yes" xml:space="preserve">
          <source>Once a node is turned into the replica of another master node, there is no need to inform the other cluster nodes about the change: heartbeat packets exchanged between nodes will propagate the new configuration automatically.</source>
          <target state="translated">ノードが他のマスターノードのレプリカになった後は、他のクラスタノードに変更を通知する必要はありません。ノード間で交換されたハートビートパケットが自動的に新しい構成を伝搬します。</target>
        </trans-unit>
        <trans-unit id="24b95a3638ec064976a3c5a5f6794040d2c4ed0b" translate="yes" xml:space="preserve">
          <source>Once new data is present on one of the lists, the client returns with the name of the key unblocking it and the popped value.</source>
          <target state="translated">リストのいずれかに新しいデータが存在すると、クライアントはブロックを解除したキーの名前とポップされた値を返します。</target>
        </trans-unit>
        <trans-unit id="dd41998567cd1f4f810cbadee2b74617b57a32fa" translate="yes" xml:space="preserve">
          <source>Once the client enters the subscribed state it is not supposed to issue any other commands, except for additional &lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt; and &lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt; commands.</source>
          <target state="translated">クライアントがサブスクライブ状態になると、追加の&lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;、&lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;、&lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt;、および&lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt;コマンドを除いて、他のコマンドを発行することは想定されていません。</target>
        </trans-unit>
        <trans-unit id="7a78727304122280256c3edfc937460559a439ea" translate="yes" xml:space="preserve">
          <source>Once the client enters the subscribed state it is not supposed to issue any other commands, except for additional &lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;ping&quot;&gt;PING&lt;/a&gt;, &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; and &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; commands.</source>
          <target state="translated">クライアントがサブスクライブ状態に入ると、追加の&lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;、&lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;、&lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt;、&lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt;、&lt;a href=&quot;ping&quot;&gt;PING&lt;/a&gt;、&lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt;、および&lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt;コマンドを除いて、他のコマンドを発行することは想定されていません。</target>
        </trans-unit>
        <trans-unit id="c4b215656d61ce9a1a4991539bbd4f84ece9f512" translate="yes" xml:space="preserve">
          <source>Once we get some replies, the next call will be something like:</source>
          <target state="translated">いくつか返事が来たら、次はこんな感じで電話がかかってきます。</target>
        </trans-unit>
        <trans-unit id="9de09a5350a4d4653c094b67b0dba8689a762e24" translate="yes" xml:space="preserve">
          <source>One client connection per line (separated by LF)</source>
          <target state="translated">1行に1つのクライアント接続(LFで区切られています</target>
        </trans-unit>
        <trans-unit id="81d95091e8731132a88b7f9f02a3169be5e6b187" translate="yes" xml:space="preserve">
          <source>One of the guarantees of consumer groups is that a given consumer can only see the history of messages that were delivered to it, so a message has just a single owner. However there is a special feature called &lt;em&gt;message claiming&lt;/em&gt; that allows other consumers to claim messages in case there is a non recoverable failure of some consumer. In order to implement such semantics, consumer groups require explicit acknowledgement of the messages successfully processed by the consumer, via the &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command. This is needed because the stream will track, for each consumer group, who is processing what message.</source>
          <target state="translated">コンシューマグループの保証の1つは、特定のコンシューマは配信されたメッセージの履歴しか表示できないため、メッセージの所有者は1人だけであることです。ただし、一部のコンシューマで回復不可能な障害が発生した場合に、他のコンシューマが&lt;em&gt;メッセージを要求&lt;/em&gt;できるようにする&lt;em&gt;メッセージ要求&lt;/em&gt;と呼ばれる特別な機能があります。そのようなセマンティクスを実装するために、コンシューマーグループは、&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;コマンドを介して、コンシューマーによって正常に処理されたメッセージの明示的な確認応答を必要とします。これは、ストリームが各メッセージを処理している各コンシューマグループを追跡するために必要です。</target>
        </trans-unit>
        <trans-unit id="19ce1ec3b2311a2d98754806626a6daf14da6b47" translate="yes" xml:space="preserve">
          <source>One of the guarantees of consumer groups is that a given consumer can only see the history of messages that were delivered to it, so a message has just a single owner. However there is a special feature called &lt;em&gt;message claiming&lt;/em&gt; that allows other consumers to claim messages in case there is a non recoverable failure of some consumer. In order to implement such semantics, consumer groups require explicit acknowledgment of the messages successfully processed by the consumer, via the &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command. This is needed because the stream will track, for each consumer group, who is processing what message.</source>
          <target state="translated">コンシューマーグループの保証の1つは、特定のコンシューマーが配信されたメッセージの履歴のみを表示できるため、メッセージの所有者は1人だけであるということです。ただし、&lt;em&gt;メッセージ要求&lt;/em&gt;と呼ばれる特別な機能があり、一部のコンシューマーで回復不能な障害が発生した場合に、他のコンシューマーが&lt;em&gt;メッセージを要求&lt;/em&gt;できるようにします。このようなセマンティクスを実装するために、コンシューマーグループは、&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;コマンドを介して、コンシューマーによって正常に処理されたメッセージの明示的な確認応答を必要とします。これが必要なのは、ストリームが各コンシューマーグループについて、誰がどのメッセージを処理しているかを追跡するためです。</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="daa479a36fbba3ff638d59ae19308e8976bd5ac3" translate="yes" xml:space="preserve">
          <source>Orders of bits</source>
          <target state="translated">ビットの次数</target>
        </trans-unit>
        <trans-unit id="dcfd7c36726b3d9723cbd1a8981b89247967a629" translate="yes" xml:space="preserve">
          <source>Other consumers may inspect the list of pending messages, that are stale for quite some time, using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command. In order to continue processing such messages, they use &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; to acquire the ownership of the message and continue.</source>
          <target state="translated">他のコンシューマは、&lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt;コマンドを使用して、しばらくの間古くなっている保留中のメッセージのリストを検査する場合があります。このようなメッセージの処理を続行するために、&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;を使用してメッセージの所有権を取得し、続行します。</target>
        </trans-unit>
        <trans-unit id="3c2a27c636dc79870e309393531406e960ec4e18" translate="yes" xml:space="preserve">
          <source>Our previous example returns just the sorted IDs. In some cases, it is more useful to get the actual objects instead of their IDs (&lt;code&gt;object_1&lt;/code&gt;, &lt;code&gt;object_2&lt;/code&gt; and &lt;code&gt;object_3&lt;/code&gt;). Retrieving external keys based on the elements in a list, set or sorted set can be done with the following command:</source>
          <target state="translated">前の例では、ソートされたIDのみを返します。場合によっては、ID（ &lt;code&gt;object_1&lt;/code&gt; 、 &lt;code&gt;object_2&lt;/code&gt; 、および &lt;code&gt;object_3&lt;/code&gt; ）ではなく実際のオブジェクトを取得する方が便利です。リスト、セット、またはソート済みセットの要素に基づいて外部キーを取得するには、次のコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="e9c8427bc7498ec3380d38f116037bdd3bcddf6e" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error. If &lt;code&gt;start&lt;/code&gt; is larger than the end of the list, an empty list is returned. If &lt;code&gt;stop&lt;/code&gt; is larger than the actual end of the list, Redis will treat it like the last element of the list.</source>
          <target state="translated">範囲外のインデックスはエラーを生成しません。 &lt;code&gt;start&lt;/code&gt; がリストの最後より大きい場合、空のリストが返されます。 &lt;code&gt;stop&lt;/code&gt; がリストの実際の末尾よりも大きい場合、Redisはストップをリストの最後の要素のように扱います。</target>
        </trans-unit>
        <trans-unit id="c0a3cb19e89ec7bd7c87e53355299d0f62cc91cc" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error. If &lt;code&gt;start&lt;/code&gt; is larger than the largest index in the sorted set, or &lt;code&gt;start &amp;gt;
stop&lt;/code&gt;, an empty list is returned. If &lt;code&gt;stop&lt;/code&gt; is larger than the end of the sorted set Redis will treat it like it is the last element of the sorted set.</source>
          <target state="translated">範囲外のインデックスはエラーを生成しません。 &lt;code&gt;start&lt;/code&gt; がソートされたセットの最大のインデックスより大きい場合、または &lt;code&gt;start &amp;gt; stop&lt;/code&gt; 場合、空のリストが返されます。場合は &lt;code&gt;stop&lt;/code&gt; ソートセットのRedisの端部よりも大きくなって、それはソートセットの最後の要素であるようにそれを扱います。</target>
        </trans-unit>
        <trans-unit id="3dc054b880cd4ad0a83857995e10c362ec4b2504" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error: if &lt;code&gt;start&lt;/code&gt; is larger than the end of the list, or &lt;code&gt;start &amp;gt; end&lt;/code&gt;, the result will be an empty list (which causes &lt;code&gt;key&lt;/code&gt; to be removed). If &lt;code&gt;end&lt;/code&gt; is larger than the end of the list, Redis will treat it like the last element of the list.</source>
          <target state="translated">範囲外のインデックスはエラーを生成しません： &lt;code&gt;start&lt;/code&gt; がリストの最後より大きいか、 &lt;code&gt;start &amp;gt; end&lt;/code&gt; 場合、結果は空のリストになり &lt;code&gt;key&lt;/code&gt; （これによりキーが削除されます）。 &lt;code&gt;end&lt;/code&gt; がリストの最後より大きい場合、Redisはリストの最後の要素のように扱います。</target>
        </trans-unit>
        <trans-unit id="c4e6b6c77c67abd27de260eb5ce674860a95ad42" translate="yes" xml:space="preserve">
          <source>Out-of-range indexes</source>
          <target state="translated">範囲外のインデックス</target>
        </trans-unit>
        <trans-unit id="c03f08a8f205e4568e916e3cfaa50c6a48749706" translate="yes" xml:space="preserve">
          <source>Output format</source>
          <target state="translated">出力形式</target>
        </trans-unit>
        <trans-unit id="275395efd6e79fdbe55cb36a4ebb4892dbdd5c40" translate="yes" xml:space="preserve">
          <source>Output of the command on replicas</source>
          <target state="translated">レプリカに関するコマンドの出力</target>
        </trans-unit>
        <trans-unit id="5ea9a43450142f5e1cfd51ca7b6956f8a9dbb82d" translate="yes" xml:space="preserve">
          <source>Overflow control</source>
          <target state="translated">オーバーフロー制御</target>
        </trans-unit>
        <trans-unit id="36fd64a953472994b938bbb13337305e87d9a9eb" translate="yes" xml:space="preserve">
          <source>Overwrites part of the string stored at &lt;em&gt;key&lt;/em&gt;, starting at the specified offset, for the entire length of &lt;em&gt;value&lt;/em&gt;. If the offset is larger than the current length of the string at &lt;em&gt;key&lt;/em&gt;, the string is padded with zero-bytes to make &lt;em&gt;offset&lt;/em&gt; fit. Non-existing keys are considered as empty strings, so this command will make sure it holds a string large enough to be able to set &lt;em&gt;value&lt;/em&gt; at &lt;em&gt;offset&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;key&lt;/em&gt;に格納されている文字列の一部を、指定されたオフセットから始めて、&lt;em&gt;valueの&lt;/em&gt;長さ全体を上書きし&lt;em&gt;ます&lt;/em&gt;。オフセットが&lt;em&gt;key&lt;/em&gt;の文字列の現在の長さより大きい場合、文字列はゼロバイトで埋められ、&lt;em&gt;オフセットに&lt;/em&gt;適合します。存在しないキーは空の文字列と見なされるため、このコマンドは、&lt;em&gt;オフセットに&lt;/em&gt;&lt;em&gt;値&lt;/em&gt;を設定できる十分な大きさの文字列を保持していることを確認します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34512fba1d256a361565532a3535096429399084" translate="yes" xml:space="preserve">
          <source>PERSIST</source>
          <target state="translated">PERSIST</target>
        </trans-unit>
        <trans-unit id="ae51373f050f6d2b0e0edfdd08e69fc1968bdf20" translate="yes" xml:space="preserve">
          <source>PERSIST  key   Remove the expiration from a key</source>
          <target state="translated">PERSIST キー キーの有効期限を削除する</target>
        </trans-unit>
        <trans-unit id="7fa59fa06dcb2c9dc1b2b2bd46df7f33912c57b3" translate="yes" xml:space="preserve">
          <source>PEXPIRE</source>
          <target state="translated">PEXPIRE</target>
        </trans-unit>
        <trans-unit id="77a946764b4ffdf95c5ae217ca7f9cec5340bdc1" translate="yes" xml:space="preserve">
          <source>PEXPIRE  key milliseconds   Set a key's time to live in milliseconds</source>
          <target state="translated">PEXPIRE key milliseconds キーのライブ時間をミリ秒単位で設定します。</target>
        </trans-unit>
        <trans-unit id="e609e3af460df9737d7d964f8bfec75a3773bde7" translate="yes" xml:space="preserve">
          <source>PEXPIREAT</source>
          <target state="translated">PEXPIREAT</target>
        </trans-unit>
        <trans-unit id="12d0e8f2d7d7718d124f2a5d583dfa8315ee3c0c" translate="yes" xml:space="preserve">
          <source>PEXPIREAT  key milliseconds-timestamp   Set the expiration for a key as a UNIX timestamp specified in milliseconds</source>
          <target state="translated">PEXPIREAT key milliseconds-timestamp 鍵の有効期限をミリ秒単位で指定したUNIXタイムスタンプとして設定します。</target>
        </trans-unit>
        <trans-unit id="fc7a17907dc63d1312607f17460e9eb6e7871f9d" translate="yes" xml:space="preserve">
          <source>PFADD</source>
          <target state="translated">PFADD</target>
        </trans-unit>
        <trans-unit id="e4e9e83ebacf78fb8cf3124d42502528b53d06ca" translate="yes" xml:space="preserve">
          <source>PFADD  key element [element ...]   Adds the specified elements to the specified HyperLogLog.</source>
          <target state="translated">PFADD key element [element ...]指定されたHyperLogに指定された要素を追加します。</target>
        </trans-unit>
        <trans-unit id="274e92a9d4138573a0f107d2e57b9d0b46e7ac01" translate="yes" xml:space="preserve">
          <source>PFCOUNT</source>
          <target state="translated">PFCOUNT</target>
        </trans-unit>
        <trans-unit id="f81913b01d976cbaac4ade6c06f6bf299ee86214" translate="yes" xml:space="preserve">
          <source>PFCOUNT  key [key ...]   Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).</source>
          <target state="translated">PFCOUNT key [key ...]key(s)でHyperLogLogが観測した集合の近似カーディナリティを返します。</target>
        </trans-unit>
        <trans-unit id="62f6ef6fa6924abe295c8c766f2b3e89d6d074fc" translate="yes" xml:space="preserve">
          <source>PFMERGE</source>
          <target state="translated">PFMERGE</target>
        </trans-unit>
        <trans-unit id="2ad005659587e94338ccd67e31dbc3fac2cb1536" translate="yes" xml:space="preserve">
          <source>PFMERGE  destkey sourcekey [sourcekey ...]   Merge N different HyperLogLogs into a single one.</source>
          <target state="translated">PFMERGE destkey sourcekey [sourcekey ...]N個の異なるHyperLogを1つに統合します。</target>
        </trans-unit>
        <trans-unit id="0b1786a083a9087f0db36b08c1ff81a58930fbc2" translate="yes" xml:space="preserve">
          <source>PING</source>
          <target state="translated">PING</target>
        </trans-unit>
        <trans-unit id="45dae0d4784e1c9ea33d8d88f448f7989ea29500" translate="yes" xml:space="preserve">
          <source>PING  [message]   Ping the server</source>
          <target state="translated">PING [メッセージ]サーバーにpingを送信します。</target>
        </trans-unit>
        <trans-unit id="81efb783fc237efd685a1393fa9f947dd8abda5a" translate="yes" xml:space="preserve">
          <source>PSETEX</source>
          <target state="translated">PSETEX</target>
        </trans-unit>
        <trans-unit id="d7c40d1ee18ffeabe6099f89603c950454eb0276" translate="yes" xml:space="preserve">
          <source>PSETEX  key milliseconds value   Set the value and expiration in milliseconds of a key</source>
          <target state="translated">キーの値と有効期限をミリ秒単位で設定します。</target>
        </trans-unit>
        <trans-unit id="9e7e79c8d02bde08c4e705066bd533ffa7218538" translate="yes" xml:space="preserve">
          <source>PSUBSCRIBE</source>
          <target state="translated">PSUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="71ae64e5df443252e78a1d1f929289a8311a1ef4" translate="yes" xml:space="preserve">
          <source>PSUBSCRIBE  pattern [pattern ...]   Listen for messages published to channels matching the given patterns</source>
          <target state="translated">PSUBSCRIBE パターン [pattern ....]与えられたパターンにマッチするチャンネルに公開されたメッセージを聞く</target>
        </trans-unit>
        <trans-unit id="2c633ee880363a76906d0e48643fc6fd3afe6539" translate="yes" xml:space="preserve">
          <source>PSYNC</source>
          <target state="translated">PSYNC</target>
        </trans-unit>
        <trans-unit id="5d448b1760960854b1253a3a2cad23abdcfdac61" translate="yes" xml:space="preserve">
          <source>PSYNC  replicationid offset   Internal command used for replication</source>
          <target state="translated">PSYNC replicationid offset レプリケーションに使用される内部コマンド</target>
        </trans-unit>
        <trans-unit id="7b8bdca458042e425d2902f59f800419aed5c8b1" translate="yes" xml:space="preserve">
          <source>PTTL</source>
          <target state="translated">PTTL</target>
        </trans-unit>
        <trans-unit id="05bf8ee07e7053cfaf8f62c038f0255fadf89afe" translate="yes" xml:space="preserve">
          <source>PTTL  key   Get the time to live for a key in milliseconds</source>
          <target state="translated">PTTL キー キーのライブ時間をミリ秒単位で取得します。</target>
        </trans-unit>
        <trans-unit id="ff0fc30c743813f924dff4b751315af42d5ab08b" translate="yes" xml:space="preserve">
          <source>PUBLISH</source>
          <target state="translated">PUBLISH</target>
        </trans-unit>
        <trans-unit id="46e845a027f7bb36580703fc200d9108559fa747" translate="yes" xml:space="preserve">
          <source>PUBLISH  channel message   Post a message to a channel</source>
          <target state="translated">PUBLISH チャンネルメッセージ チャンネルにメッセージを投稿する</target>
        </trans-unit>
        <trans-unit id="9487f50e961af3141e0c7833372d9b2c28cfa2a4" translate="yes" xml:space="preserve">
          <source>PUBSUB</source>
          <target state="translated">PUBSUB</target>
        </trans-unit>
        <trans-unit id="acad4a3c05b50f5f04a99427d2a3cdbb983fb0b9" translate="yes" xml:space="preserve">
          <source>PUBSUB  subcommand [argument [argument ...]]   Inspect the state of the Pub/Sub subsystem</source>
          <target state="translated">PUBSUBサブコマンド [引数 [引数 ...]PUB/SUBサブシステムの状態を検査する</target>
        </trans-unit>
        <trans-unit id="ca024e3f958c6b7f4c7fa3671697866707cfa352" translate="yes" xml:space="preserve">
          <source>PUBSUB CHANNELS [pattern]</source>
          <target state="translated">サブチャンネル[パターン]</target>
        </trans-unit>
        <trans-unit id="56e20f63e75d465369356d3ab7aa54f42d22cbb4" translate="yes" xml:space="preserve">
          <source>PUNSUBSCRIBE</source>
          <target state="translated">PUNSUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="e54d89cca768ad85f7527ac0169fa1af2910b1cf" translate="yes" xml:space="preserve">
          <source>PUNSUBSCRIBE  [pattern [pattern ...]]   Stop listening for messages posted to channels matching the given patterns</source>
          <target state="translated">PUNSUBSCRIBE [パターン [パターン ...]指定されたパターンにマッチするチャンネルに投稿されたメッセージのリスニングを停止します。</target>
        </trans-unit>
        <trans-unit id="df3251b7546bede28dd0b0e82a26302f58157038" translate="yes" xml:space="preserve">
          <source>Passing keys and arguments as additional &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; arguments is also very useful in this context as the script string remains constant and can be efficiently cached by Redis.</source>
          <target state="translated">キーと引数を追加の&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;引数として渡すことも、スクリプト文字列が一定のままであり、Redisによって効率的にキャッシュできるため、このコンテキストでは非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="19999dd613b36fb0786e599a84893b1e8a156a95" translate="yes" xml:space="preserve">
          <source>Pattern: Circular list</source>
          <target state="translated">パターン。サーキュラーリスト</target>
        </trans-unit>
        <trans-unit id="4d81f3aa2a2c95fc4a2b98f51dce59a3bb00d586" translate="yes" xml:space="preserve">
          <source>Pattern: Counter</source>
          <target state="translated">パターン。カウンター</target>
        </trans-unit>
        <trans-unit id="73ea3bc6eae64663018b769f7c415b912584ee38" translate="yes" xml:space="preserve">
          <source>Pattern: Event notification</source>
          <target state="translated">パターン。イベント通知</target>
        </trans-unit>
        <trans-unit id="9ff13cc43cfbf608a403dd95aced2e1c0f9fa96b" translate="yes" xml:space="preserve">
          <source>Pattern: Navigation session</source>
          <target state="translated">パターン。ナビゲーションセッション</target>
        </trans-unit>
        <trans-unit id="a7fd682d147cfd39262ca78719007b5177407a15" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter</source>
          <target state="translated">パターン。レートリミッター</target>
        </trans-unit>
        <trans-unit id="527a190ff3f82d3d4bdfebea8586b0d301a67e3d" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter 1</source>
          <target state="translated">パターン。レートリミッター1</target>
        </trans-unit>
        <trans-unit id="d037a3f2c416c91b7789e304c06bd5786301383d" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter 2</source>
          <target state="translated">パターン。レートリミッター2</target>
        </trans-unit>
        <trans-unit id="18e48daae4954154a5de8c81ecf51283e080aacd" translate="yes" xml:space="preserve">
          <source>Pattern: Reliable queue</source>
          <target state="translated">パターン。信頼性の高いキュー</target>
        </trans-unit>
        <trans-unit id="bc4ebd36f01622a36d608ba3197fe5c6b53d07d7" translate="yes" xml:space="preserve">
          <source>Pattern: Time series</source>
          <target state="translated">パターン 時系列</target>
        </trans-unit>
        <trans-unit id="aaa32185c003a60c49d4fa1de6cdca30261f99bd" translate="yes" xml:space="preserve">
          <source>Pattern: accessing the entire bitmap</source>
          <target state="translated">パターン:ビットマップ全体にアクセスする</target>
        </trans-unit>
        <trans-unit id="6aa9774204b5b0358a99c12a75b97dace59e135d" translate="yes" xml:space="preserve">
          <source>Pattern: real time metrics using bitmaps</source>
          <target state="translated">パターン:ビットマップを使ったリアルタイムのメトリクス</target>
        </trans-unit>
        <trans-unit id="387aa2d6e23537ab60fac1801379d3a3550c02d6" translate="yes" xml:space="preserve">
          <source>Pattern: real-time metrics using bitmaps</source>
          <target state="translated">パターン:ビットマップを使ったリアルタイムメトリクス</target>
        </trans-unit>
        <trans-unit id="4fd48af62eda73b71f46321f27a6f38fb4751056" translate="yes" xml:space="preserve">
          <source>Pattern: setting multiple bits</source>
          <target state="translated">パターン:複数ビット設定</target>
        </trans-unit>
        <trans-unit id="d8f113cb1df36820baa76cc50b4089ad6af9aea4" translate="yes" xml:space="preserve">
          <source>Pattern: weighted random selection of an element</source>
          <target state="translated">パターン:要素の重み付きランダム選択</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="65bb2cda328eeb96caf6c6dce99ad10ccece742e" translate="yes" xml:space="preserve">
          <source>Pause the clients using &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;を使用してクライアントを一時停止する</target>
        </trans-unit>
        <trans-unit id="172162ae29287e5e829be8811d680119905ff86b" translate="yes" xml:space="preserve">
          <source>Perform a bitwise operation between multiple keys (containing string values) and store the result in the destination key.</source>
          <target state="translated">複数のキー(文字列値を含む)間でビット演算を行い、その結果を宛先キーに格納します。</target>
        </trans-unit>
        <trans-unit id="1627d1d0d50fdeb9a3dce196f5de79d8f43842c0" translate="yes" xml:space="preserve">
          <source>Perform a blocking SAVE if at least one &lt;strong&gt;save point&lt;/strong&gt; is configured.</source>
          <target state="translated">少なくとも1つの&lt;strong&gt;セーブポイント&lt;/strong&gt;が構成されている場合は、ブロッキングSAVEを実行します。</target>
        </trans-unit>
        <trans-unit id="c05e233359dba5b59b70fc0039c9fb4fdb4976d0" translate="yes" xml:space="preserve">
          <source>Perform a partial resynchronization after a disconnection.</source>
          <target state="translated">切断後に部分的な再同期を実行します。</target>
        </trans-unit>
        <trans-unit id="9d05c962f81bccc17939e7dff46bacb302dd37a2" translate="yes" xml:space="preserve">
          <source>Perform the SHA1 of the input string.</source>
          <target state="translated">入力文字列のSHA1を実行します。</target>
        </trans-unit>
        <trans-unit id="0cb883fc85b1fd84aaebb7319c682c586a065641" translate="yes" xml:space="preserve">
          <source>Performance considerations</source>
          <target state="translated">パフォーマンスの考慮事項</target>
        </trans-unit>
        <trans-unit id="c5453c00c8e4c4429dffd7c57ff9e409df17e57a" translate="yes" xml:space="preserve">
          <source>Performances</source>
          <target state="translated">Performances</target>
        </trans-unit>
        <trans-unit id="98a191010a72a819b496571f1515f19fc5db230c" translate="yes" xml:space="preserve">
          <source>Please check the example below and the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; documentation for more information about the command and its options.</source>
          <target state="translated">コマンドとそのオプションの詳細については、以下の例と&lt;a href=&quot;georadius&quot;&gt;GEORADIUSの&lt;/a&gt;ドキュメントを確認してください。</target>
        </trans-unit>
        <trans-unit id="2adb7fe266cd87cc96a429b9dce43b2d62d33470" translate="yes" xml:space="preserve">
          <source>Please for the specific semantics of the command refer to the documentation of &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;.</source>
          <target state="translated">コマンドの具体的なセマンティクスについては、&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="d37ebc2f4f2d1c9e1508f49167dd6105a3aa57b4" translate="yes" xml:space="preserve">
          <source>Please note depending on the version of Redis some of the fields have been added or removed. A robust client application should therefore parse the result of this command by skipping unknown properties, and gracefully handle missing fields.</source>
          <target state="translated">Redisのバージョンによっては、いくつかのフィールドが追加されたり削除されたりしていることに注意してください。したがって、堅牢なクライアントアプリケーションは、未知のプロパティをスキップしてこのコマンドの結果を解析し、欠落しているフィールドを優雅に処理しなければなりません。</target>
        </trans-unit>
        <trans-unit id="cf36c5202e34a4a67ab38d9f9bd7222bda763dfd" translate="yes" xml:space="preserve">
          <source>Please note that before reading this page, if you are new to streams, we recommend to read &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;our introduction to Redis Streams&lt;/a&gt;.</source>
          <target state="translated">このページを読む前に、ストリーム&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;に慣れてい&lt;/a&gt;ない場合は、Redis Streamsの概要を読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="95e0253f33057b2f70a061e11de2d3d4a685d9c7" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; documentation for detailed information about Redis Lua scripting.</source>
          <target state="translated">Redis Luaスクリプトの詳細については、&lt;a href=&quot;eval&quot;&gt;EVALの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="67fc81a1bc0292fa12fdf63856d1ae3a69b0523a" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;persistence documentation&lt;/a&gt; for detailed information.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;永続性のドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="13eff9f035082f1c14cd73067127e19e708dd746" translate="yes" xml:space="preserve">
          <source>Please see the pattern description in the &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt;ドキュメントのパターンの説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="7a135ffdb71c43178f876e40f960bf45f1a29237" translate="yes" xml:space="preserve">
          <source>Please see the pattern description in the &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;ドキュメントのパターンの説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="aed6d393dd61d1ba31957e351636ff901b0e6fa8" translate="yes" xml:space="preserve">
          <source>Posts a message to the given channel.</source>
          <target state="translated">指定されたチャンネルにメッセージを投稿します。</target>
        </trans-unit>
        <trans-unit id="f815dfb4f6f438e54dc2f0a16193e4c96d3c1109" translate="yes" xml:space="preserve">
          <source>Practically speaking, for the client it is much better to simply assume that in the context of a given connection, cached scripts are guaranteed to be there unless an administrator explicitly called the &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; command.</source>
          <target state="translated">実際には、クライアントにとって、特定の接続のコンテキストでは、管理者が明示的に&lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt;コマンドを呼び出さない限り、キャッシュされたスクリプトが存在することが保証されていると単純に想定する方がはるかに優れています。</target>
        </trans-unit>
        <trans-unit id="9d8c495de1a9098dd3bc4b934ccc859d56035029" translate="yes" xml:space="preserve">
          <source>Produces an ASCII-art style graph for the specified event.</source>
          <target state="translated">指定されたイベントのASCIIアートスタイルのグラフを生成します。</target>
        </trans-unit>
        <trans-unit id="4d21fc376a96084ebb73d4e8b35c0a4c4be845e0" translate="yes" xml:space="preserve">
          <source>Provide information on the role of a Redis instance in the context of replication, by returning if the instance is currently a &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;slave&lt;/code&gt;, or &lt;code&gt;sentinel&lt;/code&gt;. The command also returns additional information about the state of the replication (if the role is master or slave) or the list of monitored master names (if the role is sentinel).</source>
          <target state="translated">インスタンスが現在 &lt;code&gt;master&lt;/code&gt; 、 &lt;code&gt;slave&lt;/code&gt; 、または &lt;code&gt;sentinel&lt;/code&gt; であるかどうかを返すことにより、レプリケーションのコンテキストでのRedisインスタンスの役割に関する情報を提供します。このコマンドは、レプリケーションの状態に関する追加情報（役割がマスターまたはスレーブの場合）または監視対象のマスター名のリスト（役割が標識の場合）も返します。</target>
        </trans-unit>
        <trans-unit id="7ca91750d60fd45e80636934b3d1f1da26ffd9f9" translate="yes" xml:space="preserve">
          <source>Pub/Sub</source>
          <target state="translated">Pub/Sub</target>
        </trans-unit>
        <trans-unit id="5860c8458788e44e7636fa364548e067049a0d7b" translate="yes" xml:space="preserve">
          <source>QUIT</source>
          <target state="translated">QUIT</target>
        </trans-unit>
        <trans-unit id="7471799996c7de46c4ffa444365596fb514b6f5a" translate="yes" xml:space="preserve">
          <source>QUIT   Close the connection</source>
          <target state="translated">QUIT 接続を閉じる</target>
        </trans-unit>
        <trans-unit id="baa5d3184c0cc0ce5e007af06198524a4d26548f" translate="yes" xml:space="preserve">
          <source>Quit the server.</source>
          <target state="translated">サーバーを終了します。</target>
        </trans-unit>
        <trans-unit id="94386a96dc3f69665a14e74fb2942d92163c5d74" translate="yes" xml:space="preserve">
          <source>RANDOMKEY</source>
          <target state="translated">RANDOMKEY</target>
        </trans-unit>
        <trans-unit id="338552ba06825ef4f555f3d5ff79d40557c925de" translate="yes" xml:space="preserve">
          <source>RANDOMKEY   Return a random key from the keyspace</source>
          <target state="translated">RANDOMKEY 鍵空間からランダムなキーを返します。</target>
        </trans-unit>
        <trans-unit id="90a97e888676c2d0f3b14c8b4a5ca16d360880bc" translate="yes" xml:space="preserve">
          <source>READONLY</source>
          <target state="translated">READONLY</target>
        </trans-unit>
        <trans-unit id="21d1a8e094bd428debefea84e6dd96322d4c6011" translate="yes" xml:space="preserve">
          <source>READONLY   Enables read queries for a connection to a cluster replica node</source>
          <target state="translated">READONLY クラスタ・レプリカ・ノードへの接続に対する読み取りクエリを有効にします。</target>
        </trans-unit>
        <trans-unit id="5305e8529d963d471cecc6faf967cedff2ea7494" translate="yes" xml:space="preserve">
          <source>READWRITE</source>
          <target state="translated">READWRITE</target>
        </trans-unit>
        <trans-unit id="2ae19352a72e6e879b7c82d353a544f20f6b355b" translate="yes" xml:space="preserve">
          <source>READWRITE   Disables read queries for a connection to a cluster replica node</source>
          <target state="translated">READWRITE クラスタ・レプリカ・ノードへの接続に対する読み取りクエリを無効にします。</target>
        </trans-unit>
        <trans-unit id="4756081595ff9366e8b59c094aebf3df53a8fc98" translate="yes" xml:space="preserve">
          <source>RENAME</source>
          <target state="translated">RENAME</target>
        </trans-unit>
        <trans-unit id="434016433de8ed51fc6a3df25c58d49e8397ca2e" translate="yes" xml:space="preserve">
          <source>RENAME  key newkey   Rename a key</source>
          <target state="translated">RENAME key newkey キーの名前を変更します。</target>
        </trans-unit>
        <trans-unit id="eb9b6064a90c47e23a80adefc9b43f4215668dbe" translate="yes" xml:space="preserve">
          <source>RENAMENX</source>
          <target state="translated">RENAMENX</target>
        </trans-unit>
        <trans-unit id="e1288934ac4d4000f51ff88bf791420487a34758" translate="yes" xml:space="preserve">
          <source>RENAMENX  key newkey   Rename a key, only if the new key does not exist</source>
          <target state="translated">RENAMENX key newkey キーの名前を変更します。</target>
        </trans-unit>
        <trans-unit id="12c92fcd35c554e1970345d0c852363a2bfff485" translate="yes" xml:space="preserve">
          <source>REPLICAOF</source>
          <target state="translated">REPLICAOF</target>
        </trans-unit>
        <trans-unit id="81253c78d1304948f92fc2d7488335ba2280cd3f" translate="yes" xml:space="preserve">
          <source>REPLICAOF  host port   Make the server a replica of another instance, or promote it as master.</source>
          <target state="translated">REPLICAOF ホストポート サーバを別のインスタンスのレプリカにするか、マスタとして昇格させます。</target>
        </trans-unit>
        <trans-unit id="995f2d9ddfbe7ab63a2a7ddd59856b61ae272710" translate="yes" xml:space="preserve">
          <source>RESET</source>
          <target state="translated">RESET</target>
        </trans-unit>
        <trans-unit id="1b3151a71b95e8cdeb31ff88835e69beefec4ac4" translate="yes" xml:space="preserve">
          <source>RESET   Reset the connection</source>
          <target state="translated">RESET 接続をリセットします。</target>
        </trans-unit>
        <trans-unit id="6a8135bcdb582d28d5425eef52faf6ac80eefb26" translate="yes" xml:space="preserve">
          <source>RESTORE</source>
          <target state="translated">RESTORE</target>
        </trans-unit>
        <trans-unit id="693be3f2ba1e3d54a77f2bd81f59053740c9352a" translate="yes" xml:space="preserve">
          <source>RESTORE  key ttl serialized-value [REPLACE]   Create a key using the provided serialized value, previously obtained using DUMP.</source>
          <target state="translated">RESTORE key ttl serialized-value [REPLACE]以前にDUMPを使用して取得した、与えられたシリアライズされた値を使用してキーを作成します。</target>
        </trans-unit>
        <trans-unit id="e604e0070c2d8dbd159ab393d370ee42dc12812f" translate="yes" xml:space="preserve">
          <source>RESTORE  key ttl serialized-value [REPLACE] [ABSTTL] [IDLETIME seconds] [FREQ frequency]   Create a key using the provided serialized value, previously obtained using DUMP.</source>
          <target state="translated">RESTORE key ttl serialized-value [REPLACE][ABSTTL][IDLETIME seconds][FREQ frequency]以前にDUMPを使用して取得した、与えられたシリアライズされた値を使用してキーを作成します。</target>
        </trans-unit>
        <trans-unit id="1631070e7f0b44982ae66b11640654e7ec5dc4bd" translate="yes" xml:space="preserve">
          <source>ROLE</source>
          <target state="translated">ROLE</target>
        </trans-unit>
        <trans-unit id="5b2e8afa66ad35a6843b32ab5ca521321ed80e09" translate="yes" xml:space="preserve">
          <source>ROLE   Return the role of the instance in the context of replication</source>
          <target state="translated">ROLE レプリケーションのコンテキストにおけるインスタンスのロールを返します。</target>
        </trans-unit>
        <trans-unit id="b7ce3009275f8c79b50c7f42dcb85f259fc1334f" translate="yes" xml:space="preserve">
          <source>RPOP</source>
          <target state="translated">RPOP</target>
        </trans-unit>
        <trans-unit id="daae95751cd7b3b0d6286ba595f17b95a4dbf14d" translate="yes" xml:space="preserve">
          <source>RPOP  key   Remove and get the last element in a list</source>
          <target state="translated">RPOPキー リストの最後の要素を削除して取得する</target>
        </trans-unit>
        <trans-unit id="153bcead99c65ede929618b160dd530ec6817223" translate="yes" xml:space="preserve">
          <source>RPOP  key [count]   Remove and get the last elements in a list</source>
          <target state="translated">RPOPキー [count]リストの最後の要素を削除して取得する</target>
        </trans-unit>
        <trans-unit id="5fc91e22c7eda82f26217a9a276a557189795a83" translate="yes" xml:space="preserve">
          <source>RPOPLPUSH</source>
          <target state="translated">RPOPLPUSH</target>
        </trans-unit>
        <trans-unit id="9b4f14c63b639db09e2a8cbabb9aee76bf074fd7" translate="yes" xml:space="preserve">
          <source>RPOPLPUSH  source destination   Remove the last element in a list, prepend it to another list and return it</source>
          <target state="translated">RPOPLPUSH ソース デスティネーション リストの最後の要素を削除し、別のリストに前置して返す</target>
        </trans-unit>
        <trans-unit id="b9d73dc860be3da3eb63b95dc888be66d34c596b" translate="yes" xml:space="preserve">
          <source>RPUSH</source>
          <target state="translated">RPUSH</target>
        </trans-unit>
        <trans-unit id="3c855c64755366500528d84baa161e66c153eb2f" translate="yes" xml:space="preserve">
          <source>RPUSH  key element [element ...]   Append one or multiple elements to a list</source>
          <target state="translated">RPUSH key element [element ....]1つまたは複数の要素をリストに追加する</target>
        </trans-unit>
        <trans-unit id="cc9293df01dd3379605fef72d334681379153757" translate="yes" xml:space="preserve">
          <source>RPUSH  key value [value ...]   Append one or multiple values to a list</source>
          <target state="translated">RPUSH キー値 [value ....]1つまたは複数の値をリストに追加します。</target>
        </trans-unit>
        <trans-unit id="a2fe5b491151e540de6422c6e85592df5f204dc3" translate="yes" xml:space="preserve">
          <source>RPUSHX</source>
          <target state="translated">RPUSHX</target>
        </trans-unit>
        <trans-unit id="9ca949029559acfa6521e4bf6649e713de5742b1" translate="yes" xml:space="preserve">
          <source>RPUSHX  key element [element ...]   Append an element to a list, only if the list exists</source>
          <target state="translated">RPUSHX key element [element ....]リストが存在する場合のみ、リストに要素を追加します。</target>
        </trans-unit>
        <trans-unit id="61d6ff5cbc32d5fc0ed38bfb10b34d14916d1c00" translate="yes" xml:space="preserve">
          <source>RPUSHX  key value   Append a value to a list, only if the list exists</source>
          <target state="translated">RPUSHX キー値 リストが存在する場合にのみ、リストに値を追加します。</target>
        </trans-unit>
        <trans-unit id="a31a9b75b6318e8c48bf5d454b96698ee608da57" translate="yes" xml:space="preserve">
          <source>Range of integer scores that can be expressed precisely</source>
          <target state="translated">正確に表現できる整数スコアの範囲</target>
        </trans-unit>
        <trans-unit id="df8903174eb3eac863f1253076caa8171702cb53" translate="yes" xml:space="preserve">
          <source>Range: 3900-4000</source>
          <target state="translated">範囲。3900-4000</target>
        </trans-unit>
        <trans-unit id="e1d33f7270a253d76d9b6fe1deb9155ecce0ca42" translate="yes" xml:space="preserve">
          <source>Read data from one or multiple streams, only returning entries with an ID greater than the last received ID reported by the caller. This command has an option to block if items are not available, in a similar fashion to &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; or &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; and others.</source>
          <target state="translated">1つまたは複数のストリームからデータを読み取り、呼び出し元から報告された最後に受信したIDより大きいIDを持つエントリのみを返します。このコマンドには、&lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt;や&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt;などと同様に、アイテムが利用できない場合にブロックするオプションがあります。</target>
        </trans-unit>
        <trans-unit id="58ccdcefd173a8269ea376346a634ff6e968e57b" translate="yes" xml:space="preserve">
          <source>Read only variants</source>
          <target state="translated">読み取りバリアントのみ</target>
        </trans-unit>
        <trans-unit id="b8590ac877c85f2030d4921db5e93ead78595a0f" translate="yes" xml:space="preserve">
          <source>Read queries against a Redis Cluster slave node are disabled by default, but you can use the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command to change this behavior on a per- connection basis. The &lt;a href=&quot;readwrite&quot;&gt;READWRITE&lt;/a&gt; command resets the readonly mode flag of a connection back to readwrite.</source>
          <target state="translated">Redisクラスタースレーブノードに対する読み取りクエリはデフォルトで無効になっていますが、&lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt;コマンドを使用して、この動作を接続ごとに変更できます。&lt;a href=&quot;readwrite&quot;&gt;READWRITE&lt;/a&gt;コマンドは、読み書きに接続裏面の読み取り専用モードフラグをリセットします。</target>
        </trans-unit>
        <trans-unit id="9ec77fdefc87d676b3e9acb9a7b04ded405da8e4" translate="yes" xml:space="preserve">
          <source>Reading application code, the complete semantics might not be clear since the application calls commands defined server side.</source>
          <target state="translated">アプリケーションのコードを読むと、サーバ側で定義されたコマンドを呼び出しているため、完全なセマンティクスが不明瞭になることがあります。</target>
        </trans-unit>
        <trans-unit id="116cec955773e978e0eecf1499a10199d4278c99" translate="yes" xml:space="preserve">
          <source>Reading the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redis Streams introduction&lt;/a&gt; is highly suggested in order to understand more about the streams overall behavior and semantics.</source>
          <target state="translated">ストリーム全体の動作とセマンティクスについて理解を深めるために、&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redisストリーム&lt;/a&gt;の概要を読むことを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="88951d0701502f598feecc55f4d3172c32a2db31" translate="yes" xml:space="preserve">
          <source>Reading the slow log</source>
          <target state="translated">遅いログを読む</target>
        </trans-unit>
        <trans-unit id="a87de541283ca3bc3c0a398706ee3346da0564e3" translate="yes" xml:space="preserve">
          <source>Recent versions of Redis Sentinel (Redis 2.8.12 or greater) use CLIENT KILL in order to kill clients when an instance is reconfigured, in order to force clients to perform the handshake with one Sentinel again and update its configuration.</source>
          <target state="translated">Redis Sentinelの最近のバージョン(Redis 2.8.12以上)では、インスタンスが再構成されたときにクライアントを殺すためにCLIENT KILLを使用します。</target>
        </trans-unit>
        <trans-unit id="68c1dff2ef06724a3eb5f0a503f24117784a62d1" translate="yes" xml:space="preserve">
          <source>Reconfigure clients to connect with the new master.</source>
          <target state="translated">新しいマスターに接続するためにクライアントを再設定します。</target>
        </trans-unit>
        <trans-unit id="24071b57a13027c01339027dcccb98218f052a8f" translate="yes" xml:space="preserve">
          <source>Redis</source>
          <target state="translated">Redis</target>
        </trans-unit>
        <trans-unit id="64fb7fd6108bc6be312c9ee1e4ae786b08c32a13" translate="yes" xml:space="preserve">
          <source>Redis 3.2 introduced an optional &lt;code&gt;count&lt;/code&gt; argument that can be passed to &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt; in order to retrieve multiple elements in a single call.</source>
          <target state="translated">Redis 3.2では、1回の呼び出しで複数の要素を取得するために&lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt;に渡すことができるオプションの &lt;code&gt;count&lt;/code&gt; 引数が導入されました。</target>
        </trans-unit>
        <trans-unit id="ff9622e92b582b377cd9d107f3253f8a189b7cf9" translate="yes" xml:space="preserve">
          <source>Redis 6 connections starts in RESP2 mode, so clients implementing RESP2 do not need to change (nor there are short term plans to drop support for RESP2). Clients that want to handshake the RESP3 mode need to call the &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command, using &quot;3&quot; as first argument.</source>
          <target state="translated">Redis 6接続はRESP2モードで開始されるため、RESP2を実装するクライアントを変更する必要はありません（RESP2のサポートを終了する短期計画もありません）。RESP3モードをハンドシェイクするクライアントは、最初の引数として「3」を使用して&lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt;コマンドを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="09da59c00f13190142c29bd0fc09b7580fb99363" translate="yes" xml:space="preserve">
          <source>Redis Cluster live resharding explained</source>
          <target state="translated">Redisクラスタのライブreshardingは説明されています</target>
        </trans-unit>
        <trans-unit id="8be0343488efef207b0826c15486c08f81f5710d" translate="yes" xml:space="preserve">
          <source>Redis HyperLogLogs are represented using a double representation: the &lt;em&gt;sparse&lt;/em&gt; representation suitable for HLLs counting a small number of elements (resulting in a small number of registers set to non-zero value), and a &lt;em&gt;dense&lt;/em&gt; representation suitable for higher cardinalities. Redis automatically switches from the sparse to the dense representation when needed.</source>
          <target state="translated">Redis HyperLogLogsは、2つの表現を使用して表されます。HLLが少数の要素をカウントするのに適した&lt;em&gt;疎な&lt;/em&gt;表現（結果として、少数のレジスタがゼロ以外の値に設定される）と、より高いカーディナリティに適した&lt;em&gt;密な&lt;/em&gt;表現。Redisは必要に応じて、自動的に疎表現から密表現に切り替えます。</target>
        </trans-unit>
        <trans-unit id="2e645ecd73ea1ffa136575150e55a17bbdaf4a35" translate="yes" xml:space="preserve">
          <source>Redis Nil bulk reply and Nil multi bulk reply -&amp;gt; Lua false boolean type</source>
          <target state="translated">Redis Nilバルク応答およびNilマルチバルク応答-&amp;gt; Lua falseブール型</target>
        </trans-unit>
        <trans-unit id="12deb2b7b17fe48280b9acc8ac6e268a2fccdfc8" translate="yes" xml:space="preserve">
          <source>Redis bulk reply -&amp;gt; Lua string</source>
          <target state="translated">Redis一括返信-&amp;gt; Lua文字列</target>
        </trans-unit>
        <trans-unit id="28c992585f8b92e96ef7862e17fbc69b72429ffe" translate="yes" xml:space="preserve">
          <source>Redis commands that may return elements in random order, like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; (because Redis Sets are &lt;em&gt;unordered&lt;/em&gt;) have a different behavior when called from Lua, and undergo a silent lexicographical sorting filter before returning data to Lua scripts. So &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; will always return the Set elements in the same order, while the same command invoked from normal clients may return different results even if the key contains exactly the same elements.</source>
          <target state="translated">&lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt;（Redisセットは&lt;em&gt;順序付けされていない&lt;/em&gt;ため）などのランダムな順序で要素を返す可能性のあるRedisコマンドは、Luaから呼び出されたときに異なる動作をし、Luaスクリプトにデータを返す前にサイレント辞書式ソートフィルターを実行します。したがって、 &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; は常にSet要素を同じ順序で返しますが、通常のクライアントから呼び出された同じコマンドは、キーにまったく同じ要素が含まれている場合でも異なる結果を返すことがあります。</target>
        </trans-unit>
        <trans-unit id="9030a22b56473e440d80783adf7755f42e3cd798" translate="yes" xml:space="preserve">
          <source>Redis commands usually accept one key, two keys, or an unlimited number of keys.</source>
          <target state="translated">Redisコマンドは通常、1つのキー、2つのキー、または無制限の数のキーを受け入れます。</target>
        </trans-unit>
        <trans-unit id="4798309557a5e9b4d97ab42c59e238806f00fa04" translate="yes" xml:space="preserve">
          <source>Redis different selectable databases are a form of namespacing: all the databases are anyway persisted together in the same RDB / AOF file. However different databases can have keys having the same name, and there are commands available like &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;, &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; or &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; that work on specific databases.</source>
          <target state="translated">Redisの異なる選択可能なデータベースは名前空間の形式です。すべてのデータベースは、とにかく同じRDB / AOFファイルに一緒に永続化されます。ただし、異なるデータベースに同じ名前のキーを&lt;a href=&quot;flushdb&quot;&gt;含める&lt;/a&gt;ことができ、特定のデータベースで機能するFLUSHDB、&lt;a href=&quot;swapdb&quot;&gt;SWAPDB、&lt;/a&gt;または&lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;などのコマンドを使用できます。</target>
        </trans-unit>
        <trans-unit id="9e3076b9d3288c97597280422f53f06eb0450c13" translate="yes" xml:space="preserve">
          <source>Redis double reply -&amp;gt; Lua table with a single &lt;code&gt;score&lt;/code&gt; field containing a Lua number representing the double value.</source>
          <target state="translated">Redis二重応答-&amp;gt; double値を表すLua番号を含む単一の &lt;code&gt;score&lt;/code&gt; フィールドを持つLuaテーブル。</target>
        </trans-unit>
        <trans-unit id="a48311c837dbe1e0c3cec8f3114d4df2e8c16385" translate="yes" xml:space="preserve">
          <source>Redis error reply -&amp;gt; Lua table with a single &lt;code&gt;err&lt;/code&gt; field containing the error</source>
          <target state="translated">Redisエラー応答-&amp;gt; エラーを含む単一の &lt;code&gt;err&lt;/code&gt; フィールドを持つLuaテーブル</target>
        </trans-unit>
        <trans-unit id="26c2d6e6bcc8ce21554bdf0baf74815e6f8c13dd" translate="yes" xml:space="preserve">
          <source>Redis false reply -&amp;gt; Lua false boolean value.</source>
          <target state="translated">Redis false reply-&amp;gt; Lua falseboolean値。</target>
        </trans-unit>
        <trans-unit id="562ad79eb5fcdcd97d8a0283855bce99c0023855" translate="yes" xml:space="preserve">
          <source>Redis integer reply -&amp;gt; Lua number</source>
          <target state="translated">Redis整数応答-&amp;gt; Lua番号</target>
        </trans-unit>
        <trans-unit id="53c0959152bcf66e99f3ab4d98ebaba488b539de" translate="yes" xml:space="preserve">
          <source>Redis is UTF-8 aware, assuming you correctly set the &lt;code&gt;!LC_COLLATE&lt;/code&gt; environment variable.</source>
          <target state="translated">RedisはUTF &lt;code&gt;!LC_COLLATE&lt;/code&gt; 対応しており、！LC_COLLATE環境変数が正しく設定されていることを前提としています。</target>
        </trans-unit>
        <trans-unit id="ac11208b3186492fddcf23ffb985bed2f4b921dd" translate="yes" xml:space="preserve">
          <source>Redis is now able to delete keys in the background in a different thread without blocking the server. An &lt;code&gt;ASYNC&lt;/code&gt; option was added to &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; and &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; in order to let the entire dataset or a single database to be freed asynchronously.</source>
          <target state="translated">Redisは、サーバーをブロックすることなく、別のスレッドのバックグラウンドでキーを削除できるようになりました。 &lt;code&gt;ASYNC&lt;/code&gt; のオプションがに追加された&lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt;と&lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;データセット全体または非同期的に解放される単一のデータベースをもらうために。</target>
        </trans-unit>
        <trans-unit id="f26191bd07f5d296d686b49ddf0fea28de008280" translate="yes" xml:space="preserve">
          <source>Redis is often used as a messaging server to implement processing of background jobs or other kinds of messaging tasks. A simple form of queue is often obtained pushing values into a list in the producer side, and waiting for this values in the consumer side using &lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt; (using polling), or &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; if the client is better served by a blocking operation.</source>
          <target state="translated">Redisは、バックグラウンドジョブやその他の種類のメッセージングタスクの処理を実装するメッセージングサーバーとしてよく使用されます。単純な形式のキューは、プロデューサー側のリストに値をプッシュして取得され、コンシューマー側で&lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt;（ポーリングを使用）を使用してこの値を待機するか、クライアントがブロッキング操作でより適切にサービスを提供している場合は&lt;a href=&quot;brpop&quot;&gt;BRPOPを取得&lt;/a&gt;します。</target>
        </trans-unit>
        <trans-unit id="42a27bac8c1f348420272658d3c655887b07c3ba" translate="yes" xml:space="preserve">
          <source>Redis keys are expired in two ways: a passive way, and an active way.</source>
          <target state="translated">Redisの鍵の有効期限は、受動的な方法と能動的な方法の2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="ea38abb16e6fc53c1055d716b8dafffc97128c14" translate="yes" xml:space="preserve">
          <source>Redis logs that a script is running too long.</source>
          <target state="translated">Redisはスクリプトの実行時間が長すぎることをログに記録します。</target>
        </trans-unit>
        <trans-unit id="07c6c60386c8d0b1cb8c0291d6e6212cf17c794b" translate="yes" xml:space="preserve">
          <source>Redis map reply -&amp;gt; Lua table with a single &lt;code&gt;map&lt;/code&gt; field containing a Lua table representing the fields and values of the map.</source>
          <target state="translated">Redisマップ応答-&amp;gt; &lt;code&gt;map&lt;/code&gt; のフィールドと値を表すLuaテーブルを含む単一のマップフィールドを持つLuaテーブル。</target>
        </trans-unit>
        <trans-unit id="5ada15ccb812ae3dfe260cac4cea16ab388a5061" translate="yes" xml:space="preserve">
          <source>Redis multi bulk reply -&amp;gt; Lua table (may have other Redis data types nested)</source>
          <target state="translated">Redisマルチバルク返信-&amp;gt; Luaテーブル（他のRedisデータ型がネストされている場合があります）</target>
        </trans-unit>
        <trans-unit id="6afefff72418c96bb7166299d904551e6e4c186a" translate="yes" xml:space="preserve">
          <source>Redis new RESP3 single null value -&amp;gt; Lua nil.</source>
          <target state="translated">新しいRESP3シングルヌル値-&amp;gt; LuanilをRedisします。</target>
        </trans-unit>
        <trans-unit id="cb910cc16645a1fbd760219098ebcbf7bc9f050c" translate="yes" xml:space="preserve">
          <source>Redis offers a SCRIPT command that can be used in order to control the scripting subsystem. SCRIPT currently accepts three different commands:</source>
          <target state="translated">Redisはスクリプトサブシステムを制御するために使用できるSCRIPTコマンドを提供しています。SCRIPTは現在3つの異なるコマンドを受け付けています。</target>
        </trans-unit>
        <trans-unit id="0ab17f17e02f188a1bdf8cac0d6180f82fee1717" translate="yes" xml:space="preserve">
          <source>Redis return values are converted into Lua data types when Lua calls a Redis command using &lt;code&gt;call()&lt;/code&gt; or &lt;code&gt;pcall()&lt;/code&gt;. Similarly, Lua data types are converted into the Redis protocol when calling a Redis command and when a Lua script returns a value, so that scripts can control what &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; will return to the client.</source>
          <target state="translated">Luaが &lt;code&gt;call()&lt;/code&gt; または &lt;code&gt;pcall()&lt;/code&gt; を使用してRedisコマンドを呼び出すと、Redisの戻り値がLuaデータ型に変換されます。同様に、Luaデータ型は、Redisコマンドを呼び出すとき、およびLuaスクリプトが値を返すときにRedisプロトコルに変換されるので、スクリプトは&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;がクライアントに返す内容を制御できます。</target>
        </trans-unit>
        <trans-unit id="0fa967ae24b949a1700795759c8cdfe062988a8a" translate="yes" xml:space="preserve">
          <source>Redis scripts are not allowed to create global variables, in order to avoid leaking data into the Lua state. If a script needs to maintain state between calls (a pretty uncommon need) it should use Redis keys instead.</source>
          <target state="translated">Redisスクリプトでは、Luaの状態にデータが漏れることを避けるため、グローバル変数を作成することはできません。呼び出しの間に状態を維持する必要がある場合は、代わりにRedisキーを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="62adbd77b4f8fad448a651b5f523abd0f146da57" translate="yes" xml:space="preserve">
          <source>Redis set reply -&amp;gt; Lua table with a single &lt;code&gt;set&lt;/code&gt; field containing a Lua table representing the elements of the set as fields, having as value just &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Redisセット応答-&amp;gt; &lt;code&gt;set&lt;/code&gt; の要素をフィールドとして表すLuaテーブルを含む単一のセットフィールドを持つLuaテーブル。値は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e62135b0922f82850c893085d4cd08cc6fd7ccb4" translate="yes" xml:space="preserve">
          <source>Redis slow log overview</source>
          <target state="translated">Redisの遅いログの概要</target>
        </trans-unit>
        <trans-unit id="add967db3e0dd55b3522bf60d87afa3192a4838a" translate="yes" xml:space="preserve">
          <source>Redis sorted sets use a &lt;em&gt;double 64-bit floating point number&lt;/em&gt; to represent the score. In all the architectures we support, this is represented as an &lt;strong&gt;IEEE 754 floating point number&lt;/strong&gt;, that is able to represent precisely integer numbers between &lt;code&gt;-(2^53)&lt;/code&gt; and &lt;code&gt;+(2^53)&lt;/code&gt; included. In more practical terms, all the integers between -9007199254740992 and 9007199254740992 are perfectly representable. Larger integers, or fractions, are internally represented in exponential form, so it is possible that you get only an approximation of the decimal number, or of the very big integer, that you set as score.</source>
          <target state="translated">Redisソートセットは、スコアを表すために&lt;em&gt;64ビットの浮動小数点数&lt;/em&gt;を使用します。私たちがサポートするすべてのアーキテクチャでは、これは&lt;strong&gt;IEEE 754浮動小数点数&lt;/strong&gt;として表され、含まれる &lt;code&gt;-(2^53)&lt;/code&gt; から &lt;code&gt;+(2^53)&lt;/code&gt; までの整数を正確に表すことができます。より実際的には、-9007199254740992から9007199254740992までの整数はすべて完全に表現可能です。大きい整数、または分数は内部的に指数形式で表されるため、スコアとして設定した10進数または非常に大きな整数の概算のみが得られる可能性があります。</target>
        </trans-unit>
        <trans-unit id="738a4a620b4c28b97c15ca1b2edd5526cb23af29" translate="yes" xml:space="preserve">
          <source>Redis status reply -&amp;gt; Lua table with a single &lt;code&gt;ok&lt;/code&gt; field containing the status</source>
          <target state="translated">Redisステータス応答-&amp;gt; ステータスを含む単一の &lt;code&gt;ok&lt;/code&gt; フィールドを持つLuaテーブル</target>
        </trans-unit>
        <trans-unit id="db935d0902ab47146d7cddc707ae23f8dbd30e13" translate="yes" xml:space="preserve">
          <source>Redis stores integers in their integer representation, so for string values that actually hold an integer, there is no overhead for storing the string representation of the integer.</source>
          <target state="translated">Redis は整数を整数表現で保存するので、実際に整数を保持する文字列値の場合、整数の文字列表現を保存するためのオーバーヘッドはありません。</target>
        </trans-unit>
        <trans-unit id="b6955638f080137455ca2315a3e774bacb29e670" translate="yes" xml:space="preserve">
          <source>Redis streams are represented in a way that makes them memory efficient: a radix tree is used in order to index macro-nodes that pack linearly tens of stream entries. Normally what happens when you delete an entry from a stream is that the entry is not &lt;em&gt;really&lt;/em&gt; evicted, it just gets marked as deleted.</source>
          <target state="translated">Redisストリームは、メモリを効率的にする方法で表現されます。基数ツリーは、数十のストリームエントリを線形にパックするマクロノードにインデックスを付けるために使用されます。通常、ストリームからエントリを削除すると、エントリは&lt;em&gt;実際に&lt;/em&gt;は削除されず、削除済みとしてマークされます。</target>
        </trans-unit>
        <trans-unit id="5d32a14fd1723b346b2a3b7e8ab15af43e61bb43" translate="yes" xml:space="preserve">
          <source>Redis true reply -&amp;gt; Lua true boolean value.</source>
          <target state="translated">Redisの真の応答-&amp;gt; Luaの真のブール値。</target>
        </trans-unit>
        <trans-unit id="fa7af6984c788798f4aee1b72f3fb15136c972f4" translate="yes" xml:space="preserve">
          <source>Redis uses the same Lua interpreter to run all the commands. Also Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed. This semantic is similar to the one of &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;. From the point of view of all the other clients the effects of a script are either still not visible or already completed.</source>
          <target state="translated">Redisは同じLuaインタープリターを使用してすべてのコマンドを実行します。また、Redisは、スクリプトがアトミックな方法で実行されることを保証します。スクリプトの実行中は、他のスクリプトやRedisコマンドは実行されません。このセマンティクスは、&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXECの&lt;/a&gt;セマンティクスに似ています。他のすべてのクライアントの観点から見ると、スクリプトの効果はまだ表示されていないか、すでに完了しています。</target>
        </trans-unit>
        <trans-unit id="358fd429e373e6f088abb4b934d2faf8511ecbc9" translate="yes" xml:space="preserve">
          <source>Redis versions prior of Redis 6 were only able to understand the one argument version of the command:</source>
          <target state="translated">Redis 6以前のRedisバージョンでは、1引数バージョンのコマンドしか理解できませんでした。</target>
        </trans-unit>
        <trans-unit id="315e6feef25876fa664b37d723e94c657b1c8f6a" translate="yes" xml:space="preserve">
          <source>Redis will block the script with an error if a script calls a Redis command able to alter the data set &lt;strong&gt;after&lt;/strong&gt; a Redis &lt;em&gt;random&lt;/em&gt; command like &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;, &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;, &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt;. This means that if a script is read-only and does not modify the data set it is free to call those commands. Note that a &lt;em&gt;random command&lt;/em&gt; does not necessarily mean a command that uses random numbers: any non-deterministic command is considered a random command (the best example in this regard is the &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; command).</source>
          <target state="translated">スクリプトが&lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;、&lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;、&lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt;などのRedis &lt;em&gt;ランダム&lt;/em&gt;コマンドの&lt;strong&gt;後で&lt;/strong&gt;データセットを変更できるRedisコマンドを呼び出すと、Redisはエラーでスクリプトをブロックします。つまり、スクリプトが読み取り専用でデータセットを変更しない場合は、それらのコマンドを自由に呼び出すことができます。&lt;em&gt;ランダムコマンド&lt;/em&gt;は必ずしも乱数を使用するコマンドを意味するわけではないことに注意してください。非決定的コマンドはランダムコマンドと見なされます（この点での最良の例は&lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt;コマンドです）。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d65bbb9c212a9d98ffb329def918b64ef3d8889" translate="yes" xml:space="preserve">
          <source>Refreshing expires</source>
          <target state="translated">リフレッシングの有効期限</target>
        </trans-unit>
        <trans-unit id="26ca731c99535195e55e64ad25c62f00fdbd2a4c" translate="yes" xml:space="preserve">
          <source>Reliable queues</source>
          <target state="translated">信頼性の高いテール</target>
        </trans-unit>
        <trans-unit id="ea59d67e277c60b336a409408ff4d775b8225584" translate="yes" xml:space="preserve">
          <source>Remove a specific consumer from a consumer group.</source>
          <target state="translated">特定の消費者を消費者グループから削除します。</target>
        </trans-unit>
        <trans-unit id="ce4d2a865a5a06124187f3a0d8a5354cd701d61f" translate="yes" xml:space="preserve">
          <source>Remove the existing timeout on &lt;code&gt;key&lt;/code&gt;, turning the key from &lt;em&gt;volatile&lt;/em&gt; (a key with an expire set) to &lt;em&gt;persistent&lt;/em&gt; (a key that will never expire as no timeout is associated).</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; の既存のタイムアウトを削除し、キーを&lt;em&gt;揮発性&lt;/em&gt;（有効期限が設定されたキー）から&lt;em&gt;永続的&lt;/em&gt;（タイムアウトが関連付けられていないため期限切れにならないキー）に変更します。</target>
        </trans-unit>
        <trans-unit id="c1d260f4e3da83fa28a692c23e66ed0cb15dd796" translate="yes" xml:space="preserve">
          <source>Remove the specified members from the set stored at &lt;code&gt;key&lt;/code&gt;. Specified members that are not a member of this set are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, it is treated as an empty set and this command returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているセットから指定されたメンバーを削除します。このセットのメンバーではない指定されたメンバーは無視されます。場合は &lt;code&gt;key&lt;/code&gt; 存在しない、それが空集合として扱われ、このコマンドが返す &lt;code&gt;0&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="de0b8cb5dfcd4da1251a55ebacec477902ab7fa1" translate="yes" xml:space="preserve">
          <source>Removes all elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (inclusive).</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; &lt;code&gt;max&lt;/code&gt; から最大値（両端を含む）までのスコアを持つ &lt;code&gt;key&lt;/code&gt; 格納されているソート済みセットのすべての要素を削除します。</target>
        </trans-unit>
        <trans-unit id="cbb3fc019bde7aa5a4f4696386c7635ab2172c17" translate="yes" xml:space="preserve">
          <source>Removes all elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt; with rank between &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. Both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are &lt;code&gt;0&lt;/code&gt; -based indexes with &lt;code&gt;0&lt;/code&gt; being the element with the lowest score. These indexes can be negative numbers, where they indicate offsets starting at the element with the highest score. For example: &lt;code&gt;-1&lt;/code&gt; is the element with the highest score, &lt;code&gt;-2&lt;/code&gt; the element with the second highest score and so forth.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; の間のランクで &lt;code&gt;key&lt;/code&gt; に格納されているソート済みセットのすべての要素を削除します。 &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; はどちらも &lt;code&gt;0&lt;/code&gt; ベースのインデックスで、 &lt;code&gt;0&lt;/code&gt; が最低のスコアの要素です。これらのインデックスは負の数にすることができ、スコアが最も高い要素から始まるオフセットを示します。たとえば、 &lt;code&gt;-1&lt;/code&gt; は最も高いスコアの要素、 &lt;code&gt;-2&lt;/code&gt; は2番目に高いスコアの要素などです。</target>
        </trans-unit>
        <trans-unit id="da37c36034834387a9dd7fbda191a975ebb105b0" translate="yes" xml:space="preserve">
          <source>Removes and returns one or more random elements from the set value store at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; の設定値ストアから1つ以上のランダム要素を削除して返します。</target>
        </trans-unit>
        <trans-unit id="cbdedbfa9e258d96431019af8d58bcfa65137941" translate="yes" xml:space="preserve">
          <source>Removes and returns one or more random members from the set value store at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 設定値ストアから1つ以上のランダムメンバーを削除して返します。</target>
        </trans-unit>
        <trans-unit id="870ac46dca2c1a6689064e1cced801af5e158f69" translate="yes" xml:space="preserve">
          <source>Removes and returns the first element of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストの最初の要素を削除して返します。</target>
        </trans-unit>
        <trans-unit id="abb0c00334891c9a62b73bcc7669016da3f5a06d" translate="yes" xml:space="preserve">
          <source>Removes and returns the first elements of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストの最初の要素を削除して返します。</target>
        </trans-unit>
        <trans-unit id="ec2ce52901cbc45793a1c6bb41b722b9057d2bc4" translate="yes" xml:space="preserve">
          <source>Removes and returns the last element of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストの最後の要素を削除して返します。</target>
        </trans-unit>
        <trans-unit id="068c1fcc92f924f323a2866cd513ee38912fea94" translate="yes" xml:space="preserve">
          <source>Removes and returns the last elements of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストの最後の要素を削除して返します。</target>
        </trans-unit>
        <trans-unit id="52acb45013cdb2a41dc580913c01c50bd6ebca86" translate="yes" xml:space="preserve">
          <source>Removes and returns up to &lt;code&gt;count&lt;/code&gt; members with the highest scores in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているソートされたセットの中で最高のスコアを持つ最大 &lt;code&gt;count&lt;/code&gt; メンバーを削除して返します。</target>
        </trans-unit>
        <trans-unit id="ac48e8c652eae033a19d95a11cb8d9dbd5e35dab" translate="yes" xml:space="preserve">
          <source>Removes and returns up to &lt;code&gt;count&lt;/code&gt; members with the lowest scores in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているソートされたセットでスコアが最も低いメンバーを最大で &lt;code&gt;count&lt;/code&gt; 個削除して返します。</target>
        </trans-unit>
        <trans-unit id="f36f141768a197b4276a61d3b54c8f396195cafb" translate="yes" xml:space="preserve">
          <source>Removes the first &lt;code&gt;count&lt;/code&gt; occurrences of elements equal to &lt;code&gt;element&lt;/code&gt; from the list stored at &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;count&lt;/code&gt; argument influences the operation in the following ways:</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストから、 &lt;code&gt;element&lt;/code&gt; に等しい要素の最初の &lt;code&gt;count&lt;/code&gt; オカレンスを削除します。 &lt;code&gt;count&lt;/code&gt; 引数は、次の方法での動作に影響を与えます：</target>
        </trans-unit>
        <trans-unit id="7c6ffaff6ffe08c9f43baab9718f030d2162d111" translate="yes" xml:space="preserve">
          <source>Removes the first &lt;code&gt;count&lt;/code&gt; occurrences of elements equal to &lt;code&gt;value&lt;/code&gt; from the list stored at &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;count&lt;/code&gt; argument influences the operation in the following ways:</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストから、 &lt;code&gt;value&lt;/code&gt; に等しい要素の最初の &lt;code&gt;count&lt;/code&gt; 個の出現を削除します。 &lt;code&gt;count&lt;/code&gt; 引数は、次の方法での動作に影響を与えます：</target>
        </trans-unit>
        <trans-unit id="494ca7e2faa6bd5b36a369eb7746bb78fb3e96bc" translate="yes" xml:space="preserve">
          <source>Removes the specified entries from a stream, and returns the number of entries deleted, that may be different from the number of IDs passed to the command in case certain IDs do not exist.</source>
          <target state="translated">ストリームから指定されたエントリを削除し、削除したエントリの数を返します。</target>
        </trans-unit>
        <trans-unit id="594397839f7156989bc1b259c19072c5484f7bdc" translate="yes" xml:space="preserve">
          <source>Removes the specified fields from the hash stored at &lt;code&gt;key&lt;/code&gt;. Specified fields that do not exist within this hash are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, it is treated as an empty hash and this command returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているハッシュから指定されたフィールドを削除します。このハッシュ内に存在しない指定されたフィールドは無視されます。場合は &lt;code&gt;key&lt;/code&gt; 存在しない、それが空のハッシュとして扱われ、このコマンドが返す &lt;code&gt;0&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="322e3109be94b3ac9ea4c2a44f232f96c6cd905a" translate="yes" xml:space="preserve">
          <source>Removes the specified keys. A key is ignored if it does not exist.</source>
          <target state="translated">指定されたキーを削除します。キーが存在しない場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="933e4f3eff042f249c190608a122f8e43bd494af" translate="yes" xml:space="preserve">
          <source>Removes the specified members from the sorted set stored at &lt;code&gt;key&lt;/code&gt;. Non existing members are ignored.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているソート済みセットから指定されたメンバーを削除します。存在しないメンバーは無視されます。</target>
        </trans-unit>
        <trans-unit id="17baa9fe7f8ed0143fa7df75975e104465db4e59" translate="yes" xml:space="preserve">
          <source>Renames &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;newkey&lt;/code&gt; if &lt;code&gt;newkey&lt;/code&gt; does not yet exist. It returns an error when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">名前を変更し &lt;code&gt;key&lt;/code&gt; に &lt;code&gt;newkey&lt;/code&gt; 場合 &lt;code&gt;newkey&lt;/code&gt; まだ存在していません。 &lt;code&gt;key&lt;/code&gt; が存在しない場合はエラーを返します。</target>
        </trans-unit>
        <trans-unit id="0155259665636f6ceaaa0a0ebda67bb195d98a6d" translate="yes" xml:space="preserve">
          <source>Renames &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;newkey&lt;/code&gt;. It returns an error when &lt;code&gt;key&lt;/code&gt; does not exist. If &lt;code&gt;newkey&lt;/code&gt; already exists it is overwritten, when this happens &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; executes an implicit &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; operation, so if the deleted key contains a very big value it may cause high latency even if &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; itself is usually a constant-time operation.</source>
          <target state="translated">名前を変更し &lt;code&gt;key&lt;/code&gt; に &lt;code&gt;newkey&lt;/code&gt; 。 &lt;code&gt;key&lt;/code&gt; が存在しない場合はエラーを返します。 &lt;code&gt;newkey&lt;/code&gt; がすでに存在する場合、上書きされます。この場合、&lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;は暗黙の&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;操作を実行するため、削除されたキーに非常に大きな値が含まれている場合、&lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;自体が通常は一定時間の操作であっても、レイテンシが長くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="351fb2e9d60cd91bf6510354de71fa6c06419ab4" translate="yes" xml:space="preserve">
          <source>Replicas broadcast their master's config epochs (in order to get an &lt;code&gt;UPDATE&lt;/code&gt; message if they are found to be stale), so the real config epoch of the replica (which is meaningless more or less, since they don't serve hash slots) can be only obtained checking the node flagged as &lt;code&gt;myself&lt;/code&gt;, which is the entry of the node we are asking to generate &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output. The other replicas epochs reflect what they publish in heartbeat packets, which is, the configuration epoch of the masters they are currently replicating.</source>
          <target state="translated">レプリカはマスターの構成エポックをブロードキャストし（古くなっていることが判明した場合に &lt;code&gt;UPDATE&lt;/code&gt; メッセージを取得するため）、レプリカの実際の構成エポック（ハッシュスロットを提供しないため、多かれ少なかれ意味がない）にすることができます。&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;出力を生成するように要求しているノードのエントリである &lt;code&gt;myself&lt;/code&gt; のフラグが付けられたノードのチェックのみを取得しました。他のレプリカエポックは、ハートビートパケットで公開するもの、つまり現在複製しているマスターの構成エポックを反映しています。</target>
        </trans-unit>
        <trans-unit id="57ee014fca43ed90896705e17d43f35b06757596" translate="yes" xml:space="preserve">
          <source>Replicating commands instead of scripts</source>
          <target state="translated">スクリプトの代わりにコマンドを複製する</target>
        </trans-unit>
        <trans-unit id="054fb8240ac6c1ab20550a9e5b79d9d4cd6d1345" translate="yes" xml:space="preserve">
          <source>Request for authentication in a password-protected Redis server. Redis can be instructed to require a password before allowing clients to execute commands. This is done using the &lt;code&gt;requirepass&lt;/code&gt; directive in the configuration file.</source>
          <target state="translated">パスワードで保護されたRedisサーバーでの認証の要求。Redisは、クライアントにコマンドの実行を許可する前にパスワードを要求するように指示できます。これは、構成ファイルの &lt;code&gt;requirepass&lt;/code&gt; ディレクティブを使用して行われます。</target>
        </trans-unit>
        <trans-unit id="da1bb4a2fc17746f7a5baea5144086fae0563a1a" translate="yes" xml:space="preserve">
          <source>Reset a Redis Cluster node, in a more or less drastic way depending on the reset type, that can be &lt;strong&gt;hard&lt;/strong&gt; or &lt;strong&gt;soft&lt;/strong&gt;. Note that this command &lt;strong&gt;does not work for masters if they hold one or more keys&lt;/strong&gt;, in that case to completely reset a master node keys must be removed first, e.g. by using &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; first, and then &lt;a href=&quot;cluster-reset&quot;&gt;CLUSTER RESET&lt;/a&gt;.</source>
          <target state="translated">Redisクラスターノードをリセットします。リセットタイプに応じて、&lt;strong&gt;ハード&lt;/strong&gt;または&lt;strong&gt;ソフトの&lt;/strong&gt;いずれかで、大幅に異なります。&lt;strong&gt;マスターが1つ以上のキーを保持&lt;/strong&gt;している場合、このコマンド&lt;strong&gt;はマスターに対しては機能しない&lt;/strong&gt;ことに注意してください。その場合、マスターノードのキーを完全にリセットするには、最初に&lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt;を使用し、次に&lt;a href=&quot;cluster-reset&quot;&gt;CLUSTER RESET&lt;/a&gt;などを使用して削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="5b45f167ccc9268d6db2b2030f5f33cd642304b9" translate="yes" xml:space="preserve">
          <source>Resets the statistics reported by Redis using the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;コマンドを使用してRedisによって報告された統計をリセットします。</target>
        </trans-unit>
        <trans-unit id="8b4926f937540a054f457674fa7da321fbd6a1f7" translate="yes" xml:space="preserve">
          <source>Resetting the slow log.</source>
          <target state="translated">遅いログをリセットします。</target>
        </trans-unit>
        <trans-unit id="401feffc58d082a7dc99bf3cdbc90af756748e94" translate="yes" xml:space="preserve">
          <source>Reshard all the hash slots from D to nodes A, B, C.</source>
          <target state="translated">DからノードA,B,Cへのすべてのハッシュスロットを再構築します。</target>
        </trans-unit>
        <trans-unit id="d71f5749e9e28d5922b96f1c26e811052165fc71" translate="yes" xml:space="preserve">
          <source>Retrieving external keys</source>
          <target state="translated">外部キーの取得</target>
        </trans-unit>
        <trans-unit id="6fc93fde5d23bf392c79a9f984537ca96d065420" translate="yes" xml:space="preserve">
          <source>Return a random key from the currently selected database.</source>
          <target state="translated">現在選択されているデータベースからランダムキーを返します。</target>
        </trans-unit>
        <trans-unit id="6fd47a35bf916d5d67439ea375fe4e2fb769d84c" translate="yes" xml:space="preserve">
          <source>Return the UNIX TIME of the last DB save executed with success. A client may check if a &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; command succeeded reading the &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; value, then issuing a &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; command and checking at regular intervals every N seconds if &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; changed.</source>
          <target state="translated">正常に実行された最後のDB保存のUNIX TIMEを返します。場合、クライアントは確認することが&lt;a href=&quot;bgsave&quot;&gt;BGSAVEの&lt;/a&gt;コマンドが読んで成功した&lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt;、その後、値を発行&lt;a href=&quot;bgsave&quot;&gt;BGSAVEの&lt;/a&gt;コマンドをしている場合、一定の間隔N秒ごとにチェック&lt;a href=&quot;lastsave&quot;&gt;LASTSAVEを&lt;/a&gt;変更しました。</target>
        </trans-unit>
        <trans-unit id="7298f92c54146228ead6d1a31b40025056a03b02" translate="yes" xml:space="preserve">
          <source>Return the distance between two members in the geospatial index represented by the sorted set.</source>
          <target state="translated">ソートされた集合で表される地理空間インデックス内の2つのメンバー間の距離を返します。</target>
        </trans-unit>
        <trans-unit id="da507356e98e4d51d3b0a5e69a99468bdb6da16d" translate="yes" xml:space="preserve">
          <source>Return the members of a sorted set populated with geospatial information using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;, which are within the borders of the area specified by a given shape. This command extends the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; command, so in addition to searching within circular areas, it supports searching within rectangular areas.</source>
          <target state="translated">&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;を使用して地理空間情報が入力された並べ替えられたセットのメンバーを返します。これらは、指定された形状で指定された領域の境界内にあります。このコマンドは&lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt;コマンドを拡張するため、円形領域内の検索に加えて、長方形領域内の検索もサポートします。</target>
        </trans-unit>
        <trans-unit id="1bb126873153beb4e986e8428f3f0a902f06d1bc" translate="yes" xml:space="preserve">
          <source>Return the members of a sorted set populated with geospatial information using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;, which are within the borders of the area specified with the center location and the maximum distance from the center (the radius).</source>
          <target state="translated">中心位置と中心からの最大距離（半径）で指定された領域の境界内にある、&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;を使用して地理空間情報が入力されたソート済みセットのメンバーを返します。</target>
        </trans-unit>
        <trans-unit id="a7ff116fa994743f4fb0646cce53a6396e097c89" translate="yes" xml:space="preserve">
          <source>Return the number of keys in the currently-selected database.</source>
          <target state="translated">現在選択されているデータベースのキーの数を返します。</target>
        </trans-unit>
        <trans-unit id="06398ca22b9ef82a3c94cf8b1160f8f9c766b74a" translate="yes" xml:space="preserve">
          <source>Return the position of the first bit set to 1 or 0 in a string.</source>
          <target state="translated">文字列の最初のビットが 1 または 0 に設定されている位置を返します。</target>
        </trans-unit>
        <trans-unit id="1d1482b5db471b056549fa1a5580198ec9701587" translate="yes" xml:space="preserve">
          <source>Return the positions (longitude,latitude) of all the specified members of the geospatial index represented by the sorted set at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;keyで&lt;/em&gt;ソートされたセットによって表される地理空間インデックスの指定されたすべてのメンバーの位置（経度、緯度）を返し&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="38c82e40bf5034793c00ae747edeb8cd30dfe3ef" translate="yes" xml:space="preserve">
          <source>Return the username the current connection is authenticated with. New connections are authenticated with the &quot;default&quot; user. They can change user using &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt;.</source>
          <target state="translated">現在の接続が認証されているユーザー名を返します。新しい接続は「デフォルト」ユーザーで認証されます。&lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt;を使用してユーザーを変更できます。</target>
        </trans-unit>
        <trans-unit id="0492bdeb7afe890056ed3d150bcd3cc644b0be83" translate="yes" xml:space="preserve">
          <source>Return valid &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt; strings representing the position of one or more elements in a sorted set value representing a geospatial index (where elements were added using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;).</source>
          <target state="translated">（要素が&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;を使用して追加された）空間インデックスを表すソートされたセット値内の1つ以上の要素の位置を表す有効な&lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt;文字列を返します。</target>
        </trans-unit>
        <trans-unit id="232f3db04c4faa620bfbfc11fd3689a472ef9881" translate="yes" xml:space="preserve">
          <source>Return value</source>
          <target state="translated">戻り値</target>
        </trans-unit>
        <trans-unit id="864674bcd0783b3457690f475310b938e42a7db7" translate="yes" xml:space="preserve">
          <source>Returning a maximum number of entries</source>
          <target state="translated">最大エントリ数を返す</target>
        </trans-unit>
        <trans-unit id="8f278b9f0e4f851622b8ed184503714c9eb2b40b" translate="yes" xml:space="preserve">
          <source>Returning items in a specific time range. This is possible because Stream IDs are &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;related to time&lt;/a&gt;.</source>
          <target state="translated">特定の時間範囲のアイテムを返す。これは、ストリームIDが&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;時間に関連して&lt;/a&gt;いるために可能です。</target>
        </trans-unit>
        <trans-unit id="6fecab38b77030a1f63f2810d6747aa68c069f23" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of details about all Redis commands.</source>
          <target state="translated">すべてのRedisコマンドに関する詳細の&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;配列応答&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="fc344310aece8efa4afcb637dd3fdf8dc24fa45b" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of details about multiple Redis commands.</source>
          <target state="translated">複数のRedisコマンドに関する詳細の&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;配列応答&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="4a134a2f3cf379373d004a605091cb6cf69dedcb" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of keys from a full Redis command.</source>
          <target state="translated">完全なRedisコマンドからのキーの&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;配列応答&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="bce4982fceed9f9a0c759decc9c92ecb37cc9be2" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt; of number of total commands in this Redis server.</source>
          <target state="translated">このRedisサーバー内の合計コマンド数の&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;整数応答&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="a915d042e7bc17cfcfeeccbd870dfc5af9c1ca16" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;PONG&lt;/code&gt; if no argument is provided, otherwise return a copy of the argument as a bulk. This command is often used to test if a connection is still alive, or to measure latency.</source>
          <target state="translated">引数が指定されていない場合は &lt;code&gt;PONG&lt;/code&gt; を返し、それ以外の場合は引数のコピーを一括して返します。このコマンドは、接続がまだ生きているかどうかをテストしたり、待ち時間を測定したりするためによく使用されます。</target>
        </trans-unit>
        <trans-unit id="dd1b58db010b114867573670782f464e9b034412" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;message&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="a8491e8a1858fe4a13538635b038fd1bb846df79" translate="yes" xml:space="preserve">
          <source>Returns all field names in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に保存されているハッシュのすべてのフィールド名を返します。</target>
        </trans-unit>
        <trans-unit id="514836e0465ae87a7f738140eb4e2b3ae4475e1f" translate="yes" xml:space="preserve">
          <source>Returns all fields and values of the hash stored at &lt;code&gt;key&lt;/code&gt;. In the returned value, every field name is followed by its value, so the length of the reply is twice the size of the hash.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に保存されているハッシュのすべてのフィールドと値を返します。戻り値では、すべてのフィールド名の後にその値が続くため、応答の長さはハッシュのサイズの2倍になります。</target>
        </trans-unit>
        <trans-unit id="e9924b464875fe91e2b89cf6f97649ff9ec1b5ce" translate="yes" xml:space="preserve">
          <source>Returns all keys matching &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; に一致するすべてのキーを返します。</target>
        </trans-unit>
        <trans-unit id="1ceba3296cc87483f6becfe1cdae897e811a1b1e" translate="yes" xml:space="preserve">
          <source>Returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; (including elements with score equal to &lt;code&gt;max&lt;/code&gt; or &lt;code&gt;min&lt;/code&gt;). In contrary to the default ordering of sorted sets, for this command the elements are considered to be ordered from high to low scores.</source>
          <target state="translated">&lt;code&gt;max&lt;/code&gt; から &lt;code&gt;min&lt;/code&gt; までのスコア（ &lt;code&gt;key&lt;/code&gt; が &lt;code&gt;max&lt;/code&gt; または &lt;code&gt;min&lt;/code&gt; に等しい要素を含む）を持つキーでソートされたセットのすべての要素を返します。ソートされたセットのデフォルトの順序とは異なり、このコマンドでは、要素は高スコアから低スコアの順に並べられていると見なされます。</target>
        </trans-unit>
        <trans-unit id="6def9bec387c3e744963c6ac4b0bf7f4010504e6" translate="yes" xml:space="preserve">
          <source>Returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (including elements with score equal to &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt;). The elements are considered to be ordered from low to high scores.</source>
          <target state="translated">スコアが &lt;code&gt;min&lt;/code&gt; から &lt;code&gt;max&lt;/code&gt; までの &lt;code&gt;key&lt;/code&gt; でソートされたセットのすべての要素を返します（スコアが &lt;code&gt;min&lt;/code&gt; または &lt;code&gt;max&lt;/code&gt; に等しい要素を含みます）。要素は低いスコアから高いスコアの順に並べられていると見なされます。</target>
        </trans-unit>
        <trans-unit id="1925ffaf420a57d589c1888eb5b09007e4f1d203" translate="yes" xml:space="preserve">
          <source>Returns all the members of the set value stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されている設定値のすべてのメンバーを返します。</target>
        </trans-unit>
        <trans-unit id="c11f5fe0471c6d472d362d6dbbf041c048b49125" translate="yes" xml:space="preserve">
          <source>Returns all values in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に保存されているハッシュのすべての値を返します。</target>
        </trans-unit>
        <trans-unit id="4792ce321c7a364f3dc2071cf137fcc522daf25d" translate="yes" xml:space="preserve">
          <source>Returns an integer identifying the hash slot the specified key hashes to. This command is mainly useful for debugging and testing, since it exposes via an API the underlying Redis implementation of the hashing algorithm. Example use cases for this command:</source>
          <target state="translated">指定したキーのハッシュ先のハッシュスロットを特定する整数値を返します。このコマンドは主にデバッグやテストに便利です。このコマンドの使用例。</target>
        </trans-unit>
        <trans-unit id="899ca03feedce83f7aa728b87a784b60bd95adf0" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;field&lt;/code&gt; is an existing field in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返した場合 &lt;code&gt;field&lt;/code&gt; で保存されたハッシュで既存のフィールドである &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e13b7a867bbaf0e4121d5da403d54edbe4a8b1f" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;key&lt;/code&gt; exists.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; が存在するかどうかを返します。</target>
        </trans-unit>
        <trans-unit id="163373a24e8be296b7e7c88d0c4da2f59ceca677" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;member&lt;/code&gt; is a member of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;member&lt;/code&gt; が &lt;code&gt;key&lt;/code&gt; に格納されているセットのメンバーであるかどうかを返します。</target>
        </trans-unit>
        <trans-unit id="abd92cbd9d7d0b6e4392a36873fd8c21767b398a" translate="yes" xml:space="preserve">
          <source>Returns information about the existence of the scripts in the script cache.</source>
          <target state="translated">スクリプトキャッシュ内のスクリプトが存在するかどうかの情報を返します。</target>
        </trans-unit>
        <trans-unit id="820ae40f339c061fc09ac87d928788d5e7ea006a" translate="yes" xml:space="preserve">
          <source>Returns information about the modules loaded to the server.</source>
          <target state="translated">サーバに読み込まれたモジュールに関する情報を返します。</target>
        </trans-unit>
        <trans-unit id="13855077d7cb93a1fce1c3432c59e7e463ea29a6" translate="yes" xml:space="preserve">
          <source>Returns or stores the elements contained in the &lt;a href=&quot;https://redis.io/topics/data-types#lists&quot;&gt;list&lt;/a&gt;, &lt;a href=&quot;https://redis.io/topics/data-types#set&quot;&gt;set&lt;/a&gt; or &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;sorted set&lt;/a&gt; at &lt;code&gt;key&lt;/code&gt;. By default, sorting is numeric and elements are compared by their value interpreted as double precision floating point number. This is &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; in its simplest form:</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; の&lt;a href=&quot;https://redis.io/topics/data-types#lists&quot;&gt;リスト&lt;/a&gt;、&lt;a href=&quot;https://redis.io/topics/data-types#set&quot;&gt;セット、&lt;/a&gt;または&lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;ソート済みセットに&lt;/a&gt;含まれる要素を返すか、格納します。デフォルトでは、ソートは数値であり、要素は倍精度浮動小数点数として解釈される値によって比較されます。これは、最も単純な形式の&lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f68574957008d127438140f50ac56b278260cf09" translate="yes" xml:space="preserve">
          <source>Returns the bit value at &lt;em&gt;offset&lt;/em&gt; in the string value stored at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;keyに&lt;/em&gt;格納されている文字列値の&lt;em&gt;オフセット&lt;/em&gt;のビット値を返します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6d63c7c2388918da907438c78c891dff4a16999" translate="yes" xml:space="preserve">
          <source>Returns the element at index &lt;code&gt;index&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt;. The index is zero-based, so &lt;code&gt;0&lt;/code&gt; means the first element, &lt;code&gt;1&lt;/code&gt; the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, &lt;code&gt;-1&lt;/code&gt; means the last element, &lt;code&gt;-2&lt;/code&gt; means the penultimate and so forth.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストのインデックス &lt;code&gt;index&lt;/code&gt; の要素を返します。インデックスはゼロベースなので、 &lt;code&gt;0&lt;/code&gt; は最初の要素、 &lt;code&gt;1&lt;/code&gt; は2番目の要素、というように続きます。負のインデックスを使用して、リストの末尾から始まる要素を指定できます。ここで、 &lt;code&gt;-1&lt;/code&gt; は最後の要素を意味し、 &lt;code&gt;-2&lt;/code&gt; は最後から2番目の要素を意味します。</target>
        </trans-unit>
        <trans-unit id="669652a24b746680e968eb8d19e304712aaafbef" translate="yes" xml:space="preserve">
          <source>Returns the length of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is interpreted as an empty list and &lt;code&gt;0&lt;/code&gt; is returned. An error is returned when the value stored at &lt;code&gt;key&lt;/code&gt; is not a list.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストの長さを返します。場合は &lt;code&gt;key&lt;/code&gt; 存在しない、それは空のリストとして解釈され、 &lt;code&gt;0&lt;/code&gt; が返されます。 &lt;code&gt;key&lt;/code&gt; に格納されている値がリストでない場合、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="b1b9de7b079dd5e1ad7bef3504c123ad01db9ecc" translate="yes" xml:space="preserve">
          <source>Returns the length of the string value stored at &lt;code&gt;key&lt;/code&gt;. An error is returned when &lt;code&gt;key&lt;/code&gt; holds a non-string value.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されている文字列値の長さを返します。 &lt;code&gt;key&lt;/code&gt; が文字列以外の値を保持している場合、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="5ca8167d0a845062b5e1c8307dc022d4e1bbe99c" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the difference between the first set and all the successive sets.</source>
          <target state="translated">最初の集合と連続するすべての集合との差から得られる集合のメンバを返します。</target>
        </trans-unit>
        <trans-unit id="65286cf35136f5258861b04a7983164ea5b463a3" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the intersection of all the given sets.</source>
          <target state="translated">与えられたすべての集合の交点から得られる集合のメンバを返します。</target>
        </trans-unit>
        <trans-unit id="473b41ab8be68badcb9ee743f59ebda61ccb6efd" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the union of all the given sets.</source>
          <target state="translated">与えられたすべての集合の和から得られる集合のメンバを返します。</target>
        </trans-unit>
        <trans-unit id="5f50e5f3ee257d3917e04c66ed0f097e9a6cbcd0" translate="yes" xml:space="preserve">
          <source>Returns the node's id.</source>
          <target state="translated">ノードのIDを返します。</target>
        </trans-unit>
        <trans-unit id="ae58574da7b69acb45d5608e905fbe416f5828a3" translate="yes" xml:space="preserve">
          <source>Returns the number of elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">スコアが &lt;code&gt;min&lt;/code&gt; から &lt;code&gt;max&lt;/code&gt; の &lt;code&gt;key&lt;/code&gt; でソートされたセットの要素数を返します。</target>
        </trans-unit>
        <trans-unit id="4ba5a6e2cdf681a72b81189fc73dab62a38a2630" translate="yes" xml:space="preserve">
          <source>Returns the number of entries inside a stream. If the specified key does not exist the command returns zero, as if the stream was empty. However note that unlike other Redis types, zero-length streams are possible, so you should call &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; or &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; in order to check if a key exists or not.</source>
          <target state="translated">ストリーム内のエントリ数を返します。指定されたキーが存在しない場合、ストリームが空であるかのように、コマンドはゼロを返します。ただし、他のRedisタイプとは異なり、長さがゼロのストリームが可能であるため、キーが存在するかどうかを確認するには、&lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt;または&lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt;を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="05ec2c01f1e7966c86d566259fe9827a1ce5788e" translate="yes" xml:space="preserve">
          <source>Returns the number of fields contained in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されたハッシュに含まれるフィールドの数を返します。</target>
        </trans-unit>
        <trans-unit id="cba9b6e741951a2ea3575443214cf403c194bc0f" translate="yes" xml:space="preserve">
          <source>Returns the number of keys in the specified Redis Cluster hash slot. The command only queries the local data set, so contacting a node that is not serving the specified hash slot will always result in a count of zero being returned.</source>
          <target state="translated">指定されたRedis Clusterハッシュスロット内のキーの数を返します。このコマンドはローカルデータセットのみを問い合わせますので、指定されたハッシュスロットを提供していないノードに問い合わせると、常にゼロのカウントが返されます。</target>
        </trans-unit>
        <trans-unit id="567352a29cfaef33a8cd3fcbcac829c78575fb62" translate="yes" xml:space="preserve">
          <source>Returns the number of subscribers (not counting clients subscribed to patterns) for the specified channels.</source>
          <target state="translated">指定したチャンネルの加入者数(パターンに加入しているクライアントはカウントしない)を返します。</target>
        </trans-unit>
        <trans-unit id="56eb7af42eb7b4bb5b7efb363837228225fedb8e" translate="yes" xml:space="preserve">
          <source>Returns the number of subscriptions to patterns (that are performed using the &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt; command). Note that this is not just the count of clients subscribed to patterns but the total number of patterns all the clients are subscribed to.</source>
          <target state="translated">（&lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;コマンドを使用して実行される）パターンへのサブスクリプションの数を返します。これは、パターンにサブスクライブしているクライアントの数だけでなく、すべてのクライアントがサブスクライブしているパターンの総数であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="029e626a83e98d1ddd2b45f2a08391faf674382c" translate="yes" xml:space="preserve">
          <source>Returns the rank of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;, with the scores ordered from high to low. The rank (or index) is 0-based, which means that the member with the highest score has rank &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているソート済みセットの &lt;code&gt;member&lt;/code&gt; のランクを返します。スコアは高いものから低いものへと並べられています。ランク（またはインデックス）は0ベースです。つまり、最高のスコアを持つメンバーのランクは &lt;code&gt;0&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="04ac6b8e04ac2d5fa91a42abbe270ab24969dcf8" translate="yes" xml:space="preserve">
          <source>Returns the rank of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;, with the scores ordered from low to high. The rank (or index) is 0-based, which means that the member with the lowest score has rank &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているソート済みセット内の &lt;code&gt;member&lt;/code&gt; のランクを返します。スコアは低いものから高いものへと並べられています。ランク（またはインデックス）は0ベースです。つまり、スコアが最も低いメンバーのランクは &lt;code&gt;0&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="dac65708cc841972517b49f4a323aba557dd7743" translate="yes" xml:space="preserve">
          <source>Returns the remaining time to live of a key that has a timeout. This introspection capability allows a Redis client to check how many seconds a given key will continue to be part of the dataset.</source>
          <target state="translated">タイムアウトしたキーの残り時間を返します。このイントロスペクション機能により、Redisクライアントは与えられたキーが何秒でデータセットの一部であり続けるかをチェックすることができます。</target>
        </trans-unit>
        <trans-unit id="bdaf416765952fb3c543f080075ad7115471f130" translate="yes" xml:space="preserve">
          <source>Returns the score of &lt;code&gt;member&lt;/code&gt; in the sorted set at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; のソートされたセットの &lt;code&gt;member&lt;/code&gt; のスコアを返します。</target>
        </trans-unit>
        <trans-unit id="4bb764cd364e3749541c7692eea4d198b1e88fce" translate="yes" xml:space="preserve">
          <source>Returns the scores associated with the specified &lt;code&gt;members&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 保存されているソート済みセット内の指定された &lt;code&gt;members&lt;/code&gt; に関連付けられているスコアを返します。</target>
        </trans-unit>
        <trans-unit id="0525192497ba351f01f7c69505a721186043f122" translate="yes" xml:space="preserve">
          <source>Returns the set cardinality (number of elements) of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているセットのカーディナリティ（要素数）を返します。</target>
        </trans-unit>
        <trans-unit id="538e8ccb043255bf1866a8c948a35b08642708eb" translate="yes" xml:space="preserve">
          <source>Returns the sorted set cardinality (number of elements) of the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に保存されているソート済みセットのソート済みセットのカーディナリティ（要素数）を返します。</target>
        </trans-unit>
        <trans-unit id="aed5ad61cf2dae51ecb526ffeb96e8ae6f66dd61" translate="yes" xml:space="preserve">
          <source>Returns the specified elements of the list stored at &lt;code&gt;key&lt;/code&gt;. The offsets &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are zero-based indexes, with &lt;code&gt;0&lt;/code&gt; being the first element of the list (the head of the list), &lt;code&gt;1&lt;/code&gt; being the next element and so on.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストの指定された要素を返します。オフセットの &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; は0 から始まるインデックスで、 &lt;code&gt;0&lt;/code&gt; はリストの最初の要素（リストの先頭）、 &lt;code&gt;1&lt;/code&gt; は次の要素というようになります。</target>
        </trans-unit>
        <trans-unit id="165e254b16f95c82b554bb625de96b2c2d45635e" translate="yes" xml:space="preserve">
          <source>Returns the specified range of elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt;. The elements are considered to be ordered from the highest to the lowest score. Descending lexicographical order is used for elements with equal score.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているソート済みセットの指定された範囲の要素を返します。要素は、最高から最低のスコアの順に並べられていると見なされます。降順の辞書式順序は、スコアが等しい要素に使用されます。</target>
        </trans-unit>
        <trans-unit id="c5f3848ec567b8c9da3f19a86ff736fd69145ae8" translate="yes" xml:space="preserve">
          <source>Returns the specified range of elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt;. The elements are considered to be ordered from the lowest to the highest score. Lexicographical order is used for elements with equal score.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているソート済みセットの指定された範囲の要素を返します。要素は最低スコアから最高スコアの順に並べられていると見なされます。辞書式順序は、スコアが等しい要素に使用されます。</target>
        </trans-unit>
        <trans-unit id="d28b315a7a61b9bf04b21fccdd6ae5bd4f8eb130" translate="yes" xml:space="preserve">
          <source>Returns the string length of the value associated with &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;. If the &lt;code&gt;key&lt;/code&gt; or the &lt;code&gt;field&lt;/code&gt; do not exist, 0 is returned.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されたハッシュの &lt;code&gt;field&lt;/code&gt; に関連付けられた値の文字列長を返します。場合は &lt;code&gt;key&lt;/code&gt; または &lt;code&gt;field&lt;/code&gt; 存在しない、0が返されます。</target>
        </trans-unit>
        <trans-unit id="ffb4e3b3a6a5708cfdef83bd04363741160ed0a4" translate="yes" xml:space="preserve">
          <source>Returns the string representation of the type of the value stored at &lt;code&gt;key&lt;/code&gt;. The different types that can be returned are: &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;zset&lt;/code&gt; and &lt;code&gt;hash&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されている値のタイプの文字列表現を返します。返される可能性のある異なるタイプは、 &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;list&lt;/code&gt; 、 &lt;code&gt;set&lt;/code&gt; 、 &lt;code&gt;zset&lt;/code&gt; 、および &lt;code&gt;hash&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c9feb2d475967dd13f03c72121d597fd1520318c" translate="yes" xml:space="preserve">
          <source>Returns the string representation of the type of the value stored at &lt;code&gt;key&lt;/code&gt;. The different types that can be returned are: &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;zset&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt; and &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されている値のタイプの文字列表現を返します。返される可能性のあるさまざまなタイプは、 &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;list&lt;/code&gt; 、 &lt;code&gt;set&lt;/code&gt; 、 &lt;code&gt;zset&lt;/code&gt; 、 &lt;code&gt;hash&lt;/code&gt; 、および &lt;code&gt;stream&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8a246620818088ec9a16f70b9fb4ae809aad9ad2" translate="yes" xml:space="preserve">
          <source>Returns the substring of the string value stored at &lt;code&gt;key&lt;/code&gt;, determined by the offsets &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; (both are inclusive). Negative offsets can be used in order to provide an offset starting from the end of the string. So -1 means the last character, -2 the penultimate and so forth.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されている文字列値の部分文字列を返します。これは、オフセットの &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;end&lt;/code&gt; によって決定されます（両方を含みます）。負のオフセットは、文字列の最後から始まるオフセットを提供するために使用できます。したがって、-1は最後の文字、-2は最後から2番目の文字などを意味します。</target>
        </trans-unit>
        <trans-unit id="ff8cb8f9712a465de8610b460278556869c01387" translate="yes" xml:space="preserve">
          <source>Returns the value associated with &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されたハッシュの &lt;code&gt;field&lt;/code&gt; に関連付けられた値を返します。</target>
        </trans-unit>
        <trans-unit id="6e8fea73a6efe9b1e714890adedb119e477e5b94" translate="yes" xml:space="preserve">
          <source>Returns the values associated with the specified &lt;code&gt;fields&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されたハッシュの指定された &lt;code&gt;fields&lt;/code&gt; に関連付けられた値を返します。</target>
        </trans-unit>
        <trans-unit id="2a3f6c24ab0b5bf50119e41442adccdd069520b2" translate="yes" xml:space="preserve">
          <source>Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value &lt;code&gt;nil&lt;/code&gt; is returned. Because of this, the operation never fails.</source>
          <target state="translated">指定されたすべてのキーの値を返します。文字列値を保持しないか存在しないすべてのキーについて、特別な値 &lt;code&gt;nil&lt;/code&gt; が返されます。このため、操作が失敗することはありません。</target>
        </trans-unit>
        <trans-unit id="0b14b8f8217819a1f6163396383d48d4cd2d94d9" translate="yes" xml:space="preserve">
          <source>Returns whether each &lt;code&gt;member&lt;/code&gt; is a member of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">各 &lt;code&gt;member&lt;/code&gt; が &lt;code&gt;key&lt;/code&gt; に格納されているセットのメンバーであるかどうかを返します。</target>
        </trans-unit>
        <trans-unit id="33fe03995fd835515d8b0c378391e0d80d6d96a2" translate="yes" xml:space="preserve">
          <source>Running the bitmap incrementally using the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt;&lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; optional parameters, accumulating the results client-side, and optionally caching the result into a key.</source>
          <target state="translated">&lt;a href=&quot;bitcount&quot;&gt;BITCOUNTの&lt;/a&gt;&lt;em&gt;開始&lt;/em&gt;と&lt;em&gt;終了の&lt;/em&gt;オプションパラメータを使用してビットマップを段階的に実行し、結果をクライアント側に蓄積し、オプションで結果をキーにキャッシュします。</target>
        </trans-unit>
        <trans-unit id="afc896d0c818d9d81d1502addeeed94d978515cb" translate="yes" xml:space="preserve">
          <source>SADD</source>
          <target state="translated">SADD</target>
        </trans-unit>
        <trans-unit id="afe4d83e232611365cc3a02706eeee448267b671" translate="yes" xml:space="preserve">
          <source>SADD  key member [member ...]   Add one or more members to a set</source>
          <target state="translated">SADD key member [member ....]1つまたは複数のメンバーをセットに追加します。</target>
        </trans-unit>
        <trans-unit id="508156a39b09ccfe61cc81d984e9317e5e0d8eec" translate="yes" xml:space="preserve">
          <source>SAVE</source>
          <target state="translated">SAVE</target>
        </trans-unit>
        <trans-unit id="a806788f2be230df4e533ace9d23ff41f5ebd919" translate="yes" xml:space="preserve">
          <source>SAVE   Synchronously save the dataset to disk</source>
          <target state="translated">SAVE 同期的にデータセットをディスクに保存する</target>
        </trans-unit>
        <trans-unit id="65b4fd3a026ef6fa00d5747035f289ef54695f24" translate="yes" xml:space="preserve">
          <source>SAVE and NOSAVE modifiers</source>
          <target state="translated">SAVEとNOSAVEの修飾子</target>
        </trans-unit>
        <trans-unit id="c5a19955ea5dab3fd18ab68f367f98693df1b60b" translate="yes" xml:space="preserve">
          <source>SCAN</source>
          <target state="translated">SCAN</target>
        </trans-unit>
        <trans-unit id="f6a353aff0f0da25a0e7f7c1d96621ee0a75fe99" translate="yes" xml:space="preserve">
          <source>SCAN  cursor [MATCH pattern] [COUNT count]   Incrementally iterate the keys space</source>
          <target state="translated">SCAN カーソル [MATCH パターン][COUNT カウント]キー空間をインクリメンタルに反復します。</target>
        </trans-unit>
        <trans-unit id="72556acd6ec7fd4188e74406d411c51d45f1c442" translate="yes" xml:space="preserve">
          <source>SCAN  cursor [MATCH pattern] [COUNT count] [TYPE type]   Incrementally iterate the keys space</source>
          <target state="translated">SCAN カーソル [MATCH パターン][COUNT カウント][TYPE タイプ]キー空間をインクリメンタルに反復します。</target>
        </trans-unit>
        <trans-unit id="f904e681db7d6de1d40ec70145524cd0367d1bf0" translate="yes" xml:space="preserve">
          <source>SCAN basic usage</source>
          <target state="translated">SCAN基本使用法</target>
        </trans-unit>
        <trans-unit id="aa3b23325236e95772d7cd2d8a5db2f2530e669f" translate="yes" xml:space="preserve">
          <source>SCAN is a cursor based iterator. This means that at every call of the command, the server returns an updated cursor that the user needs to use as the cursor argument in the next call.</source>
          <target state="translated">SCAN はカーソルベースのイテレータです。これは、コマンドを呼び出すたびに、サーバが更新されたカーソルを返し、ユーザが次の呼び出しでカーソルの引数として使用する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="0431790b7b638b530f089a6638b4b046bf245d05" translate="yes" xml:space="preserve">
          <source>SCARD</source>
          <target state="translated">SCARD</target>
        </trans-unit>
        <trans-unit id="45b0af77625a8e40fbd9c79a72bf85a01a682a2e" translate="yes" xml:space="preserve">
          <source>SCARD  key   Get the number of members in a set</source>
          <target state="translated">SCARD キー セット内のメンバー数を取得します。</target>
        </trans-unit>
        <trans-unit id="46ab5a918078b88865c34d46d45763f78a5cc2a8" translate="yes" xml:space="preserve">
          <source>SCRIPT</source>
          <target state="translated">SCRIPT</target>
        </trans-unit>
        <trans-unit id="942ec0d4567f537a05d81b40e79ed670c8098df1" translate="yes" xml:space="preserve">
          <source>SCRIPT DEBUG  YES|SYNC|NO   Set the debug mode for executed scripts.</source>
          <target state="translated">SCRIPT DEBUG YES|SYNC|NO 実行されるスクリプトのデバッグモードを設定します。</target>
        </trans-unit>
        <trans-unit id="d4f0300810cbd56a02078e94b26444e04a369df1" translate="yes" xml:space="preserve">
          <source>SCRIPT EXISTS  sha1 [sha1 ...]   Check existence of scripts in the script cache.</source>
          <target state="translated">SCRIPT EXISTS sha1 [sha1 ...]スクリプトキャッシュ内のスクリプトの存在を確認します。</target>
        </trans-unit>
        <trans-unit id="155351693709972a944322985f623357a60203d8" translate="yes" xml:space="preserve">
          <source>SCRIPT FLUSH</source>
          <target state="translated">スクリプトフラッシュ</target>
        </trans-unit>
        <trans-unit id="ff5ac14542c8a5c4ff717c937c92483157332c48" translate="yes" xml:space="preserve">
          <source>SCRIPT FLUSH   Remove all the scripts from the script cache.</source>
          <target state="translated">スクリプトのフラッシュ スクリプトキャッシュからすべてのスクリプトを削除します。</target>
        </trans-unit>
        <trans-unit id="5e2a68acdd358effce354e479fe828441291386c" translate="yes" xml:space="preserve">
          <source>SCRIPT KILL</source>
          <target state="translated">スクリプトキル</target>
        </trans-unit>
        <trans-unit id="898216faf82d0e8094a40fff1a1d11316572b3a1" translate="yes" xml:space="preserve">
          <source>SCRIPT KILL   Kill the script currently in execution.</source>
          <target state="translated">SCRIPT KILL 現在実行中のスクリプトをキルします。</target>
        </trans-unit>
        <trans-unit id="bf00a0ed4afe21cec9ac5006aa471a2c75ce80dd" translate="yes" xml:space="preserve">
          <source>SCRIPT LOAD  script   Load the specified Lua script into the script cache.</source>
          <target state="translated">SCRIPT LOAD script 指定した Lua スクリプトをスクリプトキャッシュにロードします。</target>
        </trans-unit>
        <trans-unit id="605e7c9dd422426230eae60c02acc7d7a5705884" translate="yes" xml:space="preserve">
          <source>SDIFF</source>
          <target state="translated">SDIFF</target>
        </trans-unit>
        <trans-unit id="18d8e0e316b86cf9a259f83877f9d4536e919048" translate="yes" xml:space="preserve">
          <source>SDIFF  key [key ...]   Subtract multiple sets</source>
          <target state="translated">SDIFF キー [key ....]複数セットを減算します。</target>
        </trans-unit>
        <trans-unit id="144b2bd3509fd63bb1b369b8c7665713eb587bd9" translate="yes" xml:space="preserve">
          <source>SDIFFSTORE</source>
          <target state="translated">SDIFFSTORE</target>
        </trans-unit>
        <trans-unit id="de1820fefd3db78a9062bc31ca0bace599879b7b" translate="yes" xml:space="preserve">
          <source>SDIFFSTORE  destination key [key ...]   Subtract multiple sets and store the resulting set in a key</source>
          <target state="translated">SDIFFSTORE 宛先キー [key ...]複数のセットを減算し、その結果をキーに格納します。</target>
        </trans-unit>
        <trans-unit id="a4942c26d0735947d8a22a2fbe2735a12e381808" translate="yes" xml:space="preserve">
          <source>SELECT</source>
          <target state="translated">SELECT</target>
        </trans-unit>
        <trans-unit id="f439068c5eb4482362ce42c7382665b32a13512a" translate="yes" xml:space="preserve">
          <source>SELECT  index   Change the selected database for the current connection</source>
          <target state="translated">SELECT index 現在の接続で選択したデータベースを変更します。</target>
        </trans-unit>
        <trans-unit id="55c5d81017a30edf1e47ba1b78c377a5e5ebfd50" translate="yes" xml:space="preserve">
          <source>SET</source>
          <target state="translated">SET</target>
        </trans-unit>
        <trans-unit id="b2f1db45c77eaf2c94d566bc200555c564e53670" translate="yes" xml:space="preserve">
          <source>SET  key value [EX seconds|PX milliseconds|KEEPTTL] [NX|XX] [GET]   Set the string value of a key</source>
          <target state="translated">SET キー値 [EX秒|PXミリ秒|KEEPTTL][NX|XX][GET]キーの文字列値を設定します。</target>
        </trans-unit>
        <trans-unit id="91a720b839d692fc7a7e17565ac1e4963650fe98" translate="yes" xml:space="preserve">
          <source>SET  key value [expiration EX seconds|PX milliseconds] [NX|XX]   Set the string value of a key</source>
          <target state="translated">SET key value [expiration EX seconds|PX milliseconds][NX|XX]キーの文字列値を設定します。</target>
        </trans-unit>
        <trans-unit id="7df70cb863a3d3a5e4a199b5d8ef3c9851ce87bf" translate="yes" xml:space="preserve">
          <source>SETBIT</source>
          <target state="translated">SETBIT</target>
        </trans-unit>
        <trans-unit id="b66f69a03f672489d4ae1d69a757435c5b63bd51" translate="yes" xml:space="preserve">
          <source>SETBIT  key offset value   Sets or clears the bit at offset in the string value stored at key</source>
          <target state="translated">SETBIT キーオフセット値 キーに格納されている文字列値のオフセット時のビットを設定またはクリアします。</target>
        </trans-unit>
        <trans-unit id="c92872db8021ac60dd456ca7447fb52919f32143" translate="yes" xml:space="preserve">
          <source>SETEX</source>
          <target state="translated">SETEX</target>
        </trans-unit>
        <trans-unit id="0b5df1d3ddffe0fdbb568accc5d3c3dac5121afc" translate="yes" xml:space="preserve">
          <source>SETEX  key seconds value   Set the value and expiration of a key</source>
          <target state="translated">SETEX key seconds value キーの値と有効期限を設定します。</target>
        </trans-unit>
        <trans-unit id="1ace6531f1c27b916c1368f17e1a7ae87aa79f97" translate="yes" xml:space="preserve">
          <source>SETNX</source>
          <target state="translated">SETNX</target>
        </trans-unit>
        <trans-unit id="a50f293fa49f962b5d82c0bb86c82df413a498b7" translate="yes" xml:space="preserve">
          <source>SETNX  key value   Set the value of a key, only if the key does not exist</source>
          <target state="translated">SETNX key value キーが存在しない場合のみ、キーの値を設定する。</target>
        </trans-unit>
        <trans-unit id="c1d82383232438676e2182b69bf2797640b1fcd2" translate="yes" xml:space="preserve">
          <source>SETRANGE</source>
          <target state="translated">SETRANGE</target>
        </trans-unit>
        <trans-unit id="a2132f99e69e7919051651c2b4fc7de24734eba2" translate="yes" xml:space="preserve">
          <source>SETRANGE  key offset value   Overwrite part of a string at key starting at the specified offset</source>
          <target state="translated">SETRANGE キーオフセット値 指定されたオフセットから始まるキーの文字列の一部を上書きします。</target>
        </trans-unit>
        <trans-unit id="ec493147ec1b78adab002626ee80cc23772aded8" translate="yes" xml:space="preserve">
          <source>SHUTDOWN</source>
          <target state="translated">SHUTDOWN</target>
        </trans-unit>
        <trans-unit id="606e1ec5d1ea13b283de4e59cd16289518254c6c" translate="yes" xml:space="preserve">
          <source>SHUTDOWN  [NOSAVE|SAVE]   Synchronously save the dataset to disk and then shut down the server</source>
          <target state="translated">SHUTDOWN [NOSAVE|SAVE]同期的にデータセットをディスクに保存した後、サーバをシャットダウンします。</target>
        </trans-unit>
        <trans-unit id="c340be94a16bd060ccd24ece053ed10ff4cfb1a2" translate="yes" xml:space="preserve">
          <source>SINTER</source>
          <target state="translated">SINTER</target>
        </trans-unit>
        <trans-unit id="acc6f9a5a6867145ccd5835b170277c3127f8f60" translate="yes" xml:space="preserve">
          <source>SINTER  key [key ...]   Intersect multiple sets</source>
          <target state="translated">SINTER キー [キー ...]複数セットを交差させます。</target>
        </trans-unit>
        <trans-unit id="ae286ac2efddc7ffc6de81fb4eef82083c5d0d0a" translate="yes" xml:space="preserve">
          <source>SINTERSTORE</source>
          <target state="translated">SINTERSTORE</target>
        </trans-unit>
        <trans-unit id="3cc889bdb24445318099b6bfa98a849204bc5321" translate="yes" xml:space="preserve">
          <source>SINTERSTORE  destination key [key ...]   Intersect multiple sets and store the resulting set in a key</source>
          <target state="translated">SINTERSTORE デスティネーションキー [key ...]複数のセットを交差させ、結果として得られたセットをキーに格納します。</target>
        </trans-unit>
        <trans-unit id="8074903f43c428dec41033b139437bb9d7e46e61" translate="yes" xml:space="preserve">
          <source>SISMEMBER</source>
          <target state="translated">SISMEMBER</target>
        </trans-unit>
        <trans-unit id="2613d73d648b1f6845f55faac8664acb5e2e9af6" translate="yes" xml:space="preserve">
          <source>SISMEMBER  key member   Determine if a given value is a member of a set</source>
          <target state="translated">SISMEMBER キーメンバー 与えられた値が集合のメンバーであるかどうかを決定します。</target>
        </trans-unit>
        <trans-unit id="bb3731aa645af4f77072e934700ff033a81e173b" translate="yes" xml:space="preserve">
          <source>SLAVEOF</source>
          <target state="translated">SLAVEOF</target>
        </trans-unit>
        <trans-unit id="9bb4401fd3b09a14ad63da1fc4e0ebcc9c0ee189" translate="yes" xml:space="preserve">
          <source>SLAVEOF  host port   Make the server a replica of another instance, or promote it as master. Deprecated starting with Redis 5. Use REPLICAOF instead.</source>
          <target state="translated">SLAVEOF ホストポート サーバを別のインスタンスのレプリカにするか、マスタとして昇格させます。Redis 5 以降では非推奨。 代わりに REPLICAOF を使用してください。</target>
        </trans-unit>
        <trans-unit id="4078b703021998b0c963d9636d85d96b1ddfa618" translate="yes" xml:space="preserve">
          <source>SLOWLOG</source>
          <target state="translated">SLOWLOG</target>
        </trans-unit>
        <trans-unit id="acfcd934ccfd2203f5ccc3e824371c24109642b8" translate="yes" xml:space="preserve">
          <source>SLOWLOG  subcommand [argument]   Manages the Redis slow queries log</source>
          <target state="translated">SLOWLOGサブコマンド [引数]Redisの遅いクエリのログを管理します。</target>
        </trans-unit>
        <trans-unit id="e6687e28d8b75312f0ea51bc9520b394ec2a7a63" translate="yes" xml:space="preserve">
          <source>SMEMBERS</source>
          <target state="translated">SMEMBERS</target>
        </trans-unit>
        <trans-unit id="fe66421f332187f83010e275c4b51042858f5234" translate="yes" xml:space="preserve">
          <source>SMEMBERS  key   Get all the members in a set</source>
          <target state="translated">SMEMBERS キー セット内のすべてのメンバーを取得します。</target>
        </trans-unit>
        <trans-unit id="3a5a30822e064f7dd03cefac6d437e4654f3aca9" translate="yes" xml:space="preserve">
          <source>SMISMEMBER</source>
          <target state="translated">SMISMEMBER</target>
        </trans-unit>
        <trans-unit id="aaa0292e655dd3747fc97cd25825a806d4aa708b" translate="yes" xml:space="preserve">
          <source>SMISMEMBER  key member [member ...]   Returns the membership associated with the given elements for a set</source>
          <target state="translated">SMISMEMBER key member [member ....]集合に対する、与えられた要素に関連付けられたメンバーシップを返します。</target>
        </trans-unit>
        <trans-unit id="20f84dbd21a3d84899dade0a24ef5c6978f0403e" translate="yes" xml:space="preserve">
          <source>SMOVE</source>
          <target state="translated">SMOVE</target>
        </trans-unit>
        <trans-unit id="1f7888e464279456fc99ea1259b436e9ad0d4f64" translate="yes" xml:space="preserve">
          <source>SMOVE  source destination member   Move a member from one set to another</source>
          <target state="translated">SMOVE ソース・デスティネーション・メンバー あるセットから別のセットにメンバーを移動します。</target>
        </trans-unit>
        <trans-unit id="2434fe1de87e4949f51786cc87dd6a83c095a422" translate="yes" xml:space="preserve">
          <source>SORT</source>
          <target state="translated">SORT</target>
        </trans-unit>
        <trans-unit id="8e248ec645f54a08b3eb01462adb200f94f15d79" translate="yes" xml:space="preserve">
          <source>SORT  key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]   Sort the elements in a list, set or sorted set</source>
          <target state="translated">SORTキー [BYパターン][LIMITオフセットカウント][GETパターン [GETパターン ...]ASC|DESC][ALPHA][STORE destination][STORE destination]リスト、セット、ソートされたセットの要素をソートします。</target>
        </trans-unit>
        <trans-unit id="757f5e1ed1192585c3e7deb4986d7e204a0c8613" translate="yes" xml:space="preserve">
          <source>SPOP</source>
          <target state="translated">SPOP</target>
        </trans-unit>
        <trans-unit id="a1bcd919a884989656266471e065ce0ed9f3b014" translate="yes" xml:space="preserve">
          <source>SPOP  key [count]   Remove and return one or multiple random members from a set</source>
          <target state="translated">SPOP キー [count]セットから 1 つまたは複数のランダムなメンバーを削除して返します。</target>
        </trans-unit>
        <trans-unit id="fa889adf02f632d165c3f2d12d9b5ec8d781cbb2" translate="yes" xml:space="preserve">
          <source>SRANDMEMBER</source>
          <target state="translated">SRANDMEMBER</target>
        </trans-unit>
        <trans-unit id="a3aa05de6787d8cb6b5fb2eeb41ce24756a254c7" translate="yes" xml:space="preserve">
          <source>SRANDMEMBER  key [count]   Get one or multiple random members from a set</source>
          <target state="translated">SRANDMEMBER key [count]セットから1つまたは複数のランダムメンバーを取得します。</target>
        </trans-unit>
        <trans-unit id="a25d27e5f9def5c1d9e1a790c413156760a00937" translate="yes" xml:space="preserve">
          <source>SREM</source>
          <target state="translated">SREM</target>
        </trans-unit>
        <trans-unit id="68363946a4081440ca501f29c43f5fbe4f7eefc4" translate="yes" xml:space="preserve">
          <source>SREM  key member [member ...]   Remove one or more members from a set</source>
          <target state="translated">SREM キーメンバー [メンバー ...]セットから 1 つ以上のメンバーを削除する。</target>
        </trans-unit>
        <trans-unit id="39f084973b61a7bea28e4e94336a3c5a0bf9fee7" translate="yes" xml:space="preserve">
          <source>SSCAN</source>
          <target state="translated">SSCAN</target>
        </trans-unit>
        <trans-unit id="9c2bba696b7b86cd88c82a287899370d9f0e3bb5" translate="yes" xml:space="preserve">
          <source>SSCAN  key cursor [MATCH pattern] [COUNT count]   Incrementally iterate Set elements</source>
          <target state="translated">SSCAN キーカーソル [MATCH パターン][COUNT カウント]インクリメンタル・イテレート セット要素</target>
        </trans-unit>
        <trans-unit id="746fc78a74ffba46a591afc21fe85ad08b00b6da" translate="yes" xml:space="preserve">
          <source>STRALGO</source>
          <target state="translated">STRALGO</target>
        </trans-unit>
        <trans-unit id="3faaaa804aaa356ec8a33bd42d375f1bc189c7e7" translate="yes" xml:space="preserve">
          <source>STRALGO  LCS algo-specific-argument [algo-specific-argument ...]   Run algorithms (currently LCS) against strings</source>
          <target state="translated">STRALGO LCS algo-specific-argument [algo-specific-argument ...]文字列に対してアルゴリズム(現在はLCS)を実行します。</target>
        </trans-unit>
        <trans-unit id="c89c4cb21a1d403bb307b502f69a87f9e3b3a8ab" translate="yes" xml:space="preserve">
          <source>STRLEN</source>
          <target state="translated">STRLEN</target>
        </trans-unit>
        <trans-unit id="ba1403b52701f08d29eb084587b5d84ec8dde893" translate="yes" xml:space="preserve">
          <source>STRLEN  key   Get the length of the value stored in a key</source>
          <target state="translated">STRLEN key キーに格納されている値の長さを取得します。</target>
        </trans-unit>
        <trans-unit id="43a6e12318adbbee03f06872c109322b0f558e29" translate="yes" xml:space="preserve">
          <source>SUBSCRIBE</source>
          <target state="translated">SUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="47236795c3b9acd1da0f66ecb88ffdd913189ac5" translate="yes" xml:space="preserve">
          <source>SUBSCRIBE  channel [channel ...]   Listen for messages published to the given channels</source>
          <target state="translated">SUBSCRIBE channel [channel ...]指定されたチャンネルに公開されたメッセージを聞く</target>
        </trans-unit>
        <trans-unit id="a9a4bd3707fb7f204fddf46673a38114093dbb82" translate="yes" xml:space="preserve">
          <source>SUNION</source>
          <target state="translated">SUNION</target>
        </trans-unit>
        <trans-unit id="5b757c33f2f9e74b674645b6ccda3d80138ff877" translate="yes" xml:space="preserve">
          <source>SUNION  key [key ...]   Add multiple sets</source>
          <target state="translated">SUNION キー [キー ...]複数セット追加</target>
        </trans-unit>
        <trans-unit id="48b1035f133322c326cae720a6ee6ad1108226dc" translate="yes" xml:space="preserve">
          <source>SUNIONSTORE</source>
          <target state="translated">SUNIONSTORE</target>
        </trans-unit>
        <trans-unit id="be4a84a92460ba7a99f970a1bd856700c5285869" translate="yes" xml:space="preserve">
          <source>SUNIONSTORE  destination key [key ...]   Add multiple sets and store the resulting set in a key</source>
          <target state="translated">SUNIONSTORE 宛先キー [キー ...]複数のセットを追加し、その結果をキーに格納します。</target>
        </trans-unit>
        <trans-unit id="52e8b5aa51a1b6c9b46c6f4abe8b613e777665e4" translate="yes" xml:space="preserve">
          <source>SWAPDB</source>
          <target state="translated">SWAPDB</target>
        </trans-unit>
        <trans-unit id="b86537c7b961d4302819caedcc63376c729b2e03" translate="yes" xml:space="preserve">
          <source>SWAPDB  index index   Swaps two Redis databases</source>
          <target state="translated">SWAPDBインデックスインデックス 2つのRedisデータベースをスワップします。</target>
        </trans-unit>
        <trans-unit id="77754660ca2a32513ded08ad488bd2a9af650258" translate="yes" xml:space="preserve">
          <source>SWAPDB  index1 index2   Swaps two Redis databases</source>
          <target state="translated">SWAPDB index1 index2 2つのRedisデータベースをスワップします。</target>
        </trans-unit>
        <trans-unit id="2f8d236566d2393cd3a112e7190d8837c8004cc2" translate="yes" xml:space="preserve">
          <source>SYNC</source>
          <target state="translated">SYNC</target>
        </trans-unit>
        <trans-unit id="7dade54cfe46a1450fe32e252c2fe2557e402641" translate="yes" xml:space="preserve">
          <source>SYNC   Internal command used for replication</source>
          <target state="translated">SYNC レプリケーションに使用される内部コマンド</target>
        </trans-unit>
        <trans-unit id="b54491fb2810da81b1ac818eeb380198be74decd" translate="yes" xml:space="preserve">
          <source>Same result format as &lt;a href=&quot;command&quot;&gt;COMMAND&lt;/a&gt; except you can specify which commands get returned.</source>
          <target state="translated">返されるコマンドを指定できることを除いて、&lt;a href=&quot;command&quot;&gt;COMMANDと&lt;/a&gt;同じ結果フォーマット。</target>
        </trans-unit>
        <trans-unit id="1cc201c6f067fb6b6182b441f2b6dc0f4b71649b" translate="yes" xml:space="preserve">
          <source>Sample Output (new version, includes IDs)</source>
          <target state="translated">サンプル出力(新バージョン、IDを含む</target>
        </trans-unit>
        <trans-unit id="fb0cb1b1aa0fcb98cea480e75b0d7dffc839cef1" translate="yes" xml:space="preserve">
          <source>Sample Output (old version)</source>
          <target state="translated">サンプル出力(旧バージョン</target>
        </trans-unit>
        <trans-unit id="7a614be0679e1660abb7ab566a46118d4e5207f9" translate="yes" xml:space="preserve">
          <source>Sandbox and maximum execution time</source>
          <target state="translated">サンドボックスと最大実行時間</target>
        </trans-unit>
        <trans-unit id="c660854037806380c25fadc61428fa995d1aa015" translate="yes" xml:space="preserve">
          <source>Save the DB in background.</source>
          <target state="translated">DBをバックグラウンドで保存します。</target>
        </trans-unit>
        <trans-unit id="444bd4af75b503112dd46c6982e0bae0a08cf7c2" translate="yes" xml:space="preserve">
          <source>Save the DB in background. The OK code is immediately returned. Redis forks, the parent continues to serve the clients, the child saves the DB on disk then exits. A client may be able to check if the operation succeeded using the &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; command.</source>
          <target state="translated">DBをバックグラウンドで保存します。OKコードがすぐに返されます。Redisはフォークし、親は引き続きクライアントにサービスを提供し、子はDBをディスクに保存して終了します。クライアントは、&lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt;コマンドを使用して操作が成功したかどうかを確認できる場合があります。</target>
        </trans-unit>
        <trans-unit id="6e73e4e94939b275e189527f28b962ac1035dc5b" translate="yes" xml:space="preserve">
          <source>Scan guarantees</source>
          <target state="translated">スキャン保証</target>
        </trans-unit>
        <trans-unit id="983987071368a426b6b0e610cd5b5142cb273380" translate="yes" xml:space="preserve">
          <source>Script cache semantics</source>
          <target state="translated">スクリプトキャッシュのセマンティクス</target>
        </trans-unit>
        <trans-unit id="7522becbe814d8b8cbc378f8930c8ca68bb2b8b5" translate="yes" xml:space="preserve">
          <source>Scripting</source>
          <target state="translated">Scripting</target>
        </trans-unit>
        <trans-unit id="745fe7d4baa466214b942befb3f50f3311c89d23" translate="yes" xml:space="preserve">
          <source>Scripts are also subject to a maximum execution time (five seconds by default). This default timeout is huge since a script should usually run in under a millisecond. The limit is mostly to handle accidental infinite loops created during development.</source>
          <target state="translated">スクリプトには最大実行時間も設定されています (デフォルトでは 5 秒)。スクリプトは通常ミリ秒以下で実行されるはずなので、このデフォルトのタイムアウトは非常に大きなものです。この制限は主に、開発中に発生した不慮の無限ループを処理するためのものです。</target>
        </trans-unit>
        <trans-unit id="aef3e907fc9586fb823b51b6f43074de8b409561" translate="yes" xml:space="preserve">
          <source>Scripts as pure functions</source>
          <target state="translated">純粋な関数としてのスクリプト</target>
        </trans-unit>
        <trans-unit id="18ec3225e4d3fe66e7449672a6973e4c283e8bfa" translate="yes" xml:space="preserve">
          <source>Scripts should never try to access the external system, like the file system or any other system call. A script should only operate on Redis data and passed arguments.</source>
          <target state="translated">スクリプトは、ファイルシステムやその他のシステムコールのような外部システムにアクセスしようとしてはいけません。スクリプトは、Redis データと渡された引数のみを操作すべきです。</target>
        </trans-unit>
        <trans-unit id="96faa0a78d5b1890951d8f5b8b1cde571bd90423" translate="yes" xml:space="preserve">
          <source>Second replica</source>
          <target state="translated">セカンドレプリカ</target>
        </trans-unit>
        <trans-unit id="3eb4e043552c7873cf099793db5b7d1e5db95809" translate="yes" xml:space="preserve">
          <source>Security notice</source>
          <target state="translated">セキュリティ上の注意事項</target>
        </trans-unit>
        <trans-unit id="b5a6bb51bed42ec84477a8c64f567145dc6b3f5b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; for documentation.</source>
          <target state="translated">ドキュメントについては、&lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="82b75cc42f6596f8de98cea0e684609b487d2473" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; for extra information on increment/decrement operations.</source>
          <target state="translated">インクリメント/デクリメント操作の詳細については、&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b864667dcad5904883861ad9695e349acea56ad8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; for more information.</source>
          <target state="translated">詳細については、&lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="107b4f4ca6c2e49d71158688712e821a1f6afcf3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; for more information.</source>
          <target state="translated">詳細については、&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="54208184c8545cb10751d54f17912e96124fdcce" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;hscan&quot;&gt;HSCANの&lt;/a&gt;ドキュメントについては、&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c7350f489b2f884299284e290b37d7bb050416da" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;sscan&quot;&gt;SSCANの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="23e07b46cb9a86395d17dec6e25da38c0a253bd8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;zscan&quot;&gt;ZSCANの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="cf5419ddb7be58d105f864a1bb383d4d274d8979" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt; when you need the elements ordered from highest to lowest score (and descending lexicographical order for elements with equal score).</source>
          <target state="translated">要素を最高スコアから最低スコアの順に並べる必要がある場合は&lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGEを&lt;/a&gt;参照してください（スコアが等しい要素の場合は辞書式の降順）。</target>
        </trans-unit>
        <trans-unit id="a4157bb7f9bac5025b0c70053cd9e97522de9f5f" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; command that returns the same information with milliseconds resolution (Only available in Redis 2.6 or greater).</source>
          <target state="translated">ミリ秒の分解能で同じ情報を返す&lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt;コマンドも参照してください（Redis 2.6以降でのみ使用可能）。</target>
        </trans-unit>
        <trans-unit id="3f65c6fd246f3e1cbd884a1abc8369fa9e3fec12" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;blpop&quot;&gt;BLPOP documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; is identical to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; with the only difference being that it pops elements from the tail of a list instead of popping from the head.</source>
          <target state="translated">参照してください&lt;a href=&quot;blpop&quot;&gt;BLPOPのマニュアルを参照して&lt;/a&gt;いるので、正確なセマンティクスのため&lt;a href=&quot;brpop&quot;&gt;BRPOPは&lt;/a&gt;と同じです&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt;唯一の違いは、それが代わりに頭から飛び出るのリストの末尾から要素をポップということで。</target>
        </trans-unit>
        <trans-unit id="98f2a156aa61e815ac476620027b033818a3853f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;blpop&quot;&gt;BLPOP documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; is identical to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; with the only difference being the data structure being popped from.</source>
          <target state="translated">参照してください&lt;a href=&quot;blpop&quot;&gt;BLPOPのマニュアルを参照して&lt;/a&gt;いるので、正確なセマンティクスのため&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMINは&lt;/a&gt;同じです&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt;唯一の違いはからポップされたデータ構造であることを。</target>
        </trans-unit>
        <trans-unit id="682db2e97701526e3ecf1f9201b3297eab6f9ec7" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt; is identical to &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; with the only difference being that it pops members with the highest scores instead of popping the ones with the lowest scores.</source>
          <target state="translated">参照してください&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMINのマニュアルを参照して&lt;/a&gt;いるので、正確な意味については&lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAXは&lt;/a&gt;同じです&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt;唯一の違いは、それが代わりに最低のスコアを持つものをポップの最高得点を持つメンバーをポップということで。</target>
        </trans-unit>
        <trans-unit id="58bc20fb0dd298ffb8cf41a50998826b6c62ee0f" translate="yes" xml:space="preserve">
          <source>See the article called &quot;&lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;Fast easy realtime metrics using Redis bitmaps&lt;/a&gt;&quot; for a interesting use cases.</source>
          <target state="translated">興味深いユースケースについては、「&lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;Redisビットマップを使用した高速で簡単なリアルタイムメトリック&lt;/a&gt;」という記事を参照してください。</target>
        </trans-unit>
        <trans-unit id="2b55d9f15b0ea2d72611a684c74d755e0354f5c5" translate="yes" xml:space="preserve">
          <source>Select the Redis logical database having the specified zero-based numeric index. New connections always use the database 0.</source>
          <target state="translated">指定されたゼロベースの数値インデックスを持つRedis論理データベースを選択します。新しい接続は常にデータベース0を使用します。</target>
        </trans-unit>
        <trans-unit id="5e585c2b51baeb7604c1d696f4c6be82b1e7c611" translate="yes" xml:space="preserve">
          <source>Selectable Redis databases are a form of namespacing: all databases are still persisted in the same RDB / AOF file. However different databases can have keys with the same name, and commands like &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;, &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; or &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; work on specific databases.</source>
          <target state="translated">選択可能なRedisデータベースは名前空間の形式です。すべてのデータベースは引き続き同じRDB / AOFファイルに保持されます。しかし、異なるデータベースは、同じ名前を持つキー等のコマンド持つことができ&lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;、&lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt;または&lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;特定のデータベースで作業を。</target>
        </trans-unit>
        <trans-unit id="19899928b5f8951aa558a826d2465808d72a01a5" translate="yes" xml:space="preserve">
          <source>Selective replication of commands</source>
          <target state="translated">コマンドの選択的複製</target>
        </trans-unit>
        <trans-unit id="49cedc3ef8c6db0043eba553132d30f3fe261b2a" translate="yes" xml:space="preserve">
          <source>Sentinel output</source>
          <target state="translated">センチネル出力</target>
        </trans-unit>
        <trans-unit id="23e75937982f844ac2efdda93d0cf6e15629e1a7" translate="yes" xml:space="preserve">
          <source>Serialization format</source>
          <target state="translated">シリアライズ形式</target>
        </trans-unit>
        <trans-unit id="7af4afd659e0dc29f7d2d75a3f48646f5eb4ec0b" translate="yes" xml:space="preserve">
          <source>Serialize the value stored at key in a Redis-specific format and return it to the user. The returned value can be synthesized back into a Redis key using the &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command.</source>
          <target state="translated">キーに格納されている値をRedis固有の形式でシリアル化し、ユーザーに返します。&lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt;コマンドを使用して、戻り値を合成してRedisキーに戻すことができます。</target>
        </trans-unit>
        <trans-unit id="cb0cb170d106f8e8d5af1e05bbdbd3a96a7de197" translate="yes" xml:space="preserve">
          <source>Server</source>
          <target state="translated">Server</target>
        </trans-unit>
        <trans-unit id="c0ae85ee6d7ed57f6a577247b126ae67f64df433" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold string &lt;code&gt;value&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; does not exist. In that case, it is equal to &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. When &lt;code&gt;key&lt;/code&gt; already holds a value, no operation is performed. &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; is short for &quot;&lt;strong&gt;SET&lt;/strong&gt; if &lt;strong&gt;N&lt;/strong&gt;ot e&lt;strong&gt;X&lt;/strong&gt;ists&quot;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; が存在しない場合に文字列 &lt;code&gt;value&lt;/code&gt; を保持するように &lt;code&gt;key&lt;/code&gt; を設定します。その場合、それは&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;と同じです。ときに &lt;code&gt;key&lt;/code&gt; すでに値を保持し、何も操作は実行されません。&lt;a href=&quot;setnx&quot;&gt;SETNXは&lt;/a&gt; &quot;の略である&lt;strong&gt;SET&lt;/strong&gt;場合&lt;strong&gt;N&lt;/strong&gt; OT E &lt;strong&gt;X&lt;/strong&gt; ISTS&quot;。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68ffd036a56e1e5a5a24f70d86f4819eb308fad6" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold the string &lt;code&gt;value&lt;/code&gt; and set &lt;code&gt;key&lt;/code&gt; to timeout after a given number of seconds. This command is equivalent to executing the following commands:</source>
          <target state="translated">文字列 &lt;code&gt;value&lt;/code&gt; を保持するように &lt;code&gt;key&lt;/code&gt; を設定し、指定された秒数後にタイムアウトするように &lt;code&gt;key&lt;/code&gt; を設定します。このコマンドは、次のコマンドを実行することと同等です。</target>
        </trans-unit>
        <trans-unit id="e17569ffaef1d28acdfd66d09de8af3c0b06dd1a" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold the string &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; already holds a value, it is overwritten, regardless of its type. Any previous time to live associated with the key is discarded on successful &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; operation.</source>
          <target state="translated">文字列 &lt;code&gt;value&lt;/code&gt; を保持する &lt;code&gt;key&lt;/code&gt; を設定します。場合は &lt;code&gt;key&lt;/code&gt; すでに値を保持し、それは関係なく、そのタイプの、上書きされます。キーに関連付けられた以前の存続時間は、&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;操作が成功すると破棄されます。</target>
        </trans-unit>
        <trans-unit id="1f4c1e8e25a5de08761510d1ae33392ed98c3afb" translate="yes" xml:space="preserve">
          <source>Set a timeout on &lt;code&gt;key&lt;/code&gt;. After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is often said to be &lt;em&gt;volatile&lt;/em&gt; in Redis terminology.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; タイムアウトを設定します。タイムアウトの期限が切れると、キーは自動的に削除されます。タイムアウトが関連付けられているキーは、Redisの用語では&lt;em&gt;揮発性&lt;/em&gt;であるとよく言われます。</target>
        </trans-unit>
        <trans-unit id="eaec93cdacc6eb6c55472f85e73e6fb3ad082dbe" translate="yes" xml:space="preserve">
          <source>Set the consumer group &lt;em&gt;last delivered ID&lt;/em&gt; to something else.</source>
          <target state="translated">コンシューマグループが&lt;em&gt;最後に配信したID&lt;/em&gt;を別の&lt;em&gt;ID&lt;/em&gt;に設定します。</target>
        </trans-unit>
        <trans-unit id="5d89ad31b7de012f12a03f34f4620f730e4db31a" translate="yes" xml:space="preserve">
          <source>Set the debug mode for subsequent scripts executed with &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;. Redis includes a complete Lua debugger, codename LDB, that can be used to make the task of writing complex scripts much simpler. In debug mode Redis acts as a remote debugging server and a client, such as &lt;code&gt;redis-cli&lt;/code&gt;, can execute scripts step by step, set breakpoints, inspect variables and more - for additional information about LDB refer to the &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Redis Lua debugger&lt;/a&gt; page.</source>
          <target state="translated">&lt;a href=&quot;eval&quot;&gt;EVALで&lt;/a&gt;実行される後続のスクリプトのデバッグモードを設定します。Redisには、完全なLuaデバッガー、コードネームLDBが含まれています。これを使用して、複雑なスクリプトを作成するタスクをはるかに簡単にすることができます。デバッグモードでは、Redisはリモートデバッグサーバーとして機能し、 &lt;code&gt;redis-cli&lt;/code&gt; などのクライアントは、ステップバイステップでスクリプトを実行し、ブレークポイントを設定し、変数を検査します。LDBの詳細については、&lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Redis Luaデバッガー&lt;/a&gt;ページを参照してください。</target>
        </trans-unit>
        <trans-unit id="6550b71f96cbf89e715fc6e575e8db9958a3525f" translate="yes" xml:space="preserve">
          <source>Set the destination node slot to &lt;em&gt;importing&lt;/em&gt; state using &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; IMPORTING &amp;lt;source-node-id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; IMPORTING &amp;lt;source-node-id&amp;gt;&lt;/code&gt; を使用して、宛先ノードスロットを&lt;em&gt;インポート&lt;/em&gt;状態に設定します。</target>
        </trans-unit>
        <trans-unit id="84c2dc8e1aa43a852766a49a5d96696d6e7e9329" translate="yes" xml:space="preserve">
          <source>Set the source node slot to &lt;em&gt;migrating&lt;/em&gt; state using &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; MIGRATING &amp;lt;destination-node-id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; MIGRATING &amp;lt;destination-node-id&amp;gt;&lt;/code&gt; を使用して、ソースノードスロットを&lt;em&gt;移行&lt;/em&gt;状態に設定します。</target>
        </trans-unit>
        <trans-unit id="2ab262f44dfc9e1ee8adf98c1aa64de34434fa83" translate="yes" xml:space="preserve">
          <source>Sets</source>
          <target state="translated">Sets</target>
        </trans-unit>
        <trans-unit id="d9264103cd2db8160e2072438f28377ce6a9fc7b" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, only if &lt;code&gt;field&lt;/code&gt; does not yet exist. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; already exists, this operation has no effect.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されたハッシュの &lt;code&gt;field&lt;/code&gt; を &lt;code&gt;value&lt;/code&gt; に設定します（ &lt;code&gt;field&lt;/code&gt; がまだ存在しない場合のみ）。 &lt;code&gt;key&lt;/code&gt; が存在しない場合は、ハッシュを保持する新しいキーが作成されます。場合は &lt;code&gt;field&lt;/code&gt; すでに存在している、この操作は効果がありません。</target>
        </trans-unit>
        <trans-unit id="4067fd3c70d6275dbeb4b012c5dce8cf613a429a" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; already exists in the hash, it is overwritten.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されたハッシュの &lt;code&gt;field&lt;/code&gt; を &lt;code&gt;value&lt;/code&gt; に設定します。 &lt;code&gt;key&lt;/code&gt; が存在しない場合は、ハッシュを保持する新しいキーが作成されます。 &lt;code&gt;field&lt;/code&gt; がハッシュにすでに存在する場合、それは上書きされます。</target>
        </trans-unit>
        <trans-unit id="e0c3c8b5846a6b7343db97e53a136456e18a31e2" translate="yes" xml:space="preserve">
          <source>Sets can be encoded as &lt;code&gt;intset&lt;/code&gt; or &lt;code&gt;hashtable&lt;/code&gt;. The &lt;code&gt;intset&lt;/code&gt; is a special encoding used for small sets composed solely of integers.</source>
          <target state="translated">セットはとしてエンコードすることができ &lt;code&gt;intset&lt;/code&gt; または &lt;code&gt;hashtable&lt;/code&gt; 。 &lt;code&gt;intset&lt;/code&gt; 、単に整数の小セットに使用される特別なエンコーディングです。</target>
        </trans-unit>
        <trans-unit id="e2de8a522a3c6c1fa9f2cb3110ab55a427778354" translate="yes" xml:space="preserve">
          <source>Sets or clears the bit at &lt;em&gt;offset&lt;/em&gt; in the string value stored at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;keyに&lt;/em&gt;格納されている文字列値の&lt;em&gt;オフセット&lt;/em&gt;のビットを設定またはクリアし&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e97dcc6f663f896d57a6785f5e028d865ad0719f" translate="yes" xml:space="preserve">
          <source>Sets the given keys to their respective values. &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; replaces existing values with new values, just as regular &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. See &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; if you don't want to overwrite existing values.</source>
          <target state="translated">指定されたキーをそれぞれの値に設定します。&lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt;は、通常の&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;と同様に、既存の値を新しい値で置き換えます。既存の値を上書きしたくない場合は、&lt;a href=&quot;msetnx&quot;&gt;MSETNXを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5a2c8ceb3bc610f26a67627aba4acc8339a9ce7d" translate="yes" xml:space="preserve">
          <source>Sets the given keys to their respective values. &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; will not perform any operation at all even if just a single key already exists.</source>
          <target state="translated">指定されたキーをそれぞれの値に設定します。&lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt;は、単一のキーが既に存在する場合でも、何の操作も実行しません。</target>
        </trans-unit>
        <trans-unit id="97465787360d692779d220c22de863eac3b87265" translate="yes" xml:space="preserve">
          <source>Sets the list element at &lt;code&gt;index&lt;/code&gt; to &lt;code&gt;element&lt;/code&gt;. For more information on the &lt;code&gt;index&lt;/code&gt; argument, see &lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; のリスト要素を要素に設定し &lt;code&gt;element&lt;/code&gt; 。詳細については &lt;code&gt;index&lt;/code&gt; 引数、参照&lt;a href=&quot;lindex&quot;&gt;LINDEXを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8750c7a418a307afb7502f752e1bd4c1264fa761" translate="yes" xml:space="preserve">
          <source>Sets the list element at &lt;code&gt;index&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;. For more information on the &lt;code&gt;index&lt;/code&gt; argument, see &lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; のリスト要素を &lt;code&gt;value&lt;/code&gt; に設定します。詳細については &lt;code&gt;index&lt;/code&gt; 引数、参照&lt;a href=&quot;lindex&quot;&gt;LINDEXを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3acb8a6c67905faa893fe92726100c83a3b40b2e" translate="yes" xml:space="preserve">
          <source>Sets the specified fields to their respective values in the hash stored at &lt;code&gt;key&lt;/code&gt;. This command overwrites any specified fields already existing in the hash. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created.</source>
          <target state="translated">指定されたフィールドを、 &lt;code&gt;key&lt;/code&gt; に格納されているハッシュのそれぞれの値に設定します。このコマンドは、ハッシュに既に存在する指定されたフィールドを上書きします。 &lt;code&gt;key&lt;/code&gt; が存在しない場合は、ハッシュを保持する新しいキーが作成されます。</target>
        </trans-unit>
        <trans-unit id="66e4a6395d06dd6c9ac9889a54defa5d69368f6e" translate="yes" xml:space="preserve">
          <source>Similarly to get just the last element added into the stream it is enough to send:</source>
          <target state="translated">同様に、ストリームに追加された最後の要素だけを取得するには、それを送信するのに十分です。</target>
        </trans-unit>
        <trans-unit id="e66ca1aceaf1d95b66f61ef999386ba4322050ac" translate="yes" xml:space="preserve">
          <source>Simple string reply</source>
          <target state="translated">単純な文字列の返信</target>
        </trans-unit>
        <trans-unit id="d1d2334a81971315130c4fe2db94eeb5d843a482" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; and &lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER&lt;/a&gt; have a &lt;code&gt;STORE&lt;/code&gt; and &lt;code&gt;STOREDIST&lt;/code&gt; option they are technically flagged as writing commands in the Redis command table. For this reason read-only replicas will flag them, and Redis Cluster replicas will redirect them to the master instance even if the connection is in read only mode (See the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command of Redis Cluster).</source>
          <target state="translated">以来&lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt;と&lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBERを&lt;/a&gt;持っ &lt;code&gt;STORE&lt;/code&gt; と &lt;code&gt;STOREDIST&lt;/code&gt; オプションを彼らは技術的にRedisのコマンドテーブルにコマンドを書いとしてフラグ付けされています。このため、読み取り専用レプリカはフラグを立て、Redisクラスターレプリカは、接続が読み取り専用モードであってもマスターインスタンスにリダイレクトします（Redisクラスターの&lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt;コマンドを参照）。</target>
        </trans-unit>
        <trans-unit id="97d9bd95aec04226ad20ff34e75e5087d27999bb" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; returns the number of replicas reached both in case of failure and success, the client should check that the returned value is equal or greater to the replication level it demanded.</source>
          <target state="translated">以来&lt;a href=&quot;wait&quot;&gt;WAITの&lt;/a&gt;リターンはレプリカの数が、失敗と成功の場合には、両方に達し、クライアントは、返される値は、それが要求複製レベル以上であることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="d91e505ea765c9a82be96ae5534dfec641b36446" translate="yes" xml:space="preserve">
          <source>Since Redis 2.4 the AOF rewrite is automatically triggered by Redis, however the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; command can be used to trigger a rewrite at any time.</source>
          <target state="translated">Redis 2.4以降、AOF書き換えはRedisによって自動的にトリガーされますが、&lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt;コマンドを使用していつでも書き換えをトリガーできます。</target>
        </trans-unit>
        <trans-unit id="fea1afb4200834342d36841c2047774edeed20c3" translate="yes" xml:space="preserve">
          <source>Since Redis 2.6 the expire error is from 0 to 1 milliseconds.</source>
          <target state="translated">Redis 2.6以降、期限切れエラーは0から1ミリ秒になりました。</target>
        </trans-unit>
        <trans-unit id="c0dcf1f129fbdd5b581db58c1a230256a6836c37" translate="yes" xml:space="preserve">
          <source>Since Redis 3.0.3 it is possible to specify multiple keys instead of a single one. In such a case, it returns the total number of keys existing. Note that returning 1 or 0 for a single key is just a special case of the variadic usage, so the command is completely backward compatible.</source>
          <target state="translated">Redis 3.0.3以降、単一のキーではなく複数のキーを指定することが可能になりました。そのような場合、存在するキーの総数を返します。単一のキーに対して 1 や 0 を返すのは variadic の使用法の特殊なケースに過ぎないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f8bcf2ebedfce566d24835d3a2aba17bb7c2d1ca" translate="yes" xml:space="preserve">
          <source>Since Redis 3.0.3 the command accepts a variable number of keys and the return value is generalized:</source>
          <target state="translated">Redis 3.0.3以降、このコマンドは可変数のキーを受け付け、戻り値は一般化されています。</target>
        </trans-unit>
        <trans-unit id="e151485b203362c942ed95e59fd38510a0f0ba0d" translate="yes" xml:space="preserve">
          <source>Since Redis 3.2.10 / 4.0.0, this command also prevents keys to be evicted or expired during the time clients are paused. This way the dataset is guaranteed to be static not just from the point of view of clients not being able to write, but also from the point of view of internal operations.</source>
          <target state="translated">Redis 3.2.10/4.0.0.0以降では、このコマンドはクライアントが一時停止している間にキーが削除されたり、期限切れになったりするのを防ぐこともできます。このようにして、クライアントが書き込みできないという観点からだけでなく、内部操作の観点からも、データセットが静的であることが保証されます。</target>
        </trans-unit>
        <trans-unit id="b23d8947d72fa1ab05d11117a996f014677a635b" translate="yes" xml:space="preserve">
          <source>Since in the second call the returned cursor is 0, the server signaled to the caller that the iteration finished, and the collection was completely explored. Starting an iteration with a cursor value of 0, and calling &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; until the returned cursor is 0 again is called a &lt;strong&gt;full iteration&lt;/strong&gt;.</source>
          <target state="translated">2番目の呼び出しで返されたカーソルは0であるため、サーバーは呼び出しが終了し、コレクションが完全に探索されたことを呼び出し元に通知しました。カーソル値0で反復を開始し、返されたカーソルが再び0になるまで&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;を呼び出すことを、&lt;strong&gt;完全反復&lt;/strong&gt;と呼び&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5ff6f2c9633e20e1d4f2fc7a23a6109e8917c9ab" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;increment&lt;/code&gt; argument is signed, both increment and decrement operations can be performed:</source>
          <target state="translated">以来 &lt;code&gt;increment&lt;/code&gt; 引数が署名され、両方のインクリメントとデクリメント操作を行うことができます。</target>
        </trans-unit>
        <trans-unit id="37a6aaafe1e5adca5e6fbd58e615c9ceed7c328a" translate="yes" xml:space="preserve">
          <source>Since the currently selected database is a property of the connection, clients should track the currently selected database and re-select it on reconnection. While there is no command in order to query the selected database in the current connection, the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; output shows, for each client, the currently selected database.</source>
          <target state="translated">現在選択されているデータベースは接続のプロパティであるため、クライアントは現在選択されているデータベースを追跡し、再接続時に再選択する必要があります。現在の接続で選択したデータベースを照会するコマンドはありませんが、&lt;a href=&quot;client-list&quot;&gt;CLIENT LISTの&lt;/a&gt;出力には、クライアントごとに現在選択されているデータベースが表示されます。</target>
        </trans-unit>
        <trans-unit id="52b5e60090730a6d250177de9e20295f9eac7ba4" translate="yes" xml:space="preserve">
          <source>Since the introduction of partial resynchronization with replicas (PSYNC feature) Redis replicas asynchronously ping their master with the offset they already processed in the replication stream. This is used in multiple ways:</source>
          <target state="translated">レプリカとの部分的な再同期化(PSYNC機能)が導入されて以来、Redisレプリカは、レプリケーションストリームで既に処理されたオフセットで非同期的にマスターにpingを行います。これは複数の方法で使用されます。</target>
        </trans-unit>
        <trans-unit id="22f6371320dc02af91620e9a2e69ac86d721aec2" translate="yes" xml:space="preserve">
          <source>Since there is no state server side, but the full state is captured by the cursor, the caller is free to terminate an iteration half-way without signaling this to the server in any way. An infinite number of iterations can be started and never terminated without any issue.</source>
          <target state="translated">状態サーバ側には状態が存在せず、カーソルによって完全な状態がキャプチャされるため、呼び出し元はサーバに何らのシグナルを送ることなく、反復を途中で終了させることができます。無限の数の反復が開始されても、問題なく終了することはありません。</target>
        </trans-unit>
        <trans-unit id="262e696e012026f3d4f6a8415b02d5a7c46227f9" translate="yes" xml:space="preserve">
          <source>Since these commands allow for incremental iteration, returning only a small number of elements per call, they can be used in production without the downside of commands like &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; or &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; that may block the server for a long time (even several seconds) when called against big collections of keys or elements.</source>
          <target state="translated">これらのコマンドはインクリメンタルな反復を可能にし、呼び出しごとに少数の要素のみを返すため、呼び出されたときにサーバーを長時間（数秒でも）ブロックする可能性がある&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt;や&lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt;などのコマンドの欠点なしで本番環境で使用できます。キーまたは要素の大きなコレクション。</target>
        </trans-unit>
        <trans-unit id="3c0c8d4b217b1b3c149a8290667da3e389e7ef26" translate="yes" xml:space="preserve">
          <source>Since this involves approximations, in order to avoid C is set to, like, 0.998 instead of 1, we just modify the above algorithm to make sure the last score is 1 (left as an exercise for the reader...).</source>
          <target state="translated">これには近似が含まれているので、Cが1ではなく0.998に設定されるのを避けるために、上のアルゴリズムを修正して、最後のスコアが1になるようにするだけです(読者のための演習として残しておきます...)。</target>
        </trans-unit>
        <trans-unit id="7872f5590df64a34d5d83302b83736d78de377e5" translate="yes" xml:space="preserve">
          <source>Since version 2.1.6, &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; can be exclusive, following the syntax of &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">バージョン2.1.6以降、&lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;の構文に従って、 &lt;code&gt;min&lt;/code&gt; と &lt;code&gt;max&lt;/code&gt; を排他的にすることができます。</target>
        </trans-unit>
        <trans-unit id="62c6108c3b6b3ae8ea558c2fa3e4a664136371f3" translate="yes" xml:space="preserve">
          <source>Since version 6.2 it is possible to filter entries by their idle-time, given in milliseconds (useful for &lt;code&gt;XCLAIM&lt;/code&gt;ing entries that have not been processed for some time):</source>
          <target state="translated">バージョン6.2以降、ミリ秒単位で指定されたアイドル時間でエントリをフィルタリングすることができます（しばらく処理されていないエントリを &lt;code&gt;XCLAIM&lt;/code&gt; する場合に便利です）。</target>
        </trans-unit>
        <trans-unit id="1c1d2abc7675af0239fa910c466960e644589788" translate="yes" xml:space="preserve">
          <source>Single number: 3894</source>
          <target state="translated">単数:3894</target>
        </trans-unit>
        <trans-unit id="f4a53209e61b36ab81faa5f943fba8e855032018" translate="yes" xml:space="preserve">
          <source>Skip sorting the elements</source>
          <target state="translated">要素のソートをスキップ</target>
        </trans-unit>
        <trans-unit id="8eab09bbd450823e91103eb2aaa19c7c3697409f" translate="yes" xml:space="preserve">
          <source>So for example the command &lt;code&gt;GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST&lt;/code&gt; will return each item in the following way:</source>
          <target state="translated">たとえば、コマンド &lt;code&gt;GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST&lt;/code&gt; は、次のように各アイテムを返します。</target>
        </trans-unit>
        <trans-unit id="76d0f19de574ac1304a0b3b169f72caa92244d72" translate="yes" xml:space="preserve">
          <source>So for instance, to get all the elements from the higher ID to the lower ID one could use:</source>
          <target state="translated">そのため、例えば、高い方のIDから低い方のIDまでのすべての要素を取得するには、以下のような方法があります。</target>
        </trans-unit>
        <trans-unit id="605cfa3fd340ae3e5e756672779740b80a689628" translate="yes" xml:space="preserve">
          <source>So in order for a given node to accept another one into the list of nodes composing a Redis Cluster, there are only two ways:</source>
          <target state="translated">そのため、あるノードがRedisクラスタを構成するノードのリストに別のノードを受け入れるためには、2つの方法しかありません。</target>
        </trans-unit>
        <trans-unit id="2350b72b46e64aeb370c2cbfa4c601de95c3d620" translate="yes" xml:space="preserve">
          <source>So we start with a list of keys, and later continue with all the associated IDs, representing &lt;em&gt;the last ID we received for that stream&lt;/em&gt;, so that the call will serve us only greater IDs from the same stream.</source>
          <target state="translated">したがって、キーのリストから開始し、その後&lt;em&gt;、そのストリームに対して受け取った最後のIDを&lt;/em&gt;表すすべての関連IDに進み&lt;em&gt;ます&lt;/em&gt;。これにより、呼び出しは同じストリームからのより大きなIDのみを処理します。</target>
        </trans-unit>
        <trans-unit id="46ddca2244f21f2b27c1eb6025f1e694d4b8bea0" translate="yes" xml:space="preserve">
          <source>So what the command really does is:</source>
          <target state="translated">だから、コマンドが実際に何をするかというと</target>
        </trans-unit>
        <trans-unit id="f434d4f52b4b99882f1b83c63bcdd004df128d69" translate="yes" xml:space="preserve">
          <source>So, if we link node A with node B via &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;, and B with C, A and C will find their ways to handshake and create a link.</source>
          <target state="translated">したがって、&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;を介してノードAをノードBにリンクし、BをCにリンクすると、AとCはハンドシェイクしてリンクを作成する方法を見つけます。</target>
        </trans-unit>
        <trans-unit id="60790236df4f5916ea98a7288f81aafe33a99ab5" translate="yes" xml:space="preserve">
          <source>So, using &lt;code&gt;CONFIG SET-CONFIG-EPOCH&lt;/code&gt;, when a new cluster is created, we can assign a different progressive configuration epoch to each node before joining the cluster together.</source>
          <target state="translated">したがって、 &lt;code&gt;CONFIG SET-CONFIG-EPOCH&lt;/code&gt; を使用すると、新しいクラスターが作成されたときに、クラスターを結合する前に各ノードに異なるプログレッシブ構成エポックを割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="f4318ce82f602a680da3fd3d1f1b92cbeae45d01" translate="yes" xml:space="preserve">
          <source>So, we want to say, give me the first element starting from the tail of the list:</source>
          <target state="translated">つまり、リストの最後尾から始まる最初の要素をくれと言いたいのです。</target>
        </trans-unit>
        <trans-unit id="173217936882f8d5719c8defa86bf0d23eac51fe" translate="yes" xml:space="preserve">
          <source>Some Redis commands have no predetermined key locations. For those commands, flag &lt;code&gt;movablekeys&lt;/code&gt; is added to the command flags &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;. Your Redis Cluster client needs to parse commands marked &lt;code&gt;movablekeys&lt;/code&gt; to locate all relevant key positions.</source>
          <target state="translated">一部のRedisコマンドには、キーの場所が事前に定義されていません。これらのコマンドでは、フラグ &lt;code&gt;movablekeys&lt;/code&gt; がコマンドフラグの&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;配列応答に&lt;/a&gt;追加されます。Redisクラスタークライアントは、すべての関連するキーの位置を見つけるために、 &lt;code&gt;movablekeys&lt;/code&gt; とマークされたコマンドを解析する必要があります。</target>
        </trans-unit>
        <trans-unit id="ddceed7fe40007b57317ba7df983076bcd185123" translate="yes" xml:space="preserve">
          <source>Some consumer A reads a message via &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; from a stream, in the context of that consumer group.</source>
          <target state="translated">一部のコンシューマーA は、そのコンシューマーグループのコンテキストで、ストリームから&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;を介してメッセージを読み取ります。</target>
        </trans-unit>
        <trans-unit id="28d440075fc880e5ff5b66c8a65009bc3be5acfb" translate="yes" xml:space="preserve">
          <source>Sometimes it can be useful for clients to completely disable replies from the Redis server. For example when the client sends fire and forget commands or performs a mass loading of data, or in caching contexts where new data is streamed constantly. In such contexts to use server time and bandwidth in order to send back replies to clients, which are going to be ignored, is considered wasteful.</source>
          <target state="translated">クライアントがRedisサーバからの返信を完全に無効にすることが有用な場合もあります。例えば、クライアントが fire and forget コマンドを送信したり、データの大量ロードを行ったり、新しいデータが常にストリーミングされるようなキャッシングのコンテキストでは、そのような場合には、サーバの時間と帯域幅を使用します。このような状況では、無視されそうな返信をクライアントに送り返すためにサーバの時間と帯域幅を使うのは無駄なことだと考えられます。</target>
        </trans-unit>
        <trans-unit id="a1fbf7ca3941093b616976378d4450adc4f2adb7" translate="yes" xml:space="preserve">
          <source>Sometimes it may be useful to remove old consumers since they are no longer used. This form returns the number of pending messages that the consumer had before it was deleted.</source>
          <target state="translated">古いコンシューマはもう使われていないので、削除した方が便利な場合もあります。このフォームは、削除される前にその消費者が持っていた保留中のメッセージの数を返します。</target>
        </trans-unit>
        <trans-unit id="295b7c77aec21f1ec78f8bb6debbc23501dae53f" translate="yes" xml:space="preserve">
          <source>Sometimes we need just the length of the match:</source>
          <target state="translated">試合の長さだけでも必要な時もある。</target>
        </trans-unit>
        <trans-unit id="0a212e08b7709fdef0e43a6ae14d5840bfa05846" translate="yes" xml:space="preserve">
          <source>Sometimes we want to return not just the Nth matching element, but the position of all the first N matching elements. This can be achieved using the &lt;code&gt;COUNT&lt;/code&gt; option.</source>
          <target state="translated">N番目の一致する要素だけでなく、最初のN個の一致する要素すべての位置を返したい場合があります。これは、 &lt;code&gt;COUNT&lt;/code&gt; オプションを使用して実現できます。</target>
        </trans-unit>
        <trans-unit id="43292f17e4e5fce7b6e4920a4500928789cc3b9d" translate="yes" xml:space="preserve">
          <source>Sometimes you want to sort elements using external keys as weights to compare instead of comparing the actual elements in the list, set or sorted set. Let's say the list &lt;code&gt;mylist&lt;/code&gt; contains the elements &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; representing unique IDs of objects stored in &lt;code&gt;object_1&lt;/code&gt;, &lt;code&gt;object_2&lt;/code&gt; and &lt;code&gt;object_3&lt;/code&gt;. When these objects have associated weights stored in &lt;code&gt;weight_1&lt;/code&gt;, &lt;code&gt;weight_2&lt;/code&gt; and &lt;code&gt;weight_3&lt;/code&gt;, &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; can be instructed to use these weights to sort &lt;code&gt;mylist&lt;/code&gt; with the following statement:</source>
          <target state="translated">リスト、セット、またはソート済みセットの実際の要素を比較するのではなく、外部キーを重みとして使用して要素をソートしたい場合があります。リストを言ってみましょう &lt;code&gt;mylist&lt;/code&gt; 要素が含ま &lt;code&gt;1&lt;/code&gt; 、 &lt;code&gt;2&lt;/code&gt; 及び &lt;code&gt;3&lt;/code&gt; に格納されているオブジェクトのユニークなIDを表す &lt;code&gt;object_1&lt;/code&gt; 、 &lt;code&gt;object_2&lt;/code&gt; と &lt;code&gt;object_3&lt;/code&gt; を。これらのオブジェクトに &lt;code&gt;weight_1&lt;/code&gt; 、 &lt;code&gt;weight_2&lt;/code&gt; 、および &lt;code&gt;weight_3&lt;/code&gt; に格納された重みが関連付けられている場合、次のステートメントでこれらの重みを使用して &lt;code&gt;mylist&lt;/code&gt; をソートするように&lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt;に指示できます。</target>
        </trans-unit>
        <trans-unit id="b2397d818d7562914c5b062b54f97e833db314f2" translate="yes" xml:space="preserve">
          <source>Sorted Sets</source>
          <target state="translated">ソートされたセット</target>
        </trans-unit>
        <trans-unit id="25ab5e6a0d5f2c9c6bc25d348c156dc61d5c8552" translate="yes" xml:space="preserve">
          <source>Sorted Sets can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;skiplist&lt;/code&gt; format. As for the List type small sorted sets can be specially encoded using &lt;code&gt;ziplist&lt;/code&gt;, while the &lt;code&gt;skiplist&lt;/code&gt; encoding is the one that works with sorted sets of any size.</source>
          <target state="translated">ソートされたセットは、 &lt;code&gt;ziplist&lt;/code&gt; または &lt;code&gt;skiplist&lt;/code&gt; 形式としてエンコードできます。リストタイプについては、小さいソートセットは &lt;code&gt;ziplist&lt;/code&gt; を使用して特別にエンコードできますが、 &lt;code&gt;skiplist&lt;/code&gt; エンコーディングは、任意のサイズのソートセットで機能します。</target>
        </trans-unit>
        <trans-unit id="86e387fe2a33fb39f76cfff98ea344b952f84a62" translate="yes" xml:space="preserve">
          <source>Sorted sets 101</source>
          <target state="translated">ソートされたセット101</target>
        </trans-unit>
        <trans-unit id="785f83ba9125723b72d2c573196ef8beabb345a8" translate="yes" xml:space="preserve">
          <source>Sorted sets are sorted by their score in an ascending way. The same element only exists a single time, no repeated elements are permitted. The score can be modified both by &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; that will update the element score, and as a side effect, its position on the sorted set, and by &lt;a href=&quot;zincrby&quot;&gt;ZINCRBY&lt;/a&gt; that can be used in order to update the score relatively to its previous value.</source>
          <target state="translated">ソートされたセットは、スコアによって昇順でソートされます。同じ要素は1回だけ存在し、繰り返しの要素は許可されません。スコアは、要素のスコアを更新する&lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt;と副作用としてのソート済みセット上の位置、および以前の値と比較してスコアを更新するために使用できる&lt;a href=&quot;zincrby&quot;&gt;ZINCRBYの両方&lt;/a&gt;によって変更できます。</target>
        </trans-unit>
        <trans-unit id="2f2a07b6f7677455f1b32d657bbc8366bfa48bf3" translate="yes" xml:space="preserve">
          <source>Sorting by external keys</source>
          <target state="translated">外部キーによるソート</target>
        </trans-unit>
        <trans-unit id="614fb399b6728ae041f21780ab6202d98e11c79a" translate="yes" xml:space="preserve">
          <source>Special conditions not allowing the command execution</source>
          <target state="translated">コマンドの実行を許可しない特殊条件</target>
        </trans-unit>
        <trans-unit id="0869a917cb9ab140bb00f5d52e7332ad6727fd9a" translate="yes" xml:space="preserve">
          <source>Special slot entries</source>
          <target state="translated">特別なスロットのエントリー</target>
        </trans-unit>
        <trans-unit id="549c2b56d95e908566338d2fd5914a21fd08d936" translate="yes" xml:space="preserve">
          <source>Specifically if a given write is transferred to one or more replicas, it is more likely (but not guaranteed) that if the master fails, we'll be able to promote, during a failover, a replica that received the write: both Sentinel and Redis Cluster will do a best-effort attempt to promote the best replica among the set of available replicas.</source>
          <target state="translated">具体的には、ある書き込みが1つ以上のレプリカに転送された場合、マスターに障害が発生した場合、フェイルオーバー中に書き込みを受けたレプリカをプロモートできる可能性が高くなります (保証はされませんが)。</target>
        </trans-unit>
        <trans-unit id="d526406a65071e1fec15bd4174751e7a5bc387d7" translate="yes" xml:space="preserve">
          <source>Specifically this is what Redis does 10 times per second:</source>
          <target state="translated">具体的には、これがRedisが1秒間に10回行うことです。</target>
        </trans-unit>
        <trans-unit id="2fa9940f1d66c2c57fbda5e1ef12bce097cf18d3" translate="yes" xml:space="preserve">
          <source>Specifically, it lists the user's ACL flags, password hashes and key name patterns. Note that command rules are returned as a string in the same format used with the &lt;a href=&quot;acl-setuser&quot;&gt;ACL SETUSER&lt;/a&gt; command. This description of command rules reflects the user's effective permissions, so while it may not be identical to the set of rules used to configure the user, it is still functionally identical.</source>
          <target state="translated">具体的には、ユーザーのACLフラグ、パスワードハッシュ、およびキー名のパターンが一覧表示されます。コマンドルールは、&lt;a href=&quot;acl-setuser&quot;&gt;ACLSETUSER&lt;/a&gt;コマンドで使用されるのと同じ形式の文字列として返されることに注意してください。このコマンドルールの説明は、ユーザーの有効なアクセス許可を反映しているため、ユーザーの構成に使用される一連のルールと同じではない場合がありますが、機能的には同じです。</target>
        </trans-unit>
        <trans-unit id="d9ff7d39e693899b2fb01c2af7e0b9aad8efd43b" translate="yes" xml:space="preserve">
          <source>Specifically:</source>
          <target state="translated">Specifically:</target>
        </trans-unit>
        <trans-unit id="37ec7d989573caff7ef9f45953dba8d022709000" translate="yes" xml:space="preserve">
          <source>Specification of the behavior when count is passed</source>
          <target state="translated">カウントが渡されたときの動作の指定</target>
        </trans-unit>
        <trans-unit id="14c30af049c8842dbcbd1159d5db60d5f0981029" translate="yes" xml:space="preserve">
          <source>Specifying a Stream ID as an argument</source>
          <target state="translated">ストリームIDを引数に指定する</target>
        </trans-unit>
        <trans-unit id="1544a5bc78a2aee56854818668d14afd235ec6c9" translate="yes" xml:space="preserve">
          <source>Start slot range</source>
          <target state="translated">開始スロット範囲</target>
        </trans-unit>
        <trans-unit id="ee455845986f290115764586b0c8b62db6794d99" translate="yes" xml:space="preserve">
          <source>Starting from Redis version 2.6, when called with the additional &lt;code&gt;count&lt;/code&gt; argument, return an array of &lt;code&gt;count&lt;/code&gt;&lt;strong&gt;distinct elements&lt;/strong&gt; if &lt;code&gt;count&lt;/code&gt; is positive. If called with a negative &lt;code&gt;count&lt;/code&gt; the behavior changes and the command is allowed to return the &lt;strong&gt;same element multiple times&lt;/strong&gt;. In this case the number of returned elements is the absolute value of the specified &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">Redisバージョン2.6以降、追加の &lt;code&gt;count&lt;/code&gt; 引数を指定して呼び出された場合、 &lt;code&gt;count&lt;/code&gt; が正の場合、 &lt;code&gt;count&lt;/code&gt; 個の&lt;strong&gt;異なる要素の&lt;/strong&gt;配列を返します。負の &lt;code&gt;count&lt;/code&gt; 呼び出されると、動作が変化し、コマンドは&lt;strong&gt;同じ要素を複数回&lt;/strong&gt;返すことができます。この場合、返される要素の数は、指定された &lt;code&gt;count&lt;/code&gt; 絶対値です。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83f9c28598d952311fc09fa54e334ed57a68832b" translate="yes" xml:space="preserve">
          <source>Starting with Redis 2.6.12 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; supports a set of options that modify its behavior:</source>
          <target state="translated">Redis 2.6.12以降、&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;はその動作を変更する一連のオプションをサポートしています。</target>
        </trans-unit>
        <trans-unit id="f154b597ac1178d82fc4c50afc3e83d654688468" translate="yes" xml:space="preserve">
          <source>Starting with Redis 2.8 the return value in case of error changed:</source>
          <target state="translated">Redis 2.8からエラー時の戻り値が変更されました。</target>
        </trans-unit>
        <trans-unit id="cb9c10a639cbbf2b71b38cd0e777ffb915ed4e8b" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.0.6 &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; supports a new bulk-migration mode that uses pipelining in order to migrate multiple keys between instances without incurring in the round trip time latency and other overheads that there are when moving each key with a single &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; call.</source>
          <target state="translated">Redis 3.0.6以降、&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;は、パイプラインを使用する新しい一括移行モードをサポートしています。この一括移行モードでは、単一の&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;呼び出しで各キーを移動するときに発生するラウンドトリップ時間のレイテンシやその他のオーバーヘッドを発生させることなく、インスタンス間で複数のキーを移行します。</target>
        </trans-unit>
        <trans-unit id="6578980d36f8246047edd57af78a6f9934454cea" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.2, Redis has support for native Lua debugging. The Redis Lua debugger is a remote debugger consisting of a server, which is Redis itself, and a client, which is by default &lt;code&gt;redis-cli&lt;/code&gt;.</source>
          <target state="translated">Redis 3.2以降、RedisはネイティブLuaデバッグをサポートしています。Redis Luaデバッガーは、サーバー（Redis自体）とクライアント（デフォルトでは &lt;code&gt;redis-cli&lt;/code&gt; )で構成されるリモートデバッガーです。</target>
        </trans-unit>
        <trans-unit id="5b01b9bd2a097f98e87d6033b411073bab6691f7" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.2, it is possible to select an alternative replication method. Instead of replication whole scripts, we can just replicate single write commands generated by the script. We call this &lt;strong&gt;script effects replication&lt;/strong&gt;.</source>
          <target state="translated">Redis 3.2以降では、代替のレプリケーション方法を選択できます。スクリプト全体を複製する代わりに、スクリプトによって生成された単一の書き込みコマンドを複製することができます。この&lt;strong&gt;スクリプトをレプリケーション&lt;/strong&gt;と呼びます。</target>
        </trans-unit>
        <trans-unit id="2b5108a4d347209131d9cdaa00d48ad36bea64af" translate="yes" xml:space="preserve">
          <source>Starting with Redis version 6, the server supports two different protocols. One is called RESP2, and is the old protocol: all the new connections to the server start in this mode. However clients are able to negotiate the new protocol using the &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command: this way the connection is put in RESP3 mode. In this mode certain commands, like for instance &lt;a href=&quot;hgetall&quot;&gt;HGETALL&lt;/a&gt;, reply with a new data type (the Map data type in this specific case). The RESP3 protocol is semantically more powerful, however most scripts are OK with using just RESP2.</source>
          <target state="translated">Redisバージョン6以降、サーバーは2つの異なるプロトコルをサポートします。 1つはRESP2と呼ばれ、古いプロトコルです。サーバーへのすべての新しい接続はこのモードで開始されます。ただし、クライアントは&lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt;コマンドを使用して新しいプロトコルをネゴシエートできます。このようにして、接続はRESP3モードになります。このモードでは、たとえば&lt;a href=&quot;hgetall&quot;&gt;HGETALL&lt;/a&gt;などの特定のコマンドが、新しいデータ型（この特定の場合はMapデータ型）で応答します。 RESP3プロトコルは意味的に強力ですが、ほとんどのスクリプトはRESP2だけを使用しても問題ありません。</target>
        </trans-unit>
        <trans-unit id="1ffd355623442762e32037427cffdb34a18e3984" translate="yes" xml:space="preserve">
          <source>Step 4 does not technically need to use &lt;code&gt;SETSLOT&lt;/code&gt; in the nodes not involved in the resharding, since the configuration will eventually propagate itself, however it is a good idea to do so in order to stop nodes from pointing to the wrong node for the hash slot moved as soon as possible, resulting in less redirections to find the right node.</source>
          <target state="translated">ステップ4では、設定が最終的に自身を伝播するため、技術的には &lt;code&gt;SETSLOT&lt;/code&gt; に関与しないノードでSETSLOTを使用する必要はありませんが、ノードがハッシュスロットの間違ったノードを指すのを防ぐためにそうすることをお勧めしますできるだけ早く移動し、正しいノードを見つけるためのリダイレクトを減らしました。</target>
        </trans-unit>
        <trans-unit id="f75b76768d708a29fc0fb9becaf181931853bd99" translate="yes" xml:space="preserve">
          <source>Step Count</source>
          <target state="translated">ステップ数</target>
        </trans-unit>
        <trans-unit id="f7fa846d5511789adfec64aa9b8751f7351a0ca5" translate="yes" xml:space="preserve">
          <source>Stop all the clients.</source>
          <target state="translated">客を全員止めろ</target>
        </trans-unit>
        <trans-unit id="6cb759f69a54fcb63d47af649e368c12075f71be" translate="yes" xml:space="preserve">
          <source>Storing the result of a SORT operation</source>
          <target state="translated">SORT操作の結果を保存する</target>
        </trans-unit>
        <trans-unit id="df063869e11d7a9aa132cd4a984f7b5eb870d656" translate="yes" xml:space="preserve">
          <source>Stream</source>
          <target state="translated">Stream</target>
        </trans-unit>
        <trans-unit id="61c2b2148d7f362f23210527dbc1bd6b0437b131" translate="yes" xml:space="preserve">
          <source>Stream IDs are composed of two parts, a Unix millisecond time stamp and a sequence number for entries inserted in the same millisecond. It is possible to use &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; specifying just the first part of the ID, the millisecond time, like in the following example:</source>
          <target state="translated">ストリームIDは、Unixミリ秒のタイムスタンプと、同じミリ秒に挿入されたエントリのシーケンス番号の2つの部分で構成されています。次の例のように、&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;を使用して、IDの最初の部分であるミリ秒の時間のみを指定することができます。</target>
        </trans-unit>
        <trans-unit id="e577b53fb1794580c0560fa9502cf28744dcd504" translate="yes" xml:space="preserve">
          <source>Stream entries are returned, including fields and values.</source>
          <target state="translated">フィールドや値を含むストリームエントリが返されます。</target>
        </trans-unit>
        <trans-unit id="f7e700aeb9d8c3a456c6730300f1abde75268288" translate="yes" xml:space="preserve">
          <source>Streams are not auto-deleted once they have no entries inside (for instance after an &lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt; call), because the stream may have consumer groups associated with it.</source>
          <target state="translated">ストリームにエントリがない場合（&lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt;呼び出し後など）、ストリームにはコンシューマグループが関連付けられている可能性があるため、ストリームは自動削除されません。</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="48c2711e04347f7b6d1ddd6b4a79296a8d2830ea" translate="yes" xml:space="preserve">
          <source>Strings are compared as binary array of bytes. Because of how the ASCII character set is specified, this means that usually this also have the effect of comparing normal ASCII characters in an obvious dictionary way. However this is not true if non plain ASCII strings are used (for example utf8 strings).</source>
          <target state="translated">文字列はバイトのバイナリ配列として比較されます。ASCII 文字セットがどのように指定されているかによって、通常は通常の ASCII 文字を辞書的に比較する効果があることを意味します。しかし、プレーンでないASCII文字列(例えばutf8文字列)が使用されている場合はこの限りではありません。</target>
        </trans-unit>
        <trans-unit id="2593368d27635cc5293b7e53f7145a56dff05dd8" translate="yes" xml:space="preserve">
          <source>Strings can be encoded as &lt;code&gt;raw&lt;/code&gt; (normal string encoding) or &lt;code&gt;int&lt;/code&gt; (strings representing integers in a 64 bit signed interval are encoded in this way in order to save space).</source>
          <target state="translated">文字列は、 &lt;code&gt;raw&lt;/code&gt; （通常の文字列エンコーディング）または &lt;code&gt;int&lt;/code&gt; （64ビットの符号付き間隔の整数を表す文字列は、スペースを節約するためにこの方法でエンコードされます）としてエンコードできます。</target>
        </trans-unit>
        <trans-unit id="d5294ece475c0dd1b0e5c4f6f621c1e0c0bf7039" translate="yes" xml:space="preserve">
          <source>Strings with a similar prefix are nearby, but the contrary is not true, it is possible that strings with different prefixes are nearby too.</source>
          <target state="translated">接頭辞が似ている文字列が近くにありますが、逆に接頭辞が違う文字列も近くにある可能性があります。</target>
        </trans-unit>
        <trans-unit id="3f9d46e5fb83a7700b4c788a03b12a80a7e61e08" translate="yes" xml:space="preserve">
          <source>Subcommand &lt;code&gt;encoding&lt;/code&gt; returns a bulk reply.</source>
          <target state="translated">サブコマンドの &lt;code&gt;encoding&lt;/code&gt; は、バルク応答を返します。</target>
        </trans-unit>
        <trans-unit id="03e52fefcd721e1070e1756817dc5fb3908630a4" translate="yes" xml:space="preserve">
          <source>Subcommands &lt;code&gt;refcount&lt;/code&gt; and &lt;code&gt;idletime&lt;/code&gt; return integers.</source>
          <target state="translated">サブコマンド &lt;code&gt;refcount&lt;/code&gt; および &lt;code&gt;idletime&lt;/code&gt; は整数を返します。</target>
        </trans-unit>
        <trans-unit id="9cdf88a718c3f491225fa1cc2fd76602c7208ad1" translate="yes" xml:space="preserve">
          <source>Subscribes the client to the given patterns.</source>
          <target state="translated">クライアントを指定されたパターンにサブスクライブします。</target>
        </trans-unit>
        <trans-unit id="481c5cf231fde7f8730860922d6f3194fc5f2170" translate="yes" xml:space="preserve">
          <source>Subscribes the client to the specified channels.</source>
          <target state="translated">指定したチャンネルにクライアントをサブスクライブします。</target>
        </trans-unit>
        <trans-unit id="4a47fd9934d349f948abbf361726590ff096c6b8" translate="yes" xml:space="preserve">
          <source>Summary form of XPENDING</source>
          <target state="translated">XPENDENDINGの概要</target>
        </trans-unit>
        <trans-unit id="dfe7ee6f8d575326187ecdb8ea7e6fb7cbf4ec35" translate="yes" xml:space="preserve">
          <source>Supported glob-style patterns:</source>
          <target state="translated">グロブスタイルのパターンをサポートしました。</target>
        </trans-unit>
        <trans-unit id="ced890cac00d712740bdc4d39c1db48f7483c499" translate="yes" xml:space="preserve">
          <source>Supported subcommands and integer types</source>
          <target state="translated">サポートされているサブコマンドと整数型</target>
        </trans-unit>
        <trans-unit id="108e22a5749de8f07b0272d8029eeb2811ea28dd" translate="yes" xml:space="preserve">
          <source>Switch the connection to a different protocol. Redis version 6 or greater are able to support two protocols, the old protocol, RESP2, and a new one introduced with Redis 6, RESP3. RESP3 has certain advantages since when the connection is in this mode, Redis is able to reply with more semantical replies: for instance &lt;a href=&quot;hgetall&quot;&gt;HGETALL&lt;/a&gt; will return a &lt;em&gt;map type&lt;/em&gt;, so a client library implementation no longer requires to know in advance to translate the array into a hash before returning it to the caller. For a full coverage of RESP3 please &lt;a href=&quot;https://github.com/antirez/resp3&quot;&gt;check this repository&lt;/a&gt;.</source>
          <target state="translated">接続を別のプロトコルに切り替えます。 Redisバージョン6以降は、古いプロトコルであるRESP2と、Redis 6で導入された新しいプロトコルであるRESP3の2つのプロトコルをサポートできます。 RESP3には、接続がこのモードの場合、Redis&lt;a href=&quot;hgetall&quot;&gt;がより&lt;/a&gt;セマンティックな応答で応答できるため、特定の利点があります。たとえば、HGETALLは&lt;em&gt;マップタイプ&lt;/em&gt;を返すため、クライアントライブラリの実装では、配列をに変換するために事前に知る必要がなくなります。呼び出し元に返す前にハッシュします。 RESP3の完全なカバレッジについては、&lt;a href=&quot;https://github.com/antirez/resp3&quot;&gt;このリポジトリ&lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="b8398e47e81dab008569a234703960eb8bab2f11" translate="yes" xml:space="preserve">
          <source>TAKEOVER option: manual failover without cluster consensus</source>
          <target state="translated">TAKEOVERオプション:クラスタコンセンサスなしの手動フェイルオーバー</target>
        </trans-unit>
        <trans-unit id="64269f9bd268bf28815bb69e82601cd7e806a37b" translate="yes" xml:space="preserve">
          <source>TIME</source>
          <target state="translated">TIME</target>
        </trans-unit>
        <trans-unit id="8696f7a4c64b4516c2d96434e8b7824957a37d2a" translate="yes" xml:space="preserve">
          <source>TIME   Return the current server time</source>
          <target state="translated">TIME 現在のサーバーの時刻を返します。</target>
        </trans-unit>
        <trans-unit id="c701f5f92060225c236ac0e6b3051e03bb0ad061" translate="yes" xml:space="preserve">
          <source>TOUCH</source>
          <target state="translated">TOUCH</target>
        </trans-unit>
        <trans-unit id="ad5ae533c502772151a704d28a2bece0e0f4ca1b" translate="yes" xml:space="preserve">
          <source>TOUCH  key [key ...]   Alters the last access time of a key(s). Returns the number of existing keys specified.</source>
          <target state="translated">TOUCH key [key ...]キーの最終アクセス時刻を変更します。指定した既存のキーの数を返します。</target>
        </trans-unit>
        <trans-unit id="878260dfb888c3312c119e6db2253c2aa207ae98" translate="yes" xml:space="preserve">
          <source>TTL</source>
          <target state="translated">TTL</target>
        </trans-unit>
        <trans-unit id="8ef7742bd419d3406904eb9723c6ce85d49c0f81" translate="yes" xml:space="preserve">
          <source>TTL  key   Get the time to live for a key</source>
          <target state="translated">TTLキー 鍵のために生きる時間を手に入れる</target>
        </trans-unit>
        <trans-unit id="6e9816a8e9d0388eecdb52866188c04e75e4b1b3" translate="yes" xml:space="preserve">
          <source>TYPE</source>
          <target state="translated">TYPE</target>
        </trans-unit>
        <trans-unit id="7d0cfb250d49bba162e019907ea71cfcab32d9f4" translate="yes" xml:space="preserve">
          <source>TYPE  key   Determine the type stored at key</source>
          <target state="translated">TYPE キー キーに格納されているタイプを決定します。</target>
        </trans-unit>
        <trans-unit id="5bbc08d2de04a7034dc9edbe2e20759367a5f82f" translate="yes" xml:space="preserve">
          <source>Taking a separated key that is incremented every time the bitmap is modified. This can be very efficient and atomic using a small Redis Lua script.</source>
          <target state="translated">分離されたキーを取り、ビットマップが変更されるたびにインクリメントされます。これは、小さなRedis Luaスクリプトを使用することで、非常に効率的でアトミックなものになります。</target>
        </trans-unit>
        <trans-unit id="8b5d4fb8b75675d300f4de7425675abc3149473f" translate="yes" xml:space="preserve">
          <source>Terminating iterations in the middle</source>
          <target state="translated">イテレーションを途中で終了させる</target>
        </trans-unit>
        <trans-unit id="8a78f0cb0822107a63b906522f8970fb02d3906a" translate="yes" xml:space="preserve">
          <source>Test 20 random keys from the set of keys with an associated expire.</source>
          <target state="translated">関連する期限切れの鍵のセットから20個のランダムな鍵をテストします。</target>
        </trans-unit>
        <trans-unit id="0c0c5f66ed89ad8b7f73f25128b137a4d67fcbb8" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; and the analogous &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; commands, you can use Redis strings as a linear array with O(1) random access. This is a very fast and efficient storage in many real world use cases.</source>
          <target state="translated">&lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt;と類似の&lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt;コマンドのおかげで、Redis文字列をO（1）ランダムアクセスの線形配列として使用できます。これは、多くの実際の使用例で非常に高速で効率的なストレージです。</target>
        </trans-unit>
        <trans-unit id="8026b8ed5921c819cac7c44288be64954a1b0af5" translate="yes" xml:space="preserve">
          <source>That is, the second occurrence of &quot;c&quot; is at position 6. A negative &quot;rank&quot; as the &lt;code&gt;RANK&lt;/code&gt; argument tells &lt;a href=&quot;lpos&quot;&gt;LPOS&lt;/a&gt; to invert the search direction, starting from the tail to the head.</source>
          <target state="translated">つまり、「c」の2番目のオカレンスは位置6にあります &lt;code&gt;RANK&lt;/code&gt; 引数としての負の「ランク」は、&lt;a href=&quot;lpos&quot;&gt;LPOS&lt;/a&gt;に、尾から頭に向かって検索方向を反転するように指示します。</target>
        </trans-unit>
        <trans-unit id="733be8ce43bb740e68f58527c40732d288c9eb0b" translate="yes" xml:space="preserve">
          <source>That said, &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; can be used, and was historically used, as a locking primitive. For example, to acquire the lock of the key &lt;code&gt;foo&lt;/code&gt;, the client could try the following:</source>
          <target state="translated">そうは言っても、&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;はロックプリミティブとして使用でき、歴史的に使用されていました。たとえば、キー &lt;code&gt;foo&lt;/code&gt; のロックを取得するために、クライアントは次のことを試すことができます。</target>
        </trans-unit>
        <trans-unit id="b0aa14a2afe89147b651f01c25f18c35b9adb8d8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;acl-help&quot;&gt;ACL HELP&lt;/a&gt; command returns a helpful text describing the different subcommands.</source>
          <target state="translated">&lt;a href=&quot;acl-help&quot;&gt;ACL HELPの&lt;/a&gt;コマンドは、異なるサブコマンドを記述する役立つテキストを返します。</target>
        </trans-unit>
        <trans-unit id="77d6d135447dbf512e1ae2af8102405447c9f874" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; command can be used to create a very compact representation of a list of fixed-size samples, usually referred as &lt;em&gt;time series&lt;/em&gt;. Every time a new sample arrives we can store it using the command</source>
          <target state="translated">&lt;a href=&quot;append&quot;&gt;APPENDの&lt;/a&gt;コマンドは、固定サイズのサンプルのリストの非常にコンパクトな表現を作成するために使用することができ、通常と呼ば&lt;em&gt;時系列&lt;/em&gt;。新しいサンプルが到着するたびに、次のコマンドを使用して保存できます</target>
        </trans-unit>
        <trans-unit id="af3680004f1f3af89a74cfdd597524f1d5b57aa0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; command supports four bitwise operations: &lt;strong&gt;AND&lt;/strong&gt;, &lt;strong&gt;OR&lt;/strong&gt;, &lt;strong&gt;XOR&lt;/strong&gt; and &lt;strong&gt;NOT&lt;/strong&gt;, thus the valid forms to call the command are:</source>
          <target state="translated">&lt;a href=&quot;bitop&quot;&gt;BITOPの&lt;/a&gt;コマンドは、4ビット単位の操作をサポートします。&lt;strong&gt;AND&lt;/strong&gt;、&lt;strong&gt;OR&lt;/strong&gt;、&lt;strong&gt;XOR&lt;/strong&gt;および&lt;strong&gt;NOT&lt;/strong&gt;、これコマンドを呼び出すための有効な形式は以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="4dd66d959585425a19858f722e901be8748f987c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt; returns the name of the current connection as set by &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt;. Since every new connection starts without an associated name, if no name was assigned a null bulk reply is returned.</source>
          <target state="translated">&lt;a href=&quot;client-getname&quot;&gt;クライアントGETNAMEは&lt;/a&gt;によって設定された現在の接続の名前を返す&lt;a href=&quot;client-setname&quot;&gt;クライアントSETNAMEを&lt;/a&gt;。新しい接続はすべて関連付けられた名前なしで開始されるため、名前が割り当てられていない場合は、nullバルク応答が返されます。</target>
        </trans-unit>
        <trans-unit id="1660d56ff9988d9b97b8e4b556121bfa1958f2dd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-kill&quot;&gt;CLIENT KILL&lt;/a&gt; command closes a given client connection. This command support two formats, the old format:</source>
          <target state="translated">&lt;a href=&quot;client-kill&quot;&gt;クライアントのKILL&lt;/a&gt;コマンドは、指定されたクライアント接続を閉じます。このコマンドは、古い形式の2つの形式をサポートします。</target>
        </trans-unit>
        <trans-unit id="77571e239b6c4924e5ae8625b133ece1b2fb165b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-kill&quot;&gt;CLIENT KILL&lt;/a&gt; command closes a given client connection. Up to Redis 2.8.11 it was possible to close a connection only by client address, using the following form:</source>
          <target state="translated">&lt;a href=&quot;client-kill&quot;&gt;クライアントのKILL&lt;/a&gt;コマンドは、指定されたクライアント接続を閉じます。Redis 2.8.11までは、次の形式を使用して、クライアントアドレスによってのみ接続を閉じることができました。</target>
        </trans-unit>
        <trans-unit id="c0d7e72efd1901513aa26d76fc6efa880b0ffcd7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; command returns information and statistics about the client connections server in a mostly human readable format.</source>
          <target state="translated">&lt;a href=&quot;client-list&quot;&gt;クライアントリストの&lt;/a&gt;コマンドは、主に人間が読める形式でクライアント接続サーバーに関する情報と統計を返します。</target>
        </trans-unit>
        <trans-unit id="99ea497bab9ec2eb991df932e164aeadc0d98009" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-reply&quot;&gt;CLIENT REPLY&lt;/a&gt; command controls whether the server will reply the client's commands. The following modes are available:</source>
          <target state="translated">&lt;a href=&quot;client-reply&quot;&gt;クライアントREPLYの&lt;/a&gt;コマンドコントロールは、サーバーはクライアントのコマンドを返信しますか。次のモードを使用できます。</target>
        </trans-unit>
        <trans-unit id="66ef05bc81ce96b58454a695580464830edc9445" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; command assigns a name to the current connection.</source>
          <target state="translated">&lt;a href=&quot;client-setname&quot;&gt;クライアントSETNAMEの&lt;/a&gt;コマンドは、現在の接続に名前を割り当てます。</target>
        </trans-unit>
        <trans-unit id="43f3ab9bcc1ea0150ec08bf3548ed1a84c95f9e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-bumpepoch&quot;&gt;CLUSTER BUMPEPOCH&lt;/a&gt; command triggers an increment to the cluster's config epoch from the connected node. The epoch will be incremented if the node's config epoch is zero, or if it is less than the cluster's greatest epoch.</source>
          <target state="translated">&lt;a href=&quot;cluster-bumpepoch&quot;&gt;CLUSTER BUMPEPOCHの&lt;/a&gt;コマンドは、接続されたノードからクラスタのconfigエポックの増分をトリガーします。ノードの構成エポックがゼロの場合、またはクラスターの最大エポックよりも小さい場合、エポックは増分されます。</target>
        </trans-unit>
        <trans-unit id="7c5540561e37398d0ed7b865d91ceff7a71f6377" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-flushslots&quot;&gt;CLUSTER FLUSHSLOTS&lt;/a&gt; deletes all information about slots from the connected node. It can only be called when the database is empty.</source>
          <target state="translated">&lt;a href=&quot;cluster-flushslots&quot;&gt;CLUSTER FLUSHSLOTSは、&lt;/a&gt;接続されたノードからスロットに関するすべての情報を削除します。データベースが空の場合にのみ呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="1ca5f595e917e610d79a666d6599f3f325569dcf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-myid&quot;&gt;CLUSTER MYID&lt;/a&gt; command returns the unique, auto-generated identifier that is associated with the connected cluster node.</source>
          <target state="translated">&lt;a href=&quot;cluster-myid&quot;&gt;CLUSTERのMYIDの&lt;/a&gt;コマンドは、接続されたクラスタ・ノードに関連付けられている固有の、自動生成された識別子を返します。</target>
        </trans-unit>
        <trans-unit id="29ca3ac0a9d2f6b99b3b3cfed122170d73c27a26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; command is an important piece used by Redis Cluster in order to migrate all the keys contained in one hash slot from one node to another. This is how the migration is orchestrated, with the help of other commands as well. We'll call the node that has the current ownership of the hash slot the &lt;code&gt;source&lt;/code&gt; node, and the node where we want to migrate the &lt;code&gt;destination&lt;/code&gt; node.</source>
          <target state="translated">&lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTERのSETSLOTの&lt;/a&gt;コマンドは、1つのノードから別の1つのハッシュスロットに含まれるすべてのキーを移行するためにRedisのクラスタによって使用される重要な部分です。これは、他のコマンドを使用して移行を調整する方法です。ハッシュスロットの現在の所有権を持つノードを &lt;code&gt;source&lt;/code&gt; ノードと呼び、 &lt;code&gt;destination&lt;/code&gt; ノードを移行するノードと呼びます。</target>
        </trans-unit>
        <trans-unit id="9969254dbf9ad62d16ce54578a579c12bed90714" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; command is used to read the configuration parameters of a running Redis server. Not all the configuration parameters are supported in Redis 2.4, while Redis 2.6 can read the whole configuration of a server using this command.</source>
          <target state="translated">&lt;a href=&quot;config-get&quot;&gt;CONFIGのGETの&lt;/a&gt;コマンドが実行されているRedisのサーバーの構成パラメータを読み取るために使用されます。Redis 2.4ではすべての構成パラメーターがサポートされているわけではありませんが、Redis 2.6ではこのコマンドを使用してサーバーの構成全体を読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="b44e010365af8a822e0e64c895b3b9356396e69b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-rewrite&quot;&gt;CONFIG REWRITE&lt;/a&gt; command rewrites the &lt;code&gt;redis.conf&lt;/code&gt; file the server was started with, applying the minimal changes needed to make it reflect the configuration currently used by the server, which may be different compared to the original one because of the use of the &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;config-rewrite&quot;&gt;CONFIG REWRITEの&lt;/a&gt;コマンドが書き換えられ &lt;code&gt;redis.conf&lt;/code&gt; のための使用のオリジナルのものと比べて異なることがあり、それが現在のサーバで使用される設定を反映させるために必要な最小限の変更、適用し、サーバーがで開始されたファイルを&lt;a href=&quot;config-set&quot;&gt;CONFIG SETを&lt;/a&gt;コマンド。</target>
        </trans-unit>
        <trans-unit id="a94ff0d50f7b4db45f039a4dafafa3f4c9259a89" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command is used in order to reconfigure the server at run time without the need to restart Redis. You can change both trivial parameters or switch from one to another persistence option using this command.</source>
          <target state="translated">&lt;a href=&quot;config-set&quot;&gt;CONFIGのSET&lt;/a&gt;コマンドはRedisのを再起動することなく、実行時にサーバーを再構成するために使用されています。このコマンドを使用して、両方の簡単なパラメーターを変更するか、1つの永続化オプションから別の永続化オプションに切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="166c68e394d8ab06f1a3bb76f56f32a612a6683d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command forces you to send the script body again and again. Redis does not need to recompile the script every time as it uses an internal caching mechanism, however paying the cost of the additional bandwidth may not be optimal in many contexts.</source>
          <target state="translated">&lt;a href=&quot;eval&quot;&gt;EVALの&lt;/a&gt;コマンド部隊あなたは何度も何度もスクリプト本体を送信します。Redisは内部キャッシュメカニズムを使用するため、毎回スクリプトを再コンパイルする必要はありませんが、追加の帯域幅のコストを支払うことは、多くの状況で最適ではない場合があります。</target>
        </trans-unit>
        <trans-unit id="bd6411fae08a91e9b321232ed876a3d9070cad9b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; family of commands is able to associate an expire to a given key, at the cost of some additional memory used by the key. When a key has an expire set, Redis will make sure to remove the key when the specified amount of time elapsed.</source>
          <target state="translated">コマンドの&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;ファミリーは、キーによって使用される追加のメモリを犠牲にして、特定のキーに有効期限を関連付けることができます。キーに有効期限が設定されている場合、Redisは指定された時間が経過するとキーを削除するようにします。</target>
        </trans-unit>
        <trans-unit id="9537af381c721635428a198bca98f65d00f50bfa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command has a useful reply that will state a number of facts about the server: the exact version, the set of modules loaded, the client ID, the replication role and so forth. Because of that, and given that the &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command also works with &quot;2&quot; as argument, both in order to downgrade the protocol back to version 2, or just to get the reply from the server without switching the protocol, client library authors may consider using this command instead of the canonical &lt;a href=&quot;ping&quot;&gt;PING&lt;/a&gt; when setting up the connection.</source>
          <target state="translated">&lt;a href=&quot;hello&quot;&gt;ハロー&lt;/a&gt;など正確なバージョン、ロードされたモジュールのセットは、クライアントID、複製の役割と：コマンドは、サーバーについての事実の数を記載します有益な回答を持っています。そのため、また&lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt;コマンドが引数として「2」でも機能することを考えると、プロトコルをバージョン2にダウングレードするため、またはプロトコルを切り替えずにサーバーから応答を取得するために、クライアントライブラリの作成者は検討することができます。接続をセットアップするときに、正規の&lt;a href=&quot;ping&quot;&gt;PINGの&lt;/a&gt;代わりにこのコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="ae44c019fde6841c16a68c04d38047f2e0f60739" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command returns information and statistics about the server in a format that is simple to parse by computers and easy to read by humans.</source>
          <target state="translated">&lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;コンピュータで解析するシンプルで人間が読みやすい形式で、サーバーに関するコマンドが返す情報と統計。</target>
        </trans-unit>
        <trans-unit id="a72bec6083e79854302b4e9ff14a0e8f3e859562" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-doctor&quot;&gt;LATENCY DOCTOR&lt;/a&gt; command reports about different latency-related issues and advises about possible remedies.</source>
          <target state="translated">&lt;a href=&quot;latency-doctor&quot;&gt;LATENCY DOCTORの&lt;/a&gt;コマンド異なる遅延に関連する問題についてのレポートとは、可能な救済策についてアドバイスします。</target>
        </trans-unit>
        <trans-unit id="1066b09a9b25b6b6ed879ca10e517428a219419a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-help&quot;&gt;LATENCY HELP&lt;/a&gt; command returns a helpful text describing the different subcommands.</source>
          <target state="translated">&lt;a href=&quot;latency-help&quot;&gt;LATENCYヘルプ&lt;/a&gt;コマンドが異なるサブコマンドを記述する役立つテキストを返します。</target>
        </trans-unit>
        <trans-unit id="50807ff2bf2c847fd5988e426fdf8c05c9a36546" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-history&quot;&gt;LATENCY HISTORY&lt;/a&gt; command returns the raw data of the &lt;code&gt;event&lt;/code&gt;'s latency spikes time series.</source>
          <target state="translated">&lt;a href=&quot;latency-history&quot;&gt;LATENCYの歴史&lt;/a&gt;コマンドは、生データを返す &lt;code&gt;event&lt;/code&gt; の待ち時間のスパイク時系列を。</target>
        </trans-unit>
        <trans-unit id="52c78093ad61fe69ebb2499c714e0f2256697635" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-latest&quot;&gt;LATENCY LATEST&lt;/a&gt; command reports the latest latency events logged.</source>
          <target state="translated">&lt;a href=&quot;latency-latest&quot;&gt;LATENCY LATEST&lt;/a&gt;コマンドは、最新のレイテンシのイベントがログに記録報告します。</target>
        </trans-unit>
        <trans-unit id="147880a1d1ea91581373c0559cd3dfedfc864e5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-reset&quot;&gt;LATENCY RESET&lt;/a&gt; command resets the latency spikes time series of all, or only some, events.</source>
          <target state="translated">&lt;a href=&quot;latency-reset&quot;&gt;LATENCYリセット&lt;/a&gt;コマンドは、すべての待ち時間のスパイク時系列、または一部だけ、イベントをリセットします。</target>
        </trans-unit>
        <trans-unit id="34c3a5fba12b1ed2508a72f81c29ed6c56b41d88" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-doctor&quot;&gt;MEMORY DOCTOR&lt;/a&gt; command reports about different memory-related issues that the Redis server experiences, and advises about possible remedies.</source>
          <target state="translated">&lt;a href=&quot;memory-doctor&quot;&gt;MEMORYドクター&lt;/a&gt;異なるメモリ関連の問題に関するコマンドのレポートは、Redisのサーバーの経験、とは、可能な救済策について助言こと。</target>
        </trans-unit>
        <trans-unit id="09f518db007c555b3fc51849cb715d5f37978149" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-help&quot;&gt;MEMORY HELP&lt;/a&gt; command returns a helpful text describing the different subcommands.</source>
          <target state="translated">&lt;a href=&quot;memory-help&quot;&gt;MEMORYヘルプ&lt;/a&gt;コマンドが異なるサブコマンドを記述する役立つテキストを返します。</target>
        </trans-unit>
        <trans-unit id="ff16e624359e33f1f97dfa1a1d20188c59460b7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-malloc-stats&quot;&gt;MEMORY MALLOC-STATS&lt;/a&gt; command provides an internal statistics report from the memory allocator.</source>
          <target state="translated">&lt;a href=&quot;memory-malloc-stats&quot;&gt;MEMORY MALLOC-STATSの&lt;/a&gt;コマンドは、メモリアロケータから内部統計レポートを提供します。</target>
        </trans-unit>
        <trans-unit id="abed28f03c444a07fa9a013ee06dd6217f071068" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-purge&quot;&gt;MEMORY PURGE&lt;/a&gt; command attempts to purge dirty pages so these can be reclaimed by the allocator.</source>
          <target state="translated">&lt;a href=&quot;memory-purge&quot;&gt;MEMORYパージ&lt;/a&gt;これらはアロケータによって再利用できるようにダーティページをパージするためのコマンドの試行。</target>
        </trans-unit>
        <trans-unit id="6661981989e0edd2ff7e2bf5fdb3e79066d8b8f3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-stats&quot;&gt;MEMORY STATS&lt;/a&gt; command returns an &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; about the memory usage of the server.</source>
          <target state="translated">&lt;a href=&quot;memory-stats&quot;&gt;MEMORY STATSの&lt;/a&gt;コマンドが返す&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;配列の返信&lt;/a&gt;サーバーのメモリ使用量については。</target>
        </trans-unit>
        <trans-unit id="753fff2843cf4f675766fb16f94fa6b171989202" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-usage&quot;&gt;MEMORY USAGE&lt;/a&gt; command reports the number of bytes that a key and its value require to be stored in RAM.</source>
          <target state="translated">&lt;a href=&quot;memory-usage&quot;&gt;メモリ使用量の&lt;/a&gt;コマンドは、キーとその値をRAMに格納する必要があることバイト数を報告します。</target>
        </trans-unit>
        <trans-unit id="2af70a6f2971f44c0c1aa28591f8b6524acbcca6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command allows to inspect the internals of Redis Objects associated with keys. It is useful for debugging or to understand if your keys are using the specially encoded data types to save space. Your application may also use the information reported by the &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command to implement application level key eviction policies when using Redis as a Cache.</source>
          <target state="translated">&lt;a href=&quot;object&quot;&gt;OBJECTの&lt;/a&gt;コマンドは、キーに関連付けられているRedisのオブジェクトの内部を検査することができます。これは、デバッグしたり、キーが特別にエンコードされたデータ型を使用してスペースを節約しているかどうかを理解したりするのに役立ちます。アプリケーションは、&lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt;コマンドによって報告された情報を使用して、Redisをキャッシュとして使用するときに、アプリケーションレベルのキー排除ポリシーを実装することもできます。</target>
        </trans-unit>
        <trans-unit id="eea48beebb7220fe5ecc2f8e71ddc8ce2e90d62c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command supports multiple sub commands:</source>
          <target state="translated">&lt;a href=&quot;object&quot;&gt;OBJECTの&lt;/a&gt;コマンドは、複数のサブコマンドをサポートしています。</target>
        </trans-unit>
        <trans-unit id="ca3cc9ef5973b2b3ef21bdff9c9e13b41c03044f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;psync&quot;&gt;PSYNC&lt;/a&gt; command is called by Redis replicas for initiating a replication stream from the master.</source>
          <target state="translated">&lt;a href=&quot;psync&quot;&gt;PSYNCの&lt;/a&gt;コマンドは、マスターからの複製ストリームを開始するためのRedisのレプリカによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="6bc73cb913e243c94705a7071cd05dd7f69ae35a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; command can change the replication settings of a replica on the fly.</source>
          <target state="translated">&lt;a href=&quot;replicaof&quot;&gt;REPLICAOFの&lt;/a&gt;コマンドは、オンザフライでのレプリカのレプリケーション設定を変更することができます。</target>
        </trans-unit>
        <trans-unit id="4ce9249bde2a45fd1e0f497151a2d69b16bbda13" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rpushx&quot;&gt;RPUSHX&lt;/a&gt; command only pushes the element if the key already exists.</source>
          <target state="translated">&lt;a href=&quot;rpushx&quot;&gt;RPUSHXの&lt;/a&gt;キーがすでに存在する場合、コマンドは唯一の要素をプッシュします。</target>
        </trans-unit>
        <trans-unit id="614a32f854070cdcbbba350287fb7c58ac067da4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; commands performs a &lt;strong&gt;synchronous&lt;/strong&gt; save of the dataset producing a &lt;em&gt;point in time&lt;/em&gt; snapshot of all the data inside the Redis instance, in the form of an RDB file.</source>
          <target state="translated">&lt;a href=&quot;save&quot;&gt;SAVEは、&lt;/a&gt;実行コマンドを&lt;strong&gt;同期&lt;/strong&gt;製造データセットの保存&lt;em&gt;時間における点&lt;/em&gt; RDBファイルの形でRedisのインスタンス内のすべてのデータのスナップショット。</target>
        </trans-unit>
        <trans-unit id="67466c1875af0bcc544ed2934fa216ebaf0fb8ec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; algorithm is guaranteed to terminate only if the size of the iterated collection remains bounded to a given maximum size, otherwise iterating a collection that always grows may result into &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; to never terminate a full iteration.</source>
          <target state="translated">&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;アルゴリズムは、与えられた最大サイズに囲まれた反復収集遺跡の大きさは、それ以外の場合は常に成長がになることがあり、そのコレクション反復処理する場合にのみ終了することが保証されて&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;フル反復を終了したことがないのを。</target>
        </trans-unit>
        <trans-unit id="9b83fdceccccced73f803ea3fe0587ccedbc5d43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command and the closely related commands &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; are used in order to incrementally iterate over a collection of elements.</source>
          <target state="translated">&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;コマンドと密接に関連するコマンド&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;、&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt;と&lt;a href=&quot;zscan&quot;&gt;ZSCANは&lt;/a&gt;漸増要素のコレクションを反復処理するために使用されています。</target>
        </trans-unit>
        <trans-unit id="debbeaf11369c9e161ae3c316731408d752cc02f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command, and the other commands in the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family, are able to provide to the user a set of guarantees associated to full iterations.</source>
          <target state="translated">&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;コマンド、および内の他のコマンド&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;家族は、ユーザーに完全な反復処理に関連した保証のセットを提供することができます。</target>
        </trans-unit>
        <trans-unit id="1745a85b233cd9864512e1af6c727c0eb8686c05" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command supports a set of options that modify its behavior:</source>
          <target state="translated">&lt;a href=&quot;set&quot;&gt;SETの&lt;/a&gt;コマンドは、その動作を変更するオプションのセットをサポートしています。</target>
        </trans-unit>
        <trans-unit id="c8bb1ffaa9cf08918dd7437412b9271325c4076a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; command can change the replication settings of a replica on the fly. If a Redis server is already acting as replica, the command &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE will turn off the replication, turning the Redis server into a MASTER. In the proper form &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname port will make the server a replica of another server listening at the specified hostname and port.</source>
          <target state="translated">&lt;a href=&quot;slaveof&quot;&gt;SLAVEOFの&lt;/a&gt;コマンドは、オンザフライでのレプリカのレプリケーション設定を変更することができます。Redisサーバーが既にレプリカとして機能している場合、&lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE コマンドはレプリケーションをオフにし、Redisサーバーをマスターにします。適切な形式の&lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt;ホスト名ポートは、サーバーを指定されたホスト名とポートでリッスンする別のサーバーのレプリカにします。</target>
        </trans-unit>
        <trans-unit id="0ff4cdfae050eccc9a56820c72e2716bcf7a7f22" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sync&quot;&gt;SYNC&lt;/a&gt; command is called by Redis replicas for initiating a replication stream from the master. It has been replaced in newer versions of Redis by &lt;a href=&quot;psync&quot;&gt;PSYNC&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;sync&quot;&gt;SYNCの&lt;/a&gt;コマンドは、マスターからの複製ストリームを開始するためのレプリカのRedisによって呼び出されます。新しいバージョンのRedis&lt;a href=&quot;psync&quot;&gt;ではPSYNCに&lt;/a&gt;置き換えられました。</target>
        </trans-unit>
        <trans-unit id="bd3e1b27429bbc884368294b8f7962375860257e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; command returns the current server time as a two items lists: a Unix timestamp and the amount of microseconds already elapsed in the current second. Basically the interface is very similar to the one of the &lt;code&gt;gettimeofday&lt;/code&gt; system call.</source>
          <target state="translated">&lt;a href=&quot;time&quot;&gt;TIMEの&lt;/a&gt; Unixタイムスタンプと、すでに現在の秒で経過マイクロ秒の量：コマンドは、2つの項目リストなどの現在のサーバー時刻を返します。基本的に、インターフェースは &lt;code&gt;gettimeofday&lt;/code&gt; システムコールのインターフェースに非常に似ています。</target>
        </trans-unit>
        <trans-unit id="70be0ca493bf011ad2206bbde68c46ec552ad130" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command removes one or multiple messages from the &lt;em&gt;pending entries list&lt;/em&gt; (PEL) of a stream consumer group. A message is pending, and as such stored inside the PEL, when it was delivered to some consumer, normally as a side effect of calling &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;, or when a consumer took ownership of a message calling &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;. The pending message was delivered to some consumer but the server is yet not sure it was processed at least once. So new calls to &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; to grab the messages history for a consumer (for instance using an ID of 0), will return such message. Similarly the pending message will be listed by the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command, that inspects the PEL.</source>
          <target state="translated">&lt;a href=&quot;xack&quot;&gt;XACKの&lt;/a&gt;コマンドは、1つまたは複数からのメッセージ削除&lt;em&gt;ペンディングエントリリスト&lt;/em&gt;ストリームのコンシューマ・グループの（PEL）を。メッセージは保留中で、PEL内に格納されているため、通常は&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;を呼び出すことの副作用として、あるコンシューマに配信されたとき、またはコンシューマが&lt;a href=&quot;xclaim&quot;&gt;XCLAIMを&lt;/a&gt;呼び出すメッセージの所有権を取得したとき。保留中のメッセージは一部のコンシューマに配信されましたが、サーバーは少なくとも1回は処理されたことをまだ確認していません。したがって、コンシューマのメッセージ履歴を取得するための&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;への新しい呼び出し（たとえば、IDが0の場合）は、そのようなメッセージを返します。同様に、保留メッセージは、PELを検査する&lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt;コマンドによって一覧表示されます。</target>
        </trans-unit>
        <trans-unit id="7dd37542831e217f80423791c1758b898b47cbcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command allows iterating over the pending entries just like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; and &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; allow for the stream's entries. You can do this by prefixing the ID of the last-read pending entry with the &lt;code&gt;(&lt;/code&gt; character that denotes an open (exclusive) range, and proving it to the subsequent call to the command.</source>
          <target state="translated">&lt;a href=&quot;xpending&quot;&gt;XPENDINGの&lt;/a&gt;コマンドは、同じよう保留中のエントリの上に反復することができます&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;と&lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt;ストリームのエントリーが可能になります。これを行うには、最後に読み取られた保留中のエントリのIDの前に &lt;code&gt;(&lt;/code&gt; オープン（排他）範囲を示す文字を付け、それをコマンドの後続の呼び出しで証明します。</target>
        </trans-unit>
        <trans-unit id="f919fa1bdb0a477435ee790e9628136dda8f63ea" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command is the interface to inspect the list of pending messages, and is as thus a very important command in order to observe and understand what is happening with a streams consumer groups: what clients are active, what messages are pending to be consumed, or to see if there are idle messages. Moreover this command, together with &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; is used in order to implement recovering of consumers that are failing for a long time, and as a result certain messages are not processed: a different consumer can claim the message and continue. This is better explained in the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;streams intro&lt;/a&gt; and in the &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; command page, and is not covered here.</source>
          <target state="translated">&lt;a href=&quot;xpending&quot;&gt;XPENDINGの&lt;/a&gt;コマンドでは、保留中のメッセージのリストを検査するためのインタフェースである、と観察し、消費者団体をストリームで何が起こっているのかを理解するために極めて重要なコマンドとして次のとおりです。どのようなメッセージが消費されることが保留され、アクティブであるかのクライアント、または、アイドルメッセージがあるかどうかを確認します。さらに、このコマンドは、&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;とともに、長時間失敗しているコンシューマーのリカバリーを実装するために使用され、その結果、特定のメッセージは処理されません。別のコンシューマーがメッセージを要求して続行できます。これについては、&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;ストリームの紹介&lt;/a&gt;と&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;コマンドページで詳しく説明しています。ここでは説明しません。</target>
        </trans-unit>
        <trans-unit id="be7aa14ec80fad3a57ca56d203c2ac6e1198edd2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; command has a number of applications:</source>
          <target state="translated">&lt;a href=&quot;xrange&quot;&gt;XRANGEの&lt;/a&gt;コマンドは、アプリケーションの数を持っています：</target>
        </trans-unit>
        <trans-unit id="1033731d720ba1e5c57d34f9f982462de081667c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command is a special version of the &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; command with support for consumer groups. Probably you will have to understand the &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; command before reading this page will makes sense.</source>
          <target state="translated">&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUPの&lt;/a&gt;コマンドは、特別なバージョンです&lt;a href=&quot;xread&quot;&gt;XREADの&lt;/a&gt;消費者団体をサポートするコマンド。おそらく、このページを読む前に、&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;コマンドを理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="7ac305f70170c901011610af97e0bc42f712f0a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&lt;/code&gt; ID is effectively just exactly as specifying &lt;code&gt;0-0&lt;/code&gt;, while &lt;code&gt;+&lt;/code&gt; is equivalent to &lt;code&gt;18446744073709551615-18446744073709551615&lt;/code&gt;, however they are nicer to type.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; IDは、効果的にだけで正確に指定することとされて &lt;code&gt;0-0&lt;/code&gt; ながら、 &lt;code&gt;+&lt;/code&gt; は同等です &lt;code&gt;18446744073709551615-18446744073709551615&lt;/code&gt; 、しかし、彼らはタイプによりよいです。</target>
        </trans-unit>
        <trans-unit id="ad556b3da4050d845b9c3a874361828db5c442a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; special IDs mean respectively the minimum ID possible and the maximum ID possible inside a stream, so the following command will just return every entry in the stream:</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; と &lt;code&gt;+&lt;/code&gt; 次のコマンドは、単にストリーム内のすべてのエントリを返しますので、特別なIDは、それぞれの可能な最小のIDとストリーム内の可能な最大のIDを意味します：</target>
        </trans-unit>
        <trans-unit id="7b7c72e7ac11e971e25ca474ee3da37e97621a8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BY&lt;/code&gt; option can also take a non-existent key, which causes &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; to skip the sorting operation. This is useful if you want to retrieve external keys (see the &lt;code&gt;GET&lt;/code&gt; option below) without the overhead of sorting.</source>
          <target state="translated">&lt;code&gt;BY&lt;/code&gt; のオプションも原因存在しないキー、取ることができ&lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt;ソート操作をスキップすることを。これは、ソートのオーバーヘッドなしで外部キーを取得したい場合（下記の &lt;code&gt;GET&lt;/code&gt; オプションを参照）に役立ちます。</target>
        </trans-unit>
        <trans-unit id="04d5c46b7c9e4c0432ac2f85c4c63dc2b3333abd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BY&lt;/code&gt; option takes a pattern (equal to &lt;code&gt;weight_*&lt;/code&gt; in this example) that is used to generate the keys that are used for sorting. These key names are obtained substituting the first occurrence of &lt;code&gt;*&lt;/code&gt; with the actual value of the element in the list (&lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; in this example).</source>
          <target state="translated">&lt;code&gt;BY&lt;/code&gt; のオプションは、パターン（に等しいかかる &lt;code&gt;weight_*&lt;/code&gt; ソートに使用されるキーを生成するために使用されるこの例では）。これらのキー名は、最初に出現置換得られ &lt;code&gt;*&lt;/code&gt; を（リスト内の要素の実際の値が &lt;code&gt;1&lt;/code&gt; 、 &lt;code&gt;2&lt;/code&gt; 及び &lt;code&gt;3&lt;/code&gt; この例では）。</target>
        </trans-unit>
        <trans-unit id="bd7cf93ba7657f4f2966769280d74bac3ba29a14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COUNT&lt;/code&gt; option is used to limit the amount of stream/PEL entries that are returned (The first &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; entries are returned). The default &lt;code&gt;COUNT&lt;/code&gt; is 10 and a &lt;code&gt;COUNT&lt;/code&gt; of 0 means that all entries will be returned (Execution time may be long if the stream has a lot of entries)</source>
          <target state="translated">&lt;code&gt;COUNT&lt;/code&gt; のオプションは、返されたストリーム/ PELエントリ（最初の量を制限するために使用される &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; エントリが返されますが）。デフォルトの &lt;code&gt;COUNT&lt;/code&gt; は10で、 &lt;code&gt;COUNT&lt;/code&gt; が0の場合、すべてのエントリが返されます（ストリームに多数のエントリがある場合、実行時間が長くなる可能性があります）。</target>
        </trans-unit>
        <trans-unit id="7781d414a168c2c6071c960ca2a2f476d429921c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELSLOTS&lt;/code&gt; command asks a particular Redis Cluster node to forget which master is serving the hash slots specified as arguments.</source>
          <target state="translated">&lt;code&gt;DELSLOTS&lt;/code&gt; のコマンドは、引数として指定されたハッシュスロットにサービスを提供しているマスタ忘れて特定のRedisのクラスタ・ノードに要求します。</target>
        </trans-unit>
        <trans-unit id="f40cf7905426fe2efaf1d7bb82912ca46b5d481b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; option can be used multiple times in order to get more keys for every element of the original list, set or sorted set.</source>
          <target state="translated">&lt;code&gt;GET&lt;/code&gt; のオプションは、元のリスト、セットまたはソートセットのすべての要素のための複数のキーを取得するために複数回使用することができます。</target>
        </trans-unit>
        <trans-unit id="d2200d7bc7ff4797c7f7c14add0d36376defba47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ID&lt;/code&gt; filter only returns entries for clients with IDs matching the &lt;code&gt;client-id&lt;/code&gt; arguments.</source>
          <target state="translated">&lt;code&gt;ID&lt;/code&gt; のフィルタは一致するIDを持つクライアントのエントリを返し &lt;code&gt;client-id&lt;/code&gt; 引数を。</target>
        </trans-unit>
        <trans-unit id="692cd27ca778c52fb164170863c312f93a4febd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOACK&lt;/code&gt; subcommand can be used to avoid adding the message to the PEL in cases where reliability is not a requirement and the occasional message loss is acceptable. This is equivalent to acknowledging the message when it is read.</source>
          <target state="translated">&lt;code&gt;NOACK&lt;/code&gt; のサブコマンドは、信頼性が要件ではなく、時折メッセージ損失が許容可能である場合にはPELにメッセージを追加することを回避するために使用することができます。これは、メッセージが読み取られたときに確認応答することと同じです。</target>
        </trans-unit>
        <trans-unit id="70ae9c69379861ae43b186cc1aea347b195c9116" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NODE&lt;/code&gt; subcommand is the one with the most complex semantics. It associates the hash slot with the specified node, however the command works only in specific situations and has different side effects depending on the slot state. The following is the set of pre-conditions and side effects of the command:</source>
          <target state="translated">&lt;code&gt;NODE&lt;/code&gt; のサブコマンドは、最も複雑なセマンティクスを持つものです。ハッシュスロットを指定されたノードに関連付けますが、コマンドは特定の状況でのみ機能し、スロットの状態に応じてさまざまな副作用があります。以下は、コマンドの前提条件と副作用のセットです。</target>
        </trans-unit>
        <trans-unit id="f3353a302ef9a9215dfe9198dea9a7e8ef365e65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aof_delayed_fsync&lt;/code&gt; counter</source>
          <target state="translated">&lt;code&gt;aof_delayed_fsync&lt;/code&gt; カウンタ</target>
        </trans-unit>
        <trans-unit id="8b5f4a6fffad95a3f4be7e216981db9fcd1d6fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; argument is available since version 3.2.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 引数には、バージョン3.2以降で利用可能です。</target>
        </trans-unit>
        <trans-unit id="8ce90da51cb5b392562f97eba72b463845c11c4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ip:port&lt;/code&gt; should match a line returned by the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; command (&lt;code&gt;addr&lt;/code&gt; field).</source>
          <target state="translated">&lt;code&gt;ip:port&lt;/code&gt; で返される行と一致する必要があり&lt;a href=&quot;client-list&quot;&gt;、クライアントリストの&lt;/a&gt;コマンド（ &lt;code&gt;addr&lt;/code&gt; フィールド）。</target>
        </trans-unit>
        <trans-unit id="5777eb84fcb1170d8747af88e5c07f98feb04ee9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;message&lt;/code&gt; argument is simply a string. Example:</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; 引数は、単純に文字列です。例：</target>
        </trans-unit>
        <trans-unit id="9ea110d8be26fa3611a695ea1e98f388ddefd010" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; arguments have the same meaning as described for &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; と &lt;code&gt;max&lt;/code&gt; の引数は、のために説明したのと同じ意味を有する&lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEXを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="109dd07703928b5f87b169ad0c30d69a49fafa5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; arguments have the same semantic as described for &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; と &lt;code&gt;max&lt;/code&gt; のために説明した引数が同じセマンティックを持つ&lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="07c405abf8ce41269def6794789e4d59831e2dc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;score&lt;/code&gt; value should be the string representation of a numeric value, and accepts double precision floating point numbers. It is possible to provide a negative value to decrement the score.</source>
          <target state="translated">&lt;code&gt;score&lt;/code&gt; 値は、数値の文字列表現であること、および浮動小数点数、倍精度を受け入れなければなりません。負の値を指定してスコアを減らすことができます。</target>
        </trans-unit>
        <trans-unit id="4192359597f0ce567f180b8ce4e1911ba0a4fee7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument is interpreted as a double value specifying the maximum number of seconds to block. A timeout of zero can be used to block indefinitely.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 引数をブロックする最大秒数を指定する二値として解釈されます。ゼロのタイムアウトを使用して、無期限にブロックできます。</target>
        </trans-unit>
        <trans-unit id="e7f5712887288aace7cb25c9ca1f98dbdf6c03f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument is interpreted as an double value specifying the maximum number of seconds to block. A timeout of zero can be used to block indefinitely.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 引数をブロックする最大秒数を指定する二値として解釈されます。ゼロのタイムアウトを使用して、無期限にブロックできます。</target>
        </trans-unit>
        <trans-unit id="ca4c3a5926b2e82699f6692683e7c60016ad3961" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument is interpreted as an integer value specifying the maximum number of seconds to block. A timeout of zero can be used to block indefinitely.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 引数をブロックする最大秒数を指定する整数値として解釈されます。ゼロのタイムアウトを使用すると、無期限にブロックできます。</target>
        </trans-unit>
        <trans-unit id="1ad755fb1756745bfb0855cce9d6737683c771bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; argument is the same string name that the &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; command returns. Note a quirk where some Redis types, such as GeoHashes, HyperLogLogs, Bitmaps, and Bitfields, may internally be implemented using other Redis types, such as a string or zset, so can't be distinguished from other keys of that same type by &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;. For example, a ZSET and GEOHASH:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 引数は、同じ文字列の名前であること&lt;a href=&quot;type&quot;&gt;のTYPE&lt;/a&gt;コマンドが返します。GeoHashes、HyperLogLogs、Bitmaps、Bitfieldsなどの一部のRedisタイプが、文字列やzsetなどの他のRedisタイプを使用して内部的に実装される可能性があるため、&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;で同じタイプの他のキーと区別できないという癖に注意してください。。たとえば、ZSETとGEOHASH：</target>
        </trans-unit>
        <trans-unit id="b70e592aaa3d9e8f7df4a512dc479e926a2adbc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; argument between the &lt;strong&gt;MAXLEN&lt;/strong&gt; option and the actual count means that the user is not really requesting that the stream length is exactly 1000 items, but instead it could be a few tens of entries more, but never less than 1000 items. When this option modifier is used, the trimming is performed only when Redis is able to remove a whole macro node. This makes it much more efficient, and it is usually what you want.</source>
          <target state="translated">&lt;strong&gt;MAXLEN&lt;/strong&gt;オプションと実際のカウントの間の &lt;code&gt;~&lt;/code&gt; 引数は、ユーザーが実際にストリーム長が正確に1000アイテムであることを要求していないことを意味しますが、代わりに数十エントリ以上になることもありますが、1000アイテム以上になることはありません。このオプション修飾子を使用すると、Redisがマクロノード全体を削除できる場合にのみトリミングが実行されます。これにより、効率が大幅に向上し、通常はこれが必要です。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ea8b5fbf2699e6884711237f84a50ed662e87dcb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;STREAMS&lt;/strong&gt; option is mandatory and MUST be the final option because such option gets a variable length of argument in the following format:</source>
          <target state="translated">&lt;strong&gt;STREAMSの&lt;/strong&gt;オプションは必須であり、そのようなオプションは、次の形式で引数の可変長を取得するため、最終的なオプションでなければなりません。</target>
        </trans-unit>
        <trans-unit id="f1467c9ba6d40cf52b5cdae46604d845510d3c66" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;TAKEOVER&lt;/strong&gt; option implies everything &lt;strong&gt;FORCE&lt;/strong&gt; implies, but also does not uses any cluster authorization in order to failover. A replica receiving &lt;code&gt;CLUSTER FAILOVER TAKEOVER&lt;/code&gt; will instead:</source>
          <target state="translated">&lt;strong&gt;TAKEOVERの&lt;/strong&gt;オプションはすべて意味&lt;strong&gt;FORCEは&lt;/strong&gt;意味がなく、フェイルオーバーするために、任意のクラスタの認証を使用しません。代わりに、 &lt;code&gt;CLUSTER FAILOVER TAKEOVER&lt;/code&gt; を受信するレプリカは次のようになります。</target>
        </trans-unit>
        <trans-unit id="706ee50ff413a981311879f38f0325b685e418ae" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;cluster&lt;/strong&gt; section currently only contains a unique field:</source>
          <target state="translated">現在、&lt;strong&gt;クラスター&lt;/strong&gt;セクションには一意のフィールドのみが含まれています。</target>
        </trans-unit>
        <trans-unit id="e18469751043e4051869a86bbcba03716b45e346" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;commandstats&lt;/strong&gt; section provides statistics based on the command type, including the number of calls, the total CPU time consumed by these commands, and the average CPU consumed per command execution.</source>
          <target state="translated">&lt;strong&gt;commandstatsの&lt;/strong&gt;セクションでは、コールの数、これらのコマンドによって消費される総CPU時間、およびコマンドの実行ごとに消費される平均CPUを含むコマンドの種類に基づいて統計を提供します。</target>
        </trans-unit>
        <trans-unit id="f90c39a55fa63248e76899e871ade6a1431c29d1" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;keyspace&lt;/strong&gt; section provides statistics on the main dictionary of each database. The statistics are the number of keys, and the number of keys with an expiration.</source>
          <target state="translated">&lt;strong&gt;鍵空間の&lt;/strong&gt;セクションでは、各データベースのメイン辞書に統計を提供します。統計は、キーの数、および有効期限のあるキーの数です。</target>
        </trans-unit>
        <trans-unit id="3a0202270041736b1216ba5baa1f54459be4f741" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;modules&lt;/strong&gt; section contains additional information about loaded modules if the modules provide it. The field part of properties lines in this section is always prefixed with the module's name.</source>
          <target state="translated">&lt;strong&gt;モジュール&lt;/strong&gt;モジュールは、それを提供する場合セクションでは、ロードされたモジュールに関する追加情報が含まれています。このセクションのプロパティ行のフィールド部分には、常にモジュール名のプレフィックスが付いています。</target>
        </trans-unit>
        <trans-unit id="3ac8492c1e70ee526ecccc4abef734bddc537815" translate="yes" xml:space="preserve">
          <source>The AUTH command authenticates the current connection in two cases:</source>
          <target state="translated">AUTH コマンドは、2 つの場合に現在の接続を認証します。</target>
        </trans-unit>
        <trans-unit id="3ff483a1ce1f770bdb2f62a76889e8f7ada78a73" translate="yes" xml:space="preserve">
          <source>The CJSON library provides extremely fast JSON manipulation within Lua.</source>
          <target state="translated">CJSONライブラリは、Lua内でのJSON操作を非常に高速に行うことができます。</target>
        </trans-unit>
        <trans-unit id="7530389adb107898a8e0437c53cce50bad07ea36" translate="yes" xml:space="preserve">
          <source>The COUNT option</source>
          <target state="translated">COUNTオプション</target>
        </trans-unit>
        <trans-unit id="e8dffa28f7261bfe8a1090fc2b6db1ae98bb313f" translate="yes" xml:space="preserve">
          <source>The HyperLogLog data structure can be used in order to count &lt;strong&gt;unique&lt;/strong&gt; elements in a set using just a small constant amount of memory, specifically 12k bytes for every HyperLogLog (plus a few bytes for the key itself).</source>
          <target state="translated">HyperLogLogデータ構造は、少量の一定量のメモリ、具体的にはすべてのHyperLogLogに12kバイト（およびキー自体に数バイト）を使用して、セット内の&lt;strong&gt;一意の&lt;/strong&gt;要素をカウントするために使用できます。</target>
        </trans-unit>
        <trans-unit id="5d5e9e7569c5ac826ef312fb92859c0deffb60e9" translate="yes" xml:space="preserve">
          <source>The HyperLogLog, being a Redis string, can be retrieved with &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; and restored with &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. Calling &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;, &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; or &lt;a href=&quot;pfmerge&quot;&gt;PFMERGE&lt;/a&gt; commands with a corrupted HyperLogLog is never a problem, it may return random values but does not affect the stability of the server. Most of the times when corrupting a sparse representation, the server recognizes the corruption and returns an error.</source>
          <target state="translated">HyperLogLogはRedis文字列であり、&lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;を使用して取得し、&lt;a href=&quot;set&quot;&gt;SETを&lt;/a&gt;使用して復元できます。呼び出し&lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;、&lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt;または&lt;a href=&quot;pfmerge&quot;&gt;PFMERGE&lt;/a&gt;壊れHyperLogLogでコマンドが問題になることはありません、それはランダムな値を返すことがありますが、サーバーの安定性に影響を与えることはありません。ほとんどの場合、スパース表現を破損すると、サーバーは破損を認識してエラーを返します。</target>
        </trans-unit>
        <trans-unit id="b9ffa717a680ea863704c9d4cbe178090dee5908" translate="yes" xml:space="preserve">
          <source>The ID is monotonically incremental. If the ID of a connection is greater than the ID of another connection, it is guaranteed that the second connection was established with the server at a later time.</source>
          <target state="translated">ID は単調に増加します。接続のIDが他の接続のIDよりも大きい場合、2番目の接続が後からサーバとの間で確立されたことが保証されます。</target>
        </trans-unit>
        <trans-unit id="7f2d6cad55038bdb71cc5342903dad20539f48ed" translate="yes" xml:space="preserve">
          <source>The ID is never reset in the course of the Redis server execution, only a server restart will reset it.</source>
          <target state="translated">Redisサーバの実行中にIDがリセットされることはなく、サーバの再起動だけがIDをリセットします。</target>
        </trans-unit>
        <trans-unit id="5028f5e06740630088beea552d56dbc9a9d96305" translate="yes" xml:space="preserve">
          <source>The ID of the last entry is &lt;code&gt;1526985685298-0&lt;/code&gt;, so we just add 1 to the sequence to obtain &lt;code&gt;1526985685298-1&lt;/code&gt;, and continue our iteration:</source>
          <target state="translated">最後のエントリのIDは &lt;code&gt;1526985685298-0&lt;/code&gt; であるため、シーケンスに1を追加して &lt;code&gt;1526985685298-1&lt;/code&gt; を取得し、反復を続けます。</target>
        </trans-unit>
        <trans-unit id="7eefbc13fad88639889dfca1eea5bd903a412b2f" translate="yes" xml:space="preserve">
          <source>The ID of the last entry is &lt;code&gt;1526985685298-0&lt;/code&gt;, so we just prefix it with a '(', and continue our iteration:</source>
          <target state="translated">最後のエントリのIDは &lt;code&gt;1526985685298-0&lt;/code&gt; であるため、プレフィックスとして '（'を付けて、反復を続行します。</target>
        </trans-unit>
        <trans-unit id="bfc0d85cea060a3580771bdafcea7e5bc90996bb" translate="yes" xml:space="preserve">
          <source>The ID of the message.</source>
          <target state="translated">メッセージのIDです。</target>
        </trans-unit>
        <trans-unit id="10ecce9f88d9ae56cb1bcd6efbec98fbc1a5f68e" translate="yes" xml:space="preserve">
          <source>The ID to specify in the &lt;strong&gt;STREAMS&lt;/strong&gt; option when using &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; can be one of the following two:</source>
          <target state="translated">&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUPの&lt;/a&gt;使用時に&lt;strong&gt;STREAMS&lt;/strong&gt;オプションで指定するID は、次の2つのいずれかです。</target>
        </trans-unit>
        <trans-unit id="a5addd3dd6a1b78a37c68a12e4b0f086415a0b5b" translate="yes" xml:space="preserve">
          <source>The IP of the master.</source>
          <target state="translated">マスターのIPです。</target>
        </trans-unit>
        <trans-unit id="5bcb92df23fdb05d8a0140fd9087b6b631c09793" translate="yes" xml:space="preserve">
          <source>The LCS subcommand implements the longest common subsequence algorithm. Note that this is different than the longest common string algorithm, since matching characters in the string does not need to be contiguous.</source>
          <target state="translated">LCSサブコマンドは最長共通部分行列アルゴリズムを実装しています。これは最長共通文字列アルゴリズムとは異なることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e326a0ab79090e9945701455a9f67576780adbaf" translate="yes" xml:space="preserve">
          <source>The LOLWUT command displays the Redis version: however as a side effect of doing so, it also creates a piece of generative computer art that is different with each version of Redis. The command was introduced in Redis 5 and announced with this &lt;a href=&quot;http://antirez.com/news/123&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">LOLWUTコマンドはRedisバージョンを表示しますが、そうすることの副作用として、Redisのバージョンごとに異なる生成的なコンピューターアートも作成されます。このコマンドはRedis5で導入され、この&lt;a href=&quot;http://antirez.com/news/123&quot;&gt;ブログ投稿で&lt;/a&gt;発表されました。</target>
        </trans-unit>
        <trans-unit id="4f53ea350a50177374bcdd35f9332bb81e5298f0" translate="yes" xml:space="preserve">
          <source>The Lua Bit Operations Module adds bitwise operations on numbers. It is available for scripting in Redis since version 2.8.18.</source>
          <target state="translated">Lua Bit Operations Moduleは、数値に対するビット演算を追加します。バージョン 2.8.18 以降、Redis のスクリプトで利用可能です。</target>
        </trans-unit>
        <trans-unit id="1051d37718542a5598a286cc56e5f5aaafbf73d5" translate="yes" xml:space="preserve">
          <source>The Lua PRNG in this mode is seeded randomly at every call.</source>
          <target state="translated">このモードのLua PRNGは、呼び出しのたびにランダムにシードされます。</target>
        </trans-unit>
        <trans-unit id="a8d85991ddfb0f169b9f806f86a3cc0413e31e4e" translate="yes" xml:space="preserve">
          <source>The Lua debugger is described in the &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Lua scripts debugging&lt;/a&gt; section of the Redis documentation.</source>
          <target state="translated">Luaデバッガーについては、Redisドキュメントの&lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Luaスクリプトデバッグ&lt;/a&gt;セクションで説明されています。</target>
        </trans-unit>
        <trans-unit id="4515a3f12b04929b3987b1647823726616d895eb" translate="yes" xml:space="preserve">
          <source>The Lua engine always assumes to run in RESP2 mode when talking with Redis, so whatever the connection that is invoking the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; or &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; command is in RESP2 or RESP3 mode, Lua scripts will, by default, still see the same kind of replies they used to see in the past from Redis, when calling commands using the &lt;code&gt;redis.call()&lt;/code&gt; built-in function.</source>
          <target state="translated">Luaエンジンは、Redisと&lt;a href=&quot;evalsha&quot;&gt;通信する&lt;/a&gt;ときに常にRESP2モードで実行されることを前提としているため、&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;またはEVALSHAコマンドを呼び出す接続がRESP2またはRESP3モードである場合でも、Luaスクリプトは、デフォルトで、使用したのと同じ種類の応答を表示します。過去にRedisから、 &lt;code&gt;redis.call()&lt;/code&gt; 組み込み関数を使用してコマンドを呼び出すときに確認します。</target>
        </trans-unit>
        <trans-unit id="0a696a748eaeb904c163e6d11e4f1f007a0ef038" translate="yes" xml:space="preserve">
          <source>The MATCH option</source>
          <target state="translated">MATCHオプション</target>
        </trans-unit>
        <trans-unit id="4eb0859176601ed31b0ed60fbf24deb7442f3423" translate="yes" xml:space="preserve">
          <source>The PUBSUB command is an introspection command that allows to inspect the state of the Pub/Sub subsystem. It is composed of subcommands that are documented separately. The general form is:</source>
          <target state="translated">PUBSUBコマンドは、PUB/SUBサブシステムの状態を検査するためのイントロスペクションコマンドです。これは、個別に文書化されたサブコマンドで構成されています。一般的な形式は</target>
        </trans-unit>
        <trans-unit id="82e7a6dd485996953664282bec28fa4f1043afe7" translate="yes" xml:space="preserve">
          <source>The Redis Lua interpreter loads the following Lua libraries:</source>
          <target state="translated">Redis Luaインタプリタは、以下のLuaライブラリをロードします。</target>
        </trans-unit>
        <trans-unit id="bb0c5eade03c486c5f8281c1da8633f26a4b714d" translate="yes" xml:space="preserve">
          <source>The Redis Slow Log is a system to log queries that exceeded a specified execution time. The execution time does not include I/O operations like talking with the client, sending the reply and so forth, but just the time needed to actually execute the command (this is the only stage of command execution where the thread is blocked and can not serve other requests in the meantime).</source>
          <target state="translated">Redis Slow Logは、指定した実行時間を超えたクエリをログに記録する仕組みです。実行時間には、クライアントとの会話や返信の送信などのI/O操作は含まれておらず、実際にコマンドを実行するのに必要な時間だけが記録されます(これはコマンド実行の唯一の段階で、スレッドがブロックされ、その間他のリクエストにサービスを提供することができません)。</target>
        </trans-unit>
        <trans-unit id="63b3dcb2e93d3c4b06fb3ccd03dd7de69fb04d43" translate="yes" xml:space="preserve">
          <source>The SCRIPT command</source>
          <target state="translated">SCRIPT コマンド</target>
        </trans-unit>
        <trans-unit id="7b0199097175bc8f260d469794e2e96bed7dab06" translate="yes" xml:space="preserve">
          <source>The STRALGO implements complex algorithms that operate on strings. Right now the only algorithm implemented is the LCS algorithm (longest common substring). However new algorithms could be implemented in the future. The goal of this command is to provide to Redis users algorithms that need fast implementations and are normally not provided in the standard library of most programming languages.</source>
          <target state="translated">STRALGOは文字列を操作する複雑なアルゴリズムを実装しています。現在、実装されているアルゴリズムはLCSアルゴリズム(最長共通部分文字列)のみです。しかし、将来的には新しいアルゴリズムが実装される可能性があります。このコマンドの目的は、高速な実装を必要とし、通常はほとんどのプログラミング言語の標準ライブラリでは提供されていないアルゴリズムをRedisユーザに提供することです。</target>
        </trans-unit>
        <trans-unit id="a04ad115145f4340fd6a7e75d3c008104af8a7d2" translate="yes" xml:space="preserve">
          <source>The TYPE option</source>
          <target state="translated">TYPEオプション</target>
        </trans-unit>
        <trans-unit id="0f9be29f5758f4e3311e10dd99d11effd38e89f6" translate="yes" xml:space="preserve">
          <source>The ability to see all the requests processed by the server is useful in order to spot bugs in an application both when using Redis as a database and as a distributed caching system.</source>
          <target state="translated">サーバで処理されたすべてのリクエストを見ることができる機能は、データベースとしてRedisを使用している場合や分散キャッシュシステムとして使用している場合に、アプリケーションのバグを発見するのに便利です。</target>
        </trans-unit>
        <trans-unit id="a9a4c4b85d74e390cf97f77d86569a9c392136a7" translate="yes" xml:space="preserve">
          <source>The above command will create a user called &lt;code&gt;virginia&lt;/code&gt; that is active (the on rule), can access any key (allkeys rule), and can call the set command (+set rule). Then another SETUSER call can modify the user rules:</source>
          <target state="translated">上記のコマンドは、アクティブ（onルール）で、任意のキー（allkeysルール）にアクセスでき、setコマンド（+ setルール）を呼び出すことができる &lt;code&gt;virginia&lt;/code&gt; というユーザーを作成します。次に、別のSETUSER呼び出しでユーザールールを変更できます。</target>
        </trans-unit>
        <trans-unit id="f195a8757b1d8a55a19d37ee9ad3a22c5c0a4e17" translate="yes" xml:space="preserve">
          <source>The above makes it very simple to implement a system where a set of items must be processed by N workers continuously as fast as possible. An example is a monitoring system that must check that a set of web sites are reachable, with the smallest delay possible, using a number of parallel workers.</source>
          <target state="translated">以上のことから、一組のアイテムを可能な限り高速に連続的にN人のワーカーによって処理しなければならないシステムを実装することは非常に簡単である。例としては、複数の並列ワーカーを使用して、一組のウェブサイトが可能な限り最小の遅延で到達可能であるかどうかをチェックしなければならない監視システムがある。</target>
        </trans-unit>
        <trans-unit id="75a3a44602ce55e23d207b895b5a485f6d4a2fc0" translate="yes" xml:space="preserve">
          <source>The above pattern works even if the following two conditions:</source>
          <target state="translated">上記のパターンは、以下の2つの条件を満たしていても動作します。</target>
        </trans-unit>
        <trans-unit id="27a55611f4365743e826db0b0f9378c4a66a4f67" translate="yes" xml:space="preserve">
          <source>The above rule will not apply the new rule to the user virginia, so other than &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;, the user virginia will now be able to also use the &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; command.</source>
          <target state="translated">上記のルールは、新しいルールをユーザーvirginiaに適用しないため、&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;以外に、ユーザーvirginiaは&lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;コマンドも使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="4d153745d60911da280f1df79b2e372158711e77" translate="yes" xml:space="preserve">
          <source>The above script sets the key &lt;code&gt;foo&lt;/code&gt; to the string &lt;code&gt;bar&lt;/code&gt;. However it violates the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command semantics as all the keys that the script uses should be passed using the &lt;code&gt;KEYS&lt;/code&gt; array:</source>
          <target state="translated">上記のスクリプトは、キー &lt;code&gt;foo&lt;/code&gt; を文字列 &lt;code&gt;bar&lt;/code&gt; に設定します。ただし、スクリプトが使用するすべてのキーは &lt;code&gt;KEYS&lt;/code&gt; 配列を使用して渡す必要があるため、&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;コマンドのセマンティクスに違反します。</target>
        </trans-unit>
        <trans-unit id="0dd21e93f4a7ab544f682629858a1ca7196710f4" translate="yes" xml:space="preserve">
          <source>The additional elements of the array depends on the role.</source>
          <target state="translated">配列の追加要素は役割に依存します。</target>
        </trans-unit>
        <trans-unit id="b4c1764b30cb0625e6c253a27bb41e84ea603d9e" translate="yes" xml:space="preserve">
          <source>The algorithm used, that is implemented inside dict.c, samples the hash table buckets to find a non-empty one. Once a non empty bucket is found, since we use chaining in our hash table implementation, the number of elements inside the bucket is checked and a random element is selected.</source>
          <target state="translated">使用されるアルゴリズムは、dict.cの内部に実装されており、ハッシュテーブルのバケットをサンプリングして空でないものを見つけます。空でないバケットが見つかると、ハッシュテーブルの実装ではチェーニングを使用しているので、バケット内の要素数をチェックし、ランダムな要素を選択します。</target>
        </trans-unit>
        <trans-unit id="6de2e476596fcaba51a4ddd43e2a8bd4d48c346f" translate="yes" xml:space="preserve">
          <source>The amount of data received from the replica so far in terms of master replication offset.</source>
          <target state="translated">これまでにレプリカから受け取ったデータの量を、マスターレプリケーションのオフセットに換算したものです。</target>
        </trans-unit>
        <trans-unit id="5d8b8009ef4dd06c8c025f1eed58b5b1787f1f48" translate="yes" xml:space="preserve">
          <source>The amount of time needed for its execution, in microseconds.</source>
          <target state="translated">実行に必要な時間をマイクロ秒で表します。</target>
        </trans-unit>
        <trans-unit id="e5407b8706df1e8319a7a989bf68d7ad75911c3a" translate="yes" xml:space="preserve">
          <source>The approximated number of unique elements observed via &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;を介して監視される一意の要素の概数。</target>
        </trans-unit>
        <trans-unit id="5d3457f0c58f45dac774e34be45c19b72f462db2" translate="yes" xml:space="preserve">
          <source>The arguments of the &lt;code&gt;redis.call()&lt;/code&gt; and &lt;code&gt;redis.pcall()&lt;/code&gt; functions are all the arguments of a well formed Redis command:</source>
          <target state="translated">引数 &lt;code&gt;redis.call()&lt;/code&gt; と &lt;code&gt;redis.pcall()&lt;/code&gt; 関数は、すべてのウェルに形成されRedisのコマンドの引数です。</target>
        </trans-unit>
        <trans-unit id="120865be87c8e6ca3cb347b65ffdefe018090581" translate="yes" xml:space="preserve">
          <source>The array composing the arguments of the command.</source>
          <target state="translated">コマンドの引数を構成する配列。</target>
        </trans-unit>
        <trans-unit id="a010440d8c2596df424c379b3133bfd83782f2d9" translate="yes" xml:space="preserve">
          <source>The assigned name is displayed in the output of &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; so that it is possible to identify the client that performed a given connection.</source>
          <target state="translated">割り当てられた名前は&lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt;の出力に表示されるので、特定の接続を実行したクライアントを識別できます。</target>
        </trans-unit>
        <trans-unit id="885f9339188f139f7b1172052e203973f59a224e" translate="yes" xml:space="preserve">
          <source>The basic idea is that nodes by default don't trust each other, and are considered unknown, so that it is unlikely that different cluster nodes will mix into a single one because of system administration errors or network addresses modifications.</source>
          <target state="translated">基本的な考え方としては、デフォルトではノード同士が信頼し合っておらず、未知のノードとみなされているため、システム管理のエラーやネットワークアドレスの変更などで、異なるクラスタノードが混ざってしまう可能性は低いと考えられています。</target>
        </trans-unit>
        <trans-unit id="d3155ed9386ade27ef1929683ef41081fb15be86" translate="yes" xml:space="preserve">
          <source>The basic usage is the following:</source>
          <target state="translated">基本的な使い方は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="da9c85f3c202fdd59f8f147e36c3ec1f770f703e" translate="yes" xml:space="preserve">
          <source>The behavior of Redis 2.4 creates a lot of problems when replicating or persisting data into the AOF file, so the much more generic and semantically simpler behavior was introduced into Redis 2.6 to prevent problems.</source>
          <target state="translated">Redis 2.4の動作では、データをAOFファイルに複製したり保存したりする際に多くの問題が発生していました。</target>
        </trans-unit>
        <trans-unit id="b344dc2bc04bb34933613eb7044804cab8c272df" translate="yes" xml:space="preserve">
          <source>The binary nature of the comparison allows to use sorted sets as a general purpose index, for example the first part of the element can be a 64 bit big endian number: since big endian numbers have the most significant bytes in the initial positions, the binary comparison will match the numerical comparison of the numbers. This can be used in order to implement range queries on 64 bit values. As in the example below, after the first 8 bytes we can store the value of the element we are actually indexing.</source>
          <target state="translated">比較のバイナリ性により、ソートされたセットを汎用インデックスとして使用することができます。例えば、要素の最初の部分は64ビットのビッグエンディアン数にすることができます:ビッグエンディアン数は初期位置に最も重要なバイトを持つため、バイナリ比較は数値比較と一致します。これは、64ビット値の範囲問い合わせを実装するために使用することができます。以下の例のように、最初の8バイトの後には、実際にインデックスを作成している要素の値を格納することができます。</target>
        </trans-unit>
        <trans-unit id="f19a05fbdb75f958bfa6f09541362b1de2c7798d" translate="yes" xml:space="preserve">
          <source>The bit is either set or cleared depending on &lt;em&gt;value&lt;/em&gt;, which can be either 0 or 1.</source>
          <target state="translated">ビットは、0または1のいずれかの&lt;em&gt;値&lt;/em&gt;に応じてセットまたはクリアされ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="d3282d877e14a9e1a4f618e1ae58563eb55cb394" translate="yes" xml:space="preserve">
          <source>The bit is either set or cleared depending on &lt;em&gt;value&lt;/em&gt;, which can be either 0 or 1. When &lt;em&gt;key&lt;/em&gt; does not exist, a new string value is created. The string is grown to make sure it can hold a bit at &lt;em&gt;offset&lt;/em&gt;. The &lt;em&gt;offset&lt;/em&gt; argument is required to be greater than or equal to 0, and smaller than 2&lt;sup&gt;32&lt;/sup&gt; (this limits bitmaps to 512MB). When the string at &lt;em&gt;key&lt;/em&gt; is grown, added bits are set to 0.</source>
          <target state="translated">ビットは、&lt;em&gt;値&lt;/em&gt;に応じて設定またはクリアされ&lt;em&gt;ます。値&lt;/em&gt;は0または1のいずれかです。&lt;em&gt;キー&lt;/em&gt;が存在しない場合、新しい文字列値が作成されます。文字列は、&lt;em&gt;オフセットで&lt;/em&gt;ビットを保持できるように拡張されます。&lt;em&gt;オフセット&lt;/em&gt;引数は0以上であることが必要であり、より小さい2は&lt;sup&gt;32&lt;/sup&gt;（この制限ビットマップ512メガバイトまで）。&lt;em&gt;キー&lt;/em&gt;の文字列が大きくなると、追加されたビットは0に設定されます。</target>
        </trans-unit>
        <trans-unit id="0b7af7df323735c0dce87d77fcd93c888e45e3a0" translate="yes" xml:space="preserve">
          <source>The client explicitly checks the &lt;code&gt;runid&lt;/code&gt; field in the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command in order to make sure the server was not restarted and is still the same process.</source>
          <target state="translated">クライアントは、&lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;コマンドの &lt;code&gt;runid&lt;/code&gt; フィールドを明示的にチェックして、サーバーが再起動されておらず、同じプロセスであることを確認します。</target>
        </trans-unit>
        <trans-unit id="9350ca0340f5b792f129eec734a9c6029b8bad38" translate="yes" xml:space="preserve">
          <source>The client flags can be a combination of:</source>
          <target state="translated">クライアントフラグは、以下の組み合わせが可能です。</target>
        </trans-unit>
        <trans-unit id="ef7c4ea851346ff688f43804007664e07a0ee9aa" translate="yes" xml:space="preserve">
          <source>The client library implementation can always optimistically send &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; under the hood even when the client actually calls &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;, in the hope the script was already seen by the server. If the &lt;code&gt;NOSCRIPT&lt;/code&gt; error is returned &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; will be used instead.</source>
          <target state="translated">クライアントライブラリの実装は、クライアントが実際に&lt;a href=&quot;eval&quot;&gt;EVALを&lt;/a&gt;呼び出した場合でも、いつでも楽観的に&lt;a href=&quot;evalsha&quot;&gt;EVALSHAを内部&lt;/a&gt;で送信できます。これは、スクリプトがサーバーにすでに表示されていることを期待しています。 &lt;code&gt;NOSCRIPT&lt;/code&gt; エラーが返された場合は、代わりに&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;が使用されます。</target>
        </trans-unit>
        <trans-unit id="5dfcddce441b9e425d29945dfa151dd5838c9e0e" translate="yes" xml:space="preserve">
          <source>The client library implementation should take one of the following approaches:</source>
          <target state="translated">クライアントライブラリの実装は、以下のいずれかのアプローチを取る必要があります。</target>
        </trans-unit>
        <trans-unit id="cea5f73089ab49d55692f68c7533b954be4a4271" translate="yes" xml:space="preserve">
          <source>The client sent a command about hash slots never served by the master of this replica.</source>
          <target state="translated">クライアントは、このレプリカのマスターがサービスを提供していないハッシュスロットについてのコマンドを送信しました。</target>
        </trans-unit>
        <trans-unit id="4f3cae0941780fdfb0d5aa096cbd40be72c4d373" translate="yes" xml:space="preserve">
          <source>The client will have to acknowledge the message processing using &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; in order for the pending entry to be removed from the PEL. The PEL can be inspected using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command.</source>
          <target state="translated">クライアントは、保留中のエントリをPELから削除するために、&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;を使用してメッセージ処理を確認する必要があります。PELは&lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt;コマンドを使用して検査できます。</target>
        </trans-unit>
        <trans-unit id="82fd513f621c09ac0869a99d08b31390f0bc842b" translate="yes" xml:space="preserve">
          <source>The cluster was reconfigured (for example resharded) and the replica is no longer able to serve commands for a given hash slot.</source>
          <target state="translated">クラスタが再構成され(例えば resharded)、レプリカは指定されたハッシュスロットのコマンドを提供できなくなりました。</target>
        </trans-unit>
        <trans-unit id="9940f805fd9de379d7d0c58cd1b84f3338b5e58f" translate="yes" xml:space="preserve">
          <source>The cmsgpack library provides simple and fast MessagePack manipulation within Lua.</source>
          <target state="translated">cmsgpackライブラリは、Lua内でシンプルかつ高速にMessagePackを操作することができます。</target>
        </trans-unit>
        <trans-unit id="0b9bb30b2dbe12e3fa62af10a99007a2ae4848a9" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; is also able to iterate the stream. The command &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; can iterate the stream reverse, from higher IDs (or times) to lower IDs (or times).</source>
          <target state="translated">コマンド&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;は、ストリームを反復することもできます。コマンド&lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt;は、高いID（または時間）から低いID（または時間）にストリームを逆方向に反復できます。</target>
        </trans-unit>
        <trans-unit id="4fbd17702a2c89af4ecc45167e7c6a7b02c943ed" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;SET resource-name anystring NX EX max-lock-time&lt;/code&gt; is a simple way to implement a locking system with Redis.</source>
          <target state="translated">コマンド &lt;code&gt;SET resource-name anystring NX EX max-lock-time&lt;/code&gt; は、Redisでロックシステムを実装する簡単な方法です。</target>
        </trans-unit>
        <trans-unit id="2dbda62e4a8fd31c5ca6fc1f4cddf22961ead108" translate="yes" xml:space="preserve">
          <source>The command &lt;strong&gt;will always return&lt;/strong&gt; the number of replicas that acknowledged the write commands sent before the &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; command, both in the case where the specified number of replicas are reached, or when the timeout is reached.</source>
          <target state="translated">このコマンド&lt;strong&gt;は&lt;/strong&gt;、指定されたレプリカ数に達した場合、またはタイムアウトに達した場合の両方で、&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;コマンドの前に送信された書き込みコマンドを確認したレプリカの数&lt;strong&gt;を常に返し&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="4a44b122481ff3652c96ef6533c739e783fe19c3" translate="yes" xml:space="preserve">
          <source>The command also has a reciprocal command returning items in the reverse order, called &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt;, which is otherwise identical.</source>
          <target state="translated">このコマンドには、&lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt;と呼ばれる逆の順序でアイテムを返す相互コマンドもあります。これは、他の点では同じです。</target>
        </trans-unit>
        <trans-unit id="b51d9780c5d61a87b53bd27d3ac5c24a4b0638d8" translate="yes" xml:space="preserve">
          <source>The command behavior can be modified by two options: &lt;strong&gt;FORCE&lt;/strong&gt; and &lt;strong&gt;TAKEOVER&lt;/strong&gt;.</source>
          <target state="translated">コマンドの動作は、&lt;strong&gt;FORCE&lt;/strong&gt;と&lt;strong&gt;TAKEOVERの&lt;/strong&gt; 2つのオプションで変更できます。</target>
        </trans-unit>
        <trans-unit id="0e77b773bc1837b920cb41a24e1a0ef629792be6" translate="yes" xml:space="preserve">
          <source>The command behavior is the following:</source>
          <target state="translated">コマンドの動作は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="913ef9d1ec1890a263c7a3667b134a3de340bd38" translate="yes" xml:space="preserve">
          <source>The command can accept a variable number of arguments so it always returns an array of positions even when a single element is specified.</source>
          <target state="translated">このコマンドは可変数の引数を受け付けることができるので、単一の要素が指定された場合でも常に位置の配列を返します。</target>
        </trans-unit>
        <trans-unit id="b9a60a6fc9ab713863d0cdace7cfdb88da1428ea" translate="yes" xml:space="preserve">
          <source>The command can be called with four different arguments:</source>
          <target state="translated">コマンドは4つの異なる引数で呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="d2095dc05dd59018ca256f0a5fc566c35f0f4cc7" translate="yes" xml:space="preserve">
          <source>The command default is to return unsorted items. Two different sorting methods can be invoked using the following two options:</source>
          <target state="translated">コマンドのデフォルトでは、ソートされていない項目を返すようになっています。以下の2つのオプションを使用して、2つの異なるソート方法を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="958832c31d8e5542b245102310cbd53d9f34320f" translate="yes" xml:space="preserve">
          <source>The command does not succeed and returns an error in the following cases:</source>
          <target state="translated">以下の場合、コマンドが成功せず、エラーを返します。</target>
        </trans-unit>
        <trans-unit id="32a8711ea8a78a0226239432ccf720cba86e66af" translate="yes" xml:space="preserve">
          <source>The command fails if the same slot is specified multiple times.</source>
          <target state="translated">同じスロットが複数回指定された場合、コマンドは失敗します。</target>
        </trans-unit>
        <trans-unit id="b6f1f38c10e41d6cb188193c5859a8d2a04588ed" translate="yes" xml:space="preserve">
          <source>The command has multiple options, however most are mainly for internal use in order to transfer the effects of &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; or other commands to the AOF file and to propagate the same effects to the slaves, and are unlikely to be useful to normal users:</source>
          <target state="translated">コマンドには複数のオプションがありますが、ほとんどは主に&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;または他のコマンドの効果をAOFファイルに転送し、スレーブに同じ効果を伝播するための内部使用のためのものであり、通常のユーザーには役立ちそうにありません。</target>
        </trans-unit>
        <trans-unit id="aff611203495e6eb730550d71c578dbd6ea9eaee" translate="yes" xml:space="preserve">
          <source>The command internally uses &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt; to generate the serialized version of the key value, and &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; in order to synthesize the key in the target instance. The source instance acts as a client for the target instance. If the target instance returns OK to the &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command, the source instance deletes the key using &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;.</source>
          <target state="translated">コマンドは内部的に&lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt;を使用してシリアル化されたバージョンのキー値を生成し、&lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt;を使用してターゲットインスタンスでキーを合成します。ソースインスタンスは、ターゲットインスタンスのクライアントとして機能します。ターゲットインスタンスが&lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt;コマンドにOKを返す場合、ソースインスタンスは&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;を使用してキーを削除します。</target>
        </trans-unit>
        <trans-unit id="a8dc74da7f9aeeb2a318e48a6c60e1183a0da365" translate="yes" xml:space="preserve">
          <source>The command is always propagated in the replication link and the Append Only File as a &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; operation, so that differences in the underlying floating point math implementation will not be sources of inconsistency.</source>
          <target state="translated">コマンドは常にレプリケーションリンクとAppend Only Fileで&lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt;操作として伝達されるため、基になる浮動小数点演算実装の違いが不整合の原因になることはありません。</target>
        </trans-unit>
        <trans-unit id="89297d1be1338bce5eaa89c5524f124377b2d8a5" translate="yes" xml:space="preserve">
          <source>The command is always propagated in the replication link and the Append Only File as a &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; operation, so that differences in the underlying floating point math implementation will not be sources of inconsistency.</source>
          <target state="translated">コマンドは常にレプリケーションリンクと追加操作のみのファイルに&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;操作として伝達されるため、基になる浮動小数点演算の実装の違いが不整合の原因になることはありません。</target>
        </trans-unit>
        <trans-unit id="a86933f06a2ba31db5ee212ee8cc903bc3c40f34" translate="yes" xml:space="preserve">
          <source>The command is atomic and blocks the two instances for the time required to transfer the key, at any given time the key will appear to exist in a given instance or in the other instance, unless a timeout error occurs. In 3.2 and above, multiple keys can be pipelined in a single call to &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; by passing the empty string (&quot;&quot;) as key and adding the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; clause.</source>
          <target state="translated">コマンドはアトミックであり、タイムアウトエラーが発生しない限り、キーの転送に必要な時間の間、2つのインスタンスをブロックします。キーは常に、特定のインスタンスまたは他のインスタンスに存在するように見えます。3.2以降では、空の文字列（ &quot;&quot;）をキーとして渡し、&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt;句を追加することで、&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;への1回の呼び出しで複数のキーをパイプライン処理できます。</target>
        </trans-unit>
        <trans-unit id="c4335b586f31c83a0ae96d3ccf6ca0cfaf3a8429" translate="yes" xml:space="preserve">
          <source>The command is used in order to remove a node, specified via its node ID, from the set of &lt;em&gt;known nodes&lt;/em&gt; of the Redis Cluster node receiving the command. In other words the specified node is removed from the &lt;em&gt;nodes table&lt;/em&gt; of the node receiving the command.</source>
          <target state="translated">このコマンドは、ノードIDで指定されたノードを、コマンドを受信するRedisクラスターノードの&lt;em&gt;既知のノード&lt;/em&gt;のセットから削除するために使用されます。つまり、指定されたノードは、コマンドを受信するノードの&lt;em&gt;ノードテーブル&lt;/em&gt;から削除されます。</target>
        </trans-unit>
        <trans-unit id="9389c07b5be98086699ffdc71ab5655cfb6ab6aa" translate="yes" xml:space="preserve">
          <source>The command just returns the ID of the current connection. Every connection ID has certain guarantees:</source>
          <target state="translated">このコマンドは現在の接続の ID を返します。すべての接続IDには一定の保証があります。</target>
        </trans-unit>
        <trans-unit id="1e36a1bc65a56400c52d66e29f9ce1757bbf2e26" translate="yes" xml:space="preserve">
          <source>The command may fail with an error for several reasons: if the file cannot be written or if the server is not configured to use an external ACL file.</source>
          <target state="translated">このコマンドは、ファイルを書き込めない場合や、サーバーが外部ACLファイルを使用するように設定されていない場合など、いくつかの理由でエラーが発生して失敗することがあります。</target>
        </trans-unit>
        <trans-unit id="344468f4b5f6d51949f0a2c14063fc0a3b852987" translate="yes" xml:space="preserve">
          <source>The command may fail with an error for several reasons: if the file is not readable, if there is an error inside the file, and in such case the error will be reported to the user in the error. Finally the command will fail if the server is not configured to use an external ACL file.</source>
          <target state="translated">コマンドはいくつかの理由でエラーで失敗することがあります:ファイルが読めない場合、ファイル内にエラーがある場合、そのような場合はエラーでユーザーに報告されます。最後に、サーバが外部ACLファイルを使用するように設定されていない場合、コマンドは失敗します。</target>
        </trans-unit>
        <trans-unit id="4aa2b5549f1c670208cc851a7701050140450874" translate="yes" xml:space="preserve">
          <source>The command may reply with an error in certain cases, as documented above.</source>
          <target state="translated">上記で説明したように、特定のケースではコマンドがエラーで返答することがあります。</target>
        </trans-unit>
        <trans-unit id="1a0d0753b06a3754e2b6097d7df536fcb852c4ed" translate="yes" xml:space="preserve">
          <source>The command only works if all the specified slots are already associated with some node.</source>
          <target state="translated">このコマンドは、指定されたすべてのスロットがすでにいくつかのノードに関連付けられている場合にのみ動作します。</target>
        </trans-unit>
        <trans-unit id="43abdb47aec6d5ef3beb1e76ddc4c6370f0f6354" translate="yes" xml:space="preserve">
          <source>The command only works if all the specified slots are, from the point of view of the node receiving the command, currently not assigned. A node will refuse to take ownership for slots that already belong to some other node (including itself).</source>
          <target state="translated">このコマンドは、コマンドを受信したノードから見て、指定されたすべてのスロットが現在割り当てられていない場合にのみ機能します。ノードは、すでに他のノード(自分自身を含む)に属しているスロットの所有権を取得することを拒否します。</target>
        </trans-unit>
        <trans-unit id="63f80c4f55dda4254e917500ebea54b888f88f18" translate="yes" xml:space="preserve">
          <source>The command optionally returns additional information using the following options:</source>
          <target state="translated">このコマンドは、オプションで以下のオプションを使用して追加情報を返します。</target>
        </trans-unit>
        <trans-unit id="94c796162b217920f7fda542eef1c135d9fe60f2" translate="yes" xml:space="preserve">
          <source>The command output is an hexadecimal representation of a binary string. By default it emits 256 bits (so 64 hex characters). The user can provide an argument in form of number of bits to emit from 1 to 1024 to change the output length. Note that the number of bits provided is always rounded to the next multiple of 4. So for instance asking for just 1 bit password will result in 4 bits to be emitted, in the form of a single hex character.</source>
          <target state="translated">コマンドの出力は、バイナリ文字列の16進数表現です。デフォルトでは256ビット(16進数64文字)を出力します。ユーザーは、出力するビット数を1から1024までの間で指定することで、出力の長さを変更することができます。指定されたビット数は常に4の倍数に丸められますので、例えば1ビットのパスワードを要求すると、16進数1文字の形で4ビットが出力されることになります。</target>
        </trans-unit>
        <trans-unit id="11f65176db9808f7847abb3d37f52b1528a65ac2" translate="yes" xml:space="preserve">
          <source>The command performs the following actions:</source>
          <target state="translated">コマンドは以下のアクションを実行します。</target>
        </trans-unit>
        <trans-unit id="4778a65d0ba749aa47da2ae16d4895853e331c48" translate="yes" xml:space="preserve">
          <source>The command provides a list of replica nodes replicating from the specified master node. The list is provided in the same format used by &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; (please refer to its documentation for the specification of the format).</source>
          <target state="translated">このコマンドは、指定されたマスターノードから複製するレプリカノードのリストを提供します。リストは、&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODESで&lt;/a&gt;使用されているものと同じ形式で提供されます（形式の仕様については、そのドキュメントを参照してください）。</target>
        </trans-unit>
        <trans-unit id="75946e7c075807ac0ec08889c9ae03a9a184e3d3" translate="yes" xml:space="preserve">
          <source>The command reconfigures a node as a replica of the specified master. If the node receiving the command is an &lt;em&gt;empty master&lt;/em&gt;, as a side effect of the command, the node role is changed from master to replica.</source>
          <target state="translated">このコマンドは、指定されたマスターのレプリカとしてノードを再構成します。コマンドを受け取るノードが&lt;em&gt;空のマスター&lt;/em&gt;である場合、コマンドの副作用として、ノードの役割がマスターからレプリカに変更されます。</target>
        </trans-unit>
        <trans-unit id="4ebd54c736f27aa3986d5c357015059ce2df6b55" translate="yes" xml:space="preserve">
          <source>The command returns 11 characters Geohash strings, so no precision is loss compared to the Redis internal 52 bit representation. The returned Geohashes have the following properties:</source>
          <target state="translated">このコマンドは11文字のGeohash文字列を返すので、Redis内部の52ビット表現と比較しても精度の損失はありません。返されたGeohashは以下のプロパティを持っています。</target>
        </trans-unit>
        <trans-unit id="68e0628c08bc7ef387bda65ff2fbb36117fe6040" translate="yes" xml:space="preserve">
          <source>The command returns &lt;code&gt;-1&lt;/code&gt; if the key exists but has no associated expire.</source>
          <target state="translated">キーは存在するが、関連付けられている有効期限がない場合、コマンドは &lt;code&gt;-1&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="9900e726bbbfd1d7f718d4225bf8abc8e591a526" translate="yes" xml:space="preserve">
          <source>The command returns &lt;code&gt;-2&lt;/code&gt; if the key does not exist.</source>
          <target state="translated">キーが存在しない場合、コマンドは &lt;code&gt;-2&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="263f04bc6090861d15e393e44fe1a4d42bd2408e" translate="yes" xml:space="preserve">
          <source>The command returns a &lt;a href=&quot;https://redis.io/topics/protocol#nil-reply&quot;&gt;Null reply&lt;/a&gt; when used with the &lt;code&gt;NOMKSTREAM&lt;/code&gt; option and the key doesn't exist.</source>
          <target state="translated">このコマンドは、 &lt;code&gt;NOMKSTREAM&lt;/code&gt; オプションとともに使用され、キーが存在しない場合に&lt;a href=&quot;https://redis.io/topics/protocol#nil-reply&quot;&gt;Null応答を&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="7cf3ff8b30b845ead44db4d82109c56f01457aed" translate="yes" xml:space="preserve">
          <source>The command returns all the messages successfully claimed, in the same format as &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;. However if the &lt;code&gt;JUSTID&lt;/code&gt; option was specified, only the message IDs are reported, without including the actual message.</source>
          <target state="translated">このコマンドは、正常に要求されたすべてのメッセージを&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;と同じ形式で返します。ただし、 &lt;code&gt;JUSTID&lt;/code&gt; オプションが指定されている場合は、メッセージIDのみが報告され、実際のメッセージは含まれません。</target>
        </trans-unit>
        <trans-unit id="d91929db6b639c8bbfadd32a8fc0bdbaccdfc27a" translate="yes" xml:space="preserve">
          <source>The command returns all the rules defined for an existing ACL user.</source>
          <target state="translated">このコマンドは、既存の ACL ユーザーに対して定義されたすべてのルールを返します。</target>
        </trans-unit>
        <trans-unit id="61a71cfae2a2b43a889c9e6bd259963281080b15" translate="yes" xml:space="preserve">
          <source>The command returns an array of elements. The first element is the role of the instance, as one of the following three strings:</source>
          <target state="translated">このコマンドは要素の配列を返します。最初の要素はインスタンスの役割で、以下の3つの文字列のうちの1つです。</target>
        </trans-unit>
        <trans-unit id="aa91d91e133acc78d18bba2922ce5bd5a6f7f354" translate="yes" xml:space="preserve">
          <source>The command returns an array of keys names stored in the contacted node and hashing to the specified hash slot. The maximum number of keys to return is specified via the &lt;code&gt;count&lt;/code&gt; argument, so that it is possible for the user of this API to batch-processing keys.</source>
          <target state="translated">このコマンドは、接続されたノードに格納され、指定されたハッシュスロットにハッシュするキー名の配列を返します。返されるキーの最大数は &lt;code&gt;count&lt;/code&gt; 引数で指定されるため、このAPIのユーザーはキーをバッチ処理できます。</target>
        </trans-unit>
        <trans-unit id="e6bc3ec726a066c82649799db4b402b18c37620c" translate="yes" xml:space="preserve">
          <source>The command returns an array of results: each element of the returned array is an array composed of a two element containing the key name and the entries reported for that key. The entries reported are full stream entries, having IDs and the list of all the fields and values. Field and values are guaranteed to be reported in the same order they were added by &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;.</source>
          <target state="translated">コマンドは結果の配列を返します。返された配列の各要素は、キー名とそのキーについて報告されたエントリを含む2つの要素で構成される配列です。報告されるエントリは、IDとすべてのフィールドと値のリストを持つ完全なストリームエントリです。フィールドと値は、&lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;によって追加されたのと同じ順序で報告されることが保証されています。</target>
        </trans-unit>
        <trans-unit id="59dca4232b984a49106f20180ccd68dd85cde434" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is a four elements array representing the event's name, timestamp, latest and all-time latency measurements.</source>
          <target state="translated">コマンドは、各要素がイベント名、タイムスタンプ、最新および全時間のレイテンシ測定値を表す 4 つの要素の配列を返します。</target>
        </trans-unit>
        <trans-unit id="d59bdbda1d4276c59a205bc75690c8792da83930" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is a two elements array representing longitude and latitude (x,y) of each member name passed as argument to the command.</source>
          <target state="translated">コマンドは、引数に渡された各メンバ名の経度と緯度(x,y)を表す2要素の配列を返します。</target>
        </trans-unit>
        <trans-unit id="c2da6177dc0df5d03aa7780c4ae1b3e2b3b664b6" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is a two elements array representing the timestamp and the latency of the event.</source>
          <target state="translated">このコマンドは、各要素がタイムスタンプとイベントの待ち時間を表す2つの要素の配列を返します。</target>
        </trans-unit>
        <trans-unit id="299bd584711e094e5bb4f6fecbd5c79b634a792b" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is the Geohash corresponding to each member name passed as argument to the command.</source>
          <target state="translated">このコマンドは、各要素が、コマンドの引数として渡された各メンバ名に対応するジオハッシュである配列を返します。</target>
        </trans-unit>
        <trans-unit id="63618225d498ac1d95054dac445c00eb7942b4b2" translate="yes" xml:space="preserve">
          <source>The command returns an array with each entry being the corresponding result of the sub command given at the same position. &lt;code&gt;OVERFLOW&lt;/code&gt; subcommands don't count as generating a reply.</source>
          <target state="translated">コマンドは配列を返し、各エントリは同じ位置にあるサブコマンドの対応する結果になります。 &lt;code&gt;OVERFLOW&lt;/code&gt; サブコマンドは、応答の生成としてカウントされません。</target>
        </trans-unit>
        <trans-unit id="0d3fdeb1c470e8f290735d9f570986e08dde9291" translate="yes" xml:space="preserve">
          <source>The command returns an error when the &lt;code&gt;destination&lt;/code&gt; key already exists. The &lt;code&gt;REPLACE&lt;/code&gt; option removes the &lt;code&gt;destination&lt;/code&gt; key before copying the value to it.</source>
          <target state="translated">&lt;code&gt;destination&lt;/code&gt; キーがすでに存在する場合、コマンドはエラーを返します。 &lt;code&gt;REPLACE&lt;/code&gt; オプションが削除され &lt;code&gt;destination&lt;/code&gt; に値をコピーする前にキーを。</target>
        </trans-unit>
        <trans-unit id="599682f8e696ffcef9a41f128a35f008ec692b72" translate="yes" xml:space="preserve">
          <source>The command returns data in different format depending on the way it is called, as previously explained in this page. However the reply is always an array of items.</source>
          <target state="translated">コマンドは、以前このページで説明したように、呼び出し方によって異なる形式でデータを返します。しかし、返信は常に項目の配列です。</target>
        </trans-unit>
        <trans-unit id="64555ea6ac3dd842f32e77db3528c6314f55ca4d" translate="yes" xml:space="preserve">
          <source>The command returns data in the same format as &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;.</source>
          <target state="translated">このコマンドは、&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;と同じ形式でデータを返します。</target>
        </trans-unit>
        <trans-unit id="f11ff6c087b294c263c888936947fb519a703574" translate="yes" xml:space="preserve">
          <source>The command returns information about the current client connection's use of the &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;server assisted client side caching&lt;/a&gt; feature.</source>
          <target state="translated">このコマンドは、現在のクライアント接続による&lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;サーバー支援クライアント側キャッシュ&lt;/a&gt;機能の使用に関する情報を返します。</target>
        </trans-unit>
        <trans-unit id="a84d7525c4b51e3bbe67ae31259831e14b15be40" translate="yes" xml:space="preserve">
          <source>The command returns information and statistics about the current client connection in a mostly human readable format.</source>
          <target state="translated">このコマンドは、現在のクライアント接続に関する情報と統計情報を、ほとんど人間が読める形式で返します。</target>
        </trans-unit>
        <trans-unit id="854de1e7ab31a436fe3503c72376101ec2883922" translate="yes" xml:space="preserve">
          <source>The command returns the ID of the added entry. The ID is the one auto-generated if &lt;code&gt;*&lt;/code&gt; is passed as ID argument, otherwise the command just returns the same ID specified by the user during insertion.</source>
          <target state="translated">このコマンドは、追加されたエントリーのIDを返します。IDは、 &lt;code&gt;*&lt;/code&gt; がID引数として渡された場合に自動生成されるIDです。それ以外の場合、コマンドは挿入時にユーザーが指定した同じIDを返します。</target>
        </trans-unit>
        <trans-unit id="7247b723aad05766caad65ebc7ede74ba6d1e1dd" translate="yes" xml:space="preserve">
          <source>The command returns the distance as a double (represented as a string) in the specified unit, or NULL if one or both the elements are missing.</source>
          <target state="translated">このコマンドは、指定された単位での距離をダブル(文字列で表現)で返します。</target>
        </trans-unit>
        <trans-unit id="a226a6dbee33f1a9bdf015f4eb2291dd60f7022b" translate="yes" xml:space="preserve">
          <source>The command returns the entries with IDs matching the specified range, from the higher ID to the lower ID matching. The returned entries are complete, that means that the ID and all the fields they are composed are returned. Moreover the entries are returned with their fields and values in the exact same order as &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; added them.</source>
          <target state="translated">このコマンドは、高いIDから低いIDまで、指定された範囲に一致するIDを持つエントリを返します。返されたエントリは完全です。つまり、IDとそれらを構成するすべてのフィールドが返されます。さらに、&lt;a href=&quot;xadd&quot;&gt;XADDが&lt;/a&gt;追加したのとまったく同じ順序で、フィールドと値とともにエントリが返されます。</target>
        </trans-unit>
        <trans-unit id="444f426015abc65778606f24926eb62888ddcfbe" translate="yes" xml:space="preserve">
          <source>The command returns the entries with IDs matching the specified range. The returned entries are complete, that means that the ID and all the fields they are composed are returned. Moreover, the entries are returned with their fields and values in the exact same order as &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; added them.</source>
          <target state="translated">コマンドは、指定された範囲と一致するIDを持つエントリを返します。返されたエントリは完全です。つまり、IDとそれらを構成するすべてのフィールドが返されます。さらに、&lt;a href=&quot;xadd&quot;&gt;XADDが&lt;/a&gt;追加したのとまったく同じ順序で、フィールドと値とともにエントリが返されます。</target>
        </trans-unit>
        <trans-unit id="62939248d8e32365e6957d42055f2de89814a292" translate="yes" xml:space="preserve">
          <source>The command returns the index of matching elements inside a Redis list. By default, when no options are given, it will scan the list from head to tail, looking for the first match of &quot;element&quot;. If the element is found, its index (the zero-based position in the list) is returned. Otherwise, if no match is found, NULL is returned.</source>
          <target state="translated">このコマンドは、Redisリスト内のマッチする要素のインデックスを返す。デフォルトでは、オプションが指定されていない場合、リストの先頭から末尾までスキャンし、&quot;element &quot;の最初にマッチする要素を探します。要素が見つかった場合、そのインデックス(リスト内のゼロベースの位置)が返されます。そうでない場合は、一致するものが見つからなかった場合はNULLが返されます。</target>
        </trans-unit>
        <trans-unit id="f216246f788da7553b72042887561f848de4e55c" translate="yes" xml:space="preserve">
          <source>The command returns the integer representing the matching element, or null if there is no match. However, if the &lt;code&gt;COUNT&lt;/code&gt; option is given the command returns an array (empty if there are no matches).</source>
          <target state="translated">このコマンドは、一致する要素を表す整数を返します。一致する要素がない場合はnullを返します。ただし、 &lt;code&gt;COUNT&lt;/code&gt; オプションが指定されている場合、コマンドは配列を返します（一致するものがない場合は空）。</target>
        </trans-unit>
        <trans-unit id="25a3d21f3dbcaa198bbe343d23738bbd28a872e1" translate="yes" xml:space="preserve">
          <source>The command returns the number of &lt;em&gt;failure reports&lt;/em&gt; for the specified node. Failure reports are the way Redis Cluster uses in order to promote a &lt;code&gt;PFAIL&lt;/code&gt; state, that means a node is not reachable, to a &lt;code&gt;FAIL&lt;/code&gt; state, that means that the majority of masters in the cluster agreed within a window of time that the node is not reachable.</source>
          <target state="translated">このコマンドは、指定されたノードの&lt;em&gt;障害レポート&lt;/em&gt;の数を返します。障害レポートは、ノードに到達できないことを意味する &lt;code&gt;PFAIL&lt;/code&gt; 状態をノードが到達しない時間枠内で合意されたクラスター内の大部分のマスターを意味する &lt;code&gt;FAIL&lt;/code&gt; 状態に昇格させるためにRedisクラスターが使用する方法です到達可能。</target>
        </trans-unit>
        <trans-unit id="11d6963d3c757dd171e4446f81aa6fbb2b4f3cbe" translate="yes" xml:space="preserve">
          <source>The command returns the number of entries deleted from the stream.</source>
          <target state="translated">このコマンドは、ストリームから削除されたエントリの数を返します。</target>
        </trans-unit>
        <trans-unit id="90a0913f53aff4fc9a2c5f477057692b16cb61c2" translate="yes" xml:space="preserve">
          <source>The command returns the number of messages successfully acknowledged. Certain message IDs may no longer be part of the PEL (for example because they have been already acknowledge), and XACK will not count them as successfully acknowledged.</source>
          <target state="translated">このコマンドは確認に成功したメッセージの数を返します。特定のメッセージIDはPELの一部ではなくなっているかもしれません(例えば、既に確認済みである場合など)。</target>
        </trans-unit>
        <trans-unit id="25862d0137651f4c50c642c84cec4c703a39cc67" translate="yes" xml:space="preserve">
          <source>The command returns the position of the first bit set to 1 or 0 according to the request.</source>
          <target state="translated">コマンドは、要求に応じて1または0に設定された第1ビットの位置を返す。</target>
        </trans-unit>
        <trans-unit id="0f2fe335e56363e46ba8079d81809ab997be12eb" translate="yes" xml:space="preserve">
          <source>The command returns the stream entries matching a given range of IDs. The range is specified by a minimum and maximum ID. All the entires having an ID between the two specified or exactly one of the two IDs specified (closed interval) are returned.</source>
          <target state="translated">このコマンドは、指定された範囲の ID に一致するストリームエントリを返します。範囲は最小値と最大値で指定されます。指定された2つのIDの間、または指定された2つのIDのうち正確に1つのID(クローズドインターバル)を持つすべてのエントリが返されます。</target>
        </trans-unit>
        <trans-unit id="383ccd477dc944e0c3ebd47dbea4b6b2017eb35b" translate="yes" xml:space="preserve">
          <source>The command returns the stream entries matching a given range of IDs. The range is specified by a minimum and maximum ID. All the entries having an ID between the two specified or exactly one of the two IDs specified (closed interval) are returned.</source>
          <target state="translated">このコマンドは、指定された範囲の ID に一致するストリームエントリを返します。範囲は、最小値と最大値の ID で指定されます。指定された2つのIDの間、または指定された2つのIDのうち正確に1つのID(クローズドインターバル)を持つすべてのエントリが返されます。</target>
        </trans-unit>
        <trans-unit id="9be8f3674812a7bb5d9fb3101b17c38b3646405b" translate="yes" xml:space="preserve">
          <source>The command shows a list of all the usernames of the currently configured users in the Redis ACL system.</source>
          <target state="translated">このコマンドは、Redis ACLシステムで現在構成されているユーザーのすべてのユーザー名のリストを表示します。</target>
        </trans-unit>
        <trans-unit id="13c06047a0b602e177d71981a4d9e29349f77a37" translate="yes" xml:space="preserve">
          <source>The command shows a list of recent ACL security events:</source>
          <target state="translated">このコマンドは、最近の ACL セキュリティ イベントのリストを表示します。</target>
        </trans-unit>
        <trans-unit id="2382a9cd868ca3bdb3953efcef5f79ded0789a3c" translate="yes" xml:space="preserve">
          <source>The command shows the available ACL categories if called without arguments. If a category name is given, the command shows all the Redis commands in the specified category.</source>
          <target state="translated">このコマンドは、引数なしで呼び出された場合、利用可能な ACL カテゴリを表示します。カテゴリ名が指定された場合、このコマンドは指定されたカテゴリ内のすべての Redis コマンドを表示します。</target>
        </trans-unit>
        <trans-unit id="724b74eeaa692174c50661ecd1cc035a30521473" translate="yes" xml:space="preserve">
          <source>The command shows the currently active ACL rules in the Redis server. Each line in the returned array defines a different user, and the format is the same used in the redis.conf file or the external ACL file, so you can cut and paste what is returned by the ACL LIST command directly inside a configuration file if you wish (but make sure to check &lt;a href=&quot;acl-save&quot;&gt;ACL SAVE&lt;/a&gt;).</source>
          <target state="translated">このコマンドは、Redisサーバーで現在アクティブなACLルールを表示します。返される配列の各行は異なるユーザーを定義し、形式はredis.confファイルまたは外部ACLファイルで使用されるものと同じであるため、ACLLISTコマンドによって返されるものを構成ファイル内に直接カットアンドペーストできます。必要に応じて（ただし、必ず&lt;a href=&quot;acl-save&quot;&gt;ACL SAVE&lt;/a&gt;を確認してください）。</target>
        </trans-unit>
        <trans-unit id="26b22d366f18019ba16fe8b5883618685376f0fb" translate="yes" xml:space="preserve">
          <source>The command takes arguments in the standard format x,y so the longitude must be specified before the latitude. There are limits to the coordinates that can be indexed: areas very near to the poles are not indexable. The exact limits, as specified by EPSG:900913 / EPSG:3785 / OSGEO:41001 are the following:</source>
          <target state="translated">このコマンドは標準フォーマット x,y で引数をとりますので、緯度の前に経度を指定しなければなりません。インデックス化できる座標には制限があります:極地に非常に近い地域はインデックス化できません。EPSG:900913/EPSG:3785/OSGEO:41001で指定されている正確な制限は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="69e46f6ba0a5d03f8dc0e5aa7af7b003d2e71820" translate="yes" xml:space="preserve">
          <source>The command treats a Redis string as a array of bits, and is capable of addressing specific integer fields of varying bit widths and arbitrary non (necessary) aligned offset. In practical terms using this command you can set, for example, a signed 5 bits integer at bit offset 1234 to a specific value, retrieve a 31 bit unsigned integer from offset 4567. Similarly the command handles increments and decrements of the specified integers, providing guaranteed and well specified overflow and underflow behavior that the user can configure.</source>
          <target state="translated">このコマンドは、Redis 文字列をビットの配列として扱い、異なるビット幅と任意の(必要のない)アラインメントされたオフセットの特定の整数フィールドをアドレス指定することができます。実用的には、このコマンドを使用して、例えばビットオフセット1234の符号付き5ビット整数を特定の値に設定したり、オフセット4567から31ビットの符号なし整数を取得したりすることができます。同様に、 こ の コ マ ン ド は指定 さ れた整数の増分お よ び減分を処理 し 、 ユーザーが構成で き る オーバーフ ロ ーお よ びアンダーフ ロ ーの動作を保証 し て指定す る こ と がで き ます。</target>
        </trans-unit>
        <trans-unit id="13c5fae6e8ea2d19068840627307808e57ed434f" translate="yes" xml:space="preserve">
          <source>The command will fail if the specified node is not known or if it is not a master according to the node table of the node receiving the command.</source>
          <target state="translated">指定されたノードがわからない場合や、コマンドを受信したノードのノードテーブルによるとマスタでない場合は、コマンドは失敗します。</target>
        </trans-unit>
        <trans-unit id="83094ac4a33e4188f42d4a2c20d7dbf3f6620df3" translate="yes" xml:space="preserve">
          <source>The command will report an error when the user attempts to index coordinates outside the specified ranges.</source>
          <target state="translated">このコマンドは、ユーザが指定された範囲外の座標をインデックス化しようとした場合にエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="c3184d09a508b5c6fdb922b8b826ae4f98d9a67a" translate="yes" xml:space="preserve">
          <source>The command will return up to 160 timestamp-latency pairs for the &lt;code&gt;event&lt;/code&gt;.</source>
          <target state="translated">このコマンドは、 &lt;code&gt;event&lt;/code&gt; に対して最大160のタイムスタンプとレイテンシのペアを返します。</target>
        </trans-unit>
        <trans-unit id="7a427adc7c29c84562496f4e3dd746f3b4883cbf" translate="yes" xml:space="preserve">
          <source>The command with its set of subcommands is useful in order to start and end cluster live resharding operations, which are accomplished by setting a hash slot in migrating state in the source node, and importing state in the destination node.</source>
          <target state="translated">サブコマンドのセットを持つこのコマンドは、クラスタのライブ再シャーディング操作を開始したり終了したりするのに便利です。</target>
        </trans-unit>
        <trans-unit id="f34a45ceabab28f1008f0f9d2405fbba32c8e338" translate="yes" xml:space="preserve">
          <source>The command works in the same way even if the script was already present in the script cache.</source>
          <target state="translated">このコマンドは、スクリプトがすでにスクリプトキャッシュに存在していた場合でも、同じように動作します。</target>
        </trans-unit>
        <trans-unit id="58212b0000147d5bba3264e4996ad46fd286b905" translate="yes" xml:space="preserve">
          <source>The common use case for this command is to retrieve geospatial items near a specified point not farther than a given amount of meters (or other units). This allows, for example, to suggest mobile users of an application nearby places.</source>
          <target state="translated">このコマンドの一般的な使用例は、与えられた量のメートル(または他の単位)よりも遠くない指定された点の近くの地理空間アイテムを取得することです。これにより、例えば、アプリケーションのモバイルユーザーに近くの場所を提案することができます。</target>
        </trans-unit>
        <trans-unit id="83d84f2e6d0bc285dccf475994bf2dfe5a7034d1" translate="yes" xml:space="preserve">
          <source>The computed merged HyperLogLog is set to the destination variable, which is created if does not exist (defaulting to an empty HyperLogLog).</source>
          <target state="translated">計算されたマージされたHyperLogが格納先の変数に設定され、存在しない場合に作成されます(デフォルトは空のHyperLogです)。</target>
        </trans-unit>
        <trans-unit id="892b6264b392f8ad48dfbfcfe6dff8a94a45c598" translate="yes" xml:space="preserve">
          <source>The configuration can be done by editing &lt;code&gt;redis.conf&lt;/code&gt; or while the server is running using the &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; and &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; commands.</source>
          <target state="translated">設定は、 &lt;code&gt;redis.conf&lt;/code&gt; を編集するか、&lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt;コマンドと&lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt;コマンドを使用してサーバーが実行されている間に行うことができます。</target>
        </trans-unit>
        <trans-unit id="d9924fa1c31458da66b46121ed81593fd5a4fbad" translate="yes" xml:space="preserve">
          <source>The connection name can be inspected using &lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt;.</source>
          <target state="translated">接続名は&lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt;を使用して検査できます。</target>
        </trans-unit>
        <trans-unit id="6da99886277806746e8e984d617153310b22b176" translate="yes" xml:space="preserve">
          <source>The connection we have with the server is persistent and was never closed so far.</source>
          <target state="translated">サーバーとの接続はしつこく、今のところ閉じたことはありませんでした。</target>
        </trans-unit>
        <trans-unit id="812045821e03fcc1f9ffc04b5ef35de3b612856e" translate="yes" xml:space="preserve">
          <source>The consumer group will be destroyed even if there are active consumers and pending messages, so make sure to call this command only when really needed.</source>
          <target state="translated">コンシューマグループは、アクティブなコンシューマや保留中のメッセージがあっても破棄されるので、本当に必要なときだけこのコマンドを呼び出すようにしてください。</target>
        </trans-unit>
        <trans-unit id="8d4c2cd743047005cdb993a3a9d7afc356bb6664" translate="yes" xml:space="preserve">
          <source>The consumer will do:</source>
          <target state="translated">消費者がやる。</target>
        </trans-unit>
        <trans-unit id="a09ada6e198e1cc27a58e1c5cd2063765d34a60e" translate="yes" xml:space="preserve">
          <source>The coordinates as a two items x,y array (longitude,latitude).</source>
          <target state="translated">座標を x,y の 2 項目の配列 (longitude,latitude)にしたもの。</target>
        </trans-unit>
        <trans-unit id="d6f85adf1bad41bef7242defbfacbfdea663e0f0" translate="yes" xml:space="preserve">
          <source>The counter is created in a way that it only will survive one second, starting from the first request performed in the current second. If there are more than 10 requests in the same second the counter will reach a value greater than 10, otherwise it will expire and start again from 0.</source>
          <target state="translated">カウンタは、現在の秒に実行された最初のリクエストから 1 秒間だけ生き残るように作成されます。同じ秒に10以上のリクエストがあった場合、カウンタは10以上の値に達し、そうでない場合は期限切れとなり、0から再開します。</target>
        </trans-unit>
        <trans-unit id="224e5c836dc00eb5744ec82792c094203a16fc27" translate="yes" xml:space="preserve">
          <source>The counter pattern is the most obvious thing you can do with Redis atomic increment operations. The idea is simply send an &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; command to Redis every time an operation occurs. For instance in a web application we may want to know how many page views this user did every day of the year.</source>
          <target state="translated">カウンターパターンは、Redisのアトミックなインクリメント操作で実行できる最も明白なことです。アイデアは、操作が発生するたびに&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;コマンドをRedisに送信するだけです。たとえば、Webアプリケーションでは、このユーザーが1年間に何回ページビューしたかを知りたい場合があります。</target>
        </trans-unit>
        <trans-unit id="b77e139112433671a542addfa1a32daf47ee322d" translate="yes" xml:space="preserve">
          <source>The crashed client C3 still holds it, so Redis will reply with &lt;code&gt;0&lt;/code&gt; to C4.</source>
          <target state="translated">クラッシュしたクライアントC3はまだそれを保持しているため、Redisは &lt;code&gt;0&lt;/code&gt; でC4に応答します。</target>
        </trans-unit>
        <trans-unit id="8423b58d7e3aaab1a157d34537088cf7071837ad" translate="yes" xml:space="preserve">
          <source>The current field content or the specified increment are not parsable as a double precision floating point number.</source>
          <target state="translated">現在のフィールド内容や指定されたインクリメントは、倍精度浮動小数点数として解析できません。</target>
        </trans-unit>
        <trans-unit id="838fa5216f1f1cdff3694527a8a6d1c1f9f94411" translate="yes" xml:space="preserve">
          <source>The current key content or the specified increment are not parsable as a double precision floating point number.</source>
          <target state="translated">現在のキーの内容や指定されたインクリメントは、倍精度の浮動小数点数として解析できません。</target>
        </trans-unit>
        <trans-unit id="931ea7e75c2dded718677c9f4a1676825fcb3baa" translate="yes" xml:space="preserve">
          <source>The current master replication offset, which is an offset that masters and replicas share to understand, in partial resynchronizations, the part of the replication stream the replicas needs to fetch to continue.</source>
          <target state="translated">現在のマスター レプリケーション オフセットは、部分的な再同期化で、マスターとレプリカが理解するために共有するオフセットで、レプリカが継続するためにフェッチする必要があるレプリケーション ストリームの一部を表しています。</target>
        </trans-unit>
        <trans-unit id="b7064688c0f4d788a94324f8ce3624a598ba7058" translate="yes" xml:space="preserve">
          <source>The current score of an element can be retrieved using the &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; command, that can also be used to verify if an element already exists or not.</source>
          <target state="translated">要素の現在のスコアは、&lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt;コマンドを使用して取得できます。これは、要素がすでに存在するかどうかを確認するためにも使用できます。</target>
        </trans-unit>
        <trans-unit id="30d1eb14ec245a20077a7d25213dc588a8512c5c" translate="yes" xml:space="preserve">
          <source>The cursor returned by the previous call to SCAN in order to continue the iteration.</source>
          <target state="translated">反復を続けるために、前回のSCAN呼び出しで返されたカーソル。</target>
        </trans-unit>
        <trans-unit id="219c36e5291d2c3051ee7cf69aa75399bb2fc52c" translate="yes" xml:space="preserve">
          <source>The cursor value of 0 when starting an iteration.</source>
          <target state="translated">イテレーション開始時のカーソル値 0。</target>
        </trans-unit>
        <trans-unit id="93cb8fd7598a4e9c87b91141380a4bde0e9f7ad1" translate="yes" xml:space="preserve">
          <source>The default COUNT value is 10.</source>
          <target state="translated">デフォルトのCOUNT値は10です。</target>
        </trans-unit>
        <trans-unit id="1472348f89b9c094e365f856bf74ca11dcb1cdde" translate="yes" xml:space="preserve">
          <source>The deliveries counter, that is the fourth element in the array, is incremented when some other consumer &lt;em&gt;claims&lt;/em&gt; the message with &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;, or when the message is delivered again via &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;, when accessing the history of a consumer in a consumer group (see the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; page for more info).</source>
          <target state="translated">他のいくつかの消費者が場合、アレイ内の4番目の要素である出荷カウンタは、インクリメントされる&lt;em&gt;主張&lt;/em&gt;のメッセージ&lt;a href=&quot;xclaim&quot;&gt;XCLAIMを&lt;/a&gt;、またはメッセージを介して再び配信されるとき&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;コンシューマ・グループ内の消費者の履歴にアクセスするとき、（参照&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUPを&lt;/a&gt;詳しくはページをご覧ください）。</target>
        </trans-unit>
        <trans-unit id="c29b8b8f823cca94ef6ad774fed42578a146e94a" translate="yes" xml:space="preserve">
          <source>The difference between this command and the vanilla &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; is that this one supports consumer groups.</source>
          <target state="translated">このコマンドと&lt;a href=&quot;xread&quot;&gt;通常のXREAD&lt;/a&gt;の違いは、このコマンドはコンシューマグループをサポートすることです。</target>
        </trans-unit>
        <trans-unit id="3c1c5811c1d1a274026dcc95a504bdc2dd6d5a09" translate="yes" xml:space="preserve">
          <source>The distance from the center as a floating point number, in the same unit specified in the radius.</source>
          <target state="translated">中心からの距離を浮動小数点数で表したもので、半径で指定した単位と同じです。</target>
        </trans-unit>
        <trans-unit id="e1121b0e8297b7fecce16b935b4718ce15930933" translate="yes" xml:space="preserve">
          <source>The distance from the center as a floating point number, in the same unit specified in the shape.</source>
          <target state="translated">中心からの距離を浮動小数点数で表したもので、形状で指定した単位と同じ単位で表示します。</target>
        </trans-unit>
        <trans-unit id="3afe599a4181bcd5a732c0ec177cb011be65df41" translate="yes" xml:space="preserve">
          <source>The distance is computed assuming that the Earth is a perfect sphere, so errors up to 0.5% are possible in edge cases.</source>
          <target state="translated">距離は地球が完全な球体であると仮定して計算されているため、エッジケースでは0.5%までの誤差が生じる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a8be9ff0b07a549071a611002c4a08732b5c80a8" translate="yes" xml:space="preserve">
          <source>The distribution of the returned elements is far from perfect when the number of elements in the set is small, this is due to the fact that we used an approximated random element function that does not really guarantees good distribution.</source>
          <target state="translated">返された要素の分布は、集合内の要素数が少ない場合には完全には程遠いものとなりますが、これは良い分布を保証しない近似ランダム要素関数を使用したことに起因します。</target>
        </trans-unit>
        <trans-unit id="e2451d0313184cb7cb1bfd5f5707106d6b571329" translate="yes" xml:space="preserve">
          <source>The elements are considered to be ordered from lower to higher strings as compared byte-by-byte using the &lt;code&gt;memcmp()&lt;/code&gt; C function. Longer strings are considered greater than shorter strings if the common part is identical.</source>
          <target state="translated">要素は、 &lt;code&gt;memcmp()&lt;/code&gt; C関数を使用してバイトごとに比較すると、下位から上位の文字列に並べられていると見なされます。共通部分が同一の場合、長い文字列は短い文字列よりも大きいと見なされます。</target>
        </trans-unit>
        <trans-unit id="7dd12a75b48ac332a2dfe23f1549d87b855bfd6d" translate="yes" xml:space="preserve">
          <source>The elements having the same score are returned in lexicographical order (this follows from a property of the sorted set implementation in Redis and does not involve further computation).</source>
          <target state="translated">同じスコアを持つ要素は、辞書順に返されます(これはRedisのソートされた集合の実装のプロパティに由来するもので、これ以上の計算は必要ありません)。</target>
        </trans-unit>
        <trans-unit id="12d2f968d07516f9654dcc50b588d898c0361273" translate="yes" xml:space="preserve">
          <source>The elements having the same score are returned in reverse lexicographical order.</source>
          <target state="translated">同じスコアを持つ要素は、辞書順を逆にして返されます。</target>
        </trans-unit>
        <trans-unit id="8a7336e9649584aeb5dd7541a2422de663fa783e" translate="yes" xml:space="preserve">
          <source>The entry's unique ID can be used in order to avoid processing slow log entries multiple times (for instance you may have a script sending you an email alert for every new slow log entry).</source>
          <target state="translated">エントリの一意の ID は、遅いログエントリを複数回処理しないようにするために使用することができます (例えば、新しい遅いログエントリのたびにメールアラートを送信するスクリプトがあるかもしれません)。</target>
        </trans-unit>
        <trans-unit id="4c3c6b922261a4a3c02503cd2200bbc2e1969187" translate="yes" xml:space="preserve">
          <source>The exact behavior of this command is identical to the one of the &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; command, please refer to the documentation of &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; for further information.</source>
          <target state="translated">このコマンドの正確な動作は&lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt;コマンドの動作と同じです。詳細については、&lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt;のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="81ef5cb9ba6108b82ece4143c01d73481b4f607e" translate="yes" xml:space="preserve">
          <source>The fact that the user can count on Redis not removing scripts is semantically useful in the context of pipelining.</source>
          <target state="translated">Redisがスクリプトを削除しないことをユーザーが期待できるという事実は、パイプラインのコンテキストでは意味的に有用です。</target>
        </trans-unit>
        <trans-unit id="a0c00c319cfd875c00a2280921682c92066dd97a" translate="yes" xml:space="preserve">
          <source>The feature will remain active in the current connection for all its life, unless tracking is turned on with &lt;code&gt;CLIENT TRACKING off&lt;/code&gt; at some point.</source>
          <target state="translated">この機能は、ある時点で &lt;code&gt;CLIENT TRACKING off&lt;/code&gt; にしてトラッキングをオンにしない限り、現在の接続でその存続期間中アクティブなままになります。</target>
        </trans-unit>
        <trans-unit id="ccad1b83c48c6dc04cc17404f3912c32d936c720" translate="yes" xml:space="preserve">
          <source>The field contains a value of the wrong type (not a string).</source>
          <target state="translated">このフィールドには、間違った型の値が含まれています (文字列ではありません)。</target>
        </trans-unit>
        <trans-unit id="6058628e04e98718045db43e11d253a6db12f594" translate="yes" xml:space="preserve">
          <source>The file descriptor events can be:</source>
          <target state="translated">ファイル記述子イベントが可能です。</target>
        </trans-unit>
        <trans-unit id="d4261d3e5eb2c06f28ad9faa68309fdf262f21cb" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is a Lua 5.1 script. The script does not need to define a Lua function (and should not). It is just a Lua program that will run in the context of the Redis server.</source>
          <target state="translated">&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;の最初の引数はLua 5.1スクリプトです。スクリプトはLua関数を定義する必要はありません（必要ありません）。これは、Redisサーバーのコンテキストで実行される単なるLuaプログラムです。</target>
        </trans-unit>
        <trans-unit id="46870f99efa0c3b2959dcb93e1e13013212f023d" translate="yes" xml:space="preserve">
          <source>The first argument of the command selects the algorithm to use, right now the argument must be &quot;LCS&quot;, since this is the only implemented one.</source>
          <target state="translated">コマンドの最初の引数は使用するアルゴリズムを選択します。</target>
        </trans-unit>
        <trans-unit id="647fb34e5b11b941bb5e49ce5d7abfd78a858447" translate="yes" xml:space="preserve">
          <source>The first case will return the first 10 (or less) PEL entries of the entire group that are idle for over 9 seconds, whereas in the second case only those of &lt;code&gt;consumer-123&lt;/code&gt;.</source>
          <target state="translated">最初のケースでは、9秒を超えてアイドル状態になっているグループ全体の最初の10（またはそれ以下）のPELエントリが返されますが、2番目のケースでは &lt;code&gt;consumer-123&lt;/code&gt; のエントリのみが返されます。</target>
        </trans-unit>
        <trans-unit id="8cbda77e6bd32de6a17a5ed2d8395d40439856eb" translate="yes" xml:space="preserve">
          <source>The following are a few examples of importing and migrating slots:</source>
          <target state="translated">スロットのインポートと移行については、以下の通りです。</target>
        </trans-unit>
        <trans-unit id="6c3d5dc29a069636be48f90bb368850ce3fda788" translate="yes" xml:space="preserve">
          <source>The following are the list of options that modify the behavior of the command when enabling tracking:</source>
          <target state="translated">以下は、トラッキングを有効にする際にコマンドの動作を変更するオプションの一覧です。</target>
        </trans-unit>
        <trans-unit id="3b94aea73b4255f0bc659c9805b5380b0565b107" translate="yes" xml:space="preserve">
          <source>The following command removes the association for slots 5000 and 5001 from the node receiving the command:</source>
          <target state="translated">以下のコマンドは、コマンドを受信したノードからスロット5000と5001のアソシエーションを削除します。</target>
        </trans-unit>
        <trans-unit id="784815ebd70c0fe925bcd60bddc497d55949fa3a" translate="yes" xml:space="preserve">
          <source>The following documentation is a reference manual about the capabilities of this command, however our &lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;ACL tutorial&lt;/a&gt; may be a more gentle introduction to how the ACL system works in general.</source>
          <target state="translated">次のドキュメントは、このコマンドの機能に関するリファレンスマニュアルですが、&lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;ACLチュートリアル&lt;/a&gt;は、ACLシステムが一般的にどのように機能するかをより穏やかに紹介している場合があります。</target>
        </trans-unit>
        <trans-unit id="00075a28fdc9ff572c3eac87bcaf7c44d932e7da" translate="yes" xml:space="preserve">
          <source>The following example should clarify what stated above:</source>
          <target state="translated">以下の例では、上記で述べたことを明確にする必要があります。</target>
        </trans-unit>
        <trans-unit id="1ec034b27145454749448bb4c66e40315aa13e2f" translate="yes" xml:space="preserve">
          <source>The following example using &lt;code&gt;WITHSCORES&lt;/code&gt; shows how the command returns always an array, but this time, populated with &lt;em&gt;element_1&lt;/em&gt;, &lt;em&gt;score_1&lt;/em&gt;, &lt;em&gt;element_2&lt;/em&gt;, &lt;em&gt;score_2&lt;/em&gt;, ..., &lt;em&gt;element_N&lt;/em&gt;, &lt;em&gt;score_N&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;WITHSCORES&lt;/code&gt; を使用した次の例は、コマンドが常に配列を返す方法を示してい&lt;em&gt;ますが&lt;/em&gt;、&lt;em&gt;今回&lt;/em&gt;は&lt;em&gt;element_1&lt;/em&gt;、&lt;em&gt;score_1&lt;/em&gt;、&lt;em&gt;element_2&lt;/em&gt;、&lt;em&gt;score_2&lt;/em&gt;、...、&lt;em&gt;element_N&lt;/em&gt;、&lt;em&gt;score_Nが入力されてい&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="69face26cb0b6283ed9eddef9110c599dd9ae6eb" translate="yes" xml:space="preserve">
          <source>The following field is always provided:</source>
          <target state="translated">以下のフィールドが必ず用意されています。</target>
        </trans-unit>
        <trans-unit id="5fede26fc672e9d5137b89bc60a98de02e5d6528" translate="yes" xml:space="preserve">
          <source>The following is an example of &lt;code&gt;OVERFLOW FAIL&lt;/code&gt; returning NULL.</source>
          <target state="translated">以下は、NULLを返す &lt;code&gt;OVERFLOW FAIL&lt;/code&gt; の例です。</target>
        </trans-unit>
        <trans-unit id="f26894ffa2e5bfa52e8acebe022822e6a159ac5d" translate="yes" xml:space="preserve">
          <source>The following is the list of supported commands.</source>
          <target state="translated">サポートされているコマンドの一覧は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="487db5ff0187b77e2cfe37d8572892092c01e33a" translate="yes" xml:space="preserve">
          <source>The following pattern is discouraged in favor of &lt;a href=&quot;http://redis.io/topics/distlock&quot;&gt;the Redlock algorithm&lt;/a&gt; which is only a bit more complex to implement, but offers better guarantees and is fault tolerant.</source>
          <target state="translated">次のパターンは、実装が少しだけ複雑ですが、より優れた保証を提供し、フォールトトレラントで&lt;a href=&quot;http://redis.io/topics/distlock&quot;&gt;あるRedlockアルゴリズムの&lt;/a&gt;ために推奨されません。</target>
        </trans-unit>
        <trans-unit id="8e9fc798f24c122b5b0b23c06739d7c4c95610dd" translate="yes" xml:space="preserve">
          <source>The following pattern is discouraged in favor of &lt;a href=&quot;https://redis.io/topics/distlock&quot;&gt;the Redlock algorithm&lt;/a&gt; which is only a bit more complex to implement, but offers better guarantees and is fault tolerant.</source>
          <target state="translated">次のパターンは、実装が少し複雑ですが、より良い保証を提供し、フォールトトレラントで&lt;a href=&quot;https://redis.io/topics/distlock&quot;&gt;あるRedlockアルゴリズム&lt;/a&gt;を支持するために推奨されていません。</target>
        </trans-unit>
        <trans-unit id="685c86199b8431155924b73d00e71167faabb72e" translate="yes" xml:space="preserve">
          <source>The form &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE will stop replication, turning the server into a MASTER, but will not discard the replication. So, if the old master stops working, it is possible to turn the replica into a master and set the application to use this new master in read/write. Later when the other Redis server is fixed, it can be reconfigured to work as a replica.</source>
          <target state="translated">&lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE の形式はレプリケーションを停止し、サーバーをマスターに変更しますが、レプリケーションは破棄しません。そのため、古いマスターが機能しなくなった場合、レプリカをマスターにして、この新しいマスターを読み取り/書き込みで使用するようにアプリケーションを設定することができます。後で他のRedisサーバーが修正されたときに、レプリカとして機能するように再構成できます。</target>
        </trans-unit>
        <trans-unit id="2a758769f42fa16fd49a6c65e260a443efa58858" translate="yes" xml:space="preserve">
          <source>The form &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE will stop replication, turning the server into a MASTER, but will not discard the replication. So, if the old master stops working, it is possible to turn the replica into a master and set the application to use this new master in read/write. Later when the other Redis server is fixed, it can be reconfigured to work as a replica.</source>
          <target state="translated">&lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE の形式はレプリケーションを停止し、サーバーをマスターに変更しますが、レプリケーションは破棄しません。そのため、古いマスターが機能しなくなった場合、レプリカをマスターにして、この新しいマスターを読み取り/書き込みで使用するようにアプリケーションを設定することができます。後で他のRedisサーバーが修正されたときに、レプリカとして機能するように再構成できます。</target>
        </trans-unit>
        <trans-unit id="cfb81787e75be423c5bbd1da337f47a738269c3b" translate="yes" xml:space="preserve">
          <source>The function handles out of range requests by limiting the resulting range to the actual length of the string.</source>
          <target state="translated">この関数は、結果として得られる範囲を文字列の実際の長さに制限することで、範囲外のリクエストを処理します。</target>
        </trans-unit>
        <trans-unit id="bae822e06654577340df39aec8c279a41923dbdf" translate="yes" xml:space="preserve">
          <source>The function returns true if the script effects replication was enabled, otherwise if the function was called after the script already called some write command, it returns false, and normal whole script replication is used.</source>
          <target state="translated">スクリプト効果のレプリケーションが有効になっていればこの関数はtrueを返し、そうでなければ、スクリプトがすでに何らかの書き込みコマンドを呼び出した後にこの関数が呼び出された場合はfalseを返し、通常のスクリプト全体のレプリケーションが使用されます。</target>
        </trans-unit>
        <trans-unit id="e3d352c9158e45827d58fa0bb1daa62cb827202a" translate="yes" xml:space="preserve">
          <source>The geohash integer.</source>
          <target state="translated">ジオハッシュ整数。</target>
        </trans-unit>
        <trans-unit id="a74105f90399289d271dac87ebbc775e37f16a9d" translate="yes" xml:space="preserve">
          <source>The graph is normalized in the min-max scale so that the zero (the underscore in the lower row) is the minimum, and a # in the higher row is the maximum.</source>
          <target state="translated">グラフは、0(下段のアンダースコア)が最小値、上段の#が最大値となるように、最小値から最大値までのスケールで正規化されています。</target>
        </trans-unit>
        <trans-unit id="1802968f15db7e03ec0c89118a7963b7fbc9d55a" translate="yes" xml:space="preserve">
          <source>The group name is just the name of a consumer group associated to the stream. The group is created using the &lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt; command. The consumer name is the string that is used by the client to identify itself inside the group. The consumer is auto created inside the consumer group the first time it is saw. Different clients should select a different consumer name.</source>
          <target state="translated">グループ名は、ストリームに関連付けられているコンシューマグループの名前です。グループは&lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt;コマンドを使用して作成されます。コンシューマ名は、クライアントがグループ内で自身を識別するために使用する文字列です。コンシューマーは、初めて見たときにコンシューマーグループ内で自動作成されます。クライアントごとに異なるコンシューマ名を選択する必要があります。</target>
        </trans-unit>
        <trans-unit id="9501214421f828fe1bcfe6cfb269ae7881da1706" translate="yes" xml:space="preserve">
          <source>The id of the client.</source>
          <target state="translated">クライアントのID。</target>
        </trans-unit>
        <trans-unit id="5dfb24eb9709d7c83208076fd77b0d419da27db0" translate="yes" xml:space="preserve">
          <source>The information about memory usage is provided as metrics and their respective values. The following metrics are reported:</source>
          <target state="translated">メモリ使用量に関する情報は、メトリクスとそれぞれの値として提供されます。以下のメトリクスが報告されています。</target>
        </trans-unit>
        <trans-unit id="34a2e40e15b32f6149b206a299f7840113d10818" translate="yes" xml:space="preserve">
          <source>The key contains a value of the wrong type (not a string).</source>
          <target state="translated">キーには間違った型の値が含まれています (文字列ではありません)。</target>
        </trans-unit>
        <trans-unit id="09d97b8e7dc4c8276b96f5602bc74dea1d0e36c5" translate="yes" xml:space="preserve">
          <source>The key may be on both the instances.</source>
          <target state="translated">キーは両方のインスタンスにあるかもしれません。</target>
        </trans-unit>
        <trans-unit id="317c7c0e8fc5ce228ab50cadfc186268268a73ba" translate="yes" xml:space="preserve">
          <source>The key may be only in the source instance.</source>
          <target state="translated">キーはソースのインスタンスにのみ存在する場合があります。</target>
        </trans-unit>
        <trans-unit id="770d7559e7b2fdc7128e6105d19ea9ca36a0376e" translate="yes" xml:space="preserve">
          <source>The key time to live can be updated or entirely removed using the &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; and &lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt; command (or other strictly related commands).</source>
          <target state="translated">重要な&lt;a href=&quot;persist&quot;&gt;存続時間&lt;/a&gt;は、&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;およびPERSISTコマンド（または他の厳密に関連するコマンド）を使用して更新または完全に削除できます。</target>
        </trans-unit>
        <trans-unit id="547c694280239130253479a419ced5c053003ea8" translate="yes" xml:space="preserve">
          <source>The last ID returned is &lt;code&gt;1526985712947-0&lt;/code&gt;, since the sequence number is already zero, the next ID I'll use instead of the &lt;code&gt;+&lt;/code&gt; special ID will be &lt;code&gt;1526985712946-18446744073709551615&lt;/code&gt;, or just &lt;code&gt;18446744073709551615&lt;/code&gt;:</source>
          <target state="translated">返される最後のIDは &lt;code&gt;1526985712947-0&lt;/code&gt; です。シーケンス番号は既にゼロであるため、 &lt;code&gt;+&lt;/code&gt; の特別なIDの代わりに使用する次のIDは &lt;code&gt;1526985712946-18446744073709551615&lt;/code&gt; または単に &lt;code&gt;18446744073709551615&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="11471f50fbf81f6258a27201c930e977959ad0cd" translate="yes" xml:space="preserve">
          <source>The last argument is the ID of the last item in the stream to consider already delivered. In the above case we used the special ID '$' (that means: the ID of the last item in the stream). In this case the consumers fetching data from that consumer group will only see new elements arriving in the stream.</source>
          <target state="translated">最後の引数は、既に配信されたものを考慮するためのストリーム内の最後のアイテムのIDです。上記のケースでは、特別なID '$' (つまり、ストリーム内の最後のアイテムのID)を使用しました。この場合、その消費者グループからデータをフェッチする消費者は、ストリームに到着した新しい要素のみを見ることになります。</target>
        </trans-unit>
        <trans-unit id="42e7923c299c01e54ed6170cd5e8fc34b5599898" translate="yes" xml:space="preserve">
          <source>The last example shows how it is possible to receive the exact return value of &lt;code&gt;redis.call()&lt;/code&gt; or &lt;code&gt;redis.pcall()&lt;/code&gt; from Lua that would be returned if the command was called directly.</source>
          <target state="translated">最後の例は、コマンドが直接呼び出された場合に返される、Luaからの &lt;code&gt;redis.call()&lt;/code&gt; または &lt;code&gt;redis.pcall()&lt;/code&gt; の正確な戻り値を受け取る方法を示しています。</target>
        </trans-unit>
        <trans-unit id="898edad6fe267446764a3f01813e23c34e6a4dc9" translate="yes" xml:space="preserve">
          <source>The lexicographic ordering used is binary, it compares strings as array of bytes.</source>
          <target state="translated">使用される辞書順はバイナリで、文字列をバイトの配列として比較します。</target>
        </trans-unit>
        <trans-unit id="e89335ad1d56e8f847f0e52f7c837e0cf165daeb" translate="yes" xml:space="preserve">
          <source>The limitation of this pattern is that we are forced into an append-only mode of operation, there is no way to cut the time series to a given size easily because Redis currently lacks a command able to trim string objects. However the space efficiency of time series stored in this way is remarkable.</source>
          <target state="translated">このパターンの制限は、操作の追加のみのモードに強制されていることで、Redisには現在のところ文字列オブジェクトをトリミングするコマンドがないため、時系列を指定したサイズに簡単にカットする方法がありません。しかし、この方法で保存された時系列の空間効率は驚くべきものです。</target>
        </trans-unit>
        <trans-unit id="da33cd971f0747462e42ccd2282a1e6fb83aa7be" translate="yes" xml:space="preserve">
          <source>The list of configuration parameters supported by &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; can be obtained issuing a &lt;code&gt;CONFIG GET *&lt;/code&gt; command, that is the symmetrical command used to obtain information about the configuration of a running Redis instance.</source>
          <target state="translated">&lt;a href=&quot;config-set&quot;&gt;CONFIG SETで&lt;/a&gt;サポートされる構成パラメーターのリストは、 &lt;code&gt;CONFIG GET *&lt;/code&gt; コマンドを発行して取得できます。これは、実行中のRedisインスタンスの構成に関する情報を取得するために使用される対称コマンドです。</target>
        </trans-unit>
        <trans-unit id="8095634a38168f2c281c9616bbb338721d7efd28" translate="yes" xml:space="preserve">
          <source>The lock will be auto-released after the expire time is reached.</source>
          <target state="translated">有効期限に達するとロックが自動解除されます。</target>
        </trans-unit>
        <trans-unit id="08a7894ad23c8503b151cc8bfa325bf87f080cfd" translate="yes" xml:space="preserve">
          <source>The main drawback with the &lt;em&gt;whole scripts replication&lt;/em&gt; approach is that scripts are required to have the following property:</source>
          <target state="translated">&lt;em&gt;スクリプト全体のレプリケーション&lt;/em&gt;アプローチの主な欠点は、スクリプトに次のプロパティが必要なことです。</target>
        </trans-unit>
        <trans-unit id="7e2e2adfa0c27b3c4fcd6715d167f77cf7aab615" translate="yes" xml:space="preserve">
          <source>The main usage of this command is during rehashing of cluster slots from one node to another. The way the rehashing is performed is exposed in the Redis Cluster specification, or in a more simple to digest form, as an appendix of the &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; command documentation.</source>
          <target state="translated">このコマンドの主な用途は、あるノードから別のノードへのクラスタースロットのリハッシュ中です。再ハッシュが実行される方法は、&lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt;コマンドのドキュメントの付録として、Redisクラスター仕様、またはより簡単にダイジェスト形式で公開されています。</target>
        </trans-unit>
        <trans-unit id="51aa615de4288430f4f542dd741b0be9823a9984" translate="yes" xml:space="preserve">
          <source>The master output is composed of the following parts:</source>
          <target state="translated">マスター出力は以下の部分から構成されています。</target>
        </trans-unit>
        <trans-unit id="9294413196a1d66d0e89a267022407a00ed67b4f" translate="yes" xml:space="preserve">
          <source>The master replies to the replica with the current &lt;em&gt;replication offset&lt;/em&gt;.</source>
          <target state="translated">マスターは、現在の&lt;em&gt;レプリケーションオフセットで&lt;/em&gt;レプリカに応答します。</target>
        </trans-unit>
        <trans-unit id="9aa0f4e849bf549de77dfa2bc7bf7ffcfaf99bf4" translate="yes" xml:space="preserve">
          <source>The meaning of &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; are the same of the &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; command. Similarly, this command actually returns the same elements that &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; would return if called with the same &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; arguments.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; と &lt;code&gt;max&lt;/code&gt; の意味は、&lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;コマンドと同じです。同様に、このコマンドは、実際のと同じ要素を返し&lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEXが&lt;/a&gt;同じで呼び出された場合戻ってくる &lt;code&gt;min&lt;/code&gt; と &lt;code&gt;max&lt;/code&gt; の引数。</target>
        </trans-unit>
        <trans-unit id="9e23ac08d91ce30fa5d8f4e6bbb8d1a66fed8600" translate="yes" xml:space="preserve">
          <source>The meaning of each filed is the following:</source>
          <target state="translated">各ファイルの意味は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="69174101963d6daf8e0c498390ca52d478774c02" translate="yes" xml:space="preserve">
          <source>The meaning of the two states is explained in the Redis Specification, however the gist of the two states is the following:</source>
          <target state="translated">2つの状態の意味はRedisの仕様書で説明されていますが、その要旨は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="5fe7d63b1ebc573c80de8db8907af87f4669998b" translate="yes" xml:space="preserve">
          <source>The more simple and direct implementation of this pattern is the following:</source>
          <target state="translated">このパターンのよりシンプルで直接的な実装は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="8eafae6da4cd26a48b49e41708a6136f1a6de4a6" translate="yes" xml:space="preserve">
          <source>The motivation for this command is that the ability to store many small integers as a single large bitmap (or segmented over a few keys to avoid having huge keys) is extremely memory efficient, and opens new use cases for Redis to be applied, especially in the field of real time analytics. This use cases are supported by the ability to specify the overflow in a controlled way.</source>
          <target state="translated">このコマンドの動機は、多くの小さな整数を単一の大きなビットマップとして保存できる(あるいは、巨大なキーを持たないようにいくつかのキーにわたってセグメント化されている)ことが非常にメモリ効率が良く、特にリアルタイム分析の分野でRedisが適用できる新しいユースケースを開くことにあります。このユースケースは、制御された方法でオーバーフローを指定する機能によってサポートされています。</target>
        </trans-unit>
        <trans-unit id="8a6f6dffc18be981185e9a84435cd70cbbe693b9" translate="yes" xml:space="preserve">
          <source>The name of the consumer that fetched the message and has still to acknowledge it. We call it the current &lt;em&gt;owner&lt;/em&gt; of the message.</source>
          <target state="translated">メッセージをフェッチし、それをまだ確認していないコンシューマの名前。これをメッセージの現在の&lt;em&gt;所有者&lt;/em&gt;と呼びます。</target>
        </trans-unit>
        <trans-unit id="95a0cef10627d21f971cf58ca481b45ed9811331" translate="yes" xml:space="preserve">
          <source>The new configuration is persisted on disk in the node cluster configuration file.</source>
          <target state="translated">新しい構成は、ノードクラスタ構成ファイルのディスク上に保持されます。</target>
        </trans-unit>
        <trans-unit id="ce3fd26b48bfdbc550ce60034f680213e04e3fa5" translate="yes" xml:space="preserve">
          <source>The new format:</source>
          <target state="translated">新しいフォーマットです。</target>
        </trans-unit>
        <trans-unit id="69cbd0fd1035f94debad3eb8086987173fc0e180" translate="yes" xml:space="preserve">
          <source>The new score of &lt;code&gt;member&lt;/code&gt; (a double precision floating point number) represented as string, or &lt;code&gt;nil&lt;/code&gt; if the operation was aborted (when called with either the &lt;code&gt;XX&lt;/code&gt; or the &lt;code&gt;NX&lt;/code&gt; option).</source>
          <target state="translated">文字列として表される &lt;code&gt;member&lt;/code&gt; の新しいスコア（倍精度浮動小数点数）、または操作が中止された場合は &lt;code&gt;nil&lt;/code&gt; （ &lt;code&gt;XX&lt;/code&gt; または &lt;code&gt;NX&lt;/code&gt; オプションのいずれかで呼び出された場合）。</target>
        </trans-unit>
        <trans-unit id="1512d4f9273a472bf5054bc09af80c7b583c9993" translate="yes" xml:space="preserve">
          <source>The node ID identifies the same node we are sending the command to.</source>
          <target state="translated">ノードIDは、コマンドを送信するノードと同じノードを識別します。</target>
        </trans-unit>
        <trans-unit id="4a94b0edb207a0f9aad4e9890ab6a41a4abc596d" translate="yes" xml:space="preserve">
          <source>The node ID of the removed node gets added to the ban-list, for 1 minute.</source>
          <target state="translated">削除されたノードのノードIDは、1分間、禁止リストに追加されます。</target>
        </trans-unit>
        <trans-unit id="7282e91e365e1582b64fd77e649fb8fae6ff8480" translate="yes" xml:space="preserve">
          <source>The node current &lt;em&gt;config epoch&lt;/em&gt; is zero.</source>
          <target state="translated">ノードの現在の構成&lt;em&gt;エポック&lt;/em&gt;はゼロです。</target>
        </trans-unit>
        <trans-unit id="96c472bb576e96ca78ba9e6916a3879a69d9af69" translate="yes" xml:space="preserve">
          <source>The node is empty, no keys are stored at all in the key space.</source>
          <target state="translated">ノードは空であり、キースペースにはキーが全く格納されていません。</target>
        </trans-unit>
        <trans-unit id="c909806a718de9cb07358d8ed9ed00c019748494" translate="yes" xml:space="preserve">
          <source>The node is not serving any hash slots.</source>
          <target state="translated">このノードはハッシュ・スロットを提供していません。</target>
        </trans-unit>
        <trans-unit id="ce819a3025f8ff3393901c2c8e810e36e0f1c69b" translate="yes" xml:space="preserve">
          <source>The node receiving the command is a replica, and the specified node ID identifies its current master.</source>
          <target state="translated">コマンドを受信したノードはレプリカであり、指定されたノードIDは現在のマスタを識別します。</target>
        </trans-unit>
        <trans-unit id="3debb3fa567694b78b44554108f738a7a81cf421" translate="yes" xml:space="preserve">
          <source>The node will skip all the node IDs listed in the ban-list when processing gossip sections received in heartbeat packets from other nodes.</source>
          <target state="translated">ノードは,他のノードからハートビートパケットで受信したゴシップ部を処理する際に,ban-listに記載されているすべてのノードIDをスキップします。</target>
        </trans-unit>
        <trans-unit id="a02415f9a093ecefd5c824168bfb43638285dd33" translate="yes" xml:space="preserve">
          <source>The nodes table of the node is empty.</source>
          <target state="translated">ノードのノードテーブルは空です。</target>
        </trans-unit>
        <trans-unit id="a21d4be2cd3c8386a5bd51f51d8e281923d2f322" translate="yes" xml:space="preserve">
          <source>The number of bits set to 1.</source>
          <target state="translated">1に設定されているビット数です。</target>
        </trans-unit>
        <trans-unit id="59385708853390f9ca74251fea5131270265eecd" translate="yes" xml:space="preserve">
          <source>The number of elements added to the sorted set, not including elements already existing for which the score was updated.</source>
          <target state="translated">ソートされたセットに追加された要素の数で、スコアが更新された既存の要素は含まれていません。</target>
        </trans-unit>
        <trans-unit id="dc1eea05d5c0b5d2f315739abfba0f7deefc344d" translate="yes" xml:space="preserve">
          <source>The number of elements added to the sorted sets, not including elements already existing for which the score was updated.</source>
          <target state="translated">ソートされたセットに追加された要素数で、スコアが更新された既存の要素は含まれていません。</target>
        </trans-unit>
        <trans-unit id="e1784080520f069f819c069f9066d039833cf4fa" translate="yes" xml:space="preserve">
          <source>The number of keys existing among the ones specified as arguments. Keys mentioned multiple times and existing are counted multiple times.</source>
          <target state="translated">引数に指定されたキーのうち、存在するキーの数。複数回言及されたキーと既存のキーは複数回カウントされる。</target>
        </trans-unit>
        <trans-unit id="3563b055f87d27dac0ac55fd291fab644c82615a" translate="yes" xml:space="preserve">
          <source>The number of members removed from the sorted set, not including non existing members.</source>
          <target state="translated">ソートされたセットから削除されたメンバーの数。</target>
        </trans-unit>
        <trans-unit id="2eae56d8105036d6f2b2f01b5669d022f7996c37" translate="yes" xml:space="preserve">
          <source>The number of milliseconds that elapsed since the last time this message was delivered to this consumer.</source>
          <target state="translated">このメッセージがこの消費者に最後に配信されてからの経過時間(ミリ秒)。</target>
        </trans-unit>
        <trans-unit id="bbb45a4c926e88dd9593fe92bcaf35382576535c" translate="yes" xml:space="preserve">
          <source>The number of returned elements can be limited using the &lt;code&gt;LIMIT&lt;/code&gt; modifier. This modifier takes the &lt;code&gt;offset&lt;/code&gt; argument, specifying the number of elements to skip and the &lt;code&gt;count&lt;/code&gt; argument, specifying the number of elements to return from starting at &lt;code&gt;offset&lt;/code&gt;. The following example will return 10 elements of the sorted version of &lt;code&gt;mylist&lt;/code&gt;, starting at element 0 (&lt;code&gt;offset&lt;/code&gt; is zero-based):</source>
          <target state="translated">返される要素の数は、 &lt;code&gt;LIMIT&lt;/code&gt; 修飾子を使用して制限できます。この修飾子は、かかる &lt;code&gt;offset&lt;/code&gt; スキップする要素の数と指定し、引数を &lt;code&gt;count&lt;/code&gt; から始まるから復帰する要素の数を指定する引数を、 &lt;code&gt;offset&lt;/code&gt; 。次の例では、要素0（ &lt;code&gt;offset&lt;/code&gt; はゼロベース）から始まる、ソートされたバージョンの &lt;code&gt;mylist&lt;/code&gt; の 10要素を返します。</target>
        </trans-unit>
        <trans-unit id="2eeaa2bda10c14131d8f8224aae3f44fbab1d33b" translate="yes" xml:space="preserve">
          <source>The number of times this message was delivered.</source>
          <target state="translated">このメッセージが配信された回数です。</target>
        </trans-unit>
        <trans-unit id="4b95ac5bed75bd380b7e253506beeb45e5dcdf48" translate="yes" xml:space="preserve">
          <source>The old master receives the configuration update: unblocks its clients and starts replying with redirection messages so that they'll continue the chat with the new master.</source>
          <target state="translated">古いマスターは設定の更新を受信します:クライアントのブロックを解除し、新しいマスターとのチャットを継続できるように、リダイレクトメッセージの返信を開始します。</target>
        </trans-unit>
        <trans-unit id="1d689942edb764c6bd34cea24670f1e2f9a34fe2" translate="yes" xml:space="preserve">
          <source>The only valid cursors to use are:</source>
          <target state="translated">有効なカーソルはこれだけです。</target>
        </trans-unit>
        <trans-unit id="71d7b3a0d8bb44887a86cd184249f11ce4bd68cd" translate="yes" xml:space="preserve">
          <source>The only way to flush the script cache is by explicitly calling the &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; command, which will &lt;em&gt;completely flush&lt;/em&gt; the scripts cache removing all the scripts executed so far.</source>
          <target state="translated">スクリプトキャッシュをフラッシュする唯一の方法は、&lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt;コマンドを明示的に呼び出すことです。これにより、スクリプトキャッシュが&lt;em&gt;完全にフラッシュ&lt;/em&gt;され、これまでに実行されたすべてのスクリプトが削除されます。</target>
        </trans-unit>
        <trans-unit id="851a4dff1ddadeea08eb160100034cb226114c6d" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;LIMIT&lt;/code&gt; argument can be used to only get a range of the matching elements (similar to &lt;em&gt;SELECT LIMIT offset, count&lt;/em&gt; in SQL). A negative &lt;code&gt;count&lt;/code&gt; returns all elements from the &lt;code&gt;offset&lt;/code&gt;. Keep in mind that if &lt;code&gt;offset&lt;/code&gt; is large, the sorted set needs to be traversed for &lt;code&gt;offset&lt;/code&gt; elements before getting to the elements to return, which can add up to O(N) time complexity.</source>
          <target state="translated">オプションの &lt;code&gt;LIMIT&lt;/code&gt; 引数は、一致する要素の範囲のみを取得するために使用できます（&lt;em&gt;SELECT LIMITオフセット、&lt;/em&gt; SQLの&lt;em&gt;カウント&lt;/em&gt;と同様）。負の &lt;code&gt;count&lt;/code&gt; は、 &lt;code&gt;offset&lt;/code&gt; からすべての要素を返します。 &lt;code&gt;offset&lt;/code&gt; が大きい場合は、戻る要素に到達する前に、ソートされたセットを &lt;code&gt;offset&lt;/code&gt; 要素に対してトラバースする必要があることに注意してください。これにより、O（N）時間の複雑さが増す可能性があります。</target>
        </trans-unit>
        <trans-unit id="b79325b395f9601a80868e44ee285b402fa0bfad" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;LIMIT&lt;/code&gt; argument can be used to only get a range of the matching elements (similar to &lt;em&gt;SELECT LIMIT offset, count&lt;/em&gt; in SQL). Keep in mind that if &lt;code&gt;offset&lt;/code&gt; is large, the sorted set needs to be traversed for &lt;code&gt;offset&lt;/code&gt; elements before getting to the elements to return, which can add up to O(N) time complexity.</source>
          <target state="translated">オプションの &lt;code&gt;LIMIT&lt;/code&gt; 引数は、一致する要素の範囲のみを取得するために使用できます（SQLの&lt;em&gt;SELECT LIMITオフセット、カウント&lt;/em&gt;と同様）。場合ことを覚えておいてください &lt;code&gt;offset&lt;/code&gt; 大きい場合、ソートセットがために横断する必要が &lt;code&gt;offset&lt;/code&gt; O（N）時間計算量まで追加することができた、復帰に要素に入る前の要素。</target>
        </trans-unit>
        <trans-unit id="500dba23b5e32b54cd518b60d5bf8b2bf6fe3ec8" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WITHSCORES&lt;/code&gt; argument makes the command return both the element and its score, instead of the element alone. This option is available since Redis 2.0.</source>
          <target state="translated">オプションの &lt;code&gt;WITHSCORES&lt;/code&gt; 引数を指定すると、コマンドは要素のみではなく、要素とそのスコアの両方を返します。このオプションはRedis 2.0以降で使用できます。</target>
        </trans-unit>
        <trans-unit id="0f54b06c2148c9b6919787651cb0104f905c8131" translate="yes" xml:space="preserve">
          <source>The optional argument specifies how many entries to show. By default up to ten failures are returned. The special &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; argument clears the log. Entries are displayed starting from the most recent.</source>
          <target state="translated">オプションの引数は、表示するエントリの数を指定します。デフォルトでは、最大10個の障害が返されます。特別な&lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt;引数は、ログをクリアします。エントリは最新のものから表示されます。</target>
        </trans-unit>
        <trans-unit id="50b302b8ebe5d4f766a30687aa495211b0a41cc8" translate="yes" xml:space="preserve">
          <source>The optional arguments and options can modify the command's behavior. The &lt;code&gt;RANK&lt;/code&gt; option specifies the &quot;rank&quot; of the first element to return, in case there are multiple matches. A rank of 1 means to return the first match, 2 to return the second match, and so forth.</source>
          <target state="translated">オプションの引数とオプションは、コマンドの動作を変更できます。 &lt;code&gt;RANK&lt;/code&gt; のオプションは、ケース内に複数の一致がある、復帰への最初の要素の「ランク」を指定します。ランク1は最初の一致を返すことを意味し、2は2番目の一致を返すことを意味します。</target>
        </trans-unit>
        <trans-unit id="0d8aa34d3ef4ed317f6f4c66d1281cf452a3e134" translate="yes" xml:space="preserve">
          <source>The optional parameter can be used to select a specific section of information:</source>
          <target state="translated">オプションのパラメータを使用して、情報の特定のセクションを選択することができます。</target>
        </trans-unit>
        <trans-unit id="d3f8920e23cd2f39487b2140b719e87054ae2b2b" translate="yes" xml:space="preserve">
          <source>The order of step 1 and 2 is important. We want the destination node to be ready to accept &lt;code&gt;ASK&lt;/code&gt; redirections when the source node is configured to redirect.</source>
          <target state="translated">手順1と2の順序は重要です。ソースノードがリダイレクトするように構成されている場合は、宛先ノードが &lt;code&gt;ASK&lt;/code&gt; リダイレクトを受け入れる準備ができている必要があります。</target>
        </trans-unit>
        <trans-unit id="b62304b58ff7ffb9f9709c25da7f4765174f07a9" translate="yes" xml:space="preserve">
          <source>The output of the command is just a space-separated CSV string, where each line represents a node in the cluster. The following is an example of output:</source>
          <target state="translated">コマンドの出力はスペースで区切られたCSV文字列で、各行はクラスタ内のノードを表します。以下に出力例を示します。</target>
        </trans-unit>
        <trans-unit id="27eaed3275801016a87c11dc8a65ad526a22ea0c" translate="yes" xml:space="preserve">
          <source>The port number of the master.</source>
          <target state="translated">マスターのポート番号です。</target>
        </trans-unit>
        <trans-unit id="251a4c07dcd21d1710028ff045133e0223bd8086" translate="yes" xml:space="preserve">
          <source>The position is returned, thinking of the string as an array of bits from left to right, where the first byte's most significant bit is at position 0, the second byte's most significant bit is at position 8, and so forth.</source>
          <target state="translated">位置は、文字列を左から右へのビットの配列として考えて返され、最初のバイトの最上位ビットが0の位置に、2番目のバイトの最上位ビットが8の位置に、などとなります。</target>
        </trans-unit>
        <trans-unit id="cf1bf81ee9d88a76e67d9f14175bdac96ea2eae6" translate="yes" xml:space="preserve">
          <source>The position of the specified member is used as the center of the query.</source>
          <target state="translated">指定されたメンバの位置がクエリの中心として使用されます。</target>
        </trans-unit>
        <trans-unit id="fe9f9e53a4720c0a3b3f8dd9ba6795a8d524ecc9" translate="yes" xml:space="preserve">
          <source>The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.</source>
          <target state="translated">出力の精度は、実際の計算の内部精度に関わらず、小数点以下17桁で固定されています。</target>
        </trans-unit>
        <trans-unit id="77e23fa703efecfb1c5bf352cb4f0529fa3a9d39" translate="yes" xml:space="preserve">
          <source>The query's center point is provided by one of these mandatory options:</source>
          <target state="translated">クエリの中心点は、これらの必須オプションのいずれかによって提供されます。</target>
        </trans-unit>
        <trans-unit id="b1e2a1f42bcb6a5e4c6e642aa88cfced9dff68d3" translate="yes" xml:space="preserve">
          <source>The query's shape is provided by one of these mandatory options:</source>
          <target state="translated">クエリの形状は、これらの必須オプションのいずれかによって提供されます。</target>
        </trans-unit>
        <trans-unit id="a9079c728747b4e6051aebcc896878af23a86276" translate="yes" xml:space="preserve">
          <source>The radius is specified in one of the following units:</source>
          <target state="translated">半径は以下のいずれかの単位で指定します。</target>
        </trans-unit>
        <trans-unit id="5d69c6f303471181769a8ce1e67050c18c180806" translate="yes" xml:space="preserve">
          <source>The range is close (inclusive) by default, meaning that the reply can include entries with IDs matching the query's start and end intervals. It is possible to specify an open interval (exclusive) by prefixing the ID with the character &lt;code&gt;(&lt;/code&gt;. This is useful for iterating the stream, as explained below.</source>
          <target state="translated">範囲はデフォルトで近い（包括的）です。つまり、応答には、クエリの開始間隔と終了間隔に一致するIDを持つエントリを含めることができます。IDの前に文字 &lt;code&gt;(&lt;/code&gt; ）を付けることで、オープン間隔（排他的）を指定できます。これは、以下で説明するように、ストリームを反復する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="fa101056c680bd6adea2c67580ad18683b432390" translate="yes" xml:space="preserve">
          <source>The range of values supported by &lt;a href=&quot;hincrby&quot;&gt;HINCRBY&lt;/a&gt; is limited to 64 bit signed integers.</source>
          <target state="translated">&lt;a href=&quot;hincrby&quot;&gt;HINCRBY&lt;/a&gt;でサポートされる値の範囲は、64ビットの符号付き整数に制限されています。</target>
        </trans-unit>
        <trans-unit id="33bdfca071502b90c1a8026acb1caf737da192b8" translate="yes" xml:space="preserve">
          <source>The rate limiter pattern is a special counter that is used to limit the rate at which an operation can be performed. The classical materialization of this pattern involves limiting the number of requests that can be performed against a public API.</source>
          <target state="translated">レート リミッター パターンは、操作を実行できるレートを制限するために使用される特別なカウンタです。このパターンの古典的な具体化には、パブリック API に対して実行できるリクエストの数を制限することが含まれます。</target>
        </trans-unit>
        <trans-unit id="602f859c103a55957a4cbd71395a1cae9a978824" translate="yes" xml:space="preserve">
          <source>The reason is that sending a script to another Redis instance is often much faster than sending the multiple commands the script generates, so if the client is sending many scripts to the master, converting the scripts into individual commands for the replica / AOF would result in too much bandwidth for the replication link or the Append Only File (and also too much CPU since dispatching a command received via network is a lot more work for Redis compared to dispatching a command invoked by Lua scripts).</source>
          <target state="translated">その理由は、スクリプトを別のRedisインスタンスに送信する場合、スクリプトが生成する複数のコマンドを送信するよりも、スクリプトを別のRedisインスタンスに送信する方が高速であることが多いからです。クライアントが多くのスクリプトをマスターに送信している場合、スクリプトをレプリカ/AOF用の個々のコマンドに変換すると、レプリケーションリンクやAppend Only Fileの帯域幅が大きすぎることになります(また、ネットワーク経由で受信したコマンドをディスパッチすることは、Luaスクリプトによって呼び出されたコマンドをディスパッチすることに比べて、Redisの作業量が多くなるため、CPUの負担も大きくなります)。</target>
        </trans-unit>
        <trans-unit id="f4d6d43d2e03d821aeb88801c0d8fb884cbca911" translate="yes" xml:space="preserve">
          <source>The reason why scripts can be cached for long time is that it is unlikely for a well written application to have enough different scripts to cause memory problems. Every script is conceptually like the implementation of a new command, and even a large application will likely have just a few hundred of them. Even if the application is modified many times and scripts will change, the memory used is negligible.</source>
          <target state="translated">スクリプトを長期間キャッシュできる理由は、よく書かれたアプリケーションがメモリの問題を引き起こすのに十分な数の異なるスクリプトを持っている可能性が低いからです。すべてのスクリプトは概念的には新しいコマンドの実装のようなもので、大規模なアプリケーションでも数百個のスクリプトを持つことになるでしょう。アプリケーションが何度も変更され、スクリプトが変更されたとしても、使用されるメモリはごくわずかです。</target>
        </trans-unit>
        <trans-unit id="0e5533e8fee1cbd59ebef949c8411c0d7d01dc8e" translate="yes" xml:space="preserve">
          <source>The replica output is composed of the following parts:</source>
          <target state="translated">レプリカ出力は以下の部分で構成されています。</target>
        </trans-unit>
        <trans-unit id="d985304abe6bf0f8f4ea24090445b6bf55af90d3" translate="yes" xml:space="preserve">
          <source>The replica starts a failover, obtains a new configuration epoch from the majority of the masters, and broadcasts the new configuration.</source>
          <target state="translated">レプリカはフェイルオーバーを開始し、大多数のマスターから新しい設定エポックを取得し、新しい設定をブロードキャストします。</target>
        </trans-unit>
        <trans-unit id="7c096a5e647ff1a64af00045529cba5bd168f06b" translate="yes" xml:space="preserve">
          <source>The replica tells the master to stop processing queries from clients.</source>
          <target state="translated">レプリカは、クライアントからのクエリの処理を停止するようにマスターに指示します。</target>
        </trans-unit>
        <trans-unit id="e43729fea60babeefa0888b3097ef84a1143b1a0" translate="yes" xml:space="preserve">
          <source>The replica waits for the replication offset to match on its side, to make sure it processed all the data from the master before it continues.</source>
          <target state="translated">レプリカはレプリカ側でレプリケーションオフセットが一致するのを待って、マスターからのデータをすべて処理したことを確認してから続行します。</target>
        </trans-unit>
        <trans-unit id="71f9285cf89c4539aedf2939b67fe3ee74695f78" translate="yes" xml:space="preserve">
          <source>The reply format is identical to that of &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt;, and the content consists only of information about the current client.</source>
          <target state="translated">返信形式は&lt;a href=&quot;client-list&quot;&gt;CLIENTLIST&lt;/a&gt;と同じで、内容は現在のクライアントに関する情報のみで構成されています。</target>
        </trans-unit>
        <trans-unit id="7c6d847d0bceaf13a4c9effd31564050074fa753" translate="yes" xml:space="preserve">
          <source>The reported information contains all of the fields reported by the simple form of &lt;code&gt;XINFO STREAM&lt;/code&gt;, with some additional information:</source>
          <target state="translated">報告される情報には、 &lt;code&gt;XINFO STREAM&lt;/code&gt; の単純な形式で報告されるすべてのフィールドと、いくつかの追加情報が含まれます。</target>
        </trans-unit>
        <trans-unit id="2fb0e618b4e3d9e5fe2c17d1edb7fb80034a8b4f" translate="yes" xml:space="preserve">
          <source>The reported usage is the total of memory allocations for data and administrative overheads that a key its value require.</source>
          <target state="translated">報告された使用量は、そのキーの値が必要とするデータと管理上のオーバーヘッドのためのメモリ割り当ての合計です。</target>
        </trans-unit>
        <trans-unit id="79c8f80736bb00aecddcc76c1b8f02af94064a15" translate="yes" xml:space="preserve">
          <source>The representation is neutral from the point of view of the processor word size and endianness, so the same representation is used by 32 bit and 64 bit processor, big endian or little endian.</source>
          <target state="translated">この表現は、プロセッサのワードサイズとエンディアンの観点から中立であるため、32ビットと64ビットのプロセッサでも、ビッグエンディアンでもリトルエンディアンでも同じ表現を使用します。</target>
        </trans-unit>
        <trans-unit id="d07c8ceb7018e1bcd908f1c44ebce957404cda02" translate="yes" xml:space="preserve">
          <source>The representation used by &lt;a href=&quot;bitfield&quot;&gt;BITFIELD&lt;/a&gt; considers the bitmap as having the bit number 0 to be the most significant bit of the first byte, and so forth, so for example setting a 5 bits unsigned integer to value 23 at offset 7 into a bitmap previously set to all zeroes, will produce the following representation:</source>
          <target state="translated">&lt;a href=&quot;bitfield&quot;&gt;BITFIELDで&lt;/a&gt;使用される表現は、ビットマップをビット番号0が最初のバイトの最上位ビットであると見なします。たとえば、5ビットの符号なし整数をオフセット7で値23に設定し、以前に設定したビットマップに設定します。すべてゼロの場合、次の表現が生成されます。</target>
        </trans-unit>
        <trans-unit id="69c89883952564695abb2bebcaf5f11f6b3d6f75" translate="yes" xml:space="preserve">
          <source>The result of the operation is always stored at &lt;code&gt;destkey&lt;/code&gt;.</source>
          <target state="translated">操作の結果は常に &lt;code&gt;destkey&lt;/code&gt; に格納されます。</target>
        </trans-unit>
        <trans-unit id="8563416a363c2cdbe31060c220e5e3844f6d8270" translate="yes" xml:space="preserve">
          <source>The return type of the command is a &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;.</source>
          <target state="translated">コマンドの戻りタイプは、&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;配列応答&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="29bc7d6c144c9d4891cb5866b63897dea6e00bee" translate="yes" xml:space="preserve">
          <source>The returned cardinality of the observed set is not exact, but approximated with a standard error of 0.81%.</source>
          <target state="translated">返された観測集合のカーディナリティは正確ではありませんが、0.81%の標準誤差で近似されています。</target>
        </trans-unit>
        <trans-unit id="f485b5467a04f58f023ce0589b088bae79cd349e" translate="yes" xml:space="preserve">
          <source>The rewrite is performed in a very conservative way:</source>
          <target state="translated">かなり保守的な書き換えが行われています。</target>
        </trans-unit>
        <trans-unit id="3d4aef252f6710693b627be68f7b05c7734609ba" translate="yes" xml:space="preserve">
          <source>The rewrite will be only triggered by Redis if there is not already a background process doing persistence.</source>
          <target state="translated">書き換えは、パーシステンスを行っているバックグラウンドプロセスが既に存在しない場合にのみ、Redisによってトリガされます。</target>
        </trans-unit>
        <trans-unit id="95ba82b2fd87a033c00319b26e5a7be447966868" translate="yes" xml:space="preserve">
          <source>The rewrite will be only triggered by Redis if there is not already a background process doing persistence. Specifically:</source>
          <target state="translated">書き換えは、パーシステンスを行っているバックグラウンドプロセスが既に存在しない場合にのみ、Redisによってトリガされます。具体的には</target>
        </trans-unit>
        <trans-unit id="1f1d9ccb03a5f0171c2e12fc9e5717671728f51a" translate="yes" xml:space="preserve">
          <source>The same bit position convention is followed by &lt;a href=&quot;getbit&quot;&gt;GETBIT&lt;/a&gt; and &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt;.</source>
          <target state="translated">同じビット位置規則の後に&lt;a href=&quot;getbit&quot;&gt;GETBIT&lt;/a&gt;および&lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt;が続きます。</target>
        </trans-unit>
        <trans-unit id="2db5a15e45c348362ce43e64d992a94fa7834d6c" translate="yes" xml:space="preserve">
          <source>The same holds true for non-existent keys, that are considered as a stream of zero bytes up to the length of the longest string.</source>
          <target state="translated">存在しない鍵についても同様で、最長の文字列の長さまでゼロバイトのストリームとみなされます。</target>
        </trans-unit>
        <trans-unit id="459993ded23b09fc27e5d6a4bf1ae20c56fbcf0c" translate="yes" xml:space="preserve">
          <source>The save parameter is a single string of space-separated integers. Every pair of integers represent a seconds/modifications threshold.</source>
          <target state="translated">saveパラメータは、スペースで区切られた整数の1つの文字列です。各整数のペアは秒/変更のしきい値を表します。</target>
        </trans-unit>
        <trans-unit id="19337abd9b3767724cccba46357082deb732a2c0" translate="yes" xml:space="preserve">
          <source>The score values should be the string representation of a double precision floating point number. &lt;code&gt;+inf&lt;/code&gt; and &lt;code&gt;-inf&lt;/code&gt; values are valid values as well.</source>
          <target state="translated">スコア値は、倍精度浮動小数点数の文字列表現である必要があります。 &lt;code&gt;+inf&lt;/code&gt; と &lt;code&gt;-inf&lt;/code&gt; の値も有効な値です。</target>
        </trans-unit>
        <trans-unit id="8704ce1cdf5da36cc8175add936925537e2b6762" translate="yes" xml:space="preserve">
          <source>The script is guaranteed to stay in the script cache forever (unless &lt;code&gt;SCRIPT
FLUSH&lt;/code&gt; is called).</source>
          <target state="translated">スクリプトは、（ &lt;code&gt;SCRIPT FLUSH&lt;/code&gt; が呼び出されない限り）永久にスクリプトキャッシュに留まることが保証されています。</target>
        </trans-unit>
        <trans-unit id="84e6859345305305b03236c94f49ebcdfaf9f284" translate="yes" xml:space="preserve">
          <source>The script must always evaluates the same Redis &lt;em&gt;write&lt;/em&gt; commands with the same arguments given the same input data set. Operations performed by the script cannot depend on any hidden (non-explicit) information or state that may change as script execution proceeds or between different executions of the script, nor can it depend on any external input from I/O devices.</source>
          <target state="translated">スクリプトは常に、同じ入力データセットが指定された同じ引数で同じRedis &lt;em&gt;書き込み&lt;/em&gt;コマンドを評価する必要があります。スクリプトによって実行される操作は、スクリプトの実行が進むにつれて、またはスクリプトの異なる実行間で変化する可能性がある非表示の（明示的ではない）情報や状態に依存したり、I / Oデバイスからの外部入力に依存したりすることはできません。</target>
        </trans-unit>
        <trans-unit id="f6f50abe88117410baf6ae78d63eac9d06193d38" translate="yes" xml:space="preserve">
          <source>The script should be called with &lt;code&gt;EVAL ...script... 1 resource-name token-value&lt;/code&gt;</source>
          <target state="translated">スクリプトは &lt;code&gt;EVAL ...script... 1 resource-name token-value&lt;/code&gt; で呼び出す必要があります</target>
        </trans-unit>
        <trans-unit id="ae5f9a8c3637986eaac0c1b5c2a821ed62bfff96" translate="yes" xml:space="preserve">
          <source>The second argument of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is the number of arguments that follows the script (starting from the third argument) that represent Redis key names. The arguments can be accessed by Lua using the &lt;code&gt;KEYS&lt;/code&gt; global variable in the form of a one-based array (so &lt;code&gt;KEYS[1]&lt;/code&gt;, &lt;code&gt;KEYS[2]&lt;/code&gt;, ...).</source>
          <target state="translated">&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;の2番目の引数は、スクリプトに続く（3番目の引数から始まる）Redisキー名を表す引数の数です。Lua は、1ベースの配列（ &lt;code&gt;KEYS[1]&lt;/code&gt; 、 &lt;code&gt;KEYS[2]&lt;/code&gt; など）の形式で &lt;code&gt;KEYS&lt;/code&gt; グローバル変数を使用して引数にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="5e06049c7fb2a08a77ed966e80b1bd0de88bb6c2" translate="yes" xml:space="preserve">
          <source>The semantic change between patch level releases was needed since the old behavior was inherently incompatible with the Redis replication layer and was the cause of bugs.</source>
          <target state="translated">古い動作は本質的にRedisレプリケーションレイヤーとの互換性がなく、バグの原因となっていたため、パッチレベルのリリース間でのセマンティックな変更が必要でした。</target>
        </trans-unit>
        <trans-unit id="c86d0b330e63015ff6018ffba522da6d3c2c8fb8" translate="yes" xml:space="preserve">
          <source>The sentinel output is composed of the following parts:</source>
          <target state="translated">センチネル出力は、以下の部分から構成されています。</target>
        </trans-unit>
        <trans-unit id="295a39c211fe9b12478b873df477a317d327e2b4" translate="yes" xml:space="preserve">
          <source>The serialization format is opaque and non-standard, however it has a few semantic characteristics:</source>
          <target state="translated">シリアライズフォーマットは不透明で非標準ですが、いくつかの意味的な特徴を持っています。</target>
        </trans-unit>
        <trans-unit id="06e5cb4e4d36f51aabfd49438bd236dcf9c4976a" translate="yes" xml:space="preserve">
          <source>The serialized value does NOT contain expire information. In order to capture the time to live of the current value the &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; command should be used.</source>
          <target state="translated">シリアル化された値には有効期限情報が含まれていません。現在の値の&lt;a href=&quot;pttl&quot;&gt;存続&lt;/a&gt;時間をキャプチャするには、PTTLコマンドを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="dd5acc612a2b52a80de5b2a3e24e38f5ba00302b" translate="yes" xml:space="preserve">
          <source>The size of the string stored in the destination key, that is equal to the size of the longest input string.</source>
          <target state="translated">宛先キーに格納されている文字列のサイズは、最長の入力文字列のサイズに等しい。</target>
        </trans-unit>
        <trans-unit id="1a0a5df2b74e73a15c2817e253d14a10935a2191" translate="yes" xml:space="preserve">
          <source>The slow log is accumulated in memory, so no file is written with information about the slow command executions. This makes the slow log remarkably fast at the point that you can enable the logging of all the commands (setting the &lt;em&gt;slowlog-log-slower-than&lt;/em&gt; config parameter to zero) with minor performance hit.</source>
          <target state="translated">遅いログはメモリに蓄積されるため、遅いコマンドの実行に関する情報を含むファイルは書き込まれません。これにより、パフォーマンスがわずかに低下するだけで、すべてのコマンドのロギングを有効にできる（&lt;em&gt;slowlog-log-slower-than構成&lt;/em&gt;パラメーターをゼロに設定する）時点で、スローログが著しく高速になります。</target>
        </trans-unit>
        <trans-unit id="4eaa8de726819dc3e71079d7a6f328e12fd9ddc2" translate="yes" xml:space="preserve">
          <source>The sparse representation uses a run-length encoding optimized to store efficiently a big number of registers set to zero. The dense representation is a Redis string of 12288 bytes in order to store 16384 6-bit counters. The need for the double representation comes from the fact that using 12k (which is the dense representation memory requirement) to encode just a few registers for smaller cardinalities is extremely suboptimal.</source>
          <target state="translated">疎な表現は、ゼロに設定された多数のレジスタを効率的に格納するために最適化されたランレングスのエンコーディングを使用します。密な表現は、16384個の6ビットカウンタを格納するために、12288バイトのRedis文字列を使用します。二重表現の必要性は、12k(これは密表現のメモリ要件)を使用して、より小さな基数のために数個のレジスタだけをエンコードするのは非常に最適ではないという事実に由来しています。</target>
        </trans-unit>
        <trans-unit id="8eeebccfe9d0cfc87769de4a2c07747fec580fbc" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;$&lt;/code&gt; ID.</source>
          <target state="translated">特別な &lt;code&gt;$&lt;/code&gt; ID。</target>
        </trans-unit>
        <trans-unit id="0f067eeaba3e5a87a3236774a27fada6161ea70f" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;&amp;gt;&lt;/code&gt; ID, which means that the consumer want to receive only messages that were &lt;em&gt;never delivered to any other consumer&lt;/em&gt;. It just means, give me new messages.</source>
          <target state="translated">特別な &lt;code&gt;&amp;gt;&lt;/code&gt; ID。つまり、コンシューマーは&lt;em&gt;、他のコンシューマーに配信されなかった&lt;/em&gt;メッセージのみを受信したいということです。新しいメッセージを送ってください。</target>
        </trans-unit>
        <trans-unit id="5029fc6d051bb809efc7fcb4a44af5a544f6b49f" translate="yes" xml:space="preserve">
          <source>The specified node ID does not identify the instance we are sending the command to.</source>
          <target state="translated">指定されたノードIDは、コマンドを送信するインスタンスを特定しません。</target>
        </trans-unit>
        <trans-unit id="15f8e4eecac9b5616dbc97abb4f74fd51bce6356" translate="yes" xml:space="preserve">
          <source>The specified node ID exists in its nodes table.</source>
          <target state="translated">指定されたノードIDは、そのノードテーブルに存在します。</target>
        </trans-unit>
        <trans-unit id="07565949c7a13614b4cf396e3dee4474076dd98c" translate="yes" xml:space="preserve">
          <source>The specified node ID is a master.</source>
          <target state="translated">指定されたノードIDはマスターです。</target>
        </trans-unit>
        <trans-unit id="92c45a066b5df5b3300ad8d74734dc668cec5a44" translate="yes" xml:space="preserve">
          <source>The specified node ID is not found in the nodes table.</source>
          <target state="translated">指定したノードIDがノードテーブルに見つかりません。</target>
        </trans-unit>
        <trans-unit id="dadcfd8e793bf395f94eff22f99b0da2a7a715b6" translate="yes" xml:space="preserve">
          <source>The specified node gets removed from the nodes table.</source>
          <target state="translated">指定したノードはノードテーブルから削除されます。</target>
        </trans-unit>
        <trans-unit id="3be929a4c6ff231339b330125852213fb5229ce4" translate="yes" xml:space="preserve">
          <source>The state of the replication from the point of view of the master, that can be &lt;code&gt;connect&lt;/code&gt; (the instance needs to connect to its master), &lt;code&gt;connecting&lt;/code&gt; (the master-replica connection is in progress), &lt;code&gt;sync&lt;/code&gt; (the master and replica are trying to perform the synchronization), &lt;code&gt;connected&lt;/code&gt; (the replica is online).</source>
          <target state="translated">マスターから見た &lt;code&gt;connect&lt;/code&gt; （インスタンスはそのマスターに接続する必要があります）、 &lt;code&gt;connecting&lt;/code&gt; （マスターとレプリカの接続が進行中）、 &lt;code&gt;sync&lt;/code&gt; （マスターとレプリカは同期を実行）、 &lt;code&gt;connected&lt;/code&gt; （レプリカはオンライン）。</target>
        </trans-unit>
        <trans-unit id="b8b0d67ec2d33e9415285fa0b1b04c01c7c00db9" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;-&amp;gt;&lt;/code&gt; is used to separate the key name from the hash field name. The key is substituted as documented above, and the hash stored at the resulting key is accessed to retrieve the specified hash field.</source>
          <target state="translated">文字列 &lt;code&gt;-&amp;gt;&lt;/code&gt; は、キー名とハッシュフィールド名を区切るために使用されます。キーは上記のように置き換えられ、結果のキーに格納されているハッシュにアクセスして、指定されたハッシュフィールドを取得します。</target>
        </trans-unit>
        <trans-unit id="f708ccbae2afe95a0cd4653de56c8fb34c79374e" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">文字列 &lt;code&gt;master&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2940a9d939b4548e348a547825fc4662aaec04e" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;sentinel&lt;/code&gt;.</source>
          <target state="translated">文字列 &lt;code&gt;sentinel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d8519eae0e62aff504d921a1adc6159ed001fa3" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;slave&lt;/code&gt;, because of backward compatbility (see note at the end of this page).</source>
          <target state="translated">後方互換性のため、文字列 &lt;code&gt;slave&lt;/code&gt; です（このページの最後の注を参照）。</target>
        </trans-unit>
        <trans-unit id="6831b1a65326ef3cc261059e475703f978f1b6bb" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;slave&lt;/code&gt;, because of backward compatibility (see note at the end of this page).</source>
          <target state="translated">下位互換性のため、文字列 &lt;code&gt;slave&lt;/code&gt; （このページの最後にある注を参照）。</target>
        </trans-unit>
        <trans-unit id="a409de83f682db65c898664c9dbb138b1160b8f1" translate="yes" xml:space="preserve">
          <source>The summary provides a good overview, but sometimes we are interested in the details. In order to see all the pending messages with more associated information we need to also pass a range of IDs, in a similar way we do it with &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;, and a non optional &lt;em&gt;count&lt;/em&gt; argument, to limit the number of messages returned per call:</source>
          <target state="translated">要約は良い概要を提供しますが、時々私たちは詳細に興味があります。より多くの関連情報を含むすべての保留中のメッセージを表示するには、&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;で行うのと同様の方法で、IDの範囲を渡す必要があります。また、オプションではない&lt;em&gt;count&lt;/em&gt;引数を使用して、呼び出しごとに返されるメッセージの数を制限します。</target>
        </trans-unit>
        <trans-unit id="d2cc70797e244120c92cdce0be9d797bbb5993d5" translate="yes" xml:space="preserve">
          <source>The supported types are up to 64 bits for signed integers, and up to 63 bits for unsigned integers. This limitation with unsigned integers is due to the fact that currently the Redis protocol is unable to return 64 bit unsigned integers as replies.</source>
          <target state="translated">サポートされている型は、符号付き整数では最大64ビット、符号なし整数では最大63ビットです。符号なし整数でのこの制限は、現在 Redis プロトコルは 64 ビットの符号なし整数を返信として返すことができないという事実に起因しています。</target>
        </trans-unit>
        <trans-unit id="7a2d3466f691698508a75fad6644713be3c44a8f" translate="yes" xml:space="preserve">
          <source>The symmetric command used to alter the configuration at run time is &lt;code&gt;CONFIG
SET&lt;/code&gt;.</source>
          <target state="translated">実行時に構成を変更するために使用される対称コマンドは &lt;code&gt;CONFIG SET&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c4ef14ef5924effb0e2166473b48d643f3dd0b5a" translate="yes" xml:space="preserve">
          <source>The system administrator sends a &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; command to force a node to meet another one.</source>
          <target state="translated">システム管理者は&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;コマンドを送信して、ノードを強制的に別のノードに適合させます。</target>
        </trans-unit>
        <trans-unit id="f7dd65cc5a619424783dd395e5066f1952bf62a3" translate="yes" xml:space="preserve">
          <source>The third nested reply is guaranteed to be the IP/Port pair of the master instance for the slot range. All IP/Port pairs after the third nested reply are replicas of the master.</source>
          <target state="translated">3番目の入れ子になった返信は、スロット範囲のマスターインスタンスのIP/ポートペアであることが保証されています。3番目のネストした返信の後のIP/ポートペアはすべてマスターのレプリカです。</target>
        </trans-unit>
        <trans-unit id="bc7c54ea663acc1cd16d645f286e49bdb17828f2" translate="yes" xml:space="preserve">
          <source>The time-complexity for this operation is O(N), N being the number of keys in all existing databases.</source>
          <target state="translated">この操作の時間的複雑さはO(N)であり、Nはすべての既存のデータベースの鍵の数である。</target>
        </trans-unit>
        <trans-unit id="5dd2a246bdbf984a712d84e324dfcd54e3e83cfb" translate="yes" xml:space="preserve">
          <source>The time-complexity for this operation is O(N), N being the number of keys in the database.</source>
          <target state="translated">この操作の時間的複雑さはO(N)であり、Nはデータベースのキーの数である。</target>
        </trans-unit>
        <trans-unit id="33b9dc1580854319ae2c493dffcae592f1834dfc" translate="yes" xml:space="preserve">
          <source>The timeout can also be cleared, turning the key back into a persistent key, using the &lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt;コマンドを使用して、タイムアウトをクリアし、キーを永続キーに戻すこともできます。</target>
        </trans-unit>
        <trans-unit id="5a3cd5936158e61d7536637d6c3696dfb0161419" translate="yes" xml:space="preserve">
          <source>The timeout specifies the maximum idle time in any moment of the communication with the destination instance in milliseconds. This means that the operation does not need to be completed within the specified amount of milliseconds, but that the transfer should make progresses without blocking for more than the specified amount of milliseconds.</source>
          <target state="translated">タイムアウトは、転送先インスタンスとの通信のいずれかの瞬間の最大アイドル時間をミリ秒単位で指定する。これは、指定されたミリ秒数以内に操作を完了させる必要はなく、指定されたミリ秒数以上の間はブロックすることなく転送を進行させることを意味します。</target>
        </trans-unit>
        <trans-unit id="47a97f0f97c34f511b051b78756091a74729e20b" translate="yes" xml:space="preserve">
          <source>The timeout will only be cleared by commands that delete or overwrite the contents of the key, including &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;, &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;, &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; and all the &lt;code&gt;*STORE&lt;/code&gt; commands. This means that all the operations that conceptually &lt;em&gt;alter&lt;/em&gt; the value stored at the key without replacing it with a new one will leave the timeout untouched. For instance, incrementing the value of a key with &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;, pushing a new value into a list with &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, or altering the field value of a hash with &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; are all operations that will leave the timeout untouched.</source>
          <target state="translated">タイムアウトは、&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;、&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;、&lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt;およびすべての &lt;code&gt;*STORE&lt;/code&gt; コマンドを含む、キーの内容を削除または上書きするコマンドによってのみクリアされます。つまり、キーに格納されている値を新しい値に置き換えることなく概念的に&lt;em&gt;変更&lt;/em&gt;するすべての操作では、タイムアウトは変更されません。例えば、とキーの値がインクリメント&lt;a href=&quot;incr&quot;&gt;INCRを&lt;/a&gt;、とのリストに新しい値をプッシュ&lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;、またはとハッシュのフィールド値変更&lt;a href=&quot;hset&quot;&gt;HSETは&lt;/a&gt;手つかずのタイムアウトを残してすべての操作です。</target>
        </trans-unit>
        <trans-unit id="b4902022e2711d4049af153f6960e9c07559e3db" translate="yes" xml:space="preserve">
          <source>The unit must be one of the following, and defaults to meters:</source>
          <target state="translated">単位は次のいずれかでなければならず、デフォルトはメーターです。</target>
        </trans-unit>
        <trans-unit id="a995cbd615ab3e6d82df762d54a3d2493e68cc0e" translate="yes" xml:space="preserve">
          <source>The unix timestamp at which the logged command was processed.</source>
          <target state="translated">ログに記録されたコマンドが処理された unix タイムスタンプ。</target>
        </trans-unit>
        <trans-unit id="a0310f88660618094c01bca5ea0d0463bbd02002" translate="yes" xml:space="preserve">
          <source>The user just turned on AOF, and the server triggered the first AOF rewrite in order to create the initial AOF file. In this context, stopping will result in losing the dataset at all: once restarted, the server will potentially have AOF enabled without having any AOF file at all.</source>
          <target state="translated">このような状況では、ユーザがAOFを有効にしただけで、サーバが最初のAOFファイルを作成するために最初のAOF書き換えを行ったとします。この場合、停止するとデータセットが全く失われてしまいます。</target>
        </trans-unit>
        <trans-unit id="5f17b8b7fd14b72046eefe6ae0e142f682927503" translate="yes" xml:space="preserve">
          <source>The user should be aware that if the same existing key is mentioned in the arguments multiple times, it will be counted multiple times. So if &lt;code&gt;somekey&lt;/code&gt; exists, &lt;code&gt;EXISTS somekey somekey&lt;/code&gt; will return 2.</source>
          <target state="translated">ユーザーは、同じ既存のキーが引数で複数回言及されている場合、複数回カウントされることに注意する必要があります。したがって、 &lt;code&gt;somekey&lt;/code&gt; が存在する場合、 &lt;code&gt;EXISTS somekey somekey&lt;/code&gt; は2を返します。</target>
        </trans-unit>
        <trans-unit id="a2b1b03bb92333675d117bc7fc8c0c76fc472f63" translate="yes" xml:space="preserve">
          <source>The user should take in mind that single-key and multiple-keys executions of this command are semantically different and have different performances.</source>
          <target state="translated">ユーザーは、このコマンドのシングルキーとマルチキーの実行は意味的に異なり、異なる性能を持つことを念頭に置く必要があります。</target>
        </trans-unit>
        <trans-unit id="aee2053c45b6ced184922e49824bb87ce4f26e87" translate="yes" xml:space="preserve">
          <source>The vertical labels under each graph column represent the amount of seconds, minutes, hours or days ago the event happened. For example &quot;15s&quot; means that the first graphed event happened 15 seconds ago.</source>
          <target state="translated">各グラフの列の下にある垂直ラベルは、イベントが起こった秒、分、時間、または日前の量を表しています。例えば、&quot;15s &quot;は、最初にグラフ化されたイベントが15秒前に起こったことを意味します。</target>
        </trans-unit>
        <trans-unit id="2e0c79b31b353c9ce51c111498c89af1634cee6b" translate="yes" xml:space="preserve">
          <source>The way the sorted set is populated is using a technique called &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt;. Latitude and Longitude bits are interleaved in order to form an unique 52 bit integer. We know that a sorted set double score can represent a 52 bit integer without losing precision.</source>
          <target state="translated">ソートされたセットにデータが入力される方法は、&lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt;と呼ばれる手法を使用しています。固有の52ビット整数を形成するために、緯度と経度のビットがインターリーブされます。ソートされたセットのダブルスコアは、精度を失うことなく52ビットの整数を表すことができます。</target>
        </trans-unit>
        <trans-unit id="7b31bb2e561758eaef35a12c00599f8b3a9ccbe4" translate="yes" xml:space="preserve">
          <source>Then instead of starting the iteration again from &lt;code&gt;-&lt;/code&gt;, as the start of the range we use the entry ID of the &lt;em&gt;last&lt;/em&gt; entry returned by the previous &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; call as an exclusive interval.</source>
          <target state="translated">次に、 &lt;code&gt;-&lt;/code&gt; から反復を再開する代わりに、範囲の開始として、前の&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;呼び出しによって返された&lt;em&gt;最後の&lt;/em&gt;エントリのエントリIDを排他的な間隔として使用します。</target>
        </trans-unit>
        <trans-unit id="473281da4300480447326ee40d8d889bb9d90481" translate="yes" xml:space="preserve">
          <source>Then instead of starting the iteration again from &lt;code&gt;-&lt;/code&gt;, as the start of the range we use the entry ID of the &lt;em&gt;last&lt;/em&gt; entry returned by the previous &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; call, adding the sequence part of the ID by one.</source>
          <target state="translated">次に、 &lt;code&gt;-&lt;/code&gt; から再び反復を開始する代わりに、範囲の開始として、前の&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;呼び出しによって返された&lt;em&gt;最後の&lt;/em&gt;エントリのエントリIDを使用し、IDのシーケンス部分を1つ追加します。</target>
        </trans-unit>
        <trans-unit id="49d73108f34c912bc3dcd46d706878a2b1cfa83b" translate="yes" xml:space="preserve">
          <source>Then suddenly that consumer fails forever.</source>
          <target state="translated">そして突然、その消費者は永遠に失敗する。</target>
        </trans-unit>
        <trans-unit id="c54ead856d23cc39661d8102bdb6330ddb30ed3d" translate="yes" xml:space="preserve">
          <source>Then we may want to know what commands are part of a given category:</source>
          <target state="translated">次に、どのようなコマンドが与えられたカテゴリの一部であるかを知りたいと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="b66921f715545a310ecff4dca64b25267fdd5efb" translate="yes" xml:space="preserve">
          <source>There are also optional fields emitted only by Redis 4.0 or greater:</source>
          <target state="translated">また、Redis 4.0以上でのみ発行されるオプションのフィールドもあります。</target>
        </trans-unit>
        <trans-unit id="a381e0a250a57263ea1da7d6465921f290bc2868" translate="yes" xml:space="preserve">
          <source>There are cases when you need to set all the bits of single bitmap at once, for example when initializing it to a default non-zero value. It is possible to do this with multiple calls to the &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; command, one for each bit that needs to be set. However, so as an optimization you can use a single &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command to set the entire bitmap.</source>
          <target state="translated">たとえば、デフォルトのゼロ以外の値に初期化する場合など、単一のビットマップのすべてのビットを一度に設定する必要がある場合があります。これは、設定する必要のあるビットごとに1つずつ、&lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt;コマンドを複数回呼び出すことで実行できます。ただし、最適化として、単一の&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;コマンドを使用してビットマップ全体を設定できます。</target>
        </trans-unit>
        <trans-unit id="faf4557f2ee4da2fe1ae76ce2cecd829e57c75d9" translate="yes" xml:space="preserve">
          <source>There are conditions when we want just to terminate a Redis instance ASAP, regardless of what its content is. In such a case, the right combination of commands is to send a &lt;strong&gt;CONFIG appendonly no&lt;/strong&gt; followed by a &lt;strong&gt;SHUTDOWN NOSAVE&lt;/strong&gt;. The first command will turn off the AOF if needed, and will terminate the AOF rewriting child if there is one active. The second command will not have any problem to execute since the AOF is no longer enabled.</source>
          <target state="translated">内容に関係なく、Redisインスタンスをできるだけ早く終了したい場合があります。このような場合、コマンドの正しい組み合わせは、&lt;strong&gt;CONFIG appendonly noの&lt;/strong&gt;後に&lt;strong&gt;SHUTDOWN NOSAVE&lt;/strong&gt;を送信すること&lt;strong&gt;です&lt;/strong&gt;。最初のコマンドは、必要に応じてAOFをオフにし、アクティブなAOFがある場合はAOF書き換え子を終了します。AOFが有効になっていないため、2番目のコマンドを実行しても問題はありません。</target>
        </trans-unit>
        <trans-unit id="158a7d63bcc769d78e3493a2bc55c7a4ee6bce03" translate="yes" xml:space="preserve">
          <source>There are multiple clients rotating the list: they'll fetch different elements, until all the elements of the list are visited, and the process restarts.</source>
          <target state="translated">複数のクライアントがリストを回転させています:リストのすべての要素が訪問され、プロセスが再起動するまで、異なる要素を取得します。</target>
        </trans-unit>
        <trans-unit id="bdda3afdb8163e659ca9981491dbe7bcadb74afd" translate="yes" xml:space="preserve">
          <source>There are situations where this is not enough, and we want a replica to failover without any agreement with the rest of the cluster. A real world use case for this is to mass promote replicas in a different data center to masters in order to perform a data center switch, while all the masters are down or partitioned away.</source>
          <target state="translated">これだけでは十分ではなく、クラスタの残りの部分との合意なしにレプリカをフェイルオーバーさせたいという状況もあります。実際の使用例としては、すべてのマスターがダウンしている間にデータセンターの切り替えを行うために、別のデータセンターにあるレプリカをマスターに大量に宣伝することがあります。</target>
        </trans-unit>
        <trans-unit id="6bd7c5396466fc74307415d5fb57447e1fc4a356" translate="yes" xml:space="preserve">
          <source>There are times when a list can receive multiple elements in the context of the same conceptual command:</source>
          <target state="translated">リストが同じ概念コマンドの文脈で複数の要素を受け取ることができる場合があります。</target>
        </trans-unit>
        <trans-unit id="8e2a3e6a950f5d8a609385be1af06951e77dc2ea" translate="yes" xml:space="preserve">
          <source>There are two helper functions to return Redis types from Lua.</source>
          <target state="translated">LuaからRedisの型を返すヘルパー関数は2つあります。</target>
        </trans-unit>
        <trans-unit id="be8d4180a42a37a500975b93ef1e55ade0e6286d" translate="yes" xml:space="preserve">
          <source>There are two ways in order to specify offsets in the bitfield command. If a number without any prefix is specified, it is used just as a zero based bit offset inside the string.</source>
          <target state="translated">ビットフィールドコマンドでオフセットを指定するには、2つの方法があります。接頭辞のない数値が指定された場合は、文字列内のゼロベースのビットオフセットとして使用されます。</target>
        </trans-unit>
        <trans-unit id="d75f55602fddc93ba9011e7393a6bc36a64ba5a7" translate="yes" xml:space="preserve">
          <source>There is &lt;a href=&quot;http://www.lua.org/pil/19.1.html&quot;&gt;no simple way to have nils inside Lua arrays&lt;/a&gt;, this is a result of Lua table semantics, so when Redis converts a Lua array into Redis protocol the conversion is stopped if a nil is encountered.</source>
          <target state="translated">&lt;a href=&quot;http://www.lua.org/pil/19.1.html&quot;&gt;Lua配列内にnilを設定する簡単な方法&lt;/a&gt;はありません。これはLuaテーブルセマンティクスの結果であるため、RedisがLua配列をRedisプロトコルに変換するときに、nilが検出されると変換が停止します。</target>
        </trans-unit>
        <trans-unit id="1181df382608fdc99dac69533a65959f383591cd" translate="yes" xml:space="preserve">
          <source>There is a different way to fix this issue without using scripting, but using Redis lists instead of counters. The implementation is more complex and uses more advanced features but has the advantage of remembering the IP addresses of the clients currently performing an API call, that may be useful or not depending on the application.</source>
          <target state="translated">スクリプトを使用せずにこの問題を修正する別の方法がありますが、カウンタの代わりにRedisのリストを使用します。この実装はより複雑で、より高度な機能を使用しますが、現在APIコールを実行しているクライアントのIPアドレスを記憶するという利点があります。</target>
        </trans-unit>
        <trans-unit id="2318fb4edc6b835e7f3009f7b1cfc0bceadc13e5" translate="yes" xml:space="preserve">
          <source>There is a stream with an associated consumer group.</source>
          <target state="translated">関連する消費者グループを持つストリームがあります。</target>
        </trans-unit>
        <trans-unit id="f5813da89c7be6046d913f1f5df04a5cf2e30994" translate="yes" xml:space="preserve">
          <source>There is an additional Lua-to-Redis conversion rule that has no corresponding Redis to Lua conversion rule:</source>
          <target state="translated">追加のLua-to-Redis変換ルールがありますが、対応するRedis-to-Lua変換ルールはありません。</target>
        </trans-unit>
        <trans-unit id="3c2e8ff8c03c52243caafd83d9c21a0190459a1a" translate="yes" xml:space="preserve">
          <source>There is another subcommand that only changes the behavior of successive &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; subcommand calls by setting the overflow behavior:</source>
          <target state="translated">オーバーフロー動作を設定することにより、連続する&lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt;サブコマンド呼び出しの動作のみを変更する別のサブコマンドがあります。</target>
        </trans-unit>
        <trans-unit id="ad004d677ac8d1220049f68515cbe366e16611b0" translate="yes" xml:space="preserve">
          <source>There is no difference between using the helper functions or directly returning the table with the specified format, so the following two forms are equivalent:</source>
          <target state="translated">ヘルパー関数を使うか、指定した形式の表を直接返すかの違いはありませんので、以下の2つの形式が等価です。</target>
        </trans-unit>
        <trans-unit id="688604faa0496cccdc56e5c3415b7e254e6c2086" translate="yes" xml:space="preserve">
          <source>There is no guarantee that it is actually the higher configuration epoch, since, for example, we can use the &lt;strong&gt;TAKEOVER&lt;/strong&gt; option within a minority, nor any message exchange is performed to generate the new configuration epoch.</source>
          <target state="translated">たとえば、少数のユーザー内で&lt;strong&gt;TAKEOVER&lt;/strong&gt;オプションを使用したり、メッセージ交換を実行して新しい構成エポックを生成したりできるため、実際にそれがより高い構成エポックであるという保証はありません。</target>
        </trans-unit>
        <trans-unit id="f9d2324c27d0bdf5977e444923fed05e29f7f2d5" translate="yes" xml:space="preserve">
          <source>There is no limit to the length of the name that can be assigned if not the usual limits of the Redis string type (512 MB). However it is not possible to use spaces in the connection name as this would violate the format of the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; reply.</source>
          <target state="translated">Redis文字列タイプの通常の制限（512 MB）でない場合に割り当てることができる名前の長さに制限はありません。ただし、接続名にスペースを使用することはできません。これは、&lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt;応答のフォーマットに違反するためです。</target>
        </trans-unit>
        <trans-unit id="939fac74be0ef5905e18fc0965563dbdb047a83f" translate="yes" xml:space="preserve">
          <source>There is one key thing to understand: in case Lua replies with RESP3 types, but the connection calling Lua is in RESP2 mode, Redis will automatically convert the RESP3 protocol to RESP2 compatible protocol, as it happens for normal commands. For instance returning a map type to a connection in RESP2 mode will have the effect of returning a flat array of fields and values.</source>
          <target state="translated">それは、LuaがRESP3型で返信しているが、Luaを呼び出している接続がRESP2モードである場合、通常のコマンドと同様に、Redisは自動的にRESP3プロトコルをRESP2互換プロトコルに変換します。例えば、RESP2モードの接続に対してマップ型を返すと、フィールドと値のフラット配列を返すことになります。</target>
        </trans-unit>
        <trans-unit id="a5147f1530dd4898c039cd6ac5ba9eae79430a62" translate="yes" xml:space="preserve">
          <source>These are the counters that are reset:</source>
          <target state="translated">これらはリセットされるカウンタです。</target>
        </trans-unit>
        <trans-unit id="3f9525d03220e878ebb457481ab1b1546ad897b4" translate="yes" xml:space="preserve">
          <source>These bytes are pure overhead at the moment as no actual data is stored, and are used for maintaining the internal data structures of the server. Longer keys and values show asymptotically linear usage.</source>
          <target state="translated">これらのバイトは、実際のデータが保存されていないため、現時点では純粋なオーバーヘッドであり、サーバの内部データ構造を維持するために使用されます。より長いキーと値は、漸近的に直線的に使用されます。</target>
        </trans-unit>
        <trans-unit id="0c0d7819e41ea841eca9c54ef01aab00acdd805e" translate="yes" xml:space="preserve">
          <source>These offsets can also be negative numbers indicating offsets starting at the end of the list. For example, &lt;code&gt;-1&lt;/code&gt; is the last element of the list, &lt;code&gt;-2&lt;/code&gt; the penultimate, and so on.</source>
          <target state="translated">これらのオフセットは、リストの最後から始まるオフセットを示す負の数にすることもできます。たとえば、 &lt;code&gt;-1&lt;/code&gt; はリストの最後の要素、 &lt;code&gt;-2&lt;/code&gt; は最後から2番目の要素です。</target>
        </trans-unit>
        <trans-unit id="3327f4f330ea4245b93a5884cfe66d7c642a01a1" translate="yes" xml:space="preserve">
          <source>These prerequisites are needed since usually, manually altering the configuration epoch of a node is unsafe, we want to be sure that the node with the higher configuration epoch value (that is the last that failed over) wins over other nodes in claiming the hash slots ownership.</source>
          <target state="translated">通常、ノードのコンフィグレーションエポックを手動で変更することは安全ではないので、これらの前提条件が必要です。</target>
        </trans-unit>
        <trans-unit id="74cdd9a11d855a7fe9706564ff82f50aed545b21" translate="yes" xml:space="preserve">
          <source>They can be shortened removing characters from the right. It will lose precision but will still point to the same area.</source>
          <target state="translated">右から文字を削除して短くすることができます。精度は失われますが、同じ領域を指すことに変わりはありません。</target>
        </trans-unit>
        <trans-unit id="de21a5f9f7664481a629fd440bf41584926e640e" translate="yes" xml:space="preserve">
          <source>They correspond directly to the normal Redis log levels. Only logs emitted by scripting using a log level that is equal or greater than the currently configured Redis instance log level will be emitted.</source>
          <target state="translated">これらは通常の Redis ログレベルに直接対応しています。現在設定されている Redis インスタンスのログレベルと同じかそれ以上のログレベルを使用してスクリプトを実行した場合にのみ、ログが出力されます。</target>
        </trans-unit>
        <trans-unit id="1163c9f8d8e2d599dd815fa54afcf7fcd4819d93" translate="yes" xml:space="preserve">
          <source>Things like using the system time, calling Redis random commands like &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;, or using Lua random number generator, could result into scripts that will not always evaluate in the same way.</source>
          <target state="translated">システム時間の使用、&lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;などのRedisランダムコマンドの呼び出し、Lua乱数ジェネレーターの使用などの結果は、常に同じ方法で評価されるわけではないスクリプトになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="3a6c24e6bcae98d8b374c6b8a2cb2e847242de7f" translate="yes" xml:space="preserve">
          <source>Think at a Lua script where we perform an intersection between two sets. Pick five random elements, and create a new set with this five random elements. Finally we delete the temporary key representing the intersection between the two original sets. What we want to replicate is only the creation of the new set with the five elements. It's not useful to also replicate the commands creating the temporary key.</source>
          <target state="translated">2つの集合間の交差を行うLuaスクリプトで考えてみましょう。ランダムな要素を5つ選び、この5つのランダムな要素で新しい集合を作成します。最後に、2つの元の集合間の交点を表す一時的なキーを削除します。複製したいのは、5つの要素で新しい集合を作成することだけです。一時キーを作成するコマンドも複製しても意味がありません。</target>
        </trans-unit>
        <trans-unit id="d05a95556307e74d8c3d500f8eaf5b432fd6a284" translate="yes" xml:space="preserve">
          <source>This avoids that a client will try to release the lock after the expire time deleting the key created by another client that acquired the lock later.</source>
          <target state="translated">これにより、クライアントが期限切れ後にロックを解除しようとすると、後からロックを取得した別のクライアントが作成したキーが削除されてしまうことを防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="e05975c8ace39fb16ed1689fdd42d78b56751af2" translate="yes" xml:space="preserve">
          <source>This can be a problem with some application where we want a more reliable messaging system. When this is the case, please check the &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; command, that is a variant of &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; that adds the returned element to a target list before returning it to the client.</source>
          <target state="translated">これは、より信頼性の高いメッセージングシステムが必要な一部のアプリケーションで問題になる可能性があります。この場合は、&lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;コマンドを確認してください。これは、クライアントに返す前に、返された要素をターゲットリストに追加する&lt;a href=&quot;blpop&quot;&gt;BLPOPの&lt;/a&gt;バリアントです。</target>
        </trans-unit>
        <trans-unit id="7d43703d663f6362b0a28ec9100f4db91d08a310" translate="yes" xml:space="preserve">
          <source>This can be fixed easily turning the &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; with optional &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; into a Lua script that is send using the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command (only available since Redis version 2.6).</source>
          <target state="translated">これは簡単に修正でき、オプションの&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;を含む&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;を、&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;コマンドを使用して送信されるLuaスクリプトに変換できます（Redisバージョン2.6以降でのみ使用可能）。</target>
        </trans-unit>
        <trans-unit id="72b1b07f3e247301ca1521cd5c3a4e2df6db2967" translate="yes" xml:space="preserve">
          <source>This command accepts one or more SHA1 digests and returns a list of ones or zeros to signal if the scripts are already defined or not inside the script cache. This can be useful before a pipelining operation to ensure that scripts are loaded (and if not, to load them using &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt;) so that the pipelining operation can be performed solely using &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; instead of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; to save bandwidth.</source>
          <target state="translated">このコマンドは、1つ以上のSHA1ダイジェストを受け入れ、1または0のリストを返し、スクリプトが既にスクリプトキャッシュ内に定義されているかどうかを通知します。これは、パイプライン処理の前にスクリプトを確実にロードし（そうでない場合は、&lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt;を使用してロードするため）、パイプライン処理を&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;ではなく&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;のみを使用して実行して帯域幅を節約できるようにするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="dcfeceb3df3a9d1203f8df4602183697ddf7897a" translate="yes" xml:space="preserve">
          <source>This command accepts two non mandatory options:</source>
          <target state="translated">このコマンドでは、2つの必須ではないオプションを指定することができます。</target>
        </trans-unit>
        <trans-unit id="43467785cd12ce45437b2b4eecb4c3b0671ef615" translate="yes" xml:space="preserve">
          <source>This command blocks the current client until all the previous write commands are successfully transferred and acknowledged by at least the specified number of replicas. If the timeout, specified in milliseconds, is reached, the command returns even if the specified number of replicas were not yet reached.</source>
          <target state="translated">このコマンドは、前のすべての書き込みコマンドが正常に転送され、少なくとも指定された数のレプリカによって確認されるまで、現在のクライアントをブロックします。ミリ秒単位で指定されたタイムアウトに達した場合、指定された数のレプリカがまだ到達していなくてもコマンドは戻ります。</target>
        </trans-unit>
        <trans-unit id="7a62033f131f44c3fe86c2c4ab2196a020d7e337" translate="yes" xml:space="preserve">
          <source>This command can be called with multiple streams if we want to read at the same time from a number of keys. This is a key feature of &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; because especially when blocking with &lt;strong&gt;BLOCK&lt;/strong&gt;, to be able to listen with a single connection to multiple keys is a vital feature.</source>
          <target state="translated">このコマンドは、複数のキーから同時に読み取りたい場合、複数のストリームで呼び出すことができます。これは&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;の重要な機能です。特に&lt;strong&gt;BLOCK&lt;/strong&gt;でブロックする場合、複数のキーへの単一の接続でリッスンできることが重要な機能であるためです。</target>
        </trans-unit>
        <trans-unit id="ea63b36c2daa60b6b416fb9f70368e117feeda86" translate="yes" xml:space="preserve">
          <source>This command can unblock, from a different connection, a client blocked in a blocking operation, such as for instance &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; or &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; or &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;.</source>
          <target state="translated">このコマンドは、別の接続から、&lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt;、&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;、&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;などのブロック操作でブロックされたクライアントのブロックを解除できます。</target>
        </trans-unit>
        <trans-unit id="7d6f9176a21b0c3f64b6d59331a54d4112960a8c" translate="yes" xml:space="preserve">
          <source>This command comes in place of the now deprecated &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;. Doing &lt;code&gt;BLMOVE RIGHT LEFT&lt;/code&gt; is equivalent.</source>
          <target state="translated">このコマンドは、現在非推奨となっている&lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSHの&lt;/a&gt;代わりに使用されます。 &lt;code&gt;BLMOVE RIGHT LEFT&lt;/code&gt; ことは同等です。</target>
        </trans-unit>
        <trans-unit id="ae4b7969f891e0631e6b36c849a8182bdc4a8ebc" translate="yes" xml:space="preserve">
          <source>This command comes in place of the now deprecated &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;. Doing &lt;code&gt;LMOVE RIGHT LEFT&lt;/code&gt; is equivalent.</source>
          <target state="translated">このコマンドは、現在非推奨となっている&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSHの&lt;/a&gt;代わりに使用されます。 &lt;code&gt;LMOVE RIGHT LEFT&lt;/code&gt; ことは同等です。</target>
        </trans-unit>
        <trans-unit id="7f02c76dc59dbdc13fe5dd0f4a1731c43a14ddd0" translate="yes" xml:space="preserve">
          <source>This command controls the tracking of the keys in the next command executed by the connection, when tracking is enabled in &lt;code&gt;OPTIN&lt;/code&gt; or &lt;code&gt;OPTOUT&lt;/code&gt; mode. Please check the &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;client side caching documentation&lt;/a&gt; for background information.</source>
          <target state="translated">このコマンドは、 &lt;code&gt;OPTIN&lt;/code&gt; または &lt;code&gt;OPTOUT&lt;/code&gt; モードで追跡が有効になっている場合に、接続によって実行される次のコマンドでのキーの追跡を制御します。背景情報については、&lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;クライアント側のキャッシュドキュメント&lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="e2f8b881a98ea2d40bfed754bab550d934301142" translate="yes" xml:space="preserve">
          <source>This command copies the value stored at the &lt;code&gt;source&lt;/code&gt; key to the &lt;code&gt;destination&lt;/code&gt; key.</source>
          <target state="translated">このコマンドは、 &lt;code&gt;source&lt;/code&gt; キーに保存されている値を &lt;code&gt;destination&lt;/code&gt; キーにコピーします。</target>
        </trans-unit>
        <trans-unit id="cff095ce217da2e3523c4effed757c97e397dac6" translate="yes" xml:space="preserve">
          <source>This command enables the tracking feature of the Redis server, that is used for &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;server assisted client side caching&lt;/a&gt;.</source>
          <target state="translated">このコマンドは、&lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;サーバー支援のクライアント側キャッシュに&lt;/a&gt;使用されるRedisサーバーの追跡機能を有効にします。</target>
        </trans-unit>
        <trans-unit id="66b31d1c2eb93e0473a8a5492fa02a9c8c2c2d69" translate="yes" xml:space="preserve">
          <source>This command is currently implemented only when using &lt;strong&gt;jemalloc&lt;/strong&gt; as an allocator, and evaluates to a benign NOOP for all others.</source>
          <target state="translated">このコマンドは現在、アロケータとして&lt;strong&gt;jemalloc&lt;/strong&gt;を使用する場合にのみ実装され、他のすべての場合は無害なNOOPと評価されます。</target>
        </trans-unit>
        <trans-unit id="932344d8190e35db9df40d94e5197fd7c1d13364" translate="yes" xml:space="preserve">
          <source>This command is equal to &lt;a href=&quot;sdiff&quot;&gt;SDIFF&lt;/a&gt;, but instead of returning the resulting set, it is stored in &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">このコマンドは&lt;a href=&quot;sdiff&quot;&gt;SDIFF&lt;/a&gt;と同じですが、結果セットを返す代わりに、 &lt;code&gt;destination&lt;/code&gt; に保存されます。</target>
        </trans-unit>
        <trans-unit id="507f9a2dec2a09af16c3fc0fe75de6b0370a3364" translate="yes" xml:space="preserve">
          <source>This command is equal to &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt;, but instead of returning the resulting set, it is stored in &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">このコマンドは&lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt;と同じですが、結果セットを返す代わりに、 &lt;code&gt;destination&lt;/code&gt; に格納されます。</target>
        </trans-unit>
        <trans-unit id="86af64e6b7731ea035f82e2694ba78f231528031" translate="yes" xml:space="preserve">
          <source>This command is equal to &lt;a href=&quot;sunion&quot;&gt;SUNION&lt;/a&gt;, but instead of returning the resulting set, it is stored in &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">このコマンドは&lt;a href=&quot;sunion&quot;&gt;SUNION&lt;/a&gt;と同じですが、結果セットを返す代わりに、 &lt;code&gt;destination&lt;/code&gt; に格納されます。</target>
        </trans-unit>
        <trans-unit id="5e32e7ca3fa8b824bc6b60a666e52d947d9640ed" translate="yes" xml:space="preserve">
          <source>This command is especially useful together with &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; which was introduced also in Redis 5 together with &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt;. Check the &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; command page for a pattern involving the two commands.</source>
          <target state="translated">このコマンドは、&lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt;とともにRedis 5でも導入された&lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt;と一緒に使用すると特に便利です。2つのコマンドが関係するパターンについては、&lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt;コマンドページを確認してください。</target>
        </trans-unit>
        <trans-unit id="86526f15e70874597af78fb5a748e15addec9fd4" translate="yes" xml:space="preserve">
          <source>This command is exactly like &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; with the sole difference that instead of taking, as the center of the area to query, a longitude and latitude value, it takes the name of a member already existing inside the geospatial index represented by the sorted set.</source>
          <target state="translated">このコマンドは&lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt;とまったく同じですが、唯一の違いは、クエリを実行するエリアの中心として経度と緯度の値をとるのではなく、並べ替えられたセットによって表される地理空間インデックス内に既に存在するメンバーの名前をとることです。</target>
        </trans-unit>
        <trans-unit id="20782308b0ebe308769b63e3df355d6efd05d3a3" translate="yes" xml:space="preserve">
          <source>This command is exactly like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;, but with the notable difference of returning the entries in reverse order, and also taking the start-end range in reverse order: in &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; you need to state the &lt;em&gt;end&lt;/em&gt; ID and later the &lt;em&gt;start&lt;/em&gt; ID, and the command will produce all the element between (or exactly like) the two IDs, starting from the &lt;em&gt;end&lt;/em&gt; side.</source>
          <target state="translated">このコマンドは&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;とまったく同じですが、エントリを逆の順序で返し、開始と終了の範囲を逆の順序で&lt;a href=&quot;xrevrange&quot;&gt;取るという大きな違い&lt;/a&gt;があります。XREVRANGEでは、&lt;em&gt;終了&lt;/em&gt; IDと後で&lt;em&gt;開始&lt;/em&gt; ID を指定する必要があり、コマンドは、2つのIDの間（またはまったく同じ）のすべての要素を、&lt;em&gt;端&lt;/em&gt;側から作成します。</target>
        </trans-unit>
        <trans-unit id="076bd15f23123ea6b78baa94e15f792d2be93592" translate="yes" xml:space="preserve">
          <source>This command is like &lt;a href=&quot;geosearch&quot;&gt;GEOSEARCH&lt;/a&gt;, but stores the result in destination key.</source>
          <target state="translated">このコマンドは&lt;a href=&quot;geosearch&quot;&gt;GEOSEARCH&lt;/a&gt;に似ていますが、結果を宛先キーに保存します。</target>
        </trans-unit>
        <trans-unit id="f0909cd0cbb5b65dceb56a6821a06b32b029f0ae" translate="yes" xml:space="preserve">
          <source>This command is mainly used in the event a &lt;code&gt;nodes.conf&lt;/code&gt; node state file gets lost / deleted for some reason, and we want to generate it again from scratch. It can also be useful in case of mundane alterations of a node cluster configuration via the &lt;code&gt;CLUSTER&lt;/code&gt; command in order to ensure the new configuration is persisted on disk, however all the commands should normally be able to auto schedule to persist the configuration on disk when it is important to do so for the correctness of the system in the event of a restart.</source>
          <target state="translated">このコマンドは主に、何らかの理由で、 &lt;code&gt;nodes.conf&lt;/code&gt; ノード状態ファイルが失われたり削除されたりした場合に使用されます。新しい構成がディスクに永続化されるようにするために、 &lt;code&gt;CLUSTER&lt;/code&gt; コマンドを介してノードクラスター構成を日常的に変更する場合にも役立ちますが、通常、すべてのコマンドが自動スケジュールを設定して、構成をディスクに永続化する必要があります。再起動時のシステムの正確さのためにそうすることが重要です。</target>
        </trans-unit>
        <trans-unit id="b0d65e64e68abf2d5af87daf134cb637fc1df1f2" translate="yes" xml:space="preserve">
          <source>This command is mainly useful for debugging, when the failure detector of Redis Cluster is not operating as we believe it should.</source>
          <target state="translated">このコマンドは主に、Redis Clusterの障害検出器が我々が考えるように動作していない場合のデバッグに便利です。</target>
        </trans-unit>
        <trans-unit id="30fc3be6e9d8c6b14224168e93a2ce61a33ebf6a" translate="yes" xml:space="preserve">
          <source>This command is mainly useful to kill a script that is running for too much time(for instance because it entered an infinite loop because of a bug). The script will be killed and the client currently blocked into EVAL will see the command returning with an error.</source>
          <target state="translated">このコマンドは主に、(バグのために無限ループに入ってしまったなど)長時間実行されているスクリプトを終了させるのに便利です。スクリプトが kill され、現在 EVAL にブロックされているクライアントは、コマンドがエラーで返ってくるのを見ることができます。</target>
        </trans-unit>
        <trans-unit id="37c2b15b0fd4a88889c5862b221daca96c7ea555" translate="yes" xml:space="preserve">
          <source>This command is mainly useful to re-provision a Redis Cluster node in order to be used in the context of a new, different cluster. The command is also extensively used by the Redis Cluster testing framework in order to reset the state of the cluster every time a new test unit is executed.</source>
          <target state="translated">このコマンドは主に、新しい異なるクラスタのコンテキストで使用するためにRedisクラスタノードを再プロビジョニングするのに便利です。このコマンドは、新しいテストユニットが実行されるたびにクラスタの状態をリセットするために、Redis Cluster テストフレームワークでも広く使われています。</target>
        </trans-unit>
        <trans-unit id="fed8489efd023df6aa3b9c8828a92cf9cbe79777" translate="yes" xml:space="preserve">
          <source>This command is similar to &lt;a href=&quot;zdiffstore&quot;&gt;ZDIFFSTORE&lt;/a&gt;, but instead of storing the resulting sorted set, it is returned to the client.</source>
          <target state="translated">このコマンドは&lt;a href=&quot;zdiffstore&quot;&gt;ZDIFFSTORE&lt;/a&gt;に似ていますが、結果のソートされたセットを保管する代わりに、クライアントに返されます。</target>
        </trans-unit>
        <trans-unit id="39b570683c8482e1a6ba032781b807f8695533eb" translate="yes" xml:space="preserve">
          <source>This command is similar to &lt;a href=&quot;zinterstore&quot;&gt;ZINTERSTORE&lt;/a&gt;, but instead of storing the resulting sorted set, it is returned to the client.</source>
          <target state="translated">このコマンドは&lt;a href=&quot;zinterstore&quot;&gt;ZINTERSTORE&lt;/a&gt;に似ていますが、結果のソートされたセットを格納する代わりに、クライアントに返されます。</target>
        </trans-unit>
        <trans-unit id="d880d1fb82050509f79c50bd6fb5ec73f51cf212" translate="yes" xml:space="preserve">
          <source>This command is similar to &lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt;, but instead of storing the resulting sorted set, it is returned to the client.</source>
          <target state="translated">このコマンドは&lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt;に似ていますが、結果のソートされたセットを格納する代わりに、クライアントに返されます。</target>
        </trans-unit>
        <trans-unit id="9de9c0357b2f6bf5f5b30bfd602eff2f9c1cbcf1" translate="yes" xml:space="preserve">
          <source>This command is the most powerful analysis tool in the latency monitoring framework, and is able to provide additional statistical data like the average period between latency spikes, the median deviation, and a human-readable analysis of the event. For certain events, like &lt;code&gt;fork&lt;/code&gt;, additional information is provided, like the rate at which the system forks processes.</source>
          <target state="translated">このコマンドは、遅延監視フレームワークで最も強力な分析ツールであり、遅延スパイク間の平均期間、中央値偏差、イベントの人間が読める形式の分析などの追加の統計データを提供できます。 &lt;code&gt;fork&lt;/code&gt; などの特定のイベントについては、システムフォークが処理する速度などの追加情報が提供されます。</target>
        </trans-unit>
        <trans-unit id="6b9cd1ceade82d616f55d37288e27be4ecc550c1" translate="yes" xml:space="preserve">
          <source>This command is the only way to force Redis to flush the scripts cache. It is most useful in a cloud environment where the same instance can be reassigned to a different user. It is also useful for testing client libraries' implementations of the scripting feature.</source>
          <target state="translated">このコマンドはRedisにスクリプトキャッシュを強制的にフラッシュさせる唯一の方法です。これは、同じインスタンスを別のユーザに再割り当てすることができるクラウド環境で最も有用です。また、クライアントライブラリのスクリプト機能の実装をテストするのにも便利です。</target>
        </trans-unit>
        <trans-unit id="8562c28aa29c0aee65ed6fb4a3d690ee24e35388" translate="yes" xml:space="preserve">
          <source>This command is the only way to interrupt a long-running script that reaches the configured maximum execution time for scripts. The SCRIPT KILL command can only be used with scripts that did not modify the dataset during their execution (since stopping a read-only script does not violate the scripting engine's guaranteed atomicity). See the next sections for more information about long running scripts.</source>
          <target state="translated">このコマンドは、設定されたスクリプトの最大実行時間に達した長時間実行中のスクリプトを中断する唯一の方法である。SCRIPT KILLコマンドは、実行中にデータセットを変更しなかったスクリプトでのみ使用できます(読み取り専用のスクリプトを停止しても、スクリプトエンジンの保証されたアトミック性に違反しないため)。長時間実行中のスクリプトの詳細については、次のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="74540a3a51962d64e542e90991498fda99b11c4b" translate="yes" xml:space="preserve">
          <source>This command is used in order to manage the consumer groups associated with a stream data structure. Using &lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt; you can:</source>
          <target state="translated">このコマンドは、ストリームデータ構造に関連付けられたコンシューマグループを管理するために使用されます。&lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt;を使用すると、次のことができます。</target>
        </trans-unit>
        <trans-unit id="0f3f38de2ae9dc1853425848b341ace4420d82e4" translate="yes" xml:space="preserve">
          <source>This command is used in order to read and reset the Redis slow queries log.</source>
          <target state="translated">このコマンドは、Redisの遅いクエリログを読み込んでリセットするために使用されます。</target>
        </trans-unit>
        <trans-unit id="4469a3906600e48388ff32654f41a170c058ed11" translate="yes" xml:space="preserve">
          <source>This command is useful as it makes able to switch clients from a Redis instance to another one in a controlled way. For example during an instance upgrade the system administrator could do the following:</source>
          <target state="translated">このコマンドは、制御された方法でクライアントを Redis インスタンスから別のインスタンスに切り替えることができるので便利です。例えば、インスタンスのアップグレード中に、システム管理者は以下のようにすることができます。</target>
        </trans-unit>
        <trans-unit id="7716c05ccc0dd7cac30547152d82c808312925c0" translate="yes" xml:space="preserve">
          <source>This command is useful especially when we are monitoring many keys with a limited number of connections. For instance we may want to monitor multiple streams with &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; without using more than N connections. However at some point the consumer process is informed that there is one more stream key to monitor. In order to avoid using more connections, the best behavior would be to stop the blocking command from one of the connections in the pool, add the new key, and issue the blocking command again.</source>
          <target state="translated">このコマンドは、限られた数の接続で多くのキーを監視している場合に特に役立ちます。たとえば、Nを超える接続を使用せずに、&lt;a href=&quot;xread&quot;&gt;XREADで&lt;/a&gt;複数のストリームを監視したい場合があります。ただし、ある時点で、監視するストリームキーがもう1つあることがコンシューマプロセスに通知されます。より多くの接続を使用しないようにするための最善の動作は、プール内のいずれかの接続からのブロッキングコマンドを停止し、新しいキーを追加して、ブロッキングコマンドを再度発行することです。</target>
        </trans-unit>
        <trans-unit id="59ff8c186eb229a2dac30dbd70e43e24baabed7c" translate="yes" xml:space="preserve">
          <source>This command is useful in order to modify a node's view of the cluster configuration. Specifically it assigns a set of hash slots to the node receiving the command. If the command is successful, the node will map the specified hash slots to itself, and will start broadcasting the new configuration.</source>
          <target state="translated">このコマンドは、クラスタ構成のノードの表示を変更するのに便利です。具体的には、コマンドを受け取ったノードにハッシュスロットのセットを割り当てます。コマンドが成功した場合、ノードは指定されたハッシュスロットを自分自身にマッピングし、新しい設定のブロードキャストを開始します。</target>
        </trans-unit>
        <trans-unit id="afcb99c36c15189824ecdc3091bf486391211187" translate="yes" xml:space="preserve">
          <source>This command is very similar to &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;: it removes the specified keys. Just like &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; a key is ignored if it does not exist. However the command performs the actual memory reclaiming in a different thread, so it is not blocking, while &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; is. This is where the command name comes from: the command just &lt;strong&gt;unlinks&lt;/strong&gt; the keys from the keyspace. The actual removal will happen later asynchronously.</source>
          <target state="translated">このコマンドは&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;によく似ています。指定したキーを削除します。&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;と同様に、キーが存在しない場合は無視されます。ただし、コマンドは実際のメモリ再利用を別のスレッドで実行するため、&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;がブロックしている間はブロックされません。これがコマンド名の由来です。コマンドはキースペースからキーを&lt;strong&gt;リンク解除&lt;/strong&gt;するだけです。実際の削除は後で非同期に行われます。</target>
        </trans-unit>
        <trans-unit id="8d70f66fb80485b6d531d7d9ab8ad149118bee56" translate="yes" xml:space="preserve">
          <source>This command loads and initializes the Redis module from the dynamic library specified by the &lt;code&gt;path&lt;/code&gt; argument. The &lt;code&gt;path&lt;/code&gt; should be the absolute path of the library, including the full filename. Any additional arguments are passed unmodified to the module.</source>
          <target state="translated">このコマンドは、 &lt;code&gt;path&lt;/code&gt; 引数で指定されたダイナミックライブラリからRedisモジュールをロードして初期化します。 &lt;code&gt;path&lt;/code&gt; 完全なファイル名を含むライブラリーの絶対パスでなければなりません。追加の引数は変更されずにモジュールに渡されます。</target>
        </trans-unit>
        <trans-unit id="6e7d9161cbb27663ecc1a90a3f6bb05f23dbad84" translate="yes" xml:space="preserve">
          <source>This command only works in cluster mode and is useful in the following Redis Cluster operations:</source>
          <target state="translated">このコマンドはクラスタモードでのみ動作し、以下のRedisクラスタ操作で有用です。</target>
        </trans-unit>
        <trans-unit id="ae45a8ae2f8e5aecd7b6912a681c88c74a505274" translate="yes" xml:space="preserve">
          <source>This command only works in cluster mode and may be useful for debugging and in order to manually orchestrate a cluster configuration when a new cluster is created. It is currently not used by &lt;code&gt;redis-trib&lt;/code&gt;, and mainly exists for API completeness.</source>
          <target state="translated">このコマンドはクラスターモードでのみ機能し、デバッグや、新しいクラスターが作成されたときにクラスター構成を手動で調整するのに役立ちます。現在 &lt;code&gt;redis-trib&lt;/code&gt; では使用されておらず、主にAPIの完全性のために存在しています。</target>
        </trans-unit>
        <trans-unit id="b0562f793b35f58a57b7250775581e06cabbe124" translate="yes" xml:space="preserve">
          <source>This command performs a full reset of the connection's server-side context, mimicking the effect of disconnecting and reconnecting again.</source>
          <target state="translated">このコマンドは、接続のサーバー側コンテキストを完全にリセットし、切断して再接続する効果を真似て実行します。</target>
        </trans-unit>
        <trans-unit id="a5304131d86dfa25555f9abe5b57dd4ad31bed60" translate="yes" xml:space="preserve">
          <source>This command registers the specified script in the Redis script cache. The command is useful in all the contexts where we want to make sure that &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; will not fail (for instance during a pipeline or MULTI/EXEC operation), without the need to actually execute the script.</source>
          <target state="translated">このコマンドは、指定されたスクリプトをRedisスクリプトキャッシュに登録します。このコマンドは、実際にスクリプトを実行する必要なしに、&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;が失敗しないことを確認する必要があるすべてのコンテキスト（パイプラインやMULTI / EXEC操作中など）で役立ちます。</target>
        </trans-unit>
        <trans-unit id="09806309aef17ea4d51d659e1cc3d714503d0680" translate="yes" xml:space="preserve">
          <source>This command returns the client ID we are redirecting our &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;tracking&lt;/a&gt; notifications to. We set a client to redirect to when using &lt;a href=&quot;client-tracking&quot;&gt;CLIENT TRACKING&lt;/a&gt; to enable tracking. However in order to avoid forcing client libraries implementations to remember the ID notifications are redirected to, this command exists in order to improve introspection and allow clients to check later if redirection is active and towards which client ID.</source>
          <target state="translated">このコマンドは、&lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;追跡&lt;/a&gt;通知のリダイレクト先のクライアントIDを返します。&lt;a href=&quot;client-tracking&quot;&gt;CLIENTTRACKING&lt;/a&gt;を使用して追跡を有効にするときにリダイレクトするクライアントを設定します。ただし、クライアントライブラリの実装にID通知がリダイレクトされることを記憶させることを回避するために、このコマンドはイントロスペクションを改善し、クライアントがリダイレクトがアクティブであるかどうか、およびどのクライアントIDに向かっているかを後で確認できるようにするために存在します。</target>
        </trans-unit>
        <trans-unit id="ef7e7424bc09f286d32a4b812efe8253277e59f5" translate="yes" xml:space="preserve">
          <source>This command returns the number of failure reports for the current node which are currently not expired (so received within two times the &lt;em&gt;node timeout&lt;/em&gt; time). The count does not include what the node we are asking this count believes about the node ID we pass as argument, the count &lt;em&gt;only&lt;/em&gt; includes the failure reports the node received from other nodes.</source>
          <target state="translated">このコマンドは、現在有効期限が切れていない（&lt;em&gt;ノードのタイムアウト&lt;/em&gt;時間の2倍以内に受信された）現在のノードの障害レポートの数を返します。カウントには、このカウントが引数として渡すノードIDについてどのノードが信じているかは含まれません。カウントには、ノードが他のノードから受信した障害レポート&lt;em&gt;のみが&lt;/em&gt;含まれます。</target>
        </trans-unit>
        <trans-unit id="541223fddf4b501cc96317842ccc50859641cd10" translate="yes" xml:space="preserve">
          <source>This command sets a specific &lt;em&gt;config epoch&lt;/em&gt; in a fresh node. It only works when:</source>
          <target state="translated">このコマンドは、新しいノードに特定の構成&lt;em&gt;エポック&lt;/em&gt;を&lt;em&gt;設定し&lt;/em&gt;ます。次の場合にのみ機能します。</target>
        </trans-unit>
        <trans-unit id="18e23f892090be38939eafd00c77e503dab8c192" translate="yes" xml:space="preserve">
          <source>This command swaps two Redis databases, so that immediately all the clients connected to a given database will see the data of the other database, and the other way around. Example:</source>
          <target state="translated">このコマンドは2つのRedisデータベースを入れ替えることで、指定されたデータベースに接続しているすべてのクライアントがすぐにもう一方のデータベースのデータを見ることができ、逆にもう一方のデータベースのデータを見ることができます。例を示します。</target>
        </trans-unit>
        <trans-unit id="75c1ca96e42909a085011b83f917c82db8bdd8f7" translate="yes" xml:space="preserve">
          <source>This command unloads the module specified by &lt;code&gt;name&lt;/code&gt;. Note that the module's name is reported by the &lt;a href=&quot;module-list&quot;&gt;MODULE LIST&lt;/a&gt; command, and may differ from the dynamic library's filename.</source>
          <target state="translated">このコマンドは、 &lt;code&gt;name&lt;/code&gt; で指定されたモジュールをアンロードします。モジュールの名前は&lt;a href=&quot;module-list&quot;&gt;MODULELIST&lt;/a&gt;コマンドによって報告され、ダイナミックライブラリのファイル名とは異なる場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6adc7a43ee507fff544bbc6adc515bc47ac97ad4" translate="yes" xml:space="preserve">
          <source>This command was introduced in the middle of a Redis stable release, specifically with Redis 2.8.12.</source>
          <target state="translated">このコマンドは、Redisの安定版リリースの途中で導入されたもので、特にRedis 2.8.12で導入されました。</target>
        </trans-unit>
        <trans-unit id="838bb242e39a256bd97fcf68121a5b0ba9ba6cad" translate="yes" xml:space="preserve">
          <source>This command works exactly like &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; but the time to live of the key is specified in milliseconds instead of seconds.</source>
          <target state="translated">このコマンドは&lt;a href=&quot;expire&quot;&gt;EXPIREと&lt;/a&gt;まったく同じように機能しますが、キーの有効期間は秒ではなくミリ秒で指定されます。</target>
        </trans-unit>
        <trans-unit id="7341623725ef962c36ad811614642ab5632c4c2c" translate="yes" xml:space="preserve">
          <source>This command, that can only be sent to a Redis Cluster replica node, forces the replica to start a manual failover of its master instance.</source>
          <target state="translated">Redis Clusterレプリカノードにのみ送信できるこのコマンドは、レプリカにマスターインスタンスの手動フェイルオーバーを強制的に開始させます。</target>
        </trans-unit>
        <trans-unit id="4da304a4683087def0d8d26eb2c481c6af27db0a" translate="yes" xml:space="preserve">
          <source>This conversion between data types is designed in a way that if a Redis type is converted into a Lua type, and then the result is converted back into a Redis type, the result is the same as the initial value.</source>
          <target state="translated">このデータ型間の変換は、Redis型をLua型に変換した後、結果をRedis型に戻しても初期値と同じ結果になるように設計されています。</target>
        </trans-unit>
        <trans-unit id="e18d68145955b4559f3ba803d90954ff94c0dac8" translate="yes" xml:space="preserve">
          <source>This dynamic is clearly explained in the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Stream intro documentation&lt;/a&gt;.</source>
          <target state="translated">このダイナミクスは、&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;ストリームのイントロのドキュメント&lt;/a&gt;で明確に説明されています。</target>
        </trans-unit>
        <trans-unit id="19d5d3191e2445ef69de01881bb5939b9f401be6" translate="yes" xml:space="preserve">
          <source>This example shows the application in the context of Redis streams, however the pattern is a general one and can be applied to other cases.</source>
          <target state="translated">この例では、Redis ストリームのコンテキストでのアプリケーションを示していますが、パターンは一般的なものであり、他のケースにも適用できます。</target>
        </trans-unit>
        <trans-unit id="7b81b5550c835cb846e3da1e36e1dc058efa8bc9" translate="yes" xml:space="preserve">
          <source>This form just authenticates against the password set with &lt;code&gt;requirepass&lt;/code&gt;. In this configuration Redis will deny any command executed by the just connected clients, unless the connection gets authenticated via &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt;.</source>
          <target state="translated">このフォームは、 &lt;code&gt;requirepass&lt;/code&gt; で設定されたパスワードに対して認証するだけです。この構成では、接続が&lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt;を介して認証されない限り、Redisは接続されたばかりのクライアントによって実行されたコマンドをすべて拒否します。</target>
        </trans-unit>
        <trans-unit id="c30a4ad86f29101d3c1fcdfab12485ff0ca6c027" translate="yes" xml:space="preserve">
          <source>This format allows for radius querying by checking the 1+8 areas needed to cover the whole radius, and discarding elements outside the radius. The areas are checked by calculating the range of the box covered removing enough bits from the less significant part of the sorted set score, and computing the score range to query in the sorted set for each area.</source>
          <target state="translated">この形式では、半径全体をカバーするために必要な1+8の領域をチェックし、半径外の要素を破棄することで、半径の問い合わせを行うことができます。領域のチェックは、ソートされたセットのスコアの重要度の低い部分から十分なビットを削除し、各領域についてソートされたセットの中で照会するスコアの範囲を計算することで行われます。</target>
        </trans-unit>
        <trans-unit id="5f7d96d3049d4f76efb356668757ef71fbc55342" translate="yes" xml:space="preserve">
          <source>This has the same effect as running &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt; with one argument &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">これは、1つの引数 &lt;code&gt;key&lt;/code&gt; &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt;を実行するのと同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="5d0bfed0b5c7c513675b9c26b7ab5ed0c6f3d603" translate="yes" xml:space="preserve">
          <source>This is a good overview, but sometimes we are interested in the details. In order to see all the pending messages with more associated information we need to also pass a range of IDs, in a similar way we do it with &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;, and a non optional &lt;em&gt;count&lt;/em&gt; argument, to limit the number of messages returned per call:</source>
          <target state="translated">これは良い概要ですが、時々詳細に興味があります。より多くの関連情報を含む保留中のすべてのメッセージを表示するには、&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;およびオプションの&lt;em&gt;count&lt;/em&gt;引数を使用して同じようにIDの範囲を渡す必要があります。これにより、呼び出しごとに返されるメッセージの数を制限できます。</target>
        </trans-unit>
        <trans-unit id="90aa8094613e02ff36a67a68b984d933a74e701a" translate="yes" xml:space="preserve">
          <source>This is a list of all the supported Redis ACL rules:</source>
          <target state="translated">これは、サポートされているすべてのRedis ACLルールのリストです。</target>
        </trans-unit>
        <trans-unit id="61b4d531c8516c33061d94d3a8959add03c42f29" translate="yes" xml:space="preserve">
          <source>This is a trivial probabilistic algorithm, basically the assumption is that our sample is representative of the whole key space, and we continue to expire until the percentage of keys that are likely to be expired is under 25%</source>
          <target state="translated">これは些細な確率論的アルゴリズムで、基本的にはサンプルが鍵空間全体の代表的なものであると仮定し、失効する可能性の高い鍵の割合が25%以下になるまで失効を続けます。</target>
        </trans-unit>
        <trans-unit id="c48adb8e8d877ae182110cc1e68d2e6bc1d83311" translate="yes" xml:space="preserve">
          <source>This is an example of blocking invocation, where the command later returns a null reply because the timeout has elapsed without new data arriving:</source>
          <target state="translated">これは呼び出しをブロックする例で、新しいデータが到着しないままタイムアウトが経過したために、コマンドが後になってヌル応答を返すというものです。</target>
        </trans-unit>
        <trans-unit id="622bd341d8dc701d53c24284f457bffb1eb9df29" translate="yes" xml:space="preserve">
          <source>This is an example of iteration using &lt;strong&gt;MATCH&lt;/strong&gt;:</source>
          <target state="translated">これは&lt;strong&gt;MATCH&lt;/strong&gt;を使用した反復の例です。</target>
        </trans-unit>
        <trans-unit id="4d789554ece00f72c77acd57e4f313f31c717e24" translate="yes" xml:space="preserve">
          <source>This is an introspection command used in order to retrieve different information about the streams and associated consumer groups. Three forms are possible:</source>
          <target state="translated">これは、ストリームと関連する消費者グループに関するさまざまな情報を取得するために使用されるイントロスペクションコマンドです。3つの形態が考えられます。</target>
        </trans-unit>
        <trans-unit id="fa13476351797926204e99a9b54034d28b5780cc" translate="yes" xml:space="preserve">
          <source>This is easy to see intuitively: if the collection grows there is more and more work to do in order to visit all the possible elements, and the ability to terminate the iteration depends on the number of calls to &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; and its COUNT option value compared with the rate at which the collection grows.</source>
          <target state="translated">これは直感的に簡単に確認できます。コレクションが大きくなると、すべての可能な要素にアクセスするために行う作業がますます多くなり、反復を終了できるかどうかは、&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;の呼び出し数とそのCOUNTオプション値によって異なります。コレクションが成長する速度。</target>
        </trans-unit>
        <trans-unit id="5ecf6a9694906630d3be8ffa19f791d25178c710" translate="yes" xml:space="preserve">
          <source>This is how a typical &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; call looks like in the first iteration of a consumer willing to consume only new entries:</source>
          <target state="translated">これは、新しいエントリのみを消費するコンシューマーの最初の反復での典型的な&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;呼び出しの様子です。</target>
        </trans-unit>
        <trans-unit id="720fb76cbe63b3ee37bb596512afa1691c9ba3f2" translate="yes" xml:space="preserve">
          <source>This is how to understand if you want to use a consumer group or not:</source>
          <target state="translated">消費者団体を利用するかしないかは、このようにして把握しておきましょう。</target>
        </trans-unit>
        <trans-unit id="2d94df873adfd43289accd82b71abdee4a8063f4" translate="yes" xml:space="preserve">
          <source>This is how we use this command in order to mount such an algorithm:</source>
          <target state="translated">このようなアルゴリズムをマウントするために、このコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="c0d3b602529b7dea150254bfa283c67fb2eed932" translate="yes" xml:space="preserve">
          <source>This is the output you should post in the Redis mailing list if you are looking for help about Latency related issues.</source>
          <target state="translated">これは、レイテンシ関連の問題についてのヘルプを探している場合に、Redis メーリングリストに投稿すべき出力です。</target>
        </trans-unit>
        <trans-unit id="b9658590fc318422333085d731b93a7035c7459f" translate="yes" xml:space="preserve">
          <source>This is useful in several ways depending on the use case:</source>
          <target state="translated">これはユースケースに応じていくつかの方法があるので便利です。</target>
        </trans-unit>
        <trans-unit id="bcf3a4afdd1a41afed7a49db731a6c6ebfa0cc2a" translate="yes" xml:space="preserve">
          <source>This is useful to an application that wants to fetch raw data in order to perform monitoring, display graphs, and so forth.</source>
          <target state="translated">モニタリングやグラフ表示などを行うために生データを取得したいアプリケーションに便利です。</target>
        </trans-unit>
        <trans-unit id="7a58d44535039d5a20b0fa97b3b1ee43b1b6dd46" translate="yes" xml:space="preserve">
          <source>This is usually needed only when the instance is going to be instantiated for another customer or application in a cloud environment.</source>
          <target state="translated">これは通常、クラウド環境で別の顧客やアプリケーションのためにインスタンスを作成する場合にのみ必要となります。</target>
        </trans-unit>
        <trans-unit id="bbfa8fbc11f623748d63d11e9bf5ee03c12ff234" translate="yes" xml:space="preserve">
          <source>This manual page also covers the &lt;code&gt;GEORADIUS_RO&lt;/code&gt; and &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; variants (see the section below for more information).</source>
          <target state="translated">このマニュアルページは、 &lt;code&gt;GEORADIUS_RO&lt;/code&gt; および &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; バリアントについても説明しています（詳細については、以下のセクションを参照してください）。</target>
        </trans-unit>
        <trans-unit id="d223d35db64e1d19fc9f2926f21b42e4ab2344a9" translate="yes" xml:space="preserve">
          <source>This means that at any given moment the maximum amount of keys already expired that are using memory is at max equal to max amount of write operations per second divided by 4.</source>
          <target state="translated">これは、メモリを使用している鍵のうち、既に期限切れとなっている鍵の最大量が、1秒あたりの書き込み操作の最大量を4で割った値が最大となることを意味する。</target>
        </trans-unit>
        <trans-unit id="aabcd9a95a39d430c629afa9fad1b539c022ac85" translate="yes" xml:space="preserve">
          <source>This means that if you have two non-empty buckets in the entire hash table, and one has three elements while one has just one, the element that is alone in its bucket will be returned with much higher probability.</source>
          <target state="translated">これは、ハッシュテーブル全体の中に空でないバケットが2つあり、1つが1つだけなのに3つの要素を持っている場合、そのバケットに単独で入っている要素がはるかに高い確率で返されることを意味しています。</target>
        </trans-unit>
        <trans-unit id="249f94aa848de22f03290fa35dfb93a51fdb5d7d" translate="yes" xml:space="preserve">
          <source>This means that this command should be used with care only by applications orchestrating Redis Cluster, like &lt;code&gt;redis-trib&lt;/code&gt;, and the command if used out of the right context can leave the cluster in a wrong state or cause data loss.</source>
          <target state="translated">つまり、このコマンドは、 &lt;code&gt;redis-trib&lt;/code&gt; などのRedisクラスターを調整するアプリケーションでのみ注意して使用する必要があります。このコマンドを適切なコンテキスト外で使用すると、クラスターが誤った状態になるか、データが失われる可能性があります。</target>
        </trans-unit>
        <trans-unit id="b4b18f04b9acb83f71f24c60b244188e2d234cce" translate="yes" xml:space="preserve">
          <source>This means that you set:</source>
          <target state="translated">セットしたということです。</target>
        </trans-unit>
        <trans-unit id="8a0b4cfa314b524daabda36aba34d428f894ef1e" translate="yes" xml:space="preserve">
          <source>This operation is similar to &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;, that returns one or more random elements from a set but does not remove it.</source>
          <target state="translated">この操作は&lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;に似ており、セットから1つ以上のランダム要素を返しますが、削除はしません。</target>
        </trans-unit>
        <trans-unit id="b82ae6d609ba5f4bff538ca99ae907087f8e8c97" translate="yes" xml:space="preserve">
          <source>This pair of commands will push a new element on the list, while making sure that the list will not grow larger than 100 elements. This is very useful when using Redis to store logs for example. It is important to note that when used in this way &lt;a href=&quot;ltrim&quot;&gt;LTRIM&lt;/a&gt; is an O(1) operation because in the average case just one element is removed from the tail of the list.</source>
          <target state="translated">このコマンドのペアは、リストが新しい要素をプッシュする一方で、リストが100要素を超えないようにします。これは、Redisを使用してログを保存する場合などに非常に役立ちます。このように使用すると、&lt;a href=&quot;ltrim&quot;&gt;LTRIM&lt;/a&gt;はO（1）演算になることに注意することが重要です。これは、平均の場合、リストの末尾から1つの要素しか削除されないためです。</target>
        </trans-unit>
        <trans-unit id="80b9715de053267e5fffa59b0b1112d991e9ba3f" translate="yes" xml:space="preserve">
          <source>This pattern is easily modified to use counters using &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; instead of lists using &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;.</source>
          <target state="translated">このパターンは、&lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;を使用するリストの代わりに&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;を使用するカウンターを使用するように簡単に変更できます。</target>
        </trans-unit>
        <trans-unit id="d386987d572848d3712f1ff810e5567134c02087" translate="yes" xml:space="preserve">
          <source>This simple pattern can be extended in many ways:</source>
          <target state="translated">このシンプルなパターンは、様々な方法で拡張することができます。</target>
        </trans-unit>
        <trans-unit id="92785c4b9f557c4d2558a4fa95a80f3ac27c63a5" translate="yes" xml:space="preserve">
          <source>This subcommand is the reverse of &lt;code&gt;MIGRATING&lt;/code&gt;, and prepares the destination node to import keys from the specified source node. The command only works if the node is not already owner of the specified hash slot.</source>
          <target state="translated">このサブコマンドは &lt;code&gt;MIGRATING&lt;/code&gt; の逆であり、指定されたソースノードからキーをインポートするために宛先ノードを準備します。このコマンドは、ノードが指定されたハッシュスロットの所有者でない場合にのみ機能します。</target>
        </trans-unit>
        <trans-unit id="3af1b4ceac0630f2f07d73ce38551a82afebcee6" translate="yes" xml:space="preserve">
          <source>This subcommand just clears migrating / importing state from the slot. It is mainly used to fix a cluster stuck in a wrong state by &lt;code&gt;redis-trib fix&lt;/code&gt;. Normally the two states are cleared automatically at the end of the migration using the &lt;code&gt;SETSLOT ... NODE ...&lt;/code&gt; subcommand as explained in the next section.</source>
          <target state="translated">このサブコマンドは、移行/インポート状態をスロットからクリアするだけです。主に &lt;code&gt;redis-trib fix&lt;/code&gt; によって誤った状態でスタックしたクラスターを修正するために使用されます。通常、2つの状態は、次のセクションで説明するように、 &lt;code&gt;SETSLOT ... NODE ...&lt;/code&gt; サブコマンドを使用して、移行の終了時に自動的にクリアされます。</target>
        </trans-unit>
        <trans-unit id="9fe3e638e8830d97f18b8e18e7bb1f71a19b5a85" translate="yes" xml:space="preserve">
          <source>This subcommand sets a slot to &lt;em&gt;migrating&lt;/em&gt; state. In order to set a slot in this state, the node receiving the command must be the hash slot owner, otherwise an error is returned.</source>
          <target state="translated">このサブコマンドは、スロットを&lt;em&gt;移行&lt;/em&gt;状態に設定&lt;em&gt;し&lt;/em&gt;ます。スロットをこの状態に設定するには、コマンドを受信するノードがハッシュスロットの所有者でなければなりません。そうでない場合、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="edb8d5f6aeacab24056a48e5cdeee519f5cf870a" translate="yes" xml:space="preserve">
          <source>This way clients are moved away from the old master to the new master atomically and only when the replica that is turning into the new master has processed all of the replication stream from the old master.</source>
          <target state="translated">この方法では、クライアントは古いマスターから新しいマスターへとアトミックに移動し、新しいマスターになるレプリカが古いマスターからのレプリケーションストリームをすべて処理した場合にのみ、新しいマスターへと移動します。</target>
        </trans-unit>
        <trans-unit id="eabc7eeeb462a96b3b77723425f464bf9ccbef27" translate="yes" xml:space="preserve">
          <source>This way we have a 60 second window to inform all the nodes in the cluster that we want to remove a node.</source>
          <target state="translated">この方法では、クラスタ内のすべてのノードにノードを削除したい旨を通知するための60秒のウィンドウがあります。</target>
        </trans-unit>
        <trans-unit id="e40460902c1181221678071c434b045c404620fa" translate="yes" xml:space="preserve">
          <source>This will swap database 0 with database 1. All the clients connected with database 0 will immediately see the new data, exactly like all the clients connected with database 1 will see the data that was formerly of database 0.</source>
          <target state="translated">これはデータベース0をデータベース1と入れ替えます。データベース0に接続されているすべてのクライアントは、データベース1に接続されているすべてのクライアントがデータベース0の以前のデータを見るのと同じように、すぐに新しいデータを見ることになります。</target>
        </trans-unit>
        <trans-unit id="d5bfb565b7330daf67d56a70b8a026b02f7b8efa" translate="yes" xml:space="preserve">
          <source>Tip: setting names to connections is a good way to debug connection leaks due to bugs in the application using Redis.</source>
          <target state="translated">ヒント:接続に名前を設定することは、Redisを使用したアプリケーションのバグによる接続漏れをデバッグするのに良い方法です。</target>
        </trans-unit>
        <trans-unit id="ff53653923ebddab009510a619b44980ec4c2bad" translate="yes" xml:space="preserve">
          <source>To call the command without elements but just the variable name is valid, this will result into no operation performed if the variable already exists, or just the creation of the data structure if the key does not exist (in the latter case 1 is returned).</source>
          <target state="translated">要素を持たずに変数名だけを指定してコマンドを呼び出すと、変数が既に存在する場合には操作が行われず、キーが存在しない場合にはデータ構造体が作成されるだけになります(後者の場合は1が返されます)。</target>
        </trans-unit>
        <trans-unit id="480b89cfe665e37f5248f03df59af64d3763158a" translate="yes" xml:space="preserve">
          <source>To continue iterating the two streams I'll call:</source>
          <target state="translated">2つのストリームの反復処理を続けるために、私は呼び出します。</target>
        </trans-unit>
        <trans-unit id="0314c05fdc90b76eea71abe37038408de3a97e39" translate="yes" xml:space="preserve">
          <source>To create a new cluster ADDSLOTS is used in order to initially setup master nodes splitting the available hash slots among them.</source>
          <target state="translated">新しいクラスタを作成するには、最初にマスターノードをセットアップし、利用可能なハッシュスロットをそれらの間で分割するためにADDSLOTSを使用します。</target>
        </trans-unit>
        <trans-unit id="44bff97be54184d5c7829a3927adcbbc623cd71d" translate="yes" xml:space="preserve">
          <source>To create a new consumer group, use the following form:</source>
          <target state="translated">新しい消費者グループを作成するには、以下のフォームを使用します。</target>
        </trans-unit>
        <trans-unit id="89c4cf93004db2e7ed530c2bd4661a6d909ed66e" translate="yes" xml:space="preserve">
          <source>To do so the web application may simply increment a key every time the user performs a page view, creating the key name concatenating the User ID and a string representing the current date.</source>
          <target state="translated">これを行うために、ウェブアプリケーションは、ユーザがページビューを実行するたびにキーをインクリメントし、ユーザIDと現在の日付を表す文字列を連結したキー名を作成することができます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
